; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\Lost Saga For Developer\Youtube\Tutorial\Source\src\LSClient\ccddaabb.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_7ccddaabb@@6B@				; ccddaabb::`vftable'
PUBLIC	??0ccddaabb@@QAE@XZ				; ccddaabb::ccddaabb
PUBLIC	??_R4ccddaabb@@6B@				; ccddaabb::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVccddaabb@@@8				; ccddaabb `RTTI Type Descriptor'
PUBLIC	??_R3ccddaabb@@8				; ccddaabb::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ccddaabb@@8				; ccddaabb::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ccddaabb@@8			; ccddaabb::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Eccddaabb@@UAEPAXI@Z:PROC			; ccddaabb::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@ccddaabb@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ccddaabb.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@ccddaabb@@8 DD FLAT:??_R0?AVccddaabb@@@8	; ccddaabb::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ccddaabb@@8
rdata$r	ENDS
;	COMDAT ??_R2ccddaabb@@8
rdata$r	SEGMENT
??_R2ccddaabb@@8 DD FLAT:??_R1A@?0A@EA@ccddaabb@@8	; ccddaabb::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ccddaabb@@8
rdata$r	SEGMENT
??_R3ccddaabb@@8 DD 00H					; ccddaabb::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ccddaabb@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVccddaabb@@@8
_DATA	SEGMENT
??_R0?AVccddaabb@@@8 DD FLAT:??_7type_info@@6B@		; ccddaabb `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVccddaabb@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ccddaabb@@6B@
rdata$r	SEGMENT
??_R4ccddaabb@@6B@ DD 00H				; ccddaabb::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVccddaabb@@@8
	DD	FLAT:??_R3ccddaabb@@8
rdata$r	ENDS
;	COMDAT ??_7ccddaabb@@6B@
CONST	SEGMENT
??_7ccddaabb@@6B@ DD FLAT:??_R4ccddaabb@@6B@		; ccddaabb::`vftable'
	DD	FLAT:??_Eccddaabb@@UAEPAXI@Z
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??0ccddaabb@@QAE@XZ
_TEXT	SEGMENT
??0ccddaabb@@QAE@XZ PROC				; ccddaabb::ccddaabb, COMDAT
; _this$ = ecx

; 5    : {

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ccddaabb@@6B@

; 6    : }

  00008	c3		 ret	 0
??0ccddaabb@@QAE@XZ ENDP				; ccddaabb::ccddaabb
_TEXT	ENDS
PUBLIC	??1ccddaabb@@UAE@XZ				; ccddaabb::~ccddaabb
; Function compile flags: /Ogsp
;	COMDAT ??1ccddaabb@@UAE@XZ
_TEXT	SEGMENT
??1ccddaabb@@UAE@XZ PROC				; ccddaabb::~ccddaabb, COMDAT
; _this$ = ecx

; 9    : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ccddaabb@@6B@

; 10   : }

  00006	c3		 ret	 0
??1ccddaabb@@UAE@XZ ENDP				; ccddaabb::~ccddaabb
_TEXT	ENDS
PUBLIC	?Setup@ccddaabb@@QAEXPBDHH@Z			; ccddaabb::Setup
; Function compile flags: /Ogsp
;	COMDAT ?Setup@ccddaabb@@QAEXPBDHH@Z
_TEXT	SEGMENT
_szKey$ = 8						; size = 4
_iMagicP$ = 12						; size = 4
_iMagicQ$ = 16						; size = 4
?Setup@ccddaabb@@QAEXPBDHH@Z PROC			; ccddaabb::Setup, COMDAT
; _this$ = ecx

; 13   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 14   : 	m_iMagicP = iMagicP;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _iMagicP$[ebp]

; 15   : 	m_iMagicQ = iMagicQ;

  00006	8b 55 10	 mov	 edx, DWORD PTR _iMagicQ$[ebp]
  00009	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 16   : 
; 17   : 	//UJ 130913, 속도향상을 위해 m_iTable[0]만 사용 --start
; 18   : 	//unsigned int i, j, k, u=WORD_SIZE/8, A, B, L[KEY_CEIL]; 
; 19   : 	///* Initialize L, then S, then mix key into S */
; 20   : 	//for(i=KEY_SIZE-1,L[KEY_CEIL-1]=0; i!=-1; i--) 
; 21   : 	//{
; 22   : 	//	L[i/u] = (L[i/u]<<8)+szKey[i];
; 23   : 	//}
; 24   : 	//for (m_iTable[0]=m_iMagicP,i=1; i<TABLE_SIZE; i++) 
; 25   : 	//{
; 26   : 	//	m_iTable[i] = m_iTable[i-1]+m_iMagicQ;
; 27   : 	//}
; 28   : 	//for (A=B=i=j=k=0; k<3*TABLE_SIZE; k++,i=(i+1)%TABLE_SIZE,j=(j+1)%KEY_CEIL)   /* 3*t > 3*c */
; 29   : 	//{ 
; 30   : 	//	A = m_iTable[i] = ROTL_fast(m_iTable[i]+(A+B),3);  
; 31   : 	//	B = L[j] = ROTL(L[j]+(A+B),(A+B)); 
; 32   : 	//}
; 33   : 	m_iTable[0] = ROTL_fast(m_iMagicP, 3);

  0000c	c1 c0 03	 rol	 eax, 3
  0000f	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  00012	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 34   : 	//UJ --end
; 35   : }

  00015	5d		 pop	 ebp
  00016	c2 0c 00	 ret	 12			; 0000000cH
?Setup@ccddaabb@@QAEXPBDHH@Z ENDP			; ccddaabb::Setup
_TEXT	ENDS
PUBLIC	?Encrypt@ccddaabb@@IAEXPBIPAI@Z			; ccddaabb::Encrypt
; Function compile flags: /Ogsp
;	COMDAT ?Encrypt@ccddaabb@@IAEXPBIPAI@Z
_TEXT	SEGMENT
_pt$ = 8						; size = 4
_ct$ = 12						; size = 4
?Encrypt@ccddaabb@@IAEXPBIPAI@Z PROC			; ccddaabb::Encrypt, COMDAT
; _this$ = ecx

; 38   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 39   : 	//UJ 130829, 속도향상을 위해 4bytes 단위로 수행하게 변경 --start
; 40   : 	//unsigned int i, A=pt[0]+m_iTable[0], B=pt[1]+m_iTable[1];
; 41   : 	//for (i=1; i<=ROUND_NUM; i++) 
; 42   : 	//{
; 43   : 	//	A = ROTL(A^B,B)+m_iTable[2*i]; 
; 44   : 	//	B = ROTL(B^A,A)+m_iTable[2*i+1]; 
; 45   : 	//}
; 46   : 	//ct[0] = A; ct[1] = B;
; 47   : 	unsigned int A=pt[0]+m_iTable[0];

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _pt$[ebp]
  00009	03 01		 add	 eax, DWORD PTR [ecx]

; 48   : 	A = ROTL_fast(A^0x11223355,7);
; 49   : 	ct[0] = A;

  0000b	8b c8		 mov	 ecx, eax
  0000d	35 00 00 00 10	 xor	 eax, 268435456		; 10000000H
  00012	81 f1 55 33 22
	ff		 xor	 ecx, -14535851		; ff223355H
  00018	c1 e8 19	 shr	 eax, 25			; 00000019H
  0001b	c1 e1 07	 shl	 ecx, 7
  0001e	0b c8		 or	 ecx, eax
  00020	8b 45 0c	 mov	 eax, DWORD PTR _ct$[ebp]
  00023	89 08		 mov	 DWORD PTR [eax], ecx

; 50   : 	//UJ --end
; 51   : }

  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
?Encrypt@ccddaabb@@IAEXPBIPAI@Z ENDP			; ccddaabb::Encrypt
_TEXT	ENDS
PUBLIC	?Decrypt@ccddaabb@@IBEXPBIPAI@Z			; ccddaabb::Decrypt
; Function compile flags: /Ogsp
;	COMDAT ?Decrypt@ccddaabb@@IBEXPBIPAI@Z
_TEXT	SEGMENT
_ct$ = 8						; size = 4
_pt$ = 12						; size = 4
?Decrypt@ccddaabb@@IBEXPBIPAI@Z PROC			; ccddaabb::Decrypt, COMDAT
; _this$ = ecx

; 54   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 55   : 	//UJ 130829, 속도향상을 위해 4bytes 단위로 수행하게 변경 --start
; 56   : 	//unsigned int i, B=ct[1], A=ct[0];
; 57   : 	//for (i=ROUND_NUM; i>0; i--) 
; 58   : 	//{ 
; 59   : 	//	B = ROTR(B-m_iTable[2*i+1],A)^A; 
; 60   : 	//	A = ROTR(A-m_iTable[2*i],B)^B; 
; 61   : 	//}
; 62   : 	//pt[1] = B-m_iTable[1]; pt[0] = A-m_iTable[0];
; 63   : 	unsigned int A=ct[0];
; 64   : 	A = ROTR_fast(A,7)^0x11223355; 

  00003	8b 45 08	 mov	 eax, DWORD PTR _ct$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	c1 c8 07	 ror	 eax, 7
  0000b	35 55 33 22 11	 xor	 eax, 287454037		; 11223355H

; 65   : 	pt[0] = A-m_iTable[0];

  00010	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _pt$[ebp]
  00016	89 01		 mov	 DWORD PTR [ecx], eax

; 66   : 	//UJ --end
; 67   : }

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
?Decrypt@ccddaabb@@IBEXPBIPAI@Z ENDP			; ccddaabb::Decrypt
_TEXT	ENDS
PUBLIC	?EncryptByte@ccddaabb@@QAEXPBDPADH@Z		; ccddaabb::EncryptByte
; Function compile flags: /Ogsp
;	COMDAT ?EncryptByte@ccddaabb@@QAEXPBDPADH@Z
_TEXT	SEGMENT
_szPlain$ = 8						; size = 4
_szCipher$ = 12						; size = 4
_iSize$ = 16						; size = 4
?EncryptByte@ccddaabb@@QAEXPBDPADH@Z PROC		; ccddaabb::EncryptByte, COMDAT
; _this$ = ecx

; 70   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 71   : 	//UJ 130829, 속도향상을 위해 4bytes 단위로 수행하게 변경
; 72   : 	//if( (iSize%8) != 0 )
; 73   : 	if( (iSize%4) != 0 )

  00003	8b 45 10	 mov	 eax, DWORD PTR _iSize$[ebp]
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx
  00009	8b c8		 mov	 ecx, eax
  0000b	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00011	79 05		 jns	 SHORT $LN9@EncryptByt
  00013	49		 dec	 ecx
  00014	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00017	41		 inc	 ecx
$LN9@EncryptByt:
  00018	75 29		 jne	 SHORT $LN1@EncryptByt

; 74   : 		return;
; 75   : 
; 76   : 	//for (int i = 0; i < iSize ; i+=8)
; 77   : 	for (int i = 0; i < iSize ; i+=4)

  0001a	85 c0		 test	 eax, eax
  0001c	7e 25		 jle	 SHORT $LN1@EncryptByt
  0001e	56		 push	 esi
  0001f	8b 75 0c	 mov	 esi, DWORD PTR _szCipher$[ebp]
  00022	57		 push	 edi
  00023	8b 7d 08	 mov	 edi, DWORD PTR _szPlain$[ebp]
  00026	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
  00029	c1 ea 02	 shr	 edx, 2
  0002c	2b f7		 sub	 esi, edi
  0002e	42		 inc	 edx
$LL3@EncryptByt:
  0002f	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]

; 78   : 	{
; 79   : 		Encrypt( (const unsigned int*)&szPlain[i], (unsigned int*)&szCipher[i] );

  00032	50		 push	 eax
  00033	57		 push	 edi
  00034	8b cb		 mov	 ecx, ebx
  00036	e8 00 00 00 00	 call	 ?Encrypt@ccddaabb@@IAEXPBIPAI@Z ; ccddaabb::Encrypt
  0003b	83 c7 04	 add	 edi, 4
  0003e	4a		 dec	 edx
  0003f	75 ee		 jne	 SHORT $LL3@EncryptByt
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
$LN1@EncryptByt:
  00043	5b		 pop	 ebx

; 80   : 	}
; 81   : }

  00044	5d		 pop	 ebp
  00045	c2 0c 00	 ret	 12			; 0000000cH
?EncryptByte@ccddaabb@@QAEXPBDPADH@Z ENDP		; ccddaabb::EncryptByte
_TEXT	ENDS
PUBLIC	?DecryptByte@ccddaabb@@QBEXPBDPADH@Z		; ccddaabb::DecryptByte
; Function compile flags: /Ogsp
;	COMDAT ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z
_TEXT	SEGMENT
_szCipher$ = 8						; size = 4
_szPlain$ = 12						; size = 4
_iSize$ = 16						; size = 4
?DecryptByte@ccddaabb@@QBEXPBDPADH@Z PROC		; ccddaabb::DecryptByte, COMDAT
; _this$ = ecx

; 84   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 85   : 	//UJ 130829, 속도향상을 위해 4bytes 단위로 수행하게 변경
; 86   : 	//if( (iSize%4) != 0 )
; 87   : 	//	return;
; 88   : 	//
; 89   : 	//for (int i = 0; i < iSize ; i+=8)
; 90   : 	for (int i = 0; i < iSize ; i+=4)

  00003	8b 45 10	 mov	 eax, DWORD PTR _iSize$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	7e 28		 jle	 SHORT $LN1@DecryptByt
  0000a	8b 55 0c	 mov	 edx, DWORD PTR _szPlain$[ebp]
  0000d	56		 push	 esi
  0000e	8b 75 08	 mov	 esi, DWORD PTR _szCipher$[ebp]
  00011	2b f2		 sub	 esi, edx
  00013	48		 dec	 eax
  00014	c1 e8 02	 shr	 eax, 2
  00017	57		 push	 edi
  00018	40		 inc	 eax
$LL3@DecryptByt:

; 91   : 	{
; 92   : 		Decrypt( (const unsigned int*)&szCipher[i], (unsigned int*)&szPlain[i] );

  00019	8b 3c 16	 mov	 edi, DWORD PTR [esi+edx]
  0001c	c1 cf 07	 ror	 edi, 7
  0001f	81 f7 55 33 22
	11		 xor	 edi, 287454037		; 11223355H
  00025	2b 79 04	 sub	 edi, DWORD PTR [ecx+4]
  00028	89 3a		 mov	 DWORD PTR [edx], edi
  0002a	83 c2 04	 add	 edx, 4
  0002d	48		 dec	 eax
  0002e	75 e9		 jne	 SHORT $LL3@DecryptByt
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
$LN1@DecryptByt:

; 93   : 	}
; 94   : }

  00032	5d		 pop	 ebp
  00033	c2 0c 00	 ret	 12			; 0000000cH
?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ENDP		; ccddaabb::DecryptByte
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogsp
;	COMDAT ??_Gccddaabb@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gccddaabb@@UAEPAXI@Z PROC				; ccddaabb::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ccddaabb@@6B@
  00010	74 07		 je	 SHORT $LN1@scalar
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	59		 pop	 ecx
$LN1@scalar:
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??_Gccddaabb@@UAEPAXI@Z ENDP				; ccddaabb::`scalar deleting destructor'
_TEXT	ENDS
END
