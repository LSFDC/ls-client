; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\Lost Saga For Developer\Youtube\Tutorial\Source\src\LSClient\ioSHA256.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
_K	DD	0428a2f98H
	DD	071374491H
	DD	0b5c0fbcfH
	DD	0e9b5dba5H
	DD	03956c25bH
	DD	059f111f1H
	DD	0923f82a4H
	DD	0ab1c5ed5H
	DD	0d807aa98H
	DD	012835b01H
	DD	0243185beH
	DD	0550c7dc3H
	DD	072be5d74H
	DD	080deb1feH
	DD	09bdc06a7H
	DD	0c19bf174H
	DD	0e49b69c1H
	DD	0efbe4786H
	DD	0fc19dc6H
	DD	0240ca1ccH
	DD	02de92c6fH
	DD	04a7484aaH
	DD	05cb0a9dcH
	DD	076f988daH
	DD	0983e5152H
	DD	0a831c66dH
	DD	0b00327c8H
	DD	0bf597fc7H
	DD	0c6e00bf3H
	DD	0d5a79147H
	DD	06ca6351H
	DD	014292967H
	DD	027b70a85H
	DD	02e1b2138H
	DD	04d2c6dfcH
	DD	053380d13H
	DD	0650a7354H
	DD	0766a0abbH
	DD	081c2c92eH
	DD	092722c85H
	DD	0a2bfe8a1H
	DD	0a81a664bH
	DD	0c24b8b70H
	DD	0c76c51a3H
	DD	0d192e819H
	DD	0d6990624H
	DD	0f40e3585H
	DD	0106aa070H
	DD	019a4c116H
	DD	01e376c08H
	DD	02748774cH
	DD	034b0bcb5H
	DD	0391c0cb3H
	DD	04ed8aa4aH
	DD	05b9cca4fH
	DD	0682e6ff3H
	DD	0748f82eeH
	DD	078a5636fH
	DD	084c87814H
	DD	08cc70208H
	DD	090befffaH
	DD	0a4506cebH
	DD	0bef9a3f7H
	DD	0c67178f2H
CONST	ENDS
PUBLIC	??0ioSHA256@@QAE@XZ				; ioSHA256::ioSHA256
EXTRN	_memset:PROC
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iosha256.cpp
;	COMDAT ??0ioSHA256@@QAE@XZ
_TEXT	SEGMENT
??0ioSHA256@@QAE@XZ PROC				; ioSHA256::ioSHA256, COMDAT
; _this$ = ecx

; 8    : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 9    : 	ZeroMemory(&m_sha, sizeof(m_sha));

  00002	6a 68		 push	 104			; 00000068H
  00004	8b f1		 mov	 esi, ecx
  00006	6a 00		 push	 0
  00008	56		 push	 esi
  00009	e8 00 00 00 00	 call	 _memset
  0000e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10   : 	ZeroMemory(&m_hash, sizeof(m_hash));

  00011	6a 08		 push	 8
  00013	59		 pop	 ecx
  00014	33 c0		 xor	 eax, eax
  00016	8d 7e 68	 lea	 edi, DWORD PTR [esi+104]
  00019	f3 ab		 rep stosd
  0001b	5f		 pop	 edi

; 11   : }

  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	c3		 ret	 0
??0ioSHA256@@QAE@XZ ENDP				; ioSHA256::ioSHA256
_TEXT	ENDS
PUBLIC	??1ioSHA256@@QAE@XZ				; ioSHA256::~ioSHA256
; Function compile flags: /Ogsp
;	COMDAT ??1ioSHA256@@QAE@XZ
_TEXT	SEGMENT
??1ioSHA256@@QAE@XZ PROC				; ioSHA256::~ioSHA256, COMDAT
; _this$ = ecx

; 16   : }

  00000	c3		 ret	 0
??1ioSHA256@@QAE@XZ ENDP				; ioSHA256::~ioSHA256
_TEXT	ENDS
PUBLIC	?Sha256_Init@ioSHA256@@QAEXXZ			; ioSHA256::Sha256_Init
; Function compile flags: /Ogsp
;	COMDAT ?Sha256_Init@ioSHA256@@QAEXXZ
_TEXT	SEGMENT
?Sha256_Init@ioSHA256@@QAEXXZ PROC			; ioSHA256::Sha256_Init, COMDAT
; _this$ = ecx

; 89   : {

  00000	56		 push	 esi

; 90   : 	ZeroMemory(&m_sha, sizeof(m_sha));

  00001	6a 68		 push	 104			; 00000068H
  00003	8b f1		 mov	 esi, ecx
  00005	6a 00		 push	 0
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 _memset

; 91   : 	m_sha.state[0] = 0x6a09e667;
; 92   : 	m_sha.state[1] = 0xbb67ae85;
; 93   : 	m_sha.state[2] = 0x3c6ef372;
; 94   : 	m_sha.state[3] = 0xa54ff53a;
; 95   : 	m_sha.state[4] = 0x510e527f;
; 96   : 	m_sha.state[5] = 0x9b05688c;
; 97   : 	m_sha.state[6] = 0x1f83d9ab;
; 98   : 	m_sha.state[7] = 0x5be0cd19;
; 99   : 	m_sha.count = 0;

  0000d	83 66 20 00	 and	 DWORD PTR [esi+32], 0
  00011	83 66 24 00	 and	 DWORD PTR [esi+36], 0
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH
  00018	c7 06 67 e6 09
	6a		 mov	 DWORD PTR [esi], 1779033703 ; 6a09e667H
  0001e	c7 46 04 85 ae
	67 bb		 mov	 DWORD PTR [esi+4], -1150833019 ; bb67ae85H
  00025	c7 46 08 72 f3
	6e 3c		 mov	 DWORD PTR [esi+8], 1013904242 ; 3c6ef372H
  0002c	c7 46 0c 3a f5
	4f a5		 mov	 DWORD PTR [esi+12], -1521486534 ; a54ff53aH
  00033	c7 46 10 7f 52
	0e 51		 mov	 DWORD PTR [esi+16], 1359893119 ; 510e527fH
  0003a	c7 46 14 8c 68
	05 9b		 mov	 DWORD PTR [esi+20], -1694144372 ; 9b05688cH
  00041	c7 46 18 ab d9
	83 1f		 mov	 DWORD PTR [esi+24], 528734635 ; 1f83d9abH
  00048	c7 46 1c 19 cd
	e0 5b		 mov	 DWORD PTR [esi+28], 1541459225 ; 5be0cd19H
  0004f	5e		 pop	 esi

; 100  : }

  00050	c3		 ret	 0
?Sha256_Init@ioSHA256@@QAEXXZ ENDP			; ioSHA256::Sha256_Init
_TEXT	ENDS
PUBLIC	_state$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?Sha256_Transform@ioSHA256@@IAEXPAIPBI@Z	; ioSHA256::Sha256_Transform
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogsp
;	COMDAT ?Sha256_Transform@ioSHA256@@IAEXPAIPBI@Z
_TEXT	SEGMENT
tv1252 = -132						; size = 4
_state$GSCopy$ = -128					; size = 4
tv827 = -124						; size = 4
tv596 = -120						; size = 4
tv1073 = -116						; size = 4
tv1238 = -112						; size = 4
_j$ = -108						; size = 4
tv1401 = -104						; size = 4
tv1319 = -104						; size = 4
tv219 = -104						; size = 4
_W$ = -100						; size = 64
_T$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_state$ = 8						; size = 4
_data$ = 12						; size = 4
?Sha256_Transform@ioSHA256@@IAEXPAIPBI@Z PROC		; ioSHA256::Sha256_Transform, COMDAT
; _this$ = ecx

; 103  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 104  : 	UInt32 W[16];
; 105  : 	unsigned j;
; 106  : #ifdef _SHA256_UNROLL2
; 107  : 	UInt32 a,b,c,d,e,f,g,h;
; 108  : 	a = state[0];
; 109  : 	b = state[1];
; 110  : 	c = state[2];
; 111  : 	d = state[3];
; 112  : 	e = state[4];
; 113  : 	f = state[5];
; 114  : 	g = state[6];
; 115  : 	h = state[7];
; 116  : #else
; 117  : 	UInt32 T[8];
; 118  : 	for (j = 0; j < 8; j++)
; 119  : 		T[j] = state[j];
; 120  : #endif
; 121  : 
; 122  : 	for (j = 0; j < 64; j += 16)

  00013	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00016	83 65 94 00	 and	 DWORD PTR _j$[ebp], 0
  0001a	56		 push	 esi
  0001b	8b 75 08	 mov	 esi, DWORD PTR _state$[ebp]
  0001e	57		 push	 edi
  0001f	6a 08		 push	 8
  00021	59		 pop	 ecx
  00022	8d 7d dc	 lea	 edi, DWORD PTR _T$[ebp]
  00025	89 75 80	 mov	 DWORD PTR _state$GSCopy$[ebp], esi
  00028	f3 a5		 rep movsd
  0002a	8d 4d 9c	 lea	 ecx, DWORD PTR _W$[ebp]
  0002d	2b c1		 sub	 eax, ecx

; 123  : 	{
; 124  : #if defined(_SHA256_UNROLL) || defined(_SHA256_UNROLL2)
; 125  : 		RX_8(0); RX_8(8);
; 126  : #else
; 127  : 		unsigned i;
; 128  : 		for (i = 0; i < 16; i++) { R(i); }

  0002f	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv1252[ebp], eax
  00035	53		 push	 ebx
$LL25@Sha256_Tra:
  00036	8b 75 94	 mov	 esi, DWORD PTR _j$[ebp]
  00039	33 c9		 xor	 ecx, ecx
  0003b	41		 inc	 ecx
  0003c	6a fc		 push	 -4			; fffffffcH
  0003e	8d 55 9c	 lea	 edx, DWORD PTR _W$[ebp]
  00041	8d 34 b5 00 00
	00 00		 lea	 esi, DWORD PTR _K[esi*4]
  00048	89 4d 84	 mov	 DWORD PTR tv827[ebp], ecx
  0004b	58		 pop	 eax
  0004c	89 55 8c	 mov	 DWORD PTR tv1073[ebp], edx
  0004f	89 75 90	 mov	 DWORD PTR tv1238[ebp], esi
  00052	c7 45 88 10 00
	00 00		 mov	 DWORD PTR tv596[ebp], 16 ; 00000010H
$LL26@Sha256_Tra:
  00059	83 7d 94 00	 cmp	 DWORD PTR _j$[ebp], 0
  0005d	74 57		 je	 SHORT $LN15@Sha256_Tra
  0005f	8d 79 ff	 lea	 edi, DWORD PTR [ecx-1]
  00062	83 e7 0f	 and	 edi, 15			; 0000000fH
  00065	8b f1		 mov	 esi, ecx
  00067	83 e6 0f	 and	 esi, 15			; 0000000fH
  0006a	8b 74 b5 9c	 mov	 esi, DWORD PTR _W$[ebp+esi*4]
  0006e	8d 7c bd 9c	 lea	 edi, DWORD PTR _W$[ebp+edi*4]
  00072	89 7d 98	 mov	 DWORD PTR tv1319[ebp], edi
  00075	8d 51 fd	 lea	 edx, DWORD PTR [ecx-3]
  00078	83 e2 0f	 and	 edx, 15			; 0000000fH
  0007b	8b 54 95 9c	 mov	 edx, DWORD PTR _W$[ebp+edx*4]
  0007f	8b fe		 mov	 edi, esi
  00081	c1 cf 12	 ror	 edi, 18			; 00000012H
  00084	8b de		 mov	 ebx, esi
  00086	c1 cb 07	 ror	 ebx, 7
  00089	33 fb		 xor	 edi, ebx
  0008b	c1 ee 03	 shr	 esi, 3
  0008e	33 fe		 xor	 edi, esi
  00090	8b f2		 mov	 esi, edx
  00092	c1 ce 13	 ror	 esi, 19			; 00000013H
  00095	8b da		 mov	 ebx, edx
  00097	c1 cb 11	 ror	 ebx, 17			; 00000011H
  0009a	33 f3		 xor	 esi, ebx
  0009c	c1 ea 0a	 shr	 edx, 10			; 0000000aH
  0009f	83 c1 f8	 add	 ecx, -8			; fffffff8H
  000a2	33 f2		 xor	 esi, edx
  000a4	83 e1 0f	 and	 ecx, 15			; 0000000fH
  000a7	03 fe		 add	 edi, esi
  000a9	03 7c 8d 9c	 add	 edi, DWORD PTR _W$[ebp+ecx*4]
  000ad	8b 4d 98	 mov	 ecx, DWORD PTR tv1319[ebp]
  000b0	01 39		 add	 DWORD PTR [ecx], edi
  000b2	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000b4	eb 0b		 jmp	 SHORT $LN27@Sha256_Tra
$LN15@Sha256_Tra:
  000b6	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR tv1252[ebp]
  000bc	8b 0c 11	 mov	 ecx, DWORD PTR [ecx+edx]
  000bf	89 0a		 mov	 DWORD PTR [edx], ecx
$LN27@Sha256_Tra:
  000c1	89 4d 98	 mov	 DWORD PTR tv219[ebp], ecx
  000c4	8b c8		 mov	 ecx, eax
  000c6	83 e1 07	 and	 ecx, 7
  000c9	8b 54 8d dc	 mov	 edx, DWORD PTR _T$[ebp+ecx*4]
  000cd	8b fa		 mov	 edi, edx
  000cf	8b da		 mov	 ebx, edx
  000d1	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
  000d4	83 e1 07	 and	 ecx, 7
  000d7	8b 74 8d dc	 mov	 esi, DWORD PTR _T$[ebp+ecx*4]
  000db	8d 48 03	 lea	 ecx, DWORD PTR [eax+3]
  000de	83 e1 07	 and	 ecx, 7
  000e1	c1 cf 19	 ror	 edi, 25			; 00000019H
  000e4	c1 cb 0b	 ror	 ebx, 11			; 0000000bH
  000e7	33 fb		 xor	 edi, ebx
  000e9	8b da		 mov	 ebx, edx
  000eb	c1 cb 06	 ror	 ebx, 6
  000ee	33 fb		 xor	 edi, ebx
  000f0	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]
  000f3	83 e3 07	 and	 ebx, 7
  000f6	8b 5c 9d dc	 mov	 ebx, DWORD PTR _T$[ebp+ebx*4]
  000fa	33 de		 xor	 ebx, esi
  000fc	23 da		 and	 ebx, edx
  000fe	8b 55 90	 mov	 edx, DWORD PTR tv1238[ebp]
  00101	33 de		 xor	 ebx, esi
  00103	03 fb		 add	 edi, ebx
  00105	03 3a		 add	 edi, DWORD PTR [edx]
  00107	8d 4c 8d dc	 lea	 ecx, DWORD PTR _T$[ebp+ecx*4]
  0010b	03 7d 98	 add	 edi, DWORD PTR tv219[ebp]
  0010e	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
  00111	01 39		 add	 DWORD PTR [ecx], edi
  00113	8b 31		 mov	 esi, DWORD PTR [ecx]
  00115	83 e2 07	 and	 edx, 7
  00118	8d 54 95 dc	 lea	 edx, DWORD PTR _T$[ebp+edx*4]
  0011c	01 32		 add	 DWORD PTR [edx], esi
  0011e	8d 50 fc	 lea	 edx, DWORD PTR [eax-4]
  00121	83 e2 07	 and	 edx, 7
  00124	8b 54 95 dc	 mov	 edx, DWORD PTR _T$[ebp+edx*4]
  00128	83 45 90 04	 add	 DWORD PTR tv1238[ebp], 4
  0012c	8d 70 fd	 lea	 esi, DWORD PTR [eax-3]
  0012f	83 e6 07	 and	 esi, 7
  00132	8b 74 b5 dc	 mov	 esi, DWORD PTR _T$[ebp+esi*4]
  00136	8b fa		 mov	 edi, edx
  00138	c1 cf 16	 ror	 edi, 22			; 00000016H
  0013b	8b da		 mov	 ebx, edx
  0013d	c1 cb 0d	 ror	 ebx, 13			; 0000000dH
  00140	33 fb		 xor	 edi, ebx
  00142	8b da		 mov	 ebx, edx
  00144	c1 cb 02	 ror	 ebx, 2
  00147	33 fb		 xor	 edi, ebx
  00149	8d 58 fe	 lea	 ebx, DWORD PTR [eax-2]
  0014c	83 e3 07	 and	 ebx, 7
  0014f	8b 5c 9d dc	 mov	 ebx, DWORD PTR _T$[ebp+ebx*4]
  00153	89 75 98	 mov	 DWORD PTR tv1401[ebp], esi
  00156	0b f2		 or	 esi, edx
  00158	23 de		 and	 ebx, esi
  0015a	8b 75 98	 mov	 esi, DWORD PTR tv1401[ebp]
  0015d	23 f2		 and	 esi, edx
  0015f	8b 55 8c	 mov	 edx, DWORD PTR tv1073[ebp]
  00162	0b de		 or	 ebx, esi
  00164	03 fb		 add	 edi, ebx
  00166	01 39		 add	 DWORD PTR [ecx], edi
  00168	8b 4d 84	 mov	 ecx, DWORD PTR tv827[ebp]
  0016b	41		 inc	 ecx
  0016c	83 c2 04	 add	 edx, 4
  0016f	48		 dec	 eax
  00170	ff 4d 88	 dec	 DWORD PTR tv596[ebp]
  00173	89 4d 84	 mov	 DWORD PTR tv827[ebp], ecx
  00176	89 55 8c	 mov	 DWORD PTR tv1073[ebp], edx
  00179	0f 85 da fe ff
	ff		 jne	 $LL26@Sha256_Tra

; 104  : 	UInt32 W[16];
; 105  : 	unsigned j;
; 106  : #ifdef _SHA256_UNROLL2
; 107  : 	UInt32 a,b,c,d,e,f,g,h;
; 108  : 	a = state[0];
; 109  : 	b = state[1];
; 110  : 	c = state[2];
; 111  : 	d = state[3];
; 112  : 	e = state[4];
; 113  : 	f = state[5];
; 114  : 	g = state[6];
; 115  : 	h = state[7];
; 116  : #else
; 117  : 	UInt32 T[8];
; 118  : 	for (j = 0; j < 8; j++)
; 119  : 		T[j] = state[j];
; 120  : #endif
; 121  : 
; 122  : 	for (j = 0; j < 64; j += 16)

  0017f	83 45 94 10	 add	 DWORD PTR _j$[ebp], 16	; 00000010H
  00183	83 7d 94 40	 cmp	 DWORD PTR _j$[ebp], 64	; 00000040H
  00187	0f 82 a9 fe ff
	ff		 jb	 $LL25@Sha256_Tra

; 129  : #endif
; 130  : 	}
; 131  : 
; 132  : #ifdef _SHA256_UNROLL2
; 133  : 	state[0] += a;
; 134  : 	state[1] += b;
; 135  : 	state[2] += c;
; 136  : 	state[3] += d;
; 137  : 	state[4] += e;
; 138  : 	state[5] += f;
; 139  : 	state[6] += g;
; 140  : 	state[7] += h;
; 141  : #else
; 142  : 	for (j = 0; j < 8; j++)

  0018d	8b 45 80	 mov	 eax, DWORD PTR _state$GSCopy$[ebp]
  00190	6a 08		 push	 8
  00192	8d 4d dc	 lea	 ecx, DWORD PTR _T$[ebp]
  00195	5a		 pop	 edx
  00196	2b c8		 sub	 ecx, eax
  00198	5b		 pop	 ebx
$LL3@Sha256_Tra:

; 143  : 		state[j] += T[j];

  00199	8b 34 01	 mov	 esi, DWORD PTR [ecx+eax]
  0019c	01 30		 add	 DWORD PTR [eax], esi
  0019e	83 c0 04	 add	 eax, 4
  001a1	4a		 dec	 edx
  001a2	75 f5		 jne	 SHORT $LL3@Sha256_Tra

; 144  : #endif
; 145  : 
; 146  : 	/* Wipe variables */
; 147  : 	/* memset(W, 0, sizeof(W)); */
; 148  : 	/* memset(T, 0, sizeof(T)); */
; 149  : }

  001a4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a7	5f		 pop	 edi
  001a8	33 cd		 xor	 ecx, ebp
  001aa	5e		 pop	 esi
  001ab	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b0	c9		 leave
  001b1	c2 08 00	 ret	 8
?Sha256_Transform@ioSHA256@@IAEXPAIPBI@Z ENDP		; ioSHA256::Sha256_Transform
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?Sha256_WriteByteBlock@ioSHA256@@IAEXXZ		; ioSHA256::Sha256_WriteByteBlock
; Function compile flags: /Ogsp
;	COMDAT ?Sha256_WriteByteBlock@ioSHA256@@IAEXXZ
_TEXT	SEGMENT
_data32$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
?Sha256_WriteByteBlock@ioSHA256@@IAEXXZ PROC		; ioSHA256::Sha256_WriteByteBlock, COMDAT
; _this$ = ecx

; 157  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 158  : 	UInt32 data32[16];
; 159  : 	unsigned i;
; 160  : 	for (i = 0; i < 16; i++)

  00011	33 d2		 xor	 edx, edx
  00013	8d 41 29	 lea	 eax, DWORD PTR [ecx+41]
  00016	57		 push	 edi
$LL3@Sha256_Wri:

; 161  : 		data32[i] =
; 162  : 		((UInt32)(m_sha.buffer[i * 4    ]) << 24) +
; 163  : 		((UInt32)(m_sha.buffer[i * 4 + 1]) << 16) +
; 164  : 		((UInt32)(m_sha.buffer[i * 4 + 2]) <<  8) +
; 165  : 		((UInt32)(m_sha.buffer[i * 4 + 3]));

  00017	0f b6 70 ff	 movzx	 esi, BYTE PTR [eax-1]
  0001b	0f b6 38	 movzx	 edi, BYTE PTR [eax]
  0001e	c1 e6 08	 shl	 esi, 8
  00021	03 f7		 add	 esi, edi
  00023	0f b6 78 01	 movzx	 edi, BYTE PTR [eax+1]
  00027	c1 e6 08	 shl	 esi, 8
  0002a	03 f7		 add	 esi, edi
  0002c	0f b6 78 02	 movzx	 edi, BYTE PTR [eax+2]
  00030	c1 e6 08	 shl	 esi, 8
  00033	03 f7		 add	 esi, edi
  00035	89 74 95 bc	 mov	 DWORD PTR _data32$[ebp+edx*4], esi
  00039	42		 inc	 edx
  0003a	83 c0 04	 add	 eax, 4
  0003d	83 fa 10	 cmp	 edx, 16			; 00000010H
  00040	72 d5		 jb	 SHORT $LL3@Sha256_Wri

; 166  : 	Sha256_Transform(m_sha.state, data32);

  00042	8d 45 bc	 lea	 eax, DWORD PTR _data32$[ebp]
  00045	50		 push	 eax
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 ?Sha256_Transform@ioSHA256@@IAEXPAIPBI@Z ; ioSHA256::Sha256_Transform

; 167  : }

  0004c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004f	5f		 pop	 edi
  00050	33 cd		 xor	 ecx, ebp
  00052	5e		 pop	 esi
  00053	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00058	c9		 leave
  00059	c3		 ret	 0
?Sha256_WriteByteBlock@ioSHA256@@IAEXXZ ENDP		; ioSHA256::Sha256_WriteByteBlock
_TEXT	ENDS
PUBLIC	?Sha256_Update@ioSHA256@@QAEXPBEI@Z		; ioSHA256::Sha256_Update
; Function compile flags: /Ogsp
;	COMDAT ?Sha256_Update@ioSHA256@@QAEXPBEI@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
_size$ = 12						; size = 4
?Sha256_Update@ioSHA256@@QAEXPBEI@Z PROC		; ioSHA256::Sha256_Update, COMDAT
; _this$ = ecx

; 170  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f1		 mov	 esi, ecx

; 171  : 	UInt32 curBufferPos = (UInt32)m_sha.count & 0x3F;

  00007	8b 7e 20	 mov	 edi, DWORD PTR [esi+32]
  0000a	83 e7 3f	 and	 edi, 63			; 0000003fH

; 172  : 	while (size > 0)

  0000d	83 7d 0c 00	 cmp	 DWORD PTR _size$[ebp], 0
  00011	76 2c		 jbe	 SHORT $LN2@Sha256_Upd
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _data$[ebp]
$LL3@Sha256_Upd:

; 173  : 	{
; 174  : 		m_sha.buffer[curBufferPos++] = *data++;

  00017	8a 03		 mov	 al, BYTE PTR [ebx]
  00019	88 44 3e 28	 mov	 BYTE PTR [esi+edi+40], al
  0001d	47		 inc	 edi
  0001e	43		 inc	 ebx

; 175  : 		m_sha.count++;

  0001f	83 46 20 01	 add	 DWORD PTR [esi+32], 1
  00023	83 56 24 00	 adc	 DWORD PTR [esi+36], 0

; 176  : 		size--;

  00027	ff 4d 0c	 dec	 DWORD PTR _size$[ebp]

; 177  : 		if (curBufferPos == 64)

  0002a	83 ff 40	 cmp	 edi, 64			; 00000040H
  0002d	75 09		 jne	 SHORT $LN1@Sha256_Upd

; 178  : 		{
; 179  : 			curBufferPos = 0;
; 180  : 			Sha256_WriteByteBlock();

  0002f	8b ce		 mov	 ecx, esi
  00031	33 ff		 xor	 edi, edi
  00033	e8 00 00 00 00	 call	 ?Sha256_WriteByteBlock@ioSHA256@@IAEXXZ ; ioSHA256::Sha256_WriteByteBlock
$LN1@Sha256_Upd:

; 172  : 	while (size > 0)

  00038	83 7d 0c 00	 cmp	 DWORD PTR _size$[ebp], 0
  0003c	77 d9		 ja	 SHORT $LL3@Sha256_Upd
  0003e	5b		 pop	 ebx
$LN2@Sha256_Upd:
  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi

; 181  : 		}
; 182  : 	}
; 183  : }

  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
?Sha256_Update@ioSHA256@@QAEXPBEI@Z ENDP		; ioSHA256::Sha256_Update
_TEXT	ENDS
PUBLIC	?Sha256_Final@ioSHA256@@QAEXPAE@Z		; ioSHA256::Sha256_Final
; Function compile flags: /Ogsp
;	COMDAT ?Sha256_Final@ioSHA256@@QAEXPAE@Z
_TEXT	SEGMENT
_lenInBits$ = -8					; size = 8
_digest$ = 8						; size = 4
?Sha256_Final@ioSHA256@@QAEXPAE@Z PROC			; ioSHA256::Sha256_Final, COMDAT
; _this$ = ecx

; 186  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx

; 187  : 	UInt64 lenInBits = (m_sha.count << 3);

  0000a	8b 5f 20	 mov	 ebx, DWORD PTR [edi+32]
  0000d	8b 47 24	 mov	 eax, DWORD PTR [edi+36]

; 188  : 	UInt32 curBufferPos = (UInt32)m_sha.count & 0x3F;

  00010	8b 77 20	 mov	 esi, DWORD PTR [edi+32]
  00013	0f a4 d8 03	 shld	 eax, ebx, 3
  00017	c1 e3 03	 shl	 ebx, 3
  0001a	83 e6 3f	 and	 esi, 63			; 0000003fH
  0001d	89 45 fc	 mov	 DWORD PTR _lenInBits$[ebp+4], eax

; 189  : 	unsigned i;
; 190  : 	m_sha.buffer[curBufferPos++] = 0x80;

  00020	c6 44 3e 28 80	 mov	 BYTE PTR [esi+edi+40], 128 ; 00000080H
  00025	eb 11		 jmp	 SHORT $LN21@Sha256_Fin
$LL9@Sha256_Fin:

; 191  : 	while (curBufferPos != (64 - 8))
; 192  : 	{
; 193  : 		curBufferPos &= 0x3F;

  00027	83 e6 3f	 and	 esi, 63			; 0000003fH

; 194  : 		if (curBufferPos == 0)

  0002a	75 07		 jne	 SHORT $LN7@Sha256_Fin

; 195  : 			Sha256_WriteByteBlock();

  0002c	8b cf		 mov	 ecx, edi
  0002e	e8 00 00 00 00	 call	 ?Sha256_WriteByteBlock@ioSHA256@@IAEXXZ ; ioSHA256::Sha256_WriteByteBlock
$LN7@Sha256_Fin:

; 196  : 		m_sha.buffer[curBufferPos++] = 0;

  00033	c6 44 37 28 00	 mov	 BYTE PTR [edi+esi+40], 0
$LN21@Sha256_Fin:
  00038	46		 inc	 esi
  00039	83 fe 38	 cmp	 esi, 56			; 00000038H
  0003c	75 e9		 jne	 SHORT $LL9@Sha256_Fin

; 197  : 	}
; 198  : 	for (i = 0; i < 8; i++)

  0003e	6a 08		 push	 8
  00040	8d 74 3e 28	 lea	 esi, DWORD PTR [esi+edi+40]
  00044	58		 pop	 eax
$LL18@Sha256_Fin:

; 199  : 	{
; 200  : 		m_sha.buffer[curBufferPos++] = (Byte)(lenInBits >> 56);

  00045	8b 4d fc	 mov	 ecx, DWORD PTR _lenInBits$[ebp+4]
  00048	c1 e9 18	 shr	 ecx, 24			; 00000018H
  0004b	88 0e		 mov	 BYTE PTR [esi], cl

; 201  : 		lenInBits <<= 8;

  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _lenInBits$[ebp+4]
  00050	0f a4 d9 08	 shld	 ecx, ebx, 8
  00054	46		 inc	 esi
  00055	c1 e3 08	 shl	 ebx, 8
  00058	48		 dec	 eax
  00059	89 4d fc	 mov	 DWORD PTR _lenInBits$[ebp+4], ecx
  0005c	75 e7		 jne	 SHORT $LL18@Sha256_Fin

; 202  : 	}
; 203  : 	Sha256_WriteByteBlock();

  0005e	8b cf		 mov	 ecx, edi
  00060	e8 00 00 00 00	 call	 ?Sha256_WriteByteBlock@ioSHA256@@IAEXXZ ; ioSHA256::Sha256_WriteByteBlock

; 204  : 
; 205  : 	for (i = 0; i < 8; i++)

  00065	8b 45 08	 mov	 eax, DWORD PTR _digest$[ebp]
  00068	33 f6		 xor	 esi, esi
$LL3@Sha256_Fin:
  0006a	8d 0c b7	 lea	 ecx, DWORD PTR [edi+esi*4]

; 206  : 	{
; 207  : 		*digest++ = (Byte)(m_sha.state[i] >> 24);

  0006d	8a 51 03	 mov	 dl, BYTE PTR [ecx+3]
  00070	88 10		 mov	 BYTE PTR [eax], dl

; 208  : 		*digest++ = (Byte)(m_sha.state[i] >> 16);

  00072	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  00075	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 209  : 		*digest++ = (Byte)(m_sha.state[i] >> 8);

  00078	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007a	c1 ea 08	 shr	 edx, 8
  0007d	88 50 02	 mov	 BYTE PTR [eax+2], dl

; 210  : 		*digest++ = (Byte)(m_sha.state[i]);

  00080	8a 09		 mov	 cl, BYTE PTR [ecx]
  00082	88 48 03	 mov	 BYTE PTR [eax+3], cl
  00085	83 c0 04	 add	 eax, 4
  00088	46		 inc	 esi
  00089	83 fe 08	 cmp	 esi, 8
  0008c	72 dc		 jb	 SHORT $LL3@Sha256_Fin

; 211  : 	}
; 212  : 	Sha256_Init();

  0008e	8b cf		 mov	 ecx, edi
  00090	e8 00 00 00 00	 call	 ?Sha256_Init@ioSHA256@@QAEXXZ ; ioSHA256::Sha256_Init
  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx

; 213  : }

  00098	c9		 leave
  00099	c2 04 00	 ret	 4
?Sha256_Final@ioSHA256@@QAEXPAE@Z ENDP			; ioSHA256::Sha256_Final
_TEXT	ENDS
PUBLIC	?MakeHashCode@ioSHA256@@QAEPBEPAIPBEI@Z		; ioSHA256::MakeHashCode
; Function compile flags: /Ogsp
;	COMDAT ?MakeHashCode@ioSHA256@@QAEPBEPAIPBEI@Z
_TEXT	SEGMENT
_hashSize$ = 8						; size = 4
_sourceData$ = 12					; size = 4
_size$ = 16						; size = 4
?MakeHashCode@ioSHA256@@QAEPBEPAIPBEI@Z PROC		; ioSHA256::MakeHashCode, COMDAT
; _this$ = ecx

; 216  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f1		 mov	 esi, ecx

; 217  : 	int hasize = sizeof(m_hash);
; 218  : 	hasize++;
; 219  : 
; 220  : 	ZeroMemory(&m_hash, sizeof(m_hash));

  00008	6a 08		 push	 8
  0000a	8d 5e 68	 lea	 ebx, DWORD PTR [esi+104]
  0000d	59		 pop	 ecx
  0000e	33 c0		 xor	 eax, eax
  00010	8b fb		 mov	 edi, ebx
  00012	f3 ab		 rep stosd

; 221  : 	Sha256_Init();

  00014	8b ce		 mov	 ecx, esi
  00016	e8 00 00 00 00	 call	 ?Sha256_Init@ioSHA256@@QAEXXZ ; ioSHA256::Sha256_Init

; 222  : 	Sha256_Update(sourceData, size);

  0001b	ff 75 10	 push	 DWORD PTR _size$[ebp]
  0001e	8b ce		 mov	 ecx, esi
  00020	ff 75 0c	 push	 DWORD PTR _sourceData$[ebp]
  00023	e8 00 00 00 00	 call	 ?Sha256_Update@ioSHA256@@QAEXPBEI@Z ; ioSHA256::Sha256_Update

; 223  : 	Sha256_Final(m_hash);

  00028	53		 push	 ebx
  00029	8b ce		 mov	 ecx, esi
  0002b	e8 00 00 00 00	 call	 ?Sha256_Final@ioSHA256@@QAEXPAE@Z ; ioSHA256::Sha256_Final

; 224  : 
; 225  : 	int hsize = 0;
; 226  : 	hsize += hasize;
; 227  : 	*hashSize = SHA256_DIGEST_SIZE;

  00030	8b 45 08	 mov	 eax, DWORD PTR _hashSize$[ebp]
  00033	5f		 pop	 edi
  00034	c7 00 20 00 00
	00		 mov	 DWORD PTR [eax], 32	; 00000020H
  0003a	5e		 pop	 esi

; 228  : 	return m_hash;

  0003b	8b c3		 mov	 eax, ebx
  0003d	5b		 pop	 ebx

; 229  : }

  0003e	5d		 pop	 ebp
  0003f	c2 0c 00	 ret	 12			; 0000000cH
?MakeHashCode@ioSHA256@@QAEPBEPAIPBEI@Z ENDP		; ioSHA256::MakeHashCode
_TEXT	ENDS
END
