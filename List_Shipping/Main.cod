; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\Lost Saga For Developer\Youtube\Tutorial\Source\src\LSClient\Main.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?g_szErrorPos@@3PADA				; g_szErrorPos
PUBLIC	?g_szErrorLog@@3PADA				; g_szErrorLog
PUBLIC	?g_szTempLogBuf@@3PADA				; g_szTempLogBuf
PUBLIC	?g_szSendErrorLog@@3PADA			; g_szSendErrorLog
PUBLIC	?NtSetSystemInformation@@3P6GKKPAXK@ZA		; NtSetSystemInformation
PUBLIC	?NtQuerySystemInformation@@3P6GKKPAXKPAK@ZA	; NtQuerySystemInformation
PUBLIC	?g_StartupStickyKeys@@3UtagSTICKYKEYS@@A	; g_StartupStickyKeys
PUBLIC	?g_StartupFilterKeys@@3UtagFILTERKEYS@@A	; g_StartupFilterKeys
PUBLIC	?g_bHappenCrash@@3_NA				; g_bHappenCrash
PUBLIC	?g_bHappenError@@3_NA				; g_bHappenError
PUBLIC	?g_iErrorNumber@@3HA				; g_iErrorNumber
PUBLIC	?szTrace@@3PBDB					; szTrace
PUBLIC	?g_pErrorDlgSkin@@3PAVCSkin@@A			; g_pErrorDlgSkin
PUBLIC	?g_hEdit@@3PAUHWND__@@A				; g_hEdit
PUBLIC	?g_hBrushEdit@@3PAUHBRUSH__@@A			; g_hBrushEdit
PUBLIC	?g_hBitmapX@@3PAPAUHBITMAP__@@A			; g_hBitmapX
PUBLIC	?g_hBitmapSolution@@3PAPAUHBITMAP__@@A		; g_hBitmapSolution
PUBLIC	?g_hBitmapExit@@3PAPAUHBITMAP__@@A		; g_hBitmapExit
PUBLIC	?g_bXOver@@3_NA					; g_bXOver
PUBLIC	?g_bSolutionOver@@3_NA				; g_bSolutionOver
PUBLIC	?g_bExitOver@@3_NA				; g_bExitOver
PUBLIC	?g_OldXProc@@3P6GJPAUHWND__@@IIJ@ZA		; g_OldXProc
PUBLIC	?g_OldSolutionProc@@3P6GJPAUHWND__@@IIJ@ZA	; g_OldSolutionProc
PUBLIC	?g_OldExitProc@@3P6GJPAUHWND__@@IIJ@ZA		; g_OldExitProc
PUBLIC	?bTestLog@@3_NA					; bTestLog
PUBLIC	?bMemoryTest@@3_NA				; bMemoryTest
_BSS	SEGMENT
?g_szErrorPos@@3PADA DB 0104H DUP (?)			; g_szErrorPos
?g_szErrorLog@@3PADA DB 01000H DUP (?)			; g_szErrorLog
?g_szTempLogBuf@@3PADA DB 0800H DUP (?)			; g_szTempLogBuf
?g_szSendErrorLog@@3PADA DB 01000H DUP (?)		; g_szSendErrorLog
?NtSetSystemInformation@@3P6GKKPAXK@ZA DD 01H DUP (?)	; NtSetSystemInformation
?NtQuerySystemInformation@@3P6GKKPAXKPAK@ZA DD 01H DUP (?) ; NtQuerySystemInformation
?g_bHappenCrash@@3_NA DB 01H DUP (?)			; g_bHappenCrash
	ALIGN	4

?g_bHappenError@@3_NA DB 01H DUP (?)			; g_bHappenError
	ALIGN	4

?g_iErrorNumber@@3HA DD 01H DUP (?)			; g_iErrorNumber
?szTrace@@3PBDB DD 01H DUP (?)				; szTrace
?g_pErrorDlgSkin@@3PAVCSkin@@A DD 01H DUP (?)		; g_pErrorDlgSkin
?g_hEdit@@3PAUHWND__@@A DD 01H DUP (?)			; g_hEdit
?g_hBrushEdit@@3PAUHBRUSH__@@A DD 01H DUP (?)		; g_hBrushEdit
?g_hBitmapX@@3PAPAUHBITMAP__@@A DD 03H DUP (?)		; g_hBitmapX
?g_hBitmapSolution@@3PAPAUHBITMAP__@@A DD 03H DUP (?)	; g_hBitmapSolution
?g_hBitmapExit@@3PAPAUHBITMAP__@@A DD 03H DUP (?)	; g_hBitmapExit
?g_bXOver@@3_NA DB 01H DUP (?)				; g_bXOver
	ALIGN	4

?g_bSolutionOver@@3_NA DB 01H DUP (?)			; g_bSolutionOver
	ALIGN	4

?g_bExitOver@@3_NA DB 01H DUP (?)			; g_bExitOver
	ALIGN	4

?g_OldXProc@@3P6GJPAUHWND__@@IIJ@ZA DD 01H DUP (?)	; g_OldXProc
?g_OldSolutionProc@@3P6GJPAUHWND__@@IIJ@ZA DD 01H DUP (?) ; g_OldSolutionProc
?g_OldExitProc@@3P6GJPAUHWND__@@IIJ@ZA DD 01H DUP (?)	; g_OldExitProc
?bTestLog@@3_NA DB 01H DUP (?)				; bTestLog
	ALIGN	4

?bMemoryTest@@3_NA DB 01H DUP (?)			; bMemoryTest
_BSS	ENDS
_DATA	SEGMENT
?g_StartupStickyKeys@@3UtagSTICKYKEYS@@A DD 08H		; g_StartupStickyKeys
	DD	00H
?g_StartupFilterKeys@@3UtagFILTERKEYS@@A DD 018H	; g_StartupFilterKeys
	DD	00H
	ORG $+16
_DATA	ENDS
PUBLIC	?OnDrawItem@@YAXJI@Z				; OnDrawItem
EXTRN	__imp__DeleteDC@4:PROC
EXTRN	__imp__BitBlt@36:PROC
EXTRN	__imp__SelectObject@8:PROC
EXTRN	__imp__CreateCompatibleDC@4:PROC
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\main.cpp
;	COMDAT ?OnDrawItem@@YAXJI@Z
_TEXT	SEGMENT
_lParam$ = 8						; size = 4
_wParam$ = 12						; size = 4
?OnDrawItem@@YAXJI@Z PROC				; OnDrawItem, COMDAT

; 806  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 807  : 	HDC	hdc;
; 808  : 	DRAWITEMSTRUCT *lpDi = NULL;
; 809  : 	lpDi = (LPDRAWITEMSTRUCT)lParam;	
; 810  : 	if( !lpDi )

  00004	8b 75 08	 mov	 esi, DWORD PTR _lParam$[ebp]
  00007	57		 push	 edi
  00008	33 ff		 xor	 edi, edi
  0000a	3b f7		 cmp	 esi, edi
  0000c	0f 84 00 01 00
	00		 je	 $LN16@OnDrawItem

; 811  : 		return;
; 812  : 
; 813  : 	switch(wParam)

  00012	8b 45 0c	 mov	 eax, DWORD PTR _wParam$[ebp]
  00015	48		 dec	 eax
  00016	53		 push	 ebx
  00017	0f 84 9f 00 00
	00		 je	 $LN5@OnDrawItem
  0001d	2d 01 04 00 00	 sub	 eax, 1025		; 00000401H
  00022	74 50		 je	 SHORT $LN10@OnDrawItem
  00024	48		 dec	 eax
  00025	48		 dec	 eax
  00026	0f 85 e5 00 00
	00		 jne	 $LN21@OnDrawItem

; 814  : 	{
; 815  : 	case IDC_X:
; 816  : 		hdc = CreateCompatibleDC(lpDi->hDC);

  0002c	ff 76 18	 push	 DWORD PTR [esi+24]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4

; 817  : 		if( lpDi->itemState & ODS_SELECTED)

  00035	f6 46 10 01	 test	 BYTE PTR [esi+16], 1
  00039	8b d8		 mov	 ebx, eax
  0003b	74 08		 je	 SHORT $LN14@OnDrawItem

; 818  : 			SelectObject(hdc, g_hBitmapX[2]);

  0003d	ff 35 08 00 00
	00		 push	 DWORD PTR ?g_hBitmapX@@3PAPAUHBITMAP__@@A+8
  00043	eb 17		 jmp	 SHORT $LN22@OnDrawItem
$LN14@OnDrawItem:

; 819  : 		else if(g_bXOver == true)

  00045	80 3d 00 00 00
	00 01		 cmp	 BYTE PTR ?g_bXOver@@3_NA, 1 ; g_bXOver
  0004c	75 08		 jne	 SHORT $LN12@OnDrawItem

; 820  : 			SelectObject(hdc, g_hBitmapX[1]);		

  0004e	ff 35 04 00 00
	00		 push	 DWORD PTR ?g_hBitmapX@@3PAPAUHBITMAP__@@A+4

; 821  : 		else

  00054	eb 06		 jmp	 SHORT $LN22@OnDrawItem
$LN12@OnDrawItem:

; 822  : 			SelectObject(hdc, g_hBitmapX[0]);

  00056	ff 35 00 00 00
	00		 push	 DWORD PTR ?g_hBitmapX@@3PAPAUHBITMAP__@@A
$LN22@OnDrawItem:
  0005c	53		 push	 ebx
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 823  : 
; 824  : 		BitBlt(lpDi->hDC,0,0, ERROR_X_WIDTH, ERROR_X_HEIGHT, hdc, 0, 0, SRCCOPY);				

  00063	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  00068	57		 push	 edi
  00069	57		 push	 edi
  0006a	53		 push	 ebx
  0006b	6a 1a		 push	 26			; 0000001aH
  0006d	6a 19		 push	 25			; 00000019H

; 825  : 		DeleteDC(hdc);
; 826  : 		break;

  0006f	e9 8b 00 00 00	 jmp	 $LN23@OnDrawItem
$LN10@OnDrawItem:

; 827  : 	case IDC_SOLUTION:
; 828  : 		hdc = CreateCompatibleDC(lpDi->hDC);

  00074	ff 76 18	 push	 DWORD PTR [esi+24]
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4

; 829  : 		if( lpDi->itemState & ODS_SELECTED)

  0007d	f6 46 10 01	 test	 BYTE PTR [esi+16], 1
  00081	8b d8		 mov	 ebx, eax
  00083	74 08		 je	 SHORT $LN9@OnDrawItem

; 830  : 			SelectObject(hdc, g_hBitmapSolution[2]);

  00085	ff 35 08 00 00
	00		 push	 DWORD PTR ?g_hBitmapSolution@@3PAPAUHBITMAP__@@A+8
  0008b	eb 17		 jmp	 SHORT $LN24@OnDrawItem
$LN9@OnDrawItem:

; 831  : 		else if(g_bSolutionOver == true)

  0008d	80 3d 00 00 00
	00 01		 cmp	 BYTE PTR ?g_bSolutionOver@@3_NA, 1 ; g_bSolutionOver
  00094	75 08		 jne	 SHORT $LN7@OnDrawItem

; 832  : 			SelectObject(hdc, g_hBitmapSolution[1]);		

  00096	ff 35 04 00 00
	00		 push	 DWORD PTR ?g_hBitmapSolution@@3PAPAUHBITMAP__@@A+4

; 833  : 		else

  0009c	eb 06		 jmp	 SHORT $LN24@OnDrawItem
$LN7@OnDrawItem:

; 834  : 			SelectObject(hdc, g_hBitmapSolution[0]);

  0009e	ff 35 00 00 00
	00		 push	 DWORD PTR ?g_hBitmapSolution@@3PAPAUHBITMAP__@@A
$LN24@OnDrawItem:
  000a4	53		 push	 ebx
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 835  : 
; 836  : 		BitBlt(lpDi->hDC,0,0, ERROR_SOLUTION_WIDTH, ERROR_SOLUTION_HEIGHT, hdc, 0, 0, SRCCOPY);				

  000ab	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  000b0	57		 push	 edi
  000b1	57		 push	 edi
  000b2	53		 push	 ebx
  000b3	6a 1f		 push	 31			; 0000001fH
  000b5	68 1e 01 00 00	 push	 286			; 0000011eH

; 837  : 		DeleteDC(hdc);
; 838  : 		break;

  000ba	eb 43		 jmp	 SHORT $LN23@OnDrawItem
$LN5@OnDrawItem:

; 839  : 	case IDOK:
; 840  : 		hdc = CreateCompatibleDC(lpDi->hDC);

  000bc	ff 76 18	 push	 DWORD PTR [esi+24]
  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4

; 841  : 		if( lpDi->itemState & ODS_SELECTED)

  000c5	f6 46 10 01	 test	 BYTE PTR [esi+16], 1
  000c9	8b d8		 mov	 ebx, eax
  000cb	74 08		 je	 SHORT $LN4@OnDrawItem

; 842  : 			SelectObject(hdc, g_hBitmapExit[2]);

  000cd	ff 35 08 00 00
	00		 push	 DWORD PTR ?g_hBitmapExit@@3PAPAUHBITMAP__@@A+8
  000d3	eb 17		 jmp	 SHORT $LN25@OnDrawItem
$LN4@OnDrawItem:

; 843  : 		else if(g_bExitOver == true)

  000d5	80 3d 00 00 00
	00 01		 cmp	 BYTE PTR ?g_bExitOver@@3_NA, 1 ; g_bExitOver
  000dc	75 08		 jne	 SHORT $LN2@OnDrawItem

; 844  : 			SelectObject(hdc, g_hBitmapExit[1]);		

  000de	ff 35 04 00 00
	00		 push	 DWORD PTR ?g_hBitmapExit@@3PAPAUHBITMAP__@@A+4

; 845  : 		else

  000e4	eb 06		 jmp	 SHORT $LN25@OnDrawItem
$LN2@OnDrawItem:

; 846  : 			SelectObject(hdc, g_hBitmapExit[0]);

  000e6	ff 35 00 00 00
	00		 push	 DWORD PTR ?g_hBitmapExit@@3PAPAUHBITMAP__@@A
$LN25@OnDrawItem:
  000ec	53		 push	 ebx
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 847  : 
; 848  : 		BitBlt(lpDi->hDC,0,0, ERROR_EXIT_WIDTH, ERROR_EXIT_HEIGHT, hdc, 0, 0, SRCCOPY);				

  000f3	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  000f8	57		 push	 edi
  000f9	57		 push	 edi
  000fa	53		 push	 ebx
  000fb	6a 1f		 push	 31			; 0000001fH
  000fd	6a 58		 push	 88			; 00000058H
$LN23@OnDrawItem:
  000ff	57		 push	 edi
  00100	57		 push	 edi
  00101	ff 76 18	 push	 DWORD PTR [esi+24]
  00104	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36

; 849  : 		DeleteDC(hdc);

  0010a	53		 push	 ebx
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4
$LN21@OnDrawItem:
  00111	5b		 pop	 ebx
$LN16@OnDrawItem:
  00112	5f		 pop	 edi
  00113	5e		 pop	 esi

; 850  : 		break;
; 851  : 	}
; 852  : }

  00114	5d		 pop	 ebp
  00115	c3		 ret	 0
?OnDrawItem@@YAXJI@Z ENDP				; OnDrawItem
_TEXT	ENDS
PUBLIC	?XProc@@YGJPAUHWND__@@IIJ@Z			; XProc
EXTRN	__imp__CallWindowProcA@20:PROC
EXTRN	__imp__TrackMouseEvent@4:PROC
EXTRN	__imp__InvalidateRect@12:PROC
; Function compile flags: /Ogsp
;	COMDAT ?XProc@@YGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_tme$519707 = -16					; size = 16
_hwnd$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?XProc@@YGJPAUHWND__@@IIJ@Z PROC			; XProc, COMDAT

; 855  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 856  : 	switch(message)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _message$[ebp]
  00006	83 ec 10	 sub	 esp, 16			; 00000010H
  00009	2d 00 02 00 00	 sub	 eax, 512		; 00000200H
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR _hwnd$[ebp]
  00012	74 26		 je	 SHORT $LN3@XProc
  00014	2d a1 00 00 00	 sub	 eax, 161		; 000000a1H
  00019	74 0b		 je	 SHORT $LN2@XProc
  0001b	48		 dec	 eax
  0001c	48		 dec	 eax
  0001d	75 3d		 jne	 SHORT $LN4@XProc

; 870  : 	case WM_MOUSELEAVE:		
; 871  : 		g_bXOver = false;

  0001f	a2 00 00 00 00	 mov	 BYTE PTR ?g_bXOver@@3_NA, al ; g_bXOver

; 872  : 		InvalidateRect(hwnd, NULL, FALSE);	
; 873  : 		break;

  00024	eb 09		 jmp	 SHORT $LN8@XProc
$LN2@XProc:

; 865  : 		break;
; 866  : 	case WM_MOUSEHOVER:
; 867  : 		g_bXOver = true;

  00026	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?g_bXOver@@3_NA, 1 ; g_bXOver

; 868  : 		InvalidateRect(hwnd, NULL, FALSE);	

  0002d	33 c0		 xor	 eax, eax
$LN8@XProc:
  0002f	50		 push	 eax
  00030	50		 push	 eax
  00031	56		 push	 esi
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InvalidateRect@12

; 869  : 		break;

  00038	eb 22		 jmp	 SHORT $LN4@XProc
$LN3@XProc:

; 857  : 	{
; 858  : 	case WM_MOUSEMOVE:
; 859  : 		TRACKMOUSEEVENT tme;
; 860  : 		tme.cbSize = sizeof(tme);
; 861  : 		tme.dwFlags = TME_HOVER | TME_LEAVE; 
; 862  : 		tme.hwndTrack = hwnd;
; 863  : 		tme.dwHoverTime = 1; 
; 864  : 		TrackMouseEvent(&tme);  

  0003a	8d 45 f0	 lea	 eax, DWORD PTR _tme$519707[ebp]
  0003d	50		 push	 eax
  0003e	c7 45 f0 10 00
	00 00		 mov	 DWORD PTR _tme$519707[ebp], 16 ; 00000010H
  00045	c7 45 f4 03 00
	00 00		 mov	 DWORD PTR _tme$519707[ebp+4], 3
  0004c	89 75 f8	 mov	 DWORD PTR _tme$519707[ebp+8], esi
  0004f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _tme$519707[ebp+12], 1
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TrackMouseEvent@4
$LN4@XProc:

; 874  : 	}
; 875  : 
; 876  : 	return CallWindowProc(g_OldXProc, hwnd, message, wParam, lParam);

  0005c	ff 75 14	 push	 DWORD PTR _lParam$[ebp]
  0005f	ff 75 10	 push	 DWORD PTR _wParam$[ebp]
  00062	ff 75 0c	 push	 DWORD PTR _message$[ebp]
  00065	56		 push	 esi
  00066	ff 35 00 00 00
	00		 push	 DWORD PTR ?g_OldXProc@@3P6GJPAUHWND__@@IIJ@ZA ; g_OldXProc
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  00072	5e		 pop	 esi

; 877  : }

  00073	c9		 leave
  00074	c2 10 00	 ret	 16			; 00000010H
?XProc@@YGJPAUHWND__@@IIJ@Z ENDP			; XProc
_TEXT	ENDS
PUBLIC	?SolutionProc@@YGJPAUHWND__@@IIJ@Z		; SolutionProc
; Function compile flags: /Ogsp
;	COMDAT ?SolutionProc@@YGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_tme$519721 = -16					; size = 16
_hwnd$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?SolutionProc@@YGJPAUHWND__@@IIJ@Z PROC			; SolutionProc, COMDAT

; 880  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 881  : 	switch(message)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _message$[ebp]
  00006	83 ec 10	 sub	 esp, 16			; 00000010H
  00009	2d 00 02 00 00	 sub	 eax, 512		; 00000200H
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR _hwnd$[ebp]
  00012	74 26		 je	 SHORT $LN3@SolutionPr
  00014	2d a1 00 00 00	 sub	 eax, 161		; 000000a1H
  00019	74 0b		 je	 SHORT $LN2@SolutionPr
  0001b	48		 dec	 eax
  0001c	48		 dec	 eax
  0001d	75 3d		 jne	 SHORT $LN4@SolutionPr

; 895  : 	case WM_MOUSELEAVE:		
; 896  : 		g_bSolutionOver = false;

  0001f	a2 00 00 00 00	 mov	 BYTE PTR ?g_bSolutionOver@@3_NA, al ; g_bSolutionOver

; 897  : 		InvalidateRect(hwnd, NULL, FALSE);	
; 898  : 		break;

  00024	eb 09		 jmp	 SHORT $LN8@SolutionPr
$LN2@SolutionPr:

; 890  : 		break;
; 891  : 	case WM_MOUSEHOVER:
; 892  : 		g_bSolutionOver = true;

  00026	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?g_bSolutionOver@@3_NA, 1 ; g_bSolutionOver

; 893  : 		InvalidateRect(hwnd, NULL, FALSE);	

  0002d	33 c0		 xor	 eax, eax
$LN8@SolutionPr:
  0002f	50		 push	 eax
  00030	50		 push	 eax
  00031	56		 push	 esi
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InvalidateRect@12

; 894  : 		break;

  00038	eb 22		 jmp	 SHORT $LN4@SolutionPr
$LN3@SolutionPr:

; 882  : 	{
; 883  : 	case WM_MOUSEMOVE:
; 884  : 		TRACKMOUSEEVENT tme;
; 885  : 		tme.cbSize = sizeof(tme);
; 886  : 		tme.dwFlags = TME_HOVER | TME_LEAVE; 
; 887  : 		tme.hwndTrack = hwnd;
; 888  : 		tme.dwHoverTime = 1; 
; 889  : 		TrackMouseEvent(&tme);  

  0003a	8d 45 f0	 lea	 eax, DWORD PTR _tme$519721[ebp]
  0003d	50		 push	 eax
  0003e	c7 45 f0 10 00
	00 00		 mov	 DWORD PTR _tme$519721[ebp], 16 ; 00000010H
  00045	c7 45 f4 03 00
	00 00		 mov	 DWORD PTR _tme$519721[ebp+4], 3
  0004c	89 75 f8	 mov	 DWORD PTR _tme$519721[ebp+8], esi
  0004f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _tme$519721[ebp+12], 1
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TrackMouseEvent@4
$LN4@SolutionPr:

; 899  : 	}	
; 900  : 
; 901  : 	return CallWindowProc(g_OldXProc, hwnd, message, wParam, lParam);

  0005c	ff 75 14	 push	 DWORD PTR _lParam$[ebp]
  0005f	ff 75 10	 push	 DWORD PTR _wParam$[ebp]
  00062	ff 75 0c	 push	 DWORD PTR _message$[ebp]
  00065	56		 push	 esi
  00066	ff 35 00 00 00
	00		 push	 DWORD PTR ?g_OldXProc@@3P6GJPAUHWND__@@IIJ@ZA ; g_OldXProc
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  00072	5e		 pop	 esi

; 902  : }

  00073	c9		 leave
  00074	c2 10 00	 ret	 16			; 00000010H
?SolutionProc@@YGJPAUHWND__@@IIJ@Z ENDP			; SolutionProc
_TEXT	ENDS
PUBLIC	?ExitProc@@YGJPAUHWND__@@IIJ@Z			; ExitProc
; Function compile flags: /Ogsp
;	COMDAT ?ExitProc@@YGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_tme$519735 = -16					; size = 16
_hwnd$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?ExitProc@@YGJPAUHWND__@@IIJ@Z PROC			; ExitProc, COMDAT

; 905  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 906  : 	switch(message)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _message$[ebp]
  00006	83 ec 10	 sub	 esp, 16			; 00000010H
  00009	2d 00 02 00 00	 sub	 eax, 512		; 00000200H
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR _hwnd$[ebp]
  00012	74 26		 je	 SHORT $LN3@ExitProc
  00014	2d a1 00 00 00	 sub	 eax, 161		; 000000a1H
  00019	74 0b		 je	 SHORT $LN2@ExitProc
  0001b	48		 dec	 eax
  0001c	48		 dec	 eax
  0001d	75 3d		 jne	 SHORT $LN4@ExitProc

; 920  : 	case WM_MOUSELEAVE:		
; 921  : 		g_bExitOver = false;

  0001f	a2 00 00 00 00	 mov	 BYTE PTR ?g_bExitOver@@3_NA, al ; g_bExitOver

; 922  : 		InvalidateRect(hwnd, NULL, FALSE);	
; 923  : 		break;

  00024	eb 09		 jmp	 SHORT $LN8@ExitProc
$LN2@ExitProc:

; 915  : 		break;
; 916  : 	case WM_MOUSEHOVER:
; 917  : 		g_bExitOver = true;

  00026	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?g_bExitOver@@3_NA, 1 ; g_bExitOver

; 918  : 		InvalidateRect(hwnd, NULL, FALSE);	

  0002d	33 c0		 xor	 eax, eax
$LN8@ExitProc:
  0002f	50		 push	 eax
  00030	50		 push	 eax
  00031	56		 push	 esi
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InvalidateRect@12

; 919  : 		break;

  00038	eb 22		 jmp	 SHORT $LN4@ExitProc
$LN3@ExitProc:

; 907  : 	{
; 908  : 	case WM_MOUSEMOVE:
; 909  : 		TRACKMOUSEEVENT tme;
; 910  : 		tme.cbSize = sizeof(tme);
; 911  : 		tme.dwFlags = TME_HOVER | TME_LEAVE; 
; 912  : 		tme.hwndTrack = hwnd;
; 913  : 		tme.dwHoverTime = 1; 
; 914  : 		TrackMouseEvent(&tme);  

  0003a	8d 45 f0	 lea	 eax, DWORD PTR _tme$519735[ebp]
  0003d	50		 push	 eax
  0003e	c7 45 f0 10 00
	00 00		 mov	 DWORD PTR _tme$519735[ebp], 16 ; 00000010H
  00045	c7 45 f4 03 00
	00 00		 mov	 DWORD PTR _tme$519735[ebp+4], 3
  0004c	89 75 f8	 mov	 DWORD PTR _tme$519735[ebp+8], esi
  0004f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _tme$519735[ebp+12], 1
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TrackMouseEvent@4
$LN4@ExitProc:

; 924  : 	}
; 925  : 
; 926  : 	return CallWindowProc(g_OldXProc, hwnd, message, wParam, lParam);

  0005c	ff 75 14	 push	 DWORD PTR _lParam$[ebp]
  0005f	ff 75 10	 push	 DWORD PTR _wParam$[ebp]
  00062	ff 75 0c	 push	 DWORD PTR _message$[ebp]
  00065	56		 push	 esi
  00066	ff 35 00 00 00
	00		 push	 DWORD PTR ?g_OldXProc@@3P6GJPAUHWND__@@IIJ@ZA ; g_OldXProc
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  00072	5e		 pop	 esi

; 927  : }

  00073	c9		 leave
  00074	c2 10 00	 ret	 16			; 00000010H
?ExitProc@@YGJPAUHWND__@@IIJ@Z ENDP			; ExitProc
_TEXT	ENDS
PUBLIC	?InitOnWinMain@@YAXAAVioHashString@@@Z		; InitOnWinMain
EXTRN	__imp_?Init@ioCPU@@SAX_N@Z:PROC
EXTRN	__imp__srand:PROC
EXTRN	__imp__timeGetTime@0:PROC
EXTRN	__imp__timeBeginPeriod@4:PROC
; Function compile flags: /Ogsp
;	COMDAT ?InitOnWinMain@@YAXAAVioHashString@@@Z
_TEXT	SEGMENT
_szOptions$ = 8						; size = 4
?InitOnWinMain@@YAXAAVioHashString@@@Z PROC		; InitOnWinMain, COMDAT

; 931  : 	timeBeginPeriod(1);

  00000	6a 01		 push	 1
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeBeginPeriod@4

; 932  : 	srand( timeGetTime() );	

  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  0000e	50		 push	 eax
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__srand

; 933  : 
; 934  : #ifndef SHIPPING		
; 935  : 	if( szOptions.IsEmpty() || szOptions.At(CLogin::OT_SHOW_CONSOLWINDOW) != '0')
; 936  : 	{		
; 937  : 		LOG.OpenConsole( 1 );
; 938  : 	}
; 939  : #endif // SHIPPING
; 940  : 
; 941  : 	ioCPU::Init();

  00015	6a 00		 push	 0
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Init@ioCPU@@SAX_N@Z
  0001d	59		 pop	 ecx
  0001e	59		 pop	 ecx

; 942  : }

  0001f	c3		 ret	 0
?InitOnWinMain@@YAXAAVioHashString@@@Z ENDP		; InitOnWinMain
_TEXT	ENDS
PUBLIC	?RelaseOnWinMain@@YAXPAVioApplication@@@Z	; RelaseOnWinMain
EXTRN	__imp__timeEndPeriod@4:PROC
EXTRN	__imp_?CloseAndRelease@CLog@@QAEXXZ:PROC
EXTRN	__imp_?LOG@@3VCLog@@A:BYTE
EXTRN	__imp_?ReleaseInstance@ioResourceLoader@@SAXXZ:PROC
EXTRN	__imp_?ShotDown@ioCPU@@SAXXZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ?RelaseOnWinMain@@YAXPAVioApplication@@@Z
_TEXT	SEGMENT
_pApp$ = 8						; size = 4
?RelaseOnWinMain@@YAXPAVioApplication@@@Z PROC		; RelaseOnWinMain, COMDAT

; 948  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 949  : 	SAFEDELETE( pApp );

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pApp$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 06		 je	 SHORT $LN4@RelaseOnWi
  0000a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000c	6a 01		 push	 1
  0000e	ff 10		 call	 DWORD PTR [eax]
$LN4@RelaseOnWi:

; 950  : 
; 951  : 	ioCPU::ShotDown();

  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ShotDown@ioCPU@@SAXXZ

; 952  : 	ioResourceLoader::ReleaseInstance();

  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ReleaseInstance@ioResourceLoader@@SAXXZ

; 953  : 
; 954  : 	LOG.CloseAndRelease();

  0001c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?LOG@@3VCLog@@A
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?CloseAndRelease@CLog@@QAEXXZ

; 955  : 	timeEndPeriod(1);

  00028	6a 01		 push	 1
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeEndPeriod@4

; 956  : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?RelaseOnWinMain@@YAXPAVioApplication@@@Z ENDP		; RelaseOnWinMain
_TEXT	ENDS
PUBLIC	??_C@_0BH@CENBOLNM@_LOSTSAGA_AUTOUPGRADE_?$AA@	; `string'
PUBLIC	?SendMsgToAutoUpgrade@@YAXK@Z			; SendMsgToAutoUpgrade
EXTRN	__imp__SendMessageA@16:PROC
EXTRN	__imp__FindWindowA@8:PROC
;	COMDAT ?cds@?4??SendMsgToAutoUpgrade@@YAXK@Z@4UtagCOPYDATASTRUCT@@A
_BSS	SEGMENT
?cds@?4??SendMsgToAutoUpgrade@@YAXK@Z@4UtagCOPYDATASTRUCT@@A DB 0cH DUP (?) ; `SendMsgToAutoUpgrade'::`5'::cds
_BSS	ENDS
;	COMDAT ??_C@_0BH@CENBOLNM@_LOSTSAGA_AUTOUPGRADE_?$AA@
CONST	SEGMENT
??_C@_0BH@CENBOLNM@_LOSTSAGA_AUTOUPGRADE_?$AA@ DB '_LOSTSAGA_AUTOUPGRADE_'
	DB	00H						; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?SendMsgToAutoUpgrade@@YAXK@Z
_TEXT	SEGMENT
_dwWMTYPE$ = 8						; size = 4
?SendMsgToAutoUpgrade@@YAXK@Z PROC			; SendMsgToAutoUpgrade, COMDAT

; 959  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 960  : 	HWND hWnd = FindWindow(AUTPUPGRADE_CLASS_NAME,NULL);

  00003	6a 00		 push	 0
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@CENBOLNM@_LOSTSAGA_AUTOUPGRADE_?$AA@
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindWindowA@8

; 961  : 	if(hWnd != NULL)

  00010	85 c0		 test	 eax, eax
  00012	74 27		 je	 SHORT $LN1@SendMsgToA

; 962  : 	{
; 963  : 		static COPYDATASTRUCT cds;
; 964  : 		cds.dwData = dwWMTYPE;

  00014	8b 4d 08	 mov	 ecx, DWORD PTR _dwWMTYPE$[ebp]

; 965  : 		cds.cbData = 0;

  00017	83 25 04 00 00
	00 00		 and	 DWORD PTR ?cds@?4??SendMsgToAutoUpgrade@@YAXK@Z@4UtagCOPYDATASTRUCT@@A+4, 0

; 966  : 		cds.lpData = NULL;

  0001e	83 25 08 00 00
	00 00		 and	 DWORD PTR ?cds@?4??SendMsgToAutoUpgrade@@YAXK@Z@4UtagCOPYDATASTRUCT@@A+8, 0

; 967  : 		SendMessage(hWnd, WM_COPYDATA, 0,(LPARAM)&cds);

  00025	68 00 00 00 00	 push	 OFFSET ?cds@?4??SendMsgToAutoUpgrade@@YAXK@Z@4UtagCOPYDATASTRUCT@@A
  0002a	6a 00		 push	 0
  0002c	6a 4a		 push	 74			; 0000004aH
  0002e	50		 push	 eax
  0002f	89 0d 00 00 00
	00		 mov	 DWORD PTR ?cds@?4??SendMsgToAutoUpgrade@@YAXK@Z@4UtagCOPYDATASTRUCT@@A, ecx
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
$LN1@SendMsgToA:

; 968  : 	}
; 969  : }

  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?SendMsgToAutoUpgrade@@YAXK@Z ENDP			; SendMsgToAutoUpgrade
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?AllowAccessibilityShortcutKeys@@YAX_N@Z	; AllowAccessibilityShortcutKeys
EXTRN	__imp__SystemParametersInfoA@16:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogsp
;	COMDAT ?AllowAccessibilityShortcutKeys@@YAX_N@Z
_TEXT	SEGMENT
_skOff$519763 = -36					; size = 8
_fkOff$519766 = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
_bAllowKeys$ = 8					; size = 1
?AllowAccessibilityShortcutKeys@@YAX_N@Z PROC		; AllowAccessibilityShortcutKeys, COMDAT

; 972  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 973  :     if( bAllowKeys )

  00010	80 7d 08 00	 cmp	 BYTE PTR _bAllowKeys$[ebp], 0
  00014	56		 push	 esi
  00015	74 22		 je	 SHORT $LN4@AllowAcces

; 974  :     {
; 975  :         // 초기값으로 복귀
; 976  :         SystemParametersInfo(SPI_SETSTICKYKEYS, sizeof(STICKYKEYS), &g_StartupStickyKeys, 0);

  00017	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SystemParametersInfoA@16
  0001d	6a 00		 push	 0
  0001f	68 00 00 00 00	 push	 OFFSET ?g_StartupStickyKeys@@3UtagSTICKYKEYS@@A ; g_StartupStickyKeys
  00024	6a 08		 push	 8
  00026	6a 3b		 push	 59			; 0000003bH
  00028	ff d6		 call	 esi

; 977  :         SystemParametersInfo(SPI_SETFILTERKEYS, sizeof(FILTERKEYS), &g_StartupFilterKeys, 0);

  0002a	6a 00		 push	 0
  0002c	68 00 00 00 00	 push	 OFFSET ?g_StartupFilterKeys@@3UtagFILTERKEYS@@A ; g_StartupFilterKeys
  00031	6a 18		 push	 24			; 00000018H
  00033	6a 33		 push	 51			; 00000033H
  00035	ff d6		 call	 esi

; 978  :     }
; 979  :     else

  00037	eb 51		 jmp	 SHORT $LN1@AllowAcces
$LN4@AllowAcces:

; 980  :     {
; 981  :         // 불가상태로 전환
; 982  :          STICKYKEYS skOff = g_StartupStickyKeys;

  00039	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_StartupStickyKeys@@3UtagSTICKYKEYS@@A
  0003e	89 45 dc	 mov	 DWORD PTR _skOff$519763[ebp], eax
  00041	a1 04 00 00 00	 mov	 eax, DWORD PTR ?g_StartupStickyKeys@@3UtagSTICKYKEYS@@A+4
  00046	53		 push	 ebx

; 983  : 
; 984  : 		if( (skOff.dwFlags & SKF_STICKYKEYSON) == 0 )

  00047	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__SystemParametersInfoA@16
  0004d	89 45 e0	 mov	 DWORD PTR _skOff$519763[ebp+4], eax
  00050	a8 01		 test	 al, 1
  00052	75 10		 jne	 SHORT $LN2@AllowAcces

; 985  : 		{
; 986  : 			// Disable the hotkey
; 987  : 			skOff.dwFlags &= ~SKF_HOTKEYACTIVE;

  00054	83 65 e0 fb	 and	 DWORD PTR _skOff$519763[ebp+4], -5 ; fffffffbH

; 988  : 	 
; 989  : 			SystemParametersInfo(SPI_SETSTICKYKEYS, sizeof(STICKYKEYS), &skOff, 0);

  00058	6a 00		 push	 0
  0005a	8d 45 dc	 lea	 eax, DWORD PTR _skOff$519763[ebp]
  0005d	50		 push	 eax
  0005e	6a 08		 push	 8
  00060	6a 3b		 push	 59			; 0000003bH
  00062	ff d3		 call	 ebx
$LN2@AllowAcces:

; 990  : 		}
; 991  :  
; 992  :         FILTERKEYS fkOff = g_StartupFilterKeys;

  00064	57		 push	 edi
  00065	6a 06		 push	 6
  00067	59		 pop	 ecx
  00068	be 00 00 00 00	 mov	 esi, OFFSET ?g_StartupFilterKeys@@3UtagFILTERKEYS@@A ; g_StartupFilterKeys
  0006d	8d 7d e4	 lea	 edi, DWORD PTR _fkOff$519766[ebp]
  00070	f3 a5		 rep movsd

; 993  : 
; 994  : 		if( (fkOff.dwFlags & FKF_FILTERKEYSON) == 0 )

  00072	f6 45 e8 01	 test	 BYTE PTR _fkOff$519766[ebp+4], 1
  00076	5f		 pop	 edi
  00077	75 10		 jne	 SHORT $LN7@AllowAcces

; 995  : 		{
; 996  : 			// Disable the hotkey
; 997  : 			fkOff.dwFlags &= ~FKF_HOTKEYACTIVE;

  00079	83 65 e8 fb	 and	 DWORD PTR _fkOff$519766[ebp+4], -5 ; fffffffbH

; 998  : 	 
; 999  : 			SystemParametersInfo(SPI_SETFILTERKEYS, sizeof(FILTERKEYS), &fkOff, 0);

  0007d	6a 00		 push	 0
  0007f	8d 45 e4	 lea	 eax, DWORD PTR _fkOff$519766[ebp]
  00082	50		 push	 eax
  00083	6a 18		 push	 24			; 00000018H
  00085	6a 33		 push	 51			; 00000033H
  00087	ff d3		 call	 ebx
$LN7@AllowAcces:
  00089	5b		 pop	 ebx
$LN1@AllowAcces:

; 1000 : 		}
; 1001 :     }
; 1002 : }

  0008a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008d	33 cd		 xor	 ecx, ebp
  0008f	5e		 pop	 esi
  00090	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00095	c9		 leave
  00096	c3		 ret	 0
?AllowAccessibilityShortcutKeys@@YAX_N@Z ENDP		; AllowAccessibilityShortcutKeys
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?trimProcessWorkingSet@@YAXK@Z			; trimProcessWorkingSet
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__GlobalFree@4:PROC
EXTRN	_EmptyWorkingSet@4:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__GlobalAlloc@8:PROC
EXTRN	__imp__LookupAccountSidA@28:PROC
EXTRN	__imp__GetSecurityInfo@32:PROC
EXTRN	_GetModuleBaseNameA@16:PROC
EXTRN	_EnumProcessModules@16:PROC
EXTRN	__imp__OpenProcess@12:PROC
EXTRN	__imp__GetCurrentProcessId@0:PROC
EXTRN	__chkstk:PROC
; Function compile flags: /Ogsp
;	COMDAT ?trimProcessWorkingSet@@YAXK@Z
_TEXT	SEGMENT
_hMods$ = -4388						; size = 4096
_cbNeeded$ = -292					; size = 4
_pSD$519791 = -288					; size = 4
_dwDomainName$519795 = -284				; size = 4
_eUse$519796 = -280					; size = 4
_hProcess$ = -276					; size = 4
_dwAcctName$519794 = -272				; size = 4
_pSidOwner$519790 = -268				; size = 4
_szModBaseName$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_processID$ = 8						; size = 4
?trimProcessWorkingSet@@YAXK@Z PROC			; trimProcessWorkingSet, COMDAT

; 1025 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 24 11 00 00	 mov	 eax, 4388		; 00001124H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	56		 push	 esi
  00018	8b 75 08	 mov	 esi, DWORD PTR _processID$[ebp]

; 1026 : 	if (processID == GetCurrentProcessId())

  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcessId@0
  00021	3b f0		 cmp	 esi, eax
  00023	0f 84 22 01 00
	00		 je	 $LN8@trimProces

; 1027 : 		return;
; 1028 : 
; 1029 : 	// Get a handle to the process.
; 1030 : 	HANDLE hProcess = OpenProcess( PROCESS_SET_QUOTA |
; 1031 : 		PROCESS_QUERY_INFORMATION |
; 1032 : 		PROCESS_VM_READ,
; 1033 : 		FALSE, processID );

  00029	57		 push	 edi
  0002a	56		 push	 esi
  0002b	33 f6		 xor	 esi, esi
  0002d	56		 push	 esi
  0002e	68 10 05 00 00	 push	 1296			; 00000510H
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenProcess@12
  00039	8b f8		 mov	 edi, eax
  0003b	89 bd ec fe ff
	ff		 mov	 DWORD PTR _hProcess$[ebp], edi

; 1034 : 	if (!hProcess)

  00041	3b fe		 cmp	 edi, esi
  00043	0f 84 01 01 00
	00		 je	 $LN11@trimProces

; 1035 : 		return;
; 1036 : 
; 1037 : 	HMODULE hMods[1024];
; 1038 : 	DWORD cbNeeded;
; 1039 : 	//char szModName[MAX_PATH];
; 1040 : 	char szModBaseName[MAX_PATH];
; 1041 : 
; 1042 : 	// 가져올 수 있는 모듈에서만
; 1043 : 	if( EnumProcessModules( hProcess, hMods, sizeof(hMods), &cbNeeded ) )

  00049	53		 push	 ebx
  0004a	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _cbNeeded$[ebp]
  00050	50		 push	 eax
  00051	68 00 10 00 00	 push	 4096			; 00001000H
  00056	8d 85 dc ee ff
	ff		 lea	 eax, DWORD PTR _hMods$[ebp]
  0005c	50		 push	 eax
  0005d	57		 push	 edi
  0005e	e8 00 00 00 00	 call	 _EnumProcessModules@16
  00063	85 c0		 test	 eax, eax
  00065	0f 84 d2 00 00
	00		 je	 $LN10@trimProces

; 1044 : 	{
; 1045 : 		//bGetBaseName = true;
; 1046 : 		GetModuleBaseName(hProcess, hMods[0], szModBaseName, sizeof(szModBaseName) );

  0006b	68 04 01 00 00	 push	 260			; 00000104H
  00070	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szModBaseName$[ebp]
  00076	50		 push	 eax
  00077	ff b5 dc ee ff
	ff		 push	 DWORD PTR _hMods$[ebp]
  0007d	57		 push	 edi
  0007e	e8 00 00 00 00	 call	 _GetModuleBaseNameA@16

; 1047 : 
; 1048 : 		PSID pSidOwner = NULL;
; 1049 : 		PSECURITY_DESCRIPTOR pSD = NULL;
; 1050 : 		LPTSTR AcctName = NULL;
; 1051 : 		LPTSTR DomainName = NULL;
; 1052 : 		DWORD dwAcctName = 1, dwDomainName = 1;
; 1053 : 		SID_NAME_USE eUse = SidTypeUnknown;
; 1054 : 
; 1055 : 		BOOL dwRtnCode = GetSecurityInfo(
; 1056 : 			hProcess,
; 1057 : 			SE_FILE_OBJECT,
; 1058 : 			OWNER_SECURITY_INFORMATION,
; 1059 : 			&pSidOwner,
; 1060 : 			NULL,
; 1061 : 			NULL,
; 1062 : 			NULL,
; 1063 : 			&pSD);

  00083	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _pSD$519791[ebp]
  00089	51		 push	 ecx
  0008a	56		 push	 esi
  0008b	56		 push	 esi
  0008c	56		 push	 esi
  0008d	33 c0		 xor	 eax, eax
  0008f	40		 inc	 eax
  00090	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _pSidOwner$519790[ebp]
  00096	51		 push	 ecx
  00097	50		 push	 eax
  00098	50		 push	 eax
  00099	57		 push	 edi
  0009a	89 b5 f4 fe ff
	ff		 mov	 DWORD PTR _pSidOwner$519790[ebp], esi
  000a0	89 b5 e0 fe ff
	ff		 mov	 DWORD PTR _pSD$519791[ebp], esi
  000a6	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _dwAcctName$519794[ebp], eax
  000ac	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _dwDomainName$519795[ebp], eax
  000b2	c7 85 e8 fe ff
	ff 08 00 00 00	 mov	 DWORD PTR _eUse$519796[ebp], 8
  000bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSecurityInfo@32

; 1064 : 		if( dwRtnCode == ERROR_SUCCESS )

  000c2	85 c0		 test	 eax, eax
  000c4	75 77		 jne	 SHORT $LN10@trimProces

; 1065 : 		{
; 1066 : 			BOOL bRtnBool = LookupAccountSid(
; 1067 : 				NULL,           // local computer
; 1068 : 				pSidOwner,
; 1069 : 				AcctName,
; 1070 : 				(LPDWORD)&dwAcctName,
; 1071 : 				DomainName,
; 1072 : 				(LPDWORD)&dwDomainName,
; 1073 : 				&eUse);

  000c6	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__LookupAccountSidA@28
  000cc	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _eUse$519796[ebp]
  000d2	50		 push	 eax
  000d3	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _dwDomainName$519795[ebp]
  000d9	50		 push	 eax
  000da	56		 push	 esi
  000db	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _dwAcctName$519794[ebp]
  000e1	50		 push	 eax
  000e2	56		 push	 esi
  000e3	ff b5 f4 fe ff
	ff		 push	 DWORD PTR _pSidOwner$519790[ebp]
  000e9	56		 push	 esi
  000ea	ff d7		 call	 edi

; 1074 : 
; 1075 : 			AcctName = (LPTSTR)GlobalAlloc(
; 1076 : 				GMEM_FIXED,
; 1077 : 				dwAcctName);

  000ec	ff b5 f0 fe ff
	ff		 push	 DWORD PTR _dwAcctName$519794[ebp]
  000f2	56		 push	 esi
  000f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalAlloc@8
  000f9	8b d8		 mov	 ebx, eax

; 1078 : 
; 1079 : 			// Check GetLastError for GlobalAlloc error condition.
; 1080 : 			if (AcctName == NULL) {

  000fb	3b de		 cmp	 ebx, esi
  000fd	75 08		 jne	 SHORT $LN3@trimProces

; 1081 : 				DWORD dwErrorCode = 0;
; 1082 : 				dwErrorCode = GetLastError();

  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 1083 : 				return;

  00105	eb 42		 jmp	 SHORT $LN12@trimProces
$LN3@trimProces:

; 1084 : 			}
; 1085 : 
; 1086 : 			// Second call to LookupAccountSid to get the account name.
; 1087 : 			bRtnBool = LookupAccountSid(
; 1088 : 				NULL,                   // name of local or remote computer
; 1089 : 				pSidOwner,              // security identifier
; 1090 : 				AcctName,               // account name buffer
; 1091 : 				(LPDWORD)&dwAcctName,   // size of account name buffer 
; 1092 : 				DomainName,             // domain name
; 1093 : 				(LPDWORD)&dwDomainName, // size of domain name buffer
; 1094 : 				&eUse);

  00107	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _eUse$519796[ebp]
  0010d	50		 push	 eax
  0010e	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _dwDomainName$519795[ebp]
  00114	50		 push	 eax
  00115	56		 push	 esi
  00116	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _dwAcctName$519794[ebp]
  0011c	50		 push	 eax
  0011d	53		 push	 ebx
  0011e	ff b5 f4 fe ff
	ff		 push	 DWORD PTR _pSidOwner$519790[ebp]
  00124	56		 push	 esi
  00125	ff d7		 call	 edi

; 1095 : 
; 1096 : 			//테스트로는 Admin껏만 들어오지만 혹시 모르니..
; 1097 : 			if( bRtnBool )

  00127	85 c0		 test	 eax, eax
  00129	74 12		 je	 SHORT $LN10@trimProces

; 1098 : 			{
; 1099 : 				//기본적으로 Admin것만 넘어오지만 혹시 몰라서 체크 넣었다가 뺌
; 1100 : 				//const char admin[] = "Administrators";
; 1101 : 				if( AcctName /*&& (strcmp( AcctName,admin )==0)*/  )
; 1102 : 				{	
; 1103 : 					EmptyWorkingSet(hProcess);

  0012b	ff b5 ec fe ff
	ff		 push	 DWORD PTR _hProcess$[ebp]
  00131	e8 00 00 00 00	 call	 _EmptyWorkingSet@4

; 1104 : 					GlobalFree(AcctName);

  00136	53		 push	 ebx
  00137	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4
$LN10@trimProces:

; 1105 : 				}
; 1106 : 			}
; 1107 : 		}
; 1108 : 	}
; 1109 : 
; 1110 : 	//////////////////////////////////////////////////////////////////////////
; 1111 : 
; 1112 : 	CloseHandle( hProcess );

  0013d	ff b5 ec fe ff
	ff		 push	 DWORD PTR _hProcess$[ebp]
  00143	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN12@trimProces:
  00149	5b		 pop	 ebx
$LN11@trimProces:
  0014a	5f		 pop	 edi
$LN8@trimProces:

; 1113 : }

  0014b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014e	33 cd		 xor	 ecx, ebp
  00150	5e		 pop	 esi
  00151	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00156	c9		 leave
  00157	c3		 ret	 0
?trimProcessWorkingSet@@YAXK@Z ENDP			; trimProcessWorkingSet
_TEXT	ENDS
PUBLIC	_hToken$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?SetPrivilege@@YAHPAXPBDH@Z			; SetPrivilege
EXTRN	__imp__AdjustTokenPrivileges@24:PROC
EXTRN	__imp__LookupPrivilegeValueA@12:PROC
; Function compile flags: /Ogsp
;	COMDAT ?SetPrivilege@@YAHPAXPBDH@Z
_TEXT	SEGMENT
_hToken$GSCopy$ = -52					; size = 4
_luid$ = -48						; size = 8
_cbPrevious$ = -40					; size = 4
_tp$ = -36						; size = 16
_tpPrevious$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_hToken$ = 8						; size = 4
_Privilege$ = 12					; size = 4
_bEnablePrivilege$ = 16					; size = 4
?SetPrivilege@@YAHPAXPBDH@Z PROC			; SetPrivilege, COMDAT

; 1182 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _Privilege$[ebp]
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _hToken$[ebp]

; 1183 : 	TOKEN_PRIVILEGES tp;
; 1184 : 	LUID luid;
; 1185 : 	TOKEN_PRIVILEGES tpPrevious;
; 1186 : 	DWORD cbPrevious=sizeof(TOKEN_PRIVILEGES);
; 1187 : 
; 1188 : 	if(!LookupPrivilegeValue( NULL, Privilege, &luid )) return FALSE;

  00018	8d 4d d0	 lea	 ecx, DWORD PTR _luid$[ebp]
  0001b	51		 push	 ecx
  0001c	50		 push	 eax
  0001d	33 db		 xor	 ebx, ebx
  0001f	53		 push	 ebx

; 1205 : 
; 1206 : 			return FALSE;
; 1207 : 	}
; 1208 : 
; 1209 : 	//
; 1210 : 	// second pass.  set privilege based on previous setting
; 1211 : 	//
; 1212 : 	tpPrevious.PrivilegeCount       = 1;

  00020	89 75 cc	 mov	 DWORD PTR _hToken$GSCopy$[ebp], esi
  00023	c7 45 d8 10 00
	00 00		 mov	 DWORD PTR _cbPrevious$[ebp], 16 ; 00000010H
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LookupPrivilegeValueA@12
  00030	85 c0		 test	 eax, eax
  00032	74 5e		 je	 SHORT $LN5@SetPrivile
$LN4@SetPrivile:

; 1189 : 
; 1190 : 	//
; 1191 : 	// first pass.  get current privilege setting
; 1192 : 	//
; 1193 : 	tp.PrivilegeCount           = 1;
; 1194 : 	tp.Privileges[0].Luid       = luid;

  00034	8b 45 d0	 mov	 eax, DWORD PTR _luid$[ebp]
  00037	57		 push	 edi
  00038	89 45 e0	 mov	 DWORD PTR _tp$[ebp+4], eax
  0003b	8b 45 d4	 mov	 eax, DWORD PTR _luid$[ebp+4]
  0003e	89 45 e4	 mov	 DWORD PTR _tp$[ebp+8], eax

; 1195 : 	tp.Privileges[0].Attributes = 0;
; 1196 : 
; 1197 : 	if( !AdjustTokenPrivileges(
; 1198 : 		hToken,
; 1199 : 		FALSE,
; 1200 : 		&tp,
; 1201 : 		sizeof(TOKEN_PRIVILEGES),
; 1202 : 		&tpPrevious,
; 1203 : 		&cbPrevious
; 1204 : 		)) {

  00041	8d 45 d8	 lea	 eax, DWORD PTR _cbPrevious$[ebp]
  00044	50		 push	 eax
  00045	8d 45 ec	 lea	 eax, DWORD PTR _tpPrevious$[ebp]
  00048	50		 push	 eax
  00049	6a 10		 push	 16			; 00000010H
  0004b	8d 45 dc	 lea	 eax, DWORD PTR _tp$[ebp]
  0004e	50		 push	 eax
  0004f	53		 push	 ebx
  00050	33 ff		 xor	 edi, edi
  00052	56		 push	 esi
  00053	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__AdjustTokenPrivileges@24
  00059	47		 inc	 edi
  0005a	89 7d dc	 mov	 DWORD PTR _tp$[ebp], edi
  0005d	89 5d e8	 mov	 DWORD PTR _tp$[ebp+12], ebx
  00060	ff d6		 call	 esi
  00062	85 c0		 test	 eax, eax
  00064	74 2b		 je	 SHORT $LN7@SetPrivile
$LN3@SetPrivile:

; 1213 : 	tpPrevious.Privileges[0].Luid   = luid;

  00066	8b 45 d0	 mov	 eax, DWORD PTR _luid$[ebp]
  00069	89 45 f0	 mov	 DWORD PTR _tpPrevious$[ebp+4], eax
  0006c	8b 45 d4	 mov	 eax, DWORD PTR _luid$[ebp+4]
  0006f	89 45 f4	 mov	 DWORD PTR _tpPrevious$[ebp+8], eax

; 1214 : 	tpPrevious.Privileges[0].Attributes  = 0;
; 1215 : 
; 1216 : 	if(bEnablePrivilege) {

  00072	8b 45 10	 mov	 eax, DWORD PTR _bEnablePrivilege$[ebp]
  00075	f7 d8		 neg	 eax

; 1217 : 		tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
; 1218 : 	}
; 1219 : 	else {
; 1220 : 		tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED &
; 1221 : 			tpPrevious.Privileges[0].Attributes);
; 1222 : 	}
; 1223 : 
; 1224 : 	return AdjustTokenPrivileges(
; 1225 : 		hToken,
; 1226 : 		FALSE,
; 1227 : 		&tpPrevious,
; 1228 : 		cbPrevious,
; 1229 : 		NULL,
; 1230 : 		NULL
; 1231 : 		);

  00077	53		 push	 ebx
  00078	1b c0		 sbb	 eax, eax
  0007a	53		 push	 ebx
  0007b	ff 75 d8	 push	 DWORD PTR _cbPrevious$[ebp]
  0007e	83 e0 02	 and	 eax, 2
  00081	89 45 f8	 mov	 DWORD PTR _tpPrevious$[ebp+12], eax
  00084	8d 45 ec	 lea	 eax, DWORD PTR _tpPrevious$[ebp]
  00087	50		 push	 eax
  00088	53		 push	 ebx
  00089	ff 75 cc	 push	 DWORD PTR _hToken$GSCopy$[ebp]
  0008c	89 7d ec	 mov	 DWORD PTR _tpPrevious$[ebp], edi
  0008f	ff d6		 call	 esi
$LN7@SetPrivile:
  00091	5f		 pop	 edi
$LN5@SetPrivile:

; 1232 : }

  00092	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00095	5e		 pop	 esi
  00096	33 cd		 xor	 ecx, ebp
  00098	5b		 pop	 ebx
  00099	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009e	c9		 leave
  0009f	c3		 ret	 0
?SetPrivilege@@YAHPAXPBDH@Z ENDP			; SetPrivilege
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft sdks\windows\v7.0a\include\strsafe.h
_TEXT	ENDS
;	COMDAT ?StringValidateDestA@@YGJPBDII@Z
_TEXT	SEGMENT
_cchMax$ = 8						; size = 4
?StringValidateDestA@@YGJPBDII@Z PROC			; StringValidateDestA, COMDAT
; _cchDest$ = ecx

; 8721 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 8722 :     HRESULT hr = S_OK;

  00003	33 c0		 xor	 eax, eax

; 8723 : 
; 8724 :     if ((cchDest == 0) || (cchDest > cchMax))

  00005	85 c9		 test	 ecx, ecx
  00007	74 05		 je	 SHORT $LN1@StringVali
  00009	3b 4d 08	 cmp	 ecx, DWORD PTR _cchMax$[ebp]
  0000c	76 05		 jbe	 SHORT $LN2@StringVali
$LN1@StringVali:

; 8725 :     {
; 8726 :         hr = STRSAFE_E_INVALID_PARAMETER;

  0000e	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
$LN2@StringVali:

; 8727 :     }
; 8728 : 
; 8729 :     return hr;
; 8730 : }

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?StringValidateDestA@@YGJPBDII@Z ENDP			; StringValidateDestA
_TEXT	ENDS
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Ogsp
;	COMDAT ?StringVPrintfWorkerA@@YGJPADIPAIPBD0@Z
_TEXT	SEGMENT
_pcchNewDestLength$ = 8					; size = 4
_pszFormat$ = 12					; size = 4
_argList$ = 16						; size = 4
?StringVPrintfWorkerA@@YGJPADIPAIPBD0@Z PROC		; StringVPrintfWorkerA, COMDAT
; _pszDest$ = edi
; _cchDest$ = eax

; 9029 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 9030 :     HRESULT hr = S_OK;
; 9031 :     int iRet;
; 9032 :     size_t cchMax;
; 9033 :     size_t cchNewDestLength = 0;
; 9034 : 
; 9035 :     // leave the last space for the null terminator
; 9036 :     cchMax = cchDest - 1;
; 9037 : 
; 9038 : #if (STRSAFE_USE_SECURE_CRT == 1) && !defined(STRSAFE_LIB_IMPL)
; 9039 :     iRet = _vsnprintf_s(pszDest, cchDest, cchMax, pszFormat, argList);
; 9040 : #else
; 9041 :     #pragma warning(push)
; 9042 :     #pragma warning(disable: __WARNING_BANNED_API_USAGE)// "STRSAFE not included"
; 9043 :     iRet = _vsnprintf(pszDest, cchMax, pszFormat, argList);

  00005	ff 75 10	 push	 DWORD PTR _argList$[ebp]
  00008	8d 70 ff	 lea	 esi, DWORD PTR [eax-1]
  0000b	ff 75 0c	 push	 DWORD PTR _pszFormat$[ebp]
  0000e	33 db		 xor	 ebx, ebx
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___vsnprintf
  00018	83 c4 10	 add	 esp, 16			; 00000010H

; 9044 :     #pragma warning(pop)
; 9045 : #endif
; 9046 :     // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));
; 9047 : 
; 9048 :     if ((iRet < 0) || (((size_t)iRet) > cchMax))

  0001b	85 c0		 test	 eax, eax
  0001d	78 0b		 js	 SHORT $LN5@StringVPri
  0001f	3b c6		 cmp	 eax, esi
  00021	77 07		 ja	 SHORT $LN5@StringVPri

; 9058 :     }
; 9059 :     else if (((size_t)iRet) == cchMax)

  00023	75 0f		 jne	 SHORT $LN2@StringVPri

; 9060 :     {
; 9061 :         // need to null terminate the string
; 9062 :         pszDest += cchMax;
; 9063 :         *pszDest = '\0';

  00025	88 1c 3e	 mov	 BYTE PTR [esi+edi], bl

; 9064 : 
; 9065 :         cchNewDestLength = cchMax;
; 9066 :     }
; 9067 :     else

  00028	eb 08		 jmp	 SHORT $LN9@StringVPri
$LN5@StringVPri:

; 9049 :     {
; 9050 :         // need to null terminate the string
; 9051 :         pszDest += cchMax;
; 9052 :         *pszDest = '\0';

  0002a	88 1c 3e	 mov	 BYTE PTR [esi+edi], bl

; 9055 : 
; 9056 :         // we have truncated pszDest
; 9057 :         hr = STRSAFE_E_INSUFFICIENT_BUFFER;

  0002d	bb 7a 00 07 80	 mov	 ebx, -2147024774	; 8007007aH
$LN9@StringVPri:

; 9053 : 
; 9054 :         cchNewDestLength = cchMax;

  00032	8b c6		 mov	 eax, esi
$LN2@StringVPri:

; 9068 :     {
; 9069 :         cchNewDestLength = (size_t)iRet;
; 9070 :     }
; 9071 : 
; 9072 :     if (pcchNewDestLength)

  00034	8b 4d 08	 mov	 ecx, DWORD PTR _pcchNewDestLength$[ebp]
  00037	85 c9		 test	 ecx, ecx
  00039	74 02		 je	 SHORT $LN1@StringVPri

; 9073 :     {
; 9074 :         *pcchNewDestLength = cchNewDestLength;

  0003b	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@StringVPri:
  0003d	5e		 pop	 esi

; 9075 :     }
; 9076 : 
; 9077 :     return hr;

  0003e	8b c3		 mov	 eax, ebx
  00040	5b		 pop	 ebx

; 9078 : }

  00041	5d		 pop	 ebp
  00042	c2 0c 00	 ret	 12			; 0000000cH
?StringVPrintfWorkerA@@YGJPADIPAIPBD0@Z ENDP		; StringVPrintfWorkerA
_TEXT	ENDS
PUBLIC	?GetFullSystemInfo@Setting@@SAPADXZ		; Setting::GetFullSystemInfo
EXTRN	?m_szFullSystemInfo@Setting@@1PADA:BYTE		; Setting::m_szFullSystemInfo
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\setting.h
;	COMDAT ?GetFullSystemInfo@Setting@@SAPADXZ
_TEXT	SEGMENT
?GetFullSystemInfo@Setting@@SAPADXZ PROC		; Setting::GetFullSystemInfo, COMDAT

; 170  : 	static char* GetFullSystemInfo() { return m_szFullSystemInfo; }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?m_szFullSystemInfo@Setting@@1PADA ; Setting::m_szFullSystemInfo
  00005	c3		 ret	 0
?GetFullSystemInfo@Setting@@SAPADXZ ENDP		; Setting::GetFullSystemInfo
_TEXT	ENDS
PUBLIC	?IsWin98Series@Setting@@SA_NXZ			; Setting::IsWin98Series
EXTRN	?m_bWin98Series@Setting@@1_NA:BYTE		; Setting::m_bWin98Series
; Function compile flags: /Ogsp
;	COMDAT ?IsWin98Series@Setting@@SA_NXZ
_TEXT	SEGMENT
?IsWin98Series@Setting@@SA_NXZ PROC			; Setting::IsWin98Series, COMDAT

; 171  : 	static bool IsWin98Series() { return m_bWin98Series; }

  00000	a0 00 00 00 00	 mov	 al, BYTE PTR ?m_bWin98Series@Setting@@1_NA ; Setting::m_bWin98Series
  00005	c3		 ret	 0
?IsWin98Series@Setting@@SA_NXZ ENDP			; Setting::IsWin98Series
_TEXT	ENDS
PUBLIC	?GetHWnd@ioApplication@@QBEPAUHWND__@@XZ	; ioApplication::GetHWnd
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioapplication.h
;	COMDAT ?GetHWnd@ioApplication@@QBEPAUHWND__@@XZ
_TEXT	SEGMENT
?GetHWnd@ioApplication@@QBEPAUHWND__@@XZ PROC		; ioApplication::GetHWnd, COMDAT
; _this$ = ecx

; 686  : 	HWND GetHWnd() const { return m_hWnd; }

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	c3		 ret	 0
?GetHWnd@ioApplication@@QBEPAUHWND__@@XZ ENDP		; ioApplication::GetHWnd
_TEXT	ENDS
PUBLIC	?GetPrivateID@ioMyInfo@@QBEABVioHashString@@XZ	; ioMyInfo::GetPrivateID
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iomyinfo.h
;	COMDAT ?GetPrivateID@ioMyInfo@@QBEABVioHashString@@XZ
_TEXT	SEGMENT
?GetPrivateID@ioMyInfo@@QBEABVioHashString@@XZ PROC	; ioMyInfo::GetPrivateID, COMDAT
; _this$ = ecx

; 516  : 	const ioHashString& GetPrivateID() const { return m_user_data.m_private_id; }  

  00000	8d 41 0c	 lea	 eax, DWORD PTR [ecx+12]
  00003	c3		 ret	 0
?GetPrivateID@ioMyInfo@@QBEABVioHashString@@XZ ENDP	; ioMyInfo::GetPrivateID
_TEXT	ENDS
PUBLIC	?GetPublicID@ioMyInfo@@QBEABVioHashString@@XZ	; ioMyInfo::GetPublicID
; Function compile flags: /Ogsp
;	COMDAT ?GetPublicID@ioMyInfo@@QBEABVioHashString@@XZ
_TEXT	SEGMENT
?GetPublicID@ioMyInfo@@QBEABVioHashString@@XZ PROC	; ioMyInfo::GetPublicID, COMDAT
; _this$ = ecx

; 517  : 	const ioHashString& GetPublicID() const { return m_user_data.m_public_id; }    

  00000	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  00003	c3		 ret	 0
?GetPublicID@ioMyInfo@@QBEABVioHashString@@XZ ENDP	; ioMyInfo::GetPublicID
_TEXT	ENDS
PUBLIC	?GetMyIP@ioMyInfo@@QBEABVioHashString@@XZ	; ioMyInfo::GetMyIP
; Function compile flags: /Ogsp
;	COMDAT ?GetMyIP@ioMyInfo@@QBEABVioHashString@@XZ
_TEXT	SEGMENT
?GetMyIP@ioMyInfo@@QBEABVioHashString@@XZ PROC		; ioMyInfo::GetMyIP, COMDAT
; _this$ = ecx

; 763  : 	inline const ioHashString& GetMyIP() const {return m_MyIP;}

  00000	8d 81 68 04 00
	00		 lea	 eax, DWORD PTR [ecx+1128]
  00006	c3		 ret	 0
?GetMyIP@ioMyInfo@@QBEABVioHashString@@XZ ENDP		; ioMyInfo::GetMyIP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?trimOtherProcessesWorkingSet@@YAXXZ		; trimOtherProcessesWorkingSet
EXTRN	_EnumProcesses@12:PROC
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\main.cpp
;	COMDAT ?trimOtherProcessesWorkingSet@@YAXXZ
_TEXT	SEGMENT
_cbNeeded$ = -4104					; size = 4
_aProcesses$ = -4100					; size = 4096
__$ArrayPad$ = -4					; size = 4
?trimOtherProcessesWorkingSet@@YAXXZ PROC		; trimOtherProcessesWorkingSet, COMDAT

; 1006 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 08 10 00 00	 mov	 eax, 4104		; 00001008H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1007 : 	// Get the list of process identifiers.
; 1008 : 	DWORD aProcesses[1024], cbNeeded, cProcesses;
; 1009 : 	unsigned int i;
; 1010 : 
; 1011 : 	if ( !EnumProcesses( aProcesses, sizeof(aProcesses), &cbNeeded ) )

  00017	8d 85 f8 ef ff
	ff		 lea	 eax, DWORD PTR _cbNeeded$[ebp]
  0001d	50		 push	 eax
  0001e	68 00 10 00 00	 push	 4096			; 00001000H
  00023	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _aProcesses$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _EnumProcesses@12
  0002f	85 c0		 test	 eax, eax
  00031	74 25		 je	 SHORT $LN1@trimOtherP

; 1012 : 		return;
; 1013 : 
; 1014 : 	// Calculate how many process identifiers were returned.
; 1015 : 	cProcesses = cbNeeded / sizeof(DWORD);

  00033	56		 push	 esi
  00034	8b b5 f8 ef ff
	ff		 mov	 esi, DWORD PTR _cbNeeded$[ebp]
  0003a	57		 push	 edi
  0003b	c1 ee 02	 shr	 esi, 2

; 1016 : 
; 1017 : 	for ( i = 0; i < cProcesses; i++ )

  0003e	33 ff		 xor	 edi, edi
  00040	85 f6		 test	 esi, esi
  00042	74 12		 je	 SHORT $LN9@trimOtherP
$LL3@trimOtherP:

; 1018 : 		trimProcessWorkingSet( aProcesses[i] );

  00044	ff b4 bd fc ef
	ff ff		 push	 DWORD PTR _aProcesses$[ebp+edi*4]
  0004b	e8 00 00 00 00	 call	 ?trimProcessWorkingSet@@YAXK@Z ; trimProcessWorkingSet
  00050	47		 inc	 edi
  00051	59		 pop	 ecx
  00052	3b fe		 cmp	 edi, esi
  00054	72 ee		 jb	 SHORT $LL3@trimOtherP
$LN9@trimOtherP:
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
$LN1@trimOtherP:

; 1019 : 	
; 1020 : 	// 캐시 초기화는 안 하는걸로..
; 1021 : 	//clearSystemCache();
; 1022 : }

  00058	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005b	33 cd		 xor	 ecx, ebp
  0005d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00062	c9		 leave
  00063	c3		 ret	 0
?trimOtherProcessesWorkingSet@@YAXXZ ENDP		; trimOtherProcessesWorkingSet
_TEXT	ENDS
PUBLIC	??_C@_0CA@KBPLIBMA@SeProfileSingleProcessPrivilege?$AA@ ; `string'
PUBLIC	??_C@_0BJ@BIIKLOLC@SeIncreaseQuotaPrivilege?$AA@ ; `string'
PUBLIC	??_C@_0DN@GKGDBHKO@You?5do?5not?5have?5the?5necessary?5pr@ ; `string'
PUBLIC	??_C@_0BJ@NDLOPGCH@NtQuerySystemInformation?$AA@ ; `string'
PUBLIC	??_C@_1BE@GJOFHIHD@?$AAn?$AAt?$AAd?$AAl?$AAl?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BH@GKJMLNG@NtSetSystemInformation?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?clearSystemCache@@YAXXZ			; clearSystemCache
EXTRN	__imp__printf:PROC
EXTRN	__imp__OpenProcessToken@12:PROC
EXTRN	__imp__GetCurrentProcess@0:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__GetModuleHandleW@4:PROC
;	COMDAT ??_C@_0CA@KBPLIBMA@SeProfileSingleProcessPrivilege?$AA@
CONST	SEGMENT
??_C@_0CA@KBPLIBMA@SeProfileSingleProcessPrivilege?$AA@ DB 'SeProfileSing'
	DB	'leProcessPrivilege', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BIIKLOLC@SeIncreaseQuotaPrivilege?$AA@
CONST	SEGMENT
??_C@_0BJ@BIIKLOLC@SeIncreaseQuotaPrivilege?$AA@ DB 'SeIncreaseQuotaPrivi'
	DB	'lege', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@GKGDBHKO@You?5do?5not?5have?5the?5necessary?5pr@
CONST	SEGMENT
??_C@_0DN@GKGDBHKO@You?5do?5not?5have?5the?5necessary?5pr@ DB 'You do not'
	DB	' have the necessary privilege to run this program', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NDLOPGCH@NtQuerySystemInformation?$AA@
CONST	SEGMENT
??_C@_0BJ@NDLOPGCH@NtQuerySystemInformation?$AA@ DB 'NtQuerySystemInforma'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@GJOFHIHD@?$AAn?$AAt?$AAd?$AAl?$AAl?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@GJOFHIHD@?$AAn?$AAt?$AAd?$AAl?$AAl?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@ DB 'n'
	DB	00H, 't', 00H, 'd', 00H, 'l', 00H, 'l', 00H, '.', 00H, 'd', 00H
	DB	'l', 00H, 'l', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GKJMLNG@NtSetSystemInformation?$AA@
CONST	SEGMENT
??_C@_0BH@GKJMLNG@NtSetSystemInformation?$AA@ DB 'NtSetSystemInformation', 00H ; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?clearSystemCache@@YAXXZ
_TEXT	SEGMENT
_command$519835 = -84					; size = 4
_returnLength$519824 = -84				; size = 4
_hToken$ = -80						; size = 4
_info$519830 = -76					; size = 36
_newCacheSize$519823 = -40				; size = 36
__$ArrayPad$ = -4					; size = 4
?clearSystemCache@@YAXXZ PROC				; clearSystemCache, COMDAT

; 1115 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi

; 1116 : 	if (NULL == (NtSetSystemInformation = (NTSETSYSTEMINFORMATION) GetProcAddress( GetModuleHandleW(L"ntdll.dll"), "NtSetSystemInformation")))

  00012	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetModuleHandleW@4
  00018	57		 push	 edi
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@GKJMLNG@NtSetSystemInformation?$AA@
  0001e	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_1BE@GJOFHIHD@?$AAn?$AAt?$AAd?$AAl?$AAl?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
  00023	53		 push	 ebx
  00024	ff d6		 call	 esi
  00026	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetProcAddress@8
  0002c	50		 push	 eax
  0002d	ff d7		 call	 edi
  0002f	a3 00 00 00 00	 mov	 DWORD PTR ?NtSetSystemInformation@@3P6GKKPAXK@ZA, eax ; NtSetSystemInformation
  00034	85 c0		 test	 eax, eax
  00036	0f 84 da 00 00
	00		 je	 $LN1@clearSyste

; 1117 : 		return;
; 1118 : 	if (NULL == (NtQuerySystemInformation = (NTQUERYSYSTEMINFORMATION) GetProcAddress( GetModuleHandleW(L"ntdll.dll"), "NtQuerySystemInformation")))

  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@NDLOPGCH@NtQuerySystemInformation?$AA@
  00041	53		 push	 ebx
  00042	ff d6		 call	 esi
  00044	50		 push	 eax
  00045	ff d7		 call	 edi
  00047	a3 00 00 00 00	 mov	 DWORD PTR ?NtQuerySystemInformation@@3P6GKKPAXKPAK@ZA, eax ; NtQuerySystemInformation
  0004c	85 c0		 test	 eax, eax
  0004e	0f 84 c2 00 00
	00		 je	 $LN1@clearSyste

; 1119 : 		return;
; 1120 : 
; 1121 : 	// Enable increase quota privilege
; 1122 : 	HANDLE hToken;
; 1123 : 	if (!OpenProcessToken( GetCurrentProcess(),
; 1124 : 		TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
; 1125 : 		&hToken )) {

  00054	8d 45 b0	 lea	 eax, DWORD PTR _hToken$[ebp]
  00057	50		 push	 eax
  00058	6a 28		 push	 40			; 00000028H
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcess@0
  00060	50		 push	 eax
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenProcessToken@12
  00067	85 c0		 test	 eax, eax
  00069	75 11		 jne	 SHORT $LN9@clearSyste

; 1126 : 			printf("You do not have the necessary privilege to run this program\n");

  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@GKGDBHKO@You?5do?5not?5have?5the?5necessary?5pr@
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00076	59		 pop	 ecx

; 1127 : 			return;

  00077	e9 9a 00 00 00	 jmp	 $LN1@clearSyste
$LN9@clearSyste:

; 1128 : 	}
; 1129 : 
; 1130 : 	// Enable SeDebugPrivilege
; 1131 : 	if(SetPrivilege(hToken, SE_INCREASE_QUOTA_NAME, TRUE))

  0007c	6a 01		 push	 1
  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@BIIKLOLC@SeIncreaseQuotaPrivilege?$AA@
  00083	ff 75 b0	 push	 DWORD PTR _hToken$[ebp]
  00086	e8 00 00 00 00	 call	 ?SetPrivilege@@YAHPAXPBDH@Z ; SetPrivilege
  0008b	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__CloseHandle@4
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH
  00094	85 c0		 test	 eax, eax
  00096	74 49		 je	 SHORT $LN8@clearSyste

; 1132 : 	{
; 1133 : 		SYSTEM_CACHE_INFORMATION newCacheSize;
; 1134 : 		ULONG returnLength;
; 1135 : 		if (NtQuerySystemInformation( SYSTEMCACHEINFORMATION,
; 1136 : 			&newCacheSize, sizeof(newCacheSize),
; 1137 : 			&returnLength ) ) 

  00098	8d 45 ac	 lea	 eax, DWORD PTR _returnLength$519824[ebp]
  0009b	50		 push	 eax
  0009c	6a 24		 push	 36			; 00000024H
  0009e	8d 45 d8	 lea	 eax, DWORD PTR _newCacheSize$519823[ebp]
  000a1	50		 push	 eax
  000a2	6a 15		 push	 21			; 00000015H
  000a4	ff 15 00 00 00
	00		 call	 DWORD PTR ?NtQuerySystemInformation@@3P6GKKPAXKPAK@ZA ; NtQuerySystemInformation

; 1138 : 		{		
; 1139 : 			//return;
; 1140 : 		}
; 1141 : 		
; 1142 : 		newCacheSize.MinimumWorkingSet = (ULONG) -1;
; 1143 : 		newCacheSize.MaximumWorkingSet = (ULONG) -1;
; 1144 : 		NTSTATUS ret = NtSetSystemInformation( SYSTEMCACHEINFORMATION,	&newCacheSize, sizeof( newCacheSize));

  000aa	6a 24		 push	 36			; 00000024H
  000ac	8d 45 d8	 lea	 eax, DWORD PTR _newCacheSize$519823[ebp]
  000af	50		 push	 eax
  000b0	83 ce ff	 or	 esi, -1
  000b3	6a 15		 push	 21			; 00000015H
  000b5	89 75 e4	 mov	 DWORD PTR _newCacheSize$519823[ebp+12], esi
  000b8	89 75 e8	 mov	 DWORD PTR _newCacheSize$519823[ebp+16], esi
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR ?NtSetSystemInformation@@3P6GKKPAXK@ZA ; NtSetSystemInformation

; 1145 : 		if( ret >= 0 )
; 1146 : 		{
; 1147 : 			//success
; 1148 : 		}
; 1149 : 
; 1150 : 		SYSTEM_FILECACHE_INFORMATION info;
; 1151 : 		ZeroMemory(&info, sizeof(info));

  000c1	6a 09		 push	 9
  000c3	59		 pop	 ecx
  000c4	33 c0		 xor	 eax, eax
  000c6	8d 7d b4	 lea	 edi, DWORD PTR _info$519830[ebp]
  000c9	f3 ab		 rep stosd

; 1152 : 		info.MinimumWorkingSet = -1;
; 1153 : 		info.MaximumWorkingSet = -1;
; 1154 : 		ret = NtSetSystemInformation(SystemFileCacheInformation, &info, sizeof(info));

  000cb	6a 24		 push	 36			; 00000024H
  000cd	8d 45 b4	 lea	 eax, DWORD PTR _info$519830[ebp]
  000d0	50		 push	 eax
  000d1	6a 15		 push	 21			; 00000015H
  000d3	89 75 c0	 mov	 DWORD PTR _info$519830[ebp+12], esi
  000d6	89 75 c4	 mov	 DWORD PTR _info$519830[ebp+16], esi
  000d9	ff 15 00 00 00
	00		 call	 DWORD PTR ?NtSetSystemInformation@@3P6GKKPAXK@ZA ; NtSetSystemInformation

; 1155 : 		if( ret >= 0 )
; 1156 : 		{
; 1157 : 			//success
; 1158 : 		}
; 1159 : 	}
; 1160 : 	else

  000df	eb 05		 jmp	 SHORT $LN4@clearSyste
$LN8@clearSyste:

; 1161 : 	{
; 1162 : 		CloseHandle(hToken);

  000e1	ff 75 b0	 push	 DWORD PTR _hToken$[ebp]
  000e4	ff d3		 call	 ebx
$LN4@clearSyste:

; 1163 : 	}
; 1164 : 
; 1165 : 	if(SetPrivilege(hToken, SE_PROF_SINGLE_PROCESS_NAME, TRUE))

  000e6	6a 01		 push	 1
  000e8	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@KBPLIBMA@SeProfileSingleProcessPrivilege?$AA@
  000ed	ff 75 b0	 push	 DWORD PTR _hToken$[ebp]
  000f0	e8 00 00 00 00	 call	 ?SetPrivilege@@YAHPAXPBDH@Z ; SetPrivilege
  000f5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f8	85 c0		 test	 eax, eax
  000fa	74 15		 je	 SHORT $LN3@clearSyste

; 1166 : 	{
; 1167 : 		SYSTEM_MEMORY_LIST_COMMAND command = MemoryPurgeStandbyList;

  000fc	6a 04		 push	 4
  000fe	58		 pop	 eax

; 1168 : 		NTSTATUS ret = NtSetSystemInformation(SystemMemoryListInformation, &command, sizeof(command));

  000ff	50		 push	 eax
  00100	89 45 ac	 mov	 DWORD PTR _command$519835[ebp], eax
  00103	8d 45 ac	 lea	 eax, DWORD PTR _command$519835[ebp]
  00106	50		 push	 eax
  00107	6a 50		 push	 80			; 00000050H
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR ?NtSetSystemInformation@@3P6GKKPAXK@ZA ; NtSetSystemInformation

; 1169 : 		if( ret >= 0 )
; 1170 : 		{
; 1171 : 			//success
; 1172 : 		}
; 1173 : 	}
; 1174 : 	else

  0010f	eb 05		 jmp	 SHORT $LN1@clearSyste
$LN3@clearSyste:

; 1175 : 	{
; 1176 : 		CloseHandle(hToken);

  00111	ff 75 b0	 push	 DWORD PTR _hToken$[ebp]
  00114	ff d3		 call	 ebx
$LN1@clearSyste:

; 1177 : 	}
; 1178 : 	
; 1179 : }

  00116	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi
  0011b	33 cd		 xor	 ecx, ebp
  0011d	5b		 pop	 ebx
  0011e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00123	c9		 leave
  00124	c3		 ret	 0
?clearSystemCache@@YAXXZ ENDP				; clearSystemCache
_TEXT	ENDS
PUBLIC	??_C@_0BJ@KAKCFKFA@?9?9?9?9?5Crash?5Help?5End?5?9?9?9?9?$AA@ ; `string'
PUBLIC	??_C@_0BD@GNMFBGDG@?5Crash?5Files?5Sent?5?$AA@	; `string'
PUBLIC	??_C@_0BK@DPLNDBJD@lsdump?4exe?5LsVer_?$CFs_?$CFs_?$CFs?$AA@ ; `string'
PUBLIC	??_C@_05IJNOCPGM@12861?$AA@			; `string'
PUBLIC	??_C@_0M@DMGKCCIB@ClientError?$AA@		; `string'
PUBLIC	??_C@_0P@DNLMMKHH@?$CFs?6?$CFs?6?$CFs?6?$CFs?6?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0CN@GMNFKGGD@There?5are?5?$CFd?5free?5Mbytes?5of?5exte@ ; `string'
PUBLIC	??_C@_0CM@JDEOAGKO@There?5are?5?$CFd?5free?5Mbytes?5of?5virt@ ; `string'
PUBLIC	??_C@_0CN@BMCLKNEO@There?5are?5?$CFd?5total?5Mbytes?5of?5vir@ ; `string'
PUBLIC	??_C@_0CJ@DAJMLJFP@There?5are?5?$CFd?5free?5Mbytes?5of?5pagi@ ; `string'
PUBLIC	??_C@_0CK@JKOIEDHH@There?5are?5?$CFd?5total?5Mbytes?5of?5pag@ ; `string'
PUBLIC	??_C@_0CN@KBJGDEHL@There?5are?5?$CFd?5free?5Mbytes?5of?5phys@ ; `string'
PUBLIC	??_C@_0CO@BBDLDKI@There?5are?5?$CFd?5total?5Mbytes?5of?5phy@ ; `string'
PUBLIC	??_C@_0CH@JECOCODG@There?5is?5?5?$CFd?5percent?5of?5memory?5i@ ; `string'
PUBLIC	??_C@_02PCIJFNDE@?$AN?6?$AA@			; `string'
PUBLIC	??_C@_04LLEBNMDN@?$CFs?$AN?6?$AA@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_0BK@FJMDFBJG@?9?9?9?9?5Crash?5Help?5Data?5?9?9?9?9?$AA@ ; `string'
PUBLIC	??_C@_0CL@OGOEEGLJ@?$CFs?1?$CFs?1?$CFs?5ErrorPos?5?3?5?$CFd?0?5?$CFd?0?5?$CFd?0?5@ ; `string'
PUBLIC	??_C@_0N@GKLKNAPC@LostSaga?4dmp?$AA@		; `string'
PUBLIC	_pExPtrs$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?ExceptCallBack@@YGJPAU_EXCEPTION_POINTERS@@@Z	; ExceptCallBack
EXTRN	??1SP2Packet@@UAE@XZ:PROC			; SP2Packet::~SP2Packet
EXTRN	__imp__CreateProcessA@40:PROC
EXTRN	__imp__sprintf:PROC
EXTRN	?SendLog@P2PNetwork@@YAXAAVSP2Packet@@@Z:PROC	; P2PNetwork::SendLog
EXTRN	??6SP2Packet@@QAEAAV0@_N@Z:PROC			; SP2Packet::operator<<
EXTRN	??6SP2Packet@@QAEAAV0@H@Z:PROC			; SP2Packet::operator<<
EXTRN	??6SP2Packet@@QAEAAV0@PAD@Z:PROC		; SP2Packet::operator<<
EXTRN	??6SP2Packet@@QAEAAV0@PBD@Z:PROC		; SP2Packet::operator<<
EXTRN	??0SP2Packet@@QAE@K@Z:PROC			; SP2Packet::SP2Packet
EXTRN	?GetLOG@ioTCPChecker@@QAEPADXZ:PROC		; ioTCPChecker::GetLOG
EXTRN	?GetSingleton@ioTCPChecker@@SAAAV1@XZ:PROC	; ioTCPChecker::GetSingleton
EXTRN	?GetSettingString@Setting@@SAPADXZ:PROC		; Setting::GetSettingString
EXTRN	__imp_?PrintTimeAndLog@CLog@@QAAXHPADZZ:PROC
EXTRN	__imp__GlobalMemoryStatusEx@4:PROC
EXTRN	__imp__GetNextStackTraceString@8:PROC
EXTRN	__imp__GetFirstStackTraceString@8:PROC
EXTRN	__imp__GetRegisterString@4:PROC
EXTRN	__imp_?PrintNoEnterLog@CLog@@QAAXHPADZZ:PROC
EXTRN	__imp__GetFaultReason@4:PROC
EXTRN	__imp_?PrintLog@CLog@@QAAXHPADZZ:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	__imp_?c_str@ioHashString@@QBEPBDXZ:PROC
EXTRN	__imp_?GetMajorPosition@ErrorReport@@YAMXZ:PROC
EXTRN	__imp_?GetMinorPosition@ErrorReport@@YAMXZ:PROC
EXTRN	__imp_?GetEngineMajorPos@ErrorReport@@YAHXZ:PROC
EXTRN	__imp_?GetEngineMinorPos@ErrorReport@@YAHXZ:PROC
EXTRN	__imp_?GetAndSoOnInfo@ErrorReport@@YAHXZ:PROC
EXTRN	__imp_?GetString@ErrorReport@@YAPBDXZ:PROC
EXTRN	?GetSingleton@ioMyInfo@@SAAAV1@XZ:PROC		; ioMyInfo::GetSingleton
EXTRN	__imp_?ReleaseInstance@ioThreadTaskManager@@SAXXZ:PROC
EXTRN	_MiniDumpWriteDump@28:PROC
EXTRN	__imp__GetCurrentThreadId@0:PROC
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	?CaptureScreenWithJPEG@Help@@YA_NXZ:PROC	; Help::CaptureScreenWithJPEG
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__fltused:DWORD
EXTRN	_memset:PROC
;	COMDAT ??_C@_0BJ@KAKCFKFA@?9?9?9?9?5Crash?5Help?5End?5?9?9?9?9?$AA@
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iomyinfo.h
CONST	SEGMENT
??_C@_0BJ@KAKCFKFA@?9?9?9?9?5Crash?5Help?5End?5?9?9?9?9?$AA@ DB '---- Cra'
	DB	'sh Help End ----', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GNMFBGDG@?5Crash?5Files?5Sent?5?$AA@
CONST	SEGMENT
??_C@_0BD@GNMFBGDG@?5Crash?5Files?5Sent?5?$AA@ DB ' Crash Files Sent ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DPLNDBJD@lsdump?4exe?5LsVer_?$CFs_?$CFs_?$CFs?$AA@
CONST	SEGMENT
??_C@_0BK@DPLNDBJD@lsdump?4exe?5LsVer_?$CFs_?$CFs_?$CFs?$AA@ DB 'lsdump.e'
	DB	'xe LsVer_%s_%s_%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05IJNOCPGM@12861?$AA@
CONST	SEGMENT
??_C@_05IJNOCPGM@12861?$AA@ DB '12861', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DMGKCCIB@ClientError?$AA@
CONST	SEGMENT
??_C@_0M@DMGKCCIB@ClientError?$AA@ DB 'ClientError', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DNLMMKHH@?$CFs?6?$CFs?6?$CFs?6?$CFs?6?$CFs?$AA@
CONST	SEGMENT
??_C@_0P@DNLMMKHH@?$CFs?6?$CFs?6?$CFs?6?$CFs?6?$CFs?$AA@ DB '%s', 0aH, '%'
	DB	's', 0aH, '%s', 0aH, '%s', 0aH, '%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@GMNFKGGD@There?5are?5?$CFd?5free?5Mbytes?5of?5exte@
CONST	SEGMENT
??_C@_0CN@GMNFKGGD@There?5are?5?$CFd?5free?5Mbytes?5of?5exte@ DB 'There a'
	DB	're %d free Mbytes of extended memory.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@JDEOAGKO@There?5are?5?$CFd?5free?5Mbytes?5of?5virt@
CONST	SEGMENT
??_C@_0CM@JDEOAGKO@There?5are?5?$CFd?5free?5Mbytes?5of?5virt@ DB 'There a'
	DB	're %d free Mbytes of virtual memory.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@BMCLKNEO@There?5are?5?$CFd?5total?5Mbytes?5of?5vir@
CONST	SEGMENT
??_C@_0CN@BMCLKNEO@There?5are?5?$CFd?5total?5Mbytes?5of?5vir@ DB 'There a'
	DB	're %d total Mbytes of virtual memory.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@DAJMLJFP@There?5are?5?$CFd?5free?5Mbytes?5of?5pagi@
CONST	SEGMENT
??_C@_0CJ@DAJMLJFP@There?5are?5?$CFd?5free?5Mbytes?5of?5pagi@ DB 'There a'
	DB	're %d free Mbytes of paging file.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@JKOIEDHH@There?5are?5?$CFd?5total?5Mbytes?5of?5pag@
CONST	SEGMENT
??_C@_0CK@JKOIEDHH@There?5are?5?$CFd?5total?5Mbytes?5of?5pag@ DB 'There a'
	DB	're %d total Mbytes of paging file.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@KBJGDEHL@There?5are?5?$CFd?5free?5Mbytes?5of?5phys@
CONST	SEGMENT
??_C@_0CN@KBJGDEHL@There?5are?5?$CFd?5free?5Mbytes?5of?5phys@ DB 'There a'
	DB	're %d free Mbytes of physical memory.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@BBDLDKI@There?5are?5?$CFd?5total?5Mbytes?5of?5phy@
CONST	SEGMENT
??_C@_0CO@BBDLDKI@There?5are?5?$CFd?5total?5Mbytes?5of?5phy@ DB 'There ar'
	DB	'e %d total Mbytes of physical memory.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@JECOCODG@There?5is?5?5?$CFd?5percent?5of?5memory?5i@
CONST	SEGMENT
??_C@_0CH@JECOCODG@There?5is?5?5?$CFd?5percent?5of?5memory?5i@ DB 'There '
	DB	'is  %d percent of memory in use.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02PCIJFNDE@?$AN?6?$AA@
CONST	SEGMENT
??_C@_02PCIJFNDE@?$AN?6?$AA@ DB 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LLEBNMDN@?$CFs?$AN?6?$AA@
CONST	SEGMENT
??_C@_04LLEBNMDN@?$CFs?$AN?6?$AA@ DB '%s', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FJMDFBJG@?9?9?9?9?5Crash?5Help?5Data?5?9?9?9?9?$AA@
CONST	SEGMENT
??_C@_0BK@FJMDFBJG@?9?9?9?9?5Crash?5Help?5Data?5?9?9?9?9?$AA@ DB '---- Cr'
	DB	'ash Help Data ----', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@OGOEEGLJ@?$CFs?1?$CFs?1?$CFs?5ErrorPos?5?3?5?$CFd?0?5?$CFd?0?5?$CFd?0?5@
CONST	SEGMENT
??_C@_0CL@OGOEEGLJ@?$CFs?1?$CFs?1?$CFs?5ErrorPos?5?3?5?$CFd?0?5?$CFd?0?5?$CFd?0?5@ DB '%'
	DB	's/%s/%s ErrorPos : %d, %d, %d, %d, %d, %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GKLKNAPC@LostSaga?4dmp?$AA@
CONST	SEGMENT
??_C@_0N@GKLKNAPC@LostSaga?4dmp?$AA@ DB 'LostSaga.dmp', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ExceptCallBack@@YGJPAU_EXCEPTION_POINTERS@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExceptCallBack@@YGJPAU_EXCEPTION_POINTERS@@@Z$0
__ehfuncinfo$?ExceptCallBack@@YGJPAU_EXCEPTION_POINTERS@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ExceptCallBack@@YGJPAU_EXCEPTION_POINTERS@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\main.cpp
xdata$x	ENDS
;	COMDAT ?ExceptCallBack@@YGJPAU_EXCEPTION_POINTERS@@@Z
_TEXT	SEGMENT
_si$ = -33236						; size = 68
_pi$ = -33168						; size = 16
_MiniDumpExceptionInfo$519864 = -33152			; size = 12
_Success$ = -33140					; size = 4
tv398 = -33136						; size = 4
$T520301 = -33136					; size = 4
_pExPtrs$GSCopy$ = -33132				; size = 4
_kPacket$ = -33128					; size = 32792
_statex$ = -336						; size = 64
_buf$ = -272						; size = 256
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pExPtrs$ = 8						; size = 4
?ExceptCallBack@@YGJPAU_EXCEPTION_POINTERS@@@Z PROC	; ExceptCallBack, COMDAT

; 1236 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ExceptCallBack@@YGJPAU_EXCEPTION_POINTERS@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 c8 81 00 00	 mov	 eax, 33224		; 000081c8H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00032	8b 7d 08	 mov	 edi, DWORD PTR _pExPtrs$[ebp]

; 1237 : 	if( g_bHappenCrash )

  00035	33 db		 xor	 ebx, ebx

; 1373 : 	}
; 1374 : 
; 1375 : 	LOG.PrintLog(0, "---- Crash Help End ----");

  00037	89 bd 94 7e ff
	ff		 mov	 DWORD PTR _pExPtrs$GSCopy$[ebp], edi
  0003d	38 1d 00 00 00
	00		 cmp	 BYTE PTR ?g_bHappenCrash@@3_NA, bl ; g_bHappenCrash
  00043	74 1f		 je	 SHORT $LN8@ExceptCall

; 1238 : 		return EXCEPTION_EXECUTE_HANDLER;

  00045	33 c0		 xor	 eax, eax
  00047	40		 inc	 eax
$LN9@ExceptCall:

; 1379 : 
; 1380 : 
; 1381 : 	return EXCEPTION_CONTINUE_EXECUTION;
; 1382 : }

  00048	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00052	59		 pop	 ecx
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx
  00056	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00059	33 cd		 xor	 ecx, ebp
  0005b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00060	c9		 leave
  00061	c2 04 00	 ret	 4
$LN8@ExceptCall:

; 1239 : 
; 1240 : 	g_bHappenCrash = true;

  00064	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?g_bHappenCrash@@3_NA, 1 ; g_bHappenCrash

; 1241 : 
; 1242 : #ifdef STEAM_ATTACH
; 1243 : 	g_ioSteamClient.End();
; 1244 : #endif
; 1245 : 
; 1246 : #ifdef HACKSHIELD
; 1247 : 	g_ioHackShield.End();
; 1248 : #endif 
; 1249 : 
; 1250 : 	Help::CaptureScreenWithJPEG();

  0006b	e8 00 00 00 00	 call	 ?CaptureScreenWithJPEG@Help@@YA_NXZ ; Help::CaptureScreenWithJPEG

; 1251 : 
; 1252 : 	BOOL Success = FALSE;
; 1253 : 
; 1254 : 	HANDLE hMiniDumpFile = CreateFile(
; 1255 : 		_T("LostSaga.dmp"),
; 1256 : 		GENERIC_WRITE,
; 1257 : 		0,
; 1258 : 		NULL,
; 1259 : 		CREATE_ALWAYS,
; 1260 : 		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
; 1261 : 		NULL);

  00070	53		 push	 ebx
  00071	68 80 00 00 80	 push	 -2147483520		; 80000080H
  00076	6a 02		 push	 2
  00078	53		 push	 ebx
  00079	53		 push	 ebx
  0007a	68 00 00 00 40	 push	 1073741824		; 40000000H
  0007f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GKLKNAPC@LostSaga?4dmp?$AA@
  00084	89 9d 8c 7e ff
	ff		 mov	 DWORD PTR _Success$[ebp], ebx
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00090	8b f0		 mov	 esi, eax

; 1262 : 
; 1263 : 	// Write the minidump to the file
; 1264 : 	if (hMiniDumpFile != INVALID_HANDLE_VALUE)

  00092	83 fe ff	 cmp	 esi, -1
  00095	74 43		 je	 SHORT $LN7@ExceptCall

; 1265 : 	{
; 1266 : 		// 		DumpMiniDump(hMiniDumpFile, pExPtrs);
; 1267 : 
; 1268 : 		_MINIDUMP_EXCEPTION_INFORMATION MiniDumpExceptionInfo;
; 1269 : 		MiniDumpExceptionInfo.ThreadId			= GetCurrentThreadId();

  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThreadId@0

; 1270 : 		MiniDumpExceptionInfo.ExceptionPointers	= (PEXCEPTION_POINTERS)pExPtrs;
; 1271 : 		MiniDumpExceptionInfo.ClientPointers		= NULL;
; 1272 : 
; 1273 : 		Success = MiniDumpWriteDump(
; 1274 : 			GetCurrentProcess(),
; 1275 : 			GetCurrentProcessId(),
; 1276 : 			hMiniDumpFile,				//덤프를 기록할 파일 핸들
; 1277 : 			MiniDumpNormal,
; 1278 : 			&MiniDumpExceptionInfo,	//MiniDump 예외 정보
; 1279 : 			NULL,
; 1280 : 			NULL);

  0009d	53		 push	 ebx
  0009e	53		 push	 ebx
  0009f	89 85 80 7e ff
	ff		 mov	 DWORD PTR _MiniDumpExceptionInfo$519864[ebp], eax
  000a5	8d 85 80 7e ff
	ff		 lea	 eax, DWORD PTR _MiniDumpExceptionInfo$519864[ebp]
  000ab	50		 push	 eax
  000ac	53		 push	 ebx
  000ad	56		 push	 esi
  000ae	89 bd 84 7e ff
	ff		 mov	 DWORD PTR _MiniDumpExceptionInfo$519864[ebp+4], edi
  000b4	89 9d 88 7e ff
	ff		 mov	 DWORD PTR _MiniDumpExceptionInfo$519864[ebp+8], ebx
  000ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcessId@0
  000c0	50		 push	 eax
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcess@0
  000c7	50		 push	 eax
  000c8	e8 00 00 00 00	 call	 _MiniDumpWriteDump@28

; 1281 : 
; 1282 : 
; 1283 : 		CloseHandle(hMiniDumpFile);

  000cd	56		 push	 esi
  000ce	89 85 8c 7e ff
	ff		 mov	 DWORD PTR _Success$[ebp], eax
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN7@ExceptCall:

; 1284 : 	}
; 1285 : 
; 1286 : 	ioThreadTaskManager::ReleaseInstance();

  000da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ReleaseInstance@ioThreadTaskManager@@SAXXZ

; 1287 : 	ioResourceLoader::ReleaseInstance();

  000e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ReleaseInstance@ioResourceLoader@@SAXXZ

; 1288 : 
; 1289 : 	wsprintf( g_szErrorPos, "%s/%s/%s ErrorPos : %d, %d, %d, %d, %d, %s", g_MyInfo.GetMyIP().c_str(),
; 1290 : 		g_MyInfo.GetPrivateID().c_str(),
; 1291 : 		g_MyInfo.GetPublicID().c_str(),
; 1292 : 		ErrorReport::GetMajorPosition(),
; 1293 : 		ErrorReport::GetMinorPosition(),
; 1294 : 		ErrorReport::GetEngineMajorPos(),
; 1295 : 		ErrorReport::GetEngineMinorPos(),
; 1296 : 		ErrorReport::GetAndSoOnInfo(),
; 1297 : 		ErrorReport::GetString() );

  000e6	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  000eb	8b f0		 mov	 esi, eax
  000ed	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  000f2	8b f8		 mov	 edi, eax
  000f4	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  000f9	89 85 90 7e ff
	ff		 mov	 DWORD PTR $T520301[ebp], eax
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ErrorReport@@YAPBDXZ
  00105	50		 push	 eax
  00106	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetAndSoOnInfo@ErrorReport@@YAHXZ
  0010c	50		 push	 eax
  0010d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetEngineMinorPos@ErrorReport@@YAHXZ
  00113	50		 push	 eax
  00114	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetEngineMajorPos@ErrorReport@@YAHXZ
  0011a	50		 push	 eax
  0011b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetMinorPosition@ErrorReport@@YAMXZ
  00121	51		 push	 ecx
  00122	51		 push	 ecx
  00123	dd 1c 24	 fstp	 QWORD PTR [esp]
  00126	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetMajorPosition@ErrorReport@@YAMXZ
  0012c	51		 push	 ecx
  0012d	51		 push	 ecx
  0012e	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
  00131	dd 1c 24	 fstp	 QWORD PTR [esp]
  00134	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  0013a	50		 push	 eax
  0013b	8d 4f 0c	 lea	 ecx, DWORD PTR [edi+12]
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00144	8b 8d 90 7e ff
	ff		 mov	 ecx, DWORD PTR $T520301[ebp]
  0014a	50		 push	 eax
  0014b	81 c1 68 04 00
	00		 add	 ecx, 1128		; 00000468H
  00151	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00157	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__wsprintfA
  0015d	50		 push	 eax
  0015e	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@OGOEEGLJ@?$CFs?1?$CFs?1?$CFs?5ErrorPos?5?3?5?$CFd?0?5?$CFd?0?5?$CFd?0?5@
  00163	68 00 00 00 00	 push	 OFFSET ?g_szErrorPos@@3PADA ; g_szErrorPos
  00168	ff d7		 call	 edi

; 1298 : 
; 1299 : 	LOG.PrintLog( 0, "---- Crash Help Data ----");

  0016a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?PrintLog@CLog@@QAAXHPADZZ
  00170	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@FJMDFBJG@?9?9?9?9?5Crash?5Help?5Data?5?9?9?9?9?$AA@
  00175	53		 push	 ebx
  00176	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  0017c	ff d6		 call	 esi
  0017e	83 c4 40	 add	 esp, 64			; 00000040H

; 1300 : 
; 1301 : 	LOG.PrintLog( 0, "%s", g_szErrorPos );

  00181	68 00 00 00 00	 push	 OFFSET ?g_szErrorPos@@3PADA ; g_szErrorPos
  00186	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  0018b	53		 push	 ebx
  0018c	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  00192	ff d6		 call	 esi
  00194	83 c4 10	 add	 esp, 16			; 00000010H

; 1302 : 
; 1303 : #ifndef SHIPPING
; 1304 : 	LOG.PrintLog( 0, "%s", g_TCPChecker.GetLOG() );
; 1305 : #endif
; 1306 : 
; 1307 : 	wsprintf( g_szTempLogBuf, "%s\r\n", GetFaultReason(pExPtrs) );

  00197	ff b5 94 7e ff
	ff		 push	 DWORD PTR _pExPtrs$GSCopy$[ebp]
  0019d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFaultReason@4
  001a3	50		 push	 eax
  001a4	68 00 00 00 00	 push	 OFFSET ??_C@_04LLEBNMDN@?$CFs?$AN?6?$AA@
  001a9	be 00 00 00 00	 mov	 esi, OFFSET ?g_szTempLogBuf@@3PADA ; g_szTempLogBuf
  001ae	56		 push	 esi
  001af	ff d7		 call	 edi

; 1308 : 	LOG.PrintNoEnterLog(0, "%s", g_szTempLogBuf);

  001b1	56		 push	 esi
  001b2	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  001b7	53		 push	 ebx
  001b8	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  001be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintNoEnterLog@CLog@@QAAXHPADZZ
  001c4	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1309 : 	strcpy( g_szErrorLog, g_szTempLogBuf );

  001c7	33 c0		 xor	 eax, eax
$LL11@ExceptCall:
  001c9	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR ?g_szTempLogBuf@@3PADA[eax]
  001cf	88 88 00 00 00
	00		 mov	 BYTE PTR ?g_szErrorLog@@3PADA[eax], cl
  001d5	40		 inc	 eax
  001d6	3a cb		 cmp	 cl, bl
  001d8	75 ef		 jne	 SHORT $LL11@ExceptCall

; 1310 : 
; 1311 : 	wsprintf( g_szTempLogBuf, "%s\r\n", GetRegisterString(pExPtrs) );

  001da	ff b5 94 7e ff
	ff		 push	 DWORD PTR _pExPtrs$GSCopy$[ebp]
  001e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetRegisterString@4
  001e6	50		 push	 eax
  001e7	68 00 00 00 00	 push	 OFFSET ??_C@_04LLEBNMDN@?$CFs?$AN?6?$AA@
  001ec	56		 push	 esi
  001ed	ff d7		 call	 edi

; 1312 : 	LOG.PrintNoEnterLog(0, "%s", g_szTempLogBuf);

  001ef	56		 push	 esi
  001f0	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  001f5	53		 push	 ebx
  001f6	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  001fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintNoEnterLog@CLog@@QAAXHPADZZ
  00202	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1313 : 	strcat( g_szErrorLog, g_szTempLogBuf );

  00205	8b c6		 mov	 eax, esi
$LL29@ExceptCall:
  00207	8a 08		 mov	 cl, BYTE PTR [eax]
  00209	40		 inc	 eax
  0020a	3a cb		 cmp	 cl, bl
  0020c	75 f9		 jne	 SHORT $LL29@ExceptCall
  0020e	bf 00 00 00 00	 mov	 edi, OFFSET ?g_szErrorLog@@3PADA ; g_szErrorLog
  00213	2b c6		 sub	 eax, esi
  00215	4f		 dec	 edi
$LL30@ExceptCall:
  00216	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00219	47		 inc	 edi
  0021a	3a cb		 cmp	 cl, bl
  0021c	75 f8		 jne	 SHORT $LL30@ExceptCall

; 1314 : 
; 1315 : 	szTrace = GetFirstStackTraceString( GSTSO_SYMBOL | GSTSO_SRCLINE, pExPtrs );

  0021e	ff b5 94 7e ff
	ff		 push	 DWORD PTR _pExPtrs$GSCopy$[ebp]
  00224	8b c8		 mov	 ecx, eax
  00226	c1 e9 02	 shr	 ecx, 2
  00229	f3 a5		 rep movsd
  0022b	8b c8		 mov	 ecx, eax
  0022d	83 e1 03	 and	 ecx, 3
  00230	6a 0c		 push	 12			; 0000000cH
  00232	f3 a4		 rep movsb
  00234	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFirstStackTraceString@8
  0023a	e9 98 00 00 00	 jmp	 $LN39@ExceptCall
$LL6@ExceptCall:

; 1317 : 	{
; 1318 : 		LOG.PrintLog(0,"%s" , szTrace );

  0023f	50		 push	 eax
  00240	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00245	53		 push	 ebx
  00246	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  0024c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintLog@CLog@@QAAXHPADZZ

; 1319 : 
; 1320 : 		if( strlen(g_szErrorLog) + strlen(szTrace) < 2047 )

  00252	bf 00 00 00 00	 mov	 edi, OFFSET ?g_szErrorLog@@3PADA ; g_szErrorLog
  00257	8b c7		 mov	 eax, edi
  00259	83 c4 10	 add	 esp, 16			; 00000010H
  0025c	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$LL31@ExceptCall:
  0025f	8a 08		 mov	 cl, BYTE PTR [eax]
  00261	40		 inc	 eax
  00262	3a cb		 cmp	 cl, bl
  00264	75 f9		 jne	 SHORT $LL31@ExceptCall
  00266	2b c6		 sub	 eax, esi
  00268	89 85 90 7e ff
	ff		 mov	 DWORD PTR tv398[ebp], eax
  0026e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?szTrace@@3PBDB ; szTrace
  00273	8b c8		 mov	 ecx, eax
  00275	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$LL32@ExceptCall:
  00278	8a 11		 mov	 dl, BYTE PTR [ecx]
  0027a	41		 inc	 ecx
  0027b	3a d3		 cmp	 dl, bl
  0027d	75 f9		 jne	 SHORT $LL32@ExceptCall
  0027f	8b 95 90 7e ff
	ff		 mov	 edx, DWORD PTR tv398[ebp]
  00285	2b ce		 sub	 ecx, esi
  00287	03 d1		 add	 edx, ecx
  00289	81 fa ff 07 00
	00		 cmp	 edx, 2047		; 000007ffH
  0028f	73 58		 jae	 SHORT $LN4@ExceptCall

; 1321 : 		{
; 1322 : 			strcat( g_szErrorLog, "\r\n" );

  00291	4f		 dec	 edi
$LL33@ExceptCall:
  00292	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00295	47		 inc	 edi
  00296	3a cb		 cmp	 cl, bl
  00298	75 f8		 jne	 SHORT $LL33@ExceptCall
  0029a	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
  0029f	66 a5		 movsw
  002a1	a4		 movsb

; 1323 : 			strcat( g_szErrorLog, szTrace );

  002a2	8b f0		 mov	 esi, eax
$LL34@ExceptCall:
  002a4	8a 08		 mov	 cl, BYTE PTR [eax]
  002a6	40		 inc	 eax
  002a7	3a cb		 cmp	 cl, bl
  002a9	75 f9		 jne	 SHORT $LL34@ExceptCall
  002ab	bf 00 00 00 00	 mov	 edi, OFFSET ?g_szErrorLog@@3PADA ; g_szErrorLog
  002b0	2b c6		 sub	 eax, esi
  002b2	4f		 dec	 edi
$LL35@ExceptCall:
  002b3	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  002b6	47		 inc	 edi
  002b7	3a cb		 cmp	 cl, bl
  002b9	75 f8		 jne	 SHORT $LL35@ExceptCall

; 1324 : 		}
; 1325 : 		else
; 1326 : 		{
; 1327 : 			break;
; 1328 : 		}
; 1329 : 
; 1330 : 		szTrace = GetNextStackTraceString( GSTSO_SYMBOL | GSTSO_SRCLINE, pExPtrs );

  002bb	ff b5 94 7e ff
	ff		 push	 DWORD PTR _pExPtrs$GSCopy$[ebp]
  002c1	8b c8		 mov	 ecx, eax
  002c3	c1 e9 02	 shr	 ecx, 2
  002c6	f3 a5		 rep movsd
  002c8	8b c8		 mov	 ecx, eax
  002ca	83 e1 03	 and	 ecx, 3
  002cd	6a 0c		 push	 12			; 0000000cH
  002cf	f3 a4		 rep movsb
  002d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetNextStackTraceString@8
$LN39@ExceptCall:
  002d7	a3 00 00 00 00	 mov	 DWORD PTR ?szTrace@@3PBDB, eax ; szTrace
  002dc	3b c3		 cmp	 eax, ebx
  002de	0f 85 5b ff ff
	ff		 jne	 $LL6@ExceptCall

; 1316 : 	while( szTrace )

  002e4	bf 00 00 00 00	 mov	 edi, OFFSET ?g_szErrorLog@@3PADA ; g_szErrorLog
$LN4@ExceptCall:

; 1331 : 	};
; 1332 : 
; 1333 : 
; 1334 : 	MEMORYSTATUSEX statex;
; 1335 : 	statex.dwLength = sizeof (statex);
; 1336 : 	GlobalMemoryStatusEx (&statex);

  002e9	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _statex$[ebp]
  002ef	50		 push	 eax
  002f0	c7 85 b0 fe ff
	ff 40 00 00 00	 mov	 DWORD PTR _statex$[ebp], 64 ; 00000040H
  002fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalMemoryStatusEx@4

; 1337 : 
; 1338 : 	LOG.PrintTimeAndLog(0, ("There is  %d percent of memory in use."),statex.dwMemoryLoad);

  00300	ff b5 b4 fe ff
	ff		 push	 DWORD PTR _statex$[ebp+4]
  00306	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?PrintTimeAndLog@CLog@@QAAXHPADZZ
  0030c	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@JECOCODG@There?5is?5?5?$CFd?5percent?5of?5memory?5i@
  00311	53		 push	 ebx
  00312	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  00318	ff d6		 call	 esi

; 1339 : 	LOG.PrintTimeAndLog(0, ("There are %d total Mbytes of physical memory."),statex.ullTotalPhys/1048576);

  0031a	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _statex$[ebp+8]
  00320	8b 8d bc fe ff
	ff		 mov	 ecx, DWORD PTR _statex$[ebp+12]
  00326	0f ac c8 14	 shrd	 eax, ecx, 20
  0032a	c1 e9 14	 shr	 ecx, 20			; 00000014H
  0032d	51		 push	 ecx
  0032e	50		 push	 eax
  0032f	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@BBDLDKI@There?5are?5?$CFd?5total?5Mbytes?5of?5phy@
  00334	53		 push	 ebx
  00335	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  0033b	ff d6		 call	 esi

; 1340 : 	LOG.PrintTimeAndLog(0, ("There are %d free Mbytes of physical memory."), statex.ullAvailPhys/1048576);

  0033d	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _statex$[ebp+16]
  00343	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR _statex$[ebp+20]
  00349	0f ac c8 14	 shrd	 eax, ecx, 20
  0034d	c1 e9 14	 shr	 ecx, 20			; 00000014H
  00350	51		 push	 ecx
  00351	50		 push	 eax
  00352	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@KBJGDEHL@There?5are?5?$CFd?5free?5Mbytes?5of?5phys@
  00357	53		 push	 ebx
  00358	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  0035e	ff d6		 call	 esi

; 1341 : 	LOG.PrintTimeAndLog(0, ("There are %d total Mbytes of paging file."), statex.ullTotalPageFile/1048576);

  00360	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _statex$[ebp+24]
  00366	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR _statex$[ebp+28]
  0036c	0f ac c8 14	 shrd	 eax, ecx, 20
  00370	c1 e9 14	 shr	 ecx, 20			; 00000014H
  00373	51		 push	 ecx
  00374	50		 push	 eax
  00375	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@JKOIEDHH@There?5are?5?$CFd?5total?5Mbytes?5of?5pag@
  0037a	53		 push	 ebx
  0037b	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  00381	ff d6		 call	 esi

; 1342 : 	LOG.PrintTimeAndLog(0, ("There are %d free Mbytes of paging file."), statex.ullAvailPageFile/1048576);

  00383	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _statex$[ebp+32]
  00389	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _statex$[ebp+36]
  0038f	0f ac c8 14	 shrd	 eax, ecx, 20
  00393	83 c4 4c	 add	 esp, 76			; 0000004cH
  00396	c1 e9 14	 shr	 ecx, 20			; 00000014H
  00399	51		 push	 ecx
  0039a	50		 push	 eax
  0039b	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@DAJMLJFP@There?5are?5?$CFd?5free?5Mbytes?5of?5pagi@
  003a0	53		 push	 ebx
  003a1	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  003a7	ff d6		 call	 esi

; 1343 : 	LOG.PrintTimeAndLog(0, ("There are %d total Mbytes of virtual memory."), statex.ullTotalVirtual/1048576);

  003a9	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _statex$[ebp+40]
  003af	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _statex$[ebp+44]
  003b5	0f ac c8 14	 shrd	 eax, ecx, 20
  003b9	c1 e9 14	 shr	 ecx, 20			; 00000014H
  003bc	51		 push	 ecx
  003bd	50		 push	 eax
  003be	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@BMCLKNEO@There?5are?5?$CFd?5total?5Mbytes?5of?5vir@
  003c3	53		 push	 ebx
  003c4	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  003ca	ff d6		 call	 esi

; 1344 : 	LOG.PrintTimeAndLog(0, ("There are %d free Mbytes of virtual memory."), statex.ullAvailVirtual/1048576);

  003cc	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _statex$[ebp+48]
  003d2	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _statex$[ebp+52]
  003d8	0f ac c8 14	 shrd	 eax, ecx, 20
  003dc	c1 e9 14	 shr	 ecx, 20			; 00000014H
  003df	51		 push	 ecx
  003e0	50		 push	 eax
  003e1	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@JDEOAGKO@There?5are?5?$CFd?5free?5Mbytes?5of?5virt@
  003e6	53		 push	 ebx
  003e7	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  003ed	ff d6		 call	 esi

; 1345 : 	LOG.PrintTimeAndLog(0, ("There are %d free Mbytes of extended memory."), statex.ullAvailExtendedVirtual/1048576);

  003ef	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _statex$[ebp+56]
  003f5	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _statex$[ebp+60]
  003fb	0f ac c8 14	 shrd	 eax, ecx, 20
  003ff	c1 e9 14	 shr	 ecx, 20			; 00000014H
  00402	51		 push	 ecx
  00403	50		 push	 eax
  00404	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@GMNFKGGD@There?5are?5?$CFd?5free?5Mbytes?5of?5exte@
  00409	53		 push	 ebx
  0040a	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  00410	ff d6		 call	 esi
  00412	83 c4 50	 add	 esp, 80			; 00000050H

; 1346 : 
; 1347 : 	wsprintf( g_szSendErrorLog, "%s\n%s\n%s\n%s\n%s", g_szErrorPos, 
; 1348 : 		g_TCPChecker.GetLOG(), 
; 1349 : 		Setting::GetFullSystemInfo(),
; 1350 : 		Setting::GetSettingString(),
; 1351 : 		g_szErrorLog );

  00415	57		 push	 edi
  00416	e8 00 00 00 00	 call	 ?GetSettingString@Setting@@SAPADXZ ; Setting::GetSettingString
  0041b	50		 push	 eax
  0041c	68 00 00 00 00	 push	 OFFSET ?m_szFullSystemInfo@Setting@@1PADA ; Setting::m_szFullSystemInfo
  00421	e8 00 00 00 00	 call	 ?GetSingleton@ioTCPChecker@@SAAAV1@XZ ; ioTCPChecker::GetSingleton
  00426	8b c8		 mov	 ecx, eax
  00428	e8 00 00 00 00	 call	 ?GetLOG@ioTCPChecker@@QAEPADXZ ; ioTCPChecker::GetLOG
  0042d	50		 push	 eax
  0042e	68 00 00 00 00	 push	 OFFSET ?g_szErrorPos@@3PADA ; g_szErrorPos
  00433	68 00 00 00 00	 push	 OFFSET ??_C@_0P@DNLMMKHH@?$CFs?6?$CFs?6?$CFs?6?$CFs?6?$CFs?$AA@
  00438	be 00 00 00 00	 mov	 esi, OFFSET ?g_szSendErrorLog@@3PADA ; g_szSendErrorLog
  0043d	56		 push	 esi
  0043e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00444	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1352 : 
; 1353 : 	SP2Packet kPacket( LUPK_LOG );

  00447	68 00 90 00 00	 push	 36864			; 00009000H
  0044c	8d 8d 98 7e ff
	ff		 lea	 ecx, DWORD PTR _kPacket$[ebp]
  00452	e8 00 00 00 00	 call	 ??0SP2Packet@@QAE@K@Z	; SP2Packet::SP2Packet

; 1354 : 	kPacket << "ClientError";  // 로그 파일 타입

  00457	68 00 00 00 00	 push	 OFFSET ??_C@_0M@DMGKCCIB@ClientError?$AA@
  0045c	8d 8d 98 7e ff
	ff		 lea	 ecx, DWORD PTR _kPacket$[ebp]
  00462	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00465	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@PBD@Z ; SP2Packet::operator<<

; 1355 : 	kPacket << g_szSendErrorLog;

  0046a	56		 push	 esi
  0046b	8d 8d 98 7e ff
	ff		 lea	 ecx, DWORD PTR _kPacket$[ebp]
  00471	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@PAD@Z ; SP2Packet::operator<<

; 1356 : 	kPacket << 317;  // 오류번호:317

  00476	68 3d 01 00 00	 push	 317			; 0000013dH
  0047b	8d 8d 98 7e ff
	ff		 lea	 ecx, DWORD PTR _kPacket$[ebp]
  00481	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@H@Z ; SP2Packet::operator<<

; 1357 : 	kPacket << true; // write db

  00486	6a 01		 push	 1
  00488	8d 8d 98 7e ff
	ff		 lea	 ecx, DWORD PTR _kPacket$[ebp]
  0048e	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@_N@Z ; SP2Packet::operator<<

; 1358 : 	P2PNetwork::SendLog(kPacket);

  00493	8d 85 98 7e ff
	ff		 lea	 eax, DWORD PTR _kPacket$[ebp]
  00499	50		 push	 eax
  0049a	e8 00 00 00 00	 call	 ?SendLog@P2PNetwork@@YAXAAVSP2Packet@@@Z ; P2PNetwork::SendLog

; 1359 : 
; 1360 : 	STARTUPINFO si;
; 1361 : 	PROCESS_INFORMATION pi;
; 1362 : 
; 1363 : 	ZeroMemory(&si, sizeof(STARTUPINFO));

  0049f	6a 44		 push	 68			; 00000044H
  004a1	5e		 pop	 esi
  004a2	56		 push	 esi
  004a3	8d 85 2c 7e ff
	ff		 lea	 eax, DWORD PTR _si$[ebp]
  004a9	53		 push	 ebx
  004aa	50		 push	 eax
  004ab	e8 00 00 00 00	 call	 _memset
  004b0	83 c4 10	 add	 esp, 16			; 00000010H

; 1364 : 	si.cb = sizeof(STARTUPINFO);

  004b3	89 b5 2c 7e ff
	ff		 mov	 DWORD PTR _si$[ebp], esi

; 1365 : 
; 1366 : 	char buf[256];
; 1367 : 	sprintf(buf, "lsdump.exe LsVer_%s_%s_%s", STRFILEVER, g_MyInfo.GetPrivateID().c_str(), 
; 1368 : 		g_MyInfo.GetPublicID().c_str());

  004b9	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  004be	8b f0		 mov	 esi, eax
  004c0	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  004c5	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
  004c8	8b f8		 mov	 edi, eax
  004ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  004d0	50		 push	 eax
  004d1	8d 4f 0c	 lea	 ecx, DWORD PTR [edi+12]
  004d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  004da	50		 push	 eax
  004db	68 00 00 00 00	 push	 OFFSET ??_C@_05IJNOCPGM@12861?$AA@
  004e0	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  004e6	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@DPLNDBJD@lsdump?4exe?5LsVer_?$CFs_?$CFs_?$CFs?$AA@
  004eb	50		 push	 eax
  004ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  004f2	83 c4 14	 add	 esp, 20			; 00000014H

; 1369 : 
; 1370 : 	if ( CreateProcess(NULL, buf, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi) )

  004f5	8d 85 70 7e ff
	ff		 lea	 eax, DWORD PTR _pi$[ebp]
  004fb	50		 push	 eax
  004fc	8d 85 2c 7e ff
	ff		 lea	 eax, DWORD PTR _si$[ebp]
  00502	50		 push	 eax
  00503	53		 push	 ebx
  00504	53		 push	 ebx
  00505	53		 push	 ebx
  00506	53		 push	 ebx
  00507	53		 push	 ebx
  00508	53		 push	 ebx
  00509	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  0050f	50		 push	 eax
  00510	53		 push	 ebx
  00511	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateProcessA@40
  00517	85 c0		 test	 eax, eax
  00519	74 15		 je	 SHORT $LN2@ExceptCall

; 1371 : 	{
; 1372 : 		LOG.PrintLog(0, " Crash Files Sent ");

  0051b	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@GNMFBGDG@?5Crash?5Files?5Sent?5?$AA@
  00520	53		 push	 ebx
  00521	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  00527	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintLog@CLog@@QAAXHPADZZ
  0052d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@ExceptCall:

; 1373 : 	}
; 1374 : 
; 1375 : 	LOG.PrintLog(0, "---- Crash Help End ----");

  00530	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@KAKCFKFA@?9?9?9?9?5Crash?5Help?5End?5?9?9?9?9?$AA@
  00535	53		 push	 ebx
  00536	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  0053c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintLog@CLog@@QAAXHPADZZ
  00542	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1376 : 
; 1377 : 	if (Success)

  00545	39 9d 8c 7e ff
	ff		 cmp	 DWORD PTR _Success$[ebp], ebx
  0054b	74 19		 je	 SHORT $LN1@ExceptCall
  0054d	33 f6		 xor	 esi, esi
  0054f	46		 inc	 esi
$LN28@ExceptCall:

; 1378 : 		return EXCEPTION_EXECUTE_HANDLER;

  00550	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00554	8d 8d 98 7e ff
	ff		 lea	 ecx, DWORD PTR _kPacket$[ebp]
  0055a	e8 00 00 00 00	 call	 ??1SP2Packet@@UAE@XZ	; SP2Packet::~SP2Packet
  0055f	8b c6		 mov	 eax, esi
  00561	e9 e2 fa ff ff	 jmp	 $LN9@ExceptCall
$LN1@ExceptCall:
  00566	83 ce ff	 or	 esi, -1
  00569	eb e5		 jmp	 SHORT $LN28@ExceptCall
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExceptCallBack@@YGJPAU_EXCEPTION_POINTERS@@@Z$0:
  00000	8d 8d 98 7e ff
	ff		 lea	 ecx, DWORD PTR _kPacket$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1SP2Packet@@UAE@XZ	; SP2Packet::~SP2Packet
__ehhandler$?ExceptCallBack@@YGJPAU_EXCEPTION_POINTERS@@@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 28 7e ff
	ff		 mov	 ecx, DWORD PTR [edx-33240]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ExceptCallBack@@YGJPAU_EXCEPTION_POINTERS@@@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ExceptCallBack@@YGJPAU_EXCEPTION_POINTERS@@@Z ENDP	; ExceptCallBack
PUBLIC	?StringCbPrintfA@@YAJPADIPBDZZ			; StringCbPrintfA
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft sdks\windows\v7.0a\include\strsafe.h
;	COMDAT ?StringCbPrintfA@@YAJPADIPBDZZ
_TEXT	SEGMENT
_pszDest$ = 8						; size = 4
_cbDest$ = 12						; size = 4
_pszFormat$ = 16					; size = 4
?StringCbPrintfA@@YAJPADIPBDZZ PROC			; StringCbPrintfA, COMDAT

; 4767 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4768 :     HRESULT hr;
; 4769 :     size_t cchDest = cbDest / sizeof(char);
; 4770 : 
; 4771 :     hr = StringValidateDestA(pszDest, cchDest, STRSAFE_MAX_CCH);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _cbDest$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	85 c9		 test	 ecx, ecx
  0000a	74 08		 je	 SHORT $LN4@StringCbPr
  0000c	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  00012	76 05		 jbe	 SHORT $LN5@StringCbPr
$LN4@StringCbPr:
  00014	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
$LN5@StringCbPr:

; 4772 :     
; 4773 :     if (SUCCEEDED(hr))

  00019	85 c0		 test	 eax, eax
  0001b	78 39		 js	 SHORT $LN1@StringCbPr

; 4774 :     {
; 4775 :         va_list argList;
; 4776 : 
; 4777 :         va_start(argList, pszFormat);
; 4778 : 
; 4779 :         hr = StringVPrintfWorkerA(pszDest,
; 4780 :                                   cchDest,
; 4781 :                                   NULL,
; 4782 :                                   pszFormat,
; 4783 :                                   argList);

  0001d	53		 push	 ebx
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	8b 7d 08	 mov	 edi, DWORD PTR _pszDest$[ebp]
  00023	8d 45 14	 lea	 eax, DWORD PTR _pszFormat$[ebp+4]
  00026	50		 push	 eax
  00027	ff 75 10	 push	 DWORD PTR _pszFormat$[ebp]
  0002a	8d 71 ff	 lea	 esi, DWORD PTR [ecx-1]
  0002d	56		 push	 esi
  0002e	57		 push	 edi
  0002f	33 db		 xor	 ebx, ebx
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___vsnprintf
  00037	83 c4 10	 add	 esp, 16			; 00000010H
  0003a	85 c0		 test	 eax, eax
  0003c	78 0b		 js	 SHORT $LN12@StringCbPr
  0003e	3b c6		 cmp	 eax, esi
  00040	77 07		 ja	 SHORT $LN12@StringCbPr
  00042	75 0d		 jne	 SHORT $LN9@StringCbPr
  00044	88 1c 3e	 mov	 BYTE PTR [esi+edi], bl
  00047	eb 08		 jmp	 SHORT $LN9@StringCbPr
$LN12@StringCbPr:
  00049	88 1c 3e	 mov	 BYTE PTR [esi+edi], bl
  0004c	bb 7a 00 07 80	 mov	 ebx, -2147024774	; 8007007aH
$LN9@StringCbPr:
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	8b c3		 mov	 eax, ebx
  00055	5b		 pop	 ebx
$LN1@StringCbPr:

; 4784 : 
; 4785 :         va_end(argList);
; 4786 :     }
; 4787 : 
; 4788 :     return hr;
; 4789 : }

  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?StringCbPrintfA@@YAJPADIPBDZZ ENDP			; StringCbPrintfA
_TEXT	ENDS
PUBLIC	??_C@_09OLCKPLJB@Lost?5Saga?$AA@		; `string'
PUBLIC	??_C@_0N@MAOBBNPD@ErrorDlgProc?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	_hDlg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?ErrorDlgProc@@YGHPAUHWND__@@IIJ@Z		; ErrorDlgProc
EXTRN	__imp__SetWindowTextA@8:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__EnableWindow@8:PROC
EXTRN	__imp__SetForegroundWindow@4:PROC
EXTRN	__imp__SetDlgItemTextA@12:PROC
EXTRN	__imp_?SafeSprintf@@YAXPADHPBD11@Z:PROC
EXTRN	__imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z:PROC
EXTRN	__imp_?GetSingleton@ioStringManager@@SAAAV1@XZ:PROC
EXTRN	__imp__SetWindowPos@28:PROC
EXTRN	__imp__CreateSolidBrush@4:PROC
EXTRN	__imp__SetWindowLongA@12:PROC
EXTRN	__imp__GetWindowLongA@8:PROC
EXTRN	__imp__MoveWindow@24:PROC
EXTRN	__imp__GetDlgItem@8:PROC
EXTRN	?Enable@CSkin@@QAE_N_N@Z:PROC			; CSkin::Enable
EXTRN	?Hook@CSkin@@QAE_NPAUHWND__@@@Z:PROC		; CSkin::Hook
EXTRN	?ExcuteWeb@Help@@YAXPBD@Z:PROC			; Help::ExcuteWeb
EXTRN	?GetLocal@ioLocalManager@@QAEPAVioLocalParent@@W4LocalType@ioLocalManagerParent@@@Z:PROC ; ioLocalManager::GetLocal
EXTRN	?GetSingleton@ioLocalManager@@SAAAV1@XZ:PROC	; ioLocalManager::GetSingleton
EXTRN	__imp_?GetLocalType@ioLocalManagerParent@@SA?AW4LocalType@1@XZ:PROC
EXTRN	__imp__DeleteObject@4:PROC
EXTRN	__imp__EndDialog@8:PROC
EXTRN	__imp__SetBkColor@8:PROC
EXTRN	__imp__SetTextColor@8:PROC
;	COMDAT ?szEditText@?1??ErrorDlgProc@@YGHPAUHWND__@@IIJ@Z@4PADA
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\setting.h
_BSS	SEGMENT
?szEditText@?1??ErrorDlgProc@@YGHPAUHWND__@@IIJ@Z@4PADA DB 02000H DUP (?) ; `ErrorDlgProc'::`2'::szEditText
_BSS	ENDS
;	COMDAT ??_C@_09OLCKPLJB@Lost?5Saga?$AA@
CONST	SEGMENT
??_C@_09OLCKPLJB@Lost?5Saga?$AA@ DB 'Lost Saga', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MAOBBNPD@ErrorDlgProc?$AA@
CONST	SEGMENT
??_C@_0N@MAOBBNPD@ErrorDlgProc?$AA@ DB 'ErrorDlgProc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\main.cpp
CONST	ENDS
;	COMDAT ?ErrorDlgProc@@YGHPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_hDlg$GSCopy$ = -288					; size = 4
_winwidth$519546 = -284					; size = 4
_hWndCtrl$519530 = -284					; size = 4
_workrect$519543 = -280					; size = 16
_szURL$519585 = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_hDlg$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?ErrorDlgProc@@YGHPAUHWND__@@IIJ@Z PROC			; ErrorDlgProc, COMDAT

; 585  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 586  : 	static char szEditText[4096 * 2];
; 587  : 
; 588  : 	switch(message)

  00013	8b 45 0c	 mov	 eax, DWORD PTR _message$[ebp]
  00016	83 e8 2b	 sub	 eax, 43			; 0000002bH
  00019	53		 push	 ebx
  0001a	8b 5d 08	 mov	 ebx, DWORD PTR _hDlg$[ebp]
  0001d	56		 push	 esi
  0001e	8b 75 10	 mov	 esi, DWORD PTR _wParam$[ebp]

; 597  : 			}
; 598  : 			//
; 599  : 
; 600  : 			// edit skin
; 601  : 			g_hEdit = GetDlgItem( hDlg, IDC_ERROR_EDIT );

  00021	89 9d e0 fe ff
	ff		 mov	 DWORD PTR _hDlg$GSCopy$[ebp], ebx
  00027	0f 84 40 03 00
	00		 je	 $LN8@ErrorDlgPr

; 586  : 	static char szEditText[4096 * 2];
; 587  : 
; 588  : 	switch(message)

  0002d	2d e5 00 00 00	 sub	 eax, 229		; 000000e5H
  00032	0f 84 e9 00 00
	00		 je	 $LN13@ErrorDlgPr
  00038	48		 dec	 eax
  00039	74 3d		 je	 SHORT $LN6@ErrorDlgPr
  0003b	83 e8 27	 sub	 eax, 39			; 00000027H
  0003e	74 07		 je	 SHORT $LN10@ErrorDlgPr

; 712  : 		}
; 713  : 		return TRUE;
; 714  : 	}
; 715  : 
; 716  : 	return FALSE;

  00040	33 c0		 xor	 eax, eax
  00042	e9 34 03 00 00	 jmp	 $LN16@ErrorDlgPr
$LN10@ErrorDlgPr:

; 672  : 	case WM_CTLCOLORSTATIC:
; 673  : 		if( (HWND) lParam == g_hEdit )

  00047	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  0004a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?g_hEdit@@3PAUHWND__@@A ; g_hEdit
  00050	0f 85 22 03 00
	00		 jne	 $LN9@ErrorDlgPr

; 674  : 		{
; 675  : 			SetTextColor( (HDC)wParam, ERROR_EDIT_TEXT_RGB );

  00056	68 3a 3a 3a 00	 push	 3815994			; 003a3a3aH
  0005b	56		 push	 esi
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTextColor@8

; 676  : 			SetBkColor( (HDC)wParam, ERROR_EDIT_BK_RGB );

  00062	68 eb eb eb 00	 push	 15461355		; 00ebebebH
  00067	56		 push	 esi
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkColor@8

; 677  : 			return (BOOL) g_hBrushEdit;

  0006e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hBrushEdit@@3PAUHBRUSH__@@A ; g_hBrushEdit
  00073	e9 03 03 00 00	 jmp	 $LN16@ErrorDlgPr
$LN6@ErrorDlgPr:

; 684  : 	case WM_COMMAND:
; 685  : 		switch( LOWORD(wParam) )

  00078	0f b7 c6	 movzx	 eax, si
  0007b	85 c0		 test	 eax, eax
  0007d	0f 8e f5 02 00
	00		 jle	 $LN9@ErrorDlgPr
  00083	83 f8 02	 cmp	 eax, 2
  00086	7e 12		 jle	 SHORT $LN3@ErrorDlgPr
  00088	3d 02 04 00 00	 cmp	 eax, 1026		; 00000402H
  0008d	74 25		 je	 SHORT $LN2@ErrorDlgPr
  0008f	3d 04 04 00 00	 cmp	 eax, 1028		; 00000404H
  00094	0f 85 de 02 00
	00		 jne	 $LN9@ErrorDlgPr
$LN3@ErrorDlgPr:

; 686  : 		{
; 687  : 		case IDOK:
; 688  : 		case IDCANCEL:
; 689  : 		case IDC_X:
; 690  : 			EndDialog( hDlg, 0 );

  0009a	6a 00		 push	 0
  0009c	53		 push	 ebx
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndDialog@8

; 691  : 			DeleteObject( g_hBrushEdit );

  000a3	ff 35 00 00 00
	00		 push	 DWORD PTR ?g_hBrushEdit@@3PAUHBRUSH__@@A ; g_hBrushEdit
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4

; 692  : 			return TRUE;

  000af	e9 c4 02 00 00	 jmp	 $LN9@ErrorDlgPr
$LN2@ErrorDlgPr:

; 693  : 		case IDC_SOLUTION:
; 694  : 			{
; 695  : 				ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );

  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLocalType@ioLocalManagerParent@@SA?AW4LocalType@1@XZ
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 ?GetSingleton@ioLocalManager@@SAAAV1@XZ ; ioLocalManager::GetSingleton
  000c0	8b c8		 mov	 ecx, eax
  000c2	e8 00 00 00 00	 call	 ?GetLocal@ioLocalManager@@QAEPAVioLocalParent@@W4LocalType@ioLocalManagerParent@@@Z ; ioLocalManager::GetLocal
  000c7	8b f0		 mov	 esi, eax

; 696  : 				if( pLocal )

  000c9	85 f6		 test	 esi, esi
  000cb	0f 84 a7 02 00
	00		 je	 $LN9@ErrorDlgPr

; 697  : 				{
; 698  : 					//기능블럭
; 699  : 					//if( g_iErrorNumber == 328 )
; 700  : 					//{
; 701  : 					//	pLocal->ShowHackShieldErrorDlg( g_MyInfo.GetPrivateID() );
; 702  : 					//}
; 703  : 					//else
; 704  : 					{
; 705  : 						char szURL[MAX_PATH]="";

  000d1	68 03 01 00 00	 push	 259			; 00000103H
  000d6	8d 85 f9 fe ff
	ff		 lea	 eax, DWORD PTR _szURL$519585[ebp+1]
  000dc	6a 00		 push	 0
  000de	50		 push	 eax
  000df	c6 85 f8 fe ff
	ff 00		 mov	 BYTE PTR _szURL$519585[ebp], 0
  000e6	e8 00 00 00 00	 call	 _memset

; 706  : 						StringCbPrintf( szURL, sizeof(szURL), pLocal->GetErrorSolutionURL(), g_iErrorNumber );

  000eb	8b 06		 mov	 eax, DWORD PTR [esi]
  000ed	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f0	ff 35 00 00 00
	00		 push	 DWORD PTR ?g_iErrorNumber@@3HA ; g_iErrorNumber
  000f6	8b ce		 mov	 ecx, esi
  000f8	ff 50 6c	 call	 DWORD PTR [eax+108]
  000fb	50		 push	 eax
  000fc	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szURL$519585[ebp]
  00102	68 04 01 00 00	 push	 260			; 00000104H
  00107	50		 push	 eax
  00108	e8 00 00 00 00	 call	 ?StringCbPrintfA@@YAJPADIPBDZZ ; StringCbPrintfA

; 707  : 						Help::ExcuteWeb( szURL );

  0010d	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szURL$519585[ebp]
  00113	50		 push	 eax
  00114	e8 00 00 00 00	 call	 ?ExcuteWeb@Help@@YAXPBD@Z ; Help::ExcuteWeb
  00119	83 c4 14	 add	 esp, 20			; 00000014H

; 708  : 					}
; 709  : 				}
; 710  : 			}
; 711  : 			return TRUE;

  0011c	e9 57 02 00 00	 jmp	 $LN9@ErrorDlgPr
$LN13@ErrorDlgPr:

; 589  : 	{
; 590  : 	case WM_INITDIALOG:
; 591  : 		{
; 592  : 			// back skin
; 593  : 			if( g_pErrorDlgSkin )

  00121	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pErrorDlgSkin@@3PAVCSkin@@A ; g_pErrorDlgSkin
  00127	85 c9		 test	 ecx, ecx
  00129	74 13		 je	 SHORT $LN24@ErrorDlgPr

; 594  : 			{
; 595  : 				g_pErrorDlgSkin->Hook(hDlg);

  0012b	53		 push	 ebx
  0012c	e8 00 00 00 00	 call	 ?Hook@CSkin@@QAE_NPAUHWND__@@@Z ; CSkin::Hook

; 596  : 				g_pErrorDlgSkin->Enable(true);

  00131	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pErrorDlgSkin@@3PAVCSkin@@A ; g_pErrorDlgSkin
  00137	6a 01		 push	 1
  00139	e8 00 00 00 00	 call	 ?Enable@CSkin@@QAE_N_N@Z ; CSkin::Enable
$LN24@ErrorDlgPr:

; 597  : 			}
; 598  : 			//
; 599  : 
; 600  : 			// edit skin
; 601  : 			g_hEdit = GetDlgItem( hDlg, IDC_ERROR_EDIT );

  0013e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  00144	57		 push	 edi
  00145	68 ff 03 00 00	 push	 1023			; 000003ffH
  0014a	53		 push	 ebx
  0014b	ff d6		 call	 esi

; 602  : 			MoveWindow(g_hEdit, 18, 47, ERROR_EDIT_WIDTH, ERROR_EDIT_HEIGHT, TRUE);

  0014d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__MoveWindow@24
  00153	6a 01		 push	 1
  00155	68 bf 00 00 00	 push	 191			; 000000bfH
  0015a	68 78 01 00 00	 push	 376			; 00000178H
  0015f	6a 2f		 push	 47			; 0000002fH
  00161	6a 12		 push	 18			; 00000012H
  00163	50		 push	 eax
  00164	a3 00 00 00 00	 mov	 DWORD PTR ?g_hEdit@@3PAUHWND__@@A, eax ; g_hEdit
  00169	ff d7		 call	 edi

; 603  : 			//
; 604  : 
; 605  : 			// btn 
; 606  : 			HWND hWndCtrl = GetDlgItem( hDlg, IDC_X );

  0016b	68 04 04 00 00	 push	 1028			; 00000404H
  00170	53		 push	 ebx
  00171	ff d6		 call	 esi

; 607  : 			MoveWindow(hWndCtrl, 380, 5, ERROR_X_WIDTH, ERROR_X_HEIGHT, TRUE);

  00173	6a 01		 push	 1
  00175	6a 1a		 push	 26			; 0000001aH
  00177	6a 19		 push	 25			; 00000019H
  00179	6a 05		 push	 5
  0017b	68 7c 01 00 00	 push	 380			; 0000017cH
  00180	50		 push	 eax
  00181	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _hWndCtrl$519530[ebp], eax
  00187	ff d7		 call	 edi

; 608  : 			g_OldXProc = (WNDPROC)GetWindowLong(hWndCtrl, GWL_WNDPROC);

  00189	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetWindowLongA@8
  0018f	6a fc		 push	 -4			; fffffffcH
  00191	ff b5 e4 fe ff
	ff		 push	 DWORD PTR _hWndCtrl$519530[ebp]
  00197	ff d3		 call	 ebx

; 609  : 			SetWindowLong(hWndCtrl, GWL_WNDPROC, (LONG)XProc);

  00199	68 00 00 00 00	 push	 OFFSET ?XProc@@YGJPAUHWND__@@IIJ@Z ; XProc
  0019e	6a fc		 push	 -4			; fffffffcH
  001a0	ff b5 e4 fe ff
	ff		 push	 DWORD PTR _hWndCtrl$519530[ebp]
  001a6	a3 00 00 00 00	 mov	 DWORD PTR ?g_OldXProc@@3P6GJPAUHWND__@@IIJ@ZA, eax ; g_OldXProc
  001ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowLongA@12

; 610  : 
; 611  : 			hWndCtrl = GetDlgItem( hDlg, IDC_SOLUTION );

  001b1	68 02 04 00 00	 push	 1026			; 00000402H
  001b6	ff b5 e0 fe ff
	ff		 push	 DWORD PTR _hDlg$GSCopy$[ebp]
  001bc	ff d6		 call	 esi

; 612  : 			MoveWindow(hWndCtrl, 17, 252, ERROR_SOLUTION_WIDTH, ERROR_SOLUTION_HEIGHT, TRUE);

  001be	6a 01		 push	 1
  001c0	6a 1f		 push	 31			; 0000001fH
  001c2	68 1e 01 00 00	 push	 286			; 0000011eH
  001c7	68 fc 00 00 00	 push	 252			; 000000fcH
  001cc	6a 11		 push	 17			; 00000011H
  001ce	50		 push	 eax
  001cf	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _hWndCtrl$519530[ebp], eax
  001d5	ff d7		 call	 edi

; 613  : 			g_OldSolutionProc = (WNDPROC)GetWindowLong(hWndCtrl, GWL_WNDPROC);

  001d7	6a fc		 push	 -4			; fffffffcH
  001d9	ff b5 e4 fe ff
	ff		 push	 DWORD PTR _hWndCtrl$519530[ebp]
  001df	ff d3		 call	 ebx

; 614  : 			SetWindowLong(hWndCtrl, GWL_WNDPROC, (LONG)SolutionProc);

  001e1	68 00 00 00 00	 push	 OFFSET ?SolutionProc@@YGJPAUHWND__@@IIJ@Z ; SolutionProc
  001e6	6a fc		 push	 -4			; fffffffcH
  001e8	ff b5 e4 fe ff
	ff		 push	 DWORD PTR _hWndCtrl$519530[ebp]
  001ee	a3 00 00 00 00	 mov	 DWORD PTR ?g_OldSolutionProc@@3P6GJPAUHWND__@@IIJ@ZA, eax ; g_OldSolutionProc
  001f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowLongA@12

; 615  : 
; 616  : 			hWndCtrl = GetDlgItem( hDlg, IDOK );

  001f9	6a 01		 push	 1
  001fb	ff b5 e0 fe ff
	ff		 push	 DWORD PTR _hDlg$GSCopy$[ebp]
  00201	ff d6		 call	 esi

; 617  : 			MoveWindow(hWndCtrl, 305, 252, ERROR_EXIT_WIDTH, ERROR_EXIT_HEIGHT, TRUE);

  00203	6a 01		 push	 1
  00205	6a 1f		 push	 31			; 0000001fH
  00207	6a 58		 push	 88			; 00000058H
  00209	68 fc 00 00 00	 push	 252			; 000000fcH
  0020e	68 31 01 00 00	 push	 305			; 00000131H
  00213	50		 push	 eax
  00214	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _hWndCtrl$519530[ebp], eax
  0021a	ff d7		 call	 edi

; 618  : 			g_OldExitProc = (WNDPROC)GetWindowLong(hWndCtrl, GWL_WNDPROC);

  0021c	6a fc		 push	 -4			; fffffffcH
  0021e	ff b5 e4 fe ff
	ff		 push	 DWORD PTR _hWndCtrl$519530[ebp]
  00224	ff d3		 call	 ebx

; 619  : 			SetWindowLong(hWndCtrl, GWL_WNDPROC, (LONG)ExitProc);

  00226	68 00 00 00 00	 push	 OFFSET ?ExitProc@@YGJPAUHWND__@@IIJ@Z ; ExitProc
  0022b	6a fc		 push	 -4			; fffffffcH
  0022d	ff b5 e4 fe ff
	ff		 push	 DWORD PTR _hWndCtrl$519530[ebp]
  00233	a3 00 00 00 00	 mov	 DWORD PTR ?g_OldExitProc@@3P6GJPAUHWND__@@IIJ@ZA, eax ; g_OldExitProc
  00238	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowLongA@12

; 620  : 			//
; 621  : 
; 622  : 			g_hBrushEdit = CreateSolidBrush( ERROR_EDIT_BK_RGB );

  0023e	68 eb eb eb 00	 push	 15461355		; 00ebebebH
  00243	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateSolidBrush@4

; 623  : 
; 624  : 			//----------창 중간에 띄우기 ---------------------
; 625  : 			RECT workrect;
; 626  : 			// Find how large the desktop work area is
; 627  : 			SystemParametersInfo(SPI_GETWORKAREA, 0, &workrect, 0);

  00249	6a 00		 push	 0
  0024b	a3 00 00 00 00	 mov	 DWORD PTR ?g_hBrushEdit@@3PAUHBRUSH__@@A, eax ; g_hBrushEdit
  00250	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _workrect$519543[ebp]
  00256	50		 push	 eax
  00257	6a 00		 push	 0
  00259	6a 30		 push	 48			; 00000030H
  0025b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SystemParametersInfoA@16

; 628  : 			int workwidth  = workrect.right -  workrect.left;

  00261	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _workrect$519543[ebp+8]
  00267	2b 8d e8 fe ff
	ff		 sub	 ecx, DWORD PTR _workrect$519543[ebp]

; 629  : 			int workheight = workrect.bottom - workrect.top;

  0026d	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _workrect$519543[ebp+12]
  00273	2b 85 ec fe ff
	ff		 sub	 eax, DWORD PTR _workrect$519543[ebp+4]

; 630  : 
; 631  : 			// And how big the window is
; 632  : 			int winwidth  = ERROR_DLG_WIDTH;

  00279	ba 9a 01 00 00	 mov	 edx, 410		; 0000019aH
  0027e	89 95 e4 fe ff
	ff		 mov	 DWORD PTR _winwidth$519546[ebp], edx

; 633  : 			int winheight = ERROR_DLG_HEIGHT;

  00284	8d 7a 90	 lea	 edi, DWORD PTR [edx-112]

; 634  : 			// Make sure it"s not bigger than the work area
; 635  : 			winwidth  = min(winwidth, workwidth);

  00287	3b ca		 cmp	 ecx, edx
  00289	7f 06		 jg	 SHORT $LN25@ErrorDlgPr
  0028b	89 8d e4 fe ff
	ff		 mov	 DWORD PTR _winwidth$519546[ebp], ecx
$LN25@ErrorDlgPr:

; 636  : 			winheight = min(winheight, workheight);

  00291	3b c7		 cmp	 eax, edi
  00293	0f 4e f8	 cmovle	 edi, eax

; 637  : 
; 638  : 			// Now center it
; 639  : 			SetWindowPos( hDlg,
; 640  : 						  HWND_TOP,
; 641  : 						  workrect.left + (workwidth-winwidth) / 2,
; 642  : 						  workrect.top + (workheight-winheight) / 2,
; 643  : 						  winwidth, winheight, 
; 644  : 						  SWP_SHOWWINDOW);

  00296	2b c7		 sub	 eax, edi
  00298	99		 cdq
  00299	2b c2		 sub	 eax, edx
  0029b	8b 9d e0 fe ff
	ff		 mov	 ebx, DWORD PTR _hDlg$GSCopy$[ebp]
  002a1	6a 40		 push	 64			; 00000040H
  002a3	d1 f8		 sar	 eax, 1
  002a5	03 85 ec fe ff
	ff		 add	 eax, DWORD PTR _workrect$519543[ebp+4]
  002ab	57		 push	 edi
  002ac	ff b5 e4 fe ff
	ff		 push	 DWORD PTR _winwidth$519546[ebp]
  002b2	50		 push	 eax
  002b3	8b c1		 mov	 eax, ecx
  002b5	2b 85 e4 fe ff
	ff		 sub	 eax, DWORD PTR _winwidth$519546[ebp]
  002bb	99		 cdq
  002bc	2b c2		 sub	 eax, edx
  002be	d1 f8		 sar	 eax, 1
  002c0	03 85 e8 fe ff
	ff		 add	 eax, DWORD PTR _workrect$519543[ebp]
  002c6	50		 push	 eax
  002c7	6a 00		 push	 0
  002c9	53		 push	 ebx
  002ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowPos@28

; 645  : 			//----------------------------------------------------------
; 646  : 
; 647  : 			SafeSprintf(    szEditText,
; 648  : 				            sizeof( szEditText ),
; 649  : 					        STR(1),
; 650  : 					        Setting::GetFullSystemInfo(),
; 651  : 					        g_szErrorLog );

  002d0	68 00 00 00 00	 push	 OFFSET ?g_szErrorLog@@3PADA ; g_szErrorLog
  002d5	68 00 00 00 00	 push	 OFFSET ?m_szFullSystemInfo@Setting@@1PADA ; Setting::m_szFullSystemInfo
  002da	6a 00		 push	 0
  002dc	6a 01		 push	 1
  002de	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  002e3	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MAOBBNPD@ErrorDlgProc?$AA@
  002e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  002ee	8b c8		 mov	 ecx, eax
  002f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  002f6	50		 push	 eax
  002f7	68 00 20 00 00	 push	 8192			; 00002000H
  002fc	bf 00 00 00 00	 mov	 edi, OFFSET ?szEditText@?1??ErrorDlgProc@@YGHPAUHWND__@@IIJ@Z@4PADA
  00301	57		 push	 edi
  00302	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SafeSprintf@@YAXPADHPBD11@Z
  00308	83 c4 14	 add	 esp, 20			; 00000014H

; 652  : 
; 653  : #ifdef MESSAGEBOX_UNICODE
; 654  : 			std::wstring strText = CA2W(szEditText, COUNTRY_CODE_PAGE);
; 655  : 			SetDlgItemTextW( hDlg, IDC_ERROR_EDIT, strText.c_str() );
; 656  : #else
; 657  : 			SetDlgItemText( hDlg, IDC_ERROR_EDIT, szEditText );

  0030b	57		 push	 edi
  0030c	68 ff 03 00 00	 push	 1023			; 000003ffH
  00311	53		 push	 ebx
  00312	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetDlgItemTextA@12

; 658  : #endif
; 659  : 			SetForegroundWindow( hDlg );

  00318	53		 push	 ebx
  00319	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetForegroundWindow@4

; 660  : 
; 661  : 			ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );

  0031f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLocalType@ioLocalManagerParent@@SA?AW4LocalType@1@XZ
  00325	50		 push	 eax
  00326	e8 00 00 00 00	 call	 ?GetSingleton@ioLocalManager@@SAAAV1@XZ ; ioLocalManager::GetSingleton
  0032b	8b c8		 mov	 ecx, eax
  0032d	e8 00 00 00 00	 call	 ?GetLocal@ioLocalManager@@QAEPAVioLocalParent@@W4LocalType@ioLocalManagerParent@@@Z ; ioLocalManager::GetLocal
  00332	5f		 pop	 edi

; 662  : 			if( pLocal && pLocal->GetResourceIDErrorSolutionN() == -1 )

  00333	85 c0		 test	 eax, eax
  00335	74 28		 je	 SHORT $LN11@ErrorDlgPr
  00337	8b 10		 mov	 edx, DWORD PTR [eax]
  00339	8b c8		 mov	 ecx, eax
  0033b	ff 52 44	 call	 DWORD PTR [edx+68]
  0033e	83 f8 ff	 cmp	 eax, -1
  00341	75 1c		 jne	 SHORT $LN11@ErrorDlgPr

; 663  : 			{
; 664  : 				HWND hChildWnd = GetDlgItem( hDlg, IDC_SOLUTION );

  00343	68 02 04 00 00	 push	 1026			; 00000402H
  00348	53		 push	 ebx
  00349	ff d6		 call	 esi
  0034b	8b f0		 mov	 esi, eax

; 665  : 				EnableWindow( hChildWnd, false );

  0034d	6a 00		 push	 0
  0034f	56		 push	 esi
  00350	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 666  : 				ShowWindow( hChildWnd, SW_HIDE );

  00356	6a 00		 push	 0
  00358	56		 push	 esi
  00359	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8
$LN11@ErrorDlgPr:

; 667  : 			}
; 668  : 
; 669  : 			SetWindowText( hDlg, "Lost Saga" ); 

  0035f	68 00 00 00 00	 push	 OFFSET ??_C@_09OLCKPLJB@Lost?5Saga?$AA@
  00364	53		 push	 ebx
  00365	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8

; 670  : 		}
; 671  : 		return TRUE;

  0036b	eb 0b		 jmp	 SHORT $LN9@ErrorDlgPr
$LN8@ErrorDlgPr:

; 678  : 		}
; 679  : 		else
; 680  : 			return TRUE;
; 681  : 	case WM_DRAWITEM:	
; 682  : 		OnDrawItem(lParam, wParam);

  0036d	56		 push	 esi
  0036e	ff 75 14	 push	 DWORD PTR _lParam$[ebp]
  00371	e8 00 00 00 00	 call	 ?OnDrawItem@@YAXJI@Z	; OnDrawItem
  00376	59		 pop	 ecx
  00377	59		 pop	 ecx
$LN9@ErrorDlgPr:

; 683  : 		return TRUE;

  00378	33 c0		 xor	 eax, eax
  0037a	40		 inc	 eax
$LN16@ErrorDlgPr:

; 717  : }

  0037b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0037e	5e		 pop	 esi
  0037f	33 cd		 xor	 ecx, ebp
  00381	5b		 pop	 ebx
  00382	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00387	c9		 leave
  00388	c2 10 00	 ret	 16			; 00000010H
?ErrorDlgProc@@YGHPAUHWND__@@IIJ@Z ENDP			; ErrorDlgProc
_TEXT	ENDS
PUBLIC	??_C@_0BA@JAIIHPNB@?$CFs?2ErrorDlg?4exe?$AA@	; `string'
PUBLIC	??_C@_09EOPAKANI@?$CFs?$FO?$CFs?$FO?$CFs?$FO?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?ShowOtherErrorDlg@@YAXPAUHINSTANCE__@@@Z	; ShowOtherErrorDlg
EXTRN	?ExcuteProcess@Help@@YAXPAD0@Z:PROC		; Help::ExcuteProcess
EXTRN	__imp__access:PROC
EXTRN	__imp__GetCurrentDirectoryA@8:PROC
EXTRN	__imp__sprintf_s:PROC
EXTRN	__imp__itoa:PROC
;	COMDAT ??_C@_0BA@JAIIHPNB@?$CFs?2ErrorDlg?4exe?$AA@
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\setting.h
CONST	SEGMENT
??_C@_0BA@JAIIHPNB@?$CFs?2ErrorDlg?4exe?$AA@ DB '%s\ErrorDlg.exe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09EOPAKANI@?$CFs?$FO?$CFs?$FO?$CFs?$FO?$AA@
CONST	SEGMENT
??_C@_09EOPAKANI@?$CFs?$FO?$CFs?$FO?$CFs?$FO?$AA@ DB '%s^%s^%s^', 00H ; `string'
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\main.cpp
CONST	ENDS
;	COMDAT ?ShowOtherErrorDlg@@YAXPAUHINSTANCE__@@@Z
_TEXT	SEGMENT
_szEditText$ = -2832					; size = 2048
_szRootDir$ = -784					; size = 260
_szLocal$ = -524					; size = 260
_szLauncherPath$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_hInstance$ = 8						; size = 4
?ShowOtherErrorDlg@@YAXPAUHINSTANCE__@@@Z PROC		; ShowOtherErrorDlg, COMDAT

; 720  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 0b 00
	00		 sub	 esp, 2832		; 00000b10H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 721  : 	if( ioLocalManager::GetLocalType() == ioLocalManager::LCT_THAILAND )

  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLocalType@ioLocalManagerParent@@SA?AW4LocalType@1@XZ
  00019	3d e3 f1 b0 2f	 cmp	 eax, 800125411		; 2fb0f1e3H
  0001e	0f 84 fb 00 00
	00		 je	 $LN2@ShowOtherE

; 722  : 		return;
; 723  : 
; 724  : 	TCHAR szEditText[2048] = {0,};

  00024	53		 push	 ebx
  00025	56		 push	 esi
  00026	57		 push	 edi
  00027	33 db		 xor	 ebx, ebx
  00029	68 ff 07 00 00	 push	 2047			; 000007ffH
  0002e	8d 85 f1 f4 ff
	ff		 lea	 eax, DWORD PTR _szEditText$[ebp+1]
  00034	53		 push	 ebx
  00035	50		 push	 eax
  00036	88 9d f0 f4 ff
	ff		 mov	 BYTE PTR _szEditText$[ebp], bl
  0003c	e8 00 00 00 00	 call	 _memset

; 725  : 	char szTemp[9] = "SOJINLOV";
; 726  : 	char szLocal[MAX_PATH] = {0,};

  00041	be 03 01 00 00	 mov	 esi, 259		; 00000103H
  00046	56		 push	 esi
  00047	8d 85 f5 fd ff
	ff		 lea	 eax, DWORD PTR _szLocal$[ebp+1]
  0004d	53		 push	 ebx
  0004e	50		 push	 eax
  0004f	88 9d f4 fd ff
	ff		 mov	 BYTE PTR _szLocal$[ebp], bl
  00055	e8 00 00 00 00	 call	 _memset

; 727  : 
; 728  : 	DWORD LocalData = g_LocalMgr.GetLocalType();

  0005a	e8 00 00 00 00	 call	 ?GetSingleton@ioLocalManager@@SAAAV1@XZ ; ioLocalManager::GetSingleton
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLocalType@ioLocalManagerParent@@SA?AW4LocalType@1@XZ

; 729  : 	itoa(LocalData, szLocal, 10);

  00065	6a 0a		 push	 10			; 0000000aH
  00067	8d 8d f4 fd ff
	ff		 lea	 ecx, DWORD PTR _szLocal$[ebp]
  0006d	51		 push	 ecx
  0006e	50		 push	 eax
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__itoa

; 730  : 
; 731  : 	sprintf_s(	szEditText, 
; 732  : 		sizeof(szEditText), 
; 733  : 		"%s^%s^%s^", 
; 734  : 		Setting::GetFullSystemInfo(), 
; 735  : 		g_szErrorLog,
; 736  : 		szLocal
; 737  : 		);

  00075	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szLocal$[ebp]
  0007b	50		 push	 eax
  0007c	68 00 00 00 00	 push	 OFFSET ?g_szErrorLog@@3PADA ; g_szErrorLog
  00081	68 00 00 00 00	 push	 OFFSET ?m_szFullSystemInfo@Setting@@1PADA ; Setting::m_szFullSystemInfo
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_09EOPAKANI@?$CFs?$FO?$CFs?$FO?$CFs?$FO?$AA@
  0008b	8d 85 f0 f4 ff
	ff		 lea	 eax, DWORD PTR _szEditText$[ebp]
  00091	68 00 08 00 00	 push	 2048			; 00000800H
  00096	50		 push	 eax
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf_s

; 738  : 
; 739  : 	char szRootDir[MAX_PATH]="";

  0009d	56		 push	 esi
  0009e	8d 85 f1 fc ff
	ff		 lea	 eax, DWORD PTR _szRootDir$[ebp+1]
  000a4	53		 push	 ebx
  000a5	50		 push	 eax
  000a6	88 9d f0 fc ff
	ff		 mov	 BYTE PTR _szRootDir$[ebp], bl
  000ac	e8 00 00 00 00	 call	 _memset
  000b1	83 c4 48	 add	 esp, 72			; 00000048H

; 740  : 	::GetCurrentDirectory(MAX_PATH,szRootDir);

  000b4	8d 85 f0 fc ff
	ff		 lea	 eax, DWORD PTR _szRootDir$[ebp]
  000ba	50		 push	 eax
  000bb	8d 7e 01	 lea	 edi, DWORD PTR [esi+1]
  000be	57		 push	 edi
  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentDirectoryA@8

; 741  : 
; 742  : 	char szLauncherPath[MAX_PATH]="";

  000c5	56		 push	 esi
  000c6	8d 85 f9 fe ff
	ff		 lea	 eax, DWORD PTR _szLauncherPath$[ebp+1]
  000cc	53		 push	 ebx
  000cd	50		 push	 eax
  000ce	88 9d f8 fe ff
	ff		 mov	 BYTE PTR _szLauncherPath$[ebp], bl
  000d4	e8 00 00 00 00	 call	 _memset

; 743  : 	StringCbPrintf(szLauncherPath, sizeof(szLauncherPath), "%s\\ErrorDlg.exe", szRootDir);

  000d9	8d 85 f0 fc ff
	ff		 lea	 eax, DWORD PTR _szRootDir$[ebp]
  000df	50		 push	 eax
  000e0	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JAIIHPNB@?$CFs?2ErrorDlg?4exe?$AA@
  000e5	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szLauncherPath$[ebp]
  000eb	57		 push	 edi
  000ec	50		 push	 eax
  000ed	e8 00 00 00 00	 call	 ?StringCbPrintfA@@YAJPADIPBDZZ ; StringCbPrintfA

; 744  : 
; 745  : 	if( access(szLauncherPath, 0) == 0 )

  000f2	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szLauncherPath$[ebp]
  000f8	53		 push	 ebx
  000f9	50		 push	 eax
  000fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__access
  00100	83 c4 24	 add	 esp, 36			; 00000024H
  00103	5f		 pop	 edi
  00104	5e		 pop	 esi
  00105	5b		 pop	 ebx
  00106	85 c0		 test	 eax, eax
  00108	75 15		 jne	 SHORT $LN2@ShowOtherE

; 746  : 		Help::ExcuteProcess(szLauncherPath, szEditText);

  0010a	8d 85 f0 f4 ff
	ff		 lea	 eax, DWORD PTR _szEditText$[ebp]
  00110	50		 push	 eax
  00111	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szLauncherPath$[ebp]
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 ?ExcuteProcess@Help@@YAXPAD0@Z ; Help::ExcuteProcess
  0011d	59		 pop	 ecx
  0011e	59		 pop	 ecx
$LN2@ShowOtherE:

; 747  : 	else
; 748  : 		return;
; 749  : }

  0011f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00122	33 cd		 xor	 ecx, ebp
  00124	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00129	c9		 leave
  0012a	c3		 ret	 0
?ShowOtherErrorDlg@@YAXPAUHINSTANCE__@@@Z ENDP		; ShowOtherErrorDlg
_TEXT	ENDS
PUBLIC	?ShowErrorDlg@@YAXPAUHINSTANCE__@@@Z		; ShowErrorDlg
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	__imp__DialogBoxParamA@20:PROC
EXTRN	??0CSkin@@QAE@HH@Z:PROC				; CSkin::CSkin
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp__ShowCursor@4:PROC
EXTRN	__imp__LoadBitmapA@8:PROC
EXTRN	__EH_epilog3:PROC
EXTRN	__EH_prolog3:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ShowErrorDlg@@YAXPAUHINSTANCE__@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ShowErrorDlg@@YAXPAUHINSTANCE__@@@Z$0
__ehfuncinfo$?ShowErrorDlg@@YAXPAUHINSTANCE__@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ShowErrorDlg@@YAXPAUHINSTANCE__@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ?ShowErrorDlg@@YAXPAUHINSTANCE__@@@Z
_TEXT	SEGMENT
_dwBack$ = -36						; size = 4
$T520385 = -32						; size = 4
_dwExitO$ = -32						; size = 4
_dwExitN$ = -28						; size = 4
_dwSolutionC$ = -24					; size = 4
_dwSolutionO$ = -20					; size = 4
_dwSolutionN$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_hInstance$ = 8						; size = 4
?ShowErrorDlg@@YAXPAUHINSTANCE__@@@Z PROC		; ShowErrorDlg, COMDAT

; 753  : {

  00000	6a 18		 push	 24			; 00000018H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?ShowErrorDlg@@YAXPAUHINSTANCE__@@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3

; 754  : 	DWORD dwBack = IDB_BACK_ERROR;

  0000c	c7 45 dc 83 00
	00 00		 mov	 DWORD PTR _dwBack$[ebp], 131 ; 00000083H

; 755  : 	DWORD dwSolutionN = IDB_SOLUTION_N;

  00013	c7 45 f0 8a 00
	00 00		 mov	 DWORD PTR _dwSolutionN$[ebp], 138 ; 0000008aH

; 756  : 	DWORD dwSolutionO = IDB_SOLUTION_O;

  0001a	c7 45 ec 8b 00
	00 00		 mov	 DWORD PTR _dwSolutionO$[ebp], 139 ; 0000008bH

; 757  : 	DWORD dwSolutionC = IDB_SOLUTION_C;

  00021	c7 45 e8 89 00
	00 00		 mov	 DWORD PTR _dwSolutionC$[ebp], 137 ; 00000089H

; 758  : 	DWORD dwExitN = IDB_EXIT_N;

  00028	c7 45 e4 86 00
	00 00		 mov	 DWORD PTR _dwExitN$[ebp], 134 ; 00000086H

; 759  : 	DWORD dwExitO = IDB_EXIT_O;

  0002f	c7 45 e0 88 00
	00 00		 mov	 DWORD PTR _dwExitO$[ebp], 136 ; 00000088H

; 760  : 	DWORD dwExitC = IDB_EXIT_C;

  00036	bb 85 00 00 00	 mov	 ebx, 133		; 00000085H

; 761  : 
; 762  : 	ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );

  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLocalType@ioLocalManagerParent@@SA?AW4LocalType@1@XZ
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ?GetSingleton@ioLocalManager@@SAAAV1@XZ ; ioLocalManager::GetSingleton
  00047	8b c8		 mov	 ecx, eax
  00049	e8 00 00 00 00	 call	 ?GetLocal@ioLocalManager@@QAEPAVioLocalParent@@W4LocalType@ioLocalManagerParent@@@Z ; ioLocalManager::GetLocal
  0004e	8b f0		 mov	 esi, eax

; 763  : 	if( pLocal )

  00050	85 f6		 test	 esi, esi
  00052	0f 84 95 00 00
	00		 je	 $LN5@ShowErrorD

; 764  : 	{
; 765  : 		if( pLocal->GetResourceIDErrorBack() != -1 )

  00058	8b 06		 mov	 eax, DWORD PTR [esi]
  0005a	8b ce		 mov	 ecx, esi
  0005c	ff 50 30	 call	 DWORD PTR [eax+48]
  0005f	83 cf ff	 or	 edi, -1
  00062	3b c7		 cmp	 eax, edi
  00064	74 0a		 je	 SHORT $LN11@ShowErrorD

; 766  : 			dwBack = pLocal->GetResourceIDErrorBack();

  00066	8b 06		 mov	 eax, DWORD PTR [esi]
  00068	8b ce		 mov	 ecx, esi
  0006a	ff 50 30	 call	 DWORD PTR [eax+48]
  0006d	89 45 dc	 mov	 DWORD PTR _dwBack$[ebp], eax
$LN11@ShowErrorD:

; 767  : 		if( pLocal->GetResourceIDErrorSolutionN() != -1 )

  00070	8b 06		 mov	 eax, DWORD PTR [esi]
  00072	8b ce		 mov	 ecx, esi
  00074	ff 50 44	 call	 DWORD PTR [eax+68]
  00077	3b c7		 cmp	 eax, edi
  00079	74 0a		 je	 SHORT $LN10@ShowErrorD

; 768  : 			dwSolutionN = pLocal->GetResourceIDErrorSolutionN();

  0007b	8b 06		 mov	 eax, DWORD PTR [esi]
  0007d	8b ce		 mov	 ecx, esi
  0007f	ff 50 44	 call	 DWORD PTR [eax+68]
  00082	89 45 f0	 mov	 DWORD PTR _dwSolutionN$[ebp], eax
$LN10@ShowErrorD:

; 769  : 		if( pLocal->GetResourceIDErrorSolutionO() != -1 )

  00085	8b 06		 mov	 eax, DWORD PTR [esi]
  00087	8b ce		 mov	 ecx, esi
  00089	ff 50 48	 call	 DWORD PTR [eax+72]
  0008c	3b c7		 cmp	 eax, edi
  0008e	74 0a		 je	 SHORT $LN9@ShowErrorD

; 770  : 			dwSolutionO = pLocal->GetResourceIDErrorSolutionO();

  00090	8b 06		 mov	 eax, DWORD PTR [esi]
  00092	8b ce		 mov	 ecx, esi
  00094	ff 50 48	 call	 DWORD PTR [eax+72]
  00097	89 45 ec	 mov	 DWORD PTR _dwSolutionO$[ebp], eax
$LN9@ShowErrorD:

; 771  : 		if( pLocal->GetResourceIDErrorSolutionC() != -1 )

  0009a	8b 06		 mov	 eax, DWORD PTR [esi]
  0009c	8b ce		 mov	 ecx, esi
  0009e	ff 50 40	 call	 DWORD PTR [eax+64]
  000a1	3b c7		 cmp	 eax, edi
  000a3	74 0a		 je	 SHORT $LN8@ShowErrorD

; 772  : 			dwSolutionC = pLocal->GetResourceIDErrorSolutionC();

  000a5	8b 06		 mov	 eax, DWORD PTR [esi]
  000a7	8b ce		 mov	 ecx, esi
  000a9	ff 50 40	 call	 DWORD PTR [eax+64]
  000ac	89 45 e8	 mov	 DWORD PTR _dwSolutionC$[ebp], eax
$LN8@ShowErrorD:

; 773  : 		if( pLocal->GetResourceIDErrorExitN() != -1 )

  000af	8b 06		 mov	 eax, DWORD PTR [esi]
  000b1	8b ce		 mov	 ecx, esi
  000b3	ff 50 38	 call	 DWORD PTR [eax+56]
  000b6	3b c7		 cmp	 eax, edi
  000b8	74 0a		 je	 SHORT $LN7@ShowErrorD

; 774  : 			dwExitN = pLocal->GetResourceIDErrorExitN();

  000ba	8b 06		 mov	 eax, DWORD PTR [esi]
  000bc	8b ce		 mov	 ecx, esi
  000be	ff 50 38	 call	 DWORD PTR [eax+56]
  000c1	89 45 e4	 mov	 DWORD PTR _dwExitN$[ebp], eax
$LN7@ShowErrorD:

; 775  : 		if( pLocal->GetResourceIDErrorExitO() != -1 )

  000c4	8b 06		 mov	 eax, DWORD PTR [esi]
  000c6	8b ce		 mov	 ecx, esi
  000c8	ff 50 3c	 call	 DWORD PTR [eax+60]
  000cb	3b c7		 cmp	 eax, edi
  000cd	74 0a		 je	 SHORT $LN6@ShowErrorD

; 776  : 			dwExitO = pLocal->GetResourceIDErrorExitO();

  000cf	8b 06		 mov	 eax, DWORD PTR [esi]
  000d1	8b ce		 mov	 ecx, esi
  000d3	ff 50 3c	 call	 DWORD PTR [eax+60]
  000d6	89 45 e0	 mov	 DWORD PTR _dwExitO$[ebp], eax
$LN6@ShowErrorD:

; 777  : 		if( pLocal->GetResourceIDErrorExitC() != -1 )

  000d9	8b 06		 mov	 eax, DWORD PTR [esi]
  000db	8b ce		 mov	 ecx, esi
  000dd	ff 50 34	 call	 DWORD PTR [eax+52]
  000e0	3b c7		 cmp	 eax, edi
  000e2	74 09		 je	 SHORT $LN5@ShowErrorD

; 778  : 			dwExitC = pLocal->GetResourceIDErrorExitC();

  000e4	8b 06		 mov	 eax, DWORD PTR [esi]
  000e6	8b ce		 mov	 ecx, esi
  000e8	ff 50 34	 call	 DWORD PTR [eax+52]
  000eb	8b d8		 mov	 ebx, eax
$LN5@ShowErrorD:

; 779  : 	}
; 780  : 
; 781  : 	g_hBitmapX[0] = LoadBitmap( hInstance, MAKEINTRESOURCE(IDB_X_N) );

  000ed	8b 7d 08	 mov	 edi, DWORD PTR _hInstance$[ebp]
  000f0	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__LoadBitmapA@8
  000f6	68 8d 00 00 00	 push	 141			; 0000008dH
  000fb	57		 push	 edi
  000fc	ff d6		 call	 esi

; 782  : 	g_hBitmapX[1] = LoadBitmap( hInstance, MAKEINTRESOURCE(IDB_X_O) );

  000fe	68 8e 00 00 00	 push	 142			; 0000008eH
  00103	57		 push	 edi
  00104	a3 00 00 00 00	 mov	 DWORD PTR ?g_hBitmapX@@3PAPAUHBITMAP__@@A, eax
  00109	ff d6		 call	 esi

; 783  : 	g_hBitmapX[2] = LoadBitmap( hInstance, MAKEINTRESOURCE(IDB_X_C) );

  0010b	68 8c 00 00 00	 push	 140			; 0000008cH
  00110	57		 push	 edi
  00111	a3 04 00 00 00	 mov	 DWORD PTR ?g_hBitmapX@@3PAPAUHBITMAP__@@A+4, eax
  00116	ff d6		 call	 esi
  00118	a3 08 00 00 00	 mov	 DWORD PTR ?g_hBitmapX@@3PAPAUHBITMAP__@@A+8, eax

; 784  : 	g_hBitmapSolution[0] = LoadBitmap( hInstance, MAKEINTRESOURCE(dwSolutionN) );

  0011d	0f b7 45 f0	 movzx	 eax, WORD PTR _dwSolutionN$[ebp]
  00121	50		 push	 eax
  00122	57		 push	 edi
  00123	ff d6		 call	 esi
  00125	a3 00 00 00 00	 mov	 DWORD PTR ?g_hBitmapSolution@@3PAPAUHBITMAP__@@A, eax

; 785  : 	g_hBitmapSolution[1] = LoadBitmap( hInstance, MAKEINTRESOURCE(dwSolutionO) );

  0012a	0f b7 45 ec	 movzx	 eax, WORD PTR _dwSolutionO$[ebp]
  0012e	50		 push	 eax
  0012f	57		 push	 edi
  00130	ff d6		 call	 esi
  00132	a3 04 00 00 00	 mov	 DWORD PTR ?g_hBitmapSolution@@3PAPAUHBITMAP__@@A+4, eax

; 786  : 	g_hBitmapSolution[2] = LoadBitmap( hInstance, MAKEINTRESOURCE(dwSolutionC) );

  00137	0f b7 45 e8	 movzx	 eax, WORD PTR _dwSolutionC$[ebp]
  0013b	50		 push	 eax
  0013c	57		 push	 edi
  0013d	ff d6		 call	 esi
  0013f	a3 08 00 00 00	 mov	 DWORD PTR ?g_hBitmapSolution@@3PAPAUHBITMAP__@@A+8, eax

; 787  : 	g_hBitmapExit[0] = LoadBitmap( hInstance, MAKEINTRESOURCE(dwExitN) );

  00144	0f b7 45 e4	 movzx	 eax, WORD PTR _dwExitN$[ebp]
  00148	50		 push	 eax
  00149	57		 push	 edi
  0014a	ff d6		 call	 esi
  0014c	a3 00 00 00 00	 mov	 DWORD PTR ?g_hBitmapExit@@3PAPAUHBITMAP__@@A, eax

; 788  : 	g_hBitmapExit[1] = LoadBitmap( hInstance, MAKEINTRESOURCE(dwExitO) );

  00151	0f b7 45 e0	 movzx	 eax, WORD PTR _dwExitO$[ebp]
  00155	50		 push	 eax
  00156	57		 push	 edi
  00157	ff d6		 call	 esi
  00159	a3 04 00 00 00	 mov	 DWORD PTR ?g_hBitmapExit@@3PAPAUHBITMAP__@@A+4, eax

; 789  : 	g_hBitmapExit[2] = LoadBitmap( hInstance, MAKEINTRESOURCE(dwExitC) );

  0015e	0f b7 c3	 movzx	 eax, bx
  00161	50		 push	 eax
  00162	57		 push	 edi
  00163	ff d6		 call	 esi

; 790  : 
; 791  : 	ShowCursor( TRUE );

  00165	6a 01		 push	 1
  00167	a3 08 00 00 00	 mov	 DWORD PTR ?g_hBitmapExit@@3PAPAUHBITMAP__@@A+8, eax
  0016c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowCursor@4

; 792  : 	g_pErrorDlgSkin = new CSkin(IDR_BINARY1, dwBack );

  00172	6a 28		 push	 40			; 00000028H
  00174	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00179	59		 pop	 ecx
  0017a	8b c8		 mov	 ecx, eax
  0017c	89 4d e0	 mov	 DWORD PTR $T520385[ebp], ecx
  0017f	33 f6		 xor	 esi, esi
  00181	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  00184	3b ce		 cmp	 ecx, esi
  00186	74 0f		 je	 SHORT $LN15@ShowErrorD
  00188	ff 75 dc	 push	 DWORD PTR _dwBack$[ebp]
  0018b	68 8f 00 00 00	 push	 143			; 0000008fH
  00190	e8 00 00 00 00	 call	 ??0CSkin@@QAE@HH@Z	; CSkin::CSkin
  00195	eb 02		 jmp	 SHORT $LN16@ShowErrorD
$LN15@ShowErrorD:
  00197	33 c0		 xor	 eax, eax
$LN16@ShowErrorD:
  00199	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 793  : 
; 794  : 	DialogBox( hInstance, MAKEINTRESOURCE(IDD_ERROR_DLG), NULL, ErrorDlgProc );

  0019d	56		 push	 esi
  0019e	68 00 00 00 00	 push	 OFFSET ?ErrorDlgProc@@YGHPAUHWND__@@IIJ@Z ; ErrorDlgProc
  001a3	56		 push	 esi
  001a4	6a 6d		 push	 109			; 0000006dH
  001a6	57		 push	 edi
  001a7	a3 00 00 00 00	 mov	 DWORD PTR ?g_pErrorDlgSkin@@3PAVCSkin@@A, eax ; g_pErrorDlgSkin
  001ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DialogBoxParamA@20

; 795  : 	
; 796  : 	SAFEDELETE( g_pErrorDlgSkin );

  001b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pErrorDlgSkin@@3PAVCSkin@@A ; g_pErrorDlgSkin
  001b8	3b ce		 cmp	 ecx, esi
  001ba	74 0c		 je	 SHORT $LN4@ShowErrorD
  001bc	8b 01		 mov	 eax, DWORD PTR [ecx]
  001be	6a 01		 push	 1
  001c0	ff 10		 call	 DWORD PTR [eax]
  001c2	89 35 00 00 00
	00		 mov	 DWORD PTR ?g_pErrorDlgSkin@@3PAVCSkin@@A, esi ; g_pErrorDlgSkin
$LN4@ShowErrorD:

; 797  : 	for( int i=0 ; i< BTN_BITMAP_SIZE ; i++)

  001c8	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__DeleteObject@4
  001ce	33 ff		 xor	 edi, edi
$LL3@ShowErrorD:

; 798  : 	{
; 799  : 		DeleteObject( g_hBitmapX[i] );			

  001d0	ff b7 00 00 00
	00		 push	 DWORD PTR ?g_hBitmapX@@3PAPAUHBITMAP__@@A[edi]
  001d6	ff d6		 call	 esi

; 800  : 		DeleteObject( g_hBitmapSolution[i] );

  001d8	ff b7 00 00 00
	00		 push	 DWORD PTR ?g_hBitmapSolution@@3PAPAUHBITMAP__@@A[edi]
  001de	ff d6		 call	 esi

; 801  : 		DeleteObject( g_hBitmapExit[i] );

  001e0	ff b7 00 00 00
	00		 push	 DWORD PTR ?g_hBitmapExit@@3PAPAUHBITMAP__@@A[edi]
  001e6	ff d6		 call	 esi
  001e8	83 c7 04	 add	 edi, 4
  001eb	83 ff 0c	 cmp	 edi, 12			; 0000000cH
  001ee	7c e0		 jl	 SHORT $LL3@ShowErrorD

; 802  : 	}
; 803  : }

  001f0	e8 00 00 00 00	 call	 __EH_epilog3
  001f5	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ShowErrorDlg@@YAXPAUHINSTANCE__@@@Z$0:
  00000	ff 75 e0	 push	 DWORD PTR $T520385[ebp]
  00003	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00008	59		 pop	 ecx
  00009	c3		 ret	 0
__ehhandler$?ShowErrorDlg@@YAXPAUHINSTANCE__@@@Z:
  0000a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00011	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00014	33 c8		 xor	 ecx, eax
  00016	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ShowErrorDlg@@YAXPAUHINSTANCE__@@@Z
  00020	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ShowErrorDlg@@YAXPAUHINSTANCE__@@@Z ENDP		; ShowErrorDlg
PUBLIC	??_C@_0BG@JPJMNGLB@App?5InitWindow?5Error?$CB?$AA@ ; `string'
PUBLIC	??_C@_0BO@GBFBNNHH@?$FLMain?$FN?5?9?5App?5InitWindow?5Error?$AA@ ; `string'
PUBLIC	??_C@_0BM@JCAGJNJC@App?5SetupBeforeLogin?5Error?$CB?$AA@ ; `string'
PUBLIC	??_C@_0CE@IABOHEFL@?$FLMain?$FN?5?9?5App?5SetupBeforeLogin?5Er@ ; `string'
PUBLIC	??_C@_0BF@PLMGNAIB@App?5LoginLoop?5Error?$CB?$AA@ ; `string'
PUBLIC	??_C@_0BE@FOPFPEAB@App?5LoginLoop?5Error?$AA@	; `string'
PUBLIC	??_C@_0BC@HOHJBABM@?$FLMain?$FN?5?9?5Run?5Call?$AA@ ; `string'
PUBLIC	??_C@_0BA@IKLGNONL@info?1pp_mem?4log?$AA@	; `string'
PUBLIC	??_C@_0CF@IEMNCGND@?$FLMain?$FN?5?9?5Setup?5Before?5Login?5Comp@ ; `string'
PUBLIC	??_C@_0BN@EFAHBBDE@?$FLMain?$FN?5?9?5InitWindow?5Complete?$AA@ ; `string'
PUBLIC	??_C@_0CH@MNBGPEDD@?$FLMain?$FN?5?9?5Process?5Option?5Start?5Co@ ; `string'
PUBLIC	??_C@_0CF@FFGCOBIA@?$FLMain?$FN?5?9?5Process?5Option?5Start?5Fa@ ; `string'
PUBLIC	??_C@_0BC@HJHPPENM@App?5Option?5Error?$CB?$AA@	; `string'
PUBLIC	??_C@_0BO@MJEKFOCL@?$FLMain?$FN?5?9?5Process?5Option?5Start?$AA@ ; `string'
PUBLIC	??_C@_0M@OAAAHGKD@Memory?5Test?$AA@		; `string'
PUBLIC	??_C@_0P@OLKIABFH@App?5Cmd?5Error?$CB?$AA@	; `string'
PUBLIC	??_C@_0BL@FEBEPHPG@?$FLMain?$FN?5?9?5Create?5App?5Error?$CB?$AA@ ; `string'
PUBLIC	??_C@_0BC@LLKKGKHC@Create?5App?5Error?$CB?$AA@	; `string'
PUBLIC	??_C@_0BL@FNOAENGG@?$FLMain?$FN?5?9?5DX?5Version?5Error?$CB?$AA@ ; `string'
PUBLIC	??_C@_0BC@LCFONAOC@DX?5Version?5Error?$CB?$AA@	; `string'
PUBLIC	??_C@_0BL@PDJKFNLM@?$FLMain?$FN?5?9?5Get?5DX?5Info?5Error?$AA@ ; `string'
PUBLIC	??_C@_0BD@KEIBIJLN@Get?5DX?5Info?5Error?$CB?$AA@ ; `string'
PUBLIC	??_C@_05KKCIMGE@error?$AA@			; `string'
PUBLIC	??_C@_0BN@BNHKPFEA@?$FLMain?$FN?5?9?5Mutex?5Create?5Failed?$AA@ ; `string'
PUBLIC	??_C@_07HGGPAHEN@WinMain?$AA@			; `string'
PUBLIC	??_C@_0BI@PPHFGBKO@LostSaga_Client?5?9?5Error?$AA@ ; `string'
PUBLIC	??_C@_0DI@MFGDLFLE@Global?2_LOSTSAGA_CLIENT_38947383@ ; `string'
PUBLIC	??_C@_0BH@IPJHKBFC@?$FLMain?$FN?5?9?5license?5Error?$AA@ ; `string'
PUBLIC	??_C@_0CF@HMNPAODJ@Your?5license?5has?5com?5up?5for?5rene@ ; `string'
PUBLIC	??_C@_07NAJDILEH@IOEnter?$AA@			; `string'
PUBLIC	??_SioStringManager@@6B@			; ioStringManager::`local vftable'
PUBLIC	??_C@_0CD@FNCGCLND@?$FLMain?$FN?5?9?5Local?5Manager?5Init?5Fail@ ; `string'
PUBLIC	??_C@_0CF@CHDBNJEO@?$FLMain?$FN?5?9?5Local?5Manager?5Init?5Comp@ ; `string'
PUBLIC	??_SioINIMemoryStatic@@6B@			; ioINIMemoryStatic::`local vftable'
PUBLIC	??_C@_0CO@POJFBNPL@WINAPI?5WinMain?5?9?5SetCrashHandler@ ; `string'
PUBLIC	??_C@_09DOKKIOMA@LostSagaT?$AA@			; `string'
PUBLIC	??_C@_0BI@OMIBODJD@?$FLMain?$FN?5?9?5LostSaga?5Start?$AA@ ; `string'
PUBLIC	_lpCmdLine$GSCopy$
PUBLIC	??_C@_0M@MNHKONMG@info?1pp?4log?$AA@		; `string'
PUBLIC	_hInstance$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_WinMain@16
PUBLIC	??_R4ioINIMemoryStatic@@6B@			; ioINIMemoryStatic::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVioINIMemoryStatic@@@8			; ioINIMemoryStatic `RTTI Type Descriptor'
PUBLIC	??_R3ioINIMemoryStatic@@8			; ioINIMemoryStatic::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioINIMemoryStatic@@8			; ioINIMemoryStatic::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ioINIMemoryStatic@@8		; ioINIMemoryStatic::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R13?0A@EA@?$Singleton@VioINIMemoryStatic@@@@8 ; Singleton<ioINIMemoryStatic>::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AV?$Singleton@VioINIMemoryStatic@@@@@8	; Singleton<ioINIMemoryStatic> `RTTI Type Descriptor'
PUBLIC	??_R3?$Singleton@VioINIMemoryStatic@@@@8	; Singleton<ioINIMemoryStatic>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$Singleton@VioINIMemoryStatic@@@@8	; Singleton<ioINIMemoryStatic>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$Singleton@VioINIMemoryStatic@@@@8 ; Singleton<ioINIMemoryStatic>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4ioStringManager@@6B@			; ioStringManager::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVioStringManager@@@8			; ioStringManager `RTTI Type Descriptor'
PUBLIC	??_R3ioStringManager@@8				; ioStringManager::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioStringManager@@8				; ioStringManager::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ioStringManager@@8		; ioStringManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R13?0A@EA@?$Singleton@VioStringManager@@@@8	; Singleton<ioStringManager>::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AV?$Singleton@VioStringManager@@@@@8	; Singleton<ioStringManager> `RTTI Type Descriptor'
PUBLIC	??_R3?$Singleton@VioStringManager@@@@8		; Singleton<ioStringManager>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$Singleton@VioStringManager@@@@8		; Singleton<ioStringManager>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$Singleton@VioStringManager@@@@8	; Singleton<ioStringManager>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__imp__SleepEx@8:PROC
EXTRN	__imp__DispatchMessageA@4:PROC
EXTRN	__imp__TranslateMessage@4:PROC
EXTRN	__imp__GetMessageA@16:PROC
EXTRN	__imp__PeekMessageA@20:PROC
EXTRN	__imp__DestroyWindow@4:PROC
EXTRN	?Run@ioApplication@@QAEHXZ:PROC			; ioApplication::Run
EXTRN	__imp_?SetSwitch@ioINIMemoryStatic@@QAEXH@Z:PROC
EXTRN	__imp_?GetSingleton@ioINIMemoryStatic@@SAAAV1@XZ:PROC
EXTRN	?IsMeDeveloper@ioApplication@@QAE_NXZ:PROC	; ioApplication::IsMeDeveloper
EXTRN	?GetSingleton@ioApplication@@SAAAV1@XZ:PROC	; ioApplication::GetSingleton
EXTRN	?LoginLoop@ioApplication@@QAE_NABVioHashString@@@Z:PROC ; ioApplication::LoginLoop
EXTRN	?SetupBeforeLogin@ioApplication@@QAE_NABVioHashString@@H@Z:PROC ; ioApplication::SetupBeforeLogin
EXTRN	?InitWindow@ioApplication@@QAE_NPAUHINSTANCE__@@ABVioHashString@@@Z:PROC ; ioApplication::InitWindow
EXTRN	?ProcessOptions@ioApplication@@QAE_NABVioHashString@@@Z:PROC ; ioApplication::ProcessOptions
EXTRN	?LogGlobalMemory@ioApplication@@QAEXXZ:PROC	; ioApplication::LogGlobalMemory
EXTRN	?ParseCmd@ioApplication@@QAE_NPBDAAVioHashString@@11AAH@Z:PROC ; ioApplication::ParseCmd
EXTRN	__imp_??0ioHashString@@QAE@XZ:PROC
EXTRN	?DebugWebLogin@ioApplication@@QAEXAAPAD@Z:PROC	; ioApplication::DebugWebLogin
EXTRN	??0ioApplication@@QAE@XZ:PROC			; ioApplication::ioApplication
EXTRN	__imp_?SetWindowsModule@ioFrameTimer@@SAX_N@Z:PROC
EXTRN	?CheckOSVersion@Setting@@SAXXZ:PROC		; Setting::CheckOSVersion
EXTRN	?SetDirectXVersion@Setting@@SAXPBDK@Z:PROC	; Setting::SetDirectXVersion
EXTRN	?SaveClientError@Help@@YAXHHH@Z:PROC		; Help::SaveClientError
EXTRN	__imp_?SafeSprintf@@YAXPADHPBDZZ:PROC
EXTRN	__imp_??1ioHashString@@QAE@XZ:PROC
EXTRN	?Initialize@Setting@@SAXABVioHashString@@@Z:PROC ; Setting::Initialize
EXTRN	__imp_??0ioHashString@@QAE@PBD@Z:PROC
EXTRN	?GetDXVersionInfo@Help@@YA_NPAKPADH@Z:PROC	; Help::GetDXVersionInfo
EXTRN	?MessageboxShow@Help@@YAHPAUHWND__@@PBD1I@Z:PROC ; Help::MessageboxShow
EXTRN	__imp__CreateMutexA@12:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	__imp_?LoadData@ioStringManager@@QAEXPBD00_N@Z:PROC
EXTRN	?LoadTextInResource@Help@@YAXHAAKAAPBD@Z:PROC	; Help::LoadTextInResource
EXTRN	__imp_??0ioStringManager@@QAE@XZ:PROC
EXTRN	?ParseCmd@ioLocalManager@@QAEXPBD@Z:PROC	; ioLocalManager::ParseCmd
EXTRN	?Init@ioLocalManager@@QAEXXZ:PROC		; ioLocalManager::Init
EXTRN	??0ioLocalManager@@QAE@XZ:PROC			; ioLocalManager::ioLocalManager
EXTRN	__imp_??0ioINIMemoryStatic@@QAE@XZ:PROC
EXTRN	__imp__SetCrashHandlerFilter@4:PROC
EXTRN	?Begin@MiniDump@@SAHPBD@Z:PROC			; MiniDump::Begin
EXTRN	?CheckEnableTimeGapUser@Help@@YA_NH@Z:PROC	; Help::CheckEnableTimeGapUser
EXTRN	__imp_?OpenLog@CLog@@QAEXHPBD_N@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_EioINIMemoryStatic@@UAEPAXI@Z:PROC		; ioINIMemoryStatic::`vector deleting destructor'
EXTRN	??_EioStringManager@@UAEPAXI@Z:PROC		; ioStringManager::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$Singleton@VioStringManager@@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioapplication.h
rdata$r	SEGMENT
??_R1A@?0A@EA@?$Singleton@VioStringManager@@@@8 DD FLAT:??_R0?AV?$Singleton@VioStringManager@@@@@8 ; Singleton<ioStringManager>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$Singleton@VioStringManager@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$Singleton@VioStringManager@@@@8
rdata$r	SEGMENT
??_R2?$Singleton@VioStringManager@@@@8 DD FLAT:??_R1A@?0A@EA@?$Singleton@VioStringManager@@@@8 ; Singleton<ioStringManager>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$Singleton@VioStringManager@@@@8
rdata$r	SEGMENT
??_R3?$Singleton@VioStringManager@@@@8 DD 00H		; Singleton<ioStringManager>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$Singleton@VioStringManager@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$Singleton@VioStringManager@@@@@8
_DATA	SEGMENT
??_R0?AV?$Singleton@VioStringManager@@@@@8 DD FLAT:??_7type_info@@6B@ ; Singleton<ioStringManager> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$Singleton@VioStringManager@@@@', 00H
_DATA	ENDS
;	COMDAT ??_R13?0A@EA@?$Singleton@VioStringManager@@@@8
rdata$r	SEGMENT
??_R13?0A@EA@?$Singleton@VioStringManager@@@@8 DD FLAT:??_R0?AV?$Singleton@VioStringManager@@@@@8 ; Singleton<ioStringManager>::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$Singleton@VioStringManager@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ioStringManager@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioStringManager@@8 DD FLAT:??_R0?AVioStringManager@@@8 ; ioStringManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioStringManager@@8
rdata$r	ENDS
;	COMDAT ??_R2ioStringManager@@8
rdata$r	SEGMENT
??_R2ioStringManager@@8 DD FLAT:??_R1A@?0A@EA@ioStringManager@@8 ; ioStringManager::`RTTI Base Class Array'
	DD	FLAT:??_R13?0A@EA@?$Singleton@VioStringManager@@@@8
rdata$r	ENDS
;	COMDAT ??_R3ioStringManager@@8
rdata$r	SEGMENT
??_R3ioStringManager@@8 DD 00H				; ioStringManager::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ioStringManager@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioStringManager@@@8
_DATA	SEGMENT
??_R0?AVioStringManager@@@8 DD FLAT:??_7type_info@@6B@	; ioStringManager `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioStringManager@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ioStringManager@@6B@
rdata$r	SEGMENT
??_R4ioStringManager@@6B@ DD 00H			; ioStringManager::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVioStringManager@@@8
	DD	FLAT:??_R3ioStringManager@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$Singleton@VioINIMemoryStatic@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$Singleton@VioINIMemoryStatic@@@@8 DD FLAT:??_R0?AV?$Singleton@VioINIMemoryStatic@@@@@8 ; Singleton<ioINIMemoryStatic>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$Singleton@VioINIMemoryStatic@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$Singleton@VioINIMemoryStatic@@@@8
rdata$r	SEGMENT
??_R2?$Singleton@VioINIMemoryStatic@@@@8 DD FLAT:??_R1A@?0A@EA@?$Singleton@VioINIMemoryStatic@@@@8 ; Singleton<ioINIMemoryStatic>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$Singleton@VioINIMemoryStatic@@@@8
rdata$r	SEGMENT
??_R3?$Singleton@VioINIMemoryStatic@@@@8 DD 00H		; Singleton<ioINIMemoryStatic>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$Singleton@VioINIMemoryStatic@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$Singleton@VioINIMemoryStatic@@@@@8
_DATA	SEGMENT
??_R0?AV?$Singleton@VioINIMemoryStatic@@@@@8 DD FLAT:??_7type_info@@6B@ ; Singleton<ioINIMemoryStatic> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$Singleton@VioINIMemoryStatic@@@@', 00H
_DATA	ENDS
;	COMDAT ??_R13?0A@EA@?$Singleton@VioINIMemoryStatic@@@@8
rdata$r	SEGMENT
??_R13?0A@EA@?$Singleton@VioINIMemoryStatic@@@@8 DD FLAT:??_R0?AV?$Singleton@VioINIMemoryStatic@@@@@8 ; Singleton<ioINIMemoryStatic>::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$Singleton@VioINIMemoryStatic@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ioINIMemoryStatic@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioINIMemoryStatic@@8 DD FLAT:??_R0?AVioINIMemoryStatic@@@8 ; ioINIMemoryStatic::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioINIMemoryStatic@@8
rdata$r	ENDS
;	COMDAT ??_R2ioINIMemoryStatic@@8
rdata$r	SEGMENT
??_R2ioINIMemoryStatic@@8 DD FLAT:??_R1A@?0A@EA@ioINIMemoryStatic@@8 ; ioINIMemoryStatic::`RTTI Base Class Array'
	DD	FLAT:??_R13?0A@EA@?$Singleton@VioINIMemoryStatic@@@@8
rdata$r	ENDS
;	COMDAT ??_R3ioINIMemoryStatic@@8
rdata$r	SEGMENT
??_R3ioINIMemoryStatic@@8 DD 00H			; ioINIMemoryStatic::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ioINIMemoryStatic@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioINIMemoryStatic@@@8
_DATA	SEGMENT
??_R0?AVioINIMemoryStatic@@@8 DD FLAT:??_7type_info@@6B@ ; ioINIMemoryStatic `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioINIMemoryStatic@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ioINIMemoryStatic@@6B@
rdata$r	SEGMENT
??_R4ioINIMemoryStatic@@6B@ DD 00H			; ioINIMemoryStatic::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVioINIMemoryStatic@@@8
	DD	FLAT:??_R3ioINIMemoryStatic@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BG@JPJMNGLB@App?5InitWindow?5Error?$CB?$AA@
CONST	SEGMENT
??_C@_0BG@JPJMNGLB@App?5InitWindow?5Error?$CB?$AA@ DB 'App InitWindow Err'
	DB	'or!', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GBFBNNHH@?$FLMain?$FN?5?9?5App?5InitWindow?5Error?$AA@
CONST	SEGMENT
??_C@_0BO@GBFBNNHH@?$FLMain?$FN?5?9?5App?5InitWindow?5Error?$AA@ DB '[Mai'
	DB	'n] - App InitWindow Error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JCAGJNJC@App?5SetupBeforeLogin?5Error?$CB?$AA@
CONST	SEGMENT
??_C@_0BM@JCAGJNJC@App?5SetupBeforeLogin?5Error?$CB?$AA@ DB 'App SetupBef'
	DB	'oreLogin Error!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@IABOHEFL@?$FLMain?$FN?5?9?5App?5SetupBeforeLogin?5Er@
CONST	SEGMENT
??_C@_0CE@IABOHEFL@?$FLMain?$FN?5?9?5App?5SetupBeforeLogin?5Er@ DB '[Main'
	DB	'] - App SetupBeforeLogin Error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PLMGNAIB@App?5LoginLoop?5Error?$CB?$AA@
CONST	SEGMENT
??_C@_0BF@PLMGNAIB@App?5LoginLoop?5Error?$CB?$AA@ DB 'App LoginLoop Error'
	DB	'!', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FOPFPEAB@App?5LoginLoop?5Error?$AA@
CONST	SEGMENT
??_C@_0BE@FOPFPEAB@App?5LoginLoop?5Error?$AA@ DB 'App LoginLoop Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HOHJBABM@?$FLMain?$FN?5?9?5Run?5Call?$AA@
CONST	SEGMENT
??_C@_0BC@HOHJBABM@?$FLMain?$FN?5?9?5Run?5Call?$AA@ DB '[Main] - Run Call'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IKLGNONL@info?1pp_mem?4log?$AA@
CONST	SEGMENT
??_C@_0BA@IKLGNONL@info?1pp_mem?4log?$AA@ DB 'info/pp_mem.log', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@IEMNCGND@?$FLMain?$FN?5?9?5Setup?5Before?5Login?5Comp@
CONST	SEGMENT
??_C@_0CF@IEMNCGND@?$FLMain?$FN?5?9?5Setup?5Before?5Login?5Comp@ DB '[Mai'
	DB	'n] - Setup Before Login Complete', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@EFAHBBDE@?$FLMain?$FN?5?9?5InitWindow?5Complete?$AA@
CONST	SEGMENT
??_C@_0BN@EFAHBBDE@?$FLMain?$FN?5?9?5InitWindow?5Complete?$AA@ DB '[Main]'
	DB	' - InitWindow Complete', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MNBGPEDD@?$FLMain?$FN?5?9?5Process?5Option?5Start?5Co@
CONST	SEGMENT
??_C@_0CH@MNBGPEDD@?$FLMain?$FN?5?9?5Process?5Option?5Start?5Co@ DB '[Mai'
	DB	'n] - Process Option Start Complete', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@FFGCOBIA@?$FLMain?$FN?5?9?5Process?5Option?5Start?5Fa@
CONST	SEGMENT
??_C@_0CF@FFGCOBIA@?$FLMain?$FN?5?9?5Process?5Option?5Start?5Fa@ DB '[Mai'
	DB	'n] - Process Option Start Failed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HJHPPENM@App?5Option?5Error?$CB?$AA@
CONST	SEGMENT
??_C@_0BC@HJHPPENM@App?5Option?5Error?$CB?$AA@ DB 'App Option Error!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MJEKFOCL@?$FLMain?$FN?5?9?5Process?5Option?5Start?$AA@
CONST	SEGMENT
??_C@_0BO@MJEKFOCL@?$FLMain?$FN?5?9?5Process?5Option?5Start?$AA@ DB '[Mai'
	DB	'n] - Process Option Start', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OAAAHGKD@Memory?5Test?$AA@
CONST	SEGMENT
??_C@_0M@OAAAHGKD@Memory?5Test?$AA@ DB 'Memory Test', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OLKIABFH@App?5Cmd?5Error?$CB?$AA@
CONST	SEGMENT
??_C@_0P@OLKIABFH@App?5Cmd?5Error?$CB?$AA@ DB 'App Cmd Error!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FEBEPHPG@?$FLMain?$FN?5?9?5Create?5App?5Error?$CB?$AA@
CONST	SEGMENT
??_C@_0BL@FEBEPHPG@?$FLMain?$FN?5?9?5Create?5App?5Error?$CB?$AA@ DB '[Mai'
	DB	'n] - Create App Error!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LLKKGKHC@Create?5App?5Error?$CB?$AA@
CONST	SEGMENT
??_C@_0BC@LLKKGKHC@Create?5App?5Error?$CB?$AA@ DB 'Create App Error!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FNOAENGG@?$FLMain?$FN?5?9?5DX?5Version?5Error?$CB?$AA@
CONST	SEGMENT
??_C@_0BL@FNOAENGG@?$FLMain?$FN?5?9?5DX?5Version?5Error?$CB?$AA@ DB '[Mai'
	DB	'n] - DX Version Error!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LCFONAOC@DX?5Version?5Error?$CB?$AA@
CONST	SEGMENT
??_C@_0BC@LCFONAOC@DX?5Version?5Error?$CB?$AA@ DB 'DX Version Error!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PDJKFNLM@?$FLMain?$FN?5?9?5Get?5DX?5Info?5Error?$AA@
CONST	SEGMENT
??_C@_0BL@PDJKFNLM@?$FLMain?$FN?5?9?5Get?5DX?5Info?5Error?$AA@ DB '[Main]'
	DB	' - Get DX Info Error', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KEIBIJLN@Get?5DX?5Info?5Error?$CB?$AA@
CONST	SEGMENT
??_C@_0BD@KEIBIJLN@Get?5DX?5Info?5Error?$CB?$AA@ DB 'Get DX Info Error!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05KKCIMGE@error?$AA@
CONST	SEGMENT
??_C@_05KKCIMGE@error?$AA@ DB 'error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BNHKPFEA@?$FLMain?$FN?5?9?5Mutex?5Create?5Failed?$AA@
CONST	SEGMENT
??_C@_0BN@BNHKPFEA@?$FLMain?$FN?5?9?5Mutex?5Create?5Failed?$AA@ DB '[Main'
	DB	'] - Mutex Create Failed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HGGPAHEN@WinMain?$AA@
CONST	SEGMENT
??_C@_07HGGPAHEN@WinMain?$AA@ DB 'WinMain', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PPHFGBKO@LostSaga_Client?5?9?5Error?$AA@
CONST	SEGMENT
??_C@_0BI@PPHFGBKO@LostSaga_Client?5?9?5Error?$AA@ DB 'LostSaga_Client - '
	DB	'Error', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@MFGDLFLE@Global?2_LOSTSAGA_CLIENT_38947383@
CONST	SEGMENT
??_C@_0DI@MFGDLFLE@Global?2_LOSTSAGA_CLIENT_38947383@ DB 'Global\_LOSTSAG'
	DB	'A_CLIENT_3894738393994848484939308770494', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@IPJHKBFC@?$FLMain?$FN?5?9?5license?5Error?$AA@
CONST	SEGMENT
??_C@_0BH@IPJHKBFC@?$FLMain?$FN?5?9?5license?5Error?$AA@ DB '[Main] - lic'
	DB	'ense Error', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HMNPAODJ@Your?5license?5has?5com?5up?5for?5rene@
CONST	SEGMENT
??_C@_0CF@HMNPAODJ@Your?5license?5has?5com?5up?5for?5rene@ DB 'Your licen'
	DB	'se has com up for renewal.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NAJDILEH@IOEnter?$AA@
CONST	SEGMENT
??_C@_07NAJDILEH@IOEnter?$AA@ DB 'IOEnter', 00H		; `string'
CONST	ENDS
;	COMDAT ??_SioStringManager@@6B@
CONST	SEGMENT
??_SioStringManager@@6B@ DD FLAT:??_R4ioStringManager@@6B@ ; ioStringManager::`local vftable'
	DD	FLAT:??_EioStringManager@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_0CD@FNCGCLND@?$FLMain?$FN?5?9?5Local?5Manager?5Init?5Fail@
CONST	SEGMENT
??_C@_0CD@FNCGCLND@?$FLMain?$FN?5?9?5Local?5Manager?5Init?5Fail@ DB '[Mai'
	DB	'n] - Local Manager Init Failed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@CHDBNJEO@?$FLMain?$FN?5?9?5Local?5Manager?5Init?5Comp@
CONST	SEGMENT
??_C@_0CF@CHDBNJEO@?$FLMain?$FN?5?9?5Local?5Manager?5Init?5Comp@ DB '[Mai'
	DB	'n] - Local Manager Init Complete', 00H	; `string'
CONST	ENDS
;	COMDAT ??_SioINIMemoryStatic@@6B@
CONST	SEGMENT
??_SioINIMemoryStatic@@6B@ DD FLAT:??_R4ioINIMemoryStatic@@6B@ ; ioINIMemoryStatic::`local vftable'
	DD	FLAT:??_EioINIMemoryStatic@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_0CO@POJFBNPL@WINAPI?5WinMain?5?9?5SetCrashHandler@
CONST	SEGMENT
??_C@_0CO@POJFBNPL@WINAPI?5WinMain?5?9?5SetCrashHandler@ DB 'WINAPI WinMa'
	DB	'in - SetCrashHandlerFilter Failed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09DOKKIOMA@LostSagaT?$AA@
CONST	SEGMENT
??_C@_09DOKKIOMA@LostSagaT?$AA@ DB 'LostSagaT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@OMIBODJD@?$FLMain?$FN?5?9?5LostSaga?5Start?$AA@
CONST	SEGMENT
??_C@_0BI@OMIBODJD@?$FLMain?$FN?5?9?5LostSaga?5Start?$AA@ DB '[Main] - Lo'
	DB	'stSaga Start', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MNHKONMG@info?1pp?4log?$AA@
CONST	SEGMENT
??_C@_0M@MNHKONMG@info?1pp?4log?$AA@ DB 'info/pp.log', 00H ; `string'
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\main.cpp
CONST	ENDS
;	COMDAT _WinMain@16
_TEXT	SEGMENT
_szIPOnCmd$ = -380					; size = 16
_msg$519487 = -364					; size = 28
$T520455 = -352						; size = 16
$T520442 = -352						; size = 16
_szOptionsOnCmd$ = -336					; size = 16
_szKeyOnCmd$ = -320					; size = 16
_dwVersion$ = -304					; size = 4
_iPortOncmd$ = -300					; size = 4
_lpCmdLine$GSCopy$ = -296				; size = 4
_iRet$ = -292						; size = 4
_buffer$519348 = -292					; size = 4
_hInstance$GSCopy$ = -288				; size = 4
$T520468 = -284						; size = 4
_pLocal$ = -284						; size = 4
$T520406 = -280						; size = 4
$T520414 = -276						; size = 4
$T520410 = -272						; size = 4
_hMutex$ = -268						; size = 4
_size$519347 = -268					; size = 4
_szVersion$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_hInstance$ = 8						; size = 4
_hPrevInstance$ = 12					; size = 4
_lpCmdLine$ = 16					; size = 4
_nShowCmd$ = 20						; size = 4
_WinMain@16 PROC					; COMDAT

; 155  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 7c 01 00
	00		 sub	 esp, 380		; 0000017cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _hInstance$[ebp]

; 156  : 
; 157  : #ifdef SHIPPING
; 158  : 	LOG.OpenLog( 0, "info/pp.log");

  00016	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?LOG@@3VCLog@@A
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	33 db		 xor	 ebx, ebx
  00020	53		 push	 ebx

; 266  : 	{
; 267  : 		SendMsgToAutoUpgrade( WM_MY_MSG_C_ERROR );

  00021	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _hInstance$GSCopy$[ebp], eax
  00027	8b 45 10	 mov	 eax, DWORD PTR _lpCmdLine$[ebp]
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0M@MNHKONMG@info?1pp?4log?$AA@
  0002f	53		 push	 ebx
  00030	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _lpCmdLine$GSCopy$[ebp], eax
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?OpenLog@CLog@@QAEXHPBD_N@Z
  0003c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?PrintTimeAndLog@CLog@@QAAXHPADZZ
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@OMIBODJD@?$FLMain?$FN?5?9?5LostSaga?5Start?$AA@
  00047	53		 push	 ebx
  00048	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  0004e	ff d6		 call	 esi
  00050	6a 01		 push	 1
  00052	e8 00 00 00 00	 call	 ?CheckEnableTimeGapUser@Help@@YA_NH@Z ; Help::CheckEnableTimeGapUser
  00057	83 c4 10	 add	 esp, 16			; 00000010H
  0005a	84 c0		 test	 al, al
  0005c	74 0b		 je	 SHORT $LN62@WinMain

; 159  : #else
; 160  : 	//Admin버전은 다중 실행 될 수 있음으로 각 프로세스 별로 로그 파일을 생성 할 수 있도록 수정함
; 161  : 	int iProcessCount = Help::GetProcessRunningCount( "lostsaga.exe" );
; 162  : 	char szBuff[MAX_PATH];
; 163  : 	sprintf_s( szBuff, "info/pp_%d.log", iProcessCount );
; 164  : 	LOG.OpenLog( 0, szBuff );
; 165  : #endif
; 166  : 
; 167  : 	LOG.PrintTimeAndLog(0, "[Main] - LostSaga Start");
; 168  : 
; 169  : //	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
; 170  : 
; 171  : #ifndef _DEBUG
; 172  : 	// minidump
; 173  :  	if( Help::CheckEnableTimeGapUser(1) )
; 174  : 		MiniDump::Begin( "LostSagaT" );

  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_09DOKKIOMA@LostSagaT?$AA@
  00063	e8 00 00 00 00	 call	 ?Begin@MiniDump@@SAHPBD@Z ; MiniDump::Begin
  00068	59		 pop	 ecx
$LN62@WinMain:

; 175  : 
; 176  : 	if( !SetCrashHandlerFilter( ExceptCallBack ) )

  00069	68 00 00 00 00	 push	 OFFSET ?ExceptCallBack@@YGJPAU_EXCEPTION_POINTERS@@@Z ; ExceptCallBack
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCrashHandlerFilter@4
  00074	85 c0		 test	 eax, eax
  00076	75 18		 jne	 SHORT $LN61@WinMain

; 177  : 	{
; 178  : 		LOG.PrintTimeAndLog( 0, "WINAPI WinMain - SetCrashHandlerFilter Failed" );

  00078	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@POJFBNPL@WINAPI?5WinMain?5?9?5SetCrashHandler@
  0007d	53		 push	 ebx
  0007e	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  00084	ff d6		 call	 esi
  00086	83 c4 0c	 add	 esp, 12			; 0000000cH

; 179  : 		return false;

  00089	33 c0		 xor	 eax, eax
  0008b	e9 e3 05 00 00	 jmp	 $LN63@WinMain
$LN61@WinMain:
  00090	57		 push	 edi

; 180  : 	}
; 181  : #endif
; 182  : 
; 183  : 	ioINIMemoryStatic* pStatics = new ioINIMemoryStatic;

  00091	6a 18		 push	 24			; 00000018H
  00093	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00098	8b f8		 mov	 edi, eax
  0009a	59		 pop	 ecx
  0009b	3b fb		 cmp	 edi, ebx
  0009d	74 16		 je	 SHORT $LN65@WinMain
  0009f	8b cf		 mov	 ecx, edi
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioINIMemoryStatic@@QAE@XZ
  000a7	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_SioINIMemoryStatic@@6B@
  000ad	89 bd e8 fe ff
	ff		 mov	 DWORD PTR $T520406[ebp], edi
  000b3	eb 06		 jmp	 SHORT $LN66@WinMain
$LN65@WinMain:
  000b5	89 9d e8 fe ff
	ff		 mov	 DWORD PTR $T520406[ebp], ebx
$LN66@WinMain:

; 184  : 	ioLocalManager *pLocalMgr = new ioLocalManager;   

  000bb	68 18 04 00 00	 push	 1048			; 00000418H
  000c0	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000c5	59		 pop	 ecx
  000c6	3b c3		 cmp	 eax, ebx
  000c8	74 0f		 je	 SHORT $LN67@WinMain
  000ca	8b c8		 mov	 ecx, eax
  000cc	e8 00 00 00 00	 call	 ??0ioLocalManager@@QAE@XZ ; ioLocalManager::ioLocalManager
  000d1	89 85 f0 fe ff
	ff		 mov	 DWORD PTR $T520410[ebp], eax
  000d7	eb 06		 jmp	 SHORT $LN68@WinMain
$LN67@WinMain:
  000d9	89 9d f0 fe ff
	ff		 mov	 DWORD PTR $T520410[ebp], ebx
$LN68@WinMain:

; 185  : 	if( pLocalMgr )

  000df	39 9d f0 fe ff
	ff		 cmp	 DWORD PTR $T520410[ebp], ebx
  000e5	74 23		 je	 SHORT $LN60@WinMain

; 186  : 	{		
; 187  : 		pLocalMgr->Init();

  000e7	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR $T520410[ebp]
  000ed	e8 00 00 00 00	 call	 ?Init@ioLocalManager@@QAEXXZ ; ioLocalManager::Init

; 188  : 		pLocalMgr->ParseCmd( lpCmdLine );

  000f2	ff b5 d8 fe ff
	ff		 push	 DWORD PTR _lpCmdLine$GSCopy$[ebp]
  000f8	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR $T520410[ebp]
  000fe	e8 00 00 00 00	 call	 ?ParseCmd@ioLocalManager@@QAEXPBD@Z ; ioLocalManager::ParseCmd

; 189  : 		LOG.PrintTimeAndLog(0, "[Main] - Local Manager Init Complete");

  00103	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@CHDBNJEO@?$FLMain?$FN?5?9?5Local?5Manager?5Init?5Comp@

; 190  : 	}
; 191  : 	else

  00108	eb 05		 jmp	 SHORT $LN146@WinMain
$LN60@WinMain:

; 192  : 	{
; 193  : 		LOG.PrintTimeAndLog(0, "[Main] - Local Manager Init Failed");

  0010a	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@FNCGCLND@?$FLMain?$FN?5?9?5Local?5Manager?5Init?5Fail@
$LN146@WinMain:
  0010f	53		 push	 ebx
  00110	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  00116	ff d6		 call	 esi
  00118	83 c4 0c	 add	 esp, 12			; 0000000cH

; 194  : 	}
; 195  : 
; 196  : 	ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );

  0011b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLocalType@ioLocalManagerParent@@SA?AW4LocalType@1@XZ
  00121	50		 push	 eax
  00122	e8 00 00 00 00	 call	 ?GetSingleton@ioLocalManager@@SAAAV1@XZ ; ioLocalManager::GetSingleton
  00127	8b c8		 mov	 ecx, eax
  00129	e8 00 00 00 00	 call	 ?GetLocal@ioLocalManager@@QAEPAVioLocalParent@@W4LocalType@ioLocalManagerParent@@@Z ; ioLocalManager::GetLocal

; 197  : 	ioStringManager *pStringMgr = new ioStringManager;

  0012e	6a 24		 push	 36			; 00000024H
  00130	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _pLocal$[ebp], eax
  00136	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0013b	8b f8		 mov	 edi, eax
  0013d	59		 pop	 ecx
  0013e	3b fb		 cmp	 edi, ebx
  00140	74 16		 je	 SHORT $LN69@WinMain
  00142	8b cf		 mov	 ecx, edi
  00144	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioStringManager@@QAE@XZ
  0014a	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_SioStringManager@@6B@
  00150	89 bd ec fe ff
	ff		 mov	 DWORD PTR $T520414[ebp], edi
  00156	eb 06		 jmp	 SHORT $LN70@WinMain
$LN69@WinMain:
  00158	89 9d ec fe ff
	ff		 mov	 DWORD PTR $T520414[ebp], ebx
$LN70@WinMain:

; 198  : 	if( pStringMgr && pLocal )

  0015e	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00163	39 9d ec fe ff
	ff		 cmp	 DWORD PTR $T520414[ebp], ebx
  00169	74 49		 je	 SHORT $LN58@WinMain
  0016b	39 9d e4 fe ff
	ff		 cmp	 DWORD PTR _pLocal$[ebp], ebx
  00171	0f 84 a3 00 00
	00		 je	 $LN57@WinMain

; 199  : 	{
; 200  : #ifdef SRC_OVERSEAS
; 201  : 		DWORD size = 0;
; 202  : 		const char * buffer = NULL;
; 203  : 		Help::LoadTextInResource(IDR_ERROR, size, buffer);

  00177	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _buffer$519348[ebp]
  0017d	50		 push	 eax
  0017e	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _size$519347[ebp]
  00184	50		 push	 eax
  00185	68 c9 00 00 00	 push	 201			; 000000c9H
  0018a	89 9d f4 fe ff
	ff		 mov	 DWORD PTR _size$519347[ebp], ebx
  00190	89 9d dc fe ff
	ff		 mov	 DWORD PTR _buffer$519348[ebp], ebx
  00196	e8 00 00 00 00	 call	 ?LoadTextInResource@Help@@YAXHAAKAAPBD@Z ; Help::LoadTextInResource

; 204  : 		pStringMgr->LoadData( "", "", buffer, true );

  0019b	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR $T520414[ebp]
  001a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a4	6a 01		 push	 1
  001a6	ff b5 dc fe ff
	ff		 push	 DWORD PTR _buffer$519348[ebp]
  001ac	57		 push	 edi
  001ad	57		 push	 edi
  001ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadData@ioStringManager@@QAEXPBD00_N@Z
$LN58@WinMain:

; 205  : #else	
; 206  : 		pStringMgr->LoadData( "", "", pLocal->GetMemTextList(), true );
; 207  : #endif
; 208  : 	}
; 209  : 
; 210  : 
; 211  : 	if( pLocal && !pLocal->IsRightLicense() )

  001b4	39 9d e4 fe ff
	ff		 cmp	 DWORD PTR _pLocal$[ebp], ebx
  001ba	74 5e		 je	 SHORT $LN57@WinMain
  001bc	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _pLocal$[ebp]
  001c2	8b 01		 mov	 eax, DWORD PTR [ecx]
  001c4	ff 90 cc 00 00
	00		 call	 DWORD PTR [eax+204]
  001ca	84 c0		 test	 al, al
  001cc	75 4c		 jne	 SHORT $LN57@WinMain

; 212  : 	{
; 213  : 		MessageBox( NULL, "Your license has com up for renewal.", "IOEnter", MB_OK );

  001ce	53		 push	 ebx
  001cf	68 00 00 00 00	 push	 OFFSET ??_C@_07NAJDILEH@IOEnter?$AA@
  001d4	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@HMNPAODJ@Your?5license?5has?5com?5up?5for?5rene@
  001d9	53		 push	 ebx
  001da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 214  : 		SAFEDELETE( pLocalMgr );

  001e0	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR $T520410[ebp]
  001e6	3b cb		 cmp	 ecx, ebx
  001e8	74 06		 je	 SHORT $LN131@WinMain
  001ea	8b 01		 mov	 eax, DWORD PTR [ecx]
  001ec	6a 01		 push	 1
  001ee	ff 10		 call	 DWORD PTR [eax]
$LN131@WinMain:

; 215  : 		SAFEDELETE( pStringMgr );

  001f0	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR $T520414[ebp]
  001f6	3b cb		 cmp	 ecx, ebx
  001f8	74 06		 je	 SHORT $LN139@WinMain
  001fa	8b 01		 mov	 eax, DWORD PTR [ecx]
  001fc	6a 01		 push	 1
  001fe	ff 10		 call	 DWORD PTR [eax]
$LN139@WinMain:

; 216  : 		SAFEDELETE( pStatics );

  00200	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR $T520406[ebp]
  00206	3b cb		 cmp	 ecx, ebx
  00208	74 06		 je	 SHORT $LN75@WinMain
  0020a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0020c	6a 01		 push	 1
  0020e	ff 10		 call	 DWORD PTR [eax]
$LN75@WinMain:

; 217  : 
; 218  : 
; 219  : 		LOG.PrintTimeAndLog(0, "[Main] - license Error" );

  00210	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@IPJHKBFC@?$FLMain?$FN?5?9?5license?5Error?$AA@

; 220  : 		return 0;

  00215	e9 58 03 00 00	 jmp	 $LN149@WinMain
$LN57@WinMain:

; 221  : 	}
; 222  : 	
; 223  : 	HANDLE hMutex = NULL;
; 224  : #ifdef SHIPPING
; 225  : 	hMutex = CreateMutex(NULL, true, CLIENTMUTEXNAME );

  0021a	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@MFGDLFLE@Global?2_LOSTSAGA_CLIENT_38947383@
  0021f	6a 01		 push	 1
  00221	53		 push	 ebx
  00222	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateMutexA@12
  00228	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _hMutex$[ebp], eax

; 226  : 	if(GetLastError() == ERROR_ALREADY_EXISTS)

  0022e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00234	3d b7 00 00 00	 cmp	 eax, 183		; 000000b7H
  00239	75 69		 jne	 SHORT $LN53@WinMain

; 227  : 	{
; 228  : 		Help::MessageboxShow( NULL, STR(2), "LostSaga_Client - Error", MB_TOPMOST );

  0023b	68 00 00 04 00	 push	 262144			; 00040000H
  00240	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@PPHFGBKO@LostSaga_Client?5?9?5Error?$AA@
  00245	53		 push	 ebx
  00246	6a 02		 push	 2
  00248	57		 push	 edi
  00249	68 00 00 00 00	 push	 OFFSET ??_C@_07HGGPAHEN@WinMain?$AA@
  0024e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00254	8b c8		 mov	 ecx, eax
  00256	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0025c	50		 push	 eax
  0025d	53		 push	 ebx
  0025e	e8 00 00 00 00	 call	 ?MessageboxShow@Help@@YAHPAUHWND__@@PBD1I@Z ; Help::MessageboxShow
  00263	83 c4 10	 add	 esp, 16			; 00000010H

; 229  : 		SAFEDELETE( pLocalMgr );

  00266	39 9d f0 fe ff
	ff		 cmp	 DWORD PTR $T520410[ebp], ebx
  0026c	74 0c		 je	 SHORT $LN132@WinMain
  0026e	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR $T520410[ebp]
  00274	8b 01		 mov	 eax, DWORD PTR [ecx]
  00276	6a 01		 push	 1
  00278	ff 10		 call	 DWORD PTR [eax]
$LN132@WinMain:

; 230  : 		SAFEDELETE( pStringMgr );

  0027a	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR $T520414[ebp]
  00280	3b cb		 cmp	 ecx, ebx
  00282	74 06		 je	 SHORT $LN140@WinMain
  00284	8b 01		 mov	 eax, DWORD PTR [ecx]
  00286	6a 01		 push	 1
  00288	ff 10		 call	 DWORD PTR [eax]
$LN140@WinMain:

; 231  : 		SAFEDELETE( pStatics );

  0028a	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR $T520406[ebp]
  00290	3b cb		 cmp	 ecx, ebx
  00292	74 06		 je	 SHORT $LN81@WinMain
  00294	8b 01		 mov	 eax, DWORD PTR [ecx]
  00296	6a 01		 push	 1
  00298	ff 10		 call	 DWORD PTR [eax]
$LN81@WinMain:

; 232  : 
; 233  : 		LOG.PrintTimeAndLog( 0, "[Main] - Mutex Create Failed" );

  0029a	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@BNHKPFEA@?$FLMain?$FN?5?9?5Mutex?5Create?5Failed?$AA@

; 234  : 		return 0;

  0029f	e9 ce 02 00 00	 jmp	 $LN149@WinMain
$LN53@WinMain:

; 235  : 	}
; 236  : #endif
; 237  : 
; 238  : 	DWORD dwVersion;
; 239  : 	char  szVersion[MAX_PATH];
; 240  : 
; 241  : 	if( !Help::GetDXVersionInfo( &dwVersion, szVersion, MAX_PATH ) )

  002a4	68 04 01 00 00	 push	 260			; 00000104H
  002a9	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szVersion$[ebp]
  002af	50		 push	 eax
  002b0	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _dwVersion$[ebp]
  002b6	50		 push	 eax
  002b7	e8 00 00 00 00	 call	 ?GetDXVersionInfo@Help@@YA_NPAKPADH@Z ; Help::GetDXVersionInfo
  002bc	83 c4 0c	 add	 esp, 12			; 0000000cH
  002bf	84 c0		 test	 al, al
  002c1	0f 85 f3 00 00
	00		 jne	 $LN49@WinMain

; 242  : 	{
; 243  : 		SendMsgToAutoUpgrade( WM_MY_MSG_C_ERROR );

  002c7	68 2f 05 00 00	 push	 1327			; 0000052fH
  002cc	e8 00 00 00 00	 call	 ?SendMsgToAutoUpgrade@@YAXK@Z ; SendMsgToAutoUpgrade

; 244  : 		Setting::Initialize("error");

  002d1	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR $T520442[ebp]
  002d7	c7 04 24 00 00
	00 00		 mov	 DWORD PTR [esp], OFFSET ??_C@_05KKCIMGE@error?$AA@
  002de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  002e4	8d 85 a0 fe ff
	ff		 lea	 eax, DWORD PTR $T520442[ebp]
  002ea	50		 push	 eax
  002eb	e8 00 00 00 00	 call	 ?Initialize@Setting@@SAXABVioHashString@@@Z ; Setting::Initialize
  002f0	59		 pop	 ecx
  002f1	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR $T520442[ebp]
  002f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ

; 245  : 		g_bHappenError = true;
; 246  : 		g_iErrorNumber = 301;
; 247  : 		SafeSprintf( g_szErrorLog, sizeof(g_szErrorLog), STR(3) );

  002fd	53		 push	 ebx
  002fe	6a 03		 push	 3
  00300	57		 push	 edi
  00301	68 00 00 00 00	 push	 OFFSET ??_C@_07HGGPAHEN@WinMain?$AA@
  00306	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?g_bHappenError@@3_NA, 1 ; g_bHappenError
  0030d	c7 05 00 00 00
	00 2d 01 00 00	 mov	 DWORD PTR ?g_iErrorNumber@@3HA, 301 ; g_iErrorNumber, 0000012dH
  00317	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  0031d	8b c8		 mov	 ecx, eax
  0031f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  00325	50		 push	 eax
  00326	68 00 10 00 00	 push	 4096			; 00001000H
  0032b	68 00 00 00 00	 push	 OFFSET ?g_szErrorLog@@3PADA ; g_szErrorLog
  00330	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SafeSprintf@@YAXPADHPBDZZ

; 248  : 		// 소켓통신이 안되는 구간이므로 ini 기록하고 나중에 전송.
; 249  : 		Help::SaveClientError( g_iErrorNumber, 0, 0 );

  00336	53		 push	 ebx
  00337	53		 push	 ebx
  00338	ff 35 00 00 00
	00		 push	 DWORD PTR ?g_iErrorNumber@@3HA ; g_iErrorNumber
  0033e	e8 00 00 00 00	 call	 ?SaveClientError@Help@@YAXHHH@Z ; Help::SaveClientError
  00343	83 c4 18	 add	 esp, 24			; 00000018H

; 250  : 
; 251  : 		if( hInstance )

  00346	39 9d e0 fe ff
	ff		 cmp	 DWORD PTR _hInstance$GSCopy$[ebp], ebx
  0034c	74 0c		 je	 SHORT $LN48@WinMain

; 252  : 			ShowOtherErrorDlg(hInstance);

  0034e	ff b5 e0 fe ff
	ff		 push	 DWORD PTR _hInstance$GSCopy$[ebp]
  00354	e8 00 00 00 00	 call	 ?ShowOtherErrorDlg@@YAXPAUHINSTANCE__@@@Z ; ShowOtherErrorDlg
  00359	59		 pop	 ecx
$LN48@WinMain:

; 253  : 
; 254  : 		if(hMutex != NULL)

  0035a	39 9d f4 fe ff
	ff		 cmp	 DWORD PTR _hMutex$[ebp], ebx
  00360	74 0c		 je	 SHORT $LN47@WinMain

; 255  : 			CloseHandle(hMutex);

  00362	ff b5 f4 fe ff
	ff		 push	 DWORD PTR _hMutex$[ebp]
  00368	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN47@WinMain:

; 256  : 		SAFEDELETE( pLocalMgr );

  0036e	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR $T520410[ebp]
  00374	3b cb		 cmp	 ecx, ebx
  00376	74 06		 je	 SHORT $LN133@WinMain
  00378	8b 01		 mov	 eax, DWORD PTR [ecx]
  0037a	6a 01		 push	 1
  0037c	ff 10		 call	 DWORD PTR [eax]
$LN133@WinMain:

; 257  : 		SAFEDELETE( pStringMgr );

  0037e	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR $T520414[ebp]
  00384	3b cb		 cmp	 ecx, ebx
  00386	74 06		 je	 SHORT $LN141@WinMain
  00388	8b 01		 mov	 eax, DWORD PTR [ecx]
  0038a	6a 01		 push	 1
  0038c	ff 10		 call	 DWORD PTR [eax]
$LN141@WinMain:

; 258  : 		SAFEDELETE( pStatics );

  0038e	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR $T520406[ebp]
  00394	3b cb		 cmp	 ecx, ebx
  00396	74 06		 je	 SHORT $LN87@WinMain
  00398	8b 01		 mov	 eax, DWORD PTR [ecx]
  0039a	6a 01		 push	 1
  0039c	ff 10		 call	 DWORD PTR [eax]
$LN87@WinMain:

; 259  : 
; 260  : 		MessageBox( NULL, "Get DX Info Error!", "IOEnter", MB_OK );

  0039e	53		 push	 ebx
  0039f	68 00 00 00 00	 push	 OFFSET ??_C@_07NAJDILEH@IOEnter?$AA@
  003a4	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KEIBIJLN@Get?5DX?5Info?5Error?$CB?$AA@
  003a9	53		 push	 ebx
  003aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 261  : 		LOG.PrintTimeAndLog( 0, "[Main] - Get DX Info Error" );

  003b0	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@PDJKFNLM@?$FLMain?$FN?5?9?5Get?5DX?5Info?5Error?$AA@

; 262  : 		return 0;

  003b5	e9 b8 01 00 00	 jmp	 $LN149@WinMain
$LN49@WinMain:

; 263  : 	}
; 264  : 
; 265  : 	if( dwVersion < 0x00090003 )	// 9.0c

  003ba	81 bd d0 fe ff
	ff 03 00 09 00	 cmp	 DWORD PTR _dwVersion$[ebp], 589827 ; 00090003H
  003c4	0f 83 f3 00 00
	00		 jae	 $LN43@WinMain

; 266  : 	{
; 267  : 		SendMsgToAutoUpgrade( WM_MY_MSG_C_ERROR );

  003ca	68 2f 05 00 00	 push	 1327			; 0000052fH
  003cf	e8 00 00 00 00	 call	 ?SendMsgToAutoUpgrade@@YAXK@Z ; SendMsgToAutoUpgrade

; 268  : 		Setting::Initialize("error");

  003d4	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR $T520455[ebp]
  003da	c7 04 24 00 00
	00 00		 mov	 DWORD PTR [esp], OFFSET ??_C@_05KKCIMGE@error?$AA@
  003e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  003e7	8d 85 a0 fe ff
	ff		 lea	 eax, DWORD PTR $T520455[ebp]
  003ed	50		 push	 eax
  003ee	e8 00 00 00 00	 call	 ?Initialize@Setting@@SAXABVioHashString@@@Z ; Setting::Initialize
  003f3	59		 pop	 ecx
  003f4	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR $T520455[ebp]
  003fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ

; 269  : 		g_bHappenError = true;
; 270  : 		g_iErrorNumber = 302;
; 271  : 		SafeSprintf( g_szErrorLog, sizeof(g_szErrorLog), STR(4) );

  00400	53		 push	 ebx
  00401	6a 04		 push	 4
  00403	57		 push	 edi
  00404	68 00 00 00 00	 push	 OFFSET ??_C@_07HGGPAHEN@WinMain?$AA@
  00409	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?g_bHappenError@@3_NA, 1 ; g_bHappenError
  00410	c7 05 00 00 00
	00 2e 01 00 00	 mov	 DWORD PTR ?g_iErrorNumber@@3HA, 302 ; g_iErrorNumber, 0000012eH
  0041a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00420	8b c8		 mov	 ecx, eax
  00422	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  00428	50		 push	 eax
  00429	68 00 10 00 00	 push	 4096			; 00001000H
  0042e	68 00 00 00 00	 push	 OFFSET ?g_szErrorLog@@3PADA ; g_szErrorLog
  00433	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SafeSprintf@@YAXPADHPBDZZ

; 272  : 		// 소켓통신이 안되는 구간이므로 ini 기록하고 나중에 전송.
; 273  : 		Help::SaveClientError( g_iErrorNumber, 0, 0 );

  00439	53		 push	 ebx
  0043a	53		 push	 ebx
  0043b	ff 35 00 00 00
	00		 push	 DWORD PTR ?g_iErrorNumber@@3HA ; g_iErrorNumber
  00441	e8 00 00 00 00	 call	 ?SaveClientError@Help@@YAXHHH@Z ; Help::SaveClientError
  00446	83 c4 18	 add	 esp, 24			; 00000018H

; 274  : 
; 275  : 		if( hInstance )

  00449	39 9d e0 fe ff
	ff		 cmp	 DWORD PTR _hInstance$GSCopy$[ebp], ebx
  0044f	74 0c		 je	 SHORT $LN42@WinMain

; 276  : 			ShowOtherErrorDlg(hInstance);

  00451	ff b5 e0 fe ff
	ff		 push	 DWORD PTR _hInstance$GSCopy$[ebp]
  00457	e8 00 00 00 00	 call	 ?ShowOtherErrorDlg@@YAXPAUHINSTANCE__@@@Z ; ShowOtherErrorDlg
  0045c	59		 pop	 ecx
$LN42@WinMain:

; 277  : 
; 278  : 		if(hMutex != NULL)

  0045d	39 9d f4 fe ff
	ff		 cmp	 DWORD PTR _hMutex$[ebp], ebx
  00463	74 0c		 je	 SHORT $LN41@WinMain

; 279  : 			CloseHandle(hMutex);

  00465	ff b5 f4 fe ff
	ff		 push	 DWORD PTR _hMutex$[ebp]
  0046b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN41@WinMain:

; 280  : 		SAFEDELETE( pLocalMgr );

  00471	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR $T520410[ebp]
  00477	3b cb		 cmp	 ecx, ebx
  00479	74 06		 je	 SHORT $LN134@WinMain
  0047b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0047d	6a 01		 push	 1
  0047f	ff 10		 call	 DWORD PTR [eax]
$LN134@WinMain:

; 281  : 		SAFEDELETE( pStringMgr );

  00481	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR $T520414[ebp]
  00487	3b cb		 cmp	 ecx, ebx
  00489	74 06		 je	 SHORT $LN142@WinMain
  0048b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0048d	6a 01		 push	 1
  0048f	ff 10		 call	 DWORD PTR [eax]
$LN142@WinMain:

; 282  : 		SAFEDELETE( pStatics );

  00491	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR $T520406[ebp]
  00497	3b cb		 cmp	 ecx, ebx
  00499	74 06		 je	 SHORT $LN93@WinMain
  0049b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0049d	6a 01		 push	 1
  0049f	ff 10		 call	 DWORD PTR [eax]
$LN93@WinMain:

; 283  : 
; 284  : 		MessageBox( NULL, "DX Version Error!", "IOEnter", MB_OK );

  004a1	53		 push	 ebx
  004a2	68 00 00 00 00	 push	 OFFSET ??_C@_07NAJDILEH@IOEnter?$AA@
  004a7	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@LCFONAOC@DX?5Version?5Error?$CB?$AA@
  004ac	53		 push	 ebx
  004ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 285  : 		LOG.PrintTimeAndLog( 0, "[Main] - DX Version Error!" );

  004b3	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@FNOAENGG@?$FLMain?$FN?5?9?5DX?5Version?5Error?$CB?$AA@

; 286  : 
; 287  : 		return 0;

  004b8	e9 b5 00 00 00	 jmp	 $LN149@WinMain
$LN43@WinMain:

; 288  : 	}
; 289  : 
; 290  : 	Setting::SetDirectXVersion( szVersion, dwVersion );

  004bd	ff b5 d0 fe ff
	ff		 push	 DWORD PTR _dwVersion$[ebp]
  004c3	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szVersion$[ebp]
  004c9	50		 push	 eax
  004ca	e8 00 00 00 00	 call	 ?SetDirectXVersion@Setting@@SAXPBDK@Z ; Setting::SetDirectXVersion

; 291  : 
; 292  : 	Setting::CheckOSVersion();

  004cf	e8 00 00 00 00	 call	 ?CheckOSVersion@Setting@@SAXXZ ; Setting::CheckOSVersion

; 293  : 	ioFrameTimer::SetWindowsModule( !Setting::IsWin98Series() );

  004d4	38 1d 00 00 00
	00		 cmp	 BYTE PTR ?m_bWin98Series@Setting@@1_NA, bl ; Setting::m_bWin98Series
  004da	0f 94 c0	 sete	 al
  004dd	0f b6 c0	 movzx	 eax, al
  004e0	50		 push	 eax
  004e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetWindowsModule@ioFrameTimer@@SAX_N@Z

; 294  : 
; 295  : 	ioApplication *pApp = new ioApplication;

  004e7	68 80 07 00 00	 push	 1920			; 00000780H
  004ec	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  004f1	83 c4 10	 add	 esp, 16			; 00000010H
  004f4	3b c3		 cmp	 eax, ebx
  004f6	74 0f		 je	 SHORT $LN95@WinMain
  004f8	8b c8		 mov	 ecx, eax
  004fa	e8 00 00 00 00	 call	 ??0ioApplication@@QAE@XZ ; ioApplication::ioApplication
  004ff	89 85 e4 fe ff
	ff		 mov	 DWORD PTR $T520468[ebp], eax
  00505	eb 06		 jmp	 SHORT $LN96@WinMain
$LN95@WinMain:
  00507	89 9d e4 fe ff
	ff		 mov	 DWORD PTR $T520468[ebp], ebx
$LN96@WinMain:

; 296  : 	if( !pApp )	

  0050d	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR $T520468[ebp]
  00513	3b cb		 cmp	 ecx, ebx
  00515	75 6c		 jne	 SHORT $LN37@WinMain

; 297  : 	{
; 298  : 		if(hMutex != NULL)

  00517	39 9d f4 fe ff
	ff		 cmp	 DWORD PTR _hMutex$[ebp], ebx
  0051d	74 0c		 je	 SHORT $LN36@WinMain

; 299  : 			CloseHandle(hMutex);

  0051f	ff b5 f4 fe ff
	ff		 push	 DWORD PTR _hMutex$[ebp]
  00525	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN36@WinMain:

; 300  : 		SAFEDELETE( pLocalMgr );

  0052b	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR $T520410[ebp]
  00531	3b cb		 cmp	 ecx, ebx
  00533	74 06		 je	 SHORT $LN135@WinMain
  00535	8b 01		 mov	 eax, DWORD PTR [ecx]
  00537	6a 01		 push	 1
  00539	ff 10		 call	 DWORD PTR [eax]
$LN135@WinMain:

; 301  : 		SAFEDELETE( pStringMgr );

  0053b	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR $T520414[ebp]
  00541	3b cb		 cmp	 ecx, ebx
  00543	74 06		 je	 SHORT $LN143@WinMain
  00545	8b 01		 mov	 eax, DWORD PTR [ecx]
  00547	6a 01		 push	 1
  00549	ff 10		 call	 DWORD PTR [eax]
$LN143@WinMain:

; 302  : 		SAFEDELETE( pStatics );

  0054b	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR $T520406[ebp]
  00551	3b cb		 cmp	 ecx, ebx
  00553	74 06		 je	 SHORT $LN101@WinMain
  00555	8b 01		 mov	 eax, DWORD PTR [ecx]
  00557	6a 01		 push	 1
  00559	ff 10		 call	 DWORD PTR [eax]
$LN101@WinMain:

; 303  : 
; 304  : 		MessageBox( NULL, "Create App Error!", "IOEnter", MB_OK );

  0055b	53		 push	 ebx
  0055c	68 00 00 00 00	 push	 OFFSET ??_C@_07NAJDILEH@IOEnter?$AA@
  00561	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@LLKKGKHC@Create?5App?5Error?$CB?$AA@
  00566	53		 push	 ebx
  00567	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 305  : 		LOG.PrintTimeAndLog( 0, "[Main] - Create App Error!" );

  0056d	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@FEBEPHPG@?$FLMain?$FN?5?9?5Create?5App?5Error?$CB?$AA@
$LN149@WinMain:
  00572	53		 push	 ebx
  00573	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  00579	ff d6		 call	 esi
  0057b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 306  : 
; 307  : 		return 0;

  0057e	e9 ed 00 00 00	 jmp	 $LN148@WinMain
$LN37@WinMain:

; 308  : 	}
; 309  : 
; 310  : //브라우저창 안띄우고 실행하려면 아래 주석을 풀고 컴파일
; 311  : //#define _DIRECT_RUN_
; 312  : #ifdef _DIRECT_RUN_
; 313  : 	int iPortOncmd = 0;
; 314  : 	ioHashString szKeyOnCmd, szOptionsOnCmd, szIPOnCmd;
; 315  : 	szOptionsOnCmd += "1"; //싱글
; 316  : 	szOptionsOnCmd += "0"; //리소스 업데이트
; 317  : 	szOptionsOnCmd += "0"; //리드팩
; 318  : 	szOptionsOnCmd += "0"; //팩 풀기
; 319  : 	szOptionsOnCmd += "2"; //모드
; 320  : 	szOptionsOnCmd += "0"; //풀스크린
; 321  : 	szOptionsOnCmd += "1"; //바운드박스
; 322  : 	szOptionsOnCmd += "1"; //추가 정보(EXTRA INFO)
; 323  : 	szOptionsOnCmd += "0"; //메모리 정보(MEMORY USAGE)
; 324  : 	szOptionsOnCmd += "1"; //콘솔창
; 325  : 	szOptionsOnCmd += "0"; //VS디버그
; 326  : 	szOptionsOnCmd += "0"; //폴더 카피
; 327  : 	szOptionsOnCmd += "1"; //모드 Sub
; 328  : 	szOptionsOnCmd += "9"; //모드 맵
; 329  : #else
; 330  : 
; 331  : #ifdef LOCAL_DBG
; 332  : 	int iPortOncmd = 0;
; 333  : 	ioHashString szKeyOnCmd, szOptionsOnCmd, szIPOnCmd;
; 334  : 	char *TempCmd = lpCmdLine;
; 335  : 	int iSize    = strlen( TempCmd );
; 336  : 	int iNum = 0;
; 337  : 	char szTemp[MAX_PATH] ="";
; 338  : 	for( int i = 0 ; i < iSize ; ++i )
; 339  : 	{
; 340  : 		if( TempCmd[i] == '*')
; 341  : 		{
; 342  : 			memcpy( szTemp, TempCmd, i );
; 343  : 			szIPOnCmd = szTemp;
; 344  : 			memcpy( szTemp, TempCmd + iNum + 1, iSize );
; 345  : 			szKeyOnCmd = szTemp;
; 346  : 			break;
; 347  : 		}
; 348  : 		++iNum;
; 349  : 	}
; 350  : 	szOptionsOnCmd = "10006011011011";
; 351  : 	//szIPOnCmd		= "172.20.20.175";
; 352  : 	iPortOncmd		= 14009;
; 353  : 	//szKeyOnCmd		= lpCmdLine;
; 354  : #endif
; 355  : #ifdef LOCAL_DBG_UNPAC
; 356  : 	szOptionsOnCmd = "10016011111011";
; 357  : #endif
; 358  : 
; 359  : //브라우저창 없이 존에 접속하기
; 360  : //#define _NO_WEB_
; 361  : #ifdef _NO_WEB_
; 362  : #ifndef SHIPPING
; 363  : 	char szURL[MAX_PATH];
; 364  : 	char szFile[MAX_PATH];
; 365  : 	::GetCurrentDirectory( MAX_PATH, szFile );
; 366  : 	sprintf( szFile, "%s/%s", szFile, "config/debug_connect.ini" );
; 367  : 	FILE* fp = fopen( szFile, "rt" );
; 368  : 	if(fp == NULL)
; 369  : 	{
; 370  : 		MessageBox( NULL, "Debug App Error!", "IOEnter", MB_OK );
; 371  : 		LOG.PrintTimeAndLog( 0, "[Main] - Debug App Error!" );
; 372  : 		return 0;
; 373  : 	}
; 374  : 	fclose(fp);
; 375  : 
; 376  : 	GetPrivateProfileString( "no_web_connect", "login_key", "", szURL, MAX_PATH, szFile );
; 377  : 	lpCmdLine = szURL;
; 378  : #else
; 379  : 	MessageBox( NULL, "Debug App Error!", "IOEnter", MB_OK );
; 380  : 	LOG.PrintTimeAndLog( 0, "[Main] - Debug App Error!" );
; 381  : #endif
; 382  : #else
; 383  : 	pApp->DebugWebLogin(lpCmdLine);

  00583	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _lpCmdLine$GSCopy$[ebp]
  00589	50		 push	 eax
  0058a	e8 00 00 00 00	 call	 ?DebugWebLogin@ioApplication@@QAEXAAPAD@Z ; ioApplication::DebugWebLogin

; 384  : #endif
; 385  : 
; 386  : #ifdef SHIPPING
; 387  : 	int iPortOncmd = 0;
; 388  : 	ioHashString szKeyOnCmd, szOptionsOnCmd, szIPOnCmd;

  0058f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_??0ioHashString@@QAE@XZ
  00595	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR _szKeyOnCmd$[ebp]
  0059b	89 9d d4 fe ff
	ff		 mov	 DWORD PTR _iPortOncmd$[ebp], ebx
  005a1	ff d7		 call	 edi
  005a3	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR _szOptionsOnCmd$[ebp]
  005a9	ff d7		 call	 edi
  005ab	8d 8d 84 fe ff
	ff		 lea	 ecx, DWORD PTR _szIPOnCmd$[ebp]
  005b1	ff d7		 call	 edi

; 389  : #endif
; 390  : 	if(!pApp->ParseCmd(lpCmdLine, szKeyOnCmd ,szOptionsOnCmd ,szIPOnCmd ,iPortOncmd))

  005b3	8b bd e4 fe ff
	ff		 mov	 edi, DWORD PTR $T520468[ebp]
  005b9	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _iPortOncmd$[ebp]
  005bf	50		 push	 eax
  005c0	8d 85 84 fe ff
	ff		 lea	 eax, DWORD PTR _szIPOnCmd$[ebp]
  005c6	50		 push	 eax
  005c7	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _szOptionsOnCmd$[ebp]
  005cd	50		 push	 eax
  005ce	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR _szKeyOnCmd$[ebp]
  005d4	50		 push	 eax
  005d5	ff b5 d8 fe ff
	ff		 push	 DWORD PTR _lpCmdLine$GSCopy$[ebp]
  005db	8b cf		 mov	 ecx, edi
  005dd	e8 00 00 00 00	 call	 ?ParseCmd@ioApplication@@QAE_NPBDAAVioHashString@@11AAH@Z ; ioApplication::ParseCmd
  005e2	84 c0		 test	 al, al
  005e4	0f 85 99 00 00
	00		 jne	 $LN32@WinMain

; 391  : 	{
; 392  : 		SendMsgToAutoUpgrade( WM_MY_MSG_C_ERROR );

  005ea	68 2f 05 00 00	 push	 1327			; 0000052fH
  005ef	e8 00 00 00 00	 call	 ?SendMsgToAutoUpgrade@@YAXK@Z ; SendMsgToAutoUpgrade
  005f4	59		 pop	 ecx

; 393  : 		if(hMutex != NULL)

  005f5	39 9d f4 fe ff
	ff		 cmp	 DWORD PTR _hMutex$[ebp], ebx
  005fb	74 0c		 je	 SHORT $LN31@WinMain

; 394  : 			CloseHandle(hMutex);

  005fd	ff b5 f4 fe ff
	ff		 push	 DWORD PTR _hMutex$[ebp]
  00603	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN31@WinMain:

; 395  : 		SAFEDELETE( pApp );

  00609	8b 07		 mov	 eax, DWORD PTR [edi]
  0060b	33 f6		 xor	 esi, esi
  0060d	46		 inc	 esi
  0060e	56		 push	 esi
  0060f	8b cf		 mov	 ecx, edi
  00611	ff 10		 call	 DWORD PTR [eax]

; 396  : 		SAFEDELETE( pLocalMgr );

  00613	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR $T520410[ebp]
  00619	3b cb		 cmp	 ecx, ebx
  0061b	74 05		 je	 SHORT $LN105@WinMain
  0061d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0061f	56		 push	 esi
  00620	ff 10		 call	 DWORD PTR [eax]
$LN105@WinMain:

; 397  : 		SAFEDELETE( pStringMgr );

  00622	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR $T520414[ebp]
  00628	3b cb		 cmp	 ecx, ebx
  0062a	74 05		 je	 SHORT $LN107@WinMain
  0062c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0062e	56		 push	 esi
  0062f	ff 10		 call	 DWORD PTR [eax]
$LN107@WinMain:

; 398  : 		SAFEDELETE( pStatics );

  00631	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR $T520406[ebp]
  00637	3b cb		 cmp	 ecx, ebx
  00639	74 05		 je	 SHORT $LN109@WinMain
  0063b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0063d	56		 push	 esi
  0063e	ff 10		 call	 DWORD PTR [eax]
$LN109@WinMain:

; 399  : 
; 400  : 		MessageBox( NULL, "App Cmd Error!", "IOEnter", MB_OK );

  00640	53		 push	 ebx
  00641	68 00 00 00 00	 push	 OFFSET ??_C@_07NAJDILEH@IOEnter?$AA@
  00646	68 00 00 00 00	 push	 OFFSET ??_C@_0P@OLKIABFH@App?5Cmd?5Error?$CB?$AA@
  0064b	53		 push	 ebx
  0064c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 401  : 		return 0;

  00652	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00658	8d 8d 84 fe ff
	ff		 lea	 ecx, DWORD PTR _szIPOnCmd$[ebp]
  0065e	ff d6		 call	 esi
  00660	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR _szOptionsOnCmd$[ebp]
  00666	ff d6		 call	 esi
  00668	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR _szKeyOnCmd$[ebp]
  0066e	ff d6		 call	 esi
$LN148@WinMain:
  00670	33 c0		 xor	 eax, eax
$LN145@WinMain:
  00672	5f		 pop	 edi
$LN63@WinMain:

; 575  : 	//SAFEDELETE( pSymtable );
; 576  : 
; 577  : //	 _CrtMemDumpAllObjectsSince(0);
; 578  : 
; 579  :     return iRet;
; 580  : }

  00673	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00676	5e		 pop	 esi
  00677	33 cd		 xor	 ecx, ebp
  00679	5b		 pop	 ebx
  0067a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0067f	c9		 leave
  00680	c2 10 00	 ret	 16			; 00000010H
$LN32@WinMain:

; 402  : 	}
; 403  : 	InitOnWinMain( szOptionsOnCmd );

  00683	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _szOptionsOnCmd$[ebp]
  00689	50		 push	 eax
  0068a	e8 00 00 00 00	 call	 ?InitOnWinMain@@YAXAAVioHashString@@@Z ; InitOnWinMain

; 404  : 
; 405  : 	//메모리 검사부분
; 406  : 	LOG.PrintTimeAndLog(0, ("Memory Test") );

  0068f	c7 04 24 00 00
	00 00		 mov	 DWORD PTR [esp], OFFSET ??_C@_0M@OAAAHGKD@Memory?5Test?$AA@
  00696	53		 push	 ebx
  00697	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  0069d	ff d6		 call	 esi
  0069f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 407  : 	pApp->LogGlobalMemory();

  006a2	8b cf		 mov	 ecx, edi
  006a4	e8 00 00 00 00	 call	 ?LogGlobalMemory@ioApplication@@QAEXXZ ; ioApplication::LogGlobalMemory

; 408  : 
; 409  : 	// 메모리 최적화	
; 410  : #ifdef SHIPPING
; 411  : 		trimOtherProcessesWorkingSet();

  006a9	e8 00 00 00 00	 call	 ?trimOtherProcessesWorkingSet@@YAXXZ ; trimOtherProcessesWorkingSet

; 412  : #endif
; 413  : 
; 414  : 	LOG.PrintTimeAndLog( 0, "[Main] - Process Option Start" );

  006ae	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@MJEKFOCL@?$FLMain?$FN?5?9?5Process?5Option?5Start?$AA@
  006b3	53		 push	 ebx
  006b4	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  006ba	ff d6		 call	 esi
  006bc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 415  : 	if( !pApp->ProcessOptions( szOptionsOnCmd ) )

  006bf	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _szOptionsOnCmd$[ebp]
  006c5	50		 push	 eax
  006c6	8b cf		 mov	 ecx, edi
  006c8	e8 00 00 00 00	 call	 ?ProcessOptions@ioApplication@@QAE_NABVioHashString@@@Z ; ioApplication::ProcessOptions
  006cd	84 c0		 test	 al, al
  006cf	0f 85 9f 00 00
	00		 jne	 $LN26@WinMain

; 416  : 	{
; 417  : 		RelaseOnWinMain(pApp);

  006d5	57		 push	 edi
  006d6	e8 00 00 00 00	 call	 ?RelaseOnWinMain@@YAXPAVioApplication@@@Z ; RelaseOnWinMain

; 418  : 		SendMsgToAutoUpgrade( WM_MY_MSG_C_ERROR );

  006db	c7 04 24 2f 05
	00 00		 mov	 DWORD PTR [esp], 1327	; 0000052fH
  006e2	e8 00 00 00 00	 call	 ?SendMsgToAutoUpgrade@@YAXK@Z ; SendMsgToAutoUpgrade
  006e7	59		 pop	 ecx

; 419  : 		if(hMutex != NULL)

  006e8	39 9d f4 fe ff
	ff		 cmp	 DWORD PTR _hMutex$[ebp], ebx
  006ee	74 0c		 je	 SHORT $LN25@WinMain

; 420  : 			CloseHandle(hMutex);

  006f0	ff b5 f4 fe ff
	ff		 push	 DWORD PTR _hMutex$[ebp]
  006f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN25@WinMain:

; 421  : 		SAFEDELETE( pLocalMgr );

  006fc	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR $T520410[ebp]
  00702	3b cb		 cmp	 ecx, ebx
  00704	74 06		 je	 SHORT $LN136@WinMain
  00706	8b 01		 mov	 eax, DWORD PTR [ecx]
  00708	6a 01		 push	 1
  0070a	ff 10		 call	 DWORD PTR [eax]
$LN136@WinMain:

; 422  : 		SAFEDELETE( pStringMgr );

  0070c	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR $T520414[ebp]
  00712	3b cb		 cmp	 ecx, ebx
  00714	74 06		 je	 SHORT $LN144@WinMain
  00716	8b 01		 mov	 eax, DWORD PTR [ecx]
  00718	6a 01		 push	 1
  0071a	ff 10		 call	 DWORD PTR [eax]
$LN144@WinMain:

; 423  : 		SAFEDELETE( pStatics );

  0071c	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR $T520406[ebp]
  00722	3b cb		 cmp	 ecx, ebx
  00724	74 06		 je	 SHORT $LN115@WinMain
  00726	8b 01		 mov	 eax, DWORD PTR [ecx]
  00728	6a 01		 push	 1
  0072a	ff 10		 call	 DWORD PTR [eax]
$LN115@WinMain:

; 424  : 
; 425  : 		MessageBox( NULL, "App Option Error!", "IOEnter", MB_OK );

  0072c	53		 push	 ebx
  0072d	68 00 00 00 00	 push	 OFFSET ??_C@_07NAJDILEH@IOEnter?$AA@
  00732	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@HJHPPENM@App?5Option?5Error?$CB?$AA@
  00737	53		 push	 ebx
  00738	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 426  : 		LOG.PrintTimeAndLog( 0, "[Main] - Process Option Start Failed" );

  0073e	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@FFGCOBIA@?$FLMain?$FN?5?9?5Process?5Option?5Start?5Fa@
  00743	53		 push	 ebx
  00744	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  0074a	ff d6		 call	 esi
  0074c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN130@WinMain:

; 427  : 		return 0;

  0074f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00755	8d 8d 84 fe ff
	ff		 lea	 ecx, DWORD PTR _szIPOnCmd$[ebp]
  0075b	ff d6		 call	 esi
  0075d	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR _szOptionsOnCmd$[ebp]
  00763	ff d6		 call	 esi
  00765	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR _szKeyOnCmd$[ebp]
  0076b	ff d6		 call	 esi
  0076d	8b c3		 mov	 eax, ebx
  0076f	e9 fe fe ff ff	 jmp	 $LN145@WinMain
$LN26@WinMain:

; 428  : 	}
; 429  : 	LOG.PrintTimeAndLog( 0, "[Main] - Process Option Start Complete" );

  00774	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@MNBGPEDD@?$FLMain?$FN?5?9?5Process?5Option?5Start?5Co@
  00779	53		 push	 ebx
  0077a	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  00780	ff d6		 call	 esi

; 430  : #endif
; 431  : 
; 432  : 	// For Sticky Keys Disable
; 433  : 	// 초기값 백업
; 434  : 	SystemParametersInfo(SPI_GETSTICKYKEYS, sizeof(STICKYKEYS), &g_StartupStickyKeys, 0);

  00782	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SystemParametersInfoA@16
  00788	83 c4 0c	 add	 esp, 12			; 0000000cH
  0078b	53		 push	 ebx
  0078c	68 00 00 00 00	 push	 OFFSET ?g_StartupStickyKeys@@3UtagSTICKYKEYS@@A ; g_StartupStickyKeys
  00791	6a 08		 push	 8
  00793	6a 3a		 push	 58			; 0000003aH
  00795	ff d7		 call	 edi

; 435  : 	SystemParametersInfo(SPI_GETFILTERKEYS, sizeof(FILTERKEYS), &g_StartupFilterKeys, 0);

  00797	53		 push	 ebx
  00798	68 00 00 00 00	 push	 OFFSET ?g_StartupFilterKeys@@3UtagFILTERKEYS@@A ; g_StartupFilterKeys
  0079d	6a 18		 push	 24			; 00000018H
  0079f	6a 32		 push	 50			; 00000032H
  007a1	ff d7		 call	 edi

; 436  : 
; 437  : 	// 설정변경
; 438  : 	AllowAccessibilityShortcutKeys( false );

  007a3	53		 push	 ebx
  007a4	e8 00 00 00 00	 call	 ?AllowAccessibilityShortcutKeys@@YAX_N@Z ; AllowAccessibilityShortcutKeys

; 439  : 	
; 440  : 	int iRet = -1;
; 441  : 	//윈도우가 생성 됬을 경우에만 다음 로직을 수행하도록 변경
; 442  : 	if( pApp->InitWindow( hInstance, szKeyOnCmd ) )

  007a9	8b bd e4 fe ff
	ff		 mov	 edi, DWORD PTR $T520468[ebp]
  007af	83 8d dc fe ff
	ff ff		 or	 DWORD PTR _iRet$[ebp], -1
  007b6	59		 pop	 ecx
  007b7	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR _szKeyOnCmd$[ebp]
  007bd	50		 push	 eax
  007be	ff b5 e0 fe ff
	ff		 push	 DWORD PTR _hInstance$GSCopy$[ebp]
  007c4	8b cf		 mov	 ecx, edi
  007c6	e8 00 00 00 00	 call	 ?InitWindow@ioApplication@@QAE_NPAUHINSTANCE__@@ABVioHashString@@@Z ; ioApplication::InitWindow
  007cb	84 c0		 test	 al, al
  007cd	0f 84 ea 00 00
	00		 je	 $LN21@WinMain

; 443  : 	{
; 444  : 		LOG.PrintTimeAndLog( 0, "[Main] - InitWindow Complete" );

  007d3	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@EFAHBBDE@?$FLMain?$FN?5?9?5InitWindow?5Complete?$AA@
  007d8	53		 push	 ebx
  007d9	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  007df	ff d6		 call	 esi
  007e1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 445  : 
; 446  : 		//소켓 생성과 초기화에 성공한 경우에만 실행 하도록 변경
; 447  : 		if( pApp->SetupBeforeLogin( szIPOnCmd, iPortOncmd ) )

  007e4	ff b5 d4 fe ff
	ff		 push	 DWORD PTR _iPortOncmd$[ebp]
  007ea	8d 85 84 fe ff
	ff		 lea	 eax, DWORD PTR _szIPOnCmd$[ebp]
  007f0	50		 push	 eax
  007f1	8b cf		 mov	 ecx, edi
  007f3	e8 00 00 00 00	 call	 ?SetupBeforeLogin@ioApplication@@QAE_NABVioHashString@@H@Z ; ioApplication::SetupBeforeLogin
  007f8	84 c0		 test	 al, al
  007fa	0f 84 9f 00 00
	00		 je	 $LN20@WinMain

; 448  : 		{
; 449  : 			LOG.PrintTimeAndLog( 0, "[Main] - Setup Before Login Complete" );

  00800	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@IEMNCGND@?$FLMain?$FN?5?9?5Setup?5Before?5Login?5Comp@
  00805	53		 push	 ebx
  00806	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  0080c	ff d6		 call	 esi
  0080e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 450  : 
; 451  : 			if( pApp->LoginLoop( szKeyOnCmd ) )

  00811	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR _szKeyOnCmd$[ebp]
  00817	50		 push	 eax
  00818	8b cf		 mov	 ecx, edi
  0081a	e8 00 00 00 00	 call	 ?LoginLoop@ioApplication@@QAE_NABVioHashString@@@Z ; ioApplication::LoginLoop
  0081f	84 c0		 test	 al, al
  00821	74 5e		 je	 SHORT $LN19@WinMain

; 452  : 			{
; 453  : #ifndef _DEBUG
; 454  : 				if( Help::CheckEnableTimeGapUser(1) || g_App.IsMeDeveloper() )

  00823	6a 01		 push	 1
  00825	e8 00 00 00 00	 call	 ?CheckEnableTimeGapUser@Help@@YA_NH@Z ; Help::CheckEnableTimeGapUser
  0082a	59		 pop	 ecx
  0082b	84 c0		 test	 al, al
  0082d	75 10		 jne	 SHORT $LN17@WinMain
  0082f	e8 00 00 00 00	 call	 ?GetSingleton@ioApplication@@SAAAV1@XZ ; ioApplication::GetSingleton
  00834	8b c8		 mov	 ecx, eax
  00836	e8 00 00 00 00	 call	 ?IsMeDeveloper@ioApplication@@QAE_NXZ ; ioApplication::IsMeDeveloper
  0083b	84 c0		 test	 al, al
  0083d	74 22		 je	 SHORT $LN18@WinMain
$LN17@WinMain:

; 455  : 				{
; 456  : 					ioINIMemoryStatic::GetSingleton().SetSwitch( SATICS_ON );

  0083f	6a 01		 push	 1
  00841	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioINIMemoryStatic@@SAAAV1@XZ
  00847	8b c8		 mov	 ecx, eax
  00849	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetSwitch@ioINIMemoryStatic@@QAEXH@Z

; 457  : 					g_MemoryLOG.OpenLog( 0, "info/pp_mem.log");

  0084f	53		 push	 ebx
  00850	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@IKLGNONL@info?1pp_mem?4log?$AA@
  00855	53		 push	 ebx
  00856	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MemoryLOG@@3VCLog@@A ; g_MemoryLOG
  0085b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?OpenLog@CLog@@QAEXHPBD_N@Z
$LN18@WinMain:

; 458  : 				}
; 459  : #else			
; 460  : 				ioINIMemoryStatic::GetSingleton().SetSwitch( SATICS_ON );
; 461  : 				g_MemoryLOG.OpenLog( 0, "info/pp_mem.log");
; 462  : #endif
; 463  : 				LOG.PrintTimeAndLog( 0, "[Main] - Run Call" );

  00861	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@HOHJBABM@?$FLMain?$FN?5?9?5Run?5Call?$AA@
  00866	53		 push	 ebx
  00867	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  0086d	ff d6		 call	 esi
  0086f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 464  : 				iRet = pApp->Run();

  00872	8b cf		 mov	 ecx, edi
  00874	e8 00 00 00 00	 call	 ?Run@ioApplication@@QAEHXZ ; ioApplication::Run
  00879	89 85 dc fe ff
	ff		 mov	 DWORD PTR _iRet$[ebp], eax

; 465  : 			}
; 466  : 			else

  0087f	eb 5f		 jmp	 SHORT $LN14@WinMain
$LN19@WinMain:

; 467  : 			{
; 468  : #ifdef SRC_TW
; 469  : 				char szError[MAX_PATH] = "";
; 470  : 				ioLocalParent *pLocal = g_LocalMgr.GetLocal( ioLocalManager::GetLocalType() );
; 471  : 				ioStringManager *pStringMgr = new ioStringManager;
; 472  : 				if( pStringMgr && pLocal )
; 473  : 				{
; 474  : #ifdef SRC_OVERSEAS
; 475  : 					DWORD size = 0;
; 476  : 					const char * buffer = NULL;
; 477  : 					Help::LoadTextInResource(IDR_ERROR, size, buffer);
; 478  : 					pStringMgr->LoadData( "", "", buffer, true );
; 479  : #else	
; 480  : 					pStringMgr->LoadData( "", "", pLocal->GetMemTextList(), true );
; 481  : #endif
; 482  : 				}
; 483  : 				switch ( pApp->GetLoginResult() )
; 484  : 				{
; 485  : 				case CONNECT_BLOCK_ID:
; 486  : 					SafeSprintf( szError, sizeof(szError), STR(6) );
; 487  : 					break;
; 488  : 				case CONNECT_ID_NOT:
; 489  : 					SafeSprintf( szError, sizeof(szError), STR(7) );
; 490  : 					break;
; 491  : 				case CONNECT_PW_NOT:
; 492  : 					SafeSprintf( szError, sizeof(szError), STR(8) );
; 493  : 					break;
; 494  : 				case CONNECT_ID_ALREADY:
; 495  : 					SafeSprintf( szError, sizeof(szError), STR(9) );
; 496  : 					break;
; 497  : 				case CONNECT_EXCEPT:
; 498  : 					SafeSprintf( szError, sizeof(szError), STR(10) );
; 499  : 					break;
; 500  : 				case CONNECT_EXPIRE_KEY:
; 501  : 					SafeSprintf( szError, sizeof(szError), STR(11) );
; 502  : 					break;
; 503  : 				case CONNECT_EXITING_SERVER:
; 504  : 					SafeSprintf( szError, sizeof(szError), STR(12) );
; 505  : 					break;
; 506  : 				case CONNECT_WRONG_CLIENT_VER:
; 507  : 					SafeSprintf( szError, sizeof(szError), STR(13) );
; 508  : 					break;
; 509  : 				case CONNECT_WRONG_LOCAL_VER:
; 510  : 					SafeSprintf( szError, sizeof(szError), STR(14) );
; 511  : 					break;
; 512  : 				default:
; 513  : 					break;
; 514  : 				}
; 515  : 
; 516  : 				LOG.PrintTimeAndLog(0, "Login Error" ); //park 여기서 찍자~
; 517  : 				if( 0 < pApp->GetLoginResult() && pApp->GetLoginResult() <= CONNECT_BLOCK_ID)
; 518  : 					Help::MessageboxShow( NULL, szError, "IOEnter", MB_OK );
; 519  : #else
; 520  : 				LOG.PrintTimeAndLog(0, "App LoginLoop Error" );

  00881	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@FOPFPEAB@App?5LoginLoop?5Error?$AA@
  00886	53		 push	 ebx
  00887	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  0088d	ff d6		 call	 esi
  0088f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 521  : 				MessageBox( NULL, "App LoginLoop Error!", "IOEnter", MB_OK );

  00892	53		 push	 ebx
  00893	68 00 00 00 00	 push	 OFFSET ??_C@_07NAJDILEH@IOEnter?$AA@
  00898	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PLMGNAIB@App?5LoginLoop?5Error?$CB?$AA@

; 522  : #endif
; 523  : 			}
; 524  : 		}
; 525  : 		else

  0089d	eb 3a		 jmp	 SHORT $LN147@WinMain
$LN20@WinMain:

; 526  : 		{
; 527  : 			LOG.PrintTimeAndLog(0, "[Main] - App SetupBeforeLogin Error" );

  0089f	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@IABOHEFL@?$FLMain?$FN?5?9?5App?5SetupBeforeLogin?5Er@
  008a4	53		 push	 ebx
  008a5	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  008ab	ff d6		 call	 esi
  008ad	83 c4 0c	 add	 esp, 12			; 0000000cH

; 528  : 			MessageBox( NULL, "App SetupBeforeLogin Error!", "IOEnter", MB_OK );

  008b0	53		 push	 ebx
  008b1	68 00 00 00 00	 push	 OFFSET ??_C@_07NAJDILEH@IOEnter?$AA@
  008b6	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@JCAGJNJC@App?5SetupBeforeLogin?5Error?$CB?$AA@

; 529  : 		}
; 530  : 	}
; 531  : 	else

  008bb	eb 1c		 jmp	 SHORT $LN147@WinMain
$LN21@WinMain:

; 532  : 	{
; 533  : 		LOG.PrintTimeAndLog(0, "[Main] - App InitWindow Error" );

  008bd	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@GBFBNNHH@?$FLMain?$FN?5?9?5App?5InitWindow?5Error?$AA@
  008c2	53		 push	 ebx
  008c3	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  008c9	ff d6		 call	 esi
  008cb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 534  : 		MessageBox( NULL, "App InitWindow Error!", "IOEnter", MB_OK );

  008ce	53		 push	 ebx
  008cf	68 00 00 00 00	 push	 OFFSET ??_C@_07NAJDILEH@IOEnter?$AA@
  008d4	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@JPJMNGLB@App?5InitWindow?5Error?$CB?$AA@
$LN147@WinMain:
  008d9	53		 push	 ebx
  008da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
$LN14@WinMain:

; 535  : 	}
; 536  : 	
; 537  : 	// 정상종료 : DestroyWindow->ReleaseAll->PostQuitMessage
; 538  : 	if( iRet == -1 )

  008e0	83 bd dc fe ff
	ff ff		 cmp	 DWORD PTR _iRet$[ebp], -1
  008e7	75 61		 jne	 SHORT $LN137@WinMain

; 539  : 	{
; 540  : 		DestroyWindow( pApp->GetHWnd() );

  008e9	ff 77 08	 push	 DWORD PTR [edi+8]
  008ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4

; 541  : 
; 542  : 		MSG msg;
; 543  : 		for ( int i = 0; i < 10000; i++ ) // 10초간 확인

  008f2	33 f6		 xor	 esi, esi
$LL12@WinMain:

; 544  : 		{
; 545  : 			if( PeekMessage( &msg, NULL, 0, 0, PM_NOREMOVE ) )

  008f4	53		 push	 ebx
  008f5	53		 push	 ebx
  008f6	53		 push	 ebx
  008f7	53		 push	 ebx
  008f8	8d 85 94 fe ff
	ff		 lea	 eax, DWORD PTR _msg$519487[ebp]
  008fe	50		 push	 eax
  008ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PeekMessageA@20

; 546  : 			{
; 547  : 				if( !GetMessage( &msg, NULL, 0, 0 ) )

  00905	53		 push	 ebx
  00906	85 c0		 test	 eax, eax
  00908	74 2f		 je	 SHORT $LN9@WinMain
  0090a	53		 push	 ebx
  0090b	53		 push	 ebx
  0090c	8d 85 94 fe ff
	ff		 lea	 eax, DWORD PTR _msg$519487[ebp]
  00912	50		 push	 eax
  00913	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetMessageA@16
  00919	85 c0		 test	 eax, eax
  0091b	74 2d		 je	 SHORT $LN137@WinMain

; 548  : 					break;
; 549  : 
; 550  : 				TranslateMessage( &msg );

  0091d	8d 85 94 fe ff
	ff		 lea	 eax, DWORD PTR _msg$519487[ebp]
  00923	50		 push	 eax
  00924	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TranslateMessage@4

; 551  : 				DispatchMessage( &msg );

  0092a	8d 85 94 fe ff
	ff		 lea	 eax, DWORD PTR _msg$519487[ebp]
  00930	50		 push	 eax
  00931	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DispatchMessageA@4

; 552  : 				continue;

  00937	eb 08		 jmp	 SHORT $LN11@WinMain
$LN9@WinMain:

; 553  : 			}
; 554  : 			::SleepEx(1, FALSE);

  00939	6a 01		 push	 1
  0093b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SleepEx@8
$LN11@WinMain:

; 541  : 
; 542  : 		MSG msg;
; 543  : 		for ( int i = 0; i < 10000; i++ ) // 10초간 확인

  00941	46		 inc	 esi
  00942	81 fe 10 27 00
	00		 cmp	 esi, 10000		; 00002710H
  00948	7c aa		 jl	 SHORT $LL12@WinMain
$LN137@WinMain:

; 555  : 		}
; 556  : 	}
; 557  : 
; 558  : 	RelaseOnWinMain(pApp);

  0094a	57		 push	 edi
  0094b	e8 00 00 00 00	 call	 ?RelaseOnWinMain@@YAXPAVioApplication@@@Z ; RelaseOnWinMain

; 559  : 
; 560  : 	// For Sticky Keys Disable, 설정복구
; 561  : 	AllowAccessibilityShortcutKeys( true );

  00950	33 f6		 xor	 esi, esi
  00952	46		 inc	 esi
  00953	56		 push	 esi
  00954	e8 00 00 00 00	 call	 ?AllowAccessibilityShortcutKeys@@YAX_N@Z ; AllowAccessibilityShortcutKeys
  00959	59		 pop	 ecx
  0095a	59		 pop	 ecx

; 562  : 
; 563  : 	if( g_bHappenCrash || g_bHappenError )

  0095b	38 1d 00 00 00
	00		 cmp	 BYTE PTR ?g_bHappenCrash@@3_NA, bl ; g_bHappenCrash
  00961	75 08		 jne	 SHORT $LN6@WinMain
  00963	38 1d 00 00 00
	00		 cmp	 BYTE PTR ?g_bHappenError@@3_NA, bl ; g_bHappenError
  00969	74 14		 je	 SHORT $LN5@WinMain
$LN6@WinMain:

; 564  : 	{
; 565  : 		if( hInstance )

  0096b	39 9d e0 fe ff
	ff		 cmp	 DWORD PTR _hInstance$GSCopy$[ebp], ebx
  00971	74 0c		 je	 SHORT $LN5@WinMain

; 566  : 			ShowOtherErrorDlg(hInstance);

  00973	ff b5 e0 fe ff
	ff		 push	 DWORD PTR _hInstance$GSCopy$[ebp]
  00979	e8 00 00 00 00	 call	 ?ShowOtherErrorDlg@@YAXPAUHINSTANCE__@@@Z ; ShowOtherErrorDlg
  0097e	59		 pop	 ecx
$LN5@WinMain:

; 567  : 	}
; 568  : 
; 569  : 	if(hMutex != NULL)

  0097f	39 9d f4 fe ff
	ff		 cmp	 DWORD PTR _hMutex$[ebp], ebx
  00985	74 0c		 je	 SHORT $LN4@WinMain

; 570  : 		CloseHandle(hMutex);

  00987	ff b5 f4 fe ff
	ff		 push	 DWORD PTR _hMutex$[ebp]
  0098d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN4@WinMain:

; 571  : 
; 572  : 	SAFEDELETE( pLocalMgr );

  00993	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR $T520410[ebp]
  00999	3b cb		 cmp	 ecx, ebx
  0099b	74 05		 je	 SHORT $LN117@WinMain
  0099d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0099f	56		 push	 esi
  009a0	ff 10		 call	 DWORD PTR [eax]
$LN117@WinMain:

; 573  : 	SAFEDELETE( pStringMgr );

  009a2	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR $T520414[ebp]
  009a8	3b cb		 cmp	 ecx, ebx
  009aa	74 05		 je	 SHORT $LN119@WinMain
  009ac	8b 01		 mov	 eax, DWORD PTR [ecx]
  009ae	56		 push	 esi
  009af	ff 10		 call	 DWORD PTR [eax]
$LN119@WinMain:

; 574  : 	SAFEDELETE( pStatics );

  009b1	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR $T520406[ebp]
  009b7	3b cb		 cmp	 ecx, ebx
  009b9	74 05		 je	 SHORT $LN121@WinMain
  009bb	8b 01		 mov	 eax, DWORD PTR [ecx]
  009bd	56		 push	 esi
  009be	ff 10		 call	 DWORD PTR [eax]
$LN121@WinMain:
  009c0	8b 9d dc fe ff
	ff		 mov	 ebx, DWORD PTR _iRet$[ebp]
  009c6	e9 84 fd ff ff	 jmp	 $LN130@WinMain
_WinMain@16 ENDP
_TEXT	ENDS
EXTRN	__imp_??1ioINIMemoryStatic@@UAE@XZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ??_GioINIMemoryStatic@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GioINIMemoryStatic@@UAEPAXI@Z PROC			; ioINIMemoryStatic::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioINIMemoryStatic@@UAE@XZ
  0000c	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00010	74 07		 je	 SHORT $LN1@scalar
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	59		 pop	 ecx
$LN1@scalar:
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??_GioINIMemoryStatic@@UAEPAXI@Z ENDP			; ioINIMemoryStatic::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??1ioStringManager@@UAE@XZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ??_GioStringManager@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GioStringManager@@UAEPAXI@Z PROC			; ioStringManager::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioStringManager@@UAE@XZ
  0000c	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00010	74 07		 je	 SHORT $LN1@scalar@2
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	59		 pop	 ecx
$LN1@scalar@2:
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??_GioStringManager@@UAEPAXI@Z ENDP			; ioStringManager::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	_atexit:PROC
EXTRN	__imp_??0CLog@@QAE@XZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ??__Eg_MemoryLOG@@YAXXZ
text$yc	SEGMENT
??__Eg_MemoryLOG@@YAXXZ PROC				; `dynamic initializer for 'g_MemoryLOG'', COMDAT

; 45   : CLog g_MemoryLOG;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MemoryLOG@@3VCLog@@A ; g_MemoryLOG
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CLog@@QAE@XZ
  0000b	68 00 00 00 00	 push	 OFFSET ??__Fg_MemoryLOG@@YAXXZ ; `dynamic atexit destructor for 'g_MemoryLOG''
  00010	e8 00 00 00 00	 call	 _atexit
  00015	59		 pop	 ecx
  00016	c3		 ret	 0
??__Eg_MemoryLOG@@YAXXZ ENDP				; `dynamic initializer for 'g_MemoryLOG''
text$yc	ENDS
EXTRN	__imp_??1CLog@@UAE@XZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ??__Fg_MemoryLOG@@YAXXZ
text$yd	SEGMENT
??__Fg_MemoryLOG@@YAXXZ PROC				; `dynamic atexit destructor for 'g_MemoryLOG'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MemoryLOG@@3VCLog@@A ; g_MemoryLOG
  00005	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1CLog@@UAE@XZ
??__Fg_MemoryLOG@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_MemoryLOG''
text$yd	ENDS
PUBLIC	?g_MemoryLOG@@3VCLog@@A				; g_MemoryLOG
_BSS	SEGMENT
	ALIGN	4

?g_MemoryLOG@@3VCLog@@A DB 0914H DUP (?)		; g_MemoryLOG
_BSS	ENDS
CRT$XCU	SEGMENT
_g_MemoryLOG$initializer$ DD FLAT:??__Eg_MemoryLOG@@YAXXZ
CRT$XCU	ENDS
END
