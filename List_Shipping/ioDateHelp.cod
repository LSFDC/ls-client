; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\Lost Saga For Developer\Youtube\Tutorial\Source\src\LSClient\ioDateHelp.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?GetDateYear@DateHelp@@YAHK@Z			; DateHelp::GetDateYear
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iodatehelp.cpp
;	COMDAT ?GetDateYear@DateHelp@@YAHK@Z
_TEXT	SEGMENT
_dwDate$ = 8						; size = 4
?GetDateYear@DateHelp@@YAHK@Z PROC			; DateHelp::GetDateYear, COMDAT

; 97   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 98   : 		return 2000 + ( dwDate / 100000000 );

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwDate$[ebp]
  00006	33 d2		 xor	 edx, edx
  00008	b9 00 e1 f5 05	 mov	 ecx, 100000000		; 05f5e100H
  0000d	f7 f1		 div	 ecx
  0000f	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H

; 99   : 	}

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?GetDateYear@DateHelp@@YAHK@Z ENDP			; DateHelp::GetDateYear
_TEXT	ENDS
PUBLIC	?GetDateMonth@DateHelp@@YAHK@Z			; DateHelp::GetDateMonth
; Function compile flags: /Ogsp
;	COMDAT ?GetDateMonth@DateHelp@@YAHK@Z
_TEXT	SEGMENT
_dwDate$ = 8						; size = 4
?GetDateMonth@DateHelp@@YAHK@Z PROC			; DateHelp::GetDateMonth, COMDAT

; 102  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 103  : 		return ( dwDate % 100000000 ) / 1000000;

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwDate$[ebp]
  00006	33 d2		 xor	 edx, edx
  00008	b9 00 e1 f5 05	 mov	 ecx, 100000000		; 05f5e100H
  0000d	f7 f1		 div	 ecx
  0000f	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00014	8b c2		 mov	 eax, edx
  00016	33 d2		 xor	 edx, edx
  00018	f7 f1		 div	 ecx

; 104  : 	}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?GetDateMonth@DateHelp@@YAHK@Z ENDP			; DateHelp::GetDateMonth
_TEXT	ENDS
PUBLIC	?GetDateDay@DateHelp@@YAHK@Z			; DateHelp::GetDateDay
; Function compile flags: /Ogsp
;	COMDAT ?GetDateDay@DateHelp@@YAHK@Z
_TEXT	SEGMENT
_dwDate$ = 8						; size = 4
?GetDateDay@DateHelp@@YAHK@Z PROC			; DateHelp::GetDateDay, COMDAT

; 107  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 108  : 		return ( dwDate % 1000000 ) / 10000;

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwDate$[ebp]
  00006	33 d2		 xor	 edx, edx
  00008	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  0000d	f7 f1		 div	 ecx
  0000f	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00014	8b c2		 mov	 eax, edx
  00016	33 d2		 xor	 edx, edx
  00018	f7 f1		 div	 ecx

; 109  : 	}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?GetDateDay@DateHelp@@YAHK@Z ENDP			; DateHelp::GetDateDay
_TEXT	ENDS
PUBLIC	?GetDateHour@DateHelp@@YAHK@Z			; DateHelp::GetDateHour
; Function compile flags: /Ogsp
;	COMDAT ?GetDateHour@DateHelp@@YAHK@Z
_TEXT	SEGMENT
_dwDate$ = 8						; size = 4
?GetDateHour@DateHelp@@YAHK@Z PROC			; DateHelp::GetDateHour, COMDAT

; 112  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 113  : 		return ( dwDate % 10000 ) / 100;

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwDate$[ebp]
  00006	33 d2		 xor	 edx, edx
  00008	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  0000d	f7 f1		 div	 ecx
  0000f	6a 64		 push	 100			; 00000064H
  00011	59		 pop	 ecx
  00012	8b c2		 mov	 eax, edx
  00014	33 d2		 xor	 edx, edx
  00016	f7 f1		 div	 ecx

; 114  : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?GetDateHour@DateHelp@@YAHK@Z ENDP			; DateHelp::GetDateHour
_TEXT	ENDS
PUBLIC	?GetDateMinute@DateHelp@@YAHK@Z			; DateHelp::GetDateMinute
; Function compile flags: /Ogsp
;	COMDAT ?GetDateMinute@DateHelp@@YAHK@Z
_TEXT	SEGMENT
_dwDate$ = 8						; size = 4
?GetDateMinute@DateHelp@@YAHK@Z PROC			; DateHelp::GetDateMinute, COMDAT

; 117  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 118  : 		return ( dwDate % 100 );

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwDate$[ebp]
  00006	6a 64		 push	 100			; 00000064H
  00008	33 d2		 xor	 edx, edx
  0000a	59		 pop	 ecx
  0000b	f7 f1		 div	 ecx
  0000d	8b c2		 mov	 eax, edx

; 119  : 	}

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetDateMinute@DateHelp@@YAHK@Z ENDP			; DateHelp::GetDateMinute
_TEXT	ENDS
PUBLIC	?ConvertDwDate@DateHelp@@YAKHHHHH@Z		; DateHelp::ConvertDwDate
; Function compile flags: /Ogsp
;	COMDAT ?ConvertDwDate@DateHelp@@YAKHHHHH@Z
_TEXT	SEGMENT
_iYear$ = 8						; size = 4
_iMonth$ = 12						; size = 4
_iDay$ = 16						; size = 4
_iHour$ = 20						; size = 4
_iMin$ = 24						; size = 4
?ConvertDwDate@DateHelp@@YAKHHHHH@Z PROC		; DateHelp::ConvertDwDate, COMDAT

; 122  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 123  : 		DWORD dwDate = 0;
; 124  : 
; 125  : 		dwDate += ( iYear - 2000 ) * 100000000;

  00003	8b 45 08	 mov	 eax, DWORD PTR _iYear$[ebp]
  00006	05 30 f8 ff ff	 add	 eax, -2000		; fffff830H

; 126  : 		dwDate += iMonth * 1000000;
; 127  : 		dwDate += iDay * 10000;
; 128  : 		dwDate += iHour * 100;
; 129  : 		dwDate += iMin;
; 130  : 
; 131  : 		return dwDate;

  0000b	6b c0 64	 imul	 eax, 100		; 00000064H
  0000e	03 45 0c	 add	 eax, DWORD PTR _iMonth$[ebp]
  00011	6b c0 64	 imul	 eax, 100		; 00000064H
  00014	03 45 10	 add	 eax, DWORD PTR _iDay$[ebp]
  00017	6b c0 64	 imul	 eax, 100		; 00000064H
  0001a	03 45 14	 add	 eax, DWORD PTR _iHour$[ebp]
  0001d	6b c0 64	 imul	 eax, 100		; 00000064H
  00020	03 45 18	 add	 eax, DWORD PTR _iMin$[ebp]

; 132  : 	}

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?ConvertDwDate@DateHelp@@YAKHHHHH@Z ENDP		; DateHelp::ConvertDwDate
_TEXT	ENDS
PUBLIC	?isLeapYear@DateHelp@@YA_NH@Z			; DateHelp::isLeapYear
; Function compile flags: /Ogsp
;	COMDAT ?isLeapYear@DateHelp@@YA_NH@Z
_TEXT	SEGMENT
_iYear$ = 8						; size = 4
?isLeapYear@DateHelp@@YA_NH@Z PROC			; DateHelp::isLeapYear, COMDAT

; 140  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 141  : 		if( ( iYear - 2000 ) % 4  == 0 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iYear$[ebp]
  00006	05 30 f8 ff ff	 add	 eax, -2000		; fffff830H
  0000b	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00010	79 05		 jns	 SHORT $LN4@isLeapYear
  00012	48		 dec	 eax
  00013	83 c8 fc	 or	 eax, -4			; fffffffcH
  00016	40		 inc	 eax
$LN4@isLeapYear:
  00017	f7 d8		 neg	 eax
  00019	1a c0		 sbb	 al, al
  0001b	fe c0		 inc	 al

; 142  : 			return true;
; 143  : 
; 144  : 		return false;
; 145  : 	}

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?isLeapYear@DateHelp@@YA_NH@Z ENDP			; DateHelp::isLeapYear
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?isOddMonth@DateHelp@@YA_NH@Z			; DateHelp::isOddMonth
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogsp
;	COMDAT ?isOddMonth@DateHelp@@YA_NH@Z
_TEXT	SEGMENT
_nm$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_iMonth$ = 8						; size = 4
?isOddMonth@DateHelp@@YA_NH@Z PROC			; DateHelp::isOddMonth, COMDAT

; 148  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 149  : 		int nm[12]={ 31,28,31,30,31,30,31,31,30,31,30,31 };

  00010	6a 1f		 push	 31			; 0000001fH
  00012	58		 pop	 eax
  00013	6a 1e		 push	 30			; 0000001eH
  00015	59		 pop	 ecx
  00016	89 4d d8	 mov	 DWORD PTR _nm$[ebp+12], ecx
  00019	89 4d e0	 mov	 DWORD PTR _nm$[ebp+20], ecx
  0001c	89 4d ec	 mov	 DWORD PTR _nm$[ebp+32], ecx
  0001f	89 4d f4	 mov	 DWORD PTR _nm$[ebp+40], ecx

; 150  : 
; 151  : 		if( nm[iMonth-1] == 31 )

  00022	8b 4d 08	 mov	 ecx, DWORD PTR _iMonth$[ebp]
  00025	89 45 cc	 mov	 DWORD PTR _nm$[ebp], eax
  00028	89 45 d4	 mov	 DWORD PTR _nm$[ebp+8], eax
  0002b	89 45 dc	 mov	 DWORD PTR _nm$[ebp+16], eax
  0002e	89 45 e4	 mov	 DWORD PTR _nm$[ebp+24], eax
  00031	89 45 e8	 mov	 DWORD PTR _nm$[ebp+28], eax
  00034	89 45 f0	 mov	 DWORD PTR _nm$[ebp+36], eax
  00037	89 45 f8	 mov	 DWORD PTR _nm$[ebp+44], eax
  0003a	c7 45 d0 1c 00
	00 00		 mov	 DWORD PTR _nm$[ebp+4], 28 ; 0000001cH
  00041	39 44 8d c8	 cmp	 DWORD PTR _nm$[ebp+ecx*4-4], eax

; 152  : 			return true;
; 153  : 		else
; 154  : 			return false;
; 155  : 	}

  00045	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00048	0f 94 c0	 sete	 al
  0004b	33 cd		 xor	 ecx, ebp
  0004d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00052	c9		 leave
  00053	c3		 ret	 0
?isOddMonth@DateHelp@@YA_NH@Z ENDP			; DateHelp::isOddMonth
_TEXT	ENDS
PUBLIC	?IncreaseMonth@DateHelp@@YAXAAH00@Z		; DateHelp::IncreaseMonth
; Function compile flags: /Ogsp
;	COMDAT ?IncreaseMonth@DateHelp@@YAXAAH00@Z
_TEXT	SEGMENT
_iYear$ = 8						; size = 4
_iMonth$ = 12						; size = 4
_iDay$ = 16						; size = 4
?IncreaseMonth@DateHelp@@YAXAAH00@Z PROC		; DateHelp::IncreaseMonth, COMDAT

; 158  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 159  : 		if( 12 == iMonth )

  00003	8b 45 0c	 mov	 eax, DWORD PTR _iMonth$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	33 d2		 xor	 edx, edx
  0000a	42		 inc	 edx
  0000b	83 f9 0c	 cmp	 ecx, 12			; 0000000cH
  0000e	75 09		 jne	 SHORT $LN2@IncreaseMo

; 160  : 		{
; 161  : 			iMonth = 1;

  00010	89 10		 mov	 DWORD PTR [eax], edx

; 162  : 			iYear++;

  00012	8b 45 08	 mov	 eax, DWORD PTR _iYear$[ebp]
  00015	ff 00		 inc	 DWORD PTR [eax]

; 163  : 		}
; 164  : 		else

  00017	eb 03		 jmp	 SHORT $LN1@IncreaseMo
$LN2@IncreaseMo:

; 165  : 		{
; 166  : 			iMonth++;

  00019	41		 inc	 ecx
  0001a	89 08		 mov	 DWORD PTR [eax], ecx
$LN1@IncreaseMo:

; 167  : 		}
; 168  : 
; 169  : 		iDay = 1;	

  0001c	8b 45 10	 mov	 eax, DWORD PTR _iDay$[ebp]
  0001f	89 10		 mov	 DWORD PTR [eax], edx

; 170  : 	}

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
?IncreaseMonth@DateHelp@@YAXAAH00@Z ENDP		; DateHelp::IncreaseMonth
_TEXT	ENDS
PUBLIC	?DecreaseMonth@DateHelp@@YAXAAH00@Z		; DateHelp::DecreaseMonth
; Function compile flags: /Ogsp
;	COMDAT ?DecreaseMonth@DateHelp@@YAXAAH00@Z
_TEXT	SEGMENT
_iYear$ = 8						; size = 4
_iMonth$ = 12						; size = 4
_iDay$ = 16						; size = 4
?DecreaseMonth@DateHelp@@YAXAAH00@Z PROC		; DateHelp::DecreaseMonth, COMDAT

; 173  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 174  : 		if( 1 == iMonth )

  00003	8b 45 0c	 mov	 eax, DWORD PTR _iMonth$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	33 d2		 xor	 edx, edx
  0000a	42		 inc	 edx
  0000b	3b ca		 cmp	 ecx, edx
  0000d	75 0d		 jne	 SHORT $LN2@DecreaseMo

; 175  : 		{
; 176  : 			iMonth = 12;

  0000f	c7 00 0c 00 00
	00		 mov	 DWORD PTR [eax], 12	; 0000000cH

; 177  : 			iYear--;

  00015	8b 45 08	 mov	 eax, DWORD PTR _iYear$[ebp]
  00018	ff 08		 dec	 DWORD PTR [eax]

; 178  : 		}
; 179  : 		else

  0001a	eb 03		 jmp	 SHORT $LN1@DecreaseMo
$LN2@DecreaseMo:

; 180  : 		{
; 181  : 			iMonth--;

  0001c	49		 dec	 ecx
  0001d	89 08		 mov	 DWORD PTR [eax], ecx
$LN1@DecreaseMo:

; 182  : 		}
; 183  : 
; 184  : 		iDay = 1;

  0001f	8b 45 10	 mov	 eax, DWORD PTR _iDay$[ebp]
  00022	89 10		 mov	 DWORD PTR [eax], edx

; 185  : 	}

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?DecreaseMonth@DateHelp@@YAXAAH00@Z ENDP		; DateHelp::DecreaseMonth
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?IncreaseDay@DateHelp@@YAXAAH00@Z		; DateHelp::IncreaseDay
; Function compile flags: /Ogsp
;	COMDAT ?IncreaseDay@DateHelp@@YAXAAH00@Z
_TEXT	SEGMENT
_nm$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_iYear$ = 8						; size = 4
_iMonth$ = 12						; size = 4
_iDay$ = 16						; size = 4
?IncreaseDay@DateHelp@@YAXAAH00@Z PROC			; DateHelp::IncreaseDay, COMDAT

; 189  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 10	 mov	 edx, DWORD PTR _iDay$[ebp]
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 0c	 mov	 esi, DWORD PTR _iMonth$[ebp]
  00018	57		 push	 edi
  00019	8b 7d 08	 mov	 edi, DWORD PTR _iYear$[ebp]

; 190  : 		int nm[12]={ 31,28,31,30,31,30,31,31,30,31,30,31 };

  0001c	6a 1f		 push	 31			; 0000001fH
  0001e	58		 pop	 eax
  0001f	6a 1e		 push	 30			; 0000001eH
  00021	59		 pop	 ecx
  00022	89 4d d8	 mov	 DWORD PTR _nm$[ebp+12], ecx
  00025	89 4d e0	 mov	 DWORD PTR _nm$[ebp+20], ecx
  00028	89 4d ec	 mov	 DWORD PTR _nm$[ebp+32], ecx
  0002b	89 4d f4	 mov	 DWORD PTR _nm$[ebp+40], ecx

; 191  : 		if( isLeapYear(iYear) )

  0002e	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00030	51		 push	 ecx
  00031	89 45 cc	 mov	 DWORD PTR _nm$[ebp], eax
  00034	c7 45 d0 1c 00
	00 00		 mov	 DWORD PTR _nm$[ebp+4], 28 ; 0000001cH
  0003b	89 45 d4	 mov	 DWORD PTR _nm$[ebp+8], eax
  0003e	89 45 dc	 mov	 DWORD PTR _nm$[ebp+16], eax
  00041	89 45 e4	 mov	 DWORD PTR _nm$[ebp+24], eax
  00044	89 45 e8	 mov	 DWORD PTR _nm$[ebp+28], eax
  00047	89 45 f0	 mov	 DWORD PTR _nm$[ebp+36], eax
  0004a	89 45 f8	 mov	 DWORD PTR _nm$[ebp+44], eax
  0004d	e8 00 00 00 00	 call	 ?isLeapYear@DateHelp@@YA_NH@Z ; DateHelp::isLeapYear
  00052	83 c4 04	 add	 esp, 4
  00055	84 c0		 test	 al, al
  00057	74 07		 je	 SHORT $LN5@IncreaseDa

; 192  : 			nm[1] = 29;

  00059	c7 45 d0 1d 00
	00 00		 mov	 DWORD PTR _nm$[ebp+4], 29 ; 0000001dH
$LN5@IncreaseDa:

; 193  : 
; 194  : 		if( iDay < nm[iMonth-1] )

  00060	8b 06		 mov	 eax, DWORD PTR [esi]
  00062	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00064	3b 5c 85 c8	 cmp	 ebx, DWORD PTR _nm$[ebp+eax*4-4]
  00068	7d 05		 jge	 SHORT $LN4@IncreaseDa

; 195  : 		{
; 196  : 			iDay++;

  0006a	43		 inc	 ebx
  0006b	89 1a		 mov	 DWORD PTR [edx], ebx

; 197  : 		}
; 198  : 		else

  0006d	eb 1a		 jmp	 SHORT $LN1@IncreaseDa
$LN4@IncreaseDa:

; 199  : 		{
; 200  : 			if( iMonth == 12 )

  0006f	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  00072	75 0c		 jne	 SHORT $LN2@IncreaseDa

; 201  : 			{
; 202  : 				iYear++;

  00074	41		 inc	 ecx

; 203  : 				iMonth = 1;

  00075	33 c0		 xor	 eax, eax
  00077	40		 inc	 eax
  00078	89 0f		 mov	 DWORD PTR [edi], ecx
  0007a	89 06		 mov	 DWORD PTR [esi], eax

; 204  : 				iDay = 1;

  0007c	89 02		 mov	 DWORD PTR [edx], eax

; 205  : 			}
; 206  : 			else

  0007e	eb 09		 jmp	 SHORT $LN1@IncreaseDa
$LN2@IncreaseDa:

; 207  : 			{
; 208  : 				iMonth++;

  00080	40		 inc	 eax
  00081	89 06		 mov	 DWORD PTR [esi], eax

; 209  : 				iDay = 1;

  00083	c7 02 01 00 00
	00		 mov	 DWORD PTR [edx], 1
$LN1@IncreaseDa:

; 210  : 			}
; 211  : 		}
; 212  : 	}

  00089	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	33 cd		 xor	 ecx, ebp
  00090	5b		 pop	 ebx
  00091	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00096	c9		 leave
  00097	c3		 ret	 0
?IncreaseDay@DateHelp@@YAXAAH00@Z ENDP			; DateHelp::IncreaseDay
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?DecreaseDay@DateHelp@@YAXAAH00@Z		; DateHelp::DecreaseDay
; Function compile flags: /Ogsp
;	COMDAT ?DecreaseDay@DateHelp@@YAXAAH00@Z
_TEXT	SEGMENT
_nm$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_iYear$ = 8						; size = 4
_iMonth$ = 12						; size = 4
_iDay$ = 16						; size = 4
?DecreaseDay@DateHelp@@YAXAAH00@Z PROC			; DateHelp::DecreaseDay, COMDAT

; 215  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 10	 mov	 edx, DWORD PTR _iDay$[ebp]
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 0c	 mov	 esi, DWORD PTR _iMonth$[ebp]
  00018	57		 push	 edi
  00019	8b 7d 08	 mov	 edi, DWORD PTR _iYear$[ebp]

; 216  : 		int nm[12]={ 31,28,31,30,31,30,31,31,30,31,30,31 };
; 217  : 		if( isLeapYear(iYear) )

  0001c	8b 1f		 mov	 ebx, DWORD PTR [edi]
  0001e	6a 1f		 push	 31			; 0000001fH
  00020	59		 pop	 ecx
  00021	6a 1e		 push	 30			; 0000001eH
  00023	58		 pop	 eax
  00024	53		 push	 ebx
  00025	89 4d cc	 mov	 DWORD PTR _nm$[ebp], ecx
  00028	c7 45 d0 1c 00
	00 00		 mov	 DWORD PTR _nm$[ebp+4], 28 ; 0000001cH
  0002f	89 4d d4	 mov	 DWORD PTR _nm$[ebp+8], ecx
  00032	89 45 d8	 mov	 DWORD PTR _nm$[ebp+12], eax
  00035	89 4d dc	 mov	 DWORD PTR _nm$[ebp+16], ecx
  00038	89 45 e0	 mov	 DWORD PTR _nm$[ebp+20], eax
  0003b	89 4d e4	 mov	 DWORD PTR _nm$[ebp+24], ecx
  0003e	89 4d e8	 mov	 DWORD PTR _nm$[ebp+28], ecx
  00041	89 45 ec	 mov	 DWORD PTR _nm$[ebp+32], eax
  00044	89 4d f0	 mov	 DWORD PTR _nm$[ebp+36], ecx
  00047	89 45 f4	 mov	 DWORD PTR _nm$[ebp+40], eax
  0004a	89 4d f8	 mov	 DWORD PTR _nm$[ebp+44], ecx
  0004d	e8 00 00 00 00	 call	 ?isLeapYear@DateHelp@@YA_NH@Z ; DateHelp::isLeapYear
  00052	83 c4 04	 add	 esp, 4
  00055	84 c0		 test	 al, al
  00057	74 07		 je	 SHORT $LN5@DecreaseDa

; 218  : 			nm[1] = 29;

  00059	c7 45 d0 1d 00
	00 00		 mov	 DWORD PTR _nm$[ebp+4], 29 ; 0000001dH
$LN5@DecreaseDa:

; 219  : 
; 220  : 		if( 1 < iDay )

  00060	8b 02		 mov	 eax, DWORD PTR [edx]
  00062	83 f8 01	 cmp	 eax, 1
  00065	7e 03		 jle	 SHORT $LN4@DecreaseDa

; 221  : 		{
; 222  : 			iDay--;

  00067	48		 dec	 eax

; 223  : 		}
; 224  : 		else

  00068	eb 1b		 jmp	 SHORT $LN8@DecreaseDa
$LN4@DecreaseDa:

; 225  : 		{
; 226  : 			if( iMonth == 1 )

  0006a	8b 06		 mov	 eax, DWORD PTR [esi]
  0006c	83 f8 01	 cmp	 eax, 1
  0006f	75 0d		 jne	 SHORT $LN2@DecreaseDa

; 227  : 			{
; 228  : 				iYear--;

  00071	4b		 dec	 ebx
  00072	89 1f		 mov	 DWORD PTR [edi], ebx

; 229  : 				iMonth = 12;

  00074	c7 06 0c 00 00
	00		 mov	 DWORD PTR [esi], 12	; 0000000cH

; 230  : 				iDay = nm[11];

  0007a	89 0a		 mov	 DWORD PTR [edx], ecx

; 231  : 			}
; 232  : 			else

  0007c	eb 09		 jmp	 SHORT $LN1@DecreaseDa
$LN2@DecreaseDa:

; 233  : 			{
; 234  : 				iMonth--;

  0007e	48		 dec	 eax
  0007f	89 06		 mov	 DWORD PTR [esi], eax

; 235  : 				iDay = nm[iMonth-1];

  00081	8b 44 85 c8	 mov	 eax, DWORD PTR _nm$[ebp+eax*4-4]
$LN8@DecreaseDa:
  00085	89 02		 mov	 DWORD PTR [edx], eax
$LN1@DecreaseDa:

; 236  : 			}
; 237  : 		}
; 238  : 	}

  00087	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	33 cd		 xor	 ecx, ebp
  0008e	5b		 pop	 ebx
  0008f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00094	c9		 leave
  00095	c3		 ret	 0
?DecreaseDay@DateHelp@@YAXAAH00@Z ENDP			; DateHelp::DecreaseDay
_TEXT	ENDS
PUBLIC	?IncreaseMin@DateHelp@@YAXAAH0000H@Z		; DateHelp::IncreaseMin
; Function compile flags: /Ogsp
;	COMDAT ?IncreaseMin@DateHelp@@YAXAAH0000H@Z
_TEXT	SEGMENT
_iYear$ = 8						; size = 4
_iMonth$ = 12						; size = 4
_iDay$ = 16						; size = 4
_iHour$ = 20						; size = 4
_iMin$ = 24						; size = 4
_iIncraseMin$ = 28					; size = 4
?IncreaseMin@DateHelp@@YAXAAH0000H@Z PROC		; DateHelp::IncreaseMin, COMDAT

; 241  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 242  : 		int nm[12]={ 31,28,31,30,31,30,31,31,30,31,30,31 };
; 243  : 		if( isLeapYear(iYear) )
; 244  : 			nm[1] = 29;
; 245  : 
; 246  : 		int iCurDay = 0;
; 247  : 
; 248  : 		if( 60 <= iIncraseMin + iMin )

  00003	8b 4d 18	 mov	 ecx, DWORD PTR _iMin$[ebp]
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b 7d 1c	 mov	 edi, DWORD PTR _iIncraseMin$[ebp]
  0000d	03 c7		 add	 eax, edi
  0000f	83 f8 3c	 cmp	 eax, 60			; 0000003cH
  00012	7c 49		 jl	 SHORT $LN6@IncreaseMi

; 249  : 		{
; 250  : 			iHour += (iIncraseMin + iMin) / 60;

  00014	99		 cdq
  00015	6a 3c		 push	 60			; 0000003cH
  00017	5e		 pop	 esi
  00018	f7 fe		 idiv	 esi
  0001a	8b 75 14	 mov	 esi, DWORD PTR _iHour$[ebp]

; 251  : 			iMin = (iIncraseMin + iMin) % 60;

  0001d	6a 3c		 push	 60			; 0000003cH
  0001f	01 06		 add	 DWORD PTR [esi], eax
  00021	8b 01		 mov	 eax, DWORD PTR [ecx]
  00023	03 c7		 add	 eax, edi
  00025	99		 cdq
  00026	5f		 pop	 edi
  00027	f7 ff		 idiv	 edi
  00029	89 11		 mov	 DWORD PTR [ecx], edx

; 252  : 
; 253  : 			if( 24 <= iHour )

  0002b	8b 06		 mov	 eax, DWORD PTR [esi]
  0002d	83 f8 18	 cmp	 eax, 24			; 00000018H
  00030	7c 2d		 jl	 SHORT $LN1@IncreaseMi

; 254  : 			{
; 255  : 				iCurDay = iDay + (iHour / 24);

  00032	6a 18		 push	 24			; 00000018H
  00034	99		 cdq
  00035	59		 pop	 ecx
  00036	f7 f9		 idiv	 ecx
  00038	8b 7d 10	 mov	 edi, DWORD PTR _iDay$[ebp]
  0003b	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0003d	03 c8		 add	 ecx, eax

; 256  : 				iHour   = iHour % 24;

  0003f	89 16		 mov	 DWORD PTR [esi], edx

; 257  : 
; 258  : 				int iRestDay = iCurDay - iDay;

  00041	2b 0f		 sub	 ecx, DWORD PTR [edi]

; 259  : 				for( int i = 0; i < iRestDay; ++i )

  00043	85 c9		 test	 ecx, ecx
  00045	7e 18		 jle	 SHORT $LN1@IncreaseMi

; 254  : 			{
; 255  : 				iCurDay = iDay + (iHour / 24);

  00047	8b f1		 mov	 esi, ecx
$LL4@IncreaseMi:

; 260  : 					IncreaseDay( iYear, iMonth, iDay );

  00049	57		 push	 edi
  0004a	ff 75 0c	 push	 DWORD PTR _iMonth$[ebp]
  0004d	ff 75 08	 push	 DWORD PTR _iYear$[ebp]
  00050	e8 00 00 00 00	 call	 ?IncreaseDay@DateHelp@@YAXAAH00@Z ; DateHelp::IncreaseDay
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH
  00058	4e		 dec	 esi
  00059	75 ee		 jne	 SHORT $LL4@IncreaseMi

; 261  : 
; 262  : 			}
; 263  : 		}
; 264  : 		else

  0005b	eb 02		 jmp	 SHORT $LN1@IncreaseMi
$LN6@IncreaseMi:

; 265  : 		{
; 266  : 			iMin += iIncraseMin;

  0005d	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@IncreaseMi:
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi

; 267  : 		}
; 268  : 
; 269  : 	}

  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?IncreaseMin@DateHelp@@YAXAAH0000H@Z ENDP		; DateHelp::IncreaseMin
_TEXT	ENDS
EXTRN	__imp___difftime64:PROC
EXTRN	__fltused:DWORD
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
;	COMDAT _difftime
_TEXT	SEGMENT
__Time1$ = 8						; size = 8
__Time2$ = 16						; size = 8
_difftime PROC						; COMDAT

; 83   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 84   :     return _difftime64(_Time1,_Time2);

  00003	ff 75 14	 push	 DWORD PTR __Time2$[ebp+4]
  00006	ff 75 10	 push	 DWORD PTR __Time2$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Time1$[ebp+4]
  0000c	ff 75 08	 push	 DWORD PTR __Time1$[ebp]
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___difftime64
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 85   : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
_difftime ENDP
_TEXT	ENDS
EXTRN	__imp___localtime64:PROC
; Function compile flags: /Ogsp
;	COMDAT _localtime
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_localtime PROC						; COMDAT

; 113  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 117  : #pragma warning( pop )
; 118  : }

  00003	5d		 pop	 ebp

; 114  : #pragma warning( push )
; 115  : #pragma warning( disable : 4996 )
; 116  :     return _localtime64(_Time);

  00004	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp___localtime64
_localtime ENDP
_TEXT	ENDS
EXTRN	__imp___mktime64:PROC
; Function compile flags: /Ogsp
;	COMDAT _mktime
_TEXT	SEGMENT
__Tm$ = 8						; size = 4
_mktime	PROC						; COMDAT

; 124  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 126  : }

  00003	5d		 pop	 ebp

; 125  :     return _mktime64(_Tm);

  00004	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp___mktime64
_mktime	ENDP
_TEXT	ENDS
EXTRN	__imp___time64:PROC
; Function compile flags: /Ogsp
;	COMDAT _time
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC						; COMDAT

; 132  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 134  : }

  00003	5d		 pop	 ebp

; 133  :     return _time64(_Time);

  00004	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp___time64
_time	ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GetMonthDayPeriod@DateHelp@@YAHHH@Z		; DateHelp::GetMonthDayPeriod
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iodatehelp.cpp
;	COMDAT ?GetMonthDayPeriod@DateHelp@@YAHHH@Z
_TEXT	SEGMENT
_nm$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_num$ = 8						; size = 4
_mon$ = 12						; size = 4
?GetMonthDayPeriod@DateHelp@@YAHHH@Z PROC		; DateHelp::GetMonthDayPeriod, COMDAT

; 316  : 	{ 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 317  : 		int nm[12]={ 31,28,31,30,31,30,31,31,30,31,30,31 }, i = 0;

  00011	6a 1f		 push	 31			; 0000001fH
  00013	58		 pop	 eax
  00014	6a 1c		 push	 28			; 0000001cH
  00016	5a		 pop	 edx
  00017	6a 1e		 push	 30			; 0000001eH
  00019	59		 pop	 ecx
  0001a	89 4d d8	 mov	 DWORD PTR _nm$[ebp+12], ecx
  0001d	89 4d e0	 mov	 DWORD PTR _nm$[ebp+20], ecx
  00020	89 4d ec	 mov	 DWORD PTR _nm$[ebp+32], ecx
  00023	89 4d f4	 mov	 DWORD PTR _nm$[ebp+40], ecx

; 318  : 		if(mon  > 0 && mon < 13)

  00026	8b 4d 0c	 mov	 ecx, DWORD PTR _mon$[ebp]
  00029	89 45 cc	 mov	 DWORD PTR _nm$[ebp], eax
  0002c	89 45 d4	 mov	 DWORD PTR _nm$[ebp+8], eax
  0002f	89 45 dc	 mov	 DWORD PTR _nm$[ebp+16], eax
  00032	89 45 e4	 mov	 DWORD PTR _nm$[ebp+24], eax
  00035	89 45 e8	 mov	 DWORD PTR _nm$[ebp+28], eax
  00038	89 45 f0	 mov	 DWORD PTR _nm$[ebp+36], eax
  0003b	89 45 f8	 mov	 DWORD PTR _nm$[ebp+44], eax
  0003e	8d 71 ff	 lea	 esi, DWORD PTR [ecx-1]
  00041	33 c0		 xor	 eax, eax
  00043	89 55 d0	 mov	 DWORD PTR _nm$[ebp+4], edx
  00046	83 fe 0b	 cmp	 esi, 11			; 0000000bH
  00049	77 45		 ja	 SHORT $LN2@GetMonthDa

; 319  : 		{  
; 320  : 			if(mon == 2)

  0004b	83 f9 02	 cmp	 ecx, 2
  0004e	75 3c		 jne	 SHORT $LN6@GetMonthDa

; 321  : 			{
; 322  : 				// 윤달인지 체크 한다
; 323  : 				nm[1] = (num%4) ? 28 : (num%100) ? 29 : (num%400) ? 28 : 29;

  00050	8b 45 08	 mov	 eax, DWORD PTR _num$[ebp]
  00053	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00058	79 05		 jns	 SHORT $LN9@GetMonthDa
  0005a	48		 dec	 eax
  0005b	83 c8 fc	 or	 eax, -4			; fffffffcH
  0005e	40		 inc	 eax
$LN9@GetMonthDa:
  0005f	75 28		 jne	 SHORT $LN10@GetMonthDa
  00061	8b 45 08	 mov	 eax, DWORD PTR _num$[ebp]
  00064	6a 64		 push	 100			; 00000064H
  00066	99		 cdq
  00067	5e		 pop	 esi
  00068	f7 fe		 idiv	 esi
  0006a	85 d2		 test	 edx, edx
  0006c	74 09		 je	 SHORT $LN5@GetMonthDa
  0006e	c7 45 d0 1d 00
	00 00		 mov	 DWORD PTR _nm$[ebp+4], 29 ; 0000001dH
  00075	eb 15		 jmp	 SHORT $LN6@GetMonthDa
$LN5@GetMonthDa:
  00077	8b 45 08	 mov	 eax, DWORD PTR _num$[ebp]
  0007a	99		 cdq
  0007b	be 90 01 00 00	 mov	 esi, 400		; 00000190H
  00080	f7 fe		 idiv	 esi
  00082	f7 da		 neg	 edx
  00084	1b d2		 sbb	 edx, edx
  00086	83 c2 1d	 add	 edx, 29			; 0000001dH
$LN10@GetMonthDa:
  00089	89 55 d0	 mov	 DWORD PTR _nm$[ebp+4], edx
$LN6@GetMonthDa:

; 324  : 			}
; 325  : 			i = nm[mon-1];

  0008c	8b 44 8d c8	 mov	 eax, DWORD PTR _nm$[ebp+ecx*4-4]
$LN2@GetMonthDa:

; 326  : 		}
; 327  : 		return  i;
; 328  : 	}

  00090	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00093	33 cd		 xor	 ecx, ebp
  00095	5e		 pop	 esi
  00096	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009b	c9		 leave
  0009c	c3		 ret	 0
?GetMonthDayPeriod@DateHelp@@YAHHH@Z ENDP		; DateHelp::GetMonthDayPeriod
_TEXT	ENDS
PUBLIC	?GetWeekDay@DateHelp@@YAHHHH@Z			; DateHelp::GetWeekDay
; Function compile flags: /Ogsp
;	COMDAT ?GetWeekDay@DateHelp@@YAHHHH@Z
_TEXT	SEGMENT
_iYear$ = 8						; size = 4
_iMonth$ = 12						; size = 4
_iDay$ = 16						; size = 4
?GetWeekDay@DateHelp@@YAHHHH@Z PROC			; DateHelp::GetWeekDay, COMDAT

; 331  : 	{	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 332  : 		if( iMonth == 1 || iMonth == 2 )

  00005	8b 7d 0c	 mov	 edi, DWORD PTR _iMonth$[ebp]
  00008	83 ff 01	 cmp	 edi, 1
  0000b	74 05		 je	 SHORT $LN2@GetWeekDay
  0000d	83 ff 02	 cmp	 edi, 2
  00010	75 03		 jne	 SHORT $LN12@GetWeekDay
$LN2@GetWeekDay:

; 333  : 			iYear -= 1;

  00012	ff 4d 08	 dec	 DWORD PTR _iYear$[ebp]
$LN12@GetWeekDay:

; 334  : 		iMonth = ( iMonth + 9 ) % 12 + 1;
; 335  : 		int iY = iYear % 100;

  00015	8b 45 08	 mov	 eax, DWORD PTR _iYear$[ebp]
  00018	99		 cdq
  00019	6a 64		 push	 100			; 00000064H
  0001b	59		 pop	 ecx
  0001c	f7 f9		 idiv	 ecx
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	8b c8		 mov	 ecx, eax
  00022	8b f2		 mov	 esi, edx
  00024	8d 47 09	 lea	 eax, DWORD PTR [edi+9]
  00027	99		 cdq
  00028	5f		 pop	 edi
  00029	f7 ff		 idiv	 edi

; 336  : 		int iCentury = iYear / 100;
; 337  : 		int iWeek = ( ( 13 * iMonth - 1 ) / 5 + iDay + iY + iY/4 + iCentury/4 - 2*iCentury) % 7;

  0002b	6a 05		 push	 5
  0002d	8b c2		 mov	 eax, edx
  0002f	6b c0 0d	 imul	 eax, 13			; 0000000dH
  00032	03 c7		 add	 eax, edi
  00034	99		 cdq
  00035	5f		 pop	 edi
  00036	f7 ff		 idiv	 edi
  00038	6a 07		 push	 7
  0003a	8b f8		 mov	 edi, eax
  0003c	8b c1		 mov	 eax, ecx
  0003e	99		 cdq
  0003f	83 e2 03	 and	 edx, 3
  00042	03 c2		 add	 eax, edx
  00044	c1 f8 02	 sar	 eax, 2
  00047	03 f8		 add	 edi, eax
  00049	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
  0004c	2b f8		 sub	 edi, eax
  0004e	8b c6		 mov	 eax, esi
  00050	99		 cdq
  00051	83 e2 03	 and	 edx, 3
  00054	03 c2		 add	 eax, edx
  00056	c1 f8 02	 sar	 eax, 2
  00059	03 fe		 add	 edi, esi
  0005b	03 c7		 add	 eax, edi
  0005d	03 45 10	 add	 eax, DWORD PTR _iDay$[ebp]
  00060	59		 pop	 ecx
  00061	99		 cdq
  00062	f7 f9		 idiv	 ecx
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi

; 338  : 		if( iWeek < 0 )

  00066	85 d2		 test	 edx, edx
  00068	79 06		 jns	 SHORT $LN1@GetWeekDay

; 339  : 			iWeek = ( iWeek + 7 ) % 7;

  0006a	8d 42 07	 lea	 eax, DWORD PTR [edx+7]
  0006d	99		 cdq
  0006e	f7 f9		 idiv	 ecx
$LN1@GetWeekDay:

; 340  : 		return max( 0, min( 6, iWeek ) );

  00070	6a 06		 push	 6
  00072	58		 pop	 eax
  00073	3b d0		 cmp	 edx, eax
  00075	7f 0e		 jg	 SHORT $LN9@GetWeekDay
  00077	85 d2		 test	 edx, edx
  00079	79 04		 jns	 SHORT $LN10@GetWeekDay
  0007b	33 c0		 xor	 eax, eax

; 341  : 	}

  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
$LN10@GetWeekDay:

; 340  : 		return max( 0, min( 6, iWeek ) );

  0007f	3b d0		 cmp	 edx, eax
  00081	7f 02		 jg	 SHORT $LN9@GetWeekDay
  00083	8b c2		 mov	 eax, edx
$LN9@GetWeekDay:

; 341  : 	}

  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
?GetWeekDay@DateHelp@@YAHHHH@Z ENDP			; DateHelp::GetWeekDay
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?ConvertSecondTime@DateHelp@@YA_JHHHHHH@Z	; DateHelp::ConvertSecondTime
; Function compile flags: /Ogsp
;	COMDAT ?ConvertSecondTime@DateHelp@@YA_JHHHHHH@Z
_TEXT	SEGMENT
_base_time$ = -40					; size = 36
__$ArrayPad$ = -4					; size = 4
_iYear$ = 8						; size = 4
_iMonth$ = 12						; size = 4
_iDay$ = 16						; size = 4
_iHour$ = 20						; size = 4
_iMinute$ = 24						; size = 4
_iSecond$ = 28						; size = 4
?ConvertSecondTime@DateHelp@@YA_JHHHHHH@Z PROC		; DateHelp::ConvertSecondTime, COMDAT

; 383  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 384  : 		struct tm base_time;
; 385  : 		base_time.tm_year = iYear - 1900;

  00010	8b 45 08	 mov	 eax, DWORD PTR _iYear$[ebp]

; 386  : 		base_time.tm_mon  = iMonth - 1;
; 387  : 		base_time.tm_mday = iDay;	
; 388  : 		base_time.tm_hour = iHour;
; 389  : 		base_time.tm_min  = iMinute;		
; 390  : 		base_time.tm_sec  = iSecond;
; 391  : 		base_time.tm_isdst= 0;

  00013	83 65 f8 00	 and	 DWORD PTR _base_time$[ebp+32], 0
  00017	05 94 f8 ff ff	 add	 eax, -1900		; fffff894H
  0001c	89 45 ec	 mov	 DWORD PTR _base_time$[ebp+20], eax
  0001f	8b 45 0c	 mov	 eax, DWORD PTR _iMonth$[ebp]
  00022	48		 dec	 eax
  00023	89 45 e8	 mov	 DWORD PTR _base_time$[ebp+16], eax
  00026	8b 45 10	 mov	 eax, DWORD PTR _iDay$[ebp]
  00029	89 45 e4	 mov	 DWORD PTR _base_time$[ebp+12], eax
  0002c	8b 45 14	 mov	 eax, DWORD PTR _iHour$[ebp]
  0002f	89 45 e0	 mov	 DWORD PTR _base_time$[ebp+8], eax
  00032	8b 45 18	 mov	 eax, DWORD PTR _iMinute$[ebp]
  00035	89 45 dc	 mov	 DWORD PTR _base_time$[ebp+4], eax
  00038	8b 45 1c	 mov	 eax, DWORD PTR _iSecond$[ebp]
  0003b	89 45 d8	 mov	 DWORD PTR _base_time$[ebp], eax

; 392  : 
; 393  : 		return mktime( &base_time );

  0003e	8d 45 d8	 lea	 eax, DWORD PTR _base_time$[ebp]
  00041	50		 push	 eax
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mktime64
  00048	59		 pop	 ecx

; 394  : 	}

  00049	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004c	33 cd		 xor	 ecx, ebp
  0004e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00053	c9		 leave
  00054	c3		 ret	 0
?ConvertSecondTime@DateHelp@@YA_JHHHHHH@Z ENDP		; DateHelp::ConvertSecondTime
_TEXT	ENDS
PUBLIC	??_C@_0BC@BLIIIEKA@DateHelp?3?3weekday?$AA@	; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?weekday@DateHelp@@YAPADH@Z			; DateHelp::weekday
EXTRN	__imp_?GetSingleton@ioStringManager@@SAAAV1@XZ:PROC
EXTRN	__imp_?SafeSprintf@@YAXPADHPBDZZ:PROC
EXTRN	__imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z:PROC
;	COMDAT ?b@?BI@??weekday@DateHelp@@YAPADH@Z@4PADA
_BSS	SEGMENT
?b@?BI@??weekday@DateHelp@@YAPADH@Z@4PADA DB 03H DUP (?) ; `DateHelp::weekday'::`24'::b
_BSS	ENDS
;	COMDAT ??_C@_0BC@BLIIIEKA@DateHelp?3?3weekday?$AA@
CONST	SEGMENT
??_C@_0BC@BLIIIEKA@DateHelp?3?3weekday?$AA@ DB 'DateHelp::weekday', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?weekday@DateHelp@@YAPADH@Z
_TEXT	SEGMENT
_i$505286 = -32						; size = 4
_a$ = -28						; size = 21
__$ArrayPad$ = -4					; size = 4
_ky$ = 8						; size = 4
?weekday@DateHelp@@YAPADH@Z PROC			; DateHelp::weekday, COMDAT

; 397  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx

; 398  : 		char a[7][3];
; 399  : 		ZeroMemory( a, sizeof( a ) );
; 400  : 		for (int i = 0; i < 7 ; i++)

  00011	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  00017	33 c0		 xor	 eax, eax
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?SafeSprintf@@YAXPADHPBDZZ
  00021	8d 7d e4	 lea	 edi, DWORD PTR _a$[ebp]
  00024	ab		 stosd
  00025	ab		 stosd
  00026	ab		 stosd
  00027	ab		 stosd
  00028	ab		 stosd
  00029	aa		 stosb
  0002a	33 c0		 xor	 eax, eax
  0002c	89 45 e0	 mov	 DWORD PTR _i$505286[ebp], eax
$LL17@weekday:

; 401  : 		{
; 402  : 			if( i == 0 )

  0002f	39 45 e0	 cmp	 DWORD PTR _i$505286[ebp], eax
  00032	75 20		 jne	 SHORT $LN14@weekday

; 403  : 				SafeSprintf( a[i], sizeof( a[i] ), STR(1) );

  00034	50		 push	 eax
  00035	6a 01		 push	 1
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@BLIIIEKA@DateHelp?3?3weekday?$AA@
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00047	8b c8		 mov	 ecx, eax
  00049	ff d3		 call	 ebx
  0004b	50		 push	 eax
  0004c	8d 45 e4	 lea	 eax, DWORD PTR _a$[ebp]
  0004f	e9 de 00 00 00	 jmp	 $LN24@weekday
$LN14@weekday:

; 404  : 			else if( i == 1 )

  00054	83 7d e0 01	 cmp	 DWORD PTR _i$505286[ebp], 1
  00058	75 20		 jne	 SHORT $LN12@weekday

; 405  : 				SafeSprintf( a[i], sizeof( a[i] ), STR(2) );

  0005a	50		 push	 eax
  0005b	6a 02		 push	 2
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00062	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@BLIIIEKA@DateHelp?3?3weekday?$AA@
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  0006d	8b c8		 mov	 ecx, eax
  0006f	ff d3		 call	 ebx
  00071	50		 push	 eax
  00072	8d 45 e7	 lea	 eax, DWORD PTR _a$[ebp+3]
  00075	e9 b8 00 00 00	 jmp	 $LN24@weekday
$LN12@weekday:

; 406  : 			else if( i == 2 )

  0007a	83 7d e0 02	 cmp	 DWORD PTR _i$505286[ebp], 2
  0007e	75 20		 jne	 SHORT $LN10@weekday

; 407  : 				SafeSprintf( a[i], sizeof( a[i] ), STR(3) );

  00080	50		 push	 eax
  00081	6a 03		 push	 3
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00088	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@BLIIIEKA@DateHelp?3?3weekday?$AA@
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00093	8b c8		 mov	 ecx, eax
  00095	ff d3		 call	 ebx
  00097	50		 push	 eax
  00098	8d 45 ea	 lea	 eax, DWORD PTR _a$[ebp+6]
  0009b	e9 92 00 00 00	 jmp	 $LN24@weekday
$LN10@weekday:

; 408  : 			else if( i == 3 )

  000a0	8b 45 e0	 mov	 eax, DWORD PTR _i$505286[ebp]
  000a3	6a 03		 push	 3
  000a5	5f		 pop	 edi
  000a6	3b c7		 cmp	 eax, edi
  000a8	75 1f		 jne	 SHORT $LN8@weekday

; 409  : 				SafeSprintf( a[i], sizeof( a[i] ), STR(4) );

  000aa	6a 00		 push	 0
  000ac	6a 04		 push	 4
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  000b3	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@BLIIIEKA@DateHelp?3?3weekday?$AA@
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  000be	8b c8		 mov	 ecx, eax
  000c0	ff d3		 call	 ebx
  000c2	50		 push	 eax
  000c3	57		 push	 edi
  000c4	8d 45 ed	 lea	 eax, DWORD PTR _a$[ebp+9]
  000c7	eb 6b		 jmp	 SHORT $LN25@weekday
$LN8@weekday:

; 410  : 			else if( i == 4 )

  000c9	83 f8 04	 cmp	 eax, 4
  000cc	75 1f		 jne	 SHORT $LN6@weekday

; 411  : 				SafeSprintf( a[i], sizeof( a[i] ), STR(5) );

  000ce	6a 00		 push	 0
  000d0	6a 05		 push	 5
  000d2	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  000d7	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@BLIIIEKA@DateHelp?3?3weekday?$AA@
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  000e2	8b c8		 mov	 ecx, eax
  000e4	ff d3		 call	 ebx
  000e6	50		 push	 eax
  000e7	57		 push	 edi
  000e8	8d 45 f0	 lea	 eax, DWORD PTR _a$[ebp+12]
  000eb	eb 47		 jmp	 SHORT $LN25@weekday
$LN6@weekday:

; 412  : 			else if( i == 5 )

  000ed	83 f8 05	 cmp	 eax, 5
  000f0	75 1f		 jne	 SHORT $LN4@weekday

; 413  : 				SafeSprintf( a[i], sizeof( a[i] ), STR(6) );

  000f2	6a 00		 push	 0
  000f4	6a 06		 push	 6
  000f6	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  000fb	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@BLIIIEKA@DateHelp?3?3weekday?$AA@
  00100	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00106	8b c8		 mov	 ecx, eax
  00108	ff d3		 call	 ebx
  0010a	50		 push	 eax
  0010b	57		 push	 edi
  0010c	8d 45 f3	 lea	 eax, DWORD PTR _a$[ebp+15]
  0010f	eb 23		 jmp	 SHORT $LN25@weekday
$LN4@weekday:

; 414  : 			else if( i == 6 )

  00111	83 f8 06	 cmp	 eax, 6
  00114	75 24		 jne	 SHORT $LN16@weekday

; 415  : 				SafeSprintf( a[i], sizeof( a[i] ), STR(7) );

  00116	6a 00		 push	 0
  00118	6a 07		 push	 7
  0011a	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0011f	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@BLIIIEKA@DateHelp?3?3weekday?$AA@
  00124	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  0012a	8b c8		 mov	 ecx, eax
  0012c	ff d3		 call	 ebx
  0012e	50		 push	 eax
  0012f	8d 45 f6	 lea	 eax, DWORD PTR _a$[ebp+18]
$LN24@weekday:
  00132	6a 03		 push	 3
$LN25@weekday:
  00134	50		 push	 eax
  00135	ff d6		 call	 esi
  00137	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@weekday:

; 416  : 		}
; 417  : 
; 418  : 		static char b[3];
; 419  : 		ZeroMemory( b, sizeof( b ) );

  0013a	ff 45 e0	 inc	 DWORD PTR _i$505286[ebp]
  0013d	33 c0		 xor	 eax, eax
  0013f	83 7d e0 07	 cmp	 DWORD PTR _i$505286[ebp], 7
  00143	0f 8c e6 fe ff
	ff		 jl	 $LL17@weekday

; 420  : 		SafeSprintf( b, sizeof( b ), STR(1) );

  00149	6a 00		 push	 0
  0014b	bf 00 00 00 00	 mov	 edi, OFFSET ?b@?BI@??weekday@DateHelp@@YAPADH@Z@4PADA
  00150	6a 01		 push	 1
  00152	66 ab		 stosw
  00154	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00159	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@BLIIIEKA@DateHelp?3?3weekday?$AA@
  0015e	aa		 stosb
  0015f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00165	8b c8		 mov	 ecx, eax
  00167	ff d3		 call	 ebx
  00169	50		 push	 eax
  0016a	6a 03		 push	 3
  0016c	bf 00 00 00 00	 mov	 edi, OFFSET ?b@?BI@??weekday@DateHelp@@YAPADH@Z@4PADA
  00171	57		 push	 edi
  00172	ff d6		 call	 esi

; 421  : 
; 422  : 		if( ky >= 7 )  // 예외 처리

  00174	8b 45 08	 mov	 eax, DWORD PTR _ky$[ebp]
  00177	83 c4 0c	 add	 esp, 12			; 0000000cH
  0017a	83 f8 07	 cmp	 eax, 7

; 423  : 			return b;

  0017d	7d 16		 jge	 SHORT $LN26@weekday

; 424  : 
; 425  : 		b[0] = a[ky][0]; b[1] = a[ky][1];

  0017f	6b c0 03	 imul	 eax, 3
  00182	8a 4c 05 e4	 mov	 cl, BYTE PTR _a$[ebp+eax]
  00186	8a 44 05 e5	 mov	 al, BYTE PTR _a$[ebp+eax+1]
  0018a	88 0d 00 00 00
	00		 mov	 BYTE PTR ?b@?BI@??weekday@DateHelp@@YAPADH@Z@4PADA, cl
  00190	a2 01 00 00 00	 mov	 BYTE PTR ?b@?BI@??weekday@DateHelp@@YAPADH@Z@4PADA+1, al
$LN26@weekday:

; 426  : 		return b;
; 427  : 	}

  00195	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00198	8b c7		 mov	 eax, edi
  0019a	5f		 pop	 edi
  0019b	5e		 pop	 esi
  0019c	33 cd		 xor	 ecx, ebp
  0019e	5b		 pop	 ebx
  0019f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a4	c9		 leave
  001a5	c3		 ret	 0
?weekday@DateHelp@@YAPADH@Z ENDP			; DateHelp::weekday
_TEXT	ENDS
PUBLIC	??0CAtlException@ATL@@QAE@J@Z			; ATL::CAtlException::CAtlException
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ??0CAtlException@ATL@@QAE@J@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
??0CAtlException@ATL@@QAE@J@Z PROC			; ATL::CAtlException::CAtlException, COMDAT
; _this$ = ecx

; 44   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR _hr$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 45   : 	}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0CAtlException@ATL@@QAE@J@Z ENDP			; ATL::CAtlException::CAtlException
_TEXT	ENDS
PUBLIC	__TI1?AVCAtlException@ATL@@
PUBLIC	?AtlThrowImpl@ATL@@YGXJ@Z			; ATL::AtlThrowImpl
PUBLIC	__CTA1?AVCAtlException@ATL@@
PUBLIC	__CT??_R0?AVCAtlException@ATL@@@84
PUBLIC	??_R0?AVCAtlException@ATL@@@8			; ATL::CAtlException `RTTI Type Descriptor'
EXTRN	__CxxThrowException@8:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT ??_R0?AVCAtlException@ATL@@@8
_DATA	SEGMENT
??_R0?AVCAtlException@ATL@@@8 DD FLAT:??_7type_info@@6B@ ; ATL::CAtlException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCAtlException@ATL@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVCAtlException@ATL@@@84
xdata$x	SEGMENT
__CT??_R0?AVCAtlException@ATL@@@84 DD 00H
	DD	FLAT:??_R0?AVCAtlException@ATL@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT __CTA1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__CTA1?AVCAtlException@ATL@@ DD 01H
	DD	FLAT:__CT??_R0?AVCAtlException@ATL@@@84
xdata$x	ENDS
;	COMDAT __TI1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__TI1?AVCAtlException@ATL@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1?AVCAtlException@ATL@@
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ?AtlThrowImpl@ATL@@YGXJ@Z
_TEXT	SEGMENT
$T505469 = 8						; size = 4
_hr$ = 8						; size = 4
?AtlThrowImpl@ATL@@YGXJ@Z PROC				; ATL::AtlThrowImpl, COMDAT

; 65   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 66   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 67   : #ifdef _AFX
; 68   : 	if( hr == E_OUTOFMEMORY )
; 69   : 	{
; 70   : 		AfxThrowMemoryException();
; 71   : 	}
; 72   : 	else
; 73   : 	{
; 74   : 		AfxThrowOleException( hr );
; 75   : 	}
; 76   : #else
; 77   : 	throw CAtlException( hr );

  00003	8b 45 08	 mov	 eax, DWORD PTR _hr$[ebp]
  00006	89 45 08	 mov	 DWORD PTR $T505469[ebp], eax
  00009	68 00 00 00 00	 push	 OFFSET __TI1?AVCAtlException@ATL@@
  0000e	8d 45 08	 lea	 eax, DWORD PTR $T505469[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN6@AtlThrowIm:
$LN5@AtlThrowIm:
  00017	cc		 int	 3
?AtlThrowImpl@ATL@@YGXJ@Z ENDP				; ATL::AtlThrowImpl
_TEXT	ENDS
PUBLIC	??0CTime@ATL@@QAE@XZ				; ATL::CTime::CTime
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\atlmfc\include\atltime.inl
;	COMDAT ??0CTime@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CTime@ATL@@QAE@XZ PROC				; ATL::CTime::CTime, COMDAT
; _this$ = ecx

; 166  : {

  00000	8b c1		 mov	 eax, ecx
  00002	83 20 00	 and	 DWORD PTR [eax], 0
  00005	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 167  : }

  00009	c3		 ret	 0
??0CTime@ATL@@QAE@XZ ENDP				; ATL::CTime::CTime
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??0CTime@ATL@@QAE@HHHHHHH@Z			; ATL::CTime::CTime
; Function compile flags: /Ogsp
;	COMDAT ??0CTime@ATL@@QAE@HHHHHHH@Z
_TEXT	SEGMENT
_atm$ = -40						; size = 36
__$ArrayPad$ = -4					; size = 4
_nYear$ = 8						; size = 4
_nMonth$ = 12						; size = 4
_nDay$ = 16						; size = 4
_nHour$ = 20						; size = 4
_nMin$ = 24						; size = 4
_nSec$ = 28						; size = 4
_nDST$ = 32						; size = 4
??0CTime@ATL@@QAE@HHHHHHH@Z PROC			; ATL::CTime::CTime, COMDAT
; _this$ = ecx

; 182  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 183  : #pragma warning (push)
; 184  : #pragma warning (disable: 4127)  // conditional expression constant
; 185  : 
; 186  : 	ATLENSURE( nYear >= 1900 );

  00010	81 7d 08 6c 07
	00 00		 cmp	 DWORD PTR _nYear$[ebp], 1900 ; 0000076cH
  00017	56		 push	 esi
  00018	8b f1		 mov	 esi, ecx
  0001a	7d 0a		 jge	 SHORT $LN66@CTime
$LN81@CTime:
  0001c	68 05 40 00 80	 push	 -2147467259		; 80004005H
$LN82@CTime:
  00021	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN83@CTime:
$LN66@CTime:
  00026	53		 push	 ebx

; 187  : 	ATLENSURE( nMonth >= 1 && nMonth <= 12 );

  00027	8b 5d 0c	 mov	 ebx, DWORD PTR _nMonth$[ebp]
  0002a	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  0002d	57		 push	 edi
  0002e	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00031	77 e9		 ja	 SHORT $LN81@CTime

; 188  : 	ATLENSURE( nDay >= 1 && nDay <= 31 );

  00033	8b 55 10	 mov	 edx, DWORD PTR _nDay$[ebp]
  00036	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  00039	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  0003c	77 de		 ja	 SHORT $LN81@CTime

; 189  : 	ATLENSURE( nHour >= 0 && nHour <= 23 );

  0003e	8b 7d 14	 mov	 edi, DWORD PTR _nHour$[ebp]
  00041	83 ff 17	 cmp	 edi, 23			; 00000017H
  00044	77 d6		 ja	 SHORT $LN81@CTime

; 190  : 	ATLENSURE( nMin >= 0 && nMin <= 59 );

  00046	8b 4d 18	 mov	 ecx, DWORD PTR _nMin$[ebp]
  00049	83 f9 3b	 cmp	 ecx, 59			; 0000003bH
  0004c	77 ce		 ja	 SHORT $LN81@CTime

; 191  : 	ATLENSURE( nSec >= 0 && nSec <= 59 );

  0004e	8b 45 1c	 mov	 eax, DWORD PTR _nSec$[ebp]
  00051	83 f8 3b	 cmp	 eax, 59			; 0000003bH
  00054	77 c6		 ja	 SHORT $LN81@CTime

; 192  : 
; 193  : #pragma warning (pop)
; 194  : 
; 195  : 	struct tm atm;
; 196  : 
; 197  : 	atm.tm_sec = nSec;

  00056	89 45 d8	 mov	 DWORD PTR _atm$[ebp], eax

; 198  : 	atm.tm_min = nMin;
; 199  : 	atm.tm_hour = nHour;
; 200  : 	atm.tm_mday = nDay;
; 201  : 	atm.tm_mon = nMonth - 1;        // tm_mon is 0 based
; 202  : 	atm.tm_year = nYear - 1900;     // tm_year is 1900 based

  00059	8b 45 08	 mov	 eax, DWORD PTR _nYear$[ebp]
  0005c	05 94 f8 ff ff	 add	 eax, -1900		; fffff894H
  00061	89 45 ec	 mov	 DWORD PTR _atm$[ebp+20], eax

; 203  : 	atm.tm_isdst = nDST;

  00064	8b 45 20	 mov	 eax, DWORD PTR _nDST$[ebp]
  00067	89 45 f8	 mov	 DWORD PTR _atm$[ebp+32], eax

; 204  : 
; 205  : 	m_time = _mktime64(&atm);

  0006a	8d 45 d8	 lea	 eax, DWORD PTR _atm$[ebp]
  0006d	4b		 dec	 ebx
  0006e	50		 push	 eax
  0006f	89 4d dc	 mov	 DWORD PTR _atm$[ebp+4], ecx
  00072	89 7d e0	 mov	 DWORD PTR _atm$[ebp+8], edi
  00075	89 55 e4	 mov	 DWORD PTR _atm$[ebp+12], edx
  00078	89 5d e8	 mov	 DWORD PTR _atm$[ebp+16], ebx
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mktime64
  00081	59		 pop	 ecx
  00082	89 06		 mov	 DWORD PTR [esi], eax

; 206  : 	ATLASSUME(m_time != -1);       // indicates an illegal input time
; 207  : 	if(m_time == -1)

  00084	23 c2		 and	 eax, edx
  00086	5f		 pop	 edi
  00087	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0008a	5b		 pop	 ebx
  0008b	83 f8 ff	 cmp	 eax, -1
  0008e	75 07		 jne	 SHORT $LN1@CTime

; 208  : 	{
; 209  : 		AtlThrow(E_INVALIDARG);

  00090	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00095	eb 8a		 jmp	 SHORT $LN82@CTime
$LN1@CTime:

; 210  : 	}
; 211  : }

  00097	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009a	8b c6		 mov	 eax, esi
  0009c	33 cd		 xor	 ecx, ebp
  0009e	5e		 pop	 esi
  0009f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a4	c9		 leave
  000a5	c2 1c 00	 ret	 28			; 0000001cH
$LN80@CTime:
??0CTime@ATL@@QAE@HHHHHHH@Z ENDP			; ATL::CTime::CTime
_TEXT	ENDS
PUBLIC	?GetTodayOfYear@DateHelp@@YAHXZ			; DateHelp::GetTodayOfYear
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iodatehelp.cpp
;	COMDAT ?GetTodayOfYear@DateHelp@@YAHXZ
_TEXT	SEGMENT
_today$ = -8						; size = 8
?GetTodayOfYear@DateHelp@@YAHXZ PROC			; DateHelp::GetTodayOfYear, COMDAT

; 12   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 13   : 		time_t today;
; 14   : 		time( &today );

  00005	8d 45 f8	 lea	 eax, DWORD PTR _today$[ebp]
  00008	50		 push	 eax
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64

; 15   : 		struct tm* tmday;
; 16   : 		tmday = localtime( &today );

  0000f	8d 45 f8	 lea	 eax, DWORD PTR _today$[ebp]
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___localtime64

; 17   : 
; 18   : 		return 1900 + tmday->tm_year;

  00019	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001c	59		 pop	 ecx
  0001d	59		 pop	 ecx
  0001e	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH

; 19   : 	}

  00023	c9		 leave
  00024	c3		 ret	 0
?GetTodayOfYear@DateHelp@@YAHXZ ENDP			; DateHelp::GetTodayOfYear
_TEXT	ENDS
PUBLIC	?GetTodayOfMon@DateHelp@@YAHXZ			; DateHelp::GetTodayOfMon
; Function compile flags: /Ogsp
;	COMDAT ?GetTodayOfMon@DateHelp@@YAHXZ
_TEXT	SEGMENT
_today$ = -8						; size = 8
?GetTodayOfMon@DateHelp@@YAHXZ PROC			; DateHelp::GetTodayOfMon, COMDAT

; 22   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 23   : 		time_t today;
; 24   : 		time( &today );

  00005	8d 45 f8	 lea	 eax, DWORD PTR _today$[ebp]
  00008	50		 push	 eax
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64

; 25   : 		struct tm* tmday;
; 26   : 		tmday = localtime( &today );

  0000f	8d 45 f8	 lea	 eax, DWORD PTR _today$[ebp]
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___localtime64

; 27   : 		return tmday->tm_mon+1;

  00019	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0001c	59		 pop	 ecx
  0001d	59		 pop	 ecx
  0001e	40		 inc	 eax

; 28   : 	}

  0001f	c9		 leave
  00020	c3		 ret	 0
?GetTodayOfMon@DateHelp@@YAHXZ ENDP			; DateHelp::GetTodayOfMon
_TEXT	ENDS
PUBLIC	?GetTodayOfWeek@DateHelp@@YAHXZ			; DateHelp::GetTodayOfWeek
; Function compile flags: /Ogsp
;	COMDAT ?GetTodayOfWeek@DateHelp@@YAHXZ
_TEXT	SEGMENT
_today$ = -8						; size = 8
?GetTodayOfWeek@DateHelp@@YAHXZ PROC			; DateHelp::GetTodayOfWeek, COMDAT

; 31   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 32   : 		time_t today;
; 33   : 		time( &today );

  00005	8d 45 f8	 lea	 eax, DWORD PTR _today$[ebp]
  00008	50		 push	 eax
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64

; 34   : 		struct tm* tmday;
; 35   : 		tmday = localtime( &today );

  0000f	8d 45 f8	 lea	 eax, DWORD PTR _today$[ebp]
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___localtime64

; 36   : 		return tmday->tm_wday;

  00019	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0001c	59		 pop	 ecx
  0001d	59		 pop	 ecx

; 37   : 	}

  0001e	c9		 leave
  0001f	c3		 ret	 0
?GetTodayOfWeek@DateHelp@@YAHXZ ENDP			; DateHelp::GetTodayOfWeek
_TEXT	ENDS
PUBLIC	?GetTodayOfDay@DateHelp@@YAHXZ			; DateHelp::GetTodayOfDay
; Function compile flags: /Ogsp
;	COMDAT ?GetTodayOfDay@DateHelp@@YAHXZ
_TEXT	SEGMENT
_today$ = -8						; size = 8
?GetTodayOfDay@DateHelp@@YAHXZ PROC			; DateHelp::GetTodayOfDay, COMDAT

; 40   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 41   : 		time_t today;
; 42   : 		time( &today );

  00005	8d 45 f8	 lea	 eax, DWORD PTR _today$[ebp]
  00008	50		 push	 eax
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64

; 43   : 		struct tm* tmday;
; 44   : 		tmday = localtime( &today );

  0000f	8d 45 f8	 lea	 eax, DWORD PTR _today$[ebp]
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___localtime64

; 45   : 
; 46   : 		return tmday->tm_mday;

  00019	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0001c	59		 pop	 ecx
  0001d	59		 pop	 ecx

; 47   : 	}

  0001e	c9		 leave
  0001f	c3		 ret	 0
?GetTodayOfDay@DateHelp@@YAHXZ ENDP			; DateHelp::GetTodayOfDay
_TEXT	ENDS
PUBLIC	?GetTodayOfHour@DateHelp@@YAHXZ			; DateHelp::GetTodayOfHour
; Function compile flags: /Ogsp
;	COMDAT ?GetTodayOfHour@DateHelp@@YAHXZ
_TEXT	SEGMENT
_today$ = -8						; size = 8
?GetTodayOfHour@DateHelp@@YAHXZ PROC			; DateHelp::GetTodayOfHour, COMDAT

; 50   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 51   : 		time_t today;
; 52   : 		time( &today );

  00005	8d 45 f8	 lea	 eax, DWORD PTR _today$[ebp]
  00008	50		 push	 eax
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64

; 53   : 		struct tm* tmday;
; 54   : 		tmday = localtime( &today );

  0000f	8d 45 f8	 lea	 eax, DWORD PTR _today$[ebp]
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___localtime64

; 55   : 
; 56   : 		return tmday->tm_hour;

  00019	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001c	59		 pop	 ecx
  0001d	59		 pop	 ecx

; 57   : 	}

  0001e	c9		 leave
  0001f	c3		 ret	 0
?GetTodayOfHour@DateHelp@@YAHXZ ENDP			; DateHelp::GetTodayOfHour
_TEXT	ENDS
PUBLIC	?GetTodayOfMin@DateHelp@@YAHXZ			; DateHelp::GetTodayOfMin
; Function compile flags: /Ogsp
;	COMDAT ?GetTodayOfMin@DateHelp@@YAHXZ
_TEXT	SEGMENT
_today$ = -8						; size = 8
?GetTodayOfMin@DateHelp@@YAHXZ PROC			; DateHelp::GetTodayOfMin, COMDAT

; 60   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 61   : 		time_t today;
; 62   : 		time( &today );

  00005	8d 45 f8	 lea	 eax, DWORD PTR _today$[ebp]
  00008	50		 push	 eax
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64

; 63   : 		struct tm* tmday;
; 64   : 		tmday = localtime( &today );

  0000f	8d 45 f8	 lea	 eax, DWORD PTR _today$[ebp]
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___localtime64

; 65   : 
; 66   : 		return tmday->tm_min;

  00019	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001c	59		 pop	 ecx
  0001d	59		 pop	 ecx

; 67   : 	}

  0001e	c9		 leave
  0001f	c3		 ret	 0
?GetTodayOfMin@DateHelp@@YAHXZ ENDP			; DateHelp::GetTodayOfMin
_TEXT	ENDS
PUBLIC	?GetTodayOfSec@DateHelp@@YAHXZ			; DateHelp::GetTodayOfSec
; Function compile flags: /Ogsp
;	COMDAT ?GetTodayOfSec@DateHelp@@YAHXZ
_TEXT	SEGMENT
_today$ = -8						; size = 8
?GetTodayOfSec@DateHelp@@YAHXZ PROC			; DateHelp::GetTodayOfSec, COMDAT

; 70   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 71   : 		time_t today;
; 72   : 		time( &today );

  00005	8d 45 f8	 lea	 eax, DWORD PTR _today$[ebp]
  00008	50		 push	 eax
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64

; 73   : 		struct tm* tmday;
; 74   : 		tmday = localtime( &today );

  0000f	8d 45 f8	 lea	 eax, DWORD PTR _today$[ebp]
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___localtime64

; 75   : 
; 76   : 		return tmday->tm_sec;

  00019	8b 00		 mov	 eax, DWORD PTR [eax]
  0001b	59		 pop	 ecx
  0001c	59		 pop	 ecx

; 77   : 	}

  0001d	c9		 leave
  0001e	c3		 ret	 0
?GetTodayOfSec@DateHelp@@YAHXZ ENDP			; DateHelp::GetTodayOfSec
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GetCurrTime@DateHelp@@YAABVCTime@ATL@@XZ	; DateHelp::GetCurrTime
EXTRN	?GetServerTime@ioMyInfo@@QAEXAAU_SYSTEMTIME@@@Z:PROC ; ioMyInfo::GetServerTime
EXTRN	?GetSingleton@ioMyInfo@@SAAAV1@XZ:PROC		; ioMyInfo::GetSingleton
EXTRN	?IsNetworkPlaying@P2PNetwork@@YA_NXZ:PROC	; P2PNetwork::IsNetworkPlaying
;	COMDAT ?kCurrTime@?1??GetCurrTime@DateHelp@@YAABVCTime@ATL@@XZ@4V34@A
; File c:\program files (x86)\microsoft visual studio 10.0\vc\atlmfc\include\atltime.inl
_BSS	SEGMENT
?kCurrTime@?1??GetCurrTime@DateHelp@@YAABVCTime@ATL@@XZ@4V34@A DQ 01H DUP (?) ; `DateHelp::GetCurrTime'::`2'::kCurrTime
_BSS	ENDS
;	COMDAT ?$S1@?1??GetCurrTime@DateHelp@@YAABVCTime@ATL@@XZ@4IA
_BSS	SEGMENT
?$S1@?1??GetCurrTime@DateHelp@@YAABVCTime@ATL@@XZ@4IA DD 01H DUP (?) ; `DateHelp::GetCurrTime'::`2'::$S1
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iodatehelp.cpp
_BSS	ENDS
;	COMDAT ?GetCurrTime@DateHelp@@YAABVCTime@ATL@@XZ
_TEXT	SEGMENT
$T505558 = -28						; size = 8
_rkServerTime$505105 = -20				; size = 16
__$ArrayPad$ = -4					; size = 4
?GetCurrTime@DateHelp@@YAABVCTime@ATL@@XZ PROC		; DateHelp::GetCurrTime, COMDAT

; 80   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 81   : 		static CTime kCurrTime;

  00010	f6 05 00 00 00
	00 01		 test	 BYTE PTR ?$S1@?1??GetCurrTime@DateHelp@@YAABVCTime@ATL@@XZ@4IA, 1
  00017	75 13		 jne	 SHORT $LN7@GetCurrTim
  00019	83 0d 00 00 00
	00 01		 or	 DWORD PTR ?$S1@?1??GetCurrTime@DateHelp@@YAABVCTime@ATL@@XZ@4IA, 1
  00020	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00024	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?kCurrTime@?1??GetCurrTime@DateHelp@@YAABVCTime@ATL@@XZ@4V34@A, xmm0
$LN7@GetCurrTim:

; 82   : 		if( P2PNetwork::IsNetworkPlaying() )

  0002c	e8 00 00 00 00	 call	 ?IsNetworkPlaying@P2PNetwork@@YA_NXZ ; P2PNetwork::IsNetworkPlaying
  00031	84 c0		 test	 al, al
  00033	74 31		 je	 SHORT $LN2@GetCurrTim

; 83   : 		{
; 84   : 			SYSTEMTIME rkServerTime;
; 85   : 			g_MyInfo.GetServerTime( rkServerTime );	

  00035	8d 45 ec	 lea	 eax, DWORD PTR _rkServerTime$505105[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  0003e	8b c8		 mov	 ecx, eax
  00040	e8 00 00 00 00	 call	 ?GetServerTime@ioMyInfo@@QAEXAAU_SYSTEMTIME@@@Z ; ioMyInfo::GetServerTime

; 86   : 			kCurrTime = CTime( rkServerTime.wYear, rkServerTime.wMonth, rkServerTime.wDay, rkServerTime.wHour, rkServerTime.wMinute, rkServerTime.wSecond );

  00045	0f b7 45 f8	 movzx	 eax, WORD PTR _rkServerTime$505105[ebp+12]
  00049	6a ff		 push	 -1
  0004b	50		 push	 eax
  0004c	0f b7 45 f6	 movzx	 eax, WORD PTR _rkServerTime$505105[ebp+10]
  00050	50		 push	 eax
  00051	0f b7 45 f4	 movzx	 eax, WORD PTR _rkServerTime$505105[ebp+8]
  00055	50		 push	 eax
  00056	0f b7 45 f2	 movzx	 eax, WORD PTR _rkServerTime$505105[ebp+6]
  0005a	50		 push	 eax
  0005b	0f b7 45 ee	 movzx	 eax, WORD PTR _rkServerTime$505105[ebp+2]
  0005f	50		 push	 eax
  00060	0f b7 45 ec	 movzx	 eax, WORD PTR _rkServerTime$505105[ebp]

; 87   : 		}
; 88   : 		else

  00064	eb 25		 jmp	 SHORT $LN9@GetCurrTim
$LN2@GetCurrTim:

; 89   : 		{
; 90   : 			kCurrTime = CTime( GetTodayOfYear(), GetTodayOfMon(), GetTodayOfDay(), GetTodayOfHour(), GetTodayOfMin(), GetTodayOfSec() );

  00066	6a ff		 push	 -1
  00068	e8 00 00 00 00	 call	 ?GetTodayOfSec@DateHelp@@YAHXZ ; DateHelp::GetTodayOfSec
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 ?GetTodayOfMin@DateHelp@@YAHXZ ; DateHelp::GetTodayOfMin
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ?GetTodayOfHour@DateHelp@@YAHXZ ; DateHelp::GetTodayOfHour
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?GetTodayOfDay@DateHelp@@YAHXZ ; DateHelp::GetTodayOfDay
  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 ?GetTodayOfMon@DateHelp@@YAHXZ ; DateHelp::GetTodayOfMon
  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 ?GetTodayOfYear@DateHelp@@YAHXZ ; DateHelp::GetTodayOfYear
$LN9@GetCurrTim:
  0008b	50		 push	 eax
  0008c	8d 4d e4	 lea	 ecx, DWORD PTR $T505558[ebp]
  0008f	e8 00 00 00 00	 call	 ??0CTime@ATL@@QAE@HHHHHHH@Z ; ATL::CTime::CTime
  00094	8b 08		 mov	 ecx, DWORD PTR [eax]
  00096	89 0d 00 00 00
	00		 mov	 DWORD PTR ?kCurrTime@?1??GetCurrTime@DateHelp@@YAABVCTime@ATL@@XZ@4V34@A, ecx
  0009c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 91   : 		}
; 92   : 
; 93   : 		return kCurrTime;
; 94   : 	}

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a2	a3 04 00 00 00	 mov	 DWORD PTR ?kCurrTime@?1??GetCurrTime@DateHelp@@YAABVCTime@ATL@@XZ@4V34@A+4, eax
  000a7	33 cd		 xor	 ecx, ebp
  000a9	b8 00 00 00 00	 mov	 eax, OFFSET ?kCurrTime@?1??GetCurrTime@DateHelp@@YAABVCTime@ATL@@XZ@4V34@A
  000ae	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b3	c9		 leave
  000b4	c3		 ret	 0
?GetCurrTime@DateHelp@@YAABVCTime@ATL@@XZ ENDP		; DateHelp::GetCurrTime
_TEXT	ENDS
PUBLIC	?ConvertCTime@DateHelp@@YAXKAAVCTime@ATL@@@Z	; DateHelp::ConvertCTime
; Function compile flags: /Ogsp
;	COMDAT ?ConvertCTime@DateHelp@@YAXKAAVCTime@ATL@@@Z
_TEXT	SEGMENT
$T505566 = -8						; size = 8
_dwDate$ = 8						; size = 4
_Time$ = 12						; size = 4
?ConvertCTime@DateHelp@@YAXKAAVCTime@ATL@@@Z PROC	; DateHelp::ConvertCTime, COMDAT

; 135  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	56		 push	 esi

; 136  : 		Time = CTime( GetDateYear( dwDate ), GetDateMonth( dwDate ), GetDateDay( dwDate ), GetDateHour( dwDate ), GetDateMinute( dwDate ), 0 );

  00006	8b 75 08	 mov	 esi, DWORD PTR _dwDate$[ebp]
  00009	6a ff		 push	 -1
  0000b	6a 00		 push	 0
  0000d	6a 64		 push	 100			; 00000064H
  0000f	59		 pop	 ecx
  00010	33 d2		 xor	 edx, edx
  00012	8b c6		 mov	 eax, esi
  00014	f7 f1		 div	 ecx
  00016	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  0001b	8b c6		 mov	 eax, esi
  0001d	52		 push	 edx
  0001e	33 d2		 xor	 edx, edx
  00020	f7 f1		 div	 ecx
  00022	6a 64		 push	 100			; 00000064H
  00024	59		 pop	 ecx
  00025	8b c2		 mov	 eax, edx
  00027	33 d2		 xor	 edx, edx
  00029	f7 f1		 div	 ecx
  0002b	50		 push	 eax
  0002c	56		 push	 esi
  0002d	e8 00 00 00 00	 call	 ?GetDateDay@DateHelp@@YAHK@Z ; DateHelp::GetDateDay
  00032	59		 pop	 ecx
  00033	50		 push	 eax
  00034	56		 push	 esi
  00035	e8 00 00 00 00	 call	 ?GetDateMonth@DateHelp@@YAHK@Z ; DateHelp::GetDateMonth
  0003a	59		 pop	 ecx
  0003b	50		 push	 eax
  0003c	33 d2		 xor	 edx, edx
  0003e	b9 00 e1 f5 05	 mov	 ecx, 100000000		; 05f5e100H
  00043	8b c6		 mov	 eax, esi
  00045	f7 f1		 div	 ecx
  00047	8d 4d f8	 lea	 ecx, DWORD PTR $T505566[ebp]
  0004a	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ??0CTime@ATL@@QAE@HHHHHHH@Z ; ATL::CTime::CTime
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	8b 4d 0c	 mov	 ecx, DWORD PTR _Time$[ebp]
  0005a	89 11		 mov	 DWORD PTR [ecx], edx
  0005c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00062	5e		 pop	 esi

; 137  : 	}

  00063	c9		 leave
  00064	c3		 ret	 0
?ConvertCTime@DateHelp@@YAXKAAVCTime@ATL@@@Z ENDP	; DateHelp::ConvertCTime
_TEXT	ENDS
PUBLIC	__real@404e000000000000
PUBLIC	__real@40ac200000000000
PUBLIC	__real@40f5180000000000
PUBLIC	__$ArrayPad$
PUBLIC	?GetDatePeriod@DateHelp@@YAHHHHHHHHHHHW4PeriodType@1@@Z ; DateHelp::GetDatePeriod
EXTRN	__ftol2_sse:PROC
;	COMDAT __real@404e000000000000
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
CONST	SEGMENT
__real@404e000000000000 DQ 0404e000000000000r	; 60
CONST	ENDS
;	COMDAT __real@40ac200000000000
CONST	SEGMENT
__real@40ac200000000000 DQ 040ac200000000000r	; 3600
CONST	ENDS
;	COMDAT __real@40f5180000000000
CONST	SEGMENT
__real@40f5180000000000 DQ 040f5180000000000r	; 86400
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iodatehelp.cpp
CONST	ENDS
;	COMDAT ?GetDatePeriod@DateHelp@@YAHHHHHHHHHHHW4PeriodType@1@@Z
_TEXT	SEGMENT
_rawtime$ = -84						; size = 8
_EndTime$ = -76						; size = 36
_StartTime$ = -40					; size = 36
__$ArrayPad$ = -4					; size = 4
_iStartYear$ = 8					; size = 4
_iStartMonth$ = 12					; size = 4
_iStartDay$ = 16					; size = 4
_iStartHour$ = 20					; size = 4
_iStartMin$ = 24					; size = 4
_iEndYear$ = 28						; size = 4
_iEndMonth$ = 32					; size = 4
_iEndDay$ = 36						; size = 4
_iEndHour$ = 40						; size = 4
_iEndMin$ = 44						; size = 4
_eType$ = 48						; size = 4
?GetDatePeriod@DateHelp@@YAHHHHHHHHHHHW4PeriodType@1@@Z PROC ; DateHelp::GetDatePeriod, COMDAT

; 282  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi

; 283  : 
; 284  : 		//difftime 함수를 이용해서 두 날짜의 차이값이 허용 범위를 초과 하게 되면 0이되므로 
; 285  : 		//최소 날짜를 2000, 1, 1일로 설정
; 286  : 		time_t rawtime;
; 287  : 		time ( &rawtime );

  00012	8d 45 ac	 lea	 eax, DWORD PTR _rawtime$[ebp]
  00015	57		 push	 edi
  00016	50		 push	 eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64

; 288  : 		tm StartTime;
; 289  : 		StartTime = (*localtime( &rawtime ));

  0001d	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp___localtime64
  00023	8d 45 ac	 lea	 eax, DWORD PTR _rawtime$[ebp]
  00026	50		 push	 eax
  00027	ff d3		 call	 ebx
  00029	59		 pop	 ecx
  0002a	59		 pop	 ecx
  0002b	6a 09		 push	 9
  0002d	59		 pop	 ecx
  0002e	8b f0		 mov	 esi, eax

; 290  : 		StartTime.tm_year = max( 100, iStartYear - 1900 );

  00030	8b 45 08	 mov	 eax, DWORD PTR _iStartYear$[ebp]
  00033	8d 7d d8	 lea	 edi, DWORD PTR _StartTime$[ebp]
  00036	f3 a5		 rep movsd
  00038	6a 64		 push	 100			; 00000064H
  0003a	59		 pop	 ecx
  0003b	05 94 f8 ff ff	 add	 eax, -1900		; fffff894H
  00040	89 4d ec	 mov	 DWORD PTR _StartTime$[ebp+20], ecx
  00043	3b c1		 cmp	 eax, ecx
  00045	7c 03		 jl	 SHORT $LN8@GetDatePer
  00047	89 45 ec	 mov	 DWORD PTR _StartTime$[ebp+20], eax
$LN8@GetDatePer:

; 291  : 		StartTime.tm_mon  = max( 0, iStartMonth - 1 );

  0004a	8b 45 0c	 mov	 eax, DWORD PTR _iStartMonth$[ebp]
  0004d	48		 dec	 eax
  0004e	79 06		 jns	 SHORT $LN9@GetDatePer
  00050	83 65 e8 00	 and	 DWORD PTR _StartTime$[ebp+16], 0
  00054	eb 03		 jmp	 SHORT $LN10@GetDatePer
$LN9@GetDatePer:
  00056	89 45 e8	 mov	 DWORD PTR _StartTime$[ebp+16], eax
$LN10@GetDatePer:

; 292  : 		StartTime.tm_mday = max( 1, iStartDay );

  00059	8b 45 10	 mov	 eax, DWORD PTR _iStartDay$[ebp]
  0005c	33 c9		 xor	 ecx, ecx
  0005e	41		 inc	 ecx
  0005f	89 4d e4	 mov	 DWORD PTR _StartTime$[ebp+12], ecx
  00062	3b c1		 cmp	 eax, ecx
  00064	7c 03		 jl	 SHORT $LN12@GetDatePer
  00066	89 45 e4	 mov	 DWORD PTR _StartTime$[ebp+12], eax
$LN12@GetDatePer:

; 293  : 		StartTime.tm_hour = iStartHour;

  00069	8b 45 14	 mov	 eax, DWORD PTR _iStartHour$[ebp]
  0006c	89 45 e0	 mov	 DWORD PTR _StartTime$[ebp+8], eax

; 294  : 		StartTime.tm_min  = iStartMin;

  0006f	8b 45 18	 mov	 eax, DWORD PTR _iStartMin$[ebp]
  00072	89 45 dc	 mov	 DWORD PTR _StartTime$[ebp+4], eax

; 295  : 
; 296  : 		tm EndTime;
; 297  : 		EndTime = (*localtime( &rawtime ));

  00075	8d 45 ac	 lea	 eax, DWORD PTR _rawtime$[ebp]
  00078	50		 push	 eax
  00079	ff d3		 call	 ebx
  0007b	59		 pop	 ecx
  0007c	6a 09		 push	 9
  0007e	59		 pop	 ecx
  0007f	8b f0		 mov	 esi, eax

; 298  : 		EndTime.tm_year = max( 100, iEndYear - 1900 );

  00081	8b 45 1c	 mov	 eax, DWORD PTR _iEndYear$[ebp]
  00084	8d 7d b4	 lea	 edi, DWORD PTR _EndTime$[ebp]
  00087	f3 a5		 rep movsd
  00089	6a 64		 push	 100			; 00000064H
  0008b	59		 pop	 ecx
  0008c	05 94 f8 ff ff	 add	 eax, -1900		; fffff894H
  00091	89 4d c8	 mov	 DWORD PTR _EndTime$[ebp+20], ecx
  00094	3b c1		 cmp	 eax, ecx
  00096	7c 03		 jl	 SHORT $LN14@GetDatePer
  00098	89 45 c8	 mov	 DWORD PTR _EndTime$[ebp+20], eax
$LN14@GetDatePer:

; 299  : 		EndTime.tm_mon  = max( 0, iEndMonth - 1 );

  0009b	8b 45 20	 mov	 eax, DWORD PTR _iEndMonth$[ebp]
  0009e	48		 dec	 eax
  0009f	79 06		 jns	 SHORT $LN15@GetDatePer
  000a1	83 65 c4 00	 and	 DWORD PTR _EndTime$[ebp+16], 0
  000a5	eb 03		 jmp	 SHORT $LN16@GetDatePer
$LN15@GetDatePer:
  000a7	89 45 c4	 mov	 DWORD PTR _EndTime$[ebp+16], eax
$LN16@GetDatePer:

; 300  : 		EndTime.tm_mday = max( 1, iEndDay );

  000aa	8b 45 24	 mov	 eax, DWORD PTR _iEndDay$[ebp]
  000ad	33 c9		 xor	 ecx, ecx
  000af	41		 inc	 ecx
  000b0	89 4d c0	 mov	 DWORD PTR _EndTime$[ebp+12], ecx
  000b3	3b c1		 cmp	 eax, ecx
  000b5	7c 03		 jl	 SHORT $LN18@GetDatePer
  000b7	89 45 c0	 mov	 DWORD PTR _EndTime$[ebp+12], eax
$LN18@GetDatePer:

; 301  : 		EndTime.tm_hour = iEndHour;

  000ba	8b 45 28	 mov	 eax, DWORD PTR _iEndHour$[ebp]

; 302  : 		EndTime.tm_min  = iEndMin;
; 303  : 
; 304  : 		time_t tStart = mktime( &StartTime );

  000bd	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp___mktime64
  000c3	89 45 bc	 mov	 DWORD PTR _EndTime$[ebp+8], eax
  000c6	8b 45 2c	 mov	 eax, DWORD PTR _iEndMin$[ebp]
  000c9	89 45 b8	 mov	 DWORD PTR _EndTime$[ebp+4], eax
  000cc	8d 45 d8	 lea	 eax, DWORD PTR _StartTime$[ebp]
  000cf	50		 push	 eax
  000d0	ff d6		 call	 esi
  000d2	8b f8		 mov	 edi, eax

; 305  : 		time_t tEnd = mktime( &EndTime );

  000d4	8d 45 b4	 lea	 eax, DWORD PTR _EndTime$[ebp]
  000d7	50		 push	 eax
  000d8	8b da		 mov	 ebx, edx
  000da	ff d6		 call	 esi
  000dc	59		 pop	 ecx
  000dd	59		 pop	 ecx

; 306  : 
; 307  : 		if( eType == PT_DAY )
; 308  : 			return difftime( tEnd, tStart ) / ( 60 * 60 * 24 );

  000de	53		 push	 ebx
  000df	57		 push	 edi
  000e0	52		 push	 edx
  000e1	50		 push	 eax
  000e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___difftime64
  000e8	83 7d 30 00	 cmp	 DWORD PTR _eType$[ebp], 0
  000ec	75 08		 jne	 SHORT $LN4@GetDatePer
  000ee	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@40f5180000000000
  000f4	eb 14		 jmp	 SHORT $LN35@GetDatePer
$LN4@GetDatePer:

; 309  : 		else if( eType == PT_HOUR )

  000f6	83 7d 30 01	 cmp	 DWORD PTR _eType$[ebp], 1
  000fa	75 08		 jne	 SHORT $LN2@GetDatePer

; 310  : 			return difftime( tEnd, tStart ) / ( 60 * 60 );

  000fc	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@40ac200000000000
  00102	eb 06		 jmp	 SHORT $LN35@GetDatePer
$LN2@GetDatePer:

; 311  : 		else
; 312  : 			return difftime( tEnd, tStart ) / 60;

  00104	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@404e000000000000
$LN35@GetDatePer:
  0010a	83 c4 10	 add	 esp, 16			; 00000010H
  0010d	e8 00 00 00 00	 call	 __ftol2_sse

; 313  : 	}

  00112	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00115	5f		 pop	 edi
  00116	5e		 pop	 esi
  00117	33 cd		 xor	 ecx, ebp
  00119	5b		 pop	 ebx
  0011a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011f	c9		 leave
  00120	c3		 ret	 0
?GetDatePeriod@DateHelp@@YAHHHHHHHHHHHW4PeriodType@1@@Z ENDP ; DateHelp::GetDatePeriod
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GetWeekDayString@DateHelp@@YAPADH@Z		; DateHelp::GetWeekDayString
; Function compile flags: /Ogsp
;	COMDAT ?GetWeekDayString@DateHelp@@YAPADH@Z
_TEXT	SEGMENT
__$ArrayPad$ = -4					; size = 4
_index$ = 8						; size = 4
?GetWeekDayString@DateHelp@@YAPADH@Z PROC		; DateHelp::GetWeekDayString, COMDAT

; 344  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00009	33 c5		 xor	 eax, ebp
  0000b	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 345  : #ifdef SRC_OVERSEAS
; 346  : 		return weekday( index );

  0000e	ff 75 08	 push	 DWORD PTR _index$[ebp]
  00011	e8 00 00 00 00	 call	 ?weekday@DateHelp@@YAPADH@Z ; DateHelp::weekday
  00016	59		 pop	 ecx

; 347  : #endif
; 348  : 		char a[7][3]={"일", "월", "화", "수", "목", "금", "토"};
; 349  : 		static char b[3]={"일"};
; 350  : 
; 351  : 		if( index >= 7 )  // 예외 처리
; 352  : 			return b;
; 353  : 
; 354  : 		b[0] = a[index][0]; b[1] = a[index][1];
; 355  : 		return b;
; 356  : 	}

  00017	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0001a	33 cd		 xor	 ecx, ebp
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	c9		 leave
  00022	c3		 ret	 0
?GetWeekDayString@DateHelp@@YAPADH@Z ENDP		; DateHelp::GetWeekDayString
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GetWeekDayString@DateHelp@@YAPADHHH@Z		; DateHelp::GetWeekDayString
; Function compile flags: /Ogsp
;	COMDAT ?GetWeekDayString@DateHelp@@YAPADHHH@Z
_TEXT	SEGMENT
__$ArrayPad$ = -4					; size = 4
_num$ = 8						; size = 4
_mon$ = 12						; size = 4
_day$ = 16						; size = 4
?GetWeekDayString@DateHelp@@YAPADHHH@Z PROC		; DateHelp::GetWeekDayString, COMDAT

; 368  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00009	33 c5		 xor	 eax, ebp
  0000b	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0000e	53		 push	 ebx
  0000f	56		 push	 esi
  00010	57		 push	 edi

; 369  : 		int iy=num-1, nal = iy * 365;

  00011	8b 7d 08	 mov	 edi, DWORD PTR _num$[ebp]

; 370  : 
; 371  : 		 // 윤달을 더 해주어서 입력한 앞달까지의 총 일수를 구한다.
; 372  : 		nal += iy/4-iy/100+iy/400;

  00014	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  00017	99		 cdq
  00018	be 90 01 00 00	 mov	 esi, 400		; 00000190H
  0001d	f7 fe		 idiv	 esi
  0001f	6a 64		 push	 100			; 00000064H
  00021	5b		 pop	 ebx
  00022	8b f0		 mov	 esi, eax
  00024	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  00027	69 c0 6d 01 00
	00		 imul	 eax, 365		; 0000016dH
  0002d	03 f0		 add	 esi, eax
  0002f	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  00032	99		 cdq
  00033	f7 fb		 idiv	 ebx

; 373  : 
; 374  : 		for(iy=1; iy<mon; iy++) 

  00035	33 db		 xor	 ebx, ebx
  00037	43		 inc	 ebx
  00038	2b f0		 sub	 esi, eax
  0003a	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  0003d	99		 cdq
  0003e	83 e2 03	 and	 edx, 3
  00041	03 c2		 add	 eax, edx
  00043	c1 f8 02	 sar	 eax, 2
  00046	03 f0		 add	 esi, eax
  00048	39 5d 0c	 cmp	 DWORD PTR _mon$[ebp], ebx
  0004b	7e 11		 jle	 SHORT $LN1@GetWeekDay@2
$LL3@GetWeekDay@2:

; 375  : 		{
; 376  : 			nal +=  GetMonthDayPeriod( num, iy);

  0004d	53		 push	 ebx
  0004e	57		 push	 edi
  0004f	e8 00 00 00 00	 call	 ?GetMonthDayPeriod@DateHelp@@YAHHH@Z ; DateHelp::GetMonthDayPeriod
  00054	03 f0		 add	 esi, eax
  00056	43		 inc	 ebx
  00057	59		 pop	 ecx
  00058	59		 pop	 ecx
  00059	3b 5d 0c	 cmp	 ebx, DWORD PTR _mon$[ebp]
  0005c	7c ef		 jl	 SHORT $LL3@GetWeekDay@2
$LN1@GetWeekDay@2:

; 377  : 		}
; 378  : 
; 379  : 		return GetWeekDayString( ( nal+day ) % 7 );

  0005e	8b 45 10	 mov	 eax, DWORD PTR _day$[ebp]
  00061	03 c6		 add	 eax, esi
  00063	6a 07		 push	 7
  00065	99		 cdq
  00066	59		 pop	 ecx
  00067	f7 f9		 idiv	 ecx
  00069	52		 push	 edx
  0006a	e8 00 00 00 00	 call	 ?weekday@DateHelp@@YAPADH@Z ; DateHelp::weekday
  0006f	59		 pop	 ecx

; 380  : 	}

  00070	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	33 cd		 xor	 ecx, ebp
  00077	5b		 pop	 ebx
  00078	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007d	c9		 leave
  0007e	c3		 ret	 0
?GetWeekDayString@DateHelp@@YAPADHHH@Z ENDP		; DateHelp::GetWeekDayString
_TEXT	ENDS
PUBLIC	?GetWeekDayString@DateHelp@@YAPADK@Z		; DateHelp::GetWeekDayString
; Function compile flags: /Ogsp
;	COMDAT ?GetWeekDayString@DateHelp@@YAPADK@Z
_TEXT	SEGMENT
_dwDate$ = 8						; size = 4
?GetWeekDayString@DateHelp@@YAPADK@Z PROC		; DateHelp::GetWeekDayString, COMDAT

; 359  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 360  : 		int Y = GetDateYear( dwDate );
; 361  : 		int M = GetDateMonth( dwDate );
; 362  : 		int D = GetDateDay( dwDate );

  00003	ff 75 08	 push	 DWORD PTR _dwDate$[ebp]
  00006	e8 00 00 00 00	 call	 ?GetDateDay@DateHelp@@YAHK@Z ; DateHelp::GetDateDay
  0000b	59		 pop	 ecx

; 363  : 
; 364  : 		return GetWeekDayString( Y, M, D );

  0000c	50		 push	 eax
  0000d	ff 75 08	 push	 DWORD PTR _dwDate$[ebp]
  00010	e8 00 00 00 00	 call	 ?GetDateMonth@DateHelp@@YAHK@Z ; DateHelp::GetDateMonth
  00015	59		 pop	 ecx
  00016	50		 push	 eax
  00017	8b 45 08	 mov	 eax, DWORD PTR _dwDate$[ebp]
  0001a	33 d2		 xor	 edx, edx
  0001c	b9 00 e1 f5 05	 mov	 ecx, 100000000		; 05f5e100H
  00021	f7 f1		 div	 ecx
  00023	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?GetWeekDayString@DateHelp@@YAPADHHH@Z ; DateHelp::GetWeekDayString
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 365  : 	}

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?GetWeekDayString@DateHelp@@YAPADK@Z ENDP		; DateHelp::GetWeekDayString
_TEXT	ENDS
END
