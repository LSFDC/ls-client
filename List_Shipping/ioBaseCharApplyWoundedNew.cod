; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\Lost Saga For Developer\Youtube\Tutorial\Source\src\LSClient\ioBaseCharApplyWoundedNew.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_EEM_DS@?$deque@MV?$allocator@M@std@@@std@@2HB	; std::deque<float,std::allocator<float> >::_EEM_DS
PUBLIC	?_VBITS@?$vector@_NV?$allocator@_N@std@@@std@@2HB ; std::vector<bool,std::allocator<bool> >::_VBITS
PUBLIC	?_EEM_DS@?$deque@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@2HB ; std::deque<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_EEM_DS
;	COMDAT ?_EEM_DS@?$deque@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@2HB
CONST	SEGMENT
?_EEM_DS@?$deque@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@2HB DD 01H ; std::deque<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_EEM_DS
CONST	ENDS
;	COMDAT ?_VBITS@?$vector@_NV?$allocator@_N@std@@@std@@2HB
CONST	SEGMENT
?_VBITS@?$vector@_NV?$allocator@_N@std@@@std@@2HB DD 020H ; std::vector<bool,std::allocator<bool> >::_VBITS
CONST	ENDS
;	COMDAT ?_EEM_DS@?$deque@MV?$allocator@M@std@@@std@@2HB
CONST	SEGMENT
?_EEM_DS@?$deque@MV?$allocator@M@std@@@std@@2HB DD 04H	; std::deque<float,std::allocator<float> >::_EEM_DS
CONST	ENDS
PUBLIC	?return1@@YAIXZ					; return1
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stdafx.h
;	COMDAT ?return1@@YAIXZ
_TEXT	SEGMENT
?return1@@YAIXZ PROC					; return1, COMDAT

; 17   : 	__forceinline unsigned int return1() { __asm mov eax, 1 };

  00000	b8 01 00 00 00	 mov	 eax, 1
  00005	c3		 ret	 0
?return1@@YAIXZ ENDP					; return1
_TEXT	ENDS
PUBLIC	?return5@@YAIXZ					; return5
; Function compile flags: /Ogsp
;	COMDAT ?return5@@YAIXZ
_TEXT	SEGMENT
?return5@@YAIXZ PROC					; return5, COMDAT

; 18   : 	__forceinline unsigned int return5() { __asm mov eax, 5 };

  00000	b8 05 00 00 00	 mov	 eax, 5
  00005	c3		 ret	 0
?return5@@YAIXZ ENDP					; return5
_TEXT	ENDS
PUBLIC	?return10@@YAIXZ				; return10
; Function compile flags: /Ogsp
;	COMDAT ?return10@@YAIXZ
_TEXT	SEGMENT
?return10@@YAIXZ PROC					; return10, COMDAT

; 21   : 	__forceinline unsigned int return10() { __asm mov eax, 10 };

  00000	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  00005	c3		 ret	 0
?return10@@YAIXZ ENDP					; return10
_TEXT	ENDS
PUBLIC	?return100@@YAIXZ				; return100
; Function compile flags: /Ogsp
;	COMDAT ?return100@@YAIXZ
_TEXT	SEGMENT
?return100@@YAIXZ PROC					; return100, COMDAT

; 25   : 	__forceinline unsigned int return100() { __asm mov eax, 100 };

  00000	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  00005	c3		 ret	 0
?return100@@YAIXZ ENDP					; return100
_TEXT	ENDS
PUBLIC	?IsOwnerChar@ioBaseChar@@QBE_NXZ		; ioBaseChar::IsOwnerChar
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasechar.h
;	COMDAT ?IsOwnerChar@ioBaseChar@@QBE_NXZ
_TEXT	SEGMENT
?IsOwnerChar@ioBaseChar@@QBE_NXZ PROC			; ioBaseChar::IsOwnerChar, COMDAT
; _this$ = ecx

; 1467 : 	inline bool IsOwnerChar() const { return m_bOwnerChar; }

  00000	8a 81 84 13 00
	00		 mov	 al, BYTE PTR [ecx+4996]
  00006	c3		 ret	 0
?IsOwnerChar@ioBaseChar@@QBE_NXZ ENDP			; ioBaseChar::IsOwnerChar
_TEXT	ENDS
PUBLIC	?IsGangsi@ioBaseChar@@QBE_NXZ			; ioBaseChar::IsGangsi
; Function compile flags: /Ogsp
;	COMDAT ?IsGangsi@ioBaseChar@@QBE_NXZ
_TEXT	SEGMENT
?IsGangsi@ioBaseChar@@QBE_NXZ PROC			; ioBaseChar::IsGangsi, COMDAT
; _this$ = ecx

; 1498 : 	bool IsGangsi() const { return m_bGangsiCharacter; }

  00000	8a 81 f8 23 00
	00		 mov	 al, BYTE PTR [ecx+9208]
  00006	c3		 ret	 0
?IsGangsi@ioBaseChar@@QBE_NXZ ENDP			; ioBaseChar::IsGangsi
_TEXT	ENDS
PUBLIC	?GetBlowStopMotionState@ioBaseChar@@QBE_NXZ	; ioBaseChar::GetBlowStopMotionState
; Function compile flags: /Ogsp
;	COMDAT ?GetBlowStopMotionState@ioBaseChar@@QBE_NXZ
_TEXT	SEGMENT
?GetBlowStopMotionState@ioBaseChar@@QBE_NXZ PROC	; ioBaseChar::GetBlowStopMotionState, COMDAT
; _this$ = ecx

; 1566 : 	inline bool GetBlowStopMotionState() const { return m_bBlowStopMotion; }

  00000	8a 81 c7 15 00
	00		 mov	 al, BYTE PTR [ecx+5575]
  00006	c3		 ret	 0
?GetBlowStopMotionState@ioBaseChar@@QBE_NXZ ENDP	; ioBaseChar::GetBlowStopMotionState
_TEXT	ENDS
PUBLIC	?GetState@ioBaseChar@@QBE?AW4CharState@@XZ	; ioBaseChar::GetState
; Function compile flags: /Ogsp
;	COMDAT ?GetState@ioBaseChar@@QBE?AW4CharState@@XZ
_TEXT	SEGMENT
?GetState@ioBaseChar@@QBE?AW4CharState@@XZ PROC		; ioBaseChar::GetState, COMDAT
; _this$ = ecx

; 2156 : 	inline CharState GetState() const { return m_CharState; }	

  00000	8a 81 10 03 00
	00		 mov	 al, BYTE PTR [ecx+784]
  00006	c3		 ret	 0
?GetState@ioBaseChar@@QBE?AW4CharState@@XZ ENDP		; ioBaseChar::GetState
_TEXT	ENDS
PUBLIC	?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ	; ioBaseChar::GetCharName
; Function compile flags: /Ogsp
;	COMDAT ?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ
_TEXT	SEGMENT
?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ PROC	; ioBaseChar::GetCharName, COMDAT
; _this$ = ecx

; 2594 : 	inline const ioHashString& GetCharName() const { return m_Name; }

  00000	8d 81 d4 02 00
	00		 lea	 eax, DWORD PTR [ecx+724]
  00006	c3		 ret	 0
?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ ENDP	; ioBaseChar::GetCharName
_TEXT	ENDS
PUBLIC	?SetCurJumpPowerAmt@ioBaseChar@@QAEXM@Z		; ioBaseChar::SetCurJumpPowerAmt
EXTRN	__fltused:DWORD
; Function compile flags: /Ogsp
;	COMDAT ?SetCurJumpPowerAmt@ioBaseChar@@QAEXM@Z
_TEXT	SEGMENT
_fAmt$ = 8						; size = 4
?SetCurJumpPowerAmt@ioBaseChar@@QAEXM@Z PROC		; ioBaseChar::SetCurJumpPowerAmt, COMDAT
; _this$ = ecx

; 2628 : 	inline void SetCurJumpPowerAmt( float fAmt ) { m_fCurJumpPowerAmt = fAmt; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fAmt$[ebp]
  00008	f3 0f 11 81 90
	0e 00 00	 movss	 DWORD PTR [ecx+3728], xmm0
  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?SetCurJumpPowerAmt@ioBaseChar@@QAEXM@Z ENDP		; ioBaseChar::SetCurJumpPowerAmt
_TEXT	ENDS
PUBLIC	?SetSuccessJumpAttack@ioBaseChar@@QAEX_N@Z	; ioBaseChar::SetSuccessJumpAttack
; Function compile flags: /Ogsp
;	COMDAT ?SetSuccessJumpAttack@ioBaseChar@@QAEX_N@Z
_TEXT	SEGMENT
_bSuccess$ = 8						; size = 1
?SetSuccessJumpAttack@ioBaseChar@@QAEX_N@Z PROC		; ioBaseChar::SetSuccessJumpAttack, COMDAT
; _this$ = ecx

; 2647 : 	inline void SetSuccessJumpAttack( bool bSuccess ) { m_bSuccessJumpAttack = bSuccess; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8a 45 08	 mov	 al, BYTE PTR _bSuccess$[ebp]
  00006	88 81 a1 0e 00
	00		 mov	 BYTE PTR [ecx+3745], al
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?SetSuccessJumpAttack@ioBaseChar@@QAEX_N@Z ENDP		; ioBaseChar::SetSuccessJumpAttack
_TEXT	ENDS
PUBLIC	?GetLastAttackerName@ioBaseChar@@QBEABVioHashString@@XZ ; ioBaseChar::GetLastAttackerName
; Function compile flags: /Ogsp
;	COMDAT ?GetLastAttackerName@ioBaseChar@@QBEABVioHashString@@XZ
_TEXT	SEGMENT
?GetLastAttackerName@ioBaseChar@@QBEABVioHashString@@XZ PROC ; ioBaseChar::GetLastAttackerName, COMDAT
; _this$ = ecx

; 2770 : 	inline const ioHashString& GetLastAttackerName() const { return m_LastAttackerName; }

  00000	8d 81 ac 13 00
	00		 lea	 eax, DWORD PTR [ecx+5036]
  00006	c3		 ret	 0
?GetLastAttackerName@ioBaseChar@@QBEABVioHashString@@XZ ENDP ; ioBaseChar::GetLastAttackerName
_TEXT	ENDS
PUBLIC	?GetLastAttackerSkillName@ioBaseChar@@QBEABVioHashString@@XZ ; ioBaseChar::GetLastAttackerSkillName
; Function compile flags: /Ogsp
;	COMDAT ?GetLastAttackerSkillName@ioBaseChar@@QBEABVioHashString@@XZ
_TEXT	SEGMENT
?GetLastAttackerSkillName@ioBaseChar@@QBEABVioHashString@@XZ PROC ; ioBaseChar::GetLastAttackerSkillName, COMDAT
; _this$ = ecx

; 2771 : 	inline const ioHashString& GetLastAttackerSkillName() const { return m_LastAttackerSkillName; }

  00000	8d 81 bc 13 00
	00		 lea	 eax, DWORD PTR [ecx+5052]
  00006	c3		 ret	 0
?GetLastAttackerSkillName@ioBaseChar@@QBEABVioHashString@@XZ ENDP ; ioBaseChar::GetLastAttackerSkillName
_TEXT	ENDS
PUBLIC	?GetRandomSeed@ioBaseChar@@QBEKXZ		; ioBaseChar::GetRandomSeed
; Function compile flags: /Ogsp
;	COMDAT ?GetRandomSeed@ioBaseChar@@QBEKXZ
_TEXT	SEGMENT
?GetRandomSeed@ioBaseChar@@QBEKXZ PROC			; ioBaseChar::GetRandomSeed, COMDAT
; _this$ = ecx

; 3372 : 	inline DWORD GetRandomSeed() const { return m_dwRandomSeed; }

  00000	8b 81 74 16 00
	00		 mov	 eax, DWORD PTR [ecx+5748]
  00006	c3		 ret	 0
?GetRandomSeed@ioBaseChar@@QBEKXZ ENDP			; ioBaseChar::GetRandomSeed
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
  00010	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00016	8b c6		 mov	 eax, esi
  00018	5e		 pop	 esi
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogsp
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1exception@std@@UAE@XZ
  00012	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00016	74 07		 je	 SHORT $LN1@scalar
  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001e	59		 pop	 ecx
$LN1@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 56   : 	{	// construct array with placement at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : 	return (_Where);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 58   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogsp
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 62   : 	}

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_R0?AVioWeapon@@@8				; ioWeapon `RTTI Type Descriptor'
PUBLIC	??_R0?AVioContactWeapon@@@8			; ioContactWeapon `RTTI Type Descriptor'
PUBLIC	?ToContactWeapon@@YAPAVioContactWeapon@@PAVioWeapon@@@Z ; ToContactWeapon
EXTRN	___RTDynamicCast:PROC
;	COMDAT ??_R0?AVioWeapon@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iocontactweapon.h
_DATA	SEGMENT
??_R0?AVioWeapon@@@8 DD FLAT:??_7type_info@@6B@		; ioWeapon `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioWeapon@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVioContactWeapon@@@8
_DATA	SEGMENT
??_R0?AVioContactWeapon@@@8 DD FLAT:??_7type_info@@6B@	; ioContactWeapon `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioContactWeapon@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToContactWeapon@@YAPAVioContactWeapon@@PAVioWeapon@@@Z
_TEXT	SEGMENT
_pWeapon$ = 8						; size = 4
?ToContactWeapon@@YAPAVioContactWeapon@@PAVioWeapon@@@Z PROC ; ToContactWeapon, COMDAT

; 96   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 97   : 	if( !pWeapon || pWeapon->GetType() != ioWeapon::WT_CONTACT )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pWeapon$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 28		 je	 SHORT $LN1@ToContactW
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 90 10 01 00
	00		 call	 DWORD PTR [eax+272]
  00015	83 f8 01	 cmp	 eax, 1
  00018	75 19		 jne	 SHORT $LN1@ToContactW

; 99   : 
; 100  : 	return dynamic_cast< ioContactWeapon* >( pWeapon );

  0001a	6a 00		 push	 0
  0001c	68 00 00 00 00	 push	 OFFSET ??_R0?AVioContactWeapon@@@8
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWeapon@@@8
  00026	6a 00		 push	 0
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002e	83 c4 14	 add	 esp, 20			; 00000014H
  00031	eb 02		 jmp	 SHORT $LN3@ToContactW
$LN1@ToContactW:

; 98   : 		return NULL;

  00033	33 c0		 xor	 eax, eax
$LN3@ToContactW:
  00035	5e		 pop	 esi

; 101  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?ToContactWeapon@@YAPAVioContactWeapon@@PAVioWeapon@@@Z ENDP ; ToContactWeapon
_TEXT	ENDS
PUBLIC	??_R0?AVioZoneEffectWeapon@@@8			; ioZoneEffectWeapon `RTTI Type Descriptor'
PUBLIC	?ToZoneEffectWeapon@@YAPAVioZoneEffectWeapon@@PAVioWeapon@@@Z ; ToZoneEffectWeapon
;	COMDAT ??_R0?AVioZoneEffectWeapon@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iozoneeffectweapon.h
_DATA	SEGMENT
??_R0?AVioZoneEffectWeapon@@@8 DD FLAT:??_7type_info@@6B@ ; ioZoneEffectWeapon `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioZoneEffectWeapon@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToZoneEffectWeapon@@YAPAVioZoneEffectWeapon@@PAVioWeapon@@@Z
_TEXT	SEGMENT
_pWeapon$ = 8						; size = 4
?ToZoneEffectWeapon@@YAPAVioZoneEffectWeapon@@PAVioWeapon@@@Z PROC ; ToZoneEffectWeapon, COMDAT

; 217  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 218  : 	if( !pWeapon || pWeapon->GetType() != ioWeapon::WT_ZONE_EFFECT )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pWeapon$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 28		 je	 SHORT $LN1@ToZoneEffe
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 90 10 01 00
	00		 call	 DWORD PTR [eax+272]
  00015	83 f8 08	 cmp	 eax, 8
  00018	75 19		 jne	 SHORT $LN1@ToZoneEffe

; 220  : 
; 221  : 	return dynamic_cast< ioZoneEffectWeapon* >( pWeapon );

  0001a	6a 00		 push	 0
  0001c	68 00 00 00 00	 push	 OFFSET ??_R0?AVioZoneEffectWeapon@@@8
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWeapon@@@8
  00026	6a 00		 push	 0
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002e	83 c4 14	 add	 esp, 20			; 00000014H
  00031	eb 02		 jmp	 SHORT $LN3@ToZoneEffe
$LN1@ToZoneEffe:

; 219  : 		return NULL;

  00033	33 c0		 xor	 eax, eax
$LN3@ToZoneEffe:
  00035	5e		 pop	 esi

; 222  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?ToZoneEffectWeapon@@YAPAVioZoneEffectWeapon@@PAVioWeapon@@@Z ENDP ; ToZoneEffectWeapon
_TEXT	ENDS
PUBLIC	??_R0?AVioAdhesiveMissileWeapon2@@@8		; ioAdhesiveMissileWeapon2 `RTTI Type Descriptor'
PUBLIC	?ToAdhesiveMissileWeapon2@@YAPAVioAdhesiveMissileWeapon2@@PAVioWeapon@@@Z ; ToAdhesiveMissileWeapon2
;	COMDAT ??_R0?AVioAdhesiveMissileWeapon2@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioadhesivemissileweapon2.h
_DATA	SEGMENT
??_R0?AVioAdhesiveMissileWeapon2@@@8 DD FLAT:??_7type_info@@6B@ ; ioAdhesiveMissileWeapon2 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioAdhesiveMissileWeapon2@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToAdhesiveMissileWeapon2@@YAPAVioAdhesiveMissileWeapon2@@PAVioWeapon@@@Z
_TEXT	SEGMENT
_pWeapon$ = 8						; size = 4
?ToAdhesiveMissileWeapon2@@YAPAVioAdhesiveMissileWeapon2@@PAVioWeapon@@@Z PROC ; ToAdhesiveMissileWeapon2, COMDAT

; 140  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 141  : 	if( !pWeapon || pWeapon->GetType() != ioWeapon::WT_ADHESIVE_MISSILE2 )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pWeapon$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 28		 je	 SHORT $LN1@ToAdhesive
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 90 10 01 00
	00		 call	 DWORD PTR [eax+272]
  00015	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00018	75 19		 jne	 SHORT $LN1@ToAdhesive

; 143  : 
; 144  : 	return dynamic_cast< ioAdhesiveMissileWeapon2* >( pWeapon );

  0001a	6a 00		 push	 0
  0001c	68 00 00 00 00	 push	 OFFSET ??_R0?AVioAdhesiveMissileWeapon2@@@8
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWeapon@@@8
  00026	6a 00		 push	 0
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002e	83 c4 14	 add	 esp, 20			; 00000014H
  00031	eb 02		 jmp	 SHORT $LN3@ToAdhesive
$LN1@ToAdhesive:

; 142  : 		return NULL;

  00033	33 c0		 xor	 eax, eax
$LN3@ToAdhesive:
  00035	5e		 pop	 esi

; 145  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?ToAdhesiveMissileWeapon2@@YAPAVioAdhesiveMissileWeapon2@@PAVioWeapon@@@Z ENDP ; ToAdhesiveMissileWeapon2
_TEXT	ENDS
PUBLIC	??_R0?AVioMissileWeapon2@@@8			; ioMissileWeapon2 `RTTI Type Descriptor'
PUBLIC	?ToMissileWeapon2@@YAPAVioMissileWeapon2@@PAVioWeapon@@@Z ; ToMissileWeapon2
;	COMDAT ??_R0?AVioMissileWeapon2@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iomissileweapon2.h
_DATA	SEGMENT
??_R0?AVioMissileWeapon2@@@8 DD FLAT:??_7type_info@@6B@	; ioMissileWeapon2 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioMissileWeapon2@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToMissileWeapon2@@YAPAVioMissileWeapon2@@PAVioWeapon@@@Z
_TEXT	SEGMENT
_pWeapon$ = 8						; size = 4
?ToMissileWeapon2@@YAPAVioMissileWeapon2@@PAVioWeapon@@@Z PROC ; ToMissileWeapon2, COMDAT

; 98   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 99   : 	if( !pWeapon || pWeapon->GetType() != ioWeapon::WT_MISSILE2 )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pWeapon$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 28		 je	 SHORT $LN1@ToMissileW
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 90 10 01 00
	00		 call	 DWORD PTR [eax+272]
  00015	83 f8 32	 cmp	 eax, 50			; 00000032H
  00018	75 19		 jne	 SHORT $LN1@ToMissileW

; 101  : 
; 102  : 	return dynamic_cast< ioMissileWeapon2* >( pWeapon );

  0001a	6a 00		 push	 0
  0001c	68 00 00 00 00	 push	 OFFSET ??_R0?AVioMissileWeapon2@@@8
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWeapon@@@8
  00026	6a 00		 push	 0
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002e	83 c4 14	 add	 esp, 20			; 00000014H
  00031	eb 02		 jmp	 SHORT $LN3@ToMissileW
$LN1@ToMissileW:

; 100  : 		return NULL;

  00033	33 c0		 xor	 eax, eax
$LN3@ToMissileW:
  00035	5e		 pop	 esi

; 103  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?ToMissileWeapon2@@YAPAVioMissileWeapon2@@PAVioWeapon@@@Z ENDP ; ToMissileWeapon2
_TEXT	ENDS
PUBLIC	??_R0?AVioGuide2Weapon@@@8			; ioGuide2Weapon `RTTI Type Descriptor'
PUBLIC	?ToGuide2Weapon@@YAPAVioGuide2Weapon@@PAVioWeapon@@@Z ; ToGuide2Weapon
;	COMDAT ??_R0?AVioGuide2Weapon@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioguide2weapon.h
_DATA	SEGMENT
??_R0?AVioGuide2Weapon@@@8 DD FLAT:??_7type_info@@6B@	; ioGuide2Weapon `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioGuide2Weapon@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToGuide2Weapon@@YAPAVioGuide2Weapon@@PAVioWeapon@@@Z
_TEXT	SEGMENT
_pWeapon$ = 8						; size = 4
?ToGuide2Weapon@@YAPAVioGuide2Weapon@@PAVioWeapon@@@Z PROC ; ToGuide2Weapon, COMDAT

; 127  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 128  : 	if( !pWeapon || pWeapon->GetType() != ioWeapon::WT_GUIDE2 )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pWeapon$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 28		 je	 SHORT $LN1@ToGuide2We
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 90 10 01 00
	00		 call	 DWORD PTR [eax+272]
  00015	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00018	75 19		 jne	 SHORT $LN1@ToGuide2We

; 130  : 
; 131  : 	return dynamic_cast< ioGuide2Weapon* >( pWeapon );

  0001a	6a 00		 push	 0
  0001c	68 00 00 00 00	 push	 OFFSET ??_R0?AVioGuide2Weapon@@@8
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWeapon@@@8
  00026	6a 00		 push	 0
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002e	83 c4 14	 add	 esp, 20			; 00000014H
  00031	eb 02		 jmp	 SHORT $LN3@ToGuide2We
$LN1@ToGuide2We:

; 129  : 		return NULL;

  00033	33 c0		 xor	 eax, eax
$LN3@ToGuide2We:
  00035	5e		 pop	 esi

; 132  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?ToGuide2Weapon@@YAPAVioGuide2Weapon@@PAVioWeapon@@@Z ENDP ; ToGuide2Weapon
_TEXT	ENDS
PUBLIC	??_R0?AVioUroborusWeapon2@@@8			; ioUroborusWeapon2 `RTTI Type Descriptor'
PUBLIC	?ToUroborusWeapon2@@YAPAVioUroborusWeapon2@@PAVioWeapon@@@Z ; ToUroborusWeapon2
;	COMDAT ??_R0?AVioUroborusWeapon2@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iouroborusweapon2.h
_DATA	SEGMENT
??_R0?AVioUroborusWeapon2@@@8 DD FLAT:??_7type_info@@6B@ ; ioUroborusWeapon2 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioUroborusWeapon2@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToUroborusWeapon2@@YAPAVioUroborusWeapon2@@PAVioWeapon@@@Z
_TEXT	SEGMENT
_pWeapon$ = 8						; size = 4
?ToUroborusWeapon2@@YAPAVioUroborusWeapon2@@PAVioWeapon@@@Z PROC ; ToUroborusWeapon2, COMDAT

; 115  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 116  : 	if( !pWeapon || pWeapon->GetType() != ioWeapon::WT_UROBORUS2 )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pWeapon$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 28		 je	 SHORT $LN1@ToUroborus
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 90 10 01 00
	00		 call	 DWORD PTR [eax+272]
  00015	83 f8 30	 cmp	 eax, 48			; 00000030H
  00018	75 19		 jne	 SHORT $LN1@ToUroborus

; 118  : 
; 119  : 	return dynamic_cast< ioUroborusWeapon2* >( pWeapon );

  0001a	6a 00		 push	 0
  0001c	68 00 00 00 00	 push	 OFFSET ??_R0?AVioUroborusWeapon2@@@8
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWeapon@@@8
  00026	6a 00		 push	 0
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002e	83 c4 14	 add	 esp, 20			; 00000014H
  00031	eb 02		 jmp	 SHORT $LN3@ToUroborus
$LN1@ToUroborus:

; 117  : 		return NULL;

  00033	33 c0		 xor	 eax, eax
$LN3@ToUroborus:
  00035	5e		 pop	 esi

; 120  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?ToUroborusWeapon2@@YAPAVioUroborusWeapon2@@PAVioWeapon@@@Z ENDP ; ToUroborusWeapon2
_TEXT	ENDS
PUBLIC	??_R0?AVioUroborusWeapon3@@@8			; ioUroborusWeapon3 `RTTI Type Descriptor'
PUBLIC	?ToUroborusWeapon3@@YAPAVioUroborusWeapon3@@PAVioWeapon@@@Z ; ToUroborusWeapon3
;	COMDAT ??_R0?AVioUroborusWeapon3@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iouroborusweapon3.h
_DATA	SEGMENT
??_R0?AVioUroborusWeapon3@@@8 DD FLAT:??_7type_info@@6B@ ; ioUroborusWeapon3 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioUroborusWeapon3@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToUroborusWeapon3@@YAPAVioUroborusWeapon3@@PAVioWeapon@@@Z
_TEXT	SEGMENT
_pWeapon$ = 8						; size = 4
?ToUroborusWeapon3@@YAPAVioUroborusWeapon3@@PAVioWeapon@@@Z PROC ; ToUroborusWeapon3, COMDAT

; 158  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 159  : 	if( !pWeapon || pWeapon->GetType() != ioWeapon::WT_UROBORUS3 )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pWeapon$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 28		 je	 SHORT $LN1@ToUroborus@2
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 90 10 01 00
	00		 call	 DWORD PTR [eax+272]
  00015	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  00018	75 19		 jne	 SHORT $LN1@ToUroborus@2

; 161  : 
; 162  : 	return dynamic_cast< ioUroborusWeapon3* >( pWeapon );

  0001a	6a 00		 push	 0
  0001c	68 00 00 00 00	 push	 OFFSET ??_R0?AVioUroborusWeapon3@@@8
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWeapon@@@8
  00026	6a 00		 push	 0
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002e	83 c4 14	 add	 esp, 20			; 00000014H
  00031	eb 02		 jmp	 SHORT $LN3@ToUroborus@2
$LN1@ToUroborus@2:

; 160  : 		return NULL;

  00033	33 c0		 xor	 eax, eax
$LN3@ToUroborus@2:
  00035	5e		 pop	 esi

; 163  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?ToUroborusWeapon3@@YAPAVioUroborusWeapon3@@PAVioWeapon@@@Z ENDP ; ToUroborusWeapon3
_TEXT	ENDS
PUBLIC	??_R0?AVioUroborusWeapon4@@@8			; ioUroborusWeapon4 `RTTI Type Descriptor'
PUBLIC	?ToUroborusWeapon4@@YAPAVioUroborusWeapon4@@PAVioWeapon@@@Z ; ToUroborusWeapon4
;	COMDAT ??_R0?AVioUroborusWeapon4@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iouroborusweapon4.h
_DATA	SEGMENT
??_R0?AVioUroborusWeapon4@@@8 DD FLAT:??_7type_info@@6B@ ; ioUroborusWeapon4 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioUroborusWeapon4@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToUroborusWeapon4@@YAPAVioUroborusWeapon4@@PAVioWeapon@@@Z
_TEXT	SEGMENT
_pWeapon$ = 8						; size = 4
?ToUroborusWeapon4@@YAPAVioUroborusWeapon4@@PAVioWeapon@@@Z PROC ; ToUroborusWeapon4, COMDAT

; 157  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 158  : 	if( !pWeapon || pWeapon->GetType() != ioWeapon::WT_UROBORUS4 )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pWeapon$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 28		 je	 SHORT $LN1@ToUroborus@3
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 90 10 01 00
	00		 call	 DWORD PTR [eax+272]
  00015	83 f8 55	 cmp	 eax, 85			; 00000055H
  00018	75 19		 jne	 SHORT $LN1@ToUroborus@3

; 160  : 
; 161  : 	return dynamic_cast< ioUroborusWeapon4* >( pWeapon );

  0001a	6a 00		 push	 0
  0001c	68 00 00 00 00	 push	 OFFSET ??_R0?AVioUroborusWeapon4@@@8
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWeapon@@@8
  00026	6a 00		 push	 0
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002e	83 c4 14	 add	 esp, 20			; 00000014H
  00031	eb 02		 jmp	 SHORT $LN3@ToUroborus@3
$LN1@ToUroborus@3:

; 159  : 		return NULL;

  00033	33 c0		 xor	 eax, eax
$LN3@ToUroborus@3:
  00035	5e		 pop	 esi

; 162  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?ToUroborusWeapon4@@YAPAVioUroborusWeapon4@@PAVioWeapon@@@Z ENDP ; ToUroborusWeapon4
_TEXT	ENDS
PUBLIC	??_R0?AVioUroborusWeapon7@@@8			; ioUroborusWeapon7 `RTTI Type Descriptor'
PUBLIC	?ToUroborusWeapon7@@YAPAVioUroborusWeapon7@@PAVioWeapon@@@Z ; ToUroborusWeapon7
;	COMDAT ??_R0?AVioUroborusWeapon7@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iouroborusweapon7.h
_DATA	SEGMENT
??_R0?AVioUroborusWeapon7@@@8 DD FLAT:??_7type_info@@6B@ ; ioUroborusWeapon7 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioUroborusWeapon7@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToUroborusWeapon7@@YAPAVioUroborusWeapon7@@PAVioWeapon@@@Z
_TEXT	SEGMENT
_pWeapon$ = 8						; size = 4
?ToUroborusWeapon7@@YAPAVioUroborusWeapon7@@PAVioWeapon@@@Z PROC ; ToUroborusWeapon7, COMDAT

; 154  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 155  : 	if( !pWeapon || pWeapon->GetType() != ioWeapon::WT_UROBORUS7 )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pWeapon$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 28		 je	 SHORT $LN1@ToUroborus@4
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 90 10 01 00
	00		 call	 DWORD PTR [eax+272]
  00015	83 f8 6e	 cmp	 eax, 110		; 0000006eH
  00018	75 19		 jne	 SHORT $LN1@ToUroborus@4

; 157  : 
; 158  : 	return dynamic_cast< ioUroborusWeapon7* >( pWeapon );

  0001a	6a 00		 push	 0
  0001c	68 00 00 00 00	 push	 OFFSET ??_R0?AVioUroborusWeapon7@@@8
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWeapon@@@8
  00026	6a 00		 push	 0
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002e	83 c4 14	 add	 esp, 20			; 00000014H
  00031	eb 02		 jmp	 SHORT $LN3@ToUroborus@4
$LN1@ToUroborus@4:

; 156  : 		return NULL;

  00033	33 c0		 xor	 eax, eax
$LN3@ToUroborus@4:
  00035	5e		 pop	 esi

; 159  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?ToUroborusWeapon7@@YAPAVioUroborusWeapon7@@PAVioWeapon@@@Z ENDP ; ToUroborusWeapon7
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx9math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR3@@QAE@XZ PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 165  :     D3DXVECTOR3() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
PUBLIC	??0D3DXQUATERNION@@QAE@XZ			; D3DXQUATERNION::D3DXQUATERNION
; Function compile flags: /Ogsp
;	COMDAT ??0D3DXQUATERNION@@QAE@XZ
_TEXT	SEGMENT
??0D3DXQUATERNION@@QAE@XZ PROC				; D3DXQUATERNION::D3DXQUATERNION, COMDAT
; _this$ = ecx

; 429  :     D3DXQUATERNION() {}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXQUATERNION@@QAE@XZ ENDP				; D3DXQUATERNION::D3DXQUATERNION
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx9math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 303  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 304  :     x = fx;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00008	8b c1		 mov	 eax, ecx
  0000a	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 305  :     y = fy;

  0000e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00013	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 306  :     z = fz;

  00018	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0001d	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 307  : }

  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
PUBLIC	??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z			; D3DXVECTOR3::operator-
; Function compile flags: /Ogsp
;	COMDAT ??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z PROC			; D3DXVECTOR3::operator-, COMDAT
; _this$ = ecx

; 386  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 387  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00006	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0000a	f3 0f 10 0a	 movss	 xmm1, DWORD PTR [edx]
  0000e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00011	0f 5a c0	 cvtps2pd xmm0, xmm0
  00014	0f 5a c9	 cvtps2pd xmm1, xmm1
  00017	f2 0f 5c c1	 subsd	 xmm0, xmm1
  0001b	f3 0f 10 4a 04	 movss	 xmm1, DWORD PTR [edx+4]
  00020	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00024	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00028	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0002d	0f 5a c0	 cvtps2pd xmm0, xmm0
  00030	0f 5a c9	 cvtps2pd xmm1, xmm1
  00033	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00037	f3 0f 10 4a 08	 movss	 xmm1, DWORD PTR [edx+8]
  0003c	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00040	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  00045	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  0004a	0f 5a c0	 cvtps2pd xmm0, xmm0
  0004d	0f 5a c9	 cvtps2pd xmm1, xmm1
  00050	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00054	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00058	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 388  : }

  0005d	5d		 pop	 ebp
  0005e	c2 08 00	 ret	 8
??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator-
_TEXT	ENDS
PUBLIC	??8D3DXVECTOR3@@QBEHABU0@@Z			; D3DXVECTOR3::operator==
; Function compile flags: /Ogsp
;	COMDAT ??8D3DXVECTOR3@@QBEHABU0@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
??8D3DXVECTOR3@@QBEHABU0@@Z PROC			; D3DXVECTOR3::operator==, COMDAT
; _this$ = ecx

; 413  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 414  :     return x == v.x && y == v.y && z == v.z;

  00003	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  00006	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0000a	f3 0f 10 0a	 movss	 xmm1, DWORD PTR [edx]
  0000e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00011	0f 5a c9	 cvtps2pd xmm1, xmm1
  00014	66 0f 2e c1	 ucomisd xmm0, xmm1
  00018	9f		 lahf
  00019	f6 c4 44	 test	 ah, 68			; 00000044H
  0001c	7a 39		 jp	 SHORT $LN3@operator
  0001e	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  00023	f3 0f 10 4a 04	 movss	 xmm1, DWORD PTR [edx+4]
  00028	0f 5a c0	 cvtps2pd xmm0, xmm0
  0002b	0f 5a c9	 cvtps2pd xmm1, xmm1
  0002e	66 0f 2e c1	 ucomisd xmm0, xmm1
  00032	9f		 lahf
  00033	f6 c4 44	 test	 ah, 68			; 00000044H
  00036	7a 1f		 jp	 SHORT $LN3@operator
  00038	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  0003d	f3 0f 10 4a 08	 movss	 xmm1, DWORD PTR [edx+8]
  00042	0f 5a c0	 cvtps2pd xmm0, xmm0
  00045	0f 5a c9	 cvtps2pd xmm1, xmm1
  00048	66 0f 2e c1	 ucomisd xmm0, xmm1
  0004c	9f		 lahf
  0004d	f6 c4 44	 test	 ah, 68			; 00000044H
  00050	7a 05		 jp	 SHORT $LN3@operator
  00052	33 c0		 xor	 eax, eax
  00054	40		 inc	 eax
  00055	eb 02		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00057	33 c0		 xor	 eax, eax
$LN4@operator:

; 415  : }

  00059	5d		 pop	 ebp
  0005a	c2 04 00	 ret	 4
??8D3DXVECTOR3@@QBEHABU0@@Z ENDP			; D3DXVECTOR3::operator==
_TEXT	ENDS
PUBLIC	??9D3DXVECTOR3@@QBEHABU0@@Z			; D3DXVECTOR3::operator!=
; Function compile flags: /Ogsp
;	COMDAT ??9D3DXVECTOR3@@QBEHABU0@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
??9D3DXVECTOR3@@QBEHABU0@@Z PROC			; D3DXVECTOR3::operator!=, COMDAT
; _this$ = ecx

; 419  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 420  :     return x != v.x || y != v.y || z != v.z;

  00003	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  00006	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0000a	f3 0f 10 0a	 movss	 xmm1, DWORD PTR [edx]
  0000e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00011	0f 5a c9	 cvtps2pd xmm1, xmm1
  00014	66 0f 2e c1	 ucomisd xmm0, xmm1
  00018	9f		 lahf
  00019	f6 c4 44	 test	 ah, 68			; 00000044H
  0001c	7a 38		 jp	 SHORT $LN3@operator@2
  0001e	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  00023	f3 0f 10 4a 04	 movss	 xmm1, DWORD PTR [edx+4]
  00028	0f 5a c0	 cvtps2pd xmm0, xmm0
  0002b	0f 5a c9	 cvtps2pd xmm1, xmm1
  0002e	66 0f 2e c1	 ucomisd xmm0, xmm1
  00032	9f		 lahf
  00033	f6 c4 44	 test	 ah, 68			; 00000044H
  00036	7a 1e		 jp	 SHORT $LN3@operator@2
  00038	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  0003d	f3 0f 10 4a 08	 movss	 xmm1, DWORD PTR [edx+8]
  00042	0f 5a c0	 cvtps2pd xmm0, xmm0
  00045	0f 5a c9	 cvtps2pd xmm1, xmm1
  00048	66 0f 2e c1	 ucomisd xmm0, xmm1
  0004c	9f		 lahf
  0004d	f6 c4 44	 test	 ah, 68			; 00000044H
  00050	7a 04		 jp	 SHORT $LN3@operator@2
  00052	33 c0		 xor	 eax, eax
  00054	eb 03		 jmp	 SHORT $LN4@operator@2
$LN3@operator@2:
  00056	33 c0		 xor	 eax, eax
  00058	40		 inc	 eax
$LN4@operator@2:

; 421  : }

  00059	5d		 pop	 ebp
  0005a	c2 04 00	 ret	 4
??9D3DXVECTOR3@@QBEHABU0@@Z ENDP			; D3DXVECTOR3::operator!=
_TEXT	ENDS
PUBLIC	?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z	; D3DXVec3Cross
; Function compile flags: /Ogsp
;	COMDAT ?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z
_TEXT	SEGMENT
_v$ = -12						; size = 12
_pOut$ = 8						; size = 4
_pV1$ = 12						; size = 4
_pV2$ = 16						; size = 4
?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z PROC	; D3DXVec3Cross, COMDAT

; 1747 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1757 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;
; 1758 : 
; 1759 :     *pOut = v;

  00006	56		 push	 esi
  00007	57		 push	 edi

; 1748 :     D3DXVECTOR3 v;
; 1749 : 
; 1750 : #ifdef D3DX_DEBUG
; 1751 :     if(!pOut || !pV1 || !pV2)
; 1752 :         return NULL;
; 1753 : #endif
; 1754 : 
; 1755 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00008	8b 45 0c	 mov	 eax, DWORD PTR _pV1$[ebp]
  0000b	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00010	f3 0f 10 50 08	 movss	 xmm2, DWORD PTR [eax+8]
  00015	8b 4d 10	 mov	 ecx, DWORD PTR _pV2$[ebp]
  00018	f3 0f 10 49 08	 movss	 xmm1, DWORD PTR [ecx+8]
  0001d	f3 0f 10 59 04	 movss	 xmm3, DWORD PTR [ecx+4]
  00022	0f 5a e8	 cvtps2pd xmm5, xmm0
  00025	0f 5a e1	 cvtps2pd xmm4, xmm1
  00028	0f 5a f2	 cvtps2pd xmm6, xmm2
  0002b	f2 0f 59 e5	 mulsd	 xmm4, xmm5

; 1756 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  0002f	0f 5a d2	 cvtps2pd xmm2, xmm2
  00032	0f 5a c9	 cvtps2pd xmm1, xmm1
  00035	0f 5a eb	 cvtps2pd xmm5, xmm3
  00038	f2 0f 59 ee	 mulsd	 xmm5, xmm6
  0003c	f2 0f 5c e5	 subsd	 xmm4, xmm5
  00040	f3 0f 10 28	 movss	 xmm5, DWORD PTR [eax]

; 1757 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;
; 1758 : 
; 1759 :     *pOut = v;

  00044	8b 45 08	 mov	 eax, DWORD PTR _pOut$[ebp]
  00047	66 0f 5a e4	 cvtpd2ps xmm4, xmm4
  0004b	f3 0f 11 65 f4	 movss	 DWORD PTR _v$[ebp], xmm4
  00050	f3 0f 10 21	 movss	 xmm4, DWORD PTR [ecx]
  00054	0f 5a f4	 cvtps2pd xmm6, xmm4
  00057	f2 0f 59 f2	 mulsd	 xmm6, xmm2
  0005b	0f 5a d5	 cvtps2pd xmm2, xmm5
  0005e	f2 0f 59 d1	 mulsd	 xmm2, xmm1
  00062	f2 0f 5c f2	 subsd	 xmm6, xmm2
  00066	66 0f 5a ce	 cvtpd2ps xmm1, xmm6
  0006a	f3 0f 11 4d f8	 movss	 DWORD PTR _v$[ebp+4], xmm1
  0006f	0f 5a c0	 cvtps2pd xmm0, xmm0
  00072	0f 5a d3	 cvtps2pd xmm2, xmm3
  00075	0f 5a cd	 cvtps2pd xmm1, xmm5
  00078	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  0007c	8d 75 f4	 lea	 esi, DWORD PTR _v$[ebp]
  0007f	8b f8		 mov	 edi, eax
  00081	0f 5a d4	 cvtps2pd xmm2, xmm4
  00084	f2 0f 59 d0	 mulsd	 xmm2, xmm0
  00088	f2 0f 5c ca	 subsd	 xmm1, xmm2
  0008c	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  00090	f3 0f 11 45 fc	 movss	 DWORD PTR _v$[ebp+8], xmm0
  00095	a5		 movsd
  00096	a5		 movsd
  00097	a5		 movsd
  00098	5f		 pop	 edi
  00099	5e		 pop	 esi

; 1760 :     return pOut;
; 1761 : }

  0009a	c9		 leave
  0009b	c3		 ret	 0
?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z ENDP	; D3DXVec3Cross
_TEXT	ENDS
PUBLIC	??_R0?AVioExtendJump@@@8			; ioExtendJump `RTTI Type Descriptor'
PUBLIC	??_R0?AVioChargeComboJump3@@@8			; ioChargeComboJump3 `RTTI Type Descriptor'
PUBLIC	?ToChargeComboJump3@@YAPAVioChargeComboJump3@@PAVioExtendJump@@@Z ; ToChargeComboJump3
;	COMDAT ??_R0?AVioExtendJump@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iochargecombojump3.h
_DATA	SEGMENT
??_R0?AVioExtendJump@@@8 DD FLAT:??_7type_info@@6B@	; ioExtendJump `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioExtendJump@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVioChargeComboJump3@@@8
_DATA	SEGMENT
??_R0?AVioChargeComboJump3@@@8 DD FLAT:??_7type_info@@6B@ ; ioChargeComboJump3 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioChargeComboJump3@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToChargeComboJump3@@YAPAVioChargeComboJump3@@PAVioExtendJump@@@Z
_TEXT	SEGMENT
_pJump$ = 8						; size = 4
?ToChargeComboJump3@@YAPAVioChargeComboJump3@@PAVioExtendJump@@@Z PROC ; ToChargeComboJump3, COMDAT

; 604  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 605  : 	if( !pJump || pJump->GetType() != JT_CHARGE_COMBO3 )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pJump$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 25		 je	 SHORT $LN1@ToChargeCo
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 50 08	 call	 DWORD PTR [eax+8]
  00012	83 f8 13	 cmp	 eax, 19			; 00000013H
  00015	75 19		 jne	 SHORT $LN1@ToChargeCo

; 607  : 
; 608  : 	return dynamic_cast< ioChargeComboJump3* >( pJump );

  00017	6a 00		 push	 0
  00019	68 00 00 00 00	 push	 OFFSET ??_R0?AVioChargeComboJump3@@@8
  0001e	68 00 00 00 00	 push	 OFFSET ??_R0?AVioExtendJump@@@8
  00023	6a 00		 push	 0
  00025	56		 push	 esi
  00026	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002b	83 c4 14	 add	 esp, 20			; 00000014H
  0002e	eb 02		 jmp	 SHORT $LN3@ToChargeCo
$LN1@ToChargeCo:

; 606  : 		return NULL;

  00030	33 c0		 xor	 eax, eax
$LN3@ToChargeCo:
  00032	5e		 pop	 esi

; 609  : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?ToChargeComboJump3@@YAPAVioChargeComboJump3@@PAVioExtendJump@@@Z ENDP ; ToChargeComboJump3
_TEXT	ENDS
PUBLIC	?GetFrozenType@ioFrozenBuff@@QBE?AW4FrozenType@1@XZ ; ioFrozenBuff::GetFrozenType
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iofrozenbuff.h
;	COMDAT ?GetFrozenType@ioFrozenBuff@@QBE?AW4FrozenType@1@XZ
_TEXT	SEGMENT
?GetFrozenType@ioFrozenBuff@@QBE?AW4FrozenType@1@XZ PROC ; ioFrozenBuff::GetFrozenType, COMDAT
; _this$ = ecx

; 58   : 	inline FrozenType GetFrozenType() const { return m_FrozenType; }

  00000	8b 81 74 09 00
	00		 mov	 eax, DWORD PTR [ecx+2420]
  00006	c3		 ret	 0
?GetFrozenType@ioFrozenBuff@@QBE?AW4FrozenType@1@XZ ENDP ; ioFrozenBuff::GetFrozenType
_TEXT	ENDS
PUBLIC	?IsNoEmoticon@ioStateProtectionBuff@@QBE?B_NXZ	; ioStateProtectionBuff::IsNoEmoticon
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iostateprotectionbuff.h
;	COMDAT ?IsNoEmoticon@ioStateProtectionBuff@@QBE?B_NXZ
_TEXT	SEGMENT
?IsNoEmoticon@ioStateProtectionBuff@@QBE?B_NXZ PROC	; ioStateProtectionBuff::IsNoEmoticon, COMDAT
; _this$ = ecx

; 54   : 	inline const bool IsNoEmoticon() const { return m_bNoEmoticon; }

  00000	8a 81 1d 0a 00
	00		 mov	 al, BYTE PTR [ecx+2589]
  00006	c3		 ret	 0
?IsNoEmoticon@ioStateProtectionBuff@@QBE?B_NXZ ENDP	; ioStateProtectionBuff::IsNoEmoticon
_TEXT	ENDS
PUBLIC	?GetCallBuffName@ioCallBuffOnAttackBuff2@@QBEABVioHashString@@XZ ; ioCallBuffOnAttackBuff2::GetCallBuffName
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iocallbuffonattackbuff2.h
;	COMDAT ?GetCallBuffName@ioCallBuffOnAttackBuff2@@QBEABVioHashString@@XZ
_TEXT	SEGMENT
?GetCallBuffName@ioCallBuffOnAttackBuff2@@QBEABVioHashString@@XZ PROC ; ioCallBuffOnAttackBuff2::GetCallBuffName, COMDAT
; _this$ = ecx

; 30   : 	inline const ioHashString& GetCallBuffName() const { return m_CallBuffName; }

  00000	8d 81 70 09 00
	00		 lea	 eax, DWORD PTR [ecx+2416]
  00006	c3		 ret	 0
?GetCallBuffName@ioCallBuffOnAttackBuff2@@QBEABVioHashString@@XZ ENDP ; ioCallBuffOnAttackBuff2::GetCallBuffName
_TEXT	ENDS
PUBLIC	?GetPushPowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ ; ioAffectWoundedValueBuff::GetPushPowerRate
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioaffectwoundedvaluebuff.h
;	COMDAT ?GetPushPowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ
_TEXT	SEGMENT
?GetPushPowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ PROC ; ioAffectWoundedValueBuff::GetPushPowerRate, COMDAT
; _this$ = ecx

; 71   : 	const float GetPushPowerRate()		{ return m_PushPower.m_fRate; }

  00000	d9 81 74 09 00
	00		 fld	 DWORD PTR [ecx+2420]
  00006	c3		 ret	 0
?GetPushPowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ ENDP ; ioAffectWoundedValueBuff::GetPushPowerRate
_TEXT	ENDS
PUBLIC	?GetAirPushPowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ ; ioAffectWoundedValueBuff::GetAirPushPowerRate
; Function compile flags: /Ogsp
;	COMDAT ?GetAirPushPowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ
_TEXT	SEGMENT
?GetAirPushPowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ PROC ; ioAffectWoundedValueBuff::GetAirPushPowerRate, COMDAT
; _this$ = ecx

; 72   : 	const float GetAirPushPowerRate()	{ return m_AirPushPower.m_fRate; }

  00000	d9 81 80 09 00
	00		 fld	 DWORD PTR [ecx+2432]
  00006	c3		 ret	 0
?GetAirPushPowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ ENDP ; ioAffectWoundedValueBuff::GetAirPushPowerRate
_TEXT	ENDS
PUBLIC	?GetDownPushPowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ ; ioAffectWoundedValueBuff::GetDownPushPowerRate
; Function compile flags: /Ogsp
;	COMDAT ?GetDownPushPowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ
_TEXT	SEGMENT
?GetDownPushPowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ PROC ; ioAffectWoundedValueBuff::GetDownPushPowerRate, COMDAT
; _this$ = ecx

; 73   : 	const float GetDownPushPowerRate()	{ return m_DownPushPower.m_fRate; }

  00000	d9 81 8c 09 00
	00		 fld	 DWORD PTR [ecx+2444]
  00006	c3		 ret	 0
?GetDownPushPowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ ENDP ; ioAffectWoundedValueBuff::GetDownPushPowerRate
_TEXT	ENDS
PUBLIC	?GetBlowPowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ ; ioAffectWoundedValueBuff::GetBlowPowerRate
; Function compile flags: /Ogsp
;	COMDAT ?GetBlowPowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ
_TEXT	SEGMENT
?GetBlowPowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ PROC ; ioAffectWoundedValueBuff::GetBlowPowerRate, COMDAT
; _this$ = ecx

; 75   : 	const float GetBlowPowerRate()		{ return m_BlowPower.m_fRate; }

  00000	d9 81 98 09 00
	00		 fld	 DWORD PTR [ecx+2456]
  00006	c3		 ret	 0
?GetBlowPowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ ENDP ; ioAffectWoundedValueBuff::GetBlowPowerRate
_TEXT	ENDS
PUBLIC	?GetAirBlowPowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ ; ioAffectWoundedValueBuff::GetAirBlowPowerRate
; Function compile flags: /Ogsp
;	COMDAT ?GetAirBlowPowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ
_TEXT	SEGMENT
?GetAirBlowPowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ PROC ; ioAffectWoundedValueBuff::GetAirBlowPowerRate, COMDAT
; _this$ = ecx

; 76   : 	const float GetAirBlowPowerRate()	{ return m_AirBlowPower.m_fRate; }

  00000	d9 81 a4 09 00
	00		 fld	 DWORD PTR [ecx+2468]
  00006	c3		 ret	 0
?GetAirBlowPowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ ENDP ; ioAffectWoundedValueBuff::GetAirBlowPowerRate
_TEXT	ENDS
PUBLIC	?GetDownBlowPowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ ; ioAffectWoundedValueBuff::GetDownBlowPowerRate
; Function compile flags: /Ogsp
;	COMDAT ?GetDownBlowPowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ
_TEXT	SEGMENT
?GetDownBlowPowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ PROC ; ioAffectWoundedValueBuff::GetDownBlowPowerRate, COMDAT
; _this$ = ecx

; 77   : 	const float GetDownBlowPowerRate()	{ return m_DownBlowPower.m_fRate; }

  00000	d9 81 b0 09 00
	00		 fld	 DWORD PTR [ecx+2480]
  00006	c3		 ret	 0
?GetDownBlowPowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ ENDP ; ioAffectWoundedValueBuff::GetDownBlowPowerRate
_TEXT	ENDS
PUBLIC	?GetBoundJumpPowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ ; ioAffectWoundedValueBuff::GetBoundJumpPowerRate
; Function compile flags: /Ogsp
;	COMDAT ?GetBoundJumpPowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ
_TEXT	SEGMENT
?GetBoundJumpPowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ PROC ; ioAffectWoundedValueBuff::GetBoundJumpPowerRate, COMDAT
; _this$ = ecx

; 79   : 	const float GetBoundJumpPowerRate()	{ return m_BoundJumpPower.m_fRate; }

  00000	d9 81 bc 09 00
	00		 fld	 DWORD PTR [ecx+2492]
  00006	c3		 ret	 0
?GetBoundJumpPowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ ENDP ; ioAffectWoundedValueBuff::GetBoundJumpPowerRate
_TEXT	ENDS
PUBLIC	?GetBoundForcePowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ ; ioAffectWoundedValueBuff::GetBoundForcePowerRate
; Function compile flags: /Ogsp
;	COMDAT ?GetBoundForcePowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ
_TEXT	SEGMENT
?GetBoundForcePowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ PROC ; ioAffectWoundedValueBuff::GetBoundForcePowerRate, COMDAT
; _this$ = ecx

; 80   : 	const float GetBoundForcePowerRate(){ return m_BoundForcePower.m_fRate; }

  00000	d9 81 c8 09 00
	00		 fld	 DWORD PTR [ecx+2504]
  00006	c3		 ret	 0
?GetBoundForcePowerRate@ioAffectWoundedValueBuff@@QAE?BMXZ ENDP ; ioAffectWoundedValueBuff::GetBoundForcePowerRate
_TEXT	ENDS
PUBLIC	?GetBoundGravityRate@ioAffectWoundedValueBuff@@QAE?BMXZ ; ioAffectWoundedValueBuff::GetBoundGravityRate
; Function compile flags: /Ogsp
;	COMDAT ?GetBoundGravityRate@ioAffectWoundedValueBuff@@QAE?BMXZ
_TEXT	SEGMENT
?GetBoundGravityRate@ioAffectWoundedValueBuff@@QAE?BMXZ PROC ; ioAffectWoundedValueBuff::GetBoundGravityRate, COMDAT
; _this$ = ecx

; 81   : 	const float GetBoundGravityRate()	{ return m_BoundGravity.m_fRate; }

  00000	d9 81 d4 09 00
	00		 fld	 DWORD PTR [ecx+2516]
  00006	c3		 ret	 0
?GetBoundGravityRate@ioAffectWoundedValueBuff@@QAE?BMXZ ENDP ; ioAffectWoundedValueBuff::GetBoundGravityRate
_TEXT	ENDS
PUBLIC	?GetBoundDamageRate@ioAffectWoundedValueBuff@@QAE?BMXZ ; ioAffectWoundedValueBuff::GetBoundDamageRate
; Function compile flags: /Ogsp
;	COMDAT ?GetBoundDamageRate@ioAffectWoundedValueBuff@@QAE?BMXZ
_TEXT	SEGMENT
?GetBoundDamageRate@ioAffectWoundedValueBuff@@QAE?BMXZ PROC ; ioAffectWoundedValueBuff::GetBoundDamageRate, COMDAT
; _this$ = ecx

; 82   : 	const float GetBoundDamageRate()	{ return m_BoundDamage.m_fRate; }

  00000	d9 81 e0 09 00
	00		 fld	 DWORD PTR [ecx+2528]
  00006	c3		 ret	 0
?GetBoundDamageRate@ioAffectWoundedValueBuff@@QAE?BMXZ ENDP ; ioAffectWoundedValueBuff::GetBoundDamageRate
_TEXT	ENDS
PUBLIC	?GetDamageRate@ioAffectWoundedValueBuff@@QAE?BMXZ ; ioAffectWoundedValueBuff::GetDamageRate
; Function compile flags: /Ogsp
;	COMDAT ?GetDamageRate@ioAffectWoundedValueBuff@@QAE?BMXZ
_TEXT	SEGMENT
?GetDamageRate@ioAffectWoundedValueBuff@@QAE?BMXZ PROC	; ioAffectWoundedValueBuff::GetDamageRate, COMDAT
; _this$ = ecx

; 84   : 	const float GetDamageRate()			{ return m_Damage.m_fRate; }

  00000	d9 81 ec 09 00
	00		 fld	 DWORD PTR [ecx+2540]
  00006	c3		 ret	 0
?GetDamageRate@ioAffectWoundedValueBuff@@QAE?BMXZ ENDP	; ioAffectWoundedValueBuff::GetDamageRate
_TEXT	ENDS
PUBLIC	?GetPlayMode@ioPlayStage@@QBEPAVioPlayMode@@XZ	; ioPlayStage::GetPlayMode
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioplaystage.h
;	COMDAT ?GetPlayMode@ioPlayStage@@QBEPAVioPlayMode@@XZ
_TEXT	SEGMENT
?GetPlayMode@ioPlayStage@@QBEPAVioPlayMode@@XZ PROC	; ioPlayStage::GetPlayMode, COMDAT
; _this$ = ecx

; 780  : 	inline ioPlayMode* GetPlayMode() const { return m_pPlayMode; }

  00000	8b 81 10 01 00
	00		 mov	 eax, DWORD PTR [ecx+272]
  00006	c3		 ret	 0
?GetPlayMode@ioPlayStage@@QBEPAVioPlayMode@@XZ ENDP	; ioPlayStage::GetPlayMode
_TEXT	ENDS
PUBLIC	?SetDamage@ioTargetMissile2Skill@@QAEX_N@Z	; ioTargetMissile2Skill::SetDamage
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iotargetmissile2skill.h
;	COMDAT ?SetDamage@ioTargetMissile2Skill@@QAEX_N@Z
_TEXT	SEGMENT
_bDamage$ = 8						; size = 1
?SetDamage@ioTargetMissile2Skill@@QAEX_N@Z PROC		; ioTargetMissile2Skill::SetDamage, COMDAT
; _this$ = ecx

; 176  : 	void SetDamage( bool bDamage ){ m_bDamage = bDamage;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8a 45 08	 mov	 al, BYTE PTR _bDamage$[ebp]
  00006	88 81 48 15 00
	00		 mov	 BYTE PTR [ecx+5448], al
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?SetDamage@ioTargetMissile2Skill@@QAEX_N@Z ENDP		; ioTargetMissile2Skill::SetDamage
_TEXT	ENDS
PUBLIC	?GetNpcProtectType@ioNpcChar@@QBEHXZ		; ioNpcChar::GetNpcProtectType
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ionpcchar.h
;	COMDAT ?GetNpcProtectType@ioNpcChar@@QBEHXZ
_TEXT	SEGMENT
?GetNpcProtectType@ioNpcChar@@QBEHXZ PROC		; ioNpcChar::GetNpcProtectType, COMDAT
; _this$ = ecx

; 295  : 	int  GetNpcProtectType() const { return m_nNpcProtectType; }

  00000	8b 81 a0 47 00
	00		 mov	 eax, DWORD PTR [ecx+18336]
  00006	c3		 ret	 0
?GetNpcProtectType@ioNpcChar@@QBEHXZ ENDP		; ioNpcChar::GetNpcProtectType
_TEXT	ENDS
PUBLIC	?GetType@ioGrowthUpInfo@@QBE?AW4GrowthType@@XZ	; ioGrowthUpInfo::GetType
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iogrowthupinfo.h
;	COMDAT ?GetType@ioGrowthUpInfo@@QBE?AW4GrowthType@@XZ
_TEXT	SEGMENT
?GetType@ioGrowthUpInfo@@QBE?AW4GrowthType@@XZ PROC	; ioGrowthUpInfo::GetType, COMDAT
; _this$ = ecx

; 23   : 	inline GrowthType GetType() const { return m_GrowthType; }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetType@ioGrowthUpInfo@@QBE?AW4GrowthType@@XZ ENDP	; ioGrowthUpInfo::GetType
_TEXT	ENDS
PUBLIC	??_R0?AVioGrowthUpInfo@@@8			; ioGrowthUpInfo `RTTI Type Descriptor'
PUBLIC	??_R0?AVioGrowthNormalUpInfo@@@8		; ioGrowthNormalUpInfo `RTTI Type Descriptor'
PUBLIC	?ToNormalUpInfo@@YAPAVioGrowthNormalUpInfo@@PAVioGrowthUpInfo@@@Z ; ToNormalUpInfo
;	COMDAT ??_R0?AVioGrowthUpInfo@@@8
_DATA	SEGMENT
??_R0?AVioGrowthUpInfo@@@8 DD FLAT:??_7type_info@@6B@	; ioGrowthUpInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioGrowthUpInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVioGrowthNormalUpInfo@@@8
_DATA	SEGMENT
??_R0?AVioGrowthNormalUpInfo@@@8 DD FLAT:??_7type_info@@6B@ ; ioGrowthNormalUpInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioGrowthNormalUpInfo@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToNormalUpInfo@@YAPAVioGrowthNormalUpInfo@@PAVioGrowthUpInfo@@@Z
_TEXT	SEGMENT
_pUpInfo$ = 8						; size = 4
?ToNormalUpInfo@@YAPAVioGrowthNormalUpInfo@@PAVioGrowthUpInfo@@@Z PROC ; ToNormalUpInfo, COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 60   : 	if( !pUpInfo || pUpInfo->GetType() == GT_NONE )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pUpInfo$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 39		 je	 SHORT $LN6@ToNormalUp
  0000a	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0000d	85 c0		 test	 eax, eax
  0000f	74 32		 je	 SHORT $LN6@ToNormalUp

; 62   : 
; 63   : 	if( pUpInfo->GetType() == GT_CHAR_ATTACK || pUpInfo->GetType() == GT_SKILL_ATTACK )

  00011	83 f8 01	 cmp	 eax, 1
  00014	74 2d		 je	 SHORT $LN6@ToNormalUp
  00016	83 f8 07	 cmp	 eax, 7
  00019	74 28		 je	 SHORT $LN6@ToNormalUp

; 64   : 		return NULL;
; 65   : 	if( pUpInfo->GetType() == GT_BLOW_PUSH )

  0001b	83 f8 1e	 cmp	 eax, 30			; 0000001eH

; 66   : 		return NULL;

  0001e	74 23		 je	 SHORT $LN6@ToNormalUp

; 67   : 	if( pUpInfo->GetType() == GT_TELEPORT_ANI_RATE )

  00020	83 f8 20	 cmp	 eax, 32			; 00000020H

; 68   : 		return NULL;

  00023	74 1e		 je	 SHORT $LN6@ToNormalUp

; 69   : 	if( pUpInfo->GetType() == GT_SKILL_ATTACK_FORCE )

  00025	83 f8 1c	 cmp	 eax, 28			; 0000001cH

; 70   : 		return NULL;

  00028	74 19		 je	 SHORT $LN6@ToNormalUp

; 71   : 
; 72   : 	return dynamic_cast< ioGrowthNormalUpInfo* >( pUpInfo );

  0002a	6a 00		 push	 0
  0002c	68 00 00 00 00	 push	 OFFSET ??_R0?AVioGrowthNormalUpInfo@@@8
  00031	68 00 00 00 00	 push	 OFFSET ??_R0?AVioGrowthUpInfo@@@8
  00036	6a 00		 push	 0
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ___RTDynamicCast
  0003e	83 c4 14	 add	 esp, 20			; 00000014H

; 73   : }

  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
$LN6@ToNormalUp:

; 61   : 		return NULL;

  00043	33 c0		 xor	 eax, eax

; 73   : }

  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?ToNormalUpInfo@@YAPAVioGrowthNormalUpInfo@@PAVioGrowthUpInfo@@@Z ENDP ; ToNormalUpInfo
_TEXT	ENDS
PUBLIC	?ApplyWeaponWoundedBasePushBlowCalc@ioBaseChar@@IAEXPAVioWeapon@@MAAM1AA_N@Z ; ioBaseChar::ApplyWeaponWoundedBasePushBlowCalc
EXTRN	?HasFeature@ioWeapon@@QBE_NK@Z:PROC		; ioWeapon::HasFeature
EXTRN	?GetGangsiBlowPower@ioWeapon@@QBEMM@Z:PROC	; ioWeapon::GetGangsiBlowPower
EXTRN	?GetGangsiPushPower@ioWeapon@@QBEMM@Z:PROC	; ioWeapon::GetGangsiPushPower
EXTRN	?GetGangsiAirBlowPower@ioWeapon@@QBEMM@Z:PROC	; ioWeapon::GetGangsiAirBlowPower
EXTRN	?GetGangsiAirPushPower@ioWeapon@@QBEMM@Z:PROC	; ioWeapon::GetGangsiAirPushPower
EXTRN	?GetWoundEnhanceRate@ioBaseChar@@QAEMW4EnhanceOwnerType@@@Z:PROC ; ioBaseChar::GetWoundEnhanceRate
EXTRN	?IsFloatingState@ioBaseChar@@QBE_NXZ:PROC	; ioBaseChar::IsFloatingState
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasecharapplywoundednew.cpp
;	COMDAT ?ApplyWeaponWoundedBasePushBlowCalc@ioBaseChar@@IAEXPAVioWeapon@@MAAM1AA_N@Z
_TEXT	SEGMENT
_fEotBlow$693556 = -4					; size = 4
_fEotAirBlow$693551 = -4				; size = 4
_fEotPush$693555 = 8					; size = 4
_fEotAirPush$693550 = 8					; size = 4
_pWeapon$ = 8						; size = 4
_fDamage$ = 12						; size = 4
_fPushPower$ = 16					; size = 4
_fBlowPower$ = 20					; size = 4
_bForceLinear$ = 24					; size = 4
?ApplyWeaponWoundedBasePushBlowCalc@ioBaseChar@@IAEXPAVioWeapon@@MAAM1AA_N@Z PROC ; ioBaseChar::ApplyWeaponWoundedBasePushBlowCalc, COMDAT
; _this$ = ecx

; 114  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 115  : 	//--- ,  
; 116  : 
; 117  : 	if ( !pWeapon )

  00005	8b 75 08	 mov	 esi, DWORD PTR _pWeapon$[ebp]
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	85 f6		 test	 esi, esi
  0000d	0f 84 2d 01 00
	00		 je	 $LN3@ApplyWeapo

; 118  : 		return;
; 119  : 
; 120  : 	if( IsFloatingState() )

  00013	e8 00 00 00 00	 call	 ?IsFloatingState@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsFloatingState

; 121  : 	{
; 122  : 		float fEotAirPush = GetWoundEnhanceRate( EOT_AIR_PUSH );

  00018	8b cf		 mov	 ecx, edi
  0001a	84 c0		 test	 al, al
  0001c	74 73		 je	 SHORT $LN6@ApplyWeapo
  0001e	6a 02		 push	 2
  00020	e8 00 00 00 00	 call	 ?GetWoundEnhanceRate@ioBaseChar@@QAEMW4EnhanceOwnerType@@@Z ; ioBaseChar::GetWoundEnhanceRate
  00025	d9 5d 08	 fstp	 DWORD PTR _fEotAirPush$693550[ebp]

; 123  : 		float fEotAirBlow = GetWoundEnhanceRate( EOT_AIR_BLOW );

  00028	6a 03		 push	 3
  0002a	8b cf		 mov	 ecx, edi
  0002c	e8 00 00 00 00	 call	 ?GetWoundEnhanceRate@ioBaseChar@@QAEMW4EnhanceOwnerType@@@Z ; ioBaseChar::GetWoundEnhanceRate
  00031	d9 5d fc	 fstp	 DWORD PTR _fEotAirBlow$693551[ebp]

; 124  : 
; 125  : 		if( IsGangsi() )

  00034	80 bf f8 23 00
	00 00		 cmp	 BYTE PTR [edi+9208], 0

; 126  : 		{
; 127  : 			fPushPower = pWeapon->GetGangsiAirPushPower( fDamage );

  0003b	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  00040	51		 push	 ecx
  00041	8b ce		 mov	 ecx, esi
  00043	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00048	74 1e		 je	 SHORT $LN5@ApplyWeapo
  0004a	e8 00 00 00 00	 call	 ?GetGangsiAirPushPower@ioWeapon@@QBEMM@Z ; ioWeapon::GetGangsiAirPushPower
  0004f	8b 7d 10	 mov	 edi, DWORD PTR _fPushPower$[ebp]

; 128  : 			fBlowPower = pWeapon->GetGangsiAirBlowPower( fDamage );

  00052	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  00057	d9 1f		 fstp	 DWORD PTR [edi]
  00059	51		 push	 ecx
  0005a	8b ce		 mov	 ecx, esi
  0005c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00061	e8 00 00 00 00	 call	 ?GetGangsiAirBlowPower@ioWeapon@@QBEMM@Z ; ioWeapon::GetGangsiAirBlowPower

; 129  : 		}
; 130  : 		else

  00066	eb 22		 jmp	 SHORT $LN14@ApplyWeapo
$LN5@ApplyWeapo:

; 131  : 		{
; 132  : 			fPushPower = pWeapon->GetAirPushPower( fDamage );

  00068	8b 06		 mov	 eax, DWORD PTR [esi]
  0006a	ff 90 80 00 00
	00		 call	 DWORD PTR [eax+128]
  00070	8b 7d 10	 mov	 edi, DWORD PTR _fPushPower$[ebp]

; 133  : 			fBlowPower = pWeapon->GetAirBlowPower( fDamage );

  00073	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  00078	d9 1f		 fstp	 DWORD PTR [edi]
  0007a	8b 06		 mov	 eax, DWORD PTR [esi]
  0007c	51		 push	 ecx
  0007d	8b ce		 mov	 ecx, esi
  0007f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00084	ff 90 84 00 00
	00		 call	 DWORD PTR [eax+132]
$LN14@ApplyWeapo:

; 134  : 		}
; 135  : 
; 136  : 		fPushPower *= fEotAirPush;
; 137  : 		fBlowPower *= fEotAirBlow;
; 138  : 		bForceLinear = pWeapon->HasFeature( WF_AIR_PUSH_POWER_LINEAR );

  0008a	68 80 00 00 00	 push	 128			; 00000080H

; 139  : 	}
; 140  : 	else

  0008f	eb 68		 jmp	 SHORT $LN17@ApplyWeapo
$LN6@ApplyWeapo:

; 141  : 	{
; 142  : 		float fEotPush = GetWoundEnhanceRate( EOT_PUSH );

  00091	6a 00		 push	 0
  00093	e8 00 00 00 00	 call	 ?GetWoundEnhanceRate@ioBaseChar@@QAEMW4EnhanceOwnerType@@@Z ; ioBaseChar::GetWoundEnhanceRate
  00098	d9 5d 08	 fstp	 DWORD PTR _fEotPush$693555[ebp]

; 143  : 		float fEotBlow = GetWoundEnhanceRate( EOT_BLOW );

  0009b	6a 01		 push	 1
  0009d	8b cf		 mov	 ecx, edi
  0009f	e8 00 00 00 00	 call	 ?GetWoundEnhanceRate@ioBaseChar@@QAEMW4EnhanceOwnerType@@@Z ; ioBaseChar::GetWoundEnhanceRate
  000a4	d9 5d fc	 fstp	 DWORD PTR _fEotBlow$693556[ebp]

; 144  : 
; 145  : 		if( IsGangsi() )

  000a7	80 bf f8 23 00
	00 00		 cmp	 BYTE PTR [edi+9208], 0

; 146  : 		{
; 147  : 			fPushPower = pWeapon->GetGangsiPushPower( fDamage );

  000ae	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  000b3	51		 push	 ecx
  000b4	8b ce		 mov	 ecx, esi
  000b6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000bb	74 1e		 je	 SHORT $LN2@ApplyWeapo
  000bd	e8 00 00 00 00	 call	 ?GetGangsiPushPower@ioWeapon@@QBEMM@Z ; ioWeapon::GetGangsiPushPower
  000c2	8b 7d 10	 mov	 edi, DWORD PTR _fPushPower$[ebp]

; 148  : 			fBlowPower = pWeapon->GetGangsiBlowPower( fDamage );

  000c5	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  000ca	d9 1f		 fstp	 DWORD PTR [edi]
  000cc	51		 push	 ecx
  000cd	8b ce		 mov	 ecx, esi
  000cf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d4	e8 00 00 00 00	 call	 ?GetGangsiBlowPower@ioWeapon@@QBEMM@Z ; ioWeapon::GetGangsiBlowPower

; 149  : 		}
; 150  : 		else

  000d9	eb 1c		 jmp	 SHORT $LN16@ApplyWeapo
$LN2@ApplyWeapo:

; 151  : 		{
; 152  : 			fPushPower = pWeapon->GetPushPower( fDamage );

  000db	8b 06		 mov	 eax, DWORD PTR [esi]
  000dd	ff 50 78	 call	 DWORD PTR [eax+120]
  000e0	8b 7d 10	 mov	 edi, DWORD PTR _fPushPower$[ebp]

; 153  : 			fBlowPower = pWeapon->GetBlowPower( fDamage );

  000e3	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  000e8	d9 1f		 fstp	 DWORD PTR [edi]
  000ea	8b 06		 mov	 eax, DWORD PTR [esi]
  000ec	51		 push	 ecx
  000ed	8b ce		 mov	 ecx, esi
  000ef	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f4	ff 50 7c	 call	 DWORD PTR [eax+124]
$LN16@ApplyWeapo:

; 158  : 		bForceLinear = pWeapon->HasFeature( WF_PUSH_POWER_LINEAR );

  000f7	6a 40		 push	 64			; 00000040H
$LN17@ApplyWeapo:

; 153  : 			fBlowPower = pWeapon->GetBlowPower( fDamage );

  000f9	8b 45 14	 mov	 eax, DWORD PTR _fBlowPower$[ebp]

; 154  : 		}
; 155  : 
; 156  : 		fPushPower *= fEotPush;

  000fc	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _fEotPush$693555[ebp]
  00101	d9 18		 fstp	 DWORD PTR [eax]
  00103	f3 0f 10 07	 movss	 xmm0, DWORD PTR [edi]
  00107	0f 5a c0	 cvtps2pd xmm0, xmm0
  0010a	0f 5a c9	 cvtps2pd xmm1, xmm1
  0010d	f2 0f 59 c1	 mulsd	 xmm0, xmm1

; 157  : 		fBlowPower *= fEotBlow;

  00111	f3 0f 10 4d fc	 movss	 xmm1, DWORD PTR _fEotBlow$693556[ebp]
  00116	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0011a	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0
  0011e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00122	0f 5a c0	 cvtps2pd xmm0, xmm0
  00125	0f 5a c9	 cvtps2pd xmm1, xmm1
  00128	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  0012c	66 0f 5a c0	 cvtpd2ps xmm0, xmm0

; 158  : 		bForceLinear = pWeapon->HasFeature( WF_PUSH_POWER_LINEAR );

  00130	8b ce		 mov	 ecx, esi
  00132	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00136	e8 00 00 00 00	 call	 ?HasFeature@ioWeapon@@QBE_NK@Z ; ioWeapon::HasFeature
  0013b	8b 4d 18	 mov	 ecx, DWORD PTR _bForceLinear$[ebp]
  0013e	88 01		 mov	 BYTE PTR [ecx], al
$LN3@ApplyWeapo:
  00140	5f		 pop	 edi
  00141	5e		 pop	 esi

; 159  : 	}
; 160  : }

  00142	c9		 leave
  00143	c2 14 00	 ret	 20			; 00000014H
?ApplyWeaponWoundedBasePushBlowCalc@ioBaseChar@@IAEXPAVioWeapon@@MAAM1AA_N@Z ENDP ; ioBaseChar::ApplyWeaponWoundedBasePushBlowCalc
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	?ApplyWeaponWoundedExtraPushBlowCalc@ioBaseChar@@IAEXPAVioWeapon@@AAM1@Z ; ioBaseChar::ApplyWeaponWoundedExtraPushBlowCalc
EXTRN	?GetDownStatePushPower@ioWeapon@@QAEMXZ:PROC	; ioWeapon::GetDownStatePushPower
EXTRN	?GetDownStateBlowPower@ioWeapon@@QAEMXZ:PROC	; ioWeapon::GetDownStateBlowPower
EXTRN	?m_fFloatingBlowDownRate@ioBaseChar@@1MA:DWORD	; ioBaseChar::m_fFloatingBlowDownRate
EXTRN	?FindAttribute@ioWeaponManager@@QAEPBUWeaponAttribute@@H@Z:PROC ; ioWeaponManager::FindAttribute
EXTRN	?GetSingleton@ioWeaponManager@@SAAAV1@XZ:PROC	; ioWeaponManager::GetSingleton
EXTRN	?GetAttributeIndex@ioWeapon@@QBEHXZ:PROC	; ioWeapon::GetAttributeIndex
EXTRN	?CheckBlowIncreaseBuff@ioWeapon@@QAEMPAVioBaseChar@@@Z:PROC ; ioWeapon::CheckBlowIncreaseBuff
EXTRN	?CheckPushIncreaseBuff@ioWeapon@@QAEMPAVioBaseChar@@@Z:PROC ; ioWeapon::CheckPushIncreaseBuff
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?ApplyWeaponWoundedExtraPushBlowCalc@ioBaseChar@@IAEXPAVioWeapon@@AAM1@Z
_TEXT	SEGMENT
_pWeapon$ = 8						; size = 4
_fPushPower$ = 12					; size = 4
_fBlowPower$ = 16					; size = 4
?ApplyWeaponWoundedExtraPushBlowCalc@ioBaseChar@@IAEXPAVioWeapon@@AAM1@Z PROC ; ioBaseChar::ApplyWeaponWoundedExtraPushBlowCalc, COMDAT
; _this$ = ecx

; 163  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 164  : 	if ( !pWeapon )

  00003	83 7d 08 00	 cmp	 DWORD PTR _pWeapon$[ebp], 0
  00007	53		 push	 ebx
  00008	8b d9		 mov	 ebx, ecx
  0000a	0f 84 ec 00 00
	00		 je	 $LN1@ApplyWeapo@2

; 165  : 		return;
; 166  : 
; 167  : 	//---   
; 168  : 	fPushPower *= pWeapon->CheckPushIncreaseBuff( this );

  00010	8b 4d 08	 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  00013	56		 push	 esi
  00014	53		 push	 ebx
  00015	e8 00 00 00 00	 call	 ?CheckPushIncreaseBuff@ioWeapon@@QAEMPAVioBaseChar@@@Z ; ioWeapon::CheckPushIncreaseBuff
  0001a	8b 45 0c	 mov	 eax, DWORD PTR _fPushPower$[ebp]
  0001d	d8 08		 fmul	 DWORD PTR [eax]

; 169  : 	fBlowPower *= pWeapon->CheckBlowIncreaseBuff( this );

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  00022	53		 push	 ebx
  00023	d9 18		 fstp	 DWORD PTR [eax]
  00025	e8 00 00 00 00	 call	 ?CheckBlowIncreaseBuff@ioWeapon@@QAEMPAVioBaseChar@@@Z ; ioWeapon::CheckBlowIncreaseBuff
  0002a	8b 75 10	 mov	 esi, DWORD PTR _fBlowPower$[ebp]
  0002d	d8 0e		 fmul	 DWORD PTR [esi]
  0002f	d9 1e		 fstp	 DWORD PTR [esi]

; 170  : 
; 171  : 	//---  
; 172  : 	if( m_CharState == CS_BLOW_WOUNDED ||
; 173  : 		m_CharState == CS_BOUND_BLOW_WOUNDED ||
; 174  : 		m_CharState == CS_BLOW_EXTEND_WOUND )

  00031	8a 83 10 03 00
	00		 mov	 al, BYTE PTR [ebx+784]
  00037	3c 0c		 cmp	 al, 12			; 0000000cH
  00039	74 0c		 je	 SHORT $LN4@ApplyWeapo@2
  0003b	3c 31		 cmp	 al, 49			; 00000031H
  0003d	74 08		 je	 SHORT $LN4@ApplyWeapo@2
  0003f	3c 46		 cmp	 al, 70			; 00000046H
  00041	0f 85 b4 00 00
	00		 jne	 $LN11@ApplyWeapo@2
$LN4@ApplyWeapo@2:

; 175  : 	{
; 176  : 		m_iFloatingWoundedCnt++;
; 177  : 
; 178  : 		//  by yunga
; 179  : 		float fBlowRate = 0.0f;
; 180  : 		const WeaponAttribute *pAttr = g_WeaponMgr.FindAttribute( pWeapon->GetAttributeIndex() );

  00047	8b 4d 08	 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  0004a	ff 83 e0 13 00
	00		 inc	 DWORD PTR [ebx+5088]
  00050	57		 push	 edi
  00051	e8 00 00 00 00	 call	 ?GetAttributeIndex@ioWeapon@@QBEHXZ ; ioWeapon::GetAttributeIndex
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?GetSingleton@ioWeaponManager@@SAAAV1@XZ ; ioWeaponManager::GetSingleton
  0005c	8b c8		 mov	 ecx, eax
  0005e	e8 00 00 00 00	 call	 ?FindAttribute@ioWeaponManager@@QAEPBUWeaponAttribute@@H@Z ; ioWeaponManager::FindAttribute

; 181  : 		if( pAttr && pAttr->m_bNoCalcFloatingCnt )

  00063	85 c0		 test	 eax, eax
  00065	74 10		 je	 SHORT $LN3@ApplyWeapo@2
  00067	80 78 38 00	 cmp	 BYTE PTR [eax+56], 0
  0006b	74 0a		 je	 SHORT $LN3@ApplyWeapo@2

; 182  : 			fBlowRate = m_fFloatingBlowDownRate;

  0006d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?m_fFloatingBlowDownRate@ioBaseChar@@1MA

; 183  : 		else

  00075	eb 22		 jmp	 SHORT $LN2@ApplyWeapo@2
$LN3@ApplyWeapo@2:

; 184  : 			fBlowRate = m_fFloatingBlowDownRate * (float)m_iFloatingWoundedCnt;

  00077	66 0f 6e 83 e0
	13 00 00	 movd	 xmm0, DWORD PTR [ebx+5088]
  0007f	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR ?m_fFloatingBlowDownRate@ioBaseChar@@1MA
  00087	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0008a	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  0008e	0f 5a c9	 cvtps2pd xmm1, xmm1
  00091	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00095	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
$LN2@ApplyWeapo@2:

; 185  : 
; 186  : 		fBlowRate = max( 0.0f, ( 1.0f - fBlowRate ) );

  00099	0f 57 c9	 xorps	 xmm1, xmm1
  0009c	f3 0f 5a c8	 cvtss2sd xmm1, xmm0
  000a0	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  000a8	f2 0f 5c c1	 subsd	 xmm0, xmm1
  000ac	0f 57 c9	 xorps	 xmm1, xmm1
  000af	66 0f 2f c8	 comisd	 xmm1, xmm0
  000b3	5f		 pop	 edi
  000b4	76 04		 jbe	 SHORT $LN9@ApplyWeapo@2
  000b6	66 0f 28 c1	 movapd	 xmm0, xmm1
$LN9@ApplyWeapo@2:

; 187  : 		fBlowPower *= fBlowRate;

  000ba	f3 0f 10 0e	 movss	 xmm1, DWORD PTR [esi]
  000be	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  000c2	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  000c6	0f 5a c9	 cvtps2pd xmm1, xmm1
  000c9	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  000cd	66 0f 5a c0	 cvtpd2ps xmm0, xmm0

; 188  : 
; 189  : 		if( !IsFloatingState() )

  000d1	8b cb		 mov	 ecx, ebx
  000d3	f3 0f 11 06	 movss	 DWORD PTR [esi], xmm0
  000d7	e8 00 00 00 00	 call	 ?IsFloatingState@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsFloatingState
  000dc	84 c0		 test	 al, al
  000de	75 1b		 jne	 SHORT $LN11@ApplyWeapo@2

; 190  : 		{
; 191  : 			fBlowPower *= pWeapon->GetDownStateBlowPower();

  000e0	8b 4d 08	 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  000e3	e8 00 00 00 00	 call	 ?GetDownStateBlowPower@ioWeapon@@QAEMXZ ; ioWeapon::GetDownStateBlowPower
  000e8	d8 0e		 fmul	 DWORD PTR [esi]

; 192  : 			fPushPower *= pWeapon->GetDownStatePushPower();

  000ea	8b 4d 08	 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  000ed	d9 1e		 fstp	 DWORD PTR [esi]
  000ef	e8 00 00 00 00	 call	 ?GetDownStatePushPower@ioWeapon@@QAEMXZ ; ioWeapon::GetDownStatePushPower
  000f4	8b 45 0c	 mov	 eax, DWORD PTR _fPushPower$[ebp]
  000f7	d8 08		 fmul	 DWORD PTR [eax]
  000f9	d9 18		 fstp	 DWORD PTR [eax]
$LN11@ApplyWeapo@2:
  000fb	5e		 pop	 esi
$LN1@ApplyWeapo@2:
  000fc	5b		 pop	 ebx

; 193  : 		}
; 194  : 	}
; 195  : }

  000fd	5d		 pop	 ebp
  000fe	c2 0c 00	 ret	 12			; 0000000cH
?ApplyWeaponWoundedExtraPushBlowCalc@ioBaseChar@@IAEXPAVioWeapon@@AAM1@Z ENDP ; ioBaseChar::ApplyWeaponWoundedExtraPushBlowCalc
_TEXT	ENDS
PUBLIC	??1FrontBackWoundInfo@@QAE@XZ			; FrontBackWoundInfo::~FrontBackWoundInfo
EXTRN	__imp_??1ioHashString@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__EH_epilog3:PROC
EXTRN	__EH_prolog3:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1FrontBackWoundInfo@@QAE@XZ DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$??1FrontBackWoundInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1FrontBackWoundInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1FrontBackWoundInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1FrontBackWoundInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1FrontBackWoundInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1FrontBackWoundInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1FrontBackWoundInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1FrontBackWoundInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1FrontBackWoundInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1FrontBackWoundInfo@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??1FrontBackWoundInfo@@QAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??1FrontBackWoundInfo@@QAE@XZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??1FrontBackWoundInfo@@QAE@XZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??1FrontBackWoundInfo@@QAE@XZ$11
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??1FrontBackWoundInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1FrontBackWoundInfo@@QAE@XZ PROC			; FrontBackWoundInfo::~FrontBackWoundInfo, COMDAT
; _this$ = ecx
  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??1FrontBackWoundInfo@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f9		 mov	 edi, ecx
  0000e	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  00011	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00017	8d 8f d4 00 00
	00		 lea	 ecx, DWORD PTR [edi+212]
  0001d	c7 45 fc 0b 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  00024	ff d6		 call	 esi
  00026	8d 8f c4 00 00
	00		 lea	 ecx, DWORD PTR [edi+196]
  0002c	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  00030	ff d6		 call	 esi
  00032	8d 8f b0 00 00
	00		 lea	 ecx, DWORD PTR [edi+176]
  00038	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  0003c	ff d6		 call	 esi
  0003e	8d 8f a0 00 00
	00		 lea	 ecx, DWORD PTR [edi+160]
  00044	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00048	ff d6		 call	 esi
  0004a	8d 8f 8c 00 00
	00		 lea	 ecx, DWORD PTR [edi+140]
  00050	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00054	ff d6		 call	 esi
  00056	8d 4f 7c	 lea	 ecx, DWORD PTR [edi+124]
  00059	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  0005d	ff d6		 call	 esi
  0005f	8d 4f 68	 lea	 ecx, DWORD PTR [edi+104]
  00062	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00066	ff d6		 call	 esi
  00068	8d 4f 58	 lea	 ecx, DWORD PTR [edi+88]
  0006b	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0006f	ff d6		 call	 esi
  00071	8d 4f 44	 lea	 ecx, DWORD PTR [edi+68]
  00074	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00078	ff d6		 call	 esi
  0007a	8d 4f 34	 lea	 ecx, DWORD PTR [edi+52]
  0007d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00081	ff d6		 call	 esi
  00083	8d 4f 20	 lea	 ecx, DWORD PTR [edi+32]
  00086	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0008a	ff d6		 call	 esi
  0008c	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  0008f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00093	ff d6		 call	 esi
  00095	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00099	8b cf		 mov	 ecx, edi
  0009b	ff d6		 call	 esi
  0009d	e8 00 00 00 00	 call	 __EH_epilog3
  000a2	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1FrontBackWoundInfo@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??1FrontBackWoundInfo@@QAE@XZ$1:
  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 10	 add	 ecx, 16			; 00000010H
  0000f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??1FrontBackWoundInfo@@QAE@XZ$2:
  00015	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	83 c1 20	 add	 ecx, 32			; 00000020H
  0001b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??1FrontBackWoundInfo@@QAE@XZ$3:
  00021	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 34	 add	 ecx, 52			; 00000034H
  00027	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??1FrontBackWoundInfo@@QAE@XZ$4:
  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	83 c1 44	 add	 ecx, 68			; 00000044H
  00033	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??1FrontBackWoundInfo@@QAE@XZ$5:
  00039	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	83 c1 58	 add	 ecx, 88			; 00000058H
  0003f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??1FrontBackWoundInfo@@QAE@XZ$6:
  00045	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	83 c1 68	 add	 ecx, 104		; 00000068H
  0004b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??1FrontBackWoundInfo@@QAE@XZ$7:
  00051	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00057	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??1FrontBackWoundInfo@@QAE@XZ$8:
  0005d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  00066	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??1FrontBackWoundInfo@@QAE@XZ$9:
  0006c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	81 c1 a0 00 00
	00		 add	 ecx, 160		; 000000a0H
  00075	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??1FrontBackWoundInfo@@QAE@XZ$10:
  0007b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	81 c1 b0 00 00
	00		 add	 ecx, 176		; 000000b0H
  00084	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??1FrontBackWoundInfo@@QAE@XZ$11:
  0008a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	81 c1 c4 00 00
	00		 add	 ecx, 196		; 000000c4H
  00093	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$??1FrontBackWoundInfo@@QAE@XZ:
  00099	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0009d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000a0	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  000a3	33 c8		 xor	 ecx, eax
  000a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000aa	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1FrontBackWoundInfo@@QAE@XZ
  000af	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1FrontBackWoundInfo@@QAE@XZ ENDP			; FrontBackWoundInfo::~FrontBackWoundInfo
PUBLIC	??0tagBlowWoundAniInfo@@QAE@ABU0@@Z		; tagBlowWoundAniInfo::tagBlowWoundAniInfo
EXTRN	__imp_??0ioHashString@@QAE@ABV0@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0tagBlowWoundAniInfo@@QAE@ABU0@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0tagBlowWoundAniInfo@@QAE@ABU0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0tagBlowWoundAniInfo@@QAE@ABU0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0tagBlowWoundAniInfo@@QAE@ABU0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0tagBlowWoundAniInfo@@QAE@ABU0@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0tagBlowWoundAniInfo@@QAE@ABU0@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0tagBlowWoundAniInfo@@QAE@ABU0@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0tagBlowWoundAniInfo@@QAE@ABU0@@Z$4
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??0tagBlowWoundAniInfo@@QAE@ABU0@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0tagBlowWoundAniInfo@@QAE@ABU0@@Z PROC		; tagBlowWoundAniInfo::tagBlowWoundAniInfo, COMDAT
; _this$ = ecx
  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0tagBlowWoundAniInfo@@QAE@ABU0@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f9		 mov	 edi, ecx
  0000e	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  00011	8b 5d 08	 mov	 ebx, DWORD PTR ___that$[ebp]
  00014	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  0001a	53		 push	 ebx
  0001b	ff d6		 call	 esi
  0001d	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00021	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
  00024	50		 push	 eax
  00025	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  00028	ff d6		 call	 esi
  0002a	8d 43 20	 lea	 eax, DWORD PTR [ebx+32]
  0002d	50		 push	 eax
  0002e	8d 4f 20	 lea	 ecx, DWORD PTR [edi+32]
  00031	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00035	ff d6		 call	 esi
  00037	8d 43 30	 lea	 eax, DWORD PTR [ebx+48]
  0003a	50		 push	 eax
  0003b	8d 4f 30	 lea	 ecx, DWORD PTR [edi+48]
  0003e	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00042	ff d6		 call	 esi
  00044	8d 43 40	 lea	 eax, DWORD PTR [ebx+64]
  00047	50		 push	 eax
  00048	8d 4f 40	 lea	 ecx, DWORD PTR [edi+64]
  0004b	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0004f	ff d6		 call	 esi
  00051	83 c3 50	 add	 ebx, 80			; 00000050H
  00054	53		 push	 ebx
  00055	8d 4f 50	 lea	 ecx, DWORD PTR [edi+80]
  00058	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0005c	ff d6		 call	 esi
  0005e	8b c7		 mov	 eax, edi
  00060	e8 00 00 00 00	 call	 __EH_epilog3
  00065	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0tagBlowWoundAniInfo@@QAE@ABU0@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??0tagBlowWoundAniInfo@@QAE@ABU0@@Z$1:
  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 10	 add	 ecx, 16			; 00000010H
  0000f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??0tagBlowWoundAniInfo@@QAE@ABU0@@Z$2:
  00015	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	83 c1 20	 add	 ecx, 32			; 00000020H
  0001b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??0tagBlowWoundAniInfo@@QAE@ABU0@@Z$3:
  00021	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 30	 add	 ecx, 48			; 00000030H
  00027	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??0tagBlowWoundAniInfo@@QAE@ABU0@@Z$4:
  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	83 c1 40	 add	 ecx, 64			; 00000040H
  00033	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$??0tagBlowWoundAniInfo@@QAE@ABU0@@Z:
  00039	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0003d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00040	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00043	33 c8		 xor	 ecx, eax
  00045	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0tagBlowWoundAniInfo@@QAE@ABU0@@Z
  0004f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0tagBlowWoundAniInfo@@QAE@ABU0@@Z ENDP		; tagBlowWoundAniInfo::tagBlowWoundAniInfo
PUBLIC	?ApplyWeaponWoundedWeaponFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_N@Z ; ioBaseChar::ApplyWeaponWoundedWeaponFunc
EXTRN	?CheckTargetColState@ioMissileWeapon2@@QAEXPAVioBaseChar@@@Z:PROC ; ioMissileWeapon2::CheckTargetColState
EXTRN	?CheckAfterCollisionState@ioGuide2Weapon@@QAEXPAVioBaseChar@@_N@Z:PROC ; ioGuide2Weapon::CheckAfterCollisionState
EXTRN	?CheckCollision@ioContactWeapon@@QAEXPAVioBaseChar@@_N@Z:PROC ; ioContactWeapon::CheckCollision
EXTRN	?CheckTargetMoveState@ioUroborusWeapon7@@QAEXPAVioBaseChar@@_N@Z:PROC ; ioUroborusWeapon7::CheckTargetMoveState
EXTRN	?CheckTargetMoveState@ioUroborusWeapon4@@QAEXPAVioBaseChar@@_N@Z:PROC ; ioUroborusWeapon4::CheckTargetMoveState
EXTRN	?CheckTargetMoveState@ioUroborusWeapon3@@QAEXPAVioBaseChar@@_N@Z:PROC ; ioUroborusWeapon3::CheckTargetMoveState
EXTRN	?CheckTargetMoveState@ioUroborusWeapon2@@QAEXPAVioBaseChar@@_N@Z:PROC ; ioUroborusWeapon2::CheckTargetMoveState
EXTRN	?SetColMoveState@ioAdhesiveMissileWeapon2@@QAEXPAVioBaseChar@@_N@Z:PROC ; ioAdhesiveMissileWeapon2::SetColMoveState
EXTRN	?CheckBallWeapon@ioBaseChar@@QAEXPAVioWeapon@@@Z:PROC ; ioBaseChar::CheckBallWeapon
EXTRN	?CheckChainWeapon@ioBaseChar@@QAEXPAVioWeapon@@@Z:PROC ; ioBaseChar::CheckChainWeapon
EXTRN	?SetIgnoreWeaponInfo@ioBaseChar@@QAEXPAVioWeapon@@@Z:PROC ; ioBaseChar::SetIgnoreWeaponInfo
; Function compile flags: /Ogsp
;	COMDAT ?ApplyWeaponWoundedWeaponFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_N@Z
_TEXT	SEGMENT
_pWeapon$ = 8						; size = 4
_pAttacker$ = 12					; size = 4
_bApplyPushPower$ = 16					; size = 1
?ApplyWeaponWoundedWeaponFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_N@Z PROC ; ioBaseChar::ApplyWeaponWoundedWeaponFunc, COMDAT
; _this$ = ecx

; 1901 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1902 : 	if ( !pWeapon || !pAttacker )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pWeapon$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	85 f6		 test	 esi, esi
  0000c	0f 84 c7 00 00
	00		 je	 $LN9@ApplyWeapo@3
  00012	83 7d 0c 00	 cmp	 DWORD PTR _pAttacker$[ebp], 0
  00016	0f 84 bd 00 00
	00		 je	 $LN9@ApplyWeapo@3

; 1903 : 		return;
; 1904 : 
; 1905 : 	SetIgnoreWeaponInfo( pWeapon );	

  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 ?SetIgnoreWeaponInfo@ioBaseChar@@QAEXPAVioWeapon@@@Z ; ioBaseChar::SetIgnoreWeaponInfo

; 1906 : 	CheckChainWeapon( pWeapon );

  00022	56		 push	 esi
  00023	8b cf		 mov	 ecx, edi
  00025	e8 00 00 00 00	 call	 ?CheckChainWeapon@ioBaseChar@@QAEXPAVioWeapon@@@Z ; ioBaseChar::CheckChainWeapon

; 1907 : 	CheckBallWeapon( pWeapon );

  0002a	56		 push	 esi
  0002b	8b cf		 mov	 ecx, edi
  0002d	e8 00 00 00 00	 call	 ?CheckBallWeapon@ioBaseChar@@QAEXPAVioWeapon@@@Z ; ioBaseChar::CheckBallWeapon

; 1908 : 
; 1909 : 	ioAdhesiveMissileWeapon2 *pAdhesive2 = ToAdhesiveMissileWeapon2( pWeapon );

  00032	56		 push	 esi
  00033	e8 00 00 00 00	 call	 ?ToAdhesiveMissileWeapon2@@YAPAVioAdhesiveMissileWeapon2@@PAVioWeapon@@@Z ; ToAdhesiveMissileWeapon2
  00038	59		 pop	 ecx

; 1910 : 	if( pAdhesive2 )

  00039	85 c0		 test	 eax, eax
  0003b	74 0a		 je	 SHORT $LN8@ApplyWeapo@3

; 1911 : 		pAdhesive2->SetColMoveState( this, true );

  0003d	6a 01		 push	 1
  0003f	57		 push	 edi
  00040	8b c8		 mov	 ecx, eax
  00042	e8 00 00 00 00	 call	 ?SetColMoveState@ioAdhesiveMissileWeapon2@@QAEXPAVioBaseChar@@_N@Z ; ioAdhesiveMissileWeapon2::SetColMoveState
$LN8@ApplyWeapo@3:

; 1912 : 
; 1913 : 	ioUroborusWeapon2 *pUroborus2 = ToUroborusWeapon2( pWeapon );

  00047	53		 push	 ebx
  00048	56		 push	 esi
  00049	e8 00 00 00 00	 call	 ?ToUroborusWeapon2@@YAPAVioUroborusWeapon2@@PAVioWeapon@@@Z ; ToUroborusWeapon2

; 1914 : 	if( pUroborus2 )

  0004e	8b 5d 10	 mov	 ebx, DWORD PTR _bApplyPushPower$[ebp]
  00051	59		 pop	 ecx
  00052	85 c0		 test	 eax, eax
  00054	74 09		 je	 SHORT $LN7@ApplyWeapo@3

; 1915 : 		pUroborus2->CheckTargetMoveState( this, bApplyPushPower );

  00056	53		 push	 ebx
  00057	57		 push	 edi
  00058	8b c8		 mov	 ecx, eax
  0005a	e8 00 00 00 00	 call	 ?CheckTargetMoveState@ioUroborusWeapon2@@QAEXPAVioBaseChar@@_N@Z ; ioUroborusWeapon2::CheckTargetMoveState
$LN7@ApplyWeapo@3:

; 1916 : 
; 1917 : 	ioUroborusWeapon3 *pUroborus3 = ToUroborusWeapon3( pWeapon );

  0005f	56		 push	 esi
  00060	e8 00 00 00 00	 call	 ?ToUroborusWeapon3@@YAPAVioUroborusWeapon3@@PAVioWeapon@@@Z ; ToUroborusWeapon3
  00065	59		 pop	 ecx

; 1918 : 	if( pUroborus3 )

  00066	85 c0		 test	 eax, eax
  00068	74 09		 je	 SHORT $LN6@ApplyWeapo@3

; 1919 : 		pUroborus3->CheckTargetMoveState( this, bApplyPushPower );

  0006a	53		 push	 ebx
  0006b	57		 push	 edi
  0006c	8b c8		 mov	 ecx, eax
  0006e	e8 00 00 00 00	 call	 ?CheckTargetMoveState@ioUroborusWeapon3@@QAEXPAVioBaseChar@@_N@Z ; ioUroborusWeapon3::CheckTargetMoveState
$LN6@ApplyWeapo@3:

; 1920 : 
; 1921 : 	ioUroborusWeapon4 *pUroborus4 = ToUroborusWeapon4( pWeapon );

  00073	56		 push	 esi
  00074	e8 00 00 00 00	 call	 ?ToUroborusWeapon4@@YAPAVioUroborusWeapon4@@PAVioWeapon@@@Z ; ToUroborusWeapon4
  00079	59		 pop	 ecx

; 1922 : 	if( pUroborus4 )

  0007a	85 c0		 test	 eax, eax
  0007c	74 09		 je	 SHORT $LN5@ApplyWeapo@3

; 1923 : 		pUroborus4->CheckTargetMoveState( this, bApplyPushPower );

  0007e	53		 push	 ebx
  0007f	57		 push	 edi
  00080	8b c8		 mov	 ecx, eax
  00082	e8 00 00 00 00	 call	 ?CheckTargetMoveState@ioUroborusWeapon4@@QAEXPAVioBaseChar@@_N@Z ; ioUroborusWeapon4::CheckTargetMoveState
$LN5@ApplyWeapo@3:

; 1924 : 
; 1925 : 	ioUroborusWeapon7 *pUroborus7 = ToUroborusWeapon7( pWeapon );

  00087	56		 push	 esi
  00088	e8 00 00 00 00	 call	 ?ToUroborusWeapon7@@YAPAVioUroborusWeapon7@@PAVioWeapon@@@Z ; ToUroborusWeapon7
  0008d	59		 pop	 ecx

; 1926 : 	if( pUroborus7 )

  0008e	85 c0		 test	 eax, eax
  00090	74 09		 je	 SHORT $LN4@ApplyWeapo@3

; 1927 : 		pUroborus7->CheckTargetMoveState( this, bApplyPushPower );

  00092	53		 push	 ebx
  00093	57		 push	 edi
  00094	8b c8		 mov	 ecx, eax
  00096	e8 00 00 00 00	 call	 ?CheckTargetMoveState@ioUroborusWeapon7@@QAEXPAVioBaseChar@@_N@Z ; ioUroborusWeapon7::CheckTargetMoveState
$LN4@ApplyWeapo@3:

; 1928 : 
; 1929 : 	ioContactWeapon *pContact = ToContactWeapon( pWeapon );

  0009b	56		 push	 esi
  0009c	e8 00 00 00 00	 call	 ?ToContactWeapon@@YAPAVioContactWeapon@@PAVioWeapon@@@Z ; ToContactWeapon
  000a1	59		 pop	 ecx

; 1930 : 	if ( pContact )

  000a2	85 c0		 test	 eax, eax
  000a4	74 09		 je	 SHORT $LN3@ApplyWeapo@3

; 1931 : 		pContact->CheckCollision( this, bApplyPushPower );

  000a6	53		 push	 ebx
  000a7	57		 push	 edi
  000a8	8b c8		 mov	 ecx, eax
  000aa	e8 00 00 00 00	 call	 ?CheckCollision@ioContactWeapon@@QAEXPAVioBaseChar@@_N@Z ; ioContactWeapon::CheckCollision
$LN3@ApplyWeapo@3:

; 1932 : 
; 1933 : 	ioGuide2Weapon *pGuide2 = ToGuide2Weapon( pWeapon );

  000af	56		 push	 esi
  000b0	e8 00 00 00 00	 call	 ?ToGuide2Weapon@@YAPAVioGuide2Weapon@@PAVioWeapon@@@Z ; ToGuide2Weapon
  000b5	59		 pop	 ecx

; 1934 : 	if( pGuide2 )

  000b6	85 c0		 test	 eax, eax
  000b8	74 09		 je	 SHORT $LN2@ApplyWeapo@3

; 1935 : 		pGuide2->CheckAfterCollisionState( this, bApplyPushPower );

  000ba	53		 push	 ebx
  000bb	57		 push	 edi
  000bc	8b c8		 mov	 ecx, eax
  000be	e8 00 00 00 00	 call	 ?CheckAfterCollisionState@ioGuide2Weapon@@QAEXPAVioBaseChar@@_N@Z ; ioGuide2Weapon::CheckAfterCollisionState
$LN2@ApplyWeapo@3:

; 1936 : 
; 1937 : 	ioMissileWeapon2 *pMissile2 = ToMissileWeapon2( pWeapon );

  000c3	56		 push	 esi
  000c4	e8 00 00 00 00	 call	 ?ToMissileWeapon2@@YAPAVioMissileWeapon2@@PAVioWeapon@@@Z ; ToMissileWeapon2
  000c9	59		 pop	 ecx
  000ca	5b		 pop	 ebx

; 1938 : 	if( pMissile2 )

  000cb	85 c0		 test	 eax, eax
  000cd	74 0a		 je	 SHORT $LN9@ApplyWeapo@3

; 1939 : 		pMissile2->CheckTargetColState( pAttacker );

  000cf	ff 75 0c	 push	 DWORD PTR _pAttacker$[ebp]
  000d2	8b c8		 mov	 ecx, eax
  000d4	e8 00 00 00 00	 call	 ?CheckTargetColState@ioMissileWeapon2@@QAEXPAVioBaseChar@@@Z ; ioMissileWeapon2::CheckTargetColState
$LN9@ApplyWeapo@3:
  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi

; 1940 : }

  000db	5d		 pop	 ebp
  000dc	c2 0c 00	 ret	 12			; 0000000cH
?ApplyWeaponWoundedWeaponFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_N@Z ENDP ; ioBaseChar::ApplyWeaponWoundedWeaponFunc
_TEXT	ENDS
PUBLIC	?empty@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBE_NXZ ; std::vector<ioHashString,std::allocator<ioHashString> >::empty
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?empty@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBE_NXZ PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::empty, COMDAT
; _this$ = ecx

; 889  : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00005	f7 d8		 neg	 eax
  00007	1b c0		 sbb	 eax, eax
  00009	40		 inc	 eax

; 890  : 		}

  0000a	c3		 ret	 0
?empty@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBE_NXZ ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::empty
_TEXT	ENDS
PUBLIC	??A?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEAAVioHashString@@I@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::operator[]
; Function compile flags: /Ogsp
;	COMDAT ??A?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEAAVioHashString@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEAAVioHashString@@I@Z PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00006	c1 e0 04	 shl	 eax, 4
  00009	03 01		 add	 eax, DWORD PTR [ecx]

; 941  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEAAVioHashString@@I@Z ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QBEABUBuffInfoStruct@@I@Z ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::operator[]
; Function compile flags: /Ogsp
;	COMDAT ??A?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QBEABUBuffInfoStruct@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QBEABUBuffInfoStruct@@I@Z PROC ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::operator[], COMDAT
; _this$ = ecx

; 912  : 		{	// subscript nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 913  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 914  : 		if (size() <= _Pos)
; 915  : 			{	// report error
; 916  : 			_DEBUG_ERROR("vector subscript out of range");
; 917  : 			_SCL_SECURE_OUT_OF_RANGE;
; 918  : 			}
; 919  : 
; 920  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 921  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 922  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 923  : 
; 924  : 		return (*(this->_Myfirst + _Pos));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00006	6b c0 14	 imul	 eax, 20			; 00000014H
  00009	03 01		 add	 eax, DWORD PTR [ecx]

; 925  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QBEABUBuffInfoStruct@@I@Z ENDP ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEAAUBuffInfoStruct@@I@Z ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::operator[]
; Function compile flags: /Ogsp
;	COMDAT ??A?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEAAUBuffInfoStruct@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEAAUBuffInfoStruct@@I@Z PROC ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00006	6b c0 14	 imul	 eax, 20			; 00000014H
  00009	03 01		 add	 eax, DWORD PTR [ecx]

; 941  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEAAUBuffInfoStruct@@I@Z ENDP ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@PAUReflectInfo@@V?$allocator@PAUReflectInfo@@@std@@@std@@QAEAAPAUReflectInfo@@I@Z ; std::vector<ReflectInfo *,std::allocator<ReflectInfo *> >::operator[]
; Function compile flags: /Ogsp
;	COMDAT ??A?$vector@PAUReflectInfo@@V?$allocator@PAUReflectInfo@@@std@@@std@@QAEAAPAUReflectInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAUReflectInfo@@V?$allocator@PAUReflectInfo@@@std@@@std@@QAEAAPAUReflectInfo@@I@Z PROC ; std::vector<ReflectInfo *,std::allocator<ReflectInfo *> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pos$[ebp]
  00008	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 941  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@PAUReflectInfo@@V?$allocator@PAUReflectInfo@@@std@@@std@@QAEAAPAUReflectInfo@@I@Z ENDP ; std::vector<ReflectInfo *,std::allocator<ReflectInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?empty@?$vector@ULandStunInfo@@V?$allocator@ULandStunInfo@@@std@@@std@@QBE_NXZ ; std::vector<LandStunInfo,std::allocator<LandStunInfo> >::empty
; Function compile flags: /Ogsp
;	COMDAT ?empty@?$vector@ULandStunInfo@@V?$allocator@ULandStunInfo@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@ULandStunInfo@@V?$allocator@ULandStunInfo@@@std@@@std@@QBE_NXZ PROC ; std::vector<LandStunInfo,std::allocator<LandStunInfo> >::empty, COMDAT
; _this$ = ecx

; 889  : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00005	f7 d8		 neg	 eax
  00007	1b c0		 sbb	 eax, eax
  00009	40		 inc	 eax

; 890  : 		}

  0000a	c3		 ret	 0
?empty@?$vector@ULandStunInfo@@V?$allocator@ULandStunInfo@@@std@@@std@@QBE_NXZ ENDP ; std::vector<LandStunInfo,std::allocator<LandStunInfo> >::empty
_TEXT	ENDS
PUBLIC	??A?$vector@ULandStunInfo@@V?$allocator@ULandStunInfo@@@std@@@std@@QAEAAULandStunInfo@@I@Z ; std::vector<LandStunInfo,std::allocator<LandStunInfo> >::operator[]
; Function compile flags: /Ogsp
;	COMDAT ??A?$vector@ULandStunInfo@@V?$allocator@ULandStunInfo@@@std@@@std@@QAEAAULandStunInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@ULandStunInfo@@V?$allocator@ULandStunInfo@@@std@@@std@@QAEAAULandStunInfo@@I@Z PROC ; std::vector<LandStunInfo,std::allocator<LandStunInfo> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00006	c1 e0 05	 shl	 eax, 5
  00009	03 01		 add	 eax, DWORD PTR [ecx]

; 941  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@ULandStunInfo@@V?$allocator@ULandStunInfo@@@std@@@std@@QAEAAULandStunInfo@@I@Z ENDP ; std::vector<LandStunInfo,std::allocator<LandStunInfo> >::operator[]
_TEXT	ENDS
PUBLIC	?GetAt@?$ioTPtrGrowArray@VioBuff@@@@QBEPAVioBuff@@H@Z ; ioTPtrGrowArray<ioBuff>::GetAt
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iotptrgrowarray.h
;	COMDAT ?GetAt@?$ioTPtrGrowArray@VioBuff@@@@QBEPAVioBuff@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetAt@?$ioTPtrGrowArray@VioBuff@@@@QBEPAVioBuff@@H@Z PROC ; ioTPtrGrowArray<ioBuff>::GetAt, COMDAT
; _this$ = ecx

; 60   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 61   : 		if( i>=0 && i<m_iMaxCount )

  00003	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN1@GetAt
  0000a	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0000d	7d 07		 jge	 SHORT $LN1@GetAt

; 62   : 			return m_pBase[i];

  0000f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00011	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00014	eb 02		 jmp	 SHORT $LN2@GetAt
$LN1@GetAt:

; 63   : 
; 64   : 		return NULL;

  00016	33 c0		 xor	 eax, eax
$LN2@GetAt:

; 65   : 	}

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?GetAt@?$ioTPtrGrowArray@VioBuff@@@@QBEPAVioBuff@@H@Z ENDP ; ioTPtrGrowArray<ioBuff>::GetAt
_TEXT	ENDS
PUBLIC	?MaxCount@?$ioTPtrGrowArray@VioBuff@@@@QBEHXZ	; ioTPtrGrowArray<ioBuff>::MaxCount
; Function compile flags: /Ogsp
;	COMDAT ?MaxCount@?$ioTPtrGrowArray@VioBuff@@@@QBEHXZ
_TEXT	SEGMENT
?MaxCount@?$ioTPtrGrowArray@VioBuff@@@@QBEHXZ PROC	; ioTPtrGrowArray<ioBuff>::MaxCount, COMDAT
; _this$ = ecx

; 67   : 	inline int MaxCount() const { return m_iMaxCount; }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?MaxCount@?$ioTPtrGrowArray@VioBuff@@@@QBEHXZ ENDP	; ioTPtrGrowArray<ioBuff>::MaxCount
_TEXT	ENDS
PUBLIC	?_Inside@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IBE_NPBUBuffInfoStruct@@@Z ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Inside
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IBE_NPBUBuffInfoStruct@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IBE_NPBUBuffInfoStruct@@@Z PROC ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 09		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 05		 ja	 SHORT $LN3@Inside
  0000f	33 c0		 xor	 eax, eax
  00011	40		 inc	 eax
  00012	eb 02		 jmp	 SHORT $LN4@Inside
$LN3@Inside:
  00014	33 c0		 xor	 eax, eax
$LN4@Inside:

; 1287 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?_Inside@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IBE_NPBUBuffInfoStruct@@@Z ENDP ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Inside
_TEXT	ENDS
PUBLIC	?_Orphan_range@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IBEXPAUBuffInfoStruct@@0@Z ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Orphan_range
; Function compile flags: /Ogsp
;	COMDAT ?_Orphan_range@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IBEXPAUBuffInfoStruct@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IBEXPAUBuffInfoStruct@@0@Z PROC ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1454 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IBEXPAUBuffInfoStruct@@0@Z ENDP ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Orphan_range
_TEXT	ENDS
PUBLIC	?DecryptValueToPool@?$CEncrypt@W4BlowWoundedState@@@@QAEXPAW4BlowWoundedState@@@Z ; CEncrypt<enum BlowWoundedState>::DecryptValueToPool
EXTRN	?DecryptByte@ccddaabb@@QBEXPBDPADH@Z:PROC	; ccddaabb::DecryptByte
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
;	COMDAT ?DecryptValueToPool@?$CEncrypt@W4BlowWoundedState@@@@QAEXPAW4BlowWoundedState@@@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?DecryptValueToPool@?$CEncrypt@W4BlowWoundedState@@@@QAEXPAW4BlowWoundedState@@@Z PROC ; CEncrypt<enum BlowWoundedState>::DecryptValueToPool, COMDAT
; _this$ = ecx

; 2397 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2398 : 		m_RC5.DecryptByte( m_MemPool, m_TempMem, sizeof(BlowWoundedState) );

  00004	8d 71 28	 lea	 esi, DWORD PTR [ecx+40]
  00007	6a 04		 push	 4
  00009	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00011	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte

; 2399 : 		*value = *((BlowWoundedState*)m_TempMem);

  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0001b	89 01		 mov	 DWORD PTR [ecx], eax
  0001d	5e		 pop	 esi

; 2400 : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?DecryptValueToPool@?$CEncrypt@W4BlowWoundedState@@@@QAEXPAW4BlowWoundedState@@@Z ENDP ; CEncrypt<enum BlowWoundedState>::DecryptValueToPool
_TEXT	ENDS
PUBLIC	?DecryptValueToPool@?$CEncrypt@W4ProtectionMode@@@@QAEXPAW4ProtectionMode@@@Z ; CEncrypt<enum ProtectionMode>::DecryptValueToPool
; Function compile flags: /Ogsp
;	COMDAT ?DecryptValueToPool@?$CEncrypt@W4ProtectionMode@@@@QAEXPAW4ProtectionMode@@@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?DecryptValueToPool@?$CEncrypt@W4ProtectionMode@@@@QAEXPAW4ProtectionMode@@@Z PROC ; CEncrypt<enum ProtectionMode>::DecryptValueToPool, COMDAT
; _this$ = ecx

; 2879 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2880 : 		m_RC5.DecryptByte( m_MemPool, m_TempMem, sizeof(ProtectionMode) );

  00004	8d 71 28	 lea	 esi, DWORD PTR [ecx+40]
  00007	6a 04		 push	 4
  00009	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00011	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte

; 2881 : 		*value = *((ProtectionMode*)m_TempMem);

  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0001b	89 01		 mov	 DWORD PTR [ecx], eax
  0001d	5e		 pop	 esi

; 2882 : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?DecryptValueToPool@?$CEncrypt@W4ProtectionMode@@@@QAEXPAW4ProtectionMode@@@Z ENDP ; CEncrypt<enum ProtectionMode>::DecryptValueToPool
_TEXT	ENDS
PUBLIC	__real@3f91df46a2526c7a
PUBLIC	??$DEGtoRAD@M@@YAMM@Z				; DEGtoRAD<float>
;	COMDAT __real@3f91df46a2526c7a
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\veryoftenusedefine.h
CONST	SEGMENT
__real@3f91df46a2526c7a DQ 03f91df46a2526c7ar	; 0.0174533
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??$DEGtoRAD@M@@YAMM@Z
_TEXT	SEGMENT
tv129 = 8						; size = 4
_val$ = 8						; size = 4
??$DEGtoRAD@M@@YAMM@Z PROC				; DEGtoRAD<float>, COMDAT

; 20   : type  DEGtoRAD (type val) {return (type) (val * 0.0174532925199);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR _val$[ebp]
  00006	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3f91df46a2526c7a
  0000c	d9 5d 08	 fstp	 DWORD PTR tv129[ebp]
  0000f	d9 45 08	 fld	 DWORD PTR tv129[ebp]
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$DEGtoRAD@M@@YAMM@Z ENDP				; DEGtoRAD<float>
_TEXT	ENDS
PUBLIC	??$addressof@$$CBUBuffInfoStruct@@@std@@YAPBUBuffInfoStruct@@ABU1@@Z ; std::addressof<BuffInfoStruct const >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$addressof@$$CBUBuffInfoStruct@@@std@@YAPBUBuffInfoStruct@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUBuffInfoStruct@@@std@@YAPBUBuffInfoStruct@@ABU1@@Z PROC ; std::addressof<BuffInfoStruct const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBUBuffInfoStruct@@@std@@YAPBUBuffInfoStruct@@ABU1@@Z ENDP ; std::addressof<BuffInfoStruct const >
_TEXT	ENDS
PUBLIC	??$forward@ABUBuffInfoStruct@@@std@@YAABUBuffInfoStruct@@ABU1@@Z ; std::forward<BuffInfoStruct const &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABUBuffInfoStruct@@@std@@YAABUBuffInfoStruct@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUBuffInfoStruct@@@std@@YAABUBuffInfoStruct@@ABU1@@Z PROC ; std::forward<BuffInfoStruct const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUBuffInfoStruct@@@std@@YAABUBuffInfoStruct@@ABU1@@Z ENDP ; std::forward<BuffInfoStruct const &>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUBuffInfoStruct@@@std@@YAPAUBuffInfoStruct@@PAU1@@Z ; std::_Val_type<BuffInfoStruct *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAUBuffInfoStruct@@@std@@YAPAUBuffInfoStruct@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUBuffInfoStruct@@@std@@YAPAUBuffInfoStruct@@PAU1@@Z PROC ; std::_Val_type<BuffInfoStruct *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAUBuffInfoStruct@@@std@@YAPAUBuffInfoStruct@@PAU1@@Z ENDP ; std::_Val_type<BuffInfoStruct *>
_TEXT	ENDS
PUBLIC	??$forward@UBuffInfoStruct@@@std@@YA$$QAUBuffInfoStruct@@AAU1@@Z ; std::forward<BuffInfoStruct>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@UBuffInfoStruct@@@std@@YA$$QAUBuffInfoStruct@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UBuffInfoStruct@@@std@@YA$$QAUBuffInfoStruct@@AAU1@@Z PROC ; std::forward<BuffInfoStruct>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@UBuffInfoStruct@@@std@@YA$$QAUBuffInfoStruct@@AAU1@@Z ENDP ; std::forward<BuffInfoStruct>
_TEXT	ENDS
PUBLIC	?GetReflectPower@ReflectInfo@@QAEMM@Z		; ReflectInfo::GetReflectPower
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\playentityhelpstruct.h
;	COMDAT ?GetReflectPower@ReflectInfo@@QAEMM@Z
_TEXT	SEGMENT
_fPower$ = 8						; size = 4
?GetReflectPower@ReflectInfo@@QAEMM@Z PROC		; ReflectInfo::GetReflectPower, COMDAT
; _this$ = ecx

; 542  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 543  : 		fPower *= m_fReflectPowerRate;

  00003	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _fPower$[ebp]
  00008	f3 0f 10 41 14	 movss	 xmm0, DWORD PTR [ecx+20]
  0000d	0f 5a c9	 cvtps2pd xmm1, xmm1
  00010	0f 5a c0	 cvtps2pd xmm0, xmm0
  00013	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00017	0f 57 c9	 xorps	 xmm1, xmm1
  0001a	66 0f 5a c8	 cvtpd2ps xmm1, xmm0

; 544  : 		fPower = max( m_fReflectMinPower, fPower );

  0001e	f3 0f 10 41 18	 movss	 xmm0, DWORD PTR [ecx+24]
  00023	f3 0f 11 4d 08	 movss	 DWORD PTR _fPower$[ebp], xmm1
  00028	0f 5a d0	 cvtps2pd xmm2, xmm0
  0002b	0f 5a c9	 cvtps2pd xmm1, xmm1
  0002e	66 0f 2f d1	 comisd	 xmm2, xmm1
  00032	76 05		 jbe	 SHORT $LN3@GetReflect
  00034	f3 0f 11 45 08	 movss	 DWORD PTR _fPower$[ebp], xmm0
$LN3@GetReflect:

; 545  : 		fPower = min( fPower, m_fReflectMaxPower );

  00039	f3 0f 10 41 1c	 movss	 xmm0, DWORD PTR [ecx+28]
  0003e	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _fPower$[ebp]
  00043	0f 5a c9	 cvtps2pd xmm1, xmm1
  00046	0f 5a d0	 cvtps2pd xmm2, xmm0
  00049	66 0f 2f d1	 comisd	 xmm2, xmm1
  0004d	77 05		 ja	 SHORT $LN6@GetReflect
  0004f	f3 0f 11 45 08	 movss	 DWORD PTR _fPower$[ebp], xmm0
$LN6@GetReflect:

; 546  : 		return fPower;

  00054	d9 45 08	 fld	 DWORD PTR _fPower$[ebp]

; 547  : 	}

  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
?GetReflectPower@ReflectInfo@@QAEMM@Z ENDP		; ReflectInfo::GetReflectPower
_TEXT	ENDS
PUBLIC	__real@4f800000
PUBLIC	??0FrontBackWoundInfo@@QAE@XZ			; FrontBackWoundInfo::FrontBackWoundInfo
EXTRN	__imp_??0ioHashString@@QAE@XZ:PROC
;	COMDAT __real@4f800000
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stdafx.h
CONST	SEGMENT
__real@4f800000 DD 04f800000r			; 4.29497e+009
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0FrontBackWoundInfo@@QAE@XZ DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$??0FrontBackWoundInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0FrontBackWoundInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0FrontBackWoundInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0FrontBackWoundInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0FrontBackWoundInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0FrontBackWoundInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0FrontBackWoundInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0FrontBackWoundInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0FrontBackWoundInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0FrontBackWoundInfo@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??0FrontBackWoundInfo@@QAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??0FrontBackWoundInfo@@QAE@XZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??0FrontBackWoundInfo@@QAE@XZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??0FrontBackWoundInfo@@QAE@XZ$11
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\playentityhelpstruct.h
xdata$x	ENDS
;	COMDAT ??0FrontBackWoundInfo@@QAE@XZ
_TEXT	SEGMENT
tv258 = -16						; size = 4
tv254 = -16						; size = 4
tv250 = -16						; size = 4
tv246 = -16						; size = 4
tv242 = -16						; size = 4
tv238 = -16						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0FrontBackWoundInfo@@QAE@XZ PROC			; FrontBackWoundInfo::FrontBackWoundInfo, COMDAT
; _this$ = ecx

; 993  : 	FrontBackWoundInfo()

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0FrontBackWoundInfo@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_??0ioHashString@@QAE@XZ
  00017	ff d7		 call	 edi
  00019	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0001d	8d 4e 10	 lea	 ecx, DWORD PTR [esi+16]
  00020	ff d7		 call	 edi
  00022	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  00025	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00029	ff d7		 call	 edi
  0002b	8d 4e 34	 lea	 ecx, DWORD PTR [esi+52]
  0002e	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00032	ff d7		 call	 edi
  00034	8d 4e 44	 lea	 ecx, DWORD PTR [esi+68]
  00037	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0003b	ff d7		 call	 edi
  0003d	8d 4e 58	 lea	 ecx, DWORD PTR [esi+88]
  00040	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00044	ff d7		 call	 edi
  00046	8d 4e 68	 lea	 ecx, DWORD PTR [esi+104]
  00049	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0004d	ff d7		 call	 edi
  0004f	8d 4e 7c	 lea	 ecx, DWORD PTR [esi+124]
  00052	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00056	ff d7		 call	 edi
  00058	8d 8e 8c 00 00
	00		 lea	 ecx, DWORD PTR [esi+140]
  0005e	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00062	ff d7		 call	 edi
  00064	8d 8e a0 00 00
	00		 lea	 ecx, DWORD PTR [esi+160]
  0006a	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  0006e	ff d7		 call	 edi
  00070	8d 8e b0 00 00
	00		 lea	 ecx, DWORD PTR [esi+176]
  00076	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  0007a	ff d7		 call	 edi
  0007c	8d 8e c4 00 00
	00		 lea	 ecx, DWORD PTR [esi+196]
  00082	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  00086	ff d7		 call	 edi
  00088	8d 8e d4 00 00
	00		 lea	 ecx, DWORD PTR [esi+212]
  0008e	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  00092	ff d7		 call	 edi

; 994  : 	{
; 995  : 		m_fFrontDamageRate = FLOAT1;

  00094	b8 01 00 00 00	 mov	 eax, 1
  00099	89 45 f0	 mov	 DWORD PTR tv258[ebp], eax
  0009c	db 45 f0	 fild	 DWORD PTR tv258[ebp]
  0009f	85 c0		 test	 eax, eax
  000a1	79 06		 jns	 SHORT $LN29@FrontBackW
  000a3	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN29@FrontBackW:
  000a9	d9 5e 30	 fstp	 DWORD PTR [esi+48]

; 996  : 		m_fBackDamageRate = FLOAT1;

  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	89 45 f0	 mov	 DWORD PTR tv254[ebp], eax
  000b4	db 45 f0	 fild	 DWORD PTR tv254[ebp]
  000b7	85 c0		 test	 eax, eax
  000b9	79 06		 jns	 SHORT $LN30@FrontBackW
  000bb	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN30@FrontBackW:
  000c1	d9 5e 54	 fstp	 DWORD PTR [esi+84]

; 997  : 
; 998  : 		m_fDownFrontDamageRate = FLOAT1;

  000c4	b8 01 00 00 00	 mov	 eax, 1
  000c9	89 45 f0	 mov	 DWORD PTR tv250[ebp], eax
  000cc	db 45 f0	 fild	 DWORD PTR tv250[ebp]
  000cf	85 c0		 test	 eax, eax
  000d1	79 06		 jns	 SHORT $LN31@FrontBackW
  000d3	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN31@FrontBackW:
  000d9	d9 5e 78	 fstp	 DWORD PTR [esi+120]

; 999  : 		m_fDownBackDamageRate = FLOAT1;

  000dc	b8 01 00 00 00	 mov	 eax, 1
  000e1	89 45 f0	 mov	 DWORD PTR tv246[ebp], eax
  000e4	db 45 f0	 fild	 DWORD PTR tv246[ebp]
  000e7	85 c0		 test	 eax, eax
  000e9	79 06		 jns	 SHORT $LN32@FrontBackW
  000eb	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN32@FrontBackW:
  000f1	d9 9e 9c 00 00
	00		 fstp	 DWORD PTR [esi+156]

; 1000 : 
; 1001 : 		m_fAirFrontDamageRate = FLOAT1;

  000f7	b8 01 00 00 00	 mov	 eax, 1
  000fc	89 45 f0	 mov	 DWORD PTR tv242[ebp], eax
  000ff	db 45 f0	 fild	 DWORD PTR tv242[ebp]
  00102	85 c0		 test	 eax, eax
  00104	79 06		 jns	 SHORT $LN33@FrontBackW
  00106	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN33@FrontBackW:
  0010c	d9 9e c0 00 00
	00		 fstp	 DWORD PTR [esi+192]

; 1002 : 		m_fAirBackDamageRate = FLOAT1;

  00112	b8 01 00 00 00	 mov	 eax, 1
  00117	89 45 f0	 mov	 DWORD PTR tv238[ebp], eax
  0011a	db 45 f0	 fild	 DWORD PTR tv238[ebp]
  0011d	85 c0		 test	 eax, eax
  0011f	79 06		 jns	 SHORT $LN34@FrontBackW
  00121	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN34@FrontBackW:
  00127	d9 9e e4 00 00
	00		 fstp	 DWORD PTR [esi+228]

; 1003 : 	}

  0012d	8b c6		 mov	 eax, esi
  0012f	e8 00 00 00 00	 call	 __EH_epilog3
  00134	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0FrontBackWoundInfo@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??0FrontBackWoundInfo@@QAE@XZ$1:
  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 10	 add	 ecx, 16			; 00000010H
  0000f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??0FrontBackWoundInfo@@QAE@XZ$2:
  00015	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	83 c1 20	 add	 ecx, 32			; 00000020H
  0001b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??0FrontBackWoundInfo@@QAE@XZ$3:
  00021	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 34	 add	 ecx, 52			; 00000034H
  00027	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??0FrontBackWoundInfo@@QAE@XZ$4:
  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	83 c1 44	 add	 ecx, 68			; 00000044H
  00033	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??0FrontBackWoundInfo@@QAE@XZ$5:
  00039	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	83 c1 58	 add	 ecx, 88			; 00000058H
  0003f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??0FrontBackWoundInfo@@QAE@XZ$6:
  00045	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	83 c1 68	 add	 ecx, 104		; 00000068H
  0004b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??0FrontBackWoundInfo@@QAE@XZ$7:
  00051	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00057	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??0FrontBackWoundInfo@@QAE@XZ$8:
  0005d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  00066	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??0FrontBackWoundInfo@@QAE@XZ$9:
  0006c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	81 c1 a0 00 00
	00		 add	 ecx, 160		; 000000a0H
  00075	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??0FrontBackWoundInfo@@QAE@XZ$10:
  0007b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	81 c1 b0 00 00
	00		 add	 ecx, 176		; 000000b0H
  00084	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??0FrontBackWoundInfo@@QAE@XZ$11:
  0008a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	81 c1 c4 00 00
	00		 add	 ecx, 196		; 000000c4H
  00093	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$??0FrontBackWoundInfo@@QAE@XZ:
  00099	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0009d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000a0	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  000a3	33 c8		 xor	 ecx, eax
  000a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000aa	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0FrontBackWoundInfo@@QAE@XZ
  000af	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0FrontBackWoundInfo@@QAE@XZ ENDP			; FrontBackWoundInfo::FrontBackWoundInfo
PUBLIC	??_R0?AVioGameEntity@@@8			; ioGameEntity `RTTI Type Descriptor'
PUBLIC	??_R0?AVioPlayEntity@@@8			; ioPlayEntity `RTTI Type Descriptor'
PUBLIC	?ToPlayEntity@@YAPAVioPlayEntity@@PAVioGameEntity@@@Z ; ToPlayEntity
;	COMDAT ??_R0?AVioGameEntity@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioplayentity.h
_DATA	SEGMENT
??_R0?AVioGameEntity@@@8 DD FLAT:??_7type_info@@6B@	; ioGameEntity `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioGameEntity@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVioPlayEntity@@@8
_DATA	SEGMENT
??_R0?AVioPlayEntity@@@8 DD FLAT:??_7type_info@@6B@	; ioPlayEntity `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioPlayEntity@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToPlayEntity@@YAPAVioPlayEntity@@PAVioGameEntity@@@Z
_TEXT	SEGMENT
_pObj$ = 8						; size = 4
?ToPlayEntity@@YAPAVioPlayEntity@@PAVioGameEntity@@@Z PROC ; ToPlayEntity, COMDAT

; 121  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 122  : 	if( !pObj || pObj->GetTypeID() != ioGameEntity::GET_PLAY_ENTITY )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pObj$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 25		 je	 SHORT $LN1@ToPlayEnti
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 50 10	 call	 DWORD PTR [eax+16]
  00012	83 f8 01	 cmp	 eax, 1
  00015	75 19		 jne	 SHORT $LN1@ToPlayEnti

; 124  : 
; 125  : 	return dynamic_cast< ioPlayEntity* >( pObj );

  00017	6a 00		 push	 0
  00019	68 00 00 00 00	 push	 OFFSET ??_R0?AVioPlayEntity@@@8
  0001e	68 00 00 00 00	 push	 OFFSET ??_R0?AVioGameEntity@@@8
  00023	6a 00		 push	 0
  00025	56		 push	 esi
  00026	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002b	83 c4 14	 add	 esp, 20			; 00000014H
  0002e	eb 02		 jmp	 SHORT $LN3@ToPlayEnti
$LN1@ToPlayEnti:

; 123  : 		return NULL;

  00030	33 c0		 xor	 eax, eax
$LN3@ToPlayEnti:
  00032	5e		 pop	 esi

; 126  : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?ToPlayEntity@@YAPAVioPlayEntity@@PAVioGameEntity@@@Z ENDP ; ToPlayEntity
_TEXT	ENDS
PUBLIC	??1tagBlowWoundAniInfo@@QAE@XZ			; tagBlowWoundAniInfo::~tagBlowWoundAniInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1tagBlowWoundAniInfo@@QAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??1tagBlowWoundAniInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1tagBlowWoundAniInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1tagBlowWoundAniInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1tagBlowWoundAniInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1tagBlowWoundAniInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1tagBlowWoundAniInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1tagBlowWoundAniInfo@@QAE@XZ$4
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??1tagBlowWoundAniInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1tagBlowWoundAniInfo@@QAE@XZ PROC			; tagBlowWoundAniInfo::~tagBlowWoundAniInfo, COMDAT
; _this$ = ecx
  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??1tagBlowWoundAniInfo@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f9		 mov	 edi, ecx
  0000e	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  00011	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00017	8d 4f 50	 lea	 ecx, DWORD PTR [edi+80]
  0001a	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4
  00021	ff d6		 call	 esi
  00023	8d 4f 40	 lea	 ecx, DWORD PTR [edi+64]
  00026	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0002a	ff d6		 call	 esi
  0002c	8d 4f 30	 lea	 ecx, DWORD PTR [edi+48]
  0002f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00033	ff d6		 call	 esi
  00035	8d 4f 20	 lea	 ecx, DWORD PTR [edi+32]
  00038	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0003c	ff d6		 call	 esi
  0003e	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  00041	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00045	ff d6		 call	 esi
  00047	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0004b	8b cf		 mov	 ecx, edi
  0004d	ff d6		 call	 esi
  0004f	e8 00 00 00 00	 call	 __EH_epilog3
  00054	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1tagBlowWoundAniInfo@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??1tagBlowWoundAniInfo@@QAE@XZ$1:
  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 10	 add	 ecx, 16			; 00000010H
  0000f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??1tagBlowWoundAniInfo@@QAE@XZ$2:
  00015	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	83 c1 20	 add	 ecx, 32			; 00000020H
  0001b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??1tagBlowWoundAniInfo@@QAE@XZ$3:
  00021	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 30	 add	 ecx, 48			; 00000030H
  00027	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??1tagBlowWoundAniInfo@@QAE@XZ$4:
  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	83 c1 40	 add	 ecx, 64			; 00000040H
  00033	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$??1tagBlowWoundAniInfo@@QAE@XZ:
  00039	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0003d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00040	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00043	33 c8		 xor	 ecx, eax
  00045	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1tagBlowWoundAniInfo@@QAE@XZ
  0004f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1tagBlowWoundAniInfo@@QAE@XZ ENDP			; tagBlowWoundAniInfo::~tagBlowWoundAniInfo
PUBLIC	??1BuffInfoStruct@@QAE@XZ			; BuffInfoStruct::~BuffInfoStruct
; Function compile flags: /Ogsp
;	COMDAT ??1BuffInfoStruct@@QAE@XZ
_TEXT	SEGMENT
??1BuffInfoStruct@@QAE@XZ PROC				; BuffInfoStruct::~BuffInfoStruct, COMDAT
; _this$ = ecx
  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
??1BuffInfoStruct@@QAE@XZ ENDP				; BuffInfoStruct::~BuffInfoStruct
_TEXT	ENDS
PUBLIC	?GetCalcActionDelayPassType@ioWeapon@@QAE_NXZ	; ioWeapon::GetCalcActionDelayPassType
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioweapon.h
;	COMDAT ?GetCalcActionDelayPassType@ioWeapon@@QAE_NXZ
_TEXT	SEGMENT
?GetCalcActionDelayPassType@ioWeapon@@QAE_NXZ PROC	; ioWeapon::GetCalcActionDelayPassType, COMDAT
; _this$ = ecx

; 436  : 	bool GetCalcActionDelayPassType(){ return m_bPassCalcDamageActionStopDelay; }

  00000	8a 81 38 08 00
	00		 mov	 al, BYTE PTR [ecx+2104]
  00006	c3		 ret	 0
?GetCalcActionDelayPassType@ioWeapon@@QAE_NXZ ENDP	; ioWeapon::GetCalcActionDelayPassType
_TEXT	ENDS
PUBLIC	?CheckWeaponBySkill@ioWeapon@@QBE_NXZ		; ioWeapon::CheckWeaponBySkill
; Function compile flags: /Ogsp
;	COMDAT ?CheckWeaponBySkill@ioWeapon@@QBE_NXZ
_TEXT	SEGMENT
?CheckWeaponBySkill@ioWeapon@@QBE_NXZ PROC		; ioWeapon::CheckWeaponBySkill, COMDAT
; _this$ = ecx

; 484  : 	inline bool CheckWeaponBySkill() const { return m_bUseSkill; }

  00000	8a 81 7e 05 00
	00		 mov	 al, BYTE PTR [ecx+1406]
  00006	c3		 ret	 0
?CheckWeaponBySkill@ioWeapon@@QBE_NXZ ENDP		; ioWeapon::CheckWeaponBySkill
_TEXT	ENDS
PUBLIC	?CheckWeaponByBuff@ioWeapon@@QBE_NXZ		; ioWeapon::CheckWeaponByBuff
; Function compile flags: /Ogsp
;	COMDAT ?CheckWeaponByBuff@ioWeapon@@QBE_NXZ
_TEXT	SEGMENT
?CheckWeaponByBuff@ioWeapon@@QBE_NXZ PROC		; ioWeapon::CheckWeaponByBuff, COMDAT
; _this$ = ecx

; 485  : 	inline bool CheckWeaponByBuff() const { return m_bBuffWeapon; }

  00000	8a 81 7c 05 00
	00		 mov	 al, BYTE PTR [ecx+1404]
  00006	c3		 ret	 0
?CheckWeaponByBuff@ioWeapon@@QBE_NXZ ENDP		; ioWeapon::CheckWeaponByBuff
_TEXT	ENDS
PUBLIC	?CheckWeaponByJump@ioWeapon@@QBE_NXZ		; ioWeapon::CheckWeaponByJump
; Function compile flags: /Ogsp
;	COMDAT ?CheckWeaponByJump@ioWeapon@@QBE_NXZ
_TEXT	SEGMENT
?CheckWeaponByJump@ioWeapon@@QBE_NXZ PROC		; ioWeapon::CheckWeaponByJump, COMDAT
; _this$ = ecx

; 487  : 	inline bool CheckWeaponByJump() const { return m_bJumpAttack; }

  00000	8a 81 7f 05 00
	00		 mov	 al, BYTE PTR [ecx+1407]
  00006	c3		 ret	 0
?CheckWeaponByJump@ioWeapon@@QBE_NXZ ENDP		; ioWeapon::CheckWeaponByJump
_TEXT	ENDS
PUBLIC	?CheckWeaponByStruct@ioWeapon@@QBE_NXZ		; ioWeapon::CheckWeaponByStruct
; Function compile flags: /Ogsp
;	COMDAT ?CheckWeaponByStruct@ioWeapon@@QBE_NXZ
_TEXT	SEGMENT
?CheckWeaponByStruct@ioWeapon@@QBE_NXZ PROC		; ioWeapon::CheckWeaponByStruct, COMDAT
; _this$ = ecx

; 488  : 	inline bool CheckWeaponByStruct() const { return m_bStructWeapon; }

  00000	8a 81 8c 05 00
	00		 mov	 al, BYTE PTR [ecx+1420]
  00006	c3		 ret	 0
?CheckWeaponByStruct@ioWeapon@@QBE_NXZ ENDP		; ioWeapon::CheckWeaponByStruct
_TEXT	ENDS
PUBLIC	?CheckWeaponByDummyChar@ioWeapon@@QBE_NXZ	; ioWeapon::CheckWeaponByDummyChar
; Function compile flags: /Ogsp
;	COMDAT ?CheckWeaponByDummyChar@ioWeapon@@QBE_NXZ
_TEXT	SEGMENT
?CheckWeaponByDummyChar@ioWeapon@@QBE_NXZ PROC		; ioWeapon::CheckWeaponByDummyChar, COMDAT
; _this$ = ecx

; 489  : 	inline bool CheckWeaponByDummyChar() const { return m_bDummyCharWeapon; }

  00000	8a 81 9c 05 00
	00		 mov	 al, BYTE PTR [ecx+1436]
  00006	c3		 ret	 0
?CheckWeaponByDummyChar@ioWeapon@@QBE_NXZ ENDP		; ioWeapon::CheckWeaponByDummyChar
_TEXT	ENDS
PUBLIC	?CheckWeaponByFloatBreak@ioWeapon@@QBE_NXZ	; ioWeapon::CheckWeaponByFloatBreak
; Function compile flags: /Ogsp
;	COMDAT ?CheckWeaponByFloatBreak@ioWeapon@@QBE_NXZ
_TEXT	SEGMENT
?CheckWeaponByFloatBreak@ioWeapon@@QBE_NXZ PROC		; ioWeapon::CheckWeaponByFloatBreak, COMDAT
; _this$ = ecx

; 491  : 	inline bool CheckWeaponByFloatBreak() const { return m_bFloatStateBreak; }

  00000	8a 81 83 05 00
	00		 mov	 al, BYTE PTR [ecx+1411]
  00006	c3		 ret	 0
?CheckWeaponByFloatBreak@ioWeapon@@QBE_NXZ ENDP		; ioWeapon::CheckWeaponByFloatBreak
_TEXT	ENDS
PUBLIC	?GetWeaponIndex@ioWeapon@@QBEKXZ		; ioWeapon::GetWeaponIndex
; Function compile flags: /Ogsp
;	COMDAT ?GetWeaponIndex@ioWeapon@@QBEKXZ
_TEXT	SEGMENT
?GetWeaponIndex@ioWeapon@@QBEKXZ PROC			; ioWeapon::GetWeaponIndex, COMDAT
; _this$ = ecx

; 536  : 	inline DWORD GetWeaponIndex() const { return m_dwWeaponIdx; }

  00000	8b 81 b8 04 00
	00		 mov	 eax, DWORD PTR [ecx+1208]
  00006	c3		 ret	 0
?GetWeaponIndex@ioWeapon@@QBEKXZ ENDP			; ioWeapon::GetWeaponIndex
_TEXT	ENDS
PUBLIC	?IsLoopWoundedAnimation@ioWeapon@@QBE_NXZ	; ioWeapon::IsLoopWoundedAnimation
; Function compile flags: /Ogsp
;	COMDAT ?IsLoopWoundedAnimation@ioWeapon@@QBE_NXZ
_TEXT	SEGMENT
?IsLoopWoundedAnimation@ioWeapon@@QBE_NXZ PROC		; ioWeapon::IsLoopWoundedAnimation, COMDAT
; _this$ = ecx

; 539  : 	inline bool IsLoopWoundedAnimation() const { return m_bLoopWoundedAni; }

  00000	8a 81 bc 04 00
	00		 mov	 al, BYTE PTR [ecx+1212]
  00006	c3		 ret	 0
?IsLoopWoundedAnimation@ioWeapon@@QBE_NXZ ENDP		; ioWeapon::IsLoopWoundedAnimation
_TEXT	ENDS
PUBLIC	?GetWoundedAnimation@ioWeapon@@QBEABVioHashString@@XZ ; ioWeapon::GetWoundedAnimation
; Function compile flags: /Ogsp
;	COMDAT ?GetWoundedAnimation@ioWeapon@@QBEABVioHashString@@XZ
_TEXT	SEGMENT
?GetWoundedAnimation@ioWeapon@@QBEABVioHashString@@XZ PROC ; ioWeapon::GetWoundedAnimation, COMDAT
; _this$ = ecx

; 540  : 	inline const ioHashString& GetWoundedAnimation() const { return m_WoundedAnimation; }

  00000	8d 81 c0 04 00
	00		 lea	 eax, DWORD PTR [ecx+1216]
  00006	c3		 ret	 0
?GetWoundedAnimation@ioWeapon@@QBEABVioHashString@@XZ ENDP ; ioWeapon::GetWoundedAnimation
_TEXT	ENDS
PUBLIC	?CheckWoundSkill@ioWeapon@@QBE_NXZ		; ioWeapon::CheckWoundSkill
; Function compile flags: /Ogsp
;	COMDAT ?CheckWoundSkill@ioWeapon@@QBE_NXZ
_TEXT	SEGMENT
?CheckWoundSkill@ioWeapon@@QBE_NXZ PROC			; ioWeapon::CheckWoundSkill, COMDAT
; _this$ = ecx

; 554  : 	inline bool CheckWoundSkill() const { return m_bEnableWoundSkill; }

  00000	8a 81 84 05 00
	00		 mov	 al, BYTE PTR [ecx+1412]
  00006	c3		 ret	 0
?CheckWoundSkill@ioWeapon@@QBE_NXZ ENDP			; ioWeapon::CheckWoundSkill
_TEXT	ENDS
PUBLIC	?GetOwnerName@ioWeapon@@QBEABVioHashString@@XZ	; ioWeapon::GetOwnerName
; Function compile flags: /Ogsp
;	COMDAT ?GetOwnerName@ioWeapon@@QBEABVioHashString@@XZ
_TEXT	SEGMENT
?GetOwnerName@ioWeapon@@QBEABVioHashString@@XZ PROC	; ioWeapon::GetOwnerName, COMDAT
; _this$ = ecx

; 636  : 	inline const ioHashString& GetOwnerName() const { return m_OwnerName; }

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
  00003	c3		 ret	 0
?GetOwnerName@ioWeapon@@QBEABVioHashString@@XZ ENDP	; ioWeapon::GetOwnerName
_TEXT	ENDS
PUBLIC	?GetCreateItem@ioWeapon@@QBEABVioHashString@@XZ	; ioWeapon::GetCreateItem
; Function compile flags: /Ogsp
;	COMDAT ?GetCreateItem@ioWeapon@@QBEABVioHashString@@XZ
_TEXT	SEGMENT
?GetCreateItem@ioWeapon@@QBEABVioHashString@@XZ PROC	; ioWeapon::GetCreateItem, COMDAT
; _this$ = ecx

; 637  : 	inline const ioHashString& GetCreateItem() const { return m_CreateItem; }

  00000	8d 41 20	 lea	 eax, DWORD PTR [ecx+32]
  00003	c3		 ret	 0
?GetCreateItem@ioWeapon@@QBEABVioHashString@@XZ ENDP	; ioWeapon::GetCreateItem
_TEXT	ENDS
PUBLIC	?GetWeaponByDummyChar@ioWeapon@@QAE?BHXZ	; ioWeapon::GetWeaponByDummyChar
; Function compile flags: /Ogsp
;	COMDAT ?GetWeaponByDummyChar@ioWeapon@@QAE?BHXZ
_TEXT	SEGMENT
?GetWeaponByDummyChar@ioWeapon@@QAE?BHXZ PROC		; ioWeapon::GetWeaponByDummyChar, COMDAT
; _this$ = ecx

; 638  : 	inline const int GetWeaponByDummyChar() { return m_iDummyIndex; }

  00000	8b 81 98 05 00
	00		 mov	 eax, DWORD PTR [ecx+1432]
  00006	c3		 ret	 0
?GetWeaponByDummyChar@ioWeapon@@QAE?BHXZ ENDP		; ioWeapon::GetWeaponByDummyChar
_TEXT	ENDS
PUBLIC	?IsPush@ioWeapon@@QBE_NXZ			; ioWeapon::IsPush
; Function compile flags: /Ogsp
;	COMDAT ?IsPush@ioWeapon@@QBE_NXZ
_TEXT	SEGMENT
?IsPush@ioWeapon@@QBE_NXZ PROC				; ioWeapon::IsPush, COMDAT
; _this$ = ecx

; 800  : 	inline bool IsPush() const { return m_bSetPush; }

  00000	8a 81 65 08 00
	00		 mov	 al, BYTE PTR [ecx+2149]
  00006	c3		 ret	 0
?IsPush@ioWeapon@@QBE_NXZ ENDP				; ioWeapon::IsPush
_TEXT	ENDS
PUBLIC	?GetEnablePushPowerRate@ioWeapon@@QBEMXZ	; ioWeapon::GetEnablePushPowerRate
; Function compile flags: /Ogsp
;	COMDAT ?GetEnablePushPowerRate@ioWeapon@@QBEMXZ
_TEXT	SEGMENT
?GetEnablePushPowerRate@ioWeapon@@QBEMXZ PROC		; ioWeapon::GetEnablePushPowerRate, COMDAT
; _this$ = ecx

; 801  : 	inline float GetEnablePushPowerRate() const { return m_fEnablePushPowerRate; }

  00000	d9 81 68 08 00
	00		 fld	 DWORD PTR [ecx+2152]
  00006	c3		 ret	 0
?GetEnablePushPowerRate@ioWeapon@@QBEMXZ ENDP		; ioWeapon::GetEnablePushPowerRate
_TEXT	ENDS
PUBLIC	??_R0?AVioItem@@@8				; ioItem `RTTI Type Descriptor'
PUBLIC	??_R0?AVioWeaponItem@@@8			; ioWeaponItem `RTTI Type Descriptor'
PUBLIC	?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z	; ToWeaponItem
;	COMDAT ??_R0?AVioItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioweaponitem.h
_DATA	SEGMENT
??_R0?AVioItem@@@8 DD FLAT:??_7type_info@@6B@		; ioItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioItem@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVioWeaponItem@@@8
_DATA	SEGMENT
??_R0?AVioWeaponItem@@@8 DD FLAT:??_7type_info@@6B@	; ioWeaponItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioWeaponItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z PROC	; ToWeaponItem, COMDAT

; 303  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 304  : 	if( !pItem || pItem->GetType() != ioItem::IT_WEAPON )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pItem$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 25		 je	 SHORT $LN1@ToWeaponIt
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 50 08	 call	 DWORD PTR [eax+8]
  00012	83 f8 01	 cmp	 eax, 1
  00015	75 19		 jne	 SHORT $LN1@ToWeaponIt

; 306  : 
; 307  : 	return dynamic_cast< ioWeaponItem* >( pItem );

  00017	6a 00		 push	 0
  00019	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWeaponItem@@@8
  0001e	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  00023	6a 00		 push	 0
  00025	56		 push	 esi
  00026	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002b	83 c4 14	 add	 esp, 20			; 00000014H
  0002e	eb 02		 jmp	 SHORT $LN3@ToWeaponIt
$LN1@ToWeaponIt:

; 305  : 		return NULL;

  00030	33 c0		 xor	 eax, eax
$LN3@ToWeaponIt:
  00032	5e		 pop	 esi

; 308  : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ENDP	; ToWeaponItem
_TEXT	ENDS
PUBLIC	??_R0?AVioSkill@@@8				; ioSkill `RTTI Type Descriptor'
PUBLIC	??_R0?AVioPassiveSkill@@@8			; ioPassiveSkill `RTTI Type Descriptor'
PUBLIC	?ToPassiveSkill@@YAPAVioPassiveSkill@@PAVioSkill@@@Z ; ToPassiveSkill
;	COMDAT ??_R0?AVioSkill@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iopassiveskill.h
_DATA	SEGMENT
??_R0?AVioSkill@@@8 DD FLAT:??_7type_info@@6B@		; ioSkill `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioSkill@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVioPassiveSkill@@@8
_DATA	SEGMENT
??_R0?AVioPassiveSkill@@@8 DD FLAT:??_7type_info@@6B@	; ioPassiveSkill `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioPassiveSkill@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToPassiveSkill@@YAPAVioPassiveSkill@@PAVioSkill@@@Z
_TEXT	SEGMENT
_pSkill$ = 8						; size = 4
?ToPassiveSkill@@YAPAVioPassiveSkill@@PAVioSkill@@@Z PROC ; ToPassiveSkill, COMDAT

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 201  : 	if( !pSkill || pSkill->GetTypeID() != ST_PASSIVE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pSkill$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 25		 je	 SHORT $LN1@ToPassiveS
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 50 08	 call	 DWORD PTR [eax+8]
  00012	83 f8 04	 cmp	 eax, 4
  00015	75 19		 jne	 SHORT $LN1@ToPassiveS

; 203  : 	
; 204  : 	return dynamic_cast< ioPassiveSkill* >( pSkill );

  00017	6a 00		 push	 0
  00019	68 00 00 00 00	 push	 OFFSET ??_R0?AVioPassiveSkill@@@8
  0001e	68 00 00 00 00	 push	 OFFSET ??_R0?AVioSkill@@@8
  00023	6a 00		 push	 0
  00025	56		 push	 esi
  00026	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002b	83 c4 14	 add	 esp, 20			; 00000014H
  0002e	eb 02		 jmp	 SHORT $LN3@ToPassiveS
$LN1@ToPassiveS:

; 202  : 		return NULL;

  00030	33 c0		 xor	 eax, eax
$LN3@ToPassiveS:
  00032	5e		 pop	 esi

; 205  : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?ToPassiveSkill@@YAPAVioPassiveSkill@@PAVioSkill@@@Z ENDP ; ToPassiveSkill
_TEXT	ENDS
PUBLIC	??_R0?AVioNormalSkill@@@8			; ioNormalSkill `RTTI Type Descriptor'
PUBLIC	?ToNormalSkill@@YAPAVioNormalSkill@@PAVioSkill@@@Z ; ToNormalSkill
;	COMDAT ??_R0?AVioNormalSkill@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ionormalskill.h
_DATA	SEGMENT
??_R0?AVioNormalSkill@@@8 DD FLAT:??_7type_info@@6B@	; ioNormalSkill `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioNormalSkill@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToNormalSkill@@YAPAVioNormalSkill@@PAVioSkill@@@Z
_TEXT	SEGMENT
_pSkill$ = 8						; size = 4
?ToNormalSkill@@YAPAVioNormalSkill@@PAVioSkill@@@Z PROC	; ToNormalSkill, COMDAT

; 60   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 61   : 	if( !pSkill || pSkill->GetTypeID() != ST_NORMAL )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pSkill$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 25		 je	 SHORT $LN1@ToNormalSk
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 50 08	 call	 DWORD PTR [eax+8]
  00012	83 f8 03	 cmp	 eax, 3
  00015	75 19		 jne	 SHORT $LN1@ToNormalSk

; 63   : 
; 64   : 	return dynamic_cast< ioNormalSkill* >( pSkill );

  00017	6a 00		 push	 0
  00019	68 00 00 00 00	 push	 OFFSET ??_R0?AVioNormalSkill@@@8
  0001e	68 00 00 00 00	 push	 OFFSET ??_R0?AVioSkill@@@8
  00023	6a 00		 push	 0
  00025	56		 push	 esi
  00026	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002b	83 c4 14	 add	 esp, 20			; 00000014H
  0002e	eb 02		 jmp	 SHORT $LN3@ToNormalSk
$LN1@ToNormalSk:

; 62   : 		return NULL;

  00030	33 c0		 xor	 eax, eax
$LN3@ToNormalSk:
  00032	5e		 pop	 esi

; 65   : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?ToNormalSkill@@YAPAVioNormalSkill@@PAVioSkill@@@Z ENDP	; ToNormalSkill
_TEXT	ENDS
PUBLIC	?GetTypeID@ioBuff@@QBEHXZ			; ioBuff::GetTypeID
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobuff.h
;	COMDAT ?GetTypeID@ioBuff@@QBEHXZ
_TEXT	SEGMENT
?GetTypeID@ioBuff@@QBEHXZ PROC				; ioBuff::GetTypeID, COMDAT
; _this$ = ecx

; 424  : 	inline int GetTypeID() const { return m_iBuffType; }

  00000	8b 81 cc 03 00
	00		 mov	 eax, DWORD PTR [ecx+972]
  00006	c3		 ret	 0
?GetTypeID@ioBuff@@QBEHXZ ENDP				; ioBuff::GetTypeID
_TEXT	ENDS
PUBLIC	?GetCreatorName@ioBuff@@QBEABVioHashString@@XZ	; ioBuff::GetCreatorName
; Function compile flags: /Ogsp
;	COMDAT ?GetCreatorName@ioBuff@@QBEABVioHashString@@XZ
_TEXT	SEGMENT
?GetCreatorName@ioBuff@@QBEABVioHashString@@XZ PROC	; ioBuff::GetCreatorName, COMDAT
; _this$ = ecx

; 442  : 	inline const ioHashString& GetCreatorName() const { return m_CreateChar; }

  00000	8d 81 88 02 00
	00		 lea	 eax, DWORD PTR [ecx+648]
  00006	c3		 ret	 0
?GetCreatorName@ioBuff@@QBEABVioHashString@@XZ ENDP	; ioBuff::GetCreatorName
_TEXT	ENDS
PUBLIC	?GetModeState@ioPlayMode@@QBE?AW4ModeState@1@XZ	; ioPlayMode::GetModeState
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioplaymode.h
;	COMDAT ?GetModeState@ioPlayMode@@QBE?AW4ModeState@1@XZ
_TEXT	SEGMENT
?GetModeState@ioPlayMode@@QBE?AW4ModeState@1@XZ PROC	; ioPlayMode::GetModeState, COMDAT
; _this$ = ecx

; 632  : 	inline ModeState GetModeState() const { return m_ModeState; }

  00000	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00003	c3		 ret	 0
?GetModeState@ioPlayMode@@QBE?AW4ModeState@1@XZ ENDP	; ioPlayMode::GetModeState
_TEXT	ENDS
PUBLIC	?size@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBEIXZ ; std::vector<ioHashString,std::allocator<ioHashString> >::size
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?size@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBEIXZ PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 04	 sar	 eax, 4

; 880  : 		}

  00008	c3		 ret	 0
?size@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBEIXZ ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::size
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ ; std::_Vector_val<ioHashString,std::allocator<ioHashString> >::~_Vector_val<ioHashString,std::allocator<ioHashString> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<ioHashString,std::allocator<ioHashString> >::~_Vector_val<ioHashString,std::allocator<ioHashString> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<ioHashString,std::allocator<ioHashString> >::~_Vector_val<ioHashString,std::allocator<ioHashString> >
_TEXT	ENDS
PUBLIC	?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z	; CEncrypt<float>::EncryptValueToPool
EXTRN	?EncryptByte@ccddaabb@@QAEXPBDPADH@Z:PROC	; ccddaabb::EncryptByte
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
;	COMDAT ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z PROC	; CEncrypt<float>::EncryptValueToPool, COMDAT
; _this$ = ecx

; 67   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 		m_RC5.EncryptByte( value, m_MemPool, max(m_ValueSize, DEFAULT_ENCRYPT) );

  00003	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00007	83 f8 04	 cmp	 eax, 4
  0000a	77 03		 ja	 SHORT $LN4@EncryptVal
  0000c	6a 04		 push	 4
  0000e	58		 pop	 eax
$LN4@EncryptVal:
  0000f	50		 push	 eax
  00010	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  00013	50		 push	 eax
  00014	ff 75 08	 push	 DWORD PTR _value$[ebp]
  00017	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0001a	e8 00 00 00 00	 call	 ?EncryptByte@ccddaabb@@QAEXPBDPADH@Z ; ccddaabb::EncryptByte

; 69   : 		
; 70   : 	}

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ENDP	; CEncrypt<float>::EncryptValueToPool
_TEXT	ENDS
PUBLIC	?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z	; CEncrypt<float>::DecryptValueToPool
; Function compile flags: /Ogsp
;	COMDAT ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z PROC	; CEncrypt<float>::DecryptValueToPool, COMDAT
; _this$ = ecx

; 1648 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1649 : 		m_RC5.DecryptByte( m_MemPool, m_TempMem, 4 );

  00004	8d 71 28	 lea	 esi, DWORD PTR [ecx+40]
  00007	6a 04		 push	 4
  00009	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00011	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte

; 1650 : 		*value = *((float*)m_TempMem);

  00016	d9 06		 fld	 DWORD PTR [esi]
  00018	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  0001b	d9 18		 fstp	 DWORD PTR [eax]
  0001d	5e		 pop	 esi

; 1651 : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ENDP	; CEncrypt<float>::DecryptValueToPool
_TEXT	ENDS
PUBLIC	?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z	; CEncrypt<bool>::DecryptValueToPool
; Function compile flags: /Ogsp
;	COMDAT ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z PROC	; CEncrypt<bool>::DecryptValueToPool, COMDAT
; _this$ = ecx

; 219  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 220  : 		m_RC5.DecryptByte( m_MemPool, m_TempMem, 4 );

  00004	8d 71 28	 lea	 esi, DWORD PTR [ecx+40]
  00007	6a 04		 push	 4
  00009	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00011	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte

; 221  : 		*value = *((bool*)m_TempMem);

  00016	8a 06		 mov	 al, BYTE PTR [esi]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0001b	88 01		 mov	 BYTE PTR [ecx], al
  0001d	5e		 pop	 esi

; 222  : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ENDP	; CEncrypt<bool>::DecryptValueToPool
_TEXT	ENDS
PUBLIC	?EncryptValueToPool@?$CEncrypt@H@@AAEXPBD@Z	; CEncrypt<int>::EncryptValueToPool
; Function compile flags: /Ogsp
;	COMDAT ?EncryptValueToPool@?$CEncrypt@H@@AAEXPBD@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?EncryptValueToPool@?$CEncrypt@H@@AAEXPBD@Z PROC	; CEncrypt<int>::EncryptValueToPool, COMDAT
; _this$ = ecx

; 67   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 		m_RC5.EncryptByte( value, m_MemPool, max(m_ValueSize, DEFAULT_ENCRYPT) );

  00003	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00007	83 f8 04	 cmp	 eax, 4
  0000a	77 03		 ja	 SHORT $LN4@EncryptVal@2
  0000c	6a 04		 push	 4
  0000e	58		 pop	 eax
$LN4@EncryptVal@2:
  0000f	50		 push	 eax
  00010	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  00013	50		 push	 eax
  00014	ff 75 08	 push	 DWORD PTR _value$[ebp]
  00017	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0001a	e8 00 00 00 00	 call	 ?EncryptByte@ccddaabb@@QAEXPBDPADH@Z ; ccddaabb::EncryptByte

; 69   : 		
; 70   : 	}

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?EncryptValueToPool@?$CEncrypt@H@@AAEXPBD@Z ENDP	; CEncrypt<int>::EncryptValueToPool
_TEXT	ENDS
PUBLIC	?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z	; CEncrypt<int>::DecryptValueToPool
; Function compile flags: /Ogsp
;	COMDAT ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z PROC	; CEncrypt<int>::DecryptValueToPool, COMDAT
; _this$ = ecx

; 837  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 838  : 		m_RC5.DecryptByte( m_MemPool, m_TempMem, 4 );

  00004	8d 71 28	 lea	 esi, DWORD PTR [ecx+40]
  00007	6a 04		 push	 4
  00009	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00011	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte

; 839  : 		*value = *((int*)m_TempMem);

  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0001b	89 01		 mov	 DWORD PTR [ecx], eax
  0001d	5e		 pop	 esi

; 840  : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ENDP	; CEncrypt<int>::DecryptValueToPool
_TEXT	ENDS
PUBLIC	?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
; Function compile flags: /Ogsp
;	COMDAT ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z PROC ; CEncrypt<enum TeamType>::DecryptValueToPool, COMDAT
; _this$ = ecx

; 2959 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2960 : 		m_RC5.DecryptByte( m_MemPool, m_TempMem, sizeof(TeamType) );

  00004	8d 71 28	 lea	 esi, DWORD PTR [ecx+40]
  00007	6a 04		 push	 4
  00009	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00011	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte

; 2961 : 		*value = *((TeamType*)m_TempMem);

  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0001b	89 01		 mov	 DWORD PTR [ecx], eax
  0001d	5e		 pop	 esi

; 2962 : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ENDP ; CEncrypt<enum TeamType>::DecryptValueToPool
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QBEIXZ ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::capacity
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QBEIXZ PROC ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::capacity, COMDAT
; _this$ = ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	6a 14		 push	 20			; 00000014H
  00007	99		 cdq
  00008	59		 pop	 ecx
  00009	f7 f9		 idiv	 ecx

; 778  : 		}

  0000b	c3		 ret	 0
?capacity@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QBEIXZ ENDP ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::capacity
_TEXT	ENDS
PUBLIC	?size@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QBEIXZ ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::size
; Function compile flags: /Ogsp
;	COMDAT ?size@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QBEIXZ PROC ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	6a 14		 push	 20			; 00000014H
  00007	99		 cdq
  00008	59		 pop	 ecx
  00009	f7 f9		 idiv	 ecx

; 880  : 		}

  0000b	c3		 ret	 0
?size@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QBEIXZ ENDP ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::size
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAE@XZ ; std::_Vector_val<BuffInfoStruct,std::allocator<BuffInfoStruct> >::~_Vector_val<BuffInfoStruct,std::allocator<BuffInfoStruct> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$_Vector_val@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<BuffInfoStruct,std::allocator<BuffInfoStruct> >::~_Vector_val<BuffInfoStruct,std::allocator<BuffInfoStruct> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<BuffInfoStruct,std::allocator<BuffInfoStruct> >::~_Vector_val<BuffInfoStruct,std::allocator<BuffInfoStruct> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UBuffInfoStruct@@@std@@QAE@XZ	; std::allocator<BuffInfoStruct>::allocator<BuffInfoStruct>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UBuffInfoStruct@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UBuffInfoStruct@@@std@@QAE@XZ PROC	; std::allocator<BuffInfoStruct>::allocator<BuffInfoStruct>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@UBuffInfoStruct@@@std@@QAE@XZ ENDP	; std::allocator<BuffInfoStruct>::allocator<BuffInfoStruct>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@I@Z ; std::allocator<BuffInfoStruct>::deallocate
; Function compile flags: /Ogsp
;	COMDAT ?deallocate@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@I@Z PROC ; std::allocator<BuffInfoStruct>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 183  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
?deallocate@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@I@Z ENDP ; std::allocator<BuffInfoStruct>::deallocate
_TEXT	ENDS
PUBLIC	?DecryptValueToPool@?$CEncrypt@W4ModeType@@@@QAEXPAW4ModeType@@@Z ; CEncrypt<enum ModeType>::DecryptValueToPool
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
;	COMDAT ?DecryptValueToPool@?$CEncrypt@W4ModeType@@@@QAEXPAW4ModeType@@@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?DecryptValueToPool@?$CEncrypt@W4ModeType@@@@QAEXPAW4ModeType@@@Z PROC ; CEncrypt<enum ModeType>::DecryptValueToPool, COMDAT
; _this$ = ecx

; 3039 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3040 : 		m_RC5.DecryptByte( m_MemPool, m_TempMem, sizeof(ModeType) );

  00004	8d 71 28	 lea	 esi, DWORD PTR [ecx+40]
  00007	6a 04		 push	 4
  00009	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00011	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte

; 3041 : 		*value = *((ModeType*)m_TempMem);

  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0001b	89 01		 mov	 DWORD PTR [ecx], eax
  0001d	5e		 pop	 esi

; 3042 : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?DecryptValueToPool@?$CEncrypt@W4ModeType@@@@QAEXPAW4ModeType@@@Z ENDP ; CEncrypt<enum ModeType>::DecryptValueToPool
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@I@Z ; std::allocator<ioHashString>::deallocate
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@I@Z PROC ; std::allocator<ioHashString>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 183  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
?deallocate@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@I@Z ENDP ; std::allocator<ioHashString>::deallocate
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IBEXXZ ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Xlen
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IBEXXZ PROC ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Xlen, COMDAT
; _this$ = ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
  0000b	cc		 int	 3
?_Xlen@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IBEXXZ ENDP ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Xlen
_TEXT	ENDS
PUBLIC	??0?$allocator@UBuffInfoStruct@@@std@@QAE@ABV01@@Z ; std::allocator<BuffInfoStruct>::allocator<BuffInfoStruct>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UBuffInfoStruct@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UBuffInfoStruct@@@std@@QAE@ABV01@@Z PROC	; std::allocator<BuffInfoStruct>::allocator<BuffInfoStruct>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@UBuffInfoStruct@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<BuffInfoStruct>::allocator<BuffInfoStruct>
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UBuffInfoStruct@@@std@@QBEIXZ ; std::allocator<BuffInfoStruct>::max_size
; Function compile flags: /Ogsp
;	COMDAT ?max_size@?$allocator@UBuffInfoStruct@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UBuffInfoStruct@@@std@@QBEIXZ PROC ; std::allocator<BuffInfoStruct>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 cc cc cc 0c	 mov	 eax, 214748364		; 0cccccccH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UBuffInfoStruct@@@std@@QBEIXZ ENDP ; std::allocator<BuffInfoStruct>::max_size
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@UBuffInfoStruct@@@std@@YAPAUBuffInfoStruct@@IPAU1@@Z ; std::_Allocate<BuffInfoStruct>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@UBuffInfoStruct@@@std@@YAPAUBuffInfoStruct@@IPAU1@@Z
_TEXT	SEGMENT
$T699428 = -12						; size = 12
$T699433 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UBuffInfoStruct@@@std@@YAPAUBuffInfoStruct@@IPAU1@@Z PROC ; std::_Allocate<BuffInfoStruct>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 3c		 je	 SHORT $LN5@Allocate

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 cc cc cc
	0c		 cmp	 ecx, 214748364		; 0cccccccH
  00015	77 0e		 ja	 SHORT $LN1@Allocate
  00017	6b c9 14	 imul	 ecx, 20			; 00000014H
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00020	59		 pop	 ecx
  00021	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00023	75 26		 jne	 SHORT $LN5@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00025	83 65 08 00	 and	 DWORD PTR $T699433[ebp], 0
  00029	8d 45 08	 lea	 eax, DWORD PTR $T699433[ebp]
  0002c	50		 push	 eax
  0002d	8d 4d f4	 lea	 ecx, DWORD PTR $T699428[ebp]
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
  00036	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003b	8d 45 f4	 lea	 eax, DWORD PTR $T699428[ebp]
  0003e	50		 push	 eax
  0003f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T699428[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00046	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate:
$LN5@Allocate:

; 40   : 	}

  0004b	c9		 leave
  0004c	c3		 ret	 0
$LN9@Allocate:
??$_Allocate@UBuffInfoStruct@@@std@@YAPAUBuffInfoStruct@@IPAU1@@Z ENDP ; std::_Allocate<BuffInfoStruct>
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
; Function compile flags: /Ogsp
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@UBuffInfoStruct@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUBuffInfoStruct@@0@Z ; std::_Ptr_cat<BuffInfoStruct,BuffInfoStruct>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@UBuffInfoStruct@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUBuffInfoStruct@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UBuffInfoStruct@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUBuffInfoStruct@@0@Z PROC ; std::_Ptr_cat<BuffInfoStruct,BuffInfoStruct>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	c9		 leave
  00008	c3		 ret	 0
??$_Ptr_cat@UBuffInfoStruct@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUBuffInfoStruct@@0@Z ENDP ; std::_Ptr_cat<BuffInfoStruct,BuffInfoStruct>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@VioHashString@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVioHashString@@0@Z ; std::_Ptr_cat<ioHashString,ioHashString>
; Function compile flags: /Ogsp
;	COMDAT ??$_Ptr_cat@VioHashString@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVioHashString@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@VioHashString@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVioHashString@@0@Z PROC ; std::_Ptr_cat<ioHashString,ioHashString>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	c9		 leave
  00008	c3		 ret	 0
??$_Ptr_cat@VioHashString@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVioHashString@@0@Z ENDP ; std::_Ptr_cat<ioHashString,ioHashString>
_TEXT	ENDS
PUBLIC	??_GioHashString@@QAEPAXI@Z			; ioHashString::`scalar deleting destructor'
; Function compile flags: /Ogsp
;	COMDAT ??_GioHashString@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GioHashString@@QAEPAXI@Z PROC			; ioHashString::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  0000c	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00010	74 07		 je	 SHORT $LN1@scalar@2
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	59		 pop	 ecx
$LN1@scalar@2:
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??_GioHashString@@QAEPAXI@Z ENDP			; ioHashString::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GBuffInfoStruct@@QAEPAXI@Z			; BuffInfoStruct::`scalar deleting destructor'
; Function compile flags: /Ogsp
;	COMDAT ??_GBuffInfoStruct@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GBuffInfoStruct@@QAEPAXI@Z PROC			; BuffInfoStruct::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  0000c	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00010	74 07		 je	 SHORT $LN1@scalar@3
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	59		 pop	 ecx
$LN1@scalar@3:
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??_GBuffInfoStruct@@QAEPAXI@Z ENDP			; BuffInfoStruct::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$forward@AAUBuffInfoStruct@@@std@@YAAAUBuffInfoStruct@@AAU1@@Z ; std::forward<BuffInfoStruct &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@AAUBuffInfoStruct@@@std@@YAAAUBuffInfoStruct@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUBuffInfoStruct@@@std@@YAAAUBuffInfoStruct@@AAU1@@Z PROC ; std::forward<BuffInfoStruct &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAUBuffInfoStruct@@@std@@YAAAUBuffInfoStruct@@AAU1@@Z ENDP ; std::forward<BuffInfoStruct &>
_TEXT	ENDS
PUBLIC	??0BuffInfoStruct@@QAE@ABU0@@Z			; BuffInfoStruct::BuffInfoStruct
; Function compile flags: /Ogsp
;	COMDAT ??0BuffInfoStruct@@QAE@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0BuffInfoStruct@@QAE@ABU0@@Z PROC			; BuffInfoStruct::BuffInfoStruct, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  00011	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00014	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00017	5f		 pop	 edi
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??0BuffInfoStruct@@QAE@ABU0@@Z ENDP			; BuffInfoStruct::BuffInfoStruct
_TEXT	ENDS
PUBLIC	??_R0?AVioBaseChar@@@8				; ioBaseChar `RTTI Type Descriptor'
PUBLIC	?ToBaseChar@@YAPAVioBaseChar@@PAVioGameEntity@@@Z ; ToBaseChar
;	COMDAT ??_R0?AVioBaseChar@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasechar.h
_DATA	SEGMENT
??_R0?AVioBaseChar@@@8 DD FLAT:??_7type_info@@6B@	; ioBaseChar `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioBaseChar@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToBaseChar@@YAPAVioBaseChar@@PAVioGameEntity@@@Z
_TEXT	SEGMENT
_pObj$ = 8						; size = 4
?ToBaseChar@@YAPAVioBaseChar@@PAVioGameEntity@@@Z PROC	; ToBaseChar, COMDAT

; 4326 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4327 : 	ioPlayEntity *pPlay = ToPlayEntity( pObj );

  00004	ff 75 08	 push	 DWORD PTR _pObj$[ebp]
  00007	e8 00 00 00 00	 call	 ?ToPlayEntity@@YAPAVioPlayEntity@@PAVioGameEntity@@@Z ; ToPlayEntity
  0000c	8b f0		 mov	 esi, eax
  0000e	59		 pop	 ecx

; 4328 : 	if( !pPlay || pPlay->GetSubType() != ioPlayEntity::PST_CHAR )

  0000f	85 f6		 test	 esi, esi
  00011	74 25		 je	 SHORT $LN1@ToBaseChar
  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	8b ce		 mov	 ecx, esi
  00017	ff 90 a4 00 00
	00		 call	 DWORD PTR [eax+164]
  0001d	85 c0		 test	 eax, eax
  0001f	75 17		 jne	 SHORT $LN1@ToBaseChar

; 4330 : 
; 4331 : 	return dynamic_cast< ioBaseChar* >( pPlay );

  00021	50		 push	 eax
  00022	68 00 00 00 00	 push	 OFFSET ??_R0?AVioBaseChar@@@8
  00027	68 00 00 00 00	 push	 OFFSET ??_R0?AVioPlayEntity@@@8
  0002c	50		 push	 eax
  0002d	56		 push	 esi
  0002e	e8 00 00 00 00	 call	 ___RTDynamicCast
  00033	83 c4 14	 add	 esp, 20			; 00000014H
  00036	eb 02		 jmp	 SHORT $LN3@ToBaseChar
$LN1@ToBaseChar:

; 4329 : 		return NULL;

  00038	33 c0		 xor	 eax, eax
$LN3@ToBaseChar:
  0003a	5e		 pop	 esi

; 4332 : }

  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?ToBaseChar@@YAPAVioBaseChar@@PAVioGameEntity@@@Z ENDP	; ToBaseChar
_TEXT	ENDS
PUBLIC	??_R0?AVioLinearChargeItem2@@@8			; ioLinearChargeItem2 `RTTI Type Descriptor'
PUBLIC	?ToLinearChargeItem2@@YAPAVioLinearChargeItem2@@PAVioItem@@@Z ; ToLinearChargeItem2
;	COMDAT ??_R0?AVioLinearChargeItem2@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iolinearchargeitem2.h
_DATA	SEGMENT
??_R0?AVioLinearChargeItem2@@@8 DD FLAT:??_7type_info@@6B@ ; ioLinearChargeItem2 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioLinearChargeItem2@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToLinearChargeItem2@@YAPAVioLinearChargeItem2@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToLinearChargeItem2@@YAPAVioLinearChargeItem2@@PAVioItem@@@Z PROC ; ToLinearChargeItem2, COMDAT

; 97   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 98   : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00004	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00007	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000c	8b f0		 mov	 esi, eax
  0000e	59		 pop	 ecx

; 99   : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_LINEAR_CHARGE2 )

  0000f	85 f6		 test	 esi, esi
  00011	74 28		 je	 SHORT $LN1@ToLinearCh
  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	8b ce		 mov	 ecx, esi
  00017	ff 90 f0 02 00
	00		 call	 DWORD PTR [eax+752]
  0001d	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  00020	75 19		 jne	 SHORT $LN1@ToLinearCh

; 101  : 
; 102  : 	return dynamic_cast< ioLinearChargeItem2* >( pWeapon );

  00022	6a 00		 push	 0
  00024	68 00 00 00 00	 push	 OFFSET ??_R0?AVioLinearChargeItem2@@@8
  00029	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWeaponItem@@@8
  0002e	6a 00		 push	 0
  00030	56		 push	 esi
  00031	e8 00 00 00 00	 call	 ___RTDynamicCast
  00036	83 c4 14	 add	 esp, 20			; 00000014H
  00039	eb 02		 jmp	 SHORT $LN3@ToLinearCh
$LN1@ToLinearCh:

; 100  : 		return NULL;

  0003b	33 c0		 xor	 eax, eax
$LN3@ToLinearCh:
  0003d	5e		 pop	 esi

; 103  : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?ToLinearChargeItem2@@YAPAVioLinearChargeItem2@@PAVioItem@@@Z ENDP ; ToLinearChargeItem2
_TEXT	ENDS
PUBLIC	??_R0?AVioFlash_Item@@@8			; ioFlash_Item `RTTI Type Descriptor'
PUBLIC	?ToFlashItem@@YAPAVioFlash_Item@@PAVioItem@@@Z	; ToFlashItem
;	COMDAT ??_R0?AVioFlash_Item@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioflash_item.h
_DATA	SEGMENT
??_R0?AVioFlash_Item@@@8 DD FLAT:??_7type_info@@6B@	; ioFlash_Item `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioFlash_Item@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToFlashItem@@YAPAVioFlash_Item@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToFlashItem@@YAPAVioFlash_Item@@PAVioItem@@@Z PROC	; ToFlashItem, COMDAT

; 281  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 282  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 283  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_FLASHITEM )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToFlashIte
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 4f	 cmp	 eax, 79			; 0000004fH
  0001d	75 1b		 jne	 SHORT $LN1@ToFlashIte

; 285  : 
; 286  : 	return dynamic_cast< ioFlash_Item* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioFlash_Item@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 287  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToFlashIte:

; 284  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 287  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToFlashItem@@YAPAVioFlash_Item@@PAVioItem@@@Z ENDP	; ToFlashItem
_TEXT	ENDS
PUBLIC	??_R0?AVioThunderBirdItem@@@8			; ioThunderBirdItem `RTTI Type Descriptor'
PUBLIC	?ToThunderBirdItem@@YAPAVioThunderBirdItem@@PAVioItem@@@Z ; ToThunderBirdItem
;	COMDAT ??_R0?AVioThunderBirdItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iothunderbirditem.h
_DATA	SEGMENT
??_R0?AVioThunderBirdItem@@@8 DD FLAT:??_7type_info@@6B@ ; ioThunderBirdItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioThunderBirdItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToThunderBirdItem@@YAPAVioThunderBirdItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToThunderBirdItem@@YAPAVioThunderBirdItem@@PAVioItem@@@Z PROC ; ToThunderBirdItem, COMDAT

; 138  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 139  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 140  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_THUNDER_BIRD_ITEM )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToThunderB
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 60	 cmp	 eax, 96			; 00000060H
  0001d	75 1b		 jne	 SHORT $LN1@ToThunderB

; 142  : 
; 143  : 	return dynamic_cast< ioThunderBirdItem* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioThunderBirdItem@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 144  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToThunderB:

; 141  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 144  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToThunderBirdItem@@YAPAVioThunderBirdItem@@PAVioItem@@@Z ENDP ; ToThunderBirdItem
_TEXT	ENDS
PUBLIC	??_R0?AVioBuff@@@8				; ioBuff `RTTI Type Descriptor'
PUBLIC	??_R0?AVioFrozenBuff@@@8			; ioFrozenBuff `RTTI Type Descriptor'
PUBLIC	?ToFrozenConst@@YAPBVioFrozenBuff@@PBVioBuff@@@Z ; ToFrozenConst
;	COMDAT ??_R0?AVioBuff@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobuff.h
_DATA	SEGMENT
??_R0?AVioBuff@@@8 DD FLAT:??_7type_info@@6B@		; ioBuff `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioBuff@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVioFrozenBuff@@@8
_DATA	SEGMENT
??_R0?AVioFrozenBuff@@@8 DD FLAT:??_7type_info@@6B@	; ioFrozenBuff `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioFrozenBuff@@', 00H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iofrozenbuff.h
_DATA	ENDS
;	COMDAT ?ToFrozenConst@@YAPBVioFrozenBuff@@PBVioBuff@@@Z
_TEXT	SEGMENT
_pBuff$ = 8						; size = 4
?ToFrozenConst@@YAPBVioFrozenBuff@@PBVioBuff@@@Z PROC	; ToFrozenConst, COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 74   : 	if( !pBuff || pBuff->GetTypeID() != BT_FROZEN_STATUE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _pBuff$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 22		 je	 SHORT $LN1@ToFrozenCo
  0000a	83 b8 cc 03 00
	00 08		 cmp	 DWORD PTR [eax+972], 8
  00011	75 19		 jne	 SHORT $LN1@ToFrozenCo

; 76   : 
; 77   : 	return dynamic_cast< const ioFrozenBuff* >( pBuff );

  00013	6a 00		 push	 0
  00015	68 00 00 00 00	 push	 OFFSET ??_R0?AVioFrozenBuff@@@8
  0001a	68 00 00 00 00	 push	 OFFSET ??_R0?AVioBuff@@@8
  0001f	6a 00		 push	 0
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ___RTDynamicCast
  00027	83 c4 14	 add	 esp, 20			; 00000014H

; 78   : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN1@ToFrozenCo:

; 75   : 		return NULL;

  0002c	33 c0		 xor	 eax, eax

; 78   : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?ToFrozenConst@@YAPBVioFrozenBuff@@PBVioBuff@@@Z ENDP	; ToFrozenConst
_TEXT	ENDS
PUBLIC	??_R0?AVioStateProtectionBuff@@@8		; ioStateProtectionBuff `RTTI Type Descriptor'
PUBLIC	?ToStateProtectBuff@@YAPAVioStateProtectionBuff@@PAVioBuff@@@Z ; ToStateProtectBuff
;	COMDAT ??_R0?AVioStateProtectionBuff@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobuff.h
_DATA	SEGMENT
??_R0?AVioStateProtectionBuff@@@8 DD FLAT:??_7type_info@@6B@ ; ioStateProtectionBuff `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioStateProtectionBuff@@', 00H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iostateprotectionbuff.h
_DATA	ENDS
;	COMDAT ?ToStateProtectBuff@@YAPAVioStateProtectionBuff@@PAVioBuff@@@Z
_TEXT	SEGMENT
_pBuff$ = 8						; size = 4
?ToStateProtectBuff@@YAPAVioStateProtectionBuff@@PAVioBuff@@@Z PROC ; ToStateProtectBuff, COMDAT

; 79   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 80   : 	if( !pBuff || pBuff->GetTypeID() != BT_STATE_PROTECTION )

  00003	8b 45 08	 mov	 eax, DWORD PTR _pBuff$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 22		 je	 SHORT $LN1@ToStatePro
  0000a	83 b8 cc 03 00
	00 23		 cmp	 DWORD PTR [eax+972], 35	; 00000023H
  00011	75 19		 jne	 SHORT $LN1@ToStatePro

; 82   : 
; 83   : 	return dynamic_cast< ioStateProtectionBuff* >( pBuff );

  00013	6a 00		 push	 0
  00015	68 00 00 00 00	 push	 OFFSET ??_R0?AVioStateProtectionBuff@@@8
  0001a	68 00 00 00 00	 push	 OFFSET ??_R0?AVioBuff@@@8
  0001f	6a 00		 push	 0
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ___RTDynamicCast
  00027	83 c4 14	 add	 esp, 20			; 00000014H

; 84   : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN1@ToStatePro:

; 81   : 		return NULL;

  0002c	33 c0		 xor	 eax, eax

; 84   : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?ToStateProtectBuff@@YAPAVioStateProtectionBuff@@PAVioBuff@@@Z ENDP ; ToStateProtectBuff
_TEXT	ENDS
PUBLIC	??_R0?AVioDummyBuff@@@8				; ioDummyBuff `RTTI Type Descriptor'
PUBLIC	?ToDummyBuff@@YAPAVioDummyBuff@@PAVioBuff@@@Z	; ToDummyBuff
;	COMDAT ??_R0?AVioDummyBuff@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobuff.h
_DATA	SEGMENT
??_R0?AVioDummyBuff@@@8 DD FLAT:??_7type_info@@6B@	; ioDummyBuff `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioDummyBuff@@', 00H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iodummybuff.h
_DATA	ENDS
;	COMDAT ?ToDummyBuff@@YAPAVioDummyBuff@@PAVioBuff@@@Z
_TEXT	SEGMENT
_pBuff$ = 8						; size = 4
?ToDummyBuff@@YAPAVioDummyBuff@@PAVioBuff@@@Z PROC	; ToDummyBuff, COMDAT

; 64   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 65   : 	if( !pBuff || pBuff->GetTypeID() != BT_DUMMY_BUFF )

  00003	8b 45 08	 mov	 eax, DWORD PTR _pBuff$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 22		 je	 SHORT $LN1@ToDummyBuf
  0000a	83 b8 cc 03 00
	00 4a		 cmp	 DWORD PTR [eax+972], 74	; 0000004aH
  00011	75 19		 jne	 SHORT $LN1@ToDummyBuf

; 67   : 
; 68   : 	return dynamic_cast< ioDummyBuff* >( pBuff );

  00013	6a 00		 push	 0
  00015	68 00 00 00 00	 push	 OFFSET ??_R0?AVioDummyBuff@@@8
  0001a	68 00 00 00 00	 push	 OFFSET ??_R0?AVioBuff@@@8
  0001f	6a 00		 push	 0
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ___RTDynamicCast
  00027	83 c4 14	 add	 esp, 20			; 00000014H

; 69   : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN1@ToDummyBuf:

; 66   : 		return NULL;

  0002c	33 c0		 xor	 eax, eax

; 69   : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?ToDummyBuff@@YAPAVioDummyBuff@@PAVioBuff@@@Z ENDP	; ToDummyBuff
_TEXT	ENDS
PUBLIC	??_R0?AVioCallBuffOnAttackBuff2@@@8		; ioCallBuffOnAttackBuff2 `RTTI Type Descriptor'
PUBLIC	?ToCallBuffOnAttackBuff2@@YAPAVioCallBuffOnAttackBuff2@@PAVioBuff@@@Z ; ToCallBuffOnAttackBuff2
;	COMDAT ??_R0?AVioCallBuffOnAttackBuff2@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobuff.h
_DATA	SEGMENT
??_R0?AVioCallBuffOnAttackBuff2@@@8 DD FLAT:??_7type_info@@6B@ ; ioCallBuffOnAttackBuff2 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioCallBuffOnAttackBuff2@@', 00H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iocallbuffonattackbuff2.h
_DATA	ENDS
;	COMDAT ?ToCallBuffOnAttackBuff2@@YAPAVioCallBuffOnAttackBuff2@@PAVioBuff@@@Z
_TEXT	SEGMENT
_pBuff$ = 8						; size = 4
?ToCallBuffOnAttackBuff2@@YAPAVioCallBuffOnAttackBuff2@@PAVioBuff@@@Z PROC ; ToCallBuffOnAttackBuff2, COMDAT

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 41   : 	if( !pBuff || pBuff->GetTypeID() != BT_CALL_BUFF_ON_ATTACK2 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _pBuff$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 25		 je	 SHORT $LN1@ToCallBuff
  0000a	81 b8 cc 03 00
	00 c9 00 00 00	 cmp	 DWORD PTR [eax+972], 201 ; 000000c9H
  00014	75 19		 jne	 SHORT $LN1@ToCallBuff

; 43   : 
; 44   : 	return dynamic_cast< ioCallBuffOnAttackBuff2* >( pBuff );

  00016	6a 00		 push	 0
  00018	68 00 00 00 00	 push	 OFFSET ??_R0?AVioCallBuffOnAttackBuff2@@@8
  0001d	68 00 00 00 00	 push	 OFFSET ??_R0?AVioBuff@@@8
  00022	6a 00		 push	 0
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002a	83 c4 14	 add	 esp, 20			; 00000014H

; 45   : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
$LN1@ToCallBuff:

; 42   : 		return NULL;

  0002f	33 c0		 xor	 eax, eax

; 45   : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?ToCallBuffOnAttackBuff2@@YAPAVioCallBuffOnAttackBuff2@@PAVioBuff@@@Z ENDP ; ToCallBuffOnAttackBuff2
_TEXT	ENDS
PUBLIC	??_R0?AVioAdhesiveBuff@@@8			; ioAdhesiveBuff `RTTI Type Descriptor'
PUBLIC	?ToAdhesiveBuff@@YAPAVioAdhesiveBuff@@PAVioBuff@@@Z ; ToAdhesiveBuff
;	COMDAT ??_R0?AVioAdhesiveBuff@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobuff.h
_DATA	SEGMENT
??_R0?AVioAdhesiveBuff@@@8 DD FLAT:??_7type_info@@6B@	; ioAdhesiveBuff `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioAdhesiveBuff@@', 00H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioadhesivebuff.h
_DATA	ENDS
;	COMDAT ?ToAdhesiveBuff@@YAPAVioAdhesiveBuff@@PAVioBuff@@@Z
_TEXT	SEGMENT
_pBuff$ = 8						; size = 4
?ToAdhesiveBuff@@YAPAVioAdhesiveBuff@@PAVioBuff@@@Z PROC ; ToAdhesiveBuff, COMDAT

; 81   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 82   : 	if( !pBuff || pBuff->GetTypeID() != BT_ADHESIVE_STATE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _pBuff$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 22		 je	 SHORT $LN1@ToAdhesive@2
  0000a	83 b8 cc 03 00
	00 5e		 cmp	 DWORD PTR [eax+972], 94	; 0000005eH
  00011	75 19		 jne	 SHORT $LN1@ToAdhesive@2

; 84   : 
; 85   : 	return dynamic_cast< ioAdhesiveBuff* >( pBuff );

  00013	6a 00		 push	 0
  00015	68 00 00 00 00	 push	 OFFSET ??_R0?AVioAdhesiveBuff@@@8
  0001a	68 00 00 00 00	 push	 OFFSET ??_R0?AVioBuff@@@8
  0001f	6a 00		 push	 0
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ___RTDynamicCast
  00027	83 c4 14	 add	 esp, 20			; 00000014H

; 86   : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN1@ToAdhesive@2:

; 83   : 		return NULL;

  0002c	33 c0		 xor	 eax, eax

; 86   : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?ToAdhesiveBuff@@YAPAVioAdhesiveBuff@@PAVioBuff@@@Z ENDP ; ToAdhesiveBuff
_TEXT	ENDS
PUBLIC	??_R0?AVioHitCountHoldBuff@@@8			; ioHitCountHoldBuff `RTTI Type Descriptor'
PUBLIC	?ToHitCountHoldBuff@@YAPAVioHitCountHoldBuff@@PAVioBuff@@@Z ; ToHitCountHoldBuff
;	COMDAT ??_R0?AVioHitCountHoldBuff@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobuff.h
_DATA	SEGMENT
??_R0?AVioHitCountHoldBuff@@@8 DD FLAT:??_7type_info@@6B@ ; ioHitCountHoldBuff `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioHitCountHoldBuff@@', 00H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iohitcountholdbuff.h
_DATA	ENDS
;	COMDAT ?ToHitCountHoldBuff@@YAPAVioHitCountHoldBuff@@PAVioBuff@@@Z
_TEXT	SEGMENT
_pBuff$ = 8						; size = 4
?ToHitCountHoldBuff@@YAPAVioHitCountHoldBuff@@PAVioBuff@@@Z PROC ; ToHitCountHoldBuff, COMDAT

; 58   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 59   : 	if( !pBuff || pBuff->GetTypeID() != BT_HIT_COUNT_HOLD )

  00003	8b 45 08	 mov	 eax, DWORD PTR _pBuff$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 22		 je	 SHORT $LN1@ToHitCount
  0000a	83 b8 cc 03 00
	00 70		 cmp	 DWORD PTR [eax+972], 112 ; 00000070H
  00011	75 19		 jne	 SHORT $LN1@ToHitCount

; 61   : 
; 62   : 	return dynamic_cast< ioHitCountHoldBuff* >( pBuff );

  00013	6a 00		 push	 0
  00015	68 00 00 00 00	 push	 OFFSET ??_R0?AVioHitCountHoldBuff@@@8
  0001a	68 00 00 00 00	 push	 OFFSET ??_R0?AVioBuff@@@8
  0001f	6a 00		 push	 0
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ___RTDynamicCast
  00027	83 c4 14	 add	 esp, 20			; 00000014H

; 63   : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN1@ToHitCount:

; 60   : 		return NULL;

  0002c	33 c0		 xor	 eax, eax

; 63   : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?ToHitCountHoldBuff@@YAPAVioHitCountHoldBuff@@PAVioBuff@@@Z ENDP ; ToHitCountHoldBuff
_TEXT	ENDS
PUBLIC	??_R0?AVioAffectWoundedValueBuff@@@8		; ioAffectWoundedValueBuff `RTTI Type Descriptor'
PUBLIC	?ToAffectWoundedValue@@YAPAVioAffectWoundedValueBuff@@PAVioBuff@@@Z ; ToAffectWoundedValue
;	COMDAT ??_R0?AVioAffectWoundedValueBuff@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobuff.h
_DATA	SEGMENT
??_R0?AVioAffectWoundedValueBuff@@@8 DD FLAT:??_7type_info@@6B@ ; ioAffectWoundedValueBuff `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioAffectWoundedValueBuff@@', 00H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioaffectwoundedvaluebuff.h
_DATA	ENDS
;	COMDAT ?ToAffectWoundedValue@@YAPAVioAffectWoundedValueBuff@@PAVioBuff@@@Z
_TEXT	SEGMENT
_pBuff$ = 8						; size = 4
?ToAffectWoundedValue@@YAPAVioAffectWoundedValueBuff@@PAVioBuff@@@Z PROC ; ToAffectWoundedValue, COMDAT

; 107  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 108  : 	if( !pBuff || pBuff->GetTypeID() != BT_AFFECT_WOUNDED_VALUE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _pBuff$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 22		 je	 SHORT $LN1@ToAffectWo
  0000a	83 b8 cc 03 00
	00 72		 cmp	 DWORD PTR [eax+972], 114 ; 00000072H
  00011	75 19		 jne	 SHORT $LN1@ToAffectWo

; 110  : 
; 111  : 	return dynamic_cast< ioAffectWoundedValueBuff* >( pBuff );

  00013	6a 00		 push	 0
  00015	68 00 00 00 00	 push	 OFFSET ??_R0?AVioAffectWoundedValueBuff@@@8
  0001a	68 00 00 00 00	 push	 OFFSET ??_R0?AVioBuff@@@8
  0001f	6a 00		 push	 0
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ___RTDynamicCast
  00027	83 c4 14	 add	 esp, 20			; 00000014H

; 112  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN1@ToAffectWo:

; 109  : 		return NULL;

  0002c	33 c0		 xor	 eax, eax

; 112  : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?ToAffectWoundedValue@@YAPAVioAffectWoundedValueBuff@@PAVioBuff@@@Z ENDP ; ToAffectWoundedValue
_TEXT	ENDS
PUBLIC	??_R0?AVioFloatBuff2@@@8			; ioFloatBuff2 `RTTI Type Descriptor'
PUBLIC	?ToFloatBuff2@@YAPAVioFloatBuff2@@PAVioBuff@@@Z	; ToFloatBuff2
;	COMDAT ??_R0?AVioFloatBuff2@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobuff.h
_DATA	SEGMENT
??_R0?AVioFloatBuff2@@@8 DD FLAT:??_7type_info@@6B@	; ioFloatBuff2 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioFloatBuff2@@', 00H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iofloatbuff2.h
_DATA	ENDS
;	COMDAT ?ToFloatBuff2@@YAPAVioFloatBuff2@@PAVioBuff@@@Z
_TEXT	SEGMENT
_pBuff$ = 8						; size = 4
?ToFloatBuff2@@YAPAVioFloatBuff2@@PAVioBuff@@@Z PROC	; ToFloatBuff2, COMDAT

; 54   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 55   : 	if( !pBuff || pBuff->GetTypeID() != BT_FLOAT2 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _pBuff$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 25		 je	 SHORT $LN1@ToFloatBuf
  0000a	81 b8 cc 03 00
	00 ad 00 00 00	 cmp	 DWORD PTR [eax+972], 173 ; 000000adH
  00014	75 19		 jne	 SHORT $LN1@ToFloatBuf

; 57   : 
; 58   : 	return dynamic_cast< ioFloatBuff2* >( pBuff );

  00016	6a 00		 push	 0
  00018	68 00 00 00 00	 push	 OFFSET ??_R0?AVioFloatBuff2@@@8
  0001d	68 00 00 00 00	 push	 OFFSET ??_R0?AVioBuff@@@8
  00022	6a 00		 push	 0
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002a	83 c4 14	 add	 esp, 20			; 00000014H

; 59   : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
$LN1@ToFloatBuf:

; 56   : 		return NULL;

  0002f	33 c0		 xor	 eax, eax

; 59   : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?ToFloatBuff2@@YAPAVioFloatBuff2@@PAVioBuff@@@Z ENDP	; ToFloatBuff2
_TEXT	ENDS
PUBLIC	??_R0?AVioTargetRushAttackBuff@@@8		; ioTargetRushAttackBuff `RTTI Type Descriptor'
PUBLIC	?ToTargetRushAttackBuff@@YAPAVioTargetRushAttackBuff@@PAVioBuff@@@Z ; ToTargetRushAttackBuff
;	COMDAT ??_R0?AVioTargetRushAttackBuff@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobuff.h
_DATA	SEGMENT
??_R0?AVioTargetRushAttackBuff@@@8 DD FLAT:??_7type_info@@6B@ ; ioTargetRushAttackBuff `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioTargetRushAttackBuff@@', 00H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iotargetrushattackbuff.h
_DATA	ENDS
;	COMDAT ?ToTargetRushAttackBuff@@YAPAVioTargetRushAttackBuff@@PAVioBuff@@@Z
_TEXT	SEGMENT
_pBuff$ = 8						; size = 4
?ToTargetRushAttackBuff@@YAPAVioTargetRushAttackBuff@@PAVioBuff@@@Z PROC ; ToTargetRushAttackBuff, COMDAT

; 145  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 146  : 	if( !pBuff || pBuff->GetTypeID() != BT_TARGET_RUSH_ATTACK )

  00003	8b 45 08	 mov	 eax, DWORD PTR _pBuff$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 25		 je	 SHORT $LN1@ToTargetRu
  0000a	81 b8 cc 03 00
	00 b0 00 00 00	 cmp	 DWORD PTR [eax+972], 176 ; 000000b0H
  00014	75 19		 jne	 SHORT $LN1@ToTargetRu

; 148  : 
; 149  : 	return dynamic_cast< ioTargetRushAttackBuff* >( pBuff );

  00016	6a 00		 push	 0
  00018	68 00 00 00 00	 push	 OFFSET ??_R0?AVioTargetRushAttackBuff@@@8
  0001d	68 00 00 00 00	 push	 OFFSET ??_R0?AVioBuff@@@8
  00022	6a 00		 push	 0
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002a	83 c4 14	 add	 esp, 20			; 00000014H

; 150  : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
$LN1@ToTargetRu:

; 147  : 		return NULL;

  0002f	33 c0		 xor	 eax, eax

; 150  : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?ToTargetRushAttackBuff@@YAPAVioTargetRushAttackBuff@@PAVioBuff@@@Z ENDP ; ToTargetRushAttackBuff
_TEXT	ENDS
PUBLIC	??_R0?AVioThunderBirdHoldBuff@@@8		; ioThunderBirdHoldBuff `RTTI Type Descriptor'
PUBLIC	?ToThunderBirdHoldBuff@@YAPAVioThunderBirdHoldBuff@@PAVioBuff@@@Z ; ToThunderBirdHoldBuff
;	COMDAT ??_R0?AVioThunderBirdHoldBuff@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobuff.h
_DATA	SEGMENT
??_R0?AVioThunderBirdHoldBuff@@@8 DD FLAT:??_7type_info@@6B@ ; ioThunderBirdHoldBuff `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioThunderBirdHoldBuff@@', 00H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iothunderbirdholdbuff.h
_DATA	ENDS
;	COMDAT ?ToThunderBirdHoldBuff@@YAPAVioThunderBirdHoldBuff@@PAVioBuff@@@Z
_TEXT	SEGMENT
_pBuff$ = 8						; size = 4
?ToThunderBirdHoldBuff@@YAPAVioThunderBirdHoldBuff@@PAVioBuff@@@Z PROC ; ToThunderBirdHoldBuff, COMDAT

; 52   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 53   : 	if( !pBuff || pBuff->GetTypeID() != BT_THUNDER_BIRD_HOLD )

  00003	8b 45 08	 mov	 eax, DWORD PTR _pBuff$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 25		 je	 SHORT $LN1@ToThunderB@2
  0000a	81 b8 cc 03 00
	00 b1 00 00 00	 cmp	 DWORD PTR [eax+972], 177 ; 000000b1H
  00014	75 19		 jne	 SHORT $LN1@ToThunderB@2

; 55   : 
; 56   : 	return dynamic_cast< ioThunderBirdHoldBuff* >( pBuff );

  00016	6a 00		 push	 0
  00018	68 00 00 00 00	 push	 OFFSET ??_R0?AVioThunderBirdHoldBuff@@@8
  0001d	68 00 00 00 00	 push	 OFFSET ??_R0?AVioBuff@@@8
  00022	6a 00		 push	 0
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002a	83 c4 14	 add	 esp, 20			; 00000014H

; 57   : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
$LN1@ToThunderB@2:

; 54   : 		return NULL;

  0002f	33 c0		 xor	 eax, eax

; 57   : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?ToThunderBirdHoldBuff@@YAPAVioThunderBirdHoldBuff@@PAVioBuff@@@Z ENDP ; ToThunderBirdHoldBuff
_TEXT	ENDS
PUBLIC	??_R0?AVioCreateDummyByAttackedBuff@@@8		; ioCreateDummyByAttackedBuff `RTTI Type Descriptor'
PUBLIC	?ToCreateDummyByAttackedBuff@@YAPAVioCreateDummyByAttackedBuff@@PAVioBuff@@@Z ; ToCreateDummyByAttackedBuff
;	COMDAT ??_R0?AVioCreateDummyByAttackedBuff@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobuff.h
_DATA	SEGMENT
??_R0?AVioCreateDummyByAttackedBuff@@@8 DD FLAT:??_7type_info@@6B@ ; ioCreateDummyByAttackedBuff `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioCreateDummyByAttackedBuff@@', 00H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iocreatedummybyattackedbuff.h
_DATA	ENDS
;	COMDAT ?ToCreateDummyByAttackedBuff@@YAPAVioCreateDummyByAttackedBuff@@PAVioBuff@@@Z
_TEXT	SEGMENT
_pBuff$ = 8						; size = 4
?ToCreateDummyByAttackedBuff@@YAPAVioCreateDummyByAttackedBuff@@PAVioBuff@@@Z PROC ; ToCreateDummyByAttackedBuff, COMDAT

; 41   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 42   : 	if( !pBuff || pBuff->GetTypeID() != BT_CREATE_DUMMY_BY_ATTACKED_BUFF )

  00003	8b 45 08	 mov	 eax, DWORD PTR _pBuff$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 25		 je	 SHORT $LN1@ToCreateDu
  0000a	81 b8 cc 03 00
	00 b5 00 00 00	 cmp	 DWORD PTR [eax+972], 181 ; 000000b5H
  00014	75 19		 jne	 SHORT $LN1@ToCreateDu

; 44   : 
; 45   : 	return dynamic_cast< ioCreateDummyByAttackedBuff* >( pBuff );

  00016	6a 00		 push	 0
  00018	68 00 00 00 00	 push	 OFFSET ??_R0?AVioCreateDummyByAttackedBuff@@@8
  0001d	68 00 00 00 00	 push	 OFFSET ??_R0?AVioBuff@@@8
  00022	6a 00		 push	 0
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002a	83 c4 14	 add	 esp, 20			; 00000014H

; 46   : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
$LN1@ToCreateDu:

; 43   : 		return NULL;

  0002f	33 c0		 xor	 eax, eax

; 46   : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?ToCreateDummyByAttackedBuff@@YAPAVioCreateDummyByAttackedBuff@@PAVioBuff@@@Z ENDP ; ToCreateDummyByAttackedBuff
_TEXT	ENDS
PUBLIC	??_R0?AVioTargetMoveAttackBuff@@@8		; ioTargetMoveAttackBuff `RTTI Type Descriptor'
PUBLIC	?ToTargetMoveAttackBuff@@YAPAVioTargetMoveAttackBuff@@PAVioBuff@@@Z ; ToTargetMoveAttackBuff
;	COMDAT ??_R0?AVioTargetMoveAttackBuff@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobuff.h
_DATA	SEGMENT
??_R0?AVioTargetMoveAttackBuff@@@8 DD FLAT:??_7type_info@@6B@ ; ioTargetMoveAttackBuff `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioTargetMoveAttackBuff@@', 00H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iotargetmoveattackbuff.h
_DATA	ENDS
;	COMDAT ?ToTargetMoveAttackBuff@@YAPAVioTargetMoveAttackBuff@@PAVioBuff@@@Z
_TEXT	SEGMENT
_pBuff$ = 8						; size = 4
?ToTargetMoveAttackBuff@@YAPAVioTargetMoveAttackBuff@@PAVioBuff@@@Z PROC ; ToTargetMoveAttackBuff, COMDAT

; 111  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 112  : 	if( !pBuff || pBuff->GetTypeID() != BT_TARGET_MOVE_ATTACK )

  00003	8b 45 08	 mov	 eax, DWORD PTR _pBuff$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 25		 je	 SHORT $LN1@ToTargetMo
  0000a	81 b8 cc 03 00
	00 bf 00 00 00	 cmp	 DWORD PTR [eax+972], 191 ; 000000bfH
  00014	75 19		 jne	 SHORT $LN1@ToTargetMo

; 114  : 
; 115  : 	return dynamic_cast<ioTargetMoveAttackBuff*>( pBuff );

  00016	6a 00		 push	 0
  00018	68 00 00 00 00	 push	 OFFSET ??_R0?AVioTargetMoveAttackBuff@@@8
  0001d	68 00 00 00 00	 push	 OFFSET ??_R0?AVioBuff@@@8
  00022	6a 00		 push	 0
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002a	83 c4 14	 add	 esp, 20			; 00000014H

; 116  : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
$LN1@ToTargetMo:

; 113  : 		return NULL;

  0002f	33 c0		 xor	 eax, eax

; 116  : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?ToTargetMoveAttackBuff@@YAPAVioTargetMoveAttackBuff@@PAVioBuff@@@Z ENDP ; ToTargetMoveAttackBuff
_TEXT	ENDS
PUBLIC	??_R0?AVioWoundedAddBuff@@@8			; ioWoundedAddBuff `RTTI Type Descriptor'
PUBLIC	?ToWoundedAddBuff@@YAPAVioWoundedAddBuff@@PAVioBuff@@@Z ; ToWoundedAddBuff
;	COMDAT ??_R0?AVioWoundedAddBuff@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobuff.h
_DATA	SEGMENT
??_R0?AVioWoundedAddBuff@@@8 DD FLAT:??_7type_info@@6B@	; ioWoundedAddBuff `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioWoundedAddBuff@@', 00H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iowoundedaddbuff.h
_DATA	ENDS
;	COMDAT ?ToWoundedAddBuff@@YAPAVioWoundedAddBuff@@PAVioBuff@@@Z
_TEXT	SEGMENT
_pBuff$ = 8						; size = 4
?ToWoundedAddBuff@@YAPAVioWoundedAddBuff@@PAVioBuff@@@Z PROC ; ToWoundedAddBuff, COMDAT

; 50   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 51   : 	if( !pBuff || pBuff->GetTypeID() != BT_WOUNDED_ADD_BUFF )

  00003	8b 45 08	 mov	 eax, DWORD PTR _pBuff$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 25		 je	 SHORT $LN1@ToWoundedA
  0000a	81 b8 cc 03 00
	00 c0 00 00 00	 cmp	 DWORD PTR [eax+972], 192 ; 000000c0H
  00014	75 19		 jne	 SHORT $LN1@ToWoundedA

; 53   : 
; 54   : 	return dynamic_cast< ioWoundedAddBuff* >( pBuff );

  00016	6a 00		 push	 0
  00018	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWoundedAddBuff@@@8
  0001d	68 00 00 00 00	 push	 OFFSET ??_R0?AVioBuff@@@8
  00022	6a 00		 push	 0
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002a	83 c4 14	 add	 esp, 20			; 00000014H

; 55   : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
$LN1@ToWoundedA:

; 52   : 		return NULL;

  0002f	33 c0		 xor	 eax, eax

; 55   : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?ToWoundedAddBuff@@YAPAVioWoundedAddBuff@@PAVioBuff@@@Z ENDP ; ToWoundedAddBuff
_TEXT	ENDS
PUBLIC	??_R0?AVioAttackCountBuff@@@8			; ioAttackCountBuff `RTTI Type Descriptor'
PUBLIC	?ToAttackCountBuff@@YAPAVioAttackCountBuff@@PAVioBuff@@@Z ; ToAttackCountBuff
;	COMDAT ??_R0?AVioAttackCountBuff@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobuff.h
_DATA	SEGMENT
??_R0?AVioAttackCountBuff@@@8 DD FLAT:??_7type_info@@6B@ ; ioAttackCountBuff `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioAttackCountBuff@@', 00H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioattackcountbuff.h
_DATA	ENDS
;	COMDAT ?ToAttackCountBuff@@YAPAVioAttackCountBuff@@PAVioBuff@@@Z
_TEXT	SEGMENT
_pBuff$ = 8						; size = 4
?ToAttackCountBuff@@YAPAVioAttackCountBuff@@PAVioBuff@@@Z PROC ; ToAttackCountBuff, COMDAT

; 44   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 45   : 	if( !pBuff || pBuff->GetTypeID() != BT_ATTACK_COUNT_BUFF )

  00003	8b 45 08	 mov	 eax, DWORD PTR _pBuff$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 25		 je	 SHORT $LN1@ToAttackCo
  0000a	81 b8 cc 03 00
	00 c3 00 00 00	 cmp	 DWORD PTR [eax+972], 195 ; 000000c3H
  00014	75 19		 jne	 SHORT $LN1@ToAttackCo

; 47   : 
; 48   : 	return dynamic_cast< ioAttackCountBuff* >( pBuff );

  00016	6a 00		 push	 0
  00018	68 00 00 00 00	 push	 OFFSET ??_R0?AVioAttackCountBuff@@@8
  0001d	68 00 00 00 00	 push	 OFFSET ??_R0?AVioBuff@@@8
  00022	6a 00		 push	 0
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002a	83 c4 14	 add	 esp, 20			; 00000014H

; 49   : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
$LN1@ToAttackCo:

; 46   : 		return NULL;

  0002f	33 c0		 xor	 eax, eax

; 49   : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?ToAttackCountBuff@@YAPAVioAttackCountBuff@@PAVioBuff@@@Z ENDP ; ToAttackCountBuff
_TEXT	ENDS
PUBLIC	??_R0?AVioHitCountHoldBuff2@@@8			; ioHitCountHoldBuff2 `RTTI Type Descriptor'
PUBLIC	?ToHitCountHoldBuff2@@YAPAVioHitCountHoldBuff2@@PAVioBuff@@@Z ; ToHitCountHoldBuff2
;	COMDAT ??_R0?AVioHitCountHoldBuff2@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobuff.h
_DATA	SEGMENT
??_R0?AVioHitCountHoldBuff2@@@8 DD FLAT:??_7type_info@@6B@ ; ioHitCountHoldBuff2 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioHitCountHoldBuff2@@', 00H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iohitcountholdbuff2.h
_DATA	ENDS
;	COMDAT ?ToHitCountHoldBuff2@@YAPAVioHitCountHoldBuff2@@PAVioBuff@@@Z
_TEXT	SEGMENT
_pBuff$ = 8						; size = 4
?ToHitCountHoldBuff2@@YAPAVioHitCountHoldBuff2@@PAVioBuff@@@Z PROC ; ToHitCountHoldBuff2, COMDAT

; 58   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 59   : 	if( !pBuff || pBuff->GetTypeID() != BT_HIT_COUNT_HOLD2 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _pBuff$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 25		 je	 SHORT $LN1@ToHitCount@2
  0000a	81 b8 cc 03 00
	00 c5 00 00 00	 cmp	 DWORD PTR [eax+972], 197 ; 000000c5H
  00014	75 19		 jne	 SHORT $LN1@ToHitCount@2

; 61   : 
; 62   : 	return dynamic_cast< ioHitCountHoldBuff2* >( pBuff );

  00016	6a 00		 push	 0
  00018	68 00 00 00 00	 push	 OFFSET ??_R0?AVioHitCountHoldBuff2@@@8
  0001d	68 00 00 00 00	 push	 OFFSET ??_R0?AVioBuff@@@8
  00022	6a 00		 push	 0
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002a	83 c4 14	 add	 esp, 20			; 00000014H

; 63   : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
$LN1@ToHitCount@2:

; 60   : 		return NULL;

  0002f	33 c0		 xor	 eax, eax

; 63   : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?ToHitCountHoldBuff2@@YAPAVioHitCountHoldBuff2@@PAVioBuff@@@Z ENDP ; ToHitCountHoldBuff2
_TEXT	ENDS
PUBLIC	??_R0?AVioCountGatherAttackBuff@@@8		; ioCountGatherAttackBuff `RTTI Type Descriptor'
PUBLIC	?ToCountGatherAttackBuff@@YAPAVioCountGatherAttackBuff@@PAVioBuff@@@Z ; ToCountGatherAttackBuff
;	COMDAT ??_R0?AVioCountGatherAttackBuff@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobuff.h
_DATA	SEGMENT
??_R0?AVioCountGatherAttackBuff@@@8 DD FLAT:??_7type_info@@6B@ ; ioCountGatherAttackBuff `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioCountGatherAttackBuff@@', 00H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iocountgatherattackbuff.h
_DATA	ENDS
;	COMDAT ?ToCountGatherAttackBuff@@YAPAVioCountGatherAttackBuff@@PAVioBuff@@@Z
_TEXT	SEGMENT
_pBuff$ = 8						; size = 4
?ToCountGatherAttackBuff@@YAPAVioCountGatherAttackBuff@@PAVioBuff@@@Z PROC ; ToCountGatherAttackBuff, COMDAT

; 97   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 98   : 	if( !pBuff || pBuff->GetTypeID() != BT_COUNT_GATHER_ATTACK )

  00003	8b 45 08	 mov	 eax, DWORD PTR _pBuff$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 25		 je	 SHORT $LN1@ToCountGat
  0000a	81 b8 cc 03 00
	00 cb 00 00 00	 cmp	 DWORD PTR [eax+972], 203 ; 000000cbH
  00014	75 19		 jne	 SHORT $LN1@ToCountGat

; 100  : 
; 101  : 	return dynamic_cast< ioCountGatherAttackBuff* >( pBuff );

  00016	6a 00		 push	 0
  00018	68 00 00 00 00	 push	 OFFSET ??_R0?AVioCountGatherAttackBuff@@@8
  0001d	68 00 00 00 00	 push	 OFFSET ??_R0?AVioBuff@@@8
  00022	6a 00		 push	 0
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002a	83 c4 14	 add	 esp, 20			; 00000014H

; 102  : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
$LN1@ToCountGat:

; 99   : 		return NULL;

  0002f	33 c0		 xor	 eax, eax

; 102  : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?ToCountGatherAttackBuff@@YAPAVioCountGatherAttackBuff@@PAVioBuff@@@Z ENDP ; ToCountGatherAttackBuff
_TEXT	ENDS
PUBLIC	??_R0?AVioCreateDummyByAttackedBuff2@@@8	; ioCreateDummyByAttackedBuff2 `RTTI Type Descriptor'
PUBLIC	?ToCreateDummyByAttackedBuff2@@YAPAVioCreateDummyByAttackedBuff2@@PAVioBuff@@@Z ; ToCreateDummyByAttackedBuff2
;	COMDAT ??_R0?AVioCreateDummyByAttackedBuff2@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobuff.h
_DATA	SEGMENT
??_R0?AVioCreateDummyByAttackedBuff2@@@8 DD FLAT:??_7type_info@@6B@ ; ioCreateDummyByAttackedBuff2 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioCreateDummyByAttackedBuff2@@', 00H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iocreatedummybyattackedbuff2.h
_DATA	ENDS
;	COMDAT ?ToCreateDummyByAttackedBuff2@@YAPAVioCreateDummyByAttackedBuff2@@PAVioBuff@@@Z
_TEXT	SEGMENT
_pBuff$ = 8						; size = 4
?ToCreateDummyByAttackedBuff2@@YAPAVioCreateDummyByAttackedBuff2@@PAVioBuff@@@Z PROC ; ToCreateDummyByAttackedBuff2, COMDAT

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 30   : 	if( !pBuff || pBuff->GetTypeID() != BT_CREATE_DUMMY_BY_ATTACKED_BUFF2 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _pBuff$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 25		 je	 SHORT $LN1@ToCreateDu@2
  0000a	81 b8 cc 03 00
	00 e7 00 00 00	 cmp	 DWORD PTR [eax+972], 231 ; 000000e7H
  00014	75 19		 jne	 SHORT $LN1@ToCreateDu@2

; 32   : 
; 33   : 	return dynamic_cast< ioCreateDummyByAttackedBuff2* >( pBuff );

  00016	6a 00		 push	 0
  00018	68 00 00 00 00	 push	 OFFSET ??_R0?AVioCreateDummyByAttackedBuff2@@@8
  0001d	68 00 00 00 00	 push	 OFFSET ??_R0?AVioBuff@@@8
  00022	6a 00		 push	 0
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002a	83 c4 14	 add	 esp, 20			; 00000014H

; 34   : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
$LN1@ToCreateDu@2:

; 31   : 		return NULL;

  0002f	33 c0		 xor	 eax, eax

; 34   : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?ToCreateDummyByAttackedBuff2@@YAPAVioCreateDummyByAttackedBuff2@@PAVioBuff@@@Z ENDP ; ToCreateDummyByAttackedBuff2
_TEXT	ENDS
PUBLIC	??_R0?AVioNpcChar@@@8				; ioNpcChar `RTTI Type Descriptor'
PUBLIC	?ToNpcChar@@YAPAVioNpcChar@@PAVioGameEntity@@@Z	; ToNpcChar
;	COMDAT ??_R0?AVioNpcChar@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ionpcchar.h
_DATA	SEGMENT
??_R0?AVioNpcChar@@@8 DD FLAT:??_7type_info@@6B@	; ioNpcChar `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioNpcChar@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToNpcChar@@YAPAVioNpcChar@@PAVioGameEntity@@@Z
_TEXT	SEGMENT
_pObj$ = 8						; size = 4
?ToNpcChar@@YAPAVioNpcChar@@PAVioGameEntity@@@Z PROC	; ToNpcChar, COMDAT

; 361  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 362  : 	ioBaseChar *pChar = ToBaseChar( pObj );

  00004	ff 75 08	 push	 DWORD PTR _pObj$[ebp]
  00007	e8 00 00 00 00	 call	 ?ToBaseChar@@YAPAVioBaseChar@@PAVioGameEntity@@@Z ; ToBaseChar
  0000c	8b f0		 mov	 esi, eax
  0000e	59		 pop	 ecx

; 363  : 	if( !pChar || pChar->GetControlType() != CONTROL_AI )

  0000f	85 f6		 test	 esi, esi
  00011	74 28		 je	 SHORT $LN1@ToNpcChar
  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	8b ce		 mov	 ecx, esi
  00017	ff 90 ec 00 00
	00		 call	 DWORD PTR [eax+236]
  0001d	83 f8 02	 cmp	 eax, 2
  00020	75 19		 jne	 SHORT $LN1@ToNpcChar

; 365  : 
; 366  : 	return dynamic_cast< ioNpcChar* >(pChar);

  00022	6a 00		 push	 0
  00024	68 00 00 00 00	 push	 OFFSET ??_R0?AVioNpcChar@@@8
  00029	68 00 00 00 00	 push	 OFFSET ??_R0?AVioBaseChar@@@8
  0002e	6a 00		 push	 0
  00030	56		 push	 esi
  00031	e8 00 00 00 00	 call	 ___RTDynamicCast
  00036	83 c4 14	 add	 esp, 20			; 00000014H
  00039	eb 02		 jmp	 SHORT $LN3@ToNpcChar
$LN1@ToNpcChar:

; 364  : 		return NULL;

  0003b	33 c0		 xor	 eax, eax
$LN3@ToNpcChar:
  0003d	5e		 pop	 esi

; 367  : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?ToNpcChar@@YAPAVioNpcChar@@PAVioGameEntity@@@Z ENDP	; ToNpcChar
_TEXT	ENDS
PUBLIC	?IsNpcChar@@YA_NPAVioGameEntity@@@Z		; IsNpcChar
; Function compile flags: /Ogsp
;	COMDAT ?IsNpcChar@@YA_NPAVioGameEntity@@@Z
_TEXT	SEGMENT
_pObj$ = 8						; size = 4
?IsNpcChar@@YA_NPAVioGameEntity@@@Z PROC		; IsNpcChar, COMDAT

; 379  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 380  : 	ioBaseChar *pChar = ToBaseChar( pObj );

  00003	ff 75 08	 push	 DWORD PTR _pObj$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToBaseChar@@YAPAVioBaseChar@@PAVioGameEntity@@@Z ; ToBaseChar
  0000b	59		 pop	 ecx

; 381  : 	if( !pChar || pChar->GetControlType() != CONTROL_AI )

  0000c	85 c0		 test	 eax, eax
  0000e	74 13		 je	 SHORT $LN1@IsNpcChar
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 ec 00 00
	00		 call	 DWORD PTR [edx+236]
  0001a	83 f8 02	 cmp	 eax, 2
  0001d	75 04		 jne	 SHORT $LN1@IsNpcChar

; 383  : 
; 384  : 	return true;

  0001f	b0 01		 mov	 al, 1

; 385  : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
$LN1@IsNpcChar:

; 382  : 		return false;

  00023	32 c0		 xor	 al, al

; 385  : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?IsNpcChar@@YA_NPAVioGameEntity@@@Z ENDP		; IsNpcChar
_TEXT	ENDS
PUBLIC	?ApplyWeaponWoundedEnableChangeWoundState@ioBaseChar@@IAEXPAVioWeapon@@AA_N1W4DefenseBreakType@@@Z ; ioBaseChar::ApplyWeaponWoundedEnableChangeWoundState
EXTRN	?IsNoCancel@ioStateProtectionBuff@@QAE_NXZ:PROC	; ioStateProtectionBuff::IsNoCancel
EXTRN	?IsNoCancel@ioThunderBirdHoldBuff@@QAE_NXZ:PROC	; ioThunderBirdHoldBuff::IsNoCancel
EXTRN	?IsNoCancel@ioFloatBuff2@@QAE_NXZ:PROC		; ioFloatBuff2::IsNoCancel
EXTRN	?GetBuff@ioBaseChar@@QAEPAVioBuff@@H@Z:PROC	; ioBaseChar::GetBuff
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasecharapplywoundednew.cpp
;	COMDAT ?ApplyWeaponWoundedEnableChangeWoundState@ioBaseChar@@IAEXPAVioWeapon@@AA_N1W4DefenseBreakType@@@Z
_TEXT	SEGMENT
_pWeapon$ = 8						; size = 4
_bEnableCancel$ = 12					; size = 4
_bNoCancel$ = 16					; size = 4
_eBreakType$ = 20					; size = 4
?ApplyWeaponWoundedEnableChangeWoundState@ioBaseChar@@IAEXPAVioWeapon@@AA_N1W4DefenseBreakType@@@Z PROC ; ioBaseChar::ApplyWeaponWoundedEnableChangeWoundState, COMDAT
; _this$ = ecx

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	if ( !pWeapon )

  00003	8b 55 08	 mov	 edx, DWORD PTR _pWeapon$[ebp]
  00006	53		 push	 ebx
  00007	33 db		 xor	 ebx, ebx
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	3b d3		 cmp	 edx, ebx
  0000e	0f 84 b7 00 00
	00		 je	 $LN1@ApplyWeapo@4

; 32   : 		return;
; 33   : 
; 34   : 	//---   
; 35   : 
; 36   : 	bEnableCancel = true;

  00014	8b 45 0c	 mov	 eax, DWORD PTR _bEnableCancel$[ebp]
  00017	57		 push	 edi

; 37   : 	bNoCancel = false;

  00018	8b 7d 10	 mov	 edi, DWORD PTR _bNoCancel$[ebp]
  0001b	c6 00 01	 mov	 BYTE PTR [eax], 1
  0001e	88 1f		 mov	 BYTE PTR [edi], bl

; 38   : 
; 39   : 	if( m_CharState == CS_FLOAT_STATE )

  00020	80 be 10 03 00
	00 25		 cmp	 BYTE PTR [esi+784], 37	; 00000025H
  00027	75 35		 jne	 SHORT $LN4@ApplyWeapo@4

; 40   : 	{
; 41   : 		if( pWeapon->CheckWeaponByFloatBreak() )

  00029	38 9a 83 05 00
	00		 cmp	 BYTE PTR [edx+1411], bl
  0002f	74 05		 je	 SHORT $LN11@ApplyWeapo@4

; 42   : 		{
; 43   : 			bEnableCancel = true;

  00031	c6 00 01	 mov	 BYTE PTR [eax], 1
  00034	eb 28		 jmp	 SHORT $LN4@ApplyWeapo@4
$LN11@ApplyWeapo@4:

; 44   : 		}
; 45   : 		else if( m_FloatBuffInfo.m_iCancelType == ioFloatBuff::FCT_NONE )

  00036	8b 8e c0 1c 00
	00		 mov	 ecx, DWORD PTR [esi+7360]
  0003c	3b cb		 cmp	 ecx, ebx

; 46   : 		{
; 47   : 			bEnableCancel = false;

  0003e	74 12		 je	 SHORT $LN21@ApplyWeapo@4

; 48   : 		}
; 49   : 		else if( m_FloatBuffInfo.m_iCancelType == ioFloatBuff::FCT_SEMI_CANCEL )

  00040	83 f9 01	 cmp	 ecx, 1
  00043	75 11		 jne	 SHORT $LN7@ApplyWeapo@4

; 50   : 		{
; 51   : 			if( eBreakType == DBT_NONE && !pWeapon->CheckWeaponBySkill() )

  00045	39 5d 14	 cmp	 DWORD PTR _eBreakType$[ebp], ebx
  00048	75 14		 jne	 SHORT $LN4@ApplyWeapo@4
  0004a	38 9a 7e 05 00
	00		 cmp	 BYTE PTR [edx+1406], bl
  00050	75 0c		 jne	 SHORT $LN4@ApplyWeapo@4
$LN21@ApplyWeapo@4:

; 52   : 				bEnableCancel = false;

  00052	88 18		 mov	 BYTE PTR [eax], bl

; 53   : 		}

  00054	eb 08		 jmp	 SHORT $LN4@ApplyWeapo@4
$LN7@ApplyWeapo@4:

; 54   : 		else if ( m_FloatBuffInfo.m_iCancelType == ioFloatBuff::FCT_NO_CANCEL )

  00056	83 f9 03	 cmp	 ecx, 3
  00059	75 03		 jne	 SHORT $LN4@ApplyWeapo@4

; 55   : 		{
; 56   : 			bNoCancel = true;

  0005b	c6 07 01	 mov	 BYTE PTR [edi], 1
$LN4@ApplyWeapo@4:

; 57   : 		}
; 58   : 	}
; 59   : 
; 60   : 	//-----------------------------------------------------------------------------
; 61   : 
; 62   : 	ioFloatBuff2 *pFloatBuff2 = ToFloatBuff2( GetBuff( BT_FLOAT2 ) );

  0005e	68 ad 00 00 00	 push	 173			; 000000adH
  00063	8b ce		 mov	 ecx, esi
  00065	e8 00 00 00 00	 call	 ?GetBuff@ioBaseChar@@QAEPAVioBuff@@H@Z ; ioBaseChar::GetBuff
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 ?ToFloatBuff2@@YAPAVioFloatBuff2@@PAVioBuff@@@Z ; ToFloatBuff2
  00070	59		 pop	 ecx

; 63   : 	if ( pFloatBuff2 && pFloatBuff2->IsNoCancel() )

  00071	3b c3		 cmp	 eax, ebx
  00073	74 0e		 je	 SHORT $LN3@ApplyWeapo@4
  00075	8b c8		 mov	 ecx, eax
  00077	e8 00 00 00 00	 call	 ?IsNoCancel@ioFloatBuff2@@QAE_NXZ ; ioFloatBuff2::IsNoCancel
  0007c	84 c0		 test	 al, al
  0007e	74 03		 je	 SHORT $LN3@ApplyWeapo@4

; 64   : 		bNoCancel = true;

  00080	c6 07 01	 mov	 BYTE PTR [edi], 1
$LN3@ApplyWeapo@4:

; 65   : 
; 66   : 	ioThunderBirdHoldBuff *pThunderBirdHoldBuff = ToThunderBirdHoldBuff( GetBuff( BT_THUNDER_BIRD_HOLD ) );

  00083	68 b1 00 00 00	 push	 177			; 000000b1H
  00088	8b ce		 mov	 ecx, esi
  0008a	e8 00 00 00 00	 call	 ?GetBuff@ioBaseChar@@QAEPAVioBuff@@H@Z ; ioBaseChar::GetBuff
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ?ToThunderBirdHoldBuff@@YAPAVioThunderBirdHoldBuff@@PAVioBuff@@@Z ; ToThunderBirdHoldBuff
  00095	59		 pop	 ecx

; 67   : 	if ( pThunderBirdHoldBuff && pThunderBirdHoldBuff->IsNoCancel() )

  00096	3b c3		 cmp	 eax, ebx
  00098	74 0e		 je	 SHORT $LN2@ApplyWeapo@4
  0009a	8b c8		 mov	 ecx, eax
  0009c	e8 00 00 00 00	 call	 ?IsNoCancel@ioThunderBirdHoldBuff@@QAE_NXZ ; ioThunderBirdHoldBuff::IsNoCancel
  000a1	84 c0		 test	 al, al
  000a3	74 03		 je	 SHORT $LN2@ApplyWeapo@4

; 68   : 		bNoCancel = true;

  000a5	c6 07 01	 mov	 BYTE PTR [edi], 1
$LN2@ApplyWeapo@4:

; 69   : 	
; 70   : 	ioStateProtectionBuff *StateProtectionBuff = ToStateProtectBuff( GetBuff( BT_STATE_PROTECTION) );

  000a8	6a 23		 push	 35			; 00000023H
  000aa	8b ce		 mov	 ecx, esi
  000ac	e8 00 00 00 00	 call	 ?GetBuff@ioBaseChar@@QAEPAVioBuff@@H@Z ; ioBaseChar::GetBuff
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 ?ToStateProtectBuff@@YAPAVioStateProtectionBuff@@PAVioBuff@@@Z ; ToStateProtectBuff
  000b7	59		 pop	 ecx

; 71   : 	if ( StateProtectionBuff && StateProtectionBuff->IsNoCancel() )

  000b8	3b c3		 cmp	 eax, ebx
  000ba	74 0e		 je	 SHORT $LN20@ApplyWeapo@4
  000bc	8b c8		 mov	 ecx, eax
  000be	e8 00 00 00 00	 call	 ?IsNoCancel@ioStateProtectionBuff@@QAE_NXZ ; ioStateProtectionBuff::IsNoCancel
  000c3	84 c0		 test	 al, al
  000c5	74 03		 je	 SHORT $LN20@ApplyWeapo@4

; 72   : 		bNoCancel = true;

  000c7	c6 07 01	 mov	 BYTE PTR [edi], 1
$LN20@ApplyWeapo@4:
  000ca	5f		 pop	 edi
$LN1@ApplyWeapo@4:
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx

; 73   : }

  000cd	5d		 pop	 ebp
  000ce	c2 10 00	 ret	 16			; 00000010H
?ApplyWeaponWoundedEnableChangeWoundState@ioBaseChar@@IAEXPAVioWeapon@@AA_N1W4DefenseBreakType@@@Z ENDP ; ioBaseChar::ApplyWeaponWoundedEnableChangeWoundState
_TEXT	ENDS
PUBLIC	?ApplyWeaponWoundedCheckFrozenState@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_N2AAH@Z ; ioBaseChar::ApplyWeaponWoundedCheckFrozenState
EXTRN	?HasBuff@ioBaseChar@@QBE_NH@Z:PROC		; ioBaseChar::HasBuff
EXTRN	?IsDefenseBreakBuff@ioWeapon@@QBE_NXZ:PROC	; ioWeapon::IsDefenseBreakBuff
EXTRN	?GetBuffConst@ioBuffMaker@@QBEPBVioBuff@@ABVioHashString@@@Z:PROC ; ioBuffMaker::GetBuffConst
EXTRN	?GetSingleton@ioBuffMaker@@SAAAV1@XZ:PROC	; ioBuffMaker::GetSingleton
; Function compile flags: /Ogsp
;	COMDAT ?ApplyWeaponWoundedCheckFrozenState@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_N2AAH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iTargetBuffCnt$ = -4					; size = 4
_pWeapon$ = 8						; size = 4
_pAttacker$ = 12					; size = 4
tv261 = 16						; size = 4
_bFrozenBuff$ = 16					; size = 4
_bChangeDefenseBreak$ = 19				; size = 1
_bFrozenState$ = 20					; size = 4
_i$693528 = 24						; size = 4
_iFrozenType$ = 24					; size = 4
?ApplyWeaponWoundedCheckFrozenState@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_N2AAH@Z PROC ; ioBaseChar::ApplyWeaponWoundedCheckFrozenState, COMDAT
; _this$ = ecx

; 76   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 77   : 	//---  
; 78   : 
; 79   : 	if ( !pWeapon || !pAttacker )

  00008	8b 4d 08	 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  0000b	85 c9		 test	 ecx, ecx
  0000d	0f 84 cf 00 00
	00		 je	 $LN10@ApplyWeapo@5
  00013	83 7d 0c 00	 cmp	 DWORD PTR _pAttacker$[ebp], 0
  00017	0f 84 c5 00 00
	00		 je	 $LN10@ApplyWeapo@5

; 80   : 		return;
; 81   : 
; 82   : 	const BuffInfoList& kBuffList = pWeapon->GetTargetBuffList();

  0001d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001f	53		 push	 ebx
  00020	56		 push	 esi
  00021	57		 push	 edi
  00022	ff 50 68	 call	 DWORD PTR [eax+104]
  00025	8b f0		 mov	 esi, eax

; 83   : 	int iTargetBuffCnt = kBuffList.size();

  00027	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002a	2b 06		 sub	 eax, DWORD PTR [esi]
  0002c	6a 14		 push	 20			; 00000014H
  0002e	99		 cdq
  0002f	59		 pop	 ecx
  00030	f7 f9		 idiv	 ecx

; 84   : 
; 85   : 	bFrozenBuff = false;

  00032	8b 5d 10	 mov	 ebx, DWORD PTR _bFrozenBuff$[ebp]

; 86   : 	iFrozenType = ioFrozenBuff::FZT_NONE;

  00035	8b 7d 18	 mov	 edi, DWORD PTR _iFrozenType$[ebp]
  00038	33 c9		 xor	 ecx, ecx
  0003a	c6 03 00	 mov	 BYTE PTR [ebx], 0
  0003d	89 0f		 mov	 DWORD PTR [edi], ecx

; 87   : 	for( int i=0; i<iTargetBuffCnt; ++i )

  0003f	89 4d 18	 mov	 DWORD PTR _i$693528[ebp], ecx
  00042	89 45 fc	 mov	 DWORD PTR _iTargetBuffCnt$[ebp], eax
  00045	3b c1		 cmp	 eax, ecx
  00047	7e 3c		 jle	 SHORT $LN7@ApplyWeapo@5

; 80   : 		return;
; 81   : 
; 82   : 	const BuffInfoList& kBuffList = pWeapon->GetTargetBuffList();

  00049	89 4d 10	 mov	 DWORD PTR tv261[ebp], ecx
$LL23@ApplyWeapo@5:

; 88   : 	{
; 89   : 		const ioFrozenBuff *pFrozen = ToFrozenConst( g_BuffMaker.GetBuffConst( kBuffList[i].m_BuffName ) );

  0004c	8b 06		 mov	 eax, DWORD PTR [esi]
  0004e	03 45 10	 add	 eax, DWORD PTR tv261[ebp]
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ?GetSingleton@ioBuffMaker@@SAAAV1@XZ ; ioBuffMaker::GetSingleton
  00057	8b c8		 mov	 ecx, eax
  00059	e8 00 00 00 00	 call	 ?GetBuffConst@ioBuffMaker@@QBEPBVioBuff@@ABVioHashString@@@Z ; ioBuffMaker::GetBuffConst
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 ?ToFrozenConst@@YAPBVioFrozenBuff@@PBVioBuff@@@Z ; ToFrozenConst
  00064	59		 pop	 ecx

; 90   : 		if( pFrozen )

  00065	85 c0		 test	 eax, eax
  00067	75 11		 jne	 SHORT $LN21@ApplyWeapo@5

; 87   : 	for( int i=0; i<iTargetBuffCnt; ++i )

  00069	ff 45 18	 inc	 DWORD PTR _i$693528[ebp]
  0006c	8b 45 18	 mov	 eax, DWORD PTR _i$693528[ebp]
  0006f	83 45 10 14	 add	 DWORD PTR tv261[ebp], 20 ; 00000014H
  00073	3b 45 fc	 cmp	 eax, DWORD PTR _iTargetBuffCnt$[ebp]
  00076	7c d4		 jl	 SHORT $LL23@ApplyWeapo@5

; 90   : 		if( pFrozen )

  00078	eb 0b		 jmp	 SHORT $LN7@ApplyWeapo@5
$LN21@ApplyWeapo@5:

; 91   : 		{
; 92   : 			bFrozenBuff = true;

  0007a	c6 03 01	 mov	 BYTE PTR [ebx], 1

; 93   : 			iFrozenType = pFrozen->GetFrozenType();

  0007d	8b 80 74 09 00
	00		 mov	 eax, DWORD PTR [eax+2420]
  00083	89 07		 mov	 DWORD PTR [edi], eax
$LN7@ApplyWeapo@5:

; 94   : 			break;
; 95   : 		}
; 96   : 	}
; 97   : 
; 98   : 	bool bChangeDefenseBreak = false;
; 99   : 	if( pWeapon->IsDefenseBreakBuff() && pAttacker->HasBuff(BT_DEFENSE_BREAK_BUFF) )

  00085	8b 4d 08	 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  00088	c6 45 13 00	 mov	 BYTE PTR _bChangeDefenseBreak$[ebp], 0
  0008c	e8 00 00 00 00	 call	 ?IsDefenseBreakBuff@ioWeapon@@QBE_NXZ ; ioWeapon::IsDefenseBreakBuff
  00091	84 c0		 test	 al, al
  00093	74 12		 je	 SHORT $LN5@ApplyWeapo@5
  00095	8b 4d 0c	 mov	 ecx, DWORD PTR _pAttacker$[ebp]
  00098	6a 3d		 push	 61			; 0000003dH
  0009a	e8 00 00 00 00	 call	 ?HasBuff@ioBaseChar@@QBE_NH@Z ; ioBaseChar::HasBuff
  0009f	84 c0		 test	 al, al
  000a1	74 04		 je	 SHORT $LN5@ApplyWeapo@5

; 100  : 		bChangeDefenseBreak = true;

  000a3	c6 45 13 01	 mov	 BYTE PTR _bChangeDefenseBreak$[ebp], 1
$LN5@ApplyWeapo@5:

; 101  : 
; 102  : 	bFrozenState = false;

  000a7	8b 75 14	 mov	 esi, DWORD PTR _bFrozenState$[ebp]

; 103  : 	if( m_CharState == CS_FROZEN )

  000aa	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	c6 06 00	 mov	 BYTE PTR [esi], 0
  000b0	80 b8 10 03 00
	00 17		 cmp	 BYTE PTR [eax+784], 23	; 00000017H
  000b7	75 03		 jne	 SHORT $LN4@ApplyWeapo@5

; 104  : 		bFrozenState = true;

  000b9	c6 06 01	 mov	 BYTE PTR [esi], 1
$LN4@ApplyWeapo@5:

; 105  : 
; 106  : 	if( pWeapon->HasFeature( WF_FROZEN_BREAK ) || bChangeDefenseBreak )

  000bc	8b 4d 08	 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  000bf	68 00 04 00 00	 push	 1024			; 00000400H
  000c4	e8 00 00 00 00	 call	 ?HasFeature@ioWeapon@@QBE_NK@Z ; ioWeapon::HasFeature
  000c9	84 c0		 test	 al, al
  000cb	75 05		 jne	 SHORT $LN2@ApplyWeapo@5
  000cd	38 45 13	 cmp	 BYTE PTR _bChangeDefenseBreak$[ebp], al
  000d0	74 0d		 je	 SHORT $LN24@ApplyWeapo@5
$LN2@ApplyWeapo@5:

; 107  : 	{
; 108  : 		if( bFrozenState && !bFrozenBuff )

  000d2	80 3e 00	 cmp	 BYTE PTR [esi], 0
  000d5	74 08		 je	 SHORT $LN24@ApplyWeapo@5
  000d7	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  000da	75 03		 jne	 SHORT $LN24@ApplyWeapo@5

; 109  : 			bFrozenState = false;

  000dc	c6 06 00	 mov	 BYTE PTR [esi], 0
$LN24@ApplyWeapo@5:
  000df	5f		 pop	 edi
  000e0	5e		 pop	 esi
  000e1	5b		 pop	 ebx
$LN10@ApplyWeapo@5:

; 110  : 	}
; 111  : }

  000e2	c9		 leave
  000e3	c2 14 00	 ret	 20			; 00000014H
?ApplyWeaponWoundedCheckFrozenState@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_N2AAH@Z ENDP ; ioBaseChar::ApplyWeaponWoundedCheckFrozenState
_TEXT	ENDS
PUBLIC	?ApplyWeaponWoundedFrontBackBuff@ioBaseChar@@IAEXPAV1@W4AttackSide@@_N22AAVioHashString@@3AAM@Z ; ioBaseChar::ApplyWeaponWoundedFrontBackBuff
EXTRN	__imp_??4ioHashString@@QAEAAV0@ABV0@@Z:PROC
EXTRN	?GetFrontBackWoundInfo@ioBaseChar@@QAE_NAAUFrontBackWoundInfo@@@Z:PROC ; ioBaseChar::GetFrontBackWoundInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ApplyWeaponWoundedFrontBackBuff@ioBaseChar@@IAEXPAV1@W4AttackSide@@_N22AAVioHashString@@3AAM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ApplyWeaponWoundedFrontBackBuff@ioBaseChar@@IAEXPAV1@W4AttackSide@@_N22AAVioHashString@@3AAM@Z$0
__ehfuncinfo$?ApplyWeaponWoundedFrontBackBuff@ioBaseChar@@IAEXPAV1@W4AttackSide@@_N22AAVioHashString@@3AAM@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ApplyWeaponWoundedFrontBackBuff@ioBaseChar@@IAEXPAV1@W4AttackSide@@_N22AAVioHashString@@3AAM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ?ApplyWeaponWoundedFrontBackBuff@ioBaseChar@@IAEXPAV1@W4AttackSide@@_N22AAVioHashString@@3AAM@Z
_TEXT	SEGMENT
_kInfo$ = -244						; size = 232
__$EHRec$ = -12						; size = 12
_pAttacker$ = 8						; size = 4
_eAttackSide$ = 12					; size = 4
_bAirTargetBuff$ = 16					; size = 1
_bTargetBuff$ = 20					; size = 1
_bDownTargetBuff$ = 24					; size = 1
_szFrontBackWoundBuff$ = 28				; size = 4
_szFrontBackAttackerBuff$ = 32				; size = 4
_fDamage$ = 36						; size = 4
?ApplyWeaponWoundedFrontBackBuff@ioBaseChar@@IAEXPAV1@W4AttackSide@@_N22AAVioHashString@@3AAM@Z PROC ; ioBaseChar::ApplyWeaponWoundedFrontBackBuff, COMDAT
; _this$ = ecx

; 726  : {

  00000	68 e8 00 00 00	 push	 232			; 000000e8H
  00005	b8 00 00 00 00	 mov	 eax, __ehhandler$?ApplyWeaponWoundedFrontBackBuff@ioBaseChar@@IAEXPAV1@W4AttackSide@@_N22AAVioHashString@@3AAM@Z
  0000a	e8 00 00 00 00	 call	 __EH_prolog3

; 727  : 	if ( !pAttacker )

  0000f	33 db		 xor	 ebx, ebx
  00011	39 5d 08	 cmp	 DWORD PTR _pAttacker$[ebp], ebx
  00014	0f 84 f2 00 00
	00		 je	 $LN15@ApplyWeapo@6

; 728  : 		return;
; 729  : 
; 730  : 	FrontBackWoundInfo kInfo;

  0001a	8d 8d 0c ff ff
	ff		 lea	 ecx, DWORD PTR _kInfo$[ebp]
  00020	e8 00 00 00 00	 call	 ??0FrontBackWoundInfo@@QAE@XZ ; FrontBackWoundInfo::FrontBackWoundInfo

; 731  : 	if( pAttacker->GetFrontBackWoundInfo( kInfo ) && bTargetBuff )

  00025	8b 4d 08	 mov	 ecx, DWORD PTR _pAttacker$[ebp]
  00028	8d 85 0c ff ff
	ff		 lea	 eax, DWORD PTR _kInfo$[ebp]
  0002e	50		 push	 eax
  0002f	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00032	e8 00 00 00 00	 call	 ?GetFrontBackWoundInfo@ioBaseChar@@QAE_NAAUFrontBackWoundInfo@@@Z ; ioBaseChar::GetFrontBackWoundInfo
  00037	84 c0		 test	 al, al
  00039	0f 84 be 00 00
	00		 je	 $LN1@ApplyWeapo@6
  0003f	38 5d 14	 cmp	 BYTE PTR _bTargetBuff$[ebp], bl
  00042	0f 84 b5 00 00
	00		 je	 $LN1@ApplyWeapo@6

; 732  : 	{
; 733  : 		if( eAttackSide == AS_FRONT )

  00048	83 7d 0c 01	 cmp	 DWORD PTR _eAttackSide$[ebp], 1

; 736  : 			{
; 737  : 				fDamage *= kInfo.m_fAirFrontDamageRate;

  0004c	8b 45 24	 mov	 eax, DWORD PTR _fDamage$[ebp]
  0004f	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]

; 738  : 				szFrontBackWoundBuff = kInfo.m_AirFrontBuff;

  00053	8b 4d 1c	 mov	 ecx, DWORD PTR _szFrontBackWoundBuff$[ebp]
  00056	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_??4ioHashString@@QAEAAV0@ABV0@@Z
  0005c	0f 5a c0	 cvtps2pd xmm0, xmm0
  0005f	75 4c		 jne	 SHORT $LN12@ApplyWeapo@6

; 734  : 		{
; 735  : 			if( bAirTargetBuff )

  00061	38 5d 10	 cmp	 BYTE PTR _bAirTargetBuff$[ebp], bl
  00064	74 1f		 je	 SHORT $LN11@ApplyWeapo@6

; 736  : 			{
; 737  : 				fDamage *= kInfo.m_fAirFrontDamageRate;

  00066	f3 0f 10 4d cc	 movss	 xmm1, DWORD PTR _kInfo$[ebp+192]
  0006b	0f 5a c9	 cvtps2pd xmm1, xmm1
  0006e	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00072	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00076	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 738  : 				szFrontBackWoundBuff = kInfo.m_AirFrontBuff;

  0007a	8d 45 ac	 lea	 eax, DWORD PTR _kInfo$[ebp+160]
  0007d	50		 push	 eax
  0007e	ff d6		 call	 esi

; 739  : 				szFrontBackAttackerBuff = kInfo.m_AirFrontAttackerBuff;

  00080	8d 45 bc	 lea	 eax, DWORD PTR _kInfo$[ebp+176]
  00083	eb 72		 jmp	 SHORT $LN19@ApplyWeapo@6
$LN11@ApplyWeapo@6:

; 740  : 			}
; 741  : 			else if( bTargetBuff )
; 742  : 			{
; 743  : 				fDamage *= kInfo.m_fFrontDamageRate;

  00085	f3 0f 10 8d 3c
	ff ff ff	 movss	 xmm1, DWORD PTR _kInfo$[ebp+48]
  0008d	0f 5a c9	 cvtps2pd xmm1, xmm1
  00090	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00094	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00098	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 744  : 				szFrontBackWoundBuff = kInfo.m_FrontBuff;

  0009c	8d 85 1c ff ff
	ff		 lea	 eax, DWORD PTR _kInfo$[ebp+16]
  000a2	50		 push	 eax
  000a3	ff d6		 call	 esi

; 745  : 				szFrontBackAttackerBuff = kInfo.m_FrontAttackerBuff;

  000a5	8d 85 2c ff ff
	ff		 lea	 eax, DWORD PTR _kInfo$[ebp+32]

; 746  : 			}
; 747  : 			else if( bDownTargetBuff )
; 748  : 			{
; 749  : 				fDamage *= kInfo.m_fDownFrontDamageRate;
; 750  : 				szFrontBackWoundBuff = kInfo.m_DownFrontBuff;
; 751  : 				szFrontBackAttackerBuff = kInfo.m_DownFrontAttackerBuff;
; 752  : 			}
; 753  : 		}
; 754  : 		else

  000ab	eb 4a		 jmp	 SHORT $LN19@ApplyWeapo@6
$LN12@ApplyWeapo@6:

; 755  : 		{
; 756  : 			if( bAirTargetBuff )

  000ad	38 5d 10	 cmp	 BYTE PTR _bAirTargetBuff$[ebp], bl
  000b0	74 1f		 je	 SHORT $LN5@ApplyWeapo@6

; 757  : 			{
; 758  : 				fDamage *= kInfo.m_fAirBackDamageRate;

  000b2	f3 0f 10 4d f0	 movss	 xmm1, DWORD PTR _kInfo$[ebp+228]
  000b7	0f 5a c9	 cvtps2pd xmm1, xmm1
  000ba	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  000be	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  000c2	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 759  : 				szFrontBackWoundBuff = kInfo.m_AirBackBuff;

  000c6	8d 45 d0	 lea	 eax, DWORD PTR _kInfo$[ebp+196]
  000c9	50		 push	 eax
  000ca	ff d6		 call	 esi

; 760  : 				szFrontBackAttackerBuff = kInfo.m_AirBackAttackerBuff;

  000cc	8d 45 e0	 lea	 eax, DWORD PTR _kInfo$[ebp+212]
  000cf	eb 26		 jmp	 SHORT $LN19@ApplyWeapo@6
$LN5@ApplyWeapo@6:

; 761  : 			}
; 762  : 			else if( bTargetBuff )
; 763  : 			{
; 764  : 				fDamage *= kInfo.m_fBackDamageRate;

  000d1	f3 0f 10 8d 60
	ff ff ff	 movss	 xmm1, DWORD PTR _kInfo$[ebp+84]
  000d9	0f 5a c9	 cvtps2pd xmm1, xmm1
  000dc	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  000e0	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  000e4	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 765  : 				szFrontBackWoundBuff = kInfo.m_BackBuff;

  000e8	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _kInfo$[ebp+52]
  000ee	50		 push	 eax
  000ef	ff d6		 call	 esi

; 766  : 				szFrontBackAttackerBuff = kInfo.m_BackAttackerBuff;

  000f1	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _kInfo$[ebp+68]
$LN19@ApplyWeapo@6:
  000f7	8b 4d 20	 mov	 ecx, DWORD PTR _szFrontBackAttackerBuff$[ebp]
  000fa	50		 push	 eax
  000fb	ff d6		 call	 esi
$LN1@ApplyWeapo@6:

; 767  : 			}
; 768  : 			else if( bDownTargetBuff )
; 769  : 			{
; 770  : 				fDamage *= kInfo.m_fDownBackDamageRate;
; 771  : 				szFrontBackWoundBuff = kInfo.m_DownBackBuff;
; 772  : 				szFrontBackAttackerBuff = kInfo.m_DownBackAttackerBuff;
; 773  : 			}
; 774  : 		}
; 775  : 	}
; 776  : }

  000fd	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00101	8d 8d 0c ff ff
	ff		 lea	 ecx, DWORD PTR _kInfo$[ebp]
  00107	e8 00 00 00 00	 call	 ??1FrontBackWoundInfo@@QAE@XZ
$LN15@ApplyWeapo@6:
  0010c	e8 00 00 00 00	 call	 __EH_epilog3
  00111	c2 20 00	 ret	 32			; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ApplyWeaponWoundedFrontBackBuff@ioBaseChar@@IAEXPAV1@W4AttackSide@@_N22AAVioHashString@@3AAM@Z$0:
  00000	8d 8d 0c ff ff
	ff		 lea	 ecx, DWORD PTR _kInfo$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1FrontBackWoundInfo@@QAE@XZ
__ehhandler$?ApplyWeaponWoundedFrontBackBuff@ioBaseChar@@IAEXPAV1@W4AttackSide@@_N22AAVioHashString@@3AAM@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 08 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-248]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ApplyWeaponWoundedFrontBackBuff@ioBaseChar@@IAEXPAV1@W4AttackSide@@_N22AAVioHashString@@3AAM@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ApplyWeaponWoundedFrontBackBuff@ioBaseChar@@IAEXPAV1@W4AttackSide@@_N22AAVioHashString@@3AAM@Z ENDP ; ioBaseChar::ApplyWeaponWoundedFrontBackBuff
PUBLIC	?ApplyWeaponWoundedPushBlowCalcByBuff@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AAM2_N@Z ; ioBaseChar::ApplyWeaponWoundedPushBlowCalcByBuff
EXTRN	?SetState@ioBaseChar@@QAEXH_N@Z:PROC		; ioBaseChar::SetState
EXTRN	?CheckThunderBirdSpecialBuff@ioBaseChar@@QAEX_N@Z:PROC ; ioBaseChar::CheckThunderBirdSpecialBuff
EXTRN	?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ:PROC ; ioBaseChar::GetWeapon
; Function compile flags: /Ogsp
;	COMDAT ?ApplyWeaponWoundedPushBlowCalcByBuff@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AAM2_N@Z
_TEXT	SEGMENT
_pWeapon$ = 8						; size = 4
_pAttacker$ = 12					; size = 4
_fPushPower$ = 16					; size = 4
_fBlowPower$ = 20					; size = 4
_bTeamAttack$ = 24					; size = 1
?ApplyWeaponWoundedPushBlowCalcByBuff@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AAM2_N@Z PROC ; ioBaseChar::ApplyWeaponWoundedPushBlowCalcByBuff, COMDAT
; _this$ = ecx

; 1416 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 1417 : 	if ( !pWeapon || !pAttacker )

  00005	8b 75 08	 mov	 esi, DWORD PTR _pWeapon$[ebp]
  00008	33 db		 xor	 ebx, ebx
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	3b f3		 cmp	 esi, ebx
  0000f	0f 84 9e 00 00
	00		 je	 $LN10@ApplyWeapo@7
  00015	39 5d 0c	 cmp	 DWORD PTR _pAttacker$[ebp], ebx
  00018	0f 84 95 00 00
	00		 je	 $LN10@ApplyWeapo@7

; 1418 : 		return;
; 1419 : 
; 1420 : 	//---  2 
; 1421 : 	if( HasBuff( BT_HIT_COUNT_HOLD ) )

  0001e	6a 70		 push	 112			; 00000070H
  00020	e8 00 00 00 00	 call	 ?HasBuff@ioBaseChar@@QBE_NH@Z ; ioBaseChar::HasBuff
  00025	8b 4d 14	 mov	 ecx, DWORD PTR _fBlowPower$[ebp]
  00028	0f 57 c0	 xorps	 xmm0, xmm0
  0002b	84 c0		 test	 al, al
  0002d	8b 45 10	 mov	 eax, DWORD PTR _fPushPower$[ebp]
  00030	74 08		 je	 SHORT $LN9@ApplyWeapo@7

; 1422 : 	{
; 1423 : 		fPushPower = 0.0f;

  00032	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 1424 : 		fBlowPower = 0.0f;

  00036	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
$LN9@ApplyWeapo@7:

; 1425 : 	}
; 1426 : 
; 1427 : 	//   
; 1428 : 	if ( m_CharState == CS_THUNDER_BIRD_HOLD )

  0003a	80 bf 10 03 00
	00 7d		 cmp	 BYTE PTR [edi+784], 125	; 0000007dH
  00041	75 70		 jne	 SHORT $LN10@ApplyWeapo@7

; 1429 : 	{
; 1430 : 		//           .
; 1431 : 		if ( !pWeapon->IsPush() )

  00043	38 9e 65 08 00
	00		 cmp	 BYTE PTR [esi+2149], bl
  00049	75 06		 jne	 SHORT $LN7@ApplyWeapo@7

; 1432 : 		{
; 1433 : 			fPushPower = 0.0f;

  0004b	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 1434 : 			fBlowPower = 0.0f;
; 1435 : 		}
; 1436 : 		else

  0004f	eb 1e		 jmp	 SHORT $LN18@ApplyWeapo@7
$LN7@ApplyWeapo@7:

; 1437 : 		{
; 1438 : 			fPushPower *= pWeapon->GetEnablePushPowerRate();

  00051	f3 0f 10 8e 68
	08 00 00	 movss	 xmm1, DWORD PTR [esi+2152]
  00059	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  0005d	0f 5a c9	 cvtps2pd xmm1, xmm1
  00060	0f 5a d2	 cvtps2pd xmm2, xmm2
  00063	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  00067	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  0006b	f3 0f 11 08	 movss	 DWORD PTR [eax], xmm1
$LN18@ApplyWeapo@7:

; 1439 : 			fBlowPower = 0.0f;

  0006f	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 1440 : 		}
; 1441 : 
; 1442 : 		if ( HasBuff( BT_THUNDER_BIRD_HOLD ) )

  00073	68 b1 00 00 00	 push	 177			; 000000b1H
  00078	8b cf		 mov	 ecx, edi
  0007a	e8 00 00 00 00	 call	 ?HasBuff@ioBaseChar@@QBE_NH@Z ; ioBaseChar::HasBuff
  0007f	84 c0		 test	 al, al
  00081	74 26		 je	 SHORT $LN5@ApplyWeapo@7

; 1443 : 		{
; 1444 : 			//  
; 1445 : 			if ( bTeamAttack )

  00083	38 5d 18	 cmp	 BYTE PTR _bTeamAttack$[ebp], bl
  00086	74 04		 je	 SHORT $LN4@ApplyWeapo@7

; 1446 : 				CheckThunderBirdSpecialBuff( true );

  00088	6a 01		 push	 1

; 1447 : 			else

  0008a	eb 14		 jmp	 SHORT $LN19@ApplyWeapo@7
$LN4@ApplyWeapo@7:

; 1448 : 			{
; 1449 : 				//       
; 1450 : 				ioThunderBirdItem *pThunderBirdItem = ToThunderBirdItem( pAttacker->GetWeapon() );

  0008c	8b 4d 0c	 mov	 ecx, DWORD PTR _pAttacker$[ebp]
  0008f	e8 00 00 00 00	 call	 ?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ ; ioBaseChar::GetWeapon
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 ?ToThunderBirdItem@@YAPAVioThunderBirdItem@@PAVioItem@@@Z ; ToThunderBirdItem
  0009a	59		 pop	 ecx

; 1451 : 				if ( !pThunderBirdItem )

  0009b	85 c0		 test	 eax, eax
  0009d	75 14		 jne	 SHORT $LN10@ApplyWeapo@7

; 1452 : 					CheckThunderBirdSpecialBuff( false );

  0009f	53		 push	 ebx
$LN19@ApplyWeapo@7:
  000a0	8b cf		 mov	 ecx, edi
  000a2	e8 00 00 00 00	 call	 ?CheckThunderBirdSpecialBuff@ioBaseChar@@QAEX_N@Z ; ioBaseChar::CheckThunderBirdSpecialBuff

; 1453 : 			}
; 1454 : 		}
; 1455 : 		else

  000a7	eb 0a		 jmp	 SHORT $LN10@ApplyWeapo@7
$LN5@ApplyWeapo@7:

; 1456 : 			SetState( CS_DELAY );

  000a9	6a 01		 push	 1
  000ab	53		 push	 ebx
  000ac	8b cf		 mov	 ecx, edi
  000ae	e8 00 00 00 00	 call	 ?SetState@ioBaseChar@@QAEXH_N@Z ; ioBaseChar::SetState
$LN10@ApplyWeapo@7:
  000b3	5f		 pop	 edi
  000b4	5e		 pop	 esi
  000b5	5b		 pop	 ebx

; 1457 : 	}
; 1458 : }

  000b6	5d		 pop	 ebp
  000b7	c2 14 00	 ret	 20			; 00000014H
?ApplyWeaponWoundedPushBlowCalcByBuff@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AAM2_N@Z ENDP ; ioBaseChar::ApplyWeaponWoundedPushBlowCalcByBuff
_TEXT	ENDS
PUBLIC	?ApplyWeaponWoundedActionStopDelay@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AAHAA_NAAW4ActionStopType@@_N55M5@Z ; ioBaseChar::ApplyWeaponWoundedActionStopDelay
EXTRN	?SetActionStopDuration@ioWeapon@@QAEXKM@Z:PROC	; ioWeapon::SetActionStopDuration
EXTRN	?CalcActionStopDelay@ioBaseChar@@SAKM_N@Z:PROC	; ioBaseChar::CalcActionStopDelay
EXTRN	?GetActionStopLooseRate@ioBaseChar@@SAM_N@Z:PROC ; ioBaseChar::GetActionStopLooseRate
EXTRN	?SetActionStopDelay@ioBaseChar@@QAEXM_NH@Z:PROC	; ioBaseChar::SetActionStopDelay
EXTRN	?IsEquipWait@ioEquipSlot@@QAE_NXZ:PROC		; ioEquipSlot::IsEquipWait
EXTRN	?m_iProtectShakeCamera@ioBaseCharParent@@2HA:DWORD ; ioBaseCharParent::m_iProtectShakeCamera
EXTRN	?GetShakeCamera@ioWeapon@@QBEHXZ:PROC		; ioWeapon::GetShakeCamera
; Function compile flags: /Ogsp
;	COMDAT ?ApplyWeaponWoundedActionStopDelay@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AAHAA_NAAW4ActionStopType@@_N55M5@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pWeapon$ = 8						; size = 4
_pAttacker$ = 12					; size = 4
_iTargetShackCamera$ = 16				; size = 4
_iShakeCamera$ = 16					; size = 4
_bTargetDie$ = 20					; size = 4
_eActionStype$ = 24					; size = 4
_bProtectShakeCamera$ = 28				; size = 1
_bCharDie$ = 32						; size = 1
_bStructWeapon$ = 36					; size = 1
_fDamage$ = 40						; size = 4
_bApplyPushPower$ = 44					; size = 1
?ApplyWeaponWoundedActionStopDelay@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AAHAA_NAAW4ActionStopType@@_N55M5@Z PROC ; ioBaseChar::ApplyWeaponWoundedActionStopDelay, COMDAT
; _this$ = ecx

; 1739 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1740 : 	if ( !pWeapon || !pAttacker )

  00007	8b 4d 08	 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  0000a	85 c9		 test	 ecx, ecx
  0000c	0f 84 3b 01 00
	00		 je	 $LN16@ApplyWeapo@8
  00012	83 7d 0c 00	 cmp	 DWORD PTR _pAttacker$[ebp], 0
  00016	0f 84 31 01 00
	00		 je	 $LN16@ApplyWeapo@8

; 1741 : 		return;
; 1742 : 
; 1743 : 	iShakeCamera = pWeapon->GetShakeCamera();

  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	e8 00 00 00 00	 call	 ?GetShakeCamera@ioWeapon@@QBEHXZ ; ioWeapon::GetShakeCamera
  00024	8b 5d 10	 mov	 ebx, DWORD PTR _iShakeCamera$[ebp]

; 1744 : 	bTargetDie = false;

  00027	8b 75 14	 mov	 esi, DWORD PTR _bTargetDie$[ebp]

; 1745 : 	eActionStype = AST_NONE;

  0002a	8b 7d 18	 mov	 edi, DWORD PTR _eActionStype$[ebp]
  0002d	89 03		 mov	 DWORD PTR [ebx], eax
  0002f	c6 06 00	 mov	 BYTE PTR [esi], 0
  00032	83 27 00	 and	 DWORD PTR [edi], 0

; 1746 : 
; 1747 : 	int iTargetShackCamera = iShakeCamera;
; 1748 : 	if( bProtectShakeCamera && m_iProtectShakeCamera > 0 )

  00035	80 7d 1c 00	 cmp	 BYTE PTR _bProtectShakeCamera$[ebp], 0
  00039	8b 03		 mov	 eax, DWORD PTR [ebx]
  0003b	89 45 10	 mov	 DWORD PTR _iTargetShackCamera$[ebp], eax
  0003e	74 0c		 je	 SHORT $LN15@ApplyWeapo@8
  00040	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_iProtectShakeCamera@ioBaseCharParent@@2HA ; ioBaseCharParent::m_iProtectShakeCamera
  00045	85 c0		 test	 eax, eax
  00047	7e 03		 jle	 SHORT $LN15@ApplyWeapo@8

; 1749 : 		iTargetShackCamera = m_iProtectShakeCamera;

  00049	89 45 10	 mov	 DWORD PTR _iTargetShackCamera$[ebp], eax
$LN15@ApplyWeapo@8:

; 1750 : 
; 1751 : 	if( bCharDie && m_pEquipSlot && ( !m_pEquipSlot->IsEquipWait() || ToNpcChar( this ) || IsGangsi() ) )

  0004c	80 7d 20 00	 cmp	 BYTE PTR _bCharDie$[ebp], 0
  00050	74 41		 je	 SHORT $LN14@ApplyWeapo@8
  00052	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00055	8b 88 48 03 00
	00		 mov	 ecx, DWORD PTR [eax+840]
  0005b	85 c9		 test	 ecx, ecx
  0005d	74 34		 je	 SHORT $LN14@ApplyWeapo@8
  0005f	e8 00 00 00 00	 call	 ?IsEquipWait@ioEquipSlot@@QAE_NXZ ; ioEquipSlot::IsEquipWait
  00064	84 c0		 test	 al, al
  00066	74 19		 je	 SHORT $LN13@ApplyWeapo@8
  00068	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0006b	e8 00 00 00 00	 call	 ?ToNpcChar@@YAPAVioNpcChar@@PAVioGameEntity@@@Z ; ToNpcChar
  00070	59		 pop	 ecx
  00071	85 c0		 test	 eax, eax
  00073	75 0c		 jne	 SHORT $LN13@ApplyWeapo@8
  00075	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00078	80 b8 f8 23 00
	00 00		 cmp	 BYTE PTR [eax+9208], 0
  0007f	74 12		 je	 SHORT $LN14@ApplyWeapo@8
$LN13@ApplyWeapo@8:

; 1752 : 	{
; 1753 : 		eActionStype = pWeapon->GetDieActionStopType();

  00081	8b 4d 08	 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  00084	8b 01		 mov	 eax, DWORD PTR [ecx]
  00086	ff 90 18 01 00
	00		 call	 DWORD PTR [eax+280]
  0008c	89 07		 mov	 DWORD PTR [edi], eax

; 1754 : 		bTargetDie = true;

  0008e	c6 06 01	 mov	 BYTE PTR [esi], 1

; 1755 : 	}
; 1756 : 	else

  00091	eb 0d		 jmp	 SHORT $LN12@ApplyWeapo@8
$LN14@ApplyWeapo@8:

; 1757 : 		eActionStype = pWeapon->GetActionStopType();

  00093	8b 4d 08	 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  00096	8b 01		 mov	 eax, DWORD PTR [ecx]
  00098	ff 90 14 01 00
	00		 call	 DWORD PTR [eax+276]
  0009e	89 07		 mov	 DWORD PTR [edi], eax
$LN12@ApplyWeapo@8:

; 1758 : 
; 1759 : 	if( bStructWeapon )

  000a0	80 7d 24 00	 cmp	 BYTE PTR _bStructWeapon$[ebp], 0
  000a4	74 0f		 je	 SHORT $LN24@ApplyWeapo@8

; 1760 : 	{
; 1761 : 		if( eActionStype != AST_NONE )

  000a6	83 3f 00	 cmp	 DWORD PTR [edi], 0
  000a9	0f 84 9b 00 00
	00		 je	 $LN25@ApplyWeapo@8

; 1762 : 			eActionStype = AST_TARGET;

  000af	c7 07 03 00 00
	00		 mov	 DWORD PTR [edi], 3
$LN24@ApplyWeapo@8:

; 1763 : 	}
; 1764 : 
; 1765 : 	if( eActionStype != AST_NONE )

  000b5	8b 07		 mov	 eax, DWORD PTR [edi]
  000b7	85 c0		 test	 eax, eax
  000b9	0f 84 8b 00 00
	00		 je	 $LN25@ApplyWeapo@8

; 1766 : 	{
; 1767 : 		//yunga ( bruce lee )
; 1768 : 		if( !pWeapon->GetCalcActionDelayPassType() )

  000bf	8b 7d 08	 mov	 edi, DWORD PTR _pWeapon$[ebp]
  000c2	80 bf 38 08 00
	00 00		 cmp	 BYTE PTR [edi+2104], 0
  000c9	75 7f		 jne	 SHORT $LN25@ApplyWeapo@8

; 1769 : 		{
; 1770 : 			switch( eActionStype )

  000cb	48		 dec	 eax
  000cc	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  000d1	74 19		 je	 SHORT $LN5@ApplyWeapo@8
  000d3	48		 dec	 eax
  000d4	74 0a		 je	 SHORT $LN3@ApplyWeapo@8
  000d6	48		 dec	 eax
  000d7	75 47		 jne	 SHORT $LN4@ApplyWeapo@8

; 1781 : 			case AST_TARGET:
; 1782 : 				if( bApplyPushPower )

  000d9	38 45 2c	 cmp	 BYTE PTR _bApplyPushPower$[ebp], al
  000dc	74 42		 je	 SHORT $LN4@ApplyWeapo@8

; 1783 : 					SetActionStopDelay( fDamage, bTargetDie, iTargetShackCamera );
; 1784 : 				break;

  000de	eb 2b		 jmp	 SHORT $LN28@ApplyWeapo@8
$LN3@ApplyWeapo@8:

; 1777 : 				break;
; 1778 : 			case AST_ATTACKER:
; 1779 : 				pAttacker->SetActionStopDelay( fDamage, bTargetDie, iShakeCamera );

  000e0	ff 33		 push	 DWORD PTR [ebx]
  000e2	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  000e5	50		 push	 eax
  000e6	51		 push	 ecx
  000e7	8b 4d 0c	 mov	 ecx, DWORD PTR _pAttacker$[ebp]

; 1780 : 				break;

  000ea	eb 2a		 jmp	 SHORT $LN29@ApplyWeapo@8
$LN5@ApplyWeapo@8:

; 1771 : 			{
; 1772 : 			case AST_BOTH:
; 1773 : 				pAttacker->SetActionStopDelay( fDamage, bTargetDie, iShakeCamera );

  000ec	ff 33		 push	 DWORD PTR [ebx]
  000ee	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  000f1	50		 push	 eax
  000f2	51		 push	 ecx
  000f3	8b 4d 0c	 mov	 ecx, DWORD PTR _pAttacker$[ebp]
  000f6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000fb	e8 00 00 00 00	 call	 ?SetActionStopDelay@ioBaseChar@@QAEXM_NH@Z ; ioBaseChar::SetActionStopDelay

; 1774 : 
; 1775 : 				if( bApplyPushPower )

  00100	80 7d 2c 00	 cmp	 BYTE PTR _bApplyPushPower$[ebp], 0
  00104	74 1a		 je	 SHORT $LN4@ApplyWeapo@8

; 1776 : 					SetActionStopDelay( fDamage, bTargetDie, iTargetShackCamera );

  00106	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
$LN28@ApplyWeapo@8:
  0010b	ff 75 10	 push	 DWORD PTR _iTargetShackCamera$[ebp]
  0010e	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00111	50		 push	 eax
  00112	51		 push	 ecx
  00113	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN29@ApplyWeapo@8:
  00116	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0011b	e8 00 00 00 00	 call	 ?SetActionStopDelay@ioBaseChar@@QAEXM_NH@Z ; ioBaseChar::SetActionStopDelay
$LN4@ApplyWeapo@8:

; 1785 : 			}
; 1786 : 
; 1787 : 			pWeapon->SetActionStopDuration( CalcActionStopDelay( fDamage, bTargetDie ), GetActionStopLooseRate( bTargetDie ) );

  00120	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 ?GetActionStopLooseRate@ioBaseChar@@SAM_N@Z ; ioBaseChar::GetActionStopLooseRate
  00129	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  0012c	d9 1c 24	 fstp	 DWORD PTR [esp]
  0012f	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  00134	50		 push	 eax
  00135	51		 push	 ecx
  00136	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0013b	e8 00 00 00 00	 call	 ?CalcActionStopDelay@ioBaseChar@@SAKM_N@Z ; ioBaseChar::CalcActionStopDelay
  00140	59		 pop	 ecx
  00141	59		 pop	 ecx
  00142	50		 push	 eax
  00143	8b cf		 mov	 ecx, edi
  00145	e8 00 00 00 00	 call	 ?SetActionStopDuration@ioWeapon@@QAEXKM@Z ; ioWeapon::SetActionStopDuration
$LN25@ApplyWeapo@8:
  0014a	5f		 pop	 edi
  0014b	5e		 pop	 esi
  0014c	5b		 pop	 ebx
$LN16@ApplyWeapo@8:

; 1788 : 		}
; 1789 : 	}
; 1790 : }

  0014d	c9		 leave
  0014e	c2 28 00	 ret	 40			; 00000028H
?ApplyWeaponWoundedActionStopDelay@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AAHAA_NAAW4ActionStopType@@_N55M5@Z ENDP ; ioBaseChar::ApplyWeaponWoundedActionStopDelay
_TEXT	ENDS
PUBLIC	?ApplyWeaponWoundedBuffFunc@ioBaseChar@@IAEXPAV1@@Z ; ioBaseChar::ApplyWeaponWoundedBuffFunc
EXTRN	?CheckHitCount@ioCountGatherAttackBuff@@QAEXPAVioBaseChar@@0@Z:PROC ; ioCountGatherAttackBuff::CheckHitCount
EXTRN	?SetAddBuff@ioWoundedAddBuff@@QAEXPAVioBaseChar@@@Z:PROC ; ioWoundedAddBuff::SetAddBuff
EXTRN	?OwnerCharApplyWeapon@ioCreateDummyByAttackedBuff2@@QAEXXZ:PROC ; ioCreateDummyByAttackedBuff2::OwnerCharApplyWeapon
EXTRN	?OwnerCharApplyWeapon@ioCreateDummyByAttackedBuff@@QAEXXZ:PROC ; ioCreateDummyByAttackedBuff::OwnerCharApplyWeapon
; Function compile flags: /Ogsp
;	COMDAT ?ApplyWeaponWoundedBuffFunc@ioBaseChar@@IAEXPAV1@@Z
_TEXT	SEGMENT
_pAttacker$ = 8						; size = 4
?ApplyWeaponWoundedBuffFunc@ioBaseChar@@IAEXPAV1@@Z PROC ; ioBaseChar::ApplyWeaponWoundedBuffFunc, COMDAT
; _this$ = ecx

; 2066 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 2067 : 	if ( !pAttacker )

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _pAttacker$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	85 db		 test	 ebx, ebx
  0000c	0f 84 af 00 00
	00		 je	 $LN1@ApplyWeapo@9

; 2068 : 		return;
; 2069 : 
; 2070 : 	if( HasBuff( BT_CREATE_DUMMY_BY_ATTACKED_BUFF ) )

  00012	56		 push	 esi
  00013	be b5 00 00 00	 mov	 esi, 181		; 000000b5H
  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 ?HasBuff@ioBaseChar@@QBE_NH@Z ; ioBaseChar::HasBuff
  0001e	84 c0		 test	 al, al
  00020	74 1a		 je	 SHORT $LN7@ApplyWeapo@9

; 2071 : 	{
; 2072 : 		ioBuff* pBuff = GetBuff( BT_CREATE_DUMMY_BY_ATTACKED_BUFF );

  00022	56		 push	 esi
  00023	8b cf		 mov	 ecx, edi
  00025	e8 00 00 00 00	 call	 ?GetBuff@ioBaseChar@@QAEPAVioBuff@@H@Z ; ioBaseChar::GetBuff

; 2073 : 		ioCreateDummyByAttackedBuff* pCreateDummyByAttacedBuff = ToCreateDummyByAttackedBuff( pBuff );

  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?ToCreateDummyByAttackedBuff@@YAPAVioCreateDummyByAttackedBuff@@PAVioBuff@@@Z ; ToCreateDummyByAttackedBuff
  00030	59		 pop	 ecx

; 2074 : 		if ( pCreateDummyByAttacedBuff )

  00031	85 c0		 test	 eax, eax
  00033	74 07		 je	 SHORT $LN7@ApplyWeapo@9

; 2075 : 			pCreateDummyByAttacedBuff->OwnerCharApplyWeapon();

  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 ?OwnerCharApplyWeapon@ioCreateDummyByAttackedBuff@@QAEXXZ ; ioCreateDummyByAttackedBuff::OwnerCharApplyWeapon
$LN7@ApplyWeapo@9:

; 2076 : 	}
; 2077 : 
; 2078 : 	if( HasBuff( BT_CREATE_DUMMY_BY_ATTACKED_BUFF2 ) )

  0003c	be e7 00 00 00	 mov	 esi, 231		; 000000e7H
  00041	56		 push	 esi
  00042	8b cf		 mov	 ecx, edi
  00044	e8 00 00 00 00	 call	 ?HasBuff@ioBaseChar@@QBE_NH@Z ; ioBaseChar::HasBuff
  00049	84 c0		 test	 al, al
  0004b	74 1a		 je	 SHORT $LN5@ApplyWeapo@9

; 2079 : 	{
; 2080 : 		ioBuff* pBuff = GetBuff( BT_CREATE_DUMMY_BY_ATTACKED_BUFF2 );

  0004d	56		 push	 esi
  0004e	8b cf		 mov	 ecx, edi
  00050	e8 00 00 00 00	 call	 ?GetBuff@ioBaseChar@@QAEPAVioBuff@@H@Z ; ioBaseChar::GetBuff

; 2081 : 		ioCreateDummyByAttackedBuff2* pCreateDummyByAttacedBuff2 = ToCreateDummyByAttackedBuff2( pBuff );

  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ?ToCreateDummyByAttackedBuff2@@YAPAVioCreateDummyByAttackedBuff2@@PAVioBuff@@@Z ; ToCreateDummyByAttackedBuff2
  0005b	59		 pop	 ecx

; 2082 : 		if ( pCreateDummyByAttacedBuff2 )

  0005c	85 c0		 test	 eax, eax
  0005e	74 07		 je	 SHORT $LN5@ApplyWeapo@9

; 2083 : 			pCreateDummyByAttacedBuff2->OwnerCharApplyWeapon();

  00060	8b c8		 mov	 ecx, eax
  00062	e8 00 00 00 00	 call	 ?OwnerCharApplyWeapon@ioCreateDummyByAttackedBuff2@@QAEXXZ ; ioCreateDummyByAttackedBuff2::OwnerCharApplyWeapon
$LN5@ApplyWeapo@9:

; 2084 : 	}
; 2085 : 
; 2086 : 	if ( HasBuff( BT_WOUNDED_ADD_BUFF ) )

  00067	be c0 00 00 00	 mov	 esi, 192		; 000000c0H
  0006c	56		 push	 esi
  0006d	8b cf		 mov	 ecx, edi
  0006f	e8 00 00 00 00	 call	 ?HasBuff@ioBaseChar@@QBE_NH@Z ; ioBaseChar::HasBuff
  00074	84 c0		 test	 al, al
  00076	74 1b		 je	 SHORT $LN3@ApplyWeapo@9

; 2087 : 	{
; 2088 : 		ioWoundedAddBuff* pWoundedAddBuff = ToWoundedAddBuff( GetBuff( BT_WOUNDED_ADD_BUFF ) );

  00078	56		 push	 esi
  00079	8b cf		 mov	 ecx, edi
  0007b	e8 00 00 00 00	 call	 ?GetBuff@ioBaseChar@@QAEPAVioBuff@@H@Z ; ioBaseChar::GetBuff
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 ?ToWoundedAddBuff@@YAPAVioWoundedAddBuff@@PAVioBuff@@@Z ; ToWoundedAddBuff
  00086	59		 pop	 ecx

; 2089 : 		if ( pWoundedAddBuff )

  00087	85 c0		 test	 eax, eax
  00089	74 08		 je	 SHORT $LN3@ApplyWeapo@9

; 2090 : 			pWoundedAddBuff->SetAddBuff( pAttacker );

  0008b	53		 push	 ebx
  0008c	8b c8		 mov	 ecx, eax
  0008e	e8 00 00 00 00	 call	 ?SetAddBuff@ioWoundedAddBuff@@QAEXPAVioBaseChar@@@Z ; ioWoundedAddBuff::SetAddBuff
$LN3@ApplyWeapo@9:

; 2091 : 	}
; 2092 : 
; 2093 : 	if ( pAttacker->HasBuff( BT_COUNT_GATHER_ATTACK ) )

  00093	be cb 00 00 00	 mov	 esi, 203		; 000000cbH
  00098	56		 push	 esi
  00099	8b cb		 mov	 ecx, ebx
  0009b	e8 00 00 00 00	 call	 ?HasBuff@ioBaseChar@@QBE_NH@Z ; ioBaseChar::HasBuff
  000a0	84 c0		 test	 al, al
  000a2	74 1c		 je	 SHORT $LN12@ApplyWeapo@9

; 2094 : 	{
; 2095 : 		ioCountGatherAttackBuff* pCountGatherAttackBuff = ToCountGatherAttackBuff( pAttacker->GetBuff( BT_COUNT_GATHER_ATTACK ) );

  000a4	56		 push	 esi
  000a5	8b cb		 mov	 ecx, ebx
  000a7	e8 00 00 00 00	 call	 ?GetBuff@ioBaseChar@@QAEPAVioBuff@@H@Z ; ioBaseChar::GetBuff
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 ?ToCountGatherAttackBuff@@YAPAVioCountGatherAttackBuff@@PAVioBuff@@@Z ; ToCountGatherAttackBuff
  000b2	59		 pop	 ecx

; 2096 : 		if ( pCountGatherAttackBuff )

  000b3	85 c0		 test	 eax, eax
  000b5	74 09		 je	 SHORT $LN12@ApplyWeapo@9

; 2097 : 			pCountGatherAttackBuff->CheckHitCount( pAttacker, this );

  000b7	57		 push	 edi
  000b8	53		 push	 ebx
  000b9	8b c8		 mov	 ecx, eax
  000bb	e8 00 00 00 00	 call	 ?CheckHitCount@ioCountGatherAttackBuff@@QAEXPAVioBaseChar@@0@Z ; ioCountGatherAttackBuff::CheckHitCount
$LN12@ApplyWeapo@9:
  000c0	5e		 pop	 esi
$LN1@ApplyWeapo@9:
  000c1	5f		 pop	 edi
  000c2	5b		 pop	 ebx

; 2098 : 	}
; 2099 : }

  000c3	5d		 pop	 ebp
  000c4	c2 04 00	 ret	 4
?ApplyWeaponWoundedBuffFunc@ioBaseChar@@IAEXPAV1@@Z ENDP ; ioBaseChar::ApplyWeaponWoundedBuffFunc
_TEXT	ENDS
PUBLIC	??G?$CEncrypt@M@@QAEMABM@Z			; CEncrypt<float>::operator-
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
;	COMDAT ??G?$CEncrypt@M@@QAEMABM@Z
_TEXT	SEGMENT
_value$ = -4						; size = 4
tv130 = 8						; size = 4
_inValue$ = 8						; size = 4
??G?$CEncrypt@M@@QAEMABM@Z PROC				; CEncrypt<float>::operator-, COMDAT
; _this$ = ecx

; 1665 : 	{	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1666 : 		type value;
; 1667 : 		DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool

; 1668 : #ifdef _NOTUSE
; 1669 : 		Debug();
; 1670 : #endif
; 1671 : 		return value - inValue;

  0000d	d9 45 fc	 fld	 DWORD PTR _value$[ebp]
  00010	8b 45 08	 mov	 eax, DWORD PTR _inValue$[ebp]
  00013	d8 20		 fsub	 DWORD PTR [eax]
  00015	d9 5d 08	 fstp	 DWORD PTR tv130[ebp]
  00018	d9 45 08	 fld	 DWORD PTR tv130[ebp]

; 1672 : 	}

  0001b	c9		 leave
  0001c	c2 04 00	 ret	 4
??G?$CEncrypt@M@@QAEMABM@Z ENDP				; CEncrypt<float>::operator-
_TEXT	ENDS
PUBLIC	??N?$CEncrypt@M@@QAE_NABM@Z			; CEncrypt<float>::operator<=
; Function compile flags: /Ogsp
;	COMDAT ??N?$CEncrypt@M@@QAE_NABM@Z
_TEXT	SEGMENT
_value$ = -4						; size = 4
_inValue$ = 8						; size = 4
??N?$CEncrypt@M@@QAE_NABM@Z PROC			; CEncrypt<float>::operator<=, COMDAT
; _this$ = ecx

; 1821 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1822 : 		type value;
; 1823 : 		DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool

; 1824 : #ifdef _NOTUSE
; 1825 : 		Debug();
; 1826 : #endif
; 1827 : 		return (value <= inValue);

  0000d	8b 45 08	 mov	 eax, DWORD PTR _inValue$[ebp]
  00010	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  00014	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _value$[ebp]
  00019	0f 5a c0	 cvtps2pd xmm0, xmm0
  0001c	0f 5a c9	 cvtps2pd xmm1, xmm1
  0001f	33 c0		 xor	 eax, eax
  00021	66 0f 2f c8	 comisd	 xmm1, xmm0
  00025	72 01		 jb	 SHORT $LN4@operator@3
  00027	40		 inc	 eax
$LN4@operator@3:

; 1828 : 	}

  00028	c9		 leave
  00029	c2 04 00	 ret	 4
??N?$CEncrypt@M@@QAE_NABM@Z ENDP			; CEncrypt<float>::operator<=
_TEXT	ENDS
PUBLIC	??8?$CEncrypt@H@@QAE_NABH@Z			; CEncrypt<int>::operator==
; Function compile flags: /Ogsp
;	COMDAT ??8?$CEncrypt@H@@QAE_NABH@Z
_TEXT	SEGMENT
_value$ = -4						; size = 4
_inValue$ = 8						; size = 4
??8?$CEncrypt@H@@QAE_NABH@Z PROC			; CEncrypt<int>::operator==, COMDAT
; _this$ = ecx

; 976  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 977  : 		
; 978  : 		type value;
; 979  : 		DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ; CEncrypt<int>::DecryptValueToPool

; 980  : #ifdef _NOTUSE
; 981  : 		Debug();
; 982  : #endif
; 983  : 		return (value == inValue);

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _inValue$[ebp]
  00010	8b 55 fc	 mov	 edx, DWORD PTR _value$[ebp]
  00013	33 c0		 xor	 eax, eax
  00015	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00017	0f 94 c0	 sete	 al

; 984  : 	} 

  0001a	c9		 leave
  0001b	c2 04 00	 ret	 4
??8?$CEncrypt@H@@QAE_NABH@Z ENDP			; CEncrypt<int>::operator==
_TEXT	ENDS
PUBLIC	??B?$CEncrypt@W4TeamType@@@@QAE?AW4TeamType@@XZ	; CEncrypt<enum TeamType>::operator enum TeamType
; Function compile flags: /Ogsp
;	COMDAT ??B?$CEncrypt@W4TeamType@@@@QAE?AW4TeamType@@XZ
_TEXT	SEGMENT
_value$ = -4						; size = 4
??B?$CEncrypt@W4TeamType@@@@QAE?AW4TeamType@@XZ PROC	; CEncrypt<enum TeamType>::operator enum TeamType, COMDAT
; _this$ = ecx

; 134  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 135  : 		type value;
; 136  : 		DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool

; 137  : 
; 138  : #ifdef _NOTUSE
; 139  : 		Debug();
; 140  : #endif
; 141  : 		return value;

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _value$[ebp]

; 142  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@W4TeamType@@@@QAE?AW4TeamType@@XZ ENDP	; CEncrypt<enum TeamType>::operator enum TeamType
_TEXT	ENDS
PUBLIC	??8?$CEncrypt@W4BlowWoundedState@@@@QAE_NABW4BlowWoundedState@@@Z ; CEncrypt<enum BlowWoundedState>::operator==
; Function compile flags: /Ogsp
;	COMDAT ??8?$CEncrypt@W4BlowWoundedState@@@@QAE_NABW4BlowWoundedState@@@Z
_TEXT	SEGMENT
_value$ = -4						; size = 4
_inValue$ = 8						; size = 4
??8?$CEncrypt@W4BlowWoundedState@@@@QAE_NABW4BlowWoundedState@@@Z PROC ; CEncrypt<enum BlowWoundedState>::operator==, COMDAT
; _this$ = ecx

; 2414 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2415 : 		type value;
; 2416 : 		DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4BlowWoundedState@@@@QAEXPAW4BlowWoundedState@@@Z ; CEncrypt<enum BlowWoundedState>::DecryptValueToPool

; 2417 : #ifdef _NOTUSE
; 2418 : 		Debug();
; 2419 : #endif
; 2420 : 		return (value == inValue);

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _inValue$[ebp]
  00010	8b 55 fc	 mov	 edx, DWORD PTR _value$[ebp]
  00013	33 c0		 xor	 eax, eax
  00015	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00017	0f 94 c0	 sete	 al

; 2421 : 	} 

  0001a	c9		 leave
  0001b	c2 04 00	 ret	 4
??8?$CEncrypt@W4BlowWoundedState@@@@QAE_NABW4BlowWoundedState@@@Z ENDP ; CEncrypt<enum BlowWoundedState>::operator==
_TEXT	ENDS
PUBLIC	??B?$CEncrypt@W4ProtectionMode@@@@QAE?AW4ProtectionMode@@XZ ; CEncrypt<enum ProtectionMode>::operator enum ProtectionMode
; Function compile flags: /Ogsp
;	COMDAT ??B?$CEncrypt@W4ProtectionMode@@@@QAE?AW4ProtectionMode@@XZ
_TEXT	SEGMENT
_value$ = -4						; size = 4
??B?$CEncrypt@W4ProtectionMode@@@@QAE?AW4ProtectionMode@@XZ PROC ; CEncrypt<enum ProtectionMode>::operator enum ProtectionMode, COMDAT
; _this$ = ecx

; 134  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 135  : 		type value;
; 136  : 		DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4ProtectionMode@@@@QAEXPAW4ProtectionMode@@@Z ; CEncrypt<enum ProtectionMode>::DecryptValueToPool

; 137  : 
; 138  : #ifdef _NOTUSE
; 139  : 		Debug();
; 140  : #endif
; 141  : 		return value;

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _value$[ebp]

; 142  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@W4ProtectionMode@@@@QAE?AW4ProtectionMode@@XZ ENDP ; CEncrypt<enum ProtectionMode>::operator enum ProtectionMode
_TEXT	ENDS
PUBLIC	??9?$CEncrypt@W4ProtectionMode@@@@QAE_NABW4ProtectionMode@@@Z ; CEncrypt<enum ProtectionMode>::operator!=
; Function compile flags: /Ogsp
;	COMDAT ??9?$CEncrypt@W4ProtectionMode@@@@QAE_NABW4ProtectionMode@@@Z
_TEXT	SEGMENT
_value$ = -4						; size = 4
_inValue$ = 8						; size = 4
??9?$CEncrypt@W4ProtectionMode@@@@QAE_NABW4ProtectionMode@@@Z PROC ; CEncrypt<enum ProtectionMode>::operator!=, COMDAT
; _this$ = ecx

; 2906 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2907 : 		type value;
; 2908 : 		DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4ProtectionMode@@@@QAEXPAW4ProtectionMode@@@Z ; CEncrypt<enum ProtectionMode>::DecryptValueToPool

; 2909 : #ifdef _NOTUSE
; 2910 : 		Debug();
; 2911 : #endif
; 2912 : 		return (value != inValue);

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _inValue$[ebp]
  00010	8b 55 fc	 mov	 edx, DWORD PTR _value$[ebp]
  00013	33 c0		 xor	 eax, eax
  00015	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00017	0f 95 c0	 setne	 al

; 2913 : 	} 

  0001a	c9		 leave
  0001b	c2 04 00	 ret	 4
??9?$CEncrypt@W4ProtectionMode@@@@QAE_NABW4ProtectionMode@@@Z ENDP ; CEncrypt<enum ProtectionMode>::operator!=
_TEXT	ENDS
PUBLIC	??$_Construct@UBuffInfoStruct@@ABU1@@std@@YAXPAUBuffInfoStruct@@ABU1@@Z ; std::_Construct<BuffInfoStruct,BuffInfoStruct const &>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??$_Construct@UBuffInfoStruct@@ABU1@@std@@YAXPAUBuffInfoStruct@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@UBuffInfoStruct@@ABU1@@std@@YAXPAUBuffInfoStruct@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@UBuffInfoStruct@@ABU1@@std@@YAXPAUBuffInfoStruct@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@UBuffInfoStruct@@ABU1@@std@@YAXPAUBuffInfoStruct@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@UBuffInfoStruct@@ABU1@@std@@YAXPAUBuffInfoStruct@@ABU1@@Z
_TEXT	SEGMENT
$T699663 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$ = 8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UBuffInfoStruct@@ABU1@@std@@YAXPAUBuffInfoStruct@@ABU1@@Z PROC ; std::_Construct<BuffInfoStruct,BuffInfoStruct const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??$_Construct@UBuffInfoStruct@@ABU1@@std@@YAXPAUBuffInfoStruct@@ABU1@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3

; 47   : 	void _FARQ *_Vptr = _Ptr;

  0000c	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  0000f	89 75 08	 mov	 DWORD PTR __Vptr$[ebp], esi

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00012	89 75 f0	 mov	 DWORD PTR $T699663[ebp], esi
  00015	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00019	85 f6		 test	 esi, esi
  0001b	74 12		 je	 SHORT $LN3@Construct
  0001d	8b 7d 0c	 mov	 edi, DWORD PTR __Val$[ebp]
  00020	57		 push	 edi
  00021	8b ce		 mov	 ecx, esi
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  00029	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0002c	89 46 10	 mov	 DWORD PTR [esi+16], eax
$LN3@Construct:

; 49   : 	}

  0002f	e8 00 00 00 00	 call	 __EH_epilog3
  00034	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@UBuffInfoStruct@@ABU1@@std@@YAXPAUBuffInfoStruct@@ABU1@@Z$0:
  00000	ff 75 08	 push	 DWORD PTR __Vptr$[ebp]
  00003	ff 75 f0	 push	 DWORD PTR $T699663[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000b	59		 pop	 ecx
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
__ehhandler$??$_Construct@UBuffInfoStruct@@ABU1@@std@@YAXPAUBuffInfoStruct@@ABU1@@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@UBuffInfoStruct@@ABU1@@std@@YAXPAUBuffInfoStruct@@ABU1@@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@UBuffInfoStruct@@ABU1@@std@@YAXPAUBuffInfoStruct@@ABU1@@Z ENDP ; std::_Construct<BuffInfoStruct,BuffInfoStruct const &>
PUBLIC	?construct@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@$$QAU3@@Z ; std::allocator<BuffInfoStruct>::construct
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@$$QAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@$$QAU3@@Z$0
__ehfuncinfo$?construct@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@$$QAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@$$QAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@$$QAU3@@Z
_TEXT	SEGMENT
$T699686 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@$$QAU3@@Z PROC ; std::allocator<BuffInfoStruct>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?construct@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@$$QAU3@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0000c	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  0000f	89 75 f0	 mov	 DWORD PTR $T699686[ebp], esi
  00012	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00016	85 f6		 test	 esi, esi
  00018	74 12		 je	 SHORT $LN3@construct
  0001a	8b 7d 0c	 mov	 edi, DWORD PTR __Val$[ebp]
  0001d	57		 push	 edi
  0001e	8b ce		 mov	 ecx, esi
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  00026	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00029	89 46 10	 mov	 DWORD PTR [esi+16], eax
$LN3@construct:

; 203  : 		}

  0002c	e8 00 00 00 00	 call	 __EH_epilog3
  00031	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@$$QAU3@@Z$0:
  00000	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00003	ff 75 f0	 push	 DWORD PTR $T699686[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000b	59		 pop	 ecx
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
__ehhandler$?construct@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@$$QAU3@@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@$$QAU3@@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@$$QAU3@@Z ENDP ; std::allocator<BuffInfoStruct>::construct
PUBLIC	??B?$CEncrypt@M@@QAEMXZ				; CEncrypt<float>::operator float
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
;	COMDAT ??B?$CEncrypt@M@@QAEMXZ
_TEXT	SEGMENT
_value$ = -4						; size = 4
??B?$CEncrypt@M@@QAEMXZ PROC				; CEncrypt<float>::operator float, COMDAT
; _this$ = ecx

; 134  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 135  : 		type value;
; 136  : 		DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool

; 137  : 
; 138  : #ifdef _NOTUSE
; 139  : 		Debug();
; 140  : #endif
; 141  : 		return value;

  0000d	d9 45 fc	 fld	 DWORD PTR _value$[ebp]

; 142  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@M@@QAEMXZ ENDP				; CEncrypt<float>::operator float
_TEXT	ENDS
PUBLIC	??B?$CEncrypt@M@@QBEMXZ				; CEncrypt<float>::operator float
; Function compile flags: /Ogsp
;	COMDAT ??B?$CEncrypt@M@@QBEMXZ
_TEXT	SEGMENT
_value$ = -4						; size = 4
??B?$CEncrypt@M@@QBEMXZ PROC				; CEncrypt<float>::operator float, COMDAT
; _this$ = ecx

; 145  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 146  : 		//UJ 130829, const    --start
; 147  : 		type value;
; 148  : 		CEncrypt<type>* pThis = const_cast<CEncrypt<type>*>(this);
; 149  : 		pThis->DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool

; 150  : 		//// const DecryptValueToPool     .
; 151  :  		//type value;
; 152  : 		//char szTempMem[MAX_ENCRYPT];
; 153  : 		//m_RC5.DecryptByte( m_MemPool, szTempMem, max(m_ValueSize, DEFAULT_ENCRYPT) );
; 154  : 		//memcpy( &value, szTempMem, m_ValueSize );
; 155  : 		//UJ --end
; 156  : 
; 157  : #ifdef _NOTUSE
; 158  : 		Debug();
; 159  : #endif
; 160  : 		return value;

  0000d	d9 45 fc	 fld	 DWORD PTR _value$[ebp]

; 161  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@M@@QBEMXZ ENDP				; CEncrypt<float>::operator float
_TEXT	ENDS
PUBLIC	??4?$CEncrypt@M@@QAEMM@Z			; CEncrypt<float>::operator=
; Function compile flags: /Ogsp
;	COMDAT ??4?$CEncrypt@M@@QAEMM@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
_inValue$ = 8						; size = 4
??4?$CEncrypt@M@@QAEMM@Z PROC				; CEncrypt<float>::operator=, COMDAT
; _this$ = ecx

; 1654 : 	{	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1655 : 		type value = inValue;

  00003	d9 45 08	 fld	 DWORD PTR _inValue$[ebp]

; 1656 : 		EncryptValueToPool((char*)&value);

  00006	8d 45 08	 lea	 eax, DWORD PTR _value$[ebp]
  00009	50		 push	 eax
  0000a	d9 5d 08	 fstp	 DWORD PTR _value$[ebp]
  0000d	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 1657 : #ifdef _NOTUSE
; 1658 : 		m_value = inValue;
; 1659 : 		Debug();
; 1660 : #endif
; 1661 : 		return value;

  00012	d9 45 08	 fld	 DWORD PTR _value$[ebp]

; 1662 : 	}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??4?$CEncrypt@M@@QAEMM@Z ENDP				; CEncrypt<float>::operator=
_TEXT	ENDS
PUBLIC	??B?$CEncrypt@_N@@QAE_NXZ			; CEncrypt<bool>::operator bool
; Function compile flags: /Ogsp
;	COMDAT ??B?$CEncrypt@_N@@QAE_NXZ
_TEXT	SEGMENT
_value$ = -1						; size = 1
??B?$CEncrypt@_N@@QAE_NXZ PROC				; CEncrypt<bool>::operator bool, COMDAT
; _this$ = ecx

; 134  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 135  : 		type value;
; 136  : 		DecryptValueToPool(&value);

  00004	8d 45 ff	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool

; 137  : 
; 138  : #ifdef _NOTUSE
; 139  : 		Debug();
; 140  : #endif
; 141  : 		return value;

  0000d	8a 45 ff	 mov	 al, BYTE PTR _value$[ebp]

; 142  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@_N@@QAE_NXZ ENDP				; CEncrypt<bool>::operator bool
_TEXT	ENDS
PUBLIC	??B?$CEncrypt@_N@@QBE_NXZ			; CEncrypt<bool>::operator bool
; Function compile flags: /Ogsp
;	COMDAT ??B?$CEncrypt@_N@@QBE_NXZ
_TEXT	SEGMENT
_value$ = -1						; size = 1
??B?$CEncrypt@_N@@QBE_NXZ PROC				; CEncrypt<bool>::operator bool, COMDAT
; _this$ = ecx

; 145  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 146  : 		//UJ 130829, const    --start
; 147  : 		type value;
; 148  : 		CEncrypt<type>* pThis = const_cast<CEncrypt<type>*>(this);
; 149  : 		pThis->DecryptValueToPool(&value);

  00004	8d 45 ff	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool

; 150  : 		//// const DecryptValueToPool     .
; 151  :  		//type value;
; 152  : 		//char szTempMem[MAX_ENCRYPT];
; 153  : 		//m_RC5.DecryptByte( m_MemPool, szTempMem, max(m_ValueSize, DEFAULT_ENCRYPT) );
; 154  : 		//memcpy( &value, szTempMem, m_ValueSize );
; 155  : 		//UJ --end
; 156  : 
; 157  : #ifdef _NOTUSE
; 158  : 		Debug();
; 159  : #endif
; 160  : 		return value;

  0000d	8a 45 ff	 mov	 al, BYTE PTR _value$[ebp]

; 161  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@_N@@QBE_NXZ ENDP				; CEncrypt<bool>::operator bool
_TEXT	ENDS
PUBLIC	??B?$CEncrypt@H@@QBEHXZ				; CEncrypt<int>::operator int
; Function compile flags: /Ogsp
;	COMDAT ??B?$CEncrypt@H@@QBEHXZ
_TEXT	SEGMENT
_value$ = -4						; size = 4
??B?$CEncrypt@H@@QBEHXZ PROC				; CEncrypt<int>::operator int, COMDAT
; _this$ = ecx

; 145  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 146  : 		//UJ 130829, const    --start
; 147  : 		type value;
; 148  : 		CEncrypt<type>* pThis = const_cast<CEncrypt<type>*>(this);
; 149  : 		pThis->DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ; CEncrypt<int>::DecryptValueToPool

; 150  : 		//// const DecryptValueToPool     .
; 151  :  		//type value;
; 152  : 		//char szTempMem[MAX_ENCRYPT];
; 153  : 		//m_RC5.DecryptByte( m_MemPool, szTempMem, max(m_ValueSize, DEFAULT_ENCRYPT) );
; 154  : 		//memcpy( &value, szTempMem, m_ValueSize );
; 155  : 		//UJ --end
; 156  : 
; 157  : #ifdef _NOTUSE
; 158  : 		Debug();
; 159  : #endif
; 160  : 		return value;

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _value$[ebp]

; 161  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@H@@QBEHXZ ENDP				; CEncrypt<int>::operator int
_TEXT	ENDS
PUBLIC	??4?$CEncrypt@H@@QAEHH@Z			; CEncrypt<int>::operator=
; Function compile flags: /Ogsp
;	COMDAT ??4?$CEncrypt@H@@QAEHH@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
_inValue$ = 8						; size = 4
??4?$CEncrypt@H@@QAEHH@Z PROC				; CEncrypt<int>::operator=, COMDAT
; _this$ = ecx

; 843  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 844  : 		type value = inValue;

  00003	8b 45 08	 mov	 eax, DWORD PTR _inValue$[ebp]
  00006	89 45 08	 mov	 DWORD PTR _value$[ebp], eax

; 845  : 		EncryptValueToPool((char*)&value);

  00009	8d 45 08	 lea	 eax, DWORD PTR _value$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@H@@AAEXPBD@Z ; CEncrypt<int>::EncryptValueToPool

; 846  : #ifdef _NOTUSE
; 847  : 		m_value = inValue;
; 848  : 		Debug();
; 849  : #endif
; 850  : 		return value;

  00012	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]

; 851  : 	}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??4?$CEncrypt@H@@QAEHH@Z ENDP				; CEncrypt<int>::operator=
_TEXT	ENDS
PUBLIC	??B?$CEncrypt@W4TeamType@@@@QBE?AW4TeamType@@XZ	; CEncrypt<enum TeamType>::operator enum TeamType
; Function compile flags: /Ogsp
;	COMDAT ??B?$CEncrypt@W4TeamType@@@@QBE?AW4TeamType@@XZ
_TEXT	SEGMENT
_value$ = -4						; size = 4
??B?$CEncrypt@W4TeamType@@@@QBE?AW4TeamType@@XZ PROC	; CEncrypt<enum TeamType>::operator enum TeamType, COMDAT
; _this$ = ecx

; 145  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 146  : 		//UJ 130829, const    --start
; 147  : 		type value;
; 148  : 		CEncrypt<type>* pThis = const_cast<CEncrypt<type>*>(this);
; 149  : 		pThis->DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool

; 150  : 		//// const DecryptValueToPool     .
; 151  :  		//type value;
; 152  : 		//char szTempMem[MAX_ENCRYPT];
; 153  : 		//m_RC5.DecryptByte( m_MemPool, szTempMem, max(m_ValueSize, DEFAULT_ENCRYPT) );
; 154  : 		//memcpy( &value, szTempMem, m_ValueSize );
; 155  : 		//UJ --end
; 156  : 
; 157  : #ifdef _NOTUSE
; 158  : 		Debug();
; 159  : #endif
; 160  : 		return value;

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _value$[ebp]

; 161  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@W4TeamType@@@@QBE?AW4TeamType@@XZ ENDP	; CEncrypt<enum TeamType>::operator enum TeamType
_TEXT	ENDS
PUBLIC	??B?$CEncrypt@W4ModeType@@@@QAE?AW4ModeType@@XZ	; CEncrypt<enum ModeType>::operator enum ModeType
; Function compile flags: /Ogsp
;	COMDAT ??B?$CEncrypt@W4ModeType@@@@QAE?AW4ModeType@@XZ
_TEXT	SEGMENT
_value$ = -4						; size = 4
??B?$CEncrypt@W4ModeType@@@@QAE?AW4ModeType@@XZ PROC	; CEncrypt<enum ModeType>::operator enum ModeType, COMDAT
; _this$ = ecx

; 134  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 135  : 		type value;
; 136  : 		DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4ModeType@@@@QAEXPAW4ModeType@@@Z ; CEncrypt<enum ModeType>::DecryptValueToPool

; 137  : 
; 138  : #ifdef _NOTUSE
; 139  : 		Debug();
; 140  : #endif
; 141  : 		return value;

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _value$[ebp]

; 142  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@W4ModeType@@@@QAE?AW4ModeType@@XZ ENDP	; CEncrypt<enum ModeType>::operator enum ModeType
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAE@V?$allocator@UBuffInfoStruct@@@1@@Z ; std::_Vector_val<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Vector_val<BuffInfoStruct,std::allocator<BuffInfoStruct> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAE@V?$allocator@UBuffInfoStruct@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAE@V?$allocator@UBuffInfoStruct@@@1@@Z PROC ; std::_Vector_val<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Vector_val<BuffInfoStruct,std::allocator<BuffInfoStruct> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAE@V?$allocator@UBuffInfoStruct@@@1@@Z ENDP ; std::_Vector_val<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Vector_val<BuffInfoStruct,std::allocator<BuffInfoStruct> >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QBEIXZ ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::max_size
; Function compile flags: /Ogsp
;	COMDAT ?max_size@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QBEIXZ PROC ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (this->_Alval.max_size());

  00000	b8 cc cc cc 0c	 mov	 eax, 214748364		; 0cccccccH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QBEIXZ ENDP ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UBuffInfoStruct@@@std@@QAEPAUBuffInfoStruct@@I@Z ; std::allocator<BuffInfoStruct>::allocate
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UBuffInfoStruct@@@std@@QAEPAUBuffInfoStruct@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UBuffInfoStruct@@@std@@QAEPAUBuffInfoStruct@@I@Z PROC ; std::allocator<BuffInfoStruct>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	6a 00		 push	 0
  00005	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Allocate@UBuffInfoStruct@@@std@@YAPAUBuffInfoStruct@@IPAU1@@Z ; std::_Allocate<BuffInfoStruct>
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx

; 188  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?allocate@?$allocator@UBuffInfoStruct@@@std@@QAEPAUBuffInfoStruct@@I@Z ENDP ; std::allocator<BuffInfoStruct>::allocate
_TEXT	ENDS
PUBLIC	??$_Destroy@VioHashString@@@std@@YAXPAVioHashString@@@Z ; std::_Destroy<ioHashString>
; Function compile flags: /Ogsp
;	COMDAT ??$_Destroy@VioHashString@@@std@@YAXPAVioHashString@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VioHashString@@@std@@YAXPAVioHashString@@@Z PROC ; std::_Destroy<ioHashString>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 63   : 	_Ptr->~_Ty();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 64   : 	}

  00006	5d		 pop	 ebp

; 63   : 	_Ptr->~_Ty();

  00007	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
??$_Destroy@VioHashString@@@std@@YAXPAVioHashString@@@Z ENDP ; std::_Destroy<ioHashString>
_TEXT	ENDS
PUBLIC	??$_Destroy@UBuffInfoStruct@@@std@@YAXPAUBuffInfoStruct@@@Z ; std::_Destroy<BuffInfoStruct>
; Function compile flags: /Ogsp
;	COMDAT ??$_Destroy@UBuffInfoStruct@@@std@@YAXPAUBuffInfoStruct@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UBuffInfoStruct@@@std@@YAXPAUBuffInfoStruct@@@Z PROC ; std::_Destroy<BuffInfoStruct>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 63   : 	_Ptr->~_Ty();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 64   : 	}

  00006	5d		 pop	 ebp

; 63   : 	_Ptr->~_Ty();

  00007	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
??$_Destroy@UBuffInfoStruct@@@std@@YAXPAUBuffInfoStruct@@@Z ENDP ; std::_Destroy<BuffInfoStruct>
_TEXT	ENDS
PUBLIC	??$construct@AAUBuffInfoStruct@@@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@AAU2@@Z ; std::allocator<BuffInfoStruct>::construct<BuffInfoStruct &>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??$construct@AAUBuffInfoStruct@@@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAUBuffInfoStruct@@@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@AAU2@@Z$0
__ehfuncinfo$??$construct@AAUBuffInfoStruct@@@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAUBuffInfoStruct@@@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$construct@AAUBuffInfoStruct@@@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@AAU2@@Z
_TEXT	SEGMENT
$T699766 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUBuffInfoStruct@@@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@AAU2@@Z PROC ; std::allocator<BuffInfoStruct>::construct<BuffInfoStruct &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??$construct@AAUBuffInfoStruct@@@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@AAU2@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0000c	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  0000f	89 75 f0	 mov	 DWORD PTR $T699766[ebp], esi
  00012	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00016	85 f6		 test	 esi, esi
  00018	74 12		 je	 SHORT $LN3@construct@2
  0001a	8b 7d 0c	 mov	 edi, DWORD PTR __Val$[ebp]
  0001d	57		 push	 edi
  0001e	8b ce		 mov	 ecx, esi
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  00026	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00029	89 46 10	 mov	 DWORD PTR [esi+16], eax
$LN3@construct@2:

; 209  : 		}

  0002c	e8 00 00 00 00	 call	 __EH_epilog3
  00031	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAUBuffInfoStruct@@@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@AAU2@@Z$0:
  00000	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00003	ff 75 f0	 push	 DWORD PTR $T699766[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000b	59		 pop	 ecx
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
__ehhandler$??$construct@AAUBuffInfoStruct@@@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@AAU2@@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAUBuffInfoStruct@@@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@AAU2@@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAUBuffInfoStruct@@@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@AAU2@@Z ENDP ; std::allocator<BuffInfoStruct>::construct<BuffInfoStruct &>
PUBLIC	?SetGravityAmt@ioBaseChar@@QAEXM@Z		; ioBaseChar::SetGravityAmt
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasechar.h
;	COMDAT ?SetGravityAmt@ioBaseChar@@QAEXM@Z
_TEXT	SEGMENT
_value$699791 = 8					; size = 4
_fAmt$ = 8						; size = 4
?SetGravityAmt@ioBaseChar@@QAEXM@Z PROC			; ioBaseChar::SetGravityAmt, COMDAT
; _this$ = ecx

; 2631 : 	inline void SetGravityAmt( float fAmt ) { m_fGravityAmt = fAmt; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fAmt$[ebp]
  00008	8d 45 08	 lea	 eax, DWORD PTR _value$699791[ebp]
  0000b	50		 push	 eax
  0000c	81 c1 e8 0b 00
	00		 add	 ecx, 3048		; 00000be8H
  00012	f3 0f 11 45 08	 movss	 DWORD PTR _value$699791[ebp], xmm0
  00017	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?SetGravityAmt@ioBaseChar@@QAEXM@Z ENDP			; ioBaseChar::SetGravityAmt
_TEXT	ENDS
PUBLIC	?CheckTeamAttack@ioAffectWoundedValueBuff@@QAE?B_NXZ ; ioAffectWoundedValueBuff::CheckTeamAttack
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioaffectwoundedvaluebuff.h
;	COMDAT ?CheckTeamAttack@ioAffectWoundedValueBuff@@QAE?B_NXZ
_TEXT	SEGMENT
_value$699797 = -1					; size = 1
?CheckTeamAttack@ioAffectWoundedValueBuff@@QAE?B_NXZ PROC ; ioAffectWoundedValueBuff::CheckTeamAttack, COMDAT
; _this$ = ecx

; 94   : 	const bool CheckTeamAttack() { return m_bCheckTeamAttack; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 ff	 lea	 eax, DWORD PTR _value$699797[ebp]
  00007	50		 push	 eax
  00008	81 c1 2c 0a 00
	00		 add	 ecx, 2604		; 00000a2cH
  0000e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  00013	8a 45 ff	 mov	 al, BYTE PTR _value$699797[ebp]
  00016	c9		 leave
  00017	c3		 ret	 0
?CheckTeamAttack@ioAffectWoundedValueBuff@@QAE?B_NXZ ENDP ; ioAffectWoundedValueBuff::CheckTeamAttack
_TEXT	ENDS
PUBLIC	?ApplyWeaponWoundedProtectDamageCalc@ioBaseChar@@IAEXPAV1@AA_NAAM2W4AttackMethodType@@HW4DefenseBreakType@@W4AttackSide@@_N@Z ; ioBaseChar::ApplyWeaponWoundedProtectDamageCalc
EXTRN	?GetCurDefenseDamageBuffRate@ioBaseChar@@QAEMXZ:PROC ; ioBaseChar::GetCurDefenseDamageBuffRate
EXTRN	?GetCurStateProtectRate@ioBaseChar@@QAEMW4AttackSide@@@Z:PROC ; ioBaseChar::GetCurStateProtectRate
EXTRN	?IsStateProtect@ioBaseChar@@QAE_NW4AttackSide@@W4DefenseBreakType@@@Z:PROC ; ioBaseChar::IsStateProtect
EXTRN	?m_fBlowStateDamageRate@ioBaseChar@@1V?$CEncrypt@M@@A:BYTE ; ioBaseChar::m_fBlowStateDamageRate
EXTRN	?IsBlowDownState@ioBaseChar@@QAE_NXZ:PROC	; ioBaseChar::IsBlowDownState
EXTRN	?m_fFloatStateDamageRate@ioBaseChar@@1V?$CEncrypt@M@@A:BYTE ; ioBaseChar::m_fFloatStateDamageRate
EXTRN	?m_fDefenseBrokenDamageRate@ioBaseChar@@1V?$CEncrypt@M@@A:BYTE ; ioBaseChar::m_fDefenseBrokenDamageRate
EXTRN	?IsDefenseEnable@ioBaseChar@@IBE_NW4AttackSide@@W4DefenseBreakType@@_N@Z:PROC ; ioBaseChar::IsDefenseEnable
EXTRN	?IsDamageProtect@ioBaseChar@@QAE_NXZ:PROC	; ioBaseChar::IsDamageProtect
EXTRN	?IsRangeProtect@ioBaseChar@@QAE_NW4AttackMethodType@@@Z:PROC ; ioBaseChar::IsRangeProtect
EXTRN	?GetConcentrateNoTargetDamageRate@ioBaseChar@@QAEMXZ:PROC ; ioBaseChar::GetConcentrateNoTargetDamageRate
EXTRN	?GetConcentrateTargetDamageRate@ioBaseChar@@QAEMXZ:PROC ; ioBaseChar::GetConcentrateTargetDamageRate
EXTRN	__imp_??8ioHashString@@QBE_NABV0@@Z:PROC
EXTRN	?GetConcentrateTargetName@ioBaseChar@@QAEABVioHashString@@XZ:PROC ; ioBaseChar::GetConcentrateTargetName
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
xdata$x	SEGMENT
__unwindtable$?ApplyWeaponWoundedProtectDamageCalc@ioBaseChar@@IAEXPAV1@AA_NAAM2W4AttackMethodType@@HW4DefenseBreakType@@W4AttackSide@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ApplyWeaponWoundedProtectDamageCalc@ioBaseChar@@IAEXPAV1@AA_NAAM2W4AttackMethodType@@HW4DefenseBreakType@@W4AttackSide@@_N@Z$0
__ehfuncinfo$?ApplyWeaponWoundedProtectDamageCalc@ioBaseChar@@IAEXPAV1@AA_NAAM2W4AttackMethodType@@HW4DefenseBreakType@@W4AttackSide@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ApplyWeaponWoundedProtectDamageCalc@ioBaseChar@@IAEXPAV1@AA_NAAM2W4AttackMethodType@@HW4DefenseBreakType@@W4AttackSide@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasecharapplywoundednew.cpp
xdata$x	ENDS
;	COMDAT ?ApplyWeaponWoundedProtectDamageCalc@ioBaseChar@@IAEXPAV1@AA_NAAM2W4AttackMethodType@@HW4DefenseBreakType@@W4AttackSide@@_N@Z
_TEXT	SEGMENT
_szConcentrateTargetName$ = -28				; size = 16
__$EHRec$ = -12						; size = 12
_pAttacker$ = 8						; size = 4
_bProtectDamage$ = 12					; size = 4
_fPreCheckDamage$ = 16					; size = 4
_fDamage$ = 20						; size = 4
_eMethodType$ = 24					; size = 4
_iIgnoreProtect$ = 28					; size = 4
_eBreakType$ = 32					; size = 4
_eSide$ = 36						; size = 4
_bCheckStopMotion$ = 40					; size = 1
?ApplyWeaponWoundedProtectDamageCalc@ioBaseChar@@IAEXPAV1@AA_NAAM2W4AttackMethodType@@HW4DefenseBreakType@@W4AttackSide@@_N@Z PROC ; ioBaseChar::ApplyWeaponWoundedProtectDamageCalc, COMDAT
; _this$ = ecx

; 296  : {

  00000	6a 10		 push	 16			; 00000010H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?ApplyWeaponWoundedProtectDamageCalc@ioBaseChar@@IAEXPAV1@AA_NAAM2W4AttackMethodType@@HW4DefenseBreakType@@W4AttackSide@@_N@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f9		 mov	 edi, ecx

; 297  : 	if ( !pAttacker )

  0000e	8b 5d 08	 mov	 ebx, DWORD PTR _pAttacker$[ebp]
  00011	85 db		 test	 ebx, ebx
  00013	0f 84 e0 01 00
	00		 je	 $LN20@ApplyWeapo@10

; 298  : 		return;
; 299  : 
; 300  : 	bProtectDamage = true;

  00019	8b 45 0c	 mov	 eax, DWORD PTR _bProtectDamage$[ebp]

; 301  : 	fPreCheckDamage = fDamage;

  0001c	8b 75 14	 mov	 esi, DWORD PTR _fDamage$[ebp]
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR _fPreCheckDamage$[ebp]
  00022	c6 00 01	 mov	 BYTE PTR [eax], 1
  00025	d9 06		 fld	 DWORD PTR [esi]
  00027	d9 19		 fstp	 DWORD PTR [ecx]

; 302  : 
; 303  : 	//    
; 304  : 	if( m_pModeParent->GetModeState() == ioPlayMode::MS_RESULT )

  00029	8b 8f 8c 00 00
	00		 mov	 ecx, DWORD PTR [edi+140]
  0002f	8b 49 38	 mov	 ecx, DWORD PTR [ecx+56]
  00032	83 f9 04	 cmp	 ecx, 4
  00035	75 0a		 jne	 SHORT $LN18@ApplyWeapo@10

; 305  : 	{
; 306  : 		bProtectDamage = false;
; 307  : 		fDamage = 0.0f;

  00037	0f 57 c0	 xorps	 xmm0, xmm0
  0003a	c6 00 00	 mov	 BYTE PTR [eax], 0
  0003d	f3 0f 11 06	 movss	 DWORD PTR [esi], xmm0
$LN18@ApplyWeapo@10:

; 308  : 		//fBaseDamage = 0.0f;
; 309  : 	}
; 310  : 
; 311  : 	ioHashString szConcentrateTargetName = pAttacker->GetConcentrateTargetName();

  00041	8b cb		 mov	 ecx, ebx
  00043	e8 00 00 00 00	 call	 ?GetConcentrateTargetName@ioBaseChar@@QAEABVioHashString@@XZ ; ioBaseChar::GetConcentrateTargetName
  00048	50		 push	 eax
  00049	8d 4d e4	 lea	 ecx, DWORD PTR _szConcentrateTargetName$[ebp]
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  00052	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 312  : 	if( szConcentrateTargetName == GetCharName() )

  00056	8d 87 d4 02 00
	00		 lea	 eax, DWORD PTR [edi+724]
  0005c	50		 push	 eax
  0005d	8d 4d e4	 lea	 ecx, DWORD PTR _szConcentrateTargetName$[ebp]
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??8ioHashString@@QBE_NABV0@@Z

; 313  : 	{
; 314  : 		fDamage *= pAttacker->GetConcentrateTargetDamageRate();

  00066	8b cb		 mov	 ecx, ebx
  00068	84 c0		 test	 al, al
  0006a	74 07		 je	 SHORT $LN17@ApplyWeapo@10
  0006c	e8 00 00 00 00	 call	 ?GetConcentrateTargetDamageRate@ioBaseChar@@QAEMXZ ; ioBaseChar::GetConcentrateTargetDamageRate

; 315  : 		//fBaseDamage *= pAttacker->GetConcentrateTargetDamageRate();
; 316  : 	}
; 317  : 	else

  00071	eb 05		 jmp	 SHORT $LN43@ApplyWeapo@10
$LN17@ApplyWeapo@10:

; 318  : 	{
; 319  : 		fDamage *= pAttacker->GetConcentrateNoTargetDamageRate();

  00073	e8 00 00 00 00	 call	 ?GetConcentrateNoTargetDamageRate@ioBaseChar@@QAEMXZ ; ioBaseChar::GetConcentrateNoTargetDamageRate
$LN43@ApplyWeapo@10:
  00078	d8 0e		 fmul	 DWORD PTR [esi]

; 320  : 		//fBaseDamage *= pAttacker->GetConcentrateNoTargetDamageRate();
; 321  : 	}	
; 322  : 
; 323  : 	//---
; 324  : 	if( IsRangeProtect(eMethodType) && iIgnoreProtect == IPT_NONE && eBreakType == DBT_NONE )

  0007a	ff 75 18	 push	 DWORD PTR _eMethodType$[ebp]
  0007d	8b cf		 mov	 ecx, edi
  0007f	d9 1e		 fstp	 DWORD PTR [esi]
  00081	e8 00 00 00 00	 call	 ?IsRangeProtect@ioBaseChar@@QAE_NW4AttackMethodType@@@Z ; ioBaseChar::IsRangeProtect
  00086	8b 5d 20	 mov	 ebx, DWORD PTR _eBreakType$[ebp]
  00089	84 c0		 test	 al, al
  0008b	74 11		 je	 SHORT $LN15@ApplyWeapo@10
  0008d	83 7d 1c 00	 cmp	 DWORD PTR _iIgnoreProtect$[ebp], 0
  00091	75 0b		 jne	 SHORT $LN15@ApplyWeapo@10
  00093	85 db		 test	 ebx, ebx
  00095	75 07		 jne	 SHORT $LN15@ApplyWeapo@10

; 325  : 	{
; 326  : 		fDamage = 0.0f;

  00097	0f 57 c0	 xorps	 xmm0, xmm0
  0009a	f3 0f 11 06	 movss	 DWORD PTR [esi], xmm0
$LN15@ApplyWeapo@10:

; 327  : 		//fBaseDamage = 0.0f;
; 328  : 	}
; 329  : 
; 330  : 	if( IsDamageProtect() && iIgnoreProtect == IPT_NONE )		//  

  0009e	8b cf		 mov	 ecx, edi
  000a0	e8 00 00 00 00	 call	 ?IsDamageProtect@ioBaseChar@@QAE_NXZ ; ioBaseChar::IsDamageProtect
  000a5	84 c0		 test	 al, al
  000a7	74 0d		 je	 SHORT $LN14@ApplyWeapo@10
  000a9	83 7d 1c 00	 cmp	 DWORD PTR _iIgnoreProtect$[ebp], 0
  000ad	75 07		 jne	 SHORT $LN14@ApplyWeapo@10

; 331  : 	{
; 332  : 		fDamage = 0.0f;

  000af	0f 57 c0	 xorps	 xmm0, xmm0
  000b2	f3 0f 11 06	 movss	 DWORD PTR [esi], xmm0
$LN14@ApplyWeapo@10:

; 333  : 		//fBaseDamage = 0.0f;
; 334  : 	}
; 335  : 
; 336  : 	if( IsDefenseEnable( eSide, eBreakType, false ) )

  000b6	6a 00		 push	 0
  000b8	53		 push	 ebx
  000b9	ff 75 24	 push	 DWORD PTR _eSide$[ebp]
  000bc	8b cf		 mov	 ecx, edi
  000be	e8 00 00 00 00	 call	 ?IsDefenseEnable@ioBaseChar@@IBE_NW4AttackSide@@W4DefenseBreakType@@_N@Z ; ioBaseChar::IsDefenseEnable
  000c3	84 c0		 test	 al, al
  000c5	74 34		 je	 SHORT $LN13@ApplyWeapo@10

; 337  : 		fDamage *= m_fDefenseBrokenDamageRate;

  000c7	6a 04		 push	 4
  000c9	68 28 00 00 00	 push	 OFFSET ?m_fDefenseBrokenDamageRate@ioBaseChar@@1V?$CEncrypt@M@@A+40
  000ce	68 1c 00 00 00	 push	 OFFSET ?m_fDefenseBrokenDamageRate@ioBaseChar@@1V?$CEncrypt@M@@A+28
  000d3	b9 0c 00 00 00	 mov	 ecx, OFFSET ?m_fDefenseBrokenDamageRate@ioBaseChar@@1V?$CEncrypt@M@@A+12
  000d8	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte
  000dd	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  000e1	f3 0f 10 0d 28
	00 00 00	 movss	 xmm1, DWORD PTR ?m_fDefenseBrokenDamageRate@ioBaseChar@@1V?$CEncrypt@M@@A+40
  000e9	0f 5a c0	 cvtps2pd xmm0, xmm0
  000ec	0f 5a c9	 cvtps2pd xmm1, xmm1
  000ef	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  000f3	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  000f7	f3 0f 11 06	 movss	 DWORD PTR [esi], xmm0
$LN13@ApplyWeapo@10:

; 338  : 
; 339  : 	if( IsFloatingState() )

  000fb	8b cf		 mov	 ecx, edi
  000fd	e8 00 00 00 00	 call	 ?IsFloatingState@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsFloatingState
  00102	84 c0		 test	 al, al
  00104	74 34		 je	 SHORT $LN12@ApplyWeapo@10

; 340  : 		fDamage *= m_fFloatStateDamageRate;

  00106	6a 04		 push	 4
  00108	68 28 00 00 00	 push	 OFFSET ?m_fFloatStateDamageRate@ioBaseChar@@1V?$CEncrypt@M@@A+40
  0010d	68 1c 00 00 00	 push	 OFFSET ?m_fFloatStateDamageRate@ioBaseChar@@1V?$CEncrypt@M@@A+28
  00112	b9 0c 00 00 00	 mov	 ecx, OFFSET ?m_fFloatStateDamageRate@ioBaseChar@@1V?$CEncrypt@M@@A+12
  00117	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte
  0011c	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  00120	f3 0f 10 0d 28
	00 00 00	 movss	 xmm1, DWORD PTR ?m_fFloatStateDamageRate@ioBaseChar@@1V?$CEncrypt@M@@A+40
  00128	0f 5a c0	 cvtps2pd xmm0, xmm0
  0012b	0f 5a c9	 cvtps2pd xmm1, xmm1
  0012e	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00132	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00136	f3 0f 11 06	 movss	 DWORD PTR [esi], xmm0
$LN12@ApplyWeapo@10:

; 341  : 
; 342  : 	if( m_CharState == CS_FLOAT_STATE && !m_FloatBuffInfo.m_bEnableDamage )

  0013a	8a 87 10 03 00
	00		 mov	 al, BYTE PTR [edi+784]
  00140	3c 25		 cmp	 al, 37			; 00000025H
  00142	75 0e		 jne	 SHORT $LN11@ApplyWeapo@10
  00144	80 bf cc 1c 00
	00 00		 cmp	 BYTE PTR [edi+7372], 0
  0014b	75 05		 jne	 SHORT $LN11@ApplyWeapo@10
$LN45@ApplyWeapo@10:

; 343  : 	{
; 344  : 		fDamage = 0.0f;

  0014d	0f 57 c0	 xorps	 xmm0, xmm0
  00150	eb 5b		 jmp	 SHORT $LN44@ApplyWeapo@10
$LN11@ApplyWeapo@10:

; 345  : 		//fBaseDamage = 0.0f;
; 346  : 	}
; 347  : 	else if( m_CharState == CS_DRINK )

  00152	3c 19		 cmp	 al, 25			; 00000019H

; 348  : 	{
; 349  : 		fDamage = 0.0f;

  00154	74 f7		 je	 SHORT $LN45@ApplyWeapo@10

; 350  : 		//fBaseDamage = 0.0f;
; 351  : 	}
; 352  : 	else if( bCheckStopMotion && eBreakType == DBT_NONE && iIgnoreProtect == IPT_NONE )

  00156	80 7d 28 00	 cmp	 BYTE PTR _bCheckStopMotion$[ebp], 0
  0015a	74 09		 je	 SHORT $LN7@ApplyWeapo@10
  0015c	85 db		 test	 ebx, ebx
  0015e	75 05		 jne	 SHORT $LN7@ApplyWeapo@10
  00160	39 5d 1c	 cmp	 DWORD PTR _iIgnoreProtect$[ebp], ebx

; 353  : 	{
; 354  : 		fDamage = 0.0f;

  00163	74 e8		 je	 SHORT $LN45@ApplyWeapo@10
$LN7@ApplyWeapo@10:

; 355  : 		//fBaseDamage = 0.0f;
; 356  : 	}
; 357  : 	else if( (m_CharState == CS_ETC_STATE && m_bBlowEtcState) || IsBlowDownState() )

  00165	3c 0f		 cmp	 al, 15			; 0000000fH
  00167	75 09		 jne	 SHORT $LN3@ApplyWeapo@10
  00169	80 bf c6 15 00
	00 00		 cmp	 BYTE PTR [edi+5574], 0
  00170	75 0b		 jne	 SHORT $LN4@ApplyWeapo@10
$LN3@ApplyWeapo@10:
  00172	8b cf		 mov	 ecx, edi
  00174	e8 00 00 00 00	 call	 ?IsBlowDownState@ioBaseChar@@QAE_NXZ ; ioBaseChar::IsBlowDownState
  00179	84 c0		 test	 al, al
  0017b	74 34		 je	 SHORT $LN5@ApplyWeapo@10
$LN4@ApplyWeapo@10:

; 358  : 		fDamage *= m_fBlowStateDamageRate;

  0017d	6a 04		 push	 4
  0017f	68 28 00 00 00	 push	 OFFSET ?m_fBlowStateDamageRate@ioBaseChar@@1V?$CEncrypt@M@@A+40
  00184	68 1c 00 00 00	 push	 OFFSET ?m_fBlowStateDamageRate@ioBaseChar@@1V?$CEncrypt@M@@A+28
  00189	b9 0c 00 00 00	 mov	 ecx, OFFSET ?m_fBlowStateDamageRate@ioBaseChar@@1V?$CEncrypt@M@@A+12
  0018e	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte
  00193	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  00197	f3 0f 10 0d 28
	00 00 00	 movss	 xmm1, DWORD PTR ?m_fBlowStateDamageRate@ioBaseChar@@1V?$CEncrypt@M@@A+40
  0019f	0f 5a c0	 cvtps2pd xmm0, xmm0
  001a2	0f 5a c9	 cvtps2pd xmm1, xmm1
  001a5	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  001a9	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
$LN44@ApplyWeapo@10:
  001ad	f3 0f 11 06	 movss	 DWORD PTR [esi], xmm0
$LN5@ApplyWeapo@10:

; 359  : 
; 360  : 	if( IsStateProtect( eSide, eBreakType ) && iIgnoreProtect == IPT_NONE )

  001b1	53		 push	 ebx
  001b2	ff 75 24	 push	 DWORD PTR _eSide$[ebp]
  001b5	8b cf		 mov	 ecx, edi
  001b7	e8 00 00 00 00	 call	 ?IsStateProtect@ioBaseChar@@QAE_NW4AttackSide@@W4DefenseBreakType@@@Z ; ioBaseChar::IsStateProtect
  001bc	84 c0		 test	 al, al
  001be	74 14		 je	 SHORT $LN2@ApplyWeapo@10
  001c0	83 7d 1c 00	 cmp	 DWORD PTR _iIgnoreProtect$[ebp], 0
  001c4	75 0e		 jne	 SHORT $LN2@ApplyWeapo@10

; 361  : 	{
; 362  : 		fDamage *= GetCurStateProtectRate( eSide );

  001c6	ff 75 24	 push	 DWORD PTR _eSide$[ebp]
  001c9	8b cf		 mov	 ecx, edi
  001cb	e8 00 00 00 00	 call	 ?GetCurStateProtectRate@ioBaseChar@@QAEMW4AttackSide@@@Z ; ioBaseChar::GetCurStateProtectRate
  001d0	d8 0e		 fmul	 DWORD PTR [esi]
  001d2	d9 1e		 fstp	 DWORD PTR [esi]
$LN2@ApplyWeapo@10:

; 363  : 	}
; 364  : 
; 365  : 	if( HasBuff(BT_DEFENSE_DAMAGE) )

  001d4	6a 5d		 push	 93			; 0000005dH
  001d6	8b cf		 mov	 ecx, edi
  001d8	e8 00 00 00 00	 call	 ?HasBuff@ioBaseChar@@QBE_NH@Z ; ioBaseChar::HasBuff
  001dd	84 c0		 test	 al, al
  001df	74 0b		 je	 SHORT $LN1@ApplyWeapo@10

; 366  : 	{
; 367  : 		fDamage *= GetCurDefenseDamageBuffRate();

  001e1	8b cf		 mov	 ecx, edi
  001e3	e8 00 00 00 00	 call	 ?GetCurDefenseDamageBuffRate@ioBaseChar@@QAEMXZ ; ioBaseChar::GetCurDefenseDamageBuffRate
  001e8	d8 0e		 fmul	 DWORD PTR [esi]
  001ea	d9 1e		 fstp	 DWORD PTR [esi]
$LN1@ApplyWeapo@10:

; 368  : 	}
; 369  : }

  001ec	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  001f0	8d 4d e4	 lea	 ecx, DWORD PTR _szConcentrateTargetName$[ebp]
  001f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
$LN20@ApplyWeapo@10:
  001f9	e8 00 00 00 00	 call	 __EH_epilog3
  001fe	c2 24 00	 ret	 36			; 00000024H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ApplyWeaponWoundedProtectDamageCalc@ioBaseChar@@IAEXPAV1@AA_NAAM2W4AttackMethodType@@HW4DefenseBreakType@@W4AttackSide@@_N@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR _szConcentrateTargetName$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$?ApplyWeaponWoundedProtectDamageCalc@ioBaseChar@@IAEXPAV1@AA_NAAM2W4AttackMethodType@@HW4DefenseBreakType@@W4AttackSide@@_N@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ApplyWeaponWoundedProtectDamageCalc@ioBaseChar@@IAEXPAV1@AA_NAAM2W4AttackMethodType@@HW4DefenseBreakType@@W4AttackSide@@_N@Z
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ApplyWeaponWoundedProtectDamageCalc@ioBaseChar@@IAEXPAV1@AA_NAAM2W4AttackMethodType@@HW4DefenseBreakType@@W4AttackSide@@_N@Z ENDP ; ioBaseChar::ApplyWeaponWoundedProtectDamageCalc
PUBLIC	?ApplyWeaponWoundedCheckBlock@ioBaseChar@@IAEXPAVioWeapon@@HAAMAA_N_N2AAW4AttackBlockType@@AAW4ProtectionMode@@W4AttackSide@@W4DefenseBreakType@@W4AttackMethodType@@33H3223@Z ; ioBaseChar::ApplyWeaponWoundedCheckBlock
EXTRN	?GetEnableSideType@ioWeapon@@QBE?AW4EnableSideType@@XZ:PROC ; ioWeapon::GetEnableSideType
EXTRN	?GetObjectA@ioBaseChar@@QBEPAVioObjectItem@@XZ:PROC ; ioBaseChar::GetObjectA
EXTRN	?m_fSkillProtectDamageRate@ioBaseChar@@1V?$CEncrypt@M@@A:BYTE ; ioBaseChar::m_fSkillProtectDamageRate
EXTRN	?GetDefenseBreakType@ioWeapon@@QBE?AW4DefenseBreakType@@XZ:PROC ; ioWeapon::GetDefenseBreakType
EXTRN	?IsProtectionMagicType@ioBaseChar@@QAE_NH@Z:PROC ; ioBaseChar::IsProtectionMagicType
EXTRN	?GetElementType@ioWeapon@@QAE?AW4ElementType@@XZ:PROC ; ioWeapon::GetElementType
EXTRN	?IsBuffProtect@ioBaseChar@@QAE_NXZ:PROC		; ioBaseChar::IsBuffProtect
EXTRN	?m_fFrozenDamageRate@ioBaseChar@@1V?$CEncrypt@M@@A:BYTE ; ioBaseChar::m_fFrozenDamageRate
EXTRN	?IsChangeJumpping@ioWeapon@@QAE_N_N0@Z:PROC	; ioWeapon::IsChangeJumpping
EXTRN	?IsNoBlockStateProtect@ioBaseChar@@QAE_NW4AttackSide@@@Z:PROC ; ioBaseChar::IsNoBlockStateProtect
; Function compile flags: /Ogsp
;	COMDAT ?ApplyWeaponWoundedCheckBlock@ioBaseChar@@IAEXPAVioWeapon@@HAAMAA_N_N2AAW4AttackBlockType@@AAW4ProtectionMode@@W4AttackSide@@W4DefenseBreakType@@W4AttackMethodType@@33H3223@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pWeapon$ = 8						; size = 4
_iIgnoreProtect$ = 12					; size = 4
_fDamage$ = 16						; size = 4
_bProtectDamage$ = 20					; size = 4
_bContactType$ = 24					; size = 1
_bOnlyEmoticon$ = 28					; size = 4
_value$699861 = 32					; size = 4
_value$699853 = 32					; size = 4
_eBlockType$ = 32					; size = 4
_eProtectionType$ = 36					; size = 4
_eAttackSide$ = 40					; size = 4
_eBreakType$ = 44					; size = 4
_eMethodType$ = 48					; size = 4
_bFrozenBuff$ = 52					; size = 1
tv513 = 56						; size = 4
_bFrozenState$ = 56					; size = 1
_iFrozenType$ = 60					; size = 4
_bCheckStopMotion$ = 64					; size = 1
_bProtectionMagic$ = 68					; size = 4
_bProtectShakeCamera$ = 72				; size = 4
_bAirTargetBuff$ = 76					; size = 1
?ApplyWeaponWoundedCheckBlock@ioBaseChar@@IAEXPAVioWeapon@@HAAMAA_N_N2AAW4AttackBlockType@@AAW4ProtectionMode@@W4AttackSide@@W4DefenseBreakType@@W4AttackMethodType@@33H3223@Z PROC ; ioBaseChar::ApplyWeaponWoundedCheckBlock, COMDAT
; _this$ = ecx

; 374  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 375  : 	if ( !pWeapon )

  00005	33 db		 xor	 ebx, ebx
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000a	39 5d 08	 cmp	 DWORD PTR _pWeapon$[ebp], ebx
  0000d	0f 84 bc 03 00
	00		 je	 $LN3@ApplyWeapo@11

; 376  : 		return;
; 377  : 
; 378  : 	bOnlyEmoticon = false;

  00013	8b 45 1c	 mov	 eax, DWORD PTR _bOnlyEmoticon$[ebp]
  00016	88 18		 mov	 BYTE PTR [eax], bl

; 379  : 	bProtectionMagic = false;

  00018	8b 45 44	 mov	 eax, DWORD PTR _bProtectionMagic$[ebp]
  0001b	88 18		 mov	 BYTE PTR [eax], bl

; 380  : 	eBlockType = ATB_NONE;
; 381  : 	eProtectionType = PM_NONE;

  0001d	8b 45 24	 mov	 eax, DWORD PTR _eProtectionType$[ebp]
  00020	56		 push	 esi
  00021	8b 75 20	 mov	 esi, DWORD PTR _eBlockType$[ebp]
  00024	89 1e		 mov	 DWORD PTR [esi], ebx
  00026	89 18		 mov	 DWORD PTR [eax], ebx

; 382  : 	bProtectShakeCamera = false;

  00028	8b 45 48	 mov	 eax, DWORD PTR _bProtectShakeCamera$[ebp]
  0002b	57		 push	 edi
  0002c	88 18		 mov	 BYTE PTR [eax], bl

; 383  : 
; 384  : 	//--- 
; 385  : 	// 1, 2, 3   .    .
; 386  : 	// 1 < 2 < 3   .     
; 387  : 
; 388  : 	// 1.     
; 389  : 	if( m_ProtectionMode != PM_NONE && iIgnoreProtect != IPT_ALL )	//  

  0002e	8d b9 d8 10 00
	00		 lea	 edi, DWORD PTR [ecx+4312]
  00034	8d 45 20	 lea	 eax, DWORD PTR _value$699853[ebp]
  00037	50		 push	 eax
  00038	8b cf		 mov	 ecx, edi
  0003a	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4ProtectionMode@@@@QAEXPAW4ProtectionMode@@@Z ; CEncrypt<enum ProtectionMode>::DecryptValueToPool
  0003f	39 5d 20	 cmp	 DWORD PTR _value$699853[ebp], ebx
  00042	74 44		 je	 SHORT $LN91@ApplyWeapo@11
  00044	33 c0		 xor	 eax, eax
  00046	40		 inc	 eax
  00047	39 45 0c	 cmp	 DWORD PTR _iIgnoreProtect$[ebp], eax
  0004a	74 3c		 je	 SHORT $LN91@ApplyWeapo@11

; 390  : 	{
; 391  : 		fDamage = 0.0f;

  0004c	8b 4d 10	 mov	 ecx, DWORD PTR _fDamage$[ebp]
  0004f	0f 57 c0	 xorps	 xmm0, xmm0
  00052	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 392  : 		//fBaseDamage = 0.0f;
; 393  : 		bProtectDamage = false;

  00056	8b 4d 14	 mov	 ecx, DWORD PTR _bProtectDamage$[ebp]
  00059	88 19		 mov	 BYTE PTR [ecx], bl

; 394  : 
; 395  : 		if( !bContactType || pWeapon->CheckWeaponBySkill() )

  0005b	38 5d 18	 cmp	 BYTE PTR _bContactType$[ebp], bl
  0005e	74 0b		 je	 SHORT $LN48@ApplyWeapo@11
  00060	8b 4d 08	 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  00063	38 99 7e 05 00
	00		 cmp	 BYTE PTR [ecx+1406], bl
  00069	74 06		 je	 SHORT $LN49@ApplyWeapo@11
$LN48@ApplyWeapo@11:

; 396  : 			bOnlyEmoticon = true;

  0006b	8b 4d 1c	 mov	 ecx, DWORD PTR _bOnlyEmoticon$[ebp]
  0006e	c6 01 01	 mov	 BYTE PTR [ecx], 1
$LN49@ApplyWeapo@11:

; 397  : 
; 398  : 		eBlockType = ATB_PROTECTION;

  00071	89 06		 mov	 DWORD PTR [esi], eax

; 399  : 		eProtectionType = m_ProtectionMode;

  00073	8d 45 20	 lea	 eax, DWORD PTR _value$699861[ebp]
  00076	50		 push	 eax
  00077	8b cf		 mov	 ecx, edi
  00079	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4ProtectionMode@@@@QAEXPAW4ProtectionMode@@@Z ; CEncrypt<enum ProtectionMode>::DecryptValueToPool
  0007e	8b 45 20	 mov	 eax, DWORD PTR _value$699861[ebp]
  00081	8b 7d 24	 mov	 edi, DWORD PTR _eProtectionType$[ebp]
  00084	89 07		 mov	 DWORD PTR [edi], eax
  00086	eb 03		 jmp	 SHORT $LN50@ApplyWeapo@11
$LN91@ApplyWeapo@11:
  00088	8b 7d 24	 mov	 edi, DWORD PTR _eProtectionType$[ebp]
$LN50@ApplyWeapo@11:

; 400  : 	}
; 401  : 
; 402  : 	// 2.     
; 403  : 	if( HasBuff(BT_ABSOLUTE_PROTECTION) && iIgnoreProtect == IPT_NONE )		//  

  0008b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	6a 1d		 push	 29			; 0000001dH
  00090	e8 00 00 00 00	 call	 ?HasBuff@ioBaseChar@@QBE_NH@Z ; ioBaseChar::HasBuff
  00095	84 c0		 test	 al, al
  00097	74 30		 je	 SHORT $LN94@ApplyWeapo@11
  00099	39 5d 0c	 cmp	 DWORD PTR _iIgnoreProtect$[ebp], ebx
  0009c	75 2b		 jne	 SHORT $LN94@ApplyWeapo@11

; 404  : 	{
; 405  : 		fDamage = 0.0f;

  0009e	8b 45 10	 mov	 eax, DWORD PTR _fDamage$[ebp]
  000a1	0f 57 c0	 xorps	 xmm0, xmm0
  000a4	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 406  : 		//fBaseDamage = 0.0f;
; 407  : 
; 408  : 		if( !bContactType || pWeapon->CheckWeaponBySkill() )

  000a8	38 5d 18	 cmp	 BYTE PTR _bContactType$[ebp], bl
  000ab	74 0b		 je	 SHORT $LN92@ApplyWeapo@11
  000ad	8b 45 08	 mov	 eax, DWORD PTR _pWeapon$[ebp]
  000b0	38 98 7e 05 00
	00		 cmp	 BYTE PTR [eax+1406], bl
  000b6	74 06		 je	 SHORT $LN93@ApplyWeapo@11
$LN92@ApplyWeapo@11:

; 409  : 			bOnlyEmoticon = true;

  000b8	8b 45 1c	 mov	 eax, DWORD PTR _bOnlyEmoticon$[ebp]
  000bb	c6 00 01	 mov	 BYTE PTR [eax], 1
$LN93@ApplyWeapo@11:

; 410  : 
; 411  : 		eBlockType = ATB_MINER;

  000be	c7 06 04 00 00
	00		 mov	 DWORD PTR [esi], 4

; 412  : 		eProtectionType = PM_NONE;

  000c4	e9 b7 01 00 00	 jmp	 $LN98@ApplyWeapo@11
$LN94@ApplyWeapo@11:

; 413  : 	}
; 414  : 	else if( HasBuff(BT_NOT_MOVE_PROTECT) && iIgnoreProtect == IPT_NONE )	// 

  000c9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000cc	6a 48		 push	 72			; 00000048H
  000ce	e8 00 00 00 00	 call	 ?HasBuff@ioBaseChar@@QBE_NH@Z ; ioBaseChar::HasBuff
  000d3	84 c0		 test	 al, al
  000d5	74 26		 je	 SHORT $LN43@ApplyWeapo@11
  000d7	39 5d 0c	 cmp	 DWORD PTR _iIgnoreProtect$[ebp], ebx
  000da	75 21		 jne	 SHORT $LN43@ApplyWeapo@11

; 415  : 	{
; 416  : 		fDamage = 0.0f;

  000dc	8b 45 10	 mov	 eax, DWORD PTR _fDamage$[ebp]
  000df	0f 57 c0	 xorps	 xmm0, xmm0
  000e2	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 417  : 		//fBaseDamage = 0.0f;
; 418  : 
; 419  : 		if( !bContactType || pWeapon->CheckWeaponBySkill() )

  000e6	38 5d 18	 cmp	 BYTE PTR _bContactType$[ebp], bl
  000e9	0f 84 4c 01 00
	00		 je	 $LN19@ApplyWeapo@11
  000ef	8b 45 08	 mov	 eax, DWORD PTR _pWeapon$[ebp]
  000f2	38 98 7e 05 00
	00		 cmp	 BYTE PTR [eax+1406], bl

; 420  : 			bOnlyEmoticon = true;
; 421  : 
; 422  : 		eBlockType = ATB_BUFF;
; 423  : 		eProtectionType = PM_NONE;

  000f8	e9 3c 01 00 00	 jmp	 $LN100@ApplyWeapo@11
$LN43@ApplyWeapo@11:

; 424  : 	}
; 425  : 	else if( IsStateProtect( eAttackSide, eBreakType ) && iIgnoreProtect == IPT_NONE )		//  

  000fd	ff 75 2c	 push	 DWORD PTR _eBreakType$[ebp]
  00100	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00103	ff 75 28	 push	 DWORD PTR _eAttackSide$[ebp]
  00106	e8 00 00 00 00	 call	 ?IsStateProtect@ioBaseChar@@QAE_NW4AttackSide@@W4DefenseBreakType@@@Z ; ioBaseChar::IsStateProtect
  0010b	84 c0		 test	 al, al
  0010d	74 56		 je	 SHORT $LN39@ApplyWeapo@11
  0010f	39 5d 0c	 cmp	 DWORD PTR _iIgnoreProtect$[ebp], ebx
  00112	75 51		 jne	 SHORT $LN39@ApplyWeapo@11

; 426  : 	{
; 427  : 		if( !bContactType || pWeapon->CheckWeaponBySkill() || IsNoBlockStateProtect( eAttackSide ) )

  00114	38 5d 18	 cmp	 BYTE PTR _bContactType$[ebp], bl
  00117	74 1a		 je	 SHORT $LN37@ApplyWeapo@11
  00119	8b 45 08	 mov	 eax, DWORD PTR _pWeapon$[ebp]
  0011c	38 98 7e 05 00
	00		 cmp	 BYTE PTR [eax+1406], bl
  00122	75 0f		 jne	 SHORT $LN37@ApplyWeapo@11
  00124	ff 75 28	 push	 DWORD PTR _eAttackSide$[ebp]
  00127	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012a	e8 00 00 00 00	 call	 ?IsNoBlockStateProtect@ioBaseChar@@QAE_NW4AttackSide@@@Z ; ioBaseChar::IsNoBlockStateProtect
  0012f	84 c0		 test	 al, al
  00131	74 06		 je	 SHORT $LN38@ApplyWeapo@11
$LN37@ApplyWeapo@11:

; 428  : 		{
; 429  : 			bOnlyEmoticon = true;

  00133	8b 45 1c	 mov	 eax, DWORD PTR _bOnlyEmoticon$[ebp]
  00136	c6 00 01	 mov	 BYTE PTR [eax], 1
$LN38@ApplyWeapo@11:

; 430  : 		}
; 431  : 
; 432  : 		ioBuff *pBuff = GetBuff( BT_STATE_PROTECTION );

  00139	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0013c	6a 23		 push	 35			; 00000023H
  0013e	e8 00 00 00 00	 call	 ?GetBuff@ioBaseChar@@QAEPAVioBuff@@H@Z ; ioBaseChar::GetBuff

; 433  : 		ioStateProtectionBuff *pStateProtectionBuff = ToStateProtectBuff( pBuff );

  00143	50		 push	 eax
  00144	e8 00 00 00 00	 call	 ?ToStateProtectBuff@@YAPAVioStateProtectionBuff@@PAVioBuff@@@Z ; ToStateProtectBuff
  00149	59		 pop	 ecx

; 434  : 		if ( pStateProtectionBuff && pStateProtectionBuff->IsNoEmoticon() )

  0014a	3b c3		 cmp	 eax, ebx
  0014c	0f 84 ef 00 00
	00		 je	 $LN97@ApplyWeapo@11
  00152	38 98 1d 0a 00
	00		 cmp	 BYTE PTR [eax+2589], bl
  00158	0f 84 e3 00 00
	00		 je	 $LN97@ApplyWeapo@11

; 435  : 			eBlockType = ATB_NONE;

  0015e	89 1e		 mov	 DWORD PTR [esi], ebx

; 436  : 		else

  00160	e9 1b 01 00 00	 jmp	 $LN98@ApplyWeapo@11
$LN39@ApplyWeapo@11:

; 437  : 			eBlockType = ATB_BUFF;
; 438  : 
; 439  : 		eProtectionType = PM_NONE;
; 440  : 	}
; 441  : 	else if( IsRangeProtect(eMethodType) && iIgnoreProtect == IPT_NONE && eBreakType == DBT_NONE )	// / 

  00165	ff 75 30	 push	 DWORD PTR _eMethodType$[ebp]
  00168	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0016b	e8 00 00 00 00	 call	 ?IsRangeProtect@ioBaseChar@@QAE_NW4AttackMethodType@@@Z ; ioBaseChar::IsRangeProtect
  00170	84 c0		 test	 al, al
  00172	74 0e		 je	 SHORT $LN95@ApplyWeapo@11
  00174	39 5d 0c	 cmp	 DWORD PTR _iIgnoreProtect$[ebp], ebx
  00177	75 09		 jne	 SHORT $LN95@ApplyWeapo@11
  00179	39 5d 2c	 cmp	 DWORD PTR _eBreakType$[ebp], ebx

; 442  : 	{
; 443  : 		bOnlyEmoticon = true;
; 444  : 
; 445  : 		eBlockType = ATB_BUFF;
; 446  : 		eProtectionType = PM_NONE;

  0017c	0f 84 b9 00 00
	00		 je	 $LN19@ApplyWeapo@11
$LN95@ApplyWeapo@11:

; 447  : 	}
; 448  : 	else if( bFrozenState && !bFrozenBuff )							//  

  00182	38 5d 38	 cmp	 BYTE PTR _bFrozenState$[ebp], bl
  00185	0f 84 84 00 00
	00		 je	 $LN27@ApplyWeapo@11
  0018b	38 5d 34	 cmp	 BYTE PTR _bFrozenBuff$[ebp], bl
  0018e	75 38		 jne	 SHORT $LN31@ApplyWeapo@11
$LN101@ApplyWeapo@11:

; 449  : 	{
; 450  : 		fDamage = 0.0f;

  00190	8b 45 10	 mov	 eax, DWORD PTR _fDamage$[ebp]
  00193	0f 57 c0	 xorps	 xmm0, xmm0
  00196	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 451  : 		//fBaseDamage = 0.0f;
; 452  : 
; 453  : 		if( !bContactType || pWeapon->CheckWeaponBySkill() || pWeapon->IsChangeJumpping( false, bAirTargetBuff ) )

  0019a	38 5d 18	 cmp	 BYTE PTR _bContactType$[ebp], bl
  0019d	74 18		 je	 SHORT $LN29@ApplyWeapo@11
  0019f	8b 4d 08	 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  001a2	38 99 7e 05 00
	00		 cmp	 BYTE PTR [ecx+1406], bl
  001a8	75 0d		 jne	 SHORT $LN29@ApplyWeapo@11
  001aa	ff 75 4c	 push	 DWORD PTR _bAirTargetBuff$[ebp]
  001ad	53		 push	 ebx
  001ae	e8 00 00 00 00	 call	 ?IsChangeJumpping@ioWeapon@@QAE_N_N0@Z ; ioWeapon::IsChangeJumpping
  001b3	84 c0		 test	 al, al
  001b5	74 06		 je	 SHORT $LN86@ApplyWeapo@11
$LN29@ApplyWeapo@11:

; 454  : 			bOnlyEmoticon = true;

  001b7	8b 45 1c	 mov	 eax, DWORD PTR _bOnlyEmoticon$[ebp]
  001ba	c6 00 01	 mov	 BYTE PTR [eax], 1
$LN86@ApplyWeapo@11:

; 455  : 
; 456  : 		eBlockType = ATB_ICE;

  001bd	c7 06 03 00 00
	00		 mov	 DWORD PTR [esi], 3

; 457  : 		eProtectionType = PM_NONE;

  001c3	e9 b8 00 00 00	 jmp	 $LN98@ApplyWeapo@11
$LN31@ApplyWeapo@11:

; 458  : 	}
; 459  : 	else if( bFrozenState && bFrozenBuff )
; 460  : 	{
; 461  : 		if( iFrozenType == ioFrozenBuff::FZT_EXCEPT && eBreakType == DBT_NONE )

  001c8	83 7d 3c 01	 cmp	 DWORD PTR _iFrozenType$[ebp], 1
  001cc	75 05		 jne	 SHORT $LN26@ApplyWeapo@11
  001ce	39 5d 2c	 cmp	 DWORD PTR _eBreakType$[ebp], ebx

; 462  : 		{
; 463  : 			fDamage = 0.0f;
; 464  : 			//fBaseDamage = 0.0f;
; 465  : 
; 466  : 			if( !bContactType || pWeapon->CheckWeaponBySkill() || pWeapon->IsChangeJumpping( false, bAirTargetBuff ) )
; 467  : 				bOnlyEmoticon = true;
; 468  : 
; 469  : 			eBlockType = ATB_ICE;
; 470  : 			eProtectionType = PM_NONE;
; 471  : 		}
; 472  : 		else

  001d1	74 bd		 je	 SHORT $LN101@ApplyWeapo@11
$LN26@ApplyWeapo@11:

; 473  : 			fDamage *= m_fFrozenDamageRate;

  001d3	6a 04		 push	 4
  001d5	68 28 00 00 00	 push	 OFFSET ?m_fFrozenDamageRate@ioBaseChar@@1V?$CEncrypt@M@@A+40
  001da	68 1c 00 00 00	 push	 OFFSET ?m_fFrozenDamageRate@ioBaseChar@@1V?$CEncrypt@M@@A+28
  001df	b9 0c 00 00 00	 mov	 ecx, OFFSET ?m_fFrozenDamageRate@ioBaseChar@@1V?$CEncrypt@M@@A+12
  001e4	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte
  001e9	8b 45 10	 mov	 eax, DWORD PTR _fDamage$[ebp]
  001ec	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001f0	f3 0f 10 0d 28
	00 00 00	 movss	 xmm1, DWORD PTR ?m_fFrozenDamageRate@ioBaseChar@@1V?$CEncrypt@M@@A+40
  001f8	0f 5a c0	 cvtps2pd xmm0, xmm0
  001fb	0f 5a c9	 cvtps2pd xmm1, xmm1
  001fe	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00202	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00206	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  0020a	e9 9e 00 00 00	 jmp	 $LN88@ApplyWeapo@11
$LN27@ApplyWeapo@11:

; 474  : 	}
; 475  : 	else if( bCheckStopMotion && eBreakType == DBT_NONE && iIgnoreProtect == IPT_NONE )

  0020f	38 5d 40	 cmp	 BYTE PTR _bCheckStopMotion$[ebp], bl
  00212	74 35		 je	 SHORT $LN21@ApplyWeapo@11
  00214	39 5d 2c	 cmp	 DWORD PTR _eBreakType$[ebp], ebx
  00217	75 30		 jne	 SHORT $LN21@ApplyWeapo@11
  00219	39 5d 0c	 cmp	 DWORD PTR _iIgnoreProtect$[ebp], ebx
  0021c	75 2b		 jne	 SHORT $LN21@ApplyWeapo@11

; 476  : 	{
; 477  : 		if( !bContactType || pWeapon->CheckWeaponBySkill() || pWeapon->IsChangeJumpping( false, bAirTargetBuff ) )

  0021e	38 5d 18	 cmp	 BYTE PTR _bContactType$[ebp], bl
  00221	74 18		 je	 SHORT $LN19@ApplyWeapo@11
  00223	8b 4d 08	 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  00226	38 99 7e 05 00
	00		 cmp	 BYTE PTR [ecx+1406], bl
  0022c	75 0d		 jne	 SHORT $LN19@ApplyWeapo@11
  0022e	ff 75 4c	 push	 DWORD PTR _bAirTargetBuff$[ebp]
  00231	53		 push	 ebx
  00232	e8 00 00 00 00	 call	 ?IsChangeJumpping@ioWeapon@@QAE_N_N0@Z ; ioWeapon::IsChangeJumpping
  00237	84 c0		 test	 al, al
$LN100@ApplyWeapo@11:
  00239	74 06		 je	 SHORT $LN97@ApplyWeapo@11
$LN19@ApplyWeapo@11:

; 478  : 			bOnlyEmoticon = true;

  0023b	8b 45 1c	 mov	 eax, DWORD PTR _bOnlyEmoticon$[ebp]
  0023e	c6 00 01	 mov	 BYTE PTR [eax], 1
$LN97@ApplyWeapo@11:

; 479  : 
; 480  : 		eBlockType = ATB_BUFF;

  00241	c7 06 05 00 00
	00		 mov	 DWORD PTR [esi], 5

; 481  : 		eProtectionType = PM_NONE;

  00247	eb 37		 jmp	 SHORT $LN98@ApplyWeapo@11
$LN21@ApplyWeapo@11:

; 482  : 	}
; 483  : 	else if( IsBuffProtect() && iIgnoreProtect == IPT_NONE )

  00249	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0024c	e8 00 00 00 00	 call	 ?IsBuffProtect@ioBaseChar@@QAE_NXZ ; ioBaseChar::IsBuffProtect
  00251	84 c0		 test	 al, al
  00253	74 2f		 je	 SHORT $LN17@ApplyWeapo@11
  00255	39 5d 0c	 cmp	 DWORD PTR _iIgnoreProtect$[ebp], ebx
  00258	75 2a		 jne	 SHORT $LN17@ApplyWeapo@11

; 484  : 	{
; 485  : 		fDamage = 0.0f;

  0025a	8b 45 10	 mov	 eax, DWORD PTR _fDamage$[ebp]
  0025d	0f 57 c0	 xorps	 xmm0, xmm0
  00260	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 486  : 
; 487  : 		if( !bContactType || pWeapon->CheckWeaponBySkill() )

  00264	38 5d 18	 cmp	 BYTE PTR _bContactType$[ebp], bl
  00267	74 0b		 je	 SHORT $LN15@ApplyWeapo@11
  00269	8b 45 08	 mov	 eax, DWORD PTR _pWeapon$[ebp]
  0026c	38 98 7e 05 00
	00		 cmp	 BYTE PTR [eax+1406], bl
  00272	74 06		 je	 SHORT $LN16@ApplyWeapo@11
$LN15@ApplyWeapo@11:

; 488  : 			bOnlyEmoticon = true;

  00274	8b 45 1c	 mov	 eax, DWORD PTR _bOnlyEmoticon$[ebp]
  00277	c6 00 01	 mov	 BYTE PTR [eax], 1
$LN16@ApplyWeapo@11:

; 489  : 
; 490  : 		eBlockType = ATB_SKILL;

  0027a	c7 06 02 00 00
	00		 mov	 DWORD PTR [esi], 2
$LN98@ApplyWeapo@11:

; 491  : 		eProtectionType = PM_NONE;

  00280	89 1f		 mov	 DWORD PTR [edi], ebx
  00282	eb 29		 jmp	 SHORT $LN88@ApplyWeapo@11
$LN17@ApplyWeapo@11:

; 492  : 	}
; 493  : 	else if( IsProtectionMagicType( pWeapon->GetElementType() ) )		//  .

  00284	8b 4d 08	 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  00287	e8 00 00 00 00	 call	 ?GetElementType@ioWeapon@@QAE?AW4ElementType@@XZ ; ioWeapon::GetElementType
  0028c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0028f	50		 push	 eax
  00290	e8 00 00 00 00	 call	 ?IsProtectionMagicType@ioBaseChar@@QAE_NH@Z ; ioBaseChar::IsProtectionMagicType
  00295	84 c0		 test	 al, al
  00297	74 14		 je	 SHORT $LN88@ApplyWeapo@11

; 494  : 	{
; 495  : 		bOnlyEmoticon = true;

  00299	8b 45 1c	 mov	 eax, DWORD PTR _bOnlyEmoticon$[ebp]
  0029c	c6 00 01	 mov	 BYTE PTR [eax], 1

; 496  : 		eBlockType = ATB_BUFF;
; 497  : 		eProtectionType = PM_NONE;
; 498  : 		bProtectionMagic = true;

  0029f	8b 45 44	 mov	 eax, DWORD PTR _bProtectionMagic$[ebp]
  002a2	c7 06 05 00 00
	00		 mov	 DWORD PTR [esi], 5
  002a8	89 1f		 mov	 DWORD PTR [edi], ebx
  002aa	c6 00 01	 mov	 BYTE PTR [eax], 1
$LN88@ApplyWeapo@11:

; 499  : 	}
; 500  : 
; 501  : 	// 3.     
; 502  : 	if( m_pActiveSkill && m_pActiveSkill->IsProtected( pWeapon->GetDefenseBreakType() ) && iIgnoreProtect == IPT_NONE )		//  

  002ad	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002b0	39 99 e0 0d 00
	00		 cmp	 DWORD PTR [ecx+3552], ebx
  002b6	0f 84 8a 00 00
	00		 je	 $LN12@ApplyWeapo@11
  002bc	8b 81 e0 0d 00
	00		 mov	 eax, DWORD PTR [ecx+3552]
  002c2	8b 00		 mov	 eax, DWORD PTR [eax]
  002c4	8b 4d 08	 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  002c7	89 45 38	 mov	 DWORD PTR tv513[ebp], eax
  002ca	e8 00 00 00 00	 call	 ?GetDefenseBreakType@ioWeapon@@QBE?AW4DefenseBreakType@@XZ ; ioWeapon::GetDefenseBreakType
  002cf	50		 push	 eax
  002d0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002d3	8b 88 e0 0d 00
	00		 mov	 ecx, DWORD PTR [eax+3552]
  002d9	8b 45 38	 mov	 eax, DWORD PTR tv513[ebp]
  002dc	ff 50 0c	 call	 DWORD PTR [eax+12]
  002df	84 c0		 test	 al, al
  002e1	74 60		 je	 SHORT $LN89@ApplyWeapo@11
  002e3	39 5d 0c	 cmp	 DWORD PTR _iIgnoreProtect$[ebp], ebx
  002e6	75 5b		 jne	 SHORT $LN89@ApplyWeapo@11

; 503  : 	{
; 504  : 		fDamage *= m_fSkillProtectDamageRate;

  002e8	6a 04		 push	 4
  002ea	68 28 00 00 00	 push	 OFFSET ?m_fSkillProtectDamageRate@ioBaseChar@@1V?$CEncrypt@M@@A+40
  002ef	68 1c 00 00 00	 push	 OFFSET ?m_fSkillProtectDamageRate@ioBaseChar@@1V?$CEncrypt@M@@A+28
  002f4	b9 0c 00 00 00	 mov	 ecx, OFFSET ?m_fSkillProtectDamageRate@ioBaseChar@@1V?$CEncrypt@M@@A+12
  002f9	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte
  002fe	8b 45 10	 mov	 eax, DWORD PTR _fDamage$[ebp]
  00301	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00305	f3 0f 10 0d 28
	00 00 00	 movss	 xmm1, DWORD PTR ?m_fSkillProtectDamageRate@ioBaseChar@@1V?$CEncrypt@M@@A+40
  0030d	0f 5a c0	 cvtps2pd xmm0, xmm0
  00310	0f 5a c9	 cvtps2pd xmm1, xmm1
  00313	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00317	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0031b	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 505  : 
; 506  : 		if( !bContactType || pWeapon->CheckWeaponBySkill() )

  0031f	38 5d 18	 cmp	 BYTE PTR _bContactType$[ebp], bl
  00322	74 0b		 je	 SHORT $LN10@ApplyWeapo@11
  00324	8b 45 08	 mov	 eax, DWORD PTR _pWeapon$[ebp]
  00327	38 98 7e 05 00
	00		 cmp	 BYTE PTR [eax+1406], bl
  0032d	74 06		 je	 SHORT $LN11@ApplyWeapo@11
$LN10@ApplyWeapo@11:

; 507  : 			bOnlyEmoticon = true;

  0032f	8b 45 1c	 mov	 eax, DWORD PTR _bOnlyEmoticon$[ebp]
  00332	c6 00 01	 mov	 BYTE PTR [eax], 1
$LN11@ApplyWeapo@11:

; 508  : 
; 509  : 		bProtectShakeCamera = true;

  00335	8b 45 48	 mov	 eax, DWORD PTR _bProtectShakeCamera$[ebp]
  00338	c6 00 01	 mov	 BYTE PTR [eax], 1

; 510  : 
; 511  : 		eBlockType = ATB_SKILL;

  0033b	c7 06 02 00 00
	00		 mov	 DWORD PTR [esi], 2

; 512  : 		eProtectionType = PM_NONE;

  00341	89 1f		 mov	 DWORD PTR [edi], ebx
$LN89@ApplyWeapo@11:
  00343	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN12@ApplyWeapo@11:

; 513  : 	}
; 514  : 
; 515  : 	// 4.     
; 516  : 	if( m_CharState == CS_DEFENSE_ATTACK && eBreakType == DBT_NONE && iIgnoreProtect == IPT_NONE )

  00346	80 b9 10 03 00
	00 3e		 cmp	 BYTE PTR [ecx+784], 62	; 0000003eH
  0034d	75 14		 jne	 SHORT $LN9@ApplyWeapo@11
  0034f	39 5d 2c	 cmp	 DWORD PTR _eBreakType$[ebp], ebx
  00352	75 0f		 jne	 SHORT $LN9@ApplyWeapo@11
  00354	39 5d 0c	 cmp	 DWORD PTR _iIgnoreProtect$[ebp], ebx
  00357	75 0a		 jne	 SHORT $LN9@ApplyWeapo@11

; 517  : 	{
; 518  : 		fDamage = 0.0f;

  00359	8b 45 10	 mov	 eax, DWORD PTR _fDamage$[ebp]
  0035c	0f 57 c0	 xorps	 xmm0, xmm0
  0035f	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
$LN9@ApplyWeapo@11:

; 519  : 		//fBaseDamage = 0.0f;
; 520  : 	}
; 521  : 
; 522  : 	// 5.     
; 523  : 	if( GetObject() )

  00363	e8 00 00 00 00	 call	 ?GetObjectA@ioBaseChar@@QBEPAVioObjectItem@@XZ ; ioBaseChar::GetObjectA
  00368	85 c0		 test	 eax, eax
  0036a	74 31		 je	 SHORT $LN7@ApplyWeapo@11

; 524  : 	{	
; 525  : 		ioObjectItem *pObject = GetObject();

  0036c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0036f	e8 00 00 00 00	 call	 ?GetObjectA@ioBaseChar@@QBEPAVioObjectItem@@XZ ; ioBaseChar::GetObjectA

; 526  : 		if( pObject && pObject->IsProtectState() && iIgnoreProtect == IPT_NONE )

  00374	3b c3		 cmp	 eax, ebx
  00376	74 25		 je	 SHORT $LN7@ApplyWeapo@11
  00378	8b 10		 mov	 edx, DWORD PTR [eax]
  0037a	8b c8		 mov	 ecx, eax
  0037c	ff 92 fc 02 00
	00		 call	 DWORD PTR [edx+764]
  00382	84 c0		 test	 al, al
  00384	74 17		 je	 SHORT $LN7@ApplyWeapo@11
  00386	39 5d 0c	 cmp	 DWORD PTR _iIgnoreProtect$[ebp], ebx
  00389	75 12		 jne	 SHORT $LN7@ApplyWeapo@11

; 527  : 		{
; 528  : 			fDamage = 0.0f;

  0038b	8b 45 10	 mov	 eax, DWORD PTR _fDamage$[ebp]
  0038e	0f 57 c0	 xorps	 xmm0, xmm0
  00391	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 529  : 			//fBaseDamage = 0.0f;
; 530  : 
; 531  : 			eBlockType = ATB_SKILL;

  00395	c7 06 02 00 00
	00		 mov	 DWORD PTR [esi], 2

; 532  : 			eProtectionType = PM_NONE;

  0039b	89 1f		 mov	 DWORD PTR [edi], ebx
$LN7@ApplyWeapo@11:

; 533  : 		}
; 534  : 	}
; 535  : 
; 536  : 	// Enable Side Check Damage
; 537  : 	EnableSideType eSideType = pWeapon->GetEnableSideType();

  0039d	8b 4d 08	 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  003a0	e8 00 00 00 00	 call	 ?GetEnableSideType@ioWeapon@@QBE?AW4EnableSideType@@XZ ; ioWeapon::GetEnableSideType

; 538  : 	switch( eSideType )

  003a5	48		 dec	 eax
  003a6	5f		 pop	 edi
  003a7	5e		 pop	 esi
  003a8	74 0f		 je	 SHORT $LN4@ApplyWeapo@11
  003aa	48		 dec	 eax
  003ab	75 22		 jne	 SHORT $LN3@ApplyWeapo@11

; 544  : 			//fBaseDamage = 0.0f;
; 545  : 		}
; 546  : 		break;
; 547  : 	case EST_BACK:
; 548  : 		if( m_AttackedSide == AS_FRONT )

  003ad	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003b0	83 b8 d4 0e 00
	00 01		 cmp	 DWORD PTR [eax+3796], 1

; 549  : 		{
; 550  : 			fDamage = 0.0f;
; 551  : 			//fBaseDamage = 0.0f;
; 552  : 		}
; 553  : 		break;

  003b7	eb 0a		 jmp	 SHORT $LN99@ApplyWeapo@11
$LN4@ApplyWeapo@11:

; 539  : 	{
; 540  : 	case EST_FRONT:
; 541  : 		if( m_AttackedSide == AS_BACK )

  003b9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003bc	83 b8 d4 0e 00
	00 02		 cmp	 DWORD PTR [eax+3796], 2
$LN99@ApplyWeapo@11:
  003c3	75 0a		 jne	 SHORT $LN3@ApplyWeapo@11

; 542  : 		{
; 543  : 			fDamage = 0.0f;

  003c5	8b 45 10	 mov	 eax, DWORD PTR _fDamage$[ebp]
  003c8	0f 57 c0	 xorps	 xmm0, xmm0
  003cb	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
$LN3@ApplyWeapo@11:
  003cf	5b		 pop	 ebx

; 554  : 	}
; 555  : }

  003d0	c9		 leave
  003d1	c2 48 00	 ret	 72			; 00000048H
?ApplyWeaponWoundedCheckBlock@ioBaseChar@@IAEXPAVioWeapon@@HAAMAA_N_N2AAW4AttackBlockType@@AAW4ProtectionMode@@W4AttackSide@@W4DefenseBreakType@@W4AttackMethodType@@33H3223@Z ENDP ; ioBaseChar::ApplyWeaponWoundedCheckBlock
_TEXT	ENDS
PUBLIC	__real@00000000
PUBLIC	__real@3f800000
PUBLIC	_fDamage$GSCopy$
PUBLIC	_szReflectAni$GSCopy$
PUBLIC	_bApplyStateProtect$GSCopy$
PUBLIC	_pWeapon$GSCopy$
PUBLIC	_vAttackDir$GSCopy$
PUBLIC	_pAttacker$GSCopy$
PUBLIC	_fWeakAttackPushPower$GSCopy$
PUBLIC	_fAttackerPushPower$GSCopy$
PUBLIC	_bPushAttacker$GSCopy$
PUBLIC	_fReflectAniRate$GSCopy$
PUBLIC	?ApplyWeaponWoundedReflect@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_N2AAVioHashString@@AAM244W4AttackSide@@_NABUD3DXVECTOR3@@W4AttackBlockType@@W4ProtectionMode@@46W4EscapeCatchType@@W4DefenseBreakType@@6@Z ; ioBaseChar::ApplyWeaponWoundedReflect
EXTRN	?CheckReflectDameage@ioBaseChar@@IAEX_N0PAV1@PAVioWeapon@@@Z:PROC ; ioBaseChar::CheckReflectDameage
EXTRN	?CheckSkillEvent@ioBaseChar@@QAEXH@Z:PROC	; ioBaseChar::CheckSkillEvent
EXTRN	?CreateMapEffect@ioPlayStage@@QAEPAVioMapEffect@@ABVioHashString@@ABUD3DXVECTOR3@@1@Z:PROC ; ioPlayStage::CreateMapEffect
EXTRN	?GetMidPositionByRate@ioGameEntity@@QBE?AUD3DXVECTOR3@@M@Z:PROC ; ioGameEntity::GetMidPositionByRate
EXTRN	?ReverseReflectPush@ioBaseChar@@QAEXABUD3DXVECTOR3@@M@Z:PROC ; ioBaseChar::ReverseReflectPush
EXTRN	?SetLastAttackerName@ioBaseChar@@QAEXABVioHashString@@0@Z:PROC ; ioBaseChar::SetLastAttackerName
EXTRN	?GetWeaponBySkillName@ioWeapon@@QBEABVioHashString@@XZ:PROC ; ioWeapon::GetWeaponBySkillName
EXTRN	__imp_??0ioHashString@@QAE@PBD@Z:PROC
EXTRN	__imp_?c_str@ioHashString@@QBEPBDXZ:PROC
EXTRN	?GetValue@ioGrowthNormalUpInfo@@QAEMPAVioPlayStage@@@Z:PROC ; ioGrowthNormalUpInfo::GetValue
EXTRN	?GetGrowthUpInfoByType@ioItem@@QAEPAVioGrowthUpInfo@@HABVioHashString@@@Z:PROC ; ioItem::GetGrowthUpInfoByType
EXTRN	?GetEquipedItem@ioBaseChar@@QAEPAVioItem@@H@Z:PROC ; ioBaseChar::GetEquipedItem
EXTRN	?SetEtcState@ioBaseChar@@QAEXABVioHashString@@M@Z:PROC ; ioBaseChar::SetEtcState
EXTRN	__imp_?IsEmpty@ioHashString@@QBE_NXZ:PROC
EXTRN	?IsEnableAttackCancelState@ioBaseChar@@QAE_NXZ:PROC ; ioBaseChar::IsEnableAttackCancelState
EXTRN	?IsFloating@ioBaseChar@@QAE_NXZ:PROC		; ioBaseChar::IsFloating
EXTRN	?CheckBlockState@ioBaseChar@@QAEXW4AttackBlockType@@W4ProtectionMode@@@Z:PROC ; ioBaseChar::CheckBlockState
EXTRN	?WeakAttackPush@ioBaseChar@@QAEXABUD3DXVECTOR3@@M@Z:PROC ; ioBaseChar::WeakAttackPush
EXTRN	?IgnoreBlock@ioBaseChar@@QAE_NXZ:PROC		; ioBaseChar::IgnoreBlock
EXTRN	?GetReflectInfoIndex@ioBaseChar@@QAEHW4AttackSide@@@Z:PROC ; ioBaseChar::GetReflectInfoIndex
EXTRN	__imp_?Clear@ioHashString@@QAEXXZ:PROC
EXTRN	__EH_epilog3_GS:PROC
EXTRN	__EH_prolog3_GS:PROC
;	COMDAT __real@00000000
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ApplyWeaponWoundedReflect@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_N2AAVioHashString@@AAM244W4AttackSide@@_NABUD3DXVECTOR3@@W4AttackBlockType@@W4ProtectionMode@@46W4EscapeCatchType@@W4DefenseBreakType@@6@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ApplyWeaponWoundedReflect@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_N2AAVioHashString@@AAM244W4AttackSide@@_NABUD3DXVECTOR3@@W4AttackBlockType@@W4ProtectionMode@@46W4EscapeCatchType@@W4DefenseBreakType@@6@Z$0
__ehfuncinfo$?ApplyWeaponWoundedReflect@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_N2AAVioHashString@@AAM244W4AttackSide@@_NABUD3DXVECTOR3@@W4AttackBlockType@@W4ProtectionMode@@46W4EscapeCatchType@@W4DefenseBreakType@@6@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ApplyWeaponWoundedReflect@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_N2AAVioHashString@@AAM244W4AttackSide@@_NABUD3DXVECTOR3@@W4AttackBlockType@@W4ProtectionMode@@46W4EscapeCatchType@@W4DefenseBreakType@@6@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasecharapplywoundednew.cpp
xdata$x	ENDS
;	COMDAT ?ApplyWeaponWoundedReflect@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_N2AAVioHashString@@AAM244W4AttackSide@@_NABUD3DXVECTOR3@@W4AttackBlockType@@W4ProtectionMode@@46W4EscapeCatchType@@W4DefenseBreakType@@6@Z
_TEXT	SEGMENT
_bPushAttacker$GSCopy$ = -88				; size = 4
_fDamage$GSCopy$ = -84					; size = 4
_szReflectAni$GSCopy$ = -80				; size = 4
_fWeakAttackPushPower$GSCopy$ = -76			; size = 4
_vAttackDir$GSCopy$ = -72				; size = 4
$T699990 = -68						; size = 4
_fAirReflectRate$ = -68					; size = 4
_fReflectAniRate$GSCopy$ = -64				; size = 4
_pWeapon$GSCopy$ = -60					; size = 4
_fGrowthValue$693788 = -56				; size = 4
_iReflectIndex$ = -56					; size = 4
_fAttackerPushPower$GSCopy$ = -52			; size = 4
_fGrowthValue$693779 = -52				; size = 4
tv724 = -48						; size = 4
tv720 = -48						; size = 4
tv716 = -48						; size = 4
_bApplyStateProtect$GSCopy$ = -48			; size = 4
_value$700012 = -48					; size = 4
$T699986 = -48						; size = 4
_bEnableEscapeCatchAttackReflect$ = -41			; size = 1
_pAttacker$GSCopy$ = -40				; size = 4
_bAirReflect$ = -33					; size = 1
$T699935 = -32						; size = 16
$T693784 = -28						; size = 12
__$EHRec$ = -12						; size = 12
_pWeapon$ = 8						; size = 4
_pAttacker$ = 12					; size = 4
_bStateProtectIgnoreReflect$ = 16			; size = 4
_bApplyStateProtect$ = 20				; size = 4
_szReflectAni$ = 24					; size = 4
_fReflectAniRate$ = 28					; size = 4
_bPushAttacker$ = 32					; size = 4
_fAttackerPushPower$ = 36				; size = 4
_fWeakAttackPushPower$ = 40				; size = 4
_eSide$ = 44						; size = 4
_bOnlyEmoticon$ = 48					; size = 1
_vAttackDir$ = 52					; size = 4
_eBlockType$ = 56					; size = 4
_eProtectionType$ = 60					; size = 4
_fDamage$ = 64						; size = 4
_bContactType$ = 68					; size = 1
_eEscapeCatchType$ = 72					; size = 4
_eBreakType$ = 76					; size = 4
_bStructWeapon$ = 80					; size = 1
?ApplyWeaponWoundedReflect@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_N2AAVioHashString@@AAM244W4AttackSide@@_NABUD3DXVECTOR3@@W4AttackBlockType@@W4ProtectionMode@@46W4EscapeCatchType@@W4DefenseBreakType@@6@Z PROC ; ioBaseChar::ApplyWeaponWoundedReflect, COMDAT
; _this$ = ecx

; 562  : {

  00000	6a 4c		 push	 76			; 0000004cH
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?ApplyWeaponWoundedReflect@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_N2AAVioHashString@@AAM244W4AttackSide@@_NABUD3DXVECTOR3@@W4AttackBlockType@@W4ProtectionMode@@46W4EscapeCatchType@@W4DefenseBreakType@@6@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_GS

; 582  : 	if( iReflectIndex != -1 )

  0000c	8b 55 1c	 mov	 edx, DWORD PTR _fReflectAniRate$[ebp]
  0000f	8b 45 0c	 mov	 eax, DWORD PTR _pAttacker$[ebp]
  00012	8b 7d 08	 mov	 edi, DWORD PTR _pWeapon$[ebp]
  00015	8b 5d 10	 mov	 ebx, DWORD PTR _bStateProtectIgnoreReflect$[ebp]
  00018	89 55 c0	 mov	 DWORD PTR _fReflectAniRate$GSCopy$[ebp], edx
  0001b	8b 55 20	 mov	 edx, DWORD PTR _bPushAttacker$[ebp]
  0001e	89 55 a8	 mov	 DWORD PTR _bPushAttacker$GSCopy$[ebp], edx
  00021	8b 55 24	 mov	 edx, DWORD PTR _fAttackerPushPower$[ebp]
  00024	89 55 cc	 mov	 DWORD PTR _fAttackerPushPower$GSCopy$[ebp], edx
  00027	8b 55 28	 mov	 edx, DWORD PTR _fWeakAttackPushPower$[ebp]

; 593  : 	{
; 594  : 		if( bStateProtectIgnoreReflect )

  0002a	89 55 b4	 mov	 DWORD PTR _fWeakAttackPushPower$GSCopy$[ebp], edx
  0002d	8b 55 34	 mov	 edx, DWORD PTR _vAttackDir$[ebp]
  00030	8b f1		 mov	 esi, ecx
  00032	8b 4d 18	 mov	 ecx, DWORD PTR _szReflectAni$[ebp]
  00035	89 45 d8	 mov	 DWORD PTR _pAttacker$GSCopy$[ebp], eax
  00038	8b 45 14	 mov	 eax, DWORD PTR _bApplyStateProtect$[ebp]
  0003b	89 55 b8	 mov	 DWORD PTR _vAttackDir$GSCopy$[ebp], edx
  0003e	8b 55 40	 mov	 edx, DWORD PTR _fDamage$[ebp]
  00041	89 7d c4	 mov	 DWORD PTR _pWeapon$GSCopy$[ebp], edi
  00044	89 45 d0	 mov	 DWORD PTR _bApplyStateProtect$GSCopy$[ebp], eax
  00047	89 4d b0	 mov	 DWORD PTR _szReflectAni$GSCopy$[ebp], ecx
  0004a	89 55 ac	 mov	 DWORD PTR _fDamage$GSCopy$[ebp], edx
  0004d	85 ff		 test	 edi, edi
  0004f	0f 84 94 04 00
	00		 je	 $LN30@ApplyWeapo@12

; 563  : 	if ( !pWeapon || !pAttacker )

  00055	83 7d d8 00	 cmp	 DWORD PTR _pAttacker$GSCopy$[ebp], 0
  00059	0f 84 8a 04 00
	00		 je	 $LN30@ApplyWeapo@12

; 564  : 		return;
; 565  : 
; 566  : 	bStateProtectIgnoreReflect = false;

  0005f	c6 03 00	 mov	 BYTE PTR [ebx], 0

; 567  : 	bApplyStateProtect = false;

  00062	c6 00 00	 mov	 BYTE PTR [eax], 0

; 568  : 
; 569  : 	szReflectAni.Clear();

  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Clear@ioHashString@@QAEXXZ

; 570  : 	fReflectAniRate = 1.0f;

  0006b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00073	8b 45 c0	 mov	 eax, DWORD PTR _fReflectAniRate$GSCopy$[ebp]

; 571  : 
; 572  : 	bPushAttacker = false;
; 573  : 	fAttackerPushPower = 0.0f;
; 574  : 	fWeakAttackPushPower = pWeapon->GetDefensePushPower( pWeapon->GetDamage(this) );

  00076	8b 4d c4	 mov	 ecx, DWORD PTR _pWeapon$GSCopy$[ebp]
  00079	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  0007d	8b 45 a8	 mov	 eax, DWORD PTR _bPushAttacker$GSCopy$[ebp]
  00080	0f 57 c0	 xorps	 xmm0, xmm0
  00083	c6 00 00	 mov	 BYTE PTR [eax], 0
  00086	8b 45 cc	 mov	 eax, DWORD PTR _fAttackerPushPower$GSCopy$[ebp]
  00089	8b 3f		 mov	 edi, DWORD PTR [edi]
  0008b	56		 push	 esi
  0008c	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00090	ff 97 d4 00 00
	00		 call	 DWORD PTR [edi+212]
  00096	51		 push	 ecx
  00097	8b 4d c4	 mov	 ecx, DWORD PTR _pWeapon$GSCopy$[ebp]
  0009a	d9 1c 24	 fstp	 DWORD PTR [esp]
  0009d	ff 97 88 00 00
	00		 call	 DWORD PTR [edi+136]
  000a3	8b 45 b4	 mov	 eax, DWORD PTR _fWeakAttackPushPower$GSCopy$[ebp]

; 575  : 
; 576  : 	float fAirReflectRate = 1.0f;

  000a6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000ae	d9 18		 fstp	 DWORD PTR [eax]

; 577  : 	bool bAirReflect = false;	
; 578  : 	AttackSide eCheckReflectSide =  AS_NONE;
; 579  : 	bool bEnableEscapeCatchAttackReflect = false;
; 580  : 
; 581  : 	int iReflectIndex = GetReflectInfoIndex( eSide );

  000b0	ff 75 2c	 push	 DWORD PTR _eSide$[ebp]
  000b3	8b ce		 mov	 ecx, esi
  000b5	f3 0f 11 45 bc	 movss	 DWORD PTR _fAirReflectRate$[ebp], xmm0
  000ba	c6 45 df 00	 mov	 BYTE PTR _bAirReflect$[ebp], 0
  000be	33 ff		 xor	 edi, edi
  000c0	c6 45 d7 00	 mov	 BYTE PTR _bEnableEscapeCatchAttackReflect$[ebp], 0
  000c4	e8 00 00 00 00	 call	 ?GetReflectInfoIndex@ioBaseChar@@QAEHW4AttackSide@@@Z ; ioBaseChar::GetReflectInfoIndex
  000c9	89 45 c8	 mov	 DWORD PTR _iReflectIndex$[ebp], eax

; 582  : 	if( iReflectIndex != -1 )

  000cc	83 f8 ff	 cmp	 eax, -1
  000cf	74 32		 je	 SHORT $LN29@ApplyWeapo@12

; 583  : 	{
; 584  : 		fAirReflectRate =  m_vReflectInfoList[iReflectIndex]->m_fAirReflectRate;

  000d1	8b c8		 mov	 ecx, eax
  000d3	8b 86 68 17 00
	00		 mov	 eax, DWORD PTR [esi+5992]
  000d9	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  000dc	f3 0f 10 40 54	 movss	 xmm0, DWORD PTR [eax+84]

; 585  : 		bAirReflect = m_vReflectInfoList[iReflectIndex]->m_bAirReflect;

  000e1	8a 50 58	 mov	 dl, BYTE PTR [eax+88]

; 586  : 		bStateProtectIgnoreReflect = m_vReflectInfoList[iReflectIndex]->m_bStateProtectIgnoreReflect;

  000e4	8a 40 59	 mov	 al, BYTE PTR [eax+89]
  000e7	88 03		 mov	 BYTE PTR [ebx], al

; 587  : 		bEnableEscapeCatchAttackReflect = m_vReflectInfoList[iReflectIndex]->m_bEnableEscapeCatchAttackReflect;

  000e9	8b 86 68 17 00
	00		 mov	 eax, DWORD PTR [esi+5992]
  000ef	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
  000f2	8a 41 5a	 mov	 al, BYTE PTR [ecx+90]

; 588  : 		eCheckReflectSide = m_vReflectInfoList[iReflectIndex]->m_ReflectSideType;

  000f5	8b 79 50	 mov	 edi, DWORD PTR [ecx+80]
  000f8	f3 0f 11 45 bc	 movss	 DWORD PTR _fAirReflectRate$[ebp], xmm0
  000fd	88 55 df	 mov	 BYTE PTR _bAirReflect$[ebp], dl
  00100	88 45 d7	 mov	 BYTE PTR _bEnableEscapeCatchAttackReflect$[ebp], al
$LN29@ApplyWeapo@12:

; 589  : 	}
; 590  : 
; 591  : 	//Reflect Buff StateProtect Buff    
; 592  : 	if ( !pAttacker->IgnoreBlock() )

  00103	8b 4d d8	 mov	 ecx, DWORD PTR _pAttacker$GSCopy$[ebp]
  00106	e8 00 00 00 00	 call	 ?IgnoreBlock@ioBaseChar@@QAE_NXZ ; ioBaseChar::IgnoreBlock
  0010b	84 c0		 test	 al, al
  0010d	75 73		 jne	 SHORT $LN23@ApplyWeapo@12

; 593  : 	{
; 594  : 		if( bStateProtectIgnoreReflect )

  0010f	38 03		 cmp	 BYTE PTR [ebx], al
  00111	74 3e		 je	 SHORT $LN27@ApplyWeapo@12

; 595  : 		{
; 596  : 			if( eCheckReflectSide != AS_NONE && eCheckReflectSide != m_AttackedSide )

  00113	85 ff		 test	 edi, edi
  00115	74 6b		 je	 SHORT $LN23@ApplyWeapo@12
  00117	3b be d4 0e 00
	00		 cmp	 edi, DWORD PTR [esi+3796]
  0011d	74 63		 je	 SHORT $LN23@ApplyWeapo@12

; 597  : 			{
; 598  : 				if( !bOnlyEmoticon )

  0011f	38 45 30	 cmp	 BYTE PTR _bOnlyEmoticon$[ebp], al
  00122	75 18		 jne	 SHORT $LN25@ApplyWeapo@12

; 599  : 					pAttacker->WeakAttackPush( vAttackDir, fWeakAttackPushPower );

  00124	8b 45 b4	 mov	 eax, DWORD PTR _fWeakAttackPushPower$GSCopy$[ebp]
  00127	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0012b	51		 push	 ecx
  0012c	8b 4d d8	 mov	 ecx, DWORD PTR _pAttacker$GSCopy$[ebp]
  0012f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00134	ff 75 b8	 push	 DWORD PTR _vAttackDir$GSCopy$[ebp]
  00137	e8 00 00 00 00	 call	 ?WeakAttackPush@ioBaseChar@@QAEXABUD3DXVECTOR3@@M@Z ; ioBaseChar::WeakAttackPush
$LN25@ApplyWeapo@12:

; 600  : 
; 601  : 				CheckBlockState( eBlockType, eProtectionType );	

  0013c	ff 75 3c	 push	 DWORD PTR _eProtectionType$[ebp]
  0013f	8b ce		 mov	 ecx, esi
  00141	ff 75 38	 push	 DWORD PTR _eBlockType$[ebp]
  00144	e8 00 00 00 00	 call	 ?CheckBlockState@ioBaseChar@@QAEXW4AttackBlockType@@W4ProtectionMode@@@Z ; ioBaseChar::CheckBlockState

; 602  : 				bApplyStateProtect = true;

  00149	8b 45 d0	 mov	 eax, DWORD PTR _bApplyStateProtect$GSCopy$[ebp]
  0014c	c6 00 01	 mov	 BYTE PTR [eax], 1

; 603  : 			}
; 604  : 		}
; 605  : 		else

  0014f	eb 31		 jmp	 SHORT $LN23@ApplyWeapo@12
$LN27@ApplyWeapo@12:

; 606  : 		{
; 607  : 			//      
; 608  : 			if( eBlockType != ATB_NONE )

  00151	83 7d 38 00	 cmp	 DWORD PTR _eBlockType$[ebp], 0
  00155	74 2b		 je	 SHORT $LN23@ApplyWeapo@12

; 609  : 			{
; 610  : 				if( !bOnlyEmoticon )

  00157	80 7d 30 00	 cmp	 BYTE PTR _bOnlyEmoticon$[ebp], 0
  0015b	75 18		 jne	 SHORT $LN22@ApplyWeapo@12

; 611  : 					pAttacker->WeakAttackPush( vAttackDir, fWeakAttackPushPower );

  0015d	8b 45 b4	 mov	 eax, DWORD PTR _fWeakAttackPushPower$GSCopy$[ebp]
  00160	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00164	51		 push	 ecx
  00165	8b 4d d8	 mov	 ecx, DWORD PTR _pAttacker$GSCopy$[ebp]
  00168	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0016d	ff 75 b8	 push	 DWORD PTR _vAttackDir$GSCopy$[ebp]
  00170	e8 00 00 00 00	 call	 ?WeakAttackPush@ioBaseChar@@QAEXABUD3DXVECTOR3@@M@Z ; ioBaseChar::WeakAttackPush
$LN22@ApplyWeapo@12:

; 612  : 
; 613  : 				CheckBlockState( eBlockType, eProtectionType );

  00175	ff 75 3c	 push	 DWORD PTR _eProtectionType$[ebp]
  00178	8b ce		 mov	 ecx, esi
  0017a	ff 75 38	 push	 DWORD PTR _eBlockType$[ebp]
  0017d	e8 00 00 00 00	 call	 ?CheckBlockState@ioBaseChar@@QAEXW4AttackBlockType@@W4ProtectionMode@@@Z ; ioBaseChar::CheckBlockState
$LN23@ApplyWeapo@12:

; 614  : 			}
; 615  : 		}	
; 616  : 	}
; 617  : 
; 618  : 	//---Refelct Start
; 619  : 	if( iReflectIndex != -1 )

  00182	8b 7d c8	 mov	 edi, DWORD PTR _iReflectIndex$[ebp]
  00185	83 ff ff	 cmp	 edi, -1
  00188	0f 84 48 03 00
	00		 je	 $LN4@ApplyWeapo@12

; 620  : 	{
; 621  : 		bool bEnableReflect = false;

  0018e	32 db		 xor	 bl, bl

; 622  : 		if( bEnableEscapeCatchAttackReflect && eEscapeCatchType )

  00190	38 5d d7	 cmp	 BYTE PTR _bEnableEscapeCatchAttackReflect$[ebp], bl
  00193	74 06		 je	 SHORT $LN20@ApplyWeapo@12
  00195	83 7d 48 00	 cmp	 DWORD PTR _eEscapeCatchType$[ebp], 0

; 623  : 			bEnableReflect = true;

  00199	75 06		 jne	 SHORT $LN92@ApplyWeapo@12
$LN20@ApplyWeapo@12:

; 624  : 		else if( bContactType )

  0019b	80 7d 44 00	 cmp	 BYTE PTR _bContactType$[ebp], 0
  0019f	74 02		 je	 SHORT $LN18@ApplyWeapo@12
$LN92@ApplyWeapo@12:

; 625  : 			bEnableReflect = true;

  001a1	b3 01		 mov	 bl, 1
$LN18@ApplyWeapo@12:

; 626  : 
; 627  : 		if( HasBuff( BT_HIT_COUNT_HOLD ) )

  001a3	6a 70		 push	 112			; 00000070H
  001a5	8b ce		 mov	 ecx, esi
  001a7	e8 00 00 00 00	 call	 ?HasBuff@ioBaseChar@@QBE_NH@Z ; ioBaseChar::HasBuff
  001ac	84 c0		 test	 al, al
  001ae	74 02		 je	 SHORT $LN17@ApplyWeapo@12

; 628  : 			bEnableReflect = false;

  001b0	32 db		 xor	 bl, bl
$LN17@ApplyWeapo@12:

; 629  : 
; 630  : 		bool bReflect = false;		
; 631  : 		if( m_CharState != CS_BLOW_WOUNDED &&
; 632  : 			m_CharState != CS_BOUND_BLOW_WOUNDED &&
; 633  : 			m_CharState != CS_BLOW_EXTEND_WOUND &&
; 634  : 			bEnableReflect && !bStructWeapon )

  001b2	8a 86 10 03 00
	00		 mov	 al, BYTE PTR [esi+784]
  001b8	3c 0c		 cmp	 al, 12			; 0000000cH
  001ba	0f 84 73 02 00
	00		 je	 $LN5@ApplyWeapo@12
  001c0	3c 31		 cmp	 al, 49			; 00000031H
  001c2	0f 84 6b 02 00
	00		 je	 $LN5@ApplyWeapo@12
  001c8	3c 46		 cmp	 al, 70			; 00000046H
  001ca	0f 84 63 02 00
	00		 je	 $LN5@ApplyWeapo@12
  001d0	84 db		 test	 bl, bl
  001d2	0f 84 5b 02 00
	00		 je	 $LN5@ApplyWeapo@12
  001d8	80 7d 50 00	 cmp	 BYTE PTR _bStructWeapon$[ebp], 0
  001dc	0f 85 51 02 00
	00		 jne	 $LN5@ApplyWeapo@12

; 635  : 		{
; 636  : 			if ( bAirReflect )

  001e2	80 7d df 00	 cmp	 BYTE PTR _bAirReflect$[ebp], 0

; 637  : 				bReflect = true;
; 638  : 			else

  001e6	75 0f		 jne	 SHORT $LN13@ApplyWeapo@12

; 639  : 			{
; 640  : 				if ( !IsFloating() )

  001e8	8b ce		 mov	 ecx, esi
  001ea	e8 00 00 00 00	 call	 ?IsFloating@ioBaseChar@@QAE_NXZ ; ioBaseChar::IsFloating
  001ef	84 c0		 test	 al, al
  001f1	0f 85 3c 02 00
	00		 jne	 $LN5@ApplyWeapo@12
$LN13@ApplyWeapo@12:

; 641  : 					bReflect = true;
; 642  : 			}
; 643  : 		}
; 644  : 
; 645  : 		if( bReflect )
; 646  : 		{
; 647  : 			if( pAttacker->IsEnableAttackCancelState() )

  001f7	8b 4d d8	 mov	 ecx, DWORD PTR _pAttacker$GSCopy$[ebp]
  001fa	e8 00 00 00 00	 call	 ?IsEnableAttackCancelState@ioBaseChar@@QAE_NXZ ; ioBaseChar::IsEnableAttackCancelState
  001ff	84 c0		 test	 al, al
  00201	0f 84 2c 02 00
	00		 je	 $LN5@ApplyWeapo@12

; 648  : 			{
; 649  : 				//  
; 650  : 				fAttackerPushPower = m_vReflectInfoList[iReflectIndex]->GetReflectPower( fDamage );

  00207	8b 86 68 17 00
	00		 mov	 eax, DWORD PTR [esi+5992]
  0020d	8b 4d ac	 mov	 ecx, DWORD PTR _fDamage$GSCopy$[ebp]
  00210	f3 0f 10 09	 movss	 xmm1, DWORD PTR [ecx]
  00214	8b df		 mov	 ebx, edi
  00216	8b 04 98	 mov	 eax, DWORD PTR [eax+ebx*4]
  00219	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  0021e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00221	0f 5a c9	 cvtps2pd xmm1, xmm1
  00224	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00228	f3 0f 10 48 18	 movss	 xmm1, DWORD PTR [eax+24]
  0022d	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00231	0f 57 db	 xorps	 xmm3, xmm3
  00234	0f 5a d1	 cvtps2pd xmm2, xmm1
  00237	f3 0f 5a d8	 cvtss2sd xmm3, xmm0
  0023b	66 0f 2f d3	 comisd	 xmm2, xmm3
  0023f	76 03		 jbe	 SHORT $LN49@ApplyWeapo@12
  00241	0f 28 c1	 movaps	 xmm0, xmm1
$LN49@ApplyWeapo@12:
  00244	f3 0f 10 48 1c	 movss	 xmm1, DWORD PTR [eax+28]
  00249	0f 57 d2	 xorps	 xmm2, xmm2
  0024c	f3 0f 5a d0	 cvtss2sd xmm2, xmm0
  00250	0f 5a d9	 cvtps2pd xmm3, xmm1
  00253	66 0f 2f da	 comisd	 xmm3, xmm2
  00257	77 03		 ja	 SHORT $LN52@ApplyWeapo@12
  00259	0f 28 c1	 movaps	 xmm0, xmm1
$LN52@ApplyWeapo@12:
  0025c	8b 7d cc	 mov	 edi, DWORD PTR _fAttackerPushPower$GSCopy$[ebp]

; 651  : 
; 652  : 				//     
; 653  : 				szReflectAni = m_vReflectInfoList[iReflectIndex]->m_ReflectAni;

  0025f	8b 4d b0	 mov	 ecx, DWORD PTR _szReflectAni$GSCopy$[ebp]
  00262	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0
  00266	8b 86 68 17 00
	00		 mov	 eax, DWORD PTR [esi+5992]
  0026c	8b 04 98	 mov	 eax, DWORD PTR [eax+ebx*4]
  0026f	83 c0 6c	 add	 eax, 108		; 0000006cH
  00272	50		 push	 eax
  00273	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@ABV0@@Z

; 654  : 				fReflectAniRate = m_vReflectInfoList[iReflectIndex]->m_fReflectAniRate;

  00279	8b 86 68 17 00
	00		 mov	 eax, DWORD PTR [esi+5992]
  0027f	8b 04 98	 mov	 eax, DWORD PTR [eax+ebx*4]
  00282	d9 40 7c	 fld	 DWORD PTR [eax+124]
  00285	8b 45 c0	 mov	 eax, DWORD PTR _fReflectAniRate$GSCopy$[ebp]

; 655  : 
; 656  : 				if( !szReflectAni.IsEmpty() && fReflectAniRate > 0.0f && !pAttacker->IgnoreBlock() )

  00288	8b 4d b0	 mov	 ecx, DWORD PTR _szReflectAni$GSCopy$[ebp]
  0028b	d9 18		 fstp	 DWORD PTR [eax]
  0028d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00293	84 c0		 test	 al, al
  00295	75 34		 jne	 SHORT $LN10@ApplyWeapo@12
  00297	8b 45 c0	 mov	 eax, DWORD PTR _fReflectAniRate$GSCopy$[ebp]
  0029a	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0029e	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  002a5	76 24		 jbe	 SHORT $LN10@ApplyWeapo@12
  002a7	8b 4d d8	 mov	 ecx, DWORD PTR _pAttacker$GSCopy$[ebp]
  002aa	e8 00 00 00 00	 call	 ?IgnoreBlock@ioBaseChar@@QAE_NXZ ; ioBaseChar::IgnoreBlock
  002af	84 c0		 test	 al, al
  002b1	75 18		 jne	 SHORT $LN10@ApplyWeapo@12

; 657  : 				{
; 658  : 					pAttacker->SetEtcState( szReflectAni, fReflectAniRate );

  002b3	8b 45 c0	 mov	 eax, DWORD PTR _fReflectAniRate$GSCopy$[ebp]
  002b6	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  002ba	51		 push	 ecx
  002bb	8b 4d d8	 mov	 ecx, DWORD PTR _pAttacker$GSCopy$[ebp]
  002be	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002c3	ff 75 b0	 push	 DWORD PTR _szReflectAni$GSCopy$[ebp]
  002c6	e8 00 00 00 00	 call	 ?SetEtcState@ioBaseChar@@QAEXABVioHashString@@M@Z ; ioBaseChar::SetEtcState
$LN10@ApplyWeapo@12:

; 659  : 				}
; 660  : 
; 661  : 				//  
; 662  : 				//    
; 663  : 				int iSlot = m_vReflectInfoList[iReflectIndex]->m_iSlot;

  002cb	8b 86 68 17 00
	00		 mov	 eax, DWORD PTR [esi+5992]
  002d1	8b 04 98	 mov	 eax, DWORD PTR [eax+ebx*4]
  002d4	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 664  : 				ioItem *pItem = NULL;
; 665  : 				if( iSlot >= 0 )

  002d7	85 c0		 test	 eax, eax
  002d9	78 5a		 js	 SHORT $LN8@ApplyWeapo@12

; 666  : 				{
; 667  : 					pItem = GetEquipedItem( iSlot );

  002db	50		 push	 eax
  002dc	8b ce		 mov	 ecx, esi
  002de	e8 00 00 00 00	 call	 ?GetEquipedItem@ioBaseChar@@QAEPAVioItem@@H@Z ; ioBaseChar::GetEquipedItem

; 668  : 					if( pItem )

  002e3	85 c0		 test	 eax, eax
  002e5	74 4e		 je	 SHORT $LN8@ApplyWeapo@12

; 669  : 					{
; 670  : 						float fGrowthValue = 0.0f;

  002e7	0f 57 c0	 xorps	 xmm0, xmm0

; 671  : 						ioGrowthNormalUpInfo *pUpInfo = ToNormalUpInfo( pItem->GetGrowthUpInfoByType(GT_REFLECT_PUSH, GetCharName()) );

  002ea	8d 8e d4 02 00
	00		 lea	 ecx, DWORD PTR [esi+724]
  002f0	51		 push	 ecx
  002f1	6a 0a		 push	 10			; 0000000aH
  002f3	8b c8		 mov	 ecx, eax
  002f5	f3 0f 11 45 cc	 movss	 DWORD PTR _fGrowthValue$693779[ebp], xmm0
  002fa	e8 00 00 00 00	 call	 ?GetGrowthUpInfoByType@ioItem@@QAEPAVioGrowthUpInfo@@HABVioHashString@@@Z ; ioItem::GetGrowthUpInfoByType
  002ff	50		 push	 eax
  00300	e8 00 00 00 00	 call	 ?ToNormalUpInfo@@YAPAVioGrowthNormalUpInfo@@PAVioGrowthUpInfo@@@Z ; ToNormalUpInfo
  00305	59		 pop	 ecx

; 672  : 						if( pUpInfo )

  00306	85 c0		 test	 eax, eax
  00308	74 10		 je	 SHORT $LN7@ApplyWeapo@12

; 673  : 							fGrowthValue = pUpInfo->GetValue(m_pCreator);

  0030a	ff b6 44 03 00
	00		 push	 DWORD PTR [esi+836]
  00310	8b c8		 mov	 ecx, eax
  00312	e8 00 00 00 00	 call	 ?GetValue@ioGrowthNormalUpInfo@@QAEMPAVioPlayStage@@@Z ; ioGrowthNormalUpInfo::GetValue
  00317	d9 5d cc	 fstp	 DWORD PTR _fGrowthValue$693779[ebp]
$LN7@ApplyWeapo@12:

; 674  : 
; 675  : 						fAttackerPushPower += fGrowthValue;

  0031a	f3 0f 10 0f	 movss	 xmm1, DWORD PTR [edi]
  0031e	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _fGrowthValue$693779[ebp]
  00323	0f 5a c0	 cvtps2pd xmm0, xmm0
  00326	0f 5a c9	 cvtps2pd xmm1, xmm1
  00329	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0032d	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00331	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0
$LN8@ApplyWeapo@12:

; 676  : 					}
; 677  : 				}
; 678  : 
; 679  : 				if( bAirReflect && pAttacker->IsFloating() )

  00335	80 7d df 00	 cmp	 BYTE PTR _bAirReflect$[ebp], 0
  00339	74 27		 je	 SHORT $LN6@ApplyWeapo@12
  0033b	8b 4d d8	 mov	 ecx, DWORD PTR _pAttacker$GSCopy$[ebp]
  0033e	e8 00 00 00 00	 call	 ?IsFloating@ioBaseChar@@QAE_NXZ ; ioBaseChar::IsFloating
  00343	84 c0		 test	 al, al
  00345	74 1b		 je	 SHORT $LN6@ApplyWeapo@12

; 680  : 				{
; 681  : 					fAttackerPushPower *= fAirReflectRate;

  00347	f3 0f 10 0f	 movss	 xmm1, DWORD PTR [edi]
  0034b	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _fAirReflectRate$[ebp]
  00350	0f 5a c0	 cvtps2pd xmm0, xmm0
  00353	0f 5a c9	 cvtps2pd xmm1, xmm1
  00356	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  0035a	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0035e	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0
$LN6@ApplyWeapo@12:

; 682  : 				}
; 683  : 
; 684  : 				pAttacker->SetLastAttackerName( GetCharName().c_str(), pWeapon->GetWeaponBySkillName() );

  00362	8d 8e d4 02 00
	00		 lea	 ecx, DWORD PTR [esi+724]
  00368	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  0036e	50		 push	 eax
  0036f	8d 4d e0	 lea	 ecx, DWORD PTR $T699935[ebp]
  00372	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  00378	8b 4d c4	 mov	 ecx, DWORD PTR _pWeapon$GSCopy$[ebp]
  0037b	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0037f	e8 00 00 00 00	 call	 ?GetWeaponBySkillName@ioWeapon@@QBEABVioHashString@@XZ ; ioWeapon::GetWeaponBySkillName
  00384	8b 4d d8	 mov	 ecx, DWORD PTR _pAttacker$GSCopy$[ebp]
  00387	50		 push	 eax
  00388	8d 45 e0	 lea	 eax, DWORD PTR $T699935[ebp]
  0038b	50		 push	 eax
  0038c	e8 00 00 00 00	 call	 ?SetLastAttackerName@ioBaseChar@@QAEXABVioHashString@@0@Z ; ioBaseChar::SetLastAttackerName
  00391	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00395	8d 4d e0	 lea	 ecx, DWORD PTR $T699935[ebp]
  00398	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ

; 685  : 				pAttacker->ReverseReflectPush( vAttackDir, fAttackerPushPower );

  0039e	f3 0f 10 07	 movss	 xmm0, DWORD PTR [edi]
  003a2	51		 push	 ecx
  003a3	8b 4d d8	 mov	 ecx, DWORD PTR _pAttacker$GSCopy$[ebp]
  003a6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003ab	ff 75 b8	 push	 DWORD PTR _vAttackDir$GSCopy$[ebp]
  003ae	e8 00 00 00 00	 call	 ?ReverseReflectPush@ioBaseChar@@QAEXABUD3DXVECTOR3@@M@Z ; ioBaseChar::ReverseReflectPush

; 686  : 
; 687  : 				//  
; 688  : 				m_pCreator->CreateMapEffect( m_vReflectInfoList[iReflectIndex]->m_ReflectEffect, GetMidPositionByRate(), GetWorldScale() );

  003b3	b8 05 00 00 00	 mov	 eax, 5
  003b8	89 45 d0	 mov	 DWORD PTR $T699986[ebp], eax
  003bb	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  003c0	8b be 68 17 00
	00		 mov	 edi, DWORD PTR [esi+5992]
  003c6	89 45 bc	 mov	 DWORD PTR $T699990[ebp], eax
  003c9	8b 06		 mov	 eax, DWORD PTR [esi]
  003cb	8b ce		 mov	 ecx, esi
  003cd	ff 50 78	 call	 DWORD PTR [eax+120]
  003d0	db 45 d0	 fild	 DWORD PTR $T699986[ebp]
  003d3	50		 push	 eax
  003d4	8b 45 d0	 mov	 eax, DWORD PTR $T699986[ebp]
  003d7	85 c0		 test	 eax, eax
  003d9	79 06		 jns	 SHORT $LN90@ApplyWeapo@12
  003db	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN90@ApplyWeapo@12:
  003e1	8b 45 bc	 mov	 eax, DWORD PTR $T699990[ebp]
  003e4	db 45 bc	 fild	 DWORD PTR $T699990[ebp]
  003e7	85 c0		 test	 eax, eax
  003e9	79 06		 jns	 SHORT $LN91@ApplyWeapo@12
  003eb	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN91@ApplyWeapo@12:
  003f1	de f9		 fdivp	 ST(1), ST(0)
  003f3	51		 push	 ecx
  003f4	8d 45 e4	 lea	 eax, DWORD PTR $T693784[ebp]
  003f7	8b ce		 mov	 ecx, esi
  003f9	d9 5d d0	 fstp	 DWORD PTR tv716[ebp]
  003fc	d9 45 d0	 fld	 DWORD PTR tv716[ebp]
  003ff	d9 1c 24	 fstp	 DWORD PTR [esp]
  00402	50		 push	 eax
  00403	e8 00 00 00 00	 call	 ?GetMidPositionByRate@ioGameEntity@@QBE?AUD3DXVECTOR3@@M@Z ; ioGameEntity::GetMidPositionByRate
  00408	8b 8e 44 03 00
	00		 mov	 ecx, DWORD PTR [esi+836]
  0040e	50		 push	 eax
  0040f	8b 04 9f	 mov	 eax, DWORD PTR [edi+ebx*4]
  00412	83 c0 5c	 add	 eax, 92			; 0000005cH
  00415	50		 push	 eax
  00416	e8 00 00 00 00	 call	 ?CreateMapEffect@ioPlayStage@@QAEPAVioMapEffect@@ABVioHashString@@ABUD3DXVECTOR3@@1@Z ; ioPlayStage::CreateMapEffect

; 689  : 
; 690  : 				bPushAttacker = true;

  0041b	8b 45 a8	 mov	 eax, DWORD PTR _bPushAttacker$GSCopy$[ebp]
  0041e	c6 00 01	 mov	 BYTE PTR [eax], 1

; 691  : 
; 692  : 				//SkillEvent
; 693  : 				if( IsOwnerChar() )

  00421	80 be 84 13 00
	00 00		 cmp	 BYTE PTR [esi+4996], 0
  00428	74 09		 je	 SHORT $LN5@ApplyWeapo@12

; 694  : 					CheckSkillEvent( BT_REFLECT );

  0042a	6a 0e		 push	 14			; 0000000eH
  0042c	8b ce		 mov	 ecx, esi
  0042e	e8 00 00 00 00	 call	 ?CheckSkillEvent@ioBaseChar@@QAEXH@Z ; ioBaseChar::CheckSkillEvent
$LN5@ApplyWeapo@12:

; 695  : 			}
; 696  : 		}
; 697  : 
; 698  : 		//   
; 699  : 		if( eBreakType == DBT_NONE )

  00433	83 7d 4c 00	 cmp	 DWORD PTR _eBreakType$[ebp], 0
  00437	0f 85 99 00 00
	00		 jne	 $LN4@ApplyWeapo@12

; 700  : 		{
; 701  : 			int iSlot = m_vReflectInfoList[iReflectIndex]->m_iSlot;

  0043d	8b 7d c8	 mov	 edi, DWORD PTR _iReflectIndex$[ebp]
  00440	8b 86 68 17 00
	00		 mov	 eax, DWORD PTR [esi+5992]
  00446	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00449	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 702  : 			float fGrowthValue = 0.0f;

  0044c	0f 57 c0	 xorps	 xmm0, xmm0
  0044f	f3 0f 11 45 c8	 movss	 DWORD PTR _fGrowthValue$693788[ebp], xmm0

; 703  : 			ioItem *pItem = NULL;
; 704  : 			if( iSlot >= 0 )

  00454	85 c0		 test	 eax, eax
  00456	78 37		 js	 SHORT $LN1@ApplyWeapo@12

; 705  : 			{
; 706  : 				pItem = GetEquipedItem( iSlot );

  00458	50		 push	 eax
  00459	8b ce		 mov	 ecx, esi
  0045b	e8 00 00 00 00	 call	 ?GetEquipedItem@ioBaseChar@@QAEPAVioItem@@H@Z ; ioBaseChar::GetEquipedItem

; 707  : 				if( pItem )

  00460	85 c0		 test	 eax, eax
  00462	74 2b		 je	 SHORT $LN1@ApplyWeapo@12

; 708  : 				{
; 709  : 					ioGrowthNormalUpInfo *pUpInfo = ToNormalUpInfo( pItem->GetGrowthUpInfoByType(GT_REFLECT_DAMAGE, GetCharName()) );

  00464	8d 8e d4 02 00
	00		 lea	 ecx, DWORD PTR [esi+724]
  0046a	51		 push	 ecx
  0046b	6a 1f		 push	 31			; 0000001fH
  0046d	8b c8		 mov	 ecx, eax
  0046f	e8 00 00 00 00	 call	 ?GetGrowthUpInfoByType@ioItem@@QAEPAVioGrowthUpInfo@@HABVioHashString@@@Z ; ioItem::GetGrowthUpInfoByType
  00474	50		 push	 eax
  00475	e8 00 00 00 00	 call	 ?ToNormalUpInfo@@YAPAVioGrowthNormalUpInfo@@PAVioGrowthUpInfo@@@Z ; ToNormalUpInfo
  0047a	59		 pop	 ecx

; 710  : 					if( pUpInfo )

  0047b	85 c0		 test	 eax, eax
  0047d	74 10		 je	 SHORT $LN1@ApplyWeapo@12

; 711  : 						fGrowthValue = pUpInfo->GetValue(m_pCreator);

  0047f	ff b6 44 03 00
	00		 push	 DWORD PTR [esi+836]
  00485	8b c8		 mov	 ecx, eax
  00487	e8 00 00 00 00	 call	 ?GetValue@ioGrowthNormalUpInfo@@QAEMPAVioPlayStage@@@Z ; ioGrowthNormalUpInfo::GetValue
  0048c	d9 5d c8	 fstp	 DWORD PTR _fGrowthValue$693788[ebp]
$LN1@ApplyWeapo@12:

; 712  : 				}
; 713  : 			}
; 714  : 
; 715  : 			fDamage *= (m_vReflectInfoList[iReflectIndex]->m_fDecreaseDamageRate - fGrowthValue);

  0048f	8d 45 d0	 lea	 eax, DWORD PTR _value$700012[ebp]
  00492	50		 push	 eax
  00493	8b 86 68 17 00
	00		 mov	 eax, DWORD PTR [esi+5992]
  00499	8b 0c b8	 mov	 ecx, DWORD PTR [eax+edi*4]
  0049c	83 c1 20	 add	 ecx, 32			; 00000020H
  0049f	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  004a4	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _value$700012[ebp]
  004a9	f3 0f 10 4d c8	 movss	 xmm1, DWORD PTR _fGrowthValue$693788[ebp]
  004ae	8b 45 ac	 mov	 eax, DWORD PTR _fDamage$GSCopy$[ebp]
  004b1	0f 5a c0	 cvtps2pd xmm0, xmm0
  004b4	0f 5a c9	 cvtps2pd xmm1, xmm1
  004b7	f2 0f 5c c1	 subsd	 xmm0, xmm1
  004bb	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  004bf	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  004c3	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  004c7	0f 5a c9	 cvtps2pd xmm1, xmm1
  004ca	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  004ce	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  004d2	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
$LN4@ApplyWeapo@12:

; 716  : 		}
; 717  : 	}
; 718  : 	// Reflect End
; 719  : 
; 720  : 	// Reflect Demeage
; 721  : 	CheckReflectDameage( bContactType, bStructWeapon, pAttacker, pWeapon );

  004d6	ff 75 c4	 push	 DWORD PTR _pWeapon$GSCopy$[ebp]
  004d9	8b ce		 mov	 ecx, esi
  004db	ff 75 d8	 push	 DWORD PTR _pAttacker$GSCopy$[ebp]
  004de	ff 75 50	 push	 DWORD PTR _bStructWeapon$[ebp]
  004e1	ff 75 44	 push	 DWORD PTR _bContactType$[ebp]
  004e4	e8 00 00 00 00	 call	 ?CheckReflectDameage@ioBaseChar@@IAEX_N0PAV1@PAVioWeapon@@@Z ; ioBaseChar::CheckReflectDameage
$LN30@ApplyWeapo@12:

; 722  : }

  004e9	e8 00 00 00 00	 call	 __EH_epilog3_GS
  004ee	c2 4c 00	 ret	 76			; 0000004cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ApplyWeaponWoundedReflect@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_N2AAVioHashString@@AAM244W4AttackSide@@_NABUD3DXVECTOR3@@W4AttackBlockType@@W4ProtectionMode@@46W4EscapeCatchType@@W4DefenseBreakType@@6@Z$0:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR $T699935[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$?ApplyWeaponWoundedReflect@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_N2AAVioHashString@@AAM244W4AttackSide@@_NABUD3DXVECTOR3@@W4AttackBlockType@@W4ProtectionMode@@46W4EscapeCatchType@@W4DefenseBreakType@@6@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ApplyWeaponWoundedReflect@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_N2AAVioHashString@@AAM244W4AttackSide@@_NABUD3DXVECTOR3@@W4AttackBlockType@@W4ProtectionMode@@46W4EscapeCatchType@@W4DefenseBreakType@@6@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ApplyWeaponWoundedReflect@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_N2AAVioHashString@@AAM244W4AttackSide@@_NABUD3DXVECTOR3@@W4AttackBlockType@@W4ProtectionMode@@46W4EscapeCatchType@@W4DefenseBreakType@@6@Z ENDP ; ioBaseChar::ApplyWeaponWoundedReflect
PUBLIC	?ApplyWeaponWoundedApplyPushPower@ioBaseChar@@IAEXPAVioWeapon@@AA_N1_N2HW4DefenseBreakType@@W4AttackSide@@W4AttackMethodType@@H2222ABUD3DXVECTOR3@@M@Z ; ioBaseChar::ApplyWeaponWoundedApplyPushPower
EXTRN	?RotateByWeaponCollision@ioBaseChar@@QAEXPAVioWeapon@@@Z:PROC ; ioBaseChar::RotateByWeaponCollision
EXTRN	?SetLastApplyWeapon@ioBaseChar@@QAEXHK@Z:PROC	; ioBaseChar::SetLastApplyWeapon
EXTRN	?GetIgnoreWeaponTime@ioWeapon@@QAEKXZ:PROC	; ioWeapon::GetIgnoreWeaponTime
EXTRN	?IncreaseHitCount@ioDummyBuff@@QAEXXZ:PROC	; ioDummyBuff::IncreaseHitCount
EXTRN	__imp_??9ioHashString@@QBE_NABV0@@Z:PROC
EXTRN	?IncreaseHitCount@ioHitCountHoldBuff2@@QAEXXZ:PROC ; ioHitCountHoldBuff2::IncreaseHitCount
EXTRN	?IncreaseHitCount@ioHitCountHoldBuff@@QAEXXZ:PROC ; ioHitCountHoldBuff::IncreaseHitCount
EXTRN	?RemoveBuffType@ioBaseChar@@QAE_NH_N@Z:PROC	; ioBaseChar::RemoveBuffType
EXTRN	?GetStateProtectHPCancelType@ioBaseChar@@QAEHXZ:PROC ; ioBaseChar::GetStateProtectHPCancelType
EXTRN	?CheckSpecialObjectItemDrop@ioBaseChar@@QAEXXZ:PROC ; ioBaseChar::CheckSpecialObjectItemDrop
EXTRN	?CheckExplosionItemWoundedDrop@ioBaseChar@@QAEXABUD3DXVECTOR3@@_N@Z:PROC ; ioBaseChar::CheckExplosionItemWoundedDrop
EXTRN	?ClearReservedSliding@ioBaseChar@@QAEXXZ:PROC	; ioBaseChar::ClearReservedSliding
EXTRN	?ClearAttackFireTimeAndSkill@ioBaseChar@@QAEXW4ClearAttackFireType@@@Z:PROC ; ioBaseChar::ClearAttackFireTimeAndSkill
; Function compile flags: /Ogsp
;	COMDAT ?ApplyWeaponWoundedApplyPushPower@ioBaseChar@@IAEXPAVioWeapon@@AA_N1_N2HW4DefenseBreakType@@W4AttackSide@@W4AttackMethodType@@H2222ABUD3DXVECTOR3@@M@Z
_TEXT	SEGMENT
_bNoDmgAniNPC$ = -1					; size = 1
_pWeapon$ = 8						; size = 4
_bApplyPushPower$ = 12					; size = 4
_bCharDie$ = 16						; size = 4
_value$700062 = 20					; size = 4
_bFrozenState$ = 20					; size = 1
_value$700066 = 23					; size = 1
_bFrozenBuff$ = 24					; size = 1
_iFrozenType$ = 28					; size = 4
_eBreakType$ = 32					; size = 4
_eAttackSide$ = 36					; size = 4
_eMethodType$ = 40					; size = 4
_iIgnoreProtect$ = 44					; size = 4
_bProtectionMagic$ = 48					; size = 1
_value$700109 = 52					; size = 4
_value$700082 = 52					; size = 4
_value$700074 = 52					; size = 4
_i$693936 = 52						; size = 4
_bTeamAttack$ = 52					; size = 1
_pHitCountHoldBuff2$693971 = 56				; size = 4
_bContactType$ = 56					; size = 1
_bCheckStopMotion$ = 60					; size = 1
_vAttackDir$ = 64					; size = 4
_fDamage$ = 68						; size = 4
?ApplyWeaponWoundedApplyPushPower@ioBaseChar@@IAEXPAVioWeapon@@AA_N1_N2HW4DefenseBreakType@@W4AttackSide@@W4AttackMethodType@@H2222ABUD3DXVECTOR3@@M@Z PROC ; ioBaseChar::ApplyWeaponWoundedApplyPushPower, COMDAT
; _this$ = ecx

; 856  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 857  : 	bApplyPushPower = true;
; 858  : 	bCharDie = false;

  00004	8b 45 10	 mov	 eax, DWORD PTR _bCharDie$[ebp]
  00007	53		 push	 ebx
  00008	8b 5d 0c	 mov	 ebx, DWORD PTR _bApplyPushPower$[ebp]
  0000b	56		 push	 esi
  0000c	8b f1		 mov	 esi, ecx
  0000e	57		 push	 edi
  0000f	c6 03 01	 mov	 BYTE PTR [ebx], 1

; 859  : 
; 860  : 	bool bNoDmgAniNPC = false;
; 861  : 	ioNpcChar *pNpc = ToNpcChar( this );

  00012	56		 push	 esi
  00013	c6 00 00	 mov	 BYTE PTR [eax], 0
  00016	c6 45 ff 00	 mov	 BYTE PTR _bNoDmgAniNPC$[ebp], 0
  0001a	e8 00 00 00 00	 call	 ?ToNpcChar@@YAPAVioNpcChar@@PAVioGameEntity@@@Z ; ToNpcChar
  0001f	8b f8		 mov	 edi, eax
  00021	59		 pop	 ecx

; 862  : 	if( pNpc )

  00022	85 ff		 test	 edi, edi
  00024	74 2f		 je	 SHORT $LN113@ApplyWeapo@13

; 863  : 	{
; 864  : 		if(COMPARE(pNpc->GetNpcType(), NT_BIGTOWER, END_FIXING_NPC))

  00026	8b 07		 mov	 eax, DWORD PTR [edi]
  00028	8b cf		 mov	 ecx, edi
  0002a	ff 90 98 01 00
	00		 call	 DWORD PTR [eax+408]
  00030	83 f8 02	 cmp	 eax, 2
  00033	7c 13		 jl	 SHORT $LN67@ApplyWeapo@13
  00035	8b 07		 mov	 eax, DWORD PTR [edi]
  00037	8b cf		 mov	 ecx, edi
  00039	ff 90 98 01 00
	00		 call	 DWORD PTR [eax+408]
  0003f	83 f8 08	 cmp	 eax, 8
  00042	7d 04		 jge	 SHORT $LN67@ApplyWeapo@13

; 865  : 			bNoDmgAniNPC = true;

  00044	c6 45 ff 01	 mov	 BYTE PTR _bNoDmgAniNPC$[ebp], 1
$LN67@ApplyWeapo@13:

; 866  : 
; 867  : 		if( pNpc->GetNpcProtectType() == ioNpcChar::NPT_NODMGANI)

  00048	83 bf a0 47 00
	00 01		 cmp	 DWORD PTR [edi+18336], 1
  0004f	75 04		 jne	 SHORT $LN113@ApplyWeapo@13

; 868  : 			bNoDmgAniNPC = true;

  00051	c6 45 ff 01	 mov	 BYTE PTR _bNoDmgAniNPC$[ebp], 1
$LN113@ApplyWeapo@13:

; 869  : 	}
; 870  : 
; 871  : 	if( bFrozenState && !bFrozenBuff )

  00055	80 7d 14 00	 cmp	 BYTE PTR _bFrozenState$[ebp], 0
  00059	74 15		 je	 SHORT $LN62@ApplyWeapo@13
  0005b	80 7d 18 00	 cmp	 BYTE PTR _bFrozenBuff$[ebp], 0

; 872  : 		bApplyPushPower = false;

  0005f	74 0c		 je	 SHORT $LN125@ApplyWeapo@13

; 873  : 	else if( bFrozenState && bFrozenBuff )
; 874  : 		if( iFrozenType == ioFrozenBuff::FZT_EXCEPT && eBreakType == DBT_NONE )

  00061	83 7d 1c 01	 cmp	 DWORD PTR _iFrozenType$[ebp], 1
  00065	75 09		 jne	 SHORT $LN62@ApplyWeapo@13
  00067	83 7d 20 00	 cmp	 DWORD PTR _eBreakType$[ebp], 0
  0006b	75 03		 jne	 SHORT $LN62@ApplyWeapo@13
$LN125@ApplyWeapo@13:

; 875  : 			bApplyPushPower = false;

  0006d	c6 03 00	 mov	 BYTE PTR [ebx], 0
$LN62@ApplyWeapo@13:

; 876  : 
; 877  : 	if( (m_ProtectionMode != PM_NONE && iIgnoreProtect != IPT_ALL) ||
; 878  : 		(HasBuff(BT_ABSOLUTE_PROTECTION) && iIgnoreProtect == IPT_NONE) ||
; 879  : 		(HasBuff(BT_NOT_MOVE_PROTECT) && iIgnoreProtect == IPT_NONE) ||
; 880  : 		(IsStateProtect( eAttackSide, eBreakType ) && iIgnoreProtect == IPT_NONE) ||
; 881  : 		(IsRangeProtect(eMethodType) && iIgnoreProtect == IPT_NONE && eBreakType == DBT_NONE) ||
; 882  : 		bProtectionMagic )

  00070	8d 45 14	 lea	 eax, DWORD PTR _value$700062[ebp]
  00073	50		 push	 eax
  00074	8d 8e d8 10 00
	00		 lea	 ecx, DWORD PTR [esi+4312]
  0007a	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4ProtectionMode@@@@QAEXPAW4ProtectionMode@@@Z ; CEncrypt<enum ProtectionMode>::DecryptValueToPool
  0007f	33 ff		 xor	 edi, edi
  00081	39 7d 14	 cmp	 DWORD PTR _value$700062[ebp], edi
  00084	74 0a		 je	 SHORT $LN118@ApplyWeapo@13
  00086	83 7d 2c 01	 cmp	 DWORD PTR _iIgnoreProtect$[ebp], 1
  0008a	0f 85 94 01 00
	00		 jne	 $LN60@ApplyWeapo@13
$LN118@ApplyWeapo@13:
  00090	6a 1d		 push	 29			; 0000001dH
  00092	8b ce		 mov	 ecx, esi
  00094	e8 00 00 00 00	 call	 ?HasBuff@ioBaseChar@@QBE_NH@Z ; ioBaseChar::HasBuff
  00099	84 c0		 test	 al, al
  0009b	74 09		 je	 SHORT $LN121@ApplyWeapo@13
  0009d	39 7d 2c	 cmp	 DWORD PTR _iIgnoreProtect$[ebp], edi
  000a0	0f 84 7e 01 00
	00		 je	 $LN60@ApplyWeapo@13
$LN121@ApplyWeapo@13:
  000a6	6a 48		 push	 72			; 00000048H
  000a8	8b ce		 mov	 ecx, esi
  000aa	e8 00 00 00 00	 call	 ?HasBuff@ioBaseChar@@QBE_NH@Z ; ioBaseChar::HasBuff
  000af	84 c0		 test	 al, al
  000b1	74 09		 je	 SHORT $LN57@ApplyWeapo@13
  000b3	39 7d 2c	 cmp	 DWORD PTR _iIgnoreProtect$[ebp], edi
  000b6	0f 84 68 01 00
	00		 je	 $LN60@ApplyWeapo@13
$LN57@ApplyWeapo@13:
  000bc	8b 7d 20	 mov	 edi, DWORD PTR _eBreakType$[ebp]
  000bf	57		 push	 edi
  000c0	ff 75 24	 push	 DWORD PTR _eAttackSide$[ebp]
  000c3	8b ce		 mov	 ecx, esi
  000c5	e8 00 00 00 00	 call	 ?IsStateProtect@ioBaseChar@@QAE_NW4AttackSide@@W4DefenseBreakType@@@Z ; ioBaseChar::IsStateProtect
  000ca	84 c0		 test	 al, al
  000cc	74 0a		 je	 SHORT $LN56@ApplyWeapo@13
  000ce	83 7d 2c 00	 cmp	 DWORD PTR _iIgnoreProtect$[ebp], 0
  000d2	0f 84 4c 01 00
	00		 je	 $LN60@ApplyWeapo@13
$LN56@ApplyWeapo@13:
  000d8	ff 75 28	 push	 DWORD PTR _eMethodType$[ebp]
  000db	8b ce		 mov	 ecx, esi
  000dd	e8 00 00 00 00	 call	 ?IsRangeProtect@ioBaseChar@@QAE_NW4AttackMethodType@@@Z ; ioBaseChar::IsRangeProtect
  000e2	84 c0		 test	 al, al
  000e4	74 0e		 je	 SHORT $LN119@ApplyWeapo@13
  000e6	83 7d 2c 00	 cmp	 DWORD PTR _iIgnoreProtect$[ebp], 0
  000ea	75 08		 jne	 SHORT $LN119@ApplyWeapo@13
  000ec	85 ff		 test	 edi, edi
  000ee	0f 84 30 01 00
	00		 je	 $LN60@ApplyWeapo@13
$LN119@ApplyWeapo@13:
  000f4	80 7d 30 00	 cmp	 BYTE PTR _bProtectionMagic$[ebp], 0

; 883  : 	{
; 884  : 		bApplyPushPower = false;

  000f8	0f 85 26 01 00
	00		 jne	 $LN60@ApplyWeapo@13

; 885  : 	}
; 886  : 	else if( m_pActiveSkill )

  000fe	33 c9		 xor	 ecx, ecx
  00100	39 8e e0 0d 00
	00		 cmp	 DWORD PTR [esi+3552], ecx
  00106	0f 84 b4 00 00
	00		 je	 $LN53@ApplyWeapo@13

; 887  : 	{
; 888  : 		if( (m_pActiveSkill->IsProtected( pWeapon->GetDefenseBreakType() ) && iIgnoreProtect == IPT_NONE) ||
; 889  : 			HasBuff(BT_ABSOLUTE_PROTECTION) && iIgnoreProtect == IPT_NONE )

  0010c	8b 86 e0 0d 00
	00		 mov	 eax, DWORD PTR [esi+3552]
  00112	8b 4d 08	 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  00115	8b 38		 mov	 edi, DWORD PTR [eax]
  00117	e8 00 00 00 00	 call	 ?GetDefenseBreakType@ioWeapon@@QBE?AW4DefenseBreakType@@XZ ; ioWeapon::GetDefenseBreakType
  0011c	8b 8e e0 0d 00
	00		 mov	 ecx, DWORD PTR [esi+3552]
  00122	50		 push	 eax
  00123	ff 57 0c	 call	 DWORD PTR [edi+12]
  00126	84 c0		 test	 al, al
  00128	74 0a		 je	 SHORT $LN114@ApplyWeapo@13
  0012a	83 7d 2c 00	 cmp	 DWORD PTR _iIgnoreProtect$[ebp], 0
  0012e	0f 84 f0 00 00
	00		 je	 $LN60@ApplyWeapo@13
$LN114@ApplyWeapo@13:
  00134	6a 1d		 push	 29			; 0000001dH
  00136	8b ce		 mov	 ecx, esi
  00138	e8 00 00 00 00	 call	 ?HasBuff@ioBaseChar@@QBE_NH@Z ; ioBaseChar::HasBuff
  0013d	84 c0		 test	 al, al
  0013f	74 0a		 je	 SHORT $LN122@ApplyWeapo@13
  00141	83 7d 2c 00	 cmp	 DWORD PTR _iIgnoreProtect$[ebp], 0

; 890  : 		{
; 891  : 			bApplyPushPower = false;

  00145	0f 84 d9 00 00
	00		 je	 $LN60@ApplyWeapo@13
$LN122@ApplyWeapo@13:

; 892  : 		}
; 893  : 		else if( GetObject() && GetObject()->IsProtectState() && iIgnoreProtect == IPT_NONE )

  0014b	8b ce		 mov	 ecx, esi
  0014d	e8 00 00 00 00	 call	 ?GetObjectA@ioBaseChar@@QBEPAVioObjectItem@@XZ ; ioBaseChar::GetObjectA
  00152	85 c0		 test	 eax, eax
  00154	74 1f		 je	 SHORT $LN48@ApplyWeapo@13
  00156	8b ce		 mov	 ecx, esi
  00158	e8 00 00 00 00	 call	 ?GetObjectA@ioBaseChar@@QBEPAVioObjectItem@@XZ ; ioBaseChar::GetObjectA
  0015d	8b 10		 mov	 edx, DWORD PTR [eax]
  0015f	8b c8		 mov	 ecx, eax
  00161	ff 92 fc 02 00
	00		 call	 DWORD PTR [edx+764]
  00167	84 c0		 test	 al, al
  00169	74 0a		 je	 SHORT $LN48@ApplyWeapo@13
  0016b	83 7d 2c 00	 cmp	 DWORD PTR _iIgnoreProtect$[ebp], 0

; 894  : 		{
; 895  : 			bApplyPushPower = false;

  0016f	0f 84 af 00 00
	00		 je	 $LN60@ApplyWeapo@13
$LN48@ApplyWeapo@13:

; 896  : 		}
; 897  : 		else if( (!m_pActiveSkill->IsProtected( pWeapon->GetDefenseBreakType() ) && iIgnoreProtect == IPT_NONE) && m_pActiveSkill->IsJumpState() )

  00175	8b 86 e0 0d 00
	00		 mov	 eax, DWORD PTR [esi+3552]
  0017b	8b 4d 08	 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  0017e	8b 38		 mov	 edi, DWORD PTR [eax]
  00180	e8 00 00 00 00	 call	 ?GetDefenseBreakType@ioWeapon@@QBE?AW4DefenseBreakType@@XZ ; ioWeapon::GetDefenseBreakType
  00185	8b 8e e0 0d 00
	00		 mov	 ecx, DWORD PTR [esi+3552]
  0018b	50		 push	 eax
  0018c	ff 57 0c	 call	 DWORD PTR [edi+12]
  0018f	84 c0		 test	 al, al
  00191	75 15		 jne	 SHORT $LN46@ApplyWeapo@13
  00193	83 7d 2c 00	 cmp	 DWORD PTR _iIgnoreProtect$[ebp], 0
  00197	75 0f		 jne	 SHORT $LN46@ApplyWeapo@13
  00199	8b 8e e0 0d 00
	00		 mov	 ecx, DWORD PTR [esi+3552]
  0019f	8b 01		 mov	 eax, DWORD PTR [ecx]
  001a1	ff 50 7c	 call	 DWORD PTR [eax+124]
  001a4	84 c0		 test	 al, al

; 898  : 		{
; 899  : 			bApplyPushPower = false;
; 900  : 		}
; 901  : 		else

  001a6	75 7c		 jne	 SHORT $LN60@ApplyWeapo@13
$LN46@ApplyWeapo@13:

; 902  : 		{
; 903  : 			if( !bNoDmgAniNPC )

  001a8	80 7d ff 00	 cmp	 BYTE PTR _bNoDmgAniNPC$[ebp], 0
  001ac	75 79		 jne	 SHORT $LN33@ApplyWeapo@13

; 904  : 			{
; 905  : 				ClearAttackFireTimeAndSkill( CAFT_APPLY_WOUNDED );

  001ae	6a 01		 push	 1
  001b0	8b ce		 mov	 ecx, esi
  001b2	e8 00 00 00 00	 call	 ?ClearAttackFireTimeAndSkill@ioBaseChar@@QAEXW4ClearAttackFireType@@@Z ; ioBaseChar::ClearAttackFireTimeAndSkill

; 906  : 				ClearReservedSliding();

  001b7	8b ce		 mov	 ecx, esi
  001b9	e8 00 00 00 00	 call	 ?ClearReservedSliding@ioBaseChar@@QAEXXZ ; ioBaseChar::ClearReservedSliding

; 907  : 			}
; 908  : 		}		

  001be	eb 67		 jmp	 SHORT $LN33@ApplyWeapo@13
$LN53@ApplyWeapo@13:

; 909  : 	}
; 910  : 	else if( m_CharState == CS_DRINK )

  001c0	8a 86 10 03 00
	00		 mov	 al, BYTE PTR [esi+784]
  001c6	3c 19		 cmp	 al, 25			; 00000019H

; 911  : 	{
; 912  : 		bApplyPushPower = false;

  001c8	74 1b		 je	 SHORT $LN126@ApplyWeapo@13

; 913  : 	}
; 914  : 	else if( bCheckStopMotion && eBreakType == DBT_NONE && iIgnoreProtect == IPT_NONE )

  001ca	38 4d 3c	 cmp	 BYTE PTR _bCheckStopMotion$[ebp], cl
  001cd	74 09		 je	 SHORT $LN123@ApplyWeapo@13
  001cf	3b f9		 cmp	 edi, ecx
  001d1	75 05		 jne	 SHORT $LN123@ApplyWeapo@13
  001d3	39 4d 2c	 cmp	 DWORD PTR _iIgnoreProtect$[ebp], ecx

; 915  : 	{
; 916  : 		bApplyPushPower = false;

  001d6	74 0d		 je	 SHORT $LN126@ApplyWeapo@13
$LN123@ApplyWeapo@13:

; 917  : 	}
; 918  : 	else if( m_CharState == CS_DEFENSE_ATTACK && eBreakType == DBT_NONE && iIgnoreProtect == IPT_NONE )

  001d8	3c 3e		 cmp	 al, 62			; 0000003eH
  001da	75 0d		 jne	 SHORT $LN38@ApplyWeapo@13
  001dc	3b f9		 cmp	 edi, ecx
  001de	75 09		 jne	 SHORT $LN38@ApplyWeapo@13
  001e0	39 4d 2c	 cmp	 DWORD PTR _iIgnoreProtect$[ebp], ecx
  001e3	75 04		 jne	 SHORT $LN38@ApplyWeapo@13
$LN126@ApplyWeapo@13:

; 919  : 	{
; 920  : 		bApplyPushPower = false;

  001e5	88 0b		 mov	 BYTE PTR [ebx], cl
  001e7	eb 3e		 jmp	 SHORT $LN33@ApplyWeapo@13
$LN38@ApplyWeapo@13:

; 921  : 	}
; 922  : 	else if( IsBuffProtect() && iIgnoreProtect == IPT_NONE )

  001e9	8b ce		 mov	 ecx, esi
  001eb	e8 00 00 00 00	 call	 ?IsBuffProtect@ioBaseChar@@QAE_NXZ ; ioBaseChar::IsBuffProtect
  001f0	84 c0		 test	 al, al
  001f2	74 06		 je	 SHORT $LN120@ApplyWeapo@13
  001f4	83 7d 2c 00	 cmp	 DWORD PTR _iIgnoreProtect$[ebp], 0

; 923  : 	{
; 924  : 		bApplyPushPower = false;

  001f8	74 2a		 je	 SHORT $LN60@ApplyWeapo@13
$LN120@ApplyWeapo@13:

; 925  : 	}
; 926  : 	else if( GetObject() )

  001fa	8b ce		 mov	 ecx, esi
  001fc	e8 00 00 00 00	 call	 ?GetObjectA@ioBaseChar@@QBEPAVioObjectItem@@XZ ; ioBaseChar::GetObjectA
  00201	85 c0		 test	 eax, eax
  00203	74 22		 je	 SHORT $LN33@ApplyWeapo@13

; 927  : 	{
; 928  : 		ioObjectItem *pObject = GetObject();

  00205	8b ce		 mov	 ecx, esi
  00207	e8 00 00 00 00	 call	 ?GetObjectA@ioBaseChar@@QBEPAVioObjectItem@@XZ ; ioBaseChar::GetObjectA

; 929  : 		if( pObject && pObject->IsProtectState() && iIgnoreProtect == IPT_NONE )

  0020c	85 c0		 test	 eax, eax
  0020e	74 17		 je	 SHORT $LN33@ApplyWeapo@13
  00210	8b 10		 mov	 edx, DWORD PTR [eax]
  00212	8b c8		 mov	 ecx, eax
  00214	ff 92 fc 02 00
	00		 call	 DWORD PTR [edx+764]
  0021a	84 c0		 test	 al, al
  0021c	74 09		 je	 SHORT $LN33@ApplyWeapo@13
  0021e	83 7d 2c 00	 cmp	 DWORD PTR _iIgnoreProtect$[ebp], 0
  00222	75 03		 jne	 SHORT $LN33@ApplyWeapo@13
$LN60@ApplyWeapo@13:

; 930  : 			bApplyPushPower = false;

  00224	c6 03 00	 mov	 BYTE PTR [ebx], 0
$LN33@ApplyWeapo@13:

; 931  : 	}
; 932  : 	//
; 933  : 	if( m_bPrisonerMode && bTeamAttack )

  00227	8d 45 17	 lea	 eax, DWORD PTR _value$700066[ebp]
  0022a	50		 push	 eax
  0022b	8d 8e cc 14 00
	00		 lea	 ecx, DWORD PTR [esi+5324]
  00231	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  00236	80 7d 17 00	 cmp	 BYTE PTR _value$700066[ebp], 0
  0023a	74 06		 je	 SHORT $LN32@ApplyWeapo@13
  0023c	80 7d 34 00	 cmp	 BYTE PTR _bTeamAttack$[ebp], 0

; 934  : 	{
; 935  : 		if( bContactType )
; 936  : 			bApplyPushPower = false;
; 937  : 	}

  00240	75 0f		 jne	 SHORT $LN127@ApplyWeapo@13
$LN32@ApplyWeapo@13:

; 938  : 	else if( m_bCatchState && bTeamAttack )

  00242	80 be 78 23 00
	00 00		 cmp	 BYTE PTR [esi+9080], 0
  00249	74 0f		 je	 SHORT $LN28@ApplyWeapo@13
  0024b	80 7d 34 00	 cmp	 BYTE PTR _bTeamAttack$[ebp], 0
  0024f	74 09		 je	 SHORT $LN28@ApplyWeapo@13
$LN127@ApplyWeapo@13:

; 939  : 	{
; 940  : 		if( bContactType )

  00251	80 7d 38 00	 cmp	 BYTE PTR _bContactType$[ebp], 0
  00255	74 03		 je	 SHORT $LN28@ApplyWeapo@13

; 941  : 			bApplyPushPower = false;

  00257	c6 03 00	 mov	 BYTE PTR [ebx], 0
$LN28@ApplyWeapo@13:

; 942  : 	}
; 943  : 
; 944  : 	// Enable Side Check Applypuspower
; 945  : 	EnableSideType eSideType = pWeapon->GetEnableSideType();

  0025a	8b 4d 08	 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  0025d	e8 00 00 00 00	 call	 ?GetEnableSideType@ioWeapon@@QBE?AW4EnableSideType@@XZ ; ioWeapon::GetEnableSideType

; 946  : 	switch( eSideType )

  00262	48		 dec	 eax
  00263	74 0c		 je	 SHORT $LN25@ApplyWeapo@13
  00265	48		 dec	 eax
  00266	75 15		 jne	 SHORT $LN115@ApplyWeapo@13

; 951  : 		break;
; 952  : 	case EST_BACK:
; 953  : 		if( m_AttackedSide == AS_FRONT )

  00268	83 be d4 0e 00
	00 01		 cmp	 DWORD PTR [esi+3796], 1

; 954  : 			bApplyPushPower = false;
; 955  : 		break;

  0026f	eb 07		 jmp	 SHORT $LN128@ApplyWeapo@13
$LN25@ApplyWeapo@13:

; 947  : 	{
; 948  : 	case EST_FRONT:
; 949  : 		if( m_AttackedSide == AS_BACK )

  00271	83 be d4 0e 00
	00 02		 cmp	 DWORD PTR [esi+3796], 2
$LN128@ApplyWeapo@13:
  00278	75 03		 jne	 SHORT $LN115@ApplyWeapo@13

; 950  : 			bApplyPushPower = false;

  0027a	c6 03 00	 mov	 BYTE PTR [ebx], 0
$LN115@ApplyWeapo@13:

; 956  : 	}
; 957  : 
; 958  : 	if( bApplyPushPower )
; 959  : 	{
; 960  : 		CheckExplosionItemWoundedDrop( m_vMoveDir, false );

  0027d	33 ff		 xor	 edi, edi
  0027f	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  00282	74 16		 je	 SHORT $LN21@ApplyWeapo@13
  00284	57		 push	 edi
  00285	8d 86 b4 06 00
	00		 lea	 eax, DWORD PTR [esi+1716]
  0028b	50		 push	 eax
  0028c	8b ce		 mov	 ecx, esi
  0028e	e8 00 00 00 00	 call	 ?CheckExplosionItemWoundedDrop@ioBaseChar@@QAEXABUD3DXVECTOR3@@_N@Z ; ioBaseChar::CheckExplosionItemWoundedDrop

; 961  : 		CheckSpecialObjectItemDrop();

  00293	8b ce		 mov	 ecx, esi
  00295	e8 00 00 00 00	 call	 ?CheckSpecialObjectItemDrop@ioBaseChar@@QAEXXZ ; ioBaseChar::CheckSpecialObjectItemDrop
$LN21@ApplyWeapo@13:

; 962  : 	}
; 963  : 
; 964  : 	//    HP Zero  .
; 965  : 	if( IsStateProtect( eAttackSide, eBreakType ) && iIgnoreProtect == IPT_NONE ) //  

  0029a	ff 75 20	 push	 DWORD PTR _eBreakType$[ebp]
  0029d	8b ce		 mov	 ecx, esi
  0029f	ff 75 24	 push	 DWORD PTR _eAttackSide$[ebp]
  002a2	e8 00 00 00 00	 call	 ?IsStateProtect@ioBaseChar@@QAE_NW4AttackSide@@W4DefenseBreakType@@@Z ; ioBaseChar::IsStateProtect
  002a7	84 c0		 test	 al, al
  002a9	74 36		 je	 SHORT $LN117@ApplyWeapo@13
  002ab	39 7d 2c	 cmp	 DWORD PTR _iIgnoreProtect$[ebp], edi
  002ae	75 31		 jne	 SHORT $LN117@ApplyWeapo@13

; 966  : 	{
; 967  : 		int iHPCancelType = GetStateProtectHPCancelType();

  002b0	8b ce		 mov	 ecx, esi
  002b2	e8 00 00 00 00	 call	 ?GetStateProtectHPCancelType@ioBaseChar@@QAEHXZ ; ioBaseChar::GetStateProtectHPCancelType

; 968  : 		if( iHPCancelType == ioStateProtectionBuff::HPT_ZERO_CANCEL &&
; 969  : 			(m_HP.m_fCurValue <= 0.0f && fDamage > 0.0f) )

  002b7	83 f8 01	 cmp	 eax, 1
  002ba	75 25		 jne	 SHORT $LN117@ApplyWeapo@13
  002bc	8d 45 34	 lea	 eax, DWORD PTR _value$700074[ebp]
  002bf	50		 push	 eax
  002c0	8d 8e c0 00 00
	00		 lea	 ecx, DWORD PTR [esi+192]
  002c6	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  002cb	0f 57 c0	 xorps	 xmm0, xmm0
  002ce	0f 2f 45 34	 comiss	 xmm0, DWORD PTR _value$700074[ebp]
  002d2	72 0d		 jb	 SHORT $LN117@ApplyWeapo@13
  002d4	f3 0f 10 4d 44	 movss	 xmm1, DWORD PTR _fDamage$[ebp]
  002d9	0f 2f c8	 comiss	 xmm1, xmm0
  002dc	76 03		 jbe	 SHORT $LN117@ApplyWeapo@13

; 970  : 		{
; 971  : 			bApplyPushPower = true;

  002de	c6 03 01	 mov	 BYTE PTR [ebx], 1
$LN117@ApplyWeapo@13:

; 972  : 		}
; 973  : 	}
; 974  : 
; 975  : 	if( IsRangeProtect(eMethodType) && iIgnoreProtect == IPT_NONE && eBreakType == DBT_NONE )

  002e1	ff 75 28	 push	 DWORD PTR _eMethodType$[ebp]
  002e4	8b ce		 mov	 ecx, esi
  002e6	e8 00 00 00 00	 call	 ?IsRangeProtect@ioBaseChar@@QAE_NW4AttackMethodType@@@Z ; ioBaseChar::IsRangeProtect
  002eb	84 c0		 test	 al, al
  002ed	74 2f		 je	 SHORT $LN106@ApplyWeapo@13
  002ef	39 7d 2c	 cmp	 DWORD PTR _iIgnoreProtect$[ebp], edi
  002f2	75 2a		 jne	 SHORT $LN106@ApplyWeapo@13
  002f4	39 7d 20	 cmp	 DWORD PTR _eBreakType$[ebp], edi
  002f7	75 25		 jne	 SHORT $LN106@ApplyWeapo@13

; 976  : 	{
; 977  : 		if( m_HP.m_fCurValue <= 0.0f && fDamage > 0.0f )

  002f9	8d 45 34	 lea	 eax, DWORD PTR _value$700082[ebp]
  002fc	50		 push	 eax
  002fd	8d 8e c0 00 00
	00		 lea	 ecx, DWORD PTR [esi+192]
  00303	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  00308	0f 57 c0	 xorps	 xmm0, xmm0
  0030b	0f 2f 45 34	 comiss	 xmm0, DWORD PTR _value$700082[ebp]
  0030f	72 0d		 jb	 SHORT $LN106@ApplyWeapo@13
  00311	f3 0f 10 4d 44	 movss	 xmm1, DWORD PTR _fDamage$[ebp]
  00316	0f 2f c8	 comiss	 xmm1, xmm0
  00319	76 03		 jbe	 SHORT $LN106@ApplyWeapo@13

; 978  : 			bApplyPushPower = true;

  0031b	c6 03 01	 mov	 BYTE PTR [ebx], 1
$LN106@ApplyWeapo@13:

; 979  : 	}
; 980  : 
; 981  : 	//   
; 982  : 	if( bApplyPushPower && HasBuff(BT_RANGE_PROTECT_BUFF) && eBreakType != DBT_NONE )

  0031e	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  00321	74 1d		 je	 SHORT $LN108@ApplyWeapo@13
  00323	6a 3f		 push	 63			; 0000003fH
  00325	8b ce		 mov	 ecx, esi
  00327	e8 00 00 00 00	 call	 ?HasBuff@ioBaseChar@@QBE_NH@Z ; ioBaseChar::HasBuff
  0032c	84 c0		 test	 al, al
  0032e	74 10		 je	 SHORT $LN108@ApplyWeapo@13
  00330	39 7d 20	 cmp	 DWORD PTR _eBreakType$[ebp], edi
  00333	74 0b		 je	 SHORT $LN108@ApplyWeapo@13

; 983  : 		RemoveBuffType( BT_RANGE_PROTECT_BUFF );

  00335	6a 01		 push	 1
  00337	6a 3f		 push	 63			; 0000003fH
  00339	8b ce		 mov	 ecx, esi
  0033b	e8 00 00 00 00	 call	 ?RemoveBuffType@ioBaseChar@@QAE_NH_N@Z ; ioBaseChar::RemoveBuffType
$LN108@ApplyWeapo@13:

; 984  : 
; 985  : 	//---Buff 
; 986  : 	for( int i=0; i<m_aBuffArray->MaxCount(); i++ )

  00340	8b 8e 7c 06 00
	00		 mov	 ecx, DWORD PTR [esi+1660]
  00346	89 7d 34	 mov	 DWORD PTR _i$693936[ebp], edi
  00349	39 79 04	 cmp	 DWORD PTR [ecx+4], edi
  0034c	0f 8e eb 00 00
	00		 jle	 $LN13@ApplyWeapo@13
$LL15@ApplyWeapo@13:

; 987  : 	{
; 988  : 		ioBuff *pBuff = m_aBuffArray->GetAt(i);

  00352	ff 75 34	 push	 DWORD PTR _i$693936[ebp]
  00355	e8 00 00 00 00	 call	 ?GetAt@?$ioTPtrGrowArray@VioBuff@@@@QBEPAVioBuff@@H@Z ; ioTPtrGrowArray<ioBuff>::GetAt
  0035a	8b f8		 mov	 edi, eax

; 989  : 		if( pBuff && pBuff->UseActiveCount() && (pBuff->GetTypeID() == BT_STATE_PROTECTION || pBuff->GetTypeID() == BT_STATE_PROTECTION_BY_PASSIVE || pBuff->GetTypeID() == BT_WINDLORD) )

  0035c	85 ff		 test	 edi, edi
  0035e	74 29		 je	 SHORT $LN12@ApplyWeapo@13
  00360	8b 07		 mov	 eax, DWORD PTR [edi]
  00362	8b cf		 mov	 ecx, edi
  00364	ff 50 54	 call	 DWORD PTR [eax+84]
  00367	84 c0		 test	 al, al
  00369	74 1e		 je	 SHORT $LN12@ApplyWeapo@13
  0036b	8b 87 cc 03 00
	00		 mov	 eax, DWORD PTR [edi+972]
  00371	83 f8 23	 cmp	 eax, 35			; 00000023H
  00374	74 0c		 je	 SHORT $LN11@ApplyWeapo@13
  00376	3d 9c 00 00 00	 cmp	 eax, 156		; 0000009cH
  0037b	74 05		 je	 SHORT $LN11@ApplyWeapo@13
  0037d	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  00380	75 07		 jne	 SHORT $LN12@ApplyWeapo@13
$LN11@ApplyWeapo@13:

; 990  : 			pBuff->CheckActiveCount();

  00382	8b 07		 mov	 eax, DWORD PTR [edi]
  00384	8b cf		 mov	 ecx, edi
  00386	ff 50 58	 call	 DWORD PTR [eax+88]
$LN12@ApplyWeapo@13:

; 991  : 
; 992  : 		ioHitCountHoldBuff *pHitCountHoldBuff = ToHitCountHoldBuff( pBuff );

  00389	57		 push	 edi
  0038a	e8 00 00 00 00	 call	 ?ToHitCountHoldBuff@@YAPAVioHitCountHoldBuff@@PAVioBuff@@@Z ; ToHitCountHoldBuff

; 993  : 		ioHitCountHoldBuff2 *pHitCountHoldBuff2 = ToHitCountHoldBuff2( pBuff );

  0038f	57		 push	 edi
  00390	8b d8		 mov	 ebx, eax
  00392	e8 00 00 00 00	 call	 ?ToHitCountHoldBuff2@@YAPAVioHitCountHoldBuff2@@PAVioBuff@@@Z ; ToHitCountHoldBuff2

; 994  : 		ioDummyBuff *pDummyBuff = ToDummyBuff( pBuff );

  00397	57		 push	 edi
  00398	89 45 38	 mov	 DWORD PTR _pHitCountHoldBuff2$693971[ebp], eax
  0039b	e8 00 00 00 00	 call	 ?ToDummyBuff@@YAPAVioDummyBuff@@PAVioBuff@@@Z ; ToDummyBuff
  003a0	83 c4 0c	 add	 esp, 12			; 0000000cH
  003a3	8b f8		 mov	 edi, eax

; 995  : 		if( pHitCountHoldBuff && bApplyPushPower && fDamage > 0.0f )

  003a5	85 db		 test	 ebx, ebx
  003a7	74 1f		 je	 SHORT $LN111@ApplyWeapo@13
  003a9	8b 45 0c	 mov	 eax, DWORD PTR _bApplyPushPower$[ebp]
  003ac	80 38 00	 cmp	 BYTE PTR [eax], 0
  003af	74 17		 je	 SHORT $LN111@ApplyWeapo@13
  003b1	f3 0f 10 45 44	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  003b6	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  003bd	76 09		 jbe	 SHORT $LN111@ApplyWeapo@13

; 996  : 			pHitCountHoldBuff->IncreaseHitCount();

  003bf	8b cb		 mov	 ecx, ebx
  003c1	e8 00 00 00 00	 call	 ?IncreaseHitCount@ioHitCountHoldBuff@@QAEXXZ ; ioHitCountHoldBuff::IncreaseHitCount
  003c6	eb 60		 jmp	 SHORT $LN14@ApplyWeapo@13
$LN111@ApplyWeapo@13:

; 997  : 		else if( pHitCountHoldBuff2 && bApplyPushPower && fDamage > 0.0f )

  003c8	8b 4d 38	 mov	 ecx, DWORD PTR _pHitCountHoldBuff2$693971[ebp]
  003cb	85 c9		 test	 ecx, ecx
  003cd	74 1d		 je	 SHORT $LN8@ApplyWeapo@13
  003cf	8b 45 0c	 mov	 eax, DWORD PTR _bApplyPushPower$[ebp]
  003d2	80 38 00	 cmp	 BYTE PTR [eax], 0
  003d5	74 15		 je	 SHORT $LN8@ApplyWeapo@13
  003d7	f3 0f 10 45 44	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  003dc	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  003e3	76 07		 jbe	 SHORT $LN8@ApplyWeapo@13

; 998  : 			pHitCountHoldBuff2->IncreaseHitCount();

  003e5	e8 00 00 00 00	 call	 ?IncreaseHitCount@ioHitCountHoldBuff2@@QAEXXZ ; ioHitCountHoldBuff2::IncreaseHitCount
  003ea	eb 3c		 jmp	 SHORT $LN14@ApplyWeapo@13
$LN8@ApplyWeapo@13:

; 999  : 		else if( pWeapon && pDummyBuff && pDummyBuff->GetCreatorName() != pWeapon->GetOwnerName() && bApplyPushPower && fDamage > 0.0f )

  003ec	8b 45 08	 mov	 eax, DWORD PTR _pWeapon$[ebp]
  003ef	85 c0		 test	 eax, eax
  003f1	74 35		 je	 SHORT $LN14@ApplyWeapo@13
  003f3	85 ff		 test	 edi, edi
  003f5	74 31		 je	 SHORT $LN14@ApplyWeapo@13
  003f7	83 c0 10	 add	 eax, 16			; 00000010H
  003fa	50		 push	 eax
  003fb	8d 8f 88 02 00
	00		 lea	 ecx, DWORD PTR [edi+648]
  00401	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??9ioHashString@@QBE_NABV0@@Z
  00407	84 c0		 test	 al, al
  00409	74 1d		 je	 SHORT $LN14@ApplyWeapo@13
  0040b	8b 45 0c	 mov	 eax, DWORD PTR _bApplyPushPower$[ebp]
  0040e	80 38 00	 cmp	 BYTE PTR [eax], 0
  00411	74 15		 je	 SHORT $LN14@ApplyWeapo@13
  00413	f3 0f 10 45 44	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  00418	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0041f	76 07		 jbe	 SHORT $LN14@ApplyWeapo@13

; 1000 : 			pDummyBuff->IncreaseHitCount();

  00421	8b cf		 mov	 ecx, edi
  00423	e8 00 00 00 00	 call	 ?IncreaseHitCount@ioDummyBuff@@QAEXXZ ; ioDummyBuff::IncreaseHitCount
$LN14@ApplyWeapo@13:

; 984  : 
; 985  : 	//---Buff 
; 986  : 	for( int i=0; i<m_aBuffArray->MaxCount(); i++ )

  00428	ff 45 34	 inc	 DWORD PTR _i$693936[ebp]
  0042b	8b 8e 7c 06 00
	00		 mov	 ecx, DWORD PTR [esi+1660]
  00431	8b 45 34	 mov	 eax, DWORD PTR _i$693936[ebp]
  00434	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00437	0f 8c 15 ff ff
	ff		 jl	 $LL15@ApplyWeapo@13
$LN13@ApplyWeapo@13:

; 1001 : 	}	
; 1002 : 
; 1003 : 	// last applyweapon check
; 1004 : 	if( bApplyPushPower || fDamage > 0.0f )

  0043d	8b 7d 0c	 mov	 edi, DWORD PTR _bApplyPushPower$[ebp]
  00440	80 3f 00	 cmp	 BYTE PTR [edi], 0
  00443	75 0e		 jne	 SHORT $LN4@ApplyWeapo@13
  00445	f3 0f 10 45 44	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  0044a	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00451	76 19		 jbe	 SHORT $LN112@ApplyWeapo@13
$LN4@ApplyWeapo@13:

; 1005 : 		SetLastApplyWeapon( pWeapon->GetAttributeIndex(), pWeapon->GetIgnoreWeaponTime() );

  00453	8b 4d 08	 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  00456	e8 00 00 00 00	 call	 ?GetIgnoreWeaponTime@ioWeapon@@QAEKXZ ; ioWeapon::GetIgnoreWeaponTime
  0045b	8b 4d 08	 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  0045e	50		 push	 eax
  0045f	e8 00 00 00 00	 call	 ?GetAttributeIndex@ioWeapon@@QBEHXZ ; ioWeapon::GetAttributeIndex
  00464	50		 push	 eax
  00465	8b ce		 mov	 ecx, esi
  00467	e8 00 00 00 00	 call	 ?SetLastApplyWeapon@ioBaseChar@@QAEXHK@Z ; ioBaseChar::SetLastApplyWeapon
$LN112@ApplyWeapo@13:

; 1006 : 
; 1007 : 	if( bNoDmgAniNPC )

  0046c	80 7d ff 00	 cmp	 BYTE PTR _bNoDmgAniNPC$[ebp], 0
  00470	74 2b		 je	 SHORT $LN3@ApplyWeapo@13

; 1008 : 	{
; 1009 : 		if( m_HP.m_fCurValue <= 0.0f && fDamage > 0.0f)

  00472	8d 45 34	 lea	 eax, DWORD PTR _value$700109[ebp]
  00475	50		 push	 eax
  00476	8d 8e c0 00 00
	00		 lea	 ecx, DWORD PTR [esi+192]
  0047c	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  00481	0f 57 c0	 xorps	 xmm0, xmm0
  00484	0f 2f 45 34	 comiss	 xmm0, DWORD PTR _value$700109[ebp]
  00488	72 10		 jb	 SHORT $LN2@ApplyWeapo@13
  0048a	f3 0f 10 4d 44	 movss	 xmm1, DWORD PTR _fDamage$[ebp]
  0048f	0f 2f c8	 comiss	 xmm1, xmm0
  00492	76 06		 jbe	 SHORT $LN2@ApplyWeapo@13

; 1010 : 			bCharDie = true;

  00494	8b 45 10	 mov	 eax, DWORD PTR _bCharDie$[ebp]
  00497	c6 00 01	 mov	 BYTE PTR [eax], 1
$LN2@ApplyWeapo@13:

; 1011 : 
; 1012 : 		bApplyPushPower = false;

  0049a	c6 07 00	 mov	 BYTE PTR [edi], 0
$LN3@ApplyWeapo@13:

; 1013 : 	}
; 1014 : 
; 1015 : 	//---  
; 1016 : 	if( bApplyPushPower )

  0049d	80 3f 00	 cmp	 BYTE PTR [edi], 0
  004a0	74 0a		 je	 SHORT $LN1@ApplyWeapo@13

; 1017 : 		RotateByWeaponCollision( pWeapon );

  004a2	ff 75 08	 push	 DWORD PTR _pWeapon$[ebp]
  004a5	8b ce		 mov	 ecx, esi
  004a7	e8 00 00 00 00	 call	 ?RotateByWeaponCollision@ioBaseChar@@QAEXPAVioWeapon@@@Z ; ioBaseChar::RotateByWeaponCollision
$LN1@ApplyWeapo@13:
  004ac	5f		 pop	 edi
  004ad	5e		 pop	 esi
  004ae	5b		 pop	 ebx

; 1018 : }

  004af	c9		 leave
  004b0	c2 40 00	 ret	 64			; 00000040H
?ApplyWeaponWoundedApplyPushPower@ioBaseChar@@IAEXPAVioWeapon@@AA_N1_N2HW4DefenseBreakType@@W4AttackSide@@W4AttackMethodType@@H2222ABUD3DXVECTOR3@@M@Z ENDP ; ioBaseChar::ApplyWeaponWoundedApplyPushPower
_TEXT	ENDS
PUBLIC	_fBlowPower$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?ApplyWeaponWoundedPushBlowPower@ioBaseChar@@IAEXPAVioWeapon@@_NABUD3DXVECTOR3@@MAAM1@Z ; ioBaseChar::ApplyWeaponWoundedPushBlowPower
EXTRN	?SetJumpPower@ioBaseChar@@QAEXM@Z:PROC		; ioBaseChar::SetJumpPower
EXTRN	?SetForcePower@ioBaseChar@@QAEXABUD3DXVECTOR3@@MM_N@Z:PROC ; ioBaseChar::SetForcePower
EXTRN	__imp_??D@YA?AUD3DXVECTOR3@@ABUD3DXQUATERNION@@ABU0@@Z:PROC
EXTRN	_D3DXQuaternionRotationAxis@12:PROC
EXTRN	__imp_?VEC3_ZERO@ioMath@@2UD3DXVECTOR3@@A:BYTE
EXTRN	_D3DXVec3Normalize@8:PROC
EXTRN	__imp_?UNIT_Y@ioMath@@2UD3DXVECTOR3@@A:BYTE
EXTRN	?SetCurSpeedToForcePower@ioBaseChar@@QAEXM@Z:PROC ; ioBaseChar::SetCurSpeedToForcePower
EXTRN	___security_cookie:DWORD
; Function compile flags: /Ogsp
;	COMDAT ?ApplyWeaponWoundedPushBlowPower@ioBaseChar@@IAEXPAVioWeapon@@_NABUD3DXVECTOR3@@MAAM1@Z
_TEXT	SEGMENT
_qtRot$694221 = -76					; size = 16
_fPushAngle$694216 = -60				; size = 4
_fBlowPower$GSCopy$ = -56				; size = 4
_v$700178 = -52						; size = 12
$T694228 = -52						; size = 12
_vAxis1$694219 = -40					; size = 12
_v$700167 = -28						; size = 12
_vAxis2$694220 = -28					; size = 12
_vPushDir$694217 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_pWeapon$ = 8						; size = 4
_bApplyPushPower$ = 12					; size = 1
_vAttackDir$ = 16					; size = 4
_fPushPower$ = 20					; size = 4
_fBlowPower$ = 24					; size = 4
_bForceLinear$ = 28					; size = 1
?ApplyWeaponWoundedPushBlowPower@ioBaseChar@@IAEXPAVioWeapon@@_NABUD3DXVECTOR3@@MAAM1@Z PROC ; ioBaseChar::ApplyWeaponWoundedPushBlowPower, COMDAT
; _this$ = ecx

; 1461 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 18	 mov	 eax, DWORD PTR _fBlowPower$[ebp]
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 10	 mov	 esi, DWORD PTR _vAttackDir$[ebp]
  00018	57		 push	 edi
  00019	8b 7d 08	 mov	 edi, DWORD PTR _pWeapon$[ebp]
  0001c	8b d9		 mov	 ebx, ecx

; 1495 : 
; 1496 : 		SetJumpPower( fBlowPower );

  0001e	89 45 c8	 mov	 DWORD PTR _fBlowPower$GSCopy$[ebp], eax
  00021	85 ff		 test	 edi, edi
  00023	0f 84 38 03 00
	00		 je	 $LN1@ApplyWeapo@14

; 1462 : 	if ( !pWeapon )
; 1463 : 		return;
; 1464 : 
; 1465 : 	if( bApplyPushPower )

  00029	80 7d 0c 00	 cmp	 BYTE PTR _bApplyPushPower$[ebp], 0
  0002d	0f 84 27 03 00
	00		 je	 $LN7@ApplyWeapo@14

; 1466 : 	{
; 1467 : 		SetCurSpeedToForcePower();

  00033	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0003b	51		 push	 ecx
  0003c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00041	e8 00 00 00 00	 call	 ?SetCurSpeedToForcePower@ioBaseChar@@QAEXM@Z ; ioBaseChar::SetCurSpeedToForcePower

; 1468 : 
; 1469 : 		float fPushAngle = pWeapon->GetPushAngle();

  00046	8b 07		 mov	 eax, DWORD PTR [edi]
  00048	8b cf		 mov	 ecx, edi
  0004a	ff 90 dc 00 00
	00		 call	 DWORD PTR [eax+220]
  00050	d9 5d c4	 fstp	 DWORD PTR _fPushAngle$694216[ebp]

; 1470 : 		D3DXVECTOR3 vPushDir = vAttackDir;
; 1471 : 
; 1472 : 		if( vPushDir != ioMath::UNIT_Y )

  00053	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?UNIT_Y@ioMath@@2UD3DXVECTOR3@@A
  00059	8d 7d f0	 lea	 edi, DWORD PTR _vPushDir$694217[ebp]
  0005c	a5		 movsd
  0005d	a5		 movsd
  0005e	a5		 movsd
  0005f	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _vPushDir$694217[ebp]
  00064	f3 0f 10 09	 movss	 xmm1, DWORD PTR [ecx]
  00068	0f 5a c0	 cvtps2pd xmm0, xmm0
  0006b	0f 5a c9	 cvtps2pd xmm1, xmm1
  0006e	66 0f 2e c1	 ucomisd xmm0, xmm1
  00072	9f		 lahf
  00073	f6 c4 44	 test	 ah, 68			; 00000044H
  00076	7a 38		 jp	 SHORT $LN13@ApplyWeapo@14
  00078	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _vPushDir$694217[ebp+4]
  0007d	f3 0f 10 49 04	 movss	 xmm1, DWORD PTR [ecx+4]
  00082	0f 5a c0	 cvtps2pd xmm0, xmm0
  00085	0f 5a c9	 cvtps2pd xmm1, xmm1
  00088	66 0f 2e c1	 ucomisd xmm0, xmm1
  0008c	9f		 lahf
  0008d	f6 c4 44	 test	 ah, 68			; 00000044H
  00090	7a 1e		 jp	 SHORT $LN13@ApplyWeapo@14
  00092	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _vPushDir$694217[ebp+8]
  00097	f3 0f 10 49 08	 movss	 xmm1, DWORD PTR [ecx+8]
  0009c	0f 5a c0	 cvtps2pd xmm0, xmm0
  0009f	0f 5a c9	 cvtps2pd xmm1, xmm1
  000a2	66 0f 2e c1	 ucomisd xmm0, xmm1
  000a6	9f		 lahf
  000a7	f6 c4 44	 test	 ah, 68			; 00000044H
  000aa	0f 8b 3f 02 00
	00		 jnp	 $LN6@ApplyWeapo@14
$LN13@ApplyWeapo@14:

; 1473 : 		{
; 1474 : 			D3DXVECTOR3 vAxis1, vAxis2;
; 1475 : 			D3DXVec3Cross( &vAxis1, &ioMath::UNIT_Y, &vPushDir );

  000b0	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  000b5	f3 0f 10 5d f8	 movss	 xmm3, DWORD PTR _vPushDir$694217[ebp+8]
  000ba	f3 0f 10 49 08	 movss	 xmm1, DWORD PTR [ecx+8]
  000bf	f3 0f 10 65 f4	 movss	 xmm4, DWORD PTR _vPushDir$694217[ebp+4]
  000c4	0f 5a db	 cvtps2pd xmm3, xmm3
  000c7	0f 5a d0	 cvtps2pd xmm2, xmm0
  000ca	f2 0f 59 d3	 mulsd	 xmm2, xmm3
  000ce	0f 5a e4	 cvtps2pd xmm4, xmm4
  000d1	0f 5a c0	 cvtps2pd xmm0, xmm0
  000d4	8d 75 e4	 lea	 esi, DWORD PTR _v$700167[ebp]
  000d7	0f 5a d9	 cvtps2pd xmm3, xmm1
  000da	f2 0f 59 dc	 mulsd	 xmm3, xmm4
  000de	f3 0f 10 65 f8	 movss	 xmm4, DWORD PTR _vPushDir$694217[ebp+8]
  000e3	f2 0f 5c d3	 subsd	 xmm2, xmm3
  000e7	f3 0f 10 5d f0	 movss	 xmm3, DWORD PTR _vPushDir$694217[ebp]
  000ec	0f 5a db	 cvtps2pd xmm3, xmm3
  000ef	66 0f 5a d2	 cvtpd2ps xmm2, xmm2
  000f3	f3 0f 11 55 e4	 movss	 DWORD PTR _v$700167[ebp], xmm2
  000f8	f3 0f 10 11	 movss	 xmm2, DWORD PTR [ecx]
  000fc	0f 5a c9	 cvtps2pd xmm1, xmm1
  000ff	f2 0f 59 cb	 mulsd	 xmm1, xmm3
  00103	0f 5a da	 cvtps2pd xmm3, xmm2
  00106	0f 5a e4	 cvtps2pd xmm4, xmm4
  00109	f2 0f 59 dc	 mulsd	 xmm3, xmm4
  0010d	f2 0f 5c cb	 subsd	 xmm1, xmm3
  00111	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  00115	f3 0f 11 4d e8	 movss	 DWORD PTR _v$700167[ebp+4], xmm1
  0011a	8d 7d d8	 lea	 edi, DWORD PTR _vAxis1$694219[ebp]

; 1476 : 			D3DXVec3Normalize(&vAxis1,&vAxis1);

  0011d	8d 45 d8	 lea	 eax, DWORD PTR _vAxis1$694219[ebp]
  00120	50		 push	 eax
  00121	50		 push	 eax
  00122	0f 5a ca	 cvtps2pd xmm1, xmm2
  00125	f3 0f 10 55 f4	 movss	 xmm2, DWORD PTR _vPushDir$694217[ebp+4]
  0012a	0f 5a d2	 cvtps2pd xmm2, xmm2
  0012d	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  00131	f3 0f 10 55 f0	 movss	 xmm2, DWORD PTR _vPushDir$694217[ebp]
  00136	0f 5a d2	 cvtps2pd xmm2, xmm2
  00139	f2 0f 59 c2	 mulsd	 xmm0, xmm2
  0013d	f2 0f 5c c8	 subsd	 xmm1, xmm0
  00141	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  00145	f3 0f 11 45 ec	 movss	 DWORD PTR _v$700167[ebp+8], xmm0
  0014a	a5		 movsd
  0014b	a5		 movsd
  0014c	a5		 movsd
  0014d	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8

; 1477 : 
; 1478 : 			D3DXVec3Cross( &vAxis2, &vPushDir, &vAxis1 );

  00152	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _vAxis1$694219[ebp+8]
  00157	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR _vPushDir$694217[ebp+4]
  0015c	f3 0f 10 55 f8	 movss	 xmm2, DWORD PTR _vPushDir$694217[ebp+8]
  00161	0f 5a c9	 cvtps2pd xmm1, xmm1
  00164	0f 5a c0	 cvtps2pd xmm0, xmm0
  00167	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  0016b	f3 0f 10 4d dc	 movss	 xmm1, DWORD PTR _vAxis1$694219[ebp+4]
  00170	0f 5a c9	 cvtps2pd xmm1, xmm1
  00173	0f 5a d2	 cvtps2pd xmm2, xmm2
  00176	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  0017a	f3 0f 10 55 f0	 movss	 xmm2, DWORD PTR _vPushDir$694217[ebp]
  0017f	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00183	f3 0f 10 4d d8	 movss	 xmm1, DWORD PTR _vAxis1$694219[ebp]
  00188	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0018c	f3 0f 11 45 cc	 movss	 DWORD PTR _v$700178[ebp], xmm0
  00191	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _vPushDir$694217[ebp+8]
  00196	0f 5a c9	 cvtps2pd xmm1, xmm1
  00199	0f 5a c0	 cvtps2pd xmm0, xmm0
  0019c	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  001a0	f3 0f 10 4d e0	 movss	 xmm1, DWORD PTR _vAxis1$694219[ebp+8]
  001a5	0f 5a c9	 cvtps2pd xmm1, xmm1
  001a8	0f 5a d2	 cvtps2pd xmm2, xmm2
  001ab	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  001af	f3 0f 10 55 d8	 movss	 xmm2, DWORD PTR _vAxis1$694219[ebp]
  001b4	f2 0f 5c c1	 subsd	 xmm0, xmm1
  001b8	f3 0f 10 4d f0	 movss	 xmm1, DWORD PTR _vPushDir$694217[ebp]
  001bd	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  001c1	f3 0f 11 45 d0	 movss	 DWORD PTR _v$700178[ebp+4], xmm0
  001c6	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _vAxis1$694219[ebp+4]
  001cb	0f 5a c9	 cvtps2pd xmm1, xmm1
  001ce	0f 5a c0	 cvtps2pd xmm0, xmm0
  001d1	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  001d5	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR _vPushDir$694217[ebp+4]
  001da	0f 5a c9	 cvtps2pd xmm1, xmm1
  001dd	0f 5a d2	 cvtps2pd xmm2, xmm2
  001e0	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  001e4	f2 0f 5c c1	 subsd	 xmm0, xmm1
  001e8	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  001ec	f3 0f 11 45 d4	 movss	 DWORD PTR _v$700178[ebp+8], xmm0
  001f1	8d 75 cc	 lea	 esi, DWORD PTR _v$700178[ebp]
  001f4	8d 7d e4	 lea	 edi, DWORD PTR _vAxis2$694220[ebp]
  001f7	a5		 movsd

; 1479 : 			D3DXVec3Normalize(&vAxis2,&vAxis2);

  001f8	8d 45 e4	 lea	 eax, DWORD PTR _vAxis2$694220[ebp]
  001fb	a5		 movsd
  001fc	50		 push	 eax
  001fd	50		 push	 eax
  001fe	a5		 movsd
  001ff	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8

; 1480 : 
; 1481 : 			D3DXQUATERNION qtRot;
; 1482 : 			if( vAxis2 == ioMath::VEC3_ZERO )

  00204	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?VEC3_ZERO@ioMath@@2UD3DXVECTOR3@@A
  0020a	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _vAxis2$694220[ebp]
  0020f	f3 0f 10 09	 movss	 xmm1, DWORD PTR [ecx]
  00213	0f 5a c0	 cvtps2pd xmm0, xmm0
  00216	0f 5a c9	 cvtps2pd xmm1, xmm1
  00219	66 0f 2e c1	 ucomisd xmm0, xmm1
  0021d	9f		 lahf
  0021e	f6 c4 44	 test	 ah, 68			; 00000044H
  00221	7a 56		 jp	 SHORT $LN5@ApplyWeapo@14
  00223	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _vAxis2$694220[ebp+4]
  00228	f3 0f 10 49 04	 movss	 xmm1, DWORD PTR [ecx+4]
  0022d	0f 5a c0	 cvtps2pd xmm0, xmm0
  00230	0f 5a c9	 cvtps2pd xmm1, xmm1
  00233	66 0f 2e c1	 ucomisd xmm0, xmm1
  00237	9f		 lahf
  00238	f6 c4 44	 test	 ah, 68			; 00000044H
  0023b	7a 3c		 jp	 SHORT $LN5@ApplyWeapo@14
  0023d	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _vAxis2$694220[ebp+8]
  00242	f3 0f 10 49 08	 movss	 xmm1, DWORD PTR [ecx+8]
  00247	0f 5a c0	 cvtps2pd xmm0, xmm0
  0024a	0f 5a c9	 cvtps2pd xmm1, xmm1
  0024d	66 0f 2e c1	 ucomisd xmm0, xmm1
  00251	9f		 lahf
  00252	f6 c4 44	 test	 ah, 68			; 00000044H
  00255	7a 22		 jp	 SHORT $LN5@ApplyWeapo@14

; 1483 : 				D3DXQuaternionRotationAxis( &qtRot, &ioMath::UNIT_Y, DEGtoRAD(fPushAngle) );

  00257	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _fPushAngle$694216[ebp]
  0025c	0f 5a c0	 cvtps2pd xmm0, xmm0
  0025f	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3f91df46a2526c7a
  00267	51		 push	 ecx
  00268	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0026c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00271	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?UNIT_Y@ioMath@@2UD3DXVECTOR3@@A

; 1484 : 			else

  00277	eb 1e		 jmp	 SHORT $LN39@ApplyWeapo@14
$LN5@ApplyWeapo@14:

; 1485 : 				D3DXQuaternionRotationAxis( &qtRot, &vAxis2, DEGtoRAD(fPushAngle) );

  00279	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _fPushAngle$694216[ebp]
  0027e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00281	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3f91df46a2526c7a
  00289	51		 push	 ecx
  0028a	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0028e	8d 45 e4	 lea	 eax, DWORD PTR _vAxis2$694220[ebp]
  00291	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00296	50		 push	 eax
$LN39@ApplyWeapo@14:
  00297	8d 45 b4	 lea	 eax, DWORD PTR _qtRot$694221[ebp]
  0029a	50		 push	 eax
  0029b	e8 00 00 00 00	 call	 _D3DXQuaternionRotationAxis@12

; 1486 : 
; 1487 : 			vPushDir = qtRot * vPushDir;

  002a0	8d 45 f0	 lea	 eax, DWORD PTR _vPushDir$694217[ebp]
  002a3	50		 push	 eax
  002a4	8d 45 b4	 lea	 eax, DWORD PTR _qtRot$694221[ebp]
  002a7	50		 push	 eax
  002a8	8d 45 cc	 lea	 eax, DWORD PTR $T694228[ebp]
  002ab	50		 push	 eax
  002ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??D@YA?AUD3DXVECTOR3@@ABUD3DXQUATERNION@@ABU0@@Z
  002b2	8b f0		 mov	 esi, eax
  002b4	8d 7d f0	 lea	 edi, DWORD PTR _vPushDir$694217[ebp]
  002b7	a5		 movsd
  002b8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1488 : 			D3DXVec3Normalize(&vPushDir,&vPushDir);

  002bb	8d 45 f0	 lea	 eax, DWORD PTR _vPushDir$694217[ebp]
  002be	a5		 movsd
  002bf	50		 push	 eax
  002c0	50		 push	 eax
  002c1	a5		 movsd
  002c2	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8

; 1489 : 
; 1490 : 			SetForcePower( vPushDir, fPushPower, 1.0f, bForceLinear );

  002c7	ff 75 1c	 push	 DWORD PTR _bForceLinear$[ebp]
  002ca	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  002d2	8d 45 f0	 lea	 eax, DWORD PTR _vPushDir$694217[ebp]
  002d5	51		 push	 ecx
  002d6	51		 push	 ecx
  002d7	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  002dd	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _fPushPower$[ebp]
  002e2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002e7	50		 push	 eax
  002e8	8b cb		 mov	 ecx, ebx
  002ea	e8 00 00 00 00	 call	 ?SetForcePower@ioBaseChar@@QAEXABUD3DXVECTOR3@@MM_N@Z ; ioBaseChar::SetForcePower
$LN6@ApplyWeapo@14:

; 1491 : 		}
; 1492 : 
; 1493 : 		if( HasBuff( BT_FLOAT_BUFF ) || HasBuff( BT_FLOAT_MODE_EVENT_BUFF ) )

  002ef	6a 24		 push	 36			; 00000024H
  002f1	8b cb		 mov	 ecx, ebx
  002f3	e8 00 00 00 00	 call	 ?HasBuff@ioBaseChar@@QBE_NH@Z ; ioBaseChar::HasBuff
  002f8	84 c0		 test	 al, al
  002fa	75 0d		 jne	 SHORT $LN2@ApplyWeapo@14
  002fc	6a 38		 push	 56			; 00000038H
  002fe	8b cb		 mov	 ecx, ebx
  00300	e8 00 00 00 00	 call	 ?HasBuff@ioBaseChar@@QBE_NH@Z ; ioBaseChar::HasBuff
  00305	84 c0		 test	 al, al
  00307	74 23		 je	 SHORT $LN38@ApplyWeapo@14
$LN2@ApplyWeapo@14:

; 1494 : 			fBlowPower *= m_FloatBuffInfo.m_fFloatBlowRate;

  00309	8b 45 c8	 mov	 eax, DWORD PTR _fBlowPower$GSCopy$[ebp]
  0030c	f3 0f 10 83 ac
	1c 00 00	 movss	 xmm0, DWORD PTR [ebx+7340]
  00314	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  00318	0f 5a c0	 cvtps2pd xmm0, xmm0
  0031b	0f 5a c9	 cvtps2pd xmm1, xmm1
  0031e	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00322	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00326	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  0032a	eb 03		 jmp	 SHORT $LN3@ApplyWeapo@14
$LN38@ApplyWeapo@14:
  0032c	8b 45 c8	 mov	 eax, DWORD PTR _fBlowPower$GSCopy$[ebp]
$LN3@ApplyWeapo@14:

; 1495 : 
; 1496 : 		SetJumpPower( fBlowPower );

  0032f	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00333	51		 push	 ecx
  00334	8b cb		 mov	 ecx, ebx
  00336	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0033b	e8 00 00 00 00	 call	 ?SetJumpPower@ioBaseChar@@QAEXM@Z ; ioBaseChar::SetJumpPower

; 1497 : 
; 1498 : 		//   .
; 1499 : 		m_fCurGravityGapAmt = m_fGravityAmt - m_fCurJumpPowerAmt;

  00340	8d 83 90 0e 00
	00		 lea	 eax, DWORD PTR [ebx+3728]
  00346	50		 push	 eax
  00347	8d 8b e8 0b 00
	00		 lea	 ecx, DWORD PTR [ebx+3048]
  0034d	e8 00 00 00 00	 call	 ??G?$CEncrypt@M@@QAEMABM@Z ; CEncrypt<float>::operator-
  00352	d9 9b 88 13 00
	00		 fstp	 DWORD PTR [ebx+5000]

; 1500 : 	}
; 1501 : 	else

  00358	eb 07		 jmp	 SHORT $LN1@ApplyWeapo@14
$LN7@ApplyWeapo@14:

; 1502 : 		fBlowPower = 0.0f;

  0035a	0f 57 c0	 xorps	 xmm0, xmm0
  0035d	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
$LN1@ApplyWeapo@14:

; 1503 : }

  00361	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00364	5f		 pop	 edi
  00365	5e		 pop	 esi
  00366	33 cd		 xor	 ecx, ebp
  00368	5b		 pop	 ebx
  00369	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0036e	c9		 leave
  0036f	c2 18 00	 ret	 24			; 00000018H
?ApplyWeaponWoundedPushBlowPower@ioBaseChar@@IAEXPAVioWeapon@@_NABUD3DXVECTOR3@@MAAM1@Z ENDP ; ioBaseChar::ApplyWeaponWoundedPushBlowPower
_TEXT	ENDS
PUBLIC	?ApplyWeaponWoundedGrappling@ioBaseChar@@IAEXPAVioWeapon@@AA_N_N22W4CharState@@@Z ; ioBaseChar::ApplyWeaponWoundedGrappling
EXTRN	?SetNoChangeGrapplingState@ioBaseChar@@QAEXH@Z:PROC ; ioBaseChar::SetNoChangeGrapplingState
EXTRN	?IsWoundedState@ioBaseChar@@QBE_NXZ:PROC	; ioBaseChar::IsWoundedState
EXTRN	?IsWoundedGrapplingState@ioBaseChar@@QBE_NW4GrapplingType@@@Z:PROC ; ioBaseChar::IsWoundedGrapplingState
; Function compile flags: /Ogsp
;	COMDAT ?ApplyWeaponWoundedGrappling@ioBaseChar@@IAEXPAVioWeapon@@AA_N_N22W4CharState@@@Z
_TEXT	SEGMENT
_value$700233 = -8					; size = 4
_value$700229 = -8					; size = 4
_value$700225 = -8					; size = 4
_value$700221 = -8					; size = 4
_value$700217 = -8					; size = 4
_value$700213 = -8					; size = 4
_eWeaponGrappling$ = -4					; size = 4
_pWeapon$ = 8						; size = 4
_bEnableFloat$694384 = 11				; size = 1
_bNoChangeGrappling$ = 12				; size = 4
_bApplyPushPower$ = 16					; size = 1
_bTargetDie$ = 20					; size = 1
_bPrisoner$ = 24					; size = 1
_eCheckCharState$ = 28					; size = 1
?ApplyWeaponWoundedGrappling@ioBaseChar@@IAEXPAVioWeapon@@AA_N_N22W4CharState@@@Z PROC ; ioBaseChar::ApplyWeaponWoundedGrappling, COMDAT
; _this$ = ecx

; 1793 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 1794 : 	if ( !pWeapon )

  00008	8b 4d 08	 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  0000b	85 c9		 test	 ecx, ecx
  0000d	0f 84 5d 02 00
	00		 je	 $LN1@ApplyWeapo@15

; 1795 : 		return;
; 1796 : 
; 1797 : 	bNoChangeGrappling = false;

  00013	8b 45 0c	 mov	 eax, DWORD PTR _bNoChangeGrappling$[ebp]
  00016	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1798 : 
; 1799 : 	m_GrapplingType = GPT_NONE;

  00019	83 a6 6c 34 00
	00 00		 and	 DWORD PTR [esi+13420], 0

; 1800 : 
; 1801 : 	GrapplingType eWeaponGrappling = pWeapon->CheckGrapplingState();

  00020	8b 01		 mov	 eax, DWORD PTR [ecx]
  00022	53		 push	 ebx
  00023	57		 push	 edi
  00024	ff 90 ec 00 00
	00		 call	 DWORD PTR [eax+236]

; 1802 : 	if( eWeaponGrappling == GPT_WRESTLING && IsWoundedGrapplingState( eWeaponGrappling ) )

  0002a	33 db		 xor	 ebx, ebx
  0002c	43		 inc	 ebx
  0002d	89 45 fc	 mov	 DWORD PTR _eWeaponGrappling$[ebp], eax
  00030	3b c3		 cmp	 eax, ebx
  00032	0f 85 f4 00 00
	00		 jne	 $LN56@ApplyWeapo@15
  00038	53		 push	 ebx
  00039	8b ce		 mov	 ecx, esi
  0003b	e8 00 00 00 00	 call	 ?IsWoundedGrapplingState@ioBaseChar@@QBE_NW4GrapplingType@@@Z ; ioBaseChar::IsWoundedGrapplingState
  00040	84 c0		 test	 al, al
  00042	0f 84 1b 01 00
	00		 je	 $LN79@ApplyWeapo@15

; 1803 : 	{
; 1804 : 		bool bEnableFloat = true;
; 1805 : 		if( IsFloatingState() )

  00048	8b ce		 mov	 ecx, esi
  0004a	88 5d 0b	 mov	 BYTE PTR _bEnableFloat$694384[ebp], bl
  0004d	e8 00 00 00 00	 call	 ?IsFloatingState@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsFloatingState
  00052	84 c0		 test	 al, al
  00054	74 7f		 je	 SHORT $LN46@ApplyWeapo@15

; 1806 : 		{
; 1807 : 			bEnableFloat = false;
; 1808 : 
; 1809 : 			if( m_CharState == CS_BLOW_WOUNDED && m_BlowState == BW_BLOWING )

  00056	80 be 10 03 00
	00 0c		 cmp	 BYTE PTR [esi+784], 12	; 0000000cH
  0005d	c6 45 0b 00	 mov	 BYTE PTR _bEnableFloat$694384[ebp], 0
  00061	75 14		 jne	 SHORT $LN54@ApplyWeapo@15
  00063	8d 45 f8	 lea	 eax, DWORD PTR _value$700213[ebp]
  00066	50		 push	 eax
  00067	8d 8e 58 0f 00
	00		 lea	 ecx, DWORD PTR [esi+3928]
  0006d	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4BlowWoundedState@@@@QAEXPAW4BlowWoundedState@@@Z ; CEncrypt<enum BlowWoundedState>::DecryptValueToPool
  00072	39 5d f8	 cmp	 DWORD PTR _value$700213[ebp], ebx

; 1810 : 			{
; 1811 : 				if( !IsFloating() )
; 1812 : 					bEnableFloat = true;
; 1813 : 			}

  00075	74 4f		 je	 SHORT $LN47@ApplyWeapo@15
$LN54@ApplyWeapo@15:

; 1814 : 			else if( m_CharState == CS_BLOW_EXTEND_WOUND && m_BlowState == BW_BLOWING )

  00077	80 be 10 03 00
	00 46		 cmp	 BYTE PTR [esi+784], 70	; 00000046H
  0007e	75 14		 jne	 SHORT $LN51@ApplyWeapo@15
  00080	8d 45 f8	 lea	 eax, DWORD PTR _value$700217[ebp]
  00083	50		 push	 eax
  00084	8d 8e 58 0f 00
	00		 lea	 ecx, DWORD PTR [esi+3928]
  0008a	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4BlowWoundedState@@@@QAEXPAW4BlowWoundedState@@@Z ; CEncrypt<enum BlowWoundedState>::DecryptValueToPool
  0008f	39 5d f8	 cmp	 DWORD PTR _value$700217[ebp], ebx

; 1815 : 			{
; 1816 : 				if( !IsFloating() )
; 1817 : 					bEnableFloat = true;
; 1818 : 			}
; 1819 : 			else if( m_CharState == CS_BOUND_BLOW_WOUNDED &&

  00092	74 32		 je	 SHORT $LN47@ApplyWeapo@15
$LN51@ApplyWeapo@15:

; 1820 : 				(m_BlowState == BW_BLOWING || m_BlowState == BW_BOUND_BLOWING) )

  00094	80 be 10 03 00
	00 31		 cmp	 BYTE PTR [esi+784], 49	; 00000031H
  0009b	75 38		 jne	 SHORT $LN46@ApplyWeapo@15
  0009d	8d 45 f8	 lea	 eax, DWORD PTR _value$700221[ebp]
  000a0	50		 push	 eax
  000a1	8d 8e 58 0f 00
	00		 lea	 ecx, DWORD PTR [esi+3928]
  000a7	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4BlowWoundedState@@@@QAEXPAW4BlowWoundedState@@@Z ; CEncrypt<enum BlowWoundedState>::DecryptValueToPool
  000ac	39 5d f8	 cmp	 DWORD PTR _value$700221[ebp], ebx
  000af	74 15		 je	 SHORT $LN47@ApplyWeapo@15
  000b1	8d 45 f8	 lea	 eax, DWORD PTR _value$700225[ebp]
  000b4	50		 push	 eax
  000b5	8d 8e 58 0f 00
	00		 lea	 ecx, DWORD PTR [esi+3928]
  000bb	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4BlowWoundedState@@@@QAEXPAW4BlowWoundedState@@@Z ; CEncrypt<enum BlowWoundedState>::DecryptValueToPool
  000c0	83 7d f8 04	 cmp	 DWORD PTR _value$700225[ebp], 4
  000c4	75 0f		 jne	 SHORT $LN46@ApplyWeapo@15
$LN47@ApplyWeapo@15:

; 1821 : 			{
; 1822 : 				if( !IsFloating() )

  000c6	8b ce		 mov	 ecx, esi
  000c8	e8 00 00 00 00	 call	 ?IsFloating@ioBaseChar@@QAE_NXZ ; ioBaseChar::IsFloating
  000cd	84 c0		 test	 al, al
  000cf	75 04		 jne	 SHORT $LN46@ApplyWeapo@15

; 1823 : 					bEnableFloat = true;

  000d1	c6 45 0b 01	 mov	 BYTE PTR _bEnableFloat$694384[ebp], 1
$LN46@ApplyWeapo@15:

; 1824 : 			}
; 1825 : 		}
; 1826 : 
; 1827 : 		bool bCheckPreBlowState = false;

  000d5	32 db		 xor	 bl, bl

; 1828 : 		if( (m_CharState == CS_BLOW_WOUNDED && m_BlowState == BW_GETUP) ||
; 1829 : 			(m_CharState == CS_BOUND_BLOW_WOUNDED && m_BlowState == BW_GETUP) )

  000d7	80 be 10 03 00
	00 0c		 cmp	 BYTE PTR [esi+784], 12	; 0000000cH
  000de	6a 03		 push	 3
  000e0	5f		 pop	 edi
  000e1	75 14		 jne	 SHORT $LN43@ApplyWeapo@15
  000e3	8d 45 f8	 lea	 eax, DWORD PTR _value$700229[ebp]
  000e6	50		 push	 eax
  000e7	8d 8e 58 0f 00
	00		 lea	 ecx, DWORD PTR [esi+3928]
  000ed	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4BlowWoundedState@@@@QAEXPAW4BlowWoundedState@@@Z ; CEncrypt<enum BlowWoundedState>::DecryptValueToPool
  000f2	39 7d f8	 cmp	 DWORD PTR _value$700229[ebp], edi
  000f5	74 1d		 je	 SHORT $LN44@ApplyWeapo@15
$LN43@ApplyWeapo@15:
  000f7	80 be 10 03 00
	00 31		 cmp	 BYTE PTR [esi+784], 49	; 00000031H
  000fe	75 16		 jne	 SHORT $LN45@ApplyWeapo@15
  00100	8d 45 f8	 lea	 eax, DWORD PTR _value$700233[ebp]
  00103	50		 push	 eax
  00104	8d 8e 58 0f 00
	00		 lea	 ecx, DWORD PTR [esi+3928]
  0010a	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4BlowWoundedState@@@@QAEXPAW4BlowWoundedState@@@Z ; CEncrypt<enum BlowWoundedState>::DecryptValueToPool
  0010f	39 7d f8	 cmp	 DWORD PTR _value$700233[ebp], edi
  00112	75 02		 jne	 SHORT $LN45@ApplyWeapo@15
$LN44@ApplyWeapo@15:

; 1830 : 			bCheckPreBlowState = true;

  00114	b3 01		 mov	 bl, 1
$LN45@ApplyWeapo@15:

; 1831 : 
; 1832 : 		if( bEnableFloat && !bCheckPreBlowState )

  00116	80 7d 0b 00	 cmp	 BYTE PTR _bEnableFloat$694384[ebp], 0
  0011a	74 47		 je	 SHORT $LN79@ApplyWeapo@15
  0011c	84 db		 test	 bl, bl
  0011e	75 43		 jne	 SHORT $LN79@ApplyWeapo@15

; 1833 : 			m_GrapplingType = GPT_WRESTLING;

  00120	c7 86 6c 34 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+13420], 1

; 1834 : 	}

  0012a	eb 37		 jmp	 SHORT $LN79@ApplyWeapo@15
$LN56@ApplyWeapo@15:

; 1835 : 	else if( eWeaponGrappling == GPT_WRESTLING_ALL && IsWoundedGrapplingState( eWeaponGrappling ) )// && !HasBuff(BT_STATE_PROTECTION) )

  0012c	6a 03		 push	 3
  0012e	5f		 pop	 edi
  0012f	3b c7		 cmp	 eax, edi
  00131	75 59		 jne	 SHORT $LN40@ApplyWeapo@15
  00133	57		 push	 edi
  00134	8b ce		 mov	 ecx, esi
  00136	e8 00 00 00 00	 call	 ?IsWoundedGrapplingState@ioBaseChar@@QBE_NW4GrapplingType@@@Z ; ioBaseChar::IsWoundedGrapplingState
  0013b	84 c0		 test	 al, al
  0013d	75 1e		 jne	 SHORT $LN88@ApplyWeapo@15

; 1866 : 		{
; 1867 : 		case GPT_WRESTLING_ALL:
; 1868 : 			if( IsWoundedState() && eCheckCharState != CS_GRAPPLING_WOUNDED && !HasBuff(BT_STATE_PROTECTION) )

  0013f	8b ce		 mov	 ecx, esi
  00141	e8 00 00 00 00	 call	 ?IsWoundedState@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsWoundedState
  00146	84 c0		 test	 al, al
  00148	74 19		 je	 SHORT $LN79@ApplyWeapo@15
  0014a	80 7d 1c 41	 cmp	 BYTE PTR _eCheckCharState$[ebp], 65 ; 00000041H
  0014e	74 13		 je	 SHORT $LN79@ApplyWeapo@15
  00150	6a 23		 push	 35			; 00000023H
  00152	8b ce		 mov	 ecx, esi
  00154	e8 00 00 00 00	 call	 ?HasBuff@ioBaseChar@@QBE_NH@Z ; ioBaseChar::HasBuff
  00159	84 c0		 test	 al, al
  0015b	75 06		 jne	 SHORT $LN79@ApplyWeapo@15
$LN88@ApplyWeapo@15:

; 1869 : 				m_GrapplingType = eWeaponGrappling;

  0015d	89 be 6c 34 00
	00		 mov	 DWORD PTR [esi+13420], edi
$LN79@ApplyWeapo@15:

; 1880 : 		}
; 1881 : 	}
; 1882 : 
; 1883 : 	if( eCheckCharState == CS_GRAPPLING_WOUNDED_SKILL &&
; 1884 : 		(eWeaponGrappling == GPT_NO_CHANGE || eWeaponGrappling == GPT_NO_CHANGE2 || eWeaponGrappling == GPT_NO_CHANGE3 ) )

  00163	80 7d 1c 43	 cmp	 BYTE PTR _eCheckCharState$[ebp], 67 ; 00000043H
  00167	5f		 pop	 edi
  00168	5b		 pop	 ebx
  00169	0f 85 c8 00 00
	00		 jne	 $LN7@ApplyWeapo@15
  0016f	83 7d fc 06	 cmp	 DWORD PTR _eWeaponGrappling$[ebp], 6
  00173	0f 84 ca 00 00
	00		 je	 $LN6@ApplyWeapo@15
  00179	83 7d fc 08	 cmp	 DWORD PTR _eWeaponGrappling$[ebp], 8
  0017d	0f 84 c0 00 00
	00		 je	 $LN6@ApplyWeapo@15
  00183	83 7d fc 0f	 cmp	 DWORD PTR _eWeaponGrappling$[ebp], 15 ; 0000000fH

; 1885 : 	{
; 1886 : 		if( !bTargetDie && !bPrisoner )
; 1887 : 			bNoChangeGrappling = true;
; 1888 : 	}

  00187	e9 b5 00 00 00	 jmp	 $LN90@ApplyWeapo@15
$LN40@ApplyWeapo@15:

; 1836 : 		m_GrapplingType = GPT_WRESTLING_ALL;
; 1837 : 	else if( eWeaponGrappling == GPT_PSYCHIC && IsWoundedState() )

  0018c	6a 02		 push	 2
  0018e	5f		 pop	 edi
  0018f	3b c7		 cmp	 eax, edi
  00191	75 0d		 jne	 SHORT $LN38@ApplyWeapo@15
  00193	8b ce		 mov	 ecx, esi
  00195	e8 00 00 00 00	 call	 ?IsWoundedState@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsWoundedState
$LN89@ApplyWeapo@15:
  0019a	84 c0		 test	 al, al
  0019c	74 c5		 je	 SHORT $LN79@ApplyWeapo@15

; 1838 : 		m_GrapplingType = GPT_PSYCHIC;

  0019e	eb bd		 jmp	 SHORT $LN88@ApplyWeapo@15
$LN38@ApplyWeapo@15:

; 1839 : 	else if( eWeaponGrappling == GPT_TOSS && bApplyPushPower )

  001a0	6a 04		 push	 4
  001a2	59		 pop	 ecx
  001a3	3b c1		 cmp	 eax, ecx
  001a5	75 0e		 jne	 SHORT $LN36@ApplyWeapo@15
  001a7	80 7d 10 00	 cmp	 BYTE PTR _bApplyPushPower$[ebp], 0
  001ab	74 b6		 je	 SHORT $LN79@ApplyWeapo@15

; 1840 : 		m_GrapplingType = GPT_TOSS;

  001ad	89 8e 6c 34 00
	00		 mov	 DWORD PTR [esi+13420], ecx
  001b3	eb ae		 jmp	 SHORT $LN79@ApplyWeapo@15
$LN36@ApplyWeapo@15:

; 1841 : 	else if( eWeaponGrappling == GPT_LUCIFER_AIR && IsWoundedGrapplingState( eWeaponGrappling ) )

  001b5	6a 0c		 push	 12			; 0000000cH
  001b7	5f		 pop	 edi
  001b8	3b c7		 cmp	 eax, edi
  001ba	75 0a		 jne	 SHORT $LN34@ApplyWeapo@15
$LN91@ApplyWeapo@15:
  001bc	57		 push	 edi
  001bd	8b ce		 mov	 ecx, esi
  001bf	e8 00 00 00 00	 call	 ?IsWoundedGrapplingState@ioBaseChar@@QBE_NW4GrapplingType@@@Z ; ioBaseChar::IsWoundedGrapplingState

; 1842 : 		m_GrapplingType = GPT_LUCIFER_AIR;

  001c4	eb d4		 jmp	 SHORT $LN89@ApplyWeapo@15
$LN34@ApplyWeapo@15:

; 1843 : 	else if( eWeaponGrappling == GPT_NAKORURU && IsWoundedGrapplingState( eWeaponGrappling ) )

  001c6	6a 0d		 push	 13			; 0000000dH
  001c8	5f		 pop	 edi
  001c9	3b c7		 cmp	 eax, edi

; 1844 : 		m_GrapplingType = GPT_NAKORURU;

  001cb	74 ef		 je	 SHORT $LN91@ApplyWeapo@15

; 1845 : 	else if( eWeaponGrappling == GPT_GRAPPLER_JUMP && IsWoundedGrapplingState( eWeaponGrappling ) )

  001cd	6a 15		 push	 21			; 00000015H
  001cf	5f		 pop	 edi
  001d0	3b c7		 cmp	 eax, edi

; 1846 : 		m_GrapplingType = GPT_GRAPPLER_JUMP;

  001d2	74 e8		 je	 SHORT $LN91@ApplyWeapo@15

; 1847 : 	else if( eWeaponGrappling == GPT_MICHAEL && IsWoundedGrapplingState( eWeaponGrappling ) )

  001d4	6a 0e		 push	 14			; 0000000eH
  001d6	5f		 pop	 edi
  001d7	3b c7		 cmp	 eax, edi

; 1848 : 		m_GrapplingType = GPT_MICHAEL;

  001d9	74 e1		 je	 SHORT $LN91@ApplyWeapo@15

; 1849 : 	else if( eWeaponGrappling == GPT_SUPER_DIMENSION && IsWoundedGrapplingState( eWeaponGrappling ) )

  001db	6a 10		 push	 16			; 00000010H
  001dd	5f		 pop	 edi
  001de	3b c7		 cmp	 eax, edi

; 1850 : 		m_GrapplingType = GPT_SUPER_DIMENSION;

  001e0	74 da		 je	 SHORT $LN91@ApplyWeapo@15

; 1851 : 	else if( eWeaponGrappling == GPT_STRIKER_AIR && IsWoundedGrapplingState( eWeaponGrappling ) )

  001e2	6a 11		 push	 17			; 00000011H
  001e4	5f		 pop	 edi
  001e5	3b c7		 cmp	 eax, edi

; 1852 : 		m_GrapplingType = GPT_STRIKER_AIR;

  001e7	74 d3		 je	 SHORT $LN91@ApplyWeapo@15

; 1853 : 	else if( eWeaponGrappling == GPT_JUMPER && IsWoundedGrapplingState( eWeaponGrappling ) )

  001e9	6a 12		 push	 18			; 00000012H
  001eb	5f		 pop	 edi
  001ec	3b c7		 cmp	 eax, edi

; 1854 : 		m_GrapplingType = GPT_JUMPER;

  001ee	74 cc		 je	 SHORT $LN91@ApplyWeapo@15

; 1855 : 	else if( eWeaponGrappling == GPT_FLY_JUMP_EXTRA_ATTACK && IsWoundedGrapplingState( eWeaponGrappling ) )

  001f0	6a 13		 push	 19			; 00000013H
  001f2	5f		 pop	 edi
  001f3	3b c7		 cmp	 eax, edi

; 1856 : 		m_GrapplingType = GPT_FLY_JUMP_EXTRA_ATTACK;

  001f5	74 c5		 je	 SHORT $LN91@ApplyWeapo@15

; 1857 : 	else if ( eWeaponGrappling == GPT_GALFORD && IsWoundedGrapplingState( eWeaponGrappling ) )

  001f7	6a 16		 push	 22			; 00000016H
  001f9	5f		 pop	 edi
  001fa	3b c7		 cmp	 eax, edi

; 1858 : 		m_GrapplingType = GPT_GALFORD;

  001fc	74 be		 je	 SHORT $LN91@ApplyWeapo@15

; 1859 : 	else if ( eWeaponGrappling == GPT_DRUID && IsWoundedGrapplingState( eWeaponGrappling ) )

  001fe	6a 17		 push	 23			; 00000017H
  00200	5f		 pop	 edi
  00201	3b c7		 cmp	 eax, edi

; 1860 : 		m_GrapplingType = GPT_DRUID;

  00203	74 b7		 je	 SHORT $LN91@ApplyWeapo@15

; 1861 : 	else if( eWeaponGrappling == GPT_GUNNER && IsWoundedGrapplingState( eWeaponGrappling ) )

  00205	6a 19		 push	 25			; 00000019H
  00207	5f		 pop	 edi
  00208	3b c7		 cmp	 eax, edi

; 1862 : 		m_GrapplingType = GPT_GUNNER;
; 1863 : 	else

  0020a	74 b0		 je	 SHORT $LN91@ApplyWeapo@15

; 1864 : 	{
; 1865 : 		switch( eWeaponGrappling )

  0020c	3b c1		 cmp	 eax, ecx
  0020e	0f 8e 4f ff ff
	ff		 jle	 $LN79@ApplyWeapo@15
  00214	83 f8 08	 cmp	 eax, 8
  00217	7e 13		 jle	 SHORT $LN77@ApplyWeapo@15
  00219	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0021c	74 0e		 je	 SHORT $LN77@ApplyWeapo@15
  0021e	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00221	74 09		 je	 SHORT $LN77@ApplyWeapo@15
  00223	83 f8 14	 cmp	 eax, 20			; 00000014H
  00226	0f 85 37 ff ff
	ff		 jne	 $LN79@ApplyWeapo@15
$LN77@ApplyWeapo@15:

; 1870 : 			break;
; 1871 : 		case GPT_MULTI:
; 1872 : 		case GPT_ATTACK:
; 1873 : 		case GPT_NO_CHANGE:
; 1874 : 		case GPT_NO_CHANGE2:
; 1875 : 		case GPT_NO_CHANGE3:
; 1876 : 		case GPT_NO_CHANGE4:
; 1877 : 		case GPT_COMPETE:
; 1878 : 			m_GrapplingType = eWeaponGrappling;

  0022c	89 86 6c 34 00
	00		 mov	 DWORD PTR [esi+13420], eax

; 1879 : 			break;

  00232	e9 2c ff ff ff	 jmp	 $LN79@ApplyWeapo@15
$LN7@ApplyWeapo@15:

; 1889 : 	else if( eCheckCharState == CS_GRAPPLING_WOUNDED && eWeaponGrappling == GPT_NO_CHANGE4 )

  00237	80 7d 1c 41	 cmp	 BYTE PTR _eCheckCharState$[ebp], 65 ; 00000041H
  0023b	75 18		 jne	 SHORT $LN87@ApplyWeapo@15
  0023d	83 7d fc 14	 cmp	 DWORD PTR _eWeaponGrappling$[ebp], 20 ; 00000014H
$LN90@ApplyWeapo@15:
  00241	75 12		 jne	 SHORT $LN87@ApplyWeapo@15
$LN6@ApplyWeapo@15:

; 1890 : 	{
; 1891 : 		if( !bTargetDie && !bPrisoner )

  00243	80 7d 14 00	 cmp	 BYTE PTR _bTargetDie$[ebp], 0
  00247	75 0c		 jne	 SHORT $LN87@ApplyWeapo@15
  00249	80 7d 18 00	 cmp	 BYTE PTR _bPrisoner$[ebp], 0
  0024d	75 06		 jne	 SHORT $LN87@ApplyWeapo@15

; 1892 : 			bNoChangeGrappling = true;

  0024f	8b 45 0c	 mov	 eax, DWORD PTR _bNoChangeGrappling$[ebp]
  00252	c6 00 01	 mov	 BYTE PTR [eax], 1
$LN87@ApplyWeapo@15:

; 1893 : 	}
; 1894 : 
; 1895 : 	if( bApplyPushPower && bNoChangeGrappling )

  00255	80 7d 10 00	 cmp	 BYTE PTR _bApplyPushPower$[ebp], 0
  00259	74 15		 je	 SHORT $LN1@ApplyWeapo@15
  0025b	8b 45 0c	 mov	 eax, DWORD PTR _bNoChangeGrappling$[ebp]
  0025e	80 38 00	 cmp	 BYTE PTR [eax], 0
  00261	74 0d		 je	 SHORT $LN1@ApplyWeapo@15

; 1896 : 		SetNoChangeGrapplingState( m_GrapplingType );

  00263	ff b6 6c 34 00
	00		 push	 DWORD PTR [esi+13420]
  00269	8b ce		 mov	 ecx, esi
  0026b	e8 00 00 00 00	 call	 ?SetNoChangeGrapplingState@ioBaseChar@@QAEXH@Z ; ioBaseChar::SetNoChangeGrapplingState
$LN1@ApplyWeapo@15:
  00270	5e		 pop	 esi

; 1897 : 
; 1898 : }

  00271	c9		 leave
  00272	c2 18 00	 ret	 24			; 00000018H
?ApplyWeaponWoundedGrappling@ioBaseChar@@IAEXPAVioWeapon@@AA_N_N22W4CharState@@@Z ENDP ; ioBaseChar::ApplyWeaponWoundedGrappling
_TEXT	ENDS
PUBLIC	?_Grow_to@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IBEII@Z ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Grow_to
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IBEII@Z PROC ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1275 : 		size_type _Capacity = capacity();

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	6a 14		 push	 20			; 00000014H
  0000a	99		 cdq
  0000b	59		 pop	 ecx
  0000c	f7 f9		 idiv	 ecx

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0000e	ba cc cc cc 0c	 mov	 edx, 214748364		; 0cccccccH
  00013	8b c8		 mov	 ecx, eax
  00015	d1 e9		 shr	 ecx, 1
  00017	2b d1		 sub	 edx, ecx
  00019	3b d0		 cmp	 edx, eax
  0001b	73 04		 jae	 SHORT $LN4@Grow_to
  0001d	33 c0		 xor	 eax, eax
  0001f	eb 02		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  00021	03 c1		 add	 eax, ecx
$LN5@Grow_to:

; 1279 : 		if (_Capacity < _Count)

  00023	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]

; 1280 : 			_Capacity = _Count;

  00026	0f 42 45 08	 cmovb	 eax, DWORD PTR __Count$[ebp]

; 1281 : 		return (_Capacity);
; 1282 : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?_Grow_to@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IBEII@Z ENDP ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Grow_to
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@ABU3@@Z ; std::allocator<BuffInfoStruct>::construct
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@ABU3@@Z PROC ; std::allocator<BuffInfoStruct>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 		_Construct(_Ptr, _Val);

  00003	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  00006	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00009	e8 00 00 00 00	 call	 ??$_Construct@UBuffInfoStruct@@ABU1@@std@@YAXPAUBuffInfoStruct@@ABU1@@Z ; std::_Construct<BuffInfoStruct,BuffInfoStruct const &>
  0000e	59		 pop	 ecx
  0000f	59		 pop	 ecx

; 198  : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?construct@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@ABU3@@Z ENDP ; std::allocator<BuffInfoStruct>::construct
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UBuffInfoStruct@@@std@@UBuffInfoStruct@@U3@@std@@YAXAAV?$allocator@UBuffInfoStruct@@@0@PAUBuffInfoStruct@@$$QAU2@@Z ; std::_Cons_val<std::allocator<BuffInfoStruct>,BuffInfoStruct,BuffInfoStruct>
; Function compile flags: /Ogsp
;	COMDAT ??$_Cons_val@V?$allocator@UBuffInfoStruct@@@std@@UBuffInfoStruct@@U3@@std@@YAXAAV?$allocator@UBuffInfoStruct@@@0@PAUBuffInfoStruct@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UBuffInfoStruct@@@std@@UBuffInfoStruct@@U3@@std@@YAXAAV?$allocator@UBuffInfoStruct@@@0@PAUBuffInfoStruct@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<BuffInfoStruct>,BuffInfoStruct,BuffInfoStruct>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	ff 75 10	 push	 DWORD PTR __Src$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Pdest$[ebp]
  0000c	e8 00 00 00 00	 call	 ?construct@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@$$QAU3@@Z ; std::allocator<BuffInfoStruct>::construct

; 281  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Cons_val@V?$allocator@UBuffInfoStruct@@@std@@UBuffInfoStruct@@U3@@std@@YAXAAV?$allocator@UBuffInfoStruct@@@0@PAUBuffInfoStruct@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<BuffInfoStruct>,BuffInfoStruct,BuffInfoStruct>
_TEXT	ENDS
PUBLIC	?GetTeam@ioPlayEntity@@QBE?AW4TeamType@@XZ	; ioPlayEntity::GetTeam
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioplayentity.h
;	COMDAT ?GetTeam@ioPlayEntity@@QBE?AW4TeamType@@XZ
_TEXT	SEGMENT
_value$700290 = -4					; size = 4
?GetTeam@ioPlayEntity@@QBE?AW4TeamType@@XZ PROC		; ioPlayEntity::GetTeam, COMDAT
; _this$ = ecx

; 107  : 	inline TeamType GetTeam() const { return m_TeamType; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$700290[ebp]
  00007	50		 push	 eax
  00008	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  0000e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  00013	8b 45 fc	 mov	 eax, DWORD PTR _value$700290[ebp]
  00016	c9		 leave
  00017	c3		 ret	 0
?GetTeam@ioPlayEntity@@QBE?AW4TeamType@@XZ ENDP		; ioPlayEntity::GetTeam
_TEXT	ENDS
PUBLIC	?GetCurSkillGuage@ioItem@@QBEMXZ		; ioItem::GetCurSkillGuage
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioitem.h
;	COMDAT ?GetCurSkillGuage@ioItem@@QBEMXZ
_TEXT	SEGMENT
_value$700296 = -4					; size = 4
?GetCurSkillGuage@ioItem@@QBEMXZ PROC			; ioItem::GetCurSkillGuage, COMDAT
; _this$ = ecx

; 367  : 	inline float GetCurSkillGuage() const { return m_fCurSkillGauge; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$700296[ebp]
  00007	50		 push	 eax
  00008	81 c1 f4 03 00
	00		 add	 ecx, 1012		; 000003f4H
  0000e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  00013	d9 45 fc	 fld	 DWORD PTR _value$700296[ebp]
  00016	c9		 leave
  00017	c3		 ret	 0
?GetCurSkillGuage@ioItem@@QBEMXZ ENDP			; ioItem::GetCurSkillGuage
_TEXT	ENDS
PUBLIC	?GetTeam@ioWeapon@@QBE?AW4TeamType@@XZ		; ioWeapon::GetTeam
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioweapon.h
;	COMDAT ?GetTeam@ioWeapon@@QBE?AW4TeamType@@XZ
_TEXT	SEGMENT
_value$700304 = -4					; size = 4
?GetTeam@ioWeapon@@QBE?AW4TeamType@@XZ PROC		; ioWeapon::GetTeam, COMDAT
; _this$ = ecx

; 534  : 	inline TeamType GetTeam() const { return m_TeamType; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$700304[ebp]
  00007	50		 push	 eax
  00008	83 c1 30	 add	 ecx, 48			; 00000030H
  0000b	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  00010	8b 45 fc	 mov	 eax, DWORD PTR _value$700304[ebp]
  00013	c9		 leave
  00014	c3		 ret	 0
?GetTeam@ioWeapon@@QBE?AW4TeamType@@XZ ENDP		; ioWeapon::GetTeam
_TEXT	ENDS
PUBLIC	?GetChangeJumppingPowerRate@ioWeapon@@QBEMXZ	; ioWeapon::GetChangeJumppingPowerRate
; Function compile flags: /Ogsp
;	COMDAT ?GetChangeJumppingPowerRate@ioWeapon@@QBEMXZ
_TEXT	SEGMENT
_value$700310 = -4					; size = 4
?GetChangeJumppingPowerRate@ioWeapon@@QBEMXZ PROC	; ioWeapon::GetChangeJumppingPowerRate, COMDAT
; _this$ = ecx

; 545  : 	inline float GetChangeJumppingPowerRate() const { return m_fChangeJumppingPowerRate; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$700310[ebp]
  00007	50		 push	 eax
  00008	81 c1 ac 05 00
	00		 add	 ecx, 1452		; 000005acH
  0000e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  00013	d9 45 fc	 fld	 DWORD PTR _value$700310[ebp]
  00016	c9		 leave
  00017	c3		 ret	 0
?GetChangeJumppingPowerRate@ioWeapon@@QBEMXZ ENDP	; ioWeapon::GetChangeJumppingPowerRate
_TEXT	ENDS
PUBLIC	?GetChangeJumppingLimitCnt@ioWeapon@@QBEHXZ	; ioWeapon::GetChangeJumppingLimitCnt
; Function compile flags: /Ogsp
;	COMDAT ?GetChangeJumppingLimitCnt@ioWeapon@@QBEHXZ
_TEXT	SEGMENT
_value$700317 = -4					; size = 4
?GetChangeJumppingLimitCnt@ioWeapon@@QBEHXZ PROC	; ioWeapon::GetChangeJumppingLimitCnt, COMDAT
; _this$ = ecx

; 546  : 	inline int GetChangeJumppingLimitCnt() const { return m_iChangeJumppingCnt; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$700317[ebp]
  00007	50		 push	 eax
  00008	81 c1 dc 05 00
	00		 add	 ecx, 1500		; 000005dcH
  0000e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ; CEncrypt<int>::DecryptValueToPool
  00013	8b 45 fc	 mov	 eax, DWORD PTR _value$700317[ebp]
  00016	c9		 leave
  00017	c3		 ret	 0
?GetChangeJumppingLimitCnt@ioWeapon@@QBEHXZ ENDP	; ioWeapon::GetChangeJumppingLimitCnt
_TEXT	ENDS
PUBLIC	?IsIgnoreProtect@ioWeapon@@QBEHXZ		; ioWeapon::IsIgnoreProtect
; Function compile flags: /Ogsp
;	COMDAT ?IsIgnoreProtect@ioWeapon@@QBEHXZ
_TEXT	SEGMENT
_value$700324 = -4					; size = 4
?IsIgnoreProtect@ioWeapon@@QBEHXZ PROC			; ioWeapon::IsIgnoreProtect, COMDAT
; _this$ = ecx

; 548  : 	inline int IsIgnoreProtect() const { return m_iIgnoreProtect; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$700324[ebp]
  00007	50		 push	 eax
  00008	81 c1 0c 06 00
	00		 add	 ecx, 1548		; 0000060cH
  0000e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ; CEncrypt<int>::DecryptValueToPool
  00013	8b 45 fc	 mov	 eax, DWORD PTR _value$700324[ebp]
  00016	c9		 leave
  00017	c3		 ret	 0
?IsIgnoreProtect@ioWeapon@@QBEHXZ ENDP			; ioWeapon::IsIgnoreProtect
_TEXT	ENDS
PUBLIC	?IsCollisionCancel@ioWeapon@@QBE_NXZ		; ioWeapon::IsCollisionCancel
; Function compile flags: /Ogsp
;	COMDAT ?IsCollisionCancel@ioWeapon@@QBE_NXZ
_TEXT	SEGMENT
_value$700331 = -1					; size = 1
?IsCollisionCancel@ioWeapon@@QBE_NXZ PROC		; ioWeapon::IsCollisionCancel, COMDAT
; _this$ = ecx

; 551  : 	inline bool IsCollisionCancel() const { return m_bCollisionCancel; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 ff	 lea	 eax, DWORD PTR _value$700331[ebp]
  00007	50		 push	 eax
  00008	81 c1 70 06 00
	00		 add	 ecx, 1648		; 00000670H
  0000e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  00013	8a 45 ff	 mov	 al, BYTE PTR _value$700331[ebp]
  00016	c9		 leave
  00017	c3		 ret	 0
?IsCollisionCancel@ioWeapon@@QBE_NXZ ENDP		; ioWeapon::IsCollisionCancel
_TEXT	ENDS
PUBLIC	?GetGrowthAttackRate@ioWeapon@@QBEMXZ		; ioWeapon::GetGrowthAttackRate
; Function compile flags: /Ogsp
;	COMDAT ?GetGrowthAttackRate@ioWeapon@@QBEMXZ
_TEXT	SEGMENT
_value$700338 = -4					; size = 4
?GetGrowthAttackRate@ioWeapon@@QBEMXZ PROC		; ioWeapon::GetGrowthAttackRate, COMDAT
; _this$ = ecx

; 673  : 	inline float GetGrowthAttackRate() const { return m_fGrowthAttackRate; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$700338[ebp]
  00007	50		 push	 eax
  00008	81 c1 c0 03 00
	00		 add	 ecx, 960		; 000003c0H
  0000e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  00013	d9 45 fc	 fld	 DWORD PTR _value$700338[ebp]
  00016	c9		 leave
  00017	c3		 ret	 0
?GetGrowthAttackRate@ioWeapon@@QBEMXZ ENDP		; ioWeapon::GetGrowthAttackRate
_TEXT	ENDS
PUBLIC	?GetSubSkillType@ioSkill@@QBEHXZ		; ioSkill::GetSubSkillType
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioskill.h
;	COMDAT ?GetSubSkillType@ioSkill@@QBEHXZ
_TEXT	SEGMENT
_value$700345 = -4					; size = 4
?GetSubSkillType@ioSkill@@QBEHXZ PROC			; ioSkill::GetSubSkillType, COMDAT
; _this$ = ecx

; 399  : 	inline int GetSubSkillType() const { return m_iSubSkillType; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$700345[ebp]
  00007	50		 push	 eax
  00008	81 c1 20 03 00
	00		 add	 ecx, 800		; 00000320H
  0000e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ; CEncrypt<int>::DecryptValueToPool
  00013	8b 45 fc	 mov	 eax, DWORD PTR _value$700345[ebp]
  00016	c9		 leave
  00017	c3		 ret	 0
?GetSubSkillType@ioSkill@@QBEHXZ ENDP			; ioSkill::GetSubSkillType
_TEXT	ENDS
PUBLIC	?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ	; ioPlayMode::GetModeType
EXTRN	?m_ModeType@ioPlayMode@@1V?$CEncrypt@W4ModeType@@@@A:BYTE ; ioPlayMode::m_ModeType
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioplaymode.h
;	COMDAT ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ
_TEXT	SEGMENT
?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ PROC	; ioPlayMode::GetModeType, COMDAT

; 782  : 	static ModeType GetModeType() { return m_ModeType; }

  00000	6a 04		 push	 4
  00002	68 28 00 00 00	 push	 OFFSET ?m_ModeType@ioPlayMode@@1V?$CEncrypt@W4ModeType@@@@A+40
  00007	68 1c 00 00 00	 push	 OFFSET ?m_ModeType@ioPlayMode@@1V?$CEncrypt@W4ModeType@@@@A+28
  0000c	b9 0c 00 00 00	 mov	 ecx, OFFSET ?m_ModeType@ioPlayMode@@1V?$CEncrypt@W4ModeType@@@@A+12
  00011	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte
  00016	a1 28 00 00 00	 mov	 eax, DWORD PTR ?m_ModeType@ioPlayMode@@1V?$CEncrypt@W4ModeType@@@@A+40
  0001b	c3		 ret	 0
?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ENDP	; ioPlayMode::GetModeType
_TEXT	ENDS
PUBLIC	??_R0?AVioPlayMode@@@8				; ioPlayMode `RTTI Type Descriptor'
PUBLIC	??_R0?AVioUnderwearMode@@@8			; ioUnderwearMode `RTTI Type Descriptor'
PUBLIC	?ToUnderWearMode@@YAPAVioUnderwearMode@@PAVioPlayMode@@@Z ; ToUnderWearMode
;	COMDAT ??_R0?AVioPlayMode@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iounderwearmode.h
_DATA	SEGMENT
??_R0?AVioPlayMode@@@8 DD FLAT:??_7type_info@@6B@	; ioPlayMode `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioPlayMode@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVioUnderwearMode@@@8
_DATA	SEGMENT
??_R0?AVioUnderwearMode@@@8 DD FLAT:??_7type_info@@6B@	; ioUnderwearMode `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioUnderwearMode@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToUnderWearMode@@YAPAVioUnderwearMode@@PAVioPlayMode@@@Z
_TEXT	SEGMENT
_pMode$ = 8						; size = 4
?ToUnderWearMode@@YAPAVioUnderwearMode@@PAVioPlayMode@@@Z PROC ; ToUnderWearMode, COMDAT

; 169  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 	if( !pMode || pMode->GetModeType() != MT_UNDERWEAR )

  00003	83 7d 08 00	 cmp	 DWORD PTR _pMode$[ebp], 0
  00007	74 25		 je	 SHORT $LN1@ToUnderWea
  00009	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  0000e	83 f8 19	 cmp	 eax, 25			; 00000019H
  00011	75 1b		 jne	 SHORT $LN1@ToUnderWea

; 172  : 
; 173  : 	return dynamic_cast< ioUnderwearMode* >( pMode );

  00013	6a 00		 push	 0
  00015	68 00 00 00 00	 push	 OFFSET ??_R0?AVioUnderwearMode@@@8
  0001a	68 00 00 00 00	 push	 OFFSET ??_R0?AVioPlayMode@@@8
  0001f	6a 00		 push	 0
  00021	ff 75 08	 push	 DWORD PTR _pMode$[ebp]
  00024	e8 00 00 00 00	 call	 ___RTDynamicCast
  00029	83 c4 14	 add	 esp, 20			; 00000014H

; 174  : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
$LN1@ToUnderWea:

; 171  : 		return NULL;

  0002e	33 c0		 xor	 eax, eax

; 174  : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?ToUnderWearMode@@YAPAVioUnderwearMode@@PAVioPlayMode@@@Z ENDP ; ToUnderWearMode
_TEXT	ENDS
PUBLIC	??_R0?AVioCBTMode@@@8				; ioCBTMode `RTTI Type Descriptor'
PUBLIC	?ToCBTMode@@YAPAVioCBTMode@@PAVioPlayMode@@@Z	; ToCBTMode
;	COMDAT ??_R0?AVioCBTMode@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iocbtmode.h
_DATA	SEGMENT
??_R0?AVioCBTMode@@@8 DD FLAT:??_7type_info@@6B@	; ioCBTMode `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioCBTMode@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToCBTMode@@YAPAVioCBTMode@@PAVioPlayMode@@@Z
_TEXT	SEGMENT
_pMode$ = 8						; size = 4
?ToCBTMode@@YAPAVioCBTMode@@PAVioPlayMode@@@Z PROC	; ToCBTMode, COMDAT

; 170  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 171  : 	if( !pMode || pMode->GetModeType() != MT_CBT )

  00003	83 7d 08 00	 cmp	 DWORD PTR _pMode$[ebp], 0
  00007	74 25		 je	 SHORT $LN1@ToCBTMode
  00009	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  0000e	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  00011	75 1b		 jne	 SHORT $LN1@ToCBTMode

; 173  : 
; 174  : 	return dynamic_cast< ioCBTMode* >( pMode );

  00013	6a 00		 push	 0
  00015	68 00 00 00 00	 push	 OFFSET ??_R0?AVioCBTMode@@@8
  0001a	68 00 00 00 00	 push	 OFFSET ??_R0?AVioPlayMode@@@8
  0001f	6a 00		 push	 0
  00021	ff 75 08	 push	 DWORD PTR _pMode$[ebp]
  00024	e8 00 00 00 00	 call	 ___RTDynamicCast
  00029	83 c4 14	 add	 esp, 20			; 00000014H

; 175  : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
$LN1@ToCBTMode:

; 172  : 		return NULL;

  0002e	33 c0		 xor	 eax, eax

; 175  : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?ToCBTMode@@YAPAVioCBTMode@@PAVioPlayMode@@@Z ENDP	; ToCBTMode
_TEXT	ENDS
PUBLIC	??_R0?AVioCatchMode@@@8				; ioCatchMode `RTTI Type Descriptor'
PUBLIC	?ToCatchMode@@YAPAVioCatchMode@@PAVioPlayMode@@@Z ; ToCatchMode
;	COMDAT ??_R0?AVioCatchMode@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iocatchmode.h
_DATA	SEGMENT
??_R0?AVioCatchMode@@@8 DD FLAT:??_7type_info@@6B@	; ioCatchMode `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioCatchMode@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToCatchMode@@YAPAVioCatchMode@@PAVioPlayMode@@@Z
_TEXT	SEGMENT
_pMode$ = 8						; size = 4
?ToCatchMode@@YAPAVioCatchMode@@PAVioPlayMode@@@Z PROC	; ToCatchMode, COMDAT

; 168  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 169  : 	if( !pMode || pMode->GetModeType() != MT_CATCH )

  00003	83 7d 08 00	 cmp	 DWORD PTR _pMode$[ebp], 0
  00007	74 25		 je	 SHORT $LN1@ToCatchMod
  00009	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  0000e	83 f8 02	 cmp	 eax, 2
  00011	75 1b		 jne	 SHORT $LN1@ToCatchMod

; 171  : 
; 172  : 	return dynamic_cast< ioCatchMode* >( pMode );

  00013	6a 00		 push	 0
  00015	68 00 00 00 00	 push	 OFFSET ??_R0?AVioCatchMode@@@8
  0001a	68 00 00 00 00	 push	 OFFSET ??_R0?AVioPlayMode@@@8
  0001f	6a 00		 push	 0
  00021	ff 75 08	 push	 DWORD PTR _pMode$[ebp]
  00024	e8 00 00 00 00	 call	 ___RTDynamicCast
  00029	83 c4 14	 add	 esp, 20			; 00000014H

; 173  : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
$LN1@ToCatchMod:

; 170  : 		return NULL;

  0002e	33 c0		 xor	 eax, eax

; 173  : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?ToCatchMode@@YAPAVioCatchMode@@PAVioPlayMode@@@Z ENDP	; ToCatchMode
_TEXT	ENDS
PUBLIC	??_R0?AVioCatchRunningManMode@@@8		; ioCatchRunningManMode `RTTI Type Descriptor'
PUBLIC	?ToCatchRunningManMode@@YAPAVioCatchRunningManMode@@PAVioPlayMode@@@Z ; ToCatchRunningManMode
;	COMDAT ??_R0?AVioCatchRunningManMode@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iocatchrunningmanmode.h
_DATA	SEGMENT
??_R0?AVioCatchRunningManMode@@@8 DD FLAT:??_7type_info@@6B@ ; ioCatchRunningManMode `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioCatchRunningManMode@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToCatchRunningManMode@@YAPAVioCatchRunningManMode@@PAVioPlayMode@@@Z
_TEXT	SEGMENT
_pMode$ = 8						; size = 4
?ToCatchRunningManMode@@YAPAVioCatchRunningManMode@@PAVioPlayMode@@@Z PROC ; ToCatchRunningManMode, COMDAT

; 106  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 107  : 	if( !pMode || pMode->GetModeType() != MT_CATCH_RUNNINGMAN )

  00003	83 7d 08 00	 cmp	 DWORD PTR _pMode$[ebp], 0
  00007	74 25		 je	 SHORT $LN1@ToCatchRun
  00009	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  0000e	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  00011	75 1b		 jne	 SHORT $LN1@ToCatchRun

; 109  : 
; 110  : 	return dynamic_cast< ioCatchRunningManMode* >( pMode );

  00013	6a 00		 push	 0
  00015	68 00 00 00 00	 push	 OFFSET ??_R0?AVioCatchRunningManMode@@@8
  0001a	68 00 00 00 00	 push	 OFFSET ??_R0?AVioPlayMode@@@8
  0001f	6a 00		 push	 0
  00021	ff 75 08	 push	 DWORD PTR _pMode$[ebp]
  00024	e8 00 00 00 00	 call	 ___RTDynamicCast
  00029	83 c4 14	 add	 esp, 20			; 00000014H

; 111  : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
$LN1@ToCatchRun:

; 108  : 		return NULL;

  0002e	33 c0		 xor	 eax, eax

; 111  : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?ToCatchRunningManMode@@YAPAVioCatchRunningManMode@@PAVioPlayMode@@@Z ENDP ; ToCatchRunningManMode
_TEXT	ENDS
PUBLIC	??_R0?AVioFightClubMode@@@8			; ioFightClubMode `RTTI Type Descriptor'
PUBLIC	?ToFightClubMode@@YAPAVioFightClubMode@@PAVioPlayMode@@@Z ; ToFightClubMode
;	COMDAT ??_R0?AVioFightClubMode@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iofightclubmode.h
_DATA	SEGMENT
??_R0?AVioFightClubMode@@@8 DD FLAT:??_7type_info@@6B@	; ioFightClubMode `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioFightClubMode@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToFightClubMode@@YAPAVioFightClubMode@@PAVioPlayMode@@@Z
_TEXT	SEGMENT
_pMode$ = 8						; size = 4
?ToFightClubMode@@YAPAVioFightClubMode@@PAVioPlayMode@@@Z PROC ; ToFightClubMode, COMDAT

; 236  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 237  : 	if( !pMode || pMode->GetModeType() != MT_FIGHT_CLUB )

  00003	83 7d 08 00	 cmp	 DWORD PTR _pMode$[ebp], 0
  00007	74 25		 je	 SHORT $LN1@ToFightClu
  00009	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  0000e	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00011	75 1b		 jne	 SHORT $LN1@ToFightClu

; 239  : 
; 240  : 	return dynamic_cast< ioFightClubMode* >( pMode );

  00013	6a 00		 push	 0
  00015	68 00 00 00 00	 push	 OFFSET ??_R0?AVioFightClubMode@@@8
  0001a	68 00 00 00 00	 push	 OFFSET ??_R0?AVioPlayMode@@@8
  0001f	6a 00		 push	 0
  00021	ff 75 08	 push	 DWORD PTR _pMode$[ebp]
  00024	e8 00 00 00 00	 call	 ___RTDynamicCast
  00029	83 c4 14	 add	 esp, 20			; 00000014H

; 241  : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
$LN1@ToFightClu:

; 238  : 		return NULL;

  0002e	33 c0		 xor	 eax, eax

; 241  : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?ToFightClubMode@@YAPAVioFightClubMode@@PAVioPlayMode@@@Z ENDP ; ToFightClubMode
_TEXT	ENDS
PUBLIC	??0?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAE@XZ ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAE@XZ PROC ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAE@XZ ENDP ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@@Z ; std::allocator<ioHashString>::destroy
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@@Z PROC ; std::allocator<ioHashString>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 213  : 		_Destroy(_Ptr);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ

; 214  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?destroy@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@@Z ENDP ; std::allocator<ioHashString>::destroy
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@@Z ; std::allocator<BuffInfoStruct>::destroy
; Function compile flags: /Ogsp
;	COMDAT ?destroy@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@@Z PROC ; std::allocator<BuffInfoStruct>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 213  : 		_Destroy(_Ptr);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ

; 214  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?destroy@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@@Z ENDP ; std::allocator<BuffInfoStruct>::destroy
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UBuffInfoStruct@@@std@@UBuffInfoStruct@@AAU3@@std@@YAXAAV?$allocator@UBuffInfoStruct@@@0@PAUBuffInfoStruct@@AAU2@@Z ; std::_Cons_val<std::allocator<BuffInfoStruct>,BuffInfoStruct,BuffInfoStruct &>
; Function compile flags: /Ogsp
;	COMDAT ??$_Cons_val@V?$allocator@UBuffInfoStruct@@@std@@UBuffInfoStruct@@AAU3@@std@@YAXAAV?$allocator@UBuffInfoStruct@@@0@PAUBuffInfoStruct@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UBuffInfoStruct@@@std@@UBuffInfoStruct@@AAU3@@std@@YAXAAV?$allocator@UBuffInfoStruct@@@0@PAUBuffInfoStruct@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<BuffInfoStruct>,BuffInfoStruct,BuffInfoStruct &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	ff 75 10	 push	 DWORD PTR __Src$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Pdest$[ebp]
  0000c	e8 00 00 00 00	 call	 ??$construct@AAUBuffInfoStruct@@@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@AAU2@@Z ; std::allocator<BuffInfoStruct>::construct<BuffInfoStruct &>

; 281  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Cons_val@V?$allocator@UBuffInfoStruct@@@std@@UBuffInfoStruct@@AAU3@@std@@YAXAAV?$allocator@UBuffInfoStruct@@@0@PAUBuffInfoStruct@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<BuffInfoStruct>,BuffInfoStruct,BuffInfoStruct &>
_TEXT	ENDS
PUBLIC	??_R0?AVioTargetMissile2Skill@@@8		; ioTargetMissile2Skill `RTTI Type Descriptor'
PUBLIC	?ToTargetMissile2Skill@@YAPAVioTargetMissile2Skill@@PAVioSkill@@@Z ; ToTargetMissile2Skill
;	COMDAT ??_R0?AVioTargetMissile2Skill@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
_DATA	SEGMENT
??_R0?AVioTargetMissile2Skill@@@8 DD FLAT:??_7type_info@@6B@ ; ioTargetMissile2Skill `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioTargetMissile2Skill@@', 00H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iotargetmissile2skill.h
_DATA	ENDS
;	COMDAT ?ToTargetMissile2Skill@@YAPAVioTargetMissile2Skill@@PAVioSkill@@@Z
_TEXT	SEGMENT
_value$700435 = -4					; size = 4
_pSkill$ = 8						; size = 4
?ToTargetMissile2Skill@@YAPAVioTargetMissile2Skill@@PAVioSkill@@@Z PROC ; ToTargetMissile2Skill, COMDAT

; 226  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 227  : 	ioNormalSkill *pNormal = ToNormalSkill( pSkill );

  00004	ff 75 08	 push	 DWORD PTR _pSkill$[ebp]
  00007	e8 00 00 00 00	 call	 ?ToNormalSkill@@YAPAVioNormalSkill@@PAVioSkill@@@Z ; ToNormalSkill
  0000c	59		 pop	 ecx

; 228  : 	if( !pNormal || pNormal->GetSubSkillType() != NST_TARGET_MISSILE2 )

  0000d	85 c0		 test	 eax, eax
  0000f	74 30		 je	 SHORT $LN1@ToTargetMi
  00011	8d 4d fc	 lea	 ecx, DWORD PTR _value$700435[ebp]
  00014	51		 push	 ecx
  00015	8d 88 20 03 00
	00		 lea	 ecx, DWORD PTR [eax+800]
  0001b	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ; CEncrypt<int>::DecryptValueToPool
  00020	83 7d fc 49	 cmp	 DWORD PTR _value$700435[ebp], 73 ; 00000049H
  00024	75 1b		 jne	 SHORT $LN1@ToTargetMi

; 230  : 
; 231  : 	return dynamic_cast< ioTargetMissile2Skill* >( pSkill );

  00026	6a 00		 push	 0
  00028	68 00 00 00 00	 push	 OFFSET ??_R0?AVioTargetMissile2Skill@@@8
  0002d	68 00 00 00 00	 push	 OFFSET ??_R0?AVioSkill@@@8
  00032	6a 00		 push	 0
  00034	ff 75 08	 push	 DWORD PTR _pSkill$[ebp]
  00037	e8 00 00 00 00	 call	 ___RTDynamicCast
  0003c	83 c4 14	 add	 esp, 20			; 00000014H

; 232  : }

  0003f	c9		 leave
  00040	c3		 ret	 0
$LN1@ToTargetMi:

; 229  : 		return NULL;

  00041	33 c0		 xor	 eax, eax

; 232  : }

  00043	c9		 leave
  00044	c3		 ret	 0
?ToTargetMissile2Skill@@YAPAVioTargetMissile2Skill@@PAVioSkill@@@Z ENDP ; ToTargetMissile2Skill
_TEXT	ENDS
PUBLIC	??_R0?AVioRandomPassiveSkill@@@8		; ioRandomPassiveSkill `RTTI Type Descriptor'
PUBLIC	?ToRandomPassiveSkill@@YAPAVioRandomPassiveSkill@@PAVioSkill@@@Z ; ToRandomPassiveSkill
;	COMDAT ??_R0?AVioRandomPassiveSkill@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
_DATA	SEGMENT
??_R0?AVioRandomPassiveSkill@@@8 DD FLAT:??_7type_info@@6B@ ; ioRandomPassiveSkill `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioRandomPassiveSkill@@', 00H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iorandompassiveskill.h
_DATA	ENDS
;	COMDAT ?ToRandomPassiveSkill@@YAPAVioRandomPassiveSkill@@PAVioSkill@@@Z
_TEXT	SEGMENT
_value$700449 = -4					; size = 4
_pSkill$ = 8						; size = 4
?ToRandomPassiveSkill@@YAPAVioRandomPassiveSkill@@PAVioSkill@@@Z PROC ; ToRandomPassiveSkill, COMDAT

; 50   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 51   : 	ioPassiveSkill *pPassive = ToPassiveSkill( pSkill );

  00004	ff 75 08	 push	 DWORD PTR _pSkill$[ebp]
  00007	e8 00 00 00 00	 call	 ?ToPassiveSkill@@YAPAVioPassiveSkill@@PAVioSkill@@@Z ; ToPassiveSkill
  0000c	59		 pop	 ecx

; 52   : 	if( !pPassive || pPassive->GetSubSkillType() != PST_RANDOM )

  0000d	85 c0		 test	 eax, eax
  0000f	74 30		 je	 SHORT $LN1@ToRandomPa
  00011	8d 4d fc	 lea	 ecx, DWORD PTR _value$700449[ebp]
  00014	51		 push	 ecx
  00015	8d 88 20 03 00
	00		 lea	 ecx, DWORD PTR [eax+800]
  0001b	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ; CEncrypt<int>::DecryptValueToPool
  00020	83 7d fc 02	 cmp	 DWORD PTR _value$700449[ebp], 2
  00024	75 1b		 jne	 SHORT $LN1@ToRandomPa

; 54   : 
; 55   : 	return dynamic_cast< ioRandomPassiveSkill* >( pSkill );

  00026	6a 00		 push	 0
  00028	68 00 00 00 00	 push	 OFFSET ??_R0?AVioRandomPassiveSkill@@@8
  0002d	68 00 00 00 00	 push	 OFFSET ??_R0?AVioSkill@@@8
  00032	6a 00		 push	 0
  00034	ff 75 08	 push	 DWORD PTR _pSkill$[ebp]
  00037	e8 00 00 00 00	 call	 ___RTDynamicCast
  0003c	83 c4 14	 add	 esp, 20			; 00000014H

; 56   : }

  0003f	c9		 leave
  00040	c3		 ret	 0
$LN1@ToRandomPa:

; 53   : 		return NULL;

  00041	33 c0		 xor	 eax, eax

; 56   : }

  00043	c9		 leave
  00044	c3		 ret	 0
?ToRandomPassiveSkill@@YAPAVioRandomPassiveSkill@@PAVioSkill@@@Z ENDP ; ToRandomPassiveSkill
_TEXT	ENDS
PUBLIC	??_R0?AVioAccessoryPassiveSkill@@@8		; ioAccessoryPassiveSkill `RTTI Type Descriptor'
PUBLIC	?ToAccessoryPassiveSkill@@YAPAVioAccessoryPassiveSkill@@PAVioSkill@@@Z ; ToAccessoryPassiveSkill
;	COMDAT ??_R0?AVioAccessoryPassiveSkill@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
_DATA	SEGMENT
??_R0?AVioAccessoryPassiveSkill@@@8 DD FLAT:??_7type_info@@6B@ ; ioAccessoryPassiveSkill `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioAccessoryPassiveSkill@@', 00H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioaccessorypassiveskill.h
_DATA	ENDS
;	COMDAT ?ToAccessoryPassiveSkill@@YAPAVioAccessoryPassiveSkill@@PAVioSkill@@@Z
_TEXT	SEGMENT
_value$700463 = -4					; size = 4
_pSkill$ = 8						; size = 4
?ToAccessoryPassiveSkill@@YAPAVioAccessoryPassiveSkill@@PAVioSkill@@@Z PROC ; ToAccessoryPassiveSkill, COMDAT

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 41   : 	ioPassiveSkill *pPassive = ToPassiveSkill( pSkill );

  00004	ff 75 08	 push	 DWORD PTR _pSkill$[ebp]
  00007	e8 00 00 00 00	 call	 ?ToPassiveSkill@@YAPAVioPassiveSkill@@PAVioSkill@@@Z ; ToPassiveSkill
  0000c	59		 pop	 ecx

; 42   : 	if( !pPassive || pPassive->GetSubSkillType() != PST_ASSESSORY )

  0000d	85 c0		 test	 eax, eax
  0000f	74 30		 je	 SHORT $LN1@ToAccessor
  00011	8d 4d fc	 lea	 ecx, DWORD PTR _value$700463[ebp]
  00014	51		 push	 ecx
  00015	8d 88 20 03 00
	00		 lea	 ecx, DWORD PTR [eax+800]
  0001b	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ; CEncrypt<int>::DecryptValueToPool
  00020	83 7d fc 03	 cmp	 DWORD PTR _value$700463[ebp], 3
  00024	75 1b		 jne	 SHORT $LN1@ToAccessor

; 44   : 
; 45   : 	return dynamic_cast< ioAccessoryPassiveSkill* >( pSkill );

  00026	6a 00		 push	 0
  00028	68 00 00 00 00	 push	 OFFSET ??_R0?AVioAccessoryPassiveSkill@@@8
  0002d	68 00 00 00 00	 push	 OFFSET ??_R0?AVioSkill@@@8
  00032	6a 00		 push	 0
  00034	ff 75 08	 push	 DWORD PTR _pSkill$[ebp]
  00037	e8 00 00 00 00	 call	 ___RTDynamicCast
  0003c	83 c4 14	 add	 esp, 20			; 00000014H

; 46   : }

  0003f	c9		 leave
  00040	c3		 ret	 0
$LN1@ToAccessor:

; 43   : 		return NULL;

  00041	33 c0		 xor	 eax, eax

; 46   : }

  00043	c9		 leave
  00044	c3		 ret	 0
?ToAccessoryPassiveSkill@@YAPAVioAccessoryPassiveSkill@@PAVioSkill@@@Z ENDP ; ToAccessoryPassiveSkill
_TEXT	ENDS
PUBLIC	??_R0?AVioShuffleBonusMode@@@8			; ioShuffleBonusMode `RTTI Type Descriptor'
PUBLIC	?ToShuffleBonusMode@@YAPAVioShuffleBonusMode@@PAVioPlayMode@@@Z ; ToShuffleBonusMode
;	COMDAT ??_R0?AVioShuffleBonusMode@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioshufflebonusmode.h
_DATA	SEGMENT
??_R0?AVioShuffleBonusMode@@@8 DD FLAT:??_7type_info@@6B@ ; ioShuffleBonusMode `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioShuffleBonusMode@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToShuffleBonusMode@@YAPAVioShuffleBonusMode@@PAVioPlayMode@@@Z
_TEXT	SEGMENT
_pMode$ = 8						; size = 4
?ToShuffleBonusMode@@YAPAVioShuffleBonusMode@@PAVioPlayMode@@@Z PROC ; ToShuffleBonusMode, COMDAT

; 241  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 242  : 	if( !pMode || pMode->GetModeType() != MT_SHUFFLE_BONUS )

  00003	83 7d 08 00	 cmp	 DWORD PTR _pMode$[ebp], 0
  00007	74 25		 je	 SHORT $LN1@ToShuffleB
  00009	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  0000e	83 f8 14	 cmp	 eax, 20			; 00000014H
  00011	75 1b		 jne	 SHORT $LN1@ToShuffleB

; 244  : 
; 245  : 	return dynamic_cast< ioShuffleBonusMode* >( pMode );

  00013	6a 00		 push	 0
  00015	68 00 00 00 00	 push	 OFFSET ??_R0?AVioShuffleBonusMode@@@8
  0001a	68 00 00 00 00	 push	 OFFSET ??_R0?AVioPlayMode@@@8
  0001f	6a 00		 push	 0
  00021	ff 75 08	 push	 DWORD PTR _pMode$[ebp]
  00024	e8 00 00 00 00	 call	 ___RTDynamicCast
  00029	83 c4 14	 add	 esp, 20			; 00000014H

; 246  : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
$LN1@ToShuffleB:

; 243  : 		return NULL;

  0002e	33 c0		 xor	 eax, eax

; 246  : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?ToShuffleBonusMode@@YAPAVioShuffleBonusMode@@PAVioPlayMode@@@Z ENDP ; ToShuffleBonusMode
_TEXT	ENDS
PUBLIC	__real@4059000000000000
PUBLIC	?ApplyWeaponWoundedBaseDamageCalc@ioBaseChar@@IAEXPAVioWeapon@@W4AttackSide@@AAM2_N@Z ; ioBaseChar::ApplyWeaponWoundedBaseDamageCalc
EXTRN	?IsEnableTeamDamage@ioBaseChar@@QAE_NXZ:PROC	; ioBaseChar::IsEnableTeamDamage
EXTRN	?GetFCBlockingRate@ioWeapon@@QAEHPAVioBaseChar@@@Z:PROC ; ioWeapon::GetFCBlockingRate
EXTRN	?GetGangsiBlockingRate@ioWeapon@@QAEHPAVioBaseChar@@@Z:PROC ; ioWeapon::GetGangsiBlockingRate
EXTRN	?GetNpcBlockingRate@ioWeapon@@QAEHPAVioBaseChar@@@Z:PROC ; ioWeapon::GetNpcBlockingRate
EXTRN	?CheckDamageIncreaseBuff@ioWeapon@@QAEMPAVioBaseChar@@@Z:PROC ; ioWeapon::CheckDamageIncreaseBuff
EXTRN	?UpdateBackAttackCount@ioBaseChar@@IAEXW4AttackSide@@@Z:PROC ; ioBaseChar::UpdateBackAttackCount
;	COMDAT __real@4059000000000000
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasecharapplywoundednew.cpp
CONST	ENDS
;	COMDAT ?ApplyWeaponWoundedBaseDamageCalc@ioBaseChar@@IAEXPAVioWeapon@@W4AttackSide@@AAM2_N@Z
_TEXT	SEGMENT
_pWeapon$ = 8						; size = 4
_value$700497 = 11					; size = 1
_value$700492 = 12					; size = 4
_value$700480 = 12					; size = 4
_eSide$ = 12						; size = 4
_fDamage$ = 16						; size = 4
_fBoundDamage$ = 20					; size = 4
_bTeamAttack$ = 24					; size = 1
?ApplyWeaponWoundedBaseDamageCalc@ioBaseChar@@IAEXPAVioWeapon@@W4AttackSide@@AAM2_N@Z PROC ; ioBaseChar::ApplyWeaponWoundedBaseDamageCalc, COMDAT
; _this$ = ecx

; 198  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	57		 push	 edi

; 199  : 	if ( !pWeapon )

  00005	8b 7d 08	 mov	 edi, DWORD PTR _pWeapon$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	85 ff		 test	 edi, edi
  0000c	0f 84 8f 01 00
	00		 je	 $LN1@ApplyWeapo@16

; 200  : 		return;
; 201  : 
; 202  : 	//---   
; 203  : 	UpdateBackAttackCount( eSide );

  00012	56		 push	 esi
  00013	8b 75 0c	 mov	 esi, DWORD PTR _eSide$[ebp]
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ?UpdateBackAttackCount@ioBaseChar@@IAEXW4AttackSide@@@Z ; ioBaseChar::UpdateBackAttackCount

; 204  : 	m_AttackedSide = eSide;
; 205  : 	
; 206  : 	// ,       
; 207  : 	fDamage *= pWeapon->GetGrowthAttackRate();

  0001c	8d 45 0c	 lea	 eax, DWORD PTR _value$700480[ebp]
  0001f	50		 push	 eax
  00020	8d 8f c0 03 00
	00		 lea	 ecx, DWORD PTR [edi+960]
  00026	89 b3 d4 0e 00
	00		 mov	 DWORD PTR [ebx+3796], esi
  0002c	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  00031	8b 75 10	 mov	 esi, DWORD PTR _fDamage$[ebp]
  00034	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  00038	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _value$700480[ebp]
  0003d	0f 5a c0	 cvtps2pd xmm0, xmm0
  00040	0f 5a c9	 cvtps2pd xmm1, xmm1

; 208  : 	fBoundDamage *= pWeapon->GetGrowthAttackRate();

  00043	8d 45 0c	 lea	 eax, DWORD PTR _value$700492[ebp]
  00046	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  0004a	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0004e	50		 push	 eax
  0004f	8d 8f c0 03 00
	00		 lea	 ecx, DWORD PTR [edi+960]
  00055	f3 0f 11 06	 movss	 DWORD PTR [esi], xmm0
  00059	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  0005e	8b 7d 14	 mov	 edi, DWORD PTR _fBoundDamage$[ebp]
  00061	f3 0f 10 07	 movss	 xmm0, DWORD PTR [edi]
  00065	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _value$700492[ebp]

; 209  : 
; 210  : 	//--- 
; 211  : 	// weapon increase buff 
; 212  : 	fDamage *= pWeapon->CheckDamageIncreaseBuff( this );

  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  0006d	0f 5a c0	 cvtps2pd xmm0, xmm0
  00070	0f 5a c9	 cvtps2pd xmm1, xmm1
  00073	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00077	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0007b	53		 push	 ebx
  0007c	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0
  00080	e8 00 00 00 00	 call	 ?CheckDamageIncreaseBuff@ioWeapon@@QAEMPAVioBaseChar@@@Z ; ioWeapon::CheckDamageIncreaseBuff
  00085	d8 0e		 fmul	 DWORD PTR [esi]

; 213  : 
; 214  : 	// Block Damage
; 215  : 	float fBlockRate = (float)pWeapon->GetNpcBlockingRate( this ) / 100.0f;

  00087	8b 4d 08	 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  0008a	53		 push	 ebx
  0008b	d9 1e		 fstp	 DWORD PTR [esi]
  0008d	e8 00 00 00 00	 call	 ?GetNpcBlockingRate@ioWeapon@@QAEHPAVioBaseChar@@@Z ; ioWeapon::GetNpcBlockingRate

; 216  : 	fDamage *= fBlockRate;

  00092	f3 0f 10 0e	 movss	 xmm1, DWORD PTR [esi]

; 217  : 	fBoundDamage *= fBlockRate;
; 218  : 
; 219  : 	//  Block Damage
; 220  : 	fBlockRate = (float)pWeapon->GetGangsiBlockingRate( this ) / 100.0f;

  00096	8b 4d 08	 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  00099	0f 57 c0	 xorps	 xmm0, xmm0
  0009c	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000a0	0f 5a c0	 cvtps2pd xmm0, xmm0
  000a3	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4059000000000000
  000ab	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  000af	0f 5a c9	 cvtps2pd xmm1, xmm1
  000b2	0f 57 d2	 xorps	 xmm2, xmm2
  000b5	f3 0f 5a d0	 cvtss2sd xmm2, xmm0
  000b9	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  000bd	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  000c1	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  000c5	f3 0f 11 0e	 movss	 DWORD PTR [esi], xmm1
  000c9	f3 0f 10 0f	 movss	 xmm1, DWORD PTR [edi]
  000cd	0f 5a c9	 cvtps2pd xmm1, xmm1
  000d0	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  000d4	53		 push	 ebx
  000d5	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  000d9	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0
  000dd	e8 00 00 00 00	 call	 ?GetGangsiBlockingRate@ioWeapon@@QAEHPAVioBaseChar@@@Z ; ioWeapon::GetGangsiBlockingRate

; 221  : 	fDamage *= fBlockRate;

  000e2	f3 0f 10 0e	 movss	 xmm1, DWORD PTR [esi]
  000e6	0f 57 c0	 xorps	 xmm0, xmm0
  000e9	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000ed	0f 5a c0	 cvtps2pd xmm0, xmm0
  000f0	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4059000000000000
  000f8	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  000fc	0f 5a c9	 cvtps2pd xmm1, xmm1
  000ff	0f 57 d2	 xorps	 xmm2, xmm2
  00102	f3 0f 5a d0	 cvtss2sd xmm2, xmm0
  00106	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  0010a	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  0010e	f3 0f 11 0e	 movss	 DWORD PTR [esi], xmm1

; 222  : 	fBoundDamage *= fBlockRate;

  00112	f3 0f 10 0f	 movss	 xmm1, DWORD PTR [edi]
  00116	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  0011a	0f 5a c9	 cvtps2pd xmm1, xmm1
  0011d	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  00121	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  00125	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 223  : 
; 224  : 	// FC Block Damage
; 225  : 	if( ToFightClubMode(m_pModeParent) )

  00129	ff b3 8c 00 00
	00		 push	 DWORD PTR [ebx+140]
  0012f	e8 00 00 00 00	 call	 ?ToFightClubMode@@YAPAVioFightClubMode@@PAVioPlayMode@@@Z ; ToFightClubMode
  00134	59		 pop	 ecx
  00135	85 c0		 test	 eax, eax
  00137	74 36		 je	 SHORT $LN2@ApplyWeapo@16

; 226  : 	{
; 227  : 		fBlockRate = (float)pWeapon->GetFCBlockingRate( this ) / 100.0f;

  00139	8b 4d 08	 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  0013c	53		 push	 ebx
  0013d	e8 00 00 00 00	 call	 ?GetFCBlockingRate@ioWeapon@@QAEHPAVioBaseChar@@@Z ; ioWeapon::GetFCBlockingRate

; 228  : 		fDamage *= fBlockRate;

  00142	f3 0f 10 0e	 movss	 xmm1, DWORD PTR [esi]
  00146	0f 57 c0	 xorps	 xmm0, xmm0
  00149	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0014d	0f 5a c0	 cvtps2pd xmm0, xmm0
  00150	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4059000000000000
  00158	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0015c	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00160	0f 5a c9	 cvtps2pd xmm1, xmm1
  00163	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  00167	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  0016b	f3 0f 11 06	 movss	 DWORD PTR [esi], xmm0
$LN2@ApplyWeapo@16:

; 229  : 	}
; 230  : 
; 231  : 	//    bTeamAttack   0
; 232  : 	if( !m_bPrisonerMode && bTeamAttack && !IsEnableTeamDamage() )

  0016f	8d 45 0b	 lea	 eax, DWORD PTR _value$700497[ebp]
  00172	50		 push	 eax
  00173	8d 8b cc 14 00
	00		 lea	 ecx, DWORD PTR [ebx+5324]
  00179	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  0017e	80 7d 0b 00	 cmp	 BYTE PTR _value$700497[ebp], 0
  00182	75 1c		 jne	 SHORT $LN16@ApplyWeapo@16
  00184	80 7d 18 00	 cmp	 BYTE PTR _bTeamAttack$[ebp], 0
  00188	74 16		 je	 SHORT $LN16@ApplyWeapo@16
  0018a	8b cb		 mov	 ecx, ebx
  0018c	e8 00 00 00 00	 call	 ?IsEnableTeamDamage@ioBaseChar@@QAE_NXZ ; ioBaseChar::IsEnableTeamDamage
  00191	84 c0		 test	 al, al
  00193	75 0b		 jne	 SHORT $LN16@ApplyWeapo@16

; 233  : 	{
; 234  : 		fDamage = 0.0f;

  00195	0f 57 c0	 xorps	 xmm0, xmm0
  00198	f3 0f 11 06	 movss	 DWORD PTR [esi], xmm0

; 235  : 		fBoundDamage = 0.0f;

  0019c	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0
$LN16@ApplyWeapo@16:
  001a0	5e		 pop	 esi
$LN1@ApplyWeapo@16:
  001a1	5f		 pop	 edi
  001a2	5b		 pop	 ebx

; 236  : 		//fBaseDamage = 0.0f;
; 237  : 	}
; 238  : }

  001a3	5d		 pop	 ebp
  001a4	c2 14 00	 ret	 20			; 00000014H
?ApplyWeaponWoundedBaseDamageCalc@ioBaseChar@@IAEXPAVioWeapon@@W4AttackSide@@AAM2_N@Z ENDP ; ioBaseChar::ApplyWeaponWoundedBaseDamageCalc
_TEXT	ENDS
PUBLIC	?ApplyWeaponWoundedCalcByBuff@ioBaseChar@@IAEXPAV1@AAM11111@Z ; ioBaseChar::ApplyWeaponWoundedCalcByBuff
EXTRN	?GetConcentrateBlowPowerByTarget@ioBaseChar@@QAEMPAV1@@Z:PROC ; ioBaseChar::GetConcentrateBlowPowerByTarget
EXTRN	?GetConcentratePushPowerByTarget@ioBaseChar@@QAEMPAV1@@Z:PROC ; ioBaseChar::GetConcentratePushPowerByTarget
EXTRN	?GetAffectWoundedValueBuff@ioBaseChar@@QAEPAVioBuff@@XZ:PROC ; ioBaseChar::GetAffectWoundedValueBuff
; Function compile flags: /Ogsp
;	COMDAT ?ApplyWeaponWoundedCalcByBuff@ioBaseChar@@IAEXPAV1@AAM11111@Z
_TEXT	SEGMENT
_value$700535 = -4					; size = 4
_value$700522 = 8					; size = 4
_pAttacker$ = 8						; size = 4
_value$700511 = 11					; size = 1
_fPushPower$ = 12					; size = 4
_fBlowPower$ = 16					; size = 4
_fBoundDamage$ = 20					; size = 4
_fBoundJumpAmt$ = 24					; size = 4
_fBoundForceAmt$ = 28					; size = 4
_fBoundGrvityRate$ = 32					; size = 4
?ApplyWeaponWoundedCalcByBuff@ioBaseChar@@IAEXPAV1@AAM11111@Z PROC ; ioBaseChar::ApplyWeaponWoundedCalcByBuff, COMDAT
; _this$ = ecx

; 241  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 242  : 	if ( !pAttacker )

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _pAttacker$[ebp]
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	85 db		 test	 ebx, ebx
  0000d	0f 84 e6 01 00
	00		 je	 $LN1@ApplyWeapo@17

; 243  : 		return;
; 244  : 
; 245  : 	// BT_AFFECT_WOUNDED_VALUE  Push, Blow, Damage .
; 246  : 	ioAffectWoundedValueBuff *pAffectWoundedValueBuff = ToAffectWoundedValue( GetAffectWoundedValueBuff() );

  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ?GetAffectWoundedValueBuff@ioBaseChar@@QAEPAVioBuff@@XZ ; ioBaseChar::GetAffectWoundedValueBuff
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?ToAffectWoundedValue@@YAPAVioAffectWoundedValueBuff@@PAVioBuff@@@Z ; ToAffectWoundedValue
  0001f	8b f0		 mov	 esi, eax
  00021	59		 pop	 ecx

; 247  : 	if( pAffectWoundedValueBuff )

  00022	85 f6		 test	 esi, esi
  00024	0f 84 a0 01 00
	00		 je	 $LN11@ApplyWeapo@17

; 248  : 	{
; 249  : 		bool bAffect = false;
; 250  : 		if( pAffectWoundedValueBuff->CheckTeamAttack() )

  0002a	8d 45 0b	 lea	 eax, DWORD PTR _value$700511[ebp]
  0002d	50		 push	 eax
  0002e	8d 8e 2c 0a 00
	00		 lea	 ecx, DWORD PTR [esi+2604]
  00034	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  00039	80 7d 0b 00	 cmp	 BYTE PTR _value$700511[ebp], 0
  0003d	74 2a		 je	 SHORT $LN10@ApplyWeapo@17

; 251  : 		{
; 252  : 			if( GetTeam() != pAttacker->GetTeam() )

  0003f	8d 45 08	 lea	 eax, DWORD PTR _value$700522[ebp]
  00042	50		 push	 eax
  00043	8d 8f 90 00 00
	00		 lea	 ecx, DWORD PTR [edi+144]
  00049	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  0004e	8d 45 fc	 lea	 eax, DWORD PTR _value$700535[ebp]
  00051	50		 push	 eax
  00052	8d 8b 90 00 00
	00		 lea	 ecx, DWORD PTR [ebx+144]
  00058	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  0005d	8b 45 08	 mov	 eax, DWORD PTR _value$700522[ebp]
  00060	3b 45 fc	 cmp	 eax, DWORD PTR _value$700535[ebp]
  00063	0f 84 8f 01 00
	00		 je	 $LN48@ApplyWeapo@17
$LN10@ApplyWeapo@17:

; 253  : 				bAffect = true;
; 254  : 		}
; 255  : 		else
; 256  : 			bAffect = true;
; 257  : 
; 258  : 		if( bAffect )
; 259  : 		{
; 260  : 			// Push, Blow Value
; 261  : 			if( IsFloatingState() )

  00069	8b cf		 mov	 ecx, edi
  0006b	e8 00 00 00 00	 call	 ?IsFloatingState@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsFloatingState
  00070	84 c0		 test	 al, al

; 262  : 			{
; 263  : 				fPushPower *= pAffectWoundedValueBuff->GetAirPushPowerRate();

  00072	8b 45 0c	 mov	 eax, DWORD PTR _fPushPower$[ebp]
  00075	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  00079	0f 5a c9	 cvtps2pd xmm1, xmm1
  0007c	74 3d		 je	 SHORT $LN6@ApplyWeapo@17
  0007e	f3 0f 10 86 80
	09 00 00	 movss	 xmm0, DWORD PTR [esi+2432]
  00086	0f 5a c0	 cvtps2pd xmm0, xmm0
  00089	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  0008d	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00091	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 264  : 				fBlowPower *= pAffectWoundedValueBuff->GetAirBlowPowerRate();

  00095	8b 45 10	 mov	 eax, DWORD PTR _fBlowPower$[ebp]
  00098	f3 0f 10 86 a4
	09 00 00	 movss	 xmm0, DWORD PTR [esi+2468]
  000a0	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  000a4	0f 5a c0	 cvtps2pd xmm0, xmm0
  000a7	0f 5a c9	 cvtps2pd xmm1, xmm1
  000aa	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  000ae	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  000b2	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 265  : 			}
; 266  : 			else

  000b6	e9 89 00 00 00	 jmp	 $LN4@ApplyWeapo@17
$LN6@ApplyWeapo@17:

; 267  : 			{
; 268  : 				fPushPower *= pAffectWoundedValueBuff->GetPushPowerRate();

  000bb	f3 0f 10 86 74
	09 00 00	 movss	 xmm0, DWORD PTR [esi+2420]

; 269  : 				fBlowPower *= pAffectWoundedValueBuff->GetBlowPowerRate();

  000c3	8b 4d 10	 mov	 ecx, DWORD PTR _fBlowPower$[ebp]
  000c6	0f 5a c0	 cvtps2pd xmm0, xmm0
  000c9	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  000cd	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  000d1	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  000d5	f3 0f 10 86 98
	09 00 00	 movss	 xmm0, DWORD PTR [esi+2456]
  000dd	f3 0f 10 09	 movss	 xmm1, DWORD PTR [ecx]
  000e1	0f 5a c0	 cvtps2pd xmm0, xmm0
  000e4	0f 5a c9	 cvtps2pd xmm1, xmm1
  000e7	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  000eb	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  000ef	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 270  : 
; 271  : 				if( m_CharState == CS_BLOW_WOUNDED ||
; 272  : 					m_CharState == CS_BOUND_BLOW_WOUNDED ||
; 273  : 					m_CharState == CS_BLOW_EXTEND_WOUND )

  000f3	8a 97 10 03 00
	00		 mov	 dl, BYTE PTR [edi+784]
  000f9	80 fa 0c	 cmp	 dl, 12			; 0000000cH
  000fc	74 0a		 je	 SHORT $LN3@ApplyWeapo@17
  000fe	80 fa 31	 cmp	 dl, 49			; 00000031H
  00101	74 05		 je	 SHORT $LN3@ApplyWeapo@17
  00103	80 fa 46	 cmp	 dl, 70			; 00000046H
  00106	75 3c		 jne	 SHORT $LN4@ApplyWeapo@17
$LN3@ApplyWeapo@17:

; 274  : 				{
; 275  : 					fPushPower *= pAffectWoundedValueBuff->GetDownPushPowerRate();

  00108	f3 0f 10 86 8c
	09 00 00	 movss	 xmm0, DWORD PTR [esi+2444]
  00110	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  00114	0f 5a c0	 cvtps2pd xmm0, xmm0
  00117	0f 5a c9	 cvtps2pd xmm1, xmm1
  0011a	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  0011e	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00122	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 276  : 					fBlowPower *= pAffectWoundedValueBuff->GetDownBlowPowerRate();

  00126	f3 0f 10 86 b0
	09 00 00	 movss	 xmm0, DWORD PTR [esi+2480]
  0012e	f3 0f 10 09	 movss	 xmm1, DWORD PTR [ecx]
  00132	0f 5a c0	 cvtps2pd xmm0, xmm0
  00135	0f 5a c9	 cvtps2pd xmm1, xmm1
  00138	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  0013c	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00140	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
$LN4@ApplyWeapo@17:

; 277  : 				}
; 278  : 			}
; 279  : 
; 280  : 			// Bound Value
; 281  : 			fBoundDamage	*= pAffectWoundedValueBuff->GetBoundDamageRate();

  00144	f3 0f 10 86 e0
	09 00 00	 movss	 xmm0, DWORD PTR [esi+2528]
  0014c	8b 45 14	 mov	 eax, DWORD PTR _fBoundDamage$[ebp]
  0014f	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  00153	0f 5a c0	 cvtps2pd xmm0, xmm0
  00156	0f 5a c9	 cvtps2pd xmm1, xmm1
  00159	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  0015d	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00161	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 282  : 			fBoundJumpAmt	*= pAffectWoundedValueBuff->GetBoundJumpPowerRate();

  00165	8b 45 18	 mov	 eax, DWORD PTR _fBoundJumpAmt$[ebp]
  00168	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  0016c	f3 0f 10 86 bc
	09 00 00	 movss	 xmm0, DWORD PTR [esi+2492]
  00174	0f 5a c0	 cvtps2pd xmm0, xmm0
  00177	0f 5a c9	 cvtps2pd xmm1, xmm1
  0017a	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  0017e	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00182	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 283  : 			fBoundForceAmt	*= pAffectWoundedValueBuff->GetBoundForcePowerRate();

  00186	8b 45 1c	 mov	 eax, DWORD PTR _fBoundForceAmt$[ebp]
  00189	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  0018d	f3 0f 10 86 c8
	09 00 00	 movss	 xmm0, DWORD PTR [esi+2504]
  00195	0f 5a c0	 cvtps2pd xmm0, xmm0
  00198	0f 5a c9	 cvtps2pd xmm1, xmm1
  0019b	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  0019f	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  001a3	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 284  : 			fBoundGrvityRate*= pAffectWoundedValueBuff->GetBoundGravityRate();

  001a7	8b 45 20	 mov	 eax, DWORD PTR _fBoundGrvityRate$[ebp]
  001aa	f3 0f 10 86 d4
	09 00 00	 movss	 xmm0, DWORD PTR [esi+2516]
  001b2	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  001b6	0f 5a c0	 cvtps2pd xmm0, xmm0
  001b9	0f 5a c9	 cvtps2pd xmm1, xmm1
  001bc	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  001c0	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  001c4	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 285  : 		}
; 286  : 	}

  001c8	eb 2e		 jmp	 SHORT $LN48@ApplyWeapo@17
$LN11@ApplyWeapo@17:

; 287  : 	else if( HasBuff( BT_CONCENTRATE_TARGET ) )

  001ca	68 89 00 00 00	 push	 137			; 00000089H
  001cf	8b cf		 mov	 ecx, edi
  001d1	e8 00 00 00 00	 call	 ?HasBuff@ioBaseChar@@QBE_NH@Z ; ioBaseChar::HasBuff
  001d6	84 c0		 test	 al, al
  001d8	74 1e		 je	 SHORT $LN48@ApplyWeapo@17

; 288  : 	{
; 289  : 		fPushPower *= GetConcentratePushPowerByTarget( pAttacker );

  001da	53		 push	 ebx
  001db	8b cf		 mov	 ecx, edi
  001dd	e8 00 00 00 00	 call	 ?GetConcentratePushPowerByTarget@ioBaseChar@@QAEMPAV1@@Z ; ioBaseChar::GetConcentratePushPowerByTarget
  001e2	8b 45 0c	 mov	 eax, DWORD PTR _fPushPower$[ebp]
  001e5	d8 08		 fmul	 DWORD PTR [eax]

; 290  : 		fBlowPower *= GetConcentrateBlowPowerByTarget( pAttacker );

  001e7	53		 push	 ebx
  001e8	8b cf		 mov	 ecx, edi
  001ea	d9 18		 fstp	 DWORD PTR [eax]
  001ec	e8 00 00 00 00	 call	 ?GetConcentrateBlowPowerByTarget@ioBaseChar@@QAEMPAV1@@Z ; ioBaseChar::GetConcentrateBlowPowerByTarget
  001f1	8b 45 10	 mov	 eax, DWORD PTR _fBlowPower$[ebp]
  001f4	d8 08		 fmul	 DWORD PTR [eax]
  001f6	d9 18		 fstp	 DWORD PTR [eax]
$LN48@ApplyWeapo@17:
  001f8	5e		 pop	 esi
$LN1@ApplyWeapo@17:
  001f9	5f		 pop	 edi
  001fa	5b		 pop	 ebx

; 291  : 	}
; 292  : }

  001fb	c9		 leave
  001fc	c2 1c 00	 ret	 28			; 0000001cH
?ApplyWeaponWoundedCalcByBuff@ioBaseChar@@IAEXPAV1@AAM11111@Z ENDP ; ioBaseChar::ApplyWeaponWoundedCalcByBuff
_TEXT	ENDS
PUBLIC	?ApplyWeaponWoundedExtraDamageCalc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_NMAAM@Z ; ioBaseChar::ApplyWeaponWoundedExtraDamageCalc
EXTRN	?GetProtectStateApplyDamage@ioBaseChar@@IAEMPAVioWeapon@@M@Z:PROC ; ioBaseChar::GetProtectStateApplyDamage
; Function compile flags: /Ogsp
;	COMDAT ?ApplyWeaponWoundedExtraDamageCalc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_NMAAM@Z
_TEXT	SEGMENT
_value$700614 = 8					; size = 4
_pWeapon$ = 8						; size = 4
_pAttacker$ = 12					; size = 4
_value$700601 = 16					; size = 4
_bProtectDamage$ = 16					; size = 1
_value$700590 = 19					; size = 1
_fPreCheckDamage$ = 20					; size = 4
_fDamage$ = 24						; size = 4
?ApplyWeaponWoundedExtraDamageCalc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_NMAAM@Z PROC ; ioBaseChar::ApplyWeaponWoundedExtraDamageCalc, COMDAT
; _this$ = ecx

; 779  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 780  : 	if ( !pWeapon || !pAttacker )

  00003	83 7d 08 00	 cmp	 DWORD PTR _pWeapon$[ebp], 0
  00007	53		 push	 ebx
  00008	8b d9		 mov	 ebx, ecx
  0000a	0f 84 a4 00 00
	00		 je	 $LN6@ApplyWeapo@18
  00010	83 7d 0c 00	 cmp	 DWORD PTR _pAttacker$[ebp], 0
  00014	0f 84 9a 00 00
	00		 je	 $LN6@ApplyWeapo@18

; 781  : 		return;
; 782  : 
; 783  : 	//--- 2 
; 784  : 	if( bProtectDamage && fDamage <= 0.0f )

  0001a	80 7d 10 00	 cmp	 BYTE PTR _bProtectDamage$[ebp], 0
  0001e	56		 push	 esi
  0001f	8b 75 18	 mov	 esi, DWORD PTR _fDamage$[ebp]
  00022	74 1d		 je	 SHORT $LN5@ApplyWeapo@18
  00024	0f 57 c0	 xorps	 xmm0, xmm0
  00027	0f 2f 06	 comiss	 xmm0, DWORD PTR [esi]
  0002a	72 15		 jb	 SHORT $LN5@ApplyWeapo@18

; 785  : 		fDamage = GetProtectStateApplyDamage( pWeapon, fPreCheckDamage );

  0002c	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _fPreCheckDamage$[ebp]
  00031	51		 push	 ecx
  00032	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00037	ff 75 08	 push	 DWORD PTR _pWeapon$[ebp]
  0003a	e8 00 00 00 00	 call	 ?GetProtectStateApplyDamage@ioBaseChar@@IAEMPAVioWeapon@@M@Z ; ioBaseChar::GetProtectStateApplyDamage
  0003f	d9 1e		 fstp	 DWORD PTR [esi]
$LN5@ApplyWeapo@18:

; 786  : 
; 787  : 	// BT_AFFECT_WOUNDED_VALUE    .
; 788  : 	ioAffectWoundedValueBuff *pAffectWoundedValueBuff = ToAffectWoundedValue( GetAffectWoundedValueBuff() );

  00041	57		 push	 edi
  00042	8b cb		 mov	 ecx, ebx
  00044	e8 00 00 00 00	 call	 ?GetAffectWoundedValueBuff@ioBaseChar@@QAEPAVioBuff@@XZ ; ioBaseChar::GetAffectWoundedValueBuff
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 ?ToAffectWoundedValue@@YAPAVioAffectWoundedValueBuff@@PAVioBuff@@@Z ; ToAffectWoundedValue
  0004f	8b f8		 mov	 edi, eax
  00051	59		 pop	 ecx

; 789  : 	if( pAffectWoundedValueBuff )

  00052	85 ff		 test	 edi, edi
  00054	74 5c		 je	 SHORT $LN27@ApplyWeapo@18

; 790  : 	{
; 791  : 		if( pAffectWoundedValueBuff->CheckTeamAttack() )

  00056	8d 45 13	 lea	 eax, DWORD PTR _value$700590[ebp]
  00059	50		 push	 eax
  0005a	8d 8f 2c 0a 00
	00		 lea	 ecx, DWORD PTR [edi+2604]
  00060	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  00065	80 7d 13 00	 cmp	 BYTE PTR _value$700590[ebp], 0
  00069	74 29		 je	 SHORT $LN3@ApplyWeapo@18

; 792  : 		{
; 793  : 			if( GetTeam() != pAttacker->GetTeam())

  0006b	8d 45 10	 lea	 eax, DWORD PTR _value$700601[ebp]
  0006e	50		 push	 eax
  0006f	8d 8b 90 00 00
	00		 lea	 ecx, DWORD PTR [ebx+144]
  00075	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  0007a	8b 4d 0c	 mov	 ecx, DWORD PTR _pAttacker$[ebp]
  0007d	8d 45 08	 lea	 eax, DWORD PTR _value$700614[ebp]
  00080	50		 push	 eax
  00081	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  00087	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  0008c	8b 45 10	 mov	 eax, DWORD PTR _value$700601[ebp]
  0008f	3b 45 08	 cmp	 eax, DWORD PTR _value$700614[ebp]
  00092	74 1e		 je	 SHORT $LN27@ApplyWeapo@18
$LN3@ApplyWeapo@18:

; 794  : 				fDamage *= pAffectWoundedValueBuff->GetDamageRate();
; 795  : 		}
; 796  : 		else
; 797  : 			fDamage *= pAffectWoundedValueBuff->GetDamageRate();

  00094	f3 0f 10 0e	 movss	 xmm1, DWORD PTR [esi]
  00098	f3 0f 10 87 ec
	09 00 00	 movss	 xmm0, DWORD PTR [edi+2540]
  000a0	0f 5a c0	 cvtps2pd xmm0, xmm0
  000a3	0f 5a c9	 cvtps2pd xmm1, xmm1
  000a6	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  000aa	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  000ae	f3 0f 11 06	 movss	 DWORD PTR [esi], xmm0
$LN27@ApplyWeapo@18:
  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
$LN6@ApplyWeapo@18:
  000b4	5b		 pop	 ebx

; 798  : 	}
; 799  : }

  000b5	5d		 pop	 ebp
  000b6	c2 14 00	 ret	 20			; 00000014H
?ApplyWeaponWoundedExtraDamageCalc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_NMAAM@Z ENDP ; ioBaseChar::ApplyWeaponWoundedExtraDamageCalc
_TEXT	ENDS
PUBLIC	?ApplyWeaponWoundedDamageFunc@ioBaseChar@@IAEXPAVioWeapon@@M@Z ; ioBaseChar::ApplyWeaponWoundedDamageFunc
EXTRN	?SetWoundedStateApplyBuff@ioBaseChar@@IAEXHW4TeamType@@@Z:PROC ; ioBaseChar::SetWoundedStateApplyBuff
EXTRN	?DropShuffleStarItem@ioShuffleBonusMode@@QAEXPAVioWeapon@@PAVioBaseChar@@@Z:PROC ; ioShuffleBonusMode::DropShuffleStarItem
EXTRN	?CheckExtraCallBuff@ioBaseChar@@QAEXXZ:PROC	; ioBaseChar::CheckExtraCallBuff
EXTRN	?CheckWoundEffectBuff@ioBaseChar@@QAEXXZ:PROC	; ioBaseChar::CheckWoundEffectBuff
EXTRN	?SetExtraGaugeTypeByWeapon@ioBaseChar@@QAEXHHM@Z:PROC ; ioBaseChar::SetExtraGaugeTypeByWeapon
EXTRN	?GetExtraGaugeType@ioWeapon@@QAEHXZ:PROC	; ioWeapon::GetExtraGaugeType
; Function compile flags: /Ogsp
;	COMDAT ?ApplyWeaponWoundedDamageFunc@ioBaseChar@@IAEXPAVioWeapon@@M@Z
_TEXT	SEGMENT
_value$700651 = -8					; size = 4
_value$700638 = -4					; size = 4
_fExtraGauge$ = 8					; size = 4
_pWeapon$ = 8						; size = 4
_value$700663 = 12					; size = 4
_fDamage$ = 12						; size = 4
?ApplyWeaponWoundedDamageFunc@ioBaseChar@@IAEXPAVioWeapon@@M@Z PROC ; ioBaseChar::ApplyWeaponWoundedDamageFunc, COMDAT
; _this$ = ecx

; 802  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	56		 push	 esi

; 803  : 	if ( !pWeapon )

  00006	8b 75 08	 mov	 esi, DWORD PTR _pWeapon$[ebp]
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	85 f6		 test	 esi, esi
  0000e	0f 84 d1 00 00
	00		 je	 $LN1@ApplyWeapo@19

; 804  : 		return;
; 805  : 
; 806  : 	//---   
; 807  : 	// check extra gauge
; 808  : 	const WeaponAttribute *pAttr = g_WeaponMgr.FindAttribute( pWeapon->GetAttributeIndex() );

  00014	8b ce		 mov	 ecx, esi
  00016	e8 00 00 00 00	 call	 ?GetAttributeIndex@ioWeapon@@QBEHXZ ; ioWeapon::GetAttributeIndex
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?GetSingleton@ioWeaponManager@@SAAAV1@XZ ; ioWeaponManager::GetSingleton
  00021	8b c8		 mov	 ecx, eax
  00023	e8 00 00 00 00	 call	 ?FindAttribute@ioWeaponManager@@QAEPBUWeaponAttribute@@H@Z ; ioWeaponManager::FindAttribute

; 809  : 	float fExtraGauge = 0.0f;

  00028	0f 57 c0	 xorps	 xmm0, xmm0
  0002b	0f 28 c8	 movaps	 xmm1, xmm0
  0002e	f3 0f 11 4d 08	 movss	 DWORD PTR _fExtraGauge$[ebp], xmm1

; 810  : 	if( pAttr )

  00033	85 c0		 test	 eax, eax
  00035	74 0a		 je	 SHORT $LN6@ApplyWeapo@19

; 811  : 		fExtraGauge = pAttr->m_fDamageRate;	

  00037	f3 0f 10 48 6c	 movss	 xmm1, DWORD PTR [eax+108]
  0003c	f3 0f 11 4d 08	 movss	 DWORD PTR _fExtraGauge$[ebp], xmm1
$LN6@ApplyWeapo@19:

; 812  : 
; 813  : 	if( fDamage > 0.0f && fExtraGauge > 0.0f && pWeapon->GetTeam() != GetTeam() )

  00041	f3 0f 10 55 0c	 movss	 xmm2, DWORD PTR _fDamage$[ebp]
  00046	0f 2f d0	 comiss	 xmm2, xmm0
  00049	76 4b		 jbe	 SHORT $LN4@ApplyWeapo@19
  0004b	0f 2f c8	 comiss	 xmm1, xmm0
  0004e	76 3f		 jbe	 SHORT $LN5@ApplyWeapo@19
  00050	8d 45 fc	 lea	 eax, DWORD PTR _value$700638[ebp]
  00053	50		 push	 eax
  00054	8d 4e 30	 lea	 ecx, DWORD PTR [esi+48]
  00057	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  0005c	8d 45 f8	 lea	 eax, DWORD PTR _value$700651[ebp]
  0005f	50		 push	 eax
  00060	8d 8f 90 00 00
	00		 lea	 ecx, DWORD PTR [edi+144]
  00066	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  0006b	8b 45 fc	 mov	 eax, DWORD PTR _value$700638[ebp]
  0006e	3b 45 f8	 cmp	 eax, DWORD PTR _value$700651[ebp]
  00071	74 1c		 je	 SHORT $LN5@ApplyWeapo@19

; 814  : 		SetExtraGaugeTypeByWeapon( EGT_WOUNDED, pWeapon->GetExtraGaugeType(), fExtraGauge );

  00073	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fExtraGauge$[ebp]
  00078	51		 push	 ecx
  00079	8b ce		 mov	 ecx, esi
  0007b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00080	e8 00 00 00 00	 call	 ?GetExtraGaugeType@ioWeapon@@QAEHXZ ; ioWeapon::GetExtraGaugeType
  00085	50		 push	 eax
  00086	6a 03		 push	 3
  00088	8b cf		 mov	 ecx, edi
  0008a	e8 00 00 00 00	 call	 ?SetExtraGaugeTypeByWeapon@ioBaseChar@@QAEXHHM@Z ; ioBaseChar::SetExtraGaugeTypeByWeapon
$LN5@ApplyWeapo@19:

; 815  : 
; 816  : 	//    
; 817  : 	if( fDamage > 0.0f )
; 818  : 		CheckWoundEffectBuff();

  0008f	8b cf		 mov	 ecx, edi
  00091	e8 00 00 00 00	 call	 ?CheckWoundEffectBuff@ioBaseChar@@QAEXXZ ; ioBaseChar::CheckWoundEffectBuff
$LN4@ApplyWeapo@19:

; 819  : 
; 820  : 	//     : /  ...
; 821  : 	CheckExtraCallBuff();

  00096	8b cf		 mov	 ecx, edi
  00098	e8 00 00 00 00	 call	 ?CheckExtraCallBuff@ioBaseChar@@QAEXXZ ; ioBaseChar::CheckExtraCallBuff

; 822  : 
; 823  : 	//     Add Buff  
; 824  : 	if( fDamage > 0.0f )

  0009d	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  000a2	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  000a9	76 3a		 jbe	 SHORT $LN1@ApplyWeapo@19

; 825  : 	{
; 826  : 		ioShuffleBonusMode* pShuffleMode = ToShuffleBonusMode( m_pModeParent );

  000ab	ff b7 8c 00 00
	00		 push	 DWORD PTR [edi+140]
  000b1	e8 00 00 00 00	 call	 ?ToShuffleBonusMode@@YAPAVioShuffleBonusMode@@PAVioPlayMode@@@Z ; ToShuffleBonusMode
  000b6	59		 pop	 ecx

; 827  : 		if( pShuffleMode )			

  000b7	85 c0		 test	 eax, eax
  000b9	74 09		 je	 SHORT $LN2@ApplyWeapo@19

; 828  : 			pShuffleMode->DropShuffleStarItem( pWeapon, this );

  000bb	57		 push	 edi
  000bc	56		 push	 esi
  000bd	8b c8		 mov	 ecx, eax
  000bf	e8 00 00 00 00	 call	 ?DropShuffleStarItem@ioShuffleBonusMode@@QAEXPAVioWeapon@@PAVioBaseChar@@@Z ; ioShuffleBonusMode::DropShuffleStarItem
$LN2@ApplyWeapo@19:

; 829  : 	}
; 830  : 	
; 831  : 	if( fDamage > 0.0f )
; 832  : 	{
; 833  : 		//     
; 834  : 		SetWoundedStateApplyBuff( (int)pWeapon->GetType(), pWeapon->GetTeam() );

  000c4	8d 45 0c	 lea	 eax, DWORD PTR _value$700663[ebp]
  000c7	50		 push	 eax
  000c8	8d 4e 30	 lea	 ecx, DWORD PTR [esi+48]
  000cb	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  000d0	ff 75 0c	 push	 DWORD PTR _value$700663[ebp]
  000d3	8b 06		 mov	 eax, DWORD PTR [esi]
  000d5	8b ce		 mov	 ecx, esi
  000d7	ff 90 10 01 00
	00		 call	 DWORD PTR [eax+272]
  000dd	50		 push	 eax
  000de	8b cf		 mov	 ecx, edi
  000e0	e8 00 00 00 00	 call	 ?SetWoundedStateApplyBuff@ioBaseChar@@IAEXHW4TeamType@@@Z ; ioBaseChar::SetWoundedStateApplyBuff
$LN1@ApplyWeapo@19:
  000e5	5f		 pop	 edi
  000e6	5e		 pop	 esi

; 835  : 
; 836  : /*		//    - >  
; 837  : 		ioGangsiMode *pGangsiMode = ToGangsiMode( m_pModeParent );
; 838  : 		if( pGangsiMode )
; 839  : 		{
; 840  : 			//         .
; 841  : 			if( pWeapon->GetTeam() == TEAM_BLUE && GetTeam() == TEAM_RED )
; 842  : 			{
; 843  : 				//     
; 844  : 				SetTeam( TEAM_BLUE );
; 845  : 				pGangsiMode->SendChangeGangsi( this );
; 846  : 			}
; 847  : 		}
; 848  : */	
; 849  : 	}
; 850  : }

  000e7	c9		 leave
  000e8	c2 08 00	 ret	 8
?ApplyWeaponWoundedDamageFunc@ioBaseChar@@IAEXPAVioWeapon@@M@Z ENDP ; ioBaseChar::ApplyWeaponWoundedDamageFunc
_TEXT	ENDS
PUBLIC	__real@3f19999a
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?ApplyWeaponWoundedChangeState@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_NAAVioHashString@@AAK22AAMAAW4BlowTargetType@@255_N7MMMMM27734MM@Z ; ioBaseChar::ApplyWeaponWoundedChangeState
EXTRN	?IsMustBlowWoundState@ioLinearChargeItem2@@QAE_NXZ:PROC ; ioLinearChargeItem2::IsMustBlowWoundState
EXTRN	?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z:PROC ; ioBaseChar::GetPriorityItem
EXTRN	?IsCanPlayWoundedAniFromExtendDash@ioBaseChar@@IAE_NXZ:PROC ; ioBaseChar::IsCanPlayWoundedAniFromExtendDash
EXTRN	?IsJumppingState@ioBaseChar@@QBE_NXZ:PROC	; ioBaseChar::IsJumppingState
EXTRN	?SetBlowExtendWoundedState@ioBaseChar@@QAEXABVioHashString@@KMMM_N@Z:PROC ; ioBaseChar::SetBlowExtendWoundedState
EXTRN	?CheckMustBlowWoundBuff@ioBaseChar@@QAE_NXZ:PROC ; ioBaseChar::CheckMustBlowWoundBuff
EXTRN	?m_fPrisonerBlowPower@ioBaseChar@@1MA:DWORD	; ioBaseChar::m_fPrisonerBlowPower
EXTRN	?m_fPrisonerPushPower@ioBaseChar@@1MA:DWORD	; ioBaseChar::m_fPrisonerPushPower
EXTRN	?SetBlowWoundedState@ioBaseChar@@QAEX_NABUtagBlowWoundAniInfo@@00@Z:PROC ; ioBaseChar::SetBlowWoundedState
EXTRN	?m_fKOActionBlowPower@ioBaseChar@@1MA:DWORD	; ioBaseChar::m_fKOActionBlowPower
EXTRN	?SetBoundWoundedState@ioBaseChar@@QAEXMMMM_N@Z:PROC ; ioBaseChar::SetBoundWoundedState
EXTRN	?SetWoundedState@ioBaseChar@@QAEXABVioHashString@@KM_N1@Z:PROC ; ioBaseChar::SetWoundedState
EXTRN	?CheckPrisonerMode@ioBaseChar@@QAE_NM@Z:PROC	; ioBaseChar::CheckPrisonerMode
EXTRN	?CheckItemDrop@ioBaseChar@@QAEH_N@Z:PROC	; ioBaseChar::CheckItemDrop
EXTRN	?AllItemDrop@ioBaseChar@@QAEXXZ:PROC		; ioBaseChar::AllItemDrop
EXTRN	?IsEnableItemDrop@ioWeapon@@QAE_NPAVioBaseChar@@@Z:PROC ; ioWeapon::IsEnableItemDrop
EXTRN	?CheckRoomWeakWounded@ioPlayStage@@QAE_NW4TeamType@@@Z:PROC ; ioPlayStage::CheckRoomWeakWounded
EXTRN	?CheckRoomZeroKO@ioPlayStage@@QAE_NXZ:PROC	; ioPlayStage::CheckRoomZeroKO
EXTRN	?GetEquipItemCnt@ioBaseChar@@QAEHXZ:PROC	; ioBaseChar::GetEquipItemCnt
EXTRN	?IsEnableTeamAttack@ioBaseChar@@QAE_NXZ:PROC	; ioBaseChar::IsEnableTeamAttack
EXTRN	?GetBlowWoundAniInfo@ioWeapon@@QBEABUtagBlowWoundAniInfo@@XZ:PROC ; ioWeapon::GetBlowWoundAniInfo
EXTRN	?GetExtendWoundDuration@ioWeapon@@QBEKXZ:PROC	; ioWeapon::GetExtendWoundDuration
EXTRN	?GetExtendWoundAni@ioWeapon@@QBEABVioHashString@@XZ:PROC ; ioWeapon::GetExtendWoundAni
EXTRN	?GetDefenseEnableRate@ioWeapon@@QBEMXZ:PROC	; ioWeapon::GetDefenseEnableRate
EXTRN	?GetWoundedDuration@ioWeapon@@QAEKXZ:PROC	; ioWeapon::GetWoundedDuration
;	COMDAT __real@3f19999a
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ApplyWeaponWoundedChangeState@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_NAAVioHashString@@AAK22AAMAAW4BlowTargetType@@255_N7MMMMM27734MM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ApplyWeaponWoundedChangeState@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_NAAVioHashString@@AAK22AAMAAW4BlowTargetType@@255_N7MMMMM27734MM@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ApplyWeaponWoundedChangeState@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_NAAVioHashString@@AAK22AAMAAW4BlowTargetType@@255_N7MMMMM27734MM@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ApplyWeaponWoundedChangeState@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_NAAVioHashString@@AAK22AAMAAW4BlowTargetType@@255_N7MMMMM27734MM@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?ApplyWeaponWoundedChangeState@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_NAAVioHashString@@AAK22AAMAAW4BlowTargetType@@255_N7MMMMM27734MM@Z$3
__ehfuncinfo$?ApplyWeaponWoundedChangeState@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_NAAVioHashString@@AAK22AAMAAW4BlowTargetType@@255_N7MMMMM27734MM@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?ApplyWeaponWoundedChangeState@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_NAAVioHashString@@AAK22AAMAAW4BlowTargetType@@255_N7MMMMM27734MM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasecharapplywoundednew.cpp
xdata$x	ENDS
;	COMDAT ?ApplyWeaponWoundedChangeState@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_NAAVioHashString@@AAK22AAMAAW4BlowTargetType@@255_N7MMMMM27734MM@Z
_TEXT	SEGMENT
_kBlowWoundAniInfo$ = -140				; size = 96
$T700673 = -44						; size = 16
$T700670 = -44						; size = 16
_szConcentrateTargetName$694040 = -44			; size = 16
_value$700696 = -28					; size = 4
_iPrevEquipItemCnt$ = -24				; size = 4
_ePreBlowType$ = -20					; size = 4
_bEnableTeamAttack$ = -13				; size = 1
__$EHRec$ = -12						; size = 12
_pWeapon$ = 8						; size = 4
_bHPZeroKo$ = 11					; size = 1
_pAttacker$ = 12					; size = 4
_bAllWeakWounded$ = 16					; size = 4
_szWoundAni$ = 20					; size = 4
_dwWoundDuration$ = 24					; size = 4
_bWoundedLoopAni$ = 28					; size = 4
_bIgnorCatch$ = 32					; size = 4
_fDefenseEnableRate$ = 36				; size = 4
_eNewBlowType$ = 40					; size = 4
_bCharDie$ = 44						; size = 4
_fPushPower$ = 48					; size = 4
_fBlowPower$ = 52					; size = 4
_value$700814 = 56					; size = 4
_value$700810 = 56					; size = 4
_value$700798 = 56					; size = 4
_value$700794 = 56					; size = 4
_value$700786 = 56					; size = 4
_value$700782 = 56					; size = 4
_value$700777 = 56					; size = 4
_value$700761 = 56					; size = 4
_value$700739 = 56					; size = 4
_value$700723 = 56					; size = 4
_value$700708 = 56					; size = 4
_bApplyPushPower$ = 56					; size = 1
_value$700766 = 59					; size = 1
_value$700750 = 59					; size = 1
_value$700728 = 59					; size = 1
_bGetUpState$694120 = 60				; size = 1
_bGetUpState$694098 = 60				; size = 1
_bGetUpState$694058 = 60				; size = 1
_bTeamAttack$ = 60					; size = 1
_value$700790 = 63					; size = 1
_bMustBlowWoundBuff$694091 = 63				; size = 1
_fDamage$ = 64						; size = 4
_fBoundJumpAmt$ = 68					; size = 4
_fBoundForceAmt$ = 72					; size = 4
_fBoundGrvityRate$ = 76					; size = 4
_fBoundDamage$ = 80					; size = 4
_bPrisoner$ = 84					; size = 4
_bEnableCancel$ = 88					; size = 1
_bNoCancel$ = 92					; size = 1
_szExtendWoundAni$ = 96					; size = 4
_dwExtendWoundDuration$ = 100				; size = 4
_fExtendWoundJumpAmt$ = 104				; size = 4
_fExtendWoundForceAmt$ = 108				; size = 4
?ApplyWeaponWoundedChangeState@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_NAAVioHashString@@AAK22AAMAAW4BlowTargetType@@255_N7MMMMM27734MM@Z PROC ; ioBaseChar::ApplyWeaponWoundedChangeState, COMDAT
; _this$ = ecx

; 1026 : {													

  00000	68 80 00 00 00	 push	 128			; 00000080H
  00005	b8 00 00 00 00	 mov	 eax, __ehhandler$?ApplyWeaponWoundedChangeState@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_NAAVioHashString@@AAK22AAMAAW4BlowTargetType@@255_N7MMMMM27734MM@Z
  0000a	e8 00 00 00 00	 call	 __EH_prolog3
  0000f	8b f1		 mov	 esi, ecx

; 1027 : 	if ( !pWeapon || !pAttacker )					

  00011	8b 7d 08	 mov	 edi, DWORD PTR _pWeapon$[ebp]
  00014	85 ff		 test	 edi, edi
  00016	0f 84 c1 09 00
	00		 je	 $LN121@ApplyWeapo@20
  0001c	83 7d 0c 00	 cmp	 DWORD PTR _pAttacker$[ebp], 0
  00020	0f 84 b7 09 00
	00		 je	 $LN121@ApplyWeapo@20

; 1028 : 		return;										
; 1029 : 
; 1030 : 	bAllWeakWounded = false;

  00026	8b 45 10	 mov	 eax, DWORD PTR _bAllWeakWounded$[ebp]

; 1031 : 	szWoundAni = pWeapon->GetWoundedAnimation();

  00029	8b 4d 14	 mov	 ecx, DWORD PTR _szWoundAni$[ebp]
  0002c	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_??4ioHashString@@QAEAAV0@ABV0@@Z
  00032	c6 00 00	 mov	 BYTE PTR [eax], 0
  00035	8d 87 c0 04 00
	00		 lea	 eax, DWORD PTR [edi+1216]
  0003b	50		 push	 eax
  0003c	ff d3		 call	 ebx

; 1032 : 	dwWoundDuration = pWeapon->GetWoundedDuration();

  0003e	8b cf		 mov	 ecx, edi
  00040	e8 00 00 00 00	 call	 ?GetWoundedDuration@ioWeapon@@QAEKXZ ; ioWeapon::GetWoundedDuration
  00045	8b 4d 18	 mov	 ecx, DWORD PTR _dwWoundDuration$[ebp]
  00048	89 01		 mov	 DWORD PTR [ecx], eax

; 1033 : 	bWoundedLoopAni = pWeapon->IsLoopWoundedAnimation();

  0004a	8a 87 bc 04 00
	00		 mov	 al, BYTE PTR [edi+1212]
  00050	8b 4d 1c	 mov	 ecx, DWORD PTR _bWoundedLoopAni$[ebp]
  00053	88 01		 mov	 BYTE PTR [ecx], al

; 1034 : 	bIgnorCatch = false;

  00055	8b 45 20	 mov	 eax, DWORD PTR _bIgnorCatch$[ebp]

; 1035 : 
; 1036 : 	fDefenseEnableRate = pWeapon->GetDefenseEnableRate();

  00058	8b cf		 mov	 ecx, edi
  0005a	c6 00 00	 mov	 BYTE PTR [eax], 0
  0005d	e8 00 00 00 00	 call	 ?GetDefenseEnableRate@ioWeapon@@QBEMXZ ; ioWeapon::GetDefenseEnableRate
  00062	8b 45 24	 mov	 eax, DWORD PTR _fDefenseEnableRate$[ebp]
  00065	d9 18		 fstp	 DWORD PTR [eax]

; 1037 : 	eNewBlowType = pWeapon->GetBlowType();

  00067	8b 07		 mov	 eax, DWORD PTR [edi]
  00069	8b cf		 mov	 ecx, edi
  0006b	ff 50 74	 call	 DWORD PTR [eax+116]
  0006e	8b 4d 28	 mov	 ecx, DWORD PTR _eNewBlowType$[ebp]
  00071	89 01		 mov	 DWORD PTR [ecx], eax

; 1038 : 
; 1039 : 	szExtendWoundAni = pWeapon->GetExtendWoundAni();

  00073	8b cf		 mov	 ecx, edi
  00075	e8 00 00 00 00	 call	 ?GetExtendWoundAni@ioWeapon@@QBEABVioHashString@@XZ ; ioWeapon::GetExtendWoundAni
  0007a	8b 4d 60	 mov	 ecx, DWORD PTR _szExtendWoundAni$[ebp]
  0007d	50		 push	 eax
  0007e	ff d3		 call	 ebx

; 1040 : 	dwExtendWoundDuration = pWeapon->GetExtendWoundDuration();

  00080	8b cf		 mov	 ecx, edi
  00082	e8 00 00 00 00	 call	 ?GetExtendWoundDuration@ioWeapon@@QBEKXZ ; ioWeapon::GetExtendWoundDuration
  00087	8b 4d 64	 mov	 ecx, DWORD PTR _dwExtendWoundDuration$[ebp]
  0008a	89 01		 mov	 DWORD PTR [ecx], eax

; 1041 : 
; 1042 : 	BlowTargetType ePreBlowType = m_BlowTargetType;

  0008c	8b 86 d0 0e 00
	00		 mov	 eax, DWORD PTR [esi+3792]
  00092	89 45 ec	 mov	 DWORD PTR _ePreBlowType$[ebp], eax

; 1043 : 	m_BlowTargetType = pWeapon->GetBlowType();

  00095	8b 07		 mov	 eax, DWORD PTR [edi]
  00097	8b cf		 mov	 ecx, edi
  00099	ff 50 74	 call	 DWORD PTR [eax+116]

; 1044 : 
; 1045 : 	BlowWoundAniInfo kBlowWoundAniInfo = pWeapon->GetBlowWoundAniInfo();

  0009c	8b cf		 mov	 ecx, edi
  0009e	89 86 d0 0e 00
	00		 mov	 DWORD PTR [esi+3792], eax
  000a4	e8 00 00 00 00	 call	 ?GetBlowWoundAniInfo@ioWeapon@@QBEABUtagBlowWoundAniInfo@@XZ ; ioWeapon::GetBlowWoundAniInfo
  000a9	50		 push	 eax
  000aa	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _kBlowWoundAniInfo$[ebp]
  000b0	e8 00 00 00 00	 call	 ??0tagBlowWoundAniInfo@@QAE@ABU0@@Z
  000b5	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 1046 : 
; 1047 : 	// MustBlowWound Buff Check
; 1048 : 	bool bEnableTeamAttack = IsEnableTeamAttack();

  000b9	8b ce		 mov	 ecx, esi
  000bb	e8 00 00 00 00	 call	 ?IsEnableTeamAttack@ioBaseChar@@QAE_NXZ ; ioBaseChar::IsEnableTeamAttack

; 1049 : 
; 1050 : 	bool bHPZeroKo = false;
; 1051 : 	int iPrevEquipItemCnt = GetEquipItemCnt();

  000c0	8b ce		 mov	 ecx, esi
  000c2	88 45 f3	 mov	 BYTE PTR _bEnableTeamAttack$[ebp], al
  000c5	c6 45 0b 00	 mov	 BYTE PTR _bHPZeroKo$[ebp], 0
  000c9	e8 00 00 00 00	 call	 ?GetEquipItemCnt@ioBaseChar@@QAEHXZ ; ioBaseChar::GetEquipItemCnt
  000ce	89 45 e8	 mov	 DWORD PTR _iPrevEquipItemCnt$[ebp], eax

; 1052 : 	if( !IsItemDrop() )

  000d1	8b 06		 mov	 eax, DWORD PTR [esi]
  000d3	8b ce		 mov	 ecx, esi
  000d5	ff 90 0c 01 00
	00		 call	 DWORD PTR [eax+268]
  000db	84 c0		 test	 al, al

; 1053 : 		iPrevEquipItemCnt = 0;

  000dd	74 09		 je	 SHORT $LN210@ApplyWeapo@20

; 1054 : 	else if( IsGangsi() )    //    .

  000df	80 be f8 23 00
	00 00		 cmp	 BYTE PTR [esi+9208], 0
  000e6	74 04		 je	 SHORT $LN118@ApplyWeapo@20
$LN210@ApplyWeapo@20:

; 1055 : 		iPrevEquipItemCnt = 0;

  000e8	83 65 e8 00	 and	 DWORD PTR _iPrevEquipItemCnt$[ebp], 0
$LN118@ApplyWeapo@20:

; 1056 : 
; 1057 : 	if( m_pCreator )

  000ec	8b 8e 44 03 00
	00		 mov	 ecx, DWORD PTR [esi+836]
  000f2	85 c9		 test	 ecx, ecx
  000f4	74 60		 je	 SHORT $LN114@ApplyWeapo@20

; 1058 : 	{
; 1059 : 		if( m_pCreator->CheckRoomZeroKO() )

  000f6	e8 00 00 00 00	 call	 ?CheckRoomZeroKO@ioPlayStage@@QAE_NXZ ; ioPlayStage::CheckRoomZeroKO
  000fb	84 c0		 test	 al, al
  000fd	74 08		 je	 SHORT $LN116@ApplyWeapo@20

; 1060 : 		{
; 1061 : 			bHPZeroKo = true;
; 1062 : 			iPrevEquipItemCnt = 0;

  000ff	83 65 e8 00	 and	 DWORD PTR _iPrevEquipItemCnt$[ebp], 0
  00103	c6 45 0b 01	 mov	 BYTE PTR _bHPZeroKo$[ebp], 1
$LN116@ApplyWeapo@20:

; 1063 : 		}
; 1064 : 
; 1065 : 		if( m_pCreator->CheckRoomWeakWounded( m_TeamType ) )

  00107	8d 45 e4	 lea	 eax, DWORD PTR _value$700696[ebp]
  0010a	50		 push	 eax
  0010b	8d 8e 90 00 00
	00		 lea	 ecx, DWORD PTR [esi+144]
  00111	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  00116	ff 75 e4	 push	 DWORD PTR _value$700696[ebp]
  00119	8b 8e 44 03 00
	00		 mov	 ecx, DWORD PTR [esi+836]
  0011f	e8 00 00 00 00	 call	 ?CheckRoomWeakWounded@ioPlayStage@@QAE_NW4TeamType@@@Z ; ioPlayStage::CheckRoomWeakWounded
  00124	84 c0		 test	 al, al
  00126	74 15		 je	 SHORT $LN115@ApplyWeapo@20

; 1066 : 		{
; 1067 : 			bAllWeakWounded = true;

  00128	8b 45 10	 mov	 eax, DWORD PTR _bAllWeakWounded$[ebp]

; 1068 : 			fBlowPower = 1.0f;

  0012b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00133	c6 00 01	 mov	 BYTE PTR [eax], 1
  00136	8b 45 34	 mov	 eax, DWORD PTR _fBlowPower$[ebp]
  00139	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
$LN115@ApplyWeapo@20:

; 1069 : 			//fPushPower = 1.0f;
; 1070 : 		}
; 1071 : 
; 1072 : 		ioPlayMode* pMode = m_pCreator->GetPlayMode();

  0013d	8b 86 44 03 00
	00		 mov	 eax, DWORD PTR [esi+836]
  00143	8b 88 10 01 00
	00		 mov	 ecx, DWORD PTR [eax+272]

; 1073 : 		if( pMode )

  00149	85 c9		 test	 ecx, ecx
  0014b	74 09		 je	 SHORT $LN114@ApplyWeapo@20

; 1074 : 			pMode->NottifyWeaponWounded( this );

  0014d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0014f	56		 push	 esi
  00150	ff 90 d4 00 00
	00		 call	 DWORD PTR [eax+212]
$LN114@ApplyWeapo@20:

; 1075 : 	}
; 1076 : 
; 1077 : 	bool bEnableTeamDamage = IsEnableTeamDamage();

  00156	8b ce		 mov	 ecx, esi
  00158	e8 00 00 00 00	 call	 ?IsEnableTeamDamage@ioBaseChar@@QAE_NXZ ; ioBaseChar::IsEnableTeamDamage

; 1078 : 	if( bApplyPushPower )

  0015d	80 7d 38 00	 cmp	 BYTE PTR _bApplyPushPower$[ebp], 0
  00161	8a d8		 mov	 bl, al
  00163	0f 84 65 08 00
	00		 je	 $LN29@ApplyWeapo@20

; 1079 : 	{
; 1080 : 		if( m_HP.m_fCurValue <= 0.0f )

  00169	8d 45 38	 lea	 eax, DWORD PTR _value$700708[ebp]
  0016c	50		 push	 eax
  0016d	8d 8e c0 00 00
	00		 lea	 ecx, DWORD PTR [esi+192]
  00173	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  00178	0f 57 c0	 xorps	 xmm0, xmm0
  0017b	0f 2f 45 38	 comiss	 xmm0, DWORD PTR _value$700708[ebp]
  0017f	0f 82 a1 01 00
	00		 jb	 $LN196@ApplyWeapo@20

; 1081 : 		{
; 1082 : 			if( m_pModeParent->GetModeState() == ioPlayMode::MS_PLAY )

  00185	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  0018b	83 78 38 01	 cmp	 DWORD PTR [eax+56], 1
  0018f	0f 85 db 00 00
	00		 jne	 $LN104@ApplyWeapo@20

; 1083 : 			{
; 1084 : 				if( (!bTeamAttack || bEnableTeamDamage ) &&
; 1085 : 					( bHPZeroKo || pWeapon->IsEnableItemDrop( this ) ) && 
; 1086 : 					(!IsDamageProtect() || pWeapon->IsIgnoreProtect()) && 
; 1087 : 					(!m_bEnableManaShield || pWeapon->IsIgnoreProtect()) )

  00195	80 7d 3c 00	 cmp	 BYTE PTR _bTeamAttack$[ebp], 0
  00199	74 08		 je	 SHORT $LN109@ApplyWeapo@20
  0019b	84 db		 test	 bl, bl
  0019d	0f 84 cd 00 00
	00		 je	 $LN104@ApplyWeapo@20
$LN109@ApplyWeapo@20:
  001a3	80 7d 0b 00	 cmp	 BYTE PTR _bHPZeroKo$[ebp], 0
  001a7	75 10		 jne	 SHORT $LN108@ApplyWeapo@20
  001a9	56		 push	 esi
  001aa	8b cf		 mov	 ecx, edi
  001ac	e8 00 00 00 00	 call	 ?IsEnableItemDrop@ioWeapon@@QAE_NPAVioBaseChar@@@Z ; ioWeapon::IsEnableItemDrop
  001b1	84 c0		 test	 al, al
  001b3	0f 84 b7 00 00
	00		 je	 $LN104@ApplyWeapo@20
$LN108@ApplyWeapo@20:
  001b9	8b ce		 mov	 ecx, esi
  001bb	e8 00 00 00 00	 call	 ?IsDamageProtect@ioBaseChar@@QAE_NXZ ; ioBaseChar::IsDamageProtect
  001c0	84 c0		 test	 al, al
  001c2	74 19		 je	 SHORT $LN107@ApplyWeapo@20
  001c4	8d 45 38	 lea	 eax, DWORD PTR _value$700723[ebp]
  001c7	8d 8f 0c 06 00
	00		 lea	 ecx, DWORD PTR [edi+1548]
  001cd	50		 push	 eax
  001ce	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ; CEncrypt<int>::DecryptValueToPool
  001d3	83 7d 38 00	 cmp	 DWORD PTR _value$700723[ebp], 0
  001d7	0f 84 93 00 00
	00		 je	 $LN104@ApplyWeapo@20
$LN107@ApplyWeapo@20:
  001dd	8d 45 3b	 lea	 eax, DWORD PTR _value$700728[ebp]
  001e0	50		 push	 eax
  001e1	8d 8e 78 19 00
	00		 lea	 ecx, DWORD PTR [esi+6520]
  001e7	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  001ec	80 7d 3b 00	 cmp	 BYTE PTR _value$700728[ebp], 0
  001f0	74 15		 je	 SHORT $LN106@ApplyWeapo@20
  001f2	8d 45 38	 lea	 eax, DWORD PTR _value$700739[ebp]
  001f5	8d 8f 0c 06 00
	00		 lea	 ecx, DWORD PTR [edi+1548]
  001fb	50		 push	 eax
  001fc	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ; CEncrypt<int>::DecryptValueToPool
  00201	83 7d 38 00	 cmp	 DWORD PTR _value$700739[ebp], 0
  00205	74 69		 je	 SHORT $LN104@ApplyWeapo@20
$LN106@ApplyWeapo@20:

; 1088 : 				{
; 1089 : 					if( bHPZeroKo && !ToNpcChar(this))

  00207	80 7d 0b 00	 cmp	 BYTE PTR _bHPZeroKo$[ebp], 0
  0020b	74 14		 je	 SHORT $LN105@ApplyWeapo@20
  0020d	56		 push	 esi
  0020e	e8 00 00 00 00	 call	 ?ToNpcChar@@YAPAVioNpcChar@@PAVioGameEntity@@@Z ; ToNpcChar
  00213	59		 pop	 ecx
  00214	85 c0		 test	 eax, eax
  00216	75 09		 jne	 SHORT $LN105@ApplyWeapo@20

; 1090 : 					{
; 1091 : 						AllItemDrop();

  00218	8b ce		 mov	 ecx, esi
  0021a	e8 00 00 00 00	 call	 ?AllItemDrop@ioBaseChar@@QAEXXZ ; ioBaseChar::AllItemDrop

; 1092 : 					}
; 1093 : 					else

  0021f	eb 4f		 jmp	 SHORT $LN104@ApplyWeapo@20
$LN105@ApplyWeapo@20:

; 1094 : 					{
; 1095 : 						ioHashString szConcentrateTargetName = pAttacker->GetConcentrateTargetName();

  00221	8b 5d 0c	 mov	 ebx, DWORD PTR _pAttacker$[ebp]
  00224	8b cb		 mov	 ecx, ebx
  00226	e8 00 00 00 00	 call	 ?GetConcentrateTargetName@ioBaseChar@@QAEABVioHashString@@XZ ; ioBaseChar::GetConcentrateTargetName
  0022b	50		 push	 eax
  0022c	8d 4d d4	 lea	 ecx, DWORD PTR _szConcentrateTargetName$694040[ebp]
  0022f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z

; 1096 : 						if( szConcentrateTargetName.IsEmpty() )

  00235	8d 4d d4	 lea	 ecx, DWORD PTR _szConcentrateTargetName$694040[ebp]
  00238	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0023c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00242	84 c0		 test	 al, al

; 1097 : 							CheckItemDrop( false );
; 1098 : 						else if( szConcentrateTargetName == pAttacker->GetCharName() )

  00244	75 14		 jne	 SHORT $LN211@ApplyWeapo@20
  00246	81 c3 d4 02 00
	00		 add	 ebx, 724		; 000002d4H
  0024c	53		 push	 ebx
  0024d	8d 4d d4	 lea	 ecx, DWORD PTR _szConcentrateTargetName$694040[ebp]
  00250	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??8ioHashString@@QBE_NABV0@@Z
  00256	84 c0		 test	 al, al
  00258	74 09		 je	 SHORT $LN101@ApplyWeapo@20
$LN211@ApplyWeapo@20:

; 1099 : 							CheckItemDrop( false );

  0025a	6a 00		 push	 0
  0025c	8b ce		 mov	 ecx, esi
  0025e	e8 00 00 00 00	 call	 ?CheckItemDrop@ioBaseChar@@QAEH_N@Z ; ioBaseChar::CheckItemDrop
$LN101@ApplyWeapo@20:

; 1100 : 					}

  00263	8d 4d d4	 lea	 ecx, DWORD PTR _szConcentrateTargetName$694040[ebp]
  00266	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0026a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
$LN104@ApplyWeapo@20:

; 1101 : 				}
; 1102 : 			}
; 1103 : 
; 1104 : 			if( !pAttacker->GetCharName().IsEmpty() && !m_bPrisonerMode )

  00270	8b 4d 0c	 mov	 ecx, DWORD PTR _pAttacker$[ebp]
  00273	81 c1 d4 02 00
	00		 add	 ecx, 724		; 000002d4H
  00279	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  0027f	84 c0		 test	 al, al
  00281	0f 85 9f 00 00
	00		 jne	 $LN196@ApplyWeapo@20
  00287	8d 45 3b	 lea	 eax, DWORD PTR _value$700750[ebp]
  0028a	50		 push	 eax
  0028b	8d 8e cc 14 00
	00		 lea	 ecx, DWORD PTR [esi+5324]
  00291	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  00296	80 7d 3b 00	 cmp	 BYTE PTR _value$700750[ebp], 0
  0029a	0f 85 86 00 00
	00		 jne	 $LN196@ApplyWeapo@20

; 1105 : 			{
; 1106 : 				if( iPrevEquipItemCnt == 0 &&
; 1107 : 					(!IsDamageProtect() || pWeapon->IsIgnoreProtect()) &&
; 1108 : 					(!m_bEnableManaShield || pWeapon->IsIgnoreProtect()) &&
; 1109 : 					(!bTeamAttack || bEnableTeamAttack ) )

  002a0	33 db		 xor	 ebx, ebx
  002a2	39 5d e8	 cmp	 DWORD PTR _iPrevEquipItemCnt$[ebp], ebx
  002a5	75 7f		 jne	 SHORT $LN196@ApplyWeapo@20
  002a7	8b ce		 mov	 ecx, esi
  002a9	e8 00 00 00 00	 call	 ?IsDamageProtect@ioBaseChar@@QAE_NXZ ; ioBaseChar::IsDamageProtect
  002ae	84 c0		 test	 al, al
  002b0	74 14		 je	 SHORT $LN98@ApplyWeapo@20
  002b2	8d 45 38	 lea	 eax, DWORD PTR _value$700761[ebp]
  002b5	8d 8f 0c 06 00
	00		 lea	 ecx, DWORD PTR [edi+1548]
  002bb	50		 push	 eax
  002bc	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ; CEncrypt<int>::DecryptValueToPool
  002c1	39 5d 38	 cmp	 DWORD PTR _value$700761[ebp], ebx
  002c4	74 60		 je	 SHORT $LN196@ApplyWeapo@20
$LN98@ApplyWeapo@20:
  002c6	8d 45 3b	 lea	 eax, DWORD PTR _value$700766[ebp]
  002c9	50		 push	 eax
  002ca	8d 8e 78 19 00
	00		 lea	 ecx, DWORD PTR [esi+6520]
  002d0	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  002d5	38 5d 3b	 cmp	 BYTE PTR _value$700766[ebp], bl
  002d8	74 14		 je	 SHORT $LN97@ApplyWeapo@20
  002da	8d 45 38	 lea	 eax, DWORD PTR _value$700777[ebp]
  002dd	8d 8f 0c 06 00
	00		 lea	 ecx, DWORD PTR [edi+1548]
  002e3	50		 push	 eax
  002e4	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ; CEncrypt<int>::DecryptValueToPool
  002e9	39 5d 38	 cmp	 DWORD PTR _value$700777[ebp], ebx
  002ec	74 38		 je	 SHORT $LN196@ApplyWeapo@20
$LN97@ApplyWeapo@20:
  002ee	38 5d 3c	 cmp	 BYTE PTR _bTeamAttack$[ebp], bl
  002f1	74 05		 je	 SHORT $LN96@ApplyWeapo@20
  002f3	38 5d f3	 cmp	 BYTE PTR _bEnableTeamAttack$[ebp], bl
  002f6	74 2e		 je	 SHORT $LN196@ApplyWeapo@20
$LN96@ApplyWeapo@20:

; 1110 : 				{
; 1111 : 					if( !CheckPrisonerMode( fDamage ) && fDamage > 0.0f )

  002f8	f3 0f 10 45 40	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  002fd	51		 push	 ecx
  002fe	8b ce		 mov	 ecx, esi
  00300	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00305	e8 00 00 00 00	 call	 ?CheckPrisonerMode@ioBaseChar@@QAE_NM@Z ; ioBaseChar::CheckPrisonerMode
  0030a	f3 0f 10 45 40	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  0030f	84 c0		 test	 al, al
  00311	0f 85 80 00 00
	00		 jne	 $LN95@ApplyWeapo@20
  00317	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0031e	76 06		 jbe	 SHORT $LN196@ApplyWeapo@20

; 1112 : 					{
; 1113 : 						bCharDie = true;

  00320	8b 45 2c	 mov	 eax, DWORD PTR _bCharDie$[ebp]
  00323	c6 00 01	 mov	 BYTE PTR [eax], 1
$LN196@ApplyWeapo@20:

; 1150 : 							}
; 1151 : 						}
; 1152 : 
; 1153 : 						bPrisoner = true;

  00326	8b 5d 1c	 mov	 ebx, DWORD PTR _bWoundedLoopAni$[ebp]
$LN93@ApplyWeapo@20:

; 1154 : 					}
; 1155 : 				}
; 1156 : 			}
; 1157 : 		}
; 1158 : 
; 1159 : 		GrapplingType eWeaponGrappling = pWeapon->CheckGrapplingState();

  00329	8b 07		 mov	 eax, DWORD PTR [edi]
  0032b	8b cf		 mov	 ecx, edi
  0032d	ff 90 ec 00 00
	00		 call	 DWORD PTR [eax+236]
  00333	8b f8		 mov	 edi, eax

; 1160 : 		if( !bCharDie && bEnableCancel && !bNoCancel )

  00335	8b 45 2c	 mov	 eax, DWORD PTR _bCharDie$[ebp]
  00338	80 38 00	 cmp	 BYTE PTR [eax], 0
  0033b	0f 85 8d 06 00
	00		 jne	 $LN29@ApplyWeapo@20
  00341	80 7d 58 00	 cmp	 BYTE PTR _bEnableCancel$[ebp], 0
  00345	0f 84 83 06 00
	00		 je	 $LN29@ApplyWeapo@20
  0034b	80 7d 5c 00	 cmp	 BYTE PTR _bNoCancel$[ebp], 0
  0034f	0f 85 79 06 00
	00		 jne	 $LN29@ApplyWeapo@20

; 1161 : 		{
; 1162 : 			if( m_bCatchState )

  00355	80 be 78 23 00
	00 00		 cmp	 BYTE PTR [esi+9080], 0
  0035c	75 19		 jne	 SHORT $LN225@ApplyWeapo@20

; 1191 : 					}
; 1192 : 				}
; 1193 : 			}
; 1194 : 			else if( m_bPrisonerMode )

  0035e	8d 45 3f	 lea	 eax, DWORD PTR _value$700790[ebp]
  00361	50		 push	 eax
  00362	8d 8e cc 14 00
	00		 lea	 ecx, DWORD PTR [esi+5324]
  00368	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  0036d	80 7d 3f 00	 cmp	 BYTE PTR _value$700790[ebp], 0
  00371	0f 84 2b 02 00
	00		 je	 $LN69@ApplyWeapo@20
$LN225@ApplyWeapo@20:

; 1195 : 			{
; 1196 : 				if( eWeaponGrappling == GPT_NO_CHANGE || eWeaponGrappling == GPT_NO_CHANGE2 || eWeaponGrappling == GPT_NO_CHANGE3  )

  00377	83 ff 06	 cmp	 edi, 6
  0037a	74 0e		 je	 SHORT $LN67@ApplyWeapo@20
  0037c	83 ff 08	 cmp	 edi, 8
  0037f	74 09		 je	 SHORT $LN67@ApplyWeapo@20
  00381	83 ff 0f	 cmp	 edi, 15			; 0000000fH

; 1200 : 				}
; 1201 : 				else
; 1202 : 				{
; 1203 : 					if( m_BlowTargetType != BTT_BLOW &&
; 1204 : 						m_BlowTargetType != BTT_BLOW2 &&
; 1205 : 						m_BlowTargetType != BTT_BLOW3 &&
; 1206 : 						m_BlowTargetType != BTT_BOUND_BLOW &&
; 1207 : 						m_BlowTargetType != BTT_BLOW_EXTEND_WOUND )
; 1208 : 					{
; 1209 : 						fPushPower = m_fPrisonerPushPower;
; 1210 : 						fBlowPower = m_fPrisonerBlowPower;
; 1211 : 					}
; 1212 : 
; 1213 : 					if( m_BlowTargetType == BTT_BOUND_BLOW )
; 1214 : 					{
; 1215 : 						SetBoundWoundedState( fBoundJumpAmt, fBoundForceAmt, fBoundGrvityRate, fBoundDamage, false );
; 1216 : 					}
; 1217 : 					else
; 1218 : 					{
; 1219 : 						if( fBlowPower > m_fKOActionBlowPower )
; 1220 : 							SetBlowWoundedState( true, kBlowWoundAniInfo );
; 1221 : 						else

  00384	0f 85 8d 01 00
	00		 jne	 $LN221@ApplyWeapo@20
$LN67@ApplyWeapo@20:

; 1197 : 				{
; 1198 : 					bIgnorCatch = true;

  0038a	8b 45 20	 mov	 eax, DWORD PTR _bIgnorCatch$[ebp]
  0038d	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1199 : 					SetWoundedState( szWoundAni, dwWoundDuration, fDefenseEnableRate, bWoundedLoopAni, bIgnorCatch );

  00390	6a 01		 push	 1

; 1222 : 							SetBlowWoundedState( false, kBlowWoundAniInfo );
; 1223 : 					}
; 1224 : 				}

  00392	e9 8c 05 00 00	 jmp	 $LN217@ApplyWeapo@20
$LN95@ApplyWeapo@20:

; 1114 : 					}
; 1115 : 					else if( fDamage > 0.0f )

  00397	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0039e	76 86		 jbe	 SHORT $LN196@ApplyWeapo@20

; 1116 : 					{
; 1117 : 						if( bAllWeakWounded )

  003a0	8b 45 10	 mov	 eax, DWORD PTR _bAllWeakWounded$[ebp]
  003a3	38 18		 cmp	 BYTE PTR [eax], bl
  003a5	0f 84 8a 00 00
	00		 je	 $LN92@ApplyWeapo@20

; 1118 : 						{
; 1119 : 							if( m_BlowTargetType == BTT_WEAK )

  003ab	39 9e d0 0e 00
	00		 cmp	 DWORD PTR [esi+3792], ebx
  003b1	75 2f		 jne	 SHORT $LN91@ApplyWeapo@20

; 1120 : 							{
; 1121 : 								SetWoundedState( szWoundAni, dwWoundDuration, fDefenseEnableRate, bWoundedLoopAni, bIgnorCatch );

  003b3	8b 45 20	 mov	 eax, DWORD PTR _bIgnorCatch$[ebp]
  003b6	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  003b9	8b 5d 1c	 mov	 ebx, DWORD PTR _bWoundedLoopAni$[ebp]
  003bc	50		 push	 eax
  003bd	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  003c0	50		 push	 eax
  003c1	8b 45 24	 mov	 eax, DWORD PTR _fDefenseEnableRate$[ebp]
  003c4	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  003c8	8b 45 18	 mov	 eax, DWORD PTR _dwWoundDuration$[ebp]
  003cb	51		 push	 ecx
  003cc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003d1	ff 30		 push	 DWORD PTR [eax]
  003d3	8b ce		 mov	 ecx, esi
  003d5	ff 75 14	 push	 DWORD PTR _szWoundAni$[ebp]
  003d8	e8 00 00 00 00	 call	 ?SetWoundedState@ioBaseChar@@QAEXABVioHashString@@KM_N1@Z ; ioBaseChar::SetWoundedState

; 1122 : 							}
; 1123 : 							else

  003dd	e9 2a 01 00 00	 jmp	 $LN81@ApplyWeapo@20
$LN91@ApplyWeapo@20:

; 1124 : 							{
; 1125 : 								m_BlowTargetType = BTT_WEAK;

  003e2	21 9e d0 0e 00
	00		 and	 DWORD PTR [esi+3792], ebx

; 1126 : 
; 1127 : 								SetWoundedState( "", 0,	0.6f, bWoundedLoopAni, bIgnorCatch );

  003e8	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  003ed	8d 4d d4	 lea	 ecx, DWORD PTR $T700670[ebp]
  003f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  003f6	8b 45 20	 mov	 eax, DWORD PTR _bIgnorCatch$[ebp]
  003f9	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  003fc	8b 5d 1c	 mov	 ebx, DWORD PTR _bWoundedLoopAni$[ebp]
  003ff	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00407	50		 push	 eax
  00408	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0040b	50		 push	 eax
  0040c	51		 push	 ecx
  0040d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00412	6a 00		 push	 0
  00414	8d 45 d4	 lea	 eax, DWORD PTR $T700670[ebp]
  00417	50		 push	 eax
  00418	8b ce		 mov	 ecx, esi
  0041a	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0041e	e8 00 00 00 00	 call	 ?SetWoundedState@ioBaseChar@@QAEXABVioHashString@@KM_N1@Z ; ioBaseChar::SetWoundedState
  00423	8d 4d d4	 lea	 ecx, DWORD PTR $T700670[ebp]
  00426	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0042a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ

; 1128 : 							}
; 1129 : 						}
; 1130 : 						else

  00430	e9 d7 00 00 00	 jmp	 $LN81@ApplyWeapo@20
$LN92@ApplyWeapo@20:

; 1131 : 						{
; 1132 : 							if( m_BlowTargetType == BTT_BOUND_BLOW )

  00435	83 be d0 0e 00
	00 09		 cmp	 DWORD PTR [esi+3792], 9
  0043c	0f 85 8a 00 00
	00		 jne	 $LN88@ApplyWeapo@20

; 1133 : 							{
; 1134 : 								bool bGetUpState = false;
; 1135 : 								if( (m_CharState == CS_ETC_STATE && m_bBlowEtcState) ||
; 1136 : 									(m_CharState == CS_BLOW_WOUNDED && m_BlowState == BW_GETUP) ||
; 1137 : 									(m_CharState == CS_BOUND_BLOW_WOUNDED && m_BlowState == BW_GETUP) )

  00442	8a 86 10 03 00
	00		 mov	 al, BYTE PTR [esi+784]
  00448	88 5d 3c	 mov	 BYTE PTR _bGetUpState$694058[ebp], bl
  0044b	3c 0f		 cmp	 al, 15			; 0000000fH
  0044d	75 08		 jne	 SHORT $LN85@ApplyWeapo@20
  0044f	38 9e c6 15 00
	00		 cmp	 BYTE PTR [esi+5574], bl
  00455	75 37		 jne	 SHORT $LN86@ApplyWeapo@20
$LN85@ApplyWeapo@20:
  00457	3c 0c		 cmp	 al, 12			; 0000000cH
  00459	75 15		 jne	 SHORT $LN84@ApplyWeapo@20
  0045b	8d 45 38	 lea	 eax, DWORD PTR _value$700782[ebp]
  0045e	50		 push	 eax
  0045f	8d 8e 58 0f 00
	00		 lea	 ecx, DWORD PTR [esi+3928]
  00465	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4BlowWoundedState@@@@QAEXPAW4BlowWoundedState@@@Z ; CEncrypt<enum BlowWoundedState>::DecryptValueToPool
  0046a	83 7d 38 03	 cmp	 DWORD PTR _value$700782[ebp], 3
  0046e	74 1e		 je	 SHORT $LN86@ApplyWeapo@20
$LN84@ApplyWeapo@20:
  00470	80 be 10 03 00
	00 31		 cmp	 BYTE PTR [esi+784], 49	; 00000031H
  00477	75 19		 jne	 SHORT $LN87@ApplyWeapo@20
  00479	8d 45 38	 lea	 eax, DWORD PTR _value$700786[ebp]
  0047c	50		 push	 eax
  0047d	8d 8e 58 0f 00
	00		 lea	 ecx, DWORD PTR [esi+3928]
  00483	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4BlowWoundedState@@@@QAEXPAW4BlowWoundedState@@@Z ; CEncrypt<enum BlowWoundedState>::DecryptValueToPool
  00488	83 7d 38 03	 cmp	 DWORD PTR _value$700786[ebp], 3
  0048c	75 04		 jne	 SHORT $LN87@ApplyWeapo@20
$LN86@ApplyWeapo@20:

; 1138 : 								{
; 1139 : 									bGetUpState = true;

  0048e	c6 45 3c 01	 mov	 BYTE PTR _bGetUpState$694058[ebp], 1
$LN87@ApplyWeapo@20:

; 1140 : 								}
; 1141 : 
; 1142 : 								SetBoundWoundedState( fBoundJumpAmt, fBoundForceAmt, fBoundGrvityRate, fBoundDamage, bGetUpState );

  00492	ff 75 3c	 push	 DWORD PTR _bGetUpState$694058[ebp]
  00495	f3 0f 10 45 50	 movss	 xmm0, DWORD PTR _fBoundDamage$[ebp]
  0049a	83 ec 10	 sub	 esp, 16			; 00000010H
  0049d	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  004a3	f3 0f 10 45 4c	 movss	 xmm0, DWORD PTR _fBoundGrvityRate$[ebp]
  004a8	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  004ae	f3 0f 10 45 48	 movss	 xmm0, DWORD PTR _fBoundForceAmt$[ebp]
  004b3	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  004b9	f3 0f 10 45 44	 movss	 xmm0, DWORD PTR _fBoundJumpAmt$[ebp]
  004be	8b ce		 mov	 ecx, esi
  004c0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004c5	e8 00 00 00 00	 call	 ?SetBoundWoundedState@ioBaseChar@@QAEXMMMM_N@Z ; ioBaseChar::SetBoundWoundedState

; 1143 : 							}
; 1144 : 							else

  004ca	eb 3d		 jmp	 SHORT $LN212@ApplyWeapo@20
$LN88@ApplyWeapo@20:

; 1145 : 							{
; 1146 : 								if( fBlowPower > m_fKOActionBlowPower )

  004cc	8b 45 34	 mov	 eax, DWORD PTR _fBlowPower$[ebp]
  004cf	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  004d3	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR ?m_fKOActionBlowPower@ioBaseChar@@1MA
  004db	0f 5a c0	 cvtps2pd xmm0, xmm0
  004de	0f 5a c9	 cvtps2pd xmm1, xmm1
  004e1	66 0f 2f c1	 comisd	 xmm0, xmm1
  004e5	76 0f		 jbe	 SHORT $LN82@ApplyWeapo@20

; 1147 : 									SetBlowWoundedState( true, kBlowWoundAniInfo );

  004e7	6a 00		 push	 0
  004e9	6a 00		 push	 0
  004eb	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _kBlowWoundAniInfo$[ebp]
  004f1	50		 push	 eax
  004f2	6a 01		 push	 1

; 1148 : 								else

  004f4	eb 0c		 jmp	 SHORT $LN213@ApplyWeapo@20
$LN82@ApplyWeapo@20:

; 1149 : 									SetBlowWoundedState( false, kBlowWoundAniInfo );

  004f6	33 c0		 xor	 eax, eax
  004f8	50		 push	 eax
  004f9	50		 push	 eax
  004fa	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _kBlowWoundAniInfo$[ebp]
  00500	51		 push	 ecx
  00501	50		 push	 eax
$LN213@ApplyWeapo@20:
  00502	8b ce		 mov	 ecx, esi
  00504	e8 00 00 00 00	 call	 ?SetBlowWoundedState@ioBaseChar@@QAEX_NABUtagBlowWoundAniInfo@@00@Z ; ioBaseChar::SetBlowWoundedState
$LN212@ApplyWeapo@20:
  00509	8b 5d 1c	 mov	 ebx, DWORD PTR _bWoundedLoopAni$[ebp]
$LN81@ApplyWeapo@20:

; 1150 : 							}
; 1151 : 						}
; 1152 : 
; 1153 : 						bPrisoner = true;

  0050c	8b 45 54	 mov	 eax, DWORD PTR _bPrisoner$[ebp]
  0050f	c6 00 01	 mov	 BYTE PTR [eax], 1
  00512	e9 12 fe ff ff	 jmp	 $LN93@ApplyWeapo@20
$LN221@ApplyWeapo@20:

; 1163 : 			{
; 1164 : 				if( eWeaponGrappling == GPT_NO_CHANGE || eWeaponGrappling == GPT_NO_CHANGE2 || eWeaponGrappling == GPT_NO_CHANGE3 )
; 1165 : 				{
; 1166 : 					bIgnorCatch = true;
; 1167 : 					SetWoundedState( szWoundAni, dwWoundDuration, fDefenseEnableRate, bWoundedLoopAni, bIgnorCatch );
; 1168 : 				}
; 1169 : 				else
; 1170 : 				{
; 1171 : 					if( m_BlowTargetType != BTT_BLOW &&
; 1172 : 						m_BlowTargetType != BTT_BLOW2 &&
; 1173 : 						m_BlowTargetType != BTT_BLOW3 &&
; 1174 : 						m_BlowTargetType != BTT_BOUND_BLOW &&
; 1175 : 						m_BlowTargetType != BTT_BLOW_EXTEND_WOUND )

  00517	8b 86 d0 0e 00
	00		 mov	 eax, DWORD PTR [esi+3792]
  0051d	83 f8 01	 cmp	 eax, 1
  00520	74 32		 je	 SHORT $LN75@ApplyWeapo@20
  00522	83 f8 07	 cmp	 eax, 7
  00525	74 2d		 je	 SHORT $LN75@ApplyWeapo@20
  00527	83 f8 08	 cmp	 eax, 8
  0052a	74 28		 je	 SHORT $LN75@ApplyWeapo@20
  0052c	83 f8 09	 cmp	 eax, 9
  0052f	74 23		 je	 SHORT $LN75@ApplyWeapo@20
  00531	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  00534	74 1e		 je	 SHORT $LN75@ApplyWeapo@20

; 1176 : 					{
; 1177 : 						fPushPower = m_fPrisonerPushPower;

  00536	8b 45 30	 mov	 eax, DWORD PTR _fPushPower$[ebp]
  00539	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?m_fPrisonerPushPower@ioBaseChar@@1MA
  00541	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 1178 : 						fBlowPower = m_fPrisonerBlowPower;

  00545	8b 45 34	 mov	 eax, DWORD PTR _fBlowPower$[ebp]
  00548	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?m_fPrisonerBlowPower@ioBaseChar@@1MA
  00550	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
$LN75@ApplyWeapo@20:

; 1179 : 					}
; 1180 : 
; 1181 : 					if( m_BlowTargetType == BTT_BOUND_BLOW )

  00554	83 be d0 0e 00
	00 09		 cmp	 DWORD PTR [esi+3792], 9
  0055b	75 07		 jne	 SHORT $LN74@ApplyWeapo@20

; 1182 : 					{
; 1183 : 						SetBoundWoundedState( fBoundJumpAmt, fBoundForceAmt, fBoundGrvityRate, fBoundDamage, false );

  0055d	6a 00		 push	 0

; 1184 : 					}
; 1185 : 					else

  0055f	e9 1d 01 00 00	 jmp	 $LN218@ApplyWeapo@20
$LN74@ApplyWeapo@20:

; 1186 : 					{
; 1187 : 						if( fBlowPower > m_fKOActionBlowPower )

  00564	8b 45 34	 mov	 eax, DWORD PTR _fBlowPower$[ebp]
  00567	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR ?m_fKOActionBlowPower@ioBaseChar@@1MA
  0056f	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00573	0f 5a c9	 cvtps2pd xmm1, xmm1
  00576	0f 5a c0	 cvtps2pd xmm0, xmm0
  00579	66 0f 2f c1	 comisd	 xmm0, xmm1
  0057d	76 12		 jbe	 SHORT $LN72@ApplyWeapo@20

; 1188 : 							SetBlowWoundedState( true, kBlowWoundAniInfo );

  0057f	6a 00		 push	 0
  00581	6a 00		 push	 0
  00583	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _kBlowWoundAniInfo$[ebp]
  00589	50		 push	 eax
$LN216@ApplyWeapo@20:
  0058a	6a 01		 push	 1

; 1189 : 						else

  0058c	e9 36 04 00 00	 jmp	 $LN214@ApplyWeapo@20
$LN72@ApplyWeapo@20:

; 1190 : 							SetBlowWoundedState( false, kBlowWoundAniInfo );

  00591	33 c0		 xor	 eax, eax
  00593	50		 push	 eax
  00594	50		 push	 eax
  00595	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _kBlowWoundAniInfo$[ebp]
  0059b	51		 push	 ecx
  0059c	50		 push	 eax
  0059d	e9 25 04 00 00	 jmp	 $LN214@ApplyWeapo@20
$LN69@ApplyWeapo@20:

; 1225 : 			}
; 1226 : 			else if( !bPrisoner )

  005a2	8b 45 54	 mov	 eax, DWORD PTR _bPrisoner$[ebp]
  005a5	80 38 00	 cmp	 BYTE PTR [eax], 0
  005a8	0f 85 20 04 00
	00		 jne	 $LN29@ApplyWeapo@20

; 1227 : 			{
; 1228 : 				bool bMustBlowWoundBuff = CheckMustBlowWoundBuff();

  005ae	8b ce		 mov	 ecx, esi
  005b0	e8 00 00 00 00	 call	 ?CheckMustBlowWoundBuff@ioBaseChar@@QAE_NXZ ; ioBaseChar::CheckMustBlowWoundBuff
  005b5	88 45 3f	 mov	 BYTE PTR _bMustBlowWoundBuff$694091[ebp], al

; 1229 : 
; 1230 : 				if( bAllWeakWounded )

  005b8	8b 45 10	 mov	 eax, DWORD PTR _bAllWeakWounded$[ebp]
  005bb	80 38 00	 cmp	 BYTE PTR [eax], 0
  005be	74 5d		 je	 SHORT $LN58@ApplyWeapo@20

; 1231 : 				{
; 1232 : 					if( m_BlowTargetType == BTT_WEAK )

  005c0	33 ff		 xor	 edi, edi
  005c2	39 be d0 0e 00
	00		 cmp	 DWORD PTR [esi+3792], edi

; 1233 : 					{
; 1234 : 						SetWoundedState( szWoundAni, dwWoundDuration, fDefenseEnableRate, bWoundedLoopAni, bIgnorCatch );
; 1235 : 					}
; 1236 : 					else

  005c8	0f 84 4e 03 00
	00		 je	 $LN4@ApplyWeapo@20

; 1237 : 					{
; 1238 : 						m_BlowTargetType = BTT_WEAK;
; 1239 : 
; 1240 : 						SetWoundedState( "", 0,	0.6f, bWoundedLoopAni, bIgnorCatch );

  005ce	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  005d3	8d 4d d4	 lea	 ecx, DWORD PTR $T700673[ebp]
  005d6	89 be d0 0e 00
	00		 mov	 DWORD PTR [esi+3792], edi
  005dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  005e2	8b 45 20	 mov	 eax, DWORD PTR _bIgnorCatch$[ebp]
  005e5	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  005e8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  005f0	50		 push	 eax
  005f1	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  005f4	50		 push	 eax
  005f5	51		 push	 ecx
  005f6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005fb	57		 push	 edi
  005fc	8d 45 d4	 lea	 eax, DWORD PTR $T700673[ebp]
  005ff	50		 push	 eax
  00600	8b ce		 mov	 ecx, esi
  00602	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00606	e8 00 00 00 00	 call	 ?SetWoundedState@ioBaseChar@@QAEXABVioHashString@@KM_N1@Z ; ioBaseChar::SetWoundedState
  0060b	8d 4d d4	 lea	 ecx, DWORD PTR $T700673[ebp]
  0060e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00612	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ

; 1241 : 					}

  00618	e9 b1 03 00 00	 jmp	 $LN29@ApplyWeapo@20
$LN58@ApplyWeapo@20:

; 1242 : 				}
; 1243 : 				else if( m_BlowTargetType == BTT_BOUND_BLOW )

  0061d	8b 86 d0 0e 00
	00		 mov	 eax, DWORD PTR [esi+3792]
  00623	83 f8 09	 cmp	 eax, 9
  00626	0f 85 8f 00 00
	00		 jne	 $LN54@ApplyWeapo@20

; 1244 : 				{
; 1245 : 					bool bGetUpState = false;
; 1246 : 					if( (m_CharState == CS_ETC_STATE && m_bBlowEtcState) ||
; 1247 : 						(m_CharState == CS_BLOW_WOUNDED && m_BlowState == BW_GETUP) ||
; 1248 : 						(m_CharState == CS_BOUND_BLOW_WOUNDED && m_BlowState == BW_GETUP) )

  0062c	8a 86 10 03 00
	00		 mov	 al, BYTE PTR [esi+784]
  00632	c6 45 3c 00	 mov	 BYTE PTR _bGetUpState$694098[ebp], 0
  00636	3c 0f		 cmp	 al, 15			; 0000000fH
  00638	75 09		 jne	 SHORT $LN51@ApplyWeapo@20
  0063a	80 be c6 15 00
	00 00		 cmp	 BYTE PTR [esi+5574], 0
  00641	75 37		 jne	 SHORT $LN52@ApplyWeapo@20
$LN51@ApplyWeapo@20:
  00643	3c 0c		 cmp	 al, 12			; 0000000cH
  00645	75 15		 jne	 SHORT $LN50@ApplyWeapo@20
  00647	8d 45 38	 lea	 eax, DWORD PTR _value$700794[ebp]
  0064a	50		 push	 eax
  0064b	8d 8e 58 0f 00
	00		 lea	 ecx, DWORD PTR [esi+3928]
  00651	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4BlowWoundedState@@@@QAEXPAW4BlowWoundedState@@@Z ; CEncrypt<enum BlowWoundedState>::DecryptValueToPool
  00656	83 7d 38 03	 cmp	 DWORD PTR _value$700794[ebp], 3
  0065a	74 1e		 je	 SHORT $LN52@ApplyWeapo@20
$LN50@ApplyWeapo@20:
  0065c	80 be 10 03 00
	00 31		 cmp	 BYTE PTR [esi+784], 49	; 00000031H
  00663	75 19		 jne	 SHORT $LN53@ApplyWeapo@20
  00665	8d 45 38	 lea	 eax, DWORD PTR _value$700798[ebp]
  00668	50		 push	 eax
  00669	8d 8e 58 0f 00
	00		 lea	 ecx, DWORD PTR [esi+3928]
  0066f	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4BlowWoundedState@@@@QAEXPAW4BlowWoundedState@@@Z ; CEncrypt<enum BlowWoundedState>::DecryptValueToPool
  00674	83 7d 38 03	 cmp	 DWORD PTR _value$700798[ebp], 3
  00678	75 04		 jne	 SHORT $LN53@ApplyWeapo@20
$LN52@ApplyWeapo@20:

; 1249 : 					{
; 1250 : 						bGetUpState = true;

  0067a	c6 45 3c 01	 mov	 BYTE PTR _bGetUpState$694098[ebp], 1
$LN53@ApplyWeapo@20:

; 1251 : 					}
; 1252 : 
; 1253 : 					SetBoundWoundedState( fBoundJumpAmt, fBoundForceAmt, fBoundGrvityRate, fBoundDamage, bGetUpState );

  0067e	ff 75 3c	 push	 DWORD PTR _bGetUpState$694098[ebp]
$LN218@ApplyWeapo@20:
  00681	f3 0f 10 45 50	 movss	 xmm0, DWORD PTR _fBoundDamage$[ebp]
  00686	83 ec 10	 sub	 esp, 16			; 00000010H
  00689	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  0068f	f3 0f 10 45 4c	 movss	 xmm0, DWORD PTR _fBoundGrvityRate$[ebp]
  00694	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  0069a	f3 0f 10 45 48	 movss	 xmm0, DWORD PTR _fBoundForceAmt$[ebp]
  0069f	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  006a5	f3 0f 10 45 44	 movss	 xmm0, DWORD PTR _fBoundJumpAmt$[ebp]
  006aa	8b ce		 mov	 ecx, esi
  006ac	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006b1	e8 00 00 00 00	 call	 ?SetBoundWoundedState@ioBaseChar@@QAEXMMMM_N@Z ; ioBaseChar::SetBoundWoundedState
  006b6	e9 13 03 00 00	 jmp	 $LN29@ApplyWeapo@20
$LN54@ApplyWeapo@20:

; 1254 : 				}
; 1255 : 				else if( m_BlowTargetType == BTT_BLOW_EXTEND_WOUND )

  006bb	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  006be	75 3d		 jne	 SHORT $LN48@ApplyWeapo@20

; 1256 : 				{
; 1257 : 					SetBlowExtendWoundedState( szExtendWoundAni, dwExtendWoundDuration, fExtendWoundJumpAmt, fExtendWoundForceAmt,
; 1258 : 						fDefenseEnableRate, bWoundedLoopAni );

  006c0	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  006c3	50		 push	 eax
  006c4	8b 45 24	 mov	 eax, DWORD PTR _fDefenseEnableRate$[ebp]
  006c7	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  006cb	8b 45 64	 mov	 eax, DWORD PTR _dwExtendWoundDuration$[ebp]
  006ce	83 ec 0c	 sub	 esp, 12			; 0000000cH
  006d1	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  006d7	f3 0f 10 45 6c	 movss	 xmm0, DWORD PTR _fExtendWoundForceAmt$[ebp]
  006dc	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  006e2	f3 0f 10 45 68	 movss	 xmm0, DWORD PTR _fExtendWoundJumpAmt$[ebp]
  006e7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006ec	ff 30		 push	 DWORD PTR [eax]
  006ee	8b ce		 mov	 ecx, esi
  006f0	ff 75 60	 push	 DWORD PTR _szExtendWoundAni$[ebp]
  006f3	e8 00 00 00 00	 call	 ?SetBlowExtendWoundedState@ioBaseChar@@QAEXABVioHashString@@KMMM_N@Z ; ioBaseChar::SetBlowExtendWoundedState
  006f8	e9 d1 02 00 00	 jmp	 $LN29@ApplyWeapo@20
$LN48@ApplyWeapo@20:

; 1259 : 				}
; 1260 : 				else if( m_BlowTargetType == BTT_GETUP )

  006fd	83 f8 0b	 cmp	 eax, 11			; 0000000bH

; 1261 : 				{
; 1262 : 					SetWoundedState( szWoundAni, dwWoundDuration, fDefenseEnableRate, bWoundedLoopAni, bIgnorCatch );

  00700	0f 84 16 02 00
	00		 je	 $LN4@ApplyWeapo@20

; 1263 : 				}
; 1264 : 				else if( m_BlowTargetType == BTT_GETUP_STAND_KO )

  00706	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  00709	75 13		 jne	 SHORT $LN44@ApplyWeapo@20

; 1265 : 				{
; 1266 : 					m_BlowTargetType = BTT_STAND_KO2;

  0070b	6a 06		 push	 6
$LN223@ApplyWeapo@20:
  0070d	5f		 pop	 edi
$LN222@ApplyWeapo@20:

; 1267 : 					eNewBlowType = BTT_STAND_KO2;

  0070e	8b 45 28	 mov	 eax, DWORD PTR _eNewBlowType$[ebp]
  00711	89 be d0 0e 00
	00		 mov	 DWORD PTR [esi+3792], edi
  00717	89 38		 mov	 DWORD PTR [eax], edi

; 1268 : 
; 1269 : 					SetWoundedState( szWoundAni, dwWoundDuration, fDefenseEnableRate, bWoundedLoopAni, bIgnorCatch );
; 1270 : 				}
; 1271 : 				else if( IsJumppingState() ||

  00719	e9 fe 01 00 00	 jmp	 $LN4@ApplyWeapo@20
$LN44@ApplyWeapo@20:

; 1272 : 					m_CharState == CS_BLOW_WOUNDED ||
; 1273 : 					m_CharState == CS_BOUND_BLOW_WOUNDED ||
; 1274 : 					m_CharState == CS_BLOW_EXTEND_WOUND ||
; 1275 : 					m_CharState == CS_FLOAT_STATE ||
; 1276 : 					m_CharState == CS_CREEPING ||
; 1277 : 					m_CharState == CS_FALL ||
; 1278 : 					m_CharState == CS_CHARGE_FLY ||
; 1279 : 					m_CharState == CS_BUFF_ACTION ||	
; 1280 : 					(m_CharState == CS_USING_SKILL && m_pActiveSkill && m_pActiveSkill->IsDownState()) ||
; 1281 : 					(m_CharState == CS_USING_SKILL && m_pActiveSkill && m_pActiveSkill->IsJumpState()) ||
; 1282 : 					(m_CharState == CS_ETC_STATE && m_bBlowEtcState ) ||
; 1283 : 					(m_CharState == CS_STOP_MOTION && GetBlowStopMotionState() ) ||
; 1284 : 					(m_CharState == CS_ICE_STATE && GetBlowStopMotionState() ) ||
; 1285 : 					(m_CharState == CS_EXTEND_DASH && IsCanPlayWoundedAniFromExtendDash() ) ||
; 1286 : 					m_BlowTargetType == BTT_BLOW ||
; 1287 : 					m_BlowTargetType == BTT_BLOW2 ||
; 1288 : 					m_BlowTargetType == BTT_BLOW3 ||
; 1289 : 					m_BlowTargetType == BTT_FLATTEN ||
; 1290 : 					bMustBlowWoundBuff ||
; 1291 : 					( m_pCharSpeicalState && m_pCharSpeicalState->IsEnableBlowWounded( this ) ) )

  0071e	8b ce		 mov	 ecx, esi
  00720	e8 00 00 00 00	 call	 ?IsJumppingState@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsJumppingState
  00725	84 c0		 test	 al, al
  00727	0f 85 1b 02 00
	00		 jne	 $LN41@ApplyWeapo@20
  0072d	8a 86 10 03 00
	00		 mov	 al, BYTE PTR [esi+784]
  00733	3c 0c		 cmp	 al, 12			; 0000000cH
  00735	0f 84 0d 02 00
	00		 je	 $LN41@ApplyWeapo@20
  0073b	3c 31		 cmp	 al, 49			; 00000031H
  0073d	0f 84 05 02 00
	00		 je	 $LN41@ApplyWeapo@20
  00743	3c 46		 cmp	 al, 70			; 00000046H
  00745	0f 84 fd 01 00
	00		 je	 $LN41@ApplyWeapo@20
  0074b	3c 25		 cmp	 al, 37			; 00000025H
  0074d	0f 84 f5 01 00
	00		 je	 $LN41@ApplyWeapo@20
  00753	3c 1e		 cmp	 al, 30			; 0000001eH
  00755	0f 84 ed 01 00
	00		 je	 $LN41@ApplyWeapo@20
  0075b	3c 12		 cmp	 al, 18			; 00000012H
  0075d	0f 84 e5 01 00
	00		 je	 $LN41@ApplyWeapo@20
  00763	3c 4d		 cmp	 al, 77			; 0000004dH
  00765	0f 84 dd 01 00
	00		 je	 $LN41@ApplyWeapo@20
  0076b	3c 70		 cmp	 al, 112			; 00000070H
  0076d	0f 84 d5 01 00
	00		 je	 $LN41@ApplyWeapo@20
  00773	3c 07		 cmp	 al, 7
  00775	75 1a		 jne	 SHORT $LN40@ApplyWeapo@20
  00777	8b 8e e0 0d 00
	00		 mov	 ecx, DWORD PTR [esi+3552]
  0077d	85 c9		 test	 ecx, ecx
  0077f	74 10		 je	 SHORT $LN40@ApplyWeapo@20
  00781	8b 01		 mov	 eax, DWORD PTR [ecx]
  00783	ff 90 80 00 00
	00		 call	 DWORD PTR [eax+128]
  00789	84 c0		 test	 al, al
  0078b	0f 85 b7 01 00
	00		 jne	 $LN41@ApplyWeapo@20
$LN40@ApplyWeapo@20:
  00791	80 be 10 03 00
	00 07		 cmp	 BYTE PTR [esi+784], 7
  00798	75 17		 jne	 SHORT $LN39@ApplyWeapo@20
  0079a	8b 8e e0 0d 00
	00		 mov	 ecx, DWORD PTR [esi+3552]
  007a0	85 c9		 test	 ecx, ecx
  007a2	74 0d		 je	 SHORT $LN39@ApplyWeapo@20
  007a4	8b 01		 mov	 eax, DWORD PTR [ecx]
  007a6	ff 50 7c	 call	 DWORD PTR [eax+124]
  007a9	84 c0		 test	 al, al
  007ab	0f 85 97 01 00
	00		 jne	 $LN41@ApplyWeapo@20
$LN39@ApplyWeapo@20:
  007b1	8a 86 10 03 00
	00		 mov	 al, BYTE PTR [esi+784]
  007b7	3c 0f		 cmp	 al, 15			; 0000000fH
  007b9	75 0d		 jne	 SHORT $LN38@ApplyWeapo@20
  007bb	80 be c6 15 00
	00 00		 cmp	 BYTE PTR [esi+5574], 0
  007c2	0f 85 80 01 00
	00		 jne	 $LN41@ApplyWeapo@20
$LN38@ApplyWeapo@20:
  007c8	3c 26		 cmp	 al, 38			; 00000026H
  007ca	75 0d		 jne	 SHORT $LN37@ApplyWeapo@20
  007cc	80 be c7 15 00
	00 00		 cmp	 BYTE PTR [esi+5575], 0
  007d3	0f 85 6f 01 00
	00		 jne	 $LN41@ApplyWeapo@20
$LN37@ApplyWeapo@20:
  007d9	3c 3b		 cmp	 al, 59			; 0000003bH
  007db	75 0d		 jne	 SHORT $LN36@ApplyWeapo@20
  007dd	80 be c7 15 00
	00 00		 cmp	 BYTE PTR [esi+5575], 0
  007e4	0f 85 5e 01 00
	00		 jne	 $LN41@ApplyWeapo@20
$LN36@ApplyWeapo@20:
  007ea	3c 03		 cmp	 al, 3
  007ec	75 0f		 jne	 SHORT $LN35@ApplyWeapo@20
  007ee	8b ce		 mov	 ecx, esi
  007f0	e8 00 00 00 00	 call	 ?IsCanPlayWoundedAniFromExtendDash@ioBaseChar@@IAE_NXZ ; ioBaseChar::IsCanPlayWoundedAniFromExtendDash
  007f5	84 c0		 test	 al, al
  007f7	0f 85 4b 01 00
	00		 jne	 $LN41@ApplyWeapo@20
$LN35@ApplyWeapo@20:
  007fd	8b 86 d0 0e 00
	00		 mov	 eax, DWORD PTR [esi+3792]
  00803	83 f8 01	 cmp	 eax, 1
  00806	0f 84 3c 01 00
	00		 je	 $LN41@ApplyWeapo@20
  0080c	83 f8 07	 cmp	 eax, 7
  0080f	0f 84 33 01 00
	00		 je	 $LN41@ApplyWeapo@20
  00815	83 f8 08	 cmp	 eax, 8
  00818	0f 84 2a 01 00
	00		 je	 $LN41@ApplyWeapo@20
  0081e	83 f8 02	 cmp	 eax, 2
  00821	0f 84 21 01 00
	00		 je	 $LN41@ApplyWeapo@20
  00827	80 7d 3f 00	 cmp	 BYTE PTR _bMustBlowWoundBuff$694091[ebp], 0
  0082b	0f 85 17 01 00
	00		 jne	 $LN41@ApplyWeapo@20
  00831	8b 8e 14 03 00
	00		 mov	 ecx, DWORD PTR [esi+788]
  00837	85 c9		 test	 ecx, ecx
  00839	74 0e		 je	 SHORT $LN42@ApplyWeapo@20
  0083b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0083d	56		 push	 esi
  0083e	ff 50 4c	 call	 DWORD PTR [eax+76]
  00841	84 c0		 test	 al, al
  00843	0f 85 ff 00 00
	00		 jne	 $LN41@ApplyWeapo@20
$LN42@ApplyWeapo@20:

; 1305 : 				}
; 1306 : 				else if( m_CharState == CS_WOUNDED )

  00849	8a 86 10 03 00
	00		 mov	 al, BYTE PTR [esi+784]
  0084f	3c 0b		 cmp	 al, 11			; 0000000bH
  00851	0f 85 8d 00 00
	00		 jne	 $LN27@ApplyWeapo@20

; 1307 : 				{
; 1308 : 					if( ePreBlowType == BTT_M_STIFF )

  00857	83 7d ec 03	 cmp	 DWORD PTR _ePreBlowType$[ebp], 3
  0085b	75 0f		 jne	 SHORT $LN26@ApplyWeapo@20

; 1309 : 					{
; 1310 : 						if( m_BlowTargetType == BTT_M_STIFF )

  0085d	83 be d0 0e 00
	00 03		 cmp	 DWORD PTR [esi+3792], 3
  00864	0f 85 b2 00 00
	00		 jne	 $LN4@ApplyWeapo@20

; 1311 : 						{
; 1312 : 							m_BlowTargetType = BTT_STAND_KO;
; 1313 : 							eNewBlowType = BTT_STAND_KO;
; 1314 : 						}
; 1315 : 
; 1316 : 						SetWoundedState( szWoundAni, dwWoundDuration, fDefenseEnableRate, bWoundedLoopAni, bIgnorCatch );

  0086a	eb 2c		 jmp	 SHORT $LN226@ApplyWeapo@20
$LN26@ApplyWeapo@20:

; 1317 : 					}
; 1318 : 					else if( ePreBlowType == BTT_M_BLOW && m_BlowTargetType == BTT_M_BLOW )

  0086c	83 7d ec 0a	 cmp	 DWORD PTR _ePreBlowType$[ebp], 10 ; 0000000aH
  00870	6a 05		 push	 5
  00872	5f		 pop	 edi
  00873	75 2a		 jne	 SHORT $LN19@ApplyWeapo@20
  00875	8b 86 d0 0e 00
	00		 mov	 eax, DWORD PTR [esi+3792]
  0087b	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0087e	75 13		 jne	 SHORT $LN190@ApplyWeapo@20

; 1319 : 					{
; 1320 : 						m_BlowTargetType = BTT_BLOW3;
; 1321 : 						eNewBlowType = BTT_BLOW3;

  00880	8b 4d 28	 mov	 ecx, DWORD PTR _eNewBlowType$[ebp]
  00883	6a 08		 push	 8
  00885	58		 pop	 eax
  00886	89 86 d0 0e 00
	00		 mov	 DWORD PTR [esi+3792], eax
  0088c	89 01		 mov	 DWORD PTR [ecx], eax

; 1322 : 
; 1323 : 						if( fBlowPower > m_fKOActionBlowPower )
; 1324 : 							SetBlowWoundedState( true, kBlowWoundAniInfo );
; 1325 : 						else

  0088e	e9 d1 fc ff ff	 jmp	 $LN74@ApplyWeapo@20
$LN190@ApplyWeapo@20:

; 1326 : 							SetBlowWoundedState( false, kBlowWoundAniInfo );
; 1327 : 					}
; 1328 : 					else if( ePreBlowType == BTT_M_BLOW && m_BlowTargetType == BTT_M_STIFF )

  00893	83 f8 03	 cmp	 eax, 3
  00896	75 10		 jne	 SHORT $LN191@ApplyWeapo@20
$LN226@ApplyWeapo@20:

; 1329 : 					{
; 1330 : 						m_BlowTargetType = BTT_STAND_KO;

  00898	6a 05		 push	 5

; 1331 : 						eNewBlowType = BTT_STAND_KO;
; 1332 : 
; 1333 : 						SetWoundedState( szWoundAni, dwWoundDuration, fDefenseEnableRate, bWoundedLoopAni, bIgnorCatch );

  0089a	e9 6e fe ff ff	 jmp	 $LN223@ApplyWeapo@20
$LN19@ApplyWeapo@20:

; 1334 : 					}
; 1335 : 					else if( ePreBlowType == BTT_STAND_KO || IsFloatingState() )

  0089f	39 7d ec	 cmp	 DWORD PTR _ePreBlowType$[ebp], edi
  008a2	0f 84 bc fc ff
	ff		 je	 $LN74@ApplyWeapo@20
$LN191@ApplyWeapo@20:
  008a8	8b ce		 mov	 ecx, esi
  008aa	e8 00 00 00 00	 call	 ?IsFloatingState@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsFloatingState
  008af	84 c0		 test	 al, al
  008b1	0f 85 ad fc ff
	ff		 jne	 $LN74@ApplyWeapo@20

; 1336 : 					{
; 1337 : 						if( fBlowPower > m_fKOActionBlowPower )
; 1338 : 							SetBlowWoundedState( true, kBlowWoundAniInfo );
; 1339 : 						else
; 1340 : 							SetBlowWoundedState( false, kBlowWoundAniInfo );
; 1341 : 					}
; 1342 : 					else if( ePreBlowType == BTT_STAND_KO2 || IsFloatingState() )

  008b7	83 7d ec 06	 cmp	 DWORD PTR _ePreBlowType$[ebp], 6
  008bb	0f 84 a3 fc ff
	ff		 je	 $LN74@ApplyWeapo@20
  008c1	8b ce		 mov	 ecx, esi
  008c3	e8 00 00 00 00	 call	 ?IsFloatingState@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsFloatingState
  008c8	84 c0		 test	 al, al
  008ca	0f 85 94 fc ff
	ff		 jne	 $LN74@ApplyWeapo@20

; 1343 : 					{
; 1344 : 						if( fBlowPower > m_fKOActionBlowPower )
; 1345 : 							SetBlowWoundedState( true, kBlowWoundAniInfo );
; 1346 : 						else
; 1347 : 							SetBlowWoundedState( false, kBlowWoundAniInfo );
; 1348 : 					}
; 1349 : 					else if( ePreBlowType == BTT_GETUP && m_BlowTargetType == BTT_M_STIFF )

  008d0	83 7d ec 0b	 cmp	 DWORD PTR _ePreBlowType$[ebp], 11 ; 0000000bH
  008d4	75 46		 jne	 SHORT $LN4@ApplyWeapo@20
  008d6	83 be d0 0e 00
	00 03		 cmp	 DWORD PTR [esi+3792], 3
  008dd	75 3d		 jne	 SHORT $LN4@ApplyWeapo@20

; 1350 : 					{
; 1351 : 						m_BlowTargetType = BTT_STAND_KO;
; 1352 : 						eNewBlowType = BTT_STAND_KO;
; 1353 : 
; 1354 : 						SetWoundedState( szWoundAni, dwWoundDuration, fDefenseEnableRate, bWoundedLoopAni, bIgnorCatch );
; 1355 : 					}
; 1356 : 					else

  008df	e9 2a fe ff ff	 jmp	 $LN222@ApplyWeapo@20
$LN27@ApplyWeapo@20:

; 1357 : 					{
; 1358 : 						SetWoundedState( szWoundAni, dwWoundDuration, fDefenseEnableRate, bWoundedLoopAni, bIgnorCatch );
; 1359 : 					}
; 1360 : 				}
; 1361 : 				else if( m_CharState == CS_ATTACK &&
; 1362 : 					ToLinearChargeItem2( GetPriorityItem(SPT_EXTEND_ATTACK) ) &&
; 1363 : 					ToLinearChargeItem2( GetPriorityItem(SPT_EXTEND_ATTACK) )->IsMustBlowWoundState() )

  008e4	3c 05		 cmp	 al, 5
  008e6	75 34		 jne	 SHORT $LN4@ApplyWeapo@20
  008e8	6a 06		 push	 6
  008ea	5f		 pop	 edi
  008eb	57		 push	 edi
  008ec	8b ce		 mov	 ecx, esi
  008ee	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  008f3	50		 push	 eax
  008f4	e8 00 00 00 00	 call	 ?ToLinearChargeItem2@@YAPAVioLinearChargeItem2@@PAVioItem@@@Z ; ToLinearChargeItem2
  008f9	59		 pop	 ecx
  008fa	85 c0		 test	 eax, eax
  008fc	74 1e		 je	 SHORT $LN4@ApplyWeapo@20
  008fe	57		 push	 edi
  008ff	8b ce		 mov	 ecx, esi
  00901	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  00906	50		 push	 eax
  00907	e8 00 00 00 00	 call	 ?ToLinearChargeItem2@@YAPAVioLinearChargeItem2@@PAVioItem@@@Z ; ToLinearChargeItem2
  0090c	59		 pop	 ecx
  0090d	8b c8		 mov	 ecx, eax
  0090f	e8 00 00 00 00	 call	 ?IsMustBlowWoundState@ioLinearChargeItem2@@QAE_NXZ ; ioLinearChargeItem2::IsMustBlowWoundState
  00914	84 c0		 test	 al, al

; 1364 : 				{
; 1365 : 					if( fBlowPower > m_fKOActionBlowPower )
; 1366 : 						SetBlowWoundedState( true, kBlowWoundAniInfo );
; 1367 : 					else

  00916	0f 85 48 fc ff
	ff		 jne	 $LN74@ApplyWeapo@20
$LN4@ApplyWeapo@20:

; 1368 : 						SetBlowWoundedState( false, kBlowWoundAniInfo );
; 1369 : 				}
; 1370 : 				else
; 1371 : 				{
; 1372 : 					SetWoundedState( szWoundAni, dwWoundDuration, fDefenseEnableRate, bWoundedLoopAni, bIgnorCatch );

  0091c	8b 45 20	 mov	 eax, DWORD PTR _bIgnorCatch$[ebp]
  0091f	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00922	50		 push	 eax
$LN217@ApplyWeapo@20:
  00923	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00926	50		 push	 eax
  00927	8b 45 24	 mov	 eax, DWORD PTR _fDefenseEnableRate$[ebp]
  0092a	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0092e	8b 45 18	 mov	 eax, DWORD PTR _dwWoundDuration$[ebp]
  00931	51		 push	 ecx
  00932	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00937	ff 30		 push	 DWORD PTR [eax]
  00939	8b ce		 mov	 ecx, esi
  0093b	ff 75 14	 push	 DWORD PTR _szWoundAni$[ebp]
  0093e	e8 00 00 00 00	 call	 ?SetWoundedState@ioBaseChar@@QAEXABVioHashString@@KM_N1@Z ; ioBaseChar::SetWoundedState
  00943	e9 86 00 00 00	 jmp	 $LN29@ApplyWeapo@20
$LN41@ApplyWeapo@20:

; 1292 : 				{
; 1293 : 					bool bGetUpState = false;
; 1294 : 					if( (m_CharState == CS_ETC_STATE && m_bBlowEtcState) ||
; 1295 : 						(m_CharState == CS_BLOW_WOUNDED && m_BlowState == BW_GETUP) ||
; 1296 : 						(m_CharState == CS_BOUND_BLOW_WOUNDED && m_BlowState == BW_GETUP) )

  00948	8a 86 10 03 00
	00		 mov	 al, BYTE PTR [esi+784]
  0094e	c6 45 3c 00	 mov	 BYTE PTR _bGetUpState$694120[ebp], 0
  00952	3c 0f		 cmp	 al, 15			; 0000000fH
  00954	75 09		 jne	 SHORT $LN32@ApplyWeapo@20
  00956	80 be c6 15 00
	00 00		 cmp	 BYTE PTR [esi+5574], 0
  0095d	75 37		 jne	 SHORT $LN33@ApplyWeapo@20
$LN32@ApplyWeapo@20:
  0095f	3c 0c		 cmp	 al, 12			; 0000000cH
  00961	75 15		 jne	 SHORT $LN31@ApplyWeapo@20
  00963	8d 45 38	 lea	 eax, DWORD PTR _value$700810[ebp]
  00966	50		 push	 eax
  00967	8d 8e 58 0f 00
	00		 lea	 ecx, DWORD PTR [esi+3928]
  0096d	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4BlowWoundedState@@@@QAEXPAW4BlowWoundedState@@@Z ; CEncrypt<enum BlowWoundedState>::DecryptValueToPool
  00972	83 7d 38 03	 cmp	 DWORD PTR _value$700810[ebp], 3
  00976	74 1e		 je	 SHORT $LN33@ApplyWeapo@20
$LN31@ApplyWeapo@20:
  00978	80 be 10 03 00
	00 31		 cmp	 BYTE PTR [esi+784], 49	; 00000031H
  0097f	75 19		 jne	 SHORT $LN34@ApplyWeapo@20
  00981	8d 45 38	 lea	 eax, DWORD PTR _value$700814[ebp]
  00984	50		 push	 eax
  00985	8d 8e 58 0f 00
	00		 lea	 ecx, DWORD PTR [esi+3928]
  0098b	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4BlowWoundedState@@@@QAEXPAW4BlowWoundedState@@@Z ; CEncrypt<enum BlowWoundedState>::DecryptValueToPool
  00990	83 7d 38 03	 cmp	 DWORD PTR _value$700814[ebp], 3
  00994	75 04		 jne	 SHORT $LN34@ApplyWeapo@20
$LN33@ApplyWeapo@20:

; 1297 : 					{
; 1298 : 						bGetUpState = true;

  00996	c6 45 3c 01	 mov	 BYTE PTR _bGetUpState$694120[ebp], 1
$LN34@ApplyWeapo@20:

; 1299 : 					}
; 1300 : 
; 1301 : 					if( fBlowPower > m_fKOActionBlowPower )

  0099a	8b 45 34	 mov	 eax, DWORD PTR _fBlowPower$[ebp]
  0099d	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  009a1	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR ?m_fKOActionBlowPower@ioBaseChar@@1MA

; 1302 : 						SetBlowWoundedState( true, kBlowWoundAniInfo, bGetUpState );

  009a9	6a 00		 push	 0
  009ab	ff 75 3c	 push	 DWORD PTR _bGetUpState$694120[ebp]
  009ae	0f 5a c0	 cvtps2pd xmm0, xmm0
  009b1	0f 5a c9	 cvtps2pd xmm1, xmm1
  009b4	66 0f 2f c1	 comisd	 xmm0, xmm1
  009b8	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _kBlowWoundAniInfo$[ebp]
  009be	50		 push	 eax

; 1303 : 					else

  009bf	0f 87 c5 fb ff
	ff		 ja	 $LN216@ApplyWeapo@20

; 1304 : 						SetBlowWoundedState( false, kBlowWoundAniInfo, bGetUpState );

  009c5	6a 00		 push	 0
$LN214@ApplyWeapo@20:
  009c7	8b ce		 mov	 ecx, esi
  009c9	e8 00 00 00 00	 call	 ?SetBlowWoundedState@ioBaseChar@@QAEX_NABUtagBlowWoundAniInfo@@00@Z ; ioBaseChar::SetBlowWoundedState
$LN29@ApplyWeapo@20:

; 1373 : 				}
; 1374 : 			}
; 1375 : 		}
; 1376 : 	}
; 1377 : }

  009ce	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  009d2	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _kBlowWoundAniInfo$[ebp]
  009d8	e8 00 00 00 00	 call	 ??1tagBlowWoundAniInfo@@QAE@XZ
$LN121@ApplyWeapo@20:
  009dd	e8 00 00 00 00	 call	 __EH_epilog3
  009e2	c2 68 00	 ret	 104			; 00000068H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ApplyWeaponWoundedChangeState@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_NAAVioHashString@@AAK22AAMAAW4BlowTargetType@@255_N7MMMMM27734MM@Z$0:
  00000	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _kBlowWoundAniInfo$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1tagBlowWoundAniInfo@@QAE@XZ
__unwindfunclet$?ApplyWeaponWoundedChangeState@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_NAAVioHashString@@AAK22AAMAAW4BlowTargetType@@255_N7MMMMM27734MM@Z$1:
  0000b	8d 4d d4	 lea	 ecx, DWORD PTR _szConcentrateTargetName$694040[ebp]
  0000e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?ApplyWeaponWoundedChangeState@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_NAAVioHashString@@AAK22AAMAAW4BlowTargetType@@255_N7MMMMM27734MM@Z$2:
  00014	8d 4d d4	 lea	 ecx, DWORD PTR $T700670[ebp]
  00017	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?ApplyWeaponWoundedChangeState@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_NAAVioHashString@@AAK22AAMAAW4BlowTargetType@@255_N7MMMMM27734MM@Z$3:
  0001d	8d 4d d4	 lea	 ecx, DWORD PTR $T700673[ebp]
  00020	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$?ApplyWeaponWoundedChangeState@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_NAAVioHashString@@AAK22AAMAAW4BlowTargetType@@255_N7MMMMM27734MM@Z:
  00026	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002d	8b 8a 70 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-144]
  00033	33 c8		 xor	 ecx, eax
  00035	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ApplyWeaponWoundedChangeState@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_NAAVioHashString@@AAK22AAMAAW4BlowTargetType@@255_N7MMMMM27734MM@Z
  0003f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ApplyWeaponWoundedChangeState@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_NAAVioHashString@@AAK22AAMAAW4BlowTargetType@@255_N7MMMMM27734MM@Z ENDP ; ioBaseChar::ApplyWeaponWoundedChangeState
PUBLIC	__$ArrayPad$
PUBLIC	?ApplyWeaponWoundedChangePrisonerState@ioBaseChar@@IAEX_N00W4EscapeCatchType@@@Z ; ioBaseChar::ApplyWeaponWoundedChangePrisonerState
EXTRN	?SetEscapeCatchState@ioBaseChar@@QAEXXZ:PROC	; ioBaseChar::SetEscapeCatchState
EXTRN	?EscapePrisonerChar@ioCatchMode@@QAEXPAVioBaseChar@@@Z:PROC ; ioCatchMode::EscapePrisonerChar
EXTRN	??1SP2Packet@@UAE@XZ:PROC			; SP2Packet::~SP2Packet
EXTRN	?SendToServer@TCPNetwork@@YAXAAVSP2Packet@@@Z:PROC ; TCPNetwork::SendToServer
EXTRN	??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z:PROC	; SP2Packet::operator<<
EXTRN	??0SP2Packet@@QAE@K@Z:PROC			; SP2Packet::SP2Packet
EXTRN	?IsNetworkMode@ioPlayStage@@QAE_NXZ:PROC	; ioPlayStage::IsNetworkMode
EXTRN	?IsNetworkPlaying@P2PNetwork@@YA_NXZ:PROC	; P2PNetwork::IsNetworkPlaying
EXTRN	__chkstk:PROC
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasechar.h
xdata$x	SEGMENT
__unwindtable$?ApplyWeaponWoundedChangePrisonerState@ioBaseChar@@IAEX_N00W4EscapeCatchType@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ApplyWeaponWoundedChangePrisonerState@ioBaseChar@@IAEX_N00W4EscapeCatchType@@@Z$0
__ehfuncinfo$?ApplyWeaponWoundedChangePrisonerState@ioBaseChar@@IAEX_N00W4EscapeCatchType@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ApplyWeaponWoundedChangePrisonerState@ioBaseChar@@IAEX_N00W4EscapeCatchType@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasecharapplywoundednew.cpp
xdata$x	ENDS
;	COMDAT ?ApplyWeaponWoundedChangePrisonerState@ioBaseChar@@IAEX_N00W4EscapeCatchType@@@Z
_TEXT	SEGMENT
_pUnderwear$694174 = -32816				; size = 4
_value$700867 = -32809					; size = 1
_kPacket$694171 = -32808				; size = 32792
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_bTeamAttack$ = 8					; size = 1
_bFrozenState$ = 12					; size = 1
_bContactType$ = 16					; size = 1
_eEscapeCatchType$ = 20					; size = 4
?ApplyWeaponWoundedChangePrisonerState@ioBaseChar@@IAEX_N00W4EscapeCatchType@@@Z PROC ; ioBaseChar::ApplyWeaponWoundedChangePrisonerState, COMDAT
; _this$ = ecx

; 1380 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ApplyWeaponWoundedChangePrisonerState@ioBaseChar@@IAEX_N00W4EscapeCatchType@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 24 80 00 00	 mov	 eax, 32804		; 00008024H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00032	8b f1		 mov	 esi, ecx

; 1381 : 	if( m_bPrisonerMode && bTeamAttack && !bFrozenState )

  00034	8d 85 d7 7f ff
	ff		 lea	 eax, DWORD PTR _value$700867[ebp]
  0003a	50		 push	 eax
  0003b	8d 8e cc 14 00
	00		 lea	 ecx, DWORD PTR [esi+5324]
  00041	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  00046	33 db		 xor	 ebx, ebx
  00048	38 9d d7 7f ff
	ff		 cmp	 BYTE PTR _value$700867[ebp], bl
  0004e	0f 84 ee 00 00
	00		 je	 $LN13@ApplyWeapo@21
  00054	38 5d 08	 cmp	 BYTE PTR _bTeamAttack$[ebp], bl
  00057	0f 84 e5 00 00
	00		 je	 $LN13@ApplyWeapo@21
  0005d	38 5d 0c	 cmp	 BYTE PTR _bFrozenState$[ebp], bl
  00060	0f 85 dc 00 00
	00		 jne	 $LN13@ApplyWeapo@21

; 1382 : 	{
; 1383 : 		if( bContactType || eEscapeCatchType != ECT_NONE )

  00066	38 5d 10	 cmp	 BYTE PTR _bContactType$[ebp], bl
  00069	75 09		 jne	 SHORT $LN11@ApplyWeapo@21
  0006b	39 5d 14	 cmp	 DWORD PTR _eEscapeCatchType$[ebp], ebx
  0006e	0f 84 f1 00 00
	00		 je	 $LN2@ApplyWeapo@21
$LN11@ApplyWeapo@21:

; 1384 : 		{
; 1385 : 			if( P2PNetwork::IsNetworkPlaying() && m_pCreator->IsNetworkMode() )

  00074	e8 00 00 00 00	 call	 ?IsNetworkPlaying@P2PNetwork@@YA_NXZ ; P2PNetwork::IsNetworkPlaying
  00079	84 c0		 test	 al, al
  0007b	74 6b		 je	 SHORT $LN10@ApplyWeapo@21
  0007d	8b 8e 44 03 00
	00		 mov	 ecx, DWORD PTR [esi+836]
  00083	e8 00 00 00 00	 call	 ?IsNetworkMode@ioPlayStage@@QAE_NXZ ; ioPlayStage::IsNetworkMode
  00088	84 c0		 test	 al, al
  0008a	74 5c		 je	 SHORT $LN10@ApplyWeapo@21

; 1386 : 			{
; 1387 : 				SP2Packet kPacket( CTPK_PRISONER_ESCAPE );

  0008c	6a 16		 push	 22			; 00000016H
  0008e	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694171[ebp]
  00094	e8 00 00 00 00	 call	 ??0SP2Packet@@QAE@K@Z	; SP2Packet::SP2Packet

; 1388 : 				kPacket << GetCharName() << GetLastAttackerName() << GetLastAttackerSkillName();

  00099	8d 86 bc 13 00
	00		 lea	 eax, DWORD PTR [esi+5052]
  0009f	50		 push	 eax
  000a0	8d 86 ac 13 00
	00		 lea	 eax, DWORD PTR [esi+5036]
  000a6	50		 push	 eax
  000a7	81 c6 d4 02 00
	00		 add	 esi, 724		; 000002d4H
  000ad	56		 push	 esi
  000ae	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694171[ebp]
  000b4	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  000b7	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z ; SP2Packet::operator<<
  000bc	8b c8		 mov	 ecx, eax
  000be	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z ; SP2Packet::operator<<
  000c3	8b c8		 mov	 ecx, eax
  000c5	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z ; SP2Packet::operator<<

; 1389 : 				TCPNetwork::SendToServer( kPacket );

  000ca	8d 85 d8 7f ff
	ff		 lea	 eax, DWORD PTR _kPacket$694171[ebp]
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 ?SendToServer@TCPNetwork@@YAXAAVSP2Packet@@@Z ; TCPNetwork::SendToServer

; 1390 : 			}

  000d6	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000da	59		 pop	 ecx
  000db	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694171[ebp]
  000e1	e8 00 00 00 00	 call	 ??1SP2Packet@@UAE@XZ	; SP2Packet::~SP2Packet

; 1391 : 			else

  000e6	eb 7d		 jmp	 SHORT $LN2@ApplyWeapo@21
$LN10@ApplyWeapo@21:

; 1392 : 			{
; 1393 : 				ioCatchMode *pMode = ToCatchMode( m_pModeParent );

  000e8	ff b6 8c 00 00
	00		 push	 DWORD PTR [esi+140]
  000ee	e8 00 00 00 00	 call	 ?ToCatchMode@@YAPAVioCatchMode@@PAVioPlayMode@@@Z ; ToCatchMode

; 1394 : 				ioUnderwearMode *pUnderwear = ToUnderWearMode(m_pModeParent);

  000f3	ff b6 8c 00 00
	00		 push	 DWORD PTR [esi+140]
  000f9	8b f8		 mov	 edi, eax
  000fb	e8 00 00 00 00	 call	 ?ToUnderWearMode@@YAPAVioUnderwearMode@@PAVioPlayMode@@@Z ; ToUnderWearMode

; 1395 : 				ioCBTMode *pCBT = ToCBTMode(m_pModeParent);

  00100	ff b6 8c 00 00
	00		 push	 DWORD PTR [esi+140]
  00106	89 85 d0 7f ff
	ff		 mov	 DWORD PTR _pUnderwear$694174[ebp], eax
  0010c	e8 00 00 00 00	 call	 ?ToCBTMode@@YAPAVioCBTMode@@PAVioPlayMode@@@Z ; ToCBTMode
  00111	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1396 : 
; 1397 : 				if( pMode || pUnderwear || pCBT)

  00114	3b fb		 cmp	 edi, ebx
  00116	75 20		 jne	 SHORT $LN7@ApplyWeapo@21
  00118	39 9d d0 7f ff
	ff		 cmp	 DWORD PTR _pUnderwear$694174[ebp], ebx
  0011e	75 18		 jne	 SHORT $LN7@ApplyWeapo@21
  00120	3b c3		 cmp	 eax, ebx
  00122	75 14		 jne	 SHORT $LN7@ApplyWeapo@21

; 1399 : 				else
; 1400 : 				{
; 1401 : 					ioCatchRunningManMode *pRunningManMode = ToCatchRunningManMode( m_pModeParent );

  00124	ff b6 8c 00 00
	00		 push	 DWORD PTR [esi+140]
  0012a	e8 00 00 00 00	 call	 ?ToCatchRunningManMode@@YAPAVioCatchRunningManMode@@PAVioPlayMode@@@Z ; ToCatchRunningManMode
  0012f	59		 pop	 ecx

; 1402 : 					if( pRunningManMode )

  00130	3b c3		 cmp	 eax, ebx
  00132	74 31		 je	 SHORT $LN2@ApplyWeapo@21

; 1403 : 						pRunningManMode->EscapePrisonerChar( this );					

  00134	8b c8		 mov	 ecx, eax
  00136	eb 02		 jmp	 SHORT $LN27@ApplyWeapo@21
$LN7@ApplyWeapo@21:

; 1398 : 					pMode->EscapePrisonerChar( this );

  00138	8b cf		 mov	 ecx, edi
$LN27@ApplyWeapo@21:
  0013a	56		 push	 esi
  0013b	e8 00 00 00 00	 call	 ?EscapePrisonerChar@ioCatchMode@@QAEXPAVioBaseChar@@@Z ; ioCatchMode::EscapePrisonerChar

; 1404 : 				}
; 1405 : 			}
; 1406 : 		}
; 1407 : 	}

  00140	eb 23		 jmp	 SHORT $LN2@ApplyWeapo@21
$LN13@ApplyWeapo@21:

; 1408 : 	else if( m_bCatchState && bTeamAttack && !bFrozenState )

  00142	38 9e 78 23 00
	00		 cmp	 BYTE PTR [esi+9080], bl
  00148	74 1b		 je	 SHORT $LN2@ApplyWeapo@21
  0014a	38 5d 08	 cmp	 BYTE PTR _bTeamAttack$[ebp], bl
  0014d	74 16		 je	 SHORT $LN2@ApplyWeapo@21
  0014f	38 5d 0c	 cmp	 BYTE PTR _bFrozenState$[ebp], bl
  00152	75 11		 jne	 SHORT $LN2@ApplyWeapo@21

; 1409 : 	{
; 1410 : 		if( bContactType || eEscapeCatchType != ECT_NONE )

  00154	38 5d 10	 cmp	 BYTE PTR _bContactType$[ebp], bl
  00157	75 05		 jne	 SHORT $LN1@ApplyWeapo@21
  00159	39 5d 14	 cmp	 DWORD PTR _eEscapeCatchType$[ebp], ebx
  0015c	74 07		 je	 SHORT $LN2@ApplyWeapo@21
$LN1@ApplyWeapo@21:

; 1411 : 			SetEscapeCatchState();

  0015e	8b ce		 mov	 ecx, esi
  00160	e8 00 00 00 00	 call	 ?SetEscapeCatchState@ioBaseChar@@QAEXXZ ; ioBaseChar::SetEscapeCatchState
$LN2@ApplyWeapo@21:

; 1412 : 	}
; 1413 : }

  00165	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00168	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0016f	59		 pop	 ecx
  00170	5f		 pop	 edi
  00171	5e		 pop	 esi
  00172	5b		 pop	 ebx
  00173	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00176	33 cd		 xor	 ecx, ebp
  00178	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017d	c9		 leave
  0017e	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ApplyWeaponWoundedChangePrisonerState@ioBaseChar@@IAEX_N00W4EscapeCatchType@@@Z$0:
  00000	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694171[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1SP2Packet@@UAE@XZ	; SP2Packet::~SP2Packet
__ehhandler$?ApplyWeaponWoundedChangePrisonerState@ioBaseChar@@IAEX_N00W4EscapeCatchType@@@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a cc 7f ff
	ff		 mov	 ecx, DWORD PTR [edx-32820]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ApplyWeaponWoundedChangePrisonerState@ioBaseChar@@IAEX_N00W4EscapeCatchType@@@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ApplyWeaponWoundedChangePrisonerState@ioBaseChar@@IAEX_N00W4EscapeCatchType@@@Z ENDP ; ioBaseChar::ApplyWeaponWoundedChangePrisonerState
PUBLIC	?ApplyWeaponWoundedNextStateFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@MAAV?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@@Z ; ioBaseChar::ApplyWeaponWoundedNextStateFunc
EXTRN	?GetCurActiveSkill@ioBaseChar@@QAEPAVioSkill@@XZ:PROC ; ioBaseChar::GetCurActiveSkill
EXTRN	?IsChangeNextSkillType@ioWeapon@@QAE_N_N@Z:PROC	; ioWeapon::IsChangeNextSkillType
EXTRN	?GetCurExtendDash@ioAttackableItem@@QAEPAVioExtendDash@@XZ:PROC ; ioAttackableItem::GetCurExtendDash
EXTRN	?AttackWound@ioAttackCountBuff@@QAEXPAVioBaseChar@@PAVioWeapon@@@Z:PROC ; ioAttackCountBuff::AttackWound
EXTRN	?ApplyActionState@ioTargetMoveAttackBuff@@QAEXPAVioBaseChar@@@Z:PROC ; ioTargetMoveAttackBuff::ApplyActionState
EXTRN	?UseMoveEndAttack@ioTargetRushAttackBuff@@QAEXPAVioBaseChar@@@Z:PROC ; ioTargetRushAttackBuff::UseMoveEndAttack
EXTRN	?GetCurExtendJump@ioAttackableItem@@QAEPAVioExtendJump@@XZ:PROC ; ioAttackableItem::GetCurExtendJump
EXTRN	?GetChangeNextItemType@ioWeapon@@QAE?AW4ChangeNextItemType@@XZ:PROC ; ioWeapon::GetChangeNextItemType
EXTRN	?IsChangeNextItemType@ioWeapon@@QAE_N_N@Z:PROC	; ioWeapon::IsChangeNextItemType
EXTRN	?GetEquipedSkill@ioBaseChar@@QAEPAVioSkill@@H@Z:PROC ; ioBaseChar::GetEquipedSkill
EXTRN	?SetEnableTeleport@ioFlash_Item@@QAEXPAVioBaseChar@@0@Z:PROC ; ioFlash_Item::SetEnableTeleport
EXTRN	?IsCheckTarget@ioZoneEffectWeapon@@QAE_NXZ:PROC	; ioZoneEffectWeapon::IsCheckTarget
; Function compile flags: /Ogsp
;	COMDAT ?ApplyWeaponWoundedNextStateFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@MAAV?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@@Z
_TEXT	SEGMENT
_value$700911 = -8					; size = 4
_this$ = -4						; size = 4
_pWeapon$ = 8						; size = 4
_value$700898 = 12					; size = 4
_pAttacker$ = 12					; size = 4
_fDamage$ = 16						; size = 4
_kAddBuffList$ = 20					; size = 4
?ApplyWeaponWoundedNextStateFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@MAAV?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@@Z PROC ; ioBaseChar::ApplyWeaponWoundedNextStateFunc, COMDAT
; _this$ = ecx

; 2102 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx
  00006	56		 push	 esi

; 2103 : 	if ( !pWeapon || !pAttacker )

  00007	8b 75 08	 mov	 esi, DWORD PTR _pWeapon$[ebp]
  0000a	33 db		 xor	 ebx, ebx
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000f	3b f3		 cmp	 esi, ebx
  00011	0f 84 ac 02 00
	00		 je	 $LN33@ApplyWeapo@22
  00017	57		 push	 edi
  00018	8b 7d 0c	 mov	 edi, DWORD PTR _pAttacker$[ebp]
  0001b	3b fb		 cmp	 edi, ebx
  0001d	0f 84 9f 02 00
	00		 je	 $LN53@ApplyWeapo@22

; 2104 : 		return;
; 2105 : 
; 2106 : 	//    (     )
; 2107 : 	ioZoneEffectWeapon *pZoneEffectWeapon = ToZoneEffectWeapon( pWeapon );

  00023	56		 push	 esi
  00024	e8 00 00 00 00	 call	 ?ToZoneEffectWeapon@@YAPAVioZoneEffectWeapon@@PAVioWeapon@@@Z ; ToZoneEffectWeapon
  00029	59		 pop	 ecx

; 2108 : 	if ( pZoneEffectWeapon && pZoneEffectWeapon->IsCheckTarget() )

  0002a	3b c3		 cmp	 eax, ebx
  0002c	74 2c		 je	 SHORT $LN30@ApplyWeapo@22
  0002e	8b c8		 mov	 ecx, eax
  00030	e8 00 00 00 00	 call	 ?IsCheckTarget@ioZoneEffectWeapon@@QAE_NXZ ; ioZoneEffectWeapon::IsCheckTarget
  00035	84 c0		 test	 al, al
  00037	74 21		 je	 SHORT $LN30@ApplyWeapo@22

; 2109 : 	{
; 2110 : 		ioWeaponItem* pWeaponItem = pAttacker->GetWeapon();

  00039	8b cf		 mov	 ecx, edi
  0003b	e8 00 00 00 00	 call	 ?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ ; ioBaseChar::GetWeapon

; 2111 : 		if( pWeaponItem )

  00040	3b c3		 cmp	 eax, ebx
  00042	74 16		 je	 SHORT $LN30@ApplyWeapo@22

; 2112 : 		{
; 2113 : 			ioFlash_Item *pFlashItem = ToFlashItem( pWeaponItem );

  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ?ToFlashItem@@YAPAVioFlash_Item@@PAVioItem@@@Z ; ToFlashItem
  0004a	59		 pop	 ecx

; 2114 : 			if ( pFlashItem )

  0004b	3b c3		 cmp	 eax, ebx
  0004d	74 0b		 je	 SHORT $LN30@ApplyWeapo@22

; 2115 : 				pFlashItem->SetEnableTeleport( this, pAttacker );

  0004f	57		 push	 edi
  00050	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00053	8b c8		 mov	 ecx, eax
  00055	e8 00 00 00 00	 call	 ?SetEnableTeleport@ioFlash_Item@@QAEXPAVioBaseChar@@0@Z ; ioFlash_Item::SetEnableTeleport
$LN30@ApplyWeapo@22:

; 2116 : 		}
; 2117 : 	}
; 2118 : 
; 2119 : 	//  
; 2120 : 	if ( fDamage > 0.0f && pAttacker->GetTeam() != GetTeam() && HasBuff( BT_STATE_PROTECTION ) )

  0005a	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  0005f	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00066	76 5d		 jbe	 SHORT $LN26@ApplyWeapo@22
  00068	8d 45 0c	 lea	 eax, DWORD PTR _value$700898[ebp]
  0006b	50		 push	 eax
  0006c	8d 8f 90 00 00
	00		 lea	 ecx, DWORD PTR [edi+144]
  00072	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  00077	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8d 45 f8	 lea	 eax, DWORD PTR _value$700911[ebp]
  0007d	50		 push	 eax
  0007e	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  00084	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  00089	8b 45 0c	 mov	 eax, DWORD PTR _value$700898[ebp]
  0008c	3b 45 f8	 cmp	 eax, DWORD PTR _value$700911[ebp]
  0008f	74 34		 je	 SHORT $LN26@ApplyWeapo@22
  00091	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	6a 23		 push	 35			; 00000023H
  00096	e8 00 00 00 00	 call	 ?HasBuff@ioBaseChar@@QBE_NH@Z ; ioBaseChar::HasBuff
  0009b	84 c0		 test	 al, al
  0009d	74 26		 je	 SHORT $LN26@ApplyWeapo@22

; 2121 : 	{
; 2122 : 		for( int i = 0; i < 4; i++ )

  0009f	33 f6		 xor	 esi, esi
$LL28@ApplyWeapo@22:

; 2123 : 		{
; 2124 : 			ioSkill *pSkill = GetEquipedSkill( i );

  000a1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a4	56		 push	 esi
  000a5	e8 00 00 00 00	 call	 ?GetEquipedSkill@ioBaseChar@@QAEPAVioSkill@@H@Z ; ioBaseChar::GetEquipedSkill

; 2125 : 			ioTargetMissile2Skill *pTargetMissile2Skill = ToTargetMissile2Skill( pSkill );

  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 ?ToTargetMissile2Skill@@YAPAVioTargetMissile2Skill@@PAVioSkill@@@Z ; ToTargetMissile2Skill
  000b0	59		 pop	 ecx

; 2126 : 			if( pTargetMissile2Skill )

  000b1	3b c3		 cmp	 eax, ebx
  000b3	74 07		 je	 SHORT $LN27@ApplyWeapo@22

; 2127 : 				pTargetMissile2Skill->SetDamage( true );			

  000b5	c6 80 48 15 00
	00 01		 mov	 BYTE PTR [eax+5448], 1
$LN27@ApplyWeapo@22:

; 2121 : 	{
; 2122 : 		for( int i = 0; i < 4; i++ )

  000bc	46		 inc	 esi
  000bd	83 fe 04	 cmp	 esi, 4
  000c0	7c df		 jl	 SHORT $LL28@ApplyWeapo@22
  000c2	8b 75 08	 mov	 esi, DWORD PTR _pWeapon$[ebp]
$LN26@ApplyWeapo@22:

; 2128 : 		}
; 2129 : 	}
; 2130 : 
; 2131 : 	//yunga
; 2132 : 	if( pWeapon->IsChangeNextItemType( false ) )

  000c5	53		 push	 ebx
  000c6	8b ce		 mov	 ecx, esi
  000c8	e8 00 00 00 00	 call	 ?IsChangeNextItemType@ioWeapon@@QAE_N_N@Z ; ioWeapon::IsChangeNextItemType
  000cd	84 c0		 test	 al, al
  000cf	0f 84 c8 01 00
	00		 je	 $LN20@ApplyWeapo@22

; 2133 : 	{
; 2134 : 		if( pWeapon->GetChangeNextItemType() == CNIT_TYPE1 || pWeapon->GetChangeNextItemType() == CNIT_TIGER1 || pWeapon->GetChangeNextItemType() == CNIT_TIGER2 )

  000d5	8b ce		 mov	 ecx, esi
  000d7	e8 00 00 00 00	 call	 ?GetChangeNextItemType@ioWeapon@@QAE?AW4ChangeNextItemType@@XZ ; ioWeapon::GetChangeNextItemType
  000dc	83 f8 01	 cmp	 eax, 1
  000df	0f 84 67 01 00
	00		 je	 $LN52@ApplyWeapo@22
  000e5	8b ce		 mov	 ecx, esi
  000e7	e8 00 00 00 00	 call	 ?GetChangeNextItemType@ioWeapon@@QAE?AW4ChangeNextItemType@@XZ ; ioWeapon::GetChangeNextItemType
  000ec	83 f8 05	 cmp	 eax, 5
  000ef	0f 84 57 01 00
	00		 je	 $LN52@ApplyWeapo@22
  000f5	8b ce		 mov	 ecx, esi
  000f7	e8 00 00 00 00	 call	 ?GetChangeNextItemType@ioWeapon@@QAE?AW4ChangeNextItemType@@XZ ; ioWeapon::GetChangeNextItemType
  000fc	83 f8 06	 cmp	 eax, 6
  000ff	0f 84 47 01 00
	00		 je	 $LN52@ApplyWeapo@22

; 2159 : 			}
; 2160 : 		}
; 2161 : 		else if( pWeapon->GetChangeNextItemType() == CNIT_TYPE2 )

  00105	8b ce		 mov	 ecx, esi
  00107	e8 00 00 00 00	 call	 ?GetChangeNextItemType@ioWeapon@@QAE?AW4ChangeNextItemType@@XZ ; ioWeapon::GetChangeNextItemType
  0010c	83 f8 02	 cmp	 eax, 2
  0010f	75 3e		 jne	 SHORT $LN18@ApplyWeapo@22

; 2162 : 		{
; 2163 : 			ioAttackableItem *pItem = pAttacker->GetPriorityItem( SPT_JUMP );

  00111	50		 push	 eax
  00112	8b cf		 mov	 ecx, edi
  00114	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem

; 2164 : 			if( pItem )

  00119	3b c3		 cmp	 eax, ebx
  0011b	0f 84 7c 01 00
	00		 je	 $LN20@ApplyWeapo@22

; 2165 : 			{
; 2166 : 				ioExtendJump *pExtendJump = pItem->GetCurExtendJump();

  00121	8b c8		 mov	 ecx, eax
  00123	e8 00 00 00 00	 call	 ?GetCurExtendJump@ioAttackableItem@@QAEPAVioExtendJump@@XZ ; ioAttackableItem::GetCurExtendJump

; 2167 : 				if( pExtendJump )

  00128	3b c3		 cmp	 eax, ebx
  0012a	0f 84 6d 01 00
	00		 je	 $LN20@ApplyWeapo@22

; 2168 : 					pExtendJump->SetNextJumpItemState( pAttacker, this, false, CNIT_TYPE2, pWeapon, fDamage );

  00130	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  00135	8b 10		 mov	 edx, DWORD PTR [eax]
  00137	51		 push	 ecx
  00138	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0013d	56		 push	 esi
  0013e	6a 02		 push	 2
  00140	53		 push	 ebx
  00141	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00144	8b c8		 mov	 ecx, eax
  00146	57		 push	 edi
  00147	ff 52 68	 call	 DWORD PTR [edx+104]

; 2169 : 			}
; 2170 : 		}

  0014a	e9 4e 01 00 00	 jmp	 $LN20@ApplyWeapo@22
$LN18@ApplyWeapo@22:

; 2171 : 		else if( pWeapon->GetChangeNextItemType() == CNIT_TYPE3 )

  0014f	8b ce		 mov	 ecx, esi
  00151	e8 00 00 00 00	 call	 ?GetChangeNextItemType@ioWeapon@@QAE?AW4ChangeNextItemType@@XZ ; ioWeapon::GetChangeNextItemType
  00156	83 f8 03	 cmp	 eax, 3
  00159	75 5d		 jne	 SHORT $LN14@ApplyWeapo@22

; 2172 : 		{
; 2173 : 			ioBuff *pBuff = pAttacker->GetBuff( BT_TARGET_RUSH_ATTACK );

  0015b	68 b0 00 00 00	 push	 176			; 000000b0H
  00160	8b cf		 mov	 ecx, edi
  00162	e8 00 00 00 00	 call	 ?GetBuff@ioBaseChar@@QAEPAVioBuff@@H@Z ; ioBaseChar::GetBuff

; 2174 : 			if ( pBuff )

  00167	3b c3		 cmp	 eax, ebx
  00169	74 23		 je	 SHORT $LN12@ApplyWeapo@22

; 2175 : 			{
; 2176 : 				ioTargetRushAttackBuff* pTargetRushAttackBuff = ToTargetRushAttackBuff( pBuff );

  0016b	50		 push	 eax
  0016c	e8 00 00 00 00	 call	 ?ToTargetRushAttackBuff@@YAPAVioTargetRushAttackBuff@@PAVioBuff@@@Z ; ToTargetRushAttackBuff
  00171	59		 pop	 ecx

; 2177 : 				if ( pTargetRushAttackBuff && fDamage > 0.0f )

  00172	3b c3		 cmp	 eax, ebx
  00174	74 18		 je	 SHORT $LN12@ApplyWeapo@22
  00176	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  0017b	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00182	76 0a		 jbe	 SHORT $LN12@ApplyWeapo@22

; 2178 : 					pTargetRushAttackBuff->UseMoveEndAttack( this );

  00184	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00187	8b c8		 mov	 ecx, eax
  00189	e8 00 00 00 00	 call	 ?UseMoveEndAttack@ioTargetRushAttackBuff@@QAEXPAVioBaseChar@@@Z ; ioTargetRushAttackBuff::UseMoveEndAttack
$LN12@ApplyWeapo@22:

; 2179 : 			}
; 2180 : 
; 2181 : 			ioTargetMoveAttackBuff* pTargetMoveAttackBuff = ToTargetMoveAttackBuff( pAttacker->GetBuff( BT_TARGET_MOVE_ATTACK ) );

  0018e	68 bf 00 00 00	 push	 191			; 000000bfH
  00193	8b cf		 mov	 ecx, edi
  00195	e8 00 00 00 00	 call	 ?GetBuff@ioBaseChar@@QAEPAVioBuff@@H@Z ; ioBaseChar::GetBuff
  0019a	50		 push	 eax
  0019b	e8 00 00 00 00	 call	 ?ToTargetMoveAttackBuff@@YAPAVioTargetMoveAttackBuff@@PAVioBuff@@@Z ; ToTargetMoveAttackBuff
  001a0	59		 pop	 ecx

; 2182 : 			if ( pTargetMoveAttackBuff )

  001a1	3b c3		 cmp	 eax, ebx
  001a3	0f 84 f4 00 00
	00		 je	 $LN20@ApplyWeapo@22

; 2183 : 				pTargetMoveAttackBuff->ApplyActionState( this );

  001a9	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  001ac	8b c8		 mov	 ecx, eax
  001ae	e8 00 00 00 00	 call	 ?ApplyActionState@ioTargetMoveAttackBuff@@QAEXPAVioBaseChar@@@Z ; ioTargetMoveAttackBuff::ApplyActionState

; 2184 : 		}

  001b3	e9 e5 00 00 00	 jmp	 $LN20@ApplyWeapo@22
$LN14@ApplyWeapo@22:

; 2185 : 		else if( pWeapon->GetChangeNextItemType() == CNIT_TYPE4 )

  001b8	8b ce		 mov	 ecx, esi
  001ba	e8 00 00 00 00	 call	 ?GetChangeNextItemType@ioWeapon@@QAE?AW4ChangeNextItemType@@XZ ; ioWeapon::GetChangeNextItemType
  001bf	83 f8 04	 cmp	 eax, 4
  001c2	75 46		 jne	 SHORT $LN9@ApplyWeapo@22

; 2186 : 		{
; 2187 : 			ioBuff *pBuff = this->GetBuff( BT_ATTACK_COUNT_BUFF );

  001c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001c7	68 c3 00 00 00	 push	 195			; 000000c3H
  001cc	e8 00 00 00 00	 call	 ?GetBuff@ioBaseChar@@QAEPAVioBuff@@H@Z ; ioBaseChar::GetBuff

; 2188 : 			if( pBuff )

  001d1	3b c3		 cmp	 eax, ebx
  001d3	0f 84 c4 00 00
	00		 je	 $LN20@ApplyWeapo@22

; 2189 : 			{
; 2190 : 				ioAttackCountBuff* pAttackCountBuff = ToAttackCountBuff( pBuff );

  001d9	50		 push	 eax
  001da	e8 00 00 00 00	 call	 ?ToAttackCountBuff@@YAPAVioAttackCountBuff@@PAVioBuff@@@Z ; ToAttackCountBuff
  001df	59		 pop	 ecx

; 2191 : 				if( pAttackCountBuff && fDamage > 0.0f )

  001e0	3b c3		 cmp	 eax, ebx
  001e2	0f 84 b5 00 00
	00		 je	 $LN20@ApplyWeapo@22
  001e8	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  001ed	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  001f4	0f 86 a3 00 00
	00		 jbe	 $LN20@ApplyWeapo@22

; 2192 : 				{
; 2193 : 					pAttackCountBuff->AttackWound( this, pWeapon );

  001fa	56		 push	 esi
  001fb	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  001fe	8b c8		 mov	 ecx, eax
  00200	e8 00 00 00 00	 call	 ?AttackWound@ioAttackCountBuff@@QAEXPAVioBaseChar@@PAVioWeapon@@@Z ; ioAttackCountBuff::AttackWound

; 2194 : 				}
; 2195 : 			}
; 2196 : 		}

  00205	e9 93 00 00 00	 jmp	 $LN20@ApplyWeapo@22
$LN9@ApplyWeapo@22:

; 2197 : 		else if( pWeapon->GetChangeNextItemType() == CNIT_TYPE5 )

  0020a	8b ce		 mov	 ecx, esi
  0020c	e8 00 00 00 00	 call	 ?GetChangeNextItemType@ioWeapon@@QAE?AW4ChangeNextItemType@@XZ ; ioWeapon::GetChangeNextItemType
  00211	83 f8 07	 cmp	 eax, 7
  00214	0f 85 83 00 00
	00		 jne	 $LN20@ApplyWeapo@22

; 2198 : 		{
; 2199 : 			ioAttackableItem *pItem = pAttacker->GetPriorityItem( SPT_DASH );

  0021a	6a 01		 push	 1
  0021c	8b cf		 mov	 ecx, edi
  0021e	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem

; 2200 : 			if( pItem )

  00223	3b c3		 cmp	 eax, ebx
  00225	74 76		 je	 SHORT $LN20@ApplyWeapo@22

; 2201 : 			{
; 2202 : 				ioExtendDash *pExtendDash = pItem->GetCurExtendDash();

  00227	8b c8		 mov	 ecx, eax
  00229	e8 00 00 00 00	 call	 ?GetCurExtendDash@ioAttackableItem@@QAEPAVioExtendDash@@XZ ; ioAttackableItem::GetCurExtendDash

; 2203 : 				if( pExtendDash )

  0022e	3b c3		 cmp	 eax, ebx
  00230	74 6b		 je	 SHORT $LN20@ApplyWeapo@22

; 2204 : 					pExtendDash->SetNextDashState( this, pAttacker, pWeapon, false, fDamage );

  00232	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  00237	8b 10		 mov	 edx, DWORD PTR [eax]
  00239	51		 push	 ecx
  0023a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0023f	53		 push	 ebx
  00240	56		 push	 esi
  00241	57		 push	 edi
  00242	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00245	8b c8		 mov	 ecx, eax
  00247	ff 52 34	 call	 DWORD PTR [edx+52]
  0024a	eb 51		 jmp	 SHORT $LN20@ApplyWeapo@22
$LN52@ApplyWeapo@22:

; 2135 : 		{
; 2136 : 			ioAttackableItem* pItem = pAttacker->GetPriorityItem( SPT_ATTACK );

  0024c	6a 05		 push	 5
  0024e	8b cf		 mov	 ecx, edi
  00250	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  00255	8b f0		 mov	 esi, eax

; 2137 : 			if( pItem )

  00257	3b f3		 cmp	 esi, ebx
  00259	74 3f		 je	 SHORT $LN51@ApplyWeapo@22

; 2138 : 			{
; 2139 : 				pItem->SetNextItemState( this, pAttacker, pWeapon, false, fDamage );

  0025b	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  00260	8b 06		 mov	 eax, DWORD PTR [esi]
  00262	51		 push	 ecx
  00263	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00268	53		 push	 ebx
  00269	ff 75 08	 push	 DWORD PTR _pWeapon$[ebp]
  0026c	8b ce		 mov	 ecx, esi
  0026e	57		 push	 edi
  0026f	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00272	ff 90 84 01 00
	00		 call	 DWORD PTR [eax+388]

; 2140 : 
; 2141 : 				//ioFlash_Item *pFlashItem = ToFlashItem( pWeaponItem );
; 2142 : 				//if ( pFlashItem)
; 2143 : 				//	pFlashItem->SetTeleportTarget( this, pAttacker );
; 2144 : 
; 2145 : 				//ioPsychoMetry_Item *pPsychoItem = ToPsychoMetryItem( pWeaponItem );
; 2146 : 				//if ( pPsychoItem && fDamage > 0.0f )
; 2147 : 				//	pPsychoItem->SetTarget( this, pAttacker );
; 2148 : 
; 2149 : 				//ioDragonNestAssassinItem *pDragonNestAssassinItem = ToDragonNestAssassinItem( pWeaponItem );
; 2150 : 				//if ( pDragonNestAssassinItem && fDamage > 0.0f )
; 2151 : 				//	pDragonNestAssassinItem->SetDashTeleportState( this, pAttacker );
; 2152 : 
; 2153 : 				//ioSaberItem *pSaber = ToSaberItem( pWeaponItem );
; 2154 : 				//if ( pSaber && fDamage > 0.0f )
; 2155 : 				//	pSaber->SetChargeTarget( this, pAttacker );
; 2156 : 
; 2157 : 				if( kAddBuffList.size() > 0 )

  00278	8b 4d 14	 mov	 ecx, DWORD PTR _kAddBuffList$[ebp]
  0027b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0027e	2b 01		 sub	 eax, DWORD PTR [ecx]
  00280	6a 14		 push	 20			; 00000014H
  00282	99		 cdq
  00283	59		 pop	 ecx
  00284	f7 f9		 idiv	 ecx
  00286	85 c0		 test	 eax, eax
  00288	74 10		 je	 SHORT $LN51@ApplyWeapo@22

; 2158 : 					pItem->WeaponWounded( pWeapon, this );

  0028a	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0028d	8b 06		 mov	 eax, DWORD PTR [esi]
  0028f	ff 75 08	 push	 DWORD PTR _pWeapon$[ebp]
  00292	8b ce		 mov	 ecx, esi
  00294	ff 90 88 01 00
	00		 call	 DWORD PTR [eax+392]
$LN51@ApplyWeapo@22:
  0029a	8b 75 08	 mov	 esi, DWORD PTR _pWeapon$[ebp]
$LN20@ApplyWeapo@22:

; 2205 : 			}
; 2206 : 		}
; 2207 : 	}
; 2208 : 
; 2209 : 	if( pWeapon->IsChangeNextSkillType( false ) )

  0029d	53		 push	 ebx
  0029e	8b ce		 mov	 ecx, esi
  002a0	e8 00 00 00 00	 call	 ?IsChangeNextSkillType@ioWeapon@@QAE_N_N@Z ; ioWeapon::IsChangeNextSkillType
  002a5	84 c0		 test	 al, al
  002a7	74 19		 je	 SHORT $LN53@ApplyWeapo@22

; 2210 : 	{
; 2211 : 		ioSkill *pCurSkill = pAttacker->GetCurActiveSkill();

  002a9	8b cf		 mov	 ecx, edi
  002ab	e8 00 00 00 00	 call	 ?GetCurActiveSkill@ioBaseChar@@QAEPAVioSkill@@XZ ; ioBaseChar::GetCurActiveSkill

; 2212 : 		if( pCurSkill )

  002b0	3b c3		 cmp	 eax, ebx
  002b2	74 0e		 je	 SHORT $LN53@ApplyWeapo@22

; 2213 : 		{
; 2214 : 			pCurSkill->SetNextSkillState( this, pWeapon );

  002b4	8b 10		 mov	 edx, DWORD PTR [eax]
  002b6	56		 push	 esi
  002b7	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  002ba	8b c8		 mov	 ecx, eax
  002bc	ff 92 ac 00 00
	00		 call	 DWORD PTR [edx+172]
$LN53@ApplyWeapo@22:
  002c2	5f		 pop	 edi
$LN33@ApplyWeapo@22:
  002c3	5e		 pop	 esi
  002c4	5b		 pop	 ebx

; 2215 : 		}
; 2216 : 	}
; 2217 : }

  002c5	c9		 leave
  002c6	c2 10 00	 ret	 16			; 00000010H
?ApplyWeaponWoundedNextStateFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@MAAV?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@@Z ENDP ; ioBaseChar::ApplyWeaponWoundedNextStateFunc
_TEXT	ENDS
PUBLIC	?ApplyWeaponWoundedSingleFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@M_N2W4AttackBlockType@@W4ProtectionMode@@@Z ; ioBaseChar::ApplyWeaponWoundedSingleFunc
EXTRN	?SetAttackGrapplingState@ioBaseChar@@QAEXABVioHashString@@@Z:PROC ; ioBaseChar::SetAttackGrapplingState
EXTRN	?SetAttackBuffGrapplingState@ioBaseChar@@QAEXABVioHashString@@H@Z:PROC ; ioBaseChar::SetAttackBuffGrapplingState
EXTRN	?SetWarpTargetList@ioBaseChar@@QAEXABVioHashString@@0@Z:PROC ; ioBaseChar::SetWarpTargetList
EXTRN	?GetCurChargeComboState@ioChargeComboJump3@@QAEHXZ:PROC ; ioChargeComboJump3::GetCurChargeComboState
EXTRN	?SetAttackItemGrapplingState@ioBaseChar@@QAEXABVioHashString@@@Z:PROC ; ioBaseChar::SetAttackItemGrapplingState
EXTRN	?SetAttackSkillGrapplingState@ioBaseChar@@QAEXABVioHashString@@@Z:PROC ; ioBaseChar::SetAttackSkillGrapplingState
EXTRN	?SetPsycGrappling@ioBaseChar@@QAEXABVioHashString@@@Z:PROC ; ioBaseChar::SetPsycGrappling
EXTRN	?SetJumpGrapplingState@ioBaseChar@@QAEXABVioHashString@@@Z:PROC ; ioBaseChar::SetJumpGrapplingState
EXTRN	?SetChangeJumppingState@ioBaseChar@@QAEXM_NH@Z:PROC ; ioBaseChar::SetChangeJumppingState
; Function compile flags: /Ogsp
;	COMDAT ?ApplyWeaponWoundedSingleFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@M_N2W4AttackBlockType@@W4ProtectionMode@@@Z
_TEXT	SEGMENT
_pWeapon$ = 8						; size = 4
_value$700937 = 12					; size = 4
_pAttacker$ = 12					; size = 4
_bAttackerNPC$ = 15					; size = 1
_fDamage$ = 16						; size = 4
_bAirTargetBuff$ = 20					; size = 1
_value$700949 = 20					; size = 4
_fExtraGauge$694698 = 24				; size = 4
_bApplyPushPower$ = 24					; size = 1
_eBlockType$ = 28					; size = 4
_eProtectionType$ = 32					; size = 4
?ApplyWeaponWoundedSingleFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@M_N2W4AttackBlockType@@W4ProtectionMode@@@Z PROC ; ioBaseChar::ApplyWeaponWoundedSingleFunc, COMDAT
; _this$ = ecx

; 2220 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2221 : 	if ( !pWeapon || !pAttacker )

  00003	83 7d 08 00	 cmp	 DWORD PTR _pWeapon$[ebp], 0
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	0f 84 42 02 00
	00		 je	 $LN53@ApplyWeapo@23
  00010	57		 push	 edi
  00011	8b 7d 0c	 mov	 edi, DWORD PTR _pAttacker$[ebp]
  00014	85 ff		 test	 edi, edi
  00016	0f 84 35 02 00
	00		 je	 $LN149@ApplyWeapo@23

; 2222 : 		return;
; 2223 : 
; 2224 : 	// local or  or NPC
; 2225 : 	bool bNPC = false;

  0001c	53		 push	 ebx
  0001d	32 db		 xor	 bl, bl

; 2226 : 	bool bAttackerNPC = false;
; 2227 : 	if( ToNpcChar( this ) )

  0001f	56		 push	 esi
  00020	88 5d 0f	 mov	 BYTE PTR _bAttackerNPC$[ebp], bl
  00023	e8 00 00 00 00	 call	 ?ToNpcChar@@YAPAVioNpcChar@@PAVioGameEntity@@@Z ; ToNpcChar
  00028	59		 pop	 ecx
  00029	85 c0		 test	 eax, eax
  0002b	74 02		 je	 SHORT $LN52@ApplyWeapo@23

; 2228 : 		bNPC = true;

  0002d	fe c3		 inc	 bl
$LN52@ApplyWeapo@23:

; 2229 : 
; 2230 : 	if( ToNpcChar( pAttacker ) )

  0002f	57		 push	 edi
  00030	e8 00 00 00 00	 call	 ?ToNpcChar@@YAPAVioNpcChar@@PAVioGameEntity@@@Z ; ToNpcChar
  00035	59		 pop	 ecx
  00036	85 c0		 test	 eax, eax
  00038	74 04		 je	 SHORT $LN51@ApplyWeapo@23

; 2231 : 		bAttackerNPC = true;

  0003a	c6 45 0f 01	 mov	 BYTE PTR _bAttackerNPC$[ebp], 1
$LN51@ApplyWeapo@23:

; 2232 : 
; 2233 : 	if( !P2PNetwork::IsNetworkPlaying() || !m_pCreator->IsNetworkMode() || (bNPC || bAttackerNPC) )

  0003e	e8 00 00 00 00	 call	 ?IsNetworkPlaying@P2PNetwork@@YA_NXZ ; P2PNetwork::IsNetworkPlaying
  00043	84 c0		 test	 al, al
  00045	74 1c		 je	 SHORT $LN48@ApplyWeapo@23
  00047	8b 8e 44 03 00
	00		 mov	 ecx, DWORD PTR [esi+836]
  0004d	e8 00 00 00 00	 call	 ?IsNetworkMode@ioPlayStage@@QAE_NXZ ; ioPlayStage::IsNetworkMode
  00052	84 c0		 test	 al, al
  00054	74 0d		 je	 SHORT $LN48@ApplyWeapo@23
  00056	84 db		 test	 bl, bl
  00058	75 09		 jne	 SHORT $LN48@ApplyWeapo@23
  0005a	38 5d 0f	 cmp	 BYTE PTR _bAttackerNPC$[ebp], bl
  0005d	0f 84 ed 01 00
	00		 je	 $LN150@ApplyWeapo@23
$LN48@ApplyWeapo@23:

; 2234 : 	{		
; 2235 : 		if( pWeapon->IsChangeJumpping( false, bAirTargetBuff ) )

  00063	ff 75 14	 push	 DWORD PTR _bAirTargetBuff$[ebp]
  00066	8b 5d 08	 mov	 ebx, DWORD PTR _pWeapon$[ebp]
  00069	6a 00		 push	 0
  0006b	8b cb		 mov	 ecx, ebx
  0006d	e8 00 00 00 00	 call	 ?IsChangeJumpping@ioWeapon@@QAE_N_N0@Z ; ioWeapon::IsChangeJumpping
  00072	84 c0		 test	 al, al
  00074	74 35		 je	 SHORT $LN147@ApplyWeapo@23

; 2236 : 		{
; 2237 : 			int iLimitCnt = pWeapon->GetChangeJumppingLimitCnt();

  00076	8d 45 0c	 lea	 eax, DWORD PTR _value$700937[ebp]
  00079	50		 push	 eax
  0007a	8d 8b dc 05 00
	00		 lea	 ecx, DWORD PTR [ebx+1500]
  00080	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ; CEncrypt<int>::DecryptValueToPool

; 2238 : 			pAttacker->SetChangeJumppingState( pWeapon->GetChangeJumppingPowerRate(), true, iLimitCnt );

  00085	8d 45 14	 lea	 eax, DWORD PTR _value$700949[ebp]
  00088	50		 push	 eax
  00089	8d 8b ac 05 00
	00		 lea	 ecx, DWORD PTR [ebx+1452]
  0008f	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  00094	ff 75 0c	 push	 DWORD PTR _value$700937[ebp]
  00097	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _value$700949[ebp]
  0009c	6a 01		 push	 1
  0009e	51		 push	 ecx
  0009f	8b cf		 mov	 ecx, edi
  000a1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a6	e8 00 00 00 00	 call	 ?SetChangeJumppingState@ioBaseChar@@QAEXM_NH@Z ; ioBaseChar::SetChangeJumppingState
$LN147@ApplyWeapo@23:

; 2239 : 		}
; 2240 : 
; 2241 : 		/*if( pWeapon->IsChangeNextItemType( false ) )
; 2242 : 		{
; 2243 : 			ioWeaponItem* pWeaponItem = pAttacker->GetWeapon();
; 2244 : 			if( pWeaponItem )
; 2245 : 				pWeaponItem->SetNextItemState( pAttacker );
; 2246 : 		}*/
; 2247 : 
; 2248 : 		switch( m_GrapplingType )

  000ab	8b 86 6c 34 00
	00		 mov	 eax, DWORD PTR [esi+13420]
  000b1	48		 dec	 eax
  000b2	83 f8 18	 cmp	 eax, 24			; 00000018H
  000b5	0f 87 1d 01 00
	00		 ja	 $LN3@ApplyWeapo@23
  000bb	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN156@ApplyWeapo@23[eax*4]
$LN41@ApplyWeapo@23:

; 2249 : 		{
; 2250 : 		case GPT_WRESTLING:
; 2251 : 			if( pAttacker->GetState() == CS_ATTACK )
; 2252 : 				pAttacker->SetAttackGrapplingState( GetCharName() );
; 2253 : 			else if( pAttacker->GetState() == CS_USING_SKILL )
; 2254 : 				pAttacker->SetAttackSkillGrapplingState( GetCharName() );
; 2255 : 			else if( pAttacker->GetState() == CS_JUMP )

  000c2	3c 04		 cmp	 al, 4
$LN151@ApplyWeapo@23:
  000c4	0f 85 0e 01 00
	00		 jne	 $LN3@ApplyWeapo@23

; 2256 : 				pAttacker->SetJumpGrapplingState( GetCharName() );

  000ca	8d 86 d4 02 00
	00		 lea	 eax, DWORD PTR [esi+724]
  000d0	50		 push	 eax
  000d1	8b cf		 mov	 ecx, edi
  000d3	e8 00 00 00 00	 call	 ?SetJumpGrapplingState@ioBaseChar@@QAEXABVioHashString@@@Z ; ioBaseChar::SetJumpGrapplingState

; 2257 : 			break;

  000d8	e9 fb 00 00 00	 jmp	 $LN3@ApplyWeapo@23
$LN38@ApplyWeapo@23:

; 2258 : 		case GPT_WRESTLING_ALL:
; 2259 : 			if( pAttacker->GetState() == CS_ATTACK )

  000dd	8a 87 10 03 00
	00		 mov	 al, BYTE PTR [edi+784]
  000e3	3c 05		 cmp	 al, 5

; 2260 : 				pAttacker->SetAttackGrapplingState( GetCharName() );

  000e5	0f 84 9d 01 00
	00		 je	 $LN154@ApplyWeapo@23

; 2261 : 			else if( pAttacker->GetState() == CS_USING_SKILL )

  000eb	3c 07		 cmp	 al, 7
  000ed	75 d3		 jne	 SHORT $LN41@ApplyWeapo@23

; 2262 : 				pAttacker->SetAttackSkillGrapplingState( GetCharName() );

  000ef	eb 2d		 jmp	 SHORT $LN152@ApplyWeapo@23
$LN32@ApplyWeapo@23:

; 2263 : 			else if( pAttacker->GetState() == CS_JUMP )
; 2264 : 				pAttacker->SetJumpGrapplingState( GetCharName() );
; 2265 : 			break;
; 2266 : 		case GPT_PSYCHIC:
; 2267 : 			if( pAttacker->GetState() == CS_USING_SKILL )

  000f1	80 bf 10 03 00
	00 07		 cmp	 BYTE PTR [edi+784], 7
  000f8	0f 85 da 00 00
	00		 jne	 $LN3@ApplyWeapo@23

; 2268 : 				pAttacker->SetPsycGrappling( GetCharName() );

  000fe	8d 86 d4 02 00
	00		 lea	 eax, DWORD PTR [esi+724]
  00104	50		 push	 eax
  00105	8b cf		 mov	 ecx, edi
  00107	e8 00 00 00 00	 call	 ?SetPsycGrappling@ioBaseChar@@QAEXABVioHashString@@@Z ; ioBaseChar::SetPsycGrappling

; 2269 : 			break;

  0010c	e9 c7 00 00 00	 jmp	 $LN3@ApplyWeapo@23
$LN30@ApplyWeapo@23:

; 2270 : 		case GPT_TOSS:
; 2271 : 		case GPT_ATTACK:
; 2272 : 		case GPT_COMPETE:
; 2273 : 			if( pAttacker->GetState() == CS_USING_SKILL )

  00111	80 bf 10 03 00
	00 07		 cmp	 BYTE PTR [edi+784], 7
  00118	0f 85 ba 00 00
	00		 jne	 $LN3@ApplyWeapo@23
$LN152@ApplyWeapo@23:

; 2274 : 				pAttacker->SetAttackSkillGrapplingState( GetCharName() );

  0011e	8d 86 d4 02 00
	00		 lea	 eax, DWORD PTR [esi+724]
  00124	50		 push	 eax
  00125	8b cf		 mov	 ecx, edi
  00127	e8 00 00 00 00	 call	 ?SetAttackSkillGrapplingState@ioBaseChar@@QAEXABVioHashString@@@Z ; ioBaseChar::SetAttackSkillGrapplingState

; 2275 : 			break;

  0012c	e9 a7 00 00 00	 jmp	 $LN3@ApplyWeapo@23
$LN28@ApplyWeapo@23:

; 2276 : 		case GPT_MULTI:
; 2277 : 			if( bApplyPushPower && eBlockType == ATB_NONE && eProtectionType == PM_NONE )

  00131	80 7d 18 00	 cmp	 BYTE PTR _bApplyPushPower$[ebp], 0
  00135	0f 84 9d 00 00
	00		 je	 $LN3@ApplyWeapo@23
  0013b	83 7d 1c 00	 cmp	 DWORD PTR _eBlockType$[ebp], 0
  0013f	0f 85 93 00 00
	00		 jne	 $LN3@ApplyWeapo@23
  00145	83 7d 20 00	 cmp	 DWORD PTR _eProtectionType$[ebp], 0
  00149	0f 85 89 00 00
	00		 jne	 $LN3@ApplyWeapo@23

; 2278 : 			{
; 2279 : 				if( pAttacker->GetState() == CS_USING_SKILL )
; 2280 : 					pAttacker->SetAttackSkillGrapplingState( GetCharName() );
; 2281 : 			}
; 2282 : 			break;

  0014f	eb c0		 jmp	 SHORT $LN30@ApplyWeapo@23
$LN25@ApplyWeapo@23:

; 2283 : 		case GPT_LUCIFER_AIR:
; 2284 : 			if( pAttacker->GetState() == CS_LUCIFER_FLY )

  00151	8a 87 10 03 00
	00		 mov	 al, BYTE PTR [edi+784]
  00157	3c 56		 cmp	 al, 86			; 00000056H
  00159	0f 85 63 ff ff
	ff		 jne	 $LN41@ApplyWeapo@23

; 2285 : 				pAttacker->SetAttackItemGrapplingState( GetCharName() );

  0015f	eb 15		 jmp	 SHORT $LN13@ApplyWeapo@23
$LN21@ApplyWeapo@23:

; 2286 : 			else if( pAttacker->GetState() == CS_JUMP )
; 2287 : 				pAttacker->SetJumpGrapplingState( GetCharName() );
; 2288 : 			break;
; 2289 : 		case GPT_NAKORURU:
; 2290 : 			if( pAttacker->GetState() == CS_JUMP )

  00161	80 bf 10 03 00
	00 04		 cmp	 BYTE PTR [edi+784], 4

; 2291 : 				pAttacker->SetJumpGrapplingState( GetCharName() );
; 2292 : 			break;

  00168	e9 57 ff ff ff	 jmp	 $LN151@ApplyWeapo@23
$LN17@ApplyWeapo@23:

; 2293 : 		case GPT_GRAPPLER_JUMP:
; 2294 : 			if( pAttacker->GetState() == CS_JUMP )
; 2295 : 				pAttacker->SetJumpGrapplingState( GetCharName() );
; 2296 : 				break;
; 2297 : 		case GPT_MICHAEL:
; 2298 : 			if( pAttacker->GetState() == CS_MICHAEL_FLY )

  0016d	80 bf 10 03 00
	00 5b		 cmp	 BYTE PTR [edi+784], 91	; 0000005bH
$LN153@ApplyWeapo@23:
  00174	75 62		 jne	 SHORT $LN3@ApplyWeapo@23
$LN13@ApplyWeapo@23:

; 2299 : 				pAttacker->SetAttackItemGrapplingState( GetCharName() );

  00176	8d 86 d4 02 00
	00		 lea	 eax, DWORD PTR [esi+724]
  0017c	50		 push	 eax
  0017d	8b cf		 mov	 ecx, edi
  0017f	e8 00 00 00 00	 call	 ?SetAttackItemGrapplingState@ioBaseChar@@QAEXABVioHashString@@@Z ; ioBaseChar::SetAttackItemGrapplingState

; 2300 : 			break;

  00184	eb 52		 jmp	 SHORT $LN3@ApplyWeapo@23
$LN15@ApplyWeapo@23:

; 2301 : 		case GPT_SUPER_DIMENSION:
; 2302 : 			if( pAttacker->GetState() == CS_SUPER_DIMENSION_DASH )

  00186	80 bf 10 03 00
	00 74		 cmp	 BYTE PTR [edi+784], 116	; 00000074H

; 2303 : 				pAttacker->SetAttackItemGrapplingState( GetCharName() );
; 2304 : 			break;

  0018d	eb e5		 jmp	 SHORT $LN153@ApplyWeapo@23
$LN12@ApplyWeapo@23:

; 2305 : 		case GPT_JUMPER:				
; 2306 : 			pAttacker->SetAttackItemGrapplingState( GetCharName() );
; 2307 : 			break;
; 2308 : 		case GPT_STRIKER_AIR:
; 2309 : 			{
; 2310 : 				ioAttackableItem *pItem = pAttacker->GetPriorityItem( SPT_JUMP );

  0018f	6a 02		 push	 2
  00191	8b cf		 mov	 ecx, edi
  00193	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem

; 2311 : 				if( pItem )

  00198	85 c0		 test	 eax, eax
  0019a	74 3c		 je	 SHORT $LN3@ApplyWeapo@23

; 2312 : 				{
; 2313 : 					ioExtendJump *pExtendJump = pItem->GetCurExtendJump();

  0019c	8b c8		 mov	 ecx, eax
  0019e	e8 00 00 00 00	 call	 ?GetCurExtendJump@ioAttackableItem@@QAEPAVioExtendJump@@XZ ; ioAttackableItem::GetCurExtendJump
  001a3	8b d8		 mov	 ebx, eax

; 2314 : 					if( pExtendJump && ToChargeComboJump3( pExtendJump) && 
; 2315 : 						ToChargeComboJump3( pExtendJump )->GetCurChargeComboState() == ioChargeComboJump3::CCS_STRIKER_MOVE_ADD_ATTACK )

  001a5	85 db		 test	 ebx, ebx
  001a7	74 2c		 je	 SHORT $LN148@ApplyWeapo@23
  001a9	53		 push	 ebx
  001aa	e8 00 00 00 00	 call	 ?ToChargeComboJump3@@YAPAVioChargeComboJump3@@PAVioExtendJump@@@Z ; ToChargeComboJump3
  001af	59		 pop	 ecx
  001b0	85 c0		 test	 eax, eax
  001b2	74 21		 je	 SHORT $LN148@ApplyWeapo@23
  001b4	53		 push	 ebx
  001b5	e8 00 00 00 00	 call	 ?ToChargeComboJump3@@YAPAVioChargeComboJump3@@PAVioExtendJump@@@Z ; ToChargeComboJump3
  001ba	59		 pop	 ecx
  001bb	8b c8		 mov	 ecx, eax
  001bd	e8 00 00 00 00	 call	 ?GetCurChargeComboState@ioChargeComboJump3@@QAEHXZ ; ioChargeComboJump3::GetCurChargeComboState
  001c2	83 f8 1b	 cmp	 eax, 27			; 0000001bH
  001c5	75 0e		 jne	 SHORT $LN148@ApplyWeapo@23

; 2316 : 					{
; 2317 : 						pAttacker->SetAttackItemGrapplingState( GetCharName() );

  001c7	8d 86 d4 02 00
	00		 lea	 eax, DWORD PTR [esi+724]
  001cd	50		 push	 eax
  001ce	8b cf		 mov	 ecx, edi
  001d0	e8 00 00 00 00	 call	 ?SetAttackItemGrapplingState@ioBaseChar@@QAEXABVioHashString@@@Z ; ioBaseChar::SetAttackItemGrapplingState
$LN148@ApplyWeapo@23:

; 2318 : 					}
; 2319 : 				}
; 2320 : 			}
; 2321 : 			break;

  001d5	8b 5d 08	 mov	 ebx, DWORD PTR _pWeapon$[ebp]
$LN3@ApplyWeapo@23:

; 2336 : 			break;
; 2337 : 		}
; 2338 : 
; 2339 : 		pAttacker->SetWarpTargetList( pAttacker->GetCharName(), GetCharName() );

  001d8	81 c6 d4 02 00
	00		 add	 esi, 724		; 000002d4H
  001de	56		 push	 esi
  001df	8d 87 d4 02 00
	00		 lea	 eax, DWORD PTR [edi+724]
  001e5	50		 push	 eax
  001e6	8b cf		 mov	 ecx, edi
  001e8	e8 00 00 00 00	 call	 ?SetWarpTargetList@ioBaseChar@@QAEXABVioHashString@@0@Z ; ioBaseChar::SetWarpTargetList

; 2340 : 						
; 2341 : 		// check extra gauge
; 2342 : 		const WeaponAttribute *pAttr = g_WeaponMgr.FindAttribute( pWeapon->GetAttributeIndex() );

  001ed	8b cb		 mov	 ecx, ebx
  001ef	e8 00 00 00 00	 call	 ?GetAttributeIndex@ioWeapon@@QBEHXZ ; ioWeapon::GetAttributeIndex
  001f4	50		 push	 eax
  001f5	e8 00 00 00 00	 call	 ?GetSingleton@ioWeaponManager@@SAAAV1@XZ ; ioWeaponManager::GetSingleton
  001fa	8b c8		 mov	 ecx, eax
  001fc	e8 00 00 00 00	 call	 ?FindAttribute@ioWeaponManager@@QAEPBUWeaponAttribute@@H@Z ; ioWeaponManager::FindAttribute

; 2343 : 		float fExtraGauge = 0.0f;

  00201	0f 57 c0	 xorps	 xmm0, xmm0
  00204	f3 0f 11 45 18	 movss	 DWORD PTR _fExtraGauge$694698[ebp], xmm0

; 2344 : 		if( pAttr )

  00209	85 c0		 test	 eax, eax
  0020b	74 0a		 je	 SHORT $LN2@ApplyWeapo@23

; 2345 : 			fExtraGauge = pAttr->m_fDamageRate;

  0020d	f3 0f 10 40 6c	 movss	 xmm0, DWORD PTR [eax+108]
  00212	f3 0f 11 45 18	 movss	 DWORD PTR _fExtraGauge$694698[ebp], xmm0
$LN2@ApplyWeapo@23:

; 2346 : 			
; 2347 : 		if( pWeapon->GetExtraGaugeType() != WGT_NONE && fDamage > 0.0f && fExtraGauge > 0.0f )

  00217	8b cb		 mov	 ecx, ebx
  00219	e8 00 00 00 00	 call	 ?GetExtraGaugeType@ioWeapon@@QAEHXZ ; ioWeapon::GetExtraGaugeType
  0021e	85 c0		 test	 eax, eax
  00220	74 2e		 je	 SHORT $LN150@ApplyWeapo@23
  00222	f3 0f 10 4d 10	 movss	 xmm1, DWORD PTR _fDamage$[ebp]
  00227	0f 57 c0	 xorps	 xmm0, xmm0
  0022a	0f 2f c8	 comiss	 xmm1, xmm0
  0022d	76 21		 jbe	 SHORT $LN150@ApplyWeapo@23
  0022f	f3 0f 10 4d 18	 movss	 xmm1, DWORD PTR _fExtraGauge$694698[ebp]
  00234	0f 2f c8	 comiss	 xmm1, xmm0
  00237	76 17		 jbe	 SHORT $LN150@ApplyWeapo@23

; 2348 : 			pAttacker->SetExtraGaugeTypeByWeapon( EGT_ATTACK, pWeapon->GetExtraGaugeType(), fExtraGauge );

  00239	51		 push	 ecx
  0023a	8b cb		 mov	 ecx, ebx
  0023c	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00241	e8 00 00 00 00	 call	 ?GetExtraGaugeType@ioWeapon@@QAEHXZ ; ioWeapon::GetExtraGaugeType
  00246	50		 push	 eax
  00247	6a 01		 push	 1
  00249	8b cf		 mov	 ecx, edi
  0024b	e8 00 00 00 00	 call	 ?SetExtraGaugeTypeByWeapon@ioBaseChar@@QAEXHHM@Z ; ioBaseChar::SetExtraGaugeTypeByWeapon
$LN150@ApplyWeapo@23:
  00250	5b		 pop	 ebx
$LN149@ApplyWeapo@23:
  00251	5f		 pop	 edi
$LN53@ApplyWeapo@23:
  00252	5e		 pop	 esi

; 2349 : 	}
; 2350 : }

  00253	5d		 pop	 ebp
  00254	c2 1c 00	 ret	 28			; 0000001cH
$LN9@ApplyWeapo@23:

; 2322 : 		case GPT_FLY_JUMP_EXTRA_ATTACK:				
; 2323 : 			pAttacker->SetAttackBuffGrapplingState( GetCharName(), BT_FLY_JUMP_EXTRA_ATTACK );

  00257	68 bc 00 00 00	 push	 188			; 000000bcH
  0025c	8d 86 d4 02 00
	00		 lea	 eax, DWORD PTR [esi+724]
  00262	50		 push	 eax
  00263	8b cf		 mov	 ecx, edi
  00265	e8 00 00 00 00	 call	 ?SetAttackBuffGrapplingState@ioBaseChar@@QAEXABVioHashString@@H@Z ; ioBaseChar::SetAttackBuffGrapplingState

; 2324 : 			break;

  0026a	e9 69 ff ff ff	 jmp	 $LN3@ApplyWeapo@23
$LN8@ApplyWeapo@23:

; 2325 : 		case GPT_GALFORD:
; 2326 : 			if( pAttacker->GetState() == CS_GALFORD_CMD_STATE )

  0026f	80 bf 10 03 00
	00 a7		 cmp	 BYTE PTR [edi+784], 167	; 000000a7H

; 2327 : 				pAttacker->SetAttackItemGrapplingState( GetCharName() );
; 2328 : 			break;

  00276	e9 f9 fe ff ff	 jmp	 $LN153@ApplyWeapo@23
$LN6@ApplyWeapo@23:

; 2329 : 		case GPT_DRUID:
; 2330 : 			if( pAttacker->GetState() == CS_ATTACK )

  0027b	80 bf 10 03 00
	00 05		 cmp	 BYTE PTR [edi+784], 5
  00282	0f 85 50 ff ff
	ff		 jne	 $LN3@ApplyWeapo@23
$LN154@ApplyWeapo@23:

; 2331 : 				pAttacker->SetAttackGrapplingState( GetCharName() );

  00288	8d 86 d4 02 00
	00		 lea	 eax, DWORD PTR [esi+724]
  0028e	50		 push	 eax
  0028f	8b cf		 mov	 ecx, edi
  00291	e8 00 00 00 00	 call	 ?SetAttackGrapplingState@ioBaseChar@@QAEXABVioHashString@@@Z ; ioBaseChar::SetAttackGrapplingState

; 2332 : 			break;

  00296	e9 3d ff ff ff	 jmp	 $LN3@ApplyWeapo@23
$LN4@ApplyWeapo@23:

; 2333 : 		case GPT_GUNNER:
; 2334 : 			if( pAttacker->GetState() == CS_CMD_STATE )

  0029b	80 bf 10 03 00
	00 53		 cmp	 BYTE PTR [edi+784], 83	; 00000053H

; 2335 : 				pAttacker->SetAttackItemGrapplingState( GetCharName() );

  002a2	e9 cd fe ff ff	 jmp	 $LN153@ApplyWeapo@23
  002a7	90		 npad	 1
$LN156@ApplyWeapo@23:

; 2349 : 	}
; 2350 : }

  002a8	00 00 00 00	 DD	 $LN38@ApplyWeapo@23
  002ac	00 00 00 00	 DD	 $LN32@ApplyWeapo@23
  002b0	00 00 00 00	 DD	 $LN38@ApplyWeapo@23
  002b4	00 00 00 00	 DD	 $LN30@ApplyWeapo@23
  002b8	00 00 00 00	 DD	 $LN30@ApplyWeapo@23
  002bc	00 00 00 00	 DD	 $LN3@ApplyWeapo@23
  002c0	00 00 00 00	 DD	 $LN28@ApplyWeapo@23
  002c4	00 00 00 00	 DD	 $LN3@ApplyWeapo@23
  002c8	00 00 00 00	 DD	 $LN3@ApplyWeapo@23
  002cc	00 00 00 00	 DD	 $LN30@ApplyWeapo@23
  002d0	00 00 00 00	 DD	 $LN3@ApplyWeapo@23
  002d4	00 00 00 00	 DD	 $LN25@ApplyWeapo@23
  002d8	00 00 00 00	 DD	 $LN21@ApplyWeapo@23
  002dc	00 00 00 00	 DD	 $LN17@ApplyWeapo@23
  002e0	00 00 00 00	 DD	 $LN3@ApplyWeapo@23
  002e4	00 00 00 00	 DD	 $LN15@ApplyWeapo@23
  002e8	00 00 00 00	 DD	 $LN12@ApplyWeapo@23
  002ec	00 00 00 00	 DD	 $LN13@ApplyWeapo@23
  002f0	00 00 00 00	 DD	 $LN9@ApplyWeapo@23
  002f4	00 00 00 00	 DD	 $LN3@ApplyWeapo@23
  002f8	00 00 00 00	 DD	 $LN21@ApplyWeapo@23
  002fc	00 00 00 00	 DD	 $LN8@ApplyWeapo@23
  00300	00 00 00 00	 DD	 $LN6@ApplyWeapo@23
  00304	00 00 00 00	 DD	 $LN3@ApplyWeapo@23
  00308	00 00 00 00	 DD	 $LN4@ApplyWeapo@23
?ApplyWeaponWoundedSingleFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@M_N2W4AttackBlockType@@W4ProtectionMode@@@Z ENDP ; ioBaseChar::ApplyWeaponWoundedSingleFunc
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UBuffInfoStruct@@@std@@UBuffInfoStruct@@ABU3@@std@@YAXAAV?$allocator@UBuffInfoStruct@@@0@PAUBuffInfoStruct@@ABU2@@Z ; std::_Cons_val<std::allocator<BuffInfoStruct>,BuffInfoStruct,BuffInfoStruct const &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@UBuffInfoStruct@@@std@@UBuffInfoStruct@@ABU3@@std@@YAXAAV?$allocator@UBuffInfoStruct@@@0@PAUBuffInfoStruct@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UBuffInfoStruct@@@std@@UBuffInfoStruct@@ABU3@@std@@YAXAAV?$allocator@UBuffInfoStruct@@@0@PAUBuffInfoStruct@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<BuffInfoStruct>,BuffInfoStruct,BuffInfoStruct const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	ff 75 10	 push	 DWORD PTR __Src$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR __Pdest$[ebp]
  00009	e8 00 00 00 00	 call	 ??$_Construct@UBuffInfoStruct@@ABU1@@std@@YAXPAUBuffInfoStruct@@ABU1@@Z ; std::_Construct<BuffInfoStruct,BuffInfoStruct const &>
  0000e	59		 pop	 ecx
  0000f	59		 pop	 ecx

; 281  : 	}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Cons_val@V?$allocator@UBuffInfoStruct@@@std@@UBuffInfoStruct@@ABU3@@std@@YAXAAV?$allocator@UBuffInfoStruct@@@0@PAUBuffInfoStruct@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<BuffInfoStruct>,BuffInfoStruct,BuffInfoStruct const &>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UBuffInfoStruct@@@std@@UBuffInfoStruct@@@std@@YAXAAV?$allocator@UBuffInfoStruct@@@0@PAUBuffInfoStruct@@@Z ; std::_Dest_val<std::allocator<BuffInfoStruct>,BuffInfoStruct>
; Function compile flags: /Ogsp
;	COMDAT ??$_Dest_val@V?$allocator@UBuffInfoStruct@@@std@@UBuffInfoStruct@@@std@@YAXAAV?$allocator@UBuffInfoStruct@@@0@PAUBuffInfoStruct@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UBuffInfoStruct@@@std@@UBuffInfoStruct@@@std@@YAXAAV?$allocator@UBuffInfoStruct@@@0@PAUBuffInfoStruct@@@Z PROC ; std::_Dest_val<std::allocator<BuffInfoStruct>,BuffInfoStruct>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 287  : 	_Alval.destroy(_Pdest);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]

; 288  : 	}

  00006	5d		 pop	 ebp

; 287  : 	_Alval.destroy(_Pdest);

  00007	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
??$_Dest_val@V?$allocator@UBuffInfoStruct@@@std@@UBuffInfoStruct@@@std@@YAXAAV?$allocator@UBuffInfoStruct@@@0@PAUBuffInfoStruct@@@Z ENDP ; std::_Dest_val<std::allocator<BuffInfoStruct>,BuffInfoStruct>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@VioHashString@@@std@@VioHashString@@@std@@YAXAAV?$allocator@VioHashString@@@0@PAVioHashString@@@Z ; std::_Dest_val<std::allocator<ioHashString>,ioHashString>
; Function compile flags: /Ogsp
;	COMDAT ??$_Dest_val@V?$allocator@VioHashString@@@std@@VioHashString@@@std@@YAXAAV?$allocator@VioHashString@@@0@PAVioHashString@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@VioHashString@@@std@@VioHashString@@@std@@YAXAAV?$allocator@VioHashString@@@0@PAVioHashString@@@Z PROC ; std::_Dest_val<std::allocator<ioHashString>,ioHashString>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 287  : 	_Alval.destroy(_Pdest);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]

; 288  : 	}

  00006	5d		 pop	 ebp

; 287  : 	_Alval.destroy(_Pdest);

  00007	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
??$_Dest_val@V?$allocator@VioHashString@@@std@@VioHashString@@@std@@YAXAAV?$allocator@VioHashString@@@0@PAVioHashString@@@Z ENDP ; std::_Dest_val<std::allocator<ioHashString>,ioHashString>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUBuffInfoStruct@@PAU1@V?$allocator@UBuffInfoStruct@@@std@@U1@@std@@YAPAUBuffInfoStruct@@PAU1@00AAV?$allocator@UBuffInfoStruct@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<BuffInfoStruct *,BuffInfoStruct *,std::allocator<BuffInfoStruct>,BuffInfoStruct>
EXTRN	__EH_prolog3_catch:PROC
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\weaponattribute.h
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAUBuffInfoStruct@@PAU1@V?$allocator@UBuffInfoStruct@@@std@@U1@@std@@YAPAUBuffInfoStruct@@PAU1@00AAV?$allocator@UBuffInfoStruct@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAUBuffInfoStruct@@PAU1@V?$allocator@UBuffInfoStruct@@@std@@U1@@std@@YAPAUBuffInfoStruct@@PAU1@00AAV?$allocator@UBuffInfoStruct@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAUBuffInfoStruct@@PAU1@V?$allocator@UBuffInfoStruct@@@std@@U1@@std@@YAPAUBuffInfoStruct@@PAU1@00AAV?$allocator@UBuffInfoStruct@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAUBuffInfoStruct@@PAU1@V?$allocator@UBuffInfoStruct@@@std@@U1@@std@@YAPAUBuffInfoStruct@@PAU1@00AAV?$allocator@UBuffInfoStruct@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAUBuffInfoStruct@@PAU1@V?$allocator@UBuffInfoStruct@@@std@@U1@@std@@YAPAUBuffInfoStruct@@PAU1@00AAV?$allocator@UBuffInfoStruct@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$3
__ehfuncinfo$??$_Uninit_move@PAUBuffInfoStruct@@PAU1@V?$allocator@UBuffInfoStruct@@@std@@U1@@std@@YAPAUBuffInfoStruct@@PAU1@00AAV?$allocator@UBuffInfoStruct@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAUBuffInfoStruct@@PAU1@V?$allocator@UBuffInfoStruct@@@std@@U1@@std@@YAPAUBuffInfoStruct@@PAU1@00AAV?$allocator@UBuffInfoStruct@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAUBuffInfoStruct@@PAU1@V?$allocator@UBuffInfoStruct@@@std@@U1@@std@@YAPAUBuffInfoStruct@@PAU1@00AAV?$allocator@UBuffInfoStruct@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAUBuffInfoStruct@@PAU1@V?$allocator@UBuffInfoStruct@@@std@@U1@@std@@YAPAUBuffInfoStruct@@PAU1@00AAV?$allocator@UBuffInfoStruct@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUBuffInfoStruct@@PAU1@V?$allocator@UBuffInfoStruct@@@std@@U1@@std@@YAPAUBuffInfoStruct@@PAU1@00AAV?$allocator@UBuffInfoStruct@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<BuffInfoStruct *,BuffInfoStruct *,std::allocator<BuffInfoStruct>,BuffInfoStruct>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	6a 08		 push	 8
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??$_Uninit_move@PAUBuffInfoStruct@@PAU1@V?$allocator@UBuffInfoStruct@@@std@@U1@@std@@YAPAUBuffInfoStruct@@PAU1@00AAV?$allocator@UBuffInfoStruct@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_catch

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0000c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 428  : 
; 429  : 	_TRY_BEGIN

  0000f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
  00013	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00016	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LL6@Uninit_mov:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  00019	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001c	74 33		 je	 SHORT $LN4@Uninit_mov

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  0001e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00021	56		 push	 esi
  00022	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00025	e8 00 00 00 00	 call	 ?construct@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@$$QAU3@@Z ; std::allocator<BuffInfoStruct>::construct
  0002a	83 45 10 14	 add	 DWORD PTR __Dest$[ebp], 20 ; 00000014H
  0002e	83 c6 14	 add	 esi, 20			; 00000014H
  00031	eb e6		 jmp	 SHORT $LL6@Uninit_mov
__catch$??$_Uninit_move@PAUBuffInfoStruct@@PAU1@V?$allocator@UBuffInfoStruct@@@std@@U1@@std@@YAPAUBuffInfoStruct@@PAU1@00AAV?$allocator@UBuffInfoStruct@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)

  00033	8b 75 ec	 mov	 esi, DWORD PTR __Next$[ebp]
  00036	eb 0b		 jmp	 SHORT $LN36@Uninit_mov
$LL3@Uninit_mov:

; 434  : 		_Dest_val(_Al, _Next);

  00038	8b ce		 mov	 ecx, esi
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00040	83 c6 14	 add	 esi, 20			; 00000014H
$LN36@Uninit_mov:

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)

  00043	3b 75 10	 cmp	 esi, DWORD PTR __Dest$[ebp]
  00046	75 f0		 jne	 SHORT $LL3@Uninit_mov

; 435  : 	_RERAISE;

  00048	6a 00		 push	 0
  0004a	6a 00		 push	 0
  0004c	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN37@Uninit_mov:
$LN4@Uninit_mov:

; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  00051	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 438  : 	}

  00054	e8 00 00 00 00	 call	 __EH_epilog3
  00059	c3		 ret	 0
$LN35@Uninit_mov:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAUBuffInfoStruct@@PAU1@V?$allocator@UBuffInfoStruct@@@std@@U1@@std@@YAPAUBuffInfoStruct@@PAU1@00AAV?$allocator@UBuffInfoStruct@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAUBuffInfoStruct@@PAU1@V?$allocator@UBuffInfoStruct@@@std@@U1@@std@@YAPAUBuffInfoStruct@@PAU1@00AAV?$allocator@UBuffInfoStruct@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAUBuffInfoStruct@@PAU1@V?$allocator@UBuffInfoStruct@@@std@@U1@@std@@YAPAUBuffInfoStruct@@PAU1@00AAV?$allocator@UBuffInfoStruct@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<BuffInfoStruct *,BuffInfoStruct *,std::allocator<BuffInfoStruct>,BuffInfoStruct>
PUBLIC	??$_Destroy_range@V?$allocator@UBuffInfoStruct@@@std@@@std@@YAXPAUBuffInfoStruct@@0AAV?$allocator@UBuffInfoStruct@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<BuffInfoStruct> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UBuffInfoStruct@@@std@@@std@@YAXPAUBuffInfoStruct@@0AAV?$allocator@UBuffInfoStruct@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UBuffInfoStruct@@@std@@@std@@YAXPAUBuffInfoStruct@@0AAV?$allocator@UBuffInfoStruct@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<BuffInfoStruct> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 96   : 	for (; _First != _Last; ++_First)

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	eb 0b		 jmp	 SHORT $LN20@Destroy_ra
$LL3@Destroy_ra:

; 97   : 		_Dest_val(_Al, _First);

  00009	8b ce		 mov	 ecx, esi
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00011	83 c6 14	 add	 esi, 20			; 00000014H
$LN20@Destroy_ra:

; 96   : 	for (; _First != _Last; ++_First)

  00014	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00017	75 f0		 jne	 SHORT $LL3@Destroy_ra
  00019	5e		 pop	 esi

; 98   : 	}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Destroy_range@V?$allocator@UBuffInfoStruct@@@std@@@std@@YAXPAUBuffInfoStruct@@0AAV?$allocator@UBuffInfoStruct@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<BuffInfoStruct> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VioHashString@@@std@@@std@@YAXPAVioHashString@@0AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<ioHashString> >
; Function compile flags: /Ogsp
;	COMDAT ??$_Destroy_range@V?$allocator@VioHashString@@@std@@@std@@YAXPAVioHashString@@0AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@VioHashString@@@std@@@std@@YAXPAVioHashString@@0AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<ioHashString> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 96   : 	for (; _First != _Last; ++_First)

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	eb 0b		 jmp	 SHORT $LN17@Destroy_ra@2
$LL3@Destroy_ra@2:

; 97   : 		_Dest_val(_Al, _First);

  00009	8b ce		 mov	 ecx, esi
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00011	83 c6 10	 add	 esi, 16			; 00000010H
$LN17@Destroy_ra@2:

; 96   : 	for (; _First != _Last; ++_First)

  00014	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00017	75 f0		 jne	 SHORT $LL3@Destroy_ra@2
  00019	5e		 pop	 esi

; 98   : 	}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Destroy_range@V?$allocator@VioHashString@@@std@@@std@@YAXPAVioHashString@@0AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<ioHashString> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUBuffInfoStruct@@PAU1@V?$allocator@UBuffInfoStruct@@@std@@@std@@YAPAUBuffInfoStruct@@PAU1@00AAV?$allocator@UBuffInfoStruct@@@0@@Z ; std::_Uninitialized_move<BuffInfoStruct *,BuffInfoStruct *,std::allocator<BuffInfoStruct> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAUBuffInfoStruct@@PAU1@V?$allocator@UBuffInfoStruct@@@std@@@std@@YAPAUBuffInfoStruct@@PAU1@00AAV?$allocator@UBuffInfoStruct@@@0@@Z
_TEXT	SEGMENT
__Cat$701315 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUBuffInfoStruct@@PAU1@V?$allocator@UBuffInfoStruct@@@std@@@std@@YAPAUBuffInfoStruct@@PAU1@00AAV?$allocator@UBuffInfoStruct@@@0@@Z PROC ; std::_Uninitialized_move<BuffInfoStruct *,BuffInfoStruct *,std::allocator<BuffInfoStruct> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$701315[ebp]
  00007	6a 00		 push	 0
  00009	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000c	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000f	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00012	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00015	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUBuffInfoStruct@@PAU1@V?$allocator@UBuffInfoStruct@@@std@@U1@@std@@YAPAUBuffInfoStruct@@PAU1@00AAV?$allocator@UBuffInfoStruct@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<BuffInfoStruct *,BuffInfoStruct *,std::allocator<BuffInfoStruct>,BuffInfoStruct>
  0001a	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  0001d	c9		 leave
  0001e	c3		 ret	 0
??$_Uninitialized_move@PAUBuffInfoStruct@@PAU1@V?$allocator@UBuffInfoStruct@@@std@@@std@@YAPAUBuffInfoStruct@@PAU1@00AAV?$allocator@UBuffInfoStruct@@@0@@Z ENDP ; std::_Uninitialized_move<BuffInfoStruct *,BuffInfoStruct *,std::allocator<BuffInfoStruct> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UBuffInfoStruct@@@std@@@std@@YAXPAUBuffInfoStruct@@0AAV?$allocator@UBuffInfoStruct@@@0@@Z ; std::_Destroy_range<std::allocator<BuffInfoStruct> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UBuffInfoStruct@@@std@@@std@@YAXPAUBuffInfoStruct@@0AAV?$allocator@UBuffInfoStruct@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UBuffInfoStruct@@@std@@@std@@YAXPAUBuffInfoStruct@@0AAV?$allocator@UBuffInfoStruct@@@0@@Z PROC ; std::_Destroy_range<std::allocator<BuffInfoStruct> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	eb 0b		 jmp	 SHORT $LN24@Destroy_ra@3
$LL7@Destroy_ra@3:
  00009	8b ce		 mov	 ecx, esi
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00011	83 c6 14	 add	 esi, 20			; 00000014H
$LN24@Destroy_ra@3:
  00014	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00017	75 f0		 jne	 SHORT $LL7@Destroy_ra@3
  00019	5e		 pop	 esi

; 89   : 	}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Destroy_range@V?$allocator@UBuffInfoStruct@@@std@@@std@@YAXPAUBuffInfoStruct@@0AAV?$allocator@UBuffInfoStruct@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<BuffInfoStruct> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VioHashString@@@std@@@std@@YAXPAVioHashString@@0AAV?$allocator@VioHashString@@@0@@Z ; std::_Destroy_range<std::allocator<ioHashString> >
; Function compile flags: /Ogsp
;	COMDAT ??$_Destroy_range@V?$allocator@VioHashString@@@std@@@std@@YAXPAVioHashString@@0AAV?$allocator@VioHashString@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@VioHashString@@@std@@@std@@YAXPAVioHashString@@0AAV?$allocator@VioHashString@@@0@@Z PROC ; std::_Destroy_range<std::allocator<ioHashString> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	eb 0b		 jmp	 SHORT $LN21@Destroy_ra@4
$LL7@Destroy_ra@4:
  00009	8b ce		 mov	 ecx, esi
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00011	83 c6 10	 add	 esi, 16			; 00000010H
$LN21@Destroy_ra@4:
  00014	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00017	75 f0		 jne	 SHORT $LL7@Destroy_ra@4
  00019	5e		 pop	 esi

; 89   : 	}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Destroy_range@V?$allocator@VioHashString@@@std@@@std@@YAXPAVioHashString@@0AAV?$allocator@VioHashString@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<ioHashString> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAUBuffInfoStruct@@@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IAEPAUBuffInfoStruct@@PAU2@00@Z ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Umove<BuffInfoStruct *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAUBuffInfoStruct@@@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IAEPAUBuffInfoStruct@@PAU2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUBuffInfoStruct@@@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IAEPAUBuffInfoStruct@@PAU2@00@Z PROC ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Umove<BuffInfoStruct *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	51		 push	 ecx
  00007	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUBuffInfoStruct@@PAU1@V?$allocator@UBuffInfoStruct@@@std@@@std@@YAPAUBuffInfoStruct@@PAU1@00AAV?$allocator@UBuffInfoStruct@@@0@@Z ; std::_Uninitialized_move<BuffInfoStruct *,BuffInfoStruct *,std::allocator<BuffInfoStruct> >
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00018	5d		 pop	 ebp
  00019	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUBuffInfoStruct@@@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IAEPAUBuffInfoStruct@@PAU2@00@Z ENDP ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Umove<BuffInfoStruct *>
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IAEXPAUBuffInfoStruct@@0@Z ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Destroy
; Function compile flags: /Ogsp
;	COMDAT ?_Destroy@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IAEXPAUBuffInfoStruct@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IAEXPAUBuffInfoStruct@@0@Z PROC ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	eb 0b		 jmp	 SHORT $LN26@Destroy
$LL9@Destroy:
  00009	8b ce		 mov	 ecx, esi
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00011	83 c6 14	 add	 esi, 20			; 00000014H
$LN26@Destroy:
  00014	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00017	75 f0		 jne	 SHORT $LL9@Destroy
  00019	5e		 pop	 esi

; 1271 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
?_Destroy@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IAEXPAUBuffInfoStruct@@0@Z ENDP ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IAEXXZ ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Tidy
EXTRN	__imp_?_Orphan_all@_Container_base0@std@@QAEXXZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ?_Tidy@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IAEXXZ PROC ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00006	74 28		 je	 SHORT $LN27@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00008	53		 push	 ebx
  00009	57		 push	 edi
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  00010	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00013	8b 3e		 mov	 edi, DWORD PTR [esi]
  00015	eb 0b		 jmp	 SHORT $LN31@Tidy
$LL12@Tidy:
  00017	8b cf		 mov	 ecx, edi
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  0001f	83 c7 14	 add	 edi, 20			; 00000014H
$LN31@Tidy:
  00022	3b fb		 cmp	 edi, ebx
  00024	75 f1		 jne	 SHORT $LL12@Tidy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002d	59		 pop	 ecx
  0002e	5f		 pop	 edi
  0002f	5b		 pop	 ebx
$LN27@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00030	33 c0		 xor	 eax, eax
  00032	89 06		 mov	 DWORD PTR [esi], eax

; 1310 : 		this->_Mylast = 0;

  00034	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1311 : 		this->_Myend = 0;

  00037	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003a	5e		 pop	 esi

; 1312 : 		}

  0003b	c3		 ret	 0
?_Tidy@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IAEXXZ ENDP ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXPAVioHashString@@0@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::_Destroy
; Function compile flags: /Ogsp
;	COMDAT ?_Destroy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXPAVioHashString@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXPAVioHashString@@0@Z PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	eb 0b		 jmp	 SHORT $LN23@Destroy@2
$LL9@Destroy@2:
  00009	8b ce		 mov	 ecx, esi
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00011	83 c6 10	 add	 esi, 16			; 00000010H
$LN23@Destroy@2:
  00014	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00017	75 f0		 jne	 SHORT $LL9@Destroy@2
  00019	5e		 pop	 esi

; 1271 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
?_Destroy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXPAVioHashString@@0@Z ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::_Destroy
_TEXT	ENDS
PUBLIC	?reserve@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEXI@Z ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::reserve
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEXI@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEXI@Z$3
__ehfuncinfo$?reserve@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Ptr$695426 = -24					; size = 4
$T701841 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEXI@Z PROC ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	6a 0c		 push	 12			; 0000000cH
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?reserve@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEXI@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_catch
  0000c	8b f1		 mov	 esi, ecx

; 747  : 		if (max_size() < _Count)

  0000e	81 7d 08 cc cc
	cc 0c		 cmp	 DWORD PTR __Count$[ebp], 214748364 ; 0cccccccH
  00015	76 0b		 jbe	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  00017	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN62@reserve:
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  00022	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00025	2b 06		 sub	 eax, DWORD PTR [esi]
  00027	6a 14		 push	 20			; 00000014H
  00029	99		 cdq
  0002a	59		 pop	 ecx
  0002b	f7 f9		 idiv	 ecx
  0002d	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00030	0f 83 81 00 00
	00		 jae	 $LN3@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  00036	6a 00		 push	 0
  00038	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  0003b	e8 00 00 00 00	 call	 ??$_Allocate@UBuffInfoStruct@@@std@@YAPAUBuffInfoStruct@@IPAU1@@Z ; std::_Allocate<BuffInfoStruct>

; 752  : 
; 753  : 			_TRY_BEGIN
; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00040	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00042	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
  00046	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  00049	52		 push	 edx
  0004a	89 45 e8	 mov	 DWORD PTR __Ptr$695426[ebp], eax
  0004d	ff 75 e8	 push	 DWORD PTR __Ptr$695426[ebp]
  00050	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00053	50		 push	 eax
  00054	51		 push	 ecx
  00055	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUBuffInfoStruct@@PAU1@V?$allocator@UBuffInfoStruct@@@std@@@std@@YAPAUBuffInfoStruct@@PAU1@00AAV?$allocator@UBuffInfoStruct@@@0@@Z ; std::_Uninitialized_move<BuffInfoStruct *,BuffInfoStruct *,std::allocator<BuffInfoStruct> >

; 758  : 			_CATCH_END
; 759  : 
; 760  : 			size_type _Size = size();

  0005a	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  0005d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0005f	83 c4 18	 add	 esp, 24			; 00000018H
  00062	8b c3		 mov	 eax, ebx
  00064	2b c1		 sub	 eax, ecx
  00066	6a 14		 push	 20			; 00000014H
  00068	99		 cdq
  00069	5f		 pop	 edi
  0006a	f7 ff		 idiv	 edi
  0006c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  00070	8b f8		 mov	 edi, eax
  00072	85 c9		 test	 ecx, ecx
  00074	74 21		 je	 SHORT $LN54@reserve

; 761  : 			if (this->_Myfirst != 0)
; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  00076	89 4d ec	 mov	 DWORD PTR $T701841[ebp], ecx
  00079	3b cb		 cmp	 ecx, ebx
  0007b	74 12		 je	 SHORT $LN37@reserve
$LN39@reserve:
  0007d	8b 4d ec	 mov	 ecx, DWORD PTR $T701841[ebp]
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00086	83 45 ec 14	 add	 DWORD PTR $T701841[ebp], 20 ; 00000014H
  0008a	39 5d ec	 cmp	 DWORD PTR $T701841[ebp], ebx
  0008d	75 ee		 jne	 SHORT $LN39@reserve
$LN37@reserve:

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  0008f	ff 36		 push	 DWORD PTR [esi]
  00091	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00096	59		 pop	 ecx
$LN54@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  00097	8b ce		 mov	 ecx, esi
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 769  : 			this->_Myend = _Ptr + _Count;
; 770  : 			this->_Mylast = _Ptr + _Size;

  0009f	6b ff 14	 imul	 edi, 20			; 00000014H
  000a2	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  000a5	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$695426[ebp]
  000a8	6b c0 14	 imul	 eax, 20			; 00000014H
  000ab	03 c1		 add	 eax, ecx
  000ad	03 f9		 add	 edi, ecx
  000af	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000b2	89 7e 04	 mov	 DWORD PTR [esi+4], edi

; 771  : 			this->_Myfirst = _Ptr;

  000b5	89 0e		 mov	 DWORD PTR [esi], ecx
$LN3@reserve:

; 772  : 			}
; 773  : 		}

  000b7	e8 00 00 00 00	 call	 __EH_epilog3
  000bc	c2 04 00	 ret	 4
__catch$?reserve@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  000bf	ff 75 e8	 push	 DWORD PTR __Ptr$695426[ebp]
  000c2	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000c7	59		 pop	 ecx

; 757  : 			_RERAISE;

  000c8	6a 00		 push	 0
  000ca	6a 00		 push	 0
  000cc	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN63@reserve:
$LN61@reserve:
  000d1	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEXI@Z ENDP ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::reserve
PUBLIC	??1?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAE@XZ ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::~vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAE@XZ PROC ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::~vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >, COMDAT
; _this$ = ecx

; 705  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IAEXXZ ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Tidy
??1?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAE@XZ ENDP ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::~vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXXZ ; std::vector<ioHashString,std::allocator<ioHashString> >::_Tidy
; Function compile flags: /Ogsp
;	COMDAT ?_Tidy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXXZ PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00006	74 28		 je	 SHORT $LN24@Tidy@2

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00008	53		 push	 ebx
  00009	57		 push	 edi
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  00010	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00013	8b 3e		 mov	 edi, DWORD PTR [esi]
  00015	eb 0b		 jmp	 SHORT $LN28@Tidy@2
$LL12@Tidy@2:
  00017	8b cf		 mov	 ecx, edi
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  0001f	83 c7 10	 add	 edi, 16			; 00000010H
$LN28@Tidy@2:
  00022	3b fb		 cmp	 edi, ebx
  00024	75 f1		 jne	 SHORT $LL12@Tidy@2

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002d	59		 pop	 ecx
  0002e	5f		 pop	 edi
  0002f	5b		 pop	 ebx
$LN24@Tidy@2:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00030	33 c0		 xor	 eax, eax
  00032	89 06		 mov	 DWORD PTR [esi], eax

; 1310 : 		this->_Mylast = 0;

  00034	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1311 : 		this->_Myend = 0;

  00037	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003a	5e		 pop	 esi

; 1312 : 		}

  0003b	c3		 ret	 0
?_Tidy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXXZ ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Reserve@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IAEXI@Z ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Reserve
; Function compile flags: /Ogsp
;	COMDAT ?_Reserve@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IAEXI@Z PROC ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1291 : 		size_type _Size = size();

  00006	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00008	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000b	2b c1		 sub	 eax, ecx
  0000d	57		 push	 edi
  0000e	99		 cdq
  0000f	6a 14		 push	 20			; 00000014H
  00011	5f		 pop	 edi
  00012	f7 ff		 idiv	 edi
  00014	8b f8		 mov	 edi, eax

; 1292 : 		if (max_size() - _Count < _Size)

  00016	b8 cc cc cc 0c	 mov	 eax, 214748364		; 0cccccccH
  0001b	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  0001e	3b c7		 cmp	 eax, edi
  00020	73 0b		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN21@Reserve:
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	2b c1		 sub	 eax, ecx
  00032	6a 14		 push	 20			; 00000014H
  00034	99		 cdq
  00035	59		 pop	 ecx
  00036	f7 f9		 idiv	 ecx
  00038	03 7d 08	 add	 edi, DWORD PTR __Count$[ebp]
  0003b	3b f8		 cmp	 edi, eax
  0003d	76 10		 jbe	 SHORT $LN1@Reserve

; 1295 : 			;
; 1296 : 		else
; 1297 : 			reserve(_Grow_to(_Size));

  0003f	57		 push	 edi
  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IBEII@Z ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Grow_to
  00047	50		 push	 eax
  00048	8b ce		 mov	 ecx, esi
  0004a	e8 00 00 00 00	 call	 ?reserve@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEXI@Z ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::reserve
$LN1@Reserve:
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi

; 1298 : 		}

  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
$LN20@Reserve:
?_Reserve@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IAEXI@Z ENDP ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Reserve
_TEXT	ENDS
PUBLIC	??1?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ ; std::vector<ioHashString,std::allocator<ioHashString> >::~vector<ioHashString,std::allocator<ioHashString> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::~vector<ioHashString,std::allocator<ioHashString> >, COMDAT
; _this$ = ecx

; 705  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXXZ ; std::vector<ioHashString,std::allocator<ioHashString> >::_Tidy
??1?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::~vector<ioHashString,std::allocator<ioHashString> >
_TEXT	ENDS
PUBLIC	?ApplyWeaponWoundedSkillFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_NMW4DefenseBreakType@@W4AttackBlockType@@W4ProtectionMode@@@Z ; ioBaseChar::ApplyWeaponWoundedSkillFunc
EXTRN	?CheckReducePassiveSkillGaugeBuff@ioPassiveSkill@@QAE_NPAVioBaseChar@@H@Z:PROC ; ioPassiveSkill::CheckReducePassiveSkillGaugeBuff
EXTRN	?AddNewBuff@ioBaseChar@@QAEPAVioBuff@@ABVioHashString@@00PAVioSkill@@_N@Z:PROC ; ioBaseChar::AddNewBuff
EXTRN	?GetOwnerGaugeBuffName@ioPassiveSkill@@QBE?BV?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@PAVioBaseChar@@@Z:PROC ; ioPassiveSkill::GetOwnerGaugeBuffName
EXTRN	?CheckWoundPassiveSkill@ioBaseChar@@QAEXPAV1@@Z:PROC ; ioBaseChar::CheckWoundPassiveSkill
EXTRN	?CheckEnablePossessionState@ioBaseChar@@QAEXABVioHashString@@@Z:PROC ; ioBaseChar::CheckEnablePossessionState
EXTRN	?HasEnablePossessionBuff@ioBaseChar@@QAE_NXZ:PROC ; ioBaseChar::HasEnablePossessionBuff
EXTRN	?IsEnablePossession@ioWeapon@@QAE_NXZ:PROC	; ioWeapon::IsEnablePossession
EXTRN	?CheckReducePassiveSkillGrade@ioPassiveSkill@@QAEXPAVioBaseChar@@0@Z:PROC ; ioPassiveSkill::CheckReducePassiveSkillGrade
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasechar.h
xdata$x	SEGMENT
__ehfuncinfo$?ApplyWeaponWoundedSkillFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_NMW4DefenseBreakType@@W4AttackBlockType@@W4ProtectionMode@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?ApplyWeaponWoundedSkillFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_NMW4DefenseBreakType@@W4AttackBlockType@@W4ProtectionMode@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ApplyWeaponWoundedSkillFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_NMW4DefenseBreakType@@W4AttackBlockType@@W4ProtectionMode@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ApplyWeaponWoundedSkillFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_NMW4DefenseBreakType@@W4AttackBlockType@@W4ProtectionMode@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ApplyWeaponWoundedSkillFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_NMW4DefenseBreakType@@W4AttackBlockType@@W4ProtectionMode@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ApplyWeaponWoundedSkillFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_NMW4DefenseBreakType@@W4AttackBlockType@@W4ProtectionMode@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?ApplyWeaponWoundedSkillFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_NMW4DefenseBreakType@@W4AttackBlockType@@W4ProtectionMode@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ApplyWeaponWoundedSkillFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_NMW4DefenseBreakType@@W4AttackBlockType@@W4ProtectionMode@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?ApplyWeaponWoundedSkillFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_NMW4DefenseBreakType@@W4AttackBlockType@@W4ProtectionMode@@@Z$5
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasecharapplywoundednew.cpp
xdata$x	ENDS
;	COMDAT ?ApplyWeaponWoundedSkillFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_NMW4DefenseBreakType@@W4AttackBlockType@@W4ProtectionMode@@@Z
_TEXT	SEGMENT
$T702064 = -68						; size = 16
_vCallBuffName$694548 = -52				; size = 16
$T702063 = -52						; size = 16
$T702062 = -52						; size = 16
_vGaugeBuffName$694535 = -36				; size = 16
_vGaugeBuffName$694517 = -36				; size = 16
_value$702118 = -20					; size = 4
_value$702093 = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
tv708 = 8						; size = 4
tv695 = 8						; size = 4
_value$702175 = 8					; size = 4
_pWeapon$ = 8						; size = 4
tv471 = 12						; size = 4
tv414 = 12						; size = 4
_bBlock$ = 12						; size = 1
_value$702147 = 12					; size = 4
_value$702105 = 12					; size = 4
_value$702080 = 12					; size = 4
_pAttacker$ = 12					; size = 4
_value$702162 = 16					; size = 4
_value$702134 = 16					; size = 4
_i$694527 = 16						; size = 4
_i$694509 = 16						; size = 4
_bApplyPushPower$ = 16					; size = 1
_fDamage$ = 20						; size = 4
_eBreakType$ = 24					; size = 4
_eBlockType$ = 28					; size = 4
_eProtectionType$ = 32					; size = 4
?ApplyWeaponWoundedSkillFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_NMW4DefenseBreakType@@W4AttackBlockType@@W4ProtectionMode@@@Z PROC ; ioBaseChar::ApplyWeaponWoundedSkillFunc, COMDAT
; _this$ = ecx

; 1943 : {

  00000	6a 38		 push	 56			; 00000038H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?ApplyWeaponWoundedSkillFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_NMW4DefenseBreakType@@W4AttackBlockType@@W4ProtectionMode@@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f9		 mov	 edi, ecx
  0000e	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi

; 1944 : 	if ( !pWeapon || !pAttacker )

  00011	33 db		 xor	 ebx, ebx
  00013	39 5d 08	 cmp	 DWORD PTR _pWeapon$[ebp], ebx
  00016	0f 84 07 04 00
	00		 je	 $LN40@ApplyWeapo@24
  0001c	8b 75 0c	 mov	 esi, DWORD PTR _pAttacker$[ebp]
  0001f	3b f3		 cmp	 esi, ebx
  00021	0f 84 fc 03 00
	00		 je	 $LN40@ApplyWeapo@24

; 1945 : 		return;
; 1946 : 
; 1947 : 	if( pAttacker->GetTeam() != GetTeam() )

  00027	8d 45 0c	 lea	 eax, DWORD PTR _value$702080[ebp]
  0002a	8d 8e 90 00 00
	00		 lea	 ecx, DWORD PTR [esi+144]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  00036	8d 45 ec	 lea	 eax, DWORD PTR _value$702093[ebp]
  00039	8d 8f 90 00 00
	00		 lea	 ecx, DWORD PTR [edi+144]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  00045	8b 45 0c	 mov	 eax, DWORD PTR _value$702080[ebp]
  00048	3b 45 ec	 cmp	 eax, DWORD PTR _value$702093[ebp]
  0004b	74 22		 je	 SHORT $LN36@ApplyWeapo@24
$LL38@ApplyWeapo@24:

; 1950 : 		{
; 1951 : 			ioSkill *pSkill = GetEquipedSkill( i );

  0004d	53		 push	 ebx
  0004e	8b cf		 mov	 ecx, edi
  00050	e8 00 00 00 00	 call	 ?GetEquipedSkill@ioBaseChar@@QAEPAVioSkill@@H@Z ; ioBaseChar::GetEquipedSkill

; 1952 : 			ioPassiveSkill *pPassiveSkill = ToPassiveSkill( pSkill );

  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ?ToPassiveSkill@@YAPAVioPassiveSkill@@PAVioSkill@@@Z ; ToPassiveSkill
  0005b	59		 pop	 ecx

; 1953 : 			if( pPassiveSkill )

  0005c	85 c0		 test	 eax, eax
  0005e	74 09		 je	 SHORT $LN37@ApplyWeapo@24

; 1954 : 				pPassiveSkill->CheckReducePassiveSkillGrade( this, pAttacker );					

  00060	56		 push	 esi
  00061	57		 push	 edi
  00062	8b c8		 mov	 ecx, eax
  00064	e8 00 00 00 00	 call	 ?CheckReducePassiveSkillGrade@ioPassiveSkill@@QAEXPAVioBaseChar@@0@Z ; ioPassiveSkill::CheckReducePassiveSkillGrade
$LN37@ApplyWeapo@24:

; 1948 : 	{
; 1949 : 		for( int i=0; i<4; i++ )

  00069	43		 inc	 ebx
  0006a	83 fb 04	 cmp	 ebx, 4
  0006d	7c de		 jl	 SHORT $LL38@ApplyWeapo@24
$LN36@ApplyWeapo@24:

; 1955 : 		}
; 1956 : 	}
; 1957 : 
; 1958 : 	//Accessory
; 1959 : 	if( pAttacker->GetTeam() != GetTeam() )

  0006f	8d 45 0c	 lea	 eax, DWORD PTR _value$702105[ebp]
  00072	50		 push	 eax
  00073	8d 8e 90 00 00
	00		 lea	 ecx, DWORD PTR [esi+144]
  00079	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  0007e	8d 45 ec	 lea	 eax, DWORD PTR _value$702118[ebp]
  00081	50		 push	 eax
  00082	8d 8f 90 00 00
	00		 lea	 ecx, DWORD PTR [edi+144]
  00088	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  0008d	8b 45 0c	 mov	 eax, DWORD PTR _value$702105[ebp]
  00090	3b 45 ec	 cmp	 eax, DWORD PTR _value$702118[ebp]
  00093	74 25		 je	 SHORT $LN31@ApplyWeapo@24

; 1960 : 	{
; 1961 : 		for( int i=ES_RING; i<MAX_EQUIP_SLOT; i++ )

  00095	6a 06		 push	 6
  00097	5b		 pop	 ebx
$LL33@ApplyWeapo@24:

; 1962 : 		{
; 1963 : 			ioSkill *pSkill = GetEquipedSkill( i );

  00098	53		 push	 ebx
  00099	8b cf		 mov	 ecx, edi
  0009b	e8 00 00 00 00	 call	 ?GetEquipedSkill@ioBaseChar@@QAEPAVioSkill@@H@Z ; ioBaseChar::GetEquipedSkill

; 1964 : 			ioPassiveSkill *pPassiveSkill = ToPassiveSkill( pSkill );

  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ?ToPassiveSkill@@YAPAVioPassiveSkill@@PAVioSkill@@@Z ; ToPassiveSkill
  000a6	59		 pop	 ecx

; 1965 : 			if( pPassiveSkill )

  000a7	85 c0		 test	 eax, eax
  000a9	74 09		 je	 SHORT $LN32@ApplyWeapo@24

; 1966 : 				pPassiveSkill->CheckReducePassiveSkillGrade( this, pAttacker );					

  000ab	56		 push	 esi
  000ac	57		 push	 edi
  000ad	8b c8		 mov	 ecx, eax
  000af	e8 00 00 00 00	 call	 ?CheckReducePassiveSkillGrade@ioPassiveSkill@@QAEXPAVioBaseChar@@0@Z ; ioPassiveSkill::CheckReducePassiveSkillGrade
$LN32@ApplyWeapo@24:

; 1960 : 	{
; 1961 : 		for( int i=ES_RING; i<MAX_EQUIP_SLOT; i++ )

  000b4	43		 inc	 ebx
  000b5	83 fb 09	 cmp	 ebx, 9
  000b8	7c de		 jl	 SHORT $LL33@ApplyWeapo@24
$LN31@ApplyWeapo@24:

; 1967 : 		}
; 1968 : 	}
; 1969 : 
; 1970 : 	bool bBlock = true;
; 1971 : 	if( eBlockType == ATB_NONE && eProtectionType == PM_NONE )

  000ba	83 7d 1c 00	 cmp	 DWORD PTR _eBlockType$[ebp], 0
  000be	c6 45 0c 01	 mov	 BYTE PTR _bBlock$[ebp], 1
  000c2	75 0a		 jne	 SHORT $LN29@ApplyWeapo@24
  000c4	83 7d 20 00	 cmp	 DWORD PTR _eProtectionType$[ebp], 0
  000c8	75 04		 jne	 SHORT $LN29@ApplyWeapo@24

; 1972 : 		bBlock = false;

  000ca	c6 45 0c 00	 mov	 BYTE PTR _bBlock$[ebp], 0
$LN29@ApplyWeapo@24:

; 1973 : 
; 1974 : 	ioSkill *pSkill = pAttacker->GetCurActiveSkill();

  000ce	8b ce		 mov	 ecx, esi
  000d0	e8 00 00 00 00	 call	 ?GetCurActiveSkill@ioBaseChar@@QAEPAVioSkill@@XZ ; ioBaseChar::GetCurActiveSkill

; 1975 : 	if( pSkill )

  000d5	85 c0		 test	 eax, eax
  000d7	74 19		 je	 SHORT $LN28@ApplyWeapo@24

; 1976 : 		pSkill->SetInfoByApplyWeapon( pAttacker, this, pWeapon->GetWeaponIndex(), bBlock );

  000d9	ff 75 0c	 push	 DWORD PTR _bBlock$[ebp]
  000dc	8b 4d 08	 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  000df	8b 89 b8 04 00
	00		 mov	 ecx, DWORD PTR [ecx+1208]
  000e5	8b 10		 mov	 edx, DWORD PTR [eax]
  000e7	51		 push	 ecx
  000e8	57		 push	 edi
  000e9	56		 push	 esi
  000ea	8b c8		 mov	 ecx, eax
  000ec	ff 92 60 01 00
	00		 call	 DWORD PTR [edx+352]
$LN28@ApplyWeapo@24:

; 1977 : 
; 1978 : 	if( !bBlock )

  000f2	80 7d 0c 00	 cmp	 BYTE PTR _bBlock$[ebp], 0
  000f6	0f 85 27 03 00
	00		 jne	 $LN40@ApplyWeapo@24

; 1979 : 	{
; 1980 : 		if( bApplyPushPower && pAttacker->GetTeam() != GetTeam() )

  000fc	80 7d 10 00	 cmp	 BYTE PTR _bApplyPushPower$[ebp], 0
  00100	0f 84 1d 03 00
	00		 je	 $LN40@ApplyWeapo@24
  00106	8d 45 10	 lea	 eax, DWORD PTR _value$702134[ebp]
  00109	50		 push	 eax
  0010a	8d 8e 90 00 00
	00		 lea	 ecx, DWORD PTR [esi+144]
  00110	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  00115	8d 45 0c	 lea	 eax, DWORD PTR _value$702147[ebp]
  00118	50		 push	 eax
  00119	8d 8f 90 00 00
	00		 lea	 ecx, DWORD PTR [edi+144]
  0011f	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  00124	8b 45 10	 mov	 eax, DWORD PTR _value$702134[ebp]
  00127	3b 45 0c	 cmp	 eax, DWORD PTR _value$702147[ebp]
  0012a	74 35		 je	 SHORT $LN25@ApplyWeapo@24

; 1981 : 		{
; 1982 : 			if( pWeapon->IsEnablePossession() && HasEnablePossessionBuff() && m_PossessionName.IsEmpty() )

  0012c	8b 4d 08	 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  0012f	e8 00 00 00 00	 call	 ?IsEnablePossession@ioWeapon@@QAE_NXZ ; ioWeapon::IsEnablePossession
  00134	84 c0		 test	 al, al
  00136	74 29		 je	 SHORT $LN25@ApplyWeapo@24
  00138	8b cf		 mov	 ecx, edi
  0013a	e8 00 00 00 00	 call	 ?HasEnablePossessionBuff@ioBaseChar@@QAE_NXZ ; ioBaseChar::HasEnablePossessionBuff
  0013f	84 c0		 test	 al, al
  00141	74 1e		 je	 SHORT $LN25@ApplyWeapo@24
  00143	8d 8f 0c 3b 00
	00		 lea	 ecx, DWORD PTR [edi+15116]
  00149	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  0014f	84 c0		 test	 al, al
  00151	74 0e		 je	 SHORT $LN25@ApplyWeapo@24

; 1983 : 				pAttacker->CheckEnablePossessionState( GetCharName() );

  00153	8d 87 d4 02 00
	00		 lea	 eax, DWORD PTR [edi+724]
  00159	50		 push	 eax
  0015a	8b ce		 mov	 ecx, esi
  0015c	e8 00 00 00 00	 call	 ?CheckEnablePossessionState@ioBaseChar@@QAEXABVioHashString@@@Z ; ioBaseChar::CheckEnablePossessionState
$LN25@ApplyWeapo@24:

; 1984 : 		}
; 1985 : 
; 1986 : 		if( bApplyPushPower && fDamage > 0.0f && pAttacker->GetTeam() != GetTeam() )

  00161	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  00166	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0016d	0f 86 b0 02 00
	00		 jbe	 $LN40@ApplyWeapo@24
  00173	8d 45 10	 lea	 eax, DWORD PTR _value$702162[ebp]
  00176	50		 push	 eax
  00177	8d 8e 90 00 00
	00		 lea	 ecx, DWORD PTR [esi+144]
  0017d	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  00182	8d 45 08	 lea	 eax, DWORD PTR _value$702175[ebp]
  00185	50		 push	 eax
  00186	8d 8f 90 00 00
	00		 lea	 ecx, DWORD PTR [edi+144]
  0018c	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  00191	8b 45 10	 mov	 eax, DWORD PTR _value$702162[ebp]
  00194	3b 45 08	 cmp	 eax, DWORD PTR _value$702175[ebp]
  00197	0f 84 86 02 00
	00		 je	 $LN40@ApplyWeapo@24

; 1987 : 		{
; 1988 : 			CheckWoundPassiveSkill(	pAttacker );

  0019d	56		 push	 esi
  0019e	8b cf		 mov	 ecx, edi
  001a0	e8 00 00 00 00	 call	 ?CheckWoundPassiveSkill@ioBaseChar@@QAEXPAV1@@Z ; ioBaseChar::CheckWoundPassiveSkill

; 1989 : 
; 1990 : 			for( int i = 0; i < 4; i++ )

  001a5	83 65 10 00	 and	 DWORD PTR _i$694509[ebp], 0
  001a9	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_??1ioHashString@@QAE@XZ
$LN23@ApplyWeapo@24:

; 1991 : 			{
; 1992 : 				ioSkill *pSkill = NULL;
; 1993 : 				pSkill = pAttacker->GetEquipedSkill( i );

  001af	ff 75 10	 push	 DWORD PTR _i$694509[ebp]
  001b2	8b ce		 mov	 ecx, esi
  001b4	e8 00 00 00 00	 call	 ?GetEquipedSkill@ioBaseChar@@QAEPAVioSkill@@H@Z ; ioBaseChar::GetEquipedSkill

; 1994 : 
; 1995 : 				ioPassiveSkill *pPassiveSkill = ToPassiveSkill( pSkill );

  001b9	50		 push	 eax
  001ba	e8 00 00 00 00	 call	 ?ToPassiveSkill@@YAPAVioPassiveSkill@@PAVioSkill@@@Z ; ToPassiveSkill
  001bf	8b f8		 mov	 edi, eax
  001c1	59		 pop	 ecx

; 1996 : 				if( pPassiveSkill && pPassiveSkill->UsePassiveGauge() )

  001c2	85 ff		 test	 edi, edi
  001c4	0f 84 ca 00 00
	00		 je	 $LN22@ApplyWeapo@24
  001ca	8b 07		 mov	 eax, DWORD PTR [edi]
  001cc	8b cf		 mov	 ecx, edi
  001ce	ff 90 a4 01 00
	00		 call	 DWORD PTR [eax+420]
  001d4	84 c0		 test	 al, al
  001d6	0f 84 b8 00 00
	00		 je	 $LN22@ApplyWeapo@24

; 1997 : 				{
; 1998 : 					if( pAttacker->HasBuff( BT_CALL_BUFF_ON_ATTACK ) )

  001dc	6a 60		 push	 96			; 00000060H
  001de	8b ce		 mov	 ecx, esi
  001e0	e8 00 00 00 00	 call	 ?HasBuff@ioBaseChar@@QBE_NH@Z ; ioBaseChar::HasBuff
  001e5	84 c0		 test	 al, al
  001e7	0f 84 85 00 00
	00		 je	 $LN94@ApplyWeapo@24

; 1999 : 					{
; 2000 : 						ioHashStringVec vGaugeBuffName = pPassiveSkill->GetOwnerGaugeBuffName( pAttacker );

  001ed	56		 push	 esi
  001ee	8d 45 dc	 lea	 eax, DWORD PTR _vGaugeBuffName$694517[ebp]
  001f1	50		 push	 eax
  001f2	8b cf		 mov	 ecx, edi
  001f4	e8 00 00 00 00	 call	 ?GetOwnerGaugeBuffName@ioPassiveSkill@@QBE?BV?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@PAVioBaseChar@@@Z ; ioPassiveSkill::GetOwnerGaugeBuffName

; 2001 : 						if( !vGaugeBuffName.empty() )

  001f9	8b 45 e0	 mov	 eax, DWORD PTR _vGaugeBuffName$694517[ebp+4]
  001fc	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00200	39 45 dc	 cmp	 DWORD PTR _vGaugeBuffName$694517[ebp], eax
  00203	74 61		 je	 SHORT $LN15@ApplyWeapo@24

; 2002 : 						{
; 2003 : 							int iBuffCnt = vGaugeBuffName.size();

  00205	2b 45 dc	 sub	 eax, DWORD PTR _vGaugeBuffName$694517[ebp]
  00208	c1 f8 04	 sar	 eax, 4

; 2004 : 							for( int j=0; j<iBuffCnt; ++j )

  0020b	85 c0		 test	 eax, eax
  0020d	7e 57		 jle	 SHORT $LN15@ApplyWeapo@24

; 2002 : 						{
; 2003 : 							int iBuffCnt = vGaugeBuffName.size();

  0020f	83 65 08 00	 and	 DWORD PTR tv695[ebp], 0
  00213	89 45 0c	 mov	 DWORD PTR tv471[ebp], eax
$LL17@ApplyWeapo@24:

; 2005 : 							{								
; 2006 : 								pPassiveSkill->CheckAttackProcess( this, pAttacker );

  00216	8b 07		 mov	 eax, DWORD PTR [edi]
  00218	56		 push	 esi
  00219	ff 75 f0	 push	 DWORD PTR _this$[ebp]
  0021c	8b cf		 mov	 ecx, edi
  0021e	ff 90 8c 01 00
	00		 call	 DWORD PTR [eax+396]

; 2007 : 								AddNewBuff( vGaugeBuffName[j], pAttacker->GetCharName(), "", NULL );

  00224	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00229	8d 4d cc	 lea	 ecx, DWORD PTR $T702062[ebp]
  0022c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  00232	8b 4d 08	 mov	 ecx, DWORD PTR tv695[ebp]
  00235	03 4d dc	 add	 ecx, DWORD PTR _vGaugeBuffName$694517[ebp]
  00238	6a 00		 push	 0
  0023a	6a 00		 push	 0
  0023c	8d 45 cc	 lea	 eax, DWORD PTR $T702062[ebp]
  0023f	50		 push	 eax
  00240	8d 86 d4 02 00
	00		 lea	 eax, DWORD PTR [esi+724]
  00246	50		 push	 eax
  00247	51		 push	 ecx
  00248	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0024b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0024f	e8 00 00 00 00	 call	 ?AddNewBuff@ioBaseChar@@QAEPAVioBuff@@ABVioHashString@@00PAVioSkill@@_N@Z ; ioBaseChar::AddNewBuff
  00254	8d 4d cc	 lea	 ecx, DWORD PTR $T702062[ebp]
  00257	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0025b	ff d3		 call	 ebx
  0025d	83 45 08 10	 add	 DWORD PTR tv695[ebp], 16 ; 00000010H
  00261	ff 4d 0c	 dec	 DWORD PTR tv471[ebp]
  00264	75 b0		 jne	 SHORT $LL17@ApplyWeapo@24
$LN15@ApplyWeapo@24:

; 2008 : 							}
; 2009 : 						}
; 2010 : 					}

  00266	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0026a	8d 4d dc	 lea	 ecx, DWORD PTR _vGaugeBuffName$694517[ebp]
  0026d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXXZ ; std::vector<ioHashString,std::allocator<ioHashString> >::_Tidy
$LN94@ApplyWeapo@24:

; 2011 : 
; 2012 : 					if( eBreakType == DBT_CHANGE &&
; 2013 : 						pPassiveSkill->CheckReducePassiveSkillGaugeBuff( pAttacker, BT_DEFENSE_BREAK_BUFF ) )

  00272	83 7d 18 03	 cmp	 DWORD PTR _eBreakType$[ebp], 3
  00276	75 1c		 jne	 SHORT $LN22@ApplyWeapo@24
  00278	6a 3d		 push	 61			; 0000003dH
  0027a	56		 push	 esi
  0027b	8b cf		 mov	 ecx, edi
  0027d	e8 00 00 00 00	 call	 ?CheckReducePassiveSkillGaugeBuff@ioPassiveSkill@@QAE_NPAVioBaseChar@@H@Z ; ioPassiveSkill::CheckReducePassiveSkillGaugeBuff
  00282	84 c0		 test	 al, al
  00284	74 0e		 je	 SHORT $LN22@ApplyWeapo@24

; 2014 : 					{							
; 2015 : 						pPassiveSkill->CheckAttackProcess( this, pAttacker );

  00286	8b 07		 mov	 eax, DWORD PTR [edi]
  00288	56		 push	 esi
  00289	ff 75 f0	 push	 DWORD PTR _this$[ebp]
  0028c	8b cf		 mov	 ecx, edi
  0028e	ff 90 8c 01 00
	00		 call	 DWORD PTR [eax+396]
$LN22@ApplyWeapo@24:

; 1989 : 
; 1990 : 			for( int i = 0; i < 4; i++ )

  00294	ff 45 10	 inc	 DWORD PTR _i$694509[ebp]
  00297	83 7d 10 04	 cmp	 DWORD PTR _i$694509[ebp], 4
  0029b	0f 8c 0e ff ff
	ff		 jl	 $LN23@ApplyWeapo@24

; 2016 : 					}
; 2017 : 				}
; 2018 : 			}
; 2019 : 
; 2020 : 			//Accessory
; 2021 : 			for( int i = ES_RING; i < MAX_EQUIP_SLOT; i++ )

  002a1	c7 45 10 06 00
	00 00		 mov	 DWORD PTR _i$694527[ebp], 6
$LN13@ApplyWeapo@24:

; 2022 : 			{
; 2023 : 				ioSkill *pSkill = NULL;
; 2024 : 				pSkill = pAttacker->GetEquipedSkill( i );

  002a8	ff 75 10	 push	 DWORD PTR _i$694527[ebp]
  002ab	8b ce		 mov	 ecx, esi
  002ad	e8 00 00 00 00	 call	 ?GetEquipedSkill@ioBaseChar@@QAEPAVioSkill@@H@Z ; ioBaseChar::GetEquipedSkill

; 2025 : 
; 2026 : 				ioPassiveSkill *pPassiveSkill = ToPassiveSkill( pSkill );

  002b2	50		 push	 eax
  002b3	e8 00 00 00 00	 call	 ?ToPassiveSkill@@YAPAVioPassiveSkill@@PAVioSkill@@@Z ; ToPassiveSkill
  002b8	8b f8		 mov	 edi, eax
  002ba	59		 pop	 ecx

; 2027 : 				if( pPassiveSkill && pPassiveSkill->UsePassiveGauge() )

  002bb	85 ff		 test	 edi, edi
  002bd	0f 84 cd 00 00
	00		 je	 $LN12@ApplyWeapo@24
  002c3	8b 07		 mov	 eax, DWORD PTR [edi]
  002c5	8b cf		 mov	 ecx, edi
  002c7	ff 90 a4 01 00
	00		 call	 DWORD PTR [eax+420]
  002cd	84 c0		 test	 al, al
  002cf	0f 84 bb 00 00
	00		 je	 $LN12@ApplyWeapo@24

; 2028 : 				{
; 2029 : 					if( pAttacker->HasBuff( BT_CALL_BUFF_ON_ATTACK ) )

  002d5	6a 60		 push	 96			; 00000060H
  002d7	8b ce		 mov	 ecx, esi
  002d9	e8 00 00 00 00	 call	 ?HasBuff@ioBaseChar@@QBE_NH@Z ; ioBaseChar::HasBuff
  002de	84 c0		 test	 al, al
  002e0	0f 84 88 00 00
	00		 je	 $LN106@ApplyWeapo@24

; 2030 : 					{
; 2031 : 						ioHashStringVec vGaugeBuffName = pPassiveSkill->GetOwnerGaugeBuffName( pAttacker );

  002e6	56		 push	 esi
  002e7	8d 45 dc	 lea	 eax, DWORD PTR _vGaugeBuffName$694535[ebp]
  002ea	50		 push	 eax
  002eb	8b cf		 mov	 ecx, edi
  002ed	e8 00 00 00 00	 call	 ?GetOwnerGaugeBuffName@ioPassiveSkill@@QBE?BV?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@PAVioBaseChar@@@Z ; ioPassiveSkill::GetOwnerGaugeBuffName

; 2032 : 						if( !vGaugeBuffName.empty() )

  002f2	8b 45 e0	 mov	 eax, DWORD PTR _vGaugeBuffName$694535[ebp+4]
  002f5	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  002fc	39 45 dc	 cmp	 DWORD PTR _vGaugeBuffName$694535[ebp], eax
  002ff	74 61		 je	 SHORT $LN5@ApplyWeapo@24

; 2033 : 						{
; 2034 : 							int iBuffCnt = vGaugeBuffName.size();

  00301	2b 45 dc	 sub	 eax, DWORD PTR _vGaugeBuffName$694535[ebp]
  00304	c1 f8 04	 sar	 eax, 4

; 2035 : 							for( int j=0; j<iBuffCnt; ++j )

  00307	85 c0		 test	 eax, eax
  00309	7e 57		 jle	 SHORT $LN5@ApplyWeapo@24

; 2033 : 						{
; 2034 : 							int iBuffCnt = vGaugeBuffName.size();

  0030b	83 65 08 00	 and	 DWORD PTR tv708[ebp], 0
  0030f	89 45 0c	 mov	 DWORD PTR tv414[ebp], eax
$LL7@ApplyWeapo@24:

; 2036 : 							{								
; 2037 : 								pPassiveSkill->CheckAttackProcess( this, pAttacker );

  00312	8b 07		 mov	 eax, DWORD PTR [edi]
  00314	56		 push	 esi
  00315	ff 75 f0	 push	 DWORD PTR _this$[ebp]
  00318	8b cf		 mov	 ecx, edi
  0031a	ff 90 8c 01 00
	00		 call	 DWORD PTR [eax+396]

; 2038 : 								AddNewBuff( vGaugeBuffName[j], pAttacker->GetCharName(), "", NULL );

  00320	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00325	8d 4d cc	 lea	 ecx, DWORD PTR $T702063[ebp]
  00328	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  0032e	8b 4d 08	 mov	 ecx, DWORD PTR tv708[ebp]
  00331	03 4d dc	 add	 ecx, DWORD PTR _vGaugeBuffName$694535[ebp]
  00334	6a 00		 push	 0
  00336	6a 00		 push	 0
  00338	8d 45 cc	 lea	 eax, DWORD PTR $T702063[ebp]
  0033b	50		 push	 eax
  0033c	8d 86 d4 02 00
	00		 lea	 eax, DWORD PTR [esi+724]
  00342	50		 push	 eax
  00343	51		 push	 ecx
  00344	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00347	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0034b	e8 00 00 00 00	 call	 ?AddNewBuff@ioBaseChar@@QAEPAVioBuff@@ABVioHashString@@00PAVioSkill@@_N@Z ; ioBaseChar::AddNewBuff
  00350	8d 4d cc	 lea	 ecx, DWORD PTR $T702063[ebp]
  00353	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00357	ff d3		 call	 ebx
  00359	83 45 08 10	 add	 DWORD PTR tv708[ebp], 16 ; 00000010H
  0035d	ff 4d 0c	 dec	 DWORD PTR tv414[ebp]
  00360	75 b0		 jne	 SHORT $LL7@ApplyWeapo@24
$LN5@ApplyWeapo@24:

; 2039 : 							}
; 2040 : 						}
; 2041 : 					}

  00362	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00366	8d 4d dc	 lea	 ecx, DWORD PTR _vGaugeBuffName$694535[ebp]
  00369	e8 00 00 00 00	 call	 ?_Tidy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXXZ ; std::vector<ioHashString,std::allocator<ioHashString> >::_Tidy
$LN106@ApplyWeapo@24:

; 2042 : 
; 2043 : 					if( eBreakType == DBT_CHANGE &&
; 2044 : 						pPassiveSkill->CheckReducePassiveSkillGaugeBuff( pAttacker, BT_DEFENSE_BREAK_BUFF ) )

  0036e	83 7d 18 03	 cmp	 DWORD PTR _eBreakType$[ebp], 3
  00372	75 1c		 jne	 SHORT $LN12@ApplyWeapo@24
  00374	6a 3d		 push	 61			; 0000003dH
  00376	56		 push	 esi
  00377	8b cf		 mov	 ecx, edi
  00379	e8 00 00 00 00	 call	 ?CheckReducePassiveSkillGaugeBuff@ioPassiveSkill@@QAE_NPAVioBaseChar@@H@Z ; ioPassiveSkill::CheckReducePassiveSkillGaugeBuff
  0037e	84 c0		 test	 al, al
  00380	74 0e		 je	 SHORT $LN12@ApplyWeapo@24

; 2045 : 					{							
; 2046 : 						pPassiveSkill->CheckAttackProcess( this, pAttacker );

  00382	8b 07		 mov	 eax, DWORD PTR [edi]
  00384	56		 push	 esi
  00385	ff 75 f0	 push	 DWORD PTR _this$[ebp]
  00388	8b cf		 mov	 ecx, edi
  0038a	ff 90 8c 01 00
	00		 call	 DWORD PTR [eax+396]
$LN12@ApplyWeapo@24:

; 2016 : 					}
; 2017 : 				}
; 2018 : 			}
; 2019 : 
; 2020 : 			//Accessory
; 2021 : 			for( int i = ES_RING; i < MAX_EQUIP_SLOT; i++ )

  00390	ff 45 10	 inc	 DWORD PTR _i$694527[ebp]
  00393	83 7d 10 09	 cmp	 DWORD PTR _i$694527[ebp], 9
  00397	0f 8c 0b ff ff
	ff		 jl	 $LN13@ApplyWeapo@24

; 2047 : 					}
; 2048 : 				}
; 2049 : 			}
; 2050 : 
; 2051 : 			if( pAttacker->HasBuff( BT_CALL_BUFF_ON_ATTACK2 ) )

  0039d	bf c9 00 00 00	 mov	 edi, 201		; 000000c9H
  003a2	57		 push	 edi
  003a3	8b ce		 mov	 ecx, esi
  003a5	e8 00 00 00 00	 call	 ?HasBuff@ioBaseChar@@QBE_NH@Z ; ioBaseChar::HasBuff
  003aa	84 c0		 test	 al, al
  003ac	74 75		 je	 SHORT $LN40@ApplyWeapo@24

; 2052 : 			{
; 2053 : 				ioCallBuffOnAttackBuff2 *pCallBuff2 = ToCallBuffOnAttackBuff2( pAttacker->GetBuff( BT_CALL_BUFF_ON_ATTACK2 ) );

  003ae	57		 push	 edi
  003af	8b ce		 mov	 ecx, esi
  003b1	e8 00 00 00 00	 call	 ?GetBuff@ioBaseChar@@QAEPAVioBuff@@H@Z ; ioBaseChar::GetBuff
  003b6	50		 push	 eax
  003b7	e8 00 00 00 00	 call	 ?ToCallBuffOnAttackBuff2@@YAPAVioCallBuffOnAttackBuff2@@PAVioBuff@@@Z ; ToCallBuffOnAttackBuff2
  003bc	59		 pop	 ecx

; 2054 : 				if( pCallBuff2 )

  003bd	85 c0		 test	 eax, eax
  003bf	74 62		 je	 SHORT $LN40@ApplyWeapo@24

; 2055 : 				{
; 2056 : 					ioHashString vCallBuffName = pCallBuff2->GetCallBuffName();

  003c1	05 70 09 00 00	 add	 eax, 2416		; 00000970H
  003c6	50		 push	 eax
  003c7	8d 4d cc	 lea	 ecx, DWORD PTR _vCallBuffName$694548[ebp]
  003ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z

; 2057 : 					if( !vCallBuffName.IsEmpty() )

  003d0	8d 4d cc	 lea	 ecx, DWORD PTR _vCallBuffName$694548[ebp]
  003d3	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4
  003da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  003e0	84 c0		 test	 al, al
  003e2	75 36		 jne	 SHORT $LN1@ApplyWeapo@24

; 2058 : 						AddNewBuff( vCallBuffName, pAttacker->GetCharName(), "", NULL );

  003e4	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  003e9	8d 4d bc	 lea	 ecx, DWORD PTR $T702064[ebp]
  003ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  003f2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  003f5	6a 00		 push	 0
  003f7	6a 00		 push	 0
  003f9	8d 45 bc	 lea	 eax, DWORD PTR $T702064[ebp]
  003fc	50		 push	 eax
  003fd	81 c6 d4 02 00
	00		 add	 esi, 724		; 000002d4H
  00403	56		 push	 esi
  00404	8d 45 cc	 lea	 eax, DWORD PTR _vCallBuffName$694548[ebp]
  00407	50		 push	 eax
  00408	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0040c	e8 00 00 00 00	 call	 ?AddNewBuff@ioBaseChar@@QAEPAVioBuff@@ABVioHashString@@00PAVioSkill@@_N@Z ; ioBaseChar::AddNewBuff
  00411	8d 4d bc	 lea	 ecx, DWORD PTR $T702064[ebp]
  00414	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00418	ff d3		 call	 ebx
$LN1@ApplyWeapo@24:

; 2059 : 				}

  0041a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0041e	8d 4d cc	 lea	 ecx, DWORD PTR _vCallBuffName$694548[ebp]
  00421	ff d3		 call	 ebx
$LN40@ApplyWeapo@24:

; 2060 : 			}
; 2061 : 		}
; 2062 : 	}
; 2063 : }

  00423	e8 00 00 00 00	 call	 __EH_epilog3
  00428	c2 1c 00	 ret	 28			; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ApplyWeaponWoundedSkillFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_NMW4DefenseBreakType@@W4AttackBlockType@@W4ProtectionMode@@@Z$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR _vGaugeBuffName$694517[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ ; std::vector<ioHashString,std::allocator<ioHashString> >::~vector<ioHashString,std::allocator<ioHashString> >
__unwindfunclet$?ApplyWeaponWoundedSkillFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_NMW4DefenseBreakType@@W4AttackBlockType@@W4ProtectionMode@@@Z$1:
  00008	8d 4d cc	 lea	 ecx, DWORD PTR $T702062[ebp]
  0000b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?ApplyWeaponWoundedSkillFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_NMW4DefenseBreakType@@W4AttackBlockType@@W4ProtectionMode@@@Z$2:
  00011	8d 4d dc	 lea	 ecx, DWORD PTR _vGaugeBuffName$694535[ebp]
  00014	e9 00 00 00 00	 jmp	 ??1?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ ; std::vector<ioHashString,std::allocator<ioHashString> >::~vector<ioHashString,std::allocator<ioHashString> >
__unwindfunclet$?ApplyWeaponWoundedSkillFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_NMW4DefenseBreakType@@W4AttackBlockType@@W4ProtectionMode@@@Z$3:
  00019	8d 4d cc	 lea	 ecx, DWORD PTR $T702063[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?ApplyWeaponWoundedSkillFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_NMW4DefenseBreakType@@W4AttackBlockType@@W4ProtectionMode@@@Z$4:
  00022	8d 4d cc	 lea	 ecx, DWORD PTR _vCallBuffName$694548[ebp]
  00025	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?ApplyWeaponWoundedSkillFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_NMW4DefenseBreakType@@W4AttackBlockType@@W4ProtectionMode@@@Z$5:
  0002b	8d 4d bc	 lea	 ecx, DWORD PTR $T702064[ebp]
  0002e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$?ApplyWeaponWoundedSkillFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_NMW4DefenseBreakType@@W4AttackBlockType@@W4ProtectionMode@@@Z:
  00034	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00038	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003b	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0003e	33 c8		 xor	 ecx, eax
  00040	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00045	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ApplyWeaponWoundedSkillFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_NMW4DefenseBreakType@@W4AttackBlockType@@W4ProtectionMode@@@Z
  0004a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ApplyWeaponWoundedSkillFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_NMW4DefenseBreakType@@W4AttackBlockType@@W4ProtectionMode@@@Z ENDP ; ioBaseChar::ApplyWeaponWoundedSkillFunc
PUBLIC	?push_back@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEXABUBuffInfoStruct@@@Z ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::push_back
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?push_back@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEXABUBuffInfoStruct@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEXABUBuffInfoStruct@@@Z PROC ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  00006	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	73 33		 jae	 SHORT $LN4@push_back
  00011	8b 16		 mov	 edx, DWORD PTR [esi]
  00013	3b d7		 cmp	 edx, edi
  00015	77 2d		 ja	 SHORT $LN4@push_back

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	8b c7		 mov	 eax, edi
  00019	2b c2		 sub	 eax, edx
  0001b	6a 14		 push	 20			; 00000014H
  0001d	99		 cdq
  0001e	5f		 pop	 edi
  0001f	f7 ff		 idiv	 edi
  00021	8b f8		 mov	 edi, eax

; 980  : 			if (this->_Mylast == this->_Myend)

  00023	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00026	75 09		 jne	 SHORT $LN3@push_back

; 981  : 				_Reserve(1);

  00028	6a 01		 push	 1
  0002a	8b ce		 mov	 ecx, esi
  0002c	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IAEXI@Z ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Reserve
$LN3@push_back:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  00031	6b ff 14	 imul	 edi, 20			; 00000014H
  00034	03 3e		 add	 edi, DWORD PTR [esi]
  00036	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00039	57		 push	 edi
  0003a	ff 76 04	 push	 DWORD PTR [esi+4]
  0003d	e8 00 00 00 00	 call	 ??$construct@AAUBuffInfoStruct@@@?$allocator@UBuffInfoStruct@@@std@@QAEXPAUBuffInfoStruct@@AAU2@@Z ; std::allocator<BuffInfoStruct>::construct<BuffInfoStruct &>

; 986  : 			++this->_Mylast;
; 987  : 			}
; 988  : 		else

  00042	eb 19		 jmp	 SHORT $LN30@push_back
$LN4@push_back:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  00044	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00047	75 09		 jne	 SHORT $LN1@push_back

; 991  : 				_Reserve(1);

  00049	6a 01		 push	 1
  0004b	8b ce		 mov	 ecx, esi
  0004d	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IAEXI@Z ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Reserve
$LN1@push_back:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  00052	57		 push	 edi
  00053	ff 76 04	 push	 DWORD PTR [esi+4]
  00056	e8 00 00 00 00	 call	 ??$_Construct@UBuffInfoStruct@@ABU1@@std@@YAXPAUBuffInfoStruct@@ABU1@@Z ; std::_Construct<BuffInfoStruct,BuffInfoStruct const &>
  0005b	59		 pop	 ecx
  0005c	59		 pop	 ecx
$LN30@push_back:

; 996  : 			++this->_Mylast;

  0005d	83 46 04 14	 add	 DWORD PTR [esi+4], 20	; 00000014H
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?push_back@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEXABUBuffInfoStruct@@@Z ENDP ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::push_back
_TEXT	ENDS
PUBLIC	_kAddBuffList$GSCopy$
PUBLIC	_pAttacker$GSCopy$
PUBLIC	_bLandStunBuff$GSCopy$
PUBLIC	_szDefenseBreakBuff$GSCopy$
PUBLIC	_szFrontBackAttackerBuff$GSCopy$
PUBLIC	_szFrontBackWoundBuff$GSCopy$
PUBLIC	_bTeamAttackNoDamage$GSCopy$
PUBLIC	_bEnableTeamAttack$GSCopy$
PUBLIC	_bTeamAttack$GSCopy$
PUBLIC	?ApplyWeaponWoundedAddBuff@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_N22AA_N32AAVioHashString@@44222W4DefenseBreakType@@3AAV?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@@Z ; ioBaseChar::ApplyWeaponWoundedAddBuff
EXTRN	?CheckLandStunBuff@ioBaseChar@@QAE_NPAVioWeapon@@@Z:PROC ; ioBaseChar::CheckLandStunBuff
EXTRN	?GetDefenseBreakBuff@ioWeapon@@QBEABVioHashString@@XZ:PROC ; ioWeapon::GetDefenseBreakBuff
EXTRN	?SetBuffDurationByRate@ioBuff@@QAEXM@Z:PROC	; ioBuff::SetBuffDurationByRate
EXTRN	?GetOwnerChargeBuffDurationRate@ioWeapon@@QAEMXZ:PROC ; ioWeapon::GetOwnerChargeBuffDurationRate
EXTRN	?GetGrowthUpInfoForItem@ioBaseChar@@QAEPAVioGrowthUpInfo@@HABVioHashString@@0@Z:PROC ; ioBaseChar::GetGrowthUpInfoForItem
EXTRN	?SetRelativeVector@ioAdhesiveBuff@@QAEXAAUD3DXVECTOR3@@@Z:PROC ; ioAdhesiveBuff::SetRelativeVector
EXTRN	?SetItemCode@ioBuff@@QAEXK@Z:PROC		; ioBuff::SetItemCode
EXTRN	?GetWeaponItemCode@ioBaseChar@@QAEKXZ:PROC	; ioBaseChar::GetWeaponItemCode
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasechar.h
xdata$x	SEGMENT
__unwindtable$?ApplyWeaponWoundedAddBuff@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_N22AA_N32AAVioHashString@@44222W4DefenseBreakType@@3AAV?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ApplyWeaponWoundedAddBuff@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_N22AA_N32AAVioHashString@@44222W4DefenseBreakType@@3AAV?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ApplyWeaponWoundedAddBuff@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_N22AA_N32AAVioHashString@@44222W4DefenseBreakType@@3AAV?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@@Z$1
__ehfuncinfo$?ApplyWeaponWoundedAddBuff@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_N22AA_N32AAVioHashString@@44222W4DefenseBreakType@@3AAV?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ApplyWeaponWoundedAddBuff@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_N22AA_N32AAVioHashString@@44222W4DefenseBreakType@@3AAV?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasecharapplywoundednew.cpp
xdata$x	ENDS
;	COMDAT ?ApplyWeaponWoundedAddBuff@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_N22AA_N32AAVioHashString@@44222W4DefenseBreakType@@3AAV?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@@Z
_TEXT	SEGMENT
$T702294 = -108						; size = 16
$T702295 = -92						; size = 16
_szFrontBackAttackerBuff$GSCopy$ = -76			; size = 4
_szFrontBackWoundBuff$GSCopy$ = -72			; size = 4
_szDefenseBreakBuff$GSCopy$ = -68			; size = 4
_value$702502 = -68					; size = 4
_value$702469 = -68					; size = 4
_bLandStunBuff$GSCopy$ = -64				; size = 4
_pBuff$694328 = -64					; size = 4
_kAddBuffList$GSCopy$ = -60				; size = 4
_bTeamAttack$GSCopy$ = -56				; size = 1
tv951 = -52						; size = 4
tv910 = -52						; size = 4
_fValue$694289 = -52					; size = 4
_value$702484 = -48					; size = 4
tv522 = -48						; size = 4
_fValue$694330 = -48					; size = 4
_fValue$694319 = -48					; size = 4
_fValue$694308 = -48					; size = 4
_pAttacker$GSCopy$ = -44				; size = 4
tv1132 = -40						; size = 4
_bTeamAttackNoDamage$GSCopy$ = -40			; size = 4
_pBuff$694268 = -40					; size = 4
_bEnableTeamAttack$GSCopy$ = -36			; size = 4
_pBuff$694306 = -36					; size = 4
_pBuff$694287 = -36					; size = 4
_fValue$694270 = -36					; size = 4
tv1477 = -32						; size = 4
tv1451 = -32						; size = 4
tv1425 = -32						; size = 4
_vRelativePos$ = -28					; size = 12
__$EHRec$ = -12						; size = 12
_pWeapon$ = 8						; size = 4
_pAttacker$ = 12					; size = 4
_bApplyPushPower$ = 16					; size = 1
_bEnableCancel$ = 20					; size = 1
_bTeamAttack$ = 24					; size = 1
_bEnableTeamAttack$ = 28				; size = 4
_bTeamAttackNoDamage$ = 32				; size = 4
_bPrisoner$ = 36					; size = 1
_szFrontBackWoundBuff$ = 40				; size = 4
_szFrontBackAttackerBuff$ = 44				; size = 4
_szDefenseBreakBuff$ = 48				; size = 4
_bAirTargetBuff$ = 52					; size = 1
_bTargetBuff$ = 56					; size = 1
_bDownTargetBuff$ = 60					; size = 1
_eBreakType$ = 64					; size = 4
_bLandStunBuff$ = 68					; size = 4
_kAddBuffList$ = 72					; size = 4
?ApplyWeaponWoundedAddBuff@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_N22AA_N32AAVioHashString@@44222W4DefenseBreakType@@3AAV?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@@Z PROC ; ioBaseChar::ApplyWeaponWoundedAddBuff, COMDAT
; _this$ = ecx

; 1510 : {

  00000	6a 60		 push	 96			; 00000060H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?ApplyWeaponWoundedAddBuff@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_N22AA_N32AAVioHashString@@44222W4DefenseBreakType@@3AAV?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_GS

; 1734 : 		pAttacker->AddNewBuff( szFrontBackAttackerBuff, "", "", NULL );

  0000c	8a 45 18	 mov	 al, BYTE PTR _bTeamAttack$[ebp]
  0000f	8b 75 08	 mov	 esi, DWORD PTR _pWeapon$[ebp]
  00012	8b 7d 0c	 mov	 edi, DWORD PTR _pAttacker$[ebp]
  00015	88 45 c8	 mov	 BYTE PTR _bTeamAttack$GSCopy$[ebp], al
  00018	8b 45 1c	 mov	 eax, DWORD PTR _bEnableTeamAttack$[ebp]
  0001b	89 45 dc	 mov	 DWORD PTR _bEnableTeamAttack$GSCopy$[ebp], eax
  0001e	8b 45 20	 mov	 eax, DWORD PTR _bTeamAttackNoDamage$[ebp]
  00021	89 45 d8	 mov	 DWORD PTR _bTeamAttackNoDamage$GSCopy$[ebp], eax
  00024	8b 45 28	 mov	 eax, DWORD PTR _szFrontBackWoundBuff$[ebp]
  00027	89 45 b8	 mov	 DWORD PTR _szFrontBackWoundBuff$GSCopy$[ebp], eax
  0002a	8b 45 2c	 mov	 eax, DWORD PTR _szFrontBackAttackerBuff$[ebp]
  0002d	89 45 b4	 mov	 DWORD PTR _szFrontBackAttackerBuff$GSCopy$[ebp], eax
  00030	8b 45 30	 mov	 eax, DWORD PTR _szDefenseBreakBuff$[ebp]
  00033	89 45 bc	 mov	 DWORD PTR _szDefenseBreakBuff$GSCopy$[ebp], eax
  00036	8b 45 44	 mov	 eax, DWORD PTR _bLandStunBuff$[ebp]
  00039	89 45 c0	 mov	 DWORD PTR _bLandStunBuff$GSCopy$[ebp], eax
  0003c	8b 45 48	 mov	 eax, DWORD PTR _kAddBuffList$[ebp]
  0003f	8b d9		 mov	 ebx, ecx
  00041	89 7d d4	 mov	 DWORD PTR _pAttacker$GSCopy$[ebp], edi
  00044	89 45 c4	 mov	 DWORD PTR _kAddBuffList$GSCopy$[ebp], eax
  00047	85 f6		 test	 esi, esi
  00049	0f 84 a1 07 00
	00		 je	 $LN52@ApplyWeapo@25

; 1511 : 	if ( !pWeapon || !pAttacker )

  0004f	85 ff		 test	 edi, edi
  00051	0f 84 99 07 00
	00		 je	 $LN52@ApplyWeapo@25

; 1512 : 		return;
; 1513 : 
; 1514 : 	bTeamAttackNoDamage = pWeapon->HasFeature(WF_TEAM_ATTACK_NO_DAMAGE);

  00057	6a 20		 push	 32			; 00000020H
  00059	8b ce		 mov	 ecx, esi
  0005b	e8 00 00 00 00	 call	 ?HasFeature@ioWeapon@@QBE_NK@Z ; ioWeapon::HasFeature
  00060	8b 4d d8	 mov	 ecx, DWORD PTR _bTeamAttackNoDamage$GSCopy$[ebp]
  00063	88 01		 mov	 BYTE PTR [ecx], al

; 1515 : 	bEnableTeamAttack = IsEnableTeamAttack();

  00065	8b cb		 mov	 ecx, ebx
  00067	e8 00 00 00 00	 call	 ?IsEnableTeamAttack@ioBaseChar@@QAE_NXZ ; ioBaseChar::IsEnableTeamAttack
  0006c	8b 4d dc	 mov	 ecx, DWORD PTR _bEnableTeamAttack$GSCopy$[ebp]
  0006f	88 01		 mov	 BYTE PTR [ecx], al

; 1516 : 	bLandStunBuff = false;

  00071	8b 45 c0	 mov	 eax, DWORD PTR _bLandStunBuff$GSCopy$[ebp]
  00074	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1517 : 
; 1518 : 	D3DXVECTOR3 vRelativePos = GetWorldPosition() - pAttacker->GetWorldPosition();

  00077	8b 07		 mov	 eax, DWORD PTR [edi]
  00079	8b cf		 mov	 ecx, edi
  0007b	ff 50 70	 call	 DWORD PTR [eax+112]
  0007e	8b f8		 mov	 edi, eax
  00080	8b 03		 mov	 eax, DWORD PTR [ebx]
  00082	8b cb		 mov	 ecx, ebx
  00084	ff 50 70	 call	 DWORD PTR [eax+112]

; 1519 : 
; 1520 : 	if( bApplyPushPower && bEnableCancel )

  00087	80 7d 10 00	 cmp	 BYTE PTR _bApplyPushPower$[ebp], 0
  0008b	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0008f	f3 0f 10 0f	 movss	 xmm1, DWORD PTR [edi]
  00093	f3 0f 10 57 04	 movss	 xmm2, DWORD PTR [edi+4]
  00098	f3 0f 10 5f 08	 movss	 xmm3, DWORD PTR [edi+8]
  0009d	0f 5a c9	 cvtps2pd xmm1, xmm1
  000a0	0f 5a c0	 cvtps2pd xmm0, xmm0
  000a3	f2 0f 5c c1	 subsd	 xmm0, xmm1
  000a7	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  000ac	0f 5a d2	 cvtps2pd xmm2, xmm2
  000af	0f 5a c9	 cvtps2pd xmm1, xmm1
  000b2	f2 0f 5c ca	 subsd	 xmm1, xmm2
  000b6	f3 0f 10 50 08	 movss	 xmm2, DWORD PTR [eax+8]
  000bb	0f 5a d2	 cvtps2pd xmm2, xmm2
  000be	0f 5a db	 cvtps2pd xmm3, xmm3
  000c1	f2 0f 5c d3	 subsd	 xmm2, xmm3
  000c5	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  000c9	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  000cd	66 0f 5a d2	 cvtpd2ps xmm2, xmm2
  000d1	f3 0f 11 45 e4	 movss	 DWORD PTR _vRelativePos$[ebp], xmm0
  000d6	f3 0f 11 4d e8	 movss	 DWORD PTR _vRelativePos$[ebp+4], xmm1
  000db	f3 0f 11 55 ec	 movss	 DWORD PTR _vRelativePos$[ebp+8], xmm2
  000e0	0f 84 a8 06 00
	00		 je	 $LN51@ApplyWeapo@25
  000e6	80 7d 14 00	 cmp	 BYTE PTR _bEnableCancel$[ebp], 0
  000ea	0f 84 9e 06 00
	00		 je	 $LN51@ApplyWeapo@25

; 1521 : 	{
; 1522 : 		if( szFrontBackWoundBuff.IsEmpty() && ((!bTeamAttack || bEnableTeamAttack) || (bTeamAttack && bTeamAttackNoDamage)) )

  000f0	8b 4d b8	 mov	 ecx, DWORD PTR _szFrontBackWoundBuff$GSCopy$[ebp]
  000f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  000f9	84 c0		 test	 al, al
  000fb	0f 84 44 05 00
	00		 je	 $LN11@ApplyWeapo@25
  00101	80 7d c8 00	 cmp	 BYTE PTR _bTeamAttack$GSCopy$[ebp], 0
  00105	74 14		 je	 SHORT $LN49@ApplyWeapo@25
  00107	8b 45 dc	 mov	 eax, DWORD PTR _bEnableTeamAttack$GSCopy$[ebp]
  0010a	80 38 00	 cmp	 BYTE PTR [eax], 0
  0010d	75 0c		 jne	 SHORT $LN49@ApplyWeapo@25
  0010f	8b 45 d8	 mov	 eax, DWORD PTR _bTeamAttackNoDamage$GSCopy$[ebp]
  00112	80 38 00	 cmp	 BYTE PTR [eax], 0
  00115	0f 84 2a 05 00
	00		 je	 $LN11@ApplyWeapo@25
$LN49@ApplyWeapo@25:

; 1523 : 		{
; 1524 : 			const BuffInfoList& kAirBuffList = pWeapon->GetTargetAirBuffList();

  0011b	8b 06		 mov	 eax, DWORD PTR [esi]
  0011d	8b ce		 mov	 ecx, esi
  0011f	ff 50 64	 call	 DWORD PTR [eax+100]
  00122	8b f8		 mov	 edi, eax

; 1525 : 			int iTargetAirBuffCnt = kAirBuffList.size();

  00124	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00127	2b 07		 sub	 eax, DWORD PTR [edi]
  00129	6a 14		 push	 20			; 00000014H
  0012b	99		 cdq
  0012c	59		 pop	 ecx
  0012d	f7 f9		 idiv	 ecx

; 1526 : 
; 1527 : 			for( int i=0; i<iTargetAirBuffCnt; ++i )

  0012f	85 c0		 test	 eax, eax
  00131	0f 8e 4c 01 00
	00		 jle	 $LN46@ApplyWeapo@25

; 1523 : 		{
; 1524 : 			const BuffInfoList& kAirBuffList = pWeapon->GetTargetAirBuffList();

  00137	83 65 e0 00	 and	 DWORD PTR tv1425[ebp], 0
  0013b	89 45 cc	 mov	 DWORD PTR tv951[ebp], eax
$LL48@ApplyWeapo@25:

; 1528 : 			{
; 1529 : 				if( bAirTargetBuff && !kAirBuffList[i].m_BuffName.IsEmpty() )

  0013e	80 7d 34 00	 cmp	 BYTE PTR _bAirTargetBuff$[ebp], 0
  00142	0f 84 2e 01 00
	00		 je	 $LN47@ApplyWeapo@25
  00148	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0014a	03 4d e0	 add	 ecx, DWORD PTR tv1425[ebp]
  0014d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00153	84 c0		 test	 al, al
  00155	0f 85 1b 01 00
	00		 jne	 $LN47@ApplyWeapo@25

; 1530 : 				{
; 1531 : 					if( kAirBuffList[i].m_iBuffType == BT_FROZEN_STATUE && bPrisoner )

  0015b	8b 07		 mov	 eax, DWORD PTR [edi]
  0015d	8b 4d e0	 mov	 ecx, DWORD PTR tv1425[ebp]
  00160	8b 44 08 10	 mov	 eax, DWORD PTR [eax+ecx+16]
  00164	83 f8 08	 cmp	 eax, 8
  00167	75 0a		 jne	 SHORT $LN44@ApplyWeapo@25
  00169	80 7d 24 00	 cmp	 BYTE PTR _bPrisoner$[ebp], 0
  0016d	0f 85 03 01 00
	00		 jne	 $LN47@ApplyWeapo@25
$LN44@ApplyWeapo@25:

; 1532 : 						continue;
; 1533 : 
; 1534 : 					if( kAirBuffList[i].m_iBuffType == BT_SKIP_STUN && HasBuff( BT_HIT_COUNT_HOLD ) )

  00173	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  00176	75 11		 jne	 SHORT $LN43@ApplyWeapo@25
  00178	6a 70		 push	 112			; 00000070H
  0017a	8b cb		 mov	 ecx, ebx
  0017c	e8 00 00 00 00	 call	 ?HasBuff@ioBaseChar@@QBE_NH@Z ; ioBaseChar::HasBuff
  00181	84 c0		 test	 al, al
  00183	0f 85 ed 00 00
	00		 jne	 $LN47@ApplyWeapo@25
$LN43@ApplyWeapo@25:

; 1535 : 						continue;
; 1536 : 
; 1537 : 					ioBuff *pBuff = AddNewBuff( kAirBuffList[i].m_BuffName, pAttacker->GetCharName(), pWeapon->GetCreateItem(), NULL, bTeamAttack );

  00189	ff 75 c8	 push	 DWORD PTR _bTeamAttack$GSCopy$[ebp]
  0018c	8b 07		 mov	 eax, DWORD PTR [edi]
  0018e	8b 55 d4	 mov	 edx, DWORD PTR _pAttacker$GSCopy$[ebp]
  00191	03 45 e0	 add	 eax, DWORD PTR tv1425[ebp]
  00194	6a 00		 push	 0
  00196	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  00199	51		 push	 ecx
  0019a	81 c2 d4 02 00
	00		 add	 edx, 724		; 000002d4H
  001a0	52		 push	 edx
  001a1	50		 push	 eax
  001a2	8b cb		 mov	 ecx, ebx
  001a4	e8 00 00 00 00	 call	 ?AddNewBuff@ioBaseChar@@QAEPAVioBuff@@ABVioHashString@@00PAVioSkill@@_N@Z ; ioBaseChar::AddNewBuff
  001a9	89 45 d8	 mov	 DWORD PTR _pBuff$694268[ebp], eax

; 1538 : 					if( pBuff )

  001ac	85 c0		 test	 eax, eax
  001ae	0f 84 a7 00 00
	00		 je	 $LN42@ApplyWeapo@25

; 1539 : 					{
; 1540 : 						float fValue = 0.0f;

  001b4	0f 57 c0	 xorps	 xmm0, xmm0

; 1541 : 						ioGrowthUpInfo *pUpInfo = NULL;
; 1542 : 						ioGrowthNormalUpInfo *pNormalUpInfo = NULL;
; 1543 : 
; 1544 : 						pBuff->SetItemCode( pAttacker->GetWeaponItemCode() );

  001b7	8b 4d d4	 mov	 ecx, DWORD PTR _pAttacker$GSCopy$[ebp]
  001ba	f3 0f 11 45 dc	 movss	 DWORD PTR _fValue$694270[ebp], xmm0
  001bf	e8 00 00 00 00	 call	 ?GetWeaponItemCode@ioBaseChar@@QAEKXZ ; ioBaseChar::GetWeaponItemCode
  001c4	8b 4d d8	 mov	 ecx, DWORD PTR _pBuff$694268[ebp]
  001c7	50		 push	 eax
  001c8	e8 00 00 00 00	 call	 ?SetItemCode@ioBuff@@QAEXK@Z ; ioBuff::SetItemCode

; 1545 : 						pBuff->SetWeaponIndex( pWeapon->GetWeaponIndex() );

  001cd	8b 86 b8 04 00
	00		 mov	 eax, DWORD PTR [esi+1208]
  001d3	8b 4d d8	 mov	 ecx, DWORD PTR _pBuff$694268[ebp]
  001d6	8b 11		 mov	 edx, DWORD PTR [ecx]
  001d8	50		 push	 eax
  001d9	ff 52 40	 call	 DWORD PTR [edx+64]

; 1546 : 
; 1547 : 						if( ToAdhesiveBuff(pBuff) )

  001dc	ff 75 d8	 push	 DWORD PTR _pBuff$694268[ebp]
  001df	e8 00 00 00 00	 call	 ?ToAdhesiveBuff@@YAPAVioAdhesiveBuff@@PAVioBuff@@@Z ; ToAdhesiveBuff
  001e4	59		 pop	 ecx
  001e5	85 c0		 test	 eax, eax
  001e7	74 14		 je	 SHORT $LN41@ApplyWeapo@25

; 1548 : 						{
; 1549 : 							ToAdhesiveBuff(pBuff)->SetRelativeVector( vRelativePos );

  001e9	8d 45 e4	 lea	 eax, DWORD PTR _vRelativePos$[ebp]
  001ec	50		 push	 eax
  001ed	ff 75 d8	 push	 DWORD PTR _pBuff$694268[ebp]
  001f0	e8 00 00 00 00	 call	 ?ToAdhesiveBuff@@YAPAVioAdhesiveBuff@@PAVioBuff@@@Z ; ToAdhesiveBuff
  001f5	59		 pop	 ecx
  001f6	8b c8		 mov	 ecx, eax
  001f8	e8 00 00 00 00	 call	 ?SetRelativeVector@ioAdhesiveBuff@@QAEXAAUD3DXVECTOR3@@@Z ; ioAdhesiveBuff::SetRelativeVector
$LN41@ApplyWeapo@25:

; 1550 : 						}
; 1551 : 
; 1552 : 						pUpInfo = GetGrowthUpInfoForItem(GT_BUFF_DURATION, pAttacker->GetCharName(), pWeapon->GetCreateItem());

  001fd	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  00200	50		 push	 eax
  00201	8b 45 d4	 mov	 eax, DWORD PTR _pAttacker$GSCopy$[ebp]
  00204	05 d4 02 00 00	 add	 eax, 724		; 000002d4H
  00209	50		 push	 eax
  0020a	6a 0f		 push	 15			; 0000000fH
  0020c	8b cb		 mov	 ecx, ebx
  0020e	e8 00 00 00 00	 call	 ?GetGrowthUpInfoForItem@ioBaseChar@@QAEPAVioGrowthUpInfo@@HABVioHashString@@0@Z ; ioBaseChar::GetGrowthUpInfoForItem

; 1553 : 						pNormalUpInfo = ToNormalUpInfo(pUpInfo);

  00213	50		 push	 eax
  00214	e8 00 00 00 00	 call	 ?ToNormalUpInfo@@YAPAVioGrowthNormalUpInfo@@PAVioGrowthUpInfo@@@Z ; ToNormalUpInfo
  00219	59		 pop	 ecx

; 1554 : 						if( pNormalUpInfo )

  0021a	85 c0		 test	 eax, eax
  0021c	74 10		 je	 SHORT $LN40@ApplyWeapo@25

; 1555 : 							fValue = pNormalUpInfo->GetValue(m_pCreator);

  0021e	ff b3 44 03 00
	00		 push	 DWORD PTR [ebx+836]
  00224	8b c8		 mov	 ecx, eax
  00226	e8 00 00 00 00	 call	 ?GetValue@ioGrowthNormalUpInfo@@QAEMPAVioPlayStage@@@Z ; ioGrowthNormalUpInfo::GetValue
  0022b	d9 5d dc	 fstp	 DWORD PTR _fValue$694270[ebp]
$LN40@ApplyWeapo@25:

; 1556 : 
; 1557 : 						pBuff->SetExtraDurationByGrowth( fValue );

  0022e	8b 4d d8	 mov	 ecx, DWORD PTR _pBuff$694268[ebp]
  00231	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _fValue$694270[ebp]
  00236	8b 01		 mov	 eax, DWORD PTR [ecx]
  00238	51		 push	 ecx
  00239	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0023e	ff 50 3c	 call	 DWORD PTR [eax+60]

; 1558 : 						pBuff->SetBuffDurationByRate( pWeapon->GetOwnerChargeBuffDurationRate() );

  00241	8b ce		 mov	 ecx, esi
  00243	e8 00 00 00 00	 call	 ?GetOwnerChargeBuffDurationRate@ioWeapon@@QAEMXZ ; ioWeapon::GetOwnerChargeBuffDurationRate
  00248	51		 push	 ecx
  00249	8b 4d d8	 mov	 ecx, DWORD PTR _pBuff$694268[ebp]
  0024c	d9 1c 24	 fstp	 DWORD PTR [esp]
  0024f	e8 00 00 00 00	 call	 ?SetBuffDurationByRate@ioBuff@@QAEXM@Z ; ioBuff::SetBuffDurationByRate

; 1559 : 
; 1560 : 						kAddBuffList.push_back( kAirBuffList[i] );

  00254	8b 07		 mov	 eax, DWORD PTR [edi]
  00256	03 45 e0	 add	 eax, DWORD PTR tv1425[ebp]

; 1561 : 					}
; 1562 : 					else if( kAirBuffList[i].m_iBuffType == BT_ACCUMULATE || kAirBuffList[i].m_iBuffType == BT_SEAL_SKILL )

  00259	eb 12		 jmp	 SHORT $LN37@ApplyWeapo@25
$LN42@ApplyWeapo@25:
  0025b	8b 07		 mov	 eax, DWORD PTR [edi]
  0025d	03 45 e0	 add	 eax, DWORD PTR tv1425[ebp]
  00260	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00263	83 f9 39	 cmp	 ecx, 57			; 00000039H
  00266	74 05		 je	 SHORT $LN37@ApplyWeapo@25
  00268	83 f9 5f	 cmp	 ecx, 95			; 0000005fH
  0026b	75 09		 jne	 SHORT $LN47@ApplyWeapo@25
$LN37@ApplyWeapo@25:

; 1563 : 					{
; 1564 : 						kAddBuffList.push_back( kAirBuffList[i] );

  0026d	8b 4d c4	 mov	 ecx, DWORD PTR _kAddBuffList$GSCopy$[ebp]
  00270	50		 push	 eax
  00271	e8 00 00 00 00	 call	 ?push_back@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEXABUBuffInfoStruct@@@Z ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::push_back
$LN47@ApplyWeapo@25:

; 1526 : 
; 1527 : 			for( int i=0; i<iTargetAirBuffCnt; ++i )

  00276	83 45 e0 14	 add	 DWORD PTR tv1425[ebp], 20 ; 00000014H
  0027a	ff 4d cc	 dec	 DWORD PTR tv951[ebp]
  0027d	0f 85 bb fe ff
	ff		 jne	 $LL48@ApplyWeapo@25
$LN46@ApplyWeapo@25:

; 1565 : 					}
; 1566 : 				}
; 1567 : 			}
; 1568 : 
; 1569 : 			const BuffInfoList& kBuffList = pWeapon->GetTargetBuffList();

  00283	8b 06		 mov	 eax, DWORD PTR [esi]
  00285	8b ce		 mov	 ecx, esi
  00287	ff 50 68	 call	 DWORD PTR [eax+104]
  0028a	8b f8		 mov	 edi, eax

; 1570 : 			int iTargetBuffCnt = kBuffList.size();

  0028c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0028f	2b 07		 sub	 eax, DWORD PTR [edi]
  00291	6a 14		 push	 20			; 00000014H
  00293	99		 cdq
  00294	59		 pop	 ecx
  00295	f7 f9		 idiv	 ecx

; 1571 : 			for( int i=0; i<iTargetBuffCnt; ++i )

  00297	85 c0		 test	 eax, eax
  00299	0f 8e 49 01 00
	00		 jle	 $LN34@ApplyWeapo@25

; 1565 : 					}
; 1566 : 				}
; 1567 : 			}
; 1568 : 
; 1569 : 			const BuffInfoList& kBuffList = pWeapon->GetTargetBuffList();

  0029f	83 65 e0 00	 and	 DWORD PTR tv1451[ebp], 0
  002a3	89 45 d0	 mov	 DWORD PTR tv522[ebp], eax
$LL36@ApplyWeapo@25:

; 1572 : 			{
; 1573 : 				if( bTargetBuff && !kBuffList[i].m_BuffName.IsEmpty() )

  002a6	80 7d 38 00	 cmp	 BYTE PTR _bTargetBuff$[ebp], 0
  002aa	0f 84 2b 01 00
	00		 je	 $LN35@ApplyWeapo@25
  002b0	8b 0f		 mov	 ecx, DWORD PTR [edi]
  002b2	03 4d e0	 add	 ecx, DWORD PTR tv1451[ebp]
  002b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  002bb	84 c0		 test	 al, al
  002bd	0f 85 18 01 00
	00		 jne	 $LN35@ApplyWeapo@25

; 1574 : 				{
; 1575 : 					if( kBuffList[i].m_iBuffType == BT_FROZEN_STATUE && bPrisoner )

  002c3	8b 07		 mov	 eax, DWORD PTR [edi]
  002c5	8b 4d e0	 mov	 ecx, DWORD PTR tv1451[ebp]
  002c8	8b 44 08 10	 mov	 eax, DWORD PTR [eax+ecx+16]
  002cc	83 f8 08	 cmp	 eax, 8
  002cf	75 0a		 jne	 SHORT $LN32@ApplyWeapo@25
  002d1	80 7d 24 00	 cmp	 BYTE PTR _bPrisoner$[ebp], 0
  002d5	0f 85 00 01 00
	00		 jne	 $LN35@ApplyWeapo@25
$LN32@ApplyWeapo@25:

; 1576 : 						continue;
; 1577 : 
; 1578 : 					if( kBuffList[i].m_iBuffType == BT_SKIP_STUN && HasBuff( BT_HIT_COUNT_HOLD ) )

  002db	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  002de	75 11		 jne	 SHORT $LN31@ApplyWeapo@25
  002e0	6a 70		 push	 112			; 00000070H
  002e2	8b cb		 mov	 ecx, ebx
  002e4	e8 00 00 00 00	 call	 ?HasBuff@ioBaseChar@@QBE_NH@Z ; ioBaseChar::HasBuff
  002e9	84 c0		 test	 al, al
  002eb	0f 85 ea 00 00
	00		 jne	 $LN35@ApplyWeapo@25
$LN31@ApplyWeapo@25:

; 1579 : 						continue;
; 1580 : 
; 1581 : 					ioBuff *pBuff = AddNewBuff( kBuffList[i].m_BuffName, pAttacker->GetCharName(), pWeapon->GetCreateItem(), NULL, bTeamAttack );

  002f1	ff 75 c8	 push	 DWORD PTR _bTeamAttack$GSCopy$[ebp]
  002f4	8b 07		 mov	 eax, DWORD PTR [edi]
  002f6	8b 55 d4	 mov	 edx, DWORD PTR _pAttacker$GSCopy$[ebp]
  002f9	03 45 e0	 add	 eax, DWORD PTR tv1451[ebp]
  002fc	6a 00		 push	 0
  002fe	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  00301	51		 push	 ecx
  00302	81 c2 d4 02 00
	00		 add	 edx, 724		; 000002d4H
  00308	52		 push	 edx
  00309	50		 push	 eax
  0030a	8b cb		 mov	 ecx, ebx
  0030c	89 55 d8	 mov	 DWORD PTR tv1132[ebp], edx
  0030f	e8 00 00 00 00	 call	 ?AddNewBuff@ioBaseChar@@QAEPAVioBuff@@ABVioHashString@@00PAVioSkill@@_N@Z ; ioBaseChar::AddNewBuff
  00314	89 45 dc	 mov	 DWORD PTR _pBuff$694287[ebp], eax

; 1582 : 					if( pBuff )

  00317	85 c0		 test	 eax, eax
  00319	0f 84 a1 00 00
	00		 je	 $LN30@ApplyWeapo@25

; 1583 : 					{
; 1584 : 						float fValue = 0.0f;

  0031f	0f 57 c0	 xorps	 xmm0, xmm0

; 1585 : 						ioGrowthUpInfo *pUpInfo = NULL;
; 1586 : 						ioGrowthNormalUpInfo *pNormalUpInfo = NULL;
; 1587 : 
; 1588 : 						pBuff->SetItemCode( pAttacker->GetWeaponItemCode() );

  00322	8b 4d d4	 mov	 ecx, DWORD PTR _pAttacker$GSCopy$[ebp]
  00325	f3 0f 11 45 cc	 movss	 DWORD PTR _fValue$694289[ebp], xmm0
  0032a	e8 00 00 00 00	 call	 ?GetWeaponItemCode@ioBaseChar@@QAEKXZ ; ioBaseChar::GetWeaponItemCode
  0032f	8b 4d dc	 mov	 ecx, DWORD PTR _pBuff$694287[ebp]
  00332	50		 push	 eax
  00333	e8 00 00 00 00	 call	 ?SetItemCode@ioBuff@@QAEXK@Z ; ioBuff::SetItemCode

; 1589 : 						pBuff->SetWeaponIndex( pWeapon->GetWeaponIndex() );

  00338	8b 86 b8 04 00
	00		 mov	 eax, DWORD PTR [esi+1208]
  0033e	8b 4d dc	 mov	 ecx, DWORD PTR _pBuff$694287[ebp]
  00341	8b 11		 mov	 edx, DWORD PTR [ecx]
  00343	50		 push	 eax
  00344	ff 52 40	 call	 DWORD PTR [edx+64]

; 1590 : 
; 1591 : 						if( ToAdhesiveBuff(pBuff) )

  00347	ff 75 dc	 push	 DWORD PTR _pBuff$694287[ebp]
  0034a	e8 00 00 00 00	 call	 ?ToAdhesiveBuff@@YAPAVioAdhesiveBuff@@PAVioBuff@@@Z ; ToAdhesiveBuff
  0034f	59		 pop	 ecx
  00350	85 c0		 test	 eax, eax
  00352	74 14		 je	 SHORT $LN29@ApplyWeapo@25

; 1592 : 						{
; 1593 : 							ToAdhesiveBuff(pBuff)->SetRelativeVector( vRelativePos );

  00354	8d 45 e4	 lea	 eax, DWORD PTR _vRelativePos$[ebp]
  00357	50		 push	 eax
  00358	ff 75 dc	 push	 DWORD PTR _pBuff$694287[ebp]
  0035b	e8 00 00 00 00	 call	 ?ToAdhesiveBuff@@YAPAVioAdhesiveBuff@@PAVioBuff@@@Z ; ToAdhesiveBuff
  00360	59		 pop	 ecx
  00361	8b c8		 mov	 ecx, eax
  00363	e8 00 00 00 00	 call	 ?SetRelativeVector@ioAdhesiveBuff@@QAEXAAUD3DXVECTOR3@@@Z ; ioAdhesiveBuff::SetRelativeVector
$LN29@ApplyWeapo@25:

; 1594 : 						}
; 1595 : 
; 1596 : 						pUpInfo = GetGrowthUpInfoForItem(GT_BUFF_DURATION, pAttacker->GetCharName(), pWeapon->GetCreateItem());

  00368	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  0036b	50		 push	 eax
  0036c	ff 75 d8	 push	 DWORD PTR tv1132[ebp]
  0036f	8b cb		 mov	 ecx, ebx
  00371	6a 0f		 push	 15			; 0000000fH
  00373	e8 00 00 00 00	 call	 ?GetGrowthUpInfoForItem@ioBaseChar@@QAEPAVioGrowthUpInfo@@HABVioHashString@@0@Z ; ioBaseChar::GetGrowthUpInfoForItem

; 1597 : 						pNormalUpInfo = ToNormalUpInfo(pUpInfo);

  00378	50		 push	 eax
  00379	e8 00 00 00 00	 call	 ?ToNormalUpInfo@@YAPAVioGrowthNormalUpInfo@@PAVioGrowthUpInfo@@@Z ; ToNormalUpInfo
  0037e	59		 pop	 ecx

; 1598 : 						if( pNormalUpInfo )

  0037f	85 c0		 test	 eax, eax
  00381	74 10		 je	 SHORT $LN28@ApplyWeapo@25

; 1599 : 							fValue = pNormalUpInfo->GetValue(m_pCreator);

  00383	ff b3 44 03 00
	00		 push	 DWORD PTR [ebx+836]
  00389	8b c8		 mov	 ecx, eax
  0038b	e8 00 00 00 00	 call	 ?GetValue@ioGrowthNormalUpInfo@@QAEMPAVioPlayStage@@@Z ; ioGrowthNormalUpInfo::GetValue
  00390	d9 5d cc	 fstp	 DWORD PTR _fValue$694289[ebp]
$LN28@ApplyWeapo@25:

; 1600 : 
; 1601 : 						pBuff->SetExtraDurationByGrowth( fValue );

  00393	8b 4d dc	 mov	 ecx, DWORD PTR _pBuff$694287[ebp]
  00396	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _fValue$694289[ebp]
  0039b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0039d	51		 push	 ecx
  0039e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003a3	ff 50 3c	 call	 DWORD PTR [eax+60]

; 1602 : 						pBuff->SetBuffDurationByRate( pWeapon->GetOwnerChargeBuffDurationRate() );

  003a6	8b ce		 mov	 ecx, esi
  003a8	e8 00 00 00 00	 call	 ?GetOwnerChargeBuffDurationRate@ioWeapon@@QAEMXZ ; ioWeapon::GetOwnerChargeBuffDurationRate
  003ad	51		 push	 ecx
  003ae	8b 4d dc	 mov	 ecx, DWORD PTR _pBuff$694287[ebp]
  003b1	d9 1c 24	 fstp	 DWORD PTR [esp]
  003b4	e8 00 00 00 00	 call	 ?SetBuffDurationByRate@ioBuff@@QAEXM@Z ; ioBuff::SetBuffDurationByRate

; 1603 : 
; 1604 : 						kAddBuffList.push_back( kBuffList[i] );

  003b9	8b 07		 mov	 eax, DWORD PTR [edi]
  003bb	03 45 e0	 add	 eax, DWORD PTR tv1451[ebp]

; 1605 : 					}
; 1606 : 					else if( kBuffList[i].m_iBuffType == BT_ACCUMULATE || kBuffList[i].m_iBuffType == BT_SEAL_SKILL )

  003be	eb 12		 jmp	 SHORT $LN25@ApplyWeapo@25
$LN30@ApplyWeapo@25:
  003c0	8b 07		 mov	 eax, DWORD PTR [edi]
  003c2	03 45 e0	 add	 eax, DWORD PTR tv1451[ebp]
  003c5	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  003c8	83 f9 39	 cmp	 ecx, 57			; 00000039H
  003cb	74 05		 je	 SHORT $LN25@ApplyWeapo@25
  003cd	83 f9 5f	 cmp	 ecx, 95			; 0000005fH
  003d0	75 09		 jne	 SHORT $LN35@ApplyWeapo@25
$LN25@ApplyWeapo@25:

; 1607 : 					{
; 1608 : 						kAddBuffList.push_back( kBuffList[i] );

  003d2	8b 4d c4	 mov	 ecx, DWORD PTR _kAddBuffList$GSCopy$[ebp]
  003d5	50		 push	 eax
  003d6	e8 00 00 00 00	 call	 ?push_back@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEXABUBuffInfoStruct@@@Z ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::push_back
$LN35@ApplyWeapo@25:

; 1571 : 			for( int i=0; i<iTargetBuffCnt; ++i )

  003db	83 45 e0 14	 add	 DWORD PTR tv1451[ebp], 20 ; 00000014H
  003df	ff 4d d0	 dec	 DWORD PTR tv522[ebp]
  003e2	0f 85 be fe ff
	ff		 jne	 $LL36@ApplyWeapo@25
$LN34@ApplyWeapo@25:

; 1609 : 					}
; 1610 : 				}
; 1611 : 			}
; 1612 : 
; 1613 : 			const BuffInfoList& kDownBuffList = pWeapon->GetTargetDownBuffList();

  003e8	8b 06		 mov	 eax, DWORD PTR [esi]
  003ea	8b ce		 mov	 ecx, esi
  003ec	ff 50 6c	 call	 DWORD PTR [eax+108]
  003ef	8b f8		 mov	 edi, eax

; 1614 : 			int iTargetDownBuffCnt = kDownBuffList.size();

  003f1	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  003f4	2b 07		 sub	 eax, DWORD PTR [edi]
  003f6	6a 14		 push	 20			; 00000014H
  003f8	99		 cdq
  003f9	59		 pop	 ecx
  003fa	f7 f9		 idiv	 ecx

; 1615 : 
; 1616 : 			for( int i=0; i<iTargetDownBuffCnt; ++i )

  003fc	85 c0		 test	 eax, eax
  003fe	0f 8e 49 01 00
	00		 jle	 $LN22@ApplyWeapo@25

; 1609 : 					}
; 1610 : 				}
; 1611 : 			}
; 1612 : 
; 1613 : 			const BuffInfoList& kDownBuffList = pWeapon->GetTargetDownBuffList();

  00404	83 65 e0 00	 and	 DWORD PTR tv1477[ebp], 0
  00408	89 45 cc	 mov	 DWORD PTR tv910[ebp], eax
$LL24@ApplyWeapo@25:

; 1617 : 			{
; 1618 : 				if( bDownTargetBuff && !kDownBuffList[i].m_BuffName.IsEmpty() )

  0040b	80 7d 3c 00	 cmp	 BYTE PTR _bDownTargetBuff$[ebp], 0
  0040f	0f 84 2b 01 00
	00		 je	 $LN23@ApplyWeapo@25
  00415	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00417	03 4d e0	 add	 ecx, DWORD PTR tv1477[ebp]
  0041a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00420	84 c0		 test	 al, al
  00422	0f 85 18 01 00
	00		 jne	 $LN23@ApplyWeapo@25

; 1619 : 				{
; 1620 : 					if( kDownBuffList[i].m_iBuffType == BT_FROZEN_STATUE && bPrisoner )

  00428	8b 07		 mov	 eax, DWORD PTR [edi]
  0042a	8b 4d e0	 mov	 ecx, DWORD PTR tv1477[ebp]
  0042d	8b 44 01 10	 mov	 eax, DWORD PTR [ecx+eax+16]
  00431	83 f8 08	 cmp	 eax, 8
  00434	75 0a		 jne	 SHORT $LN20@ApplyWeapo@25
  00436	80 7d 24 00	 cmp	 BYTE PTR _bPrisoner$[ebp], 0
  0043a	0f 85 00 01 00
	00		 jne	 $LN23@ApplyWeapo@25
$LN20@ApplyWeapo@25:

; 1621 : 						continue;
; 1622 : 
; 1623 : 					if( kDownBuffList[i].m_iBuffType == BT_SKIP_STUN && HasBuff( BT_HIT_COUNT_HOLD ) )

  00440	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  00443	75 11		 jne	 SHORT $LN19@ApplyWeapo@25
  00445	6a 70		 push	 112			; 00000070H
  00447	8b cb		 mov	 ecx, ebx
  00449	e8 00 00 00 00	 call	 ?HasBuff@ioBaseChar@@QBE_NH@Z ; ioBaseChar::HasBuff
  0044e	84 c0		 test	 al, al
  00450	0f 85 ea 00 00
	00		 jne	 $LN23@ApplyWeapo@25
$LN19@ApplyWeapo@25:

; 1624 : 						continue;
; 1625 : 
; 1626 : 					ioBuff *pBuff = AddNewBuff( kDownBuffList[i].m_BuffName, pAttacker->GetCharName(), pWeapon->GetCreateItem(), NULL, bTeamAttack );

  00456	ff 75 c8	 push	 DWORD PTR _bTeamAttack$GSCopy$[ebp]
  00459	8b 07		 mov	 eax, DWORD PTR [edi]
  0045b	8b 55 d4	 mov	 edx, DWORD PTR _pAttacker$GSCopy$[ebp]
  0045e	03 45 e0	 add	 eax, DWORD PTR tv1477[ebp]
  00461	6a 00		 push	 0
  00463	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  00466	51		 push	 ecx
  00467	81 c2 d4 02 00
	00		 add	 edx, 724		; 000002d4H
  0046d	52		 push	 edx
  0046e	50		 push	 eax
  0046f	8b cb		 mov	 ecx, ebx
  00471	89 55 d8	 mov	 DWORD PTR tv1132[ebp], edx
  00474	e8 00 00 00 00	 call	 ?AddNewBuff@ioBaseChar@@QAEPAVioBuff@@ABVioHashString@@00PAVioSkill@@_N@Z ; ioBaseChar::AddNewBuff
  00479	89 45 dc	 mov	 DWORD PTR _pBuff$694306[ebp], eax

; 1627 : 					if( pBuff )

  0047c	85 c0		 test	 eax, eax
  0047e	0f 84 a1 00 00
	00		 je	 $LN18@ApplyWeapo@25

; 1628 : 					{
; 1629 : 						float fValue = 0.0f;

  00484	0f 57 c0	 xorps	 xmm0, xmm0

; 1630 : 						ioGrowthUpInfo *pUpInfo = NULL;
; 1631 : 						ioGrowthNormalUpInfo *pNormalUpInfo = NULL;
; 1632 : 
; 1633 : 						pBuff->SetItemCode( pAttacker->GetWeaponItemCode() );

  00487	8b 4d d4	 mov	 ecx, DWORD PTR _pAttacker$GSCopy$[ebp]
  0048a	f3 0f 11 45 d0	 movss	 DWORD PTR _fValue$694308[ebp], xmm0
  0048f	e8 00 00 00 00	 call	 ?GetWeaponItemCode@ioBaseChar@@QAEKXZ ; ioBaseChar::GetWeaponItemCode
  00494	8b 4d dc	 mov	 ecx, DWORD PTR _pBuff$694306[ebp]
  00497	50		 push	 eax
  00498	e8 00 00 00 00	 call	 ?SetItemCode@ioBuff@@QAEXK@Z ; ioBuff::SetItemCode

; 1634 : 						pBuff->SetWeaponIndex( pWeapon->GetWeaponIndex() );

  0049d	8b 86 b8 04 00
	00		 mov	 eax, DWORD PTR [esi+1208]
  004a3	8b 4d dc	 mov	 ecx, DWORD PTR _pBuff$694306[ebp]
  004a6	8b 11		 mov	 edx, DWORD PTR [ecx]
  004a8	50		 push	 eax
  004a9	ff 52 40	 call	 DWORD PTR [edx+64]

; 1635 : 
; 1636 : 						if( ToAdhesiveBuff(pBuff) )

  004ac	ff 75 dc	 push	 DWORD PTR _pBuff$694306[ebp]
  004af	e8 00 00 00 00	 call	 ?ToAdhesiveBuff@@YAPAVioAdhesiveBuff@@PAVioBuff@@@Z ; ToAdhesiveBuff
  004b4	59		 pop	 ecx
  004b5	85 c0		 test	 eax, eax
  004b7	74 14		 je	 SHORT $LN17@ApplyWeapo@25

; 1637 : 						{
; 1638 : 							ToAdhesiveBuff(pBuff)->SetRelativeVector( vRelativePos );

  004b9	8d 45 e4	 lea	 eax, DWORD PTR _vRelativePos$[ebp]
  004bc	50		 push	 eax
  004bd	ff 75 dc	 push	 DWORD PTR _pBuff$694306[ebp]
  004c0	e8 00 00 00 00	 call	 ?ToAdhesiveBuff@@YAPAVioAdhesiveBuff@@PAVioBuff@@@Z ; ToAdhesiveBuff
  004c5	59		 pop	 ecx
  004c6	8b c8		 mov	 ecx, eax
  004c8	e8 00 00 00 00	 call	 ?SetRelativeVector@ioAdhesiveBuff@@QAEXAAUD3DXVECTOR3@@@Z ; ioAdhesiveBuff::SetRelativeVector
$LN17@ApplyWeapo@25:

; 1639 : 						}
; 1640 : 
; 1641 : 						pUpInfo = GetGrowthUpInfoForItem(GT_BUFF_DURATION, pAttacker->GetCharName(), pWeapon->GetCreateItem());

  004cd	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  004d0	50		 push	 eax
  004d1	ff 75 d8	 push	 DWORD PTR tv1132[ebp]
  004d4	8b cb		 mov	 ecx, ebx
  004d6	6a 0f		 push	 15			; 0000000fH
  004d8	e8 00 00 00 00	 call	 ?GetGrowthUpInfoForItem@ioBaseChar@@QAEPAVioGrowthUpInfo@@HABVioHashString@@0@Z ; ioBaseChar::GetGrowthUpInfoForItem

; 1642 : 						pNormalUpInfo = ToNormalUpInfo(pUpInfo);

  004dd	50		 push	 eax
  004de	e8 00 00 00 00	 call	 ?ToNormalUpInfo@@YAPAVioGrowthNormalUpInfo@@PAVioGrowthUpInfo@@@Z ; ToNormalUpInfo
  004e3	59		 pop	 ecx

; 1643 : 						if( pNormalUpInfo )

  004e4	85 c0		 test	 eax, eax
  004e6	74 10		 je	 SHORT $LN16@ApplyWeapo@25

; 1644 : 							fValue = pNormalUpInfo->GetValue(m_pCreator);

  004e8	ff b3 44 03 00
	00		 push	 DWORD PTR [ebx+836]
  004ee	8b c8		 mov	 ecx, eax
  004f0	e8 00 00 00 00	 call	 ?GetValue@ioGrowthNormalUpInfo@@QAEMPAVioPlayStage@@@Z ; ioGrowthNormalUpInfo::GetValue
  004f5	d9 5d d0	 fstp	 DWORD PTR _fValue$694308[ebp]
$LN16@ApplyWeapo@25:

; 1645 : 
; 1646 : 						pBuff->SetExtraDurationByGrowth( fValue );

  004f8	8b 4d dc	 mov	 ecx, DWORD PTR _pBuff$694306[ebp]
  004fb	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _fValue$694308[ebp]
  00500	8b 01		 mov	 eax, DWORD PTR [ecx]
  00502	51		 push	 ecx
  00503	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00508	ff 50 3c	 call	 DWORD PTR [eax+60]

; 1647 : 						pBuff->SetBuffDurationByRate( pWeapon->GetOwnerChargeBuffDurationRate() );

  0050b	8b ce		 mov	 ecx, esi
  0050d	e8 00 00 00 00	 call	 ?GetOwnerChargeBuffDurationRate@ioWeapon@@QAEMXZ ; ioWeapon::GetOwnerChargeBuffDurationRate
  00512	51		 push	 ecx
  00513	8b 4d dc	 mov	 ecx, DWORD PTR _pBuff$694306[ebp]
  00516	d9 1c 24	 fstp	 DWORD PTR [esp]
  00519	e8 00 00 00 00	 call	 ?SetBuffDurationByRate@ioBuff@@QAEXM@Z ; ioBuff::SetBuffDurationByRate

; 1648 : 
; 1649 : 						kAddBuffList.push_back( kDownBuffList[i] );

  0051e	8b 07		 mov	 eax, DWORD PTR [edi]
  00520	03 45 e0	 add	 eax, DWORD PTR tv1477[ebp]

; 1650 : 					}
; 1651 : 					else if( kDownBuffList[i].m_iBuffType == BT_ACCUMULATE || kDownBuffList[i].m_iBuffType == BT_SEAL_SKILL )

  00523	eb 12		 jmp	 SHORT $LN13@ApplyWeapo@25
$LN18@ApplyWeapo@25:
  00525	8b 07		 mov	 eax, DWORD PTR [edi]
  00527	03 45 e0	 add	 eax, DWORD PTR tv1477[ebp]
  0052a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0052d	83 f9 39	 cmp	 ecx, 57			; 00000039H
  00530	74 05		 je	 SHORT $LN13@ApplyWeapo@25
  00532	83 f9 5f	 cmp	 ecx, 95			; 0000005fH
  00535	75 09		 jne	 SHORT $LN23@ApplyWeapo@25
$LN13@ApplyWeapo@25:

; 1652 : 					{
; 1653 : 						kAddBuffList.push_back( kDownBuffList[i] );

  00537	8b 4d c4	 mov	 ecx, DWORD PTR _kAddBuffList$GSCopy$[ebp]
  0053a	50		 push	 eax
  0053b	e8 00 00 00 00	 call	 ?push_back@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEXABUBuffInfoStruct@@@Z ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::push_back
$LN23@ApplyWeapo@25:

; 1615 : 
; 1616 : 			for( int i=0; i<iTargetDownBuffCnt; ++i )

  00540	83 45 e0 14	 add	 DWORD PTR tv1477[ebp], 20 ; 00000014H
  00544	ff 4d cc	 dec	 DWORD PTR tv910[ebp]
  00547	0f 85 be fe ff
	ff		 jne	 $LL24@ApplyWeapo@25
$LN22@ApplyWeapo@25:

; 1654 : 					}
; 1655 : 				}
; 1656 : 			}
; 1657 : 
; 1658 : 			if( pAttacker->HasBuff(BT_DEFENSE_BREAK_BUFF) &&
; 1659 : 				pWeapon->IsDefenseBreakBuff() &&
; 1660 : 				!pWeapon->GetDefenseBreakBuff().IsEmpty() )				

  0054d	8b 4d d4	 mov	 ecx, DWORD PTR _pAttacker$GSCopy$[ebp]
  00550	6a 3d		 push	 61			; 0000003dH
  00552	e8 00 00 00 00	 call	 ?HasBuff@ioBaseChar@@QBE_NH@Z ; ioBaseChar::HasBuff
  00557	84 c0		 test	 al, al
  00559	0f 84 e6 00 00
	00		 je	 $LN11@ApplyWeapo@25
  0055f	8b ce		 mov	 ecx, esi
  00561	e8 00 00 00 00	 call	 ?IsDefenseBreakBuff@ioWeapon@@QBE_NXZ ; ioWeapon::IsDefenseBreakBuff
  00566	84 c0		 test	 al, al
  00568	0f 84 d7 00 00
	00		 je	 $LN11@ApplyWeapo@25
  0056e	8b ce		 mov	 ecx, esi
  00570	e8 00 00 00 00	 call	 ?GetDefenseBreakBuff@ioWeapon@@QBEABVioHashString@@XZ ; ioWeapon::GetDefenseBreakBuff
  00575	8b c8		 mov	 ecx, eax
  00577	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  0057d	84 c0		 test	 al, al
  0057f	0f 85 c0 00 00
	00		 jne	 $LN11@ApplyWeapo@25

; 1661 : 			{
; 1662 : 				ioBuff *pBreakBuff = AddNewBuff( pWeapon->GetDefenseBreakBuff(), pAttacker->GetCharName(), pWeapon->GetCreateItem(), NULL, bTeamAttack );

  00585	ff 75 c8	 push	 DWORD PTR _bTeamAttack$GSCopy$[ebp]
  00588	8b 4d d4	 mov	 ecx, DWORD PTR _pAttacker$GSCopy$[ebp]
  0058b	6a 00		 push	 0
  0058d	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  00590	81 c1 d4 02 00
	00		 add	 ecx, 724		; 000002d4H
  00596	50		 push	 eax
  00597	89 4d d8	 mov	 DWORD PTR tv1132[ebp], ecx
  0059a	51		 push	 ecx
  0059b	8b ce		 mov	 ecx, esi
  0059d	e8 00 00 00 00	 call	 ?GetDefenseBreakBuff@ioWeapon@@QBEABVioHashString@@XZ ; ioWeapon::GetDefenseBreakBuff
  005a2	50		 push	 eax
  005a3	8b cb		 mov	 ecx, ebx
  005a5	e8 00 00 00 00	 call	 ?AddNewBuff@ioBaseChar@@QAEPAVioBuff@@ABVioHashString@@00PAVioSkill@@_N@Z ; ioBaseChar::AddNewBuff
  005aa	8b f8		 mov	 edi, eax

; 1663 : 				if( pBreakBuff )

  005ac	85 ff		 test	 edi, edi
  005ae	0f 84 91 00 00
	00		 je	 $LN11@ApplyWeapo@25

; 1664 : 				{
; 1665 : 					float fValue = 0.0f;

  005b4	0f 57 c0	 xorps	 xmm0, xmm0

; 1666 : 					ioGrowthUpInfo *pUpInfo = NULL;
; 1667 : 					ioGrowthNormalUpInfo *pNormalUpInfo = NULL;
; 1668 : 
; 1669 : 					pBreakBuff->SetItemCode( pAttacker->GetWeaponItemCode() );

  005b7	8b 4d d4	 mov	 ecx, DWORD PTR _pAttacker$GSCopy$[ebp]
  005ba	f3 0f 11 45 d0	 movss	 DWORD PTR _fValue$694319[ebp], xmm0
  005bf	e8 00 00 00 00	 call	 ?GetWeaponItemCode@ioBaseChar@@QAEKXZ ; ioBaseChar::GetWeaponItemCode
  005c4	50		 push	 eax
  005c5	8b cf		 mov	 ecx, edi
  005c7	e8 00 00 00 00	 call	 ?SetItemCode@ioBuff@@QAEXK@Z ; ioBuff::SetItemCode

; 1670 : 					pBreakBuff->SetWeaponIndex( pWeapon->GetWeaponIndex() );

  005cc	8b 86 b8 04 00
	00		 mov	 eax, DWORD PTR [esi+1208]
  005d2	8b 17		 mov	 edx, DWORD PTR [edi]
  005d4	50		 push	 eax
  005d5	8b cf		 mov	 ecx, edi
  005d7	ff 52 40	 call	 DWORD PTR [edx+64]

; 1671 : 
; 1672 : 					if( ToAdhesiveBuff(pBreakBuff) )

  005da	57		 push	 edi
  005db	e8 00 00 00 00	 call	 ?ToAdhesiveBuff@@YAPAVioAdhesiveBuff@@PAVioBuff@@@Z ; ToAdhesiveBuff
  005e0	59		 pop	 ecx
  005e1	85 c0		 test	 eax, eax
  005e3	74 12		 je	 SHORT $LN10@ApplyWeapo@25

; 1673 : 					{
; 1674 : 						ToAdhesiveBuff(pBreakBuff)->SetRelativeVector( vRelativePos );

  005e5	8d 45 e4	 lea	 eax, DWORD PTR _vRelativePos$[ebp]
  005e8	50		 push	 eax
  005e9	57		 push	 edi
  005ea	e8 00 00 00 00	 call	 ?ToAdhesiveBuff@@YAPAVioAdhesiveBuff@@PAVioBuff@@@Z ; ToAdhesiveBuff
  005ef	59		 pop	 ecx
  005f0	8b c8		 mov	 ecx, eax
  005f2	e8 00 00 00 00	 call	 ?SetRelativeVector@ioAdhesiveBuff@@QAEXAAUD3DXVECTOR3@@@Z ; ioAdhesiveBuff::SetRelativeVector
$LN10@ApplyWeapo@25:

; 1675 : 					}
; 1676 : 
; 1677 : 					pUpInfo = GetGrowthUpInfoForItem(GT_BUFF_DURATION, pAttacker->GetCharName(), pWeapon->GetCreateItem());

  005f7	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  005fa	50		 push	 eax
  005fb	ff 75 d8	 push	 DWORD PTR tv1132[ebp]
  005fe	8b cb		 mov	 ecx, ebx
  00600	6a 0f		 push	 15			; 0000000fH
  00602	e8 00 00 00 00	 call	 ?GetGrowthUpInfoForItem@ioBaseChar@@QAEPAVioGrowthUpInfo@@HABVioHashString@@0@Z ; ioBaseChar::GetGrowthUpInfoForItem

; 1678 : 					pNormalUpInfo = ToNormalUpInfo(pUpInfo);

  00607	50		 push	 eax
  00608	e8 00 00 00 00	 call	 ?ToNormalUpInfo@@YAPAVioGrowthNormalUpInfo@@PAVioGrowthUpInfo@@@Z ; ToNormalUpInfo
  0060d	59		 pop	 ecx

; 1679 : 					if( pNormalUpInfo )

  0060e	85 c0		 test	 eax, eax
  00610	74 10		 je	 SHORT $LN9@ApplyWeapo@25

; 1680 : 						fValue = pNormalUpInfo->GetValue(m_pCreator);

  00612	ff b3 44 03 00
	00		 push	 DWORD PTR [ebx+836]
  00618	8b c8		 mov	 ecx, eax
  0061a	e8 00 00 00 00	 call	 ?GetValue@ioGrowthNormalUpInfo@@QAEMPAVioPlayStage@@@Z ; ioGrowthNormalUpInfo::GetValue
  0061f	d9 5d d0	 fstp	 DWORD PTR _fValue$694319[ebp]
$LN9@ApplyWeapo@25:

; 1681 : 
; 1682 : 					pBreakBuff->SetExtraDurationByGrowth( fValue );

  00622	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _fValue$694319[ebp]
  00627	8b 07		 mov	 eax, DWORD PTR [edi]
  00629	51		 push	 ecx
  0062a	8b cf		 mov	 ecx, edi
  0062c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00631	ff 50 3c	 call	 DWORD PTR [eax+60]

; 1683 : 
; 1684 : 					szDefenseBreakBuff = pWeapon->GetDefenseBreakBuff();

  00634	8b ce		 mov	 ecx, esi
  00636	e8 00 00 00 00	 call	 ?GetDefenseBreakBuff@ioWeapon@@QBEABVioHashString@@XZ ; ioWeapon::GetDefenseBreakBuff
  0063b	8b 4d bc	 mov	 ecx, DWORD PTR _szDefenseBreakBuff$GSCopy$[ebp]
  0063e	50		 push	 eax
  0063f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@ABV0@@Z
$LN11@ApplyWeapo@25:

; 1685 : 				}
; 1686 : 			}
; 1687 : 		}
; 1688 : 
; 1689 : 		bool bPreLandStunCheck = false;
; 1690 : 		if( GetTeam() != pWeapon->GetTeam() && CheckLandStunBuff( pWeapon ) )

  00645	8d 45 bc	 lea	 eax, DWORD PTR _value$702469[ebp]
  00648	8d 8b 90 00 00
	00		 lea	 ecx, DWORD PTR [ebx+144]
  0064e	50		 push	 eax
  0064f	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  00654	8d 45 d0	 lea	 eax, DWORD PTR _value$702484[ebp]
  00657	8d 4e 30	 lea	 ecx, DWORD PTR [esi+48]
  0065a	50		 push	 eax
  0065b	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  00660	8b 45 bc	 mov	 eax, DWORD PTR _value$702469[ebp]
  00663	3b 45 d0	 cmp	 eax, DWORD PTR _value$702484[ebp]
  00666	74 68		 je	 SHORT $LN7@ApplyWeapo@25
  00668	56		 push	 esi
  00669	8b cb		 mov	 ecx, ebx
  0066b	e8 00 00 00 00	 call	 ?CheckLandStunBuff@ioBaseChar@@QAE_NPAVioWeapon@@@Z ; ioBaseChar::CheckLandStunBuff
  00670	84 c0		 test	 al, al
  00672	74 5c		 je	 SHORT $LN7@ApplyWeapo@25

; 1691 : 			bPreLandStunCheck = true;
; 1692 : 
; 1693 : 		if( bPreLandStunCheck && eBreakType == DBT_NONE && !m_vLandStunInfoList.empty() )

  00674	83 7d 40 00	 cmp	 DWORD PTR _eBreakType$[ebp], 0
  00678	75 56		 jne	 SHORT $LN7@ApplyWeapo@25
  0067a	8b 83 d8 1b 00
	00		 mov	 eax, DWORD PTR [ebx+7128]
  00680	3b 83 dc 1b 00
	00		 cmp	 eax, DWORD PTR [ebx+7132]
  00686	74 48		 je	 SHORT $LN7@ApplyWeapo@25

; 1694 : 		{
; 1695 : 			SetCurJumpPowerAmt( 0.0f );

  00688	0f 57 c0	 xorps	 xmm0, xmm0

; 1696 : 			SetGravityAmt( 0.0f );

  0068b	8d 45 bc	 lea	 eax, DWORD PTR _value$702502[ebp]
  0068e	50		 push	 eax
  0068f	8d 8b e8 0b 00
	00		 lea	 ecx, DWORD PTR [ebx+3048]
  00695	f3 0f 11 83 90
	0e 00 00	 movss	 DWORD PTR [ebx+3728], xmm0
  0069d	f3 0f 11 45 bc	 movss	 DWORD PTR _value$702502[ebp], xmm0
  006a2	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 1697 : 
; 1698 : 			AddNewBuff( m_vLandStunInfoList[0].m_StunBuff, pAttacker->GetCharName(), pWeapon->GetCreateItem(), NULL, bTeamAttack );

  006a7	ff 75 c8	 push	 DWORD PTR _bTeamAttack$GSCopy$[ebp]
  006aa	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  006ad	6a 00		 push	 0
  006af	50		 push	 eax
  006b0	8b 45 d4	 mov	 eax, DWORD PTR _pAttacker$GSCopy$[ebp]
  006b3	05 d4 02 00 00	 add	 eax, 724		; 000002d4H
  006b8	50		 push	 eax
  006b9	8b 83 d8 1b 00
	00		 mov	 eax, DWORD PTR [ebx+7128]
  006bf	83 c0 10	 add	 eax, 16			; 00000010H
  006c2	50		 push	 eax
  006c3	8b cb		 mov	 ecx, ebx
  006c5	e8 00 00 00 00	 call	 ?AddNewBuff@ioBaseChar@@QAEPAVioBuff@@ABVioHashString@@00PAVioSkill@@_N@Z ; ioBaseChar::AddNewBuff

; 1699 : 			bLandStunBuff = true;

  006ca	8b 45 c0	 mov	 eax, DWORD PTR _bLandStunBuff$GSCopy$[ebp]
  006cd	c6 00 01	 mov	 BYTE PTR [eax], 1
$LN7@ApplyWeapo@25:

; 1700 : 		}
; 1701 : 
; 1702 : 		// FrontBack
; 1703 : 		if( !szFrontBackWoundBuff.IsEmpty() )

  006d0	8b 4d b8	 mov	 ecx, DWORD PTR _szFrontBackWoundBuff$GSCopy$[ebp]
  006d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  006d9	84 c0		 test	 al, al
  006db	0f 85 b6 00 00
	00		 jne	 $LN2@ApplyWeapo@25

; 1704 : 		{
; 1705 : 			ioBuff *pBuff = AddNewBuff( szFrontBackWoundBuff, pAttacker->GetCharName(), pWeapon->GetCreateItem(), NULL, bTeamAttack );

  006e1	ff 75 c8	 push	 DWORD PTR _bTeamAttack$GSCopy$[ebp]
  006e4	8b 45 d4	 mov	 eax, DWORD PTR _pAttacker$GSCopy$[ebp]
  006e7	6a 00		 push	 0
  006e9	8d 7e 20	 lea	 edi, DWORD PTR [esi+32]
  006ec	05 d4 02 00 00	 add	 eax, 724		; 000002d4H
  006f1	57		 push	 edi
  006f2	50		 push	 eax
  006f3	ff 75 b8	 push	 DWORD PTR _szFrontBackWoundBuff$GSCopy$[ebp]
  006f6	8b cb		 mov	 ecx, ebx
  006f8	89 45 d8	 mov	 DWORD PTR tv1132[ebp], eax
  006fb	e8 00 00 00 00	 call	 ?AddNewBuff@ioBaseChar@@QAEPAVioBuff@@ABVioHashString@@00PAVioSkill@@_N@Z ; ioBaseChar::AddNewBuff
  00700	89 45 c0	 mov	 DWORD PTR _pBuff$694328[ebp], eax

; 1706 : 			if( pBuff )

  00703	85 c0		 test	 eax, eax
  00705	0f 84 8c 00 00
	00		 je	 $LN2@ApplyWeapo@25

; 1707 : 			{
; 1708 : 				float fValue = 0.0f;

  0070b	0f 57 c0	 xorps	 xmm0, xmm0

; 1709 : 				ioGrowthUpInfo *pUpInfo = NULL;
; 1710 : 				ioGrowthNormalUpInfo *pNormalUpInfo = NULL;
; 1711 : 
; 1712 : 				pBuff->SetItemCode( pAttacker->GetWeaponItemCode() );

  0070e	8b 4d d4	 mov	 ecx, DWORD PTR _pAttacker$GSCopy$[ebp]
  00711	f3 0f 11 45 d0	 movss	 DWORD PTR _fValue$694330[ebp], xmm0
  00716	e8 00 00 00 00	 call	 ?GetWeaponItemCode@ioBaseChar@@QAEKXZ ; ioBaseChar::GetWeaponItemCode
  0071b	8b 4d c0	 mov	 ecx, DWORD PTR _pBuff$694328[ebp]
  0071e	50		 push	 eax
  0071f	e8 00 00 00 00	 call	 ?SetItemCode@ioBuff@@QAEXK@Z ; ioBuff::SetItemCode

; 1713 : 				pBuff->SetWeaponIndex( pWeapon->GetWeaponIndex() );

  00724	8b 86 b8 04 00
	00		 mov	 eax, DWORD PTR [esi+1208]
  0072a	8b 75 c0	 mov	 esi, DWORD PTR _pBuff$694328[ebp]
  0072d	8b 16		 mov	 edx, DWORD PTR [esi]
  0072f	50		 push	 eax
  00730	8b ce		 mov	 ecx, esi
  00732	ff 52 40	 call	 DWORD PTR [edx+64]

; 1714 : 
; 1715 : 				if( ToAdhesiveBuff(pBuff) )

  00735	56		 push	 esi
  00736	e8 00 00 00 00	 call	 ?ToAdhesiveBuff@@YAPAVioAdhesiveBuff@@PAVioBuff@@@Z ; ToAdhesiveBuff
  0073b	59		 pop	 ecx
  0073c	85 c0		 test	 eax, eax
  0073e	74 12		 je	 SHORT $LN4@ApplyWeapo@25

; 1716 : 				{
; 1717 : 					ToAdhesiveBuff(pBuff)->SetRelativeVector( vRelativePos );

  00740	8d 45 e4	 lea	 eax, DWORD PTR _vRelativePos$[ebp]
  00743	50		 push	 eax
  00744	56		 push	 esi
  00745	e8 00 00 00 00	 call	 ?ToAdhesiveBuff@@YAPAVioAdhesiveBuff@@PAVioBuff@@@Z ; ToAdhesiveBuff
  0074a	59		 pop	 ecx
  0074b	8b c8		 mov	 ecx, eax
  0074d	e8 00 00 00 00	 call	 ?SetRelativeVector@ioAdhesiveBuff@@QAEXAAUD3DXVECTOR3@@@Z ; ioAdhesiveBuff::SetRelativeVector
$LN4@ApplyWeapo@25:

; 1718 : 				}
; 1719 : 
; 1720 : 				pUpInfo = GetGrowthUpInfoForItem(GT_BUFF_DURATION, pAttacker->GetCharName(), pWeapon->GetCreateItem());

  00752	57		 push	 edi
  00753	ff 75 d8	 push	 DWORD PTR tv1132[ebp]
  00756	8b cb		 mov	 ecx, ebx
  00758	6a 0f		 push	 15			; 0000000fH
  0075a	e8 00 00 00 00	 call	 ?GetGrowthUpInfoForItem@ioBaseChar@@QAEPAVioGrowthUpInfo@@HABVioHashString@@0@Z ; ioBaseChar::GetGrowthUpInfoForItem

; 1721 : 				pNormalUpInfo = ToNormalUpInfo(pUpInfo);

  0075f	50		 push	 eax
  00760	e8 00 00 00 00	 call	 ?ToNormalUpInfo@@YAPAVioGrowthNormalUpInfo@@PAVioGrowthUpInfo@@@Z ; ToNormalUpInfo
  00765	59		 pop	 ecx

; 1722 : 				if( pNormalUpInfo )

  00766	85 c0		 test	 eax, eax
  00768	74 10		 je	 SHORT $LN3@ApplyWeapo@25

; 1723 : 					fValue = pNormalUpInfo->GetValue(m_pCreator);

  0076a	ff b3 44 03 00
	00		 push	 DWORD PTR [ebx+836]
  00770	8b c8		 mov	 ecx, eax
  00772	e8 00 00 00 00	 call	 ?GetValue@ioGrowthNormalUpInfo@@QAEMPAVioPlayStage@@@Z ; ioGrowthNormalUpInfo::GetValue
  00777	d9 5d d0	 fstp	 DWORD PTR _fValue$694330[ebp]
$LN3@ApplyWeapo@25:

; 1724 : 
; 1725 : 				pBuff->SetExtraDurationByGrowth( fValue );

  0077a	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _fValue$694330[ebp]
  0077f	8b 06		 mov	 eax, DWORD PTR [esi]
  00781	51		 push	 ecx
  00782	8b ce		 mov	 ecx, esi
  00784	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00789	ff 50 3c	 call	 DWORD PTR [eax+60]

; 1726 : 			}
; 1727 : 		}
; 1728 : 	}
; 1729 : 	else

  0078c	eb 09		 jmp	 SHORT $LN2@ApplyWeapo@25
$LN51@ApplyWeapo@25:

; 1730 : 		szFrontBackWoundBuff.Clear();

  0078e	8b 4d b8	 mov	 ecx, DWORD PTR _szFrontBackWoundBuff$GSCopy$[ebp]
  00791	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Clear@ioHashString@@QAEXXZ
$LN2@ApplyWeapo@25:

; 1731 : 
; 1732 : 	// FrontBack
; 1733 : 	if( !szFrontBackAttackerBuff.IsEmpty() )

  00797	8b 4d b4	 mov	 ecx, DWORD PTR _szFrontBackAttackerBuff$GSCopy$[ebp]
  0079a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  007a0	84 c0		 test	 al, al
  007a2	75 4c		 jne	 SHORT $LN52@ApplyWeapo@25

; 1734 : 		pAttacker->AddNewBuff( szFrontBackAttackerBuff, "", "", NULL );

  007a4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  007aa	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
  007af	57		 push	 edi
  007b0	8d 4d 94	 lea	 ecx, DWORD PTR $T702294[ebp]
  007b3	ff d6		 call	 esi
  007b5	33 db		 xor	 ebx, ebx
  007b7	57		 push	 edi
  007b8	8d 4d a4	 lea	 ecx, DWORD PTR $T702295[ebp]
  007bb	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  007be	ff d6		 call	 esi
  007c0	8b 4d d4	 mov	 ecx, DWORD PTR _pAttacker$GSCopy$[ebp]
  007c3	53		 push	 ebx
  007c4	53		 push	 ebx
  007c5	8d 45 94	 lea	 eax, DWORD PTR $T702294[ebp]
  007c8	50		 push	 eax
  007c9	8d 45 a4	 lea	 eax, DWORD PTR $T702295[ebp]
  007cc	50		 push	 eax
  007cd	ff 75 b4	 push	 DWORD PTR _szFrontBackAttackerBuff$GSCopy$[ebp]
  007d0	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  007d4	e8 00 00 00 00	 call	 ?AddNewBuff@ioBaseChar@@QAEPAVioBuff@@ABVioHashString@@00PAVioSkill@@_N@Z ; ioBaseChar::AddNewBuff
  007d9	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_??1ioHashString@@QAE@XZ
  007df	8d 4d a4	 lea	 ecx, DWORD PTR $T702295[ebp]
  007e2	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  007e5	ff d6		 call	 esi
  007e7	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  007eb	8d 4d 94	 lea	 ecx, DWORD PTR $T702294[ebp]
  007ee	ff d6		 call	 esi
$LN52@ApplyWeapo@25:

; 1735 : }

  007f0	e8 00 00 00 00	 call	 __EH_epilog3_GS
  007f5	c2 44 00	 ret	 68			; 00000044H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ApplyWeaponWoundedAddBuff@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_N22AA_N32AAVioHashString@@44222W4DefenseBreakType@@3AAV?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@@Z$0:
  00000	8d 4d 94	 lea	 ecx, DWORD PTR $T702294[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?ApplyWeaponWoundedAddBuff@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_N22AA_N32AAVioHashString@@44222W4DefenseBreakType@@3AAV?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@@Z$1:
  00009	8d 4d a4	 lea	 ecx, DWORD PTR $T702295[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$?ApplyWeaponWoundedAddBuff@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_N22AA_N32AAVioHashString@@44222W4DefenseBreakType@@3AAV?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@@Z:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 4a 90	 mov	 ecx, DWORD PTR [edx-112]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ApplyWeaponWoundedAddBuff@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_N22AA_N32AAVioHashString@@44222W4DefenseBreakType@@3AAV?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ApplyWeaponWoundedAddBuff@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_N22AA_N32AAVioHashString@@44222W4DefenseBreakType@@3AAV?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@@Z ENDP ; ioBaseChar::ApplyWeaponWoundedAddBuff
PUBLIC	__real@3dcccccd
PUBLIC	??_C@_0CC@FHDCBGCO@sp2_disable_defense_explosion?4tx@ ; `string'
PUBLIC	??_C@_0EB@ELHKFMNM@ioBaseChar?3?3ApplyWeaponWounded?$CI?$CJ@ ; `string'
PUBLIC	??_C@_0DE@DOOJCHPH@ioBaseChar?3?3ApplyWeaponWounded?5?9@ ; `string'
PUBLIC	_vAttackDir$GSCopy$
PUBLIC	_pWeapon$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z ; ioBaseChar::ApplyWeaponWounded
EXTRN	?AddWounderRandombuffs@ioRandomPassiveSkill@@QAEXPAVioBaseChar@@0H@Z:PROC ; ioRandomPassiveSkill::AddWounderRandombuffs
EXTRN	?CheckReducePassiveGaugeByCheckBuff@ioAccessoryPassiveSkill@@QAEXPAVioBaseChar@@@Z:PROC ; ioAccessoryPassiveSkill::CheckReducePassiveGaugeByCheckBuff
EXTRN	?AddAttackerRandombuffs@ioRandomPassiveSkill@@QAEXPAVioBaseChar@@0H@Z:PROC ; ioRandomPassiveSkill::AddAttackerRandombuffs
EXTRN	?AddWounderRandomDebuffs@ioRandomPassiveSkill@@QAEXPAVioBaseChar@@0H@Z:PROC ; ioRandomPassiveSkill::AddWounderRandomDebuffs
EXTRN	?ApplyRandomBuff@ioRSoldierInfoManager@@QAEXPAVioBaseChar@@0@Z:PROC ; ioRSoldierInfoManager::ApplyRandomBuff
EXTRN	?GetSingleton@ioRSoldierInfoManager@@SAAAV1@XZ:PROC ; ioRSoldierInfoManager::GetSingleton
EXTRN	?CheckEntityCollision@ioDummyCharManager@@QAEXPAVioBaseChar@@PAVioPlayEntity@@H@Z:PROC ; ioDummyCharManager::CheckEntityCollision
EXTRN	?GetSingleton@ioDummyCharManager@@SAAAV1@XZ:PROC ; ioDummyCharManager::GetSingleton
EXTRN	?SetAggro@ioBaseChar@@QAEXABVioHashString@@H@Z:PROC ; ioBaseChar::SetAggro
EXTRN	?AddDamage@ioAbuseManager@@QAEXH@Z:PROC		; ioAbuseManager::AddDamage
EXTRN	?GetSingleton@ioAbuseManager@@SAAAV1@XZ:PROC	; ioAbuseManager::GetSingleton
EXTRN	?AddHit@ioAwardManager@@QAEXABVioHashString@@H@Z:PROC ; ioAwardManager::AddHit
EXTRN	?AddWounded@ioAwardManager@@QAEXABVioHashString@@HH@Z:PROC ; ioAwardManager::AddWounded
EXTRN	?GetSingleton@ioAwardManager@@SAAAV1@XZ:PROC	; ioAwardManager::GetSingleton
EXTRN	?ContributeTeamPerA@ioPlayMode@@QAEMW4TeamType@@MM@Z:PROC ; ioPlayMode::ContributeTeamPerA
EXTRN	?NotifyOwnerSendControlInfo@ioPlayStage@@QAEXXZ:PROC ; ioPlayStage::NotifyOwnerSendControlInfo
EXTRN	?SendToAllPlayingUser@P2PNetwork@@YAXAAVSP2Packet@@PAVioBaseChar@@@Z:PROC ; P2PNetwork::SendToAllPlayingUser
EXTRN	?GetWeaponPeculiarity@ioWeapon@@QBEKXZ:PROC	; ioWeapon::GetWeaponPeculiarity
EXTRN	??6SP2Packet@@QAEAAV0@M@Z:PROC			; SP2Packet::operator<<
EXTRN	?encodeXYZ@@YAXABUD3DXVECTOR3@@AAM1@Z:PROC	; encodeXYZ
EXTRN	??6SP2Packet@@QAEAAV0@_N@Z:PROC			; SP2Packet::operator<<
EXTRN	?GetGlobalTime@ioGlobalTimer@@QBEKXZ:PROC	; ioGlobalTimer::GetGlobalTime
EXTRN	?GetSingleton@ioGlobalTimer@@SAAAV1@XZ:PROC	; ioGlobalTimer::GetSingleton
EXTRN	?UpdateForceDir2BYTE@ioBaseChar@@IAEXXZ:PROC	; ioBaseChar::UpdateForceDir2BYTE
EXTRN	?UpdateInputDir2BYTE@ioBaseChar@@IAEXXZ:PROC	; ioBaseChar::UpdateInputDir2BYTE
EXTRN	?UpdateMoveDir2BYTE@ioBaseChar@@IAEXXZ:PROC	; ioBaseChar::UpdateMoveDir2BYTE
EXTRN	??6SP2Packet@@QAEAAV0@G@Z:PROC			; SP2Packet::operator<<
EXTRN	?floatToHALF@@YAGM@Z:PROC			; floatToHALF
EXTRN	??6SP2Packet@@QAEAAV0@K@Z:PROC			; SP2Packet::operator<<
EXTRN	??6SP2Packet@@QAEAAV0@E@Z:PROC			; SP2Packet::operator<<
EXTRN	??6SP2Packet@@QAEAAV0@H@Z:PROC			; SP2Packet::operator<<
EXTRN	?GetNextSendIndex@P2PNetwork@@YAH_N@Z:PROC	; P2PNetwork::GetNextSendIndex
EXTRN	?CreateCE@ioCameraEventManager@@QAEPAVioCameraEvent@@KPAVioPlayStage@@@Z:PROC ; ioCameraEventManager::CreateCE
EXTRN	?GetSingleton@ioCameraEventManager@@SAAAV1@XZ:PROC ; ioCameraEventManager::GetSingleton
EXTRN	?m_dwOwnerSkillWoundedCameraEvent@ioBaseCharParent@@2KA:DWORD ; ioBaseCharParent::m_dwOwnerSkillWoundedCameraEvent
EXTRN	?OnWeaponDie@ioBaseChar@@QAEXABVioHashString@@0@Z:PROC ; ioBaseChar::OnWeaponDie
EXTRN	?CheckComboSkillHit@ioBaseChar@@QAE_NXZ:PROC	; ioBaseChar::CheckComboSkillHit
EXTRN	?ApplyDamage@ioBaseChar@@QAEXM_N@Z:PROC		; ioBaseChar::ApplyDamage
EXTRN	?AddAttackDamageInfoList@ioBaseChar@@QAEXMH@Z:PROC ; ioBaseChar::AddAttackDamageInfoList
EXTRN	?AddWoundDamageInfoList@ioBaseChar@@QAEXMH@Z:PROC ; ioBaseChar::AddWoundDamageInfoList
EXTRN	?NotifyOwnerDamaged@ioBaseChar@@QAEXABVioHashString@@MKH@Z:PROC ; ioBaseChar::NotifyOwnerDamaged
EXTRN	?CheckWoundCancelBuff@ioBaseChar@@QAEXH@Z:PROC	; ioBaseChar::CheckWoundCancelBuff
EXTRN	?CheckReturnAttackBuff@ioBaseChar@@QAEXPAVioWeapon@@ABUD3DXVECTOR3@@@Z:PROC ; ioBaseChar::CheckReturnAttackBuff
EXTRN	?GetAttackedSide@ioBaseChar@@IBE?AW4AttackSide@@ABUD3DXVECTOR3@@@Z:PROC ; ioBaseChar::GetAttackedSide
EXTRN	?IsApplyDownState@ioBaseChar@@QAE_N_N@Z:PROC	; ioBaseChar::IsApplyDownState
EXTRN	?GetAttackMethodType@ioWeapon@@QAE?AW4AttackMethodType@@XZ:PROC ; ioWeapon::GetAttackMethodType
EXTRN	?GetExtendWoundPushPower@ioWeapon@@QBEMM@Z:PROC	; ioWeapon::GetExtendWoundPushPower
EXTRN	?GetExtendWoundBlowPower@ioWeapon@@QBEMM@Z:PROC	; ioWeapon::GetExtendWoundBlowPower
EXTRN	?GetBoundBlowGravityRate@ioWeapon@@QBEMXZ:PROC	; ioWeapon::GetBoundBlowGravityRate
EXTRN	?GetBoundPushPower@ioWeapon@@QBEMM@Z:PROC	; ioWeapon::GetBoundPushPower
EXTRN	?GetBoundBlowPower@ioWeapon@@QBEMM@Z:PROC	; ioWeapon::GetBoundBlowPower
EXTRN	?GetBoundWoundedStateApplyDamage@ioBaseChar@@IAEMPAVioWeapon@@W4AttackSide@@@Z:PROC ; ioBaseChar::GetBoundWoundedStateApplyDamage
EXTRN	?GetWoundedStateApplyDamage@ioBaseChar@@IAEMPAVioWeapon@@W4AttackSide@@@Z:PROC ; ioBaseChar::GetWoundedStateApplyDamage
EXTRN	?IncreaseChangeDamageByWeapon@ioBaseChar@@QAEXM@Z:PROC ; ioBaseChar::IncreaseChangeDamageByWeapon
EXTRN	?GetWereWolfChangeDamage@ioWeapon@@QAEMXZ:PROC	; ioWeapon::GetWereWolfChangeDamage
EXTRN	?CheckRunChargeCancel@ioBaseChar@@QAEX_N@Z:PROC	; ioBaseChar::CheckRunChargeCancel
EXTRN	?SetRandomSeed@ioBaseChar@@QAEXK@Z:PROC		; ioBaseChar::SetRandomSeed
EXTRN	?CheckNamedEmoticon@ioBaseChar@@QAEXH_N@Z:PROC	; ioBaseChar::CheckNamedEmoticon
EXTRN	?GetEnableEscapeCatchType@ioWeapon@@QBE?AW4EscapeCatchType@@XZ:PROC ; ioWeapon::GetEnableEscapeCatchType
EXTRN	?GetOwner@ioWeapon@@QBEPAVioBaseChar@@XZ:PROC	; ioWeapon::GetOwner
EXTRN	__imp_?PrintTimeAndLog@CLog@@QAAXHPADZZ:PROC
EXTRN	__imp_?LOG@@3VCLog@@A:BYTE
EXTRN	__ftol2_sse:PROC
;	COMDAT __real@3dcccccd
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT ??_C@_0CC@FHDCBGCO@sp2_disable_defense_explosion?4tx@
CONST	SEGMENT
??_C@_0CC@FHDCBGCO@sp2_disable_defense_explosion?4tx@ DB 'sp2_disable_def'
	DB	'ense_explosion.txt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@ELHKFMNM@ioBaseChar?3?3ApplyWeaponWounded?$CI?$CJ@
CONST	SEGMENT
??_C@_0EB@ELHKFMNM@ioBaseChar?3?3ApplyWeaponWounded?$CI?$CJ@ DB 'ioBaseCh'
	DB	'ar::ApplyWeaponWounded() - WeaponOwner(%s) is not exist.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@DOOJCHPH@ioBaseChar?3?3ApplyWeaponWounded?5?9@
CONST	SEGMENT
??_C@_0DE@DOOJCHPH@ioBaseChar?3?3ApplyWeaponWounded?5?9@ DB 'ioBaseChar::'
	DB	'ApplyWeaponWounded - Exception Error(1)', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z$9
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasecharapplywoundednew.cpp
xdata$x	ENDS
;	COMDAT ?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
$T702570 = -33160					; size = 16
_iMagicResType$ = -33144				; size = 4
_eCheckCharState$ = -33140				; size = 1
_fWeakAttackPushPower$ = -33136				; size = 4
_bProtectDamage$ = -33132				; size = 1
_iWeaponType$ = -33128					; size = 4
_szWoundAni$ = -33124					; size = 16
_szReflectAni$ = -33108					; size = 16
_szExtendWoundAni$ = -33092				; size = 16
_szDefenseBreakBuff$ = -33076				; size = 16
_szFrontBackWoundBuff$ = -33060				; size = 16
_szFrontBackAttackerBuff$ = -33044			; size = 16
_bNoCancel$ = -33028					; size = 1
_value$702733 = -33028					; size = 4
_bProtectShakeCamera$ = -33024				; size = 1
_eActionStype$ = -33024					; size = 4
_fDefenseEnableRate$ = -33020				; size = 4
_fPreCheckDamage$ = -33020				; size = 4
_pWeapon$GSCopy$ = -33016				; size = 4
_bFrozenState$ = -33012					; size = 1
_dwAttackerWeaponItemCode$ = -33008			; size = 4
_eEscapeCatchType$ = -33004				; size = 4
_bProtectionMagic$ = -33000				; size = 1
_eNewBlowType$ = -33000					; size = 4
_fBoundJumpAmt$ = -32996				; size = 4
_bDownTargetBuff$ = -32992				; size = 1
_bTargetBuff$ = -32988					; size = 1
_bOnlyEmoticon$ = -32984				; size = 1
_fBoundForceAmt$ = -32980				; size = 4
_kAddBuffList$ = -32976					; size = 16
_bWoundedLoopAni$ = -32960				; size = 1
_bFrozenBuff$ = -32960					; size = 1
_value$702650 = -32956					; size = 4
_bPrisoner$ = -32952					; size = 1
_eProtectionType$ = -32948				; size = 4
_value$702632 = -32944					; size = 4
_fExtendWoundJumpAmt$ = -32944				; size = 4
_dwExtendWoundDuration$ = -32940			; size = 4
_iFrozenType$ = -32940					; size = 4
_bTargetDie$ = -32936					; size = 1
_bEnableCancel$ = -32936				; size = 1
tv2081 = -32932						; size = 4
_compactY$694891 = -32932				; size = 4
_bForceLinear$ = -32928					; size = 1
_value$702720 = -32928					; size = 4
_iShakeCamera$ = -32928					; size = 4
_vAttackDir$GSCopy$ = -32924				; size = 4
_value$702949 = -32920					; size = 4
_value$702898 = -32920					; size = 4
$T702572 = -32920					; size = 4
_fAttackerPushPower$ = -32920				; size = 4
_fBoundDamage$ = -32916					; size = 4
_bAirTargetBuff$ = -32912				; size = 1
_bContactType$ = -32908					; size = 1
_bLandStunBuff$ = -32904				; size = 1
_bTeamAttackNoDamage$ = -32903				; size = 1
_bEnableTeamAttack$ = -32902				; size = 1
_bStateProtectIgnoreReflect$ = -32901			; size = 1
_iAddBuffCnt$694875 = -32900				; size = 4
_fBoundGrvityRate$ = -32900				; size = 4
_bNoChangeGrappling$ = -32896				; size = 1
_bAllWeakWounded$ = -32895				; size = 1
_bIgnorCatch$ = -32894					; size = 1
_bPushAttacker$ = -32893				; size = 1
_bCharDie$ = -32892					; size = 1
_eMethodType$ = -32892					; size = 4
_bTeamAttack$ = -32888					; size = 1
_bStructWeapon$ = -32884				; size = 1
_compactX$694890 = -32884				; size = 4
$T702837 = -32880					; size = 1
_bPack$694864 = -32880					; size = 1
_value$702815 = -32880					; size = 4
_value$702804 = -32880					; size = 4
_iBombResType$ = -32880					; size = 4
_eBreakType$ = -32876					; size = 4
_bBuffCreate$ = -32870					; size = 1
_bDefenseBroken$ = -32869				; size = 1
_bPack8$694847 = -32868					; size = 1
_fBlowPower$ = -32868					; size = 4
_eCurState$ = -32864					; size = 4
_fPushPower$ = -32864					; size = 4
tv2124 = -32860						; size = 4
_value$702659 = -32860					; size = 4
_value$702655 = -32860					; size = 4
$T702667 = -32860					; size = 4
_dwWoundDuration$ = -32860				; size = 4
_eAttackSide$ = -32860					; size = 4
tv2089 = -32856						; size = 4
tv2085 = -32856						; size = 4
tv1891 = -32856						; size = 4
_value$702794 = -32856					; size = 4
_value$702789 = -32856					; size = 4
_value$702779 = -32856					; size = 4
_value$702784 = -32856					; size = 4
_value$702767 = -32856					; size = 4
_value$702601 = -32852					; size = 1
_value$702638 = -32852					; size = 4
_value$702619 = -32852					; size = 4
tv1191 = -32852						; size = 4
_pAccPassiveSkill$694928 = -32852			; size = 4
_fExtendWoundForceAmt$ = -32852				; size = 4
_i$694923 = -32848					; size = 4
_i$694916 = -32848					; size = 4
_eBlockType$ = -32848					; size = 4
tv2132 = -32844						; size = 4
tv2128 = -32844						; size = 4
tv1759 = -32844						; size = 4
_value$702936 = -32844					; size = 4
_value$702920 = -32844					; size = 4
_value$702885 = -32844					; size = 4
_value$702874 = -32844					; size = 4
_value$702861 = -32844					; size = 4
$T702571 = -32844					; size = 4
_fReflectAniRate$ = -32844				; size = 4
tv1716 = -32838						; size = 1
_value$702799 = -32838					; size = 1
_value$702848 = -32837					; size = 1
_bApplyStateProtect$ = -32837				; size = 1
_bApplyPushPower$ = -32836				; size = 1
_bCheckStopMotion$ = -32836				; size = 1
_pAttacker$ = -32832					; size = 4
_bEnableHitCount$ = -32825				; size = 1
_fDamage$ = -32824					; size = 4
_kPacket$694834 = -32820				; size = 32792
_vPos$694854 = -28					; size = 12
$T694789 = -28						; size = 12
$T694755 = -28						; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pWeapon$ = 8						; size = 4
_eSide$ = 12						; size = 4
_vAttackDir$ = 16					; size = 4
?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z PROC ; ioBaseChar::ApplyWeaponWounded, COMDAT
; _this$ = ecx

; 2353 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 7c 81 00 00	 mov	 eax, 33148		; 0000817cH
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00032	8b 75 08	 mov	 esi, DWORD PTR _pWeapon$[ebp]

; 2455 : 
; 2456 : 	ApplyWeaponWoundedProtectDamageCalc( pAttacker, bProtectDamage, fPreCheckDamage, fDamage, eMethodType, iIgnoreProtect, eBreakType, eSide, bCheckStopMotion );

  00035	8b 45 10	 mov	 eax, DWORD PTR _vAttackDir$[ebp]
  00038	33 ff		 xor	 edi, edi
  0003a	8b d9		 mov	 ebx, ecx

; 2959 : 		}
; 2960 : 	}
; 2961 : 
; 2962 : 	//wounder Accessory 
; 2963 : 	for( int i=ES_RING; i<MAX_EQUIP_SLOT; i++ )

  0003c	89 b5 08 7f ff
	ff		 mov	 DWORD PTR _pWeapon$GSCopy$[ebp], esi
  00042	89 85 64 7f ff
	ff		 mov	 DWORD PTR _vAttackDir$GSCopy$[ebp], eax
  00048	3b f7		 cmp	 esi, edi
  0004a	75 1a		 jne	 SHORT $LN74@ApplyWeapo@26

; 2354 : 	//---
; 2355 : 	if( !pWeapon )
; 2356 : 	{
; 2357 : 		LOG.PrintTimeAndLog( 0, "ioBaseChar::ApplyWeaponWounded - Exception Error(1)" );

  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@DOOJCHPH@ioBaseChar?3?3ApplyWeaponWounded?5?9@
  00051	57		 push	 edi
  00052	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintTimeAndLog@CLog@@QAAXHPADZZ
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2358 : 		return;

  00061	e9 d9 19 00 00	 jmp	 $LN75@ApplyWeapo@26
$LN74@ApplyWeapo@26:

; 2359 : 	}
; 2360 : 
; 2361 : 	ioBaseChar *pAttacker = pWeapon->GetOwner();

  00066	8b ce		 mov	 ecx, esi
  00068	e8 00 00 00 00	 call	 ?GetOwner@ioWeapon@@QBEPAVioBaseChar@@XZ ; ioWeapon::GetOwner
  0006d	89 85 c0 7f ff
	ff		 mov	 DWORD PTR _pAttacker$[ebp], eax

; 2362 : 	if( !pAttacker )

  00073	3b c7		 cmp	 eax, edi
  00075	75 24		 jne	 SHORT $LN73@ApplyWeapo@26

; 2363 : 	{
; 2364 : 		LOG.PrintTimeAndLog( 0, "ioBaseChar::ApplyWeaponWounded() - WeaponOwner(%s) is not exist.", pWeapon->GetOwnerName().c_str() );

  00077	8d 4e 10	 lea	 ecx, DWORD PTR [esi+16]
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00080	50		 push	 eax
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@ELHKFMNM@ioBaseChar?3?3ApplyWeaponWounded?$CI?$CJ@
  00086	57		 push	 edi
  00087	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintTimeAndLog@CLog@@QAAXHPADZZ
  00093	83 c4 10	 add	 esp, 16			; 00000010H

; 2365 : 		return;

  00096	e9 a4 19 00 00	 jmp	 $LN75@ApplyWeapo@26
$LN73@ApplyWeapo@26:

; 2366 : 	}
; 2367 : 
; 2368 : 	//---  
; 2369 : 	m_bEnableWoundSkill = pWeapon->CheckWoundSkill();

  0009b	8a 86 84 05 00
	00		 mov	 al, BYTE PTR [esi+1412]

; 2370 : 
; 2371 : 	EscapeCatchType eEscapeCatchType = pWeapon->GetEnableEscapeCatchType();

  000a1	8b ce		 mov	 ecx, esi
  000a3	88 83 43 0f 00
	00		 mov	 BYTE PTR [ebx+3907], al
  000a9	e8 00 00 00 00	 call	 ?GetEnableEscapeCatchType@ioWeapon@@QBE?AW4EscapeCatchType@@XZ ; ioWeapon::GetEnableEscapeCatchType
  000ae	89 85 14 7f ff
	ff		 mov	 DWORD PTR _eEscapeCatchType$[ebp], eax

; 2372 : 	int iWeaponType = (int)pWeapon->GetType();

  000b4	8b 06		 mov	 eax, DWORD PTR [esi]
  000b6	8b ce		 mov	 ecx, esi
  000b8	ff 90 10 01 00
	00		 call	 DWORD PTR [eax+272]

; 2373 : 	DefenseBreakType eBreakType = pWeapon->GetDefenseBreakType();

  000be	8b ce		 mov	 ecx, esi
  000c0	89 85 98 7e ff
	ff		 mov	 DWORD PTR _iWeaponType$[ebp], eax
  000c6	e8 00 00 00 00	 call	 ?GetDefenseBreakType@ioWeapon@@QBE?AW4DefenseBreakType@@XZ ; ioWeapon::GetDefenseBreakType
  000cb	89 85 94 7f ff
	ff		 mov	 DWORD PTR _eBreakType$[ebp], eax

; 2374 : 	CharState eCheckCharState = m_CharState;

  000d1	8a 83 10 03 00
	00		 mov	 al, BYTE PTR [ebx+784]
  000d7	88 85 8c 7e ff
	ff		 mov	 BYTE PTR _eCheckCharState$[ebp], al

; 2375 : 
; 2376 : 	//  
; 2377 : 	int iMagicResType = pWeapon->IsResistanceMagic( this );

  000dd	8b 06		 mov	 eax, DWORD PTR [esi]
  000df	53		 push	 ebx
  000e0	8b ce		 mov	 ecx, esi
  000e2	ff 90 e0 00 00
	00		 call	 DWORD PTR [eax+224]
  000e8	89 85 88 7e ff
	ff		 mov	 DWORD PTR _iMagicResType$[ebp], eax

; 2378 : 	if( iMagicResType >= 0 )

  000ee	3b c7		 cmp	 eax, edi
  000f0	7c 09		 jl	 SHORT $LN72@ApplyWeapo@26

; 2379 : 		CheckNamedEmoticon( iMagicResType, false );

  000f2	57		 push	 edi
  000f3	50		 push	 eax
  000f4	8b cb		 mov	 ecx, ebx
  000f6	e8 00 00 00 00	 call	 ?CheckNamedEmoticon@ioBaseChar@@QAEXH_N@Z ; ioBaseChar::CheckNamedEmoticon
$LN72@ApplyWeapo@26:

; 2380 : 
; 2381 : 	int iBombResType = pWeapon->IsResistanceBomb( this );

  000fb	8b 06		 mov	 eax, DWORD PTR [esi]
  000fd	53		 push	 ebx
  000fe	8b ce		 mov	 ecx, esi
  00100	ff 90 e4 00 00
	00		 call	 DWORD PTR [eax+228]
  00106	89 85 90 7f ff
	ff		 mov	 DWORD PTR _iBombResType$[ebp], eax

; 2382 : 	if( iBombResType >= 0 )

  0010c	3b c7		 cmp	 eax, edi
  0010e	7c 08		 jl	 SHORT $LN71@ApplyWeapo@26

; 2383 : 		CheckSkillEvent( iBombResType );

  00110	50		 push	 eax
  00111	8b cb		 mov	 ecx, ebx
  00113	e8 00 00 00 00	 call	 ?CheckSkillEvent@ioBaseChar@@QAEXH@Z ; ioBaseChar::CheckSkillEvent
$LN71@ApplyWeapo@26:

; 2384 : 
; 2385 : 	//---  
; 2386 : 	SetRandomSeed( 0 );

  00118	57		 push	 edi
  00119	8b cb		 mov	 ecx, ebx
  0011b	e8 00 00 00 00	 call	 ?SetRandomSeed@ioBaseChar@@QAEXK@Z ; ioBaseChar::SetRandomSeed

; 2387 : 
; 2388 : 	ioAttackableItem *pItem = GetPriorityItem( SPT_WOUNDED );

  00120	6a 04		 push	 4
  00122	8b cb		 mov	 ecx, ebx
  00124	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem

; 2389 : 	if( pItem )

  00129	3b c7		 cmp	 eax, edi
  0012b	74 08		 je	 SHORT $LN70@ApplyWeapo@26

; 2390 : 		pItem->CheckWoundedState( this );

  0012d	8b 10		 mov	 edx, DWORD PTR [eax]
  0012f	53		 push	 ebx
  00130	8b c8		 mov	 ecx, eax
  00132	ff 52 4c	 call	 DWORD PTR [edx+76]
$LN70@ApplyWeapo@26:

; 2391 : 
; 2392 : 	bool bPrisoner = false;
; 2393 : 
; 2394 : 	//---   
; 2395 : 	bool bEnableCancel, bNoCancel;
; 2396 : 	ApplyWeaponWoundedEnableChangeWoundState( pWeapon, bEnableCancel, bNoCancel, eBreakType );

  00135	ff b5 94 7f ff
	ff		 push	 DWORD PTR _eBreakType$[ebp]
  0013b	8d 85 fc 7e ff
	ff		 lea	 eax, DWORD PTR _bNoCancel$[ebp]
  00141	50		 push	 eax
  00142	8d 85 58 7f ff
	ff		 lea	 eax, DWORD PTR _bEnableCancel$[ebp]
  00148	50		 push	 eax
  00149	56		 push	 esi
  0014a	8b cb		 mov	 ecx, ebx
  0014c	c6 85 48 7f ff
	ff 00		 mov	 BYTE PTR _bPrisoner$[ebp], 0
  00153	e8 00 00 00 00	 call	 ?ApplyWeaponWoundedEnableChangeWoundState@ioBaseChar@@IAEXPAVioWeapon@@AA_N1W4DefenseBreakType@@@Z ; ioBaseChar::ApplyWeaponWoundedEnableChangeWoundState

; 2397 : 
; 2398 : 	//---  
; 2399 : 	DWORD dwAttackerWeaponItemCode = pAttacker->GetWeaponItemCode();

  00158	8b bd c0 7f ff
	ff		 mov	 edi, DWORD PTR _pAttacker$[ebp]
  0015e	8b cf		 mov	 ecx, edi
  00160	e8 00 00 00 00	 call	 ?GetWeaponItemCode@ioBaseChar@@QAEKXZ ; ioBaseChar::GetWeaponItemCode
  00165	89 85 10 7f ff
	ff		 mov	 DWORD PTR _dwAttackerWeaponItemCode$[ebp], eax

; 2400 : 
; 2401 : 	// Check RunCharge
; 2402 : 	pAttacker->CheckRunChargeCancel( pWeapon->IsCollisionCancel() );

  0016b	8d 85 ac 7f ff
	ff		 lea	 eax, DWORD PTR _value$702601[ebp]
  00171	8d 8e 70 06 00
	00		 lea	 ecx, DWORD PTR [esi+1648]
  00177	50		 push	 eax
  00178	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  0017d	ff b5 ac 7f ff
	ff		 push	 DWORD PTR _value$702601[ebp]
  00183	8b cf		 mov	 ecx, edi
  00185	e8 00 00 00 00	 call	 ?CheckRunChargeCancel@ioBaseChar@@QAEX_N@Z ; ioBaseChar::CheckRunChargeCancel

; 2403 : 	pAttacker->IncreaseChangeDamageByWeapon( pWeapon->GetWereWolfChangeDamage() );

  0018a	8b ce		 mov	 ecx, esi
  0018c	e8 00 00 00 00	 call	 ?GetWereWolfChangeDamage@ioWeapon@@QAEMXZ ; ioWeapon::GetWereWolfChangeDamage
  00191	51		 push	 ecx
  00192	8b cf		 mov	 ecx, edi
  00194	d9 1c 24	 fstp	 DWORD PTR [esp]
  00197	e8 00 00 00 00	 call	 ?IncreaseChangeDamageByWeapon@ioBaseChar@@QAEXM@Z ; ioBaseChar::IncreaseChangeDamageByWeapon

; 2404 : 
; 2405 : 	if( pWeapon->CheckWeaponByJump() )

  0019c	8a 86 7f 05 00
	00		 mov	 al, BYTE PTR [esi+1407]
  001a2	84 c0		 test	 al, al
  001a4	74 07		 je	 SHORT $LN98@ApplyWeapo@26

; 2406 : 		pAttacker->SetSuccessJumpAttack( true );

  001a6	c6 87 a1 0e 00
	00 01		 mov	 BYTE PTR [edi+3745], 1
$LN98@ApplyWeapo@26:

; 2407 : 
; 2408 : 	//  
; 2409 : 	bool bTeamAttack = false;
; 2410 : 	if( pWeapon->GetTeam() == GetTeam() && pAttacker != this )

  001ad	8d 85 ac 7f ff
	ff		 lea	 eax, DWORD PTR _value$702619[ebp]
  001b3	8d 4e 30	 lea	 ecx, DWORD PTR [esi+48]
  001b6	50		 push	 eax
  001b7	c6 85 88 7f ff
	ff 00		 mov	 BYTE PTR _bTeamAttack$[ebp], 0
  001be	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  001c3	8d 85 50 7f ff
	ff		 lea	 eax, DWORD PTR _value$702632[ebp]
  001c9	8d 8b 90 00 00
	00		 lea	 ecx, DWORD PTR [ebx+144]
  001cf	50		 push	 eax
  001d0	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  001d5	8b 85 ac 7f ff
	ff		 mov	 eax, DWORD PTR _value$702619[ebp]
  001db	3b 85 50 7f ff
	ff		 cmp	 eax, DWORD PTR _value$702632[ebp]
  001e1	75 0b		 jne	 SHORT $LN68@ApplyWeapo@26
  001e3	3b fb		 cmp	 edi, ebx
  001e5	74 07		 je	 SHORT $LN68@ApplyWeapo@26

; 2411 : 		bTeamAttack = true;

  001e7	c6 85 88 7f ff
	ff 01		 mov	 BYTE PTR _bTeamAttack$[ebp], 1
$LN68@ApplyWeapo@26:

; 2412 : 
; 2413 : 	//---  
; 2414 : 	m_iBoundBlowAttackType = pWeapon->GetType();						

  001ee	8b 06		 mov	 eax, DWORD PTR [esi]
  001f0	8b ce		 mov	 ecx, esi
  001f2	ff 90 10 01 00
	00		 call	 DWORD PTR [eax+272]
  001f8	89 85 ac 7f ff
	ff		 mov	 DWORD PTR _value$702638[ebp], eax
  001fe	8d 85 ac 7f ff
	ff		 lea	 eax, DWORD PTR _value$702638[ebp]
  00204	50		 push	 eax
  00205	8d 8b 10 31 00
	00		 lea	 ecx, DWORD PTR [ebx+12560]
  0020b	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@H@@AAEXPBD@Z ; CEncrypt<int>::EncryptValueToPool

; 2415 : 
; 2416 : 	//---  
; 2417 : 	bool bFrozenBuff, bFrozenState;
; 2418 : 	int iFrozenType;
; 2419 : 	ApplyWeaponWoundedCheckFrozenState( pWeapon, pAttacker, bFrozenBuff, bFrozenState, iFrozenType );

  00210	8d 85 54 7f ff
	ff		 lea	 eax, DWORD PTR _iFrozenType$[ebp]
  00216	50		 push	 eax
  00217	8d 85 0c 7f ff
	ff		 lea	 eax, DWORD PTR _bFrozenState$[ebp]
  0021d	50		 push	 eax
  0021e	8d 85 40 7f ff
	ff		 lea	 eax, DWORD PTR _bFrozenBuff$[ebp]
  00224	50		 push	 eax
  00225	57		 push	 edi
  00226	56		 push	 esi
  00227	8b cb		 mov	 ecx, ebx
  00229	e8 00 00 00 00	 call	 ?ApplyWeaponWoundedCheckFrozenState@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_N2AAH@Z ; ioBaseChar::ApplyWeaponWoundedCheckFrozenState

; 2420 : 
; 2421 : 	//--- 
; 2422 : 	//---
; 2423 : 	//float fBaseDamage = pWeapon->GetBaseDamage( this );
; 2424 : 	float fDamage = GetWoundedStateApplyDamage( pWeapon, eSide );

  0022e	8b 7d 0c	 mov	 edi, DWORD PTR _eSide$[ebp]
  00231	57		 push	 edi
  00232	56		 push	 esi
  00233	8b cb		 mov	 ecx, ebx
  00235	e8 00 00 00 00	 call	 ?GetWoundedStateApplyDamage@ioBaseChar@@IAEMPAVioWeapon@@W4AttackSide@@@Z ; ioBaseChar::GetWoundedStateApplyDamage
  0023a	d9 9d c8 7f ff
	ff		 fstp	 DWORD PTR _fDamage$[ebp]

; 2425 : 	float fBoundDamage = GetBoundWoundedStateApplyDamage( pWeapon, eSide );

  00240	57		 push	 edi
  00241	56		 push	 esi
  00242	8b cb		 mov	 ecx, ebx
  00244	e8 00 00 00 00	 call	 ?GetBoundWoundedStateApplyDamage@ioBaseChar@@IAEMPAVioWeapon@@W4AttackSide@@@Z ; ioBaseChar::GetBoundWoundedStateApplyDamage
  00249	d9 9d 6c 7f ff
	ff		 fstp	 DWORD PTR _fBoundDamage$[ebp]

; 2426 : 	float fBoundJumpAmt = pWeapon->GetBoundBlowPower( fBoundDamage );

  0024f	f3 0f 10 85 6c
	7f ff ff	 movss	 xmm0, DWORD PTR _fBoundDamage$[ebp]
  00257	51		 push	 ecx
  00258	8b ce		 mov	 ecx, esi
  0025a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0025f	e8 00 00 00 00	 call	 ?GetBoundBlowPower@ioWeapon@@QBEMM@Z ; ioWeapon::GetBoundBlowPower
  00264	d9 9d 1c 7f ff
	ff		 fstp	 DWORD PTR _fBoundJumpAmt$[ebp]

; 2427 : 	float fBoundForceAmt = pWeapon->GetBoundPushPower( fBoundDamage );

  0026a	f3 0f 10 85 6c
	7f ff ff	 movss	 xmm0, DWORD PTR _fBoundDamage$[ebp]
  00272	51		 push	 ecx
  00273	8b ce		 mov	 ecx, esi
  00275	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0027a	e8 00 00 00 00	 call	 ?GetBoundPushPower@ioWeapon@@QBEMM@Z ; ioWeapon::GetBoundPushPower
  0027f	d9 9d 2c 7f ff
	ff		 fstp	 DWORD PTR _fBoundForceAmt$[ebp]

; 2428 : 	float fBoundGrvityRate = pWeapon->GetBoundBlowGravityRate();

  00285	8b ce		 mov	 ecx, esi
  00287	e8 00 00 00 00	 call	 ?GetBoundBlowGravityRate@ioWeapon@@QBEMXZ ; ioWeapon::GetBoundBlowGravityRate
  0028c	d9 9d 7c 7f ff
	ff		 fstp	 DWORD PTR _fBoundGrvityRate$[ebp]

; 2429 : 
; 2430 : 	float fExtendWoundJumpAmt = pWeapon->GetExtendWoundBlowPower( fDamage );

  00292	f3 0f 10 85 c8
	7f ff ff	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  0029a	51		 push	 ecx
  0029b	8b ce		 mov	 ecx, esi
  0029d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002a2	e8 00 00 00 00	 call	 ?GetExtendWoundBlowPower@ioWeapon@@QBEMM@Z ; ioWeapon::GetExtendWoundBlowPower
  002a7	d9 9d 50 7f ff
	ff		 fstp	 DWORD PTR _fExtendWoundJumpAmt$[ebp]

; 2431 : 	float fExtendWoundForceAmt = pWeapon->GetExtendWoundPushPower( fDamage );

  002ad	f3 0f 10 85 c8
	7f ff ff	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  002b5	51		 push	 ecx
  002b6	8b ce		 mov	 ecx, esi
  002b8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002bd	e8 00 00 00 00	 call	 ?GetExtendWoundPushPower@ioWeapon@@QBEMM@Z ; ioWeapon::GetExtendWoundPushPower
  002c2	d9 9d ac 7f ff
	ff		 fstp	 DWORD PTR _fExtendWoundForceAmt$[ebp]

; 2432 : 
; 2433 : 	//--- ,  
; 2434 : 	bool bForceLinear;
; 2435 : 	float fPushPower, fBlowPower;
; 2436 : 	ApplyWeaponWoundedBasePushBlowCalc( pWeapon, fDamage, fPushPower, fBlowPower, bForceLinear );

  002c8	f3 0f 10 85 c8
	7f ff ff	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  002d0	8d 85 60 7f ff
	ff		 lea	 eax, DWORD PTR _bForceLinear$[ebp]
  002d6	50		 push	 eax
  002d7	8d 85 9c 7f ff
	ff		 lea	 eax, DWORD PTR _fBlowPower$[ebp]
  002dd	50		 push	 eax
  002de	8d 85 a0 7f ff
	ff		 lea	 eax, DWORD PTR _fPushPower$[ebp]
  002e4	50		 push	 eax
  002e5	51		 push	 ecx
  002e6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002eb	56		 push	 esi
  002ec	8b cb		 mov	 ecx, ebx
  002ee	e8 00 00 00 00	 call	 ?ApplyWeaponWoundedBasePushBlowCalc@ioBaseChar@@IAEXPAVioWeapon@@MAAM1AA_N@Z ; ioBaseChar::ApplyWeaponWoundedBasePushBlowCalc

; 2437 : 	ApplyWeaponWoundedExtraPushBlowCalc( pWeapon, fPushPower, fBlowPower );

  002f3	8d 85 9c 7f ff
	ff		 lea	 eax, DWORD PTR _fBlowPower$[ebp]
  002f9	50		 push	 eax
  002fa	8d 85 a0 7f ff
	ff		 lea	 eax, DWORD PTR _fPushPower$[ebp]
  00300	50		 push	 eax
  00301	56		 push	 esi
  00302	8b cb		 mov	 ecx, ebx
  00304	e8 00 00 00 00	 call	 ?ApplyWeaponWoundedExtraPushBlowCalc@ioBaseChar@@IAEXPAVioWeapon@@AAM1@Z ; ioBaseChar::ApplyWeaponWoundedExtraPushBlowCalc

; 2438 : 
; 2439 : 	ApplyWeaponWoundedBaseDamageCalc( pWeapon, eSide, fDamage, fBoundDamage, bTeamAttack );

  00309	ff b5 88 7f ff
	ff		 push	 DWORD PTR _bTeamAttack$[ebp]
  0030f	8d 85 6c 7f ff
	ff		 lea	 eax, DWORD PTR _fBoundDamage$[ebp]
  00315	50		 push	 eax
  00316	8d 85 c8 7f ff
	ff		 lea	 eax, DWORD PTR _fDamage$[ebp]
  0031c	50		 push	 eax
  0031d	57		 push	 edi
  0031e	56		 push	 esi
  0031f	8b cb		 mov	 ecx, ebx
  00321	e8 00 00 00 00	 call	 ?ApplyWeaponWoundedBaseDamageCalc@ioBaseChar@@IAEXPAVioWeapon@@W4AttackSide@@AAM2_N@Z ; ioBaseChar::ApplyWeaponWoundedBaseDamageCalc

; 2440 : 
; 2441 : 	//---   
; 2442 : 	ApplyWeaponWoundedCalcByBuff( pAttacker, fPushPower, fBlowPower, fBoundDamage, fBoundJumpAmt, fBoundForceAmt, fBoundGrvityRate );

  00326	8d 85 7c 7f ff
	ff		 lea	 eax, DWORD PTR _fBoundGrvityRate$[ebp]
  0032c	50		 push	 eax
  0032d	8d 85 2c 7f ff
	ff		 lea	 eax, DWORD PTR _fBoundForceAmt$[ebp]
  00333	50		 push	 eax
  00334	8d 85 1c 7f ff
	ff		 lea	 eax, DWORD PTR _fBoundJumpAmt$[ebp]
  0033a	50		 push	 eax
  0033b	8d 85 6c 7f ff
	ff		 lea	 eax, DWORD PTR _fBoundDamage$[ebp]
  00341	50		 push	 eax
  00342	8d 85 9c 7f ff
	ff		 lea	 eax, DWORD PTR _fBlowPower$[ebp]
  00348	50		 push	 eax
  00349	8d 85 a0 7f ff
	ff		 lea	 eax, DWORD PTR _fPushPower$[ebp]
  0034f	50		 push	 eax
  00350	ff b5 c0 7f ff
	ff		 push	 DWORD PTR _pAttacker$[ebp]
  00356	8b cb		 mov	 ecx, ebx
  00358	e8 00 00 00 00	 call	 ?ApplyWeaponWoundedCalcByBuff@ioBaseChar@@IAEXPAV1@AAM11111@Z ; ioBaseChar::ApplyWeaponWoundedCalcByBuff

; 2443 : 
; 2444 : 	//---  ( X)
; 2445 : 	bool bProtectDamage;
; 2446 : 	float fPreCheckDamage;
; 2447 : 	AttackMethodType eMethodType = pWeapon->GetAttackMethodType();

  0035d	8b ce		 mov	 ecx, esi
  0035f	e8 00 00 00 00	 call	 ?GetAttackMethodType@ioWeapon@@QAE?AW4AttackMethodType@@XZ ; ioWeapon::GetAttackMethodType
  00364	89 85 84 7f ff
	ff		 mov	 DWORD PTR _eMethodType$[ebp], eax

; 2448 : 	int iIgnoreProtect = pWeapon->IsIgnoreProtect();

  0036a	8d 85 44 7f ff
	ff		 lea	 eax, DWORD PTR _value$702650[ebp]
  00370	8d 8e 0c 06 00
	00		 lea	 ecx, DWORD PTR [esi+1548]
  00376	50		 push	 eax
  00377	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ; CEncrypt<int>::DecryptValueToPool

; 2449 : 
; 2450 : 	//---, 
; 2451 : 	bool bCheckStopMotion = false;
; 2452 : 	if( m_CharState == CS_STOP_MOTION &&
; 2453 : 		(m_iStopMotionType == ioStopMotionBuff::SMT_NORMAL || m_iStopMotionType == ioStopMotionBuff::SMT_LOOP_NORMAL) )

  0037c	80 bb 10 03 00
	00 26		 cmp	 BYTE PTR [ebx+784], 38	; 00000026H
  00383	c6 85 bc 7f ff
	ff 00		 mov	 BYTE PTR _bCheckStopMotion$[ebp], 0
  0038a	75 3d		 jne	 SHORT $LN67@ApplyWeapo@26
  0038c	8d 85 a4 7f ff
	ff		 lea	 eax, DWORD PTR _value$702655[ebp]
  00392	8d 8b c8 15 00
	00		 lea	 ecx, DWORD PTR [ebx+5576]
  00398	50		 push	 eax
  00399	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ; CEncrypt<int>::DecryptValueToPool
  0039e	83 bd a4 7f ff
	ff 00		 cmp	 DWORD PTR _value$702655[ebp], 0
  003a5	74 1b		 je	 SHORT $LN66@ApplyWeapo@26
  003a7	8d 85 a4 7f ff
	ff		 lea	 eax, DWORD PTR _value$702659[ebp]
  003ad	50		 push	 eax
  003ae	8d 8b c8 15 00
	00		 lea	 ecx, DWORD PTR [ebx+5576]
  003b4	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ; CEncrypt<int>::DecryptValueToPool
  003b9	83 bd a4 7f ff
	ff 02		 cmp	 DWORD PTR _value$702659[ebp], 2
  003c0	75 07		 jne	 SHORT $LN67@ApplyWeapo@26
$LN66@ApplyWeapo@26:

; 2454 : 		bCheckStopMotion = true;

  003c2	c6 85 bc 7f ff
	ff 01		 mov	 BYTE PTR _bCheckStopMotion$[ebp], 1
$LN67@ApplyWeapo@26:

; 2455 : 
; 2456 : 	ApplyWeaponWoundedProtectDamageCalc( pAttacker, bProtectDamage, fPreCheckDamage, fDamage, eMethodType, iIgnoreProtect, eBreakType, eSide, bCheckStopMotion );

  003c9	ff b5 bc 7f ff
	ff		 push	 DWORD PTR _bCheckStopMotion$[ebp]
  003cf	8d 85 c8 7f ff
	ff		 lea	 eax, DWORD PTR _fDamage$[ebp]
  003d5	57		 push	 edi
  003d6	ff b5 94 7f ff
	ff		 push	 DWORD PTR _eBreakType$[ebp]
  003dc	8b cb		 mov	 ecx, ebx
  003de	ff b5 44 7f ff
	ff		 push	 DWORD PTR _value$702650[ebp]
  003e4	ff b5 84 7f ff
	ff		 push	 DWORD PTR _eMethodType$[ebp]
  003ea	50		 push	 eax
  003eb	8d 85 04 7f ff
	ff		 lea	 eax, DWORD PTR _fPreCheckDamage$[ebp]
  003f1	50		 push	 eax
  003f2	8d 85 94 7e ff
	ff		 lea	 eax, DWORD PTR _bProtectDamage$[ebp]
  003f8	50		 push	 eax
  003f9	ff b5 c0 7f ff
	ff		 push	 DWORD PTR _pAttacker$[ebp]
  003ff	e8 00 00 00 00	 call	 ?ApplyWeaponWoundedProtectDamageCalc@ioBaseChar@@IAEXPAV1@AA_NAAM2W4AttackMethodType@@HW4DefenseBreakType@@W4AttackSide@@_N@Z ; ioBaseChar::ApplyWeaponWoundedProtectDamageCalc

; 2457 : 
; 2458 : 	bool bDefenseBroken = false;
; 2459 : 	if( eBreakType != DBT_NONE )

  00404	83 bd 94 7f ff
	ff 00		 cmp	 DWORD PTR _eBreakType$[ebp], 0
  0040b	c6 85 9b 7f ff
	ff 00		 mov	 BYTE PTR _bDefenseBroken$[ebp], 0
  00412	0f 84 c5 00 00
	00		 je	 $LN64@ApplyWeapo@26

; 2460 : 	{
; 2461 : 		if( IsDefenseEnable( eSide, eBreakType, false ) )

  00418	6a 00		 push	 0
  0041a	ff b5 94 7f ff
	ff		 push	 DWORD PTR _eBreakType$[ebp]
  00420	8b cb		 mov	 ecx, ebx
  00422	57		 push	 edi
  00423	e8 00 00 00 00	 call	 ?IsDefenseEnable@ioBaseChar@@IBE_NW4AttackSide@@W4DefenseBreakType@@_N@Z ; ioBaseChar::IsDefenseEnable
  00428	84 c0		 test	 al, al
  0042a	0f 84 ad 00 00
	00		 je	 $LN64@ApplyWeapo@26

; 2462 : 		{
; 2463 : 			m_pCreator->CreateMapEffect( "sp2_disable_defense_explosion.txt", GetMidPositionByRate(), GetWorldScale() );

  00430	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@FHDCBGCO@sp2_disable_defense_explosion?4tx@
  00435	8d 8d 78 7e ff
	ff		 lea	 ecx, DWORD PTR $T702570[ebp]
  0043b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  00441	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00445	b8 05 00 00 00	 mov	 eax, 5
  0044a	8b f8		 mov	 edi, eax
  0044c	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  00451	89 85 a4 7f ff
	ff		 mov	 DWORD PTR $T702667[ebp], eax
  00457	8b 03		 mov	 eax, DWORD PTR [ebx]
  00459	8b cb		 mov	 ecx, ebx
  0045b	ff 50 78	 call	 DWORD PTR [eax+120]
  0045e	89 bd b4 7f ff
	ff		 mov	 DWORD PTR tv2132[ebp], edi
  00464	db 85 b4 7f ff
	ff		 fild	 DWORD PTR tv2132[ebp]
  0046a	50		 push	 eax
  0046b	85 ff		 test	 edi, edi
  0046d	79 06		 jns	 SHORT $LN265@ApplyWeapo@26
  0046f	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN265@ApplyWeapo@26:
  00475	8b 85 a4 7f ff
	ff		 mov	 eax, DWORD PTR $T702667[ebp]
  0047b	db 85 a4 7f ff
	ff		 fild	 DWORD PTR $T702667[ebp]
  00481	85 c0		 test	 eax, eax
  00483	79 06		 jns	 SHORT $LN266@ApplyWeapo@26
  00485	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN266@ApplyWeapo@26:
  0048b	de f9		 fdivp	 ST(1), ST(0)
  0048d	51		 push	 ecx
  0048e	8d 45 e4	 lea	 eax, DWORD PTR $T694755[ebp]
  00491	8b cb		 mov	 ecx, ebx
  00493	d9 9d a4 7f ff
	ff		 fstp	 DWORD PTR tv2124[ebp]
  00499	d9 85 a4 7f ff
	ff		 fld	 DWORD PTR tv2124[ebp]
  0049f	d9 1c 24	 fstp	 DWORD PTR [esp]
  004a2	50		 push	 eax
  004a3	e8 00 00 00 00	 call	 ?GetMidPositionByRate@ioGameEntity@@QBE?AUD3DXVECTOR3@@M@Z ; ioGameEntity::GetMidPositionByRate
  004a8	8b 8b 44 03 00
	00		 mov	 ecx, DWORD PTR [ebx+836]
  004ae	50		 push	 eax
  004af	8d 85 78 7e ff
	ff		 lea	 eax, DWORD PTR $T702570[ebp]
  004b5	50		 push	 eax
  004b6	e8 00 00 00 00	 call	 ?CreateMapEffect@ioPlayStage@@QAEPAVioMapEffect@@ABVioHashString@@ABUD3DXVECTOR3@@1@Z ; ioPlayStage::CreateMapEffect
  004bb	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  004bf	8d 8d 78 7e ff
	ff		 lea	 ecx, DWORD PTR $T702570[ebp]
  004c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ

; 2464 : 			bDefenseBroken = true;
; 2465 : 
; 2466 : 			CheckNamedEmoticon( ioModeHelpManager::HT_DEFENSE_BREAK, false );

  004cb	6a 00		 push	 0
  004cd	6a 1f		 push	 31			; 0000001fH
  004cf	8b cb		 mov	 ecx, ebx
  004d1	c6 85 9b 7f ff
	ff 01		 mov	 BYTE PTR _bDefenseBroken$[ebp], 1
  004d8	e8 00 00 00 00	 call	 ?CheckNamedEmoticon@ioBaseChar@@QAEXH_N@Z ; ioBaseChar::CheckNamedEmoticon
$LN64@ApplyWeapo@26:

; 2467 : 		}
; 2468 : 	}
; 2469 : 
; 2470 : 	//--- 
; 2471 : 	bool bAirTargetBuff = false;
; 2472 : 	bool bTargetBuff = false;
; 2473 : 	bool bDownTargetBuff = false;
; 2474 : 
; 2475 : 	if( IsFloatingState() || (IsApplyDownState(true) && !IsApplyDownState(false)) )

  004dd	8b cb		 mov	 ecx, ebx
  004df	c6 85 70 7f ff
	ff 00		 mov	 BYTE PTR _bAirTargetBuff$[ebp], 0
  004e6	c6 85 24 7f ff
	ff 00		 mov	 BYTE PTR _bTargetBuff$[ebp], 0
  004ed	c6 85 20 7f ff
	ff 00		 mov	 BYTE PTR _bDownTargetBuff$[ebp], 0
  004f4	e8 00 00 00 00	 call	 ?IsFloatingState@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsFloatingState
  004f9	84 c0		 test	 al, al
  004fb	75 51		 jne	 SHORT $LN62@ApplyWeapo@26
  004fd	6a 01		 push	 1
  004ff	8b cb		 mov	 ecx, ebx
  00501	e8 00 00 00 00	 call	 ?IsApplyDownState@ioBaseChar@@QAE_N_N@Z ; ioBaseChar::IsApplyDownState
  00506	84 c0		 test	 al, al
  00508	74 0d		 je	 SHORT $LN63@ApplyWeapo@26
  0050a	6a 00		 push	 0
  0050c	8b cb		 mov	 ecx, ebx
  0050e	e8 00 00 00 00	 call	 ?IsApplyDownState@ioBaseChar@@QAE_N_N@Z ; ioBaseChar::IsApplyDownState
  00513	84 c0		 test	 al, al
  00515	74 37		 je	 SHORT $LN62@ApplyWeapo@26
$LN63@ApplyWeapo@26:

; 2477 : 	else if( !IsFloatingState() && !IsApplyDownState(true) )

  00517	8b cb		 mov	 ecx, ebx
  00519	e8 00 00 00 00	 call	 ?IsFloatingState@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsFloatingState
  0051e	84 c0		 test	 al, al
  00520	75 16		 jne	 SHORT $LN60@ApplyWeapo@26
  00522	6a 01		 push	 1
  00524	8b cb		 mov	 ecx, ebx
  00526	e8 00 00 00 00	 call	 ?IsApplyDownState@ioBaseChar@@QAE_N_N@Z ; ioBaseChar::IsApplyDownState
  0052b	84 c0		 test	 al, al
  0052d	75 09		 jne	 SHORT $LN60@ApplyWeapo@26

; 2478 : 		bTargetBuff = true;

  0052f	c6 85 24 7f ff
	ff 01		 mov	 BYTE PTR _bTargetBuff$[ebp], 1
  00536	eb 1d		 jmp	 SHORT $LN58@ApplyWeapo@26
$LN60@ApplyWeapo@26:

; 2479 : 	else if( IsApplyDownState(false) )

  00538	6a 00		 push	 0
  0053a	8b cb		 mov	 ecx, ebx
  0053c	e8 00 00 00 00	 call	 ?IsApplyDownState@ioBaseChar@@QAE_N_N@Z ; ioBaseChar::IsApplyDownState
  00541	84 c0		 test	 al, al
  00543	74 10		 je	 SHORT $LN58@ApplyWeapo@26

; 2480 : 		bDownTargetBuff = true;

  00545	c6 85 20 7f ff
	ff 01		 mov	 BYTE PTR _bDownTargetBuff$[ebp], 1
  0054c	eb 07		 jmp	 SHORT $LN58@ApplyWeapo@26
$LN62@ApplyWeapo@26:

; 2476 : 		bAirTargetBuff = true;

  0054e	c6 85 70 7f ff
	ff 01		 mov	 BYTE PTR _bAirTargetBuff$[ebp], 1
$LN58@ApplyWeapo@26:

; 2481 : 
; 2482 : 	bool bContactType = false;
; 2483 : 	if( pWeapon->GetType() == ioWeapon::WT_CONTACT ||
; 2484 : 		pWeapon->GetType() == ioWeapon::WT_RUN_CONTACT ||
; 2485 : 		pWeapon->GetType() == ioWeapon::WT_CONTACT2 ||
; 2486 : 		pWeapon->GetType() == ioWeapon::WT_CONTACT3 )

  00555	8b 06		 mov	 eax, DWORD PTR [esi]
  00557	8b ce		 mov	 ecx, esi
  00559	c6 85 74 7f ff
	ff 00		 mov	 BYTE PTR _bContactType$[ebp], 0
  00560	ff 90 10 01 00
	00		 call	 DWORD PTR [eax+272]
  00566	83 f8 01	 cmp	 eax, 1
  00569	74 2d		 je	 SHORT $LN56@ApplyWeapo@26
  0056b	8b 06		 mov	 eax, DWORD PTR [esi]
  0056d	8b ce		 mov	 ecx, esi
  0056f	ff 90 10 01 00
	00		 call	 DWORD PTR [eax+272]
  00575	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  00578	74 1e		 je	 SHORT $LN56@ApplyWeapo@26
  0057a	8b 06		 mov	 eax, DWORD PTR [esi]
  0057c	8b ce		 mov	 ecx, esi
  0057e	ff 90 10 01 00
	00		 call	 DWORD PTR [eax+272]
  00584	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  00587	74 0f		 je	 SHORT $LN56@ApplyWeapo@26
  00589	8b 06		 mov	 eax, DWORD PTR [esi]
  0058b	8b ce		 mov	 ecx, esi
  0058d	ff 90 10 01 00
	00		 call	 DWORD PTR [eax+272]
  00593	83 f8 68	 cmp	 eax, 104		; 00000068H
  00596	75 07		 jne	 SHORT $LN57@ApplyWeapo@26
$LN56@ApplyWeapo@26:

; 2487 : 		bContactType = true;

  00598	c6 85 74 7f ff
	ff 01		 mov	 BYTE PTR _bContactType$[ebp], 1
$LN57@ApplyWeapo@26:

; 2488 : 
; 2489 : 	AttackSide eAttackSide = GetAttackedSide( vAttackDir );

  0059f	ff b5 64 7f ff
	ff		 push	 DWORD PTR _vAttackDir$GSCopy$[ebp]
  005a5	8b cb		 mov	 ecx, ebx
  005a7	e8 00 00 00 00	 call	 ?GetAttackedSide@ioBaseChar@@IBE?AW4AttackSide@@ABUD3DXVECTOR3@@@Z ; ioBaseChar::GetAttackedSide

; 2490 : 
; 2491 : 	bool bOnlyEmoticon;
; 2492 : 	bool bProtectionMagic;
; 2493 : 	AttackBlockType eBlockType;
; 2494 : 	ProtectionMode eProtectionType;
; 2495 : 	bool bProtectShakeCamera;
; 2496 : 
; 2497 : 	//---
; 2498 : 	ApplyWeaponWoundedCheckBlock( pWeapon, iIgnoreProtect, fDamage, bProtectDamage, bContactType, 
; 2499 : 									bOnlyEmoticon, eBlockType, eProtectionType, eAttackSide, eBreakType, 
; 2500 : 									eMethodType, bFrozenBuff, bFrozenState, iFrozenType, bCheckStopMotion, bProtectionMagic, bProtectShakeCamera, bAirTargetBuff );

  005ac	ff b5 70 7f ff
	ff		 push	 DWORD PTR _bAirTargetBuff$[ebp]
  005b2	8d 8d 00 7f ff
	ff		 lea	 ecx, DWORD PTR _bProtectShakeCamera$[ebp]
  005b8	51		 push	 ecx
  005b9	8d 8d 18 7f ff
	ff		 lea	 ecx, DWORD PTR _bProtectionMagic$[ebp]
  005bf	51		 push	 ecx
  005c0	ff b5 bc 7f ff
	ff		 push	 DWORD PTR _bCheckStopMotion$[ebp]
  005c6	89 85 a4 7f ff
	ff		 mov	 DWORD PTR _eAttackSide$[ebp], eax
  005cc	ff b5 54 7f ff
	ff		 push	 DWORD PTR _iFrozenType$[ebp]
  005d2	8b cb		 mov	 ecx, ebx
  005d4	ff b5 0c 7f ff
	ff		 push	 DWORD PTR _bFrozenState$[ebp]
  005da	ff b5 40 7f ff
	ff		 push	 DWORD PTR _bFrozenBuff$[ebp]
  005e0	ff b5 84 7f ff
	ff		 push	 DWORD PTR _eMethodType$[ebp]
  005e6	ff b5 94 7f ff
	ff		 push	 DWORD PTR _eBreakType$[ebp]
  005ec	50		 push	 eax
  005ed	8d 85 4c 7f ff
	ff		 lea	 eax, DWORD PTR _eProtectionType$[ebp]
  005f3	50		 push	 eax
  005f4	8d 85 b0 7f ff
	ff		 lea	 eax, DWORD PTR _eBlockType$[ebp]
  005fa	50		 push	 eax
  005fb	8d 85 28 7f ff
	ff		 lea	 eax, DWORD PTR _bOnlyEmoticon$[ebp]
  00601	50		 push	 eax
  00602	ff b5 74 7f ff
	ff		 push	 DWORD PTR _bContactType$[ebp]
  00608	8d 85 94 7e ff
	ff		 lea	 eax, DWORD PTR _bProtectDamage$[ebp]
  0060e	50		 push	 eax
  0060f	8d 85 c8 7f ff
	ff		 lea	 eax, DWORD PTR _fDamage$[ebp]
  00615	50		 push	 eax
  00616	ff b5 44 7f ff
	ff		 push	 DWORD PTR _value$702650[ebp]
  0061c	56		 push	 esi
  0061d	e8 00 00 00 00	 call	 ?ApplyWeaponWoundedCheckBlock@ioBaseChar@@IAEXPAVioWeapon@@HAAMAA_N_N2AAW4AttackBlockType@@AAW4ProtectionMode@@W4AttackSide@@W4DefenseBreakType@@W4AttackMethodType@@33H3223@Z ; ioBaseChar::ApplyWeaponWoundedCheckBlock

; 2501 : 
; 2502 : 	//---Reflect
; 2503 : 	bool bStructWeapon = false;
; 2504 : 	if( pWeapon->CheckWeaponByStruct() || pWeapon->CheckWeaponByDummyChar() )

  00622	80 be 8c 05 00
	00 00		 cmp	 BYTE PTR [esi+1420], 0
  00629	c6 85 8c 7f ff
	ff 00		 mov	 BYTE PTR _bStructWeapon$[ebp], 0
  00630	75 09		 jne	 SHORT $LN54@ApplyWeapo@26
  00632	80 be 9c 05 00
	00 00		 cmp	 BYTE PTR [esi+1436], 0
  00639	74 0e		 je	 SHORT $LN53@ApplyWeapo@26
$LN54@ApplyWeapo@26:

; 2505 : 		bStructWeapon = true;

  0063b	c6 85 8c 7f ff
	ff 01		 mov	 BYTE PTR _bStructWeapon$[ebp], 1

; 2506 : 
; 2507 : 	if( bStructWeapon )
; 2508 : 		bOnlyEmoticon = true;

  00642	c6 85 28 7f ff
	ff 01		 mov	 BYTE PTR _bOnlyEmoticon$[ebp], 1
$LN53@ApplyWeapo@26:

; 2509 : 
; 2510 : 	bool bStateProtectIgnoreReflect;
; 2511 : 	bool bApplyStateProtect;
; 2512 : 
; 2513 : 	ioHashString szReflectAni;

  00649	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_??0ioHashString@@QAE@XZ
  0064f	8d 8d ac 7e ff
	ff		 lea	 ecx, DWORD PTR _szReflectAni$[ebp]
  00655	ff d7		 call	 edi

; 2514 : 	float fReflectAniRate;
; 2515 : 
; 2516 : 	bool bPushAttacker;
; 2517 : 	float fAttackerPushPower;
; 2518 : 	float fWeakAttackPushPower;
; 2519 : 
; 2520 : 	ApplyWeaponWoundedReflect( pWeapon, pAttacker, bStateProtectIgnoreReflect, bApplyStateProtect, szReflectAni, fReflectAniRate, 
; 2521 : 								bPushAttacker, fAttackerPushPower, fWeakAttackPushPower, eSide, bOnlyEmoticon, vAttackDir, 
; 2522 : 								eBlockType, eProtectionType, fDamage, bContactType, eEscapeCatchType, eBreakType, bStructWeapon );

  00657	ff b5 8c 7f ff
	ff		 push	 DWORD PTR _bStructWeapon$[ebp]
  0065d	8d 85 c8 7f ff
	ff		 lea	 eax, DWORD PTR _fDamage$[ebp]
  00663	ff b5 94 7f ff
	ff		 push	 DWORD PTR _eBreakType$[ebp]
  00669	8b cb		 mov	 ecx, ebx
  0066b	ff b5 14 7f ff
	ff		 push	 DWORD PTR _eEscapeCatchType$[ebp]
  00671	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00678	ff b5 74 7f ff
	ff		 push	 DWORD PTR _bContactType$[ebp]
  0067e	50		 push	 eax
  0067f	ff b5 4c 7f ff
	ff		 push	 DWORD PTR _eProtectionType$[ebp]
  00685	8d 85 90 7e ff
	ff		 lea	 eax, DWORD PTR _fWeakAttackPushPower$[ebp]
  0068b	ff b5 b0 7f ff
	ff		 push	 DWORD PTR _eBlockType$[ebp]
  00691	ff b5 64 7f ff
	ff		 push	 DWORD PTR _vAttackDir$GSCopy$[ebp]
  00697	ff b5 28 7f ff
	ff		 push	 DWORD PTR _bOnlyEmoticon$[ebp]
  0069d	ff 75 0c	 push	 DWORD PTR _eSide$[ebp]
  006a0	50		 push	 eax
  006a1	8d 85 68 7f ff
	ff		 lea	 eax, DWORD PTR _fAttackerPushPower$[ebp]
  006a7	50		 push	 eax
  006a8	8d 85 83 7f ff
	ff		 lea	 eax, DWORD PTR _bPushAttacker$[ebp]
  006ae	50		 push	 eax
  006af	8d 85 b4 7f ff
	ff		 lea	 eax, DWORD PTR _fReflectAniRate$[ebp]
  006b5	50		 push	 eax
  006b6	8d 85 ac 7e ff
	ff		 lea	 eax, DWORD PTR _szReflectAni$[ebp]
  006bc	50		 push	 eax
  006bd	8d 85 bb 7f ff
	ff		 lea	 eax, DWORD PTR _bApplyStateProtect$[ebp]
  006c3	50		 push	 eax
  006c4	8d 85 7b 7f ff
	ff		 lea	 eax, DWORD PTR _bStateProtectIgnoreReflect$[ebp]
  006ca	50		 push	 eax
  006cb	ff b5 c0 7f ff
	ff		 push	 DWORD PTR _pAttacker$[ebp]
  006d1	56		 push	 esi
  006d2	e8 00 00 00 00	 call	 ?ApplyWeaponWoundedReflect@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_N2AAVioHashString@@AAM244W4AttackSide@@_NABUD3DXVECTOR3@@W4AttackBlockType@@W4ProtectionMode@@46W4EscapeCatchType@@W4DefenseBreakType@@6@Z ; ioBaseChar::ApplyWeaponWoundedReflect

; 2523 : 
; 2524 : 	// Check ReturnAttackBuff
; 2525 : 	if( pAttacker && (bContactType || eEscapeCatchType == ECT_CATCH_RETURN) && !bStructWeapon )

  006d7	80 bd 74 7f ff
	ff 00		 cmp	 BYTE PTR _bContactType$[ebp], 0
  006de	75 09		 jne	 SHORT $LN51@ApplyWeapo@26
  006e0	83 bd 14 7f ff
	ff 02		 cmp	 DWORD PTR _eEscapeCatchType$[ebp], 2
  006e7	75 6b		 jne	 SHORT $LN52@ApplyWeapo@26
$LN51@ApplyWeapo@26:
  006e9	80 bd 8c 7f ff
	ff 00		 cmp	 BYTE PTR _bStructWeapon$[ebp], 0
  006f0	75 62		 jne	 SHORT $LN52@ApplyWeapo@26

; 2526 : 		CheckReturnAttackBuff( pWeapon, pAttacker->GetMidPositionByRate() );

  006f2	b8 05 00 00 00	 mov	 eax, 5
  006f7	8b c8		 mov	 ecx, eax
  006f9	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  006fe	89 8d a8 7f ff
	ff		 mov	 DWORD PTR tv2089[ebp], ecx
  00704	db 85 a8 7f ff
	ff		 fild	 DWORD PTR tv2089[ebp]
  0070a	85 c9		 test	 ecx, ecx
  0070c	79 06		 jns	 SHORT $LN267@ApplyWeapo@26
  0070e	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN267@ApplyWeapo@26:
  00714	89 85 a8 7f ff
	ff		 mov	 DWORD PTR tv2085[ebp], eax
  0071a	db 85 a8 7f ff
	ff		 fild	 DWORD PTR tv2085[ebp]
  00720	85 c0		 test	 eax, eax
  00722	79 06		 jns	 SHORT $LN268@ApplyWeapo@26
  00724	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN268@ApplyWeapo@26:
  0072a	de f9		 fdivp	 ST(1), ST(0)
  0072c	51		 push	 ecx
  0072d	8b 8d c0 7f ff
	ff		 mov	 ecx, DWORD PTR _pAttacker$[ebp]
  00733	8d 45 e4	 lea	 eax, DWORD PTR $T694789[ebp]
  00736	d9 9d 5c 7f ff
	ff		 fstp	 DWORD PTR tv2081[ebp]
  0073c	d9 85 5c 7f ff
	ff		 fld	 DWORD PTR tv2081[ebp]
  00742	d9 1c 24	 fstp	 DWORD PTR [esp]
  00745	50		 push	 eax
  00746	e8 00 00 00 00	 call	 ?GetMidPositionByRate@ioGameEntity@@QBE?AUD3DXVECTOR3@@M@Z ; ioGameEntity::GetMidPositionByRate
  0074b	50		 push	 eax
  0074c	56		 push	 esi
  0074d	8b cb		 mov	 ecx, ebx
  0074f	e8 00 00 00 00	 call	 ?CheckReturnAttackBuff@ioBaseChar@@QAEXPAVioWeapon@@ABUD3DXVECTOR3@@@Z ; ioBaseChar::CheckReturnAttackBuff
$LN52@ApplyWeapo@26:

; 2527 : 
; 2528 : 	//---  
; 2529 : 	ioHashString szFrontBackWoundBuff, szFrontBackAttackerBuff;

  00754	8d 8d dc 7e ff
	ff		 lea	 ecx, DWORD PTR _szFrontBackWoundBuff$[ebp]
  0075a	ff d7		 call	 edi
  0075c	8d 8d ec 7e ff
	ff		 lea	 ecx, DWORD PTR _szFrontBackAttackerBuff$[ebp]
  00762	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00766	ff d7		 call	 edi

; 2530 : 	ApplyWeaponWoundedFrontBackBuff( pAttacker, eAttackSide, bAirTargetBuff, bTargetBuff, bDownTargetBuff, szFrontBackWoundBuff, szFrontBackAttackerBuff, fDamage );

  00768	8d 85 c8 7f ff
	ff		 lea	 eax, DWORD PTR _fDamage$[ebp]
  0076e	50		 push	 eax
  0076f	8d 85 ec 7e ff
	ff		 lea	 eax, DWORD PTR _szFrontBackAttackerBuff$[ebp]
  00775	50		 push	 eax
  00776	8d 85 dc 7e ff
	ff		 lea	 eax, DWORD PTR _szFrontBackWoundBuff$[ebp]
  0077c	50		 push	 eax
  0077d	ff b5 20 7f ff
	ff		 push	 DWORD PTR _bDownTargetBuff$[ebp]
  00783	8b cb		 mov	 ecx, ebx
  00785	ff b5 24 7f ff
	ff		 push	 DWORD PTR _bTargetBuff$[ebp]
  0078b	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0078f	ff b5 70 7f ff
	ff		 push	 DWORD PTR _bAirTargetBuff$[ebp]
  00795	ff b5 a4 7f ff
	ff		 push	 DWORD PTR _eAttackSide$[ebp]
  0079b	ff b5 c0 7f ff
	ff		 push	 DWORD PTR _pAttacker$[ebp]
  007a1	e8 00 00 00 00	 call	 ?ApplyWeaponWoundedFrontBackBuff@ioBaseChar@@IAEXPAV1@W4AttackSide@@_N22AAVioHashString@@3AAM@Z ; ioBaseChar::ApplyWeaponWoundedFrontBackBuff

; 2531 : 
; 2532 : 	//    
; 2533 : 	if( fDamage > 0.0f )

  007a6	f3 0f 10 85 c8
	7f ff ff	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  007ae	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  007b5	76 24		 jbe	 SHORT $LN50@ApplyWeapo@26

; 2534 : 	{
; 2535 : 		CheckWoundCancelBuff( BT_RECOVERY );

  007b7	6a 04		 push	 4
  007b9	8b cb		 mov	 ecx, ebx
  007bb	e8 00 00 00 00	 call	 ?CheckWoundCancelBuff@ioBaseChar@@QAEXH@Z ; ioBaseChar::CheckWoundCancelBuff

; 2536 : 		CheckWoundCancelBuff( BT_RESTORATION );

  007c0	6a 05		 push	 5
  007c2	8b cb		 mov	 ecx, ebx
  007c4	e8 00 00 00 00	 call	 ?CheckWoundCancelBuff@ioBaseChar@@QAEXH@Z ; ioBaseChar::CheckWoundCancelBuff

; 2537 : 		CheckWoundCancelBuff( BT_INFECTION );

  007c9	6a 67		 push	 103			; 00000067H
  007cb	8b cb		 mov	 ecx, ebx
  007cd	e8 00 00 00 00	 call	 ?CheckWoundCancelBuff@ioBaseChar@@QAEXH@Z ; ioBaseChar::CheckWoundCancelBuff

; 2538 : 		CheckWoundCancelBuff( BT_RESTORATION_GAUGE );

  007d2	6a 11		 push	 17			; 00000011H
  007d4	8b cb		 mov	 ecx, ebx
  007d6	e8 00 00 00 00	 call	 ?CheckWoundCancelBuff@ioBaseChar@@QAEXH@Z ; ioBaseChar::CheckWoundCancelBuff
$LN50@ApplyWeapo@26:

; 2539 : 	}
; 2540 : 
; 2541 : 	// 
; 2542 : 	NotifyOwnerDamaged( pAttacker->GetCharName(), fDamage, dwAttackerWeaponItemCode, iWeaponType );

  007db	ff b5 98 7e ff
	ff		 push	 DWORD PTR _iWeaponType$[ebp]
  007e1	8b 85 c0 7f ff
	ff		 mov	 eax, DWORD PTR _pAttacker$[ebp]
  007e7	ff b5 10 7f ff
	ff		 push	 DWORD PTR _dwAttackerWeaponItemCode$[ebp]
  007ed	f3 0f 10 85 c8
	7f ff ff	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  007f5	51		 push	 ecx
  007f6	05 d4 02 00 00	 add	 eax, 724		; 000002d4H
  007fb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00800	50		 push	 eax
  00801	8b cb		 mov	 ecx, ebx
  00803	89 85 a8 7f ff
	ff		 mov	 DWORD PTR tv1891[ebp], eax
  00809	e8 00 00 00 00	 call	 ?NotifyOwnerDamaged@ioBaseChar@@QAEXABVioHashString@@MKH@Z ; ioBaseChar::NotifyOwnerDamaged

; 2543 : 
; 2544 : 	// Check Cur WoundedDamage
; 2545 : 	AddWoundDamageInfoList( fDamage, (int)pWeapon->GetType() );

  0080e	8b 06		 mov	 eax, DWORD PTR [esi]
  00810	8b ce		 mov	 ecx, esi
  00812	ff 90 10 01 00
	00		 call	 DWORD PTR [eax+272]
  00818	f3 0f 10 85 c8
	7f ff ff	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  00820	50		 push	 eax
  00821	51		 push	 ecx
  00822	8b cb		 mov	 ecx, ebx
  00824	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00829	e8 00 00 00 00	 call	 ?AddWoundDamageInfoList@ioBaseChar@@QAEXMH@Z ; ioBaseChar::AddWoundDamageInfoList

; 2546 : 
; 2547 : 	// Check Cur AttackDamage
; 2548 : 	if( pWeapon->GetWeaponBySkillName().IsEmpty() )

  0082e	8b ce		 mov	 ecx, esi
  00830	e8 00 00 00 00	 call	 ?GetWeaponBySkillName@ioWeapon@@QBEABVioHashString@@XZ ; ioWeapon::GetWeaponBySkillName
  00835	8b c8		 mov	 ecx, eax
  00837	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  0083d	84 c0		 test	 al, al
  0083f	74 24		 je	 SHORT $LN49@ApplyWeapo@26

; 2549 : 		pAttacker->AddAttackDamageInfoList( fDamage, (int)pWeapon->GetType() );

  00841	8b 06		 mov	 eax, DWORD PTR [esi]
  00843	8b ce		 mov	 ecx, esi
  00845	ff 90 10 01 00
	00		 call	 DWORD PTR [eax+272]
  0084b	f3 0f 10 85 c8
	7f ff ff	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  00853	50		 push	 eax
  00854	51		 push	 ecx
  00855	8b 8d c0 7f ff
	ff		 mov	 ecx, DWORD PTR _pAttacker$[ebp]
  0085b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00860	e8 00 00 00 00	 call	 ?AddAttackDamageInfoList@ioBaseChar@@QAEXMH@Z ; ioBaseChar::AddAttackDamageInfoList
$LN49@ApplyWeapo@26:

; 2550 : 
; 2551 : 	//--- 2 
; 2552 : 	ApplyWeaponWoundedExtraDamageCalc( pWeapon, pAttacker, bProtectDamage, fPreCheckDamage, fDamage );

  00865	f3 0f 10 85 04
	7f ff ff	 movss	 xmm0, DWORD PTR _fPreCheckDamage$[ebp]
  0086d	8d 85 c8 7f ff
	ff		 lea	 eax, DWORD PTR _fDamage$[ebp]
  00873	50		 push	 eax
  00874	51		 push	 ecx
  00875	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0087a	ff b5 94 7e ff
	ff		 push	 DWORD PTR _bProtectDamage$[ebp]
  00880	8b cb		 mov	 ecx, ebx
  00882	ff b5 c0 7f ff
	ff		 push	 DWORD PTR _pAttacker$[ebp]
  00888	56		 push	 esi
  00889	e8 00 00 00 00	 call	 ?ApplyWeaponWoundedExtraDamageCalc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_NMAAM@Z ; ioBaseChar::ApplyWeaponWoundedExtraDamageCalc

; 2553 : 
; 2554 : 	if( iIgnoreProtect == IPT_ALL )

  0088e	83 bd 44 7f ff
	ff 01		 cmp	 DWORD PTR _value$702650[ebp], 1

; 2555 : 		ApplyDamage( fDamage, true );

  00895	f3 0f 10 85 c8
	7f ff ff	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  0089d	75 04		 jne	 SHORT $LN48@ApplyWeapo@26
  0089f	6a 01		 push	 1

; 2556 : 	else

  008a1	eb 02		 jmp	 SHORT $LN270@ApplyWeapo@26
$LN48@ApplyWeapo@26:

; 2557 : 		ApplyDamage( fDamage, false );

  008a3	6a 00		 push	 0
$LN270@ApplyWeapo@26:
  008a5	51		 push	 ecx
  008a6	8b cb		 mov	 ecx, ebx
  008a8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008ad	e8 00 00 00 00	 call	 ?ApplyDamage@ioBaseChar@@QAEXM_N@Z ; ioBaseChar::ApplyDamage

; 2558 : 
; 2559 : 	//---  .
; 2560 : #ifndef SHIPPING 
; 2561 : 	if( Setting::ShowExtraInfo() )
; 2562 : 	{
; 2563 : 		if ( fDamage != 0.0f )
; 2564 : 			LOG.PrintTimeAndLog( 0, "ApplyDamage - %s, Damage: %f", m_Name.c_str(), fDamage );
; 2565 : 	}
; 2566 : #endif
; 2567 : 
; 2568 : 	ApplyWeaponWoundedDamageFunc( pWeapon, fDamage );

  008b2	f3 0f 10 85 c8
	7f ff ff	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  008ba	51		 push	 ecx
  008bb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008c0	56		 push	 esi
  008c1	8b cb		 mov	 ecx, ebx
  008c3	e8 00 00 00 00	 call	 ?ApplyWeaponWoundedDamageFunc@ioBaseChar@@IAEXPAVioWeapon@@M@Z ; ioBaseChar::ApplyWeaponWoundedDamageFunc

; 2569 : 
; 2570 : 	//------------------------------------------------------------------------------------------------------------------------------------
; 2571 : 
; 2572 : 	//--- 
; 2573 : 	bool bApplyPushPower;
; 2574 : 	bool bCharDie;
; 2575 : 	ApplyWeaponWoundedApplyPushPower( pWeapon, bApplyPushPower, bCharDie, bFrozenState, bFrozenBuff, iFrozenType, 
; 2576 : 										eBreakType, eAttackSide, eMethodType, iIgnoreProtect, bProtectionMagic, bTeamAttack, bContactType, bCheckStopMotion, vAttackDir, fDamage );

  008c8	f3 0f 10 85 c8
	7f ff ff	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  008d0	51		 push	 ecx
  008d1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008d6	ff b5 64 7f ff
	ff		 push	 DWORD PTR _vAttackDir$GSCopy$[ebp]
  008dc	8d 85 84 7f ff
	ff		 lea	 eax, DWORD PTR _bCharDie$[ebp]
  008e2	ff b5 bc 7f ff
	ff		 push	 DWORD PTR _bCheckStopMotion$[ebp]
  008e8	8b cb		 mov	 ecx, ebx
  008ea	ff b5 74 7f ff
	ff		 push	 DWORD PTR _bContactType$[ebp]
  008f0	ff b5 88 7f ff
	ff		 push	 DWORD PTR _bTeamAttack$[ebp]
  008f6	ff b5 18 7f ff
	ff		 push	 DWORD PTR _bProtectionMagic$[ebp]
  008fc	ff b5 44 7f ff
	ff		 push	 DWORD PTR _value$702650[ebp]
  00902	ff b5 84 7f ff
	ff		 push	 DWORD PTR _eMethodType$[ebp]
  00908	ff b5 a4 7f ff
	ff		 push	 DWORD PTR _eAttackSide$[ebp]
  0090e	ff b5 94 7f ff
	ff		 push	 DWORD PTR _eBreakType$[ebp]
  00914	ff b5 54 7f ff
	ff		 push	 DWORD PTR _iFrozenType$[ebp]
  0091a	ff b5 40 7f ff
	ff		 push	 DWORD PTR _bFrozenBuff$[ebp]
  00920	ff b5 0c 7f ff
	ff		 push	 DWORD PTR _bFrozenState$[ebp]
  00926	50		 push	 eax
  00927	8d 85 bc 7f ff
	ff		 lea	 eax, DWORD PTR _bApplyPushPower$[ebp]
  0092d	50		 push	 eax
  0092e	56		 push	 esi
  0092f	e8 00 00 00 00	 call	 ?ApplyWeaponWoundedApplyPushPower@ioBaseChar@@IAEXPAVioWeapon@@AA_N1_N2HW4DefenseBreakType@@W4AttackSide@@W4AttackMethodType@@H2222ABUD3DXVECTOR3@@M@Z ; ioBaseChar::ApplyWeaponWoundedApplyPushPower

; 2577 : 
; 2578 : 	//---   ()
; 2579 : 	bool bAllWeakWounded;
; 2580 : 	ioHashString szWoundAni;

  00934	8d 8d 9c 7e ff
	ff		 lea	 ecx, DWORD PTR _szWoundAni$[ebp]
  0093a	ff d7		 call	 edi

; 2581 : 	DWORD dwWoundDuration;
; 2582 : 	bool bWoundedLoopAni;
; 2583 : 	bool bIgnorCatch;
; 2584 : 
; 2585 : 	float fDefenseEnableRate;
; 2586 : 	BlowTargetType eNewBlowType;
; 2587 : 
; 2588 : 	ioHashString szExtendWoundAni;

  0093c	8d 8d bc 7e ff
	ff		 lea	 ecx, DWORD PTR _szExtendWoundAni$[ebp]
  00942	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00946	ff d7		 call	 edi

; 2589 : 	DWORD dwExtendWoundDuration;
; 2590 : 
; 2591 : 	ApplyWeaponWoundedChangeState( pWeapon, pAttacker, 
; 2592 : 									bAllWeakWounded, szWoundAni, dwWoundDuration, bWoundedLoopAni, 
; 2593 : 									bIgnorCatch, fDefenseEnableRate, eNewBlowType, bCharDie, 
; 2594 : 									fPushPower, fBlowPower, bApplyPushPower, bTeamAttack, fDamage, fBoundJumpAmt, fBoundForceAmt, fBoundGrvityRate, fBoundDamage,
; 2595 : 									bPrisoner, bEnableCancel, bNoCancel, szExtendWoundAni, dwExtendWoundDuration, fExtendWoundJumpAmt, fExtendWoundForceAmt );

  00948	f3 0f 10 85 ac
	7f ff ff	 movss	 xmm0, DWORD PTR _fExtendWoundForceAmt$[ebp]
  00950	51		 push	 ecx
  00951	51		 push	 ecx
  00952	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00958	f3 0f 10 85 50
	7f ff ff	 movss	 xmm0, DWORD PTR _fExtendWoundJumpAmt$[ebp]
  00960	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00965	f3 0f 10 85 6c
	7f ff ff	 movss	 xmm0, DWORD PTR _fBoundDamage$[ebp]
  0096d	8d 85 54 7f ff
	ff		 lea	 eax, DWORD PTR _dwExtendWoundDuration$[ebp]
  00973	50		 push	 eax
  00974	8d 85 bc 7e ff
	ff		 lea	 eax, DWORD PTR _szExtendWoundAni$[ebp]
  0097a	50		 push	 eax
  0097b	ff b5 fc 7e ff
	ff		 push	 DWORD PTR _bNoCancel$[ebp]
  00981	8d 85 48 7f ff
	ff		 lea	 eax, DWORD PTR _bPrisoner$[ebp]
  00987	ff b5 58 7f ff
	ff		 push	 DWORD PTR _bEnableCancel$[ebp]
  0098d	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00991	50		 push	 eax
  00992	83 ec 14	 sub	 esp, 20			; 00000014H
  00995	f3 0f 11 44 24
	10		 movss	 DWORD PTR [esp+16], xmm0
  0099b	f3 0f 10 85 7c
	7f ff ff	 movss	 xmm0, DWORD PTR _fBoundGrvityRate$[ebp]
  009a3	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  009a9	f3 0f 10 85 2c
	7f ff ff	 movss	 xmm0, DWORD PTR _fBoundForceAmt$[ebp]
  009b1	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  009b7	f3 0f 10 85 1c
	7f ff ff	 movss	 xmm0, DWORD PTR _fBoundJumpAmt$[ebp]
  009bf	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  009c5	f3 0f 10 85 c8
	7f ff ff	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  009cd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009d2	ff b5 88 7f ff
	ff		 push	 DWORD PTR _bTeamAttack$[ebp]
  009d8	8d 85 9c 7f ff
	ff		 lea	 eax, DWORD PTR _fBlowPower$[ebp]
  009de	ff b5 bc 7f ff
	ff		 push	 DWORD PTR _bApplyPushPower$[ebp]
  009e4	50		 push	 eax
  009e5	8d 85 a0 7f ff
	ff		 lea	 eax, DWORD PTR _fPushPower$[ebp]
  009eb	50		 push	 eax
  009ec	8d 85 84 7f ff
	ff		 lea	 eax, DWORD PTR _bCharDie$[ebp]
  009f2	50		 push	 eax
  009f3	8d 85 18 7f ff
	ff		 lea	 eax, DWORD PTR _eNewBlowType$[ebp]
  009f9	50		 push	 eax
  009fa	8d 85 04 7f ff
	ff		 lea	 eax, DWORD PTR _fDefenseEnableRate$[ebp]
  00a00	50		 push	 eax
  00a01	8d 85 82 7f ff
	ff		 lea	 eax, DWORD PTR _bIgnorCatch$[ebp]
  00a07	50		 push	 eax
  00a08	8d 85 40 7f ff
	ff		 lea	 eax, DWORD PTR _bWoundedLoopAni$[ebp]
  00a0e	50		 push	 eax
  00a0f	8d 85 a4 7f ff
	ff		 lea	 eax, DWORD PTR _dwWoundDuration$[ebp]
  00a15	50		 push	 eax
  00a16	8d 85 9c 7e ff
	ff		 lea	 eax, DWORD PTR _szWoundAni$[ebp]
  00a1c	50		 push	 eax
  00a1d	8d 85 81 7f ff
	ff		 lea	 eax, DWORD PTR _bAllWeakWounded$[ebp]
  00a23	50		 push	 eax
  00a24	ff b5 c0 7f ff
	ff		 push	 DWORD PTR _pAttacker$[ebp]
  00a2a	8b cb		 mov	 ecx, ebx
  00a2c	56		 push	 esi
  00a2d	e8 00 00 00 00	 call	 ?ApplyWeaponWoundedChangeState@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AA_NAAVioHashString@@AAK22AAMAAW4BlowTargetType@@255_N7MMMMM27734MM@Z ; ioBaseChar::ApplyWeaponWoundedChangeState

; 2596 : 
; 2597 : 	//--- 
; 2598 : 	ApplyWeaponWoundedChangePrisonerState( bTeamAttack, bFrozenState, bContactType, eEscapeCatchType );

  00a32	ff b5 14 7f ff
	ff		 push	 DWORD PTR _eEscapeCatchType$[ebp]
  00a38	8b cb		 mov	 ecx, ebx
  00a3a	ff b5 74 7f ff
	ff		 push	 DWORD PTR _bContactType$[ebp]
  00a40	ff b5 0c 7f ff
	ff		 push	 DWORD PTR _bFrozenState$[ebp]
  00a46	ff b5 88 7f ff
	ff		 push	 DWORD PTR _bTeamAttack$[ebp]
  00a4c	e8 00 00 00 00	 call	 ?ApplyWeaponWoundedChangePrisonerState@ioBaseChar@@IAEX_N00W4EscapeCatchType@@@Z ; ioBaseChar::ApplyWeaponWoundedChangePrisonerState

; 2599 : 
; 2600 : 	//---  
; 2601 : 	ApplyWeaponWoundedPushBlowCalcByBuff( pWeapon, pAttacker, fPushPower, fBlowPower, bTeamAttack );

  00a51	ff b5 88 7f ff
	ff		 push	 DWORD PTR _bTeamAttack$[ebp]
  00a57	8d 85 9c 7f ff
	ff		 lea	 eax, DWORD PTR _fBlowPower$[ebp]
  00a5d	50		 push	 eax
  00a5e	8d 85 a0 7f ff
	ff		 lea	 eax, DWORD PTR _fPushPower$[ebp]
  00a64	50		 push	 eax
  00a65	ff b5 c0 7f ff
	ff		 push	 DWORD PTR _pAttacker$[ebp]
  00a6b	8b cb		 mov	 ecx, ebx
  00a6d	56		 push	 esi
  00a6e	e8 00 00 00 00	 call	 ?ApplyWeaponWoundedPushBlowCalcByBuff@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AAM2_N@Z ; ioBaseChar::ApplyWeaponWoundedPushBlowCalcByBuff

; 2602 : 
; 2603 : 	//--- ,  
; 2604 : 	ApplyWeaponWoundedPushBlowPower( pWeapon, bApplyPushPower, vAttackDir, fPushPower, fBlowPower, bForceLinear );

  00a73	ff b5 60 7f ff
	ff		 push	 DWORD PTR _bForceLinear$[ebp]
  00a79	f3 0f 10 85 a0
	7f ff ff	 movss	 xmm0, DWORD PTR _fPushPower$[ebp]
  00a81	8d 85 9c 7f ff
	ff		 lea	 eax, DWORD PTR _fBlowPower$[ebp]
  00a87	50		 push	 eax
  00a88	51		 push	 ecx
  00a89	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a8e	ff b5 64 7f ff
	ff		 push	 DWORD PTR _vAttackDir$GSCopy$[ebp]
  00a94	8b cb		 mov	 ecx, ebx
  00a96	ff b5 bc 7f ff
	ff		 push	 DWORD PTR _bApplyPushPower$[ebp]
  00a9c	56		 push	 esi
  00a9d	e8 00 00 00 00	 call	 ?ApplyWeaponWoundedPushBlowPower@ioBaseChar@@IAEXPAVioWeapon@@_NABUD3DXVECTOR3@@MAAM1@Z ; ioBaseChar::ApplyWeaponWoundedPushBlowPower

; 2605 : 
; 2606 : 	//--- 
; 2607 : 	bool bEnableTeamAttack;
; 2608 : 	bool bTeamAttackNoDamage;
; 2609 : 	ioHashString szDefenseBreakBuff;

  00aa2	8d 8d cc 7e ff
	ff		 lea	 ecx, DWORD PTR _szDefenseBreakBuff$[ebp]
  00aa8	ff d7		 call	 edi

; 2610 : 	bool bLandStunBuff;
; 2611 : 	BuffInfoList kAddBuffList;

  00aaa	33 c0		 xor	 eax, eax
  00aac	89 85 30 7f ff
	ff		 mov	 DWORD PTR _kAddBuffList$[ebp], eax
  00ab2	89 85 34 7f ff
	ff		 mov	 DWORD PTR _kAddBuffList$[ebp+4], eax
  00ab8	89 85 38 7f ff
	ff		 mov	 DWORD PTR _kAddBuffList$[ebp+8], eax

; 2612 : 	ApplyWeaponWoundedAddBuff( pWeapon, pAttacker, bApplyPushPower, bEnableCancel, bTeamAttack, bEnableTeamAttack, bTeamAttackNoDamage, 
; 2613 : 								bPrisoner, szFrontBackWoundBuff, szFrontBackAttackerBuff, szDefenseBreakBuff, 
; 2614 : 								bAirTargetBuff, bTargetBuff, bDownTargetBuff, eBreakType, bLandStunBuff, kAddBuffList );	

  00abe	8d 85 30 7f ff
	ff		 lea	 eax, DWORD PTR _kAddBuffList$[ebp]
  00ac4	50		 push	 eax
  00ac5	8d 85 78 7f ff
	ff		 lea	 eax, DWORD PTR _bLandStunBuff$[ebp]
  00acb	50		 push	 eax
  00acc	ff b5 94 7f ff
	ff		 push	 DWORD PTR _eBreakType$[ebp]
  00ad2	8d 85 cc 7e ff
	ff		 lea	 eax, DWORD PTR _szDefenseBreakBuff$[ebp]
  00ad8	ff b5 20 7f ff
	ff		 push	 DWORD PTR _bDownTargetBuff$[ebp]
  00ade	8b cb		 mov	 ecx, ebx
  00ae0	ff b5 24 7f ff
	ff		 push	 DWORD PTR _bTargetBuff$[ebp]
  00ae6	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00aea	ff b5 70 7f ff
	ff		 push	 DWORD PTR _bAirTargetBuff$[ebp]
  00af0	50		 push	 eax
  00af1	8d 85 ec 7e ff
	ff		 lea	 eax, DWORD PTR _szFrontBackAttackerBuff$[ebp]
  00af7	50		 push	 eax
  00af8	8d 85 dc 7e ff
	ff		 lea	 eax, DWORD PTR _szFrontBackWoundBuff$[ebp]
  00afe	50		 push	 eax
  00aff	ff b5 48 7f ff
	ff		 push	 DWORD PTR _bPrisoner$[ebp]
  00b05	8d 85 79 7f ff
	ff		 lea	 eax, DWORD PTR _bTeamAttackNoDamage$[ebp]
  00b0b	50		 push	 eax
  00b0c	8d 85 7a 7f ff
	ff		 lea	 eax, DWORD PTR _bEnableTeamAttack$[ebp]
  00b12	50		 push	 eax
  00b13	ff b5 88 7f ff
	ff		 push	 DWORD PTR _bTeamAttack$[ebp]
  00b19	ff b5 58 7f ff
	ff		 push	 DWORD PTR _bEnableCancel$[ebp]
  00b1f	ff b5 bc 7f ff
	ff		 push	 DWORD PTR _bApplyPushPower$[ebp]
  00b25	ff b5 c0 7f ff
	ff		 push	 DWORD PTR _pAttacker$[ebp]
  00b2b	56		 push	 esi
  00b2c	e8 00 00 00 00	 call	 ?ApplyWeaponWoundedAddBuff@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_N22AA_N32AAVioHashString@@44222W4DefenseBreakType@@3AAV?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@@Z ; ioBaseChar::ApplyWeaponWoundedAddBuff

; 2615 : 
; 2616 : 	// buff add 
; 2617 : 	if( bApplyPushPower )

  00b31	80 bd bc 7f ff
	ff 00		 cmp	 BYTE PTR _bApplyPushPower$[ebp], 0
  00b38	74 0a		 je	 SHORT $LN46@ApplyWeapo@26

; 2618 : 		pWeapon->CheckWeaponCollision();

  00b3a	8b 06		 mov	 eax, DWORD PTR [esi]
  00b3c	8b ce		 mov	 ecx, esi
  00b3e	ff 90 0c 01 00
	00		 call	 DWORD PTR [eax+268]
$LN46@ApplyWeapo@26:

; 2619 : 
; 2620 : 	//--- 
; 2621 : 	bool bEnableHitCount = true;
; 2622 : 	if( !bApplyPushPower || pWeapon->HasFeature(WF_DISABLE_HIT_COUNT) )

  00b44	80 bd bc 7f ff
	ff 00		 cmp	 BYTE PTR _bApplyPushPower$[ebp], 0
  00b4b	c6 85 c7 7f ff
	ff 01		 mov	 BYTE PTR _bEnableHitCount$[ebp], 1
  00b52	74 10		 je	 SHORT $LN44@ApplyWeapo@26
  00b54	68 00 08 00 00	 push	 2048			; 00000800H
  00b59	8b ce		 mov	 ecx, esi
  00b5b	e8 00 00 00 00	 call	 ?HasFeature@ioWeapon@@QBE_NK@Z ; ioWeapon::HasFeature
  00b60	84 c0		 test	 al, al
  00b62	74 07		 je	 SHORT $LN45@ApplyWeapo@26
$LN44@ApplyWeapo@26:

; 2623 : 		bEnableHitCount = false;

  00b64	c6 85 c7 7f ff
	ff 00		 mov	 BYTE PTR _bEnableHitCount$[ebp], 0
$LN45@ApplyWeapo@26:

; 2624 : 
; 2625 : 	if( pWeapon->GetTeam() != GetTeam() && bEnableHitCount )

  00b6b	8d 85 60 7f ff
	ff		 lea	 eax, DWORD PTR _value$702720[ebp]
  00b71	50		 push	 eax
  00b72	8d 4e 30	 lea	 ecx, DWORD PTR [esi+48]
  00b75	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  00b7a	8d 85 fc 7e ff
	ff		 lea	 eax, DWORD PTR _value$702733[ebp]
  00b80	50		 push	 eax
  00b81	8d 8b 90 00 00
	00		 lea	 ecx, DWORD PTR [ebx+144]
  00b87	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  00b8c	8b 85 60 7f ff
	ff		 mov	 eax, DWORD PTR _value$702720[ebp]
  00b92	3b 85 fc 7e ff
	ff		 cmp	 eax, DWORD PTR _value$702733[ebp]
  00b98	74 18		 je	 SHORT $LN259@ApplyWeapo@26
  00b9a	80 bd c7 7f ff
	ff 00		 cmp	 BYTE PTR _bEnableHitCount$[ebp], 0
  00ba1	74 0f		 je	 SHORT $LN259@ApplyWeapo@26

; 2626 : 	{
; 2627 : 		//pAttacker->CheckRealComboHit( GetCharName() );
; 2628 : 		pAttacker->CheckComboSkillHit();

  00ba3	8b bd c0 7f ff
	ff		 mov	 edi, DWORD PTR _pAttacker$[ebp]
  00ba9	8b cf		 mov	 ecx, edi
  00bab	e8 00 00 00 00	 call	 ?CheckComboSkillHit@ioBaseChar@@QAE_NXZ ; ioBaseChar::CheckComboSkillHit
  00bb0	eb 06		 jmp	 SHORT $LN43@ApplyWeapo@26
$LN259@ApplyWeapo@26:
  00bb2	8b bd c0 7f ff
	ff		 mov	 edi, DWORD PTR _pAttacker$[ebp]
$LN43@ApplyWeapo@26:

; 2629 : 	}
; 2630 : 
; 2631 : 	//---ActionStopDelay
; 2632 : 	int iShakeCamera;
; 2633 : 	bool bTargetDie;
; 2634 : 	ActionStopType eActionStype;
; 2635 : 	ApplyWeaponWoundedActionStopDelay( pWeapon, pAttacker, iShakeCamera, bTargetDie, eActionStype, bProtectShakeCamera, bCharDie, bStructWeapon, fDamage, bApplyPushPower );

  00bb8	ff b5 bc 7f ff
	ff		 push	 DWORD PTR _bApplyPushPower$[ebp]
  00bbe	f3 0f 10 85 c8
	7f ff ff	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  00bc6	51		 push	 ecx
  00bc7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bcc	ff b5 8c 7f ff
	ff		 push	 DWORD PTR _bStructWeapon$[ebp]
  00bd2	8d 85 00 7f ff
	ff		 lea	 eax, DWORD PTR _eActionStype$[ebp]
  00bd8	ff b5 84 7f ff
	ff		 push	 DWORD PTR _bCharDie$[ebp]
  00bde	8b cb		 mov	 ecx, ebx
  00be0	ff b5 00 7f ff
	ff		 push	 DWORD PTR _bProtectShakeCamera$[ebp]
  00be6	50		 push	 eax
  00be7	8d 85 58 7f ff
	ff		 lea	 eax, DWORD PTR _bTargetDie$[ebp]
  00bed	50		 push	 eax
  00bee	8d 85 60 7f ff
	ff		 lea	 eax, DWORD PTR _iShakeCamera$[ebp]
  00bf4	50		 push	 eax
  00bf5	57		 push	 edi
  00bf6	56		 push	 esi
  00bf7	e8 00 00 00 00	 call	 ?ApplyWeaponWoundedActionStopDelay@ioBaseChar@@IAEXPAVioWeapon@@PAV1@AAHAA_NAAW4ActionStopType@@_N55M5@Z ; ioBaseChar::ApplyWeaponWoundedActionStopDelay

; 2636 : 
; 2637 : 	//--- 
; 2638 : 	bool bNoChangeGrappling;
; 2639 : 	ApplyWeaponWoundedGrappling( pWeapon, bNoChangeGrappling, bApplyPushPower, bTargetDie, bPrisoner, eCheckCharState );

  00bfc	ff b5 8c 7e ff
	ff		 push	 DWORD PTR _eCheckCharState$[ebp]
  00c02	8d 85 80 7f ff
	ff		 lea	 eax, DWORD PTR _bNoChangeGrappling$[ebp]
  00c08	ff b5 48 7f ff
	ff		 push	 DWORD PTR _bPrisoner$[ebp]
  00c0e	8b cb		 mov	 ecx, ebx
  00c10	ff b5 58 7f ff
	ff		 push	 DWORD PTR _bTargetDie$[ebp]
  00c16	ff b5 bc 7f ff
	ff		 push	 DWORD PTR _bApplyPushPower$[ebp]
  00c1c	50		 push	 eax
  00c1d	56		 push	 esi
  00c1e	e8 00 00 00 00	 call	 ?ApplyWeaponWoundedGrappling@ioBaseChar@@IAEXPAVioWeapon@@AA_N_N22W4CharState@@@Z ; ioBaseChar::ApplyWeaponWoundedGrappling

; 2640 : 
; 2641 : 	int eCurState = m_CharState;
; 2642 : 
; 2643 : 	if( bCharDie )

  00c23	80 bd 84 7f ff
	ff 00		 cmp	 BYTE PTR _bCharDie$[ebp], 0
  00c2a	8a 83 10 03 00
	00		 mov	 al, BYTE PTR [ebx+784]
  00c30	0f b6 c8	 movzx	 ecx, al
  00c33	89 8d a0 7f ff
	ff		 mov	 DWORD PTR _eCurState$[ebp], ecx
  00c39	74 3d		 je	 SHORT $LN42@ApplyWeapo@26

; 2644 : 	{
; 2645 : 		if( m_pEquipSlot && ( !m_pEquipSlot->IsEquipWait() || ToNpcChar( this ) || IsGangsi() ) )

  00c3b	8b 8b 48 03 00
	00		 mov	 ecx, DWORD PTR [ebx+840]
  00c41	85 c9		 test	 ecx, ecx
  00c43	74 64		 je	 SHORT $LN37@ApplyWeapo@26
  00c45	e8 00 00 00 00	 call	 ?IsEquipWait@ioEquipSlot@@QAE_NXZ ; ioEquipSlot::IsEquipWait
  00c4a	84 c0		 test	 al, al
  00c4c	74 13		 je	 SHORT $LN40@ApplyWeapo@26
  00c4e	53		 push	 ebx
  00c4f	e8 00 00 00 00	 call	 ?ToNpcChar@@YAPAVioNpcChar@@PAVioGameEntity@@@Z ; ToNpcChar
  00c54	59		 pop	 ecx
  00c55	85 c0		 test	 eax, eax
  00c57	75 08		 jne	 SHORT $LN40@ApplyWeapo@26
  00c59	38 83 f8 23 00
	00		 cmp	 BYTE PTR [ebx+9208], al
  00c5f	74 48		 je	 SHORT $LN37@ApplyWeapo@26
$LN40@ApplyWeapo@26:

; 2646 : 			OnWeaponDie( GetLastAttackerName(), GetLastAttackerSkillName() );

  00c61	8d 83 bc 13 00
	00		 lea	 eax, DWORD PTR [ebx+5052]
  00c67	50		 push	 eax
  00c68	8d 83 ac 13 00
	00		 lea	 eax, DWORD PTR [ebx+5036]
  00c6e	50		 push	 eax
  00c6f	8b cb		 mov	 ecx, ebx
  00c71	e8 00 00 00 00	 call	 ?OnWeaponDie@ioBaseChar@@QAEXABVioHashString@@0@Z ; ioBaseChar::OnWeaponDie

; 2647 : 	}
; 2648 : 	else

  00c76	eb 31		 jmp	 SHORT $LN37@ApplyWeapo@26
$LN42@ApplyWeapo@26:

; 2649 : 	{
; 2650 : 		if( pWeapon->CheckWeaponBySkill() )

  00c78	80 be 7e 05 00
	00 00		 cmp	 BYTE PTR [esi+1406], 0
  00c7f	74 28		 je	 SHORT $LN37@ApplyWeapo@26

; 2651 : 		{
; 2652 : 			if( m_CharState == CS_BLOW_WOUNDED ||
; 2653 : 				m_CharState == CS_BOUND_BLOW_WOUNDED ||
; 2654 : 				m_CharState == CS_WOUNDED ||
; 2655 : 				m_CharState == CS_BLOW_EXTEND_WOUND )

  00c81	3c 0c		 cmp	 al, 12			; 0000000cH
  00c83	74 0c		 je	 SHORT $LN36@ApplyWeapo@26
  00c85	3c 31		 cmp	 al, 49			; 00000031H
  00c87	74 08		 je	 SHORT $LN36@ApplyWeapo@26
  00c89	3c 0b		 cmp	 al, 11			; 0000000bH
  00c8b	74 04		 je	 SHORT $LN36@ApplyWeapo@26
  00c8d	3c 46		 cmp	 al, 70			; 00000046H
  00c8f	75 18		 jne	 SHORT $LN37@ApplyWeapo@26
$LN36@ApplyWeapo@26:

; 2656 : 			{
; 2657 : 				g_CameraEventMgr.CreateCE( m_dwOwnerSkillWoundedCameraEvent, m_pCreator );

  00c91	ff b3 44 03 00
	00		 push	 DWORD PTR [ebx+836]
  00c97	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_dwOwnerSkillWoundedCameraEvent@ioBaseCharParent@@2KA ; ioBaseCharParent::m_dwOwnerSkillWoundedCameraEvent
  00c9d	e8 00 00 00 00	 call	 ?GetSingleton@ioCameraEventManager@@SAAAV1@XZ ; ioCameraEventManager::GetSingleton
  00ca2	8b c8		 mov	 ecx, eax
  00ca4	e8 00 00 00 00	 call	 ?CreateCE@ioCameraEventManager@@QAEPAVioCameraEvent@@KPAVioPlayStage@@@Z ; ioCameraEventManager::CreateCE
$LN37@ApplyWeapo@26:

; 2658 : 			}
; 2659 : 		}
; 2660 : 	}
; 2661 : 
; 2662 : 	bool bBuffCreate = false;
; 2663 : 	if( pWeapon->CheckWeaponByBuff() )

  00ca9	80 be 7c 05 00
	00 00		 cmp	 BYTE PTR [esi+1404], 0
  00cb0	c6 85 9a 7f ff
	ff 00		 mov	 BYTE PTR _bBuffCreate$[ebp], 0
  00cb7	74 07		 je	 SHORT $LN35@ApplyWeapo@26

; 2664 : 		bBuffCreate = true;

  00cb9	c6 85 9a 7f ff
	ff 01		 mov	 BYTE PTR _bBuffCreate$[ebp], 1
$LN35@ApplyWeapo@26:

; 2665 : 
; 2666 : 	//--- 
; 2667 : 	if( IsNeedSendNetwork() )

  00cc0	8b 03		 mov	 eax, DWORD PTR [ebx]
  00cc2	8b cb		 mov	 ecx, ebx
  00cc4	ff 90 04 01 00
	00		 call	 DWORD PTR [eax+260]
  00cca	84 c0		 test	 al, al
  00ccc	0f 84 91 0b 00
	00		 je	 $LN34@ApplyWeapo@26

; 2668 : 	{
; 2669 : 		SP2Packet kPacket( CUPK_WEAPON_WOUNDED );

  00cd2	68 14 41 00 00	 push	 16660			; 00004114H
  00cd7	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  00cdd	e8 00 00 00 00	 call	 ??0SP2Packet@@QAE@K@Z	; SP2Packet::SP2Packet

; 2670 : 		kPacket << GetCharName();

  00ce2	8d 83 d4 02 00
	00		 lea	 eax, DWORD PTR [ebx+724]
  00ce8	50		 push	 eax
  00ce9	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  00cef	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00cf3	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z ; SP2Packet::operator<<

; 2671 : 		kPacket << P2PNetwork::GetNextSendIndex( IsNpcChar( this ) );

  00cf8	53		 push	 ebx
  00cf9	e8 00 00 00 00	 call	 ?IsNpcChar@@YA_NPAVioGameEntity@@@Z ; IsNpcChar
  00cfe	0f b6 c0	 movzx	 eax, al
  00d01	50		 push	 eax
  00d02	e8 00 00 00 00	 call	 ?GetNextSendIndex@P2PNetwork@@YAH_N@Z ; P2PNetwork::GetNextSendIndex
  00d07	59		 pop	 ecx
  00d08	59		 pop	 ecx
  00d09	50		 push	 eax
  00d0a	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  00d10	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@H@Z ; SP2Packet::operator<<

; 2672 : 
; 2673 : 		kPacket << pWeapon->GetWeaponBySkillName();

  00d15	8b ce		 mov	 ecx, esi
  00d17	e8 00 00 00 00	 call	 ?GetWeaponBySkillName@ioWeapon@@QBEABVioHashString@@XZ ; ioWeapon::GetWeaponBySkillName
  00d1c	50		 push	 eax
  00d1d	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  00d23	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z ; SP2Packet::operator<<

; 2674 : 		kPacket << (BYTE)iWeaponType;

  00d28	ff b5 98 7e ff
	ff		 push	 DWORD PTR _iWeaponType$[ebp]
  00d2e	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  00d34	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<

; 2675 : 		kPacket << dwAttackerWeaponItemCode;

  00d39	ff b5 10 7f ff
	ff		 push	 DWORD PTR _dwAttackerWeaponItemCode$[ebp]
  00d3f	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  00d45	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@K@Z ; SP2Packet::operator<<

; 2676 : 
; 2677 : 		kPacket << pWeapon->GetWeaponIndex();

  00d4a	ff b6 b8 04 00
	00		 push	 DWORD PTR [esi+1208]
  00d50	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  00d56	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@K@Z ; SP2Packet::operator<<

; 2678 : 		kPacket << pWeapon->GetAttributeIndex();

  00d5b	8b ce		 mov	 ecx, esi
  00d5d	e8 00 00 00 00	 call	 ?GetAttributeIndex@ioWeapon@@QBEHXZ ; ioWeapon::GetAttributeIndex
  00d62	50		 push	 eax
  00d63	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  00d69	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@H@Z ; SP2Packet::operator<<

; 2679 : 		kPacket << pAttacker->GetCharName();

  00d6e	ff b5 a8 7f ff
	ff		 push	 DWORD PTR tv1891[ebp]
  00d74	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  00d7a	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z ; SP2Packet::operator<<

; 2680 : 
; 2681 : 		kPacket << (BYTE)m_AttackedSide;

  00d7f	0f b6 83 d4 0e
	00 00		 movzx	 eax, BYTE PTR [ebx+3796]
  00d86	50		 push	 eax
  00d87	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  00d8d	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<

; 2682 : 		kPacket << (BYTE)eNewBlowType;

  00d92	ff b5 18 7f ff
	ff		 push	 DWORD PTR _eNewBlowType$[ebp]
  00d98	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  00d9e	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<

; 2683 : 		kPacket << floatToHALF(m_HP.m_fCurValue);

  00da3	8d 85 a8 7f ff
	ff		 lea	 eax, DWORD PTR _value$702767[ebp]
  00da9	50		 push	 eax
  00daa	8d 8b c0 00 00
	00		 lea	 ecx, DWORD PTR [ebx+192]
  00db0	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  00db5	f3 0f 10 85 a8
	7f ff ff	 movss	 xmm0, DWORD PTR _value$702767[ebp]
  00dbd	51		 push	 ecx
  00dbe	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00dc3	e8 00 00 00 00	 call	 ?floatToHALF@@YAGM@Z	; floatToHALF
  00dc8	0f b7 c0	 movzx	 eax, ax
  00dcb	59		 pop	 ecx
  00dcc	50		 push	 eax
  00dcd	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  00dd3	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@G@Z ; SP2Packet::operator<<

; 2684 : 
; 2685 : 		for( int i=ES_WEAPON; i < ES_OBJECT; i++ )

  00dd8	33 f6		 xor	 esi, esi
$LL33@ApplyWeapo@26:

; 2686 : 		{
; 2687 : 			ioItem *pItem = GetEquipedItem( i );

  00dda	56		 push	 esi
  00ddb	8b cb		 mov	 ecx, ebx
  00ddd	e8 00 00 00 00	 call	 ?GetEquipedItem@ioBaseChar@@QAEPAVioItem@@H@Z ; ioBaseChar::GetEquipedItem

; 2688 : 			if( pItem )

  00de2	85 c0		 test	 eax, eax
  00de4	74 20		 je	 SHORT $LN30@ApplyWeapo@26

; 2689 : 				kPacket << (BYTE)pItem->GetCurSkillGuage();

  00de6	8d 88 f4 03 00
	00		 lea	 ecx, DWORD PTR [eax+1012]
  00dec	8d 85 a8 7f ff
	ff		 lea	 eax, DWORD PTR _value$702779[ebp]
  00df2	50		 push	 eax
  00df3	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  00df8	f3 0f 2c 85 a8
	7f ff ff	 cvttss2si eax, DWORD PTR _value$702779[ebp]
  00e00	0f b6 c0	 movzx	 eax, al
  00e03	50		 push	 eax

; 2690 : 			else

  00e04	eb 02		 jmp	 SHORT $LN271@ApplyWeapo@26
$LN30@ApplyWeapo@26:

; 2691 : 				kPacket << (BYTE)0.0f;

  00e06	6a 00		 push	 0
$LN271@ApplyWeapo@26:
  00e08	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  00e0e	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<
  00e13	46		 inc	 esi
  00e14	83 fe 04	 cmp	 esi, 4
  00e17	7c c1		 jl	 SHORT $LL33@ApplyWeapo@26

; 2692 : 		}
; 2693 : 
; 2694 : 		UpdateMoveDir2BYTE();

  00e19	8b cb		 mov	 ecx, ebx
  00e1b	e8 00 00 00 00	 call	 ?UpdateMoveDir2BYTE@ioBaseChar@@IAEXXZ ; ioBaseChar::UpdateMoveDir2BYTE

; 2695 : 		UpdateInputDir2BYTE();

  00e20	8b cb		 mov	 ecx, ebx
  00e22	e8 00 00 00 00	 call	 ?UpdateInputDir2BYTE@ioBaseChar@@IAEXXZ ; ioBaseChar::UpdateInputDir2BYTE

; 2696 : 		UpdateForceDir2BYTE();

  00e27	8b cb		 mov	 ecx, ebx
  00e29	e8 00 00 00 00	 call	 ?UpdateForceDir2BYTE@ioBaseChar@@IAEXXZ ; ioBaseChar::UpdateForceDir2BYTE

; 2697 : 
; 2698 : 		kPacket << floatToHALF(m_fCurMoveSpeed);

  00e2e	8d 85 a8 7f ff
	ff		 lea	 eax, DWORD PTR _value$702784[ebp]
  00e34	50		 push	 eax
  00e35	8d 8b 3c 09 00
	00		 lea	 ecx, DWORD PTR [ebx+2364]
  00e3b	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  00e40	f3 0f 10 85 a8
	7f ff ff	 movss	 xmm0, DWORD PTR _value$702784[ebp]
  00e48	51		 push	 ecx
  00e49	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00e4e	e8 00 00 00 00	 call	 ?floatToHALF@@YAGM@Z	; floatToHALF
  00e53	0f b7 c0	 movzx	 eax, ax
  00e56	59		 pop	 ecx
  00e57	50		 push	 eax
  00e58	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  00e5e	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@G@Z ; SP2Packet::operator<<

; 2699 : 		kPacket << m_byAngleMoveDir << m_byAngleInputDir << m_byAngleForceDirX << m_byAngleForceDirY << m_byAngleForceDirZ;

  00e63	0f b6 83 d0 06
	00 00		 movzx	 eax, BYTE PTR [ebx+1744]
  00e6a	50		 push	 eax
  00e6b	0f b6 83 cf 06
	00 00		 movzx	 eax, BYTE PTR [ebx+1743]
  00e72	50		 push	 eax
  00e73	0f b6 83 ce 06
	00 00		 movzx	 eax, BYTE PTR [ebx+1742]
  00e7a	50		 push	 eax
  00e7b	0f b6 83 cd 06
	00 00		 movzx	 eax, BYTE PTR [ebx+1741]
  00e82	50		 push	 eax
  00e83	0f b6 83 cc 06
	00 00		 movzx	 eax, BYTE PTR [ebx+1740]
  00e8a	50		 push	 eax
  00e8b	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  00e91	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<
  00e96	8b c8		 mov	 ecx, eax
  00e98	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<
  00e9d	8b c8		 mov	 ecx, eax
  00e9f	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<
  00ea4	8b c8		 mov	 ecx, eax
  00ea6	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<
  00eab	8b c8		 mov	 ecx, eax
  00ead	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<

; 2700 : 		kPacket << floatToHALF(m_fForceAmt);

  00eb2	8d 85 a8 7f ff
	ff		 lea	 eax, DWORD PTR _value$702789[ebp]
  00eb8	50		 push	 eax
  00eb9	8d 8b 88 0b 00
	00		 lea	 ecx, DWORD PTR [ebx+2952]
  00ebf	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  00ec4	f3 0f 10 85 a8
	7f ff ff	 movss	 xmm0, DWORD PTR _value$702789[ebp]
  00ecc	51		 push	 ecx
  00ecd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ed2	e8 00 00 00 00	 call	 ?floatToHALF@@YAGM@Z	; floatToHALF
  00ed7	0f b7 c0	 movzx	 eax, ax
  00eda	59		 pop	 ecx
  00edb	50		 push	 eax
  00edc	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  00ee2	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@G@Z ; SP2Packet::operator<<

; 2701 : 		kPacket << floatToHALF(m_fForceFrictionRate);

  00ee7	8d 85 a8 7f ff
	ff		 lea	 eax, DWORD PTR _value$702794[ebp]
  00eed	50		 push	 eax
  00eee	8d 8b b8 0b 00
	00		 lea	 ecx, DWORD PTR [ebx+3000]
  00ef4	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  00ef9	f3 0f 10 85 a8
	7f ff ff	 movss	 xmm0, DWORD PTR _value$702794[ebp]
  00f01	51		 push	 ecx
  00f02	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f07	e8 00 00 00 00	 call	 ?floatToHALF@@YAGM@Z	; floatToHALF
  00f0c	0f b7 c0	 movzx	 eax, ax
  00f0f	59		 pop	 ecx
  00f10	50		 push	 eax
  00f11	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  00f17	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@G@Z ; SP2Packet::operator<<

; 2702 : 
; 2703 : 		BYTE bPack8 = ((int)m_bForcePowerLinear << 3) |
; 2704 : 			((int)bApplyPushPower << 2) |
; 2705 : 			((int)IsFloatingState() << 1) |
; 2706 : 			((int)IsFloating() << 0);

  00f1c	8d 85 ba 7f ff
	ff		 lea	 eax, DWORD PTR _value$702799[ebp]
  00f22	50		 push	 eax
  00f23	8d 8b 18 0c 00
	00		 lea	 ecx, DWORD PTR [ebx+3096]
  00f29	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  00f2e	8b cb		 mov	 ecx, ebx
  00f30	e8 00 00 00 00	 call	 ?IsFloatingState@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsFloatingState
  00f35	8a 8d ba 7f ff
	ff		 mov	 cl, BYTE PTR _value$702799[ebp]
  00f3b	02 c9		 add	 cl, cl
  00f3d	0a 8d bc 7f ff
	ff		 or	 cl, BYTE PTR _bApplyPushPower$[ebp]
  00f43	02 c9		 add	 cl, cl
  00f45	0a c1		 or	 al, cl
  00f47	02 c0		 add	 al, al
  00f49	8b cb		 mov	 ecx, ebx
  00f4b	88 85 ba 7f ff
	ff		 mov	 BYTE PTR tv1716[ebp], al
  00f51	e8 00 00 00 00	 call	 ?IsFloating@ioBaseChar@@QAE_NXZ ; ioBaseChar::IsFloating
  00f56	0a 85 ba 7f ff
	ff		 or	 al, BYTE PTR tv1716[ebp]
  00f5c	88 85 9c 7f ff
	ff		 mov	 BYTE PTR _bPack8$694847[ebp], al

; 2707 : 		kPacket << bPack8;

  00f62	ff b5 9c 7f ff
	ff		 push	 DWORD PTR _bPack8$694847[ebp]
  00f68	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  00f6e	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<

; 2708 : 
; 2709 : 		kPacket << (BYTE)iMagicResType;

  00f73	ff b5 88 7e ff
	ff		 push	 DWORD PTR _iMagicResType$[ebp]
  00f79	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  00f7f	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<

; 2710 : 		kPacket << (BYTE)iBombResType;

  00f84	ff b5 90 7f ff
	ff		 push	 DWORD PTR _iBombResType$[ebp]
  00f8a	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  00f90	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<

; 2711 : 		kPacket << floatToHALF(m_fCurJumpPowerAmt);

  00f95	f3 0f 10 83 90
	0e 00 00	 movss	 xmm0, DWORD PTR [ebx+3728]
  00f9d	51		 push	 ecx
  00f9e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00fa3	e8 00 00 00 00	 call	 ?floatToHALF@@YAGM@Z	; floatToHALF
  00fa8	0f b7 c0	 movzx	 eax, ax
  00fab	59		 pop	 ecx
  00fac	50		 push	 eax
  00fad	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  00fb3	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@G@Z ; SP2Packet::operator<<

; 2712 : 		kPacket << floatToHALF(m_fGravityAmt);

  00fb8	8d 85 90 7f ff
	ff		 lea	 eax, DWORD PTR _value$702804[ebp]
  00fbe	50		 push	 eax
  00fbf	8d 8b e8 0b 00
	00		 lea	 ecx, DWORD PTR [ebx+3048]
  00fc5	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  00fca	f3 0f 10 85 90
	7f ff ff	 movss	 xmm0, DWORD PTR _value$702804[ebp]
  00fd2	51		 push	 ecx
  00fd3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00fd8	e8 00 00 00 00	 call	 ?floatToHALF@@YAGM@Z	; floatToHALF
  00fdd	0f b7 c0	 movzx	 eax, ax
  00fe0	59		 pop	 ecx
  00fe1	50		 push	 eax
  00fe2	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  00fe8	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@G@Z ; SP2Packet::operator<<

; 2713 : 
; 2714 : 		D3DXVECTOR3 vPos = GetWorldPosition();

  00fed	8b 03		 mov	 eax, DWORD PTR [ebx]
  00fef	8b cb		 mov	 ecx, ebx
  00ff1	ff 50 70	 call	 DWORD PTR [eax+112]
  00ff4	8b f0		 mov	 esi, eax
  00ff6	8d 7d e4	 lea	 edi, DWORD PTR _vPos$694854[ebp]
  00ff9	a5		 movsd
  00ffa	a5		 movsd
  00ffb	a5		 movsd

; 2715 : 		kPacket << floatToHALF(vPos.x) << floatToHALF(vPos.y) << floatToHALF(vPos.z);

  00ffc	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _vPos$694854[ebp+8]
  01001	51		 push	 ecx
  01002	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01007	e8 00 00 00 00	 call	 ?floatToHALF@@YAGM@Z	; floatToHALF
  0100c	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _vPos$694854[ebp+4]
  01011	0f b7 c0	 movzx	 eax, ax
  01014	59		 pop	 ecx
  01015	50		 push	 eax
  01016	51		 push	 ecx
  01017	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0101c	e8 00 00 00 00	 call	 ?floatToHALF@@YAGM@Z	; floatToHALF
  01021	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _vPos$694854[ebp]
  01026	0f b7 c0	 movzx	 eax, ax
  01029	59		 pop	 ecx
  0102a	50		 push	 eax
  0102b	51		 push	 ecx
  0102c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01031	e8 00 00 00 00	 call	 ?floatToHALF@@YAGM@Z	; floatToHALF
  01036	0f b7 c0	 movzx	 eax, ax
  01039	59		 pop	 ecx
  0103a	50		 push	 eax
  0103b	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  01041	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@G@Z ; SP2Packet::operator<<
  01046	8b c8		 mov	 ecx, eax
  01048	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@G@Z ; SP2Packet::operator<<
  0104d	8b c8		 mov	 ecx, eax
  0104f	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@G@Z ; SP2Packet::operator<<

; 2716 : 		kPacket << m_halfRot[0] << m_halfRot[1] << m_halfRot[2];

  01054	0f b7 83 d6 06
	00 00		 movzx	 eax, WORD PTR [ebx+1750]
  0105b	50		 push	 eax
  0105c	0f b7 83 d4 06
	00 00		 movzx	 eax, WORD PTR [ebx+1748]
  01063	50		 push	 eax
  01064	0f b7 83 d2 06
	00 00		 movzx	 eax, WORD PTR [ebx+1746]
  0106b	50		 push	 eax
  0106c	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  01072	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@G@Z ; SP2Packet::operator<<
  01077	8b c8		 mov	 ecx, eax
  01079	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@G@Z ; SP2Packet::operator<<
  0107e	8b c8		 mov	 ecx, eax
  01080	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@G@Z ; SP2Packet::operator<<

; 2717 : 		kPacket << g_GlobalTimer.GetGlobalTime();

  01085	e8 00 00 00 00	 call	 ?GetSingleton@ioGlobalTimer@@SAAAV1@XZ ; ioGlobalTimer::GetSingleton
  0108a	8b c8		 mov	 ecx, eax
  0108c	e8 00 00 00 00	 call	 ?GetGlobalTime@ioGlobalTimer@@QBEKXZ ; ioGlobalTimer::GetGlobalTime
  01091	50		 push	 eax
  01092	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  01098	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@K@Z ; SP2Packet::operator<<

; 2718 : 		kPacket << floatToHALF(fDamage);

  0109d	f3 0f 10 85 c8
	7f ff ff	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  010a5	51		 push	 ecx
  010a6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  010ab	e8 00 00 00 00	 call	 ?floatToHALF@@YAGM@Z	; floatToHALF
  010b0	0f b7 c0	 movzx	 eax, ax
  010b3	59		 pop	 ecx
  010b4	50		 push	 eax
  010b5	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  010bb	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@G@Z ; SP2Packet::operator<<

; 2719 : 		kPacket << (BYTE)pWeapon->GetType();

  010c0	8b b5 08 7f ff
	ff		 mov	 esi, DWORD PTR _pWeapon$GSCopy$[ebp]
  010c6	8b 06		 mov	 eax, DWORD PTR [esi]
  010c8	8b ce		 mov	 ecx, esi
  010ca	ff 90 10 01 00
	00		 call	 DWORD PTR [eax+272]
  010d0	50		 push	 eax
  010d1	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  010d7	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<

; 2720 : 		kPacket << (BYTE)pWeapon->GetTeam();

  010dc	8d 85 90 7f ff
	ff		 lea	 eax, DWORD PTR _value$702815[ebp]
  010e2	50		 push	 eax
  010e3	8d 4e 30	 lea	 ecx, DWORD PTR [esi+48]
  010e6	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  010eb	ff b5 90 7f ff
	ff		 push	 DWORD PTR _value$702815[ebp]
  010f1	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  010f7	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<

; 2721 : 
; 2722 : 		kPacket << (BYTE)eCurState;

  010fc	ff b5 a0 7f ff
	ff		 push	 DWORD PTR _eCurState$[ebp]
  01102	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  01108	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<

; 2723 : 		bPack8 = ((int)m_bJumpedBlowWounded << 3) |
; 2724 : 			((int)m_bFallBlowWounded << 2) |
; 2725 : 			((int)bDefenseBroken << 1) |
; 2726 : 			((int)bLandStunBuff << 0);
; 2727 : 		kPacket << bPack8;

  0110d	8a 83 3e 0f 00
	00		 mov	 al, BYTE PTR [ebx+3902]
  01113	02 c0		 add	 al, al
  01115	0a 83 3c 0f 00
	00		 or	 al, BYTE PTR [ebx+3900]
  0111b	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  01121	02 c0		 add	 al, al
  01123	0a 85 9b 7f ff
	ff		 or	 al, BYTE PTR _bDefenseBroken$[ebp]
  01129	02 c0		 add	 al, al
  0112b	0a 85 78 7f ff
	ff		 or	 al, BYTE PTR _bLandStunBuff$[ebp]
  01131	0f b6 c0	 movzx	 eax, al
  01134	50		 push	 eax
  01135	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<

; 2728 : 
; 2729 : 		kPacket << floatToHALF(fDefenseEnableRate);

  0113a	f3 0f 10 85 04
	7f ff ff	 movss	 xmm0, DWORD PTR _fDefenseEnableRate$[ebp]
  01142	51		 push	 ecx
  01143	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01148	e8 00 00 00 00	 call	 ?floatToHALF@@YAGM@Z	; floatToHALF
  0114d	0f b7 c0	 movzx	 eax, ax
  01150	59		 pop	 ecx
  01151	50		 push	 eax
  01152	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  01158	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@G@Z ; SP2Packet::operator<<

; 2730 : 		kPacket << bWoundedLoopAni;

  0115d	ff b5 40 7f ff
	ff		 push	 DWORD PTR _bWoundedLoopAni$[ebp]
  01163	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  01169	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@_N@Z ; SP2Packet::operator<<

; 2731 : 
; 2732 : 		if( eCurState == CS_WOUNDED || eCurState == CS_GRAPPLING_WOUNDED_SKILL )

  0116e	83 bd a0 7f ff
	ff 0b		 cmp	 DWORD PTR _eCurState$[ebp], 11 ; 0000000bH
  01175	0f 84 08 01 00
	00		 je	 $LN27@ApplyWeapo@26
  0117b	83 bd a0 7f ff
	ff 43		 cmp	 DWORD PTR _eCurState$[ebp], 67 ; 00000043H
  01182	0f 84 fb 00 00
	00		 je	 $LN27@ApplyWeapo@26

; 2740 : 		}
; 2741 : 		else if( eCurState == CS_BOUND_BLOW_WOUNDED )

  01188	83 bd a0 7f ff
	ff 31		 cmp	 DWORD PTR _eCurState$[ebp], 49 ; 00000031H
  0118f	0f 85 91 00 00
	00		 jne	 $LN25@ApplyWeapo@26

; 2742 : 		{
; 2743 : 			kPacket << floatToHALF(fBoundDamage);

  01195	f3 0f 10 85 6c
	7f ff ff	 movss	 xmm0, DWORD PTR _fBoundDamage$[ebp]
  0119d	51		 push	 ecx
  0119e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  011a3	e8 00 00 00 00	 call	 ?floatToHALF@@YAGM@Z	; floatToHALF
  011a8	0f b7 c0	 movzx	 eax, ax
  011ab	59		 pop	 ecx
  011ac	50		 push	 eax
  011ad	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  011b3	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@G@Z ; SP2Packet::operator<<

; 2744 : 			kPacket << floatToHALF(fBoundJumpAmt);

  011b8	f3 0f 10 85 1c
	7f ff ff	 movss	 xmm0, DWORD PTR _fBoundJumpAmt$[ebp]
  011c0	51		 push	 ecx
  011c1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  011c6	e8 00 00 00 00	 call	 ?floatToHALF@@YAGM@Z	; floatToHALF
  011cb	0f b7 c0	 movzx	 eax, ax
  011ce	59		 pop	 ecx
  011cf	50		 push	 eax
  011d0	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  011d6	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@G@Z ; SP2Packet::operator<<

; 2745 : 			kPacket << floatToHALF(fBoundForceAmt);

  011db	f3 0f 10 85 2c
	7f ff ff	 movss	 xmm0, DWORD PTR _fBoundForceAmt$[ebp]
  011e3	51		 push	 ecx
  011e4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  011e9	e8 00 00 00 00	 call	 ?floatToHALF@@YAGM@Z	; floatToHALF
  011ee	0f b7 c0	 movzx	 eax, ax
  011f1	59		 pop	 ecx
  011f2	50		 push	 eax
  011f3	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  011f9	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@G@Z ; SP2Packet::operator<<

; 2746 : 			kPacket << floatToHALF(fBoundGrvityRate);

  011fe	f3 0f 10 85 7c
	7f ff ff	 movss	 xmm0, DWORD PTR _fBoundGrvityRate$[ebp]
$LN273@ApplyWeapo@26:
  01206	51		 push	 ecx
  01207	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0120c	e8 00 00 00 00	 call	 ?floatToHALF@@YAGM@Z	; floatToHALF
  01211	0f b7 c0	 movzx	 eax, ax
  01214	59		 pop	 ecx
  01215	50		 push	 eax
  01216	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  0121c	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@G@Z ; SP2Packet::operator<<
  01221	e9 a5 00 00 00	 jmp	 $LN23@ApplyWeapo@26
$LN25@ApplyWeapo@26:

; 2747 : 		}
; 2748 : 		else if( eCurState == CS_BLOW_EXTEND_WOUND )

  01226	83 bd a0 7f ff
	ff 46		 cmp	 DWORD PTR _eCurState$[ebp], 70 ; 00000046H
  0122d	0f 85 98 00 00
	00		 jne	 $LN23@ApplyWeapo@26

; 2749 : 		{
; 2750 : 			kPacket << szExtendWoundAni;

  01233	8d 85 bc 7e ff
	ff		 lea	 eax, DWORD PTR _szExtendWoundAni$[ebp]
  01239	50		 push	 eax
  0123a	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  01240	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z ; SP2Packet::operator<<

; 2751 : 			kPacket << dwExtendWoundDuration;

  01245	ff b5 54 7f ff
	ff		 push	 DWORD PTR _dwExtendWoundDuration$[ebp]
  0124b	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  01251	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@K@Z ; SP2Packet::operator<<

; 2752 : 			kPacket << floatToHALF(fExtendWoundJumpAmt);

  01256	f3 0f 10 85 50
	7f ff ff	 movss	 xmm0, DWORD PTR _fExtendWoundJumpAmt$[ebp]
  0125e	51		 push	 ecx
  0125f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01264	e8 00 00 00 00	 call	 ?floatToHALF@@YAGM@Z	; floatToHALF
  01269	0f b7 c0	 movzx	 eax, ax
  0126c	59		 pop	 ecx
  0126d	50		 push	 eax
  0126e	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  01274	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@G@Z ; SP2Packet::operator<<

; 2753 : 			kPacket << floatToHALF(fExtendWoundForceAmt);

  01279	f3 0f 10 85 ac
	7f ff ff	 movss	 xmm0, DWORD PTR _fExtendWoundForceAmt$[ebp]
  01281	eb 83		 jmp	 SHORT $LN273@ApplyWeapo@26
$LN27@ApplyWeapo@26:

; 2733 : 		{
; 2734 : 			BYTE bPack = ((int)bAllWeakWounded << 1) |
; 2735 : 				((int)bIgnorCatch << 0);

  01283	8a 85 81 7f ff
	ff		 mov	 al, BYTE PTR _bAllWeakWounded$[ebp]
  01289	02 c0		 add	 al, al
  0128b	0a 85 82 7f ff
	ff		 or	 al, BYTE PTR _bIgnorCatch$[ebp]

; 2736 : 
; 2737 : 			kPacket << szWoundAni;

  01291	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  01297	88 85 90 7f ff
	ff		 mov	 BYTE PTR _bPack$694864[ebp], al
  0129d	8d 85 9c 7e ff
	ff		 lea	 eax, DWORD PTR _szWoundAni$[ebp]
  012a3	50		 push	 eax
  012a4	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z ; SP2Packet::operator<<

; 2738 : 			kPacket << dwWoundDuration;

  012a9	ff b5 a4 7f ff
	ff		 push	 DWORD PTR _dwWoundDuration$[ebp]
  012af	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  012b5	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@K@Z ; SP2Packet::operator<<

; 2739 : 			kPacket << bPack;

  012ba	ff b5 90 7f ff
	ff		 push	 DWORD PTR _bPack$694864[ebp]
  012c0	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  012c6	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<
$LN23@ApplyWeapo@26:

; 2754 : 		}
; 2755 : 
; 2756 : 		kPacket << pWeapon->GetCreateItem();

  012cb	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  012ce	50		 push	 eax
  012cf	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  012d5	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z ; SP2Packet::operator<<

; 2757 : 		kPacket << GetRandomSeed();

  012da	ff b3 74 16 00
	00		 push	 DWORD PTR [ebx+5748]
  012e0	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  012e6	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@K@Z ; SP2Packet::operator<<

; 2758 : 		bPack8 = ((int)bTeamAttack << 3) |
; 2759 : 			((int)bEnableTeamAttack << 2) |
; 2760 : 			((int)bTeamAttackNoDamage << 1) |
; 2761 : 			((int)bPrisoner << 0);
; 2762 : 		kPacket << bPack8;

  012eb	8a 85 88 7f ff
	ff		 mov	 al, BYTE PTR _bTeamAttack$[ebp]
  012f1	02 c0		 add	 al, al
  012f3	0a 85 7a 7f ff
	ff		 or	 al, BYTE PTR _bEnableTeamAttack$[ebp]
  012f9	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  012ff	02 c0		 add	 al, al
  01301	0a 85 79 7f ff
	ff		 or	 al, BYTE PTR _bTeamAttackNoDamage$[ebp]
  01307	02 c0		 add	 al, al
  01309	0a 85 48 7f ff
	ff		 or	 al, BYTE PTR _bPrisoner$[ebp]
  0130f	0f b6 c0	 movzx	 eax, al
  01312	50		 push	 eax
  01313	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<

; 2763 : 
; 2764 : 		int iAddBuffCnt = kAddBuffList.size();

  01318	8b 85 34 7f ff
	ff		 mov	 eax, DWORD PTR _kAddBuffList$[ebp+4]
  0131e	2b 85 30 7f ff
	ff		 sub	 eax, DWORD PTR _kAddBuffList$[ebp]
  01324	6a 14		 push	 20			; 00000014H
  01326	59		 pop	 ecx
  01327	99		 cdq
  01328	f7 f9		 idiv	 ecx

; 2765 : 		kPacket << (BYTE)iAddBuffCnt;

  0132a	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  01330	50		 push	 eax
  01331	89 85 7c 7f ff
	ff		 mov	 DWORD PTR _iAddBuffCnt$694875[ebp], eax
  01337	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<

; 2766 : 		for( int j=0; j<iAddBuffCnt; ++j )

  0133c	83 bd 7c 7f ff
	ff 00		 cmp	 DWORD PTR _iAddBuffCnt$694875[ebp], 0
  01343	7e 64		 jle	 SHORT $LN20@ApplyWeapo@26

; 2754 : 		}
; 2755 : 
; 2756 : 		kPacket << pWeapon->GetCreateItem();

  01345	8b 85 7c 7f ff
	ff		 mov	 eax, DWORD PTR _iAddBuffCnt$694875[ebp]
  0134b	33 ff		 xor	 edi, edi
  0134d	89 85 ac 7f ff
	ff		 mov	 DWORD PTR tv1191[ebp], eax
$LL22@ApplyWeapo@26:

; 2767 : 		{
; 2768 : 			kPacket << kAddBuffList[j].m_BuffName;

  01353	8b 85 30 7f ff
	ff		 mov	 eax, DWORD PTR _kAddBuffList$[ebp]
  01359	03 c7		 add	 eax, edi
  0135b	50		 push	 eax
  0135c	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  01362	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z ; SP2Packet::operator<<

; 2769 : 			kPacket << (BYTE)kAddBuffList[j].m_iBuffType;

  01367	8b 85 30 7f ff
	ff		 mov	 eax, DWORD PTR _kAddBuffList$[ebp]
  0136d	0f b6 44 38 10	 movzx	 eax, BYTE PTR [eax+edi+16]
  01372	50		 push	 eax
  01373	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  01379	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<

; 2770 : 			kPacket << floatToHALF(pWeapon->GetOwnerChargeBuffDurationRate());

  0137e	8b ce		 mov	 ecx, esi
  01380	e8 00 00 00 00	 call	 ?GetOwnerChargeBuffDurationRate@ioWeapon@@QAEMXZ ; ioWeapon::GetOwnerChargeBuffDurationRate
  01385	51		 push	 ecx
  01386	d9 1c 24	 fstp	 DWORD PTR [esp]
  01389	e8 00 00 00 00	 call	 ?floatToHALF@@YAGM@Z	; floatToHALF
  0138e	0f b7 c0	 movzx	 eax, ax
  01391	59		 pop	 ecx
  01392	50		 push	 eax
  01393	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  01399	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@G@Z ; SP2Packet::operator<<
  0139e	83 c7 14	 add	 edi, 20			; 00000014H
  013a1	ff 8d ac 7f ff
	ff		 dec	 DWORD PTR tv1191[ebp]
  013a7	75 aa		 jne	 SHORT $LL22@ApplyWeapo@26
$LN20@ApplyWeapo@26:

; 2771 : 		}
; 2772 : 
; 2773 : 		kPacket << szDefenseBreakBuff;

  013a9	8d 85 cc 7e ff
	ff		 lea	 eax, DWORD PTR _szDefenseBreakBuff$[ebp]
  013af	50		 push	 eax
  013b0	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  013b6	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z ; SP2Packet::operator<<

; 2774 : 		kPacket << (BYTE)eBreakType;

  013bb	ff b5 94 7f ff
	ff		 push	 DWORD PTR _eBreakType$[ebp]
  013c1	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  013c7	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<

; 2775 : 
; 2776 : 		kPacket << szFrontBackWoundBuff;

  013cc	8d 85 dc 7e ff
	ff		 lea	 eax, DWORD PTR _szFrontBackWoundBuff$[ebp]
  013d2	50		 push	 eax
  013d3	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  013d9	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z ; SP2Packet::operator<<

; 2777 : 		kPacket << pWeapon->CheckWeaponByJump();

  013de	8a 86 7f 05 00
	00		 mov	 al, BYTE PTR [esi+1407]
  013e4	88 85 90 7f ff
	ff		 mov	 BYTE PTR $T702837[ebp], al
  013ea	ff b5 90 7f ff
	ff		 push	 DWORD PTR $T702837[ebp]
  013f0	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  013f6	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@_N@Z ; SP2Packet::operator<<

; 2778 : 
; 2779 : 		//Block
; 2780 : 		bPack8 = ((int)bApplyPushPower << 1) |
; 2781 : 			((int)bOnlyEmoticon);

  013fb	8a 85 bc 7f ff
	ff		 mov	 al, BYTE PTR _bApplyPushPower$[ebp]
  01401	02 c0		 add	 al, al
  01403	0a 85 28 7f ff
	ff		 or	 al, BYTE PTR _bOnlyEmoticon$[ebp]

; 2782 : 		kPacket << bPack8;

  01409	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  0140f	0f b6 c0	 movzx	 eax, al
  01412	50		 push	 eax
  01413	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<

; 2783 : 		kPacket << (BYTE)eBlockType;

  01418	ff b5 b0 7f ff
	ff		 push	 DWORD PTR _eBlockType$[ebp]
  0141e	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  01424	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<

; 2784 : 		kPacket << (BYTE)eProtectionType;

  01429	ff b5 4c 7f ff
	ff		 push	 DWORD PTR _eProtectionType$[ebp]
  0142f	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  01435	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<

; 2785 : 		kPacket << floatToHALF(fWeakAttackPushPower);

  0143a	f3 0f 10 85 90
	7e ff ff	 movss	 xmm0, DWORD PTR _fWeakAttackPushPower$[ebp]
  01442	51		 push	 ecx
  01443	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01448	e8 00 00 00 00	 call	 ?floatToHALF@@YAGM@Z	; floatToHALF
  0144d	0f b7 c0	 movzx	 eax, ax
  01450	59		 pop	 ecx
  01451	50		 push	 eax
  01452	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  01458	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@G@Z ; SP2Packet::operator<<

; 2786 : 
; 2787 : 		//Reflect
; 2788 : 		bPack8 = ((int)bPushAttacker << 2) |
; 2789 : 			((int)bStateProtectIgnoreReflect << 1) |
; 2790 : 			((int)bApplyStateProtect);
; 2791 : 		kPacket << bPack8;

  0145d	8a 85 83 7f ff
	ff		 mov	 al, BYTE PTR _bPushAttacker$[ebp]
  01463	02 c0		 add	 al, al
  01465	0a 85 7b 7f ff
	ff		 or	 al, BYTE PTR _bStateProtectIgnoreReflect$[ebp]
  0146b	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  01471	02 c0		 add	 al, al
  01473	0a 85 bb 7f ff
	ff		 or	 al, BYTE PTR _bApplyStateProtect$[ebp]
  01479	0f b6 c0	 movzx	 eax, al
  0147c	50		 push	 eax
  0147d	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<

; 2792 : 		float compactX, compactY;
; 2793 : 		encodeXYZ( vAttackDir, compactX, compactY );

  01482	8d 85 5c 7f ff
	ff		 lea	 eax, DWORD PTR _compactY$694891[ebp]
  01488	50		 push	 eax
  01489	8d 85 8c 7f ff
	ff		 lea	 eax, DWORD PTR _compactX$694890[ebp]
  0148f	50		 push	 eax
  01490	ff b5 64 7f ff
	ff		 push	 DWORD PTR _vAttackDir$GSCopy$[ebp]
  01496	e8 00 00 00 00	 call	 ?encodeXYZ@@YAXABUD3DXVECTOR3@@AAM1@Z ; encodeXYZ

; 2794 : 		kPacket << compactX << compactY;

  0149b	f3 0f 10 85 5c
	7f ff ff	 movss	 xmm0, DWORD PTR _compactY$694891[ebp]
  014a3	59		 pop	 ecx
  014a4	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  014aa	f3 0f 10 85 8c
	7f ff ff	 movss	 xmm0, DWORD PTR _compactX$694890[ebp]
  014b2	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  014b8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  014bd	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@M@Z ; SP2Packet::operator<<
  014c2	8b c8		 mov	 ecx, eax
  014c4	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@M@Z ; SP2Packet::operator<<

; 2795 : 		kPacket << floatToHALF(fAttackerPushPower);

  014c9	f3 0f 10 85 68
	7f ff ff	 movss	 xmm0, DWORD PTR _fAttackerPushPower$[ebp]
  014d1	51		 push	 ecx
  014d2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  014d7	e8 00 00 00 00	 call	 ?floatToHALF@@YAGM@Z	; floatToHALF
  014dc	0f b7 c0	 movzx	 eax, ax
  014df	59		 pop	 ecx
  014e0	50		 push	 eax
  014e1	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  014e7	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@G@Z ; SP2Packet::operator<<

; 2796 : 		kPacket << szReflectAni;

  014ec	8d 85 ac 7e ff
	ff		 lea	 eax, DWORD PTR _szReflectAni$[ebp]
  014f2	50		 push	 eax
  014f3	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  014f9	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z ; SP2Packet::operator<<

; 2797 : 		kPacket << floatToHALF(fReflectAniRate);

  014fe	f3 0f 10 85 b4
	7f ff ff	 movss	 xmm0, DWORD PTR _fReflectAniRate$[ebp]
  01506	51		 push	 ecx
  01507	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0150c	e8 00 00 00 00	 call	 ?floatToHALF@@YAGM@Z	; floatToHALF
  01511	59		 pop	 ecx
  01512	0f b7 c0	 movzx	 eax, ax
  01515	50		 push	 eax
  01516	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  0151c	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@G@Z ; SP2Packet::operator<<

; 2798 : 
; 2799 : 		//CollisionCancel
; 2800 : 		bPack8 = ((int)pWeapon->IsCollisionCancel() << 2) |
; 2801 : 			((int)bNoChangeGrappling << 1) |
; 2802 : 			((int)pWeapon->IsChangeJumpping( false, bAirTargetBuff ));

  01521	8d 85 bb 7f ff
	ff		 lea	 eax, DWORD PTR _value$702848[ebp]
  01527	50		 push	 eax
  01528	8d 8e 70 06 00
	00		 lea	 ecx, DWORD PTR [esi+1648]
  0152e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  01533	ff b5 70 7f ff
	ff		 push	 DWORD PTR _bAirTargetBuff$[ebp]
  01539	8b ce		 mov	 ecx, esi
  0153b	6a 00		 push	 0
  0153d	e8 00 00 00 00	 call	 ?IsChangeJumpping@ioWeapon@@QAE_N_N0@Z ; ioWeapon::IsChangeJumpping
  01542	8a 8d bb 7f ff
	ff		 mov	 cl, BYTE PTR _value$702848[ebp]
  01548	02 c9		 add	 cl, cl
  0154a	0a 8d 80 7f ff
	ff		 or	 cl, BYTE PTR _bNoChangeGrappling$[ebp]
  01550	02 c9		 add	 cl, cl
  01552	0a c1		 or	 al, cl
  01554	88 85 9c 7f ff
	ff		 mov	 BYTE PTR _bPack8$694847[ebp], al

; 2803 : 		kPacket << bPack8;

  0155a	ff b5 9c 7f ff
	ff		 push	 DWORD PTR _bPack8$694847[ebp]
  01560	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  01566	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<

; 2804 : 
; 2805 : 		//Grappling
; 2806 : 		kPacket << (BYTE)m_GrapplingType;

  0156b	0f b6 83 6c 34
	00 00		 movzx	 eax, BYTE PTR [ebx+13420]
  01572	50		 push	 eax
  01573	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  01579	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<

; 2807 : 		kPacket << szFrontBackAttackerBuff;

  0157e	8d 85 ec 7e ff
	ff		 lea	 eax, DWORD PTR _szFrontBackAttackerBuff$[ebp]
  01584	50		 push	 eax
  01585	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  0158b	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z ; SP2Packet::operator<<

; 2808 : 
; 2809 : 		kPacket << pWeapon->GetWeaponPeculiarity();

  01590	8b ce		 mov	 ecx, esi
  01592	e8 00 00 00 00	 call	 ?GetWeaponPeculiarity@ioWeapon@@QBEKXZ ; ioWeapon::GetWeaponPeculiarity
  01597	50		 push	 eax
  01598	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  0159e	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@K@Z ; SP2Packet::operator<<

; 2810 : 		kPacket << floatToHALF(pWeapon->GetChangeJumppingPowerRate());

  015a3	8d 85 b4 7f ff
	ff		 lea	 eax, DWORD PTR _value$702861[ebp]
  015a9	8d 8e ac 05 00
	00		 lea	 ecx, DWORD PTR [esi+1452]
  015af	50		 push	 eax
  015b0	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  015b5	f3 0f 10 85 b4
	7f ff ff	 movss	 xmm0, DWORD PTR _value$702861[ebp]
  015bd	51		 push	 ecx
  015be	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  015c3	e8 00 00 00 00	 call	 ?floatToHALF@@YAGM@Z	; floatToHALF
  015c8	0f b7 c0	 movzx	 eax, ax
  015cb	59		 pop	 ecx
  015cc	50		 push	 eax
  015cd	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  015d3	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@G@Z ; SP2Packet::operator<<

; 2811 : 		kPacket << (BYTE)pWeapon->GetChangeJumppingLimitCnt();

  015d8	8d 85 b4 7f ff
	ff		 lea	 eax, DWORD PTR _value$702874[ebp]
  015de	8d 8e dc 05 00
	00		 lea	 ecx, DWORD PTR [esi+1500]
  015e4	50		 push	 eax
  015e5	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ; CEncrypt<int>::DecryptValueToPool
  015ea	ff b5 b4 7f ff
	ff		 push	 DWORD PTR _value$702874[ebp]
  015f0	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  015f6	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<

; 2812 : 
; 2813 : 		kPacket << (BYTE)eActionStype;

  015fb	ff b5 00 7f ff
	ff		 push	 DWORD PTR _eActionStype$[ebp]
  01601	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  01607	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<

; 2814 : 		kPacket << (BYTE)iShakeCamera;	//  ,   ..

  0160c	ff b5 60 7f ff
	ff		 push	 DWORD PTR _iShakeCamera$[ebp]
  01612	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  01618	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<

; 2815 : 
; 2816 : 		bPack8 = ((int)bBuffCreate << 2) |
; 2817 : 			((int)bTargetDie << 1) |
; 2818 : 			((int)bEnableHitCount);

  0161d	8a 85 9a 7f ff
	ff		 mov	 al, BYTE PTR _bBuffCreate$[ebp]
  01623	02 c0		 add	 al, al
  01625	0a 85 58 7f ff
	ff		 or	 al, BYTE PTR _bTargetDie$[ebp]

; 2819 : 		kPacket << bPack8;

  0162b	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  01631	02 c0		 add	 al, al
  01633	0a 85 c7 7f ff
	ff		 or	 al, BYTE PTR _bEnableHitCount$[ebp]
  01639	88 85 9c 7f ff
	ff		 mov	 BYTE PTR _bPack8$694847[ebp], al
  0163f	ff b5 9c 7f ff
	ff		 push	 DWORD PTR _bPack8$694847[ebp]
  01645	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@E@Z ; SP2Packet::operator<<

; 2820 : 
; 2821 : 
; 2822 : 		P2PNetwork::SendToAllPlayingUser( kPacket );

  0164a	8d 85 cc 7f ff
	ff		 lea	 eax, DWORD PTR _kPacket$694834[ebp]
  01650	6a 00		 push	 0
  01652	50		 push	 eax
  01653	e8 00 00 00 00	 call	 ?SendToAllPlayingUser@P2PNetwork@@YAXAAVSP2Packet@@PAVioBaseChar@@@Z ; P2PNetwork::SendToAllPlayingUser
  01658	59		 pop	 ecx
  01659	59		 pop	 ecx

; 2823 : 		m_pCreator->NotifyOwnerSendControlInfo();

  0165a	8b 8b 44 03 00
	00		 mov	 ecx, DWORD PTR [ebx+836]
  01660	e8 00 00 00 00	 call	 ?NotifyOwnerSendControlInfo@ioPlayStage@@QAEXXZ ; ioPlayStage::NotifyOwnerSendControlInfo

; 2824 : 
; 2825 : 		if( bEnableHitCount )

  01665	80 bd c7 7f ff
	ff 00		 cmp	 BYTE PTR _bEnableHitCount$[ebp], 0
  0166c	0f 84 1d 01 00
	00		 je	 $LN258@ApplyWeapo@26

; 2826 : 		{
; 2827 : 			// 
; 2828 : 			if( GetTeam() != pAttacker->GetTeam() )

  01672	8d 85 b4 7f ff
	ff		 lea	 eax, DWORD PTR _value$702885[ebp]
  01678	50		 push	 eax
  01679	8d 8b 90 00 00
	00		 lea	 ecx, DWORD PTR [ebx+144]
  0167f	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  01684	8b bd c0 7f ff
	ff		 mov	 edi, DWORD PTR _pAttacker$[ebp]
  0168a	8d 85 68 7f ff
	ff		 lea	 eax, DWORD PTR _value$702898[ebp]
  01690	8d 8f 90 00 00
	00		 lea	 ecx, DWORD PTR [edi+144]
  01696	50		 push	 eax
  01697	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  0169c	8b 85 b4 7f ff
	ff		 mov	 eax, DWORD PTR _value$702885[ebp]
  016a2	3b 85 68 7f ff
	ff		 cmp	 eax, DWORD PTR _value$702898[ebp]
  016a8	0f 84 e7 00 00
	00		 je	 $LN17@ApplyWeapo@26

; 2829 : 			{
; 2830 : 				m_pModeParent->AttackCntContribute( pAttacker->GetCharName(), GetCharName(), dwAttackerWeaponItemCode );

  016ae	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  016b3	89 85 b4 7f ff
	ff		 mov	 DWORD PTR tv1759[ebp], eax
  016b9	db 85 b4 7f ff
	ff		 fild	 DWORD PTR tv1759[ebp]
  016bf	85 c0		 test	 eax, eax
  016c1	79 06		 jns	 SHORT $LN269@ApplyWeapo@26
  016c3	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN269@ApplyWeapo@26:
  016c9	e8 00 00 00 00	 call	 __ftol2_sse
  016ce	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  016d4	50		 push	 eax
  016d5	ff b5 10 7f ff
	ff		 push	 DWORD PTR _dwAttackerWeaponItemCode$[ebp]
  016db	8d 83 d4 02 00
	00		 lea	 eax, DWORD PTR [ebx+724]
  016e1	83 ec 10	 sub	 esp, 16			; 00000010H
  016e4	8b cc		 mov	 ecx, esp
  016e6	89 a5 b4 7f ff
	ff		 mov	 DWORD PTR $T702571[ebp], esp
  016ec	50		 push	 eax
  016ed	ff d6		 call	 esi
  016ef	83 ec 10	 sub	 esp, 16			; 00000010H
  016f2	8d 87 d4 02 00
	00		 lea	 eax, DWORD PTR [edi+724]
  016f8	8b cc		 mov	 ecx, esp
  016fa	89 a5 68 7f ff
	ff		 mov	 DWORD PTR $T702572[ebp], esp
  01700	50		 push	 eax
  01701	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  01705	ff d6		 call	 esi
  01707	8b 8b 8c 00 00
	00		 mov	 ecx, DWORD PTR [ebx+140]
  0170d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0170f	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  01713	ff 90 24 02 00
	00		 call	 DWORD PTR [eax+548]

; 2831 : 
; 2832 : 				if( m_pModeParent && m_pModeParent->GetModeType() != MT_FOOTBALL )

  01719	83 bb 8c 00 00
	00 00		 cmp	 DWORD PTR [ebx+140], 0
  01720	74 73		 je	 SHORT $LN17@ApplyWeapo@26
  01722	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  01727	83 f8 09	 cmp	 eax, 9
  0172a	74 69		 je	 SHORT $LN17@ApplyWeapo@26

; 2833 : 					g_AwardMgr.AddWounded( GetCharName(), 100.0f * m_pModeParent->ContributeTeamPerA( GetTeam(), 1.0f, 0.1f ) );

  0172c	8d 85 b4 7f ff
	ff		 lea	 eax, DWORD PTR _value$702920[ebp]
  01732	50		 push	 eax
  01733	8d 8b 90 00 00
	00		 lea	 ecx, DWORD PTR [ebx+144]
  01739	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  0173e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3dcccccd
  01746	6a 01		 push	 1
  01748	51		 push	 ecx
  01749	51		 push	 ecx
  0174a	8b 8b 8c 00 00
	00		 mov	 ecx, DWORD PTR [ebx+140]
  01750	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  01756	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0175e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01763	ff b5 b4 7f ff
	ff		 push	 DWORD PTR _value$702920[ebp]
  01769	e8 00 00 00 00	 call	 ?ContributeTeamPerA@ioPlayMode@@QAEMW4TeamType@@MM@Z ; ioPlayMode::ContributeTeamPerA
  0176e	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4059000000000000
  01774	e8 00 00 00 00	 call	 __ftol2_sse
  01779	50		 push	 eax
  0177a	8d 83 d4 02 00
	00		 lea	 eax, DWORD PTR [ebx+724]
  01780	50		 push	 eax
  01781	e8 00 00 00 00	 call	 ?GetSingleton@ioAwardManager@@SAAAV1@XZ ; ioAwardManager::GetSingleton
  01786	8b c8		 mov	 ecx, eax
  01788	e8 00 00 00 00	 call	 ?AddWounded@ioAwardManager@@QAEXABVioHashString@@HH@Z ; ioAwardManager::AddWounded
  0178d	eb 06		 jmp	 SHORT $LN17@ApplyWeapo@26
$LN258@ApplyWeapo@26:
  0178f	8b bd c0 7f ff
	ff		 mov	 edi, DWORD PTR _pAttacker$[ebp]
$LN17@ApplyWeapo@26:

; 2834 : 			}
; 2835 : 		}
; 2836 : 
; 2837 : 		//   
; 2838 : 		if( GetTeam() != pAttacker->GetTeam() )

  01795	8d 85 b4 7f ff
	ff		 lea	 eax, DWORD PTR _value$702936[ebp]
  0179b	50		 push	 eax
  0179c	8d 8b 90 00 00
	00		 lea	 ecx, DWORD PTR [ebx+144]
  017a2	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  017a7	8d 85 68 7f ff
	ff		 lea	 eax, DWORD PTR _value$702949[ebp]
  017ad	8d 8f 90 00 00
	00		 lea	 ecx, DWORD PTR [edi+144]
  017b3	50		 push	 eax
  017b4	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  017b9	8b 85 b4 7f ff
	ff		 mov	 eax, DWORD PTR _value$702936[ebp]
  017bf	3b 85 68 7f ff
	ff		 cmp	 eax, DWORD PTR _value$702949[ebp]
  017c5	74 28		 je	 SHORT $LN15@ApplyWeapo@26

; 2839 : 		{
; 2840 : 			if( m_pModeParent && m_pModeParent->GetModeType() != MT_FOOTBALL )

  017c7	83 bb 8c 00 00
	00 00		 cmp	 DWORD PTR [ebx+140], 0
  017ce	74 1f		 je	 SHORT $LN15@ApplyWeapo@26
  017d0	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  017d5	83 f8 09	 cmp	 eax, 9
  017d8	74 15		 je	 SHORT $LN15@ApplyWeapo@26

; 2841 : 				g_AwardMgr.AddHit( pAttacker->GetCharName() );

  017da	8d 87 d4 02 00
	00		 lea	 eax, DWORD PTR [edi+724]
  017e0	6a 01		 push	 1
  017e2	50		 push	 eax
  017e3	e8 00 00 00 00	 call	 ?GetSingleton@ioAwardManager@@SAAAV1@XZ ; ioAwardManager::GetSingleton
  017e8	8b c8		 mov	 ecx, eax
  017ea	e8 00 00 00 00	 call	 ?AddHit@ioAwardManager@@QAEXABVioHashString@@H@Z ; ioAwardManager::AddHit
$LN15@ApplyWeapo@26:

; 2842 : 		}
; 2843 : 
; 2844 : 		// NPC   
; 2845 : 		if( ToNpcChar( this ) )

  017ef	53		 push	 ebx
  017f0	e8 00 00 00 00	 call	 ?ToNpcChar@@YAPAVioNpcChar@@PAVioGameEntity@@@Z ; ToNpcChar
  017f5	59		 pop	 ecx
  017f6	85 c0		 test	 eax, eax
  017f8	74 15		 je	 SHORT $LN14@ApplyWeapo@26

; 2846 : 			g_AbuseMgr.AddDamage( (int)fDamage );

  017fa	f3 0f 2c 85 c8
	7f ff ff	 cvttss2si eax, DWORD PTR _fDamage$[ebp]
  01802	50		 push	 eax
  01803	e8 00 00 00 00	 call	 ?GetSingleton@ioAbuseManager@@SAAAV1@XZ ; ioAbuseManager::GetSingleton
  01808	8b c8		 mov	 ecx, eax
  0180a	e8 00 00 00 00	 call	 ?AddDamage@ioAbuseManager@@QAEXH@Z ; ioAbuseManager::AddDamage
$LN14@ApplyWeapo@26:

; 2847 : 
; 2848 : 		if( m_pModeParent->GetModeType() == MT_TEAM_SURVIVAL_AI  )

  0180f	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  01814	83 f8 16	 cmp	 eax, 22			; 00000016H
  01817	75 2f		 jne	 SHORT $LN12@ApplyWeapo@26

; 2849 : 		{
; 2850 : 			if( IsNpcChar(this) && fDamage > 0.f )

  01819	53		 push	 ebx
  0181a	e8 00 00 00 00	 call	 ?IsNpcChar@@YA_NPAVioGameEntity@@@Z ; IsNpcChar
  0181f	59		 pop	 ecx
  01820	84 c0		 test	 al, al
  01822	74 24		 je	 SHORT $LN12@ApplyWeapo@26
  01824	f3 0f 10 85 c8
	7f ff ff	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  0182c	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  01833	76 13		 jbe	 SHORT $LN12@ApplyWeapo@26

; 2851 : 			{
; 2852 : 				int iDamage = fDamage;

  01835	f3 0f 2c c0	 cvttss2si eax, xmm0

; 2853 : 				SetAggro( pAttacker->GetCharName(), iDamage );

  01839	50		 push	 eax
  0183a	8d 87 d4 02 00
	00		 lea	 eax, DWORD PTR [edi+724]
  01840	50		 push	 eax
  01841	8b cb		 mov	 ecx, ebx
  01843	e8 00 00 00 00	 call	 ?SetAggro@ioBaseChar@@QAEXABVioHashString@@H@Z ; ioBaseChar::SetAggro
$LN12@ApplyWeapo@26:

; 2854 : 			}
; 2855 : 		}
; 2856 : 
; 2857 : 
; 2858 : #ifdef ANTIHACK
; 2859 : 		// anti-hack : new wound check packet
; 2860 : 		BYTE eFireType = (BYTE)ANTIHACK_HIT_NORMAL;
; 2861 : 		switch( pWeapon->GetCreateFireTimeType() )
; 2862 : 		{
; 2863 : 		case FTT_SPECIAL_ATTACK:
; 2864 : 			eFireType = (BYTE)ANTIHACK_HIT_SPECIAL;
; 2865 : 			break;
; 2866 : 		case FTT_SKILL_ATTACK:
; 2867 : 			eFireType = (BYTE)ANTIHACK_HIT_SKILL;
; 2868 : 			break;
; 2869 : 		}
; 2870 : 
; 2871 : 		if(GetUserIndex() == g_MyInfo.GetUserIndex())
; 2872 : 		{
; 2873 : 			bool bNPCAttack = false;
; 2874 : 			if( ToNpcChar(pAttacker) )
; 2875 : 				bNPCAttack = true;
; 2876 : 
; 2877 : 			SP2Packet kAntiPacket( CUPK_ANTIHACK_CHAR_WOUNDED );			
; 2878 : 			if( bNPCAttack )
; 2879 : 				kAntiPacket << pAttacker->GetNPCIndex();
; 2880 : 			else
; 2881 : 				kAntiPacket << pAttacker->GetUserIndex();
; 2882 : 
; 2883 : 			kAntiPacket << pWeapon->GetWeaponIndex();
; 2884 : 			kAntiPacket << eFireType;
; 2885 : 			P2PNetwork::SendToAllPlayingUser( kAntiPacket );
; 2886 : 
; 2887 : 			if( g_bDetailLog )
; 2888 : 			{
; 2889 : 				if( g_bDetailLog )
; 2890 : 				{
; 2891 : 					if( bNPCAttack )
; 2892 : 						LOG.PrintTimeAndLog( 0, "CUPK_ANTIHACK_CHAR_WOUNDED - %u << %u, GetWeaponIndex(%u)", GetUserIndex(), pAttacker->GetNPCIndex(), pWeapon->GetWeaponIndex() );
; 2893 : 					else
; 2894 : 						LOG.PrintTimeAndLog( 0, "CUPK_ANTIHACK_CHAR_WOUNDED - %u << %u, GetWeaponIndex(%u)", GetUserIndex(), pAttacker->GetUserIndex(), pWeapon->GetWeaponIndex() );
; 2895 : 				}
; 2896 : 			}
; 2897 : 		}
; 2898 : 		else if( IsNpcChar(this) )
; 2899 : 		{
; 2900 : 			ioNpcChar* pNPC = ToNpcChar(this);
; 2901 : 			if( pNPC->GetSyncUser() == g_MyInfo.GetPublicID() )
; 2902 : 			{
; 2903 : 				bool bNPCAttack = false;
; 2904 : 				if( ToNpcChar(pAttacker) )
; 2905 : 					bNPCAttack = true;
; 2906 : 
; 2907 : 				SP2Packet kAntiPacket( CUPK_ANTIHACK_CHAR_WOUNDED );			
; 2908 : 				if( bNPCAttack )
; 2909 : 					kAntiPacket << pAttacker->GetNPCIndex();
; 2910 : 				else
; 2911 : 					kAntiPacket << pAttacker->GetUserIndex();
; 2912 : 
; 2913 : 				kAntiPacket << pWeapon->GetWeaponIndex();
; 2914 : 				kAntiPacket << eFireType;
; 2915 : 				P2PNetwork::SendToAllPlayingUser( kAntiPacket, this );
; 2916 : 
; 2917 : 				if( g_bDetailLog )
; 2918 : 				{
; 2919 : 					if( bNPCAttack )
; 2920 : 						LOG.PrintTimeAndLog( 0, "CUPK_ANTIHACK_CHAR_WOUNDED - %u << %u, GetWeaponIndex(%u)", GetNPCIndex(), pAttacker->GetNPCIndex(), pWeapon->GetWeaponIndex() );
; 2921 : 					else
; 2922 : 						LOG.PrintTimeAndLog( 0, "CUPK_ANTIHACK_CHAR_WOUNDED - %u << %u, GetWeaponIndex(%u)", GetNPCIndex(), pAttacker->GetUserIndex(), pWeapon->GetWeaponIndex() );
; 2923 : 				}
; 2924 : 			}
; 2925 : 		}
; 2926 : #endif		
; 2927 : 	}

  01848	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  0184e	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  01852	e8 00 00 00 00	 call	 ??1SP2Packet@@UAE@XZ	; SP2Packet::~SP2Packet
  01857	8b b5 08 7f ff
	ff		 mov	 esi, DWORD PTR _pWeapon$GSCopy$[ebp]
  0185d	8b bd c0 7f ff
	ff		 mov	 edi, DWORD PTR _pAttacker$[ebp]
$LN34@ApplyWeapo@26:

; 2928 : 
; 2929 : 	//---  
; 2930 : 	ApplyWeaponWoundedWeaponFunc( pWeapon, pAttacker, bApplyPushPower );

  01863	ff b5 bc 7f ff
	ff		 push	 DWORD PTR _bApplyPushPower$[ebp]
  01869	8b cb		 mov	 ecx, ebx
  0186b	57		 push	 edi
  0186c	56		 push	 esi
  0186d	e8 00 00 00 00	 call	 ?ApplyWeaponWoundedWeaponFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_N@Z ; ioBaseChar::ApplyWeaponWoundedWeaponFunc

; 2931 : 
; 2932 : 	int iDummyIndex = pWeapon->GetWeaponByDummyChar();
; 2933 : 	g_DummyCharMgr.CheckEntityCollision( pAttacker, this, iDummyIndex );

  01872	ff b6 98 05 00
	00		 push	 DWORD PTR [esi+1432]
  01878	53		 push	 ebx
  01879	57		 push	 edi
  0187a	e8 00 00 00 00	 call	 ?GetSingleton@ioDummyCharManager@@SAAAV1@XZ ; ioDummyCharManager::GetSingleton
  0187f	8b c8		 mov	 ecx, eax
  01881	e8 00 00 00 00	 call	 ?CheckEntityCollision@ioDummyCharManager@@QAEXPAVioBaseChar@@PAVioPlayEntity@@H@Z ; ioDummyCharManager::CheckEntityCollision

; 2934 : 
; 2935 : 	//---  
; 2936 : 	ApplyWeaponWoundedSkillFunc( pWeapon, pAttacker, bApplyPushPower, fDamage, eBreakType, eBlockType, eProtectionType );

  01886	ff b5 4c 7f ff
	ff		 push	 DWORD PTR _eProtectionType$[ebp]
  0188c	f3 0f 10 85 c8
	7f ff ff	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  01894	ff b5 b0 7f ff
	ff		 push	 DWORD PTR _eBlockType$[ebp]
  0189a	ff b5 94 7f ff
	ff		 push	 DWORD PTR _eBreakType$[ebp]
  018a0	51		 push	 ecx
  018a1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  018a6	ff b5 bc 7f ff
	ff		 push	 DWORD PTR _bApplyPushPower$[ebp]
  018ac	8b cb		 mov	 ecx, ebx
  018ae	57		 push	 edi
  018af	56		 push	 esi
  018b0	e8 00 00 00 00	 call	 ?ApplyWeaponWoundedSkillFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@_NMW4DefenseBreakType@@W4AttackBlockType@@W4ProtectionMode@@@Z ; ioBaseChar::ApplyWeaponWoundedSkillFunc

; 2937 : 
; 2938 : 	//---  
; 2939 : 	ApplyWeaponWoundedBuffFunc( pAttacker );

  018b5	57		 push	 edi
  018b6	8b cb		 mov	 ecx, ebx
  018b8	e8 00 00 00 00	 call	 ?ApplyWeaponWoundedBuffFunc@ioBaseChar@@IAEXPAV1@@Z ; ioBaseChar::ApplyWeaponWoundedBuffFunc

; 2940 : 
; 2941 : 	//---  
; 2942 : 	ApplyWeaponWoundedNextStateFunc( pWeapon, pAttacker, fDamage, kAddBuffList );

  018bd	f3 0f 10 85 c8
	7f ff ff	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  018c5	8d 85 30 7f ff
	ff		 lea	 eax, DWORD PTR _kAddBuffList$[ebp]
  018cb	50		 push	 eax
  018cc	51		 push	 ecx
  018cd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  018d2	57		 push	 edi
  018d3	56		 push	 esi
  018d4	8b cb		 mov	 ecx, ebx
  018d6	e8 00 00 00 00	 call	 ?ApplyWeaponWoundedNextStateFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@MAAV?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@@Z ; ioBaseChar::ApplyWeaponWoundedNextStateFunc

; 2943 : 
; 2944 : 	//---  
; 2945 : 	ApplyWeaponWoundedSingleFunc( pWeapon, pAttacker, fDamage, bAirTargetBuff, bApplyPushPower, eBlockType, eProtectionType );

  018db	ff b5 4c 7f ff
	ff		 push	 DWORD PTR _eProtectionType$[ebp]
  018e1	f3 0f 10 85 c8
	7f ff ff	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  018e9	ff b5 b0 7f ff
	ff		 push	 DWORD PTR _eBlockType$[ebp]
  018ef	ff b5 bc 7f ff
	ff		 push	 DWORD PTR _bApplyPushPower$[ebp]
  018f5	ff b5 70 7f ff
	ff		 push	 DWORD PTR _bAirTargetBuff$[ebp]
  018fb	51		 push	 ecx
  018fc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01901	57		 push	 edi
  01902	56		 push	 esi
  01903	8b cb		 mov	 ecx, ebx
  01905	e8 00 00 00 00	 call	 ?ApplyWeaponWoundedSingleFunc@ioBaseChar@@IAEXPAVioWeapon@@PAV1@M_N2W4AttackBlockType@@W4ProtectionMode@@@Z ; ioBaseChar::ApplyWeaponWoundedSingleFunc

; 2946 : 
; 2947 : 	if ( fDamage > 0.0f )

  0190a	f3 0f 10 85 c8
	7f ff ff	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  01912	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  01919	76 0e		 jbe	 SHORT $LN11@ApplyWeapo@26

; 2948 : 		g_RSoldierInfoManager.ApplyRandomBuff( pAttacker, this );

  0191b	53		 push	 ebx
  0191c	57		 push	 edi
  0191d	e8 00 00 00 00	 call	 ?GetSingleton@ioRSoldierInfoManager@@SAAAV1@XZ ; ioRSoldierInfoManager::GetSingleton
  01922	8b c8		 mov	 ecx, eax
  01924	e8 00 00 00 00	 call	 ?ApplyRandomBuff@ioRSoldierInfoManager@@QAEXPAVioBaseChar@@0@Z ; ioRSoldierInfoManager::ApplyRandomBuff
$LN11@ApplyWeapo@26:

; 2949 : 
; 2950 : 	//Attacker Accessory 
; 2951 : 	for( int i=ES_RING; i<MAX_EQUIP_SLOT; i++ )

  01929	c7 85 b0 7f ff
	ff 06 00 00 00	 mov	 DWORD PTR _i$694916[ebp], 6
$LL10@ApplyWeapo@26:

; 2952 : 	{
; 2953 : 		ioSkill *pSkill = pAttacker->GetEquipedSkill( i );

  01933	ff b5 b0 7f ff
	ff		 push	 DWORD PTR _i$694916[ebp]
  01939	8b cf		 mov	 ecx, edi
  0193b	e8 00 00 00 00	 call	 ?GetEquipedSkill@ioBaseChar@@QAEPAVioSkill@@H@Z ; ioBaseChar::GetEquipedSkill

; 2954 : 		ioRandomPassiveSkill *pRandomPassiveSkill = ToRandomPassiveSkill( pSkill );

  01940	50		 push	 eax
  01941	e8 00 00 00 00	 call	 ?ToRandomPassiveSkill@@YAPAVioRandomPassiveSkill@@PAVioSkill@@@Z ; ToRandomPassiveSkill
  01946	8b f0		 mov	 esi, eax
  01948	59		 pop	 ecx

; 2955 : 		if( pRandomPassiveSkill )

  01949	85 f6		 test	 esi, esi
  0194b	74 1e		 je	 SHORT $LN9@ApplyWeapo@26

; 2956 : 		{
; 2957 : 			pRandomPassiveSkill->AddWounderRandomDebuffs( pAttacker, this, m_pModeParent->GetModeType() );

  0194d	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  01952	50		 push	 eax
  01953	53		 push	 ebx
  01954	57		 push	 edi
  01955	8b ce		 mov	 ecx, esi
  01957	e8 00 00 00 00	 call	 ?AddWounderRandomDebuffs@ioRandomPassiveSkill@@QAEXPAVioBaseChar@@0H@Z ; ioRandomPassiveSkill::AddWounderRandomDebuffs

; 2958 : 			pRandomPassiveSkill->AddAttackerRandombuffs( pAttacker, this, m_pModeParent->GetModeType() );

  0195c	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  01961	50		 push	 eax
  01962	53		 push	 ebx
  01963	57		 push	 edi
  01964	8b ce		 mov	 ecx, esi
  01966	e8 00 00 00 00	 call	 ?AddAttackerRandombuffs@ioRandomPassiveSkill@@QAEXPAVioBaseChar@@0H@Z ; ioRandomPassiveSkill::AddAttackerRandombuffs
$LN9@ApplyWeapo@26:

; 2949 : 
; 2950 : 	//Attacker Accessory 
; 2951 : 	for( int i=ES_RING; i<MAX_EQUIP_SLOT; i++ )

  0196b	ff 85 b0 7f ff
	ff		 inc	 DWORD PTR _i$694916[ebp]
  01971	83 bd b0 7f ff
	ff 09		 cmp	 DWORD PTR _i$694916[ebp], 9
  01978	7c b9		 jl	 SHORT $LL10@ApplyWeapo@26

; 2959 : 		}
; 2960 : 	}
; 2961 : 
; 2962 : 	//wounder Accessory 
; 2963 : 	for( int i=ES_RING; i<MAX_EQUIP_SLOT; i++ )

  0197a	c7 85 b0 7f ff
	ff 06 00 00 00	 mov	 DWORD PTR _i$694923[ebp], 6
$LL6@ApplyWeapo@26:

; 2964 : 	{
; 2965 : 		ioSkill *pSkill = GetEquipedSkill( i );

  01984	ff b5 b0 7f ff
	ff		 push	 DWORD PTR _i$694923[ebp]
  0198a	8b cb		 mov	 ecx, ebx
  0198c	e8 00 00 00 00	 call	 ?GetEquipedSkill@ioBaseChar@@QAEPAVioSkill@@H@Z ; ioBaseChar::GetEquipedSkill
  01991	8b f0		 mov	 esi, eax

; 2966 : 		ioAccessoryPassiveSkill *pAccPassiveSkill = ToAccessoryPassiveSkill( pSkill );

  01993	56		 push	 esi
  01994	e8 00 00 00 00	 call	 ?ToAccessoryPassiveSkill@@YAPAVioAccessoryPassiveSkill@@PAVioSkill@@@Z ; ToAccessoryPassiveSkill

; 2967 : 		ioRandomPassiveSkill *pRandomPassiveSkill = ToRandomPassiveSkill( pSkill );

  01999	56		 push	 esi
  0199a	89 85 ac 7f ff
	ff		 mov	 DWORD PTR _pAccPassiveSkill$694928[ebp], eax
  019a0	e8 00 00 00 00	 call	 ?ToRandomPassiveSkill@@YAPAVioRandomPassiveSkill@@PAVioSkill@@@Z ; ToRandomPassiveSkill

; 2968 : 		if ( pAccPassiveSkill )

  019a5	83 bd ac 7f ff
	ff 00		 cmp	 DWORD PTR _pAccPassiveSkill$694928[ebp], 0
  019ac	59		 pop	 ecx
  019ad	59		 pop	 ecx
  019ae	8b f0		 mov	 esi, eax
  019b0	74 0e		 je	 SHORT $LN3@ApplyWeapo@26

; 2969 : 			pAccPassiveSkill->CheckReducePassiveGaugeByCheckBuff( this );

  019b2	8b 8d ac 7f ff
	ff		 mov	 ecx, DWORD PTR _pAccPassiveSkill$694928[ebp]
  019b8	53		 push	 ebx
  019b9	e8 00 00 00 00	 call	 ?CheckReducePassiveGaugeByCheckBuff@ioAccessoryPassiveSkill@@QAEXPAVioBaseChar@@@Z ; ioAccessoryPassiveSkill::CheckReducePassiveGaugeByCheckBuff
  019be	eb 13		 jmp	 SHORT $LN5@ApplyWeapo@26
$LN3@ApplyWeapo@26:

; 2970 : 		else if( pRandomPassiveSkill )

  019c0	85 f6		 test	 esi, esi
  019c2	74 0f		 je	 SHORT $LN5@ApplyWeapo@26

; 2971 : 			pRandomPassiveSkill->AddWounderRandombuffs( pAttacker, this, m_pModeParent->GetModeType() );					

  019c4	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  019c9	50		 push	 eax
  019ca	53		 push	 ebx
  019cb	57		 push	 edi
  019cc	8b ce		 mov	 ecx, esi
  019ce	e8 00 00 00 00	 call	 ?AddWounderRandombuffs@ioRandomPassiveSkill@@QAEXPAVioBaseChar@@0H@Z ; ioRandomPassiveSkill::AddWounderRandombuffs
$LN5@ApplyWeapo@26:

; 2959 : 		}
; 2960 : 	}
; 2961 : 
; 2962 : 	//wounder Accessory 
; 2963 : 	for( int i=ES_RING; i<MAX_EQUIP_SLOT; i++ )

  019d3	ff 85 b0 7f ff
	ff		 inc	 DWORD PTR _i$694923[ebp]
  019d9	83 bd b0 7f ff
	ff 09		 cmp	 DWORD PTR _i$694923[ebp], 9
  019e0	7c a2		 jl	 SHORT $LL6@ApplyWeapo@26

; 2972 : 	}
; 2973 : }

  019e2	8d 8d 30 7f ff
	ff		 lea	 ecx, DWORD PTR _kAddBuffList$[ebp]
  019e8	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  019ec	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@IAEXXZ ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::_Tidy
  019f1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_??1ioHashString@@QAE@XZ
  019f7	8d 8d cc 7e ff
	ff		 lea	 ecx, DWORD PTR _szDefenseBreakBuff$[ebp]
  019fd	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  01a01	ff d6		 call	 esi
  01a03	8d 8d bc 7e ff
	ff		 lea	 ecx, DWORD PTR _szExtendWoundAni$[ebp]
  01a09	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  01a0d	ff d6		 call	 esi
  01a0f	8d 8d 9c 7e ff
	ff		 lea	 ecx, DWORD PTR _szWoundAni$[ebp]
  01a15	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  01a19	ff d6		 call	 esi
  01a1b	8d 8d ec 7e ff
	ff		 lea	 ecx, DWORD PTR _szFrontBackAttackerBuff$[ebp]
  01a21	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  01a25	ff d6		 call	 esi
  01a27	8d 8d dc 7e ff
	ff		 lea	 ecx, DWORD PTR _szFrontBackWoundBuff$[ebp]
  01a2d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  01a31	ff d6		 call	 esi
  01a33	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  01a37	8d 8d ac 7e ff
	ff		 lea	 ecx, DWORD PTR _szReflectAni$[ebp]
  01a3d	ff d6		 call	 esi
$LN75@ApplyWeapo@26:
  01a3f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01a42	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  01a49	59		 pop	 ecx
  01a4a	5f		 pop	 edi
  01a4b	5e		 pop	 esi
  01a4c	5b		 pop	 ebx
  01a4d	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01a50	33 cd		 xor	 ecx, ebp
  01a52	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01a57	c9		 leave
  01a58	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z$0:
  00000	8d 8d 78 7e ff
	ff		 lea	 ecx, DWORD PTR $T702570[ebp]
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z$1:
  0000c	8d 8d ac 7e ff
	ff		 lea	 ecx, DWORD PTR _szReflectAni$[ebp]
  00012	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z$2:
  00018	8d 8d dc 7e ff
	ff		 lea	 ecx, DWORD PTR _szFrontBackWoundBuff$[ebp]
  0001e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z$3:
  00024	8d 8d ec 7e ff
	ff		 lea	 ecx, DWORD PTR _szFrontBackAttackerBuff$[ebp]
  0002a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z$4:
  00030	8d 8d 9c 7e ff
	ff		 lea	 ecx, DWORD PTR _szWoundAni$[ebp]
  00036	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z$5:
  0003c	8d 8d bc 7e ff
	ff		 lea	 ecx, DWORD PTR _szExtendWoundAni$[ebp]
  00042	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z$6:
  00048	8d 8d cc 7e ff
	ff		 lea	 ecx, DWORD PTR _szDefenseBreakBuff$[ebp]
  0004e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z$7:
  00054	8d 8d 30 7f ff
	ff		 lea	 ecx, DWORD PTR _kAddBuffList$[ebp]
  0005a	e9 00 00 00 00	 jmp	 ??1?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAE@XZ ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::~vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >
__unwindfunclet$?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z$8:
  0005f	8d 8d cc 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$694834[ebp]
  00065	e9 00 00 00 00	 jmp	 ??1SP2Packet@@UAE@XZ	; SP2Packet::~SP2Packet
__unwindfunclet$?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z$9:
  0006a	8b 8d b4 7f ff
	ff		 mov	 ecx, DWORD PTR $T702571[ebp]
  00070	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z:
  00076	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0007a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0007d	8b 8a 74 7e ff
	ff		 mov	 ecx, DWORD PTR [edx-33164]
  00083	33 c8		 xor	 ecx, eax
  00085	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0008d	33 c8		 xor	 ecx, eax
  0008f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00094	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z
  00099	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ApplyWeaponWounded@ioBaseChar@@QAEXPAVioWeapon@@W4AttackSide@@ABUD3DXVECTOR3@@@Z ENDP ; ioBaseChar::ApplyWeaponWounded
END
