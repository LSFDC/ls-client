; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\Lost Saga For Developer\Youtube\Tutorial\Source\src\LSClient\ioRoomOptionManager.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?ms_Singleton@?$Singleton@VioRoomOptionManager@@@@1PAVioRoomOptionManager@@A ; Singleton<ioRoomOptionManager>::ms_Singleton
;	COMDAT ?ms_Singleton@?$Singleton@VioRoomOptionManager@@@@1PAVioRoomOptionManager@@A
_BSS	SEGMENT
?ms_Singleton@?$Singleton@VioRoomOptionManager@@@@1PAVioRoomOptionManager@@A DD 01H DUP (?) ; Singleton<ioRoomOptionManager>::ms_Singleton
_BSS	ENDS
PUBLIC	?return1@@YAIXZ					; return1
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stdafx.h
;	COMDAT ?return1@@YAIXZ
_TEXT	SEGMENT
?return1@@YAIXZ PROC					; return1, COMDAT

; 17   : 	__forceinline unsigned int return1() { __asm mov eax, 1 };

  00000	b8 01 00 00 00	 mov	 eax, 1
  00005	c3		 ret	 0
?return1@@YAIXZ ENDP					; return1
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
  00010	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00016	8b c6		 mov	 eax, esi
  00018	5e		 pop	 esi
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogsp
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1exception@std@@UAE@XZ
  00012	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00016	74 07		 je	 SHORT $LN1@scalar
  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001e	59		 pop	 ecx
$LN1@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 56   : 	{	// construct array with placement at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : 	return (_Where);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 58   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogsp
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 62   : 	}

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 49   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
PUBLIC	??1ioINILoader_e@@QAE@XZ			; ioINILoader_e::~ioINILoader_e
EXTRN	__imp_??1ioINILoader@@QAE@XZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ??1ioINILoader_e@@QAE@XZ
_TEXT	SEGMENT
??1ioINILoader_e@@QAE@XZ PROC				; ioINILoader_e::~ioINILoader_e, COMDAT
; _this$ = ecx
  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioINILoader@@QAE@XZ
??1ioINILoader_e@@QAE@XZ ENDP				; ioINILoader_e::~ioINILoader_e
_TEXT	ENDS
PUBLIC	??0?$Singleton@VioRoomOptionManager@@@@QAE@XZ	; Singleton<ioRoomOptionManager>::Singleton<ioRoomOptionManager>
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\io3dengine\iosingleton.h
;	COMDAT ??0?$Singleton@VioRoomOptionManager@@@@QAE@XZ
_TEXT	SEGMENT
??0?$Singleton@VioRoomOptionManager@@@@QAE@XZ PROC	; Singleton<ioRoomOptionManager>::Singleton<ioRoomOptionManager>, COMDAT
; _this$ = ecx

; 27   : 	Singleton()

  00000	8b c1		 mov	 eax, ecx

; 28   : 	{
; 29   : 		assert( !ms_Singleton );
; 30   : 		int offset = (int)(T*)1 - (int)(Singleton <T>*)(T*)1;
; 31   : 		ms_Singleton = (T*)((int)this + offset);

  00002	8d 48 fc	 lea	 ecx, DWORD PTR [eax-4]
  00005	89 0d 00 00 00
	00		 mov	 DWORD PTR ?ms_Singleton@?$Singleton@VioRoomOptionManager@@@@1PAVioRoomOptionManager@@A, ecx ; Singleton<ioRoomOptionManager>::ms_Singleton

; 32   : 	}

  0000b	c3		 ret	 0
??0?$Singleton@VioRoomOptionManager@@@@QAE@XZ ENDP	; Singleton<ioRoomOptionManager>::Singleton<ioRoomOptionManager>
_TEXT	ENDS
PUBLIC	??1?$Singleton@VioRoomOptionManager@@@@QAE@XZ	; Singleton<ioRoomOptionManager>::~Singleton<ioRoomOptionManager>
; Function compile flags: /Ogsp
;	COMDAT ??1?$Singleton@VioRoomOptionManager@@@@QAE@XZ
_TEXT	SEGMENT
??1?$Singleton@VioRoomOptionManager@@@@QAE@XZ PROC	; Singleton<ioRoomOptionManager>::~Singleton<ioRoomOptionManager>, COMDAT
; _this$ = ecx

; 36   : 		assert( ms_Singleton );
; 37   : 		ms_Singleton = 0;

  00000	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_Singleton@?$Singleton@VioRoomOptionManager@@@@1PAVioRoomOptionManager@@A, 0 ; Singleton<ioRoomOptionManager>::ms_Singleton

; 38   : 	}

  00007	c3		 ret	 0
??1?$Singleton@VioRoomOptionManager@@@@QAE@XZ ENDP	; Singleton<ioRoomOptionManager>::~Singleton<ioRoomOptionManager>
_TEXT	ENDS
PUBLIC	?GetSingleton@?$Singleton@VioRoomOptionManager@@@@SAAAVioRoomOptionManager@@XZ ; Singleton<ioRoomOptionManager>::GetSingleton
; Function compile flags: /Ogsp
;	COMDAT ?GetSingleton@?$Singleton@VioRoomOptionManager@@@@SAAAVioRoomOptionManager@@XZ
_TEXT	SEGMENT
?GetSingleton@?$Singleton@VioRoomOptionManager@@@@SAAAVioRoomOptionManager@@XZ PROC ; Singleton<ioRoomOptionManager>::GetSingleton, COMDAT

; 42   : 		assert( ms_Singleton );
; 43   : 		return (*ms_Singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_Singleton@?$Singleton@VioRoomOptionManager@@@@1PAVioRoomOptionManager@@A ; Singleton<ioRoomOptionManager>::ms_Singleton

; 44   : 	}

  00005	c3		 ret	 0
?GetSingleton@?$Singleton@VioRoomOptionManager@@@@SAAAVioRoomOptionManager@@XZ ENDP ; Singleton<ioRoomOptionManager>::GetSingleton
_TEXT	ENDS
PUBLIC	?size@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QBEIXZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::size
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?size@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 880  : 		}

  00008	c3		 ret	 0
?size@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEAAPAURoomOptionInfo@@I@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::operator[]
; Function compile flags: /Ogsp
;	COMDAT ??A?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEAAPAURoomOptionInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEAAPAURoomOptionInfo@@I@Z PROC ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pos$[ebp]
  00008	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 941  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEAAPAURoomOptionInfo@@I@Z ENDP ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QBEIXZ ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::size
; Function compile flags: /Ogsp
;	COMDAT ?size@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 880  : 		}

  00008	c3		 ret	 0
?size@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAEAAPAUPreSetInfo@@I@Z ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::operator[]
; Function compile flags: /Ogsp
;	COMDAT ??A?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAEAAPAUPreSetInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAEAAPAUPreSetInfo@@I@Z PROC ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pos$[ebp]
  00008	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 941  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAEAAPAUPreSetInfo@@I@Z ENDP ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z ; std::vector<int,std::allocator<int> >::_Inside
; Function compile flags: /Ogsp
;	COMDAT ?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z PROC ; std::vector<int,std::allocator<int> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 09		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 05		 ja	 SHORT $LN3@Inside
  0000f	33 c0		 xor	 eax, eax
  00011	40		 inc	 eax
  00012	eb 02		 jmp	 SHORT $LN4@Inside
$LN3@Inside:
  00014	33 c0		 xor	 eax, eax
$LN4@Inside:

; 1287 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z ENDP ; std::vector<int,std::allocator<int> >::_Inside
_TEXT	ENDS
PUBLIC	?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Orphan_range
; Function compile flags: /Ogsp
;	COMDAT ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1454 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Orphan_range
_TEXT	ENDS
PUBLIC	?_Inside@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IBE_NPBQAURoomOptionInfo@@@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Inside
; Function compile flags: /Ogsp
;	COMDAT ?_Inside@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IBE_NPBQAURoomOptionInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IBE_NPBQAURoomOptionInfo@@@Z PROC ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 09		 jae	 SHORT $LN3@Inside@2
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 05		 ja	 SHORT $LN3@Inside@2
  0000f	33 c0		 xor	 eax, eax
  00011	40		 inc	 eax
  00012	eb 02		 jmp	 SHORT $LN4@Inside@2
$LN3@Inside@2:
  00014	33 c0		 xor	 eax, eax
$LN4@Inside@2:

; 1287 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?_Inside@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IBE_NPBQAURoomOptionInfo@@@Z ENDP ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Inside
_TEXT	ENDS
PUBLIC	?_Orphan_range@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IBEXPAPAURoomOptionInfo@@0@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Orphan_range
; Function compile flags: /Ogsp
;	COMDAT ?_Orphan_range@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IBEXPAPAURoomOptionInfo@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IBEXPAPAURoomOptionInfo@@0@Z PROC ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1454 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IBEXPAPAURoomOptionInfo@@0@Z ENDP ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAURoomOptionInfo@@@std@@QAE@XZ	; std::allocator<RoomOptionInfo *>::allocator<RoomOptionInfo *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAURoomOptionInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAURoomOptionInfo@@@std@@QAE@XZ PROC	; std::allocator<RoomOptionInfo *>::allocator<RoomOptionInfo *>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@PAURoomOptionInfo@@@std@@QAE@XZ ENDP	; std::allocator<RoomOptionInfo *>::allocator<RoomOptionInfo *>
_TEXT	ENDS
PUBLIC	?_Inside@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IBE_NPBQAUPreSetInfo@@@Z ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Inside
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IBE_NPBQAUPreSetInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IBE_NPBQAUPreSetInfo@@@Z PROC ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 09		 jae	 SHORT $LN3@Inside@3
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 05		 ja	 SHORT $LN3@Inside@3
  0000f	33 c0		 xor	 eax, eax
  00011	40		 inc	 eax
  00012	eb 02		 jmp	 SHORT $LN4@Inside@3
$LN3@Inside@3:
  00014	33 c0		 xor	 eax, eax
$LN4@Inside@3:

; 1287 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?_Inside@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IBE_NPBQAUPreSetInfo@@@Z ENDP ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Inside
_TEXT	ENDS
PUBLIC	?_Orphan_range@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IBEXPAPAUPreSetInfo@@0@Z ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Orphan_range
; Function compile flags: /Ogsp
;	COMDAT ?_Orphan_range@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IBEXPAPAUPreSetInfo@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IBEXPAPAUPreSetInfo@@0@Z PROC ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1454 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IBEXPAPAUPreSetInfo@@0@Z ENDP ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> >::~_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> >::~_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> >::~_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAUPreSetInfo@@@std@@QAE@XZ	; std::allocator<PreSetInfo *>::allocator<PreSetInfo *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAUPreSetInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAUPreSetInfo@@@std@@QAE@XZ PROC		; std::allocator<PreSetInfo *>::allocator<PreSetInfo *>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@PAUPreSetInfo@@@std@@QAE@XZ ENDP		; std::allocator<PreSetInfo *>::allocator<PreSetInfo *>
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QBEABQAURoomOptionInfo@@XZ ; std::_Vector_const_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >::operator*
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QBEABQAURoomOptionInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QBEABQAURoomOptionInfo@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >::operator*, COMDAT
; _this$ = ecx

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);
; 83   : 
; 84   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 85   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QBEABQAURoomOptionInfo@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >::operator++
; Function compile flags: /Ogsp
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >::operator++, COMDAT
; _this$ = ecx

; 93   : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

  00002	83 00 04	 add	 DWORD PTR [eax], 4

; 111  : 		return (*this);
; 112  : 		}

  00005	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >::operator++
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QBEABQAUPreSetInfo@@XZ ; std::_Vector_const_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >::operator*
; Function compile flags: /Ogsp
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QBEABQAUPreSetInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QBEABQAUPreSetInfo@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >::operator*, COMDAT
; _this$ = ecx

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);
; 83   : 
; 84   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 85   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QBEABQAUPreSetInfo@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >::operator++
; Function compile flags: /Ogsp
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >::operator++, COMDAT
; _this$ = ecx

; 93   : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

  00002	83 00 04	 add	 DWORD PTR [eax], 4

; 111  : 		return (*this);
; 112  : 		}

  00005	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >::operator++
_TEXT	ENDS
PUBLIC	?capacity@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QBEIXZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::capacity
; Function compile flags: /Ogsp
;	COMDAT ?capacity@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::capacity, COMDAT
; _this$ = ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 778  : 		}

  00008	c3		 ret	 0
?capacity@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::capacity
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IBEXXZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Xlen
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IBEXXZ PROC ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Xlen, COMDAT
; _this$ = ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
  0000b	cc		 int	 3
?_Xlen@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IBEXXZ ENDP ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Xlen
_TEXT	ENDS
PUBLIC	??0?$allocator@PAURoomOptionInfo@@@std@@QAE@ABV01@@Z ; std::allocator<RoomOptionInfo *>::allocator<RoomOptionInfo *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAURoomOptionInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAURoomOptionInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<RoomOptionInfo *>::allocator<RoomOptionInfo *>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@PAURoomOptionInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<RoomOptionInfo *>::allocator<RoomOptionInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAURoomOptionInfo@@@std@@QAEXPAPAURoomOptionInfo@@I@Z ; std::allocator<RoomOptionInfo *>::deallocate
; Function compile flags: /Ogsp
;	COMDAT ?deallocate@?$allocator@PAURoomOptionInfo@@@std@@QAEXPAPAURoomOptionInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAURoomOptionInfo@@@std@@QAEXPAPAURoomOptionInfo@@I@Z PROC ; std::allocator<RoomOptionInfo *>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 183  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
?deallocate@?$allocator@PAURoomOptionInfo@@@std@@QAEXPAPAURoomOptionInfo@@I@Z ENDP ; std::allocator<RoomOptionInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?capacity@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QBEIXZ ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::capacity
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::capacity, COMDAT
; _this$ = ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 778  : 		}

  00008	c3		 ret	 0
?capacity@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::capacity
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IBEXXZ ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Xlen
; Function compile flags: /Ogsp
;	COMDAT ?_Xlen@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IBEXXZ PROC ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Xlen, COMDAT
; _this$ = ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen@2:
$LN3@Xlen@2:
  0000b	cc		 int	 3
?_Xlen@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IBEXXZ ENDP ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Xlen
_TEXT	ENDS
PUBLIC	??0?$allocator@PAUPreSetInfo@@@std@@QAE@ABV01@@Z ; std::allocator<PreSetInfo *>::allocator<PreSetInfo *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAUPreSetInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAUPreSetInfo@@@std@@QAE@ABV01@@Z PROC	; std::allocator<PreSetInfo *>::allocator<PreSetInfo *>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@PAUPreSetInfo@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<PreSetInfo *>::allocator<PreSetInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAUPreSetInfo@@@std@@QAEXPAPAUPreSetInfo@@I@Z ; std::allocator<PreSetInfo *>::deallocate
; Function compile flags: /Ogsp
;	COMDAT ?deallocate@?$allocator@PAUPreSetInfo@@@std@@QAEXPAPAUPreSetInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAUPreSetInfo@@@std@@QAEXPAPAUPreSetInfo@@I@Z PROC ; std::allocator<PreSetInfo *>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 183  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
?deallocate@?$allocator@PAUPreSetInfo@@@std@@QAEXPAPAUPreSetInfo@@I@Z ENDP ; std::allocator<PreSetInfo *>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QAE@PAPAURoomOptionInfo@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >::_Vector_const_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QAE@PAPAURoomOptionInfo@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QAE@PAPAURoomOptionInfo@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >::_Vector_const_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QAE@PAPAURoomOptionInfo@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >::_Vector_const_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >::_Compat
; Function compile flags: /Ogsp
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >::_Compat, COMDAT
; _this$ = ecx

; 253  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >::_Compat
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QAE@PAPAUPreSetInfo@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >::_Vector_const_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QAE@PAPAUPreSetInfo@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QAE@PAPAUPreSetInfo@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >::_Vector_const_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QAE@PAPAUPreSetInfo@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >::_Vector_const_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >::_Compat
; Function compile flags: /Ogsp
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >::_Compat, COMDAT
; _this$ = ecx

; 253  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >::_Compat
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAURoomOptionInfo@@@std@@QBEIXZ ; std::allocator<RoomOptionInfo *>::max_size
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@PAURoomOptionInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAURoomOptionInfo@@@std@@QBEIXZ PROC ; std::allocator<RoomOptionInfo *>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@PAURoomOptionInfo@@@std@@QBEIXZ ENDP ; std::allocator<RoomOptionInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAUPreSetInfo@@@std@@QBEIXZ ; std::allocator<PreSetInfo *>::max_size
; Function compile flags: /Ogsp
;	COMDAT ?max_size@?$allocator@PAUPreSetInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAUPreSetInfo@@@std@@QBEIXZ PROC	; std::allocator<PreSetInfo *>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@PAUPreSetInfo@@@std@@QBEIXZ ENDP	; std::allocator<PreSetInfo *>::max_size
_TEXT	ENDS
PUBLIC	??$addressof@$$CBH@std@@YAPBHABH@Z		; std::addressof<int const >
; Function compile flags: /Ogsp
;	COMDAT ??$addressof@$$CBH@std@@YAPBHABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBH@std@@YAPBHABH@Z PROC			; std::addressof<int const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBH@std@@YAPBHABH@Z ENDP			; std::addressof<int const >
_TEXT	ENDS
PUBLIC	??$addressof@QAURoomOptionInfo@@@std@@YAPBQAURoomOptionInfo@@ABQAU1@@Z ; std::addressof<RoomOptionInfo * const>
; Function compile flags: /Ogsp
;	COMDAT ??$addressof@QAURoomOptionInfo@@@std@@YAPBQAURoomOptionInfo@@ABQAU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@QAURoomOptionInfo@@@std@@YAPBQAURoomOptionInfo@@ABQAU1@@Z PROC ; std::addressof<RoomOptionInfo * const>, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@QAURoomOptionInfo@@@std@@YAPBQAURoomOptionInfo@@ABQAU1@@Z ENDP ; std::addressof<RoomOptionInfo * const>
_TEXT	ENDS
PUBLIC	??$addressof@QAUPreSetInfo@@@std@@YAPBQAUPreSetInfo@@ABQAU1@@Z ; std::addressof<PreSetInfo * const>
; Function compile flags: /Ogsp
;	COMDAT ??$addressof@QAUPreSetInfo@@@std@@YAPBQAUPreSetInfo@@ABQAU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@QAUPreSetInfo@@@std@@YAPBQAUPreSetInfo@@ABQAU1@@Z PROC ; std::addressof<PreSetInfo * const>, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@QAUPreSetInfo@@@std@@YAPBQAUPreSetInfo@@ABQAU1@@Z ENDP ; std::addressof<PreSetInfo * const>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@PAURoomOptionInfo@@@std@@YAPAPAURoomOptionInfo@@IPAPAU1@@Z ; std::_Allocate<RoomOptionInfo *>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@PAURoomOptionInfo@@@std@@YAPAPAURoomOptionInfo@@IPAPAU1@@Z
_TEXT	SEGMENT
$T530713 = -12						; size = 12
$T530718 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAURoomOptionInfo@@@std@@YAPAPAURoomOptionInfo@@IPAPAU1@@Z PROC ; std::_Allocate<RoomOptionInfo *>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 3e		 je	 SHORT $LN5@Allocate

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00015	77 10		 ja	 SHORT $LN1@Allocate
  00017	8b c1		 mov	 eax, ecx
  00019	c1 e0 02	 shl	 eax, 2
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	59		 pop	 ecx
  00023	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00025	75 26		 jne	 SHORT $LN5@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00027	83 65 08 00	 and	 DWORD PTR $T530718[ebp], 0
  0002b	8d 45 08	 lea	 eax, DWORD PTR $T530718[ebp]
  0002e	50		 push	 eax
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T530713[ebp]
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
  00038	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003d	8d 45 f4	 lea	 eax, DWORD PTR $T530713[ebp]
  00040	50		 push	 eax
  00041	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T530713[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00048	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate:
$LN5@Allocate:

; 40   : 	}

  0004d	c9		 leave
  0004e	c3		 ret	 0
$LN9@Allocate:
??$_Allocate@PAURoomOptionInfo@@@std@@YAPAPAURoomOptionInfo@@IPAPAU1@@Z ENDP ; std::_Allocate<RoomOptionInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAUPreSetInfo@@@std@@YAPAPAUPreSetInfo@@IPAPAU1@@Z ; std::_Allocate<PreSetInfo *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Allocate@PAUPreSetInfo@@@std@@YAPAPAUPreSetInfo@@IPAPAU1@@Z
_TEXT	SEGMENT
$T530723 = -12						; size = 12
$T530727 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAUPreSetInfo@@@std@@YAPAPAUPreSetInfo@@IPAPAU1@@Z PROC ; std::_Allocate<PreSetInfo *>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 3e		 je	 SHORT $LN5@Allocate@2

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00015	77 10		 ja	 SHORT $LN1@Allocate@2
  00017	8b c1		 mov	 eax, ecx
  00019	c1 e0 02	 shl	 eax, 2
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	59		 pop	 ecx
  00023	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00025	75 26		 jne	 SHORT $LN5@Allocate@2
$LN1@Allocate@2:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00027	83 65 08 00	 and	 DWORD PTR $T530727[ebp], 0
  0002b	8d 45 08	 lea	 eax, DWORD PTR $T530727[ebp]
  0002e	50		 push	 eax
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T530723[ebp]
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
  00038	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003d	8d 45 f4	 lea	 eax, DWORD PTR $T530723[ebp]
  00040	50		 push	 eax
  00041	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T530723[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00048	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate@2:
$LN5@Allocate@2:

; 40   : 	}

  0004d	c9		 leave
  0004e	c3		 ret	 0
$LN9@Allocate@2:
??$_Allocate@PAUPreSetInfo@@@std@@YAPAPAUPreSetInfo@@IPAPAU1@@Z ENDP ; std::_Allocate<PreSetInfo *>
_TEXT	ENDS
PUBLIC	??$forward@ABH@std@@YAABHABH@Z			; std::forward<int const &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABH@std@@YAABHABH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABH@std@@YAABHABH@Z PROC			; std::forward<int const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABH@std@@YAABHABH@Z ENDP			; std::forward<int const &>
_TEXT	ENDS
PUBLIC	??$forward@AAPAURoomOptionInfo@@@std@@YAAAPAURoomOptionInfo@@AAPAU1@@Z ; std::forward<RoomOptionInfo * &>
; Function compile flags: /Ogsp
;	COMDAT ??$forward@AAPAURoomOptionInfo@@@std@@YAAAPAURoomOptionInfo@@AAPAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAURoomOptionInfo@@@std@@YAAAPAURoomOptionInfo@@AAPAU1@@Z PROC ; std::forward<RoomOptionInfo * &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAURoomOptionInfo@@@std@@YAAAPAURoomOptionInfo@@AAPAU1@@Z ENDP ; std::forward<RoomOptionInfo * &>
_TEXT	ENDS
PUBLIC	??$construct@AAPAURoomOptionInfo@@@?$allocator@PAURoomOptionInfo@@@std@@QAEXPAPAURoomOptionInfo@@AAPAU2@@Z ; std::allocator<RoomOptionInfo *>::construct<RoomOptionInfo * &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$construct@AAPAURoomOptionInfo@@@?$allocator@PAURoomOptionInfo@@@std@@QAEXPAPAURoomOptionInfo@@AAPAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAPAURoomOptionInfo@@@?$allocator@PAURoomOptionInfo@@@std@@QAEXPAPAURoomOptionInfo@@AAPAU2@@Z PROC ; std::allocator<RoomOptionInfo *>::construct<RoomOptionInfo * &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000f	89 08		 mov	 DWORD PTR [eax], ecx
$LN3@construct:

; 209  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@AAPAURoomOptionInfo@@@?$allocator@PAURoomOptionInfo@@@std@@QAEXPAPAURoomOptionInfo@@AAPAU2@@Z ENDP ; std::allocator<RoomOptionInfo *>::construct<RoomOptionInfo * &>
_TEXT	ENDS
PUBLIC	??$forward@ABQAURoomOptionInfo@@@std@@YAABQAURoomOptionInfo@@ABQAU1@@Z ; std::forward<RoomOptionInfo * const &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABQAURoomOptionInfo@@@std@@YAABQAURoomOptionInfo@@ABQAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAURoomOptionInfo@@@std@@YAABQAURoomOptionInfo@@ABQAU1@@Z PROC ; std::forward<RoomOptionInfo * const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABQAURoomOptionInfo@@@std@@YAABQAURoomOptionInfo@@ABQAU1@@Z ENDP ; std::forward<RoomOptionInfo * const &>
_TEXT	ENDS
PUBLIC	??$forward@AAPAUPreSetInfo@@@std@@YAAAPAUPreSetInfo@@AAPAU1@@Z ; std::forward<PreSetInfo * &>
; Function compile flags: /Ogsp
;	COMDAT ??$forward@AAPAUPreSetInfo@@@std@@YAAAPAUPreSetInfo@@AAPAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAUPreSetInfo@@@std@@YAAAPAUPreSetInfo@@AAPAU1@@Z PROC ; std::forward<PreSetInfo * &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAUPreSetInfo@@@std@@YAAAPAUPreSetInfo@@AAPAU1@@Z ENDP ; std::forward<PreSetInfo * &>
_TEXT	ENDS
PUBLIC	??$construct@AAPAUPreSetInfo@@@?$allocator@PAUPreSetInfo@@@std@@QAEXPAPAUPreSetInfo@@AAPAU2@@Z ; std::allocator<PreSetInfo *>::construct<PreSetInfo * &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$construct@AAPAUPreSetInfo@@@?$allocator@PAUPreSetInfo@@@std@@QAEXPAPAUPreSetInfo@@AAPAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAPAUPreSetInfo@@@?$allocator@PAUPreSetInfo@@@std@@QAEXPAPAUPreSetInfo@@AAPAU2@@Z PROC ; std::allocator<PreSetInfo *>::construct<PreSetInfo * &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN3@construct@2
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000f	89 08		 mov	 DWORD PTR [eax], ecx
$LN3@construct@2:

; 209  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@AAPAUPreSetInfo@@@?$allocator@PAUPreSetInfo@@@std@@QAEXPAPAUPreSetInfo@@AAPAU2@@Z ENDP ; std::allocator<PreSetInfo *>::construct<PreSetInfo * &>
_TEXT	ENDS
PUBLIC	??$forward@ABQAUPreSetInfo@@@std@@YAABQAUPreSetInfo@@ABQAU1@@Z ; std::forward<PreSetInfo * const &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABQAUPreSetInfo@@@std@@YAABQAUPreSetInfo@@ABQAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAUPreSetInfo@@@std@@YAABQAUPreSetInfo@@ABQAU1@@Z PROC ; std::forward<PreSetInfo * const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABQAUPreSetInfo@@@std@@YAABQAUPreSetInfo@@ABQAU1@@Z ENDP ; std::forward<PreSetInfo * const &>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAURoomOptionInfo@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAURoomOptionInfo@@0@Z ; std::_Ptr_cat<RoomOptionInfo *,RoomOptionInfo *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAURoomOptionInfo@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAURoomOptionInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAURoomOptionInfo@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAURoomOptionInfo@@0@Z PROC ; std::_Ptr_cat<RoomOptionInfo *,RoomOptionInfo *>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	c9		 leave
  00008	c3		 ret	 0
??$_Ptr_cat@PAURoomOptionInfo@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAURoomOptionInfo@@0@Z ENDP ; std::_Ptr_cat<RoomOptionInfo *,RoomOptionInfo *>
_TEXT	ENDS
PUBLIC	??$_Move@PAPAURoomOptionInfo@@PAPAU1@@std@@YAPAPAURoomOptionInfo@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<RoomOptionInfo * *,RoomOptionInfo * *>
EXTRN	__imp__memmove:PROC
; Function compile flags: /Ogsp
;	COMDAT ??$_Move@PAPAURoomOptionInfo@@PAPAU1@@std@@YAPAPAURoomOptionInfo@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAPAURoomOptionInfo@@PAPAU1@@std@@YAPAPAURoomOptionInfo@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<RoomOptionInfo * *,RoomOptionInfo * *>, COMDAT

; 2522 : 	{	// move [_First, _Last) to [_Dest, ...), pointers to scalars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2523 : 	ptrdiff_t _Count = _Last - _First;

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  00007	2b 75 08	 sub	 esi, DWORD PTR __First$[ebp]
  0000a	57		 push	 edi

; 2524 : 	_CSTD memmove(&*_Dest, &*_First,
; 2525 : 		_Count * sizeof (*_First));

  0000b	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
  0000e	c1 fe 02	 sar	 esi, 2
  00011	c1 e6 02	 shl	 esi, 2
  00014	56		 push	 esi
  00015	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00018	57		 push	 edi
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2526 : 	return (_Dest + _Count);

  00022	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 2527 : 	}

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Move@PAPAURoomOptionInfo@@PAPAU1@@std@@YAPAPAURoomOptionInfo@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<RoomOptionInfo * *,RoomOptionInfo * *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUPreSetInfo@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUPreSetInfo@@0@Z ; std::_Ptr_cat<PreSetInfo *,PreSetInfo *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Ptr_cat@PAUPreSetInfo@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUPreSetInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUPreSetInfo@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUPreSetInfo@@0@Z PROC ; std::_Ptr_cat<PreSetInfo *,PreSetInfo *>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	c9		 leave
  00008	c3		 ret	 0
??$_Ptr_cat@PAUPreSetInfo@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUPreSetInfo@@0@Z ENDP ; std::_Ptr_cat<PreSetInfo *,PreSetInfo *>
_TEXT	ENDS
PUBLIC	??$_Move@PAPAUPreSetInfo@@PAPAU1@@std@@YAPAPAUPreSetInfo@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<PreSetInfo * *,PreSetInfo * *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Move@PAPAUPreSetInfo@@PAPAU1@@std@@YAPAPAUPreSetInfo@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAPAUPreSetInfo@@PAPAU1@@std@@YAPAPAUPreSetInfo@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<PreSetInfo * *,PreSetInfo * *>, COMDAT

; 2522 : 	{	// move [_First, _Last) to [_Dest, ...), pointers to scalars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2523 : 	ptrdiff_t _Count = _Last - _First;

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  00007	2b 75 08	 sub	 esi, DWORD PTR __First$[ebp]
  0000a	57		 push	 edi

; 2524 : 	_CSTD memmove(&*_Dest, &*_First,
; 2525 : 		_Count * sizeof (*_First));

  0000b	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
  0000e	c1 fe 02	 sar	 esi, 2
  00011	c1 e6 02	 shl	 esi, 2
  00014	56		 push	 esi
  00015	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00018	57		 push	 edi
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2526 : 	return (_Dest + _Count);

  00022	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 2527 : 	}

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Move@PAPAUPreSetInfo@@PAPAU1@@std@@YAPAPAUPreSetInfo@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<PreSetInfo * *,PreSetInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAURoomOptionInfo@@@std@@@std@@YAXPAPAURoomOptionInfo@@0AAV?$allocator@PAURoomOptionInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<RoomOptionInfo *> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAURoomOptionInfo@@@std@@@std@@YAXPAPAURoomOptionInfo@@0AAV?$allocator@PAURoomOptionInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAURoomOptionInfo@@@std@@@std@@YAXPAPAURoomOptionInfo@@0AAV?$allocator@PAURoomOptionInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<RoomOptionInfo *> >, COMDAT

; 105  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAURoomOptionInfo@@@std@@@std@@YAXPAPAURoomOptionInfo@@0AAV?$allocator@PAURoomOptionInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<RoomOptionInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAUPreSetInfo@@@std@@@std@@YAXPAPAUPreSetInfo@@0AAV?$allocator@PAUPreSetInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<PreSetInfo *> >
; Function compile flags: /Ogsp
;	COMDAT ??$_Destroy_range@V?$allocator@PAUPreSetInfo@@@std@@@std@@YAXPAPAUPreSetInfo@@0AAV?$allocator@PAUPreSetInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAUPreSetInfo@@@std@@@std@@YAXPAPAUPreSetInfo@@0AAV?$allocator@PAUPreSetInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<PreSetInfo *> >, COMDAT

; 105  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAUPreSetInfo@@@std@@@std@@YAXPAPAUPreSetInfo@@0AAV?$allocator@PAUPreSetInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<PreSetInfo *> >
_TEXT	ENDS
PUBLIC	??$_Construct@HABH@std@@YAXPAHABH@Z		; std::_Construct<int,int const &>
; Function compile flags: /Ogsp
;	COMDAT ??$_Construct@HABH@std@@YAXPAHABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@HABH@std@@YAXPAHABH@Z PROC		; std::_Construct<int,int const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN3@Construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000f	89 08		 mov	 DWORD PTR [eax], ecx
$LN3@Construct:

; 49   : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Construct@HABH@std@@YAXPAHABH@Z ENDP		; std::_Construct<int,int const &>
_TEXT	ENDS
PUBLIC	??$_Construct@PAURoomOptionInfo@@ABQAU1@@std@@YAXPAPAURoomOptionInfo@@ABQAU1@@Z ; std::_Construct<RoomOptionInfo *,RoomOptionInfo * const &>
; Function compile flags: /Ogsp
;	COMDAT ??$_Construct@PAURoomOptionInfo@@ABQAU1@@std@@YAXPAPAURoomOptionInfo@@ABQAU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAURoomOptionInfo@@ABQAU1@@std@@YAXPAPAURoomOptionInfo@@ABQAU1@@Z PROC ; std::_Construct<RoomOptionInfo *,RoomOptionInfo * const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN3@Construct@2
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000f	89 08		 mov	 DWORD PTR [eax], ecx
$LN3@Construct@2:

; 49   : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Construct@PAURoomOptionInfo@@ABQAU1@@std@@YAXPAPAURoomOptionInfo@@ABQAU1@@Z ENDP ; std::_Construct<RoomOptionInfo *,RoomOptionInfo * const &>
_TEXT	ENDS
PUBLIC	??$_Construct@PAUPreSetInfo@@ABQAU1@@std@@YAXPAPAUPreSetInfo@@ABQAU1@@Z ; std::_Construct<PreSetInfo *,PreSetInfo * const &>
; Function compile flags: /Ogsp
;	COMDAT ??$_Construct@PAUPreSetInfo@@ABQAU1@@std@@YAXPAPAUPreSetInfo@@ABQAU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAUPreSetInfo@@ABQAU1@@std@@YAXPAPAUPreSetInfo@@ABQAU1@@Z PROC ; std::_Construct<PreSetInfo *,PreSetInfo * const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN3@Construct@3
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000f	89 08		 mov	 DWORD PTR [eax], ecx
$LN3@Construct@3:

; 49   : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Construct@PAUPreSetInfo@@ABQAU1@@std@@YAXPAPAUPreSetInfo@@ABQAU1@@Z ENDP ; std::_Construct<PreSetInfo *,PreSetInfo * const &>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAPAURoomOptionInfo@@@std@@YAPAPAURoomOptionInfo@@PAPAU1@@Z ; std::_Val_type<RoomOptionInfo * *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAURoomOptionInfo@@@std@@YAPAPAURoomOptionInfo@@PAPAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAURoomOptionInfo@@@std@@YAPAPAURoomOptionInfo@@PAPAU1@@Z PROC ; std::_Val_type<RoomOptionInfo * *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAPAURoomOptionInfo@@@std@@YAPAPAURoomOptionInfo@@PAPAU1@@Z ENDP ; std::_Val_type<RoomOptionInfo * *>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAURoomOptionInfo@@PAU1@PAU1@@std@@YAPAPAURoomOptionInfo@@PAPAU1@00AAV?$allocator@PAURoomOptionInfo@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<RoomOptionInfo *,RoomOptionInfo *,RoomOptionInfo *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAURoomOptionInfo@@PAU1@PAU1@@std@@YAPAPAURoomOptionInfo@@PAPAU1@00AAV?$allocator@PAURoomOptionInfo@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAURoomOptionInfo@@PAU1@PAU1@@std@@YAPAPAURoomOptionInfo@@PAPAU1@00AAV?$allocator@PAURoomOptionInfo@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<RoomOptionInfo *,RoomOptionInfo *,RoomOptionInfo *>, COMDAT

; 456  : 	{	// move [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 457  : 	_DEBUG_RANGE(_First, _Last);
; 458  : 	_DEBUG_POINTER(_Dest);
; 459  : 	size_t _Count = (size_t)(_Last - _First);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  00007	2b 75 08	 sub	 esi, DWORD PTR __First$[ebp]
  0000a	c1 fe 02	 sar	 esi, 2

; 460  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 461  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000d	c1 e6 02	 shl	 esi, 2
  00010	56		 push	 esi
  00011	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00014	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	03 c6		 add	 eax, esi
  00022	5e		 pop	 esi

; 462  : 	}

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$_Uninit_move@PAURoomOptionInfo@@PAU1@PAU1@@std@@YAPAPAURoomOptionInfo@@PAPAU1@00AAV?$allocator@PAURoomOptionInfo@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<RoomOptionInfo *,RoomOptionInfo *,RoomOptionInfo *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAPAUPreSetInfo@@@std@@YAPAPAUPreSetInfo@@PAPAU1@@Z ; std::_Val_type<PreSetInfo * *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAUPreSetInfo@@@std@@YAPAPAUPreSetInfo@@PAPAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAUPreSetInfo@@@std@@YAPAPAUPreSetInfo@@PAPAU1@@Z PROC ; std::_Val_type<PreSetInfo * *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAPAUPreSetInfo@@@std@@YAPAPAUPreSetInfo@@PAPAU1@@Z ENDP ; std::_Val_type<PreSetInfo * *>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUPreSetInfo@@PAU1@PAU1@@std@@YAPAPAUPreSetInfo@@PAPAU1@00AAV?$allocator@PAUPreSetInfo@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<PreSetInfo *,PreSetInfo *,PreSetInfo *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAUPreSetInfo@@PAU1@PAU1@@std@@YAPAPAUPreSetInfo@@PAPAU1@00AAV?$allocator@PAUPreSetInfo@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUPreSetInfo@@PAU1@PAU1@@std@@YAPAPAUPreSetInfo@@PAPAU1@00AAV?$allocator@PAUPreSetInfo@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<PreSetInfo *,PreSetInfo *,PreSetInfo *>, COMDAT

; 456  : 	{	// move [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 457  : 	_DEBUG_RANGE(_First, _Last);
; 458  : 	_DEBUG_POINTER(_Dest);
; 459  : 	size_t _Count = (size_t)(_Last - _First);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  00007	2b 75 08	 sub	 esi, DWORD PTR __First$[ebp]
  0000a	c1 fe 02	 sar	 esi, 2

; 460  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 461  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000d	c1 e6 02	 shl	 esi, 2
  00010	56		 push	 esi
  00011	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00014	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	03 c6		 add	 eax, esi
  00022	5e		 pop	 esi

; 462  : 	}

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$_Uninit_move@PAUPreSetInfo@@PAU1@PAU1@@std@@YAPAPAUPreSetInfo@@PAPAU1@00AAV?$allocator@PAUPreSetInfo@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<PreSetInfo *,PreSetInfo *,PreSetInfo *>
_TEXT	ENDS
PUBLIC	?_DECSTR@@YAXPADH@Z				; _DECSTR
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stringprotect.h
;	COMDAT ?_DECSTR@@YAXPADH@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_l$ = 12						; size = 4
?_DECSTR@@YAXPADH@Z PROC				; _DECSTR, COMDAT

; 40   : __forceinline void _DECSTR(char* s, int l){int i=0,l4=(l-1)/4,*p=(int*)s;s[l-1]=0;for(;i<l4;++i)*(p++)^=0xEAEBECED;for(i=l4*4;i<l-1;++i)s[i]^=0xED-i%4;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _l$[ebp]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  0000a	57		 push	 edi
  0000b	8d 79 ff	 lea	 edi, DWORD PTR [ecx-1]
  0000e	8b c7		 mov	 eax, edi
  00010	99		 cdq
  00011	83 e2 03	 and	 edx, 3
  00014	03 c2		 add	 eax, edx
  00016	c1 f8 02	 sar	 eax, 2
  00019	8b d6		 mov	 edx, esi
  0001b	c6 44 0e ff 00	 mov	 BYTE PTR [esi+ecx-1], 0
  00020	85 c0		 test	 eax, eax
  00022	7e 0e		 jle	 SHORT $LN4@DECSTR
  00024	8b c8		 mov	 ecx, eax
$LL6@DECSTR:
  00026	81 32 ed ec eb
	ea		 xor	 DWORD PTR [edx], -353637139 ; eaebecedH
  0002c	83 c2 04	 add	 edx, 4
  0002f	49		 dec	 ecx
  00030	75 f4		 jne	 SHORT $LL6@DECSTR
$LN4@DECSTR:
  00032	c1 e0 02	 shl	 eax, 2
  00035	eb 17		 jmp	 SHORT $LN14@DECSTR
$LL3@DECSTR:
  00037	8b c8		 mov	 ecx, eax
  00039	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0003f	79 05		 jns	 SHORT $LN13@DECSTR
  00041	49		 dec	 ecx
  00042	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00045	41		 inc	 ecx
$LN13@DECSTR:
  00046	b2 ed		 mov	 dl, -19			; ffffffedH
  00048	2a d1		 sub	 dl, cl
  0004a	30 14 30	 xor	 BYTE PTR [eax+esi], dl
  0004d	40		 inc	 eax
$LN14@DECSTR:
  0004e	3b c7		 cmp	 eax, edi
  00050	7c e5		 jl	 SHORT $LL3@DECSTR
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?_DECSTR@@YAXPADH@Z ENDP				; _DECSTR
_TEXT	ENDS
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 880  : 		}

  00008	c3		 ret	 0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
; Function compile flags: /Ogsp
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pos$[ebp]
  00008	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 941  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
PUBLIC	??_7?$CEncrypt@M@@6B@				; CEncrypt<float>::`vftable'
PUBLIC	??1?$CEncrypt@M@@UAE@XZ				; CEncrypt<float>::~CEncrypt<float>
PUBLIC	??_R4?$CEncrypt@M@@6B@				; CEncrypt<float>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CEncrypt@M@@@8			; CEncrypt<float> `RTTI Type Descriptor'
PUBLIC	??_R3?$CEncrypt@M@@8				; CEncrypt<float>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CEncrypt@M@@8				; CEncrypt<float>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CEncrypt@M@@8			; CEncrypt<float>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??1ccddaabb@@UAE@XZ:PROC			; ccddaabb::~ccddaabb
EXTRN	??_E?$CEncrypt@M@@UAEPAXI@Z:PROC		; CEncrypt<float>::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$CEncrypt@M@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CEncrypt@M@@8 DD FLAT:??_R0?AV?$CEncrypt@M@@@8 ; CEncrypt<float>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CEncrypt@M@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CEncrypt@M@@8
rdata$r	SEGMENT
??_R2?$CEncrypt@M@@8 DD FLAT:??_R1A@?0A@EA@?$CEncrypt@M@@8 ; CEncrypt<float>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CEncrypt@M@@8
rdata$r	SEGMENT
??_R3?$CEncrypt@M@@8 DD 00H				; CEncrypt<float>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CEncrypt@M@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CEncrypt@M@@@8
_DATA	SEGMENT
??_R0?AV?$CEncrypt@M@@@8 DD FLAT:??_7type_info@@6B@	; CEncrypt<float> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CEncrypt@M@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$CEncrypt@M@@6B@
rdata$r	SEGMENT
??_R4?$CEncrypt@M@@6B@ DD 00H				; CEncrypt<float>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CEncrypt@M@@@8
	DD	FLAT:??_R3?$CEncrypt@M@@8
rdata$r	ENDS
;	COMDAT ??_7?$CEncrypt@M@@6B@
CONST	SEGMENT
??_7?$CEncrypt@M@@6B@ DD FLAT:??_R4?$CEncrypt@M@@6B@	; CEncrypt<float>::`vftable'
	DD	FLAT:??_E?$CEncrypt@M@@UAEPAXI@Z
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??1?$CEncrypt@M@@UAE@XZ
_TEXT	SEGMENT
??1?$CEncrypt@M@@UAE@XZ PROC				; CEncrypt<float>::~CEncrypt<float>, COMDAT
; _this$ = ecx

; 127  : 	{

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CEncrypt@M@@6B@

; 128  : 	}

  00006	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00009	e9 00 00 00 00	 jmp	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
??1?$CEncrypt@M@@UAE@XZ ENDP				; CEncrypt<float>::~CEncrypt<float>
_TEXT	ENDS
PUBLIC	??_7?$CEncrypt@H@@6B@				; CEncrypt<int>::`vftable'
PUBLIC	??1?$CEncrypt@H@@UAE@XZ				; CEncrypt<int>::~CEncrypt<int>
PUBLIC	??_R4?$CEncrypt@H@@6B@				; CEncrypt<int>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CEncrypt@H@@@8			; CEncrypt<int> `RTTI Type Descriptor'
PUBLIC	??_R3?$CEncrypt@H@@8				; CEncrypt<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CEncrypt@H@@8				; CEncrypt<int>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CEncrypt@H@@8			; CEncrypt<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_E?$CEncrypt@H@@UAEPAXI@Z:PROC		; CEncrypt<int>::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$CEncrypt@H@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CEncrypt@H@@8 DD FLAT:??_R0?AV?$CEncrypt@H@@@8 ; CEncrypt<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CEncrypt@H@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CEncrypt@H@@8
rdata$r	SEGMENT
??_R2?$CEncrypt@H@@8 DD FLAT:??_R1A@?0A@EA@?$CEncrypt@H@@8 ; CEncrypt<int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CEncrypt@H@@8
rdata$r	SEGMENT
??_R3?$CEncrypt@H@@8 DD 00H				; CEncrypt<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CEncrypt@H@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CEncrypt@H@@@8
_DATA	SEGMENT
??_R0?AV?$CEncrypt@H@@@8 DD FLAT:??_7type_info@@6B@	; CEncrypt<int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CEncrypt@H@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$CEncrypt@H@@6B@
rdata$r	SEGMENT
??_R4?$CEncrypt@H@@6B@ DD 00H				; CEncrypt<int>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CEncrypt@H@@@8
	DD	FLAT:??_R3?$CEncrypt@H@@8
rdata$r	ENDS
;	COMDAT ??_7?$CEncrypt@H@@6B@
CONST	SEGMENT
??_7?$CEncrypt@H@@6B@ DD FLAT:??_R4?$CEncrypt@H@@6B@	; CEncrypt<int>::`vftable'
	DD	FLAT:??_E?$CEncrypt@H@@UAEPAXI@Z
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??1?$CEncrypt@H@@UAE@XZ
_TEXT	SEGMENT
??1?$CEncrypt@H@@UAE@XZ PROC				; CEncrypt<int>::~CEncrypt<int>, COMDAT
; _this$ = ecx

; 127  : 	{

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CEncrypt@H@@6B@

; 128  : 	}

  00006	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00009	e9 00 00 00 00	 jmp	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
??1?$CEncrypt@H@@UAE@XZ ENDP				; CEncrypt<int>::~CEncrypt<int>
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??_G?$CEncrypt@M@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CEncrypt@M@@UAEPAXI@Z PROC			; CEncrypt<float>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CEncrypt@M@@6B@
  0000f	e8 00 00 00 00	 call	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
  00014	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00018	74 07		 je	 SHORT $LN1@scalar@2
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	59		 pop	 ecx
$LN1@scalar@2:
  00021	8b c6		 mov	 eax, esi
  00023	5e		 pop	 esi
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??_G?$CEncrypt@M@@UAEPAXI@Z ENDP			; CEncrypt<float>::`scalar deleting destructor'
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??_G?$CEncrypt@H@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CEncrypt@H@@UAEPAXI@Z PROC			; CEncrypt<int>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CEncrypt@H@@6B@
  0000f	e8 00 00 00 00	 call	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
  00014	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00018	74 07		 je	 SHORT $LN1@scalar@3
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	59		 pop	 ecx
$LN1@scalar@3:
  00021	8b c6		 mov	 eax, esi
  00023	5e		 pop	 esi
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??_G?$CEncrypt@H@@UAEPAXI@Z ENDP			; CEncrypt<int>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z	; CEncrypt<float>::EncryptValueToPool
EXTRN	?EncryptByte@ccddaabb@@QAEXPBDPADH@Z:PROC	; ccddaabb::EncryptByte
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
;	COMDAT ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z PROC	; CEncrypt<float>::EncryptValueToPool, COMDAT
; _this$ = ecx

; 67   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 		m_RC5.EncryptByte( value, m_MemPool, max(m_ValueSize, DEFAULT_ENCRYPT) );

  00003	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00007	83 f8 04	 cmp	 eax, 4
  0000a	77 03		 ja	 SHORT $LN4@EncryptVal
  0000c	6a 04		 push	 4
  0000e	58		 pop	 eax
$LN4@EncryptVal:
  0000f	50		 push	 eax
  00010	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  00013	50		 push	 eax
  00014	ff 75 08	 push	 DWORD PTR _value$[ebp]
  00017	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0001a	e8 00 00 00 00	 call	 ?EncryptByte@ccddaabb@@QAEXPBDPADH@Z ; ccddaabb::EncryptByte

; 69   : 		
; 70   : 	}

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ENDP	; CEncrypt<float>::EncryptValueToPool
_TEXT	ENDS
PUBLIC	?Init@?$CEncrypt@M@@AAEXXZ			; CEncrypt<float>::Init
EXTRN	?Setup@ccddaabb@@QAEXPBDHH@Z:PROC		; ccddaabb::Setup
EXTRN	__imp__rand:PROC
EXTRN	__imp__timeGetTime@0:PROC
EXTRN	__imp__GetCurrentProcessId@0:PROC
; Function compile flags: /Ogsp
;	COMDAT ?Init@?$CEncrypt@M@@AAEXXZ
_TEXT	SEGMENT
_pid$ = -8						; size = 4
_tick$ = -4						; size = 4
?Init@?$CEncrypt@M@@AAEXXZ PROC				; CEncrypt<float>::Init, COMDAT
; _this$ = ecx

; 73   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx

; 74   : 		DWORD pid = GetCurrentProcessId();

  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcessId@0
  00010	89 45 f8	 mov	 DWORD PTR _pid$[ebp], eax

; 75   : 		DWORD tick = timeGetTime();

  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0

; 76   : 		m_ValueSize    = sizeof(type);
; 77   : 		m_MemPoolPos   = (unsigned short)( rand()+pid+tick )%(MAX_MEM_POOL-m_ValueSize);

  00019	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__rand
  0001f	89 45 fc	 mov	 DWORD PTR _tick$[ebp], eax
  00022	6a 04		 push	 4
  00024	58		 pop	 eax
  00025	66 89 46 06	 mov	 WORD PTR [esi+6], ax
  00029	ff d7		 call	 edi
  0002b	03 45 f8	 add	 eax, DWORD PTR _pid$[ebp]
  0002e	0f b7 4e 06	 movzx	 ecx, WORD PTR [esi+6]
  00032	03 45 fc	 add	 eax, DWORD PTR _tick$[ebp]
  00035	6a 0c		 push	 12			; 0000000cH
  00037	0f b7 c0	 movzx	 eax, ax
  0003a	5b		 pop	 ebx
  0003b	99		 cdq
  0003c	2b d9		 sub	 ebx, ecx
  0003e	f7 fb		 idiv	 ebx
  00040	66 89 56 04	 mov	 WORD PTR [esi+4], dx

; 78   : 		m_EncryptSeed  = (char)( rand()+pid+tick )%256;

  00044	ff d7		 call	 edi
  00046	02 45 f8	 add	 al, BYTE PTR _pid$[ebp]
  00049	02 45 fc	 add	 al, BYTE PTR _tick$[ebp]
  0004c	0f be c0	 movsx	 eax, al
  0004f	25 ff 00 00 80	 and	 eax, -2147483393	; 800000ffH
  00054	79 07		 jns	 SHORT $LN8@Init
  00056	48		 dec	 eax
  00057	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  0005c	40		 inc	 eax
$LN8@Init:
  0005d	88 46 08	 mov	 BYTE PTR [esi+8], al

; 79   : 
; 80   : 		for (int i = 0; i < MAX_MEM_POOL ; i++)

  00060	33 db		 xor	 ebx, ebx
$LL3@Init:

; 81   : 			m_MemPool[i] = (char)( rand()+pid+tick )%256; // 

  00062	ff d7		 call	 edi
  00064	02 45 f8	 add	 al, BYTE PTR _pid$[ebp]
  00067	02 45 fc	 add	 al, BYTE PTR _tick$[ebp]
  0006a	0f be c0	 movsx	 eax, al
  0006d	25 ff 00 00 80	 and	 eax, -2147483393	; 800000ffH
  00072	79 07		 jns	 SHORT $LN9@Init
  00074	48		 dec	 eax
  00075	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  0007a	40		 inc	 eax
$LN9@Init:
  0007b	88 44 1e 1c	 mov	 BYTE PTR [esi+ebx+28], al
  0007f	43		 inc	 ebx
  00080	83 fb 0c	 cmp	 ebx, 12			; 0000000cH
  00083	7c dd		 jl	 SHORT $LL3@Init

; 82   : 
; 83   : 		//UJ 130913, : szKey  
; 84   : 		//char szKey[ccddaabb::KEY_SIZE];//="";
; 85   : 		//for (int i = 0; i < ccddaabb::KEY_SIZE  ; i++)
; 86   : 		//	szKey[i] = (char)( rand()+pid+tick )%256; // 
; 87   : 		m_RC5.Setup( NULL, pid, tick );

  00085	ff 75 fc	 push	 DWORD PTR _tick$[ebp]
  00088	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0008b	ff 75 f8	 push	 DWORD PTR _pid$[ebp]
  0008e	6a 00		 push	 0
  00090	e8 00 00 00 00	 call	 ?Setup@ccddaabb@@QAEXPBDHH@Z ; ccddaabb::Setup
  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx

; 88   : 
; 89   : #ifdef _NOTUSE
; 90   : 		m_value        = 0;
; 91   : 		EncryptValueToPool((char*)&m_value);
; 92   : 		Debug();
; 93   : #endif
; 94   : 	}

  00098	c9		 leave
  00099	c3		 ret	 0
?Init@?$CEncrypt@M@@AAEXXZ ENDP				; CEncrypt<float>::Init
_TEXT	ENDS
PUBLIC	?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z	; CEncrypt<float>::DecryptValueToPool
EXTRN	?DecryptByte@ccddaabb@@QBEXPBDPADH@Z:PROC	; ccddaabb::DecryptByte
EXTRN	__fltused:DWORD
; Function compile flags: /Ogsp
;	COMDAT ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z PROC	; CEncrypt<float>::DecryptValueToPool, COMDAT
; _this$ = ecx

; 1648 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1649 : 		m_RC5.DecryptByte( m_MemPool, m_TempMem, 4 );

  00004	8d 71 28	 lea	 esi, DWORD PTR [ecx+40]
  00007	6a 04		 push	 4
  00009	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00011	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte

; 1650 : 		*value = *((float*)m_TempMem);

  00016	d9 06		 fld	 DWORD PTR [esi]
  00018	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  0001b	d9 18		 fstp	 DWORD PTR [eax]
  0001d	5e		 pop	 esi

; 1651 : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ENDP	; CEncrypt<float>::DecryptValueToPool
_TEXT	ENDS
PUBLIC	?EncryptValueToPool@?$CEncrypt@H@@AAEXPBD@Z	; CEncrypt<int>::EncryptValueToPool
; Function compile flags: /Ogsp
;	COMDAT ?EncryptValueToPool@?$CEncrypt@H@@AAEXPBD@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?EncryptValueToPool@?$CEncrypt@H@@AAEXPBD@Z PROC	; CEncrypt<int>::EncryptValueToPool, COMDAT
; _this$ = ecx

; 67   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 		m_RC5.EncryptByte( value, m_MemPool, max(m_ValueSize, DEFAULT_ENCRYPT) );

  00003	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00007	83 f8 04	 cmp	 eax, 4
  0000a	77 03		 ja	 SHORT $LN4@EncryptVal@2
  0000c	6a 04		 push	 4
  0000e	58		 pop	 eax
$LN4@EncryptVal@2:
  0000f	50		 push	 eax
  00010	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  00013	50		 push	 eax
  00014	ff 75 08	 push	 DWORD PTR _value$[ebp]
  00017	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0001a	e8 00 00 00 00	 call	 ?EncryptByte@ccddaabb@@QAEXPBDPADH@Z ; ccddaabb::EncryptByte

; 69   : 		
; 70   : 	}

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?EncryptValueToPool@?$CEncrypt@H@@AAEXPBD@Z ENDP	; CEncrypt<int>::EncryptValueToPool
_TEXT	ENDS
PUBLIC	?Init@?$CEncrypt@H@@AAEXXZ			; CEncrypt<int>::Init
; Function compile flags: /Ogsp
;	COMDAT ?Init@?$CEncrypt@H@@AAEXXZ
_TEXT	SEGMENT
_pid$ = -8						; size = 4
_tick$ = -4						; size = 4
?Init@?$CEncrypt@H@@AAEXXZ PROC				; CEncrypt<int>::Init, COMDAT
; _this$ = ecx

; 73   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx

; 74   : 		DWORD pid = GetCurrentProcessId();

  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcessId@0
  00010	89 45 f8	 mov	 DWORD PTR _pid$[ebp], eax

; 75   : 		DWORD tick = timeGetTime();

  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0

; 76   : 		m_ValueSize    = sizeof(type);
; 77   : 		m_MemPoolPos   = (unsigned short)( rand()+pid+tick )%(MAX_MEM_POOL-m_ValueSize);

  00019	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__rand
  0001f	89 45 fc	 mov	 DWORD PTR _tick$[ebp], eax
  00022	6a 04		 push	 4
  00024	58		 pop	 eax
  00025	66 89 46 06	 mov	 WORD PTR [esi+6], ax
  00029	ff d7		 call	 edi
  0002b	03 45 f8	 add	 eax, DWORD PTR _pid$[ebp]
  0002e	0f b7 4e 06	 movzx	 ecx, WORD PTR [esi+6]
  00032	03 45 fc	 add	 eax, DWORD PTR _tick$[ebp]
  00035	6a 0c		 push	 12			; 0000000cH
  00037	0f b7 c0	 movzx	 eax, ax
  0003a	5b		 pop	 ebx
  0003b	99		 cdq
  0003c	2b d9		 sub	 ebx, ecx
  0003e	f7 fb		 idiv	 ebx
  00040	66 89 56 04	 mov	 WORD PTR [esi+4], dx

; 78   : 		m_EncryptSeed  = (char)( rand()+pid+tick )%256;

  00044	ff d7		 call	 edi
  00046	02 45 f8	 add	 al, BYTE PTR _pid$[ebp]
  00049	02 45 fc	 add	 al, BYTE PTR _tick$[ebp]
  0004c	0f be c0	 movsx	 eax, al
  0004f	25 ff 00 00 80	 and	 eax, -2147483393	; 800000ffH
  00054	79 07		 jns	 SHORT $LN8@Init@2
  00056	48		 dec	 eax
  00057	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  0005c	40		 inc	 eax
$LN8@Init@2:
  0005d	88 46 08	 mov	 BYTE PTR [esi+8], al

; 79   : 
; 80   : 		for (int i = 0; i < MAX_MEM_POOL ; i++)

  00060	33 db		 xor	 ebx, ebx
$LL3@Init@2:

; 81   : 			m_MemPool[i] = (char)( rand()+pid+tick )%256; // 

  00062	ff d7		 call	 edi
  00064	02 45 f8	 add	 al, BYTE PTR _pid$[ebp]
  00067	02 45 fc	 add	 al, BYTE PTR _tick$[ebp]
  0006a	0f be c0	 movsx	 eax, al
  0006d	25 ff 00 00 80	 and	 eax, -2147483393	; 800000ffH
  00072	79 07		 jns	 SHORT $LN9@Init@2
  00074	48		 dec	 eax
  00075	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  0007a	40		 inc	 eax
$LN9@Init@2:
  0007b	88 44 1e 1c	 mov	 BYTE PTR [esi+ebx+28], al
  0007f	43		 inc	 ebx
  00080	83 fb 0c	 cmp	 ebx, 12			; 0000000cH
  00083	7c dd		 jl	 SHORT $LL3@Init@2

; 82   : 
; 83   : 		//UJ 130913, : szKey  
; 84   : 		//char szKey[ccddaabb::KEY_SIZE];//="";
; 85   : 		//for (int i = 0; i < ccddaabb::KEY_SIZE  ; i++)
; 86   : 		//	szKey[i] = (char)( rand()+pid+tick )%256; // 
; 87   : 		m_RC5.Setup( NULL, pid, tick );

  00085	ff 75 fc	 push	 DWORD PTR _tick$[ebp]
  00088	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0008b	ff 75 f8	 push	 DWORD PTR _pid$[ebp]
  0008e	6a 00		 push	 0
  00090	e8 00 00 00 00	 call	 ?Setup@ccddaabb@@QAEXPBDHH@Z ; ccddaabb::Setup
  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx

; 88   : 
; 89   : #ifdef _NOTUSE
; 90   : 		m_value        = 0;
; 91   : 		EncryptValueToPool((char*)&m_value);
; 92   : 		Debug();
; 93   : #endif
; 94   : 	}

  00098	c9		 leave
  00099	c3		 ret	 0
?Init@?$CEncrypt@H@@AAEXXZ ENDP				; CEncrypt<int>::Init
_TEXT	ENDS
PUBLIC	?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z	; CEncrypt<int>::DecryptValueToPool
; Function compile flags: /Ogsp
;	COMDAT ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z PROC	; CEncrypt<int>::DecryptValueToPool, COMDAT
; _this$ = ecx

; 837  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 838  : 		m_RC5.DecryptByte( m_MemPool, m_TempMem, 4 );

  00004	8d 71 28	 lea	 esi, DWORD PTR [ecx+40]
  00007	6a 04		 push	 4
  00009	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00011	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte

; 839  : 		*value = *((int*)m_TempMem);

  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0001b	89 01		 mov	 DWORD PTR [ecx], eax
  0001d	5e		 pop	 esi

; 840  : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ENDP	; CEncrypt<int>::DecryptValueToPool
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<int,std::allocator<int> > >::_Vector_iterator<std::_Vector_val<int,std::allocator<int> > >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<int,std::allocator<int> > >::_Vector_iterator<std::_Vector_val<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 305  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<int,std::allocator<int> > >::_Vector_iterator<std::_Vector_val<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@H@std@@QAE@ABV01@@Z PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
; Function compile flags: /Ogsp
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 183  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 778  : 		}

  00008	c3		 ret	 0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@@Z ; std::vector<int,std::allocator<int> >::_Make_iter
; Function compile flags: /Ogsp
;	COMDAT ?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@@Z PROC ; std::vector<int,std::allocator<int> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 		return (iterator(_Where._Ptr, this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 803  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@@Z ENDP ; std::vector<int,std::allocator<int> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Ogsp
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT
; _this$ = ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen@3:
$LN3@Xlen@3:
  0000b	cc		 int	 3
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC		; std::allocator<int>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::_Compat
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::_Compat, COMDAT
; _this$ = ecx

; 253  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::_Compat
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T530950 = -12						; size = 12
$T530954 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 3e		 je	 SHORT $LN5@Allocate@3

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00015	77 10		 ja	 SHORT $LN1@Allocate@3
  00017	8b c1		 mov	 eax, ecx
  00019	c1 e0 02	 shl	 eax, 2
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	59		 pop	 ecx
  00023	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00025	75 26		 jne	 SHORT $LN5@Allocate@3
$LN1@Allocate@3:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00027	83 65 08 00	 and	 DWORD PTR $T530954[ebp], 0
  0002b	8d 45 08	 lea	 eax, DWORD PTR $T530954[ebp]
  0002e	50		 push	 eax
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T530950[ebp]
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
  00038	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003d	8d 45 f4	 lea	 eax, DWORD PTR $T530950[ebp]
  00040	50		 push	 eax
  00041	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T530950[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00048	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate@3:
$LN5@Allocate@3:

; 40   : 	}

  0004d	c9		 leave
  0004e	c3		 ret	 0
$LN9@Allocate@3:
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
; Function compile flags: /Ogsp
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$forward@AAH@std@@YAAAHAAH@Z			; std::forward<int &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@AAH@std@@YAAAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAH@std@@YAAAHAAH@Z PROC			; std::forward<int &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAH@std@@YAAAHAAH@Z ENDP			; std::forward<int &>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAH@std@@YAPAHPAH@Z		; std::_Val_type<int *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAH@std@@YAPAHPAH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAH@std@@YAPAHPAH@Z PROC			; std::_Val_type<int *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAH@std@@YAPAHPAH@Z ENDP			; std::_Val_type<int *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ; std::_Ptr_cat<int,int>
; Function compile flags: /Ogsp
;	COMDAT ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z PROC ; std::_Ptr_cat<int,int>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	c9		 leave
  00008	c3		 ret	 0
??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ENDP ; std::_Ptr_cat<int,int>
_TEXT	ENDS
PUBLIC	??$_Move@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<int *,int *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Move@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<int *,int *>, COMDAT

; 2522 : 	{	// move [_First, _Last) to [_Dest, ...), pointers to scalars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2523 : 	ptrdiff_t _Count = _Last - _First;

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  00007	2b 75 08	 sub	 esi, DWORD PTR __First$[ebp]
  0000a	57		 push	 edi

; 2524 : 	_CSTD memmove(&*_Dest, &*_First,
; 2525 : 		_Count * sizeof (*_First));

  0000b	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
  0000e	c1 fe 02	 sar	 esi, 2
  00011	c1 e6 02	 shl	 esi, 2
  00014	56		 push	 esi
  00015	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00018	57		 push	 edi
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2526 : 	return (_Dest + _Count);

  00022	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 2527 : 	}

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Move@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 105  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@HHH@std@@YAPAHPAH00AAV?$allocator@H@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<int,int,int>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninit_move@HHH@std@@YAPAHPAH00AAV?$allocator@H@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@HHH@std@@YAPAHPAH00AAV?$allocator@H@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<int,int,int>, COMDAT

; 456  : 	{	// move [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 457  : 	_DEBUG_RANGE(_First, _Last);
; 458  : 	_DEBUG_POINTER(_Dest);
; 459  : 	size_t _Count = (size_t)(_Last - _First);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  00007	2b 75 08	 sub	 esi, DWORD PTR __First$[ebp]
  0000a	c1 fe 02	 sar	 esi, 2

; 460  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 461  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000d	c1 e6 02	 shl	 esi, 2
  00010	56		 push	 esi
  00011	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00014	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	03 c6		 add	 eax, esi
  00022	5e		 pop	 esi

; 462  : 	}

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$_Uninit_move@HHH@std@@YAPAHPAH00AAV?$allocator@H@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<int,int,int>
_TEXT	ENDS
PUBLIC	??1PreSetInfo@@QAE@XZ				; PreSetInfo::~PreSetInfo
EXTRN	__imp_??1ioHashString@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__EH_epilog3:PROC
EXTRN	__EH_prolog3:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1PreSetInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1PreSetInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1PreSetInfo@@QAE@XZ$1
__ehfuncinfo$??1PreSetInfo@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1PreSetInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??1PreSetInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1PreSetInfo@@QAE@XZ PROC				; PreSetInfo::~PreSetInfo, COMDAT
; _this$ = ecx
  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??1PreSetInfo@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	bf 00 00 00 00	 mov	 edi, OFFSET ??_7?$CEncrypt@H@@6B@
  00016	8d 4e 58	 lea	 ecx, DWORD PTR [esi+88]
  00019	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00020	89 7e 4c	 mov	 DWORD PTR [esi+76], edi
  00023	e8 00 00 00 00	 call	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
  00028	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  0002b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0002f	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  00032	e8 00 00 00 00	 call	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
  00037	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0003b	8b ce		 mov	 ecx, esi
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00043	e8 00 00 00 00	 call	 __EH_epilog3
  00048	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1PreSetInfo@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??1PreSetInfo@@QAE@XZ$1:
  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0000f	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@H@@UAE@XZ	; CEncrypt<int>::~CEncrypt<int>
__ehhandler$??1PreSetInfo@@QAE@XZ:
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0001e	33 c8		 xor	 ecx, eax
  00020	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00025	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1PreSetInfo@@QAE@XZ
  0002a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1PreSetInfo@@QAE@XZ ENDP				; PreSetInfo::~PreSetInfo
PUBLIC	??_GPreSetInfo@@QAEPAXI@Z			; PreSetInfo::`scalar deleting destructor'
; Function compile flags: /Ogsp
;	COMDAT ??_GPreSetInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GPreSetInfo@@QAEPAXI@Z PROC				; PreSetInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1PreSetInfo@@QAE@XZ
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 07		 je	 SHORT $LN1@scalar@4
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	59		 pop	 ecx
$LN1@scalar@4:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??_GPreSetInfo@@QAEPAXI@Z ENDP				; PreSetInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1RoomOptionInfo@@QAE@XZ			; RoomOptionInfo::~RoomOptionInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1RoomOptionInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1RoomOptionInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1RoomOptionInfo@@QAE@XZ$1
__ehfuncinfo$??1RoomOptionInfo@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1RoomOptionInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??1RoomOptionInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1RoomOptionInfo@@QAE@XZ PROC				; RoomOptionInfo::~RoomOptionInfo, COMDAT
; _this$ = ecx
  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??1RoomOptionInfo@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00017	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  0001a	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00021	ff d7		 call	 edi
  00023	8d 4e 30	 lea	 ecx, DWORD PTR [esi+48]
  00026	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0002a	ff d7		 call	 edi
  0002c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00030	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00033	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CEncrypt@M@@6B@
  00039	e8 00 00 00 00	 call	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
  0003e	e8 00 00 00 00	 call	 __EH_epilog3
  00043	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1RoomOptionInfo@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@M@@UAE@XZ	; CEncrypt<float>::~CEncrypt<float>
__unwindfunclet$??1RoomOptionInfo@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 30	 add	 ecx, 48			; 00000030H
  0000e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$??1RoomOptionInfo@@QAE@XZ:
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0001e	33 c8		 xor	 ecx, eax
  00020	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00025	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1RoomOptionInfo@@QAE@XZ
  0002a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1RoomOptionInfo@@QAE@XZ ENDP				; RoomOptionInfo::~RoomOptionInfo
PUBLIC	?IsEnableOptionMode@ioRoomOptionManager@@QAE_NH@Z ; ioRoomOptionManager::IsEnableOptionMode
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioroomoptionmanager.cpp
;	COMDAT ?IsEnableOptionMode@ioRoomOptionManager@@QAE_NH@Z
_TEXT	SEGMENT
_iModeIndex$ = 8					; size = 4
?IsEnableOptionMode@ioRoomOptionManager@@QAE_NH@Z PROC	; ioRoomOptionManager::IsEnableOptionMode, COMDAT
; _this$ = ecx

; 748  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 749  : 	int iSize = m_EnableOptionModeList.size();

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]

; 750  : 	for( int i=0; i < iSize; ++i )

  00009	33 d2		 xor	 edx, edx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi
  0000f	85 c0		 test	 eax, eax
  00011	7e 12		 jle	 SHORT $LN2@IsEnableOp

; 749  : 	int iSize = m_EnableOptionModeList.size();

  00013	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
$LL4@IsEnableOp:

; 751  : 	{
; 752  : 		if( m_EnableOptionModeList[i] == iModeIndex )

  00016	8b 31		 mov	 esi, DWORD PTR [ecx]
  00018	3b 75 08	 cmp	 esi, DWORD PTR _iModeIndex$[ebp]
  0001b	74 0f		 je	 SHORT $LN12@IsEnableOp

; 750  : 	for( int i=0; i < iSize; ++i )

  0001d	42		 inc	 edx
  0001e	83 c1 04	 add	 ecx, 4
  00021	3b d0		 cmp	 edx, eax
  00023	7c f1		 jl	 SHORT $LL4@IsEnableOp
$LN2@IsEnableOp:

; 754  : 	}
; 755  : 
; 756  : 	return false;

  00025	32 c0		 xor	 al, al
$LN5@IsEnableOp:
  00027	5e		 pop	 esi

; 757  : }

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
$LN12@IsEnableOp:

; 753  : 			return true;

  0002c	b0 01		 mov	 al, 1
  0002e	eb f7		 jmp	 SHORT $LN5@IsEnableOp
?IsEnableOptionMode@ioRoomOptionManager@@QAE_NH@Z ENDP	; ioRoomOptionManager::IsEnableOptionMode
_TEXT	ENDS
PUBLIC	?IsNoChallengerMode@ioRoomOptionManager@@QAE_NH@Z ; ioRoomOptionManager::IsNoChallengerMode
; Function compile flags: /Ogsp
;	COMDAT ?IsNoChallengerMode@ioRoomOptionManager@@QAE_NH@Z
_TEXT	SEGMENT
_iModeIndex$ = 8					; size = 4
?IsNoChallengerMode@ioRoomOptionManager@@QAE_NH@Z PROC	; ioRoomOptionManager::IsNoChallengerMode, COMDAT
; _this$ = ecx

; 760  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 761  : 	int iSize = m_NoChallengerModeList.size();

  00003	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00006	2b 41 24	 sub	 eax, DWORD PTR [ecx+36]

; 762  : 	for( int i=0; i < iSize; ++i )

  00009	33 d2		 xor	 edx, edx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi
  0000f	85 c0		 test	 eax, eax
  00011	7e 12		 jle	 SHORT $LN2@IsNoChalle

; 761  : 	int iSize = m_NoChallengerModeList.size();

  00013	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
$LL4@IsNoChalle:

; 763  : 	{
; 764  : 		if( m_NoChallengerModeList[i] == iModeIndex )

  00016	8b 31		 mov	 esi, DWORD PTR [ecx]
  00018	3b 75 08	 cmp	 esi, DWORD PTR _iModeIndex$[ebp]
  0001b	74 0f		 je	 SHORT $LN12@IsNoChalle

; 762  : 	for( int i=0; i < iSize; ++i )

  0001d	42		 inc	 edx
  0001e	83 c1 04	 add	 ecx, 4
  00021	3b d0		 cmp	 edx, eax
  00023	7c f1		 jl	 SHORT $LL4@IsNoChalle
$LN2@IsNoChalle:

; 766  : 	}
; 767  : 
; 768  : 	return false;

  00025	32 c0		 xor	 al, al
$LN5@IsNoChalle:
  00027	5e		 pop	 esi

; 769  : }

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
$LN12@IsNoChalle:

; 765  : 			return true;

  0002c	b0 01		 mov	 al, 1
  0002e	eb f7		 jmp	 SHORT $LN5@IsNoChalle
?IsNoChallengerMode@ioRoomOptionManager@@QAE_NH@Z ENDP	; ioRoomOptionManager::IsNoChallengerMode
_TEXT	ENDS
PUBLIC	?IsEnableRoundOptionMode@ioRoomOptionManager@@QAE_NH@Z ; ioRoomOptionManager::IsEnableRoundOptionMode
; Function compile flags: /Ogsp
;	COMDAT ?IsEnableRoundOptionMode@ioRoomOptionManager@@QAE_NH@Z
_TEXT	SEGMENT
_iModeIndex$ = 8					; size = 4
?IsEnableRoundOptionMode@ioRoomOptionManager@@QAE_NH@Z PROC ; ioRoomOptionManager::IsEnableRoundOptionMode, COMDAT
; _this$ = ecx

; 772  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 773  : 	int iSize = m_EnableRoundOptionModeList.size();

  00003	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00006	2b 41 14	 sub	 eax, DWORD PTR [ecx+20]

; 774  : 	for( int i=0; i < iSize; ++i )

  00009	33 d2		 xor	 edx, edx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi
  0000f	85 c0		 test	 eax, eax
  00011	7e 12		 jle	 SHORT $LN2@IsEnableRo

; 773  : 	int iSize = m_EnableRoundOptionModeList.size();

  00013	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
$LL4@IsEnableRo:

; 775  : 	{
; 776  : 		if( m_EnableRoundOptionModeList[i] == iModeIndex )

  00016	8b 31		 mov	 esi, DWORD PTR [ecx]
  00018	3b 75 08	 cmp	 esi, DWORD PTR _iModeIndex$[ebp]
  0001b	74 0f		 je	 SHORT $LN12@IsEnableRo

; 774  : 	for( int i=0; i < iSize; ++i )

  0001d	42		 inc	 edx
  0001e	83 c1 04	 add	 ecx, 4
  00021	3b d0		 cmp	 edx, eax
  00023	7c f1		 jl	 SHORT $LL4@IsEnableRo
$LN2@IsEnableRo:

; 778  : 	}
; 779  : 
; 780  : 	return false;

  00025	32 c0		 xor	 al, al
$LN5@IsEnableRo:
  00027	5e		 pop	 esi

; 781  : }

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
$LN12@IsEnableRo:

; 777  : 			return true;

  0002c	b0 01		 mov	 al, 1
  0002e	eb f7		 jmp	 SHORT $LN5@IsEnableRo
?IsEnableRoundOptionMode@ioRoomOptionManager@@QAE_NH@Z ENDP ; ioRoomOptionManager::IsEnableRoundOptionMode
_TEXT	ENDS
PUBLIC	?GetPreSetDesc@ioRoomOptionManager@@QAE?AVioHashString@@H@Z ; ioRoomOptionManager::GetPreSetDesc
EXTRN	__imp_??0ioHashString@@QAE@XZ:PROC
EXTRN	__imp_??0ioHashString@@QAE@ABV0@@Z:PROC
; Function compile flags: /Ogsp
;	COMDAT ?GetPreSetDesc@ioRoomOptionManager@@QAE?AVioHashString@@H@Z
_TEXT	SEGMENT
$T531057 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_iIndex$ = 12						; size = 4
?GetPreSetDesc@ioRoomOptionManager@@QAE?AVioHashString@@H@Z PROC ; ioRoomOptionManager::GetPreSetDesc, COMDAT
; _this$ = ecx

; 1032 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	83 65 fc 00	 and	 DWORD PTR $T531057[ebp], 0

; 1033 : 	int iSize = m_PreSetList.size();

  00008	8d 81 94 01 00
	00		 lea	 eax, DWORD PTR [ecx+404]

; 1034 : 
; 1035 : 	if( COMPARE( iIndex, 0, iSize ) )

  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00011	85 c9		 test	 ecx, ecx
  00013	78 1c		 js	 SHORT $LN1@GetPreSetD

; 1033 : 	int iSize = m_PreSetList.size();

  00015	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00018	2b 10		 sub	 edx, DWORD PTR [eax]
  0001a	c1 fa 02	 sar	 edx, 2

; 1034 : 
; 1035 : 	if( COMPARE( iIndex, 0, iSize ) )

  0001d	3b ca		 cmp	 ecx, edx
  0001f	7d 10		 jge	 SHORT $LN1@GetPreSetD

; 1036 : 	{
; 1037 : 		return m_PreSetList[iIndex]->m_Desc;

  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	ff 34 88	 push	 DWORD PTR [eax+ecx*4]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  0002f	eb 09		 jmp	 SHORT $LN10@GetPreSetD
$LN1@GetPreSetD:

; 1038 : 	}
; 1039 : 
; 1040 : 	return ioHashString();

  00031	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ
$LN10@GetPreSetD:
  0003a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1041 : }

  0003d	c9		 leave
  0003e	c2 08 00	 ret	 8
?GetPreSetDesc@ioRoomOptionManager@@QAE?AVioHashString@@H@Z ENDP ; ioRoomOptionManager::GetPreSetDesc
_TEXT	ENDS
PUBLIC	?GetChangeCharDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ; ioRoomOptionManager::GetChangeCharDesc
; Function compile flags: /Ogsp
;	COMDAT ?GetChangeCharDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z
_TEXT	SEGMENT
$T531071 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_iIndex$ = 12						; size = 4
_bUiDesc$ = 16						; size = 1
?GetChangeCharDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z PROC ; ioRoomOptionManager::GetChangeCharDesc, COMDAT
; _this$ = ecx

; 1044 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1046 : 
; 1047 : 	if( COMPARE( iIndex, 0, iSize ) )

  00004	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00007	83 65 fc 00	 and	 DWORD PTR $T531071[ebp], 0
  0000b	85 c0		 test	 eax, eax
  0000d	78 2d		 js	 SHORT $LN1@GetChangeC

; 1045 : 	int iSize = m_RoomChangeCharList.size();

  0000f	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00012	2b 51 34	 sub	 edx, DWORD PTR [ecx+52]
  00015	c1 fa 02	 sar	 edx, 2

; 1046 : 
; 1047 : 	if( COMPARE( iIndex, 0, iSize ) )

  00018	3b c2		 cmp	 eax, edx
  0001a	7d 20		 jge	 SHORT $LN1@GetChangeC

; 1048 : 	{
; 1049 : 		if( bUiDesc )

  0001c	80 7d 10 00	 cmp	 BYTE PTR _bUiDesc$[ebp], 0

; 1050 : 			return m_RoomChangeCharList[iIndex]->m_UIDesc;

  00020	8b 49 34	 mov	 ecx, DWORD PTR [ecx+52]
  00023	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00029	74 0c		 je	 SHORT $LN2@GetChangeC
  0002b	83 c0 40	 add	 eax, 64			; 00000040H
$LN15@GetChangeC:
  0002e	50		 push	 eax
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  00035	eb 0e		 jmp	 SHORT $LN14@GetChangeC
$LN2@GetChangeC:

; 1051 : 		else
; 1052 : 			return m_RoomChangeCharList[iIndex]->m_Desc;

  00037	83 c0 30	 add	 eax, 48			; 00000030H
  0003a	eb f2		 jmp	 SHORT $LN15@GetChangeC
$LN1@GetChangeC:

; 1053 : 	}
; 1054 : 
; 1055 : 	return ioHashString();

  0003c	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ
$LN14@GetChangeC:
  00045	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1056 : }

  00048	c9		 leave
  00049	c2 0c 00	 ret	 12			; 0000000cH
?GetChangeCharDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ENDP ; ioRoomOptionManager::GetChangeCharDesc
_TEXT	ENDS
PUBLIC	?GetRedHPDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ; ioRoomOptionManager::GetRedHPDesc
; Function compile flags: /Ogsp
;	COMDAT ?GetRedHPDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z
_TEXT	SEGMENT
$T531090 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_iIndex$ = 12						; size = 4
_bUiDesc$ = 16						; size = 1
?GetRedHPDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z PROC ; ioRoomOptionManager::GetRedHPDesc, COMDAT
; _this$ = ecx

; 1059 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1061 : 
; 1062 : 	if( COMPARE( iIndex, 0, iSize ) )

  00004	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00007	83 65 fc 00	 and	 DWORD PTR $T531090[ebp], 0
  0000b	85 c0		 test	 eax, eax
  0000d	78 2d		 js	 SHORT $LN1@GetRedHPDe

; 1060 : 	int iSize = m_RoomRedHPList.size();

  0000f	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  00012	2b 51 44	 sub	 edx, DWORD PTR [ecx+68]
  00015	c1 fa 02	 sar	 edx, 2

; 1061 : 
; 1062 : 	if( COMPARE( iIndex, 0, iSize ) )

  00018	3b c2		 cmp	 eax, edx
  0001a	7d 20		 jge	 SHORT $LN1@GetRedHPDe

; 1063 : 	{
; 1064 : 		if( bUiDesc )

  0001c	80 7d 10 00	 cmp	 BYTE PTR _bUiDesc$[ebp], 0

; 1065 : 			return m_RoomRedHPList[iIndex]->m_UIDesc;

  00020	8b 49 44	 mov	 ecx, DWORD PTR [ecx+68]
  00023	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00029	74 0c		 je	 SHORT $LN2@GetRedHPDe
  0002b	83 c0 40	 add	 eax, 64			; 00000040H
$LN15@GetRedHPDe:
  0002e	50		 push	 eax
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  00035	eb 0e		 jmp	 SHORT $LN14@GetRedHPDe
$LN2@GetRedHPDe:

; 1066 : 		else
; 1067 : 			return m_RoomRedHPList[iIndex]->m_Desc;

  00037	83 c0 30	 add	 eax, 48			; 00000030H
  0003a	eb f2		 jmp	 SHORT $LN15@GetRedHPDe
$LN1@GetRedHPDe:

; 1068 : 	}
; 1069 : 
; 1070 : 	return ioHashString();

  0003c	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ
$LN14@GetRedHPDe:
  00045	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1071 : }

  00048	c9		 leave
  00049	c2 0c 00	 ret	 12			; 0000000cH
?GetRedHPDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ENDP ; ioRoomOptionManager::GetRedHPDesc
_TEXT	ENDS
PUBLIC	?GetBlueHPDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ; ioRoomOptionManager::GetBlueHPDesc
; Function compile flags: /Ogsp
;	COMDAT ?GetBlueHPDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z
_TEXT	SEGMENT
$T531109 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_iIndex$ = 12						; size = 4
_bUiDesc$ = 16						; size = 1
?GetBlueHPDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z PROC ; ioRoomOptionManager::GetBlueHPDesc, COMDAT
; _this$ = ecx

; 1074 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1076 : 
; 1077 : 	if( COMPARE( iIndex, 0, iSize ) )

  00004	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00007	83 65 fc 00	 and	 DWORD PTR $T531109[ebp], 0
  0000b	85 c0		 test	 eax, eax
  0000d	78 2d		 js	 SHORT $LN1@GetBlueHPD

; 1075 : 	int iSize = m_RoomBlueHPList.size();

  0000f	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  00012	2b 51 54	 sub	 edx, DWORD PTR [ecx+84]
  00015	c1 fa 02	 sar	 edx, 2

; 1076 : 
; 1077 : 	if( COMPARE( iIndex, 0, iSize ) )

  00018	3b c2		 cmp	 eax, edx
  0001a	7d 20		 jge	 SHORT $LN1@GetBlueHPD

; 1078 : 	{
; 1079 : 		if( bUiDesc )

  0001c	80 7d 10 00	 cmp	 BYTE PTR _bUiDesc$[ebp], 0

; 1080 : 			return m_RoomBlueHPList[iIndex]->m_UIDesc;

  00020	8b 49 54	 mov	 ecx, DWORD PTR [ecx+84]
  00023	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00029	74 0c		 je	 SHORT $LN2@GetBlueHPD
  0002b	83 c0 40	 add	 eax, 64			; 00000040H
$LN15@GetBlueHPD:
  0002e	50		 push	 eax
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  00035	eb 0e		 jmp	 SHORT $LN14@GetBlueHPD
$LN2@GetBlueHPD:

; 1081 : 		else
; 1082 : 			return m_RoomBlueHPList[iIndex]->m_Desc;

  00037	83 c0 30	 add	 eax, 48			; 00000030H
  0003a	eb f2		 jmp	 SHORT $LN15@GetBlueHPD
$LN1@GetBlueHPD:

; 1083 : 	}
; 1084 : 
; 1085 : 	return ioHashString();

  0003c	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ
$LN14@GetBlueHPD:
  00045	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1086 : }

  00048	c9		 leave
  00049	c2 0c 00	 ret	 12			; 0000000cH
?GetBlueHPDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ENDP ; ioRoomOptionManager::GetBlueHPDesc
_TEXT	ENDS
PUBLIC	?GetCoolTimeDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ; ioRoomOptionManager::GetCoolTimeDesc
; Function compile flags: /Ogsp
;	COMDAT ?GetCoolTimeDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z
_TEXT	SEGMENT
$T531128 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_iIndex$ = 12						; size = 4
_bUiDesc$ = 16						; size = 1
?GetCoolTimeDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z PROC ; ioRoomOptionManager::GetCoolTimeDesc, COMDAT
; _this$ = ecx

; 1089 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1091 : 
; 1092 : 	if( COMPARE( iIndex, 0, iSize ) )

  00004	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00007	83 65 fc 00	 and	 DWORD PTR $T531128[ebp], 0
  0000b	85 c0		 test	 eax, eax
  0000d	78 36		 js	 SHORT $LN1@GetCoolTim

; 1090 : 	int iSize = m_RoomCoolTimeList.size();

  0000f	8b 91 88 00 00
	00		 mov	 edx, DWORD PTR [ecx+136]
  00015	2b 91 84 00 00
	00		 sub	 edx, DWORD PTR [ecx+132]
  0001b	c1 fa 02	 sar	 edx, 2

; 1091 : 
; 1092 : 	if( COMPARE( iIndex, 0, iSize ) )

  0001e	3b c2		 cmp	 eax, edx
  00020	7d 23		 jge	 SHORT $LN1@GetCoolTim

; 1093 : 	{
; 1094 : 		if( bUiDesc )

  00022	80 7d 10 00	 cmp	 BYTE PTR _bUiDesc$[ebp], 0

; 1095 : 			return m_RoomCoolTimeList[iIndex]->m_UIDesc;

  00026	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [ecx+132]
  0002c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00032	74 0c		 je	 SHORT $LN2@GetCoolTim
  00034	83 c0 40	 add	 eax, 64			; 00000040H
$LN15@GetCoolTim:
  00037	50		 push	 eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  0003e	eb 0e		 jmp	 SHORT $LN14@GetCoolTim
$LN2@GetCoolTim:

; 1096 : 		else
; 1097 : 			return m_RoomCoolTimeList[iIndex]->m_Desc;

  00040	83 c0 30	 add	 eax, 48			; 00000030H
  00043	eb f2		 jmp	 SHORT $LN15@GetCoolTim
$LN1@GetCoolTim:

; 1098 : 	}
; 1099 : 
; 1100 : 	return ioHashString();

  00045	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ
$LN14@GetCoolTim:
  0004e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1101 : }

  00051	c9		 leave
  00052	c2 0c 00	 ret	 12			; 0000000cH
?GetCoolTimeDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ENDP ; ioRoomOptionManager::GetCoolTimeDesc
_TEXT	ENDS
PUBLIC	?GetDropDamageDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ; ioRoomOptionManager::GetDropDamageDesc
; Function compile flags: /Ogsp
;	COMDAT ?GetDropDamageDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z
_TEXT	SEGMENT
$T531147 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_iIndex$ = 12						; size = 4
_bUiDesc$ = 16						; size = 1
?GetDropDamageDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z PROC ; ioRoomOptionManager::GetDropDamageDesc, COMDAT
; _this$ = ecx

; 1104 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1106 : 
; 1107 : 	if( COMPARE( iIndex, 0, iSize ) )

  00004	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00007	83 65 fc 00	 and	 DWORD PTR $T531147[ebp], 0
  0000b	85 c0		 test	 eax, eax
  0000d	78 36		 js	 SHORT $LN1@GetDropDam

; 1105 : 	int iSize = m_RoomDropDamageList.size();

  0000f	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  00015	2b 91 94 00 00
	00		 sub	 edx, DWORD PTR [ecx+148]
  0001b	c1 fa 02	 sar	 edx, 2

; 1106 : 
; 1107 : 	if( COMPARE( iIndex, 0, iSize ) )

  0001e	3b c2		 cmp	 eax, edx
  00020	7d 23		 jge	 SHORT $LN1@GetDropDam

; 1108 : 	{
; 1109 : 		if( bUiDesc )

  00022	80 7d 10 00	 cmp	 BYTE PTR _bUiDesc$[ebp], 0

; 1110 : 			return m_RoomDropDamageList[iIndex]->m_UIDesc;

  00026	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [ecx+148]
  0002c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00032	74 0c		 je	 SHORT $LN2@GetDropDam
  00034	83 c0 40	 add	 eax, 64			; 00000040H
$LN15@GetDropDam:
  00037	50		 push	 eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  0003e	eb 0e		 jmp	 SHORT $LN14@GetDropDam
$LN2@GetDropDam:

; 1111 : 		else
; 1112 : 			return m_RoomDropDamageList[iIndex]->m_Desc;

  00040	83 c0 30	 add	 eax, 48			; 00000030H
  00043	eb f2		 jmp	 SHORT $LN15@GetDropDam
$LN1@GetDropDam:

; 1113 : 	}
; 1114 : 
; 1115 : 	return ioHashString();

  00045	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ
$LN14@GetDropDam:
  0004e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1116 : }

  00051	c9		 leave
  00052	c2 0c 00	 ret	 12			; 0000000cH
?GetDropDamageDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ENDP ; ioRoomOptionManager::GetDropDamageDesc
_TEXT	ENDS
PUBLIC	?GetGravityDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ; ioRoomOptionManager::GetGravityDesc
; Function compile flags: /Ogsp
;	COMDAT ?GetGravityDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z
_TEXT	SEGMENT
$T531166 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_iIndex$ = 12						; size = 4
_bUiDesc$ = 16						; size = 1
?GetGravityDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z PROC ; ioRoomOptionManager::GetGravityDesc, COMDAT
; _this$ = ecx

; 1119 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1121 : 
; 1122 : 	if( COMPARE( iIndex, 0, iSize ) )

  00004	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00007	83 65 fc 00	 and	 DWORD PTR $T531166[ebp], 0
  0000b	85 c0		 test	 eax, eax
  0000d	78 36		 js	 SHORT $LN1@GetGravity

; 1120 : 	int iSize = m_RoomGravityList.size();

  0000f	8b 91 a8 00 00
	00		 mov	 edx, DWORD PTR [ecx+168]
  00015	2b 91 a4 00 00
	00		 sub	 edx, DWORD PTR [ecx+164]
  0001b	c1 fa 02	 sar	 edx, 2

; 1121 : 
; 1122 : 	if( COMPARE( iIndex, 0, iSize ) )

  0001e	3b c2		 cmp	 eax, edx
  00020	7d 23		 jge	 SHORT $LN1@GetGravity

; 1123 : 	{
; 1124 : 		if( bUiDesc )

  00022	80 7d 10 00	 cmp	 BYTE PTR _bUiDesc$[ebp], 0

; 1125 : 			return m_RoomGravityList[iIndex]->m_UIDesc;

  00026	8b 89 a4 00 00
	00		 mov	 ecx, DWORD PTR [ecx+164]
  0002c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00032	74 0c		 je	 SHORT $LN2@GetGravity
  00034	83 c0 40	 add	 eax, 64			; 00000040H
$LN15@GetGravity:
  00037	50		 push	 eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  0003e	eb 0e		 jmp	 SHORT $LN14@GetGravity
$LN2@GetGravity:

; 1126 : 		else
; 1127 : 			return m_RoomGravityList[iIndex]->m_Desc;

  00040	83 c0 30	 add	 eax, 48			; 00000030H
  00043	eb f2		 jmp	 SHORT $LN15@GetGravity
$LN1@GetGravity:

; 1128 : 	}
; 1129 : 
; 1130 : 	return ioHashString();

  00045	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ
$LN14@GetGravity:
  0004e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1131 : }

  00051	c9		 leave
  00052	c2 0c 00	 ret	 12			; 0000000cH
?GetGravityDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ENDP ; ioRoomOptionManager::GetGravityDesc
_TEXT	ENDS
PUBLIC	?GetTeamAttackDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ; ioRoomOptionManager::GetTeamAttackDesc
; Function compile flags: /Ogsp
;	COMDAT ?GetTeamAttackDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z
_TEXT	SEGMENT
$T531185 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_iIndex$ = 12						; size = 4
_bUiDesc$ = 16						; size = 1
?GetTeamAttackDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z PROC ; ioRoomOptionManager::GetTeamAttackDesc, COMDAT
; _this$ = ecx

; 1134 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1136 : 
; 1137 : 	if( COMPARE( iIndex, 0, iSize ) )

  00004	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00007	83 65 fc 00	 and	 DWORD PTR $T531185[ebp], 0
  0000b	85 c0		 test	 eax, eax
  0000d	78 36		 js	 SHORT $LN1@GetTeamAtt

; 1135 : 	int iSize = m_RoomTeamAttackList.size();

  0000f	8b 91 b8 00 00
	00		 mov	 edx, DWORD PTR [ecx+184]
  00015	2b 91 b4 00 00
	00		 sub	 edx, DWORD PTR [ecx+180]
  0001b	c1 fa 02	 sar	 edx, 2

; 1136 : 
; 1137 : 	if( COMPARE( iIndex, 0, iSize ) )

  0001e	3b c2		 cmp	 eax, edx
  00020	7d 23		 jge	 SHORT $LN1@GetTeamAtt

; 1138 : 	{
; 1139 : 		if( bUiDesc )

  00022	80 7d 10 00	 cmp	 BYTE PTR _bUiDesc$[ebp], 0

; 1140 : 			return m_RoomTeamAttackList[iIndex]->m_UIDesc;

  00026	8b 89 b4 00 00
	00		 mov	 ecx, DWORD PTR [ecx+180]
  0002c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00032	74 0c		 je	 SHORT $LN2@GetTeamAtt
  00034	83 c0 40	 add	 eax, 64			; 00000040H
$LN15@GetTeamAtt:
  00037	50		 push	 eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  0003e	eb 0e		 jmp	 SHORT $LN14@GetTeamAtt
$LN2@GetTeamAtt:

; 1141 : 		else
; 1142 : 			return m_RoomTeamAttackList[iIndex]->m_Desc;

  00040	83 c0 30	 add	 eax, 48			; 00000030H
  00043	eb f2		 jmp	 SHORT $LN15@GetTeamAtt
$LN1@GetTeamAtt:

; 1143 : 	}
; 1144 : 
; 1145 : 	return ioHashString();

  00045	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ
$LN14@GetTeamAtt:
  0004e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1146 : }

  00051	c9		 leave
  00052	c2 0c 00	 ret	 12			; 0000000cH
?GetTeamAttackDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ENDP ; ioRoomOptionManager::GetTeamAttackDesc
_TEXT	ENDS
PUBLIC	?GetGetUpDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ; ioRoomOptionManager::GetGetUpDesc
; Function compile flags: /Ogsp
;	COMDAT ?GetGetUpDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z
_TEXT	SEGMENT
$T531204 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_iIndex$ = 12						; size = 4
_bUiDesc$ = 16						; size = 1
?GetGetUpDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z PROC ; ioRoomOptionManager::GetGetUpDesc, COMDAT
; _this$ = ecx

; 1149 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1151 : 
; 1152 : 	if( COMPARE( iIndex, 0, iSize ) )

  00004	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00007	83 65 fc 00	 and	 DWORD PTR $T531204[ebp], 0
  0000b	85 c0		 test	 eax, eax
  0000d	78 36		 js	 SHORT $LN1@GetGetUpDe

; 1150 : 	int iSize = m_RoomGetUpList.size();

  0000f	8b 91 c8 00 00
	00		 mov	 edx, DWORD PTR [ecx+200]
  00015	2b 91 c4 00 00
	00		 sub	 edx, DWORD PTR [ecx+196]
  0001b	c1 fa 02	 sar	 edx, 2

; 1151 : 
; 1152 : 	if( COMPARE( iIndex, 0, iSize ) )

  0001e	3b c2		 cmp	 eax, edx
  00020	7d 23		 jge	 SHORT $LN1@GetGetUpDe

; 1153 : 	{
; 1154 : 		if( bUiDesc )

  00022	80 7d 10 00	 cmp	 BYTE PTR _bUiDesc$[ebp], 0

; 1155 : 			return m_RoomGetUpList[iIndex]->m_UIDesc;

  00026	8b 89 c4 00 00
	00		 mov	 ecx, DWORD PTR [ecx+196]
  0002c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00032	74 0c		 je	 SHORT $LN2@GetGetUpDe
  00034	83 c0 40	 add	 eax, 64			; 00000040H
$LN15@GetGetUpDe:
  00037	50		 push	 eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  0003e	eb 0e		 jmp	 SHORT $LN14@GetGetUpDe
$LN2@GetGetUpDe:

; 1156 : 		else
; 1157 : 			return m_RoomGetUpList[iIndex]->m_Desc;

  00040	83 c0 30	 add	 eax, 48			; 00000030H
  00043	eb f2		 jmp	 SHORT $LN15@GetGetUpDe
$LN1@GetGetUpDe:

; 1158 : 	}
; 1159 : 
; 1160 : 	return ioHashString();

  00045	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ
$LN14@GetGetUpDe:
  0004e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1161 : }

  00051	c9		 leave
  00052	c2 0c 00	 ret	 12			; 0000000cH
?GetGetUpDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ENDP ; ioRoomOptionManager::GetGetUpDesc
_TEXT	ENDS
PUBLIC	?GetRedMoveSpeedDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ; ioRoomOptionManager::GetRedMoveSpeedDesc
; Function compile flags: /Ogsp
;	COMDAT ?GetRedMoveSpeedDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z
_TEXT	SEGMENT
$T531223 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_iIndex$ = 12						; size = 4
_bUiDesc$ = 16						; size = 1
?GetRedMoveSpeedDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z PROC ; ioRoomOptionManager::GetRedMoveSpeedDesc, COMDAT
; _this$ = ecx

; 1164 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1166 : 
; 1167 : 	if( COMPARE( iIndex, 0, iSize ) )

  00004	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00007	83 65 fc 00	 and	 DWORD PTR $T531223[ebp], 0
  0000b	85 c0		 test	 eax, eax
  0000d	78 36		 js	 SHORT $LN1@GetRedMove

; 1165 : 	int iSize = m_RoomRedMoveSpeedList.size();

  0000f	8b 91 18 01 00
	00		 mov	 edx, DWORD PTR [ecx+280]
  00015	2b 91 14 01 00
	00		 sub	 edx, DWORD PTR [ecx+276]
  0001b	c1 fa 02	 sar	 edx, 2

; 1166 : 
; 1167 : 	if( COMPARE( iIndex, 0, iSize ) )

  0001e	3b c2		 cmp	 eax, edx
  00020	7d 23		 jge	 SHORT $LN1@GetRedMove

; 1168 : 	{
; 1169 : 		if( bUiDesc )

  00022	80 7d 10 00	 cmp	 BYTE PTR _bUiDesc$[ebp], 0

; 1170 : 			return m_RoomRedMoveSpeedList[iIndex]->m_UIDesc;

  00026	8b 89 14 01 00
	00		 mov	 ecx, DWORD PTR [ecx+276]
  0002c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00032	74 0c		 je	 SHORT $LN2@GetRedMove
  00034	83 c0 40	 add	 eax, 64			; 00000040H
$LN15@GetRedMove:
  00037	50		 push	 eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  0003e	eb 0e		 jmp	 SHORT $LN14@GetRedMove
$LN2@GetRedMove:

; 1171 : 		else
; 1172 : 			return m_RoomRedMoveSpeedList[iIndex]->m_Desc;

  00040	83 c0 30	 add	 eax, 48			; 00000030H
  00043	eb f2		 jmp	 SHORT $LN15@GetRedMove
$LN1@GetRedMove:

; 1173 : 	}
; 1174 : 
; 1175 : 	return ioHashString();

  00045	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ
$LN14@GetRedMove:
  0004e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1176 : }

  00051	c9		 leave
  00052	c2 0c 00	 ret	 12			; 0000000cH
?GetRedMoveSpeedDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ENDP ; ioRoomOptionManager::GetRedMoveSpeedDesc
_TEXT	ENDS
PUBLIC	?GetBlueMoveSpeedDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ; ioRoomOptionManager::GetBlueMoveSpeedDesc
; Function compile flags: /Ogsp
;	COMDAT ?GetBlueMoveSpeedDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z
_TEXT	SEGMENT
$T531242 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_iIndex$ = 12						; size = 4
_bUiDesc$ = 16						; size = 1
?GetBlueMoveSpeedDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z PROC ; ioRoomOptionManager::GetBlueMoveSpeedDesc, COMDAT
; _this$ = ecx

; 1179 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1181 : 
; 1182 : 	if( COMPARE( iIndex, 0, iSize ) )

  00004	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00007	83 65 fc 00	 and	 DWORD PTR $T531242[ebp], 0
  0000b	85 c0		 test	 eax, eax
  0000d	78 36		 js	 SHORT $LN1@GetBlueMov

; 1180 : 	int iSize = m_RoomBlueMoveSpeedList.size();

  0000f	8b 91 28 01 00
	00		 mov	 edx, DWORD PTR [ecx+296]
  00015	2b 91 24 01 00
	00		 sub	 edx, DWORD PTR [ecx+292]
  0001b	c1 fa 02	 sar	 edx, 2

; 1181 : 
; 1182 : 	if( COMPARE( iIndex, 0, iSize ) )

  0001e	3b c2		 cmp	 eax, edx
  00020	7d 23		 jge	 SHORT $LN1@GetBlueMov

; 1183 : 	{
; 1184 : 		if( bUiDesc )

  00022	80 7d 10 00	 cmp	 BYTE PTR _bUiDesc$[ebp], 0

; 1185 : 			return m_RoomBlueMoveSpeedList[iIndex]->m_UIDesc;

  00026	8b 89 24 01 00
	00		 mov	 ecx, DWORD PTR [ecx+292]
  0002c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00032	74 0c		 je	 SHORT $LN2@GetBlueMov
  00034	83 c0 40	 add	 eax, 64			; 00000040H
$LN15@GetBlueMov:
  00037	50		 push	 eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  0003e	eb 0e		 jmp	 SHORT $LN14@GetBlueMov
$LN2@GetBlueMov:

; 1186 : 		else
; 1187 : 			return m_RoomBlueMoveSpeedList[iIndex]->m_Desc;

  00040	83 c0 30	 add	 eax, 48			; 00000030H
  00043	eb f2		 jmp	 SHORT $LN15@GetBlueMov
$LN1@GetBlueMov:

; 1188 : 	}
; 1189 : 
; 1190 : 	return ioHashString();

  00045	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ
$LN14@GetBlueMov:
  0004e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1191 : }

  00051	c9		 leave
  00052	c2 0c 00	 ret	 12			; 0000000cH
?GetBlueMoveSpeedDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ENDP ; ioRoomOptionManager::GetBlueMoveSpeedDesc
_TEXT	ENDS
PUBLIC	?GetKODesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ; ioRoomOptionManager::GetKODesc
; Function compile flags: /Ogsp
;	COMDAT ?GetKODesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z
_TEXT	SEGMENT
$T531261 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_iIndex$ = 12						; size = 4
_bUiDesc$ = 16						; size = 1
?GetKODesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z PROC ; ioRoomOptionManager::GetKODesc, COMDAT
; _this$ = ecx

; 1194 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1196 : 
; 1197 : 	if( COMPARE( iIndex, 0, iSize ) )

  00004	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00007	83 65 fc 00	 and	 DWORD PTR $T531261[ebp], 0
  0000b	85 c0		 test	 eax, eax
  0000d	78 36		 js	 SHORT $LN1@GetKODesc

; 1195 : 	int iSize = m_RoomKOList.size();

  0000f	8b 91 d8 00 00
	00		 mov	 edx, DWORD PTR [ecx+216]
  00015	2b 91 d4 00 00
	00		 sub	 edx, DWORD PTR [ecx+212]
  0001b	c1 fa 02	 sar	 edx, 2

; 1196 : 
; 1197 : 	if( COMPARE( iIndex, 0, iSize ) )

  0001e	3b c2		 cmp	 eax, edx
  00020	7d 23		 jge	 SHORT $LN1@GetKODesc

; 1198 : 	{
; 1199 : 		if( bUiDesc )

  00022	80 7d 10 00	 cmp	 BYTE PTR _bUiDesc$[ebp], 0

; 1200 : 			return m_RoomKOList[iIndex]->m_UIDesc;

  00026	8b 89 d4 00 00
	00		 mov	 ecx, DWORD PTR [ecx+212]
  0002c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00032	74 0c		 je	 SHORT $LN2@GetKODesc
  00034	83 c0 40	 add	 eax, 64			; 00000040H
$LN15@GetKODesc:
  00037	50		 push	 eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  0003e	eb 0e		 jmp	 SHORT $LN14@GetKODesc
$LN2@GetKODesc:

; 1201 : 		else
; 1202 : 			return m_RoomKOList[iIndex]->m_Desc;

  00040	83 c0 30	 add	 eax, 48			; 00000030H
  00043	eb f2		 jmp	 SHORT $LN15@GetKODesc
$LN1@GetKODesc:

; 1203 : 	}
; 1204 : 
; 1205 : 	return ioHashString();

  00045	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ
$LN14@GetKODesc:
  0004e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1206 : }

  00051	c9		 leave
  00052	c2 0c 00	 ret	 12			; 0000000cH
?GetKODesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ENDP ; ioRoomOptionManager::GetKODesc
_TEXT	ENDS
PUBLIC	?GetKOEffectDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ; ioRoomOptionManager::GetKOEffectDesc
; Function compile flags: /Ogsp
;	COMDAT ?GetKOEffectDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z
_TEXT	SEGMENT
$T531280 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_iIndex$ = 12						; size = 4
_bUiDesc$ = 16						; size = 1
?GetKOEffectDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z PROC ; ioRoomOptionManager::GetKOEffectDesc, COMDAT
; _this$ = ecx

; 1209 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1211 : 
; 1212 : 	if( COMPARE( iIndex, 0, iSize ) )

  00004	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00007	83 65 fc 00	 and	 DWORD PTR $T531280[ebp], 0
  0000b	85 c0		 test	 eax, eax
  0000d	78 36		 js	 SHORT $LN1@GetKOEffec

; 1210 : 	int iSize = m_RoomKOEffectList.size();

  0000f	8b 91 e8 00 00
	00		 mov	 edx, DWORD PTR [ecx+232]
  00015	2b 91 e4 00 00
	00		 sub	 edx, DWORD PTR [ecx+228]
  0001b	c1 fa 02	 sar	 edx, 2

; 1211 : 
; 1212 : 	if( COMPARE( iIndex, 0, iSize ) )

  0001e	3b c2		 cmp	 eax, edx
  00020	7d 23		 jge	 SHORT $LN1@GetKOEffec

; 1213 : 	{
; 1214 : 		if( bUiDesc )

  00022	80 7d 10 00	 cmp	 BYTE PTR _bUiDesc$[ebp], 0

; 1215 : 			return m_RoomKOEffectList[iIndex]->m_UIDesc;

  00026	8b 89 e4 00 00
	00		 mov	 ecx, DWORD PTR [ecx+228]
  0002c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00032	74 0c		 je	 SHORT $LN2@GetKOEffec
  00034	83 c0 40	 add	 eax, 64			; 00000040H
$LN15@GetKOEffec:
  00037	50		 push	 eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  0003e	eb 0e		 jmp	 SHORT $LN14@GetKOEffec
$LN2@GetKOEffec:

; 1216 : 		else
; 1217 : 			return m_RoomKOEffectList[iIndex]->m_Desc;

  00040	83 c0 30	 add	 eax, 48			; 00000030H
  00043	eb f2		 jmp	 SHORT $LN15@GetKOEffec
$LN1@GetKOEffec:

; 1218 : 	}
; 1219 : 
; 1220 : 	return ioHashString();

  00045	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ
$LN14@GetKOEffec:
  0004e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1221 : }

  00051	c9		 leave
  00052	c2 0c 00	 ret	 12			; 0000000cH
?GetKOEffectDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ENDP ; ioRoomOptionManager::GetKOEffectDesc
_TEXT	ENDS
PUBLIC	?GetRedBlowDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ; ioRoomOptionManager::GetRedBlowDesc
; Function compile flags: /Ogsp
;	COMDAT ?GetRedBlowDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z
_TEXT	SEGMENT
$T531299 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_iIndex$ = 12						; size = 4
_bUiDesc$ = 16						; size = 1
?GetRedBlowDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z PROC ; ioRoomOptionManager::GetRedBlowDesc, COMDAT
; _this$ = ecx

; 1224 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1226 : 
; 1227 : 	if( COMPARE( iIndex, 0, iSize ) )

  00004	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00007	83 65 fc 00	 and	 DWORD PTR $T531299[ebp], 0
  0000b	85 c0		 test	 eax, eax
  0000d	78 36		 js	 SHORT $LN1@GetRedBlow

; 1225 : 	int iSize = m_RoomRedBlowList.size();

  0000f	8b 91 f8 00 00
	00		 mov	 edx, DWORD PTR [ecx+248]
  00015	2b 91 f4 00 00
	00		 sub	 edx, DWORD PTR [ecx+244]
  0001b	c1 fa 02	 sar	 edx, 2

; 1226 : 
; 1227 : 	if( COMPARE( iIndex, 0, iSize ) )

  0001e	3b c2		 cmp	 eax, edx
  00020	7d 23		 jge	 SHORT $LN1@GetRedBlow

; 1228 : 	{
; 1229 : 		if( bUiDesc )

  00022	80 7d 10 00	 cmp	 BYTE PTR _bUiDesc$[ebp], 0

; 1230 : 			return m_RoomRedBlowList[iIndex]->m_UIDesc;

  00026	8b 89 f4 00 00
	00		 mov	 ecx, DWORD PTR [ecx+244]
  0002c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00032	74 0c		 je	 SHORT $LN2@GetRedBlow
  00034	83 c0 40	 add	 eax, 64			; 00000040H
$LN15@GetRedBlow:
  00037	50		 push	 eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  0003e	eb 0e		 jmp	 SHORT $LN14@GetRedBlow
$LN2@GetRedBlow:

; 1231 : 		else
; 1232 : 			return m_RoomRedBlowList[iIndex]->m_Desc;

  00040	83 c0 30	 add	 eax, 48			; 00000030H
  00043	eb f2		 jmp	 SHORT $LN15@GetRedBlow
$LN1@GetRedBlow:

; 1233 : 	}
; 1234 : 
; 1235 : 	return ioHashString();

  00045	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ
$LN14@GetRedBlow:
  0004e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1236 : }

  00051	c9		 leave
  00052	c2 0c 00	 ret	 12			; 0000000cH
?GetRedBlowDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ENDP ; ioRoomOptionManager::GetRedBlowDesc
_TEXT	ENDS
PUBLIC	?GetBlueBlowDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ; ioRoomOptionManager::GetBlueBlowDesc
; Function compile flags: /Ogsp
;	COMDAT ?GetBlueBlowDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z
_TEXT	SEGMENT
$T531318 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_iIndex$ = 12						; size = 4
_bUiDesc$ = 16						; size = 1
?GetBlueBlowDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z PROC ; ioRoomOptionManager::GetBlueBlowDesc, COMDAT
; _this$ = ecx

; 1239 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1241 : 
; 1242 : 	if( COMPARE( iIndex, 0, iSize ) )

  00004	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00007	83 65 fc 00	 and	 DWORD PTR $T531318[ebp], 0
  0000b	85 c0		 test	 eax, eax
  0000d	78 36		 js	 SHORT $LN1@GetBlueBlo

; 1240 : 	int iSize = m_RoomBlueBlowList.size();

  0000f	8b 91 08 01 00
	00		 mov	 edx, DWORD PTR [ecx+264]
  00015	2b 91 04 01 00
	00		 sub	 edx, DWORD PTR [ecx+260]
  0001b	c1 fa 02	 sar	 edx, 2

; 1241 : 
; 1242 : 	if( COMPARE( iIndex, 0, iSize ) )

  0001e	3b c2		 cmp	 eax, edx
  00020	7d 23		 jge	 SHORT $LN1@GetBlueBlo

; 1243 : 	{
; 1244 : 		if( bUiDesc )

  00022	80 7d 10 00	 cmp	 BYTE PTR _bUiDesc$[ebp], 0

; 1245 : 			return m_RoomBlueBlowList[iIndex]->m_UIDesc;

  00026	8b 89 04 01 00
	00		 mov	 ecx, DWORD PTR [ecx+260]
  0002c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00032	74 0c		 je	 SHORT $LN2@GetBlueBlo
  00034	83 c0 40	 add	 eax, 64			; 00000040H
$LN15@GetBlueBlo:
  00037	50		 push	 eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  0003e	eb 0e		 jmp	 SHORT $LN14@GetBlueBlo
$LN2@GetBlueBlo:

; 1246 : 		else
; 1247 : 			return m_RoomBlueBlowList[iIndex]->m_Desc;

  00040	83 c0 30	 add	 eax, 48			; 00000030H
  00043	eb f2		 jmp	 SHORT $LN15@GetBlueBlo
$LN1@GetBlueBlo:

; 1248 : 	}
; 1249 : 
; 1250 : 	return ioHashString();

  00045	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ
$LN14@GetBlueBlo:
  0004e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1251 : }

  00051	c9		 leave
  00052	c2 0c 00	 ret	 12			; 0000000cH
?GetBlueBlowDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ENDP ; ioRoomOptionManager::GetBlueBlowDesc
_TEXT	ENDS
PUBLIC	?GetRedEquipDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ; ioRoomOptionManager::GetRedEquipDesc
; Function compile flags: /Ogsp
;	COMDAT ?GetRedEquipDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z
_TEXT	SEGMENT
$T531337 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_iIndex$ = 12						; size = 4
_bUiDesc$ = 16						; size = 1
?GetRedEquipDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z PROC ; ioRoomOptionManager::GetRedEquipDesc, COMDAT
; _this$ = ecx

; 1254 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1256 : 
; 1257 : 	if( COMPARE( iIndex, 0, iSize ) )

  00004	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00007	83 65 fc 00	 and	 DWORD PTR $T531337[ebp], 0
  0000b	85 c0		 test	 eax, eax
  0000d	78 36		 js	 SHORT $LN1@GetRedEqui

; 1255 : 	int iSize = m_RoomRedEquipList.size();

  0000f	8b 91 38 01 00
	00		 mov	 edx, DWORD PTR [ecx+312]
  00015	2b 91 34 01 00
	00		 sub	 edx, DWORD PTR [ecx+308]
  0001b	c1 fa 02	 sar	 edx, 2

; 1256 : 
; 1257 : 	if( COMPARE( iIndex, 0, iSize ) )

  0001e	3b c2		 cmp	 eax, edx
  00020	7d 23		 jge	 SHORT $LN1@GetRedEqui

; 1258 : 	{
; 1259 : 		if( bUiDesc )

  00022	80 7d 10 00	 cmp	 BYTE PTR _bUiDesc$[ebp], 0

; 1260 : 			return m_RoomRedEquipList[iIndex]->m_UIDesc;

  00026	8b 89 34 01 00
	00		 mov	 ecx, DWORD PTR [ecx+308]
  0002c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00032	74 0c		 je	 SHORT $LN2@GetRedEqui
  00034	83 c0 40	 add	 eax, 64			; 00000040H
$LN15@GetRedEqui:
  00037	50		 push	 eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  0003e	eb 0e		 jmp	 SHORT $LN14@GetRedEqui
$LN2@GetRedEqui:

; 1261 : 		else
; 1262 : 			return m_RoomRedEquipList[iIndex]->m_Desc;

  00040	83 c0 30	 add	 eax, 48			; 00000030H
  00043	eb f2		 jmp	 SHORT $LN15@GetRedEqui
$LN1@GetRedEqui:

; 1263 : 	}
; 1264 : 
; 1265 : 	return ioHashString();

  00045	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ
$LN14@GetRedEqui:
  0004e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1266 : }

  00051	c9		 leave
  00052	c2 0c 00	 ret	 12			; 0000000cH
?GetRedEquipDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ENDP ; ioRoomOptionManager::GetRedEquipDesc
_TEXT	ENDS
PUBLIC	?GetBlueEquipDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ; ioRoomOptionManager::GetBlueEquipDesc
; Function compile flags: /Ogsp
;	COMDAT ?GetBlueEquipDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z
_TEXT	SEGMENT
$T531356 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_iIndex$ = 12						; size = 4
_bUiDesc$ = 16						; size = 1
?GetBlueEquipDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z PROC ; ioRoomOptionManager::GetBlueEquipDesc, COMDAT
; _this$ = ecx

; 1269 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1271 : 
; 1272 : 	if( COMPARE( iIndex, 0, iSize ) )

  00004	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00007	83 65 fc 00	 and	 DWORD PTR $T531356[ebp], 0
  0000b	85 c0		 test	 eax, eax
  0000d	78 36		 js	 SHORT $LN1@GetBlueEqu

; 1270 : 	int iSize = m_RoomBlueEquipList.size();

  0000f	8b 91 48 01 00
	00		 mov	 edx, DWORD PTR [ecx+328]
  00015	2b 91 44 01 00
	00		 sub	 edx, DWORD PTR [ecx+324]
  0001b	c1 fa 02	 sar	 edx, 2

; 1271 : 
; 1272 : 	if( COMPARE( iIndex, 0, iSize ) )

  0001e	3b c2		 cmp	 eax, edx
  00020	7d 23		 jge	 SHORT $LN1@GetBlueEqu

; 1273 : 	{
; 1274 : 		if( bUiDesc )

  00022	80 7d 10 00	 cmp	 BYTE PTR _bUiDesc$[ebp], 0

; 1275 : 			return m_RoomBlueEquipList[iIndex]->m_UIDesc;

  00026	8b 89 44 01 00
	00		 mov	 ecx, DWORD PTR [ecx+324]
  0002c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00032	74 0c		 je	 SHORT $LN2@GetBlueEqu
  00034	83 c0 40	 add	 eax, 64			; 00000040H
$LN15@GetBlueEqu:
  00037	50		 push	 eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  0003e	eb 0e		 jmp	 SHORT $LN14@GetBlueEqu
$LN2@GetBlueEqu:

; 1276 : 		else
; 1277 : 			return m_RoomBlueEquipList[iIndex]->m_Desc;

  00040	83 c0 30	 add	 eax, 48			; 00000030H
  00043	eb f2		 jmp	 SHORT $LN15@GetBlueEqu
$LN1@GetBlueEqu:

; 1278 : 	}
; 1279 : 
; 1280 : 	return ioHashString();

  00045	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ
$LN14@GetBlueEqu:
  0004e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1281 : }

  00051	c9		 leave
  00052	c2 0c 00	 ret	 12			; 0000000cH
?GetBlueEquipDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ENDP ; ioRoomOptionManager::GetBlueEquipDesc
_TEXT	ENDS
PUBLIC	?GetRoundTypeDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ; ioRoomOptionManager::GetRoundTypeDesc
; Function compile flags: /Ogsp
;	COMDAT ?GetRoundTypeDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z
_TEXT	SEGMENT
$T531375 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_iIndex$ = 12						; size = 4
_bUiDesc$ = 16						; size = 1
?GetRoundTypeDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z PROC ; ioRoomOptionManager::GetRoundTypeDesc, COMDAT
; _this$ = ecx

; 1284 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1286 : 
; 1287 : 	if( COMPARE( iIndex, 0, iSize ) )

  00004	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00007	83 65 fc 00	 and	 DWORD PTR $T531375[ebp], 0
  0000b	85 c0		 test	 eax, eax
  0000d	78 36		 js	 SHORT $LN1@GetRoundTy

; 1285 : 	int iSize = m_RoomRoundTypeList.size();

  0000f	8b 91 58 01 00
	00		 mov	 edx, DWORD PTR [ecx+344]
  00015	2b 91 54 01 00
	00		 sub	 edx, DWORD PTR [ecx+340]
  0001b	c1 fa 02	 sar	 edx, 2

; 1286 : 
; 1287 : 	if( COMPARE( iIndex, 0, iSize ) )

  0001e	3b c2		 cmp	 eax, edx
  00020	7d 23		 jge	 SHORT $LN1@GetRoundTy

; 1288 : 	{
; 1289 : 		if( bUiDesc )

  00022	80 7d 10 00	 cmp	 BYTE PTR _bUiDesc$[ebp], 0

; 1290 : 			return m_RoomRoundTypeList[iIndex]->m_UIDesc;

  00026	8b 89 54 01 00
	00		 mov	 ecx, DWORD PTR [ecx+340]
  0002c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00032	74 0c		 je	 SHORT $LN2@GetRoundTy
  00034	83 c0 40	 add	 eax, 64			; 00000040H
$LN15@GetRoundTy:
  00037	50		 push	 eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  0003e	eb 0e		 jmp	 SHORT $LN14@GetRoundTy
$LN2@GetRoundTy:

; 1291 : 		else
; 1292 : 			return m_RoomRoundTypeList[iIndex]->m_Desc;

  00040	83 c0 30	 add	 eax, 48			; 00000030H
  00043	eb f2		 jmp	 SHORT $LN15@GetRoundTy
$LN1@GetRoundTy:

; 1293 : 	}
; 1294 : 
; 1295 : 	return ioHashString();

  00045	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ
$LN14@GetRoundTy:
  0004e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1296 : }

  00051	c9		 leave
  00052	c2 0c 00	 ret	 12			; 0000000cH
?GetRoundTypeDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ENDP ; ioRoomOptionManager::GetRoundTypeDesc
_TEXT	ENDS
PUBLIC	?GetRoundTimeTypeDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ; ioRoomOptionManager::GetRoundTimeTypeDesc
; Function compile flags: /Ogsp
;	COMDAT ?GetRoundTimeTypeDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z
_TEXT	SEGMENT
$T531394 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_iIndex$ = 12						; size = 4
_bUiDesc$ = 16						; size = 1
?GetRoundTimeTypeDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z PROC ; ioRoomOptionManager::GetRoundTimeTypeDesc, COMDAT
; _this$ = ecx

; 1299 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1301 : 
; 1302 : 	if( COMPARE( iIndex, 0, iSize ) )

  00004	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00007	83 65 fc 00	 and	 DWORD PTR $T531394[ebp], 0
  0000b	85 c0		 test	 eax, eax
  0000d	78 36		 js	 SHORT $LN1@GetRoundTi

; 1300 : 	int iSize = m_RoomRoundTimeTypeList.size();

  0000f	8b 91 68 01 00
	00		 mov	 edx, DWORD PTR [ecx+360]
  00015	2b 91 64 01 00
	00		 sub	 edx, DWORD PTR [ecx+356]
  0001b	c1 fa 02	 sar	 edx, 2

; 1301 : 
; 1302 : 	if( COMPARE( iIndex, 0, iSize ) )

  0001e	3b c2		 cmp	 eax, edx
  00020	7d 23		 jge	 SHORT $LN1@GetRoundTi

; 1303 : 	{
; 1304 : 		if( bUiDesc )

  00022	80 7d 10 00	 cmp	 BYTE PTR _bUiDesc$[ebp], 0

; 1305 : 			return m_RoomRoundTimeTypeList[iIndex]->m_UIDesc;

  00026	8b 89 64 01 00
	00		 mov	 ecx, DWORD PTR [ecx+356]
  0002c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00032	74 0c		 je	 SHORT $LN2@GetRoundTi
  00034	83 c0 40	 add	 eax, 64			; 00000040H
$LN15@GetRoundTi:
  00037	50		 push	 eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  0003e	eb 0e		 jmp	 SHORT $LN14@GetRoundTi
$LN2@GetRoundTi:

; 1306 : 		else
; 1307 : 			return m_RoomRoundTimeTypeList[iIndex]->m_Desc;

  00040	83 c0 30	 add	 eax, 48			; 00000030H
  00043	eb f2		 jmp	 SHORT $LN15@GetRoundTi
$LN1@GetRoundTi:

; 1308 : 	}
; 1309 : 
; 1310 : 	return ioHashString();

  00045	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ
$LN14@GetRoundTi:
  0004e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1311 : }

  00051	c9		 leave
  00052	c2 0c 00	 ret	 12			; 0000000cH
?GetRoundTimeTypeDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ENDP ; ioRoomOptionManager::GetRoundTimeTypeDesc
_TEXT	ENDS
PUBLIC	?GetGrowthUseDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ; ioRoomOptionManager::GetGrowthUseDesc
; Function compile flags: /Ogsp
;	COMDAT ?GetGrowthUseDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z
_TEXT	SEGMENT
$T531413 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_iIndex$ = 12						; size = 4
_bUiDesc$ = 16						; size = 1
?GetGrowthUseDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z PROC ; ioRoomOptionManager::GetGrowthUseDesc, COMDAT
; _this$ = ecx

; 1314 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1316 : 
; 1317 : 	if( COMPARE( iIndex, 0, iSize ) )

  00004	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00007	83 65 fc 00	 and	 DWORD PTR $T531413[ebp], 0
  0000b	85 c0		 test	 eax, eax
  0000d	78 36		 js	 SHORT $LN1@GetGrowthU

; 1315 : 	int iSize = m_RoomGrowthUseList.size();

  0000f	8b 91 78 01 00
	00		 mov	 edx, DWORD PTR [ecx+376]
  00015	2b 91 74 01 00
	00		 sub	 edx, DWORD PTR [ecx+372]
  0001b	c1 fa 02	 sar	 edx, 2

; 1316 : 
; 1317 : 	if( COMPARE( iIndex, 0, iSize ) )

  0001e	3b c2		 cmp	 eax, edx
  00020	7d 23		 jge	 SHORT $LN1@GetGrowthU

; 1318 : 	{
; 1319 : 		if( bUiDesc )

  00022	80 7d 10 00	 cmp	 BYTE PTR _bUiDesc$[ebp], 0

; 1320 : 			return m_RoomGrowthUseList[iIndex]->m_UIDesc;

  00026	8b 89 74 01 00
	00		 mov	 ecx, DWORD PTR [ecx+372]
  0002c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00032	74 0c		 je	 SHORT $LN2@GetGrowthU
  00034	83 c0 40	 add	 eax, 64			; 00000040H
$LN15@GetGrowthU:
  00037	50		 push	 eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  0003e	eb 0e		 jmp	 SHORT $LN14@GetGrowthU
$LN2@GetGrowthU:

; 1321 : 		else
; 1322 : 			return m_RoomGrowthUseList[iIndex]->m_Desc;

  00040	83 c0 30	 add	 eax, 48			; 00000030H
  00043	eb f2		 jmp	 SHORT $LN15@GetGrowthU
$LN1@GetGrowthU:

; 1323 : 	}
; 1324 : 
; 1325 : 	return ioHashString();

  00045	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ
$LN14@GetGrowthU:
  0004e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1326 : }

  00051	c9		 leave
  00052	c2 0c 00	 ret	 12			; 0000000cH
?GetGrowthUseDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ENDP ; ioRoomOptionManager::GetGrowthUseDesc
_TEXT	ENDS
PUBLIC	?GetExtraItemUseDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ; ioRoomOptionManager::GetExtraItemUseDesc
; Function compile flags: /Ogsp
;	COMDAT ?GetExtraItemUseDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z
_TEXT	SEGMENT
$T531432 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_iIndex$ = 12						; size = 4
_bUiDesc$ = 16						; size = 1
?GetExtraItemUseDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z PROC ; ioRoomOptionManager::GetExtraItemUseDesc, COMDAT
; _this$ = ecx

; 1329 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1331 : 
; 1332 : 	if( COMPARE( iIndex, 0, iSize ) )

  00004	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00007	83 65 fc 00	 and	 DWORD PTR $T531432[ebp], 0
  0000b	85 c0		 test	 eax, eax
  0000d	78 36		 js	 SHORT $LN1@GetExtraIt

; 1330 : 	int iSize = m_RoomExtraItemUseList.size();

  0000f	8b 91 88 01 00
	00		 mov	 edx, DWORD PTR [ecx+392]
  00015	2b 91 84 01 00
	00		 sub	 edx, DWORD PTR [ecx+388]
  0001b	c1 fa 02	 sar	 edx, 2

; 1331 : 
; 1332 : 	if( COMPARE( iIndex, 0, iSize ) )

  0001e	3b c2		 cmp	 eax, edx
  00020	7d 23		 jge	 SHORT $LN1@GetExtraIt

; 1333 : 	{
; 1334 : 		if( bUiDesc )

  00022	80 7d 10 00	 cmp	 BYTE PTR _bUiDesc$[ebp], 0

; 1335 : 			return m_RoomExtraItemUseList[iIndex]->m_UIDesc;

  00026	8b 89 84 01 00
	00		 mov	 ecx, DWORD PTR [ecx+388]
  0002c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00032	74 0c		 je	 SHORT $LN2@GetExtraIt
  00034	83 c0 40	 add	 eax, 64			; 00000040H
$LN15@GetExtraIt:
  00037	50		 push	 eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  0003e	eb 0e		 jmp	 SHORT $LN14@GetExtraIt
$LN2@GetExtraIt:

; 1336 : 		else
; 1337 : 			return m_RoomExtraItemUseList[iIndex]->m_Desc;

  00040	83 c0 30	 add	 eax, 48			; 00000030H
  00043	eb f2		 jmp	 SHORT $LN15@GetExtraIt
$LN1@GetExtraIt:

; 1338 : 	}
; 1339 : 
; 1340 : 	return ioHashString();

  00045	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ
$LN14@GetExtraIt:
  0004e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1341 : }

  00051	c9		 leave
  00052	c2 0c 00	 ret	 12			; 0000000cH
?GetExtraItemUseDesc@ioRoomOptionManager@@QAE?AVioHashString@@H_N@Z ENDP ; ioRoomOptionManager::GetExtraItemUseDesc
_TEXT	ENDS
PUBLIC	?GetOptionTypeCnt@ioRoomOptionManager@@QAEHH@Z	; ioRoomOptionManager::GetOptionTypeCnt
; Function compile flags: /Ogsp
;	COMDAT ?GetOptionTypeCnt@ioRoomOptionManager@@QAEHH@Z
_TEXT	SEGMENT
_iOptionType$ = 8					; size = 4
?GetOptionTypeCnt@ioRoomOptionManager@@QAEHH@Z PROC	; ioRoomOptionManager::GetOptionTypeCnt, COMDAT
; _this$ = ecx

; 1344 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1345 : 	switch( iOptionType )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iOptionType$[ebp]
  00006	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  00009	0f 8f ef 00 00
	00		 jg	 $LN26@GetOptionT
  0000f	0f 84 d8 00 00
	00		 je	 $LN3@GetOptionT
  00015	83 f8 14	 cmp	 eax, 20			; 00000014H
  00018	7f 7a		 jg	 SHORT $LN27@GetOptionT
  0001a	74 67		 je	 SHORT $LN14@GetOptionT
  0001c	48		 dec	 eax
  0001d	74 53		 je	 SHORT $LN21@GetOptionT
  0001f	83 e8 0b	 sub	 eax, 11			; 0000000bH
  00022	74 43		 je	 SHORT $LN19@GetOptionT
  00024	48		 dec	 eax
  00025	48		 dec	 eax
  00026	74 2e		 je	 SHORT $LN18@GetOptionT
  00028	48		 dec	 eax
  00029	48		 dec	 eax
  0002a	74 19		 je	 SHORT $LN15@GetOptionT
  0002c	48		 dec	 eax
  0002d	48		 dec	 eax
  0002e	0f 85 40 01 00
	00		 jne	 $LN22@GetOptionT

; 1349 : 	case PartyOptionWnd::ID_TEAM_ATTACK_TYPE:
; 1350 : 		return m_RoomTeamAttackList.size();

  00034	8b 81 b8 00 00
	00		 mov	 eax, DWORD PTR [ecx+184]
  0003a	2b 81 b4 00 00
	00		 sub	 eax, DWORD PTR [ecx+180]
  00040	e9 69 01 00 00	 jmp	 $LN71@GetOptionT
$LN15@GetOptionT:

; 1359 : 	case PartyOptionWnd::ID_DROP_DAMAGE_TYPE:
; 1360 : 		return m_RoomDropDamageList.size();

  00045	8b 81 98 00 00
	00		 mov	 eax, DWORD PTR [ecx+152]
  0004b	2b 81 94 00 00
	00		 sub	 eax, DWORD PTR [ecx+148]
  00051	e9 58 01 00 00	 jmp	 $LN71@GetOptionT
$LN18@GetOptionT:

; 1353 : 	case PartyOptionWnd::ID_COOLTIME_TYPE:
; 1354 : 		return m_RoomCoolTimeList.size();

  00056	8b 81 88 00 00
	00		 mov	 eax, DWORD PTR [ecx+136]
  0005c	2b 81 84 00 00
	00		 sub	 eax, DWORD PTR [ecx+132]
  00062	e9 47 01 00 00	 jmp	 $LN71@GetOptionT
$LN19@GetOptionT:

; 1351 : 	case PartyOptionWnd::ID_CHANGE_CHAR_TYPE:
; 1352 : 		return m_RoomChangeCharList.size();

  00067	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  0006a	2b 41 34	 sub	 eax, DWORD PTR [ecx+52]
  0006d	e9 3c 01 00 00	 jmp	 $LN71@GetOptionT
$LN21@GetOptionT:

; 1346 : 	{
; 1347 : 	case PartyOptionWnd::ID_PRESET_BTN:
; 1348 : 		return m_PreSetList.size();

  00072	8b 81 98 01 00
	00		 mov	 eax, DWORD PTR [ecx+408]
  00078	2b 81 94 01 00
	00		 sub	 eax, DWORD PTR [ecx+404]
  0007e	e9 2b 01 00 00	 jmp	 $LN71@GetOptionT
$LN14@GetOptionT:

; 1361 : 	case PartyOptionWnd::ID_GRAVITY_TYPE:
; 1362 : 		return m_RoomGravityList.size();

  00083	8b 81 a8 00 00
	00		 mov	 eax, DWORD PTR [ecx+168]
  00089	2b 81 a4 00 00
	00		 sub	 eax, DWORD PTR [ecx+164]
  0008f	e9 1a 01 00 00	 jmp	 $LN71@GetOptionT
$LN27@GetOptionT:

; 1345 : 	switch( iOptionType )

  00094	83 e8 16	 sub	 eax, 22			; 00000016H
  00097	74 43		 je	 SHORT $LN13@GetOptionT
  00099	48		 dec	 eax
  0009a	48		 dec	 eax
  0009b	74 2e		 je	 SHORT $LN12@GetOptionT
  0009d	48		 dec	 eax
  0009e	48		 dec	 eax
  0009f	74 19		 je	 SHORT $LN11@GetOptionT
  000a1	48		 dec	 eax
  000a2	48		 dec	 eax
  000a3	0f 85 cb 00 00
	00		 jne	 $LN22@GetOptionT

; 1381 : 	case PartyOptionWnd::ID_ROUND_TYPE:
; 1382 : 		return m_RoomRoundTypeList.size();

  000a9	8b 81 58 01 00
	00		 mov	 eax, DWORD PTR [ecx+344]
  000af	2b 81 54 01 00
	00		 sub	 eax, DWORD PTR [ecx+340]
  000b5	e9 f4 00 00 00	 jmp	 $LN71@GetOptionT
$LN11@GetOptionT:

; 1367 : 	case PartyOptionWnd::ID_KO_EFFECT_TYPE:
; 1368 : 		return m_RoomKOEffectList.size();

  000ba	8b 81 e8 00 00
	00		 mov	 eax, DWORD PTR [ecx+232]
  000c0	2b 81 e4 00 00
	00		 sub	 eax, DWORD PTR [ecx+228]
  000c6	e9 e3 00 00 00	 jmp	 $LN71@GetOptionT
$LN12@GetOptionT:

; 1365 : 	case PartyOptionWnd::ID_KO_TYPE:
; 1366 : 		return m_RoomKOList.size();

  000cb	8b 81 d8 00 00
	00		 mov	 eax, DWORD PTR [ecx+216]
  000d1	2b 81 d4 00 00
	00		 sub	 eax, DWORD PTR [ecx+212]
  000d7	e9 d2 00 00 00	 jmp	 $LN71@GetOptionT
$LN13@GetOptionT:

; 1363 : 	case PartyOptionWnd::ID_GETUP_TYPE:
; 1364 : 		return m_RoomGetUpList.size();

  000dc	8b 81 c8 00 00
	00		 mov	 eax, DWORD PTR [ecx+200]
  000e2	2b 81 c4 00 00
	00		 sub	 eax, DWORD PTR [ecx+196]
  000e8	e9 c1 00 00 00	 jmp	 $LN71@GetOptionT
$LN3@GetOptionT:

; 1383 : 	case PartyOptionWnd::ID_ROUND_TIME_TYPE:
; 1384 : 		return m_RoomRoundTimeTypeList.size();

  000ed	8b 81 68 01 00
	00		 mov	 eax, DWORD PTR [ecx+360]
  000f3	2b 81 64 01 00
	00		 sub	 eax, DWORD PTR [ecx+356]
  000f9	e9 b0 00 00 00	 jmp	 $LN71@GetOptionT
$LN26@GetOptionT:

; 1345 : 	switch( iOptionType )

  000fe	83 f8 6a	 cmp	 eax, 106		; 0000006aH
  00101	7f 62		 jg	 SHORT $LN28@GetOptionT
  00103	74 52		 je	 SHORT $LN10@GetOptionT
  00105	83 e8 20	 sub	 eax, 32			; 00000020H
  00108	74 3f		 je	 SHORT $LN2@GetOptionT
  0010a	48		 dec	 eax
  0010b	48		 dec	 eax
  0010c	74 2d		 je	 SHORT $LN1@GetOptionT
  0010e	83 e8 44	 sub	 eax, 68			; 00000044H
  00111	74 20		 je	 SHORT $LN16@GetOptionT
  00113	48		 dec	 eax
  00114	74 15		 je	 SHORT $LN17@GetOptionT
  00116	48		 dec	 eax
  00117	48		 dec	 eax
  00118	75 5a		 jne	 SHORT $LN22@GetOptionT

; 1371 : 	case PartyOptionWnd::ID_BLUE_BLOW_TYPE:
; 1372 : 		return m_RoomBlueBlowList.size();

  0011a	8b 81 08 01 00
	00		 mov	 eax, DWORD PTR [ecx+264]
  00120	2b 81 04 01 00
	00		 sub	 eax, DWORD PTR [ecx+260]
  00126	e9 83 00 00 00	 jmp	 $LN71@GetOptionT
$LN17@GetOptionT:

; 1355 : 	case PartyOptionWnd::ID_RED_HP_TYPE:
; 1356 : 		return m_RoomRedHPList.size();

  0012b	8b 41 48	 mov	 eax, DWORD PTR [ecx+72]
  0012e	2b 41 44	 sub	 eax, DWORD PTR [ecx+68]
  00131	eb 7b		 jmp	 SHORT $LN71@GetOptionT
$LN16@GetOptionT:

; 1357 : 	case PartyOptionWnd::ID_BLUE_HP_TYPE:
; 1358 : 		return m_RoomBlueHPList.size();

  00133	8b 41 58	 mov	 eax, DWORD PTR [ecx+88]
  00136	2b 41 54	 sub	 eax, DWORD PTR [ecx+84]
  00139	eb 73		 jmp	 SHORT $LN71@GetOptionT
$LN1@GetOptionT:

; 1387 : 	case PartyOptionWnd::ID_EXTRAITEM_USE_TYPE:
; 1388 : 		return m_RoomExtraItemUseList.size();

  0013b	8b 81 88 01 00
	00		 mov	 eax, DWORD PTR [ecx+392]
  00141	2b 81 84 01 00
	00		 sub	 eax, DWORD PTR [ecx+388]
  00147	eb 65		 jmp	 SHORT $LN71@GetOptionT
$LN2@GetOptionT:

; 1385 : 	case PartyOptionWnd::ID_GROWTH_USE_TYPE:
; 1386 : 		return m_RoomGrowthUseList.size();

  00149	8b 81 78 01 00
	00		 mov	 eax, DWORD PTR [ecx+376]
  0014f	2b 81 74 01 00
	00		 sub	 eax, DWORD PTR [ecx+372]
  00155	eb 57		 jmp	 SHORT $LN71@GetOptionT
$LN10@GetOptionT:

; 1369 : 	case PartyOptionWnd::ID_RED_BLOW_TYPE:
; 1370 : 		return m_RoomRedBlowList.size();

  00157	8b 81 f8 00 00
	00		 mov	 eax, DWORD PTR [ecx+248]
  0015d	2b 81 f4 00 00
	00		 sub	 eax, DWORD PTR [ecx+244]
  00163	eb 49		 jmp	 SHORT $LN71@GetOptionT
$LN28@GetOptionT:

; 1345 : 	switch( iOptionType )

  00165	83 e8 6c	 sub	 eax, 108		; 0000006cH
  00168	74 38		 je	 SHORT $LN7@GetOptionT
  0016a	48		 dec	 eax
  0016b	74 27		 je	 SHORT $LN8@GetOptionT
  0016d	48		 dec	 eax
  0016e	48		 dec	 eax
  0016f	74 15		 je	 SHORT $LN5@GetOptionT
  00171	48		 dec	 eax
  00172	74 04		 je	 SHORT $LN6@GetOptionT
$LN22@GetOptionT:

; 1389 : 	}
; 1390 : 
; 1391 : 	return 0;

  00174	33 c0		 xor	 eax, eax
  00176	eb 39		 jmp	 SHORT $LN24@GetOptionT
$LN6@GetOptionT:

; 1377 : 	case PartyOptionWnd::ID_RED_EQUIP_TYPE:
; 1378 : 		return m_RoomRedEquipList.size();

  00178	8b 81 38 01 00
	00		 mov	 eax, DWORD PTR [ecx+312]
  0017e	2b 81 34 01 00
	00		 sub	 eax, DWORD PTR [ecx+308]
  00184	eb 28		 jmp	 SHORT $LN71@GetOptionT
$LN5@GetOptionT:

; 1379 : 	case PartyOptionWnd::ID_BLUE_EQUIP_TYPE:
; 1380 : 		return m_RoomBlueEquipList.size();

  00186	8b 81 48 01 00
	00		 mov	 eax, DWORD PTR [ecx+328]
  0018c	2b 81 44 01 00
	00		 sub	 eax, DWORD PTR [ecx+324]
  00192	eb 1a		 jmp	 SHORT $LN71@GetOptionT
$LN8@GetOptionT:

; 1373 : 	case PartyOptionWnd::ID_RED_MOVE_SPEED_TYPE:
; 1374 : 		return m_RoomRedMoveSpeedList.size();

  00194	8b 81 18 01 00
	00		 mov	 eax, DWORD PTR [ecx+280]
  0019a	2b 81 14 01 00
	00		 sub	 eax, DWORD PTR [ecx+276]
  001a0	eb 0c		 jmp	 SHORT $LN71@GetOptionT
$LN7@GetOptionT:

; 1375 : 	case PartyOptionWnd::ID_BLUE_MOVE_SPEED_TYPE:
; 1376 : 		return m_RoomBlueMoveSpeedList.size();

  001a2	8b 81 28 01 00
	00		 mov	 eax, DWORD PTR [ecx+296]
  001a8	2b 81 24 01 00
	00		 sub	 eax, DWORD PTR [ecx+292]
$LN71@GetOptionT:
  001ae	c1 f8 02	 sar	 eax, 2
$LN24@GetOptionT:

; 1392 : }

  001b1	5d		 pop	 ebp
  001b2	c2 04 00	 ret	 4
?GetOptionTypeCnt@ioRoomOptionManager@@QAEHH@Z ENDP	; ioRoomOptionManager::GetOptionTypeCnt
_TEXT	ENDS
PUBLIC	?GetSingleton@ioRoomOptionManager@@SAAAV1@XZ	; ioRoomOptionManager::GetSingleton
; Function compile flags: /Ogsp
;	COMDAT ?GetSingleton@ioRoomOptionManager@@SAAAV1@XZ
_TEXT	SEGMENT
?GetSingleton@ioRoomOptionManager@@SAAAV1@XZ PROC	; ioRoomOptionManager::GetSingleton, COMDAT

; 1469 : 	return Singleton< ioRoomOptionManager >::GetSingleton();

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_Singleton@?$Singleton@VioRoomOptionManager@@@@1PAVioRoomOptionManager@@A ; Singleton<ioRoomOptionManager>::ms_Singleton

; 1470 : }

  00005	c3		 ret	 0
?GetSingleton@ioRoomOptionManager@@SAAAV1@XZ ENDP	; ioRoomOptionManager::GetSingleton
_TEXT	ENDS
PUBLIC	??G?$CEncrypt@H@@QAEHABH@Z			; CEncrypt<int>::operator-
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
;	COMDAT ??G?$CEncrypt@H@@QAEHABH@Z
_TEXT	SEGMENT
_value$ = -4						; size = 4
_inValue$ = 8						; size = 4
??G?$CEncrypt@H@@QAEHABH@Z PROC				; CEncrypt<int>::operator-, COMDAT
; _this$ = ecx

; 854  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 855  : 		type value;
; 856  : 		DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ; CEncrypt<int>::DecryptValueToPool

; 857  : #ifdef _NOTUSE
; 858  : 		Debug();
; 859  : #endif
; 860  : 		return value - inValue;

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _value$[ebp]
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _inValue$[ebp]
  00013	2b 01		 sub	 eax, DWORD PTR [ecx]

; 861  : 	}

  00015	c9		 leave
  00016	c2 04 00	 ret	 4
??G?$CEncrypt@H@@QAEHABH@Z ENDP				; CEncrypt<int>::operator-
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QBEAAPAURoomOptionInfo@@XZ ; std::_Vector_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >::operator*
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QBEAAPAURoomOptionInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QBEAAPAURoomOptionInfo@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >::operator*, COMDAT
; _this$ = ecx

; 322  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 323  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QBEAAPAURoomOptionInfo@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >::operator++
; Function compile flags: /Ogsp
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >::operator++, COMDAT
; _this$ = ecx

; 331  : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 332  : 		++*(_Mybase *)this;

  00002	83 00 04	 add	 DWORD PTR [eax], 4

; 333  : 		return (*this);
; 334  : 		}

  00005	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >::operator++
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QBEAAPAUPreSetInfo@@XZ ; std::_Vector_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >::operator*
; Function compile flags: /Ogsp
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QBEAAPAUPreSetInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QBEAAPAUPreSetInfo@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >::operator*, COMDAT
; _this$ = ecx

; 322  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 323  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QBEAAPAUPreSetInfo@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >::operator++
; Function compile flags: /Ogsp
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >::operator++, COMDAT
; _this$ = ecx

; 331  : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 332  : 		++*(_Mybase *)this;

  00002	83 00 04	 add	 DWORD PTR [eax], 4

; 333  : 		return (*this);
; 334  : 		}

  00005	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >::operator++
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@V?$allocator@PAURoomOptionInfo@@@1@@Z ; std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@V?$allocator@PAURoomOptionInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@V?$allocator@PAURoomOptionInfo@@@1@@Z PROC ; std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@V?$allocator@PAURoomOptionInfo@@@1@@Z ENDP ; std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE@V?$allocator@PAUPreSetInfo@@@1@@Z ; std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> >::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE@V?$allocator@PAUPreSetInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE@V?$allocator@PAUPreSetInfo@@@1@@Z PROC ; std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> >::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE@V?$allocator@PAUPreSetInfo@@@1@@Z ENDP ; std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> >::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QAE@PAPAURoomOptionInfo@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >::_Vector_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QAE@PAPAURoomOptionInfo@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QAE@PAPAURoomOptionInfo@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >::_Vector_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 305  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QAE@PAPAURoomOptionInfo@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >::_Vector_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >::operator==
; Function compile flags: /Ogsp
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	f7 d8		 neg	 eax
  0000c	1b c0		 sbb	 eax, eax
  0000e	40		 inc	 eax

; 204  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QAE@PAPAUPreSetInfo@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >::_Vector_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QAE@PAPAUPreSetInfo@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QAE@PAPAUPreSetInfo@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >::_Vector_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 305  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QAE@PAPAUPreSetInfo@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >::_Vector_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >::operator==
; Function compile flags: /Ogsp
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	f7 d8		 neg	 eax
  0000c	1b c0		 sbb	 eax, eax
  0000e	40		 inc	 eax

; 204  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >::operator==
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Make_iter
; Function compile flags: /Ogsp
;	COMDAT ?_Make_iter@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@@Z PROC ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 		return (iterator(_Where._Ptr, this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 803  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?_Make_iter@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@@Z ENDP ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QBEIXZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::max_size
; Function compile flags: /Ogsp
;	COMDAT ?max_size@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?_Grow_to@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IBEII@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Grow_to
; Function compile flags: /Ogsp
;	COMDAT ?_Grow_to@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IBEII@Z PROC ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1275 : 		size_type _Capacity = capacity();

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00008	ba ff ff ff 3f	 mov	 edx, 1073741823		; 3fffffffH
  0000d	c1 f8 02	 sar	 eax, 2
  00010	8b c8		 mov	 ecx, eax
  00012	d1 e9		 shr	 ecx, 1
  00014	2b d1		 sub	 edx, ecx
  00016	3b d0		 cmp	 edx, eax
  00018	73 04		 jae	 SHORT $LN4@Grow_to
  0001a	33 c0		 xor	 eax, eax
  0001c	eb 02		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  0001e	03 c1		 add	 eax, ecx
$LN5@Grow_to:

; 1279 : 		if (_Capacity < _Count)

  00020	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]

; 1280 : 			_Capacity = _Count;

  00023	0f 42 45 08	 cmovb	 eax, DWORD PTR __Count$[ebp]

; 1281 : 		return (_Capacity);
; 1282 : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?_Grow_to@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IBEII@Z ENDP ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Grow_to
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@2@@Z ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Make_iter
; Function compile flags: /Ogsp
;	COMDAT ?_Make_iter@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@2@@Z PROC ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 		return (iterator(_Where._Ptr, this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 803  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?_Make_iter@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@2@@Z ENDP ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QBEIXZ ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::max_size
; Function compile flags: /Ogsp
;	COMDAT ?max_size@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?_Grow_to@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IBEII@Z ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Grow_to
; Function compile flags: /Ogsp
;	COMDAT ?_Grow_to@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IBEII@Z PROC ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1275 : 		size_type _Capacity = capacity();

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00008	ba ff ff ff 3f	 mov	 edx, 1073741823		; 3fffffffH
  0000d	c1 f8 02	 sar	 eax, 2
  00010	8b c8		 mov	 ecx, eax
  00012	d1 e9		 shr	 ecx, 1
  00014	2b d1		 sub	 edx, ecx
  00016	3b d0		 cmp	 edx, eax
  00018	73 04		 jae	 SHORT $LN4@Grow_to@2
  0001a	33 c0		 xor	 eax, eax
  0001c	eb 02		 jmp	 SHORT $LN5@Grow_to@2
$LN4@Grow_to@2:
  0001e	03 c1		 add	 eax, ecx
$LN5@Grow_to@2:

; 1279 : 		if (_Capacity < _Count)

  00020	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]

; 1280 : 			_Capacity = _Count;

  00023	0f 42 45 08	 cmovb	 eax, DWORD PTR __Count$[ebp]

; 1281 : 		return (_Capacity);
; 1282 : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?_Grow_to@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IBEII@Z ENDP ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Grow_to
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAURoomOptionInfo@@@std@@QAEPAPAURoomOptionInfo@@I@Z ; std::allocator<RoomOptionInfo *>::allocate
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAURoomOptionInfo@@@std@@QAEPAPAURoomOptionInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAURoomOptionInfo@@@std@@QAEPAPAURoomOptionInfo@@I@Z PROC ; std::allocator<RoomOptionInfo *>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	6a 00		 push	 0
  00005	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Allocate@PAURoomOptionInfo@@@std@@YAPAPAURoomOptionInfo@@IPAPAU1@@Z ; std::_Allocate<RoomOptionInfo *>
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx

; 188  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?allocate@?$allocator@PAURoomOptionInfo@@@std@@QAEPAPAURoomOptionInfo@@I@Z ENDP ; std::allocator<RoomOptionInfo *>::allocate
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAUPreSetInfo@@@std@@QAEPAPAUPreSetInfo@@I@Z ; std::allocator<PreSetInfo *>::allocate
; Function compile flags: /Ogsp
;	COMDAT ?allocate@?$allocator@PAUPreSetInfo@@@std@@QAEPAPAUPreSetInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAUPreSetInfo@@@std@@QAEPAPAUPreSetInfo@@I@Z PROC ; std::allocator<PreSetInfo *>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	6a 00		 push	 0
  00005	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Allocate@PAUPreSetInfo@@@std@@YAPAPAUPreSetInfo@@IPAPAU1@@Z ; std::_Allocate<PreSetInfo *>
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx

; 188  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?allocate@?$allocator@PAUPreSetInfo@@@std@@QAEPAPAUPreSetInfo@@I@Z ENDP ; std::allocator<PreSetInfo *>::allocate
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$SetTitle_e@$06@ioINILoader@@QAEXAAY06$$CBD@Z	; ioINILoader::SetTitle_e<7>
EXTRN	__imp_?SetTitle@ioINILoader@@QAEXPBD@Z:PROC
EXTRN	___security_cookie:DWORD
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\io3dengine\ioiniloader.h
;	COMDAT ??$SetTitle_e@$06@ioINILoader@@QAEXAAY06$$CBD@Z
_TEXT	SEGMENT
__t$ = -16						; size = 7
__$ArrayPad$ = -4					; size = 4
_t$ = 8							; size = 4
??$SetTitle_e@$06@ioINILoader@@QAEXAAY06$$CBD@Z PROC	; ioINILoader::SetTitle_e<7>, COMDAT
; _this$ = ecx

; 188  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]

; 189  : 		_ENCSTR(t, _t);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	84 d2		 test	 dl, dl
  0001a	0f 84 c0 00 00
	00		 je	 $LN96@SetTitle_e
  00020	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00023	88 55 f0	 mov	 BYTE PTR __t$[ebp], dl
  00026	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00029	84 d2		 test	 dl, dl
  0002b	0f 84 a9 00 00
	00		 je	 $LN95@SetTitle_e
  00031	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00034	88 55 f1	 mov	 BYTE PTR __t$[ebp+1], dl
  00037	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003a	84 d2		 test	 dl, dl
  0003c	0f 84 92 00 00
	00		 je	 $LN94@SetTitle_e
  00042	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00045	88 55 f2	 mov	 BYTE PTR __t$[ebp+2], dl
  00048	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004b	84 d2		 test	 dl, dl
  0004d	74 7f		 je	 SHORT $LN93@SetTitle_e
  0004f	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00052	88 55 f3	 mov	 BYTE PTR __t$[ebp+3], dl
  00055	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  00058	84 d2		 test	 dl, dl
  0005a	74 6c		 je	 SHORT $LN92@SetTitle_e
  0005c	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0005f	88 55 f4	 mov	 BYTE PTR __t$[ebp+4], dl
  00062	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00065	84 d2		 test	 dl, dl
  00067	74 59		 je	 SHORT $LN91@SetTitle_e
  00069	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0006c	80 78 06 00	 cmp	 BYTE PTR [eax+6], 0
  00070	88 55 f5	 mov	 BYTE PTR __t$[ebp+5], dl
  00073	74 6f		 je	 SHORT $LN1@SetTitle_e
  00075	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00078	84 d2		 test	 dl, dl
  0007a	74 40		 je	 SHORT $LN89@SetTitle_e
  0007c	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0007f	88 55 f7	 mov	 BYTE PTR __t$[ebp+7], dl
  00082	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  00085	84 d2		 test	 dl, dl
  00087	74 2d		 je	 SHORT $LN88@SetTitle_e
  00089	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0008c	88 55 f8	 mov	 BYTE PTR __t$[ebp+8], dl
  0008f	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  00092	84 d2		 test	 dl, dl
  00094	74 1a		 je	 SHORT $LN87@SetTitle_e
  00096	8a 40 0a	 mov	 al, BYTE PTR [eax+10]
  00099	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0009c	88 55 f9	 mov	 BYTE PTR __t$[ebp+9], dl
  0009f	84 c0		 test	 al, al
  000a1	74 07		 je	 SHORT $LN86@SetTitle_e
  000a3	34 eb		 xor	 al, -21			; ffffffebH
  000a5	88 45 fa	 mov	 BYTE PTR __t$[ebp+10], al
  000a8	eb 3a		 jmp	 SHORT $LN1@SetTitle_e
$LN86@SetTitle_e:
  000aa	c6 45 fa eb	 mov	 BYTE PTR __t$[ebp+10], -21 ; ffffffebH
  000ae	eb 34		 jmp	 SHORT $LN1@SetTitle_e
$LN87@SetTitle_e:
  000b0	c6 45 f9 ec	 mov	 BYTE PTR __t$[ebp+9], -20 ; ffffffecH
  000b4	eb 2e		 jmp	 SHORT $LN1@SetTitle_e
$LN88@SetTitle_e:
  000b6	c6 45 f8 ed	 mov	 BYTE PTR __t$[ebp+8], -19 ; ffffffedH
  000ba	eb 28		 jmp	 SHORT $LN1@SetTitle_e
$LN89@SetTitle_e:
  000bc	c6 45 f7 ea	 mov	 BYTE PTR __t$[ebp+7], -22 ; ffffffeaH
  000c0	eb 22		 jmp	 SHORT $LN1@SetTitle_e
$LN91@SetTitle_e:
  000c2	c6 45 f5 ec	 mov	 BYTE PTR __t$[ebp+5], -20 ; ffffffecH
  000c6	eb 1c		 jmp	 SHORT $LN1@SetTitle_e
$LN92@SetTitle_e:
  000c8	c6 45 f4 ed	 mov	 BYTE PTR __t$[ebp+4], -19 ; ffffffedH
  000cc	eb 16		 jmp	 SHORT $LN1@SetTitle_e
$LN93@SetTitle_e:
  000ce	c6 45 f3 ea	 mov	 BYTE PTR __t$[ebp+3], -22 ; ffffffeaH
  000d2	eb 10		 jmp	 SHORT $LN1@SetTitle_e
$LN94@SetTitle_e:
  000d4	c6 45 f2 eb	 mov	 BYTE PTR __t$[ebp+2], -21 ; ffffffebH
  000d8	eb 0a		 jmp	 SHORT $LN1@SetTitle_e
$LN95@SetTitle_e:
  000da	c6 45 f1 ec	 mov	 BYTE PTR __t$[ebp+1], -20 ; ffffffecH
  000de	eb 04		 jmp	 SHORT $LN1@SetTitle_e
$LN96@SetTitle_e:
  000e0	c6 45 f0 ed	 mov	 BYTE PTR __t$[ebp], -19	; ffffffedH
$LN1@SetTitle_e:
  000e4	81 75 f0 ed ec
	eb ea		 xor	 DWORD PTR __t$[ebp], -353637139 ; eaebecedH
  000eb	6a 04		 push	 4
  000ed	c6 45 f6 00	 mov	 BYTE PTR __t$[ebp+6], 0
  000f1	58		 pop	 eax
$LL101@SetTitle_e:
  000f2	8b c8		 mov	 ecx, eax
  000f4	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  000fa	79 05		 jns	 SHORT $LN111@SetTitle_e
  000fc	49		 dec	 ecx
  000fd	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00100	41		 inc	 ecx
$LN111@SetTitle_e:
  00101	b2 ed		 mov	 dl, -19			; ffffffedH
  00103	2a d1		 sub	 dl, cl
  00105	30 54 05 f0	 xor	 BYTE PTR __t$[ebp+eax], dl
  00109	40		 inc	 eax
  0010a	83 f8 06	 cmp	 eax, 6
  0010d	7c e3		 jl	 SHORT $LL101@SetTitle_e

; 190  : 		SetTitle(_t);

  0010f	8d 45 f0	 lea	 eax, DWORD PTR __t$[ebp]
  00112	50		 push	 eax
  00113	8b ce		 mov	 ecx, esi
  00115	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z

; 191  : 	}

  0011b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011e	33 cd		 xor	 ecx, ebp
  00120	5e		 pop	 esi
  00121	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00126	c9		 leave
  00127	c2 04 00	 ret	 4
??$SetTitle_e@$06@ioINILoader@@QAEXAAY06$$CBD@Z ENDP	; ioINILoader::SetTitle_e<7>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadInt_e@$0N@@ioINILoader@@QAEHAAY0N@$$CBDH@Z ; ioINILoader::LoadInt_e<13>
EXTRN	__imp_?LoadInt@ioINILoader@@QAEHPBDH@Z:PROC
; Function compile flags: /Ogsp
;	COMDAT ??$LoadInt_e@$0N@@ioINILoader@@QAEHAAY0N@$$CBDH@Z
_TEXT	SEGMENT
__k$ = -24						; size = 13
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_i$ = 12						; size = 4
??$LoadInt_e@$0N@@ioINILoader@@QAEHAAY0N@$$CBDH@Z PROC	; ioINILoader::LoadInt_e<13>, COMDAT
; _this$ = ecx

; 118  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 119  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	84 d2		 test	 dl, dl
  0001a	0f 84 4d 01 00
	00		 je	 $LN96@LoadInt_e
  00020	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00023	88 55 e8	 mov	 BYTE PTR __k$[ebp], dl
  00026	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00029	84 d2		 test	 dl, dl
  0002b	0f 84 36 01 00
	00		 je	 $LN95@LoadInt_e
  00031	b1 ec		 mov	 cl, -20			; ffffffecH
  00033	32 d1		 xor	 dl, cl
  00035	88 55 e9	 mov	 BYTE PTR __k$[ebp+1], dl
  00038	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003b	84 d2		 test	 dl, dl
  0003d	0f 84 1e 01 00
	00		 je	 $LN94@LoadInt_e
  00043	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00046	88 55 ea	 mov	 BYTE PTR __k$[ebp+2], dl
  00049	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004c	84 d2		 test	 dl, dl
  0004e	0f 84 07 01 00
	00		 je	 $LN93@LoadInt_e
  00054	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00057	88 55 eb	 mov	 BYTE PTR __k$[ebp+3], dl
  0005a	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005d	84 d2		 test	 dl, dl
  0005f	0f 84 f0 00 00
	00		 je	 $LN92@LoadInt_e
  00065	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00068	88 55 ec	 mov	 BYTE PTR __k$[ebp+4], dl
  0006b	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006e	84 d2		 test	 dl, dl
  00070	0f 84 da 00 00
	00		 je	 $LN91@LoadInt_e
  00076	32 d1		 xor	 dl, cl
  00078	88 55 ed	 mov	 BYTE PTR __k$[ebp+5], dl
  0007b	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0007e	84 d2		 test	 dl, dl
  00080	0f 84 c4 00 00
	00		 je	 $LN90@LoadInt_e
  00086	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00089	88 55 ee	 mov	 BYTE PTR __k$[ebp+6], dl
  0008c	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0008f	84 d2		 test	 dl, dl
  00091	0f 84 ad 00 00
	00		 je	 $LN89@LoadInt_e
  00097	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009a	88 55 ef	 mov	 BYTE PTR __k$[ebp+7], dl
  0009d	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a0	84 d2		 test	 dl, dl
  000a2	0f 84 96 00 00
	00		 je	 $LN88@LoadInt_e
  000a8	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ab	88 55 f0	 mov	 BYTE PTR __k$[ebp+8], dl
  000ae	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b1	84 d2		 test	 dl, dl
  000b3	0f 84 80 00 00
	00		 je	 $LN87@LoadInt_e
  000b9	32 d1		 xor	 dl, cl
  000bb	88 55 f1	 mov	 BYTE PTR __k$[ebp+9], dl
  000be	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c1	84 d2		 test	 dl, dl
  000c3	74 6e		 je	 SHORT $LN86@LoadInt_e
  000c5	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000c8	88 55 f2	 mov	 BYTE PTR __k$[ebp+10], dl
  000cb	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000ce	84 d2		 test	 dl, dl
  000d0	74 5b		 je	 SHORT $LN85@LoadInt_e
  000d2	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000d5	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  000d9	88 55 f3	 mov	 BYTE PTR __k$[ebp+11], dl
  000dc	0f 84 8f 00 00
	00		 je	 $LN1@LoadInt_e
  000e2	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000e5	84 d2		 test	 dl, dl
  000e7	74 3f		 je	 SHORT $LN83@LoadInt_e
  000e9	32 d1		 xor	 dl, cl
  000eb	88 55 f5	 mov	 BYTE PTR __k$[ebp+13], dl
  000ee	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  000f1	84 d2		 test	 dl, dl
  000f3	74 2d		 je	 SHORT $LN82@LoadInt_e
  000f5	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000f8	88 55 f6	 mov	 BYTE PTR __k$[ebp+14], dl
  000fb	8a 50 0f	 mov	 dl, BYTE PTR [eax+15]
  000fe	84 d2		 test	 dl, dl
  00100	74 1a		 je	 SHORT $LN81@LoadInt_e
  00102	8a 40 10	 mov	 al, BYTE PTR [eax+16]
  00105	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00108	88 55 f7	 mov	 BYTE PTR __k$[ebp+15], dl
  0010b	84 c0		 test	 al, al
  0010d	74 07		 je	 SHORT $LN80@LoadInt_e
  0010f	34 ed		 xor	 al, -19			; ffffffedH
  00111	88 45 f8	 mov	 BYTE PTR __k$[ebp+16], al
  00114	eb 5b		 jmp	 SHORT $LN1@LoadInt_e
$LN80@LoadInt_e:
  00116	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+16], -19 ; ffffffedH
  0011a	eb 55		 jmp	 SHORT $LN1@LoadInt_e
$LN81@LoadInt_e:
  0011c	c6 45 f7 ea	 mov	 BYTE PTR __k$[ebp+15], -22 ; ffffffeaH
  00120	eb 4f		 jmp	 SHORT $LN1@LoadInt_e
$LN82@LoadInt_e:
  00122	c6 45 f6 eb	 mov	 BYTE PTR __k$[ebp+14], -21 ; ffffffebH
  00126	eb 49		 jmp	 SHORT $LN1@LoadInt_e
$LN83@LoadInt_e:
  00128	88 4d f5	 mov	 BYTE PTR __k$[ebp+13], cl
  0012b	eb 44		 jmp	 SHORT $LN1@LoadInt_e
$LN85@LoadInt_e:
  0012d	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  00131	eb 3e		 jmp	 SHORT $LN1@LoadInt_e
$LN86@LoadInt_e:
  00133	c6 45 f2 eb	 mov	 BYTE PTR __k$[ebp+10], -21 ; ffffffebH
  00137	eb 38		 jmp	 SHORT $LN1@LoadInt_e
$LN87@LoadInt_e:
  00139	88 4d f1	 mov	 BYTE PTR __k$[ebp+9], cl
  0013c	eb 33		 jmp	 SHORT $LN1@LoadInt_e
$LN88@LoadInt_e:
  0013e	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  00142	eb 2d		 jmp	 SHORT $LN1@LoadInt_e
$LN89@LoadInt_e:
  00144	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  00148	eb 27		 jmp	 SHORT $LN1@LoadInt_e
$LN90@LoadInt_e:
  0014a	c6 45 ee eb	 mov	 BYTE PTR __k$[ebp+6], -21 ; ffffffebH
  0014e	eb 21		 jmp	 SHORT $LN1@LoadInt_e
$LN91@LoadInt_e:
  00150	88 4d ed	 mov	 BYTE PTR __k$[ebp+5], cl
  00153	eb 1c		 jmp	 SHORT $LN1@LoadInt_e
$LN92@LoadInt_e:
  00155	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  00159	eb 16		 jmp	 SHORT $LN1@LoadInt_e
$LN93@LoadInt_e:
  0015b	c6 45 eb ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  0015f	eb 10		 jmp	 SHORT $LN1@LoadInt_e
$LN94@LoadInt_e:
  00161	c6 45 ea eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  00165	eb 0a		 jmp	 SHORT $LN1@LoadInt_e
$LN95@LoadInt_e:
  00167	c6 45 e9 ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  0016b	eb 04		 jmp	 SHORT $LN1@LoadInt_e
$LN96@LoadInt_e:
  0016d	c6 45 e8 ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@LoadInt_e:
  00171	6a 03		 push	 3
  00173	8d 45 e8	 lea	 eax, DWORD PTR __k$[ebp]
  00176	c6 45 f4 00	 mov	 BYTE PTR __k$[ebp+12], 0
  0017a	5a		 pop	 edx
$LL104@LoadInt_e:
  0017b	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00181	83 c0 04	 add	 eax, 4
  00184	4a		 dec	 edx
  00185	75 f4		 jne	 SHORT $LL104@LoadInt_e

; 120  : 		return LoadInt(_k, i);

  00187	ff 75 0c	 push	 DWORD PTR _i$[ebp]
  0018a	8d 45 e8	 lea	 eax, DWORD PTR __k$[ebp]
  0018d	50		 push	 eax
  0018e	8b ce		 mov	 ecx, esi
  00190	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 121  : 	}

  00196	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00199	33 cd		 xor	 ecx, ebp
  0019b	5e		 pop	 esi
  0019c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a1	c9		 leave
  001a2	c2 08 00	 ret	 8
??$LoadInt_e@$0N@@ioINILoader@@QAEHAAY0N@$$CBDH@Z ENDP	; ioINILoader::LoadInt_e<13>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$SetTitle_e@$0L@@ioINILoader@@QAEXAAY0L@$$CBD@Z ; ioINILoader::SetTitle_e<11>
; Function compile flags: /Ogsp
;	COMDAT ??$SetTitle_e@$0L@@ioINILoader@@QAEXAAY0L@$$CBD@Z
_TEXT	SEGMENT
__t$ = -20						; size = 11
__$ArrayPad$ = -4					; size = 4
_t$ = 8							; size = 4
??$SetTitle_e@$0L@@ioINILoader@@QAEXAAY0L@$$CBD@Z PROC	; ioINILoader::SetTitle_e<11>, COMDAT
; _this$ = ecx

; 188  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]

; 189  : 		_ENCSTR(t, _t);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	84 d2		 test	 dl, dl
  0001a	0f 84 24 01 00
	00		 je	 $LN96@SetTitle_e@2
  00020	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00023	88 55 ec	 mov	 BYTE PTR __t$[ebp], dl
  00026	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00029	84 d2		 test	 dl, dl
  0002b	0f 84 0d 01 00
	00		 je	 $LN95@SetTitle_e@2
  00031	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00034	88 55 ed	 mov	 BYTE PTR __t$[ebp+1], dl
  00037	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003a	84 d2		 test	 dl, dl
  0003c	0f 84 f6 00 00
	00		 je	 $LN94@SetTitle_e@2
  00042	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00045	88 55 ee	 mov	 BYTE PTR __t$[ebp+2], dl
  00048	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004b	84 d2		 test	 dl, dl
  0004d	0f 84 df 00 00
	00		 je	 $LN93@SetTitle_e@2
  00053	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00056	88 55 ef	 mov	 BYTE PTR __t$[ebp+3], dl
  00059	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005c	84 d2		 test	 dl, dl
  0005e	0f 84 c8 00 00
	00		 je	 $LN92@SetTitle_e@2
  00064	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00067	88 55 f0	 mov	 BYTE PTR __t$[ebp+4], dl
  0006a	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006d	84 d2		 test	 dl, dl
  0006f	0f 84 b1 00 00
	00		 je	 $LN91@SetTitle_e@2
  00075	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00078	88 55 f1	 mov	 BYTE PTR __t$[ebp+5], dl
  0007b	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0007e	84 d2		 test	 dl, dl
  00080	0f 84 9a 00 00
	00		 je	 $LN90@SetTitle_e@2
  00086	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00089	88 55 f2	 mov	 BYTE PTR __t$[ebp+6], dl
  0008c	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0008f	84 d2		 test	 dl, dl
  00091	0f 84 83 00 00
	00		 je	 $LN89@SetTitle_e@2
  00097	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009a	88 55 f3	 mov	 BYTE PTR __t$[ebp+7], dl
  0009d	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a0	84 d2		 test	 dl, dl
  000a2	74 70		 je	 SHORT $LN88@SetTitle_e@2
  000a4	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000a7	88 55 f4	 mov	 BYTE PTR __t$[ebp+8], dl
  000aa	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000ad	84 d2		 test	 dl, dl
  000af	74 5d		 je	 SHORT $LN87@SetTitle_e@2
  000b1	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000b4	80 78 0a 00	 cmp	 BYTE PTR [eax+10], 0
  000b8	88 55 f5	 mov	 BYTE PTR __t$[ebp+9], dl
  000bb	0f 84 87 00 00
	00		 je	 $LN1@SetTitle_e@2
  000c1	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000c4	84 d2		 test	 dl, dl
  000c6	74 40		 je	 SHORT $LN85@SetTitle_e@2
  000c8	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000cb	88 55 f7	 mov	 BYTE PTR __t$[ebp+11], dl
  000ce	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000d1	84 d2		 test	 dl, dl
  000d3	74 2d		 je	 SHORT $LN84@SetTitle_e@2
  000d5	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000d8	88 55 f8	 mov	 BYTE PTR __t$[ebp+12], dl
  000db	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000de	84 d2		 test	 dl, dl
  000e0	74 1a		 je	 SHORT $LN83@SetTitle_e@2
  000e2	8a 40 0e	 mov	 al, BYTE PTR [eax+14]
  000e5	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000e8	88 55 f9	 mov	 BYTE PTR __t$[ebp+13], dl
  000eb	84 c0		 test	 al, al
  000ed	74 07		 je	 SHORT $LN82@SetTitle_e@2
  000ef	34 eb		 xor	 al, -21			; ffffffebH
  000f1	88 45 fa	 mov	 BYTE PTR __t$[ebp+14], al
  000f4	eb 52		 jmp	 SHORT $LN1@SetTitle_e@2
$LN82@SetTitle_e@2:
  000f6	c6 45 fa eb	 mov	 BYTE PTR __t$[ebp+14], -21 ; ffffffebH
  000fa	eb 4c		 jmp	 SHORT $LN1@SetTitle_e@2
$LN83@SetTitle_e@2:
  000fc	c6 45 f9 ec	 mov	 BYTE PTR __t$[ebp+13], -20 ; ffffffecH
  00100	eb 46		 jmp	 SHORT $LN1@SetTitle_e@2
$LN84@SetTitle_e@2:
  00102	c6 45 f8 ed	 mov	 BYTE PTR __t$[ebp+12], -19 ; ffffffedH
  00106	eb 40		 jmp	 SHORT $LN1@SetTitle_e@2
$LN85@SetTitle_e@2:
  00108	c6 45 f7 ea	 mov	 BYTE PTR __t$[ebp+11], -22 ; ffffffeaH
  0010c	eb 3a		 jmp	 SHORT $LN1@SetTitle_e@2
$LN87@SetTitle_e@2:
  0010e	c6 45 f5 ec	 mov	 BYTE PTR __t$[ebp+9], -20 ; ffffffecH
  00112	eb 34		 jmp	 SHORT $LN1@SetTitle_e@2
$LN88@SetTitle_e@2:
  00114	c6 45 f4 ed	 mov	 BYTE PTR __t$[ebp+8], -19 ; ffffffedH
  00118	eb 2e		 jmp	 SHORT $LN1@SetTitle_e@2
$LN89@SetTitle_e@2:
  0011a	c6 45 f3 ea	 mov	 BYTE PTR __t$[ebp+7], -22 ; ffffffeaH
  0011e	eb 28		 jmp	 SHORT $LN1@SetTitle_e@2
$LN90@SetTitle_e@2:
  00120	c6 45 f2 eb	 mov	 BYTE PTR __t$[ebp+6], -21 ; ffffffebH
  00124	eb 22		 jmp	 SHORT $LN1@SetTitle_e@2
$LN91@SetTitle_e@2:
  00126	c6 45 f1 ec	 mov	 BYTE PTR __t$[ebp+5], -20 ; ffffffecH
  0012a	eb 1c		 jmp	 SHORT $LN1@SetTitle_e@2
$LN92@SetTitle_e@2:
  0012c	c6 45 f0 ed	 mov	 BYTE PTR __t$[ebp+4], -19 ; ffffffedH
  00130	eb 16		 jmp	 SHORT $LN1@SetTitle_e@2
$LN93@SetTitle_e@2:
  00132	c6 45 ef ea	 mov	 BYTE PTR __t$[ebp+3], -22 ; ffffffeaH
  00136	eb 10		 jmp	 SHORT $LN1@SetTitle_e@2
$LN94@SetTitle_e@2:
  00138	c6 45 ee eb	 mov	 BYTE PTR __t$[ebp+2], -21 ; ffffffebH
  0013c	eb 0a		 jmp	 SHORT $LN1@SetTitle_e@2
$LN95@SetTitle_e@2:
  0013e	c6 45 ed ec	 mov	 BYTE PTR __t$[ebp+1], -20 ; ffffffecH
  00142	eb 04		 jmp	 SHORT $LN1@SetTitle_e@2
$LN96@SetTitle_e@2:
  00144	c6 45 ec ed	 mov	 BYTE PTR __t$[ebp], -19	; ffffffedH
$LN1@SetTitle_e@2:
  00148	6a 02		 push	 2
  0014a	8d 45 ec	 lea	 eax, DWORD PTR __t$[ebp]
  0014d	c6 45 f6 00	 mov	 BYTE PTR __t$[ebp+10], 0
  00151	5a		 pop	 edx
$LL104@SetTitle_e@2:
  00152	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00158	83 c0 04	 add	 eax, 4
  0015b	4a		 dec	 edx
  0015c	75 f4		 jne	 SHORT $LL104@SetTitle_e@2
  0015e	6a 08		 push	 8
  00160	58		 pop	 eax
$LL101@SetTitle_e@2:
  00161	8b c8		 mov	 ecx, eax
  00163	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00169	79 05		 jns	 SHORT $LN111@SetTitle_e@2
  0016b	49		 dec	 ecx
  0016c	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0016f	41		 inc	 ecx
$LN111@SetTitle_e@2:
  00170	b2 ed		 mov	 dl, -19			; ffffffedH
  00172	2a d1		 sub	 dl, cl
  00174	30 54 05 ec	 xor	 BYTE PTR __t$[ebp+eax], dl
  00178	40		 inc	 eax
  00179	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0017c	7c e3		 jl	 SHORT $LL101@SetTitle_e@2

; 190  : 		SetTitle(_t);

  0017e	8d 45 ec	 lea	 eax, DWORD PTR __t$[ebp]
  00181	50		 push	 eax
  00182	8b ce		 mov	 ecx, esi
  00184	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z

; 191  : 	}

  0018a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018d	33 cd		 xor	 ecx, ebp
  0018f	5e		 pop	 esi
  00190	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00195	c9		 leave
  00196	c2 04 00	 ret	 4
??$SetTitle_e@$0L@@ioINILoader@@QAEXAAY0L@$$CBD@Z ENDP	; ioINILoader::SetTitle_e<11>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadInt_e@$0BA@@ioINILoader@@QAEHAAY0BA@$$CBDH@Z ; ioINILoader::LoadInt_e<16>
; Function compile flags: /Ogsp
;	COMDAT ??$LoadInt_e@$0BA@@ioINILoader@@QAEHAAY0BA@$$CBDH@Z
_TEXT	SEGMENT
__k$ = -24						; size = 16
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_i$ = 12						; size = 4
??$LoadInt_e@$0BA@@ioINILoader@@QAEHAAY0BA@$$CBDH@Z PROC ; ioINILoader::LoadInt_e<16>, COMDAT
; _this$ = ecx

; 118  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 119  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	84 d2		 test	 dl, dl
  0001a	0f 84 8c 01 00
	00		 je	 $LN96@LoadInt_e@2
  00020	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00023	88 55 e8	 mov	 BYTE PTR __k$[ebp], dl
  00026	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00029	84 d2		 test	 dl, dl
  0002b	0f 84 75 01 00
	00		 je	 $LN95@LoadInt_e@2
  00031	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00034	88 55 e9	 mov	 BYTE PTR __k$[ebp+1], dl
  00037	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003a	84 d2		 test	 dl, dl
  0003c	0f 84 5e 01 00
	00		 je	 $LN94@LoadInt_e@2
  00042	b1 eb		 mov	 cl, -21			; ffffffebH
  00044	32 d1		 xor	 dl, cl
  00046	88 55 ea	 mov	 BYTE PTR __k$[ebp+2], dl
  00049	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004c	84 d2		 test	 dl, dl
  0004e	0f 84 46 01 00
	00		 je	 $LN93@LoadInt_e@2
  00054	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00057	88 55 eb	 mov	 BYTE PTR __k$[ebp+3], dl
  0005a	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005d	84 d2		 test	 dl, dl
  0005f	0f 84 2f 01 00
	00		 je	 $LN92@LoadInt_e@2
  00065	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00068	88 55 ec	 mov	 BYTE PTR __k$[ebp+4], dl
  0006b	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006e	84 d2		 test	 dl, dl
  00070	0f 84 18 01 00
	00		 je	 $LN91@LoadInt_e@2
  00076	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00079	88 55 ed	 mov	 BYTE PTR __k$[ebp+5], dl
  0007c	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0007f	84 d2		 test	 dl, dl
  00081	0f 84 02 01 00
	00		 je	 $LN90@LoadInt_e@2
  00087	32 d1		 xor	 dl, cl
  00089	88 55 ee	 mov	 BYTE PTR __k$[ebp+6], dl
  0008c	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0008f	84 d2		 test	 dl, dl
  00091	0f 84 ec 00 00
	00		 je	 $LN89@LoadInt_e@2
  00097	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009a	88 55 ef	 mov	 BYTE PTR __k$[ebp+7], dl
  0009d	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a0	84 d2		 test	 dl, dl
  000a2	0f 84 d5 00 00
	00		 je	 $LN88@LoadInt_e@2
  000a8	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ab	88 55 f0	 mov	 BYTE PTR __k$[ebp+8], dl
  000ae	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b1	84 d2		 test	 dl, dl
  000b3	0f 84 be 00 00
	00		 je	 $LN87@LoadInt_e@2
  000b9	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000bc	88 55 f1	 mov	 BYTE PTR __k$[ebp+9], dl
  000bf	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c2	84 d2		 test	 dl, dl
  000c4	0f 84 a8 00 00
	00		 je	 $LN86@LoadInt_e@2
  000ca	32 d1		 xor	 dl, cl
  000cc	88 55 f2	 mov	 BYTE PTR __k$[ebp+10], dl
  000cf	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000d2	84 d2		 test	 dl, dl
  000d4	0f 84 92 00 00
	00		 je	 $LN85@LoadInt_e@2
  000da	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000dd	88 55 f3	 mov	 BYTE PTR __k$[ebp+11], dl
  000e0	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000e3	84 d2		 test	 dl, dl
  000e5	74 7f		 je	 SHORT $LN84@LoadInt_e@2
  000e7	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ea	88 55 f4	 mov	 BYTE PTR __k$[ebp+12], dl
  000ed	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000f0	84 d2		 test	 dl, dl
  000f2	74 6c		 je	 SHORT $LN83@LoadInt_e@2
  000f4	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000f7	88 55 f5	 mov	 BYTE PTR __k$[ebp+13], dl
  000fa	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  000fd	84 d2		 test	 dl, dl
  000ff	74 5a		 je	 SHORT $LN82@LoadInt_e@2
  00101	32 d1		 xor	 dl, cl
  00103	80 78 0f 00	 cmp	 BYTE PTR [eax+15], 0
  00107	88 55 f6	 mov	 BYTE PTR __k$[ebp+14], dl
  0010a	0f 84 a0 00 00
	00		 je	 $LN1@LoadInt_e@2
  00110	8a 50 10	 mov	 dl, BYTE PTR [eax+16]
  00113	84 d2		 test	 dl, dl
  00115	74 3e		 je	 SHORT $LN80@LoadInt_e@2
  00117	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0011a	88 55 f8	 mov	 BYTE PTR __k$[ebp+16], dl
  0011d	8a 50 11	 mov	 dl, BYTE PTR [eax+17]
  00120	84 d2		 test	 dl, dl
  00122	74 2b		 je	 SHORT $LN79@LoadInt_e@2
  00124	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00127	88 55 f9	 mov	 BYTE PTR __k$[ebp+17], dl
  0012a	8a 50 12	 mov	 dl, BYTE PTR [eax+18]
  0012d	84 d2		 test	 dl, dl
  0012f	74 19		 je	 SHORT $LN78@LoadInt_e@2
  00131	8a 40 13	 mov	 al, BYTE PTR [eax+19]
  00134	32 d1		 xor	 dl, cl
  00136	88 55 fa	 mov	 BYTE PTR __k$[ebp+18], dl
  00139	84 c0		 test	 al, al
  0013b	74 07		 je	 SHORT $LN77@LoadInt_e@2
  0013d	34 ea		 xor	 al, -22			; ffffffeaH
  0013f	88 45 fb	 mov	 BYTE PTR __k$[ebp+19], al
  00142	eb 6c		 jmp	 SHORT $LN1@LoadInt_e@2
$LN77@LoadInt_e@2:
  00144	c6 45 fb ea	 mov	 BYTE PTR __k$[ebp+19], -22 ; ffffffeaH
  00148	eb 66		 jmp	 SHORT $LN1@LoadInt_e@2
$LN78@LoadInt_e@2:
  0014a	88 4d fa	 mov	 BYTE PTR __k$[ebp+18], cl
  0014d	eb 61		 jmp	 SHORT $LN1@LoadInt_e@2
$LN79@LoadInt_e@2:
  0014f	c6 45 f9 ec	 mov	 BYTE PTR __k$[ebp+17], -20 ; ffffffecH
  00153	eb 5b		 jmp	 SHORT $LN1@LoadInt_e@2
$LN80@LoadInt_e@2:
  00155	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+16], -19 ; ffffffedH
  00159	eb 55		 jmp	 SHORT $LN1@LoadInt_e@2
$LN82@LoadInt_e@2:
  0015b	88 4d f6	 mov	 BYTE PTR __k$[ebp+14], cl
  0015e	eb 50		 jmp	 SHORT $LN1@LoadInt_e@2
$LN83@LoadInt_e@2:
  00160	c6 45 f5 ec	 mov	 BYTE PTR __k$[ebp+13], -20 ; ffffffecH
  00164	eb 4a		 jmp	 SHORT $LN1@LoadInt_e@2
$LN84@LoadInt_e@2:
  00166	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  0016a	eb 44		 jmp	 SHORT $LN1@LoadInt_e@2
$LN85@LoadInt_e@2:
  0016c	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  00170	eb 3e		 jmp	 SHORT $LN1@LoadInt_e@2
$LN86@LoadInt_e@2:
  00172	88 4d f2	 mov	 BYTE PTR __k$[ebp+10], cl
  00175	eb 39		 jmp	 SHORT $LN1@LoadInt_e@2
$LN87@LoadInt_e@2:
  00177	c6 45 f1 ec	 mov	 BYTE PTR __k$[ebp+9], -20 ; ffffffecH
  0017b	eb 33		 jmp	 SHORT $LN1@LoadInt_e@2
$LN88@LoadInt_e@2:
  0017d	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  00181	eb 2d		 jmp	 SHORT $LN1@LoadInt_e@2
$LN89@LoadInt_e@2:
  00183	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  00187	eb 27		 jmp	 SHORT $LN1@LoadInt_e@2
$LN90@LoadInt_e@2:
  00189	88 4d ee	 mov	 BYTE PTR __k$[ebp+6], cl
  0018c	eb 22		 jmp	 SHORT $LN1@LoadInt_e@2
$LN91@LoadInt_e@2:
  0018e	c6 45 ed ec	 mov	 BYTE PTR __k$[ebp+5], -20 ; ffffffecH
  00192	eb 1c		 jmp	 SHORT $LN1@LoadInt_e@2
$LN92@LoadInt_e@2:
  00194	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  00198	eb 16		 jmp	 SHORT $LN1@LoadInt_e@2
$LN93@LoadInt_e@2:
  0019a	c6 45 eb ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  0019e	eb 10		 jmp	 SHORT $LN1@LoadInt_e@2
$LN94@LoadInt_e@2:
  001a0	c6 45 ea eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  001a4	eb 0a		 jmp	 SHORT $LN1@LoadInt_e@2
$LN95@LoadInt_e@2:
  001a6	c6 45 e9 ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  001aa	eb 04		 jmp	 SHORT $LN1@LoadInt_e@2
$LN96@LoadInt_e@2:
  001ac	c6 45 e8 ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@LoadInt_e@2:
  001b0	6a 03		 push	 3
  001b2	8d 45 e8	 lea	 eax, DWORD PTR __k$[ebp]
  001b5	c6 45 f7 00	 mov	 BYTE PTR __k$[ebp+15], 0
  001b9	5a		 pop	 edx
$LL104@LoadInt_e@2:
  001ba	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  001c0	83 c0 04	 add	 eax, 4
  001c3	4a		 dec	 edx
  001c4	75 f4		 jne	 SHORT $LL104@LoadInt_e@2
  001c6	6a 0c		 push	 12			; 0000000cH
  001c8	58		 pop	 eax
$LL101@LoadInt_e@2:
  001c9	8b c8		 mov	 ecx, eax
  001cb	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  001d1	79 05		 jns	 SHORT $LN111@LoadInt_e@2
  001d3	49		 dec	 ecx
  001d4	83 c9 fc	 or	 ecx, -4			; fffffffcH
  001d7	41		 inc	 ecx
$LN111@LoadInt_e@2:
  001d8	b2 ed		 mov	 dl, -19			; ffffffedH
  001da	2a d1		 sub	 dl, cl
  001dc	30 54 05 e8	 xor	 BYTE PTR __k$[ebp+eax], dl
  001e0	40		 inc	 eax
  001e1	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  001e4	7c e3		 jl	 SHORT $LL101@LoadInt_e@2

; 120  : 		return LoadInt(_k, i);

  001e6	ff 75 0c	 push	 DWORD PTR _i$[ebp]
  001e9	8d 45 e8	 lea	 eax, DWORD PTR __k$[ebp]
  001ec	50		 push	 eax
  001ed	8b ce		 mov	 ecx, esi
  001ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 121  : 	}

  001f5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f8	33 cd		 xor	 ecx, ebp
  001fa	5e		 pop	 esi
  001fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00200	c9		 leave
  00201	c2 08 00	 ret	 8
??$LoadInt_e@$0BA@@ioINILoader@@QAEHAAY0BA@$$CBDH@Z ENDP ; ioINILoader::LoadInt_e<16>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$SetTitle_e@$0BB@@ioINILoader@@QAEXAAY0BB@$$CBD@Z ; ioINILoader::SetTitle_e<17>
; Function compile flags: /Ogsp
;	COMDAT ??$SetTitle_e@$0BB@@ioINILoader@@QAEXAAY0BB@$$CBD@Z
_TEXT	SEGMENT
__t$ = -28						; size = 17
__$ArrayPad$ = -4					; size = 4
_t$ = 8							; size = 4
??$SetTitle_e@$0BB@@ioINILoader@@QAEXAAY0BB@$$CBD@Z PROC ; ioINILoader::SetTitle_e<17>, COMDAT
; _this$ = ecx

; 188  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]

; 189  : 		_ENCSTR(t, _t);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	84 d2		 test	 dl, dl
  0001a	0f 84 a7 01 00
	00		 je	 $LN96@SetTitle_e@3
  00020	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00023	88 55 e4	 mov	 BYTE PTR __t$[ebp], dl
  00026	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00029	84 d2		 test	 dl, dl
  0002b	0f 84 90 01 00
	00		 je	 $LN95@SetTitle_e@3
  00031	b1 ec		 mov	 cl, -20			; ffffffecH
  00033	32 d1		 xor	 dl, cl
  00035	88 55 e5	 mov	 BYTE PTR __t$[ebp+1], dl
  00038	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003b	84 d2		 test	 dl, dl
  0003d	0f 84 78 01 00
	00		 je	 $LN94@SetTitle_e@3
  00043	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00046	88 55 e6	 mov	 BYTE PTR __t$[ebp+2], dl
  00049	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004c	84 d2		 test	 dl, dl
  0004e	0f 84 61 01 00
	00		 je	 $LN93@SetTitle_e@3
  00054	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00057	88 55 e7	 mov	 BYTE PTR __t$[ebp+3], dl
  0005a	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005d	84 d2		 test	 dl, dl
  0005f	0f 84 4a 01 00
	00		 je	 $LN92@SetTitle_e@3
  00065	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00068	88 55 e8	 mov	 BYTE PTR __t$[ebp+4], dl
  0006b	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006e	84 d2		 test	 dl, dl
  00070	0f 84 34 01 00
	00		 je	 $LN91@SetTitle_e@3
  00076	32 d1		 xor	 dl, cl
  00078	88 55 e9	 mov	 BYTE PTR __t$[ebp+5], dl
  0007b	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0007e	84 d2		 test	 dl, dl
  00080	0f 84 1e 01 00
	00		 je	 $LN90@SetTitle_e@3
  00086	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00089	88 55 ea	 mov	 BYTE PTR __t$[ebp+6], dl
  0008c	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0008f	84 d2		 test	 dl, dl
  00091	0f 84 07 01 00
	00		 je	 $LN89@SetTitle_e@3
  00097	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009a	88 55 eb	 mov	 BYTE PTR __t$[ebp+7], dl
  0009d	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a0	84 d2		 test	 dl, dl
  000a2	0f 84 f0 00 00
	00		 je	 $LN88@SetTitle_e@3
  000a8	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ab	88 55 ec	 mov	 BYTE PTR __t$[ebp+8], dl
  000ae	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b1	84 d2		 test	 dl, dl
  000b3	0f 84 da 00 00
	00		 je	 $LN87@SetTitle_e@3
  000b9	32 d1		 xor	 dl, cl
  000bb	88 55 ed	 mov	 BYTE PTR __t$[ebp+9], dl
  000be	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c1	84 d2		 test	 dl, dl
  000c3	0f 84 c4 00 00
	00		 je	 $LN86@SetTitle_e@3
  000c9	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000cc	88 55 ee	 mov	 BYTE PTR __t$[ebp+10], dl
  000cf	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000d2	84 d2		 test	 dl, dl
  000d4	0f 84 ad 00 00
	00		 je	 $LN85@SetTitle_e@3
  000da	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000dd	88 55 ef	 mov	 BYTE PTR __t$[ebp+11], dl
  000e0	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000e3	84 d2		 test	 dl, dl
  000e5	0f 84 96 00 00
	00		 je	 $LN84@SetTitle_e@3
  000eb	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ee	88 55 f0	 mov	 BYTE PTR __t$[ebp+12], dl
  000f1	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000f4	84 d2		 test	 dl, dl
  000f6	0f 84 80 00 00
	00		 je	 $LN83@SetTitle_e@3
  000fc	32 d1		 xor	 dl, cl
  000fe	88 55 f1	 mov	 BYTE PTR __t$[ebp+13], dl
  00101	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  00104	84 d2		 test	 dl, dl
  00106	74 6e		 je	 SHORT $LN82@SetTitle_e@3
  00108	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0010b	88 55 f2	 mov	 BYTE PTR __t$[ebp+14], dl
  0010e	8a 50 0f	 mov	 dl, BYTE PTR [eax+15]
  00111	84 d2		 test	 dl, dl
  00113	74 5b		 je	 SHORT $LN81@SetTitle_e@3
  00115	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00118	80 78 10 00	 cmp	 BYTE PTR [eax+16], 0
  0011c	88 55 f3	 mov	 BYTE PTR __t$[ebp+15], dl
  0011f	0f 84 a6 00 00
	00		 je	 $LN1@SetTitle_e@3
  00125	8a 50 11	 mov	 dl, BYTE PTR [eax+17]
  00128	84 d2		 test	 dl, dl
  0012a	74 3f		 je	 SHORT $LN79@SetTitle_e@3
  0012c	32 d1		 xor	 dl, cl
  0012e	88 55 f5	 mov	 BYTE PTR __t$[ebp+17], dl
  00131	8a 50 12	 mov	 dl, BYTE PTR [eax+18]
  00134	84 d2		 test	 dl, dl
  00136	74 2d		 je	 SHORT $LN78@SetTitle_e@3
  00138	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0013b	88 55 f6	 mov	 BYTE PTR __t$[ebp+18], dl
  0013e	8a 50 13	 mov	 dl, BYTE PTR [eax+19]
  00141	84 d2		 test	 dl, dl
  00143	74 1a		 je	 SHORT $LN77@SetTitle_e@3
  00145	8a 40 14	 mov	 al, BYTE PTR [eax+20]
  00148	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0014b	88 55 f7	 mov	 BYTE PTR __t$[ebp+19], dl
  0014e	84 c0		 test	 al, al
  00150	74 07		 je	 SHORT $LN76@SetTitle_e@3
  00152	34 ed		 xor	 al, -19			; ffffffedH
  00154	88 45 f8	 mov	 BYTE PTR __t$[ebp+20], al
  00157	eb 72		 jmp	 SHORT $LN1@SetTitle_e@3
$LN76@SetTitle_e@3:
  00159	c6 45 f8 ed	 mov	 BYTE PTR __t$[ebp+20], -19 ; ffffffedH
  0015d	eb 6c		 jmp	 SHORT $LN1@SetTitle_e@3
$LN77@SetTitle_e@3:
  0015f	c6 45 f7 ea	 mov	 BYTE PTR __t$[ebp+19], -22 ; ffffffeaH
  00163	eb 66		 jmp	 SHORT $LN1@SetTitle_e@3
$LN78@SetTitle_e@3:
  00165	c6 45 f6 eb	 mov	 BYTE PTR __t$[ebp+18], -21 ; ffffffebH
  00169	eb 60		 jmp	 SHORT $LN1@SetTitle_e@3
$LN79@SetTitle_e@3:
  0016b	88 4d f5	 mov	 BYTE PTR __t$[ebp+17], cl
  0016e	eb 5b		 jmp	 SHORT $LN1@SetTitle_e@3
$LN81@SetTitle_e@3:
  00170	c6 45 f3 ea	 mov	 BYTE PTR __t$[ebp+15], -22 ; ffffffeaH
  00174	eb 55		 jmp	 SHORT $LN1@SetTitle_e@3
$LN82@SetTitle_e@3:
  00176	c6 45 f2 eb	 mov	 BYTE PTR __t$[ebp+14], -21 ; ffffffebH
  0017a	eb 4f		 jmp	 SHORT $LN1@SetTitle_e@3
$LN83@SetTitle_e@3:
  0017c	88 4d f1	 mov	 BYTE PTR __t$[ebp+13], cl
  0017f	eb 4a		 jmp	 SHORT $LN1@SetTitle_e@3
$LN84@SetTitle_e@3:
  00181	c6 45 f0 ed	 mov	 BYTE PTR __t$[ebp+12], -19 ; ffffffedH
  00185	eb 44		 jmp	 SHORT $LN1@SetTitle_e@3
$LN85@SetTitle_e@3:
  00187	c6 45 ef ea	 mov	 BYTE PTR __t$[ebp+11], -22 ; ffffffeaH
  0018b	eb 3e		 jmp	 SHORT $LN1@SetTitle_e@3
$LN86@SetTitle_e@3:
  0018d	c6 45 ee eb	 mov	 BYTE PTR __t$[ebp+10], -21 ; ffffffebH
  00191	eb 38		 jmp	 SHORT $LN1@SetTitle_e@3
$LN87@SetTitle_e@3:
  00193	88 4d ed	 mov	 BYTE PTR __t$[ebp+9], cl
  00196	eb 33		 jmp	 SHORT $LN1@SetTitle_e@3
$LN88@SetTitle_e@3:
  00198	c6 45 ec ed	 mov	 BYTE PTR __t$[ebp+8], -19 ; ffffffedH
  0019c	eb 2d		 jmp	 SHORT $LN1@SetTitle_e@3
$LN89@SetTitle_e@3:
  0019e	c6 45 eb ea	 mov	 BYTE PTR __t$[ebp+7], -22 ; ffffffeaH
  001a2	eb 27		 jmp	 SHORT $LN1@SetTitle_e@3
$LN90@SetTitle_e@3:
  001a4	c6 45 ea eb	 mov	 BYTE PTR __t$[ebp+6], -21 ; ffffffebH
  001a8	eb 21		 jmp	 SHORT $LN1@SetTitle_e@3
$LN91@SetTitle_e@3:
  001aa	88 4d e9	 mov	 BYTE PTR __t$[ebp+5], cl
  001ad	eb 1c		 jmp	 SHORT $LN1@SetTitle_e@3
$LN92@SetTitle_e@3:
  001af	c6 45 e8 ed	 mov	 BYTE PTR __t$[ebp+4], -19 ; ffffffedH
  001b3	eb 16		 jmp	 SHORT $LN1@SetTitle_e@3
$LN93@SetTitle_e@3:
  001b5	c6 45 e7 ea	 mov	 BYTE PTR __t$[ebp+3], -22 ; ffffffeaH
  001b9	eb 10		 jmp	 SHORT $LN1@SetTitle_e@3
$LN94@SetTitle_e@3:
  001bb	c6 45 e6 eb	 mov	 BYTE PTR __t$[ebp+2], -21 ; ffffffebH
  001bf	eb 0a		 jmp	 SHORT $LN1@SetTitle_e@3
$LN95@SetTitle_e@3:
  001c1	c6 45 e5 ec	 mov	 BYTE PTR __t$[ebp+1], -20 ; ffffffecH
  001c5	eb 04		 jmp	 SHORT $LN1@SetTitle_e@3
$LN96@SetTitle_e@3:
  001c7	c6 45 e4 ed	 mov	 BYTE PTR __t$[ebp], -19	; ffffffedH
$LN1@SetTitle_e@3:
  001cb	6a 04		 push	 4
  001cd	8d 45 e4	 lea	 eax, DWORD PTR __t$[ebp]
  001d0	c6 45 f4 00	 mov	 BYTE PTR __t$[ebp+16], 0
  001d4	5a		 pop	 edx
$LL104@SetTitle_e@3:
  001d5	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  001db	83 c0 04	 add	 eax, 4
  001de	4a		 dec	 edx
  001df	75 f4		 jne	 SHORT $LL104@SetTitle_e@3

; 190  : 		SetTitle(_t);

  001e1	8d 45 e4	 lea	 eax, DWORD PTR __t$[ebp]
  001e4	50		 push	 eax
  001e5	8b ce		 mov	 ecx, esi
  001e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z

; 191  : 	}

  001ed	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f0	33 cd		 xor	 ecx, ebp
  001f2	5e		 pop	 esi
  001f3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f8	c9		 leave
  001f9	c2 04 00	 ret	 4
??$SetTitle_e@$0BB@@ioINILoader@@QAEXAAY0BB@$$CBD@Z ENDP ; ioINILoader::SetTitle_e<17>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadInt_e@$0BH@@ioINILoader@@QAEHAAY0BH@$$CBDH@Z ; ioINILoader::LoadInt_e<23>
; Function compile flags: /Ogsp
;	COMDAT ??$LoadInt_e@$0BH@@ioINILoader@@QAEHAAY0BH@$$CBDH@Z
_TEXT	SEGMENT
__k$ = -32						; size = 23
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_i$ = 12						; size = 4
??$LoadInt_e@$0BH@@ioINILoader@@QAEHAAY0BH@$$CBDH@Z PROC ; ioINILoader::LoadInt_e<23>, COMDAT
; _this$ = ecx

; 118  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 119  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx
  00019	84 d2		 test	 dl, dl
  0001b	0f 84 2d 02 00
	00		 je	 $LN96@LoadInt_e@3
  00021	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00024	88 55 e0	 mov	 BYTE PTR __k$[ebp], dl
  00027	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002a	84 d2		 test	 dl, dl
  0002c	0f 84 16 02 00
	00		 je	 $LN95@LoadInt_e@3
  00032	b1 ec		 mov	 cl, -20			; ffffffecH
  00034	32 d1		 xor	 dl, cl
  00036	88 55 e1	 mov	 BYTE PTR __k$[ebp+1], dl
  00039	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003c	84 d2		 test	 dl, dl
  0003e	0f 84 fe 01 00
	00		 je	 $LN94@LoadInt_e@3
  00044	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00047	88 55 e2	 mov	 BYTE PTR __k$[ebp+2], dl
  0004a	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004d	84 d2		 test	 dl, dl
  0004f	0f 84 e7 01 00
	00		 je	 $LN93@LoadInt_e@3
  00055	b3 ea		 mov	 bl, -22			; ffffffeaH
  00057	32 d3		 xor	 dl, bl
  00059	88 55 e3	 mov	 BYTE PTR __k$[ebp+3], dl
  0005c	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005f	84 d2		 test	 dl, dl
  00061	0f 84 cf 01 00
	00		 je	 $LN92@LoadInt_e@3
  00067	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0006a	88 55 e4	 mov	 BYTE PTR __k$[ebp+4], dl
  0006d	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00070	84 d2		 test	 dl, dl
  00072	0f 84 b9 01 00
	00		 je	 $LN91@LoadInt_e@3
  00078	32 d1		 xor	 dl, cl
  0007a	88 55 e5	 mov	 BYTE PTR __k$[ebp+5], dl
  0007d	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00080	84 d2		 test	 dl, dl
  00082	0f 84 a3 01 00
	00		 je	 $LN90@LoadInt_e@3
  00088	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0008b	88 55 e6	 mov	 BYTE PTR __k$[ebp+6], dl
  0008e	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00091	84 d2		 test	 dl, dl
  00093	0f 84 8d 01 00
	00		 je	 $LN89@LoadInt_e@3
  00099	32 d3		 xor	 dl, bl
  0009b	88 55 e7	 mov	 BYTE PTR __k$[ebp+7], dl
  0009e	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a1	84 d2		 test	 dl, dl
  000a3	0f 84 77 01 00
	00		 je	 $LN88@LoadInt_e@3
  000a9	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ac	88 55 e8	 mov	 BYTE PTR __k$[ebp+8], dl
  000af	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b2	84 d2		 test	 dl, dl
  000b4	0f 84 61 01 00
	00		 je	 $LN87@LoadInt_e@3
  000ba	32 d1		 xor	 dl, cl
  000bc	88 55 e9	 mov	 BYTE PTR __k$[ebp+9], dl
  000bf	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c2	84 d2		 test	 dl, dl
  000c4	0f 84 4b 01 00
	00		 je	 $LN86@LoadInt_e@3
  000ca	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000cd	88 55 ea	 mov	 BYTE PTR __k$[ebp+10], dl
  000d0	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000d3	84 d2		 test	 dl, dl
  000d5	0f 84 35 01 00
	00		 je	 $LN85@LoadInt_e@3
  000db	32 d3		 xor	 dl, bl
  000dd	88 55 eb	 mov	 BYTE PTR __k$[ebp+11], dl
  000e0	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000e3	84 d2		 test	 dl, dl
  000e5	0f 84 1f 01 00
	00		 je	 $LN84@LoadInt_e@3
  000eb	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ee	88 55 ec	 mov	 BYTE PTR __k$[ebp+12], dl
  000f1	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000f4	84 d2		 test	 dl, dl
  000f6	0f 84 09 01 00
	00		 je	 $LN83@LoadInt_e@3
  000fc	32 d1		 xor	 dl, cl
  000fe	88 55 ed	 mov	 BYTE PTR __k$[ebp+13], dl
  00101	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  00104	84 d2		 test	 dl, dl
  00106	0f 84 f3 00 00
	00		 je	 $LN82@LoadInt_e@3
  0010c	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0010f	88 55 ee	 mov	 BYTE PTR __k$[ebp+14], dl
  00112	8a 50 0f	 mov	 dl, BYTE PTR [eax+15]
  00115	84 d2		 test	 dl, dl
  00117	0f 84 dd 00 00
	00		 je	 $LN81@LoadInt_e@3
  0011d	32 d3		 xor	 dl, bl
  0011f	88 55 ef	 mov	 BYTE PTR __k$[ebp+15], dl
  00122	8a 50 10	 mov	 dl, BYTE PTR [eax+16]
  00125	84 d2		 test	 dl, dl
  00127	0f 84 c7 00 00
	00		 je	 $LN80@LoadInt_e@3
  0012d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00130	88 55 f0	 mov	 BYTE PTR __k$[ebp+16], dl
  00133	8a 50 11	 mov	 dl, BYTE PTR [eax+17]
  00136	84 d2		 test	 dl, dl
  00138	0f 84 b1 00 00
	00		 je	 $LN79@LoadInt_e@3
  0013e	32 d1		 xor	 dl, cl
  00140	88 55 f1	 mov	 BYTE PTR __k$[ebp+17], dl
  00143	8a 50 12	 mov	 dl, BYTE PTR [eax+18]
  00146	84 d2		 test	 dl, dl
  00148	0f 84 9b 00 00
	00		 je	 $LN78@LoadInt_e@3
  0014e	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00151	88 55 f2	 mov	 BYTE PTR __k$[ebp+18], dl
  00154	8a 50 13	 mov	 dl, BYTE PTR [eax+19]
  00157	84 d2		 test	 dl, dl
  00159	0f 84 85 00 00
	00		 je	 $LN77@LoadInt_e@3
  0015f	32 d3		 xor	 dl, bl
  00161	88 55 f3	 mov	 BYTE PTR __k$[ebp+19], dl
  00164	8a 50 14	 mov	 dl, BYTE PTR [eax+20]
  00167	84 d2		 test	 dl, dl
  00169	74 73		 je	 SHORT $LN76@LoadInt_e@3
  0016b	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0016e	88 55 f4	 mov	 BYTE PTR __k$[ebp+20], dl
  00171	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00174	84 d2		 test	 dl, dl
  00176	74 61		 je	 SHORT $LN75@LoadInt_e@3
  00178	32 d1		 xor	 dl, cl
  0017a	80 78 16 00	 cmp	 BYTE PTR [eax+22], 0
  0017e	88 55 f5	 mov	 BYTE PTR __k$[ebp+21], dl
  00181	0f 84 cb 00 00
	00		 je	 $LN1@LoadInt_e@3
  00187	8a 50 17	 mov	 dl, BYTE PTR [eax+23]
  0018a	84 d2		 test	 dl, dl
  0018c	74 46		 je	 SHORT $LN73@LoadInt_e@3
  0018e	32 d3		 xor	 dl, bl
  00190	88 55 f7	 mov	 BYTE PTR __k$[ebp+23], dl
  00193	8a 50 18	 mov	 dl, BYTE PTR [eax+24]
  00196	84 d2		 test	 dl, dl
  00198	74 34		 je	 SHORT $LN72@LoadInt_e@3
  0019a	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0019d	88 55 f8	 mov	 BYTE PTR __k$[ebp+24], dl
  001a0	8a 50 19	 mov	 dl, BYTE PTR [eax+25]
  001a3	84 d2		 test	 dl, dl
  001a5	74 1f		 je	 SHORT $LN71@LoadInt_e@3
  001a7	8a 40 1a	 mov	 al, BYTE PTR [eax+26]
  001aa	32 d1		 xor	 dl, cl
  001ac	88 55 f9	 mov	 BYTE PTR __k$[ebp+25], dl
  001af	84 c0		 test	 al, al
  001b1	74 0a		 je	 SHORT $LN70@LoadInt_e@3
  001b3	34 eb		 xor	 al, -21			; ffffffebH
  001b5	88 45 fa	 mov	 BYTE PTR __k$[ebp+26], al
  001b8	e9 95 00 00 00	 jmp	 $LN1@LoadInt_e@3
$LN70@LoadInt_e@3:
  001bd	c6 45 fa eb	 mov	 BYTE PTR __k$[ebp+26], -21 ; ffffffebH
  001c1	e9 8c 00 00 00	 jmp	 $LN1@LoadInt_e@3
$LN71@LoadInt_e@3:
  001c6	88 4d f9	 mov	 BYTE PTR __k$[ebp+25], cl
  001c9	e9 84 00 00 00	 jmp	 $LN1@LoadInt_e@3
$LN72@LoadInt_e@3:
  001ce	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+24], -19 ; ffffffedH
  001d2	eb 7e		 jmp	 SHORT $LN1@LoadInt_e@3
$LN73@LoadInt_e@3:
  001d4	88 5d f7	 mov	 BYTE PTR __k$[ebp+23], bl
  001d7	eb 79		 jmp	 SHORT $LN1@LoadInt_e@3
$LN75@LoadInt_e@3:
  001d9	88 4d f5	 mov	 BYTE PTR __k$[ebp+21], cl
  001dc	eb 74		 jmp	 SHORT $LN1@LoadInt_e@3
$LN76@LoadInt_e@3:
  001de	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+20], -19 ; ffffffedH
  001e2	eb 6e		 jmp	 SHORT $LN1@LoadInt_e@3
$LN77@LoadInt_e@3:
  001e4	88 5d f3	 mov	 BYTE PTR __k$[ebp+19], bl
  001e7	eb 69		 jmp	 SHORT $LN1@LoadInt_e@3
$LN78@LoadInt_e@3:
  001e9	c6 45 f2 eb	 mov	 BYTE PTR __k$[ebp+18], -21 ; ffffffebH
  001ed	eb 63		 jmp	 SHORT $LN1@LoadInt_e@3
$LN79@LoadInt_e@3:
  001ef	88 4d f1	 mov	 BYTE PTR __k$[ebp+17], cl
  001f2	eb 5e		 jmp	 SHORT $LN1@LoadInt_e@3
$LN80@LoadInt_e@3:
  001f4	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+16], -19 ; ffffffedH
  001f8	eb 58		 jmp	 SHORT $LN1@LoadInt_e@3
$LN81@LoadInt_e@3:
  001fa	88 5d ef	 mov	 BYTE PTR __k$[ebp+15], bl
  001fd	eb 53		 jmp	 SHORT $LN1@LoadInt_e@3
$LN82@LoadInt_e@3:
  001ff	c6 45 ee eb	 mov	 BYTE PTR __k$[ebp+14], -21 ; ffffffebH
  00203	eb 4d		 jmp	 SHORT $LN1@LoadInt_e@3
$LN83@LoadInt_e@3:
  00205	88 4d ed	 mov	 BYTE PTR __k$[ebp+13], cl
  00208	eb 48		 jmp	 SHORT $LN1@LoadInt_e@3
$LN84@LoadInt_e@3:
  0020a	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  0020e	eb 42		 jmp	 SHORT $LN1@LoadInt_e@3
$LN85@LoadInt_e@3:
  00210	88 5d eb	 mov	 BYTE PTR __k$[ebp+11], bl
  00213	eb 3d		 jmp	 SHORT $LN1@LoadInt_e@3
$LN86@LoadInt_e@3:
  00215	c6 45 ea eb	 mov	 BYTE PTR __k$[ebp+10], -21 ; ffffffebH
  00219	eb 37		 jmp	 SHORT $LN1@LoadInt_e@3
$LN87@LoadInt_e@3:
  0021b	88 4d e9	 mov	 BYTE PTR __k$[ebp+9], cl
  0021e	eb 32		 jmp	 SHORT $LN1@LoadInt_e@3
$LN88@LoadInt_e@3:
  00220	c6 45 e8 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  00224	eb 2c		 jmp	 SHORT $LN1@LoadInt_e@3
$LN89@LoadInt_e@3:
  00226	88 5d e7	 mov	 BYTE PTR __k$[ebp+7], bl
  00229	eb 27		 jmp	 SHORT $LN1@LoadInt_e@3
$LN90@LoadInt_e@3:
  0022b	c6 45 e6 eb	 mov	 BYTE PTR __k$[ebp+6], -21 ; ffffffebH
  0022f	eb 21		 jmp	 SHORT $LN1@LoadInt_e@3
$LN91@LoadInt_e@3:
  00231	88 4d e5	 mov	 BYTE PTR __k$[ebp+5], cl
  00234	eb 1c		 jmp	 SHORT $LN1@LoadInt_e@3
$LN92@LoadInt_e@3:
  00236	c6 45 e4 ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  0023a	eb 16		 jmp	 SHORT $LN1@LoadInt_e@3
$LN93@LoadInt_e@3:
  0023c	c6 45 e3 ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  00240	eb 10		 jmp	 SHORT $LN1@LoadInt_e@3
$LN94@LoadInt_e@3:
  00242	c6 45 e2 eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  00246	eb 0a		 jmp	 SHORT $LN1@LoadInt_e@3
$LN95@LoadInt_e@3:
  00248	c6 45 e1 ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  0024c	eb 04		 jmp	 SHORT $LN1@LoadInt_e@3
$LN96@LoadInt_e@3:
  0024e	c6 45 e0 ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@LoadInt_e@3:
  00252	6a 05		 push	 5
  00254	8d 45 e0	 lea	 eax, DWORD PTR __k$[ebp]
  00257	c6 45 f6 00	 mov	 BYTE PTR __k$[ebp+22], 0
  0025b	5a		 pop	 edx
$LL104@LoadInt_e@3:
  0025c	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00262	83 c0 04	 add	 eax, 4
  00265	4a		 dec	 edx
  00266	75 f4		 jne	 SHORT $LL104@LoadInt_e@3
  00268	6a 14		 push	 20			; 00000014H
  0026a	58		 pop	 eax
$LL101@LoadInt_e@3:
  0026b	8b c8		 mov	 ecx, eax
  0026d	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00273	79 05		 jns	 SHORT $LN111@LoadInt_e@3
  00275	49		 dec	 ecx
  00276	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00279	41		 inc	 ecx
$LN111@LoadInt_e@3:
  0027a	b2 ed		 mov	 dl, -19			; ffffffedH
  0027c	2a d1		 sub	 dl, cl
  0027e	30 54 05 e0	 xor	 BYTE PTR __k$[ebp+eax], dl
  00282	40		 inc	 eax
  00283	83 f8 16	 cmp	 eax, 22			; 00000016H
  00286	7c e3		 jl	 SHORT $LL101@LoadInt_e@3

; 120  : 		return LoadInt(_k, i);

  00288	ff 75 0c	 push	 DWORD PTR _i$[ebp]
  0028b	8d 45 e0	 lea	 eax, DWORD PTR __k$[ebp]
  0028e	50		 push	 eax
  0028f	8b ce		 mov	 ecx, esi
  00291	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 121  : 	}

  00297	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0029a	5e		 pop	 esi
  0029b	33 cd		 xor	 ecx, ebp
  0029d	5b		 pop	 ebx
  0029e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002a3	c9		 leave
  002a4	c2 08 00	 ret	 8
??$LoadInt_e@$0BH@@ioINILoader@@QAEHAAY0BH@$$CBDH@Z ENDP ; ioINILoader::LoadInt_e<23>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadInt_e@$0BE@@ioINILoader@@QAEHAAY0BE@$$CBDH@Z ; ioINILoader::LoadInt_e<20>
; Function compile flags: /Ogsp
;	COMDAT ??$LoadInt_e@$0BE@@ioINILoader@@QAEHAAY0BE@$$CBDH@Z
_TEXT	SEGMENT
__k$ = -28						; size = 20
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_i$ = 12						; size = 4
??$LoadInt_e@$0BE@@ioINILoader@@QAEHAAY0BE@$$CBDH@Z PROC ; ioINILoader::LoadInt_e<20>, COMDAT
; _this$ = ecx

; 118  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 119  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx
  00019	84 d2		 test	 dl, dl
  0001b	0f 84 dd 01 00
	00		 je	 $LN96@LoadInt_e@4
  00021	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00024	88 55 e4	 mov	 BYTE PTR __k$[ebp], dl
  00027	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002a	84 d2		 test	 dl, dl
  0002c	0f 84 c6 01 00
	00		 je	 $LN95@LoadInt_e@4
  00032	b3 ec		 mov	 bl, -20			; ffffffecH
  00034	32 d3		 xor	 dl, bl
  00036	88 55 e5	 mov	 BYTE PTR __k$[ebp+1], dl
  00039	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003c	84 d2		 test	 dl, dl
  0003e	0f 84 ae 01 00
	00		 je	 $LN94@LoadInt_e@4
  00044	b1 eb		 mov	 cl, -21			; ffffffebH
  00046	32 d1		 xor	 dl, cl
  00048	88 55 e6	 mov	 BYTE PTR __k$[ebp+2], dl
  0004b	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004e	84 d2		 test	 dl, dl
  00050	0f 84 96 01 00
	00		 je	 $LN93@LoadInt_e@4
  00056	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00059	88 55 e7	 mov	 BYTE PTR __k$[ebp+3], dl
  0005c	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005f	84 d2		 test	 dl, dl
  00061	0f 84 7f 01 00
	00		 je	 $LN92@LoadInt_e@4
  00067	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0006a	88 55 e8	 mov	 BYTE PTR __k$[ebp+4], dl
  0006d	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00070	84 d2		 test	 dl, dl
  00072	0f 84 69 01 00
	00		 je	 $LN91@LoadInt_e@4
  00078	32 d3		 xor	 dl, bl
  0007a	88 55 e9	 mov	 BYTE PTR __k$[ebp+5], dl
  0007d	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00080	84 d2		 test	 dl, dl
  00082	0f 84 54 01 00
	00		 je	 $LN90@LoadInt_e@4
  00088	32 d1		 xor	 dl, cl
  0008a	88 55 ea	 mov	 BYTE PTR __k$[ebp+6], dl
  0008d	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00090	84 d2		 test	 dl, dl
  00092	0f 84 3e 01 00
	00		 je	 $LN89@LoadInt_e@4
  00098	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009b	88 55 eb	 mov	 BYTE PTR __k$[ebp+7], dl
  0009e	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a1	84 d2		 test	 dl, dl
  000a3	0f 84 27 01 00
	00		 je	 $LN88@LoadInt_e@4
  000a9	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ac	88 55 ec	 mov	 BYTE PTR __k$[ebp+8], dl
  000af	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b2	84 d2		 test	 dl, dl
  000b4	0f 84 11 01 00
	00		 je	 $LN87@LoadInt_e@4
  000ba	32 d3		 xor	 dl, bl
  000bc	88 55 ed	 mov	 BYTE PTR __k$[ebp+9], dl
  000bf	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c2	84 d2		 test	 dl, dl
  000c4	0f 84 fc 00 00
	00		 je	 $LN86@LoadInt_e@4
  000ca	32 d1		 xor	 dl, cl
  000cc	88 55 ee	 mov	 BYTE PTR __k$[ebp+10], dl
  000cf	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000d2	84 d2		 test	 dl, dl
  000d4	0f 84 e6 00 00
	00		 je	 $LN85@LoadInt_e@4
  000da	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000dd	88 55 ef	 mov	 BYTE PTR __k$[ebp+11], dl
  000e0	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000e3	84 d2		 test	 dl, dl
  000e5	0f 84 cf 00 00
	00		 je	 $LN84@LoadInt_e@4
  000eb	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ee	88 55 f0	 mov	 BYTE PTR __k$[ebp+12], dl
  000f1	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000f4	84 d2		 test	 dl, dl
  000f6	0f 84 b9 00 00
	00		 je	 $LN83@LoadInt_e@4
  000fc	32 d3		 xor	 dl, bl
  000fe	88 55 f1	 mov	 BYTE PTR __k$[ebp+13], dl
  00101	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  00104	84 d2		 test	 dl, dl
  00106	0f 84 a4 00 00
	00		 je	 $LN82@LoadInt_e@4
  0010c	32 d1		 xor	 dl, cl
  0010e	88 55 f2	 mov	 BYTE PTR __k$[ebp+14], dl
  00111	8a 50 0f	 mov	 dl, BYTE PTR [eax+15]
  00114	84 d2		 test	 dl, dl
  00116	0f 84 8e 00 00
	00		 je	 $LN81@LoadInt_e@4
  0011c	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0011f	88 55 f3	 mov	 BYTE PTR __k$[ebp+15], dl
  00122	8a 50 10	 mov	 dl, BYTE PTR [eax+16]
  00125	84 d2		 test	 dl, dl
  00127	74 7b		 je	 SHORT $LN80@LoadInt_e@4
  00129	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0012c	88 55 f4	 mov	 BYTE PTR __k$[ebp+16], dl
  0012f	8a 50 11	 mov	 dl, BYTE PTR [eax+17]
  00132	84 d2		 test	 dl, dl
  00134	74 69		 je	 SHORT $LN79@LoadInt_e@4
  00136	32 d3		 xor	 dl, bl
  00138	88 55 f5	 mov	 BYTE PTR __k$[ebp+17], dl
  0013b	8a 50 12	 mov	 dl, BYTE PTR [eax+18]
  0013e	84 d2		 test	 dl, dl
  00140	74 58		 je	 SHORT $LN78@LoadInt_e@4
  00142	32 d1		 xor	 dl, cl
  00144	80 78 13 00	 cmp	 BYTE PTR [eax+19], 0
  00148	88 55 f6	 mov	 BYTE PTR __k$[ebp+18], dl
  0014b	0f 84 b1 00 00
	00		 je	 $LN1@LoadInt_e@4
  00151	8a 50 14	 mov	 dl, BYTE PTR [eax+20]
  00154	84 d2		 test	 dl, dl
  00156	74 3c		 je	 SHORT $LN76@LoadInt_e@4
  00158	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0015b	88 55 f8	 mov	 BYTE PTR __k$[ebp+20], dl
  0015e	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00161	84 d2		 test	 dl, dl
  00163	74 2a		 je	 SHORT $LN75@LoadInt_e@4
  00165	32 d3		 xor	 dl, bl
  00167	88 55 f9	 mov	 BYTE PTR __k$[ebp+21], dl
  0016a	8a 50 16	 mov	 dl, BYTE PTR [eax+22]
  0016d	84 d2		 test	 dl, dl
  0016f	74 19		 je	 SHORT $LN74@LoadInt_e@4
  00171	8a 40 17	 mov	 al, BYTE PTR [eax+23]
  00174	32 d1		 xor	 dl, cl
  00176	88 55 fa	 mov	 BYTE PTR __k$[ebp+22], dl
  00179	84 c0		 test	 al, al
  0017b	74 07		 je	 SHORT $LN73@LoadInt_e@4
  0017d	34 ea		 xor	 al, -22			; ffffffeaH
  0017f	88 45 fb	 mov	 BYTE PTR __k$[ebp+23], al
  00182	eb 7e		 jmp	 SHORT $LN1@LoadInt_e@4
$LN73@LoadInt_e@4:
  00184	c6 45 fb ea	 mov	 BYTE PTR __k$[ebp+23], -22 ; ffffffeaH
  00188	eb 78		 jmp	 SHORT $LN1@LoadInt_e@4
$LN74@LoadInt_e@4:
  0018a	88 4d fa	 mov	 BYTE PTR __k$[ebp+22], cl
  0018d	eb 73		 jmp	 SHORT $LN1@LoadInt_e@4
$LN75@LoadInt_e@4:
  0018f	88 5d f9	 mov	 BYTE PTR __k$[ebp+21], bl
  00192	eb 6e		 jmp	 SHORT $LN1@LoadInt_e@4
$LN76@LoadInt_e@4:
  00194	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+20], -19 ; ffffffedH
  00198	eb 68		 jmp	 SHORT $LN1@LoadInt_e@4
$LN78@LoadInt_e@4:
  0019a	88 4d f6	 mov	 BYTE PTR __k$[ebp+18], cl
  0019d	eb 63		 jmp	 SHORT $LN1@LoadInt_e@4
$LN79@LoadInt_e@4:
  0019f	88 5d f5	 mov	 BYTE PTR __k$[ebp+17], bl
  001a2	eb 5e		 jmp	 SHORT $LN1@LoadInt_e@4
$LN80@LoadInt_e@4:
  001a4	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+16], -19 ; ffffffedH
  001a8	eb 58		 jmp	 SHORT $LN1@LoadInt_e@4
$LN81@LoadInt_e@4:
  001aa	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+15], -22 ; ffffffeaH
  001ae	eb 52		 jmp	 SHORT $LN1@LoadInt_e@4
$LN82@LoadInt_e@4:
  001b0	88 4d f2	 mov	 BYTE PTR __k$[ebp+14], cl
  001b3	eb 4d		 jmp	 SHORT $LN1@LoadInt_e@4
$LN83@LoadInt_e@4:
  001b5	88 5d f1	 mov	 BYTE PTR __k$[ebp+13], bl
  001b8	eb 48		 jmp	 SHORT $LN1@LoadInt_e@4
$LN84@LoadInt_e@4:
  001ba	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  001be	eb 42		 jmp	 SHORT $LN1@LoadInt_e@4
$LN85@LoadInt_e@4:
  001c0	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  001c4	eb 3c		 jmp	 SHORT $LN1@LoadInt_e@4
$LN86@LoadInt_e@4:
  001c6	88 4d ee	 mov	 BYTE PTR __k$[ebp+10], cl
  001c9	eb 37		 jmp	 SHORT $LN1@LoadInt_e@4
$LN87@LoadInt_e@4:
  001cb	88 5d ed	 mov	 BYTE PTR __k$[ebp+9], bl
  001ce	eb 32		 jmp	 SHORT $LN1@LoadInt_e@4
$LN88@LoadInt_e@4:
  001d0	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  001d4	eb 2c		 jmp	 SHORT $LN1@LoadInt_e@4
$LN89@LoadInt_e@4:
  001d6	c6 45 eb ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  001da	eb 26		 jmp	 SHORT $LN1@LoadInt_e@4
$LN90@LoadInt_e@4:
  001dc	88 4d ea	 mov	 BYTE PTR __k$[ebp+6], cl
  001df	eb 21		 jmp	 SHORT $LN1@LoadInt_e@4
$LN91@LoadInt_e@4:
  001e1	88 5d e9	 mov	 BYTE PTR __k$[ebp+5], bl
  001e4	eb 1c		 jmp	 SHORT $LN1@LoadInt_e@4
$LN92@LoadInt_e@4:
  001e6	c6 45 e8 ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  001ea	eb 16		 jmp	 SHORT $LN1@LoadInt_e@4
$LN93@LoadInt_e@4:
  001ec	c6 45 e7 ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  001f0	eb 10		 jmp	 SHORT $LN1@LoadInt_e@4
$LN94@LoadInt_e@4:
  001f2	c6 45 e6 eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  001f6	eb 0a		 jmp	 SHORT $LN1@LoadInt_e@4
$LN95@LoadInt_e@4:
  001f8	c6 45 e5 ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  001fc	eb 04		 jmp	 SHORT $LN1@LoadInt_e@4
$LN96@LoadInt_e@4:
  001fe	c6 45 e4 ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@LoadInt_e@4:
  00202	6a 04		 push	 4
  00204	8d 45 e4	 lea	 eax, DWORD PTR __k$[ebp]
  00207	c6 45 f7 00	 mov	 BYTE PTR __k$[ebp+19], 0
  0020b	5a		 pop	 edx
$LL104@LoadInt_e@4:
  0020c	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00212	83 c0 04	 add	 eax, 4
  00215	4a		 dec	 edx
  00216	75 f4		 jne	 SHORT $LL104@LoadInt_e@4
  00218	6a 10		 push	 16			; 00000010H
  0021a	58		 pop	 eax
$LL101@LoadInt_e@4:
  0021b	8b c8		 mov	 ecx, eax
  0021d	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00223	79 05		 jns	 SHORT $LN111@LoadInt_e@4
  00225	49		 dec	 ecx
  00226	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00229	41		 inc	 ecx
$LN111@LoadInt_e@4:
  0022a	b2 ed		 mov	 dl, -19			; ffffffedH
  0022c	2a d1		 sub	 dl, cl
  0022e	30 54 05 e4	 xor	 BYTE PTR __k$[ebp+eax], dl
  00232	40		 inc	 eax
  00233	83 f8 13	 cmp	 eax, 19			; 00000013H
  00236	7c e3		 jl	 SHORT $LL101@LoadInt_e@4

; 120  : 		return LoadInt(_k, i);

  00238	ff 75 0c	 push	 DWORD PTR _i$[ebp]
  0023b	8d 45 e4	 lea	 eax, DWORD PTR __k$[ebp]
  0023e	50		 push	 eax
  0023f	8b ce		 mov	 ecx, esi
  00241	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 121  : 	}

  00247	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0024a	5e		 pop	 esi
  0024b	33 cd		 xor	 ecx, ebp
  0024d	5b		 pop	 ebx
  0024e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00253	c9		 leave
  00254	c2 08 00	 ret	 8
??$LoadInt_e@$0BE@@ioINILoader@@QAEHAAY0BE@$$CBDH@Z ENDP ; ioINILoader::LoadInt_e<20>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadInt_e@$0BI@@ioINILoader@@QAEHAAY0BI@$$CBDH@Z ; ioINILoader::LoadInt_e<24>
; Function compile flags: /Ogsp
;	COMDAT ??$LoadInt_e@$0BI@@ioINILoader@@QAEHAAY0BI@$$CBDH@Z
_TEXT	SEGMENT
__k$ = -32						; size = 24
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_i$ = 12						; size = 4
??$LoadInt_e@$0BI@@ioINILoader@@QAEHAAY0BI@$$CBDH@Z PROC ; ioINILoader::LoadInt_e<24>, COMDAT
; _this$ = ecx

; 118  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 119  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx
  00019	84 d2		 test	 dl, dl
  0001b	0f 84 45 02 00
	00		 je	 $LN96@LoadInt_e@5
  00021	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00024	88 55 e0	 mov	 BYTE PTR __k$[ebp], dl
  00027	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002a	84 d2		 test	 dl, dl
  0002c	0f 84 2e 02 00
	00		 je	 $LN95@LoadInt_e@5
  00032	b3 ec		 mov	 bl, -20			; ffffffecH
  00034	32 d3		 xor	 dl, bl
  00036	88 55 e1	 mov	 BYTE PTR __k$[ebp+1], dl
  00039	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003c	84 d2		 test	 dl, dl
  0003e	0f 84 16 02 00
	00		 je	 $LN94@LoadInt_e@5
  00044	b1 eb		 mov	 cl, -21			; ffffffebH
  00046	32 d1		 xor	 dl, cl
  00048	88 55 e2	 mov	 BYTE PTR __k$[ebp+2], dl
  0004b	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004e	84 d2		 test	 dl, dl
  00050	0f 84 fe 01 00
	00		 je	 $LN93@LoadInt_e@5
  00056	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00059	88 55 e3	 mov	 BYTE PTR __k$[ebp+3], dl
  0005c	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005f	84 d2		 test	 dl, dl
  00061	0f 84 e7 01 00
	00		 je	 $LN92@LoadInt_e@5
  00067	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0006a	88 55 e4	 mov	 BYTE PTR __k$[ebp+4], dl
  0006d	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00070	84 d2		 test	 dl, dl
  00072	0f 84 d1 01 00
	00		 je	 $LN91@LoadInt_e@5
  00078	32 d3		 xor	 dl, bl
  0007a	88 55 e5	 mov	 BYTE PTR __k$[ebp+5], dl
  0007d	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00080	84 d2		 test	 dl, dl
  00082	0f 84 bc 01 00
	00		 je	 $LN90@LoadInt_e@5
  00088	32 d1		 xor	 dl, cl
  0008a	88 55 e6	 mov	 BYTE PTR __k$[ebp+6], dl
  0008d	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00090	84 d2		 test	 dl, dl
  00092	0f 84 a6 01 00
	00		 je	 $LN89@LoadInt_e@5
  00098	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009b	88 55 e7	 mov	 BYTE PTR __k$[ebp+7], dl
  0009e	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a1	84 d2		 test	 dl, dl
  000a3	0f 84 8f 01 00
	00		 je	 $LN88@LoadInt_e@5
  000a9	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ac	88 55 e8	 mov	 BYTE PTR __k$[ebp+8], dl
  000af	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b2	84 d2		 test	 dl, dl
  000b4	0f 84 79 01 00
	00		 je	 $LN87@LoadInt_e@5
  000ba	32 d3		 xor	 dl, bl
  000bc	88 55 e9	 mov	 BYTE PTR __k$[ebp+9], dl
  000bf	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c2	84 d2		 test	 dl, dl
  000c4	0f 84 64 01 00
	00		 je	 $LN86@LoadInt_e@5
  000ca	32 d1		 xor	 dl, cl
  000cc	88 55 ea	 mov	 BYTE PTR __k$[ebp+10], dl
  000cf	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000d2	84 d2		 test	 dl, dl
  000d4	0f 84 4e 01 00
	00		 je	 $LN85@LoadInt_e@5
  000da	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000dd	88 55 eb	 mov	 BYTE PTR __k$[ebp+11], dl
  000e0	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000e3	84 d2		 test	 dl, dl
  000e5	0f 84 37 01 00
	00		 je	 $LN84@LoadInt_e@5
  000eb	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ee	88 55 ec	 mov	 BYTE PTR __k$[ebp+12], dl
  000f1	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000f4	84 d2		 test	 dl, dl
  000f6	0f 84 21 01 00
	00		 je	 $LN83@LoadInt_e@5
  000fc	32 d3		 xor	 dl, bl
  000fe	88 55 ed	 mov	 BYTE PTR __k$[ebp+13], dl
  00101	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  00104	84 d2		 test	 dl, dl
  00106	0f 84 0c 01 00
	00		 je	 $LN82@LoadInt_e@5
  0010c	32 d1		 xor	 dl, cl
  0010e	88 55 ee	 mov	 BYTE PTR __k$[ebp+14], dl
  00111	8a 50 0f	 mov	 dl, BYTE PTR [eax+15]
  00114	84 d2		 test	 dl, dl
  00116	0f 84 f6 00 00
	00		 je	 $LN81@LoadInt_e@5
  0011c	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0011f	88 55 ef	 mov	 BYTE PTR __k$[ebp+15], dl
  00122	8a 50 10	 mov	 dl, BYTE PTR [eax+16]
  00125	84 d2		 test	 dl, dl
  00127	0f 84 df 00 00
	00		 je	 $LN80@LoadInt_e@5
  0012d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00130	88 55 f0	 mov	 BYTE PTR __k$[ebp+16], dl
  00133	8a 50 11	 mov	 dl, BYTE PTR [eax+17]
  00136	84 d2		 test	 dl, dl
  00138	0f 84 c9 00 00
	00		 je	 $LN79@LoadInt_e@5
  0013e	32 d3		 xor	 dl, bl
  00140	88 55 f1	 mov	 BYTE PTR __k$[ebp+17], dl
  00143	8a 50 12	 mov	 dl, BYTE PTR [eax+18]
  00146	84 d2		 test	 dl, dl
  00148	0f 84 b4 00 00
	00		 je	 $LN78@LoadInt_e@5
  0014e	32 d1		 xor	 dl, cl
  00150	88 55 f2	 mov	 BYTE PTR __k$[ebp+18], dl
  00153	8a 50 13	 mov	 dl, BYTE PTR [eax+19]
  00156	84 d2		 test	 dl, dl
  00158	0f 84 9e 00 00
	00		 je	 $LN77@LoadInt_e@5
  0015e	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00161	88 55 f3	 mov	 BYTE PTR __k$[ebp+19], dl
  00164	8a 50 14	 mov	 dl, BYTE PTR [eax+20]
  00167	84 d2		 test	 dl, dl
  00169	0f 84 87 00 00
	00		 je	 $LN76@LoadInt_e@5
  0016f	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00172	88 55 f4	 mov	 BYTE PTR __k$[ebp+20], dl
  00175	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00178	84 d2		 test	 dl, dl
  0017a	74 75		 je	 SHORT $LN75@LoadInt_e@5
  0017c	32 d3		 xor	 dl, bl
  0017e	88 55 f5	 mov	 BYTE PTR __k$[ebp+21], dl
  00181	8a 50 16	 mov	 dl, BYTE PTR [eax+22]
  00184	84 d2		 test	 dl, dl
  00186	74 64		 je	 SHORT $LN74@LoadInt_e@5
  00188	32 d1		 xor	 dl, cl
  0018a	80 78 17 00	 cmp	 BYTE PTR [eax+23], 0
  0018e	88 55 f6	 mov	 BYTE PTR __k$[ebp+22], dl
  00191	0f 84 d3 00 00
	00		 je	 $LN1@LoadInt_e@5
  00197	8a 50 18	 mov	 dl, BYTE PTR [eax+24]
  0019a	84 d2		 test	 dl, dl
  0019c	74 48		 je	 SHORT $LN72@LoadInt_e@5
  0019e	80 f2 ed	 xor	 dl, -19			; ffffffedH
  001a1	88 55 f8	 mov	 BYTE PTR __k$[ebp+24], dl
  001a4	8a 50 19	 mov	 dl, BYTE PTR [eax+25]
  001a7	84 d2		 test	 dl, dl
  001a9	74 33		 je	 SHORT $LN71@LoadInt_e@5
  001ab	32 d3		 xor	 dl, bl
  001ad	88 55 f9	 mov	 BYTE PTR __k$[ebp+25], dl
  001b0	8a 50 1a	 mov	 dl, BYTE PTR [eax+26]
  001b3	84 d2		 test	 dl, dl
  001b5	74 1f		 je	 SHORT $LN70@LoadInt_e@5
  001b7	8a 40 1b	 mov	 al, BYTE PTR [eax+27]
  001ba	32 d1		 xor	 dl, cl
  001bc	88 55 fa	 mov	 BYTE PTR __k$[ebp+26], dl
  001bf	84 c0		 test	 al, al
  001c1	74 0a		 je	 SHORT $LN69@LoadInt_e@5
  001c3	34 ea		 xor	 al, -22			; ffffffeaH
  001c5	88 45 fb	 mov	 BYTE PTR __k$[ebp+27], al
  001c8	e9 9d 00 00 00	 jmp	 $LN1@LoadInt_e@5
$LN69@LoadInt_e@5:
  001cd	c6 45 fb ea	 mov	 BYTE PTR __k$[ebp+27], -22 ; ffffffeaH
  001d1	e9 94 00 00 00	 jmp	 $LN1@LoadInt_e@5
$LN70@LoadInt_e@5:
  001d6	88 4d fa	 mov	 BYTE PTR __k$[ebp+26], cl
  001d9	e9 8c 00 00 00	 jmp	 $LN1@LoadInt_e@5
$LN71@LoadInt_e@5:
  001de	88 5d f9	 mov	 BYTE PTR __k$[ebp+25], bl
  001e1	e9 84 00 00 00	 jmp	 $LN1@LoadInt_e@5
$LN72@LoadInt_e@5:
  001e6	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+24], -19 ; ffffffedH
  001ea	eb 7e		 jmp	 SHORT $LN1@LoadInt_e@5
$LN74@LoadInt_e@5:
  001ec	88 4d f6	 mov	 BYTE PTR __k$[ebp+22], cl
  001ef	eb 79		 jmp	 SHORT $LN1@LoadInt_e@5
$LN75@LoadInt_e@5:
  001f1	88 5d f5	 mov	 BYTE PTR __k$[ebp+21], bl
  001f4	eb 74		 jmp	 SHORT $LN1@LoadInt_e@5
$LN76@LoadInt_e@5:
  001f6	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+20], -19 ; ffffffedH
  001fa	eb 6e		 jmp	 SHORT $LN1@LoadInt_e@5
$LN77@LoadInt_e@5:
  001fc	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+19], -22 ; ffffffeaH
  00200	eb 68		 jmp	 SHORT $LN1@LoadInt_e@5
$LN78@LoadInt_e@5:
  00202	88 4d f2	 mov	 BYTE PTR __k$[ebp+18], cl
  00205	eb 63		 jmp	 SHORT $LN1@LoadInt_e@5
$LN79@LoadInt_e@5:
  00207	88 5d f1	 mov	 BYTE PTR __k$[ebp+17], bl
  0020a	eb 5e		 jmp	 SHORT $LN1@LoadInt_e@5
$LN80@LoadInt_e@5:
  0020c	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+16], -19 ; ffffffedH
  00210	eb 58		 jmp	 SHORT $LN1@LoadInt_e@5
$LN81@LoadInt_e@5:
  00212	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+15], -22 ; ffffffeaH
  00216	eb 52		 jmp	 SHORT $LN1@LoadInt_e@5
$LN82@LoadInt_e@5:
  00218	88 4d ee	 mov	 BYTE PTR __k$[ebp+14], cl
  0021b	eb 4d		 jmp	 SHORT $LN1@LoadInt_e@5
$LN83@LoadInt_e@5:
  0021d	88 5d ed	 mov	 BYTE PTR __k$[ebp+13], bl
  00220	eb 48		 jmp	 SHORT $LN1@LoadInt_e@5
$LN84@LoadInt_e@5:
  00222	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  00226	eb 42		 jmp	 SHORT $LN1@LoadInt_e@5
$LN85@LoadInt_e@5:
  00228	c6 45 eb ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  0022c	eb 3c		 jmp	 SHORT $LN1@LoadInt_e@5
$LN86@LoadInt_e@5:
  0022e	88 4d ea	 mov	 BYTE PTR __k$[ebp+10], cl
  00231	eb 37		 jmp	 SHORT $LN1@LoadInt_e@5
$LN87@LoadInt_e@5:
  00233	88 5d e9	 mov	 BYTE PTR __k$[ebp+9], bl
  00236	eb 32		 jmp	 SHORT $LN1@LoadInt_e@5
$LN88@LoadInt_e@5:
  00238	c6 45 e8 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  0023c	eb 2c		 jmp	 SHORT $LN1@LoadInt_e@5
$LN89@LoadInt_e@5:
  0023e	c6 45 e7 ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  00242	eb 26		 jmp	 SHORT $LN1@LoadInt_e@5
$LN90@LoadInt_e@5:
  00244	88 4d e6	 mov	 BYTE PTR __k$[ebp+6], cl
  00247	eb 21		 jmp	 SHORT $LN1@LoadInt_e@5
$LN91@LoadInt_e@5:
  00249	88 5d e5	 mov	 BYTE PTR __k$[ebp+5], bl
  0024c	eb 1c		 jmp	 SHORT $LN1@LoadInt_e@5
$LN92@LoadInt_e@5:
  0024e	c6 45 e4 ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  00252	eb 16		 jmp	 SHORT $LN1@LoadInt_e@5
$LN93@LoadInt_e@5:
  00254	c6 45 e3 ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  00258	eb 10		 jmp	 SHORT $LN1@LoadInt_e@5
$LN94@LoadInt_e@5:
  0025a	c6 45 e2 eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  0025e	eb 0a		 jmp	 SHORT $LN1@LoadInt_e@5
$LN95@LoadInt_e@5:
  00260	c6 45 e1 ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  00264	eb 04		 jmp	 SHORT $LN1@LoadInt_e@5
$LN96@LoadInt_e@5:
  00266	c6 45 e0 ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@LoadInt_e@5:
  0026a	6a 05		 push	 5
  0026c	8d 45 e0	 lea	 eax, DWORD PTR __k$[ebp]
  0026f	c6 45 f7 00	 mov	 BYTE PTR __k$[ebp+23], 0
  00273	5a		 pop	 edx
$LL104@LoadInt_e@5:
  00274	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0027a	83 c0 04	 add	 eax, 4
  0027d	4a		 dec	 edx
  0027e	75 f4		 jne	 SHORT $LL104@LoadInt_e@5
  00280	6a 14		 push	 20			; 00000014H
  00282	58		 pop	 eax
$LL101@LoadInt_e@5:
  00283	8b c8		 mov	 ecx, eax
  00285	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0028b	79 05		 jns	 SHORT $LN111@LoadInt_e@5
  0028d	49		 dec	 ecx
  0028e	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00291	41		 inc	 ecx
$LN111@LoadInt_e@5:
  00292	b2 ed		 mov	 dl, -19			; ffffffedH
  00294	2a d1		 sub	 dl, cl
  00296	30 54 05 e0	 xor	 BYTE PTR __k$[ebp+eax], dl
  0029a	40		 inc	 eax
  0029b	83 f8 17	 cmp	 eax, 23			; 00000017H
  0029e	7c e3		 jl	 SHORT $LL101@LoadInt_e@5

; 120  : 		return LoadInt(_k, i);

  002a0	ff 75 0c	 push	 DWORD PTR _i$[ebp]
  002a3	8d 45 e0	 lea	 eax, DWORD PTR __k$[ebp]
  002a6	50		 push	 eax
  002a7	8b ce		 mov	 ecx, esi
  002a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 121  : 	}

  002af	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002b2	5e		 pop	 esi
  002b3	33 cd		 xor	 ecx, ebp
  002b5	5b		 pop	 ebx
  002b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002bb	c9		 leave
  002bc	c2 08 00	 ret	 8
??$LoadInt_e@$0BI@@ioINILoader@@QAEHAAY0BI@$$CBDH@Z ENDP ; ioINILoader::LoadInt_e<24>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadInt_e@$0BF@@ioINILoader@@QAEHAAY0BF@$$CBDH@Z ; ioINILoader::LoadInt_e<21>
; Function compile flags: /Ogsp
;	COMDAT ??$LoadInt_e@$0BF@@ioINILoader@@QAEHAAY0BF@$$CBDH@Z
_TEXT	SEGMENT
__k$ = -32						; size = 21
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_i$ = 12						; size = 4
??$LoadInt_e@$0BF@@ioINILoader@@QAEHAAY0BF@$$CBDH@Z PROC ; ioINILoader::LoadInt_e<21>, COMDAT
; _this$ = ecx

; 118  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 119  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx
  00019	84 d2		 test	 dl, dl
  0001b	0f 84 f7 01 00
	00		 je	 $LN96@LoadInt_e@6
  00021	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00024	88 55 e0	 mov	 BYTE PTR __k$[ebp], dl
  00027	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002a	84 d2		 test	 dl, dl
  0002c	0f 84 e0 01 00
	00		 je	 $LN95@LoadInt_e@6
  00032	b1 ec		 mov	 cl, -20			; ffffffecH
  00034	32 d1		 xor	 dl, cl
  00036	88 55 e1	 mov	 BYTE PTR __k$[ebp+1], dl
  00039	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003c	84 d2		 test	 dl, dl
  0003e	0f 84 c8 01 00
	00		 je	 $LN94@LoadInt_e@6
  00044	b3 eb		 mov	 bl, -21			; ffffffebH
  00046	32 d3		 xor	 dl, bl
  00048	88 55 e2	 mov	 BYTE PTR __k$[ebp+2], dl
  0004b	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004e	84 d2		 test	 dl, dl
  00050	0f 84 b0 01 00
	00		 je	 $LN93@LoadInt_e@6
  00056	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00059	88 55 e3	 mov	 BYTE PTR __k$[ebp+3], dl
  0005c	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005f	84 d2		 test	 dl, dl
  00061	0f 84 99 01 00
	00		 je	 $LN92@LoadInt_e@6
  00067	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0006a	88 55 e4	 mov	 BYTE PTR __k$[ebp+4], dl
  0006d	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00070	84 d2		 test	 dl, dl
  00072	0f 84 83 01 00
	00		 je	 $LN91@LoadInt_e@6
  00078	32 d1		 xor	 dl, cl
  0007a	88 55 e5	 mov	 BYTE PTR __k$[ebp+5], dl
  0007d	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00080	84 d2		 test	 dl, dl
  00082	0f 84 6e 01 00
	00		 je	 $LN90@LoadInt_e@6
  00088	32 d3		 xor	 dl, bl
  0008a	88 55 e6	 mov	 BYTE PTR __k$[ebp+6], dl
  0008d	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00090	84 d2		 test	 dl, dl
  00092	0f 84 58 01 00
	00		 je	 $LN89@LoadInt_e@6
  00098	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009b	88 55 e7	 mov	 BYTE PTR __k$[ebp+7], dl
  0009e	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a1	84 d2		 test	 dl, dl
  000a3	0f 84 41 01 00
	00		 je	 $LN88@LoadInt_e@6
  000a9	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ac	88 55 e8	 mov	 BYTE PTR __k$[ebp+8], dl
  000af	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b2	84 d2		 test	 dl, dl
  000b4	0f 84 2b 01 00
	00		 je	 $LN87@LoadInt_e@6
  000ba	32 d1		 xor	 dl, cl
  000bc	88 55 e9	 mov	 BYTE PTR __k$[ebp+9], dl
  000bf	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c2	84 d2		 test	 dl, dl
  000c4	0f 84 16 01 00
	00		 je	 $LN86@LoadInt_e@6
  000ca	32 d3		 xor	 dl, bl
  000cc	88 55 ea	 mov	 BYTE PTR __k$[ebp+10], dl
  000cf	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000d2	84 d2		 test	 dl, dl
  000d4	0f 84 00 01 00
	00		 je	 $LN85@LoadInt_e@6
  000da	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000dd	88 55 eb	 mov	 BYTE PTR __k$[ebp+11], dl
  000e0	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000e3	84 d2		 test	 dl, dl
  000e5	0f 84 e9 00 00
	00		 je	 $LN84@LoadInt_e@6
  000eb	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ee	88 55 ec	 mov	 BYTE PTR __k$[ebp+12], dl
  000f1	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000f4	84 d2		 test	 dl, dl
  000f6	0f 84 d3 00 00
	00		 je	 $LN83@LoadInt_e@6
  000fc	32 d1		 xor	 dl, cl
  000fe	88 55 ed	 mov	 BYTE PTR __k$[ebp+13], dl
  00101	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  00104	84 d2		 test	 dl, dl
  00106	0f 84 be 00 00
	00		 je	 $LN82@LoadInt_e@6
  0010c	32 d3		 xor	 dl, bl
  0010e	88 55 ee	 mov	 BYTE PTR __k$[ebp+14], dl
  00111	8a 50 0f	 mov	 dl, BYTE PTR [eax+15]
  00114	84 d2		 test	 dl, dl
  00116	0f 84 a8 00 00
	00		 je	 $LN81@LoadInt_e@6
  0011c	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0011f	88 55 ef	 mov	 BYTE PTR __k$[ebp+15], dl
  00122	8a 50 10	 mov	 dl, BYTE PTR [eax+16]
  00125	84 d2		 test	 dl, dl
  00127	0f 84 91 00 00
	00		 je	 $LN80@LoadInt_e@6
  0012d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00130	88 55 f0	 mov	 BYTE PTR __k$[ebp+16], dl
  00133	8a 50 11	 mov	 dl, BYTE PTR [eax+17]
  00136	84 d2		 test	 dl, dl
  00138	74 7f		 je	 SHORT $LN79@LoadInt_e@6
  0013a	32 d1		 xor	 dl, cl
  0013c	88 55 f1	 mov	 BYTE PTR __k$[ebp+17], dl
  0013f	8a 50 12	 mov	 dl, BYTE PTR [eax+18]
  00142	84 d2		 test	 dl, dl
  00144	74 6e		 je	 SHORT $LN78@LoadInt_e@6
  00146	32 d3		 xor	 dl, bl
  00148	88 55 f2	 mov	 BYTE PTR __k$[ebp+18], dl
  0014b	8a 50 13	 mov	 dl, BYTE PTR [eax+19]
  0014e	84 d2		 test	 dl, dl
  00150	74 5c		 je	 SHORT $LN77@LoadInt_e@6
  00152	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00155	80 78 14 00	 cmp	 BYTE PTR [eax+20], 0
  00159	88 55 f3	 mov	 BYTE PTR __k$[ebp+19], dl
  0015c	0f 84 ba 00 00
	00		 je	 $LN1@LoadInt_e@6
  00162	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00165	84 d2		 test	 dl, dl
  00167	74 40		 je	 SHORT $LN75@LoadInt_e@6
  00169	32 d1		 xor	 dl, cl
  0016b	88 55 f5	 mov	 BYTE PTR __k$[ebp+21], dl
  0016e	8a 50 16	 mov	 dl, BYTE PTR [eax+22]
  00171	84 d2		 test	 dl, dl
  00173	74 2f		 je	 SHORT $LN74@LoadInt_e@6
  00175	32 d3		 xor	 dl, bl
  00177	88 55 f6	 mov	 BYTE PTR __k$[ebp+22], dl
  0017a	8a 50 17	 mov	 dl, BYTE PTR [eax+23]
  0017d	84 d2		 test	 dl, dl
  0017f	74 1d		 je	 SHORT $LN73@LoadInt_e@6
  00181	8a 40 18	 mov	 al, BYTE PTR [eax+24]
  00184	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00187	88 55 f7	 mov	 BYTE PTR __k$[ebp+23], dl
  0018a	84 c0		 test	 al, al
  0018c	74 0a		 je	 SHORT $LN72@LoadInt_e@6
  0018e	34 ed		 xor	 al, -19			; ffffffedH
  00190	88 45 f8	 mov	 BYTE PTR __k$[ebp+24], al
  00193	e9 84 00 00 00	 jmp	 $LN1@LoadInt_e@6
$LN72@LoadInt_e@6:
  00198	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+24], -19 ; ffffffedH
  0019c	eb 7e		 jmp	 SHORT $LN1@LoadInt_e@6
$LN73@LoadInt_e@6:
  0019e	c6 45 f7 ea	 mov	 BYTE PTR __k$[ebp+23], -22 ; ffffffeaH
  001a2	eb 78		 jmp	 SHORT $LN1@LoadInt_e@6
$LN74@LoadInt_e@6:
  001a4	88 5d f6	 mov	 BYTE PTR __k$[ebp+22], bl
  001a7	eb 73		 jmp	 SHORT $LN1@LoadInt_e@6
$LN75@LoadInt_e@6:
  001a9	88 4d f5	 mov	 BYTE PTR __k$[ebp+21], cl
  001ac	eb 6e		 jmp	 SHORT $LN1@LoadInt_e@6
$LN77@LoadInt_e@6:
  001ae	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+19], -22 ; ffffffeaH
  001b2	eb 68		 jmp	 SHORT $LN1@LoadInt_e@6
$LN78@LoadInt_e@6:
  001b4	88 5d f2	 mov	 BYTE PTR __k$[ebp+18], bl
  001b7	eb 63		 jmp	 SHORT $LN1@LoadInt_e@6
$LN79@LoadInt_e@6:
  001b9	88 4d f1	 mov	 BYTE PTR __k$[ebp+17], cl
  001bc	eb 5e		 jmp	 SHORT $LN1@LoadInt_e@6
$LN80@LoadInt_e@6:
  001be	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+16], -19 ; ffffffedH
  001c2	eb 58		 jmp	 SHORT $LN1@LoadInt_e@6
$LN81@LoadInt_e@6:
  001c4	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+15], -22 ; ffffffeaH
  001c8	eb 52		 jmp	 SHORT $LN1@LoadInt_e@6
$LN82@LoadInt_e@6:
  001ca	88 5d ee	 mov	 BYTE PTR __k$[ebp+14], bl
  001cd	eb 4d		 jmp	 SHORT $LN1@LoadInt_e@6
$LN83@LoadInt_e@6:
  001cf	88 4d ed	 mov	 BYTE PTR __k$[ebp+13], cl
  001d2	eb 48		 jmp	 SHORT $LN1@LoadInt_e@6
$LN84@LoadInt_e@6:
  001d4	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  001d8	eb 42		 jmp	 SHORT $LN1@LoadInt_e@6
$LN85@LoadInt_e@6:
  001da	c6 45 eb ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  001de	eb 3c		 jmp	 SHORT $LN1@LoadInt_e@6
$LN86@LoadInt_e@6:
  001e0	88 5d ea	 mov	 BYTE PTR __k$[ebp+10], bl
  001e3	eb 37		 jmp	 SHORT $LN1@LoadInt_e@6
$LN87@LoadInt_e@6:
  001e5	88 4d e9	 mov	 BYTE PTR __k$[ebp+9], cl
  001e8	eb 32		 jmp	 SHORT $LN1@LoadInt_e@6
$LN88@LoadInt_e@6:
  001ea	c6 45 e8 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  001ee	eb 2c		 jmp	 SHORT $LN1@LoadInt_e@6
$LN89@LoadInt_e@6:
  001f0	c6 45 e7 ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  001f4	eb 26		 jmp	 SHORT $LN1@LoadInt_e@6
$LN90@LoadInt_e@6:
  001f6	88 5d e6	 mov	 BYTE PTR __k$[ebp+6], bl
  001f9	eb 21		 jmp	 SHORT $LN1@LoadInt_e@6
$LN91@LoadInt_e@6:
  001fb	88 4d e5	 mov	 BYTE PTR __k$[ebp+5], cl
  001fe	eb 1c		 jmp	 SHORT $LN1@LoadInt_e@6
$LN92@LoadInt_e@6:
  00200	c6 45 e4 ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  00204	eb 16		 jmp	 SHORT $LN1@LoadInt_e@6
$LN93@LoadInt_e@6:
  00206	c6 45 e3 ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  0020a	eb 10		 jmp	 SHORT $LN1@LoadInt_e@6
$LN94@LoadInt_e@6:
  0020c	c6 45 e2 eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  00210	eb 0a		 jmp	 SHORT $LN1@LoadInt_e@6
$LN95@LoadInt_e@6:
  00212	c6 45 e1 ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  00216	eb 04		 jmp	 SHORT $LN1@LoadInt_e@6
$LN96@LoadInt_e@6:
  00218	c6 45 e0 ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@LoadInt_e@6:
  0021c	6a 05		 push	 5
  0021e	8d 45 e0	 lea	 eax, DWORD PTR __k$[ebp]
  00221	c6 45 f4 00	 mov	 BYTE PTR __k$[ebp+20], 0
  00225	5a		 pop	 edx
$LL104@LoadInt_e@6:
  00226	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0022c	83 c0 04	 add	 eax, 4
  0022f	4a		 dec	 edx
  00230	75 f4		 jne	 SHORT $LL104@LoadInt_e@6

; 120  : 		return LoadInt(_k, i);

  00232	ff 75 0c	 push	 DWORD PTR _i$[ebp]
  00235	8d 45 e0	 lea	 eax, DWORD PTR __k$[ebp]
  00238	50		 push	 eax
  00239	8b ce		 mov	 ecx, esi
  0023b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 121  : 	}

  00241	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00244	5e		 pop	 esi
  00245	33 cd		 xor	 ecx, ebp
  00247	5b		 pop	 ebx
  00248	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0024d	c9		 leave
  0024e	c2 08 00	 ret	 8
??$LoadInt_e@$0BF@@ioINILoader@@QAEHAAY0BF@$$CBDH@Z ENDP ; ioINILoader::LoadInt_e<21>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$SetTitle_e@$0P@@ioINILoader@@QAEXAAY0P@$$CBD@Z ; ioINILoader::SetTitle_e<15>
; Function compile flags: /Ogsp
;	COMDAT ??$SetTitle_e@$0P@@ioINILoader@@QAEXAAY0P@$$CBD@Z
_TEXT	SEGMENT
__t$ = -24						; size = 15
__$ArrayPad$ = -4					; size = 4
_t$ = 8							; size = 4
??$SetTitle_e@$0P@@ioINILoader@@QAEXAAY0P@$$CBD@Z PROC	; ioINILoader::SetTitle_e<15>, COMDAT
; _this$ = ecx

; 188  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]

; 189  : 		_ENCSTR(t, _t);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	84 d2		 test	 dl, dl
  0001a	0f 84 75 01 00
	00		 je	 $LN96@SetTitle_e@4
  00020	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00023	88 55 e8	 mov	 BYTE PTR __t$[ebp], dl
  00026	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00029	84 d2		 test	 dl, dl
  0002b	0f 84 5e 01 00
	00		 je	 $LN95@SetTitle_e@4
  00031	b1 ec		 mov	 cl, -20			; ffffffecH
  00033	32 d1		 xor	 dl, cl
  00035	88 55 e9	 mov	 BYTE PTR __t$[ebp+1], dl
  00038	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003b	84 d2		 test	 dl, dl
  0003d	0f 84 46 01 00
	00		 je	 $LN94@SetTitle_e@4
  00043	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00046	88 55 ea	 mov	 BYTE PTR __t$[ebp+2], dl
  00049	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004c	84 d2		 test	 dl, dl
  0004e	0f 84 2f 01 00
	00		 je	 $LN93@SetTitle_e@4
  00054	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00057	88 55 eb	 mov	 BYTE PTR __t$[ebp+3], dl
  0005a	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005d	84 d2		 test	 dl, dl
  0005f	0f 84 18 01 00
	00		 je	 $LN92@SetTitle_e@4
  00065	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00068	88 55 ec	 mov	 BYTE PTR __t$[ebp+4], dl
  0006b	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006e	84 d2		 test	 dl, dl
  00070	0f 84 02 01 00
	00		 je	 $LN91@SetTitle_e@4
  00076	32 d1		 xor	 dl, cl
  00078	88 55 ed	 mov	 BYTE PTR __t$[ebp+5], dl
  0007b	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0007e	84 d2		 test	 dl, dl
  00080	0f 84 ec 00 00
	00		 je	 $LN90@SetTitle_e@4
  00086	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00089	88 55 ee	 mov	 BYTE PTR __t$[ebp+6], dl
  0008c	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0008f	84 d2		 test	 dl, dl
  00091	0f 84 d5 00 00
	00		 je	 $LN89@SetTitle_e@4
  00097	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009a	88 55 ef	 mov	 BYTE PTR __t$[ebp+7], dl
  0009d	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a0	84 d2		 test	 dl, dl
  000a2	0f 84 be 00 00
	00		 je	 $LN88@SetTitle_e@4
  000a8	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ab	88 55 f0	 mov	 BYTE PTR __t$[ebp+8], dl
  000ae	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b1	84 d2		 test	 dl, dl
  000b3	0f 84 a8 00 00
	00		 je	 $LN87@SetTitle_e@4
  000b9	32 d1		 xor	 dl, cl
  000bb	88 55 f1	 mov	 BYTE PTR __t$[ebp+9], dl
  000be	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c1	84 d2		 test	 dl, dl
  000c3	0f 84 92 00 00
	00		 je	 $LN86@SetTitle_e@4
  000c9	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000cc	88 55 f2	 mov	 BYTE PTR __t$[ebp+10], dl
  000cf	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000d2	84 d2		 test	 dl, dl
  000d4	74 7f		 je	 SHORT $LN85@SetTitle_e@4
  000d6	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000d9	88 55 f3	 mov	 BYTE PTR __t$[ebp+11], dl
  000dc	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000df	84 d2		 test	 dl, dl
  000e1	74 6c		 je	 SHORT $LN84@SetTitle_e@4
  000e3	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000e6	88 55 f4	 mov	 BYTE PTR __t$[ebp+12], dl
  000e9	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000ec	84 d2		 test	 dl, dl
  000ee	74 5a		 je	 SHORT $LN83@SetTitle_e@4
  000f0	32 d1		 xor	 dl, cl
  000f2	80 78 0e 00	 cmp	 BYTE PTR [eax+14], 0
  000f6	88 55 f5	 mov	 BYTE PTR __t$[ebp+13], dl
  000f9	0f 84 9a 00 00
	00		 je	 $LN1@SetTitle_e@4
  000ff	8a 50 0f	 mov	 dl, BYTE PTR [eax+15]
  00102	84 d2		 test	 dl, dl
  00104	74 3e		 je	 SHORT $LN81@SetTitle_e@4
  00106	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00109	88 55 f7	 mov	 BYTE PTR __t$[ebp+15], dl
  0010c	8a 50 10	 mov	 dl, BYTE PTR [eax+16]
  0010f	84 d2		 test	 dl, dl
  00111	74 2b		 je	 SHORT $LN80@SetTitle_e@4
  00113	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00116	88 55 f8	 mov	 BYTE PTR __t$[ebp+16], dl
  00119	8a 50 11	 mov	 dl, BYTE PTR [eax+17]
  0011c	84 d2		 test	 dl, dl
  0011e	74 19		 je	 SHORT $LN79@SetTitle_e@4
  00120	8a 40 12	 mov	 al, BYTE PTR [eax+18]
  00123	32 d1		 xor	 dl, cl
  00125	88 55 f9	 mov	 BYTE PTR __t$[ebp+17], dl
  00128	84 c0		 test	 al, al
  0012a	74 07		 je	 SHORT $LN78@SetTitle_e@4
  0012c	34 eb		 xor	 al, -21			; ffffffebH
  0012e	88 45 fa	 mov	 BYTE PTR __t$[ebp+18], al
  00131	eb 66		 jmp	 SHORT $LN1@SetTitle_e@4
$LN78@SetTitle_e@4:
  00133	c6 45 fa eb	 mov	 BYTE PTR __t$[ebp+18], -21 ; ffffffebH
  00137	eb 60		 jmp	 SHORT $LN1@SetTitle_e@4
$LN79@SetTitle_e@4:
  00139	88 4d f9	 mov	 BYTE PTR __t$[ebp+17], cl
  0013c	eb 5b		 jmp	 SHORT $LN1@SetTitle_e@4
$LN80@SetTitle_e@4:
  0013e	c6 45 f8 ed	 mov	 BYTE PTR __t$[ebp+16], -19 ; ffffffedH
  00142	eb 55		 jmp	 SHORT $LN1@SetTitle_e@4
$LN81@SetTitle_e@4:
  00144	c6 45 f7 ea	 mov	 BYTE PTR __t$[ebp+15], -22 ; ffffffeaH
  00148	eb 4f		 jmp	 SHORT $LN1@SetTitle_e@4
$LN83@SetTitle_e@4:
  0014a	88 4d f5	 mov	 BYTE PTR __t$[ebp+13], cl
  0014d	eb 4a		 jmp	 SHORT $LN1@SetTitle_e@4
$LN84@SetTitle_e@4:
  0014f	c6 45 f4 ed	 mov	 BYTE PTR __t$[ebp+12], -19 ; ffffffedH
  00153	eb 44		 jmp	 SHORT $LN1@SetTitle_e@4
$LN85@SetTitle_e@4:
  00155	c6 45 f3 ea	 mov	 BYTE PTR __t$[ebp+11], -22 ; ffffffeaH
  00159	eb 3e		 jmp	 SHORT $LN1@SetTitle_e@4
$LN86@SetTitle_e@4:
  0015b	c6 45 f2 eb	 mov	 BYTE PTR __t$[ebp+10], -21 ; ffffffebH
  0015f	eb 38		 jmp	 SHORT $LN1@SetTitle_e@4
$LN87@SetTitle_e@4:
  00161	88 4d f1	 mov	 BYTE PTR __t$[ebp+9], cl
  00164	eb 33		 jmp	 SHORT $LN1@SetTitle_e@4
$LN88@SetTitle_e@4:
  00166	c6 45 f0 ed	 mov	 BYTE PTR __t$[ebp+8], -19 ; ffffffedH
  0016a	eb 2d		 jmp	 SHORT $LN1@SetTitle_e@4
$LN89@SetTitle_e@4:
  0016c	c6 45 ef ea	 mov	 BYTE PTR __t$[ebp+7], -22 ; ffffffeaH
  00170	eb 27		 jmp	 SHORT $LN1@SetTitle_e@4
$LN90@SetTitle_e@4:
  00172	c6 45 ee eb	 mov	 BYTE PTR __t$[ebp+6], -21 ; ffffffebH
  00176	eb 21		 jmp	 SHORT $LN1@SetTitle_e@4
$LN91@SetTitle_e@4:
  00178	88 4d ed	 mov	 BYTE PTR __t$[ebp+5], cl
  0017b	eb 1c		 jmp	 SHORT $LN1@SetTitle_e@4
$LN92@SetTitle_e@4:
  0017d	c6 45 ec ed	 mov	 BYTE PTR __t$[ebp+4], -19 ; ffffffedH
  00181	eb 16		 jmp	 SHORT $LN1@SetTitle_e@4
$LN93@SetTitle_e@4:
  00183	c6 45 eb ea	 mov	 BYTE PTR __t$[ebp+3], -22 ; ffffffeaH
  00187	eb 10		 jmp	 SHORT $LN1@SetTitle_e@4
$LN94@SetTitle_e@4:
  00189	c6 45 ea eb	 mov	 BYTE PTR __t$[ebp+2], -21 ; ffffffebH
  0018d	eb 0a		 jmp	 SHORT $LN1@SetTitle_e@4
$LN95@SetTitle_e@4:
  0018f	c6 45 e9 ec	 mov	 BYTE PTR __t$[ebp+1], -20 ; ffffffecH
  00193	eb 04		 jmp	 SHORT $LN1@SetTitle_e@4
$LN96@SetTitle_e@4:
  00195	c6 45 e8 ed	 mov	 BYTE PTR __t$[ebp], -19	; ffffffedH
$LN1@SetTitle_e@4:
  00199	6a 03		 push	 3
  0019b	8d 45 e8	 lea	 eax, DWORD PTR __t$[ebp]
  0019e	c6 45 f6 00	 mov	 BYTE PTR __t$[ebp+14], 0
  001a2	5a		 pop	 edx
$LL104@SetTitle_e@4:
  001a3	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  001a9	83 c0 04	 add	 eax, 4
  001ac	4a		 dec	 edx
  001ad	75 f4		 jne	 SHORT $LL104@SetTitle_e@4
  001af	6a 0c		 push	 12			; 0000000cH
  001b1	58		 pop	 eax
$LL101@SetTitle_e@4:
  001b2	8b c8		 mov	 ecx, eax
  001b4	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  001ba	79 05		 jns	 SHORT $LN111@SetTitle_e@4
  001bc	49		 dec	 ecx
  001bd	83 c9 fc	 or	 ecx, -4			; fffffffcH
  001c0	41		 inc	 ecx
$LN111@SetTitle_e@4:
  001c1	b2 ed		 mov	 dl, -19			; ffffffedH
  001c3	2a d1		 sub	 dl, cl
  001c5	30 54 05 e8	 xor	 BYTE PTR __t$[ebp+eax], dl
  001c9	40		 inc	 eax
  001ca	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  001cd	7c e3		 jl	 SHORT $LL101@SetTitle_e@4

; 190  : 		SetTitle(_t);

  001cf	8d 45 e8	 lea	 eax, DWORD PTR __t$[ebp]
  001d2	50		 push	 eax
  001d3	8b ce		 mov	 ecx, esi
  001d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z

; 191  : 	}

  001db	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001de	33 cd		 xor	 ecx, ebp
  001e0	5e		 pop	 esi
  001e1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e6	c9		 leave
  001e7	c2 04 00	 ret	 4
??$SetTitle_e@$0P@@ioINILoader@@QAEXAAY0P@$$CBD@Z ENDP	; ioINILoader::SetTitle_e<15>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadInt_e@$0BC@@ioINILoader@@QAEHAAY0BC@$$CBDH@Z ; ioINILoader::LoadInt_e<18>
; Function compile flags: /Ogsp
;	COMDAT ??$LoadInt_e@$0BC@@ioINILoader@@QAEHAAY0BC@$$CBDH@Z
_TEXT	SEGMENT
__k$ = -28						; size = 18
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_i$ = 12						; size = 4
??$LoadInt_e@$0BC@@ioINILoader@@QAEHAAY0BC@$$CBDH@Z PROC ; ioINILoader::LoadInt_e<18>, COMDAT
; _this$ = ecx

; 118  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 119  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	84 d2		 test	 dl, dl
  0001a	0f 84 be 01 00
	00		 je	 $LN96@LoadInt_e@7
  00020	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00023	88 55 e4	 mov	 BYTE PTR __k$[ebp], dl
  00026	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00029	84 d2		 test	 dl, dl
  0002b	0f 84 a7 01 00
	00		 je	 $LN95@LoadInt_e@7
  00031	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00034	88 55 e5	 mov	 BYTE PTR __k$[ebp+1], dl
  00037	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003a	84 d2		 test	 dl, dl
  0003c	0f 84 90 01 00
	00		 je	 $LN94@LoadInt_e@7
  00042	b1 eb		 mov	 cl, -21			; ffffffebH
  00044	32 d1		 xor	 dl, cl
  00046	88 55 e6	 mov	 BYTE PTR __k$[ebp+2], dl
  00049	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004c	84 d2		 test	 dl, dl
  0004e	0f 84 78 01 00
	00		 je	 $LN93@LoadInt_e@7
  00054	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00057	88 55 e7	 mov	 BYTE PTR __k$[ebp+3], dl
  0005a	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005d	84 d2		 test	 dl, dl
  0005f	0f 84 61 01 00
	00		 je	 $LN92@LoadInt_e@7
  00065	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00068	88 55 e8	 mov	 BYTE PTR __k$[ebp+4], dl
  0006b	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006e	84 d2		 test	 dl, dl
  00070	0f 84 4a 01 00
	00		 je	 $LN91@LoadInt_e@7
  00076	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00079	88 55 e9	 mov	 BYTE PTR __k$[ebp+5], dl
  0007c	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0007f	84 d2		 test	 dl, dl
  00081	0f 84 34 01 00
	00		 je	 $LN90@LoadInt_e@7
  00087	32 d1		 xor	 dl, cl
  00089	88 55 ea	 mov	 BYTE PTR __k$[ebp+6], dl
  0008c	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0008f	84 d2		 test	 dl, dl
  00091	0f 84 1e 01 00
	00		 je	 $LN89@LoadInt_e@7
  00097	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009a	88 55 eb	 mov	 BYTE PTR __k$[ebp+7], dl
  0009d	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a0	84 d2		 test	 dl, dl
  000a2	0f 84 07 01 00
	00		 je	 $LN88@LoadInt_e@7
  000a8	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ab	88 55 ec	 mov	 BYTE PTR __k$[ebp+8], dl
  000ae	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b1	84 d2		 test	 dl, dl
  000b3	0f 84 f0 00 00
	00		 je	 $LN87@LoadInt_e@7
  000b9	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000bc	88 55 ed	 mov	 BYTE PTR __k$[ebp+9], dl
  000bf	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c2	84 d2		 test	 dl, dl
  000c4	0f 84 da 00 00
	00		 je	 $LN86@LoadInt_e@7
  000ca	32 d1		 xor	 dl, cl
  000cc	88 55 ee	 mov	 BYTE PTR __k$[ebp+10], dl
  000cf	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000d2	84 d2		 test	 dl, dl
  000d4	0f 84 c4 00 00
	00		 je	 $LN85@LoadInt_e@7
  000da	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000dd	88 55 ef	 mov	 BYTE PTR __k$[ebp+11], dl
  000e0	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000e3	84 d2		 test	 dl, dl
  000e5	0f 84 ad 00 00
	00		 je	 $LN84@LoadInt_e@7
  000eb	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ee	88 55 f0	 mov	 BYTE PTR __k$[ebp+12], dl
  000f1	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000f4	84 d2		 test	 dl, dl
  000f6	0f 84 96 00 00
	00		 je	 $LN83@LoadInt_e@7
  000fc	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000ff	88 55 f1	 mov	 BYTE PTR __k$[ebp+13], dl
  00102	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  00105	84 d2		 test	 dl, dl
  00107	0f 84 80 00 00
	00		 je	 $LN82@LoadInt_e@7
  0010d	32 d1		 xor	 dl, cl
  0010f	88 55 f2	 mov	 BYTE PTR __k$[ebp+14], dl
  00112	8a 50 0f	 mov	 dl, BYTE PTR [eax+15]
  00115	84 d2		 test	 dl, dl
  00117	74 6e		 je	 SHORT $LN81@LoadInt_e@7
  00119	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0011c	88 55 f3	 mov	 BYTE PTR __k$[ebp+15], dl
  0011f	8a 50 10	 mov	 dl, BYTE PTR [eax+16]
  00122	84 d2		 test	 dl, dl
  00124	74 5b		 je	 SHORT $LN80@LoadInt_e@7
  00126	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00129	80 78 11 00	 cmp	 BYTE PTR [eax+17], 0
  0012d	88 55 f4	 mov	 BYTE PTR __k$[ebp+16], dl
  00130	0f 84 ac 00 00
	00		 je	 $LN1@LoadInt_e@7
  00136	8a 50 12	 mov	 dl, BYTE PTR [eax+18]
  00139	84 d2		 test	 dl, dl
  0013b	74 3f		 je	 SHORT $LN78@LoadInt_e@7
  0013d	32 d1		 xor	 dl, cl
  0013f	88 55 f6	 mov	 BYTE PTR __k$[ebp+18], dl
  00142	8a 50 13	 mov	 dl, BYTE PTR [eax+19]
  00145	84 d2		 test	 dl, dl
  00147	74 2d		 je	 SHORT $LN77@LoadInt_e@7
  00149	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0014c	88 55 f7	 mov	 BYTE PTR __k$[ebp+19], dl
  0014f	8a 50 14	 mov	 dl, BYTE PTR [eax+20]
  00152	84 d2		 test	 dl, dl
  00154	74 1a		 je	 SHORT $LN76@LoadInt_e@7
  00156	8a 40 15	 mov	 al, BYTE PTR [eax+21]
  00159	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0015c	88 55 f8	 mov	 BYTE PTR __k$[ebp+20], dl
  0015f	84 c0		 test	 al, al
  00161	74 07		 je	 SHORT $LN75@LoadInt_e@7
  00163	34 ec		 xor	 al, -20			; ffffffecH
  00165	88 45 f9	 mov	 BYTE PTR __k$[ebp+21], al
  00168	eb 78		 jmp	 SHORT $LN1@LoadInt_e@7
$LN75@LoadInt_e@7:
  0016a	c6 45 f9 ec	 mov	 BYTE PTR __k$[ebp+21], -20 ; ffffffecH
  0016e	eb 72		 jmp	 SHORT $LN1@LoadInt_e@7
$LN76@LoadInt_e@7:
  00170	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+20], -19 ; ffffffedH
  00174	eb 6c		 jmp	 SHORT $LN1@LoadInt_e@7
$LN77@LoadInt_e@7:
  00176	c6 45 f7 ea	 mov	 BYTE PTR __k$[ebp+19], -22 ; ffffffeaH
  0017a	eb 66		 jmp	 SHORT $LN1@LoadInt_e@7
$LN78@LoadInt_e@7:
  0017c	88 4d f6	 mov	 BYTE PTR __k$[ebp+18], cl
  0017f	eb 61		 jmp	 SHORT $LN1@LoadInt_e@7
$LN80@LoadInt_e@7:
  00181	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+16], -19 ; ffffffedH
  00185	eb 5b		 jmp	 SHORT $LN1@LoadInt_e@7
$LN81@LoadInt_e@7:
  00187	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+15], -22 ; ffffffeaH
  0018b	eb 55		 jmp	 SHORT $LN1@LoadInt_e@7
$LN82@LoadInt_e@7:
  0018d	88 4d f2	 mov	 BYTE PTR __k$[ebp+14], cl
  00190	eb 50		 jmp	 SHORT $LN1@LoadInt_e@7
$LN83@LoadInt_e@7:
  00192	c6 45 f1 ec	 mov	 BYTE PTR __k$[ebp+13], -20 ; ffffffecH
  00196	eb 4a		 jmp	 SHORT $LN1@LoadInt_e@7
$LN84@LoadInt_e@7:
  00198	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  0019c	eb 44		 jmp	 SHORT $LN1@LoadInt_e@7
$LN85@LoadInt_e@7:
  0019e	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  001a2	eb 3e		 jmp	 SHORT $LN1@LoadInt_e@7
$LN86@LoadInt_e@7:
  001a4	88 4d ee	 mov	 BYTE PTR __k$[ebp+10], cl
  001a7	eb 39		 jmp	 SHORT $LN1@LoadInt_e@7
$LN87@LoadInt_e@7:
  001a9	c6 45 ed ec	 mov	 BYTE PTR __k$[ebp+9], -20 ; ffffffecH
  001ad	eb 33		 jmp	 SHORT $LN1@LoadInt_e@7
$LN88@LoadInt_e@7:
  001af	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  001b3	eb 2d		 jmp	 SHORT $LN1@LoadInt_e@7
$LN89@LoadInt_e@7:
  001b5	c6 45 eb ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  001b9	eb 27		 jmp	 SHORT $LN1@LoadInt_e@7
$LN90@LoadInt_e@7:
  001bb	88 4d ea	 mov	 BYTE PTR __k$[ebp+6], cl
  001be	eb 22		 jmp	 SHORT $LN1@LoadInt_e@7
$LN91@LoadInt_e@7:
  001c0	c6 45 e9 ec	 mov	 BYTE PTR __k$[ebp+5], -20 ; ffffffecH
  001c4	eb 1c		 jmp	 SHORT $LN1@LoadInt_e@7
$LN92@LoadInt_e@7:
  001c6	c6 45 e8 ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  001ca	eb 16		 jmp	 SHORT $LN1@LoadInt_e@7
$LN93@LoadInt_e@7:
  001cc	c6 45 e7 ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  001d0	eb 10		 jmp	 SHORT $LN1@LoadInt_e@7
$LN94@LoadInt_e@7:
  001d2	c6 45 e6 eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  001d6	eb 0a		 jmp	 SHORT $LN1@LoadInt_e@7
$LN95@LoadInt_e@7:
  001d8	c6 45 e5 ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  001dc	eb 04		 jmp	 SHORT $LN1@LoadInt_e@7
$LN96@LoadInt_e@7:
  001de	c6 45 e4 ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@LoadInt_e@7:
  001e2	6a 04		 push	 4
  001e4	8d 45 e4	 lea	 eax, DWORD PTR __k$[ebp]
  001e7	c6 45 f5 00	 mov	 BYTE PTR __k$[ebp+17], 0
  001eb	5a		 pop	 edx
$LL104@LoadInt_e@7:
  001ec	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  001f2	83 c0 04	 add	 eax, 4
  001f5	4a		 dec	 edx
  001f6	75 f4		 jne	 SHORT $LL104@LoadInt_e@7

; 120  : 		return LoadInt(_k, i);

  001f8	ff 75 0c	 push	 DWORD PTR _i$[ebp]
  001fb	80 75 f4 ed	 xor	 BYTE PTR __k$[ebp+16], -19 ; ffffffedH
  001ff	8d 45 e4	 lea	 eax, DWORD PTR __k$[ebp]
  00202	50		 push	 eax
  00203	8b ce		 mov	 ecx, esi
  00205	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 121  : 	}

  0020b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0020e	33 cd		 xor	 ecx, ebp
  00210	5e		 pop	 esi
  00211	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00216	c9		 leave
  00217	c2 08 00	 ret	 8
??$LoadInt_e@$0BC@@ioINILoader@@QAEHAAY0BC@$$CBDH@Z ENDP ; ioINILoader::LoadInt_e<18>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$SetTitle_e@$0M@@ioINILoader@@QAEXAAY0M@$$CBD@Z ; ioINILoader::SetTitle_e<12>
; Function compile flags: /Ogsp
;	COMDAT ??$SetTitle_e@$0M@@ioINILoader@@QAEXAAY0M@$$CBD@Z
_TEXT	SEGMENT
__t$ = -20						; size = 12
__$ArrayPad$ = -4					; size = 4
_t$ = 8							; size = 4
??$SetTitle_e@$0M@@ioINILoader@@QAEXAAY0M@$$CBD@Z PROC	; ioINILoader::SetTitle_e<12>, COMDAT
; _this$ = ecx

; 188  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]

; 189  : 		_ENCSTR(t, _t);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	84 d2		 test	 dl, dl
  0001a	0f 84 32 01 00
	00		 je	 $LN96@SetTitle_e@5
  00020	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00023	88 55 ec	 mov	 BYTE PTR __t$[ebp], dl
  00026	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00029	84 d2		 test	 dl, dl
  0002b	0f 84 1b 01 00
	00		 je	 $LN95@SetTitle_e@5
  00031	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00034	88 55 ed	 mov	 BYTE PTR __t$[ebp+1], dl
  00037	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003a	84 d2		 test	 dl, dl
  0003c	0f 84 04 01 00
	00		 je	 $LN94@SetTitle_e@5
  00042	b1 eb		 mov	 cl, -21			; ffffffebH
  00044	32 d1		 xor	 dl, cl
  00046	88 55 ee	 mov	 BYTE PTR __t$[ebp+2], dl
  00049	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004c	84 d2		 test	 dl, dl
  0004e	0f 84 ec 00 00
	00		 je	 $LN93@SetTitle_e@5
  00054	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00057	88 55 ef	 mov	 BYTE PTR __t$[ebp+3], dl
  0005a	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005d	84 d2		 test	 dl, dl
  0005f	0f 84 d5 00 00
	00		 je	 $LN92@SetTitle_e@5
  00065	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00068	88 55 f0	 mov	 BYTE PTR __t$[ebp+4], dl
  0006b	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006e	84 d2		 test	 dl, dl
  00070	0f 84 be 00 00
	00		 je	 $LN91@SetTitle_e@5
  00076	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00079	88 55 f1	 mov	 BYTE PTR __t$[ebp+5], dl
  0007c	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0007f	84 d2		 test	 dl, dl
  00081	0f 84 a8 00 00
	00		 je	 $LN90@SetTitle_e@5
  00087	32 d1		 xor	 dl, cl
  00089	88 55 f2	 mov	 BYTE PTR __t$[ebp+6], dl
  0008c	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0008f	84 d2		 test	 dl, dl
  00091	0f 84 92 00 00
	00		 je	 $LN89@SetTitle_e@5
  00097	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009a	88 55 f3	 mov	 BYTE PTR __t$[ebp+7], dl
  0009d	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a0	84 d2		 test	 dl, dl
  000a2	74 7f		 je	 SHORT $LN88@SetTitle_e@5
  000a4	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000a7	88 55 f4	 mov	 BYTE PTR __t$[ebp+8], dl
  000aa	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000ad	84 d2		 test	 dl, dl
  000af	74 6c		 je	 SHORT $LN87@SetTitle_e@5
  000b1	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000b4	88 55 f5	 mov	 BYTE PTR __t$[ebp+9], dl
  000b7	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000ba	84 d2		 test	 dl, dl
  000bc	74 5a		 je	 SHORT $LN86@SetTitle_e@5
  000be	32 d1		 xor	 dl, cl
  000c0	80 78 0b 00	 cmp	 BYTE PTR [eax+11], 0
  000c4	88 55 f6	 mov	 BYTE PTR __t$[ebp+10], dl
  000c7	0f 84 89 00 00
	00		 je	 $LN1@SetTitle_e@5
  000cd	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000d0	84 d2		 test	 dl, dl
  000d2	74 3e		 je	 SHORT $LN84@SetTitle_e@5
  000d4	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000d7	88 55 f8	 mov	 BYTE PTR __t$[ebp+12], dl
  000da	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000dd	84 d2		 test	 dl, dl
  000df	74 2b		 je	 SHORT $LN83@SetTitle_e@5
  000e1	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000e4	88 55 f9	 mov	 BYTE PTR __t$[ebp+13], dl
  000e7	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  000ea	84 d2		 test	 dl, dl
  000ec	74 19		 je	 SHORT $LN82@SetTitle_e@5
  000ee	8a 40 0f	 mov	 al, BYTE PTR [eax+15]
  000f1	32 d1		 xor	 dl, cl
  000f3	88 55 fa	 mov	 BYTE PTR __t$[ebp+14], dl
  000f6	84 c0		 test	 al, al
  000f8	74 07		 je	 SHORT $LN81@SetTitle_e@5
  000fa	34 ea		 xor	 al, -22			; ffffffeaH
  000fc	88 45 fb	 mov	 BYTE PTR __t$[ebp+15], al
  000ff	eb 55		 jmp	 SHORT $LN1@SetTitle_e@5
$LN81@SetTitle_e@5:
  00101	c6 45 fb ea	 mov	 BYTE PTR __t$[ebp+15], -22 ; ffffffeaH
  00105	eb 4f		 jmp	 SHORT $LN1@SetTitle_e@5
$LN82@SetTitle_e@5:
  00107	88 4d fa	 mov	 BYTE PTR __t$[ebp+14], cl
  0010a	eb 4a		 jmp	 SHORT $LN1@SetTitle_e@5
$LN83@SetTitle_e@5:
  0010c	c6 45 f9 ec	 mov	 BYTE PTR __t$[ebp+13], -20 ; ffffffecH
  00110	eb 44		 jmp	 SHORT $LN1@SetTitle_e@5
$LN84@SetTitle_e@5:
  00112	c6 45 f8 ed	 mov	 BYTE PTR __t$[ebp+12], -19 ; ffffffedH
  00116	eb 3e		 jmp	 SHORT $LN1@SetTitle_e@5
$LN86@SetTitle_e@5:
  00118	88 4d f6	 mov	 BYTE PTR __t$[ebp+10], cl
  0011b	eb 39		 jmp	 SHORT $LN1@SetTitle_e@5
$LN87@SetTitle_e@5:
  0011d	c6 45 f5 ec	 mov	 BYTE PTR __t$[ebp+9], -20 ; ffffffecH
  00121	eb 33		 jmp	 SHORT $LN1@SetTitle_e@5
$LN88@SetTitle_e@5:
  00123	c6 45 f4 ed	 mov	 BYTE PTR __t$[ebp+8], -19 ; ffffffedH
  00127	eb 2d		 jmp	 SHORT $LN1@SetTitle_e@5
$LN89@SetTitle_e@5:
  00129	c6 45 f3 ea	 mov	 BYTE PTR __t$[ebp+7], -22 ; ffffffeaH
  0012d	eb 27		 jmp	 SHORT $LN1@SetTitle_e@5
$LN90@SetTitle_e@5:
  0012f	88 4d f2	 mov	 BYTE PTR __t$[ebp+6], cl
  00132	eb 22		 jmp	 SHORT $LN1@SetTitle_e@5
$LN91@SetTitle_e@5:
  00134	c6 45 f1 ec	 mov	 BYTE PTR __t$[ebp+5], -20 ; ffffffecH
  00138	eb 1c		 jmp	 SHORT $LN1@SetTitle_e@5
$LN92@SetTitle_e@5:
  0013a	c6 45 f0 ed	 mov	 BYTE PTR __t$[ebp+4], -19 ; ffffffedH
  0013e	eb 16		 jmp	 SHORT $LN1@SetTitle_e@5
$LN93@SetTitle_e@5:
  00140	c6 45 ef ea	 mov	 BYTE PTR __t$[ebp+3], -22 ; ffffffeaH
  00144	eb 10		 jmp	 SHORT $LN1@SetTitle_e@5
$LN94@SetTitle_e@5:
  00146	c6 45 ee eb	 mov	 BYTE PTR __t$[ebp+2], -21 ; ffffffebH
  0014a	eb 0a		 jmp	 SHORT $LN1@SetTitle_e@5
$LN95@SetTitle_e@5:
  0014c	c6 45 ed ec	 mov	 BYTE PTR __t$[ebp+1], -20 ; ffffffecH
  00150	eb 04		 jmp	 SHORT $LN1@SetTitle_e@5
$LN96@SetTitle_e@5:
  00152	c6 45 ec ed	 mov	 BYTE PTR __t$[ebp], -19	; ffffffedH
$LN1@SetTitle_e@5:
  00156	6a 02		 push	 2
  00158	8d 45 ec	 lea	 eax, DWORD PTR __t$[ebp]
  0015b	c6 45 f7 00	 mov	 BYTE PTR __t$[ebp+11], 0
  0015f	5a		 pop	 edx
$LL104@SetTitle_e@5:
  00160	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00166	83 c0 04	 add	 eax, 4
  00169	4a		 dec	 edx
  0016a	75 f4		 jne	 SHORT $LL104@SetTitle_e@5
  0016c	6a 08		 push	 8
  0016e	58		 pop	 eax
$LL101@SetTitle_e@5:
  0016f	8b c8		 mov	 ecx, eax
  00171	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00177	79 05		 jns	 SHORT $LN111@SetTitle_e@5
  00179	49		 dec	 ecx
  0017a	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0017d	41		 inc	 ecx
$LN111@SetTitle_e@5:
  0017e	b2 ed		 mov	 dl, -19			; ffffffedH
  00180	2a d1		 sub	 dl, cl
  00182	30 54 05 ec	 xor	 BYTE PTR __t$[ebp+eax], dl
  00186	40		 inc	 eax
  00187	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0018a	7c e3		 jl	 SHORT $LL101@SetTitle_e@5

; 190  : 		SetTitle(_t);

  0018c	8d 45 ec	 lea	 eax, DWORD PTR __t$[ebp]
  0018f	50		 push	 eax
  00190	8b ce		 mov	 ecx, esi
  00192	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z

; 191  : 	}

  00198	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0019b	33 cd		 xor	 ecx, ebp
  0019d	5e		 pop	 esi
  0019e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a3	c9		 leave
  001a4	c2 04 00	 ret	 4
??$SetTitle_e@$0M@@ioINILoader@@QAEXAAY0M@$$CBD@Z ENDP	; ioINILoader::SetTitle_e<12>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadInt_e@$0M@@ioINILoader@@QAEHAAY0M@$$CBDH@Z ; ioINILoader::LoadInt_e<12>
; Function compile flags: /Ogsp
;	COMDAT ??$LoadInt_e@$0M@@ioINILoader@@QAEHAAY0M@$$CBDH@Z
_TEXT	SEGMENT
__k$ = -20						; size = 12
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_i$ = 12						; size = 4
??$LoadInt_e@$0M@@ioINILoader@@QAEHAAY0M@$$CBDH@Z PROC	; ioINILoader::LoadInt_e<12>, COMDAT
; _this$ = ecx

; 118  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 119  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	84 d2		 test	 dl, dl
  0001a	0f 84 32 01 00
	00		 je	 $LN96@LoadInt_e@8
  00020	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00023	88 55 ec	 mov	 BYTE PTR __k$[ebp], dl
  00026	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00029	84 d2		 test	 dl, dl
  0002b	0f 84 1b 01 00
	00		 je	 $LN95@LoadInt_e@8
  00031	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00034	88 55 ed	 mov	 BYTE PTR __k$[ebp+1], dl
  00037	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003a	84 d2		 test	 dl, dl
  0003c	0f 84 04 01 00
	00		 je	 $LN94@LoadInt_e@8
  00042	b1 eb		 mov	 cl, -21			; ffffffebH
  00044	32 d1		 xor	 dl, cl
  00046	88 55 ee	 mov	 BYTE PTR __k$[ebp+2], dl
  00049	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004c	84 d2		 test	 dl, dl
  0004e	0f 84 ec 00 00
	00		 je	 $LN93@LoadInt_e@8
  00054	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00057	88 55 ef	 mov	 BYTE PTR __k$[ebp+3], dl
  0005a	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005d	84 d2		 test	 dl, dl
  0005f	0f 84 d5 00 00
	00		 je	 $LN92@LoadInt_e@8
  00065	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00068	88 55 f0	 mov	 BYTE PTR __k$[ebp+4], dl
  0006b	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006e	84 d2		 test	 dl, dl
  00070	0f 84 be 00 00
	00		 je	 $LN91@LoadInt_e@8
  00076	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00079	88 55 f1	 mov	 BYTE PTR __k$[ebp+5], dl
  0007c	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0007f	84 d2		 test	 dl, dl
  00081	0f 84 a8 00 00
	00		 je	 $LN90@LoadInt_e@8
  00087	32 d1		 xor	 dl, cl
  00089	88 55 f2	 mov	 BYTE PTR __k$[ebp+6], dl
  0008c	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0008f	84 d2		 test	 dl, dl
  00091	0f 84 92 00 00
	00		 je	 $LN89@LoadInt_e@8
  00097	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009a	88 55 f3	 mov	 BYTE PTR __k$[ebp+7], dl
  0009d	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a0	84 d2		 test	 dl, dl
  000a2	74 7f		 je	 SHORT $LN88@LoadInt_e@8
  000a4	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000a7	88 55 f4	 mov	 BYTE PTR __k$[ebp+8], dl
  000aa	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000ad	84 d2		 test	 dl, dl
  000af	74 6c		 je	 SHORT $LN87@LoadInt_e@8
  000b1	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000b4	88 55 f5	 mov	 BYTE PTR __k$[ebp+9], dl
  000b7	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000ba	84 d2		 test	 dl, dl
  000bc	74 5a		 je	 SHORT $LN86@LoadInt_e@8
  000be	32 d1		 xor	 dl, cl
  000c0	80 78 0b 00	 cmp	 BYTE PTR [eax+11], 0
  000c4	88 55 f6	 mov	 BYTE PTR __k$[ebp+10], dl
  000c7	0f 84 89 00 00
	00		 je	 $LN1@LoadInt_e@8
  000cd	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000d0	84 d2		 test	 dl, dl
  000d2	74 3e		 je	 SHORT $LN84@LoadInt_e@8
  000d4	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000d7	88 55 f8	 mov	 BYTE PTR __k$[ebp+12], dl
  000da	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000dd	84 d2		 test	 dl, dl
  000df	74 2b		 je	 SHORT $LN83@LoadInt_e@8
  000e1	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000e4	88 55 f9	 mov	 BYTE PTR __k$[ebp+13], dl
  000e7	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  000ea	84 d2		 test	 dl, dl
  000ec	74 19		 je	 SHORT $LN82@LoadInt_e@8
  000ee	8a 40 0f	 mov	 al, BYTE PTR [eax+15]
  000f1	32 d1		 xor	 dl, cl
  000f3	88 55 fa	 mov	 BYTE PTR __k$[ebp+14], dl
  000f6	84 c0		 test	 al, al
  000f8	74 07		 je	 SHORT $LN81@LoadInt_e@8
  000fa	34 ea		 xor	 al, -22			; ffffffeaH
  000fc	88 45 fb	 mov	 BYTE PTR __k$[ebp+15], al
  000ff	eb 55		 jmp	 SHORT $LN1@LoadInt_e@8
$LN81@LoadInt_e@8:
  00101	c6 45 fb ea	 mov	 BYTE PTR __k$[ebp+15], -22 ; ffffffeaH
  00105	eb 4f		 jmp	 SHORT $LN1@LoadInt_e@8
$LN82@LoadInt_e@8:
  00107	88 4d fa	 mov	 BYTE PTR __k$[ebp+14], cl
  0010a	eb 4a		 jmp	 SHORT $LN1@LoadInt_e@8
$LN83@LoadInt_e@8:
  0010c	c6 45 f9 ec	 mov	 BYTE PTR __k$[ebp+13], -20 ; ffffffecH
  00110	eb 44		 jmp	 SHORT $LN1@LoadInt_e@8
$LN84@LoadInt_e@8:
  00112	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  00116	eb 3e		 jmp	 SHORT $LN1@LoadInt_e@8
$LN86@LoadInt_e@8:
  00118	88 4d f6	 mov	 BYTE PTR __k$[ebp+10], cl
  0011b	eb 39		 jmp	 SHORT $LN1@LoadInt_e@8
$LN87@LoadInt_e@8:
  0011d	c6 45 f5 ec	 mov	 BYTE PTR __k$[ebp+9], -20 ; ffffffecH
  00121	eb 33		 jmp	 SHORT $LN1@LoadInt_e@8
$LN88@LoadInt_e@8:
  00123	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  00127	eb 2d		 jmp	 SHORT $LN1@LoadInt_e@8
$LN89@LoadInt_e@8:
  00129	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  0012d	eb 27		 jmp	 SHORT $LN1@LoadInt_e@8
$LN90@LoadInt_e@8:
  0012f	88 4d f2	 mov	 BYTE PTR __k$[ebp+6], cl
  00132	eb 22		 jmp	 SHORT $LN1@LoadInt_e@8
$LN91@LoadInt_e@8:
  00134	c6 45 f1 ec	 mov	 BYTE PTR __k$[ebp+5], -20 ; ffffffecH
  00138	eb 1c		 jmp	 SHORT $LN1@LoadInt_e@8
$LN92@LoadInt_e@8:
  0013a	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  0013e	eb 16		 jmp	 SHORT $LN1@LoadInt_e@8
$LN93@LoadInt_e@8:
  00140	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  00144	eb 10		 jmp	 SHORT $LN1@LoadInt_e@8
$LN94@LoadInt_e@8:
  00146	c6 45 ee eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  0014a	eb 0a		 jmp	 SHORT $LN1@LoadInt_e@8
$LN95@LoadInt_e@8:
  0014c	c6 45 ed ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  00150	eb 04		 jmp	 SHORT $LN1@LoadInt_e@8
$LN96@LoadInt_e@8:
  00152	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@LoadInt_e@8:
  00156	6a 02		 push	 2
  00158	8d 45 ec	 lea	 eax, DWORD PTR __k$[ebp]
  0015b	c6 45 f7 00	 mov	 BYTE PTR __k$[ebp+11], 0
  0015f	5a		 pop	 edx
$LL104@LoadInt_e@8:
  00160	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00166	83 c0 04	 add	 eax, 4
  00169	4a		 dec	 edx
  0016a	75 f4		 jne	 SHORT $LL104@LoadInt_e@8
  0016c	6a 08		 push	 8
  0016e	58		 pop	 eax
$LL101@LoadInt_e@8:
  0016f	8b c8		 mov	 ecx, eax
  00171	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00177	79 05		 jns	 SHORT $LN111@LoadInt_e@8
  00179	49		 dec	 ecx
  0017a	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0017d	41		 inc	 ecx
$LN111@LoadInt_e@8:
  0017e	b2 ed		 mov	 dl, -19			; ffffffedH
  00180	2a d1		 sub	 dl, cl
  00182	30 54 05 ec	 xor	 BYTE PTR __k$[ebp+eax], dl
  00186	40		 inc	 eax
  00187	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0018a	7c e3		 jl	 SHORT $LL101@LoadInt_e@8

; 120  : 		return LoadInt(_k, i);

  0018c	ff 75 0c	 push	 DWORD PTR _i$[ebp]
  0018f	8d 45 ec	 lea	 eax, DWORD PTR __k$[ebp]
  00192	50		 push	 eax
  00193	8b ce		 mov	 ecx, esi
  00195	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 121  : 	}

  0019b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0019e	33 cd		 xor	 ecx, ebp
  001a0	5e		 pop	 esi
  001a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a6	c9		 leave
  001a7	c2 08 00	 ret	 8
??$LoadInt_e@$0M@@ioINILoader@@QAEHAAY0M@$$CBDH@Z ENDP	; ioINILoader::LoadInt_e<12>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$SetTitle_e@$0N@@ioINILoader@@QAEXAAY0N@$$CBD@Z ; ioINILoader::SetTitle_e<13>
; Function compile flags: /Ogsp
;	COMDAT ??$SetTitle_e@$0N@@ioINILoader@@QAEXAAY0N@$$CBD@Z
_TEXT	SEGMENT
__t$ = -24						; size = 13
__$ArrayPad$ = -4					; size = 4
_t$ = 8							; size = 4
??$SetTitle_e@$0N@@ioINILoader@@QAEXAAY0N@$$CBD@Z PROC	; ioINILoader::SetTitle_e<13>, COMDAT
; _this$ = ecx

; 188  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]

; 189  : 		_ENCSTR(t, _t);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	84 d2		 test	 dl, dl
  0001a	0f 84 4d 01 00
	00		 je	 $LN96@SetTitle_e@6
  00020	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00023	88 55 e8	 mov	 BYTE PTR __t$[ebp], dl
  00026	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00029	84 d2		 test	 dl, dl
  0002b	0f 84 36 01 00
	00		 je	 $LN95@SetTitle_e@6
  00031	b1 ec		 mov	 cl, -20			; ffffffecH
  00033	32 d1		 xor	 dl, cl
  00035	88 55 e9	 mov	 BYTE PTR __t$[ebp+1], dl
  00038	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003b	84 d2		 test	 dl, dl
  0003d	0f 84 1e 01 00
	00		 je	 $LN94@SetTitle_e@6
  00043	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00046	88 55 ea	 mov	 BYTE PTR __t$[ebp+2], dl
  00049	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004c	84 d2		 test	 dl, dl
  0004e	0f 84 07 01 00
	00		 je	 $LN93@SetTitle_e@6
  00054	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00057	88 55 eb	 mov	 BYTE PTR __t$[ebp+3], dl
  0005a	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005d	84 d2		 test	 dl, dl
  0005f	0f 84 f0 00 00
	00		 je	 $LN92@SetTitle_e@6
  00065	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00068	88 55 ec	 mov	 BYTE PTR __t$[ebp+4], dl
  0006b	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006e	84 d2		 test	 dl, dl
  00070	0f 84 da 00 00
	00		 je	 $LN91@SetTitle_e@6
  00076	32 d1		 xor	 dl, cl
  00078	88 55 ed	 mov	 BYTE PTR __t$[ebp+5], dl
  0007b	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0007e	84 d2		 test	 dl, dl
  00080	0f 84 c4 00 00
	00		 je	 $LN90@SetTitle_e@6
  00086	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00089	88 55 ee	 mov	 BYTE PTR __t$[ebp+6], dl
  0008c	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0008f	84 d2		 test	 dl, dl
  00091	0f 84 ad 00 00
	00		 je	 $LN89@SetTitle_e@6
  00097	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009a	88 55 ef	 mov	 BYTE PTR __t$[ebp+7], dl
  0009d	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a0	84 d2		 test	 dl, dl
  000a2	0f 84 96 00 00
	00		 je	 $LN88@SetTitle_e@6
  000a8	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ab	88 55 f0	 mov	 BYTE PTR __t$[ebp+8], dl
  000ae	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b1	84 d2		 test	 dl, dl
  000b3	0f 84 80 00 00
	00		 je	 $LN87@SetTitle_e@6
  000b9	32 d1		 xor	 dl, cl
  000bb	88 55 f1	 mov	 BYTE PTR __t$[ebp+9], dl
  000be	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c1	84 d2		 test	 dl, dl
  000c3	74 6e		 je	 SHORT $LN86@SetTitle_e@6
  000c5	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000c8	88 55 f2	 mov	 BYTE PTR __t$[ebp+10], dl
  000cb	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000ce	84 d2		 test	 dl, dl
  000d0	74 5b		 je	 SHORT $LN85@SetTitle_e@6
  000d2	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000d5	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  000d9	88 55 f3	 mov	 BYTE PTR __t$[ebp+11], dl
  000dc	0f 84 8f 00 00
	00		 je	 $LN1@SetTitle_e@6
  000e2	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000e5	84 d2		 test	 dl, dl
  000e7	74 3f		 je	 SHORT $LN83@SetTitle_e@6
  000e9	32 d1		 xor	 dl, cl
  000eb	88 55 f5	 mov	 BYTE PTR __t$[ebp+13], dl
  000ee	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  000f1	84 d2		 test	 dl, dl
  000f3	74 2d		 je	 SHORT $LN82@SetTitle_e@6
  000f5	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000f8	88 55 f6	 mov	 BYTE PTR __t$[ebp+14], dl
  000fb	8a 50 0f	 mov	 dl, BYTE PTR [eax+15]
  000fe	84 d2		 test	 dl, dl
  00100	74 1a		 je	 SHORT $LN81@SetTitle_e@6
  00102	8a 40 10	 mov	 al, BYTE PTR [eax+16]
  00105	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00108	88 55 f7	 mov	 BYTE PTR __t$[ebp+15], dl
  0010b	84 c0		 test	 al, al
  0010d	74 07		 je	 SHORT $LN80@SetTitle_e@6
  0010f	34 ed		 xor	 al, -19			; ffffffedH
  00111	88 45 f8	 mov	 BYTE PTR __t$[ebp+16], al
  00114	eb 5b		 jmp	 SHORT $LN1@SetTitle_e@6
$LN80@SetTitle_e@6:
  00116	c6 45 f8 ed	 mov	 BYTE PTR __t$[ebp+16], -19 ; ffffffedH
  0011a	eb 55		 jmp	 SHORT $LN1@SetTitle_e@6
$LN81@SetTitle_e@6:
  0011c	c6 45 f7 ea	 mov	 BYTE PTR __t$[ebp+15], -22 ; ffffffeaH
  00120	eb 4f		 jmp	 SHORT $LN1@SetTitle_e@6
$LN82@SetTitle_e@6:
  00122	c6 45 f6 eb	 mov	 BYTE PTR __t$[ebp+14], -21 ; ffffffebH
  00126	eb 49		 jmp	 SHORT $LN1@SetTitle_e@6
$LN83@SetTitle_e@6:
  00128	88 4d f5	 mov	 BYTE PTR __t$[ebp+13], cl
  0012b	eb 44		 jmp	 SHORT $LN1@SetTitle_e@6
$LN85@SetTitle_e@6:
  0012d	c6 45 f3 ea	 mov	 BYTE PTR __t$[ebp+11], -22 ; ffffffeaH
  00131	eb 3e		 jmp	 SHORT $LN1@SetTitle_e@6
$LN86@SetTitle_e@6:
  00133	c6 45 f2 eb	 mov	 BYTE PTR __t$[ebp+10], -21 ; ffffffebH
  00137	eb 38		 jmp	 SHORT $LN1@SetTitle_e@6
$LN87@SetTitle_e@6:
  00139	88 4d f1	 mov	 BYTE PTR __t$[ebp+9], cl
  0013c	eb 33		 jmp	 SHORT $LN1@SetTitle_e@6
$LN88@SetTitle_e@6:
  0013e	c6 45 f0 ed	 mov	 BYTE PTR __t$[ebp+8], -19 ; ffffffedH
  00142	eb 2d		 jmp	 SHORT $LN1@SetTitle_e@6
$LN89@SetTitle_e@6:
  00144	c6 45 ef ea	 mov	 BYTE PTR __t$[ebp+7], -22 ; ffffffeaH
  00148	eb 27		 jmp	 SHORT $LN1@SetTitle_e@6
$LN90@SetTitle_e@6:
  0014a	c6 45 ee eb	 mov	 BYTE PTR __t$[ebp+6], -21 ; ffffffebH
  0014e	eb 21		 jmp	 SHORT $LN1@SetTitle_e@6
$LN91@SetTitle_e@6:
  00150	88 4d ed	 mov	 BYTE PTR __t$[ebp+5], cl
  00153	eb 1c		 jmp	 SHORT $LN1@SetTitle_e@6
$LN92@SetTitle_e@6:
  00155	c6 45 ec ed	 mov	 BYTE PTR __t$[ebp+4], -19 ; ffffffedH
  00159	eb 16		 jmp	 SHORT $LN1@SetTitle_e@6
$LN93@SetTitle_e@6:
  0015b	c6 45 eb ea	 mov	 BYTE PTR __t$[ebp+3], -22 ; ffffffeaH
  0015f	eb 10		 jmp	 SHORT $LN1@SetTitle_e@6
$LN94@SetTitle_e@6:
  00161	c6 45 ea eb	 mov	 BYTE PTR __t$[ebp+2], -21 ; ffffffebH
  00165	eb 0a		 jmp	 SHORT $LN1@SetTitle_e@6
$LN95@SetTitle_e@6:
  00167	c6 45 e9 ec	 mov	 BYTE PTR __t$[ebp+1], -20 ; ffffffecH
  0016b	eb 04		 jmp	 SHORT $LN1@SetTitle_e@6
$LN96@SetTitle_e@6:
  0016d	c6 45 e8 ed	 mov	 BYTE PTR __t$[ebp], -19	; ffffffedH
$LN1@SetTitle_e@6:
  00171	6a 03		 push	 3
  00173	8d 45 e8	 lea	 eax, DWORD PTR __t$[ebp]
  00176	c6 45 f4 00	 mov	 BYTE PTR __t$[ebp+12], 0
  0017a	5a		 pop	 edx
$LL104@SetTitle_e@6:
  0017b	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00181	83 c0 04	 add	 eax, 4
  00184	4a		 dec	 edx
  00185	75 f4		 jne	 SHORT $LL104@SetTitle_e@6

; 190  : 		SetTitle(_t);

  00187	8d 45 e8	 lea	 eax, DWORD PTR __t$[ebp]
  0018a	50		 push	 eax
  0018b	8b ce		 mov	 ecx, esi
  0018d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z

; 191  : 	}

  00193	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00196	33 cd		 xor	 ecx, ebp
  00198	5e		 pop	 esi
  00199	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0019e	c9		 leave
  0019f	c2 04 00	 ret	 4
??$SetTitle_e@$0N@@ioINILoader@@QAEXAAY0N@$$CBD@Z ENDP	; ioINILoader::SetTitle_e<13>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadInt_e@$0BD@@ioINILoader@@QAEHAAY0BD@$$CBDH@Z ; ioINILoader::LoadInt_e<19>
; Function compile flags: /Ogsp
;	COMDAT ??$LoadInt_e@$0BD@@ioINILoader@@QAEHAAY0BD@$$CBDH@Z
_TEXT	SEGMENT
__k$ = -28						; size = 19
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_i$ = 12						; size = 4
??$LoadInt_e@$0BD@@ioINILoader@@QAEHAAY0BD@$$CBDH@Z PROC ; ioINILoader::LoadInt_e<19>, COMDAT
; _this$ = ecx

; 118  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 119  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	84 d2		 test	 dl, dl
  0001a	0f 84 cf 01 00
	00		 je	 $LN96@LoadInt_e@9
  00020	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00023	88 55 e4	 mov	 BYTE PTR __k$[ebp], dl
  00026	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00029	84 d2		 test	 dl, dl
  0002b	0f 84 b8 01 00
	00		 je	 $LN95@LoadInt_e@9
  00031	b1 ec		 mov	 cl, -20			; ffffffecH
  00033	32 d1		 xor	 dl, cl
  00035	88 55 e5	 mov	 BYTE PTR __k$[ebp+1], dl
  00038	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003b	84 d2		 test	 dl, dl
  0003d	0f 84 a0 01 00
	00		 je	 $LN94@LoadInt_e@9
  00043	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00046	88 55 e6	 mov	 BYTE PTR __k$[ebp+2], dl
  00049	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004c	84 d2		 test	 dl, dl
  0004e	0f 84 89 01 00
	00		 je	 $LN93@LoadInt_e@9
  00054	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00057	88 55 e7	 mov	 BYTE PTR __k$[ebp+3], dl
  0005a	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005d	84 d2		 test	 dl, dl
  0005f	0f 84 72 01 00
	00		 je	 $LN92@LoadInt_e@9
  00065	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00068	88 55 e8	 mov	 BYTE PTR __k$[ebp+4], dl
  0006b	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006e	84 d2		 test	 dl, dl
  00070	0f 84 5c 01 00
	00		 je	 $LN91@LoadInt_e@9
  00076	32 d1		 xor	 dl, cl
  00078	88 55 e9	 mov	 BYTE PTR __k$[ebp+5], dl
  0007b	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0007e	84 d2		 test	 dl, dl
  00080	0f 84 46 01 00
	00		 je	 $LN90@LoadInt_e@9
  00086	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00089	88 55 ea	 mov	 BYTE PTR __k$[ebp+6], dl
  0008c	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0008f	84 d2		 test	 dl, dl
  00091	0f 84 2f 01 00
	00		 je	 $LN89@LoadInt_e@9
  00097	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009a	88 55 eb	 mov	 BYTE PTR __k$[ebp+7], dl
  0009d	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a0	84 d2		 test	 dl, dl
  000a2	0f 84 18 01 00
	00		 je	 $LN88@LoadInt_e@9
  000a8	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ab	88 55 ec	 mov	 BYTE PTR __k$[ebp+8], dl
  000ae	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b1	84 d2		 test	 dl, dl
  000b3	0f 84 02 01 00
	00		 je	 $LN87@LoadInt_e@9
  000b9	32 d1		 xor	 dl, cl
  000bb	88 55 ed	 mov	 BYTE PTR __k$[ebp+9], dl
  000be	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c1	84 d2		 test	 dl, dl
  000c3	0f 84 ec 00 00
	00		 je	 $LN86@LoadInt_e@9
  000c9	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000cc	88 55 ee	 mov	 BYTE PTR __k$[ebp+10], dl
  000cf	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000d2	84 d2		 test	 dl, dl
  000d4	0f 84 d5 00 00
	00		 je	 $LN85@LoadInt_e@9
  000da	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000dd	88 55 ef	 mov	 BYTE PTR __k$[ebp+11], dl
  000e0	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000e3	84 d2		 test	 dl, dl
  000e5	0f 84 be 00 00
	00		 je	 $LN84@LoadInt_e@9
  000eb	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ee	88 55 f0	 mov	 BYTE PTR __k$[ebp+12], dl
  000f1	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000f4	84 d2		 test	 dl, dl
  000f6	0f 84 a8 00 00
	00		 je	 $LN83@LoadInt_e@9
  000fc	32 d1		 xor	 dl, cl
  000fe	88 55 f1	 mov	 BYTE PTR __k$[ebp+13], dl
  00101	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  00104	84 d2		 test	 dl, dl
  00106	0f 84 92 00 00
	00		 je	 $LN82@LoadInt_e@9
  0010c	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0010f	88 55 f2	 mov	 BYTE PTR __k$[ebp+14], dl
  00112	8a 50 0f	 mov	 dl, BYTE PTR [eax+15]
  00115	84 d2		 test	 dl, dl
  00117	74 7f		 je	 SHORT $LN81@LoadInt_e@9
  00119	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0011c	88 55 f3	 mov	 BYTE PTR __k$[ebp+15], dl
  0011f	8a 50 10	 mov	 dl, BYTE PTR [eax+16]
  00122	84 d2		 test	 dl, dl
  00124	74 6c		 je	 SHORT $LN80@LoadInt_e@9
  00126	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00129	88 55 f4	 mov	 BYTE PTR __k$[ebp+16], dl
  0012c	8a 50 11	 mov	 dl, BYTE PTR [eax+17]
  0012f	84 d2		 test	 dl, dl
  00131	74 5a		 je	 SHORT $LN79@LoadInt_e@9
  00133	32 d1		 xor	 dl, cl
  00135	80 78 12 00	 cmp	 BYTE PTR [eax+18], 0
  00139	88 55 f5	 mov	 BYTE PTR __k$[ebp+17], dl
  0013c	0f 84 b1 00 00
	00		 je	 $LN1@LoadInt_e@9
  00142	8a 50 13	 mov	 dl, BYTE PTR [eax+19]
  00145	84 d2		 test	 dl, dl
  00147	74 3e		 je	 SHORT $LN77@LoadInt_e@9
  00149	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0014c	88 55 f7	 mov	 BYTE PTR __k$[ebp+19], dl
  0014f	8a 50 14	 mov	 dl, BYTE PTR [eax+20]
  00152	84 d2		 test	 dl, dl
  00154	74 2b		 je	 SHORT $LN76@LoadInt_e@9
  00156	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00159	88 55 f8	 mov	 BYTE PTR __k$[ebp+20], dl
  0015c	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  0015f	84 d2		 test	 dl, dl
  00161	74 19		 je	 SHORT $LN75@LoadInt_e@9
  00163	8a 40 16	 mov	 al, BYTE PTR [eax+22]
  00166	32 d1		 xor	 dl, cl
  00168	88 55 f9	 mov	 BYTE PTR __k$[ebp+21], dl
  0016b	84 c0		 test	 al, al
  0016d	74 07		 je	 SHORT $LN74@LoadInt_e@9
  0016f	34 eb		 xor	 al, -21			; ffffffebH
  00171	88 45 fa	 mov	 BYTE PTR __k$[ebp+22], al
  00174	eb 7d		 jmp	 SHORT $LN1@LoadInt_e@9
$LN74@LoadInt_e@9:
  00176	c6 45 fa eb	 mov	 BYTE PTR __k$[ebp+22], -21 ; ffffffebH
  0017a	eb 77		 jmp	 SHORT $LN1@LoadInt_e@9
$LN75@LoadInt_e@9:
  0017c	88 4d f9	 mov	 BYTE PTR __k$[ebp+21], cl
  0017f	eb 72		 jmp	 SHORT $LN1@LoadInt_e@9
$LN76@LoadInt_e@9:
  00181	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+20], -19 ; ffffffedH
  00185	eb 6c		 jmp	 SHORT $LN1@LoadInt_e@9
$LN77@LoadInt_e@9:
  00187	c6 45 f7 ea	 mov	 BYTE PTR __k$[ebp+19], -22 ; ffffffeaH
  0018b	eb 66		 jmp	 SHORT $LN1@LoadInt_e@9
$LN79@LoadInt_e@9:
  0018d	88 4d f5	 mov	 BYTE PTR __k$[ebp+17], cl
  00190	eb 61		 jmp	 SHORT $LN1@LoadInt_e@9
$LN80@LoadInt_e@9:
  00192	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+16], -19 ; ffffffedH
  00196	eb 5b		 jmp	 SHORT $LN1@LoadInt_e@9
$LN81@LoadInt_e@9:
  00198	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+15], -22 ; ffffffeaH
  0019c	eb 55		 jmp	 SHORT $LN1@LoadInt_e@9
$LN82@LoadInt_e@9:
  0019e	c6 45 f2 eb	 mov	 BYTE PTR __k$[ebp+14], -21 ; ffffffebH
  001a2	eb 4f		 jmp	 SHORT $LN1@LoadInt_e@9
$LN83@LoadInt_e@9:
  001a4	88 4d f1	 mov	 BYTE PTR __k$[ebp+13], cl
  001a7	eb 4a		 jmp	 SHORT $LN1@LoadInt_e@9
$LN84@LoadInt_e@9:
  001a9	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  001ad	eb 44		 jmp	 SHORT $LN1@LoadInt_e@9
$LN85@LoadInt_e@9:
  001af	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  001b3	eb 3e		 jmp	 SHORT $LN1@LoadInt_e@9
$LN86@LoadInt_e@9:
  001b5	c6 45 ee eb	 mov	 BYTE PTR __k$[ebp+10], -21 ; ffffffebH
  001b9	eb 38		 jmp	 SHORT $LN1@LoadInt_e@9
$LN87@LoadInt_e@9:
  001bb	88 4d ed	 mov	 BYTE PTR __k$[ebp+9], cl
  001be	eb 33		 jmp	 SHORT $LN1@LoadInt_e@9
$LN88@LoadInt_e@9:
  001c0	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  001c4	eb 2d		 jmp	 SHORT $LN1@LoadInt_e@9
$LN89@LoadInt_e@9:
  001c6	c6 45 eb ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  001ca	eb 27		 jmp	 SHORT $LN1@LoadInt_e@9
$LN90@LoadInt_e@9:
  001cc	c6 45 ea eb	 mov	 BYTE PTR __k$[ebp+6], -21 ; ffffffebH
  001d0	eb 21		 jmp	 SHORT $LN1@LoadInt_e@9
$LN91@LoadInt_e@9:
  001d2	88 4d e9	 mov	 BYTE PTR __k$[ebp+5], cl
  001d5	eb 1c		 jmp	 SHORT $LN1@LoadInt_e@9
$LN92@LoadInt_e@9:
  001d7	c6 45 e8 ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  001db	eb 16		 jmp	 SHORT $LN1@LoadInt_e@9
$LN93@LoadInt_e@9:
  001dd	c6 45 e7 ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  001e1	eb 10		 jmp	 SHORT $LN1@LoadInt_e@9
$LN94@LoadInt_e@9:
  001e3	c6 45 e6 eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  001e7	eb 0a		 jmp	 SHORT $LN1@LoadInt_e@9
$LN95@LoadInt_e@9:
  001e9	c6 45 e5 ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  001ed	eb 04		 jmp	 SHORT $LN1@LoadInt_e@9
$LN96@LoadInt_e@9:
  001ef	c6 45 e4 ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@LoadInt_e@9:
  001f3	6a 04		 push	 4
  001f5	8d 45 e4	 lea	 eax, DWORD PTR __k$[ebp]
  001f8	c6 45 f6 00	 mov	 BYTE PTR __k$[ebp+18], 0
  001fc	5a		 pop	 edx
$LL104@LoadInt_e@9:
  001fd	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00203	83 c0 04	 add	 eax, 4
  00206	4a		 dec	 edx
  00207	75 f4		 jne	 SHORT $LL104@LoadInt_e@9
  00209	6a 10		 push	 16			; 00000010H
  0020b	58		 pop	 eax
$LL101@LoadInt_e@9:
  0020c	8b c8		 mov	 ecx, eax
  0020e	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00214	79 05		 jns	 SHORT $LN111@LoadInt_e@9
  00216	49		 dec	 ecx
  00217	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0021a	41		 inc	 ecx
$LN111@LoadInt_e@9:
  0021b	b2 ed		 mov	 dl, -19			; ffffffedH
  0021d	2a d1		 sub	 dl, cl
  0021f	30 54 05 e4	 xor	 BYTE PTR __k$[ebp+eax], dl
  00223	40		 inc	 eax
  00224	83 f8 12	 cmp	 eax, 18			; 00000012H
  00227	7c e3		 jl	 SHORT $LL101@LoadInt_e@9

; 120  : 		return LoadInt(_k, i);

  00229	ff 75 0c	 push	 DWORD PTR _i$[ebp]
  0022c	8d 45 e4	 lea	 eax, DWORD PTR __k$[ebp]
  0022f	50		 push	 eax
  00230	8b ce		 mov	 ecx, esi
  00232	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 121  : 	}

  00238	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0023b	33 cd		 xor	 ecx, ebp
  0023d	5e		 pop	 esi
  0023e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00243	c9		 leave
  00244	c2 08 00	 ret	 8
??$LoadInt_e@$0BD@@ioINILoader@@QAEHAAY0BD@$$CBDH@Z ENDP ; ioINILoader::LoadInt_e<19>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$SetTitle_e@$07@ioINILoader@@QAEXAAY07$$CBD@Z	; ioINILoader::SetTitle_e<8>
; Function compile flags: /Ogsp
;	COMDAT ??$SetTitle_e@$07@ioINILoader@@QAEXAAY07$$CBD@Z
_TEXT	SEGMENT
__t$ = -16						; size = 8
__$ArrayPad$ = -4					; size = 4
_t$ = 8							; size = 4
??$SetTitle_e@$07@ioINILoader@@QAEXAAY07$$CBD@Z PROC	; ioINILoader::SetTitle_e<8>, COMDAT
; _this$ = ecx

; 188  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]

; 189  : 		_ENCSTR(t, _t);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	84 d2		 test	 dl, dl
  0001a	0f 84 d7 00 00
	00		 je	 $LN96@SetTitle_e@7
  00020	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00023	88 55 f0	 mov	 BYTE PTR __t$[ebp], dl
  00026	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00029	84 d2		 test	 dl, dl
  0002b	0f 84 c0 00 00
	00		 je	 $LN95@SetTitle_e@7
  00031	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00034	88 55 f1	 mov	 BYTE PTR __t$[ebp+1], dl
  00037	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003a	84 d2		 test	 dl, dl
  0003c	0f 84 a9 00 00
	00		 je	 $LN94@SetTitle_e@7
  00042	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00045	88 55 f2	 mov	 BYTE PTR __t$[ebp+2], dl
  00048	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004b	84 d2		 test	 dl, dl
  0004d	0f 84 92 00 00
	00		 je	 $LN93@SetTitle_e@7
  00053	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00056	88 55 f3	 mov	 BYTE PTR __t$[ebp+3], dl
  00059	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005c	84 d2		 test	 dl, dl
  0005e	74 7f		 je	 SHORT $LN92@SetTitle_e@7
  00060	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00063	88 55 f4	 mov	 BYTE PTR __t$[ebp+4], dl
  00066	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00069	84 d2		 test	 dl, dl
  0006b	74 6c		 je	 SHORT $LN91@SetTitle_e@7
  0006d	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00070	88 55 f5	 mov	 BYTE PTR __t$[ebp+5], dl
  00073	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00076	84 d2		 test	 dl, dl
  00078	74 59		 je	 SHORT $LN90@SetTitle_e@7
  0007a	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0007d	80 78 07 00	 cmp	 BYTE PTR [eax+7], 0
  00081	88 55 f6	 mov	 BYTE PTR __t$[ebp+6], dl
  00084	74 75		 je	 SHORT $LN1@SetTitle_e@7
  00086	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  00089	84 d2		 test	 dl, dl
  0008b	74 40		 je	 SHORT $LN88@SetTitle_e@7
  0008d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00090	88 55 f8	 mov	 BYTE PTR __t$[ebp+8], dl
  00093	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  00096	84 d2		 test	 dl, dl
  00098	74 2d		 je	 SHORT $LN87@SetTitle_e@7
  0009a	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0009d	88 55 f9	 mov	 BYTE PTR __t$[ebp+9], dl
  000a0	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000a3	84 d2		 test	 dl, dl
  000a5	74 1a		 je	 SHORT $LN86@SetTitle_e@7
  000a7	8a 40 0b	 mov	 al, BYTE PTR [eax+11]
  000aa	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000ad	88 55 fa	 mov	 BYTE PTR __t$[ebp+10], dl
  000b0	84 c0		 test	 al, al
  000b2	74 07		 je	 SHORT $LN85@SetTitle_e@7
  000b4	34 ea		 xor	 al, -22			; ffffffeaH
  000b6	88 45 fb	 mov	 BYTE PTR __t$[ebp+11], al
  000b9	eb 40		 jmp	 SHORT $LN1@SetTitle_e@7
$LN85@SetTitle_e@7:
  000bb	c6 45 fb ea	 mov	 BYTE PTR __t$[ebp+11], -22 ; ffffffeaH
  000bf	eb 3a		 jmp	 SHORT $LN1@SetTitle_e@7
$LN86@SetTitle_e@7:
  000c1	c6 45 fa eb	 mov	 BYTE PTR __t$[ebp+10], -21 ; ffffffebH
  000c5	eb 34		 jmp	 SHORT $LN1@SetTitle_e@7
$LN87@SetTitle_e@7:
  000c7	c6 45 f9 ec	 mov	 BYTE PTR __t$[ebp+9], -20 ; ffffffecH
  000cb	eb 2e		 jmp	 SHORT $LN1@SetTitle_e@7
$LN88@SetTitle_e@7:
  000cd	c6 45 f8 ed	 mov	 BYTE PTR __t$[ebp+8], -19 ; ffffffedH
  000d1	eb 28		 jmp	 SHORT $LN1@SetTitle_e@7
$LN90@SetTitle_e@7:
  000d3	c6 45 f6 eb	 mov	 BYTE PTR __t$[ebp+6], -21 ; ffffffebH
  000d7	eb 22		 jmp	 SHORT $LN1@SetTitle_e@7
$LN91@SetTitle_e@7:
  000d9	c6 45 f5 ec	 mov	 BYTE PTR __t$[ebp+5], -20 ; ffffffecH
  000dd	eb 1c		 jmp	 SHORT $LN1@SetTitle_e@7
$LN92@SetTitle_e@7:
  000df	c6 45 f4 ed	 mov	 BYTE PTR __t$[ebp+4], -19 ; ffffffedH
  000e3	eb 16		 jmp	 SHORT $LN1@SetTitle_e@7
$LN93@SetTitle_e@7:
  000e5	c6 45 f3 ea	 mov	 BYTE PTR __t$[ebp+3], -22 ; ffffffeaH
  000e9	eb 10		 jmp	 SHORT $LN1@SetTitle_e@7
$LN94@SetTitle_e@7:
  000eb	c6 45 f2 eb	 mov	 BYTE PTR __t$[ebp+2], -21 ; ffffffebH
  000ef	eb 0a		 jmp	 SHORT $LN1@SetTitle_e@7
$LN95@SetTitle_e@7:
  000f1	c6 45 f1 ec	 mov	 BYTE PTR __t$[ebp+1], -20 ; ffffffecH
  000f5	eb 04		 jmp	 SHORT $LN1@SetTitle_e@7
$LN96@SetTitle_e@7:
  000f7	c6 45 f0 ed	 mov	 BYTE PTR __t$[ebp], -19	; ffffffedH
$LN1@SetTitle_e@7:
  000fb	81 75 f0 ed ec
	eb ea		 xor	 DWORD PTR __t$[ebp], -353637139 ; eaebecedH
  00102	6a 04		 push	 4
  00104	c6 45 f7 00	 mov	 BYTE PTR __t$[ebp+7], 0
  00108	58		 pop	 eax
$LL101@SetTitle_e@7:
  00109	8b c8		 mov	 ecx, eax
  0010b	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00111	79 05		 jns	 SHORT $LN111@SetTitle_e@7
  00113	49		 dec	 ecx
  00114	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00117	41		 inc	 ecx
$LN111@SetTitle_e@7:
  00118	b2 ed		 mov	 dl, -19			; ffffffedH
  0011a	2a d1		 sub	 dl, cl
  0011c	30 54 05 f0	 xor	 BYTE PTR __t$[ebp+eax], dl
  00120	40		 inc	 eax
  00121	83 f8 07	 cmp	 eax, 7
  00124	7c e3		 jl	 SHORT $LL101@SetTitle_e@7

; 190  : 		SetTitle(_t);

  00126	8d 45 f0	 lea	 eax, DWORD PTR __t$[ebp]
  00129	50		 push	 eax
  0012a	8b ce		 mov	 ecx, esi
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z

; 191  : 	}

  00132	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00135	33 cd		 xor	 ecx, ebp
  00137	5e		 pop	 esi
  00138	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013d	c9		 leave
  0013e	c2 04 00	 ret	 4
??$SetTitle_e@$07@ioINILoader@@QAEXAAY07$$CBD@Z ENDP	; ioINILoader::SetTitle_e<8>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadInt_e@$0BB@@ioINILoader@@QAEHAAY0BB@$$CBDH@Z ; ioINILoader::LoadInt_e<17>
; Function compile flags: /Ogsp
;	COMDAT ??$LoadInt_e@$0BB@@ioINILoader@@QAEHAAY0BB@$$CBDH@Z
_TEXT	SEGMENT
__k$ = -28						; size = 17
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_i$ = 12						; size = 4
??$LoadInt_e@$0BB@@ioINILoader@@QAEHAAY0BB@$$CBDH@Z PROC ; ioINILoader::LoadInt_e<17>, COMDAT
; _this$ = ecx

; 118  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 119  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	84 d2		 test	 dl, dl
  0001a	0f 84 a7 01 00
	00		 je	 $LN96@LoadInt_e@10
  00020	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00023	88 55 e4	 mov	 BYTE PTR __k$[ebp], dl
  00026	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00029	84 d2		 test	 dl, dl
  0002b	0f 84 90 01 00
	00		 je	 $LN95@LoadInt_e@10
  00031	b1 ec		 mov	 cl, -20			; ffffffecH
  00033	32 d1		 xor	 dl, cl
  00035	88 55 e5	 mov	 BYTE PTR __k$[ebp+1], dl
  00038	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003b	84 d2		 test	 dl, dl
  0003d	0f 84 78 01 00
	00		 je	 $LN94@LoadInt_e@10
  00043	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00046	88 55 e6	 mov	 BYTE PTR __k$[ebp+2], dl
  00049	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004c	84 d2		 test	 dl, dl
  0004e	0f 84 61 01 00
	00		 je	 $LN93@LoadInt_e@10
  00054	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00057	88 55 e7	 mov	 BYTE PTR __k$[ebp+3], dl
  0005a	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005d	84 d2		 test	 dl, dl
  0005f	0f 84 4a 01 00
	00		 je	 $LN92@LoadInt_e@10
  00065	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00068	88 55 e8	 mov	 BYTE PTR __k$[ebp+4], dl
  0006b	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006e	84 d2		 test	 dl, dl
  00070	0f 84 34 01 00
	00		 je	 $LN91@LoadInt_e@10
  00076	32 d1		 xor	 dl, cl
  00078	88 55 e9	 mov	 BYTE PTR __k$[ebp+5], dl
  0007b	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0007e	84 d2		 test	 dl, dl
  00080	0f 84 1e 01 00
	00		 je	 $LN90@LoadInt_e@10
  00086	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00089	88 55 ea	 mov	 BYTE PTR __k$[ebp+6], dl
  0008c	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0008f	84 d2		 test	 dl, dl
  00091	0f 84 07 01 00
	00		 je	 $LN89@LoadInt_e@10
  00097	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009a	88 55 eb	 mov	 BYTE PTR __k$[ebp+7], dl
  0009d	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a0	84 d2		 test	 dl, dl
  000a2	0f 84 f0 00 00
	00		 je	 $LN88@LoadInt_e@10
  000a8	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ab	88 55 ec	 mov	 BYTE PTR __k$[ebp+8], dl
  000ae	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b1	84 d2		 test	 dl, dl
  000b3	0f 84 da 00 00
	00		 je	 $LN87@LoadInt_e@10
  000b9	32 d1		 xor	 dl, cl
  000bb	88 55 ed	 mov	 BYTE PTR __k$[ebp+9], dl
  000be	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c1	84 d2		 test	 dl, dl
  000c3	0f 84 c4 00 00
	00		 je	 $LN86@LoadInt_e@10
  000c9	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000cc	88 55 ee	 mov	 BYTE PTR __k$[ebp+10], dl
  000cf	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000d2	84 d2		 test	 dl, dl
  000d4	0f 84 ad 00 00
	00		 je	 $LN85@LoadInt_e@10
  000da	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000dd	88 55 ef	 mov	 BYTE PTR __k$[ebp+11], dl
  000e0	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000e3	84 d2		 test	 dl, dl
  000e5	0f 84 96 00 00
	00		 je	 $LN84@LoadInt_e@10
  000eb	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ee	88 55 f0	 mov	 BYTE PTR __k$[ebp+12], dl
  000f1	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000f4	84 d2		 test	 dl, dl
  000f6	0f 84 80 00 00
	00		 je	 $LN83@LoadInt_e@10
  000fc	32 d1		 xor	 dl, cl
  000fe	88 55 f1	 mov	 BYTE PTR __k$[ebp+13], dl
  00101	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  00104	84 d2		 test	 dl, dl
  00106	74 6e		 je	 SHORT $LN82@LoadInt_e@10
  00108	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0010b	88 55 f2	 mov	 BYTE PTR __k$[ebp+14], dl
  0010e	8a 50 0f	 mov	 dl, BYTE PTR [eax+15]
  00111	84 d2		 test	 dl, dl
  00113	74 5b		 je	 SHORT $LN81@LoadInt_e@10
  00115	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00118	80 78 10 00	 cmp	 BYTE PTR [eax+16], 0
  0011c	88 55 f3	 mov	 BYTE PTR __k$[ebp+15], dl
  0011f	0f 84 a6 00 00
	00		 je	 $LN1@LoadInt_e@10
  00125	8a 50 11	 mov	 dl, BYTE PTR [eax+17]
  00128	84 d2		 test	 dl, dl
  0012a	74 3f		 je	 SHORT $LN79@LoadInt_e@10
  0012c	32 d1		 xor	 dl, cl
  0012e	88 55 f5	 mov	 BYTE PTR __k$[ebp+17], dl
  00131	8a 50 12	 mov	 dl, BYTE PTR [eax+18]
  00134	84 d2		 test	 dl, dl
  00136	74 2d		 je	 SHORT $LN78@LoadInt_e@10
  00138	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0013b	88 55 f6	 mov	 BYTE PTR __k$[ebp+18], dl
  0013e	8a 50 13	 mov	 dl, BYTE PTR [eax+19]
  00141	84 d2		 test	 dl, dl
  00143	74 1a		 je	 SHORT $LN77@LoadInt_e@10
  00145	8a 40 14	 mov	 al, BYTE PTR [eax+20]
  00148	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0014b	88 55 f7	 mov	 BYTE PTR __k$[ebp+19], dl
  0014e	84 c0		 test	 al, al
  00150	74 07		 je	 SHORT $LN76@LoadInt_e@10
  00152	34 ed		 xor	 al, -19			; ffffffedH
  00154	88 45 f8	 mov	 BYTE PTR __k$[ebp+20], al
  00157	eb 72		 jmp	 SHORT $LN1@LoadInt_e@10
$LN76@LoadInt_e@10:
  00159	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+20], -19 ; ffffffedH
  0015d	eb 6c		 jmp	 SHORT $LN1@LoadInt_e@10
$LN77@LoadInt_e@10:
  0015f	c6 45 f7 ea	 mov	 BYTE PTR __k$[ebp+19], -22 ; ffffffeaH
  00163	eb 66		 jmp	 SHORT $LN1@LoadInt_e@10
$LN78@LoadInt_e@10:
  00165	c6 45 f6 eb	 mov	 BYTE PTR __k$[ebp+18], -21 ; ffffffebH
  00169	eb 60		 jmp	 SHORT $LN1@LoadInt_e@10
$LN79@LoadInt_e@10:
  0016b	88 4d f5	 mov	 BYTE PTR __k$[ebp+17], cl
  0016e	eb 5b		 jmp	 SHORT $LN1@LoadInt_e@10
$LN81@LoadInt_e@10:
  00170	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+15], -22 ; ffffffeaH
  00174	eb 55		 jmp	 SHORT $LN1@LoadInt_e@10
$LN82@LoadInt_e@10:
  00176	c6 45 f2 eb	 mov	 BYTE PTR __k$[ebp+14], -21 ; ffffffebH
  0017a	eb 4f		 jmp	 SHORT $LN1@LoadInt_e@10
$LN83@LoadInt_e@10:
  0017c	88 4d f1	 mov	 BYTE PTR __k$[ebp+13], cl
  0017f	eb 4a		 jmp	 SHORT $LN1@LoadInt_e@10
$LN84@LoadInt_e@10:
  00181	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  00185	eb 44		 jmp	 SHORT $LN1@LoadInt_e@10
$LN85@LoadInt_e@10:
  00187	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  0018b	eb 3e		 jmp	 SHORT $LN1@LoadInt_e@10
$LN86@LoadInt_e@10:
  0018d	c6 45 ee eb	 mov	 BYTE PTR __k$[ebp+10], -21 ; ffffffebH
  00191	eb 38		 jmp	 SHORT $LN1@LoadInt_e@10
$LN87@LoadInt_e@10:
  00193	88 4d ed	 mov	 BYTE PTR __k$[ebp+9], cl
  00196	eb 33		 jmp	 SHORT $LN1@LoadInt_e@10
$LN88@LoadInt_e@10:
  00198	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  0019c	eb 2d		 jmp	 SHORT $LN1@LoadInt_e@10
$LN89@LoadInt_e@10:
  0019e	c6 45 eb ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  001a2	eb 27		 jmp	 SHORT $LN1@LoadInt_e@10
$LN90@LoadInt_e@10:
  001a4	c6 45 ea eb	 mov	 BYTE PTR __k$[ebp+6], -21 ; ffffffebH
  001a8	eb 21		 jmp	 SHORT $LN1@LoadInt_e@10
$LN91@LoadInt_e@10:
  001aa	88 4d e9	 mov	 BYTE PTR __k$[ebp+5], cl
  001ad	eb 1c		 jmp	 SHORT $LN1@LoadInt_e@10
$LN92@LoadInt_e@10:
  001af	c6 45 e8 ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  001b3	eb 16		 jmp	 SHORT $LN1@LoadInt_e@10
$LN93@LoadInt_e@10:
  001b5	c6 45 e7 ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  001b9	eb 10		 jmp	 SHORT $LN1@LoadInt_e@10
$LN94@LoadInt_e@10:
  001bb	c6 45 e6 eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  001bf	eb 0a		 jmp	 SHORT $LN1@LoadInt_e@10
$LN95@LoadInt_e@10:
  001c1	c6 45 e5 ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  001c5	eb 04		 jmp	 SHORT $LN1@LoadInt_e@10
$LN96@LoadInt_e@10:
  001c7	c6 45 e4 ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@LoadInt_e@10:
  001cb	6a 04		 push	 4
  001cd	8d 45 e4	 lea	 eax, DWORD PTR __k$[ebp]
  001d0	c6 45 f4 00	 mov	 BYTE PTR __k$[ebp+16], 0
  001d4	5a		 pop	 edx
$LL104@LoadInt_e@10:
  001d5	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  001db	83 c0 04	 add	 eax, 4
  001de	4a		 dec	 edx
  001df	75 f4		 jne	 SHORT $LL104@LoadInt_e@10

; 120  : 		return LoadInt(_k, i);

  001e1	ff 75 0c	 push	 DWORD PTR _i$[ebp]
  001e4	8d 45 e4	 lea	 eax, DWORD PTR __k$[ebp]
  001e7	50		 push	 eax
  001e8	8b ce		 mov	 ecx, esi
  001ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 121  : 	}

  001f0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f3	33 cd		 xor	 ecx, ebp
  001f5	5e		 pop	 esi
  001f6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001fb	c9		 leave
  001fc	c2 08 00	 ret	 8
??$LoadInt_e@$0BB@@ioINILoader@@QAEHAAY0BB@$$CBDH@Z ENDP ; ioINILoader::LoadInt_e<17>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$SetTitle_e@$05@ioINILoader@@QAEXAAY05$$CBD@Z	; ioINILoader::SetTitle_e<6>
; Function compile flags: /Ogsp
;	COMDAT ??$SetTitle_e@$05@ioINILoader@@QAEXAAY05$$CBD@Z
_TEXT	SEGMENT
__t$ = -16						; size = 6
__$ArrayPad$ = -4					; size = 4
_t$ = 8							; size = 4
??$SetTitle_e@$05@ioINILoader@@QAEXAAY05$$CBD@Z PROC	; ioINILoader::SetTitle_e<6>, COMDAT
; _this$ = ecx

; 188  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]

; 189  : 		_ENCSTR(t, _t);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	84 d2		 test	 dl, dl
  00017	0f 84 a9 00 00
	00		 je	 $LN96@SetTitle_e@8
  0001d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00020	88 55 f0	 mov	 BYTE PTR __t$[ebp], dl
  00023	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00026	84 d2		 test	 dl, dl
  00028	0f 84 92 00 00
	00		 je	 $LN95@SetTitle_e@8
  0002e	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00031	88 55 f1	 mov	 BYTE PTR __t$[ebp+1], dl
  00034	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  00037	84 d2		 test	 dl, dl
  00039	74 7f		 je	 SHORT $LN94@SetTitle_e@8
  0003b	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0003e	88 55 f2	 mov	 BYTE PTR __t$[ebp+2], dl
  00041	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  00044	84 d2		 test	 dl, dl
  00046	74 6c		 je	 SHORT $LN93@SetTitle_e@8
  00048	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0004b	88 55 f3	 mov	 BYTE PTR __t$[ebp+3], dl
  0004e	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  00051	84 d2		 test	 dl, dl
  00053	74 59		 je	 SHORT $LN92@SetTitle_e@8
  00055	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00058	80 78 05 00	 cmp	 BYTE PTR [eax+5], 0
  0005c	88 55 f4	 mov	 BYTE PTR __t$[ebp+4], dl
  0005f	74 69		 je	 SHORT $LN1@SetTitle_e@8
  00061	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00064	84 d2		 test	 dl, dl
  00066	74 40		 je	 SHORT $LN90@SetTitle_e@8
  00068	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0006b	88 55 f6	 mov	 BYTE PTR __t$[ebp+6], dl
  0006e	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00071	84 d2		 test	 dl, dl
  00073	74 2d		 je	 SHORT $LN89@SetTitle_e@8
  00075	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00078	88 55 f7	 mov	 BYTE PTR __t$[ebp+7], dl
  0007b	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  0007e	84 d2		 test	 dl, dl
  00080	74 1a		 je	 SHORT $LN88@SetTitle_e@8
  00082	8a 40 09	 mov	 al, BYTE PTR [eax+9]
  00085	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00088	88 55 f8	 mov	 BYTE PTR __t$[ebp+8], dl
  0008b	84 c0		 test	 al, al
  0008d	74 07		 je	 SHORT $LN87@SetTitle_e@8
  0008f	34 ec		 xor	 al, -20			; ffffffecH
  00091	88 45 f9	 mov	 BYTE PTR __t$[ebp+9], al
  00094	eb 34		 jmp	 SHORT $LN1@SetTitle_e@8
$LN87@SetTitle_e@8:
  00096	c6 45 f9 ec	 mov	 BYTE PTR __t$[ebp+9], -20 ; ffffffecH
  0009a	eb 2e		 jmp	 SHORT $LN1@SetTitle_e@8
$LN88@SetTitle_e@8:
  0009c	c6 45 f8 ed	 mov	 BYTE PTR __t$[ebp+8], -19 ; ffffffedH
  000a0	eb 28		 jmp	 SHORT $LN1@SetTitle_e@8
$LN89@SetTitle_e@8:
  000a2	c6 45 f7 ea	 mov	 BYTE PTR __t$[ebp+7], -22 ; ffffffeaH
  000a6	eb 22		 jmp	 SHORT $LN1@SetTitle_e@8
$LN90@SetTitle_e@8:
  000a8	c6 45 f6 eb	 mov	 BYTE PTR __t$[ebp+6], -21 ; ffffffebH
  000ac	eb 1c		 jmp	 SHORT $LN1@SetTitle_e@8
$LN92@SetTitle_e@8:
  000ae	c6 45 f4 ed	 mov	 BYTE PTR __t$[ebp+4], -19 ; ffffffedH
  000b2	eb 16		 jmp	 SHORT $LN1@SetTitle_e@8
$LN93@SetTitle_e@8:
  000b4	c6 45 f3 ea	 mov	 BYTE PTR __t$[ebp+3], -22 ; ffffffeaH
  000b8	eb 10		 jmp	 SHORT $LN1@SetTitle_e@8
$LN94@SetTitle_e@8:
  000ba	c6 45 f2 eb	 mov	 BYTE PTR __t$[ebp+2], -21 ; ffffffebH
  000be	eb 0a		 jmp	 SHORT $LN1@SetTitle_e@8
$LN95@SetTitle_e@8:
  000c0	c6 45 f1 ec	 mov	 BYTE PTR __t$[ebp+1], -20 ; ffffffecH
  000c4	eb 04		 jmp	 SHORT $LN1@SetTitle_e@8
$LN96@SetTitle_e@8:
  000c6	c6 45 f0 ed	 mov	 BYTE PTR __t$[ebp], -19	; ffffffedH
$LN1@SetTitle_e@8:
  000ca	81 75 f0 ed ec
	eb ea		 xor	 DWORD PTR __t$[ebp], -353637139 ; eaebecedH
  000d1	80 75 f4 ed	 xor	 BYTE PTR __t$[ebp+4], -19 ; ffffffedH

; 190  : 		SetTitle(_t);

  000d5	8d 45 f0	 lea	 eax, DWORD PTR __t$[ebp]
  000d8	50		 push	 eax
  000d9	c6 45 f5 00	 mov	 BYTE PTR __t$[ebp+5], 0
  000dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z

; 191  : 	}

  000e3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e6	33 cd		 xor	 ecx, ebp
  000e8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ed	c9		 leave
  000ee	c2 04 00	 ret	 4
??$SetTitle_e@$05@ioINILoader@@QAEXAAY05$$CBD@Z ENDP	; ioINILoader::SetTitle_e<6>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$SetTitle_e@$0O@@ioINILoader@@QAEXAAY0O@$$CBD@Z ; ioINILoader::SetTitle_e<14>
; Function compile flags: /Ogsp
;	COMDAT ??$SetTitle_e@$0O@@ioINILoader@@QAEXAAY0O@$$CBD@Z
_TEXT	SEGMENT
__t$ = -24						; size = 14
__$ArrayPad$ = -4					; size = 4
_t$ = 8							; size = 4
??$SetTitle_e@$0O@@ioINILoader@@QAEXAAY0O@$$CBD@Z PROC	; ioINILoader::SetTitle_e<14>, COMDAT
; _this$ = ecx

; 188  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]

; 189  : 		_ENCSTR(t, _t);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	84 d2		 test	 dl, dl
  0001a	0f 84 64 01 00
	00		 je	 $LN96@SetTitle_e@9
  00020	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00023	88 55 e8	 mov	 BYTE PTR __t$[ebp], dl
  00026	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00029	84 d2		 test	 dl, dl
  0002b	0f 84 4d 01 00
	00		 je	 $LN95@SetTitle_e@9
  00031	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00034	88 55 e9	 mov	 BYTE PTR __t$[ebp+1], dl
  00037	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003a	84 d2		 test	 dl, dl
  0003c	0f 84 36 01 00
	00		 je	 $LN94@SetTitle_e@9
  00042	b1 eb		 mov	 cl, -21			; ffffffebH
  00044	32 d1		 xor	 dl, cl
  00046	88 55 ea	 mov	 BYTE PTR __t$[ebp+2], dl
  00049	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004c	84 d2		 test	 dl, dl
  0004e	0f 84 1e 01 00
	00		 je	 $LN93@SetTitle_e@9
  00054	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00057	88 55 eb	 mov	 BYTE PTR __t$[ebp+3], dl
  0005a	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005d	84 d2		 test	 dl, dl
  0005f	0f 84 07 01 00
	00		 je	 $LN92@SetTitle_e@9
  00065	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00068	88 55 ec	 mov	 BYTE PTR __t$[ebp+4], dl
  0006b	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006e	84 d2		 test	 dl, dl
  00070	0f 84 f0 00 00
	00		 je	 $LN91@SetTitle_e@9
  00076	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00079	88 55 ed	 mov	 BYTE PTR __t$[ebp+5], dl
  0007c	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0007f	84 d2		 test	 dl, dl
  00081	0f 84 da 00 00
	00		 je	 $LN90@SetTitle_e@9
  00087	32 d1		 xor	 dl, cl
  00089	88 55 ee	 mov	 BYTE PTR __t$[ebp+6], dl
  0008c	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0008f	84 d2		 test	 dl, dl
  00091	0f 84 c4 00 00
	00		 je	 $LN89@SetTitle_e@9
  00097	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009a	88 55 ef	 mov	 BYTE PTR __t$[ebp+7], dl
  0009d	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a0	84 d2		 test	 dl, dl
  000a2	0f 84 ad 00 00
	00		 je	 $LN88@SetTitle_e@9
  000a8	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ab	88 55 f0	 mov	 BYTE PTR __t$[ebp+8], dl
  000ae	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b1	84 d2		 test	 dl, dl
  000b3	0f 84 96 00 00
	00		 je	 $LN87@SetTitle_e@9
  000b9	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000bc	88 55 f1	 mov	 BYTE PTR __t$[ebp+9], dl
  000bf	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c2	84 d2		 test	 dl, dl
  000c4	0f 84 80 00 00
	00		 je	 $LN86@SetTitle_e@9
  000ca	32 d1		 xor	 dl, cl
  000cc	88 55 f2	 mov	 BYTE PTR __t$[ebp+10], dl
  000cf	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000d2	84 d2		 test	 dl, dl
  000d4	74 6e		 je	 SHORT $LN85@SetTitle_e@9
  000d6	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000d9	88 55 f3	 mov	 BYTE PTR __t$[ebp+11], dl
  000dc	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000df	84 d2		 test	 dl, dl
  000e1	74 5b		 je	 SHORT $LN84@SetTitle_e@9
  000e3	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000e6	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000ea	88 55 f4	 mov	 BYTE PTR __t$[ebp+12], dl
  000ed	0f 84 95 00 00
	00		 je	 $LN1@SetTitle_e@9
  000f3	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  000f6	84 d2		 test	 dl, dl
  000f8	74 3f		 je	 SHORT $LN82@SetTitle_e@9
  000fa	32 d1		 xor	 dl, cl
  000fc	88 55 f6	 mov	 BYTE PTR __t$[ebp+14], dl
  000ff	8a 50 0f	 mov	 dl, BYTE PTR [eax+15]
  00102	84 d2		 test	 dl, dl
  00104	74 2d		 je	 SHORT $LN81@SetTitle_e@9
  00106	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00109	88 55 f7	 mov	 BYTE PTR __t$[ebp+15], dl
  0010c	8a 50 10	 mov	 dl, BYTE PTR [eax+16]
  0010f	84 d2		 test	 dl, dl
  00111	74 1a		 je	 SHORT $LN80@SetTitle_e@9
  00113	8a 40 11	 mov	 al, BYTE PTR [eax+17]
  00116	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00119	88 55 f8	 mov	 BYTE PTR __t$[ebp+16], dl
  0011c	84 c0		 test	 al, al
  0011e	74 07		 je	 SHORT $LN79@SetTitle_e@9
  00120	34 ec		 xor	 al, -20			; ffffffecH
  00122	88 45 f9	 mov	 BYTE PTR __t$[ebp+17], al
  00125	eb 61		 jmp	 SHORT $LN1@SetTitle_e@9
$LN79@SetTitle_e@9:
  00127	c6 45 f9 ec	 mov	 BYTE PTR __t$[ebp+17], -20 ; ffffffecH
  0012b	eb 5b		 jmp	 SHORT $LN1@SetTitle_e@9
$LN80@SetTitle_e@9:
  0012d	c6 45 f8 ed	 mov	 BYTE PTR __t$[ebp+16], -19 ; ffffffedH
  00131	eb 55		 jmp	 SHORT $LN1@SetTitle_e@9
$LN81@SetTitle_e@9:
  00133	c6 45 f7 ea	 mov	 BYTE PTR __t$[ebp+15], -22 ; ffffffeaH
  00137	eb 4f		 jmp	 SHORT $LN1@SetTitle_e@9
$LN82@SetTitle_e@9:
  00139	88 4d f6	 mov	 BYTE PTR __t$[ebp+14], cl
  0013c	eb 4a		 jmp	 SHORT $LN1@SetTitle_e@9
$LN84@SetTitle_e@9:
  0013e	c6 45 f4 ed	 mov	 BYTE PTR __t$[ebp+12], -19 ; ffffffedH
  00142	eb 44		 jmp	 SHORT $LN1@SetTitle_e@9
$LN85@SetTitle_e@9:
  00144	c6 45 f3 ea	 mov	 BYTE PTR __t$[ebp+11], -22 ; ffffffeaH
  00148	eb 3e		 jmp	 SHORT $LN1@SetTitle_e@9
$LN86@SetTitle_e@9:
  0014a	88 4d f2	 mov	 BYTE PTR __t$[ebp+10], cl
  0014d	eb 39		 jmp	 SHORT $LN1@SetTitle_e@9
$LN87@SetTitle_e@9:
  0014f	c6 45 f1 ec	 mov	 BYTE PTR __t$[ebp+9], -20 ; ffffffecH
  00153	eb 33		 jmp	 SHORT $LN1@SetTitle_e@9
$LN88@SetTitle_e@9:
  00155	c6 45 f0 ed	 mov	 BYTE PTR __t$[ebp+8], -19 ; ffffffedH
  00159	eb 2d		 jmp	 SHORT $LN1@SetTitle_e@9
$LN89@SetTitle_e@9:
  0015b	c6 45 ef ea	 mov	 BYTE PTR __t$[ebp+7], -22 ; ffffffeaH
  0015f	eb 27		 jmp	 SHORT $LN1@SetTitle_e@9
$LN90@SetTitle_e@9:
  00161	88 4d ee	 mov	 BYTE PTR __t$[ebp+6], cl
  00164	eb 22		 jmp	 SHORT $LN1@SetTitle_e@9
$LN91@SetTitle_e@9:
  00166	c6 45 ed ec	 mov	 BYTE PTR __t$[ebp+5], -20 ; ffffffecH
  0016a	eb 1c		 jmp	 SHORT $LN1@SetTitle_e@9
$LN92@SetTitle_e@9:
  0016c	c6 45 ec ed	 mov	 BYTE PTR __t$[ebp+4], -19 ; ffffffedH
  00170	eb 16		 jmp	 SHORT $LN1@SetTitle_e@9
$LN93@SetTitle_e@9:
  00172	c6 45 eb ea	 mov	 BYTE PTR __t$[ebp+3], -22 ; ffffffeaH
  00176	eb 10		 jmp	 SHORT $LN1@SetTitle_e@9
$LN94@SetTitle_e@9:
  00178	c6 45 ea eb	 mov	 BYTE PTR __t$[ebp+2], -21 ; ffffffebH
  0017c	eb 0a		 jmp	 SHORT $LN1@SetTitle_e@9
$LN95@SetTitle_e@9:
  0017e	c6 45 e9 ec	 mov	 BYTE PTR __t$[ebp+1], -20 ; ffffffecH
  00182	eb 04		 jmp	 SHORT $LN1@SetTitle_e@9
$LN96@SetTitle_e@9:
  00184	c6 45 e8 ed	 mov	 BYTE PTR __t$[ebp], -19	; ffffffedH
$LN1@SetTitle_e@9:
  00188	6a 03		 push	 3
  0018a	8d 45 e8	 lea	 eax, DWORD PTR __t$[ebp]
  0018d	c6 45 f5 00	 mov	 BYTE PTR __t$[ebp+13], 0
  00191	5a		 pop	 edx
$LL104@SetTitle_e@9:
  00192	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00198	83 c0 04	 add	 eax, 4
  0019b	4a		 dec	 edx
  0019c	75 f4		 jne	 SHORT $LL104@SetTitle_e@9
  0019e	80 75 f4 ed	 xor	 BYTE PTR __t$[ebp+12], -19 ; ffffffedH

; 190  : 		SetTitle(_t);

  001a2	8d 45 e8	 lea	 eax, DWORD PTR __t$[ebp]
  001a5	50		 push	 eax
  001a6	8b ce		 mov	 ecx, esi
  001a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z

; 191  : 	}

  001ae	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b1	33 cd		 xor	 ecx, ebp
  001b3	5e		 pop	 esi
  001b4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b9	c9		 leave
  001ba	c2 04 00	 ret	 4
??$SetTitle_e@$0O@@ioINILoader@@QAEXAAY0O@$$CBD@Z ENDP	; ioINILoader::SetTitle_e<14>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadInt_e@$0O@@ioINILoader@@QAEHAAY0O@$$CBDH@Z ; ioINILoader::LoadInt_e<14>
; Function compile flags: /Ogsp
;	COMDAT ??$LoadInt_e@$0O@@ioINILoader@@QAEHAAY0O@$$CBDH@Z
_TEXT	SEGMENT
__k$ = -24						; size = 14
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_i$ = 12						; size = 4
??$LoadInt_e@$0O@@ioINILoader@@QAEHAAY0O@$$CBDH@Z PROC	; ioINILoader::LoadInt_e<14>, COMDAT
; _this$ = ecx

; 118  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 119  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	84 d2		 test	 dl, dl
  0001a	0f 84 64 01 00
	00		 je	 $LN96@LoadInt_e@11
  00020	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00023	88 55 e8	 mov	 BYTE PTR __k$[ebp], dl
  00026	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00029	84 d2		 test	 dl, dl
  0002b	0f 84 4d 01 00
	00		 je	 $LN95@LoadInt_e@11
  00031	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00034	88 55 e9	 mov	 BYTE PTR __k$[ebp+1], dl
  00037	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003a	84 d2		 test	 dl, dl
  0003c	0f 84 36 01 00
	00		 je	 $LN94@LoadInt_e@11
  00042	b1 eb		 mov	 cl, -21			; ffffffebH
  00044	32 d1		 xor	 dl, cl
  00046	88 55 ea	 mov	 BYTE PTR __k$[ebp+2], dl
  00049	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004c	84 d2		 test	 dl, dl
  0004e	0f 84 1e 01 00
	00		 je	 $LN93@LoadInt_e@11
  00054	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00057	88 55 eb	 mov	 BYTE PTR __k$[ebp+3], dl
  0005a	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005d	84 d2		 test	 dl, dl
  0005f	0f 84 07 01 00
	00		 je	 $LN92@LoadInt_e@11
  00065	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00068	88 55 ec	 mov	 BYTE PTR __k$[ebp+4], dl
  0006b	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006e	84 d2		 test	 dl, dl
  00070	0f 84 f0 00 00
	00		 je	 $LN91@LoadInt_e@11
  00076	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00079	88 55 ed	 mov	 BYTE PTR __k$[ebp+5], dl
  0007c	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0007f	84 d2		 test	 dl, dl
  00081	0f 84 da 00 00
	00		 je	 $LN90@LoadInt_e@11
  00087	32 d1		 xor	 dl, cl
  00089	88 55 ee	 mov	 BYTE PTR __k$[ebp+6], dl
  0008c	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0008f	84 d2		 test	 dl, dl
  00091	0f 84 c4 00 00
	00		 je	 $LN89@LoadInt_e@11
  00097	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009a	88 55 ef	 mov	 BYTE PTR __k$[ebp+7], dl
  0009d	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a0	84 d2		 test	 dl, dl
  000a2	0f 84 ad 00 00
	00		 je	 $LN88@LoadInt_e@11
  000a8	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ab	88 55 f0	 mov	 BYTE PTR __k$[ebp+8], dl
  000ae	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b1	84 d2		 test	 dl, dl
  000b3	0f 84 96 00 00
	00		 je	 $LN87@LoadInt_e@11
  000b9	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000bc	88 55 f1	 mov	 BYTE PTR __k$[ebp+9], dl
  000bf	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c2	84 d2		 test	 dl, dl
  000c4	0f 84 80 00 00
	00		 je	 $LN86@LoadInt_e@11
  000ca	32 d1		 xor	 dl, cl
  000cc	88 55 f2	 mov	 BYTE PTR __k$[ebp+10], dl
  000cf	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000d2	84 d2		 test	 dl, dl
  000d4	74 6e		 je	 SHORT $LN85@LoadInt_e@11
  000d6	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000d9	88 55 f3	 mov	 BYTE PTR __k$[ebp+11], dl
  000dc	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000df	84 d2		 test	 dl, dl
  000e1	74 5b		 je	 SHORT $LN84@LoadInt_e@11
  000e3	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000e6	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000ea	88 55 f4	 mov	 BYTE PTR __k$[ebp+12], dl
  000ed	0f 84 95 00 00
	00		 je	 $LN1@LoadInt_e@11
  000f3	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  000f6	84 d2		 test	 dl, dl
  000f8	74 3f		 je	 SHORT $LN82@LoadInt_e@11
  000fa	32 d1		 xor	 dl, cl
  000fc	88 55 f6	 mov	 BYTE PTR __k$[ebp+14], dl
  000ff	8a 50 0f	 mov	 dl, BYTE PTR [eax+15]
  00102	84 d2		 test	 dl, dl
  00104	74 2d		 je	 SHORT $LN81@LoadInt_e@11
  00106	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00109	88 55 f7	 mov	 BYTE PTR __k$[ebp+15], dl
  0010c	8a 50 10	 mov	 dl, BYTE PTR [eax+16]
  0010f	84 d2		 test	 dl, dl
  00111	74 1a		 je	 SHORT $LN80@LoadInt_e@11
  00113	8a 40 11	 mov	 al, BYTE PTR [eax+17]
  00116	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00119	88 55 f8	 mov	 BYTE PTR __k$[ebp+16], dl
  0011c	84 c0		 test	 al, al
  0011e	74 07		 je	 SHORT $LN79@LoadInt_e@11
  00120	34 ec		 xor	 al, -20			; ffffffecH
  00122	88 45 f9	 mov	 BYTE PTR __k$[ebp+17], al
  00125	eb 61		 jmp	 SHORT $LN1@LoadInt_e@11
$LN79@LoadInt_e@11:
  00127	c6 45 f9 ec	 mov	 BYTE PTR __k$[ebp+17], -20 ; ffffffecH
  0012b	eb 5b		 jmp	 SHORT $LN1@LoadInt_e@11
$LN80@LoadInt_e@11:
  0012d	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+16], -19 ; ffffffedH
  00131	eb 55		 jmp	 SHORT $LN1@LoadInt_e@11
$LN81@LoadInt_e@11:
  00133	c6 45 f7 ea	 mov	 BYTE PTR __k$[ebp+15], -22 ; ffffffeaH
  00137	eb 4f		 jmp	 SHORT $LN1@LoadInt_e@11
$LN82@LoadInt_e@11:
  00139	88 4d f6	 mov	 BYTE PTR __k$[ebp+14], cl
  0013c	eb 4a		 jmp	 SHORT $LN1@LoadInt_e@11
$LN84@LoadInt_e@11:
  0013e	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  00142	eb 44		 jmp	 SHORT $LN1@LoadInt_e@11
$LN85@LoadInt_e@11:
  00144	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  00148	eb 3e		 jmp	 SHORT $LN1@LoadInt_e@11
$LN86@LoadInt_e@11:
  0014a	88 4d f2	 mov	 BYTE PTR __k$[ebp+10], cl
  0014d	eb 39		 jmp	 SHORT $LN1@LoadInt_e@11
$LN87@LoadInt_e@11:
  0014f	c6 45 f1 ec	 mov	 BYTE PTR __k$[ebp+9], -20 ; ffffffecH
  00153	eb 33		 jmp	 SHORT $LN1@LoadInt_e@11
$LN88@LoadInt_e@11:
  00155	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  00159	eb 2d		 jmp	 SHORT $LN1@LoadInt_e@11
$LN89@LoadInt_e@11:
  0015b	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  0015f	eb 27		 jmp	 SHORT $LN1@LoadInt_e@11
$LN90@LoadInt_e@11:
  00161	88 4d ee	 mov	 BYTE PTR __k$[ebp+6], cl
  00164	eb 22		 jmp	 SHORT $LN1@LoadInt_e@11
$LN91@LoadInt_e@11:
  00166	c6 45 ed ec	 mov	 BYTE PTR __k$[ebp+5], -20 ; ffffffecH
  0016a	eb 1c		 jmp	 SHORT $LN1@LoadInt_e@11
$LN92@LoadInt_e@11:
  0016c	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  00170	eb 16		 jmp	 SHORT $LN1@LoadInt_e@11
$LN93@LoadInt_e@11:
  00172	c6 45 eb ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  00176	eb 10		 jmp	 SHORT $LN1@LoadInt_e@11
$LN94@LoadInt_e@11:
  00178	c6 45 ea eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  0017c	eb 0a		 jmp	 SHORT $LN1@LoadInt_e@11
$LN95@LoadInt_e@11:
  0017e	c6 45 e9 ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  00182	eb 04		 jmp	 SHORT $LN1@LoadInt_e@11
$LN96@LoadInt_e@11:
  00184	c6 45 e8 ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@LoadInt_e@11:
  00188	6a 03		 push	 3
  0018a	8d 45 e8	 lea	 eax, DWORD PTR __k$[ebp]
  0018d	c6 45 f5 00	 mov	 BYTE PTR __k$[ebp+13], 0
  00191	5a		 pop	 edx
$LL104@LoadInt_e@11:
  00192	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00198	83 c0 04	 add	 eax, 4
  0019b	4a		 dec	 edx
  0019c	75 f4		 jne	 SHORT $LL104@LoadInt_e@11

; 120  : 		return LoadInt(_k, i);

  0019e	ff 75 0c	 push	 DWORD PTR _i$[ebp]
  001a1	80 75 f4 ed	 xor	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  001a5	8d 45 e8	 lea	 eax, DWORD PTR __k$[ebp]
  001a8	50		 push	 eax
  001a9	8b ce		 mov	 ecx, esi
  001ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 121  : 	}

  001b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b4	33 cd		 xor	 ecx, ebp
  001b6	5e		 pop	 esi
  001b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001bc	c9		 leave
  001bd	c2 08 00	 ret	 8
??$LoadInt_e@$0O@@ioINILoader@@QAEHAAY0O@$$CBDH@Z ENDP	; ioINILoader::LoadInt_e<14>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadInt_e@$0P@@ioINILoader@@QAEHAAY0P@$$CBDH@Z ; ioINILoader::LoadInt_e<15>
; Function compile flags: /Ogsp
;	COMDAT ??$LoadInt_e@$0P@@ioINILoader@@QAEHAAY0P@$$CBDH@Z
_TEXT	SEGMENT
__k$ = -24						; size = 15
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_i$ = 12						; size = 4
??$LoadInt_e@$0P@@ioINILoader@@QAEHAAY0P@$$CBDH@Z PROC	; ioINILoader::LoadInt_e<15>, COMDAT
; _this$ = ecx

; 118  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 119  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	84 d2		 test	 dl, dl
  0001a	0f 84 75 01 00
	00		 je	 $LN96@LoadInt_e@12
  00020	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00023	88 55 e8	 mov	 BYTE PTR __k$[ebp], dl
  00026	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00029	84 d2		 test	 dl, dl
  0002b	0f 84 5e 01 00
	00		 je	 $LN95@LoadInt_e@12
  00031	b1 ec		 mov	 cl, -20			; ffffffecH
  00033	32 d1		 xor	 dl, cl
  00035	88 55 e9	 mov	 BYTE PTR __k$[ebp+1], dl
  00038	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003b	84 d2		 test	 dl, dl
  0003d	0f 84 46 01 00
	00		 je	 $LN94@LoadInt_e@12
  00043	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00046	88 55 ea	 mov	 BYTE PTR __k$[ebp+2], dl
  00049	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004c	84 d2		 test	 dl, dl
  0004e	0f 84 2f 01 00
	00		 je	 $LN93@LoadInt_e@12
  00054	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00057	88 55 eb	 mov	 BYTE PTR __k$[ebp+3], dl
  0005a	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005d	84 d2		 test	 dl, dl
  0005f	0f 84 18 01 00
	00		 je	 $LN92@LoadInt_e@12
  00065	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00068	88 55 ec	 mov	 BYTE PTR __k$[ebp+4], dl
  0006b	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006e	84 d2		 test	 dl, dl
  00070	0f 84 02 01 00
	00		 je	 $LN91@LoadInt_e@12
  00076	32 d1		 xor	 dl, cl
  00078	88 55 ed	 mov	 BYTE PTR __k$[ebp+5], dl
  0007b	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0007e	84 d2		 test	 dl, dl
  00080	0f 84 ec 00 00
	00		 je	 $LN90@LoadInt_e@12
  00086	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00089	88 55 ee	 mov	 BYTE PTR __k$[ebp+6], dl
  0008c	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0008f	84 d2		 test	 dl, dl
  00091	0f 84 d5 00 00
	00		 je	 $LN89@LoadInt_e@12
  00097	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009a	88 55 ef	 mov	 BYTE PTR __k$[ebp+7], dl
  0009d	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a0	84 d2		 test	 dl, dl
  000a2	0f 84 be 00 00
	00		 je	 $LN88@LoadInt_e@12
  000a8	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ab	88 55 f0	 mov	 BYTE PTR __k$[ebp+8], dl
  000ae	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b1	84 d2		 test	 dl, dl
  000b3	0f 84 a8 00 00
	00		 je	 $LN87@LoadInt_e@12
  000b9	32 d1		 xor	 dl, cl
  000bb	88 55 f1	 mov	 BYTE PTR __k$[ebp+9], dl
  000be	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c1	84 d2		 test	 dl, dl
  000c3	0f 84 92 00 00
	00		 je	 $LN86@LoadInt_e@12
  000c9	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000cc	88 55 f2	 mov	 BYTE PTR __k$[ebp+10], dl
  000cf	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000d2	84 d2		 test	 dl, dl
  000d4	74 7f		 je	 SHORT $LN85@LoadInt_e@12
  000d6	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000d9	88 55 f3	 mov	 BYTE PTR __k$[ebp+11], dl
  000dc	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000df	84 d2		 test	 dl, dl
  000e1	74 6c		 je	 SHORT $LN84@LoadInt_e@12
  000e3	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000e6	88 55 f4	 mov	 BYTE PTR __k$[ebp+12], dl
  000e9	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000ec	84 d2		 test	 dl, dl
  000ee	74 5a		 je	 SHORT $LN83@LoadInt_e@12
  000f0	32 d1		 xor	 dl, cl
  000f2	80 78 0e 00	 cmp	 BYTE PTR [eax+14], 0
  000f6	88 55 f5	 mov	 BYTE PTR __k$[ebp+13], dl
  000f9	0f 84 9a 00 00
	00		 je	 $LN1@LoadInt_e@12
  000ff	8a 50 0f	 mov	 dl, BYTE PTR [eax+15]
  00102	84 d2		 test	 dl, dl
  00104	74 3e		 je	 SHORT $LN81@LoadInt_e@12
  00106	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00109	88 55 f7	 mov	 BYTE PTR __k$[ebp+15], dl
  0010c	8a 50 10	 mov	 dl, BYTE PTR [eax+16]
  0010f	84 d2		 test	 dl, dl
  00111	74 2b		 je	 SHORT $LN80@LoadInt_e@12
  00113	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00116	88 55 f8	 mov	 BYTE PTR __k$[ebp+16], dl
  00119	8a 50 11	 mov	 dl, BYTE PTR [eax+17]
  0011c	84 d2		 test	 dl, dl
  0011e	74 19		 je	 SHORT $LN79@LoadInt_e@12
  00120	8a 40 12	 mov	 al, BYTE PTR [eax+18]
  00123	32 d1		 xor	 dl, cl
  00125	88 55 f9	 mov	 BYTE PTR __k$[ebp+17], dl
  00128	84 c0		 test	 al, al
  0012a	74 07		 je	 SHORT $LN78@LoadInt_e@12
  0012c	34 eb		 xor	 al, -21			; ffffffebH
  0012e	88 45 fa	 mov	 BYTE PTR __k$[ebp+18], al
  00131	eb 66		 jmp	 SHORT $LN1@LoadInt_e@12
$LN78@LoadInt_e@12:
  00133	c6 45 fa eb	 mov	 BYTE PTR __k$[ebp+18], -21 ; ffffffebH
  00137	eb 60		 jmp	 SHORT $LN1@LoadInt_e@12
$LN79@LoadInt_e@12:
  00139	88 4d f9	 mov	 BYTE PTR __k$[ebp+17], cl
  0013c	eb 5b		 jmp	 SHORT $LN1@LoadInt_e@12
$LN80@LoadInt_e@12:
  0013e	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+16], -19 ; ffffffedH
  00142	eb 55		 jmp	 SHORT $LN1@LoadInt_e@12
$LN81@LoadInt_e@12:
  00144	c6 45 f7 ea	 mov	 BYTE PTR __k$[ebp+15], -22 ; ffffffeaH
  00148	eb 4f		 jmp	 SHORT $LN1@LoadInt_e@12
$LN83@LoadInt_e@12:
  0014a	88 4d f5	 mov	 BYTE PTR __k$[ebp+13], cl
  0014d	eb 4a		 jmp	 SHORT $LN1@LoadInt_e@12
$LN84@LoadInt_e@12:
  0014f	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  00153	eb 44		 jmp	 SHORT $LN1@LoadInt_e@12
$LN85@LoadInt_e@12:
  00155	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  00159	eb 3e		 jmp	 SHORT $LN1@LoadInt_e@12
$LN86@LoadInt_e@12:
  0015b	c6 45 f2 eb	 mov	 BYTE PTR __k$[ebp+10], -21 ; ffffffebH
  0015f	eb 38		 jmp	 SHORT $LN1@LoadInt_e@12
$LN87@LoadInt_e@12:
  00161	88 4d f1	 mov	 BYTE PTR __k$[ebp+9], cl
  00164	eb 33		 jmp	 SHORT $LN1@LoadInt_e@12
$LN88@LoadInt_e@12:
  00166	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  0016a	eb 2d		 jmp	 SHORT $LN1@LoadInt_e@12
$LN89@LoadInt_e@12:
  0016c	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  00170	eb 27		 jmp	 SHORT $LN1@LoadInt_e@12
$LN90@LoadInt_e@12:
  00172	c6 45 ee eb	 mov	 BYTE PTR __k$[ebp+6], -21 ; ffffffebH
  00176	eb 21		 jmp	 SHORT $LN1@LoadInt_e@12
$LN91@LoadInt_e@12:
  00178	88 4d ed	 mov	 BYTE PTR __k$[ebp+5], cl
  0017b	eb 1c		 jmp	 SHORT $LN1@LoadInt_e@12
$LN92@LoadInt_e@12:
  0017d	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  00181	eb 16		 jmp	 SHORT $LN1@LoadInt_e@12
$LN93@LoadInt_e@12:
  00183	c6 45 eb ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  00187	eb 10		 jmp	 SHORT $LN1@LoadInt_e@12
$LN94@LoadInt_e@12:
  00189	c6 45 ea eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  0018d	eb 0a		 jmp	 SHORT $LN1@LoadInt_e@12
$LN95@LoadInt_e@12:
  0018f	c6 45 e9 ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  00193	eb 04		 jmp	 SHORT $LN1@LoadInt_e@12
$LN96@LoadInt_e@12:
  00195	c6 45 e8 ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@LoadInt_e@12:
  00199	6a 03		 push	 3
  0019b	8d 45 e8	 lea	 eax, DWORD PTR __k$[ebp]
  0019e	c6 45 f6 00	 mov	 BYTE PTR __k$[ebp+14], 0
  001a2	5a		 pop	 edx
$LL104@LoadInt_e@12:
  001a3	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  001a9	83 c0 04	 add	 eax, 4
  001ac	4a		 dec	 edx
  001ad	75 f4		 jne	 SHORT $LL104@LoadInt_e@12
  001af	6a 0c		 push	 12			; 0000000cH
  001b1	58		 pop	 eax
$LL101@LoadInt_e@12:
  001b2	8b c8		 mov	 ecx, eax
  001b4	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  001ba	79 05		 jns	 SHORT $LN111@LoadInt_e@12
  001bc	49		 dec	 ecx
  001bd	83 c9 fc	 or	 ecx, -4			; fffffffcH
  001c0	41		 inc	 ecx
$LN111@LoadInt_e@12:
  001c1	b2 ed		 mov	 dl, -19			; ffffffedH
  001c3	2a d1		 sub	 dl, cl
  001c5	30 54 05 e8	 xor	 BYTE PTR __k$[ebp+eax], dl
  001c9	40		 inc	 eax
  001ca	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  001cd	7c e3		 jl	 SHORT $LL101@LoadInt_e@12

; 120  : 		return LoadInt(_k, i);

  001cf	ff 75 0c	 push	 DWORD PTR _i$[ebp]
  001d2	8d 45 e8	 lea	 eax, DWORD PTR __k$[ebp]
  001d5	50		 push	 eax
  001d6	8b ce		 mov	 ecx, esi
  001d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 121  : 	}

  001de	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e1	33 cd		 xor	 ecx, ebp
  001e3	5e		 pop	 esi
  001e4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e9	c9		 leave
  001ea	c2 08 00	 ret	 8
??$LoadInt_e@$0P@@ioINILoader@@QAEHAAY0P@$$CBDH@Z ENDP	; ioINILoader::LoadInt_e<15>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$SetTitle_e@$0BD@@ioINILoader@@QAEXAAY0BD@$$CBD@Z ; ioINILoader::SetTitle_e<19>
; Function compile flags: /Ogsp
;	COMDAT ??$SetTitle_e@$0BD@@ioINILoader@@QAEXAAY0BD@$$CBD@Z
_TEXT	SEGMENT
__t$ = -28						; size = 19
__$ArrayPad$ = -4					; size = 4
_t$ = 8							; size = 4
??$SetTitle_e@$0BD@@ioINILoader@@QAEXAAY0BD@$$CBD@Z PROC ; ioINILoader::SetTitle_e<19>, COMDAT
; _this$ = ecx

; 188  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]

; 189  : 		_ENCSTR(t, _t);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	84 d2		 test	 dl, dl
  0001a	0f 84 cf 01 00
	00		 je	 $LN96@SetTitle_e@10
  00020	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00023	88 55 e4	 mov	 BYTE PTR __t$[ebp], dl
  00026	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00029	84 d2		 test	 dl, dl
  0002b	0f 84 b8 01 00
	00		 je	 $LN95@SetTitle_e@10
  00031	b1 ec		 mov	 cl, -20			; ffffffecH
  00033	32 d1		 xor	 dl, cl
  00035	88 55 e5	 mov	 BYTE PTR __t$[ebp+1], dl
  00038	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003b	84 d2		 test	 dl, dl
  0003d	0f 84 a0 01 00
	00		 je	 $LN94@SetTitle_e@10
  00043	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00046	88 55 e6	 mov	 BYTE PTR __t$[ebp+2], dl
  00049	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004c	84 d2		 test	 dl, dl
  0004e	0f 84 89 01 00
	00		 je	 $LN93@SetTitle_e@10
  00054	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00057	88 55 e7	 mov	 BYTE PTR __t$[ebp+3], dl
  0005a	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005d	84 d2		 test	 dl, dl
  0005f	0f 84 72 01 00
	00		 je	 $LN92@SetTitle_e@10
  00065	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00068	88 55 e8	 mov	 BYTE PTR __t$[ebp+4], dl
  0006b	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006e	84 d2		 test	 dl, dl
  00070	0f 84 5c 01 00
	00		 je	 $LN91@SetTitle_e@10
  00076	32 d1		 xor	 dl, cl
  00078	88 55 e9	 mov	 BYTE PTR __t$[ebp+5], dl
  0007b	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0007e	84 d2		 test	 dl, dl
  00080	0f 84 46 01 00
	00		 je	 $LN90@SetTitle_e@10
  00086	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00089	88 55 ea	 mov	 BYTE PTR __t$[ebp+6], dl
  0008c	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0008f	84 d2		 test	 dl, dl
  00091	0f 84 2f 01 00
	00		 je	 $LN89@SetTitle_e@10
  00097	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009a	88 55 eb	 mov	 BYTE PTR __t$[ebp+7], dl
  0009d	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a0	84 d2		 test	 dl, dl
  000a2	0f 84 18 01 00
	00		 je	 $LN88@SetTitle_e@10
  000a8	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ab	88 55 ec	 mov	 BYTE PTR __t$[ebp+8], dl
  000ae	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b1	84 d2		 test	 dl, dl
  000b3	0f 84 02 01 00
	00		 je	 $LN87@SetTitle_e@10
  000b9	32 d1		 xor	 dl, cl
  000bb	88 55 ed	 mov	 BYTE PTR __t$[ebp+9], dl
  000be	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c1	84 d2		 test	 dl, dl
  000c3	0f 84 ec 00 00
	00		 je	 $LN86@SetTitle_e@10
  000c9	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000cc	88 55 ee	 mov	 BYTE PTR __t$[ebp+10], dl
  000cf	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000d2	84 d2		 test	 dl, dl
  000d4	0f 84 d5 00 00
	00		 je	 $LN85@SetTitle_e@10
  000da	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000dd	88 55 ef	 mov	 BYTE PTR __t$[ebp+11], dl
  000e0	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000e3	84 d2		 test	 dl, dl
  000e5	0f 84 be 00 00
	00		 je	 $LN84@SetTitle_e@10
  000eb	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ee	88 55 f0	 mov	 BYTE PTR __t$[ebp+12], dl
  000f1	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000f4	84 d2		 test	 dl, dl
  000f6	0f 84 a8 00 00
	00		 je	 $LN83@SetTitle_e@10
  000fc	32 d1		 xor	 dl, cl
  000fe	88 55 f1	 mov	 BYTE PTR __t$[ebp+13], dl
  00101	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  00104	84 d2		 test	 dl, dl
  00106	0f 84 92 00 00
	00		 je	 $LN82@SetTitle_e@10
  0010c	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0010f	88 55 f2	 mov	 BYTE PTR __t$[ebp+14], dl
  00112	8a 50 0f	 mov	 dl, BYTE PTR [eax+15]
  00115	84 d2		 test	 dl, dl
  00117	74 7f		 je	 SHORT $LN81@SetTitle_e@10
  00119	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0011c	88 55 f3	 mov	 BYTE PTR __t$[ebp+15], dl
  0011f	8a 50 10	 mov	 dl, BYTE PTR [eax+16]
  00122	84 d2		 test	 dl, dl
  00124	74 6c		 je	 SHORT $LN80@SetTitle_e@10
  00126	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00129	88 55 f4	 mov	 BYTE PTR __t$[ebp+16], dl
  0012c	8a 50 11	 mov	 dl, BYTE PTR [eax+17]
  0012f	84 d2		 test	 dl, dl
  00131	74 5a		 je	 SHORT $LN79@SetTitle_e@10
  00133	32 d1		 xor	 dl, cl
  00135	80 78 12 00	 cmp	 BYTE PTR [eax+18], 0
  00139	88 55 f5	 mov	 BYTE PTR __t$[ebp+17], dl
  0013c	0f 84 b1 00 00
	00		 je	 $LN1@SetTitle_e@10
  00142	8a 50 13	 mov	 dl, BYTE PTR [eax+19]
  00145	84 d2		 test	 dl, dl
  00147	74 3e		 je	 SHORT $LN77@SetTitle_e@10
  00149	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0014c	88 55 f7	 mov	 BYTE PTR __t$[ebp+19], dl
  0014f	8a 50 14	 mov	 dl, BYTE PTR [eax+20]
  00152	84 d2		 test	 dl, dl
  00154	74 2b		 je	 SHORT $LN76@SetTitle_e@10
  00156	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00159	88 55 f8	 mov	 BYTE PTR __t$[ebp+20], dl
  0015c	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  0015f	84 d2		 test	 dl, dl
  00161	74 19		 je	 SHORT $LN75@SetTitle_e@10
  00163	8a 40 16	 mov	 al, BYTE PTR [eax+22]
  00166	32 d1		 xor	 dl, cl
  00168	88 55 f9	 mov	 BYTE PTR __t$[ebp+21], dl
  0016b	84 c0		 test	 al, al
  0016d	74 07		 je	 SHORT $LN74@SetTitle_e@10
  0016f	34 eb		 xor	 al, -21			; ffffffebH
  00171	88 45 fa	 mov	 BYTE PTR __t$[ebp+22], al
  00174	eb 7d		 jmp	 SHORT $LN1@SetTitle_e@10
$LN74@SetTitle_e@10:
  00176	c6 45 fa eb	 mov	 BYTE PTR __t$[ebp+22], -21 ; ffffffebH
  0017a	eb 77		 jmp	 SHORT $LN1@SetTitle_e@10
$LN75@SetTitle_e@10:
  0017c	88 4d f9	 mov	 BYTE PTR __t$[ebp+21], cl
  0017f	eb 72		 jmp	 SHORT $LN1@SetTitle_e@10
$LN76@SetTitle_e@10:
  00181	c6 45 f8 ed	 mov	 BYTE PTR __t$[ebp+20], -19 ; ffffffedH
  00185	eb 6c		 jmp	 SHORT $LN1@SetTitle_e@10
$LN77@SetTitle_e@10:
  00187	c6 45 f7 ea	 mov	 BYTE PTR __t$[ebp+19], -22 ; ffffffeaH
  0018b	eb 66		 jmp	 SHORT $LN1@SetTitle_e@10
$LN79@SetTitle_e@10:
  0018d	88 4d f5	 mov	 BYTE PTR __t$[ebp+17], cl
  00190	eb 61		 jmp	 SHORT $LN1@SetTitle_e@10
$LN80@SetTitle_e@10:
  00192	c6 45 f4 ed	 mov	 BYTE PTR __t$[ebp+16], -19 ; ffffffedH
  00196	eb 5b		 jmp	 SHORT $LN1@SetTitle_e@10
$LN81@SetTitle_e@10:
  00198	c6 45 f3 ea	 mov	 BYTE PTR __t$[ebp+15], -22 ; ffffffeaH
  0019c	eb 55		 jmp	 SHORT $LN1@SetTitle_e@10
$LN82@SetTitle_e@10:
  0019e	c6 45 f2 eb	 mov	 BYTE PTR __t$[ebp+14], -21 ; ffffffebH
  001a2	eb 4f		 jmp	 SHORT $LN1@SetTitle_e@10
$LN83@SetTitle_e@10:
  001a4	88 4d f1	 mov	 BYTE PTR __t$[ebp+13], cl
  001a7	eb 4a		 jmp	 SHORT $LN1@SetTitle_e@10
$LN84@SetTitle_e@10:
  001a9	c6 45 f0 ed	 mov	 BYTE PTR __t$[ebp+12], -19 ; ffffffedH
  001ad	eb 44		 jmp	 SHORT $LN1@SetTitle_e@10
$LN85@SetTitle_e@10:
  001af	c6 45 ef ea	 mov	 BYTE PTR __t$[ebp+11], -22 ; ffffffeaH
  001b3	eb 3e		 jmp	 SHORT $LN1@SetTitle_e@10
$LN86@SetTitle_e@10:
  001b5	c6 45 ee eb	 mov	 BYTE PTR __t$[ebp+10], -21 ; ffffffebH
  001b9	eb 38		 jmp	 SHORT $LN1@SetTitle_e@10
$LN87@SetTitle_e@10:
  001bb	88 4d ed	 mov	 BYTE PTR __t$[ebp+9], cl
  001be	eb 33		 jmp	 SHORT $LN1@SetTitle_e@10
$LN88@SetTitle_e@10:
  001c0	c6 45 ec ed	 mov	 BYTE PTR __t$[ebp+8], -19 ; ffffffedH
  001c4	eb 2d		 jmp	 SHORT $LN1@SetTitle_e@10
$LN89@SetTitle_e@10:
  001c6	c6 45 eb ea	 mov	 BYTE PTR __t$[ebp+7], -22 ; ffffffeaH
  001ca	eb 27		 jmp	 SHORT $LN1@SetTitle_e@10
$LN90@SetTitle_e@10:
  001cc	c6 45 ea eb	 mov	 BYTE PTR __t$[ebp+6], -21 ; ffffffebH
  001d0	eb 21		 jmp	 SHORT $LN1@SetTitle_e@10
$LN91@SetTitle_e@10:
  001d2	88 4d e9	 mov	 BYTE PTR __t$[ebp+5], cl
  001d5	eb 1c		 jmp	 SHORT $LN1@SetTitle_e@10
$LN92@SetTitle_e@10:
  001d7	c6 45 e8 ed	 mov	 BYTE PTR __t$[ebp+4], -19 ; ffffffedH
  001db	eb 16		 jmp	 SHORT $LN1@SetTitle_e@10
$LN93@SetTitle_e@10:
  001dd	c6 45 e7 ea	 mov	 BYTE PTR __t$[ebp+3], -22 ; ffffffeaH
  001e1	eb 10		 jmp	 SHORT $LN1@SetTitle_e@10
$LN94@SetTitle_e@10:
  001e3	c6 45 e6 eb	 mov	 BYTE PTR __t$[ebp+2], -21 ; ffffffebH
  001e7	eb 0a		 jmp	 SHORT $LN1@SetTitle_e@10
$LN95@SetTitle_e@10:
  001e9	c6 45 e5 ec	 mov	 BYTE PTR __t$[ebp+1], -20 ; ffffffecH
  001ed	eb 04		 jmp	 SHORT $LN1@SetTitle_e@10
$LN96@SetTitle_e@10:
  001ef	c6 45 e4 ed	 mov	 BYTE PTR __t$[ebp], -19	; ffffffedH
$LN1@SetTitle_e@10:
  001f3	6a 04		 push	 4
  001f5	8d 45 e4	 lea	 eax, DWORD PTR __t$[ebp]
  001f8	c6 45 f6 00	 mov	 BYTE PTR __t$[ebp+18], 0
  001fc	5a		 pop	 edx
$LL104@SetTitle_e@10:
  001fd	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00203	83 c0 04	 add	 eax, 4
  00206	4a		 dec	 edx
  00207	75 f4		 jne	 SHORT $LL104@SetTitle_e@10
  00209	6a 10		 push	 16			; 00000010H
  0020b	58		 pop	 eax
$LL101@SetTitle_e@10:
  0020c	8b c8		 mov	 ecx, eax
  0020e	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00214	79 05		 jns	 SHORT $LN111@SetTitle_e@10
  00216	49		 dec	 ecx
  00217	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0021a	41		 inc	 ecx
$LN111@SetTitle_e@10:
  0021b	b2 ed		 mov	 dl, -19			; ffffffedH
  0021d	2a d1		 sub	 dl, cl
  0021f	30 54 05 e4	 xor	 BYTE PTR __t$[ebp+eax], dl
  00223	40		 inc	 eax
  00224	83 f8 12	 cmp	 eax, 18			; 00000012H
  00227	7c e3		 jl	 SHORT $LL101@SetTitle_e@10

; 190  : 		SetTitle(_t);

  00229	8d 45 e4	 lea	 eax, DWORD PTR __t$[ebp]
  0022c	50		 push	 eax
  0022d	8b ce		 mov	 ecx, esi
  0022f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z

; 191  : 	}

  00235	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00238	33 cd		 xor	 ecx, ebp
  0023a	5e		 pop	 esi
  0023b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00240	c9		 leave
  00241	c2 04 00	 ret	 4
??$SetTitle_e@$0BD@@ioINILoader@@QAEXAAY0BD@$$CBD@Z ENDP ; ioINILoader::SetTitle_e<19>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$SetTitle_e@$09@ioINILoader@@QAEXAAY09$$CBD@Z	; ioINILoader::SetTitle_e<10>
; Function compile flags: /Ogsp
;	COMDAT ??$SetTitle_e@$09@ioINILoader@@QAEXAAY09$$CBD@Z
_TEXT	SEGMENT
__t$ = -20						; size = 10
__$ArrayPad$ = -4					; size = 4
_t$ = 8							; size = 4
??$SetTitle_e@$09@ioINILoader@@QAEXAAY09$$CBD@Z PROC	; ioINILoader::SetTitle_e<10>, COMDAT
; _this$ = ecx

; 188  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]

; 189  : 		_ENCSTR(t, _t);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	84 d2		 test	 dl, dl
  00017	0f 84 0d 01 00
	00		 je	 $LN96@SetTitle_e@11
  0001d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00020	88 55 ec	 mov	 BYTE PTR __t$[ebp], dl
  00023	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00026	84 d2		 test	 dl, dl
  00028	0f 84 f6 00 00
	00		 je	 $LN95@SetTitle_e@11
  0002e	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00031	88 55 ed	 mov	 BYTE PTR __t$[ebp+1], dl
  00034	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  00037	84 d2		 test	 dl, dl
  00039	0f 84 df 00 00
	00		 je	 $LN94@SetTitle_e@11
  0003f	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00042	88 55 ee	 mov	 BYTE PTR __t$[ebp+2], dl
  00045	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  00048	84 d2		 test	 dl, dl
  0004a	0f 84 c8 00 00
	00		 je	 $LN93@SetTitle_e@11
  00050	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00053	88 55 ef	 mov	 BYTE PTR __t$[ebp+3], dl
  00056	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  00059	84 d2		 test	 dl, dl
  0005b	0f 84 b1 00 00
	00		 je	 $LN92@SetTitle_e@11
  00061	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00064	88 55 f0	 mov	 BYTE PTR __t$[ebp+4], dl
  00067	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006a	84 d2		 test	 dl, dl
  0006c	0f 84 9a 00 00
	00		 je	 $LN91@SetTitle_e@11
  00072	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00075	88 55 f1	 mov	 BYTE PTR __t$[ebp+5], dl
  00078	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0007b	84 d2		 test	 dl, dl
  0007d	0f 84 83 00 00
	00		 je	 $LN90@SetTitle_e@11
  00083	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00086	88 55 f2	 mov	 BYTE PTR __t$[ebp+6], dl
  00089	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0008c	84 d2		 test	 dl, dl
  0008e	74 70		 je	 SHORT $LN89@SetTitle_e@11
  00090	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00093	88 55 f3	 mov	 BYTE PTR __t$[ebp+7], dl
  00096	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  00099	84 d2		 test	 dl, dl
  0009b	74 5d		 je	 SHORT $LN88@SetTitle_e@11
  0009d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000a0	80 78 09 00	 cmp	 BYTE PTR [eax+9], 0
  000a4	88 55 f4	 mov	 BYTE PTR __t$[ebp+8], dl
  000a7	0f 84 81 00 00
	00		 je	 $LN1@SetTitle_e@11
  000ad	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000b0	84 d2		 test	 dl, dl
  000b2	74 40		 je	 SHORT $LN86@SetTitle_e@11
  000b4	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000b7	88 55 f6	 mov	 BYTE PTR __t$[ebp+10], dl
  000ba	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000bd	84 d2		 test	 dl, dl
  000bf	74 2d		 je	 SHORT $LN85@SetTitle_e@11
  000c1	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000c4	88 55 f7	 mov	 BYTE PTR __t$[ebp+11], dl
  000c7	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000ca	84 d2		 test	 dl, dl
  000cc	74 1a		 je	 SHORT $LN84@SetTitle_e@11
  000ce	8a 40 0d	 mov	 al, BYTE PTR [eax+13]
  000d1	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000d4	88 55 f8	 mov	 BYTE PTR __t$[ebp+12], dl
  000d7	84 c0		 test	 al, al
  000d9	74 07		 je	 SHORT $LN83@SetTitle_e@11
  000db	34 ec		 xor	 al, -20			; ffffffecH
  000dd	88 45 f9	 mov	 BYTE PTR __t$[ebp+13], al
  000e0	eb 4c		 jmp	 SHORT $LN1@SetTitle_e@11
$LN83@SetTitle_e@11:
  000e2	c6 45 f9 ec	 mov	 BYTE PTR __t$[ebp+13], -20 ; ffffffecH
  000e6	eb 46		 jmp	 SHORT $LN1@SetTitle_e@11
$LN84@SetTitle_e@11:
  000e8	c6 45 f8 ed	 mov	 BYTE PTR __t$[ebp+12], -19 ; ffffffedH
  000ec	eb 40		 jmp	 SHORT $LN1@SetTitle_e@11
$LN85@SetTitle_e@11:
  000ee	c6 45 f7 ea	 mov	 BYTE PTR __t$[ebp+11], -22 ; ffffffeaH
  000f2	eb 3a		 jmp	 SHORT $LN1@SetTitle_e@11
$LN86@SetTitle_e@11:
  000f4	c6 45 f6 eb	 mov	 BYTE PTR __t$[ebp+10], -21 ; ffffffebH
  000f8	eb 34		 jmp	 SHORT $LN1@SetTitle_e@11
$LN88@SetTitle_e@11:
  000fa	c6 45 f4 ed	 mov	 BYTE PTR __t$[ebp+8], -19 ; ffffffedH
  000fe	eb 2e		 jmp	 SHORT $LN1@SetTitle_e@11
$LN89@SetTitle_e@11:
  00100	c6 45 f3 ea	 mov	 BYTE PTR __t$[ebp+7], -22 ; ffffffeaH
  00104	eb 28		 jmp	 SHORT $LN1@SetTitle_e@11
$LN90@SetTitle_e@11:
  00106	c6 45 f2 eb	 mov	 BYTE PTR __t$[ebp+6], -21 ; ffffffebH
  0010a	eb 22		 jmp	 SHORT $LN1@SetTitle_e@11
$LN91@SetTitle_e@11:
  0010c	c6 45 f1 ec	 mov	 BYTE PTR __t$[ebp+5], -20 ; ffffffecH
  00110	eb 1c		 jmp	 SHORT $LN1@SetTitle_e@11
$LN92@SetTitle_e@11:
  00112	c6 45 f0 ed	 mov	 BYTE PTR __t$[ebp+4], -19 ; ffffffedH
  00116	eb 16		 jmp	 SHORT $LN1@SetTitle_e@11
$LN93@SetTitle_e@11:
  00118	c6 45 ef ea	 mov	 BYTE PTR __t$[ebp+3], -22 ; ffffffeaH
  0011c	eb 10		 jmp	 SHORT $LN1@SetTitle_e@11
$LN94@SetTitle_e@11:
  0011e	c6 45 ee eb	 mov	 BYTE PTR __t$[ebp+2], -21 ; ffffffebH
  00122	eb 0a		 jmp	 SHORT $LN1@SetTitle_e@11
$LN95@SetTitle_e@11:
  00124	c6 45 ed ec	 mov	 BYTE PTR __t$[ebp+1], -20 ; ffffffecH
  00128	eb 04		 jmp	 SHORT $LN1@SetTitle_e@11
$LN96@SetTitle_e@11:
  0012a	c6 45 ec ed	 mov	 BYTE PTR __t$[ebp], -19	; ffffffedH
$LN1@SetTitle_e@11:
  0012e	6a 02		 push	 2
  00130	8d 45 ec	 lea	 eax, DWORD PTR __t$[ebp]
  00133	c6 45 f5 00	 mov	 BYTE PTR __t$[ebp+9], 0
  00137	5a		 pop	 edx
$LL104@SetTitle_e@11:
  00138	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0013e	83 c0 04	 add	 eax, 4
  00141	4a		 dec	 edx
  00142	75 f4		 jne	 SHORT $LL104@SetTitle_e@11
  00144	80 75 f4 ed	 xor	 BYTE PTR __t$[ebp+8], -19 ; ffffffedH

; 190  : 		SetTitle(_t);

  00148	8d 45 ec	 lea	 eax, DWORD PTR __t$[ebp]
  0014b	50		 push	 eax
  0014c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z

; 191  : 	}

  00152	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00155	33 cd		 xor	 ecx, ebp
  00157	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015c	c9		 leave
  0015d	c2 04 00	 ret	 4
??$SetTitle_e@$09@ioINILoader@@QAEXAAY09$$CBD@Z ENDP	; ioINILoader::SetTitle_e<10>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadInt_e@$0BG@@ioINILoader@@QAEHAAY0BG@$$CBDH@Z ; ioINILoader::LoadInt_e<22>
; Function compile flags: /Ogsp
;	COMDAT ??$LoadInt_e@$0BG@@ioINILoader@@QAEHAAY0BG@$$CBDH@Z
_TEXT	SEGMENT
__k$ = -32						; size = 22
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_i$ = 12						; size = 4
??$LoadInt_e@$0BG@@ioINILoader@@QAEHAAY0BG@$$CBDH@Z PROC ; ioINILoader::LoadInt_e<22>, COMDAT
; _this$ = ecx

; 118  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 119  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx
  00019	84 d2		 test	 dl, dl
  0001b	0f 84 15 02 00
	00		 je	 $LN96@LoadInt_e@13
  00021	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00024	88 55 e0	 mov	 BYTE PTR __k$[ebp], dl
  00027	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002a	84 d2		 test	 dl, dl
  0002c	0f 84 fe 01 00
	00		 je	 $LN95@LoadInt_e@13
  00032	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00035	88 55 e1	 mov	 BYTE PTR __k$[ebp+1], dl
  00038	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003b	84 d2		 test	 dl, dl
  0003d	0f 84 e7 01 00
	00		 je	 $LN94@LoadInt_e@13
  00043	b1 eb		 mov	 cl, -21			; ffffffebH
  00045	32 d1		 xor	 dl, cl
  00047	88 55 e2	 mov	 BYTE PTR __k$[ebp+2], dl
  0004a	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004d	84 d2		 test	 dl, dl
  0004f	0f 84 cf 01 00
	00		 je	 $LN93@LoadInt_e@13
  00055	b3 ea		 mov	 bl, -22			; ffffffeaH
  00057	32 d3		 xor	 dl, bl
  00059	88 55 e3	 mov	 BYTE PTR __k$[ebp+3], dl
  0005c	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005f	84 d2		 test	 dl, dl
  00061	0f 84 b7 01 00
	00		 je	 $LN92@LoadInt_e@13
  00067	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0006a	88 55 e4	 mov	 BYTE PTR __k$[ebp+4], dl
  0006d	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00070	84 d2		 test	 dl, dl
  00072	0f 84 a0 01 00
	00		 je	 $LN91@LoadInt_e@13
  00078	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0007b	88 55 e5	 mov	 BYTE PTR __k$[ebp+5], dl
  0007e	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00081	84 d2		 test	 dl, dl
  00083	0f 84 8a 01 00
	00		 je	 $LN90@LoadInt_e@13
  00089	32 d1		 xor	 dl, cl
  0008b	88 55 e6	 mov	 BYTE PTR __k$[ebp+6], dl
  0008e	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00091	84 d2		 test	 dl, dl
  00093	0f 84 75 01 00
	00		 je	 $LN89@LoadInt_e@13
  00099	32 d3		 xor	 dl, bl
  0009b	88 55 e7	 mov	 BYTE PTR __k$[ebp+7], dl
  0009e	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a1	84 d2		 test	 dl, dl
  000a3	0f 84 5f 01 00
	00		 je	 $LN88@LoadInt_e@13
  000a9	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ac	88 55 e8	 mov	 BYTE PTR __k$[ebp+8], dl
  000af	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b2	84 d2		 test	 dl, dl
  000b4	0f 84 48 01 00
	00		 je	 $LN87@LoadInt_e@13
  000ba	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000bd	88 55 e9	 mov	 BYTE PTR __k$[ebp+9], dl
  000c0	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c3	84 d2		 test	 dl, dl
  000c5	0f 84 32 01 00
	00		 je	 $LN86@LoadInt_e@13
  000cb	32 d1		 xor	 dl, cl
  000cd	88 55 ea	 mov	 BYTE PTR __k$[ebp+10], dl
  000d0	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000d3	84 d2		 test	 dl, dl
  000d5	0f 84 1d 01 00
	00		 je	 $LN85@LoadInt_e@13
  000db	32 d3		 xor	 dl, bl
  000dd	88 55 eb	 mov	 BYTE PTR __k$[ebp+11], dl
  000e0	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000e3	84 d2		 test	 dl, dl
  000e5	0f 84 07 01 00
	00		 je	 $LN84@LoadInt_e@13
  000eb	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ee	88 55 ec	 mov	 BYTE PTR __k$[ebp+12], dl
  000f1	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000f4	84 d2		 test	 dl, dl
  000f6	0f 84 f0 00 00
	00		 je	 $LN83@LoadInt_e@13
  000fc	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000ff	88 55 ed	 mov	 BYTE PTR __k$[ebp+13], dl
  00102	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  00105	84 d2		 test	 dl, dl
  00107	0f 84 da 00 00
	00		 je	 $LN82@LoadInt_e@13
  0010d	32 d1		 xor	 dl, cl
  0010f	88 55 ee	 mov	 BYTE PTR __k$[ebp+14], dl
  00112	8a 50 0f	 mov	 dl, BYTE PTR [eax+15]
  00115	84 d2		 test	 dl, dl
  00117	0f 84 c5 00 00
	00		 je	 $LN81@LoadInt_e@13
  0011d	32 d3		 xor	 dl, bl
  0011f	88 55 ef	 mov	 BYTE PTR __k$[ebp+15], dl
  00122	8a 50 10	 mov	 dl, BYTE PTR [eax+16]
  00125	84 d2		 test	 dl, dl
  00127	0f 84 af 00 00
	00		 je	 $LN80@LoadInt_e@13
  0012d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00130	88 55 f0	 mov	 BYTE PTR __k$[ebp+16], dl
  00133	8a 50 11	 mov	 dl, BYTE PTR [eax+17]
  00136	84 d2		 test	 dl, dl
  00138	0f 84 98 00 00
	00		 je	 $LN79@LoadInt_e@13
  0013e	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00141	88 55 f1	 mov	 BYTE PTR __k$[ebp+17], dl
  00144	8a 50 12	 mov	 dl, BYTE PTR [eax+18]
  00147	84 d2		 test	 dl, dl
  00149	0f 84 82 00 00
	00		 je	 $LN78@LoadInt_e@13
  0014f	32 d1		 xor	 dl, cl
  00151	88 55 f2	 mov	 BYTE PTR __k$[ebp+18], dl
  00154	8a 50 13	 mov	 dl, BYTE PTR [eax+19]
  00157	84 d2		 test	 dl, dl
  00159	74 71		 je	 SHORT $LN77@LoadInt_e@13
  0015b	32 d3		 xor	 dl, bl
  0015d	88 55 f3	 mov	 BYTE PTR __k$[ebp+19], dl
  00160	8a 50 14	 mov	 dl, BYTE PTR [eax+20]
  00163	84 d2		 test	 dl, dl
  00165	74 5f		 je	 SHORT $LN76@LoadInt_e@13
  00167	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0016a	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0016e	88 55 f4	 mov	 BYTE PTR __k$[ebp+20], dl
  00171	0f 84 c3 00 00
	00		 je	 $LN1@LoadInt_e@13
  00177	8a 50 16	 mov	 dl, BYTE PTR [eax+22]
  0017a	84 d2		 test	 dl, dl
  0017c	74 43		 je	 SHORT $LN74@LoadInt_e@13
  0017e	32 d1		 xor	 dl, cl
  00180	88 55 f6	 mov	 BYTE PTR __k$[ebp+22], dl
  00183	8a 50 17	 mov	 dl, BYTE PTR [eax+23]
  00186	84 d2		 test	 dl, dl
  00188	74 32		 je	 SHORT $LN73@LoadInt_e@13
  0018a	32 d3		 xor	 dl, bl
  0018c	88 55 f7	 mov	 BYTE PTR __k$[ebp+23], dl
  0018f	8a 50 18	 mov	 dl, BYTE PTR [eax+24]
  00192	84 d2		 test	 dl, dl
  00194	74 20		 je	 SHORT $LN72@LoadInt_e@13
  00196	8a 40 19	 mov	 al, BYTE PTR [eax+25]
  00199	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0019c	88 55 f8	 mov	 BYTE PTR __k$[ebp+24], dl
  0019f	84 c0		 test	 al, al
  001a1	74 0a		 je	 SHORT $LN71@LoadInt_e@13
  001a3	34 ec		 xor	 al, -20			; ffffffecH
  001a5	88 45 f9	 mov	 BYTE PTR __k$[ebp+25], al
  001a8	e9 8d 00 00 00	 jmp	 $LN1@LoadInt_e@13
$LN71@LoadInt_e@13:
  001ad	c6 45 f9 ec	 mov	 BYTE PTR __k$[ebp+25], -20 ; ffffffecH
  001b1	e9 84 00 00 00	 jmp	 $LN1@LoadInt_e@13
$LN72@LoadInt_e@13:
  001b6	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+24], -19 ; ffffffedH
  001ba	eb 7e		 jmp	 SHORT $LN1@LoadInt_e@13
$LN73@LoadInt_e@13:
  001bc	88 5d f7	 mov	 BYTE PTR __k$[ebp+23], bl
  001bf	eb 79		 jmp	 SHORT $LN1@LoadInt_e@13
$LN74@LoadInt_e@13:
  001c1	88 4d f6	 mov	 BYTE PTR __k$[ebp+22], cl
  001c4	eb 74		 jmp	 SHORT $LN1@LoadInt_e@13
$LN76@LoadInt_e@13:
  001c6	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+20], -19 ; ffffffedH
  001ca	eb 6e		 jmp	 SHORT $LN1@LoadInt_e@13
$LN77@LoadInt_e@13:
  001cc	88 5d f3	 mov	 BYTE PTR __k$[ebp+19], bl
  001cf	eb 69		 jmp	 SHORT $LN1@LoadInt_e@13
$LN78@LoadInt_e@13:
  001d1	88 4d f2	 mov	 BYTE PTR __k$[ebp+18], cl
  001d4	eb 64		 jmp	 SHORT $LN1@LoadInt_e@13
$LN79@LoadInt_e@13:
  001d6	c6 45 f1 ec	 mov	 BYTE PTR __k$[ebp+17], -20 ; ffffffecH
  001da	eb 5e		 jmp	 SHORT $LN1@LoadInt_e@13
$LN80@LoadInt_e@13:
  001dc	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+16], -19 ; ffffffedH
  001e0	eb 58		 jmp	 SHORT $LN1@LoadInt_e@13
$LN81@LoadInt_e@13:
  001e2	88 5d ef	 mov	 BYTE PTR __k$[ebp+15], bl
  001e5	eb 53		 jmp	 SHORT $LN1@LoadInt_e@13
$LN82@LoadInt_e@13:
  001e7	88 4d ee	 mov	 BYTE PTR __k$[ebp+14], cl
  001ea	eb 4e		 jmp	 SHORT $LN1@LoadInt_e@13
$LN83@LoadInt_e@13:
  001ec	c6 45 ed ec	 mov	 BYTE PTR __k$[ebp+13], -20 ; ffffffecH
  001f0	eb 48		 jmp	 SHORT $LN1@LoadInt_e@13
$LN84@LoadInt_e@13:
  001f2	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  001f6	eb 42		 jmp	 SHORT $LN1@LoadInt_e@13
$LN85@LoadInt_e@13:
  001f8	88 5d eb	 mov	 BYTE PTR __k$[ebp+11], bl
  001fb	eb 3d		 jmp	 SHORT $LN1@LoadInt_e@13
$LN86@LoadInt_e@13:
  001fd	88 4d ea	 mov	 BYTE PTR __k$[ebp+10], cl
  00200	eb 38		 jmp	 SHORT $LN1@LoadInt_e@13
$LN87@LoadInt_e@13:
  00202	c6 45 e9 ec	 mov	 BYTE PTR __k$[ebp+9], -20 ; ffffffecH
  00206	eb 32		 jmp	 SHORT $LN1@LoadInt_e@13
$LN88@LoadInt_e@13:
  00208	c6 45 e8 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  0020c	eb 2c		 jmp	 SHORT $LN1@LoadInt_e@13
$LN89@LoadInt_e@13:
  0020e	88 5d e7	 mov	 BYTE PTR __k$[ebp+7], bl
  00211	eb 27		 jmp	 SHORT $LN1@LoadInt_e@13
$LN90@LoadInt_e@13:
  00213	88 4d e6	 mov	 BYTE PTR __k$[ebp+6], cl
  00216	eb 22		 jmp	 SHORT $LN1@LoadInt_e@13
$LN91@LoadInt_e@13:
  00218	c6 45 e5 ec	 mov	 BYTE PTR __k$[ebp+5], -20 ; ffffffecH
  0021c	eb 1c		 jmp	 SHORT $LN1@LoadInt_e@13
$LN92@LoadInt_e@13:
  0021e	c6 45 e4 ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  00222	eb 16		 jmp	 SHORT $LN1@LoadInt_e@13
$LN93@LoadInt_e@13:
  00224	c6 45 e3 ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  00228	eb 10		 jmp	 SHORT $LN1@LoadInt_e@13
$LN94@LoadInt_e@13:
  0022a	c6 45 e2 eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  0022e	eb 0a		 jmp	 SHORT $LN1@LoadInt_e@13
$LN95@LoadInt_e@13:
  00230	c6 45 e1 ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  00234	eb 04		 jmp	 SHORT $LN1@LoadInt_e@13
$LN96@LoadInt_e@13:
  00236	c6 45 e0 ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@LoadInt_e@13:
  0023a	6a 05		 push	 5
  0023c	8d 45 e0	 lea	 eax, DWORD PTR __k$[ebp]
  0023f	c6 45 f5 00	 mov	 BYTE PTR __k$[ebp+21], 0
  00243	5a		 pop	 edx
$LL104@LoadInt_e@13:
  00244	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0024a	83 c0 04	 add	 eax, 4
  0024d	4a		 dec	 edx
  0024e	75 f4		 jne	 SHORT $LL104@LoadInt_e@13

; 120  : 		return LoadInt(_k, i);

  00250	ff 75 0c	 push	 DWORD PTR _i$[ebp]
  00253	80 75 f4 ed	 xor	 BYTE PTR __k$[ebp+20], -19 ; ffffffedH
  00257	8d 45 e0	 lea	 eax, DWORD PTR __k$[ebp]
  0025a	50		 push	 eax
  0025b	8b ce		 mov	 ecx, esi
  0025d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 121  : 	}

  00263	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00266	5e		 pop	 esi
  00267	33 cd		 xor	 ecx, ebp
  00269	5b		 pop	 ebx
  0026a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0026f	c9		 leave
  00270	c2 08 00	 ret	 8
??$LoadInt_e@$0BG@@ioINILoader@@QAEHAAY0BG@$$CBDH@Z ENDP ; ioINILoader::LoadInt_e<22>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadInt_e@$0L@@ioINILoader@@QAEHAAY0L@$$CBDH@Z ; ioINILoader::LoadInt_e<11>
; Function compile flags: /Ogsp
;	COMDAT ??$LoadInt_e@$0L@@ioINILoader@@QAEHAAY0L@$$CBDH@Z
_TEXT	SEGMENT
__k$ = -20						; size = 11
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_i$ = 12						; size = 4
??$LoadInt_e@$0L@@ioINILoader@@QAEHAAY0L@$$CBDH@Z PROC	; ioINILoader::LoadInt_e<11>, COMDAT
; _this$ = ecx

; 118  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 119  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	84 d2		 test	 dl, dl
  0001a	0f 84 24 01 00
	00		 je	 $LN96@LoadInt_e@14
  00020	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00023	88 55 ec	 mov	 BYTE PTR __k$[ebp], dl
  00026	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00029	84 d2		 test	 dl, dl
  0002b	0f 84 0d 01 00
	00		 je	 $LN95@LoadInt_e@14
  00031	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00034	88 55 ed	 mov	 BYTE PTR __k$[ebp+1], dl
  00037	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003a	84 d2		 test	 dl, dl
  0003c	0f 84 f6 00 00
	00		 je	 $LN94@LoadInt_e@14
  00042	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00045	88 55 ee	 mov	 BYTE PTR __k$[ebp+2], dl
  00048	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004b	84 d2		 test	 dl, dl
  0004d	0f 84 df 00 00
	00		 je	 $LN93@LoadInt_e@14
  00053	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00056	88 55 ef	 mov	 BYTE PTR __k$[ebp+3], dl
  00059	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005c	84 d2		 test	 dl, dl
  0005e	0f 84 c8 00 00
	00		 je	 $LN92@LoadInt_e@14
  00064	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00067	88 55 f0	 mov	 BYTE PTR __k$[ebp+4], dl
  0006a	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006d	84 d2		 test	 dl, dl
  0006f	0f 84 b1 00 00
	00		 je	 $LN91@LoadInt_e@14
  00075	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00078	88 55 f1	 mov	 BYTE PTR __k$[ebp+5], dl
  0007b	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0007e	84 d2		 test	 dl, dl
  00080	0f 84 9a 00 00
	00		 je	 $LN90@LoadInt_e@14
  00086	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00089	88 55 f2	 mov	 BYTE PTR __k$[ebp+6], dl
  0008c	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0008f	84 d2		 test	 dl, dl
  00091	0f 84 83 00 00
	00		 je	 $LN89@LoadInt_e@14
  00097	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009a	88 55 f3	 mov	 BYTE PTR __k$[ebp+7], dl
  0009d	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a0	84 d2		 test	 dl, dl
  000a2	74 70		 je	 SHORT $LN88@LoadInt_e@14
  000a4	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000a7	88 55 f4	 mov	 BYTE PTR __k$[ebp+8], dl
  000aa	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000ad	84 d2		 test	 dl, dl
  000af	74 5d		 je	 SHORT $LN87@LoadInt_e@14
  000b1	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000b4	80 78 0a 00	 cmp	 BYTE PTR [eax+10], 0
  000b8	88 55 f5	 mov	 BYTE PTR __k$[ebp+9], dl
  000bb	0f 84 87 00 00
	00		 je	 $LN1@LoadInt_e@14
  000c1	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000c4	84 d2		 test	 dl, dl
  000c6	74 40		 je	 SHORT $LN85@LoadInt_e@14
  000c8	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000cb	88 55 f7	 mov	 BYTE PTR __k$[ebp+11], dl
  000ce	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000d1	84 d2		 test	 dl, dl
  000d3	74 2d		 je	 SHORT $LN84@LoadInt_e@14
  000d5	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000d8	88 55 f8	 mov	 BYTE PTR __k$[ebp+12], dl
  000db	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000de	84 d2		 test	 dl, dl
  000e0	74 1a		 je	 SHORT $LN83@LoadInt_e@14
  000e2	8a 40 0e	 mov	 al, BYTE PTR [eax+14]
  000e5	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000e8	88 55 f9	 mov	 BYTE PTR __k$[ebp+13], dl
  000eb	84 c0		 test	 al, al
  000ed	74 07		 je	 SHORT $LN82@LoadInt_e@14
  000ef	34 eb		 xor	 al, -21			; ffffffebH
  000f1	88 45 fa	 mov	 BYTE PTR __k$[ebp+14], al
  000f4	eb 52		 jmp	 SHORT $LN1@LoadInt_e@14
$LN82@LoadInt_e@14:
  000f6	c6 45 fa eb	 mov	 BYTE PTR __k$[ebp+14], -21 ; ffffffebH
  000fa	eb 4c		 jmp	 SHORT $LN1@LoadInt_e@14
$LN83@LoadInt_e@14:
  000fc	c6 45 f9 ec	 mov	 BYTE PTR __k$[ebp+13], -20 ; ffffffecH
  00100	eb 46		 jmp	 SHORT $LN1@LoadInt_e@14
$LN84@LoadInt_e@14:
  00102	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  00106	eb 40		 jmp	 SHORT $LN1@LoadInt_e@14
$LN85@LoadInt_e@14:
  00108	c6 45 f7 ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  0010c	eb 3a		 jmp	 SHORT $LN1@LoadInt_e@14
$LN87@LoadInt_e@14:
  0010e	c6 45 f5 ec	 mov	 BYTE PTR __k$[ebp+9], -20 ; ffffffecH
  00112	eb 34		 jmp	 SHORT $LN1@LoadInt_e@14
$LN88@LoadInt_e@14:
  00114	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  00118	eb 2e		 jmp	 SHORT $LN1@LoadInt_e@14
$LN89@LoadInt_e@14:
  0011a	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  0011e	eb 28		 jmp	 SHORT $LN1@LoadInt_e@14
$LN90@LoadInt_e@14:
  00120	c6 45 f2 eb	 mov	 BYTE PTR __k$[ebp+6], -21 ; ffffffebH
  00124	eb 22		 jmp	 SHORT $LN1@LoadInt_e@14
$LN91@LoadInt_e@14:
  00126	c6 45 f1 ec	 mov	 BYTE PTR __k$[ebp+5], -20 ; ffffffecH
  0012a	eb 1c		 jmp	 SHORT $LN1@LoadInt_e@14
$LN92@LoadInt_e@14:
  0012c	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  00130	eb 16		 jmp	 SHORT $LN1@LoadInt_e@14
$LN93@LoadInt_e@14:
  00132	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  00136	eb 10		 jmp	 SHORT $LN1@LoadInt_e@14
$LN94@LoadInt_e@14:
  00138	c6 45 ee eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  0013c	eb 0a		 jmp	 SHORT $LN1@LoadInt_e@14
$LN95@LoadInt_e@14:
  0013e	c6 45 ed ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  00142	eb 04		 jmp	 SHORT $LN1@LoadInt_e@14
$LN96@LoadInt_e@14:
  00144	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@LoadInt_e@14:
  00148	6a 02		 push	 2
  0014a	8d 45 ec	 lea	 eax, DWORD PTR __k$[ebp]
  0014d	c6 45 f6 00	 mov	 BYTE PTR __k$[ebp+10], 0
  00151	5a		 pop	 edx
$LL104@LoadInt_e@14:
  00152	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00158	83 c0 04	 add	 eax, 4
  0015b	4a		 dec	 edx
  0015c	75 f4		 jne	 SHORT $LL104@LoadInt_e@14
  0015e	6a 08		 push	 8
  00160	58		 pop	 eax
$LL101@LoadInt_e@14:
  00161	8b c8		 mov	 ecx, eax
  00163	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00169	79 05		 jns	 SHORT $LN111@LoadInt_e@14
  0016b	49		 dec	 ecx
  0016c	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0016f	41		 inc	 ecx
$LN111@LoadInt_e@14:
  00170	b2 ed		 mov	 dl, -19			; ffffffedH
  00172	2a d1		 sub	 dl, cl
  00174	30 54 05 ec	 xor	 BYTE PTR __k$[ebp+eax], dl
  00178	40		 inc	 eax
  00179	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0017c	7c e3		 jl	 SHORT $LL101@LoadInt_e@14

; 120  : 		return LoadInt(_k, i);

  0017e	ff 75 0c	 push	 DWORD PTR _i$[ebp]
  00181	8d 45 ec	 lea	 eax, DWORD PTR __k$[ebp]
  00184	50		 push	 eax
  00185	8b ce		 mov	 ecx, esi
  00187	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 121  : 	}

  0018d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00190	33 cd		 xor	 ecx, ebp
  00192	5e		 pop	 esi
  00193	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00198	c9		 leave
  00199	c2 08 00	 ret	 8
??$LoadInt_e@$0L@@ioINILoader@@QAEHAAY0L@$$CBDH@Z ENDP	; ioINILoader::LoadInt_e<11>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@PAURoomOptionInfo@@@std@@PAURoomOptionInfo@@AAPAU3@@std@@YAXAAV?$allocator@PAURoomOptionInfo@@@0@PAPAURoomOptionInfo@@AAPAU2@@Z ; std::_Cons_val<std::allocator<RoomOptionInfo *>,RoomOptionInfo *,RoomOptionInfo * &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@PAURoomOptionInfo@@@std@@PAURoomOptionInfo@@AAPAU3@@std@@YAXAAV?$allocator@PAURoomOptionInfo@@@0@PAPAURoomOptionInfo@@AAPAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@PAURoomOptionInfo@@@std@@PAURoomOptionInfo@@AAPAU3@@std@@YAXAAV?$allocator@PAURoomOptionInfo@@@0@PAPAURoomOptionInfo@@AAPAU2@@Z PROC ; std::_Cons_val<std::allocator<RoomOptionInfo *>,RoomOptionInfo *,RoomOptionInfo * &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN7@Cons_val
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000f	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@Cons_val:

; 281  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Cons_val@V?$allocator@PAURoomOptionInfo@@@std@@PAURoomOptionInfo@@AAPAU3@@std@@YAXAAV?$allocator@PAURoomOptionInfo@@@0@PAPAURoomOptionInfo@@AAPAU2@@Z ENDP ; std::_Cons_val<std::allocator<RoomOptionInfo *>,RoomOptionInfo *,RoomOptionInfo * &>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@PAUPreSetInfo@@@std@@PAUPreSetInfo@@AAPAU3@@std@@YAXAAV?$allocator@PAUPreSetInfo@@@0@PAPAUPreSetInfo@@AAPAU2@@Z ; std::_Cons_val<std::allocator<PreSetInfo *>,PreSetInfo *,PreSetInfo * &>
; Function compile flags: /Ogsp
;	COMDAT ??$_Cons_val@V?$allocator@PAUPreSetInfo@@@std@@PAUPreSetInfo@@AAPAU3@@std@@YAXAAV?$allocator@PAUPreSetInfo@@@0@PAPAUPreSetInfo@@AAPAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@PAUPreSetInfo@@@std@@PAUPreSetInfo@@AAPAU3@@std@@YAXAAV?$allocator@PAUPreSetInfo@@@0@PAPAUPreSetInfo@@AAPAU2@@Z PROC ; std::_Cons_val<std::allocator<PreSetInfo *>,PreSetInfo *,PreSetInfo * &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN7@Cons_val@2
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000f	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@Cons_val@2:

; 281  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Cons_val@V?$allocator@PAUPreSetInfo@@@std@@PAUPreSetInfo@@AAPAU3@@std@@YAXAAV?$allocator@PAUPreSetInfo@@@0@PAPAUPreSetInfo@@AAPAU2@@Z ENDP ; std::_Cons_val<std::allocator<PreSetInfo *>,PreSetInfo *,PreSetInfo * &>
_TEXT	ENDS
PUBLIC	??$_Move@PAPAURoomOptionInfo@@PAPAU1@@std@@YAPAPAURoomOptionInfo@@PAPAU1@00@Z ; std::_Move<RoomOptionInfo * *,RoomOptionInfo * *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAPAURoomOptionInfo@@PAPAU1@@std@@YAPAPAURoomOptionInfo@@PAPAU1@00@Z
_TEXT	SEGMENT
__Cat$532317 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAPAURoomOptionInfo@@PAPAU1@@std@@YAPAPAURoomOptionInfo@@PAPAU1@00@Z PROC ; std::_Move<RoomOptionInfo * *,RoomOptionInfo * *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$532317[ebp]
  00007	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Move@PAPAURoomOptionInfo@@PAPAU1@@std@@YAPAPAURoomOptionInfo@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<RoomOptionInfo * *,RoomOptionInfo * *>
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00018	c9		 leave
  00019	c3		 ret	 0
??$_Move@PAPAURoomOptionInfo@@PAPAU1@@std@@YAPAPAURoomOptionInfo@@PAPAU1@00@Z ENDP ; std::_Move<RoomOptionInfo * *,RoomOptionInfo * *>
_TEXT	ENDS
PUBLIC	??$_Move@PAPAUPreSetInfo@@PAPAU1@@std@@YAPAPAUPreSetInfo@@PAPAU1@00@Z ; std::_Move<PreSetInfo * *,PreSetInfo * *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Move@PAPAUPreSetInfo@@PAPAU1@@std@@YAPAPAUPreSetInfo@@PAPAU1@00@Z
_TEXT	SEGMENT
__Cat$532324 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAPAUPreSetInfo@@PAPAU1@@std@@YAPAPAUPreSetInfo@@PAPAU1@00@Z PROC ; std::_Move<PreSetInfo * *,PreSetInfo * *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$532324[ebp]
  00007	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Move@PAPAUPreSetInfo@@PAPAU1@@std@@YAPAPAUPreSetInfo@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<PreSetInfo * *,PreSetInfo * *>
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00018	c9		 leave
  00019	c3		 ret	 0
??$_Move@PAPAUPreSetInfo@@PAPAU1@@std@@YAPAPAUPreSetInfo@@PAPAU1@00@Z ENDP ; std::_Move<PreSetInfo * *,PreSetInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAURoomOptionInfo@@@std@@@std@@YAXPAPAURoomOptionInfo@@0AAV?$allocator@PAURoomOptionInfo@@@0@@Z ; std::_Destroy_range<std::allocator<RoomOptionInfo *> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAURoomOptionInfo@@@std@@@std@@YAXPAPAURoomOptionInfo@@0AAV?$allocator@PAURoomOptionInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAURoomOptionInfo@@@std@@@std@@YAXPAPAURoomOptionInfo@@0AAV?$allocator@PAURoomOptionInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<RoomOptionInfo *> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAURoomOptionInfo@@@std@@@std@@YAXPAPAURoomOptionInfo@@0AAV?$allocator@PAURoomOptionInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<RoomOptionInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAUPreSetInfo@@@std@@@std@@YAXPAPAUPreSetInfo@@0AAV?$allocator@PAUPreSetInfo@@@0@@Z ; std::_Destroy_range<std::allocator<PreSetInfo *> >
; Function compile flags: /Ogsp
;	COMDAT ??$_Destroy_range@V?$allocator@PAUPreSetInfo@@@std@@@std@@YAXPAPAUPreSetInfo@@0AAV?$allocator@PAUPreSetInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAUPreSetInfo@@@std@@@std@@YAXPAPAUPreSetInfo@@0AAV?$allocator@PAUPreSetInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<PreSetInfo *> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAUPreSetInfo@@@std@@@std@@YAXPAPAUPreSetInfo@@0AAV?$allocator@PAUPreSetInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<PreSetInfo *> >
_TEXT	ENDS
PUBLIC	?construct@?$allocator@H@std@@QAEXPAHABH@Z	; std::allocator<int>::construct
; Function compile flags: /Ogsp
;	COMDAT ?construct@?$allocator@H@std@@QAEXPAHABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@H@std@@QAEXPAHABH@Z PROC		; std::allocator<int>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 		_Construct(_Ptr, _Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN5@construct@3
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000f	89 08		 mov	 DWORD PTR [eax], ecx
$LN5@construct@3:

; 198  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?construct@?$allocator@H@std@@QAEXPAHABH@Z ENDP		; std::allocator<int>::construct
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAURoomOptionInfo@@@std@@QAEXPAPAURoomOptionInfo@@ABQAU3@@Z ; std::allocator<RoomOptionInfo *>::construct
; Function compile flags: /Ogsp
;	COMDAT ?construct@?$allocator@PAURoomOptionInfo@@@std@@QAEXPAPAURoomOptionInfo@@ABQAU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAURoomOptionInfo@@@std@@QAEXPAPAURoomOptionInfo@@ABQAU3@@Z PROC ; std::allocator<RoomOptionInfo *>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 		_Construct(_Ptr, _Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN5@construct@4
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000f	89 08		 mov	 DWORD PTR [eax], ecx
$LN5@construct@4:

; 198  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?construct@?$allocator@PAURoomOptionInfo@@@std@@QAEXPAPAURoomOptionInfo@@ABQAU3@@Z ENDP ; std::allocator<RoomOptionInfo *>::construct
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAUPreSetInfo@@@std@@QAEXPAPAUPreSetInfo@@ABQAU3@@Z ; std::allocator<PreSetInfo *>::construct
; Function compile flags: /Ogsp
;	COMDAT ?construct@?$allocator@PAUPreSetInfo@@@std@@QAEXPAPAUPreSetInfo@@ABQAU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAUPreSetInfo@@@std@@QAEXPAPAUPreSetInfo@@ABQAU3@@Z PROC ; std::allocator<PreSetInfo *>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 		_Construct(_Ptr, _Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN5@construct@5
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000f	89 08		 mov	 DWORD PTR [eax], ecx
$LN5@construct@5:

; 198  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?construct@?$allocator@PAUPreSetInfo@@@std@@QAEXPAPAUPreSetInfo@@ABQAU3@@Z ENDP ; std::allocator<PreSetInfo *>::construct
_TEXT	ENDS
PUBLIC	??$encodeString@$0CA@@ioINILoader_e@@AAEPADAAY0CA@$$CBDPAD@Z ; ioINILoader_e::encodeString<32>
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\io3dengine\ioiniloader.h
;	COMDAT ??$encodeString@$0CA@@ioINILoader_e@@AAEPADAAY0CA@$$CBDPAD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_e$ = 12						; size = 4
??$encodeString@$0CA@@ioINILoader_e@@AAEPADAAY0CA@$$CBDPAD@Z PROC ; ioINILoader_e::encodeString<32>, COMDAT
; _this$ = ecx

; 215  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 216  : 		__ENCSTR(s, e);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00006	8a 11		 mov	 dl, BYTE PTR [ecx]
  00008	8b 45 0c	 mov	 eax, DWORD PTR _e$[ebp]
  0000b	53		 push	 ebx
  0000c	84 d2		 test	 dl, dl
  0000e	0f 84 6a 04 00
	00		 je	 $LN96@encodeStri
  00014	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00017	88 10		 mov	 BYTE PTR [eax], dl
  00019	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  0001c	84 d2		 test	 dl, dl
  0001e	0f 84 54 04 00
	00		 je	 $LN95@encodeStri
  00024	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00027	88 50 01	 mov	 BYTE PTR [eax+1], dl
  0002a	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  0002d	84 d2		 test	 dl, dl
  0002f	0f 84 3d 04 00
	00		 je	 $LN94@encodeStri
  00035	b3 eb		 mov	 bl, -21			; ffffffebH
  00037	32 d3		 xor	 dl, bl
  00039	88 50 02	 mov	 BYTE PTR [eax+2], dl
  0003c	8a 51 03	 mov	 dl, BYTE PTR [ecx+3]
  0003f	84 d2		 test	 dl, dl
  00041	0f 84 25 04 00
	00		 je	 $LN93@encodeStri
  00047	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0004a	88 50 03	 mov	 BYTE PTR [eax+3], dl
  0004d	8a 51 04	 mov	 dl, BYTE PTR [ecx+4]
  00050	84 d2		 test	 dl, dl
  00052	0f 84 0e 04 00
	00		 je	 $LN92@encodeStri
  00058	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0005b	88 50 04	 mov	 BYTE PTR [eax+4], dl
  0005e	8a 51 05	 mov	 dl, BYTE PTR [ecx+5]
  00061	84 d2		 test	 dl, dl
  00063	0f 84 f7 03 00
	00		 je	 $LN91@encodeStri
  00069	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0006c	88 50 05	 mov	 BYTE PTR [eax+5], dl
  0006f	8a 51 06	 mov	 dl, BYTE PTR [ecx+6]
  00072	84 d2		 test	 dl, dl
  00074	0f 84 e1 03 00
	00		 je	 $LN90@encodeStri
  0007a	32 d3		 xor	 dl, bl
  0007c	88 50 06	 mov	 BYTE PTR [eax+6], dl
  0007f	8a 51 07	 mov	 dl, BYTE PTR [ecx+7]
  00082	84 d2		 test	 dl, dl
  00084	0f 84 cb 03 00
	00		 je	 $LN89@encodeStri
  0008a	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0008d	88 50 07	 mov	 BYTE PTR [eax+7], dl
  00090	8a 51 08	 mov	 dl, BYTE PTR [ecx+8]
  00093	84 d2		 test	 dl, dl
  00095	0f 84 b4 03 00
	00		 je	 $LN88@encodeStri
  0009b	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0009e	88 50 08	 mov	 BYTE PTR [eax+8], dl
  000a1	8a 51 09	 mov	 dl, BYTE PTR [ecx+9]
  000a4	84 d2		 test	 dl, dl
  000a6	0f 84 9d 03 00
	00		 je	 $LN87@encodeStri
  000ac	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000af	88 50 09	 mov	 BYTE PTR [eax+9], dl
  000b2	8a 51 0a	 mov	 dl, BYTE PTR [ecx+10]
  000b5	84 d2		 test	 dl, dl
  000b7	0f 84 87 03 00
	00		 je	 $LN86@encodeStri
  000bd	32 d3		 xor	 dl, bl
  000bf	88 50 0a	 mov	 BYTE PTR [eax+10], dl
  000c2	8a 51 0b	 mov	 dl, BYTE PTR [ecx+11]
  000c5	84 d2		 test	 dl, dl
  000c7	0f 84 71 03 00
	00		 je	 $LN85@encodeStri
  000cd	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000d0	88 50 0b	 mov	 BYTE PTR [eax+11], dl
  000d3	8a 51 0c	 mov	 dl, BYTE PTR [ecx+12]
  000d6	84 d2		 test	 dl, dl
  000d8	0f 84 5a 03 00
	00		 je	 $LN84@encodeStri
  000de	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000e1	88 50 0c	 mov	 BYTE PTR [eax+12], dl
  000e4	8a 51 0d	 mov	 dl, BYTE PTR [ecx+13]
  000e7	84 d2		 test	 dl, dl
  000e9	0f 84 43 03 00
	00		 je	 $LN83@encodeStri
  000ef	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000f2	88 50 0d	 mov	 BYTE PTR [eax+13], dl
  000f5	8a 51 0e	 mov	 dl, BYTE PTR [ecx+14]
  000f8	84 d2		 test	 dl, dl
  000fa	0f 84 2d 03 00
	00		 je	 $LN82@encodeStri
  00100	32 d3		 xor	 dl, bl
  00102	88 50 0e	 mov	 BYTE PTR [eax+14], dl
  00105	8a 51 0f	 mov	 dl, BYTE PTR [ecx+15]
  00108	84 d2		 test	 dl, dl
  0010a	0f 84 17 03 00
	00		 je	 $LN81@encodeStri
  00110	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00113	88 50 0f	 mov	 BYTE PTR [eax+15], dl
  00116	8a 51 10	 mov	 dl, BYTE PTR [ecx+16]
  00119	84 d2		 test	 dl, dl
  0011b	0f 84 00 03 00
	00		 je	 $LN80@encodeStri
  00121	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00124	88 50 10	 mov	 BYTE PTR [eax+16], dl
  00127	8a 51 11	 mov	 dl, BYTE PTR [ecx+17]
  0012a	84 d2		 test	 dl, dl
  0012c	0f 84 e9 02 00
	00		 je	 $LN79@encodeStri
  00132	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00135	88 50 11	 mov	 BYTE PTR [eax+17], dl
  00138	8a 51 12	 mov	 dl, BYTE PTR [ecx+18]
  0013b	84 d2		 test	 dl, dl
  0013d	0f 84 d3 02 00
	00		 je	 $LN78@encodeStri
  00143	32 d3		 xor	 dl, bl
  00145	88 50 12	 mov	 BYTE PTR [eax+18], dl
  00148	8a 51 13	 mov	 dl, BYTE PTR [ecx+19]
  0014b	84 d2		 test	 dl, dl
  0014d	0f 84 bd 02 00
	00		 je	 $LN77@encodeStri
  00153	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00156	88 50 13	 mov	 BYTE PTR [eax+19], dl
  00159	8a 51 14	 mov	 dl, BYTE PTR [ecx+20]
  0015c	84 d2		 test	 dl, dl
  0015e	0f 84 a6 02 00
	00		 je	 $LN76@encodeStri
  00164	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00167	88 50 14	 mov	 BYTE PTR [eax+20], dl
  0016a	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  0016d	84 d2		 test	 dl, dl
  0016f	0f 84 8f 02 00
	00		 je	 $LN75@encodeStri
  00175	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00178	88 50 15	 mov	 BYTE PTR [eax+21], dl
  0017b	8a 51 16	 mov	 dl, BYTE PTR [ecx+22]
  0017e	84 d2		 test	 dl, dl
  00180	0f 84 79 02 00
	00		 je	 $LN74@encodeStri
  00186	32 d3		 xor	 dl, bl
  00188	88 50 16	 mov	 BYTE PTR [eax+22], dl
  0018b	8a 51 17	 mov	 dl, BYTE PTR [ecx+23]
  0018e	84 d2		 test	 dl, dl
  00190	0f 84 60 02 00
	00		 je	 $LN73@encodeStri
  00196	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00199	88 50 17	 mov	 BYTE PTR [eax+23], dl
  0019c	8a 51 18	 mov	 dl, BYTE PTR [ecx+24]
  0019f	84 d2		 test	 dl, dl
  001a1	0f 84 46 02 00
	00		 je	 $LN72@encodeStri
  001a7	80 f2 ed	 xor	 dl, -19			; ffffffedH
  001aa	88 50 18	 mov	 BYTE PTR [eax+24], dl
  001ad	8a 51 19	 mov	 dl, BYTE PTR [ecx+25]
  001b0	84 d2		 test	 dl, dl
  001b2	0f 84 2c 02 00
	00		 je	 $LN71@encodeStri
  001b8	80 f2 ec	 xor	 dl, -20			; ffffffecH
  001bb	88 50 19	 mov	 BYTE PTR [eax+25], dl
  001be	8a 51 1a	 mov	 dl, BYTE PTR [ecx+26]
  001c1	84 d2		 test	 dl, dl
  001c3	0f 84 13 02 00
	00		 je	 $LN70@encodeStri
  001c9	32 d3		 xor	 dl, bl
  001cb	88 50 1a	 mov	 BYTE PTR [eax+26], dl
  001ce	8a 51 1b	 mov	 dl, BYTE PTR [ecx+27]
  001d1	84 d2		 test	 dl, dl
  001d3	0f 84 fa 01 00
	00		 je	 $LN69@encodeStri
  001d9	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  001dc	88 50 1b	 mov	 BYTE PTR [eax+27], dl
  001df	8a 51 1c	 mov	 dl, BYTE PTR [ecx+28]
  001e2	84 d2		 test	 dl, dl
  001e4	0f 84 e0 01 00
	00		 je	 $LN68@encodeStri
  001ea	80 f2 ed	 xor	 dl, -19			; ffffffedH
  001ed	88 50 1c	 mov	 BYTE PTR [eax+28], dl
  001f0	8a 51 1d	 mov	 dl, BYTE PTR [ecx+29]
  001f3	84 d2		 test	 dl, dl
  001f5	0f 84 c6 01 00
	00		 je	 $LN67@encodeStri
  001fb	80 f2 ec	 xor	 dl, -20			; ffffffecH
  001fe	88 50 1d	 mov	 BYTE PTR [eax+29], dl
  00201	8a 51 1e	 mov	 dl, BYTE PTR [ecx+30]
  00204	84 d2		 test	 dl, dl
  00206	0f 84 ad 01 00
	00		 je	 $LN66@encodeStri
  0020c	32 d3		 xor	 dl, bl
  0020e	88 50 1e	 mov	 BYTE PTR [eax+30], dl
  00211	8a 51 1f	 mov	 dl, BYTE PTR [ecx+31]
  00214	84 d2		 test	 dl, dl
  00216	0f 84 94 01 00
	00		 je	 $LN65@encodeStri
  0021c	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0021f	88 50 1f	 mov	 BYTE PTR [eax+31], dl
  00222	8a 51 20	 mov	 dl, BYTE PTR [ecx+32]
  00225	84 d2		 test	 dl, dl
  00227	0f 84 7a 01 00
	00		 je	 $LN64@encodeStri
  0022d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00230	88 50 20	 mov	 BYTE PTR [eax+32], dl
  00233	8a 51 21	 mov	 dl, BYTE PTR [ecx+33]
  00236	84 d2		 test	 dl, dl
  00238	0f 84 60 01 00
	00		 je	 $LN63@encodeStri
  0023e	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00241	88 50 21	 mov	 BYTE PTR [eax+33], dl
  00244	8a 51 22	 mov	 dl, BYTE PTR [ecx+34]
  00247	84 d2		 test	 dl, dl
  00249	0f 84 47 01 00
	00		 je	 $LN62@encodeStri
  0024f	32 d3		 xor	 dl, bl
  00251	88 50 22	 mov	 BYTE PTR [eax+34], dl
  00254	8a 51 23	 mov	 dl, BYTE PTR [ecx+35]
  00257	84 d2		 test	 dl, dl
  00259	0f 84 2e 01 00
	00		 je	 $LN61@encodeStri
  0025f	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00262	88 50 23	 mov	 BYTE PTR [eax+35], dl
  00265	8a 51 24	 mov	 dl, BYTE PTR [ecx+36]
  00268	84 d2		 test	 dl, dl
  0026a	0f 84 14 01 00
	00		 je	 $LN60@encodeStri
  00270	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00273	88 50 24	 mov	 BYTE PTR [eax+36], dl
  00276	8a 51 25	 mov	 dl, BYTE PTR [ecx+37]
  00279	84 d2		 test	 dl, dl
  0027b	0f 84 fa 00 00
	00		 je	 $LN59@encodeStri
  00281	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00284	88 50 25	 mov	 BYTE PTR [eax+37], dl
  00287	8a 51 26	 mov	 dl, BYTE PTR [ecx+38]
  0028a	84 d2		 test	 dl, dl
  0028c	0f 84 e1 00 00
	00		 je	 $LN58@encodeStri
  00292	32 d3		 xor	 dl, bl
  00294	88 50 26	 mov	 BYTE PTR [eax+38], dl
  00297	8a 51 27	 mov	 dl, BYTE PTR [ecx+39]
  0029a	84 d2		 test	 dl, dl
  0029c	0f 84 c8 00 00
	00		 je	 $LN57@encodeStri
  002a2	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  002a5	88 50 27	 mov	 BYTE PTR [eax+39], dl
  002a8	8a 51 28	 mov	 dl, BYTE PTR [ecx+40]
  002ab	84 d2		 test	 dl, dl
  002ad	0f 84 ae 00 00
	00		 je	 $LN56@encodeStri
  002b3	80 f2 ed	 xor	 dl, -19			; ffffffedH
  002b6	88 50 28	 mov	 BYTE PTR [eax+40], dl
  002b9	8a 51 29	 mov	 dl, BYTE PTR [ecx+41]
  002bc	84 d2		 test	 dl, dl
  002be	0f 84 94 00 00
	00		 je	 $LN55@encodeStri
  002c4	80 f2 ec	 xor	 dl, -20			; ffffffecH
  002c7	88 50 29	 mov	 BYTE PTR [eax+41], dl
  002ca	8a 51 2a	 mov	 dl, BYTE PTR [ecx+42]
  002cd	84 d2		 test	 dl, dl
  002cf	74 7f		 je	 SHORT $LN54@encodeStri
  002d1	32 d3		 xor	 dl, bl
  002d3	88 50 2a	 mov	 BYTE PTR [eax+42], dl
  002d6	8a 51 2b	 mov	 dl, BYTE PTR [ecx+43]
  002d9	84 d2		 test	 dl, dl
  002db	74 6a		 je	 SHORT $LN53@encodeStri
  002dd	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  002e0	88 50 2b	 mov	 BYTE PTR [eax+43], dl
  002e3	8a 51 2c	 mov	 dl, BYTE PTR [ecx+44]
  002e6	84 d2		 test	 dl, dl
  002e8	74 54		 je	 SHORT $LN52@encodeStri
  002ea	80 f2 ed	 xor	 dl, -19			; ffffffedH
  002ed	88 50 2c	 mov	 BYTE PTR [eax+44], dl
  002f0	8a 51 2d	 mov	 dl, BYTE PTR [ecx+45]
  002f3	84 d2		 test	 dl, dl
  002f5	74 3e		 je	 SHORT $LN51@encodeStri
  002f7	80 f2 ec	 xor	 dl, -20			; ffffffecH
  002fa	88 50 2d	 mov	 BYTE PTR [eax+45], dl
  002fd	8a 51 2e	 mov	 dl, BYTE PTR [ecx+46]
  00300	84 d2		 test	 dl, dl
  00302	74 29		 je	 SHORT $LN50@encodeStri
  00304	32 d3		 xor	 dl, bl
  00306	88 50 2e	 mov	 BYTE PTR [eax+46], dl
  00309	8a 51 2f	 mov	 dl, BYTE PTR [ecx+47]
  0030c	84 d2		 test	 dl, dl
  0030e	74 14		 je	 SHORT $LN49@encodeStri
  00310	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00313	88 50 2f	 mov	 BYTE PTR [eax+47], dl
  00316	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  00319	80 f1 ed	 xor	 cl, -19			; ffffffedH
  0031c	88 48 30	 mov	 BYTE PTR [eax+48], cl
  0031f	e9 5d 01 00 00	 jmp	 $LN1@encodeStri
$LN49@encodeStri:
  00324	c6 40 2f ea	 mov	 BYTE PTR [eax+47], -22	; ffffffeaH
  00328	e9 54 01 00 00	 jmp	 $LN1@encodeStri
$LN50@encodeStri:
  0032d	88 58 2e	 mov	 BYTE PTR [eax+46], bl
  00330	e9 4c 01 00 00	 jmp	 $LN1@encodeStri
$LN51@encodeStri:
  00335	c6 40 2d ec	 mov	 BYTE PTR [eax+45], -20	; ffffffecH
  00339	e9 43 01 00 00	 jmp	 $LN1@encodeStri
$LN52@encodeStri:
  0033e	c6 40 2c ed	 mov	 BYTE PTR [eax+44], -19	; ffffffedH
  00342	e9 3a 01 00 00	 jmp	 $LN1@encodeStri
$LN53@encodeStri:
  00347	c6 40 2b ea	 mov	 BYTE PTR [eax+43], -22	; ffffffeaH
  0034b	e9 31 01 00 00	 jmp	 $LN1@encodeStri
$LN54@encodeStri:
  00350	88 58 2a	 mov	 BYTE PTR [eax+42], bl
  00353	e9 29 01 00 00	 jmp	 $LN1@encodeStri
$LN55@encodeStri:
  00358	c6 40 29 ec	 mov	 BYTE PTR [eax+41], -20	; ffffffecH
  0035c	e9 20 01 00 00	 jmp	 $LN1@encodeStri
$LN56@encodeStri:
  00361	c6 40 28 ed	 mov	 BYTE PTR [eax+40], -19	; ffffffedH
  00365	e9 17 01 00 00	 jmp	 $LN1@encodeStri
$LN57@encodeStri:
  0036a	c6 40 27 ea	 mov	 BYTE PTR [eax+39], -22	; ffffffeaH
  0036e	e9 0e 01 00 00	 jmp	 $LN1@encodeStri
$LN58@encodeStri:
  00373	88 58 26	 mov	 BYTE PTR [eax+38], bl
  00376	e9 06 01 00 00	 jmp	 $LN1@encodeStri
$LN59@encodeStri:
  0037b	c6 40 25 ec	 mov	 BYTE PTR [eax+37], -20	; ffffffecH
  0037f	e9 fd 00 00 00	 jmp	 $LN1@encodeStri
$LN60@encodeStri:
  00384	c6 40 24 ed	 mov	 BYTE PTR [eax+36], -19	; ffffffedH
  00388	e9 f4 00 00 00	 jmp	 $LN1@encodeStri
$LN61@encodeStri:
  0038d	c6 40 23 ea	 mov	 BYTE PTR [eax+35], -22	; ffffffeaH
  00391	e9 eb 00 00 00	 jmp	 $LN1@encodeStri
$LN62@encodeStri:
  00396	88 58 22	 mov	 BYTE PTR [eax+34], bl
  00399	e9 e3 00 00 00	 jmp	 $LN1@encodeStri
$LN63@encodeStri:
  0039e	c6 40 21 ec	 mov	 BYTE PTR [eax+33], -20	; ffffffecH
  003a2	e9 da 00 00 00	 jmp	 $LN1@encodeStri
$LN64@encodeStri:
  003a7	c6 40 20 ed	 mov	 BYTE PTR [eax+32], -19	; ffffffedH
  003ab	e9 d1 00 00 00	 jmp	 $LN1@encodeStri
$LN65@encodeStri:
  003b0	c6 40 1f ea	 mov	 BYTE PTR [eax+31], -22	; ffffffeaH
  003b4	e9 c8 00 00 00	 jmp	 $LN1@encodeStri
$LN66@encodeStri:
  003b9	88 58 1e	 mov	 BYTE PTR [eax+30], bl
  003bc	e9 c0 00 00 00	 jmp	 $LN1@encodeStri
$LN67@encodeStri:
  003c1	c6 40 1d ec	 mov	 BYTE PTR [eax+29], -20	; ffffffecH
  003c5	e9 b7 00 00 00	 jmp	 $LN1@encodeStri
$LN68@encodeStri:
  003ca	c6 40 1c ed	 mov	 BYTE PTR [eax+28], -19	; ffffffedH
  003ce	e9 ae 00 00 00	 jmp	 $LN1@encodeStri
$LN69@encodeStri:
  003d3	c6 40 1b ea	 mov	 BYTE PTR [eax+27], -22	; ffffffeaH
  003d7	e9 a5 00 00 00	 jmp	 $LN1@encodeStri
$LN70@encodeStri:
  003dc	88 58 1a	 mov	 BYTE PTR [eax+26], bl
  003df	e9 9d 00 00 00	 jmp	 $LN1@encodeStri
$LN71@encodeStri:
  003e4	c6 40 19 ec	 mov	 BYTE PTR [eax+25], -20	; ffffffecH
  003e8	e9 94 00 00 00	 jmp	 $LN1@encodeStri
$LN72@encodeStri:
  003ed	c6 40 18 ed	 mov	 BYTE PTR [eax+24], -19	; ffffffedH
  003f1	e9 8b 00 00 00	 jmp	 $LN1@encodeStri
$LN73@encodeStri:
  003f6	c6 40 17 ea	 mov	 BYTE PTR [eax+23], -22	; ffffffeaH
  003fa	e9 82 00 00 00	 jmp	 $LN1@encodeStri
$LN74@encodeStri:
  003ff	88 58 16	 mov	 BYTE PTR [eax+22], bl
  00402	eb 7d		 jmp	 SHORT $LN1@encodeStri
$LN75@encodeStri:
  00404	c6 40 15 ec	 mov	 BYTE PTR [eax+21], -20	; ffffffecH
  00408	eb 77		 jmp	 SHORT $LN1@encodeStri
$LN76@encodeStri:
  0040a	c6 40 14 ed	 mov	 BYTE PTR [eax+20], -19	; ffffffedH
  0040e	eb 71		 jmp	 SHORT $LN1@encodeStri
$LN77@encodeStri:
  00410	c6 40 13 ea	 mov	 BYTE PTR [eax+19], -22	; ffffffeaH
  00414	eb 6b		 jmp	 SHORT $LN1@encodeStri
$LN78@encodeStri:
  00416	88 58 12	 mov	 BYTE PTR [eax+18], bl
  00419	eb 66		 jmp	 SHORT $LN1@encodeStri
$LN79@encodeStri:
  0041b	c6 40 11 ec	 mov	 BYTE PTR [eax+17], -20	; ffffffecH
  0041f	eb 60		 jmp	 SHORT $LN1@encodeStri
$LN80@encodeStri:
  00421	c6 40 10 ed	 mov	 BYTE PTR [eax+16], -19	; ffffffedH
  00425	eb 5a		 jmp	 SHORT $LN1@encodeStri
$LN81@encodeStri:
  00427	c6 40 0f ea	 mov	 BYTE PTR [eax+15], -22	; ffffffeaH
  0042b	eb 54		 jmp	 SHORT $LN1@encodeStri
$LN82@encodeStri:
  0042d	88 58 0e	 mov	 BYTE PTR [eax+14], bl
  00430	eb 4f		 jmp	 SHORT $LN1@encodeStri
$LN83@encodeStri:
  00432	c6 40 0d ec	 mov	 BYTE PTR [eax+13], -20	; ffffffecH
  00436	eb 49		 jmp	 SHORT $LN1@encodeStri
$LN84@encodeStri:
  00438	c6 40 0c ed	 mov	 BYTE PTR [eax+12], -19	; ffffffedH
  0043c	eb 43		 jmp	 SHORT $LN1@encodeStri
$LN85@encodeStri:
  0043e	c6 40 0b ea	 mov	 BYTE PTR [eax+11], -22	; ffffffeaH
  00442	eb 3d		 jmp	 SHORT $LN1@encodeStri
$LN86@encodeStri:
  00444	88 58 0a	 mov	 BYTE PTR [eax+10], bl
  00447	eb 38		 jmp	 SHORT $LN1@encodeStri
$LN87@encodeStri:
  00449	c6 40 09 ec	 mov	 BYTE PTR [eax+9], -20	; ffffffecH
  0044d	eb 32		 jmp	 SHORT $LN1@encodeStri
$LN88@encodeStri:
  0044f	c6 40 08 ed	 mov	 BYTE PTR [eax+8], -19	; ffffffedH
  00453	eb 2c		 jmp	 SHORT $LN1@encodeStri
$LN89@encodeStri:
  00455	c6 40 07 ea	 mov	 BYTE PTR [eax+7], -22	; ffffffeaH
  00459	eb 26		 jmp	 SHORT $LN1@encodeStri
$LN90@encodeStri:
  0045b	88 58 06	 mov	 BYTE PTR [eax+6], bl
  0045e	eb 21		 jmp	 SHORT $LN1@encodeStri
$LN91@encodeStri:
  00460	c6 40 05 ec	 mov	 BYTE PTR [eax+5], -20	; ffffffecH
  00464	eb 1b		 jmp	 SHORT $LN1@encodeStri
$LN92@encodeStri:
  00466	c6 40 04 ed	 mov	 BYTE PTR [eax+4], -19	; ffffffedH
  0046a	eb 15		 jmp	 SHORT $LN1@encodeStri
$LN93@encodeStri:
  0046c	c6 40 03 ea	 mov	 BYTE PTR [eax+3], -22	; ffffffeaH
  00470	eb 0f		 jmp	 SHORT $LN1@encodeStri
$LN94@encodeStri:
  00472	c6 40 02 eb	 mov	 BYTE PTR [eax+2], -21	; ffffffebH
  00476	eb 09		 jmp	 SHORT $LN1@encodeStri
$LN95@encodeStri:
  00478	c6 40 01 ec	 mov	 BYTE PTR [eax+1], -20	; ffffffecH
  0047c	eb 03		 jmp	 SHORT $LN1@encodeStri
$LN96@encodeStri:
  0047e	c6 00 ed	 mov	 BYTE PTR [eax], -19	; ffffffedH
$LN1@encodeStri:
  00481	6a 07		 push	 7
  00483	5a		 pop	 edx
  00484	8b c8		 mov	 ecx, eax
  00486	c6 40 1f 00	 mov	 BYTE PTR [eax+31], 0
  0048a	5b		 pop	 ebx
$LL104@encodeStri:
  0048b	81 31 ed ec eb
	ea		 xor	 DWORD PTR [ecx], -353637139 ; eaebecedH
  00491	83 c1 04	 add	 ecx, 4
  00494	4a		 dec	 edx
  00495	75 f4		 jne	 SHORT $LL104@encodeStri
  00497	56		 push	 esi
  00498	6a 1c		 push	 28			; 0000001cH
  0049a	5e		 pop	 esi
$LL101@encodeStri:
  0049b	8b ce		 mov	 ecx, esi
  0049d	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  004a3	79 05		 jns	 SHORT $LN111@encodeStri
  004a5	49		 dec	 ecx
  004a6	83 c9 fc	 or	 ecx, -4			; fffffffcH
  004a9	41		 inc	 ecx
$LN111@encodeStri:
  004aa	b2 ed		 mov	 dl, -19			; ffffffedH
  004ac	2a d1		 sub	 dl, cl
  004ae	30 14 06	 xor	 BYTE PTR [esi+eax], dl
  004b1	46		 inc	 esi
  004b2	83 fe 1f	 cmp	 esi, 31			; 0000001fH
  004b5	7c e4		 jl	 SHORT $LL101@encodeStri
  004b7	5e		 pop	 esi

; 217  : 		return e;
; 218  : 	}

  004b8	5d		 pop	 ebp
  004b9	c2 08 00	 ret	 8
??$encodeString@$0CA@@ioINILoader_e@@AAEPADAAY0CA@$$CBDPAD@Z ENDP ; ioINILoader_e::encodeString<32>
_TEXT	ENDS
PUBLIC	??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z ; std::allocator<int>::construct<int &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z PROC	; std::allocator<int>::construct<int &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN3@construct@6
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000f	89 08		 mov	 DWORD PTR [eax], ecx
$LN3@construct@6:

; 209  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z ENDP	; std::allocator<int>::construct<int &>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAPAURoomOptionInfo@@PAPAU1@V?$allocator@PAURoomOptionInfo@@@std@@@std@@YAPAPAURoomOptionInfo@@PAPAU1@00AAV?$allocator@PAURoomOptionInfo@@@0@@Z ; std::_Uninitialized_move<RoomOptionInfo * *,RoomOptionInfo * *,std::allocator<RoomOptionInfo *> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAPAURoomOptionInfo@@PAPAU1@V?$allocator@PAURoomOptionInfo@@@std@@@std@@YAPAPAURoomOptionInfo@@PAPAU1@00AAV?$allocator@PAURoomOptionInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAURoomOptionInfo@@PAPAU1@V?$allocator@PAURoomOptionInfo@@@std@@@std@@YAPAPAURoomOptionInfo@@PAPAU1@00AAV?$allocator@PAURoomOptionInfo@@@0@@Z PROC ; std::_Uninitialized_move<RoomOptionInfo * *,RoomOptionInfo * *,std::allocator<RoomOptionInfo *> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  00007	2b 75 08	 sub	 esi, DWORD PTR __First$[ebp]
  0000a	c1 fe 02	 sar	 esi, 2
  0000d	c1 e6 02	 shl	 esi, 2
  00010	56		 push	 esi
  00011	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00014	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	03 c6		 add	 eax, esi
  00022	5e		 pop	 esi

; 472  : 	}

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$_Uninitialized_move@PAPAURoomOptionInfo@@PAPAU1@V?$allocator@PAURoomOptionInfo@@@std@@@std@@YAPAPAURoomOptionInfo@@PAPAU1@00AAV?$allocator@PAURoomOptionInfo@@@0@@Z ENDP ; std::_Uninitialized_move<RoomOptionInfo * *,RoomOptionInfo * *,std::allocator<RoomOptionInfo *> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAPAUPreSetInfo@@PAPAU1@V?$allocator@PAUPreSetInfo@@@std@@@std@@YAPAPAUPreSetInfo@@PAPAU1@00AAV?$allocator@PAUPreSetInfo@@@0@@Z ; std::_Uninitialized_move<PreSetInfo * *,PreSetInfo * *,std::allocator<PreSetInfo *> >
; Function compile flags: /Ogsp
;	COMDAT ??$_Uninitialized_move@PAPAUPreSetInfo@@PAPAU1@V?$allocator@PAUPreSetInfo@@@std@@@std@@YAPAPAUPreSetInfo@@PAPAU1@00AAV?$allocator@PAUPreSetInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAUPreSetInfo@@PAPAU1@V?$allocator@PAUPreSetInfo@@@std@@@std@@YAPAPAUPreSetInfo@@PAPAU1@00AAV?$allocator@PAUPreSetInfo@@@0@@Z PROC ; std::_Uninitialized_move<PreSetInfo * *,PreSetInfo * *,std::allocator<PreSetInfo *> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  00007	2b 75 08	 sub	 esi, DWORD PTR __First$[ebp]
  0000a	c1 fe 02	 sar	 esi, 2
  0000d	c1 e6 02	 shl	 esi, 2
  00010	56		 push	 esi
  00011	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00014	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	03 c6		 add	 eax, esi
  00022	5e		 pop	 esi

; 472  : 	}

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$_Uninitialized_move@PAPAUPreSetInfo@@PAPAU1@V?$allocator@PAUPreSetInfo@@@std@@@std@@YAPAPAUPreSetInfo@@PAPAU1@00AAV?$allocator@PAUPreSetInfo@@@0@@Z ENDP ; std::_Uninitialized_move<PreSetInfo * *,PreSetInfo * *,std::allocator<PreSetInfo *> >
_TEXT	ENDS
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 782  : 		return (iterator(this->_Myfirst, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 783  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
_TEXT	ENDS
PUBLIC	??0?$CEncrypt@M@@QAE@XZ				; CEncrypt<float>::CEncrypt<float>
EXTRN	??0ccddaabb@@QAE@XZ:PROC			; ccddaabb::ccddaabb
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
xdata$x	SEGMENT
__unwindtable$??0?$CEncrypt@M@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CEncrypt@M@@QAE@XZ$0
__ehfuncinfo$??0?$CEncrypt@M@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CEncrypt@M@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??0?$CEncrypt@M@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$CEncrypt@M@@QAE@XZ PROC				; CEncrypt<float>::CEncrypt<float>, COMDAT
; _this$ = ecx

; 109  : 	CEncrypt()

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0?$CEncrypt@M@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00014	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CEncrypt@M@@6B@
  0001a	e8 00 00 00 00	 call	 ??0ccddaabb@@QAE@XZ	; ccddaabb::ccddaabb
  0001f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 110  : 	{
; 111  : 		Init();

  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?Init@?$CEncrypt@M@@AAEXXZ ; CEncrypt<float>::Init

; 112  : 	}

  0002a	8b c6		 mov	 eax, esi
  0002c	e8 00 00 00 00	 call	 __EH_epilog3
  00031	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CEncrypt@M@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	e9 00 00 00 00	 jmp	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
__ehhandler$??0?$CEncrypt@M@@QAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$CEncrypt@M@@QAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$CEncrypt@M@@QAE@XZ ENDP				; CEncrypt<float>::CEncrypt<float>
PUBLIC	??B?$CEncrypt@M@@QAEMXZ				; CEncrypt<float>::operator float
; Function compile flags: /Ogsp
;	COMDAT ??B?$CEncrypt@M@@QAEMXZ
_TEXT	SEGMENT
_value$ = -4						; size = 4
??B?$CEncrypt@M@@QAEMXZ PROC				; CEncrypt<float>::operator float, COMDAT
; _this$ = ecx

; 134  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 135  : 		type value;
; 136  : 		DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool

; 137  : 
; 138  : #ifdef _NOTUSE
; 139  : 		Debug();
; 140  : #endif
; 141  : 		return value;

  0000d	d9 45 fc	 fld	 DWORD PTR _value$[ebp]

; 142  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@M@@QAEMXZ ENDP				; CEncrypt<float>::operator float
_TEXT	ENDS
PUBLIC	??4?$CEncrypt@M@@QAEMM@Z			; CEncrypt<float>::operator=
; Function compile flags: /Ogsp
;	COMDAT ??4?$CEncrypt@M@@QAEMM@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
_inValue$ = 8						; size = 4
??4?$CEncrypt@M@@QAEMM@Z PROC				; CEncrypt<float>::operator=, COMDAT
; _this$ = ecx

; 1654 : 	{	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1655 : 		type value = inValue;

  00003	d9 45 08	 fld	 DWORD PTR _inValue$[ebp]

; 1656 : 		EncryptValueToPool((char*)&value);

  00006	8d 45 08	 lea	 eax, DWORD PTR _value$[ebp]
  00009	50		 push	 eax
  0000a	d9 5d 08	 fstp	 DWORD PTR _value$[ebp]
  0000d	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 1657 : #ifdef _NOTUSE
; 1658 : 		m_value = inValue;
; 1659 : 		Debug();
; 1660 : #endif
; 1661 : 		return value;

  00012	d9 45 08	 fld	 DWORD PTR _value$[ebp]

; 1662 : 	}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??4?$CEncrypt@M@@QAEMM@Z ENDP				; CEncrypt<float>::operator=
_TEXT	ENDS
PUBLIC	??0?$CEncrypt@H@@QAE@XZ				; CEncrypt<int>::CEncrypt<int>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$CEncrypt@H@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CEncrypt@H@@QAE@XZ$0
__ehfuncinfo$??0?$CEncrypt@H@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CEncrypt@H@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??0?$CEncrypt@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$CEncrypt@H@@QAE@XZ PROC				; CEncrypt<int>::CEncrypt<int>, COMDAT
; _this$ = ecx

; 109  : 	CEncrypt()

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0?$CEncrypt@H@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00014	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CEncrypt@H@@6B@
  0001a	e8 00 00 00 00	 call	 ??0ccddaabb@@QAE@XZ	; ccddaabb::ccddaabb
  0001f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 110  : 	{
; 111  : 		Init();

  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?Init@?$CEncrypt@H@@AAEXXZ ; CEncrypt<int>::Init

; 112  : 	}

  0002a	8b c6		 mov	 eax, esi
  0002c	e8 00 00 00 00	 call	 __EH_epilog3
  00031	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CEncrypt@H@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	e9 00 00 00 00	 jmp	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
__ehhandler$??0?$CEncrypt@H@@QAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$CEncrypt@H@@QAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$CEncrypt@H@@QAE@XZ ENDP				; CEncrypt<int>::CEncrypt<int>
PUBLIC	??4?$CEncrypt@H@@QAEHH@Z			; CEncrypt<int>::operator=
; Function compile flags: /Ogsp
;	COMDAT ??4?$CEncrypt@H@@QAEHH@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
_inValue$ = 8						; size = 4
??4?$CEncrypt@H@@QAEHH@Z PROC				; CEncrypt<int>::operator=, COMDAT
; _this$ = ecx

; 843  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 844  : 		type value = inValue;

  00003	8b 45 08	 mov	 eax, DWORD PTR _inValue$[ebp]
  00006	89 45 08	 mov	 DWORD PTR _value$[ebp], eax

; 845  : 		EncryptValueToPool((char*)&value);

  00009	8d 45 08	 lea	 eax, DWORD PTR _value$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@H@@AAEXPBD@Z ; CEncrypt<int>::EncryptValueToPool

; 846  : #ifdef _NOTUSE
; 847  : 		m_value = inValue;
; 848  : 		Debug();
; 849  : #endif
; 850  : 		return value;

  00012	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]

; 851  : 	}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??4?$CEncrypt@H@@QAEHH@Z ENDP				; CEncrypt<int>::operator=
_TEXT	ENDS
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 792  : 		return (iterator(this->_Mylast, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 793  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z PROC ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z ENDP ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
; Function compile flags: /Ogsp
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
PUBLIC	?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z ; std::vector<int,std::allocator<int> >::_Grow_to
; Function compile flags: /Ogsp
;	COMDAT ?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z PROC ; std::vector<int,std::allocator<int> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1275 : 		size_type _Capacity = capacity();

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00008	ba ff ff ff 3f	 mov	 edx, 1073741823		; 3fffffffH
  0000d	c1 f8 02	 sar	 eax, 2
  00010	8b c8		 mov	 ecx, eax
  00012	d1 e9		 shr	 ecx, 1
  00014	2b d1		 sub	 edx, ecx
  00016	3b d0		 cmp	 edx, eax
  00018	73 04		 jae	 SHORT $LN4@Grow_to@3
  0001a	33 c0		 xor	 eax, eax
  0001c	eb 02		 jmp	 SHORT $LN5@Grow_to@3
$LN4@Grow_to@3:
  0001e	03 c1		 add	 eax, ecx
$LN5@Grow_to@3:

; 1279 : 		if (_Capacity < _Count)

  00020	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]

; 1280 : 			_Capacity = _Count;

  00023	0f 42 45 08	 cmovb	 eax, DWORD PTR __Count$[ebp]

; 1281 : 		return (_Capacity);
; 1282 : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z ENDP ; std::vector<int,std::allocator<int> >::_Grow_to
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	6a 00		 push	 0
  00005	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Allocate@H@std@@YAPAHIPAH@Z ; std::_Allocate<int>
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx

; 188  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator==
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	f7 d8		 neg	 eax
  0000c	1b c0		 sbb	 eax, eax
  0000e	40		 inc	 eax

; 204  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator==
_TEXT	ENDS
PUBLIC	??$_Move@PAHPAH@std@@YAPAHPAH00@Z		; std::_Move<int *,int *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
__Cat$532593 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAHPAH@std@@YAPAHPAH00@Z PROC			; std::_Move<int *,int *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$532593[ebp]
  00007	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Move@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<int *,int *>
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00018	c9		 leave
  00019	c3		 ret	 0
??$_Move@PAHPAH@std@@YAPAHPAH00@Z ENDP			; std::_Move<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,int *,std::allocator<int> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_move<int *,int *,std::allocator<int> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  00007	2b 75 08	 sub	 esi, DWORD PTR __First$[ebp]
  0000a	c1 fe 02	 sar	 esi, 2
  0000d	c1 e6 02	 shl	 esi, 2
  00010	56		 push	 esi
  00011	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00014	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	03 c6		 add	 eax, esi
  00022	5e		 pop	 esi

; 472  : 	}

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_move<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??_GRoomOptionInfo@@QAEPAXI@Z			; RoomOptionInfo::`scalar deleting destructor'
; Function compile flags: /Ogsp
;	COMDAT ??_GRoomOptionInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GRoomOptionInfo@@QAEPAXI@Z PROC			; RoomOptionInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1RoomOptionInfo@@QAE@XZ
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 07		 je	 SHORT $LN1@scalar@5
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	59		 pop	 ecx
$LN1@scalar@5:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??_GRoomOptionInfo@@QAEPAXI@Z ENDP			; RoomOptionInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	__real@00000000
PUBLIC	?CheckChangeCharType@ioRoomOptionManager@@QAE_NH@Z ; ioRoomOptionManager::CheckChangeCharType
;	COMDAT __real@00000000
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioroomoptionmanager.cpp
CONST	ENDS
;	COMDAT ?CheckChangeCharType@ioRoomOptionManager@@QAE_NH@Z
_TEXT	SEGMENT
_value$532634 = 8					; size = 4
_iIndex$ = 8						; size = 4
?CheckChangeCharType@ioRoomOptionManager@@QAE_NH@Z PROC	; ioRoomOptionManager::CheckChangeCharType, COMDAT
; _this$ = ecx

; 784  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 786  : 
; 787  : 	if( COMPARE( iIndex, 0, iSize ) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 2e		 js	 SHORT $LN1@CheckChang

; 785  : 	int iSize = m_RoomChangeCharList.size();

  0000a	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0000d	2b 51 34	 sub	 edx, DWORD PTR [ecx+52]
  00010	c1 fa 02	 sar	 edx, 2

; 786  : 
; 787  : 	if( COMPARE( iIndex, 0, iSize ) )

  00013	3b c2		 cmp	 eax, edx
  00015	7d 21		 jge	 SHORT $LN1@CheckChang

; 788  : 	{
; 789  : 		float fValue = m_RoomChangeCharList[iIndex]->m_fValue;

  00017	8b 49 34	 mov	 ecx, DWORD PTR [ecx+52]
  0001a	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  0001d	8d 55 08	 lea	 edx, DWORD PTR _value$532634[ebp]
  00020	52		 push	 edx
  00021	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool

; 790  : 		if( fValue >= 0.0f )

  00026	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _value$532634[ebp]
  0002b	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000

; 791  : 			return true;

  00032	73 04		 jae	 SHORT $LN1@CheckChang

; 792  : 		else
; 793  : 			return false;

  00034	32 c0		 xor	 al, al
  00036	eb 02		 jmp	 SHORT $LN4@CheckChang
$LN1@CheckChang:

; 794  : 	}
; 795  : 
; 796  : 	return true;

  00038	b0 01		 mov	 al, 1
$LN4@CheckChang:

; 797  : }

  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
?CheckChangeCharType@ioRoomOptionManager@@QAE_NH@Z ENDP	; ioRoomOptionManager::CheckChangeCharType
_TEXT	ENDS
PUBLIC	?CheckEnableTeamAttack@ioRoomOptionManager@@QAE_NH@Z ; ioRoomOptionManager::CheckEnableTeamAttack
; Function compile flags: /Ogsp
;	COMDAT ?CheckEnableTeamAttack@ioRoomOptionManager@@QAE_NH@Z
_TEXT	SEGMENT
_value$532651 = 8					; size = 4
_iIndex$ = 8						; size = 4
?CheckEnableTeamAttack@ioRoomOptionManager@@QAE_NH@Z PROC ; ioRoomOptionManager::CheckEnableTeamAttack, COMDAT
; _this$ = ecx

; 800  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 
; 803  : 	if( COMPARE( iIndex, 0, iSize ) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 37		 js	 SHORT $LN1@CheckEnabl

; 801  : 	int iSize = m_RoomTeamAttackList.size();

  0000a	8b 91 b8 00 00
	00		 mov	 edx, DWORD PTR [ecx+184]
  00010	2b 91 b4 00 00
	00		 sub	 edx, DWORD PTR [ecx+180]
  00016	c1 fa 02	 sar	 edx, 2

; 802  : 
; 803  : 	if( COMPARE( iIndex, 0, iSize ) )

  00019	3b c2		 cmp	 eax, edx
  0001b	7d 24		 jge	 SHORT $LN1@CheckEnabl

; 804  : 	{
; 805  : 		float fValue = m_RoomTeamAttackList[iIndex]->m_fValue;

  0001d	8b 89 b4 00 00
	00		 mov	 ecx, DWORD PTR [ecx+180]
  00023	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00026	8d 55 08	 lea	 edx, DWORD PTR _value$532651[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool

; 806  : 		if( fValue >= 0.0f )

  0002f	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _value$532651[ebp]
  00034	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000

; 807  : 			return true;

  0003b	73 04		 jae	 SHORT $LN1@CheckEnabl

; 808  : 		else
; 809  : 			return false;

  0003d	32 c0		 xor	 al, al
  0003f	eb 02		 jmp	 SHORT $LN4@CheckEnabl
$LN1@CheckEnabl:

; 810  : 	}
; 811  : 
; 812  : 	return true;

  00041	b0 01		 mov	 al, 1
$LN4@CheckEnabl:

; 813  : }

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?CheckEnableTeamAttack@ioRoomOptionManager@@QAE_NH@Z ENDP ; ioRoomOptionManager::CheckEnableTeamAttack
_TEXT	ENDS
PUBLIC	?CheckEnableTeamDamage@ioRoomOptionManager@@QAE_NH@Z ; ioRoomOptionManager::CheckEnableTeamDamage
; Function compile flags: /Ogsp
;	COMDAT ?CheckEnableTeamDamage@ioRoomOptionManager@@QAE_NH@Z
_TEXT	SEGMENT
_value$532666 = 8					; size = 4
_iIndex$ = 8						; size = 4
?CheckEnableTeamDamage@ioRoomOptionManager@@QAE_NH@Z PROC ; ioRoomOptionManager::CheckEnableTeamDamage, COMDAT
; _this$ = ecx

; 816  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 818  : 
; 819  : 	if( COMPARE( iIndex, 0, iSize ) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 37		 js	 SHORT $LN1@CheckEnabl@2

; 817  : 	int iSize = m_RoomTeamAttackList.size();

  0000a	8b 91 b8 00 00
	00		 mov	 edx, DWORD PTR [ecx+184]
  00010	2b 91 b4 00 00
	00		 sub	 edx, DWORD PTR [ecx+180]
  00016	c1 fa 02	 sar	 edx, 2

; 818  : 
; 819  : 	if( COMPARE( iIndex, 0, iSize ) )

  00019	3b c2		 cmp	 eax, edx
  0001b	7d 24		 jge	 SHORT $LN1@CheckEnabl@2

; 820  : 	{
; 821  : 		float fValue = m_RoomTeamAttackList[iIndex]->m_fValue;

  0001d	8b 89 b4 00 00
	00		 mov	 ecx, DWORD PTR [ecx+180]
  00023	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00026	8d 55 08	 lea	 edx, DWORD PTR _value$532666[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool

; 822  : 		if( fValue > 0.0f )

  0002f	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _value$532666[ebp]
  00034	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000

; 823  : 			return true;

  0003b	77 04		 ja	 SHORT $LN1@CheckEnabl@2

; 824  : 		else
; 825  : 			return false;

  0003d	32 c0		 xor	 al, al
  0003f	eb 02		 jmp	 SHORT $LN4@CheckEnabl@2
$LN1@CheckEnabl@2:

; 826  : 	}
; 827  : 
; 828  : 	return true;

  00041	b0 01		 mov	 al, 1
$LN4@CheckEnabl@2:

; 829  : }

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?CheckEnableTeamDamage@ioRoomOptionManager@@QAE_NH@Z ENDP ; ioRoomOptionManager::CheckEnableTeamDamage
_TEXT	ENDS
PUBLIC	?CheckEnableGrowthUse@ioRoomOptionManager@@QAE_NH@Z ; ioRoomOptionManager::CheckEnableGrowthUse
; Function compile flags: /Ogsp
;	COMDAT ?CheckEnableGrowthUse@ioRoomOptionManager@@QAE_NH@Z
_TEXT	SEGMENT
_value$532681 = 8					; size = 4
_iIndex$ = 8						; size = 4
?CheckEnableGrowthUse@ioRoomOptionManager@@QAE_NH@Z PROC ; ioRoomOptionManager::CheckEnableGrowthUse, COMDAT
; _this$ = ecx

; 832  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 834  : 
; 835  : 	if( COMPARE( iIndex, 0, iSize ) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 37		 js	 SHORT $LN1@CheckEnabl@3

; 833  : 	int iSize = m_RoomGrowthUseList.size();

  0000a	8b 91 78 01 00
	00		 mov	 edx, DWORD PTR [ecx+376]
  00010	2b 91 74 01 00
	00		 sub	 edx, DWORD PTR [ecx+372]
  00016	c1 fa 02	 sar	 edx, 2

; 834  : 
; 835  : 	if( COMPARE( iIndex, 0, iSize ) )

  00019	3b c2		 cmp	 eax, edx
  0001b	7d 24		 jge	 SHORT $LN1@CheckEnabl@3

; 836  : 	{
; 837  : 		float fValue = m_RoomGrowthUseList[iIndex]->m_fValue;

  0001d	8b 89 74 01 00
	00		 mov	 ecx, DWORD PTR [ecx+372]
  00023	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00026	8d 55 08	 lea	 edx, DWORD PTR _value$532681[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool

; 838  : 		if( fValue > 0.0f )

  0002f	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _value$532681[ebp]
  00034	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000

; 839  : 			return true;

  0003b	77 04		 ja	 SHORT $LN1@CheckEnabl@3

; 840  : 		else
; 841  : 			return false;

  0003d	32 c0		 xor	 al, al
  0003f	eb 02		 jmp	 SHORT $LN4@CheckEnabl@3
$LN1@CheckEnabl@3:

; 842  : 	}
; 843  : 
; 844  : 	return true;

  00041	b0 01		 mov	 al, 1
$LN4@CheckEnabl@3:

; 845  : }

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?CheckEnableGrowthUse@ioRoomOptionManager@@QAE_NH@Z ENDP ; ioRoomOptionManager::CheckEnableGrowthUse
_TEXT	ENDS
PUBLIC	?CheckEnableExtraItemUse@ioRoomOptionManager@@QAE_NH@Z ; ioRoomOptionManager::CheckEnableExtraItemUse
; Function compile flags: /Ogsp
;	COMDAT ?CheckEnableExtraItemUse@ioRoomOptionManager@@QAE_NH@Z
_TEXT	SEGMENT
_value$532696 = 8					; size = 4
_iIndex$ = 8						; size = 4
?CheckEnableExtraItemUse@ioRoomOptionManager@@QAE_NH@Z PROC ; ioRoomOptionManager::CheckEnableExtraItemUse, COMDAT
; _this$ = ecx

; 848  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 850  : 
; 851  : 	if( COMPARE( iIndex, 0, iSize ) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 37		 js	 SHORT $LN1@CheckEnabl@4

; 849  : 	int iSize = m_RoomExtraItemUseList.size();

  0000a	8b 91 88 01 00
	00		 mov	 edx, DWORD PTR [ecx+392]
  00010	2b 91 84 01 00
	00		 sub	 edx, DWORD PTR [ecx+388]
  00016	c1 fa 02	 sar	 edx, 2

; 850  : 
; 851  : 	if( COMPARE( iIndex, 0, iSize ) )

  00019	3b c2		 cmp	 eax, edx
  0001b	7d 24		 jge	 SHORT $LN1@CheckEnabl@4

; 852  : 	{
; 853  : 		float fValue = m_RoomExtraItemUseList[iIndex]->m_fValue;

  0001d	8b 89 84 01 00
	00		 mov	 ecx, DWORD PTR [ecx+388]
  00023	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00026	8d 55 08	 lea	 edx, DWORD PTR _value$532696[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool

; 854  : 		if( fValue > 0.0f )

  0002f	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _value$532696[ebp]
  00034	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000

; 855  : 			return true;

  0003b	77 04		 ja	 SHORT $LN1@CheckEnabl@4

; 856  : 		else
; 857  : 			return false;

  0003d	32 c0		 xor	 al, al
  0003f	eb 02		 jmp	 SHORT $LN4@CheckEnabl@4
$LN1@CheckEnabl@4:

; 858  : 	}
; 859  : 
; 860  : 	return true;

  00041	b0 01		 mov	 al, 1
$LN4@CheckEnabl@4:

; 861  : }

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?CheckEnableExtraItemUse@ioRoomOptionManager@@QAE_NH@Z ENDP ; ioRoomOptionManager::CheckEnableExtraItemUse
_TEXT	ENDS
PUBLIC	__real@4f800000
PUBLIC	?GetRedHPRate@ioRoomOptionManager@@QAEMH@Z	; ioRoomOptionManager::GetRedHPRate
;	COMDAT __real@4f800000
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stdafx.h
CONST	SEGMENT
__real@4f800000 DD 04f800000r			; 4.29497e+009
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioroomoptionmanager.cpp
CONST	ENDS
;	COMDAT ?GetRedHPRate@ioRoomOptionManager@@QAEMH@Z
_TEXT	SEGMENT
tv193 = 8						; size = 4
_value$532711 = 8					; size = 4
_iIndex$ = 8						; size = 4
?GetRedHPRate@ioRoomOptionManager@@QAEMH@Z PROC		; ioRoomOptionManager::GetRedHPRate, COMDAT
; _this$ = ecx

; 864  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 866  : 
; 867  : 	if( COMPARE( iIndex, 0, iSize ) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 21		 js	 SHORT $LN1@GetRedHPRa

; 865  : 	int iSize = m_RoomRedHPList.size();

  0000a	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  0000d	2b 51 44	 sub	 edx, DWORD PTR [ecx+68]
  00010	c1 fa 02	 sar	 edx, 2

; 866  : 
; 867  : 	if( COMPARE( iIndex, 0, iSize ) )

  00013	3b c2		 cmp	 eax, edx
  00015	7d 14		 jge	 SHORT $LN1@GetRedHPRa

; 868  : 	{
; 869  : 		return m_RoomRedHPList[iIndex]->m_fValue;

  00017	8b 49 44	 mov	 ecx, DWORD PTR [ecx+68]
  0001a	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  0001d	8d 55 08	 lea	 edx, DWORD PTR _value$532711[ebp]
  00020	52		 push	 edx
  00021	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  00026	d9 45 08	 fld	 DWORD PTR _value$532711[ebp]
  00029	eb 15		 jmp	 SHORT $LN2@GetRedHPRa
$LN1@GetRedHPRa:

; 870  : 	}
; 871  : 
; 872  : 	return FLOAT1;

  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	89 45 08	 mov	 DWORD PTR tv193[ebp], eax
  00033	db 45 08	 fild	 DWORD PTR tv193[ebp]
  00036	85 c0		 test	 eax, eax
  00038	79 06		 jns	 SHORT $LN2@GetRedHPRa
  0003a	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN2@GetRedHPRa:

; 873  : }

  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
?GetRedHPRate@ioRoomOptionManager@@QAEMH@Z ENDP		; ioRoomOptionManager::GetRedHPRate
_TEXT	ENDS
PUBLIC	?GetBlueHPRate@ioRoomOptionManager@@QAEMH@Z	; ioRoomOptionManager::GetBlueHPRate
; Function compile flags: /Ogsp
;	COMDAT ?GetBlueHPRate@ioRoomOptionManager@@QAEMH@Z
_TEXT	SEGMENT
tv193 = 8						; size = 4
_value$532733 = 8					; size = 4
_iIndex$ = 8						; size = 4
?GetBlueHPRate@ioRoomOptionManager@@QAEMH@Z PROC	; ioRoomOptionManager::GetBlueHPRate, COMDAT
; _this$ = ecx

; 876  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 878  : 
; 879  : 	if( COMPARE( iIndex, 0, iSize ) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 21		 js	 SHORT $LN1@GetBlueHPR

; 877  : 	int iSize = m_RoomBlueHPList.size();

  0000a	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  0000d	2b 51 54	 sub	 edx, DWORD PTR [ecx+84]
  00010	c1 fa 02	 sar	 edx, 2

; 878  : 
; 879  : 	if( COMPARE( iIndex, 0, iSize ) )

  00013	3b c2		 cmp	 eax, edx
  00015	7d 14		 jge	 SHORT $LN1@GetBlueHPR

; 880  : 	{
; 881  : 		return m_RoomBlueHPList[iIndex]->m_fValue;

  00017	8b 49 54	 mov	 ecx, DWORD PTR [ecx+84]
  0001a	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  0001d	8d 55 08	 lea	 edx, DWORD PTR _value$532733[ebp]
  00020	52		 push	 edx
  00021	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  00026	d9 45 08	 fld	 DWORD PTR _value$532733[ebp]
  00029	eb 15		 jmp	 SHORT $LN2@GetBlueHPR
$LN1@GetBlueHPR:

; 882  : 	}
; 883  : 
; 884  : 	return FLOAT1;

  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	89 45 08	 mov	 DWORD PTR tv193[ebp], eax
  00033	db 45 08	 fild	 DWORD PTR tv193[ebp]
  00036	85 c0		 test	 eax, eax
  00038	79 06		 jns	 SHORT $LN2@GetBlueHPR
  0003a	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN2@GetBlueHPR:

; 885  : }

  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
?GetBlueHPRate@ioRoomOptionManager@@QAEMH@Z ENDP	; ioRoomOptionManager::GetBlueHPRate
_TEXT	ENDS
PUBLIC	?GetCoolTimeRate@ioRoomOptionManager@@QAEMH@Z	; ioRoomOptionManager::GetCoolTimeRate
; Function compile flags: /Ogsp
;	COMDAT ?GetCoolTimeRate@ioRoomOptionManager@@QAEMH@Z
_TEXT	SEGMENT
tv193 = 8						; size = 4
_value$532753 = 8					; size = 4
_iIndex$ = 8						; size = 4
?GetCoolTimeRate@ioRoomOptionManager@@QAEMH@Z PROC	; ioRoomOptionManager::GetCoolTimeRate, COMDAT
; _this$ = ecx

; 888  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 890  : 
; 891  : 	if( COMPARE( iIndex, 0, iSize ) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 2a		 js	 SHORT $LN1@GetCoolTim@2

; 889  : 	int iSize = m_RoomCoolTimeList.size();

  0000a	8b 91 88 00 00
	00		 mov	 edx, DWORD PTR [ecx+136]
  00010	2b 91 84 00 00
	00		 sub	 edx, DWORD PTR [ecx+132]
  00016	c1 fa 02	 sar	 edx, 2

; 890  : 
; 891  : 	if( COMPARE( iIndex, 0, iSize ) )

  00019	3b c2		 cmp	 eax, edx
  0001b	7d 17		 jge	 SHORT $LN1@GetCoolTim@2

; 892  : 	{
; 893  : 		return m_RoomCoolTimeList[iIndex]->m_fValue;

  0001d	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [ecx+132]
  00023	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00026	8d 55 08	 lea	 edx, DWORD PTR _value$532753[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  0002f	d9 45 08	 fld	 DWORD PTR _value$532753[ebp]
  00032	eb 15		 jmp	 SHORT $LN2@GetCoolTim@2
$LN1@GetCoolTim@2:

; 894  : 	}
; 895  : 
; 896  : 	return FLOAT1;

  00034	b8 01 00 00 00	 mov	 eax, 1
  00039	89 45 08	 mov	 DWORD PTR tv193[ebp], eax
  0003c	db 45 08	 fild	 DWORD PTR tv193[ebp]
  0003f	85 c0		 test	 eax, eax
  00041	79 06		 jns	 SHORT $LN2@GetCoolTim@2
  00043	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN2@GetCoolTim@2:

; 897  : }

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
?GetCoolTimeRate@ioRoomOptionManager@@QAEMH@Z ENDP	; ioRoomOptionManager::GetCoolTimeRate
_TEXT	ENDS
PUBLIC	?GetDropDamageRate@ioRoomOptionManager@@QAEMH@Z	; ioRoomOptionManager::GetDropDamageRate
; Function compile flags: /Ogsp
;	COMDAT ?GetDropDamageRate@ioRoomOptionManager@@QAEMH@Z
_TEXT	SEGMENT
tv193 = 8						; size = 4
_value$532773 = 8					; size = 4
_iIndex$ = 8						; size = 4
?GetDropDamageRate@ioRoomOptionManager@@QAEMH@Z PROC	; ioRoomOptionManager::GetDropDamageRate, COMDAT
; _this$ = ecx

; 900  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 902  : 
; 903  : 	if( COMPARE( iIndex, 0, iSize ) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 2a		 js	 SHORT $LN1@GetDropDam@2

; 901  : 	int iSize = m_RoomDropDamageList.size();

  0000a	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  00010	2b 91 94 00 00
	00		 sub	 edx, DWORD PTR [ecx+148]
  00016	c1 fa 02	 sar	 edx, 2

; 902  : 
; 903  : 	if( COMPARE( iIndex, 0, iSize ) )

  00019	3b c2		 cmp	 eax, edx
  0001b	7d 17		 jge	 SHORT $LN1@GetDropDam@2

; 904  : 	{
; 905  : 		return m_RoomDropDamageList[iIndex]->m_fValue;

  0001d	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [ecx+148]
  00023	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00026	8d 55 08	 lea	 edx, DWORD PTR _value$532773[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  0002f	d9 45 08	 fld	 DWORD PTR _value$532773[ebp]
  00032	eb 15		 jmp	 SHORT $LN2@GetDropDam@2
$LN1@GetDropDam@2:

; 906  : 	}
; 907  : 
; 908  : 	return FLOAT1;

  00034	b8 01 00 00 00	 mov	 eax, 1
  00039	89 45 08	 mov	 DWORD PTR tv193[ebp], eax
  0003c	db 45 08	 fild	 DWORD PTR tv193[ebp]
  0003f	85 c0		 test	 eax, eax
  00041	79 06		 jns	 SHORT $LN2@GetDropDam@2
  00043	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN2@GetDropDam@2:

; 909  : }

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
?GetDropDamageRate@ioRoomOptionManager@@QAEMH@Z ENDP	; ioRoomOptionManager::GetDropDamageRate
_TEXT	ENDS
PUBLIC	?GetGravityRate@ioRoomOptionManager@@QAEMH@Z	; ioRoomOptionManager::GetGravityRate
; Function compile flags: /Ogsp
;	COMDAT ?GetGravityRate@ioRoomOptionManager@@QAEMH@Z
_TEXT	SEGMENT
tv193 = 8						; size = 4
_value$532793 = 8					; size = 4
_iIndex$ = 8						; size = 4
?GetGravityRate@ioRoomOptionManager@@QAEMH@Z PROC	; ioRoomOptionManager::GetGravityRate, COMDAT
; _this$ = ecx

; 912  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 914  : 
; 915  : 	if( COMPARE( iIndex, 0, iSize ) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 2a		 js	 SHORT $LN1@GetGravity@2

; 913  : 	int iSize = m_RoomGravityList.size();

  0000a	8b 91 a8 00 00
	00		 mov	 edx, DWORD PTR [ecx+168]
  00010	2b 91 a4 00 00
	00		 sub	 edx, DWORD PTR [ecx+164]
  00016	c1 fa 02	 sar	 edx, 2

; 914  : 
; 915  : 	if( COMPARE( iIndex, 0, iSize ) )

  00019	3b c2		 cmp	 eax, edx
  0001b	7d 17		 jge	 SHORT $LN1@GetGravity@2

; 916  : 	{
; 917  : 		return m_RoomGravityList[iIndex]->m_fValue;

  0001d	8b 89 a4 00 00
	00		 mov	 ecx, DWORD PTR [ecx+164]
  00023	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00026	8d 55 08	 lea	 edx, DWORD PTR _value$532793[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  0002f	d9 45 08	 fld	 DWORD PTR _value$532793[ebp]
  00032	eb 15		 jmp	 SHORT $LN2@GetGravity@2
$LN1@GetGravity@2:

; 918  : 	}
; 919  : 
; 920  : 	return FLOAT1;

  00034	b8 01 00 00 00	 mov	 eax, 1
  00039	89 45 08	 mov	 DWORD PTR tv193[ebp], eax
  0003c	db 45 08	 fild	 DWORD PTR tv193[ebp]
  0003f	85 c0		 test	 eax, eax
  00041	79 06		 jns	 SHORT $LN2@GetGravity@2
  00043	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN2@GetGravity@2:

; 921  : }

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
?GetGravityRate@ioRoomOptionManager@@QAEMH@Z ENDP	; ioRoomOptionManager::GetGravityRate
_TEXT	ENDS
PUBLIC	?GetGetUpRate@ioRoomOptionManager@@QAEMH@Z	; ioRoomOptionManager::GetGetUpRate
; Function compile flags: /Ogsp
;	COMDAT ?GetGetUpRate@ioRoomOptionManager@@QAEMH@Z
_TEXT	SEGMENT
tv193 = 8						; size = 4
_value$532813 = 8					; size = 4
_iIndex$ = 8						; size = 4
?GetGetUpRate@ioRoomOptionManager@@QAEMH@Z PROC		; ioRoomOptionManager::GetGetUpRate, COMDAT
; _this$ = ecx

; 924  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 926  : 
; 927  : 	if( COMPARE( iIndex, 0, iSize ) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 2a		 js	 SHORT $LN1@GetGetUpRa

; 925  : 	int iSize = m_RoomGetUpList.size();

  0000a	8b 91 c8 00 00
	00		 mov	 edx, DWORD PTR [ecx+200]
  00010	2b 91 c4 00 00
	00		 sub	 edx, DWORD PTR [ecx+196]
  00016	c1 fa 02	 sar	 edx, 2

; 926  : 
; 927  : 	if( COMPARE( iIndex, 0, iSize ) )

  00019	3b c2		 cmp	 eax, edx
  0001b	7d 17		 jge	 SHORT $LN1@GetGetUpRa

; 928  : 	{
; 929  : 		return m_RoomGetUpList[iIndex]->m_fValue;

  0001d	8b 89 c4 00 00
	00		 mov	 ecx, DWORD PTR [ecx+196]
  00023	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00026	8d 55 08	 lea	 edx, DWORD PTR _value$532813[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  0002f	d9 45 08	 fld	 DWORD PTR _value$532813[ebp]
  00032	eb 15		 jmp	 SHORT $LN2@GetGetUpRa
$LN1@GetGetUpRa:

; 930  : 	}
; 931  : 
; 932  : 	return FLOAT1;

  00034	b8 01 00 00 00	 mov	 eax, 1
  00039	89 45 08	 mov	 DWORD PTR tv193[ebp], eax
  0003c	db 45 08	 fild	 DWORD PTR tv193[ebp]
  0003f	85 c0		 test	 eax, eax
  00041	79 06		 jns	 SHORT $LN2@GetGetUpRa
  00043	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN2@GetGetUpRa:

; 933  : }

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
?GetGetUpRate@ioRoomOptionManager@@QAEMH@Z ENDP		; ioRoomOptionManager::GetGetUpRate
_TEXT	ENDS
PUBLIC	?GetRedMoveSpeedRate@ioRoomOptionManager@@QAEMH@Z ; ioRoomOptionManager::GetRedMoveSpeedRate
; Function compile flags: /Ogsp
;	COMDAT ?GetRedMoveSpeedRate@ioRoomOptionManager@@QAEMH@Z
_TEXT	SEGMENT
tv193 = 8						; size = 4
_value$532833 = 8					; size = 4
_iIndex$ = 8						; size = 4
?GetRedMoveSpeedRate@ioRoomOptionManager@@QAEMH@Z PROC	; ioRoomOptionManager::GetRedMoveSpeedRate, COMDAT
; _this$ = ecx

; 936  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 938  : 
; 939  : 	if( COMPARE( iIndex, 0, iSize ) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 2a		 js	 SHORT $LN1@GetRedMove@2

; 937  : 	int iSize = m_RoomRedMoveSpeedList.size();

  0000a	8b 91 18 01 00
	00		 mov	 edx, DWORD PTR [ecx+280]
  00010	2b 91 14 01 00
	00		 sub	 edx, DWORD PTR [ecx+276]
  00016	c1 fa 02	 sar	 edx, 2

; 938  : 
; 939  : 	if( COMPARE( iIndex, 0, iSize ) )

  00019	3b c2		 cmp	 eax, edx
  0001b	7d 17		 jge	 SHORT $LN1@GetRedMove@2

; 940  : 	{
; 941  : 		return m_RoomRedMoveSpeedList[iIndex]->m_fValue;

  0001d	8b 89 14 01 00
	00		 mov	 ecx, DWORD PTR [ecx+276]
  00023	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00026	8d 55 08	 lea	 edx, DWORD PTR _value$532833[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  0002f	d9 45 08	 fld	 DWORD PTR _value$532833[ebp]
  00032	eb 15		 jmp	 SHORT $LN2@GetRedMove@2
$LN1@GetRedMove@2:

; 942  : 	}
; 943  : 
; 944  : 	return FLOAT1;

  00034	b8 01 00 00 00	 mov	 eax, 1
  00039	89 45 08	 mov	 DWORD PTR tv193[ebp], eax
  0003c	db 45 08	 fild	 DWORD PTR tv193[ebp]
  0003f	85 c0		 test	 eax, eax
  00041	79 06		 jns	 SHORT $LN2@GetRedMove@2
  00043	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN2@GetRedMove@2:

; 945  : }

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
?GetRedMoveSpeedRate@ioRoomOptionManager@@QAEMH@Z ENDP	; ioRoomOptionManager::GetRedMoveSpeedRate
_TEXT	ENDS
PUBLIC	?GetBlueMoveSpeedRate@ioRoomOptionManager@@QAEMH@Z ; ioRoomOptionManager::GetBlueMoveSpeedRate
; Function compile flags: /Ogsp
;	COMDAT ?GetBlueMoveSpeedRate@ioRoomOptionManager@@QAEMH@Z
_TEXT	SEGMENT
tv193 = 8						; size = 4
_value$532853 = 8					; size = 4
_iIndex$ = 8						; size = 4
?GetBlueMoveSpeedRate@ioRoomOptionManager@@QAEMH@Z PROC	; ioRoomOptionManager::GetBlueMoveSpeedRate, COMDAT
; _this$ = ecx

; 948  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 950  : 
; 951  : 	if( COMPARE( iIndex, 0, iSize ) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 2a		 js	 SHORT $LN1@GetBlueMov@2

; 949  : 	int iSize = m_RoomBlueMoveSpeedList.size();

  0000a	8b 91 28 01 00
	00		 mov	 edx, DWORD PTR [ecx+296]
  00010	2b 91 24 01 00
	00		 sub	 edx, DWORD PTR [ecx+292]
  00016	c1 fa 02	 sar	 edx, 2

; 950  : 
; 951  : 	if( COMPARE( iIndex, 0, iSize ) )

  00019	3b c2		 cmp	 eax, edx
  0001b	7d 17		 jge	 SHORT $LN1@GetBlueMov@2

; 952  : 	{
; 953  : 		return m_RoomBlueMoveSpeedList[iIndex]->m_fValue;

  0001d	8b 89 24 01 00
	00		 mov	 ecx, DWORD PTR [ecx+292]
  00023	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00026	8d 55 08	 lea	 edx, DWORD PTR _value$532853[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  0002f	d9 45 08	 fld	 DWORD PTR _value$532853[ebp]
  00032	eb 15		 jmp	 SHORT $LN2@GetBlueMov@2
$LN1@GetBlueMov@2:

; 954  : 	}
; 955  : 
; 956  : 	return FLOAT1;

  00034	b8 01 00 00 00	 mov	 eax, 1
  00039	89 45 08	 mov	 DWORD PTR tv193[ebp], eax
  0003c	db 45 08	 fild	 DWORD PTR tv193[ebp]
  0003f	85 c0		 test	 eax, eax
  00041	79 06		 jns	 SHORT $LN2@GetBlueMov@2
  00043	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN2@GetBlueMov@2:

; 957  : }

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
?GetBlueMoveSpeedRate@ioRoomOptionManager@@QAEMH@Z ENDP	; ioRoomOptionManager::GetBlueMoveSpeedRate
_TEXT	ENDS
PUBLIC	?GetKORate@ioRoomOptionManager@@QAEMH@Z		; ioRoomOptionManager::GetKORate
; Function compile flags: /Ogsp
;	COMDAT ?GetKORate@ioRoomOptionManager@@QAEMH@Z
_TEXT	SEGMENT
tv193 = 8						; size = 4
_value$532873 = 8					; size = 4
_iIndex$ = 8						; size = 4
?GetKORate@ioRoomOptionManager@@QAEMH@Z PROC		; ioRoomOptionManager::GetKORate, COMDAT
; _this$ = ecx

; 960  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 962  : 
; 963  : 	if( COMPARE( iIndex, 0, iSize ) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 2a		 js	 SHORT $LN1@GetKORate

; 961  : 	int iSize = m_RoomKOList.size();

  0000a	8b 91 d8 00 00
	00		 mov	 edx, DWORD PTR [ecx+216]
  00010	2b 91 d4 00 00
	00		 sub	 edx, DWORD PTR [ecx+212]
  00016	c1 fa 02	 sar	 edx, 2

; 962  : 
; 963  : 	if( COMPARE( iIndex, 0, iSize ) )

  00019	3b c2		 cmp	 eax, edx
  0001b	7d 17		 jge	 SHORT $LN1@GetKORate

; 964  : 	{
; 965  : 		return m_RoomKOList[iIndex]->m_fValue;

  0001d	8b 89 d4 00 00
	00		 mov	 ecx, DWORD PTR [ecx+212]
  00023	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00026	8d 55 08	 lea	 edx, DWORD PTR _value$532873[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  0002f	d9 45 08	 fld	 DWORD PTR _value$532873[ebp]
  00032	eb 15		 jmp	 SHORT $LN2@GetKORate
$LN1@GetKORate:

; 966  : 	}
; 967  : 
; 968  : 	return FLOAT1;

  00034	b8 01 00 00 00	 mov	 eax, 1
  00039	89 45 08	 mov	 DWORD PTR tv193[ebp], eax
  0003c	db 45 08	 fild	 DWORD PTR tv193[ebp]
  0003f	85 c0		 test	 eax, eax
  00041	79 06		 jns	 SHORT $LN2@GetKORate
  00043	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN2@GetKORate:

; 969  : }

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
?GetKORate@ioRoomOptionManager@@QAEMH@Z ENDP		; ioRoomOptionManager::GetKORate
_TEXT	ENDS
PUBLIC	?GetKOEffectRate@ioRoomOptionManager@@QAEMH@Z	; ioRoomOptionManager::GetKOEffectRate
; Function compile flags: /Ogsp
;	COMDAT ?GetKOEffectRate@ioRoomOptionManager@@QAEMH@Z
_TEXT	SEGMENT
tv193 = 8						; size = 4
_value$532893 = 8					; size = 4
_iIndex$ = 8						; size = 4
?GetKOEffectRate@ioRoomOptionManager@@QAEMH@Z PROC	; ioRoomOptionManager::GetKOEffectRate, COMDAT
; _this$ = ecx

; 972  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 974  : 
; 975  : 	if( COMPARE( iIndex, 0, iSize ) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 2a		 js	 SHORT $LN1@GetKOEffec@2

; 973  : 	int iSize = m_RoomKOEffectList.size();

  0000a	8b 91 e8 00 00
	00		 mov	 edx, DWORD PTR [ecx+232]
  00010	2b 91 e4 00 00
	00		 sub	 edx, DWORD PTR [ecx+228]
  00016	c1 fa 02	 sar	 edx, 2

; 974  : 
; 975  : 	if( COMPARE( iIndex, 0, iSize ) )

  00019	3b c2		 cmp	 eax, edx
  0001b	7d 17		 jge	 SHORT $LN1@GetKOEffec@2

; 976  : 	{
; 977  : 		return m_RoomKOEffectList[iIndex]->m_fValue;

  0001d	8b 89 e4 00 00
	00		 mov	 ecx, DWORD PTR [ecx+228]
  00023	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00026	8d 55 08	 lea	 edx, DWORD PTR _value$532893[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  0002f	d9 45 08	 fld	 DWORD PTR _value$532893[ebp]
  00032	eb 15		 jmp	 SHORT $LN2@GetKOEffec@2
$LN1@GetKOEffec@2:

; 978  : 	}
; 979  : 
; 980  : 	return FLOAT1;

  00034	b8 01 00 00 00	 mov	 eax, 1
  00039	89 45 08	 mov	 DWORD PTR tv193[ebp], eax
  0003c	db 45 08	 fild	 DWORD PTR tv193[ebp]
  0003f	85 c0		 test	 eax, eax
  00041	79 06		 jns	 SHORT $LN2@GetKOEffec@2
  00043	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN2@GetKOEffec@2:

; 981  : }

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
?GetKOEffectRate@ioRoomOptionManager@@QAEMH@Z ENDP	; ioRoomOptionManager::GetKOEffectRate
_TEXT	ENDS
PUBLIC	?GetRedBlowRate@ioRoomOptionManager@@QAEMH@Z	; ioRoomOptionManager::GetRedBlowRate
; Function compile flags: /Ogsp
;	COMDAT ?GetRedBlowRate@ioRoomOptionManager@@QAEMH@Z
_TEXT	SEGMENT
tv193 = 8						; size = 4
_value$532913 = 8					; size = 4
_iIndex$ = 8						; size = 4
?GetRedBlowRate@ioRoomOptionManager@@QAEMH@Z PROC	; ioRoomOptionManager::GetRedBlowRate, COMDAT
; _this$ = ecx

; 984  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 986  : 
; 987  : 	if( COMPARE( iIndex, 0, iSize ) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 2a		 js	 SHORT $LN1@GetRedBlow@2

; 985  : 	int iSize = m_RoomRedBlowList.size();

  0000a	8b 91 f8 00 00
	00		 mov	 edx, DWORD PTR [ecx+248]
  00010	2b 91 f4 00 00
	00		 sub	 edx, DWORD PTR [ecx+244]
  00016	c1 fa 02	 sar	 edx, 2

; 986  : 
; 987  : 	if( COMPARE( iIndex, 0, iSize ) )

  00019	3b c2		 cmp	 eax, edx
  0001b	7d 17		 jge	 SHORT $LN1@GetRedBlow@2

; 988  : 	{
; 989  : 		return m_RoomRedBlowList[iIndex]->m_fValue;

  0001d	8b 89 f4 00 00
	00		 mov	 ecx, DWORD PTR [ecx+244]
  00023	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00026	8d 55 08	 lea	 edx, DWORD PTR _value$532913[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  0002f	d9 45 08	 fld	 DWORD PTR _value$532913[ebp]
  00032	eb 15		 jmp	 SHORT $LN2@GetRedBlow@2
$LN1@GetRedBlow@2:

; 990  : 	}
; 991  : 
; 992  : 	return FLOAT1;

  00034	b8 01 00 00 00	 mov	 eax, 1
  00039	89 45 08	 mov	 DWORD PTR tv193[ebp], eax
  0003c	db 45 08	 fild	 DWORD PTR tv193[ebp]
  0003f	85 c0		 test	 eax, eax
  00041	79 06		 jns	 SHORT $LN2@GetRedBlow@2
  00043	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN2@GetRedBlow@2:

; 993  : }

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
?GetRedBlowRate@ioRoomOptionManager@@QAEMH@Z ENDP	; ioRoomOptionManager::GetRedBlowRate
_TEXT	ENDS
PUBLIC	?GetBlueBlowRate@ioRoomOptionManager@@QAEMH@Z	; ioRoomOptionManager::GetBlueBlowRate
; Function compile flags: /Ogsp
;	COMDAT ?GetBlueBlowRate@ioRoomOptionManager@@QAEMH@Z
_TEXT	SEGMENT
tv193 = 8						; size = 4
_value$532933 = 8					; size = 4
_iIndex$ = 8						; size = 4
?GetBlueBlowRate@ioRoomOptionManager@@QAEMH@Z PROC	; ioRoomOptionManager::GetBlueBlowRate, COMDAT
; _this$ = ecx

; 996  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 998  : 
; 999  : 	if( COMPARE( iIndex, 0, iSize ) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 2a		 js	 SHORT $LN1@GetBlueBlo@2

; 997  : 	int iSize = m_RoomBlueBlowList.size();

  0000a	8b 91 08 01 00
	00		 mov	 edx, DWORD PTR [ecx+264]
  00010	2b 91 04 01 00
	00		 sub	 edx, DWORD PTR [ecx+260]
  00016	c1 fa 02	 sar	 edx, 2

; 998  : 
; 999  : 	if( COMPARE( iIndex, 0, iSize ) )

  00019	3b c2		 cmp	 eax, edx
  0001b	7d 17		 jge	 SHORT $LN1@GetBlueBlo@2

; 1000 : 	{
; 1001 : 		return m_RoomBlueBlowList[iIndex]->m_fValue;

  0001d	8b 89 04 01 00
	00		 mov	 ecx, DWORD PTR [ecx+260]
  00023	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00026	8d 55 08	 lea	 edx, DWORD PTR _value$532933[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  0002f	d9 45 08	 fld	 DWORD PTR _value$532933[ebp]
  00032	eb 15		 jmp	 SHORT $LN2@GetBlueBlo@2
$LN1@GetBlueBlo@2:

; 1002 : 	}
; 1003 : 
; 1004 : 	return FLOAT1;

  00034	b8 01 00 00 00	 mov	 eax, 1
  00039	89 45 08	 mov	 DWORD PTR tv193[ebp], eax
  0003c	db 45 08	 fild	 DWORD PTR tv193[ebp]
  0003f	85 c0		 test	 eax, eax
  00041	79 06		 jns	 SHORT $LN2@GetBlueBlo@2
  00043	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN2@GetBlueBlo@2:

; 1005 : }

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
?GetBlueBlowRate@ioRoomOptionManager@@QAEMH@Z ENDP	; ioRoomOptionManager::GetBlueBlowRate
_TEXT	ENDS
PUBLIC	?GetRedEquipRate@ioRoomOptionManager@@QAEMH@Z	; ioRoomOptionManager::GetRedEquipRate
; Function compile flags: /Ogsp
;	COMDAT ?GetRedEquipRate@ioRoomOptionManager@@QAEMH@Z
_TEXT	SEGMENT
tv193 = 8						; size = 4
_value$532953 = 8					; size = 4
_iIndex$ = 8						; size = 4
?GetRedEquipRate@ioRoomOptionManager@@QAEMH@Z PROC	; ioRoomOptionManager::GetRedEquipRate, COMDAT
; _this$ = ecx

; 1008 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1010 : 
; 1011 : 	if( COMPARE( iIndex, 0, iSize ) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 2a		 js	 SHORT $LN1@GetRedEqui@2

; 1009 : 	int iSize = m_RoomRedEquipList.size();

  0000a	8b 91 38 01 00
	00		 mov	 edx, DWORD PTR [ecx+312]
  00010	2b 91 34 01 00
	00		 sub	 edx, DWORD PTR [ecx+308]
  00016	c1 fa 02	 sar	 edx, 2

; 1010 : 
; 1011 : 	if( COMPARE( iIndex, 0, iSize ) )

  00019	3b c2		 cmp	 eax, edx
  0001b	7d 17		 jge	 SHORT $LN1@GetRedEqui@2

; 1012 : 	{
; 1013 : 		return m_RoomRedEquipList[iIndex]->m_fValue;

  0001d	8b 89 34 01 00
	00		 mov	 ecx, DWORD PTR [ecx+308]
  00023	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00026	8d 55 08	 lea	 edx, DWORD PTR _value$532953[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  0002f	d9 45 08	 fld	 DWORD PTR _value$532953[ebp]
  00032	eb 15		 jmp	 SHORT $LN2@GetRedEqui@2
$LN1@GetRedEqui@2:

; 1014 : 	}
; 1015 : 
; 1016 : 	return FLOAT1;

  00034	b8 01 00 00 00	 mov	 eax, 1
  00039	89 45 08	 mov	 DWORD PTR tv193[ebp], eax
  0003c	db 45 08	 fild	 DWORD PTR tv193[ebp]
  0003f	85 c0		 test	 eax, eax
  00041	79 06		 jns	 SHORT $LN2@GetRedEqui@2
  00043	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN2@GetRedEqui@2:

; 1017 : }

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
?GetRedEquipRate@ioRoomOptionManager@@QAEMH@Z ENDP	; ioRoomOptionManager::GetRedEquipRate
_TEXT	ENDS
PUBLIC	?GetBlueEquipRate@ioRoomOptionManager@@QAEMH@Z	; ioRoomOptionManager::GetBlueEquipRate
; Function compile flags: /Ogsp
;	COMDAT ?GetBlueEquipRate@ioRoomOptionManager@@QAEMH@Z
_TEXT	SEGMENT
tv193 = 8						; size = 4
_value$532973 = 8					; size = 4
_iIndex$ = 8						; size = 4
?GetBlueEquipRate@ioRoomOptionManager@@QAEMH@Z PROC	; ioRoomOptionManager::GetBlueEquipRate, COMDAT
; _this$ = ecx

; 1020 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1022 : 
; 1023 : 	if( COMPARE( iIndex, 0, iSize ) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 2a		 js	 SHORT $LN1@GetBlueEqu@2

; 1021 : 	int iSize = m_RoomBlueEquipList.size();

  0000a	8b 91 48 01 00
	00		 mov	 edx, DWORD PTR [ecx+328]
  00010	2b 91 44 01 00
	00		 sub	 edx, DWORD PTR [ecx+324]
  00016	c1 fa 02	 sar	 edx, 2

; 1022 : 
; 1023 : 	if( COMPARE( iIndex, 0, iSize ) )

  00019	3b c2		 cmp	 eax, edx
  0001b	7d 17		 jge	 SHORT $LN1@GetBlueEqu@2

; 1024 : 	{
; 1025 : 		return m_RoomBlueEquipList[iIndex]->m_fValue;

  0001d	8b 89 44 01 00
	00		 mov	 ecx, DWORD PTR [ecx+324]
  00023	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00026	8d 55 08	 lea	 edx, DWORD PTR _value$532973[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  0002f	d9 45 08	 fld	 DWORD PTR _value$532973[ebp]
  00032	eb 15		 jmp	 SHORT $LN2@GetBlueEqu@2
$LN1@GetBlueEqu@2:

; 1026 : 	}
; 1027 : 
; 1028 : 	return FLOAT1;

  00034	b8 01 00 00 00	 mov	 eax, 1
  00039	89 45 08	 mov	 DWORD PTR tv193[ebp], eax
  0003c	db 45 08	 fild	 DWORD PTR tv193[ebp]
  0003f	85 c0		 test	 eax, eax
  00041	79 06		 jns	 SHORT $LN2@GetBlueEqu@2
  00043	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN2@GetBlueEqu@2:

; 1029 : }

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
?GetBlueEquipRate@ioRoomOptionManager@@QAEMH@Z ENDP	; ioRoomOptionManager::GetBlueEquipRate
_TEXT	ENDS
PUBLIC	??0?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::begin
; Function compile flags: /Ogsp
;	COMDAT ?begin@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@XZ PROC ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 782  : 		return (iterator(this->_Myfirst, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 783  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@XZ ENDP ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::end
; Function compile flags: /Ogsp
;	COMDAT ?end@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@XZ PROC ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 792  : 		return (iterator(this->_Mylast, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 793  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@XZ ENDP ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::end
_TEXT	ENDS
PUBLIC	??0?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE@XZ ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::vector<PreSetInfo *,std::allocator<PreSetInfo *> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::vector<PreSetInfo *,std::allocator<PreSetInfo *> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::vector<PreSetInfo *,std::allocator<PreSetInfo *> >
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@2@XZ ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::begin
; Function compile flags: /Ogsp
;	COMDAT ?begin@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@2@XZ PROC ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 782  : 		return (iterator(this->_Myfirst, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 783  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@2@XZ ENDP ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@2@XZ ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::end
; Function compile flags: /Ogsp
;	COMDAT ?end@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@2@XZ PROC ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 792  : 		return (iterator(this->_Mylast, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 793  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@2@XZ ENDP ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::end
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >::operator!=
; Function compile flags: /Ogsp
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 209  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RoomOptionInfo *,std::allocator<RoomOptionInfo *> > >::operator!=
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >::operator!=
; Function compile flags: /Ogsp
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 209  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<PreSetInfo *,std::allocator<PreSetInfo *> > >::operator!=
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXPAPAURoomOptionInfo@@0@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Destroy
; Function compile flags: /Ogsp
;	COMDAT ?_Destroy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXPAPAURoomOptionInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXPAPAURoomOptionInfo@@0@Z PROC ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXPAPAURoomOptionInfo@@0@Z ENDP ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IAEXPAPAUPreSetInfo@@0@Z ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Destroy
; Function compile flags: /Ogsp
;	COMDAT ?_Destroy@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IAEXPAPAUPreSetInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IAEXPAPAUPreSetInfo@@0@Z PROC ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IAEXPAPAUPreSetInfo@@0@Z ENDP ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	??$?0$0CA@@ioINILoader_e@@QAE@AAY0CA@$$CBD_N@Z	; ioINILoader_e::ioINILoader_e<32>
EXTRN	__imp_??0ioINILoader@@QAE@PBD_N@Z:PROC
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\io3dengine\ioiniloader.h
;	COMDAT ??$?0$0CA@@ioINILoader_e@@QAE@AAY0CA@$$CBD_N@Z
_TEXT	SEGMENT
_fn$ = 8						; size = 4
_b$ = 12						; size = 1
??$?0$0CA@@ioINILoader_e@@QAE@AAY0CA@$$CBD_N@Z PROC	; ioINILoader_e::ioINILoader_e<32>, COMDAT
; _this$ = ecx

; 224  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _fn$[ebp]
  0000b	8a 11		 mov	 dl, BYTE PTR [ecx]
  0000d	8d 87 50 03 00
	00		 lea	 eax, DWORD PTR [edi+848]
  00013	84 d2		 test	 dl, dl
  00015	0f 84 6a 04 00
	00		 je	 $LN99@ioINILoade
  0001b	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0001e	88 10		 mov	 BYTE PTR [eax], dl
  00020	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  00023	84 d2		 test	 dl, dl
  00025	0f 84 54 04 00
	00		 je	 $LN98@ioINILoade
  0002b	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0002e	88 50 01	 mov	 BYTE PTR [eax+1], dl
  00031	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  00034	84 d2		 test	 dl, dl
  00036	0f 84 3d 04 00
	00		 je	 $LN97@ioINILoade
  0003c	b3 eb		 mov	 bl, -21			; ffffffebH
  0003e	32 d3		 xor	 dl, bl
  00040	88 50 02	 mov	 BYTE PTR [eax+2], dl
  00043	8a 51 03	 mov	 dl, BYTE PTR [ecx+3]
  00046	84 d2		 test	 dl, dl
  00048	0f 84 25 04 00
	00		 je	 $LN96@ioINILoade
  0004e	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00051	88 50 03	 mov	 BYTE PTR [eax+3], dl
  00054	8a 51 04	 mov	 dl, BYTE PTR [ecx+4]
  00057	84 d2		 test	 dl, dl
  00059	0f 84 0e 04 00
	00		 je	 $LN95@ioINILoade
  0005f	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00062	88 50 04	 mov	 BYTE PTR [eax+4], dl
  00065	8a 51 05	 mov	 dl, BYTE PTR [ecx+5]
  00068	84 d2		 test	 dl, dl
  0006a	0f 84 f7 03 00
	00		 je	 $LN94@ioINILoade
  00070	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00073	88 50 05	 mov	 BYTE PTR [eax+5], dl
  00076	8a 51 06	 mov	 dl, BYTE PTR [ecx+6]
  00079	84 d2		 test	 dl, dl
  0007b	0f 84 e1 03 00
	00		 je	 $LN93@ioINILoade
  00081	32 d3		 xor	 dl, bl
  00083	88 50 06	 mov	 BYTE PTR [eax+6], dl
  00086	8a 51 07	 mov	 dl, BYTE PTR [ecx+7]
  00089	84 d2		 test	 dl, dl
  0008b	0f 84 cb 03 00
	00		 je	 $LN92@ioINILoade
  00091	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00094	88 50 07	 mov	 BYTE PTR [eax+7], dl
  00097	8a 51 08	 mov	 dl, BYTE PTR [ecx+8]
  0009a	84 d2		 test	 dl, dl
  0009c	0f 84 b4 03 00
	00		 je	 $LN91@ioINILoade
  000a2	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000a5	88 50 08	 mov	 BYTE PTR [eax+8], dl
  000a8	8a 51 09	 mov	 dl, BYTE PTR [ecx+9]
  000ab	84 d2		 test	 dl, dl
  000ad	0f 84 9d 03 00
	00		 je	 $LN90@ioINILoade
  000b3	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000b6	88 50 09	 mov	 BYTE PTR [eax+9], dl
  000b9	8a 51 0a	 mov	 dl, BYTE PTR [ecx+10]
  000bc	84 d2		 test	 dl, dl
  000be	0f 84 87 03 00
	00		 je	 $LN89@ioINILoade
  000c4	32 d3		 xor	 dl, bl
  000c6	88 50 0a	 mov	 BYTE PTR [eax+10], dl
  000c9	8a 51 0b	 mov	 dl, BYTE PTR [ecx+11]
  000cc	84 d2		 test	 dl, dl
  000ce	0f 84 71 03 00
	00		 je	 $LN88@ioINILoade
  000d4	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000d7	88 50 0b	 mov	 BYTE PTR [eax+11], dl
  000da	8a 51 0c	 mov	 dl, BYTE PTR [ecx+12]
  000dd	84 d2		 test	 dl, dl
  000df	0f 84 5a 03 00
	00		 je	 $LN87@ioINILoade
  000e5	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000e8	88 50 0c	 mov	 BYTE PTR [eax+12], dl
  000eb	8a 51 0d	 mov	 dl, BYTE PTR [ecx+13]
  000ee	84 d2		 test	 dl, dl
  000f0	0f 84 43 03 00
	00		 je	 $LN86@ioINILoade
  000f6	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000f9	88 50 0d	 mov	 BYTE PTR [eax+13], dl
  000fc	8a 51 0e	 mov	 dl, BYTE PTR [ecx+14]
  000ff	84 d2		 test	 dl, dl
  00101	0f 84 2d 03 00
	00		 je	 $LN85@ioINILoade
  00107	32 d3		 xor	 dl, bl
  00109	88 50 0e	 mov	 BYTE PTR [eax+14], dl
  0010c	8a 51 0f	 mov	 dl, BYTE PTR [ecx+15]
  0010f	84 d2		 test	 dl, dl
  00111	0f 84 17 03 00
	00		 je	 $LN84@ioINILoade
  00117	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0011a	88 50 0f	 mov	 BYTE PTR [eax+15], dl
  0011d	8a 51 10	 mov	 dl, BYTE PTR [ecx+16]
  00120	84 d2		 test	 dl, dl
  00122	0f 84 00 03 00
	00		 je	 $LN83@ioINILoade
  00128	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0012b	88 50 10	 mov	 BYTE PTR [eax+16], dl
  0012e	8a 51 11	 mov	 dl, BYTE PTR [ecx+17]
  00131	84 d2		 test	 dl, dl
  00133	0f 84 e9 02 00
	00		 je	 $LN82@ioINILoade
  00139	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0013c	88 50 11	 mov	 BYTE PTR [eax+17], dl
  0013f	8a 51 12	 mov	 dl, BYTE PTR [ecx+18]
  00142	84 d2		 test	 dl, dl
  00144	0f 84 d3 02 00
	00		 je	 $LN81@ioINILoade
  0014a	32 d3		 xor	 dl, bl
  0014c	88 50 12	 mov	 BYTE PTR [eax+18], dl
  0014f	8a 51 13	 mov	 dl, BYTE PTR [ecx+19]
  00152	84 d2		 test	 dl, dl
  00154	0f 84 bd 02 00
	00		 je	 $LN80@ioINILoade
  0015a	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0015d	88 50 13	 mov	 BYTE PTR [eax+19], dl
  00160	8a 51 14	 mov	 dl, BYTE PTR [ecx+20]
  00163	84 d2		 test	 dl, dl
  00165	0f 84 a6 02 00
	00		 je	 $LN79@ioINILoade
  0016b	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0016e	88 50 14	 mov	 BYTE PTR [eax+20], dl
  00171	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00174	84 d2		 test	 dl, dl
  00176	0f 84 8f 02 00
	00		 je	 $LN78@ioINILoade
  0017c	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0017f	88 50 15	 mov	 BYTE PTR [eax+21], dl
  00182	8a 51 16	 mov	 dl, BYTE PTR [ecx+22]
  00185	84 d2		 test	 dl, dl
  00187	0f 84 79 02 00
	00		 je	 $LN77@ioINILoade
  0018d	32 d3		 xor	 dl, bl
  0018f	88 50 16	 mov	 BYTE PTR [eax+22], dl
  00192	8a 51 17	 mov	 dl, BYTE PTR [ecx+23]
  00195	84 d2		 test	 dl, dl
  00197	0f 84 60 02 00
	00		 je	 $LN76@ioINILoade
  0019d	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  001a0	88 50 17	 mov	 BYTE PTR [eax+23], dl
  001a3	8a 51 18	 mov	 dl, BYTE PTR [ecx+24]
  001a6	84 d2		 test	 dl, dl
  001a8	0f 84 46 02 00
	00		 je	 $LN75@ioINILoade
  001ae	80 f2 ed	 xor	 dl, -19			; ffffffedH
  001b1	88 50 18	 mov	 BYTE PTR [eax+24], dl
  001b4	8a 51 19	 mov	 dl, BYTE PTR [ecx+25]
  001b7	84 d2		 test	 dl, dl
  001b9	0f 84 2c 02 00
	00		 je	 $LN74@ioINILoade
  001bf	80 f2 ec	 xor	 dl, -20			; ffffffecH
  001c2	88 50 19	 mov	 BYTE PTR [eax+25], dl
  001c5	8a 51 1a	 mov	 dl, BYTE PTR [ecx+26]
  001c8	84 d2		 test	 dl, dl
  001ca	0f 84 13 02 00
	00		 je	 $LN73@ioINILoade
  001d0	32 d3		 xor	 dl, bl
  001d2	88 50 1a	 mov	 BYTE PTR [eax+26], dl
  001d5	8a 51 1b	 mov	 dl, BYTE PTR [ecx+27]
  001d8	84 d2		 test	 dl, dl
  001da	0f 84 fa 01 00
	00		 je	 $LN72@ioINILoade
  001e0	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  001e3	88 50 1b	 mov	 BYTE PTR [eax+27], dl
  001e6	8a 51 1c	 mov	 dl, BYTE PTR [ecx+28]
  001e9	84 d2		 test	 dl, dl
  001eb	0f 84 e0 01 00
	00		 je	 $LN71@ioINILoade
  001f1	80 f2 ed	 xor	 dl, -19			; ffffffedH
  001f4	88 50 1c	 mov	 BYTE PTR [eax+28], dl
  001f7	8a 51 1d	 mov	 dl, BYTE PTR [ecx+29]
  001fa	84 d2		 test	 dl, dl
  001fc	0f 84 c6 01 00
	00		 je	 $LN70@ioINILoade
  00202	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00205	88 50 1d	 mov	 BYTE PTR [eax+29], dl
  00208	8a 51 1e	 mov	 dl, BYTE PTR [ecx+30]
  0020b	84 d2		 test	 dl, dl
  0020d	0f 84 ad 01 00
	00		 je	 $LN69@ioINILoade
  00213	32 d3		 xor	 dl, bl
  00215	88 50 1e	 mov	 BYTE PTR [eax+30], dl
  00218	8a 51 1f	 mov	 dl, BYTE PTR [ecx+31]
  0021b	84 d2		 test	 dl, dl
  0021d	0f 84 94 01 00
	00		 je	 $LN68@ioINILoade
  00223	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00226	88 50 1f	 mov	 BYTE PTR [eax+31], dl
  00229	8a 51 20	 mov	 dl, BYTE PTR [ecx+32]
  0022c	84 d2		 test	 dl, dl
  0022e	0f 84 7a 01 00
	00		 je	 $LN67@ioINILoade
  00234	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00237	88 50 20	 mov	 BYTE PTR [eax+32], dl
  0023a	8a 51 21	 mov	 dl, BYTE PTR [ecx+33]
  0023d	84 d2		 test	 dl, dl
  0023f	0f 84 60 01 00
	00		 je	 $LN66@ioINILoade
  00245	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00248	88 50 21	 mov	 BYTE PTR [eax+33], dl
  0024b	8a 51 22	 mov	 dl, BYTE PTR [ecx+34]
  0024e	84 d2		 test	 dl, dl
  00250	0f 84 47 01 00
	00		 je	 $LN65@ioINILoade
  00256	32 d3		 xor	 dl, bl
  00258	88 50 22	 mov	 BYTE PTR [eax+34], dl
  0025b	8a 51 23	 mov	 dl, BYTE PTR [ecx+35]
  0025e	84 d2		 test	 dl, dl
  00260	0f 84 2e 01 00
	00		 je	 $LN64@ioINILoade
  00266	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00269	88 50 23	 mov	 BYTE PTR [eax+35], dl
  0026c	8a 51 24	 mov	 dl, BYTE PTR [ecx+36]
  0026f	84 d2		 test	 dl, dl
  00271	0f 84 14 01 00
	00		 je	 $LN63@ioINILoade
  00277	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0027a	88 50 24	 mov	 BYTE PTR [eax+36], dl
  0027d	8a 51 25	 mov	 dl, BYTE PTR [ecx+37]
  00280	84 d2		 test	 dl, dl
  00282	0f 84 fa 00 00
	00		 je	 $LN62@ioINILoade
  00288	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0028b	88 50 25	 mov	 BYTE PTR [eax+37], dl
  0028e	8a 51 26	 mov	 dl, BYTE PTR [ecx+38]
  00291	84 d2		 test	 dl, dl
  00293	0f 84 e1 00 00
	00		 je	 $LN61@ioINILoade
  00299	32 d3		 xor	 dl, bl
  0029b	88 50 26	 mov	 BYTE PTR [eax+38], dl
  0029e	8a 51 27	 mov	 dl, BYTE PTR [ecx+39]
  002a1	84 d2		 test	 dl, dl
  002a3	0f 84 c8 00 00
	00		 je	 $LN60@ioINILoade
  002a9	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  002ac	88 50 27	 mov	 BYTE PTR [eax+39], dl
  002af	8a 51 28	 mov	 dl, BYTE PTR [ecx+40]
  002b2	84 d2		 test	 dl, dl
  002b4	0f 84 ae 00 00
	00		 je	 $LN59@ioINILoade
  002ba	80 f2 ed	 xor	 dl, -19			; ffffffedH
  002bd	88 50 28	 mov	 BYTE PTR [eax+40], dl
  002c0	8a 51 29	 mov	 dl, BYTE PTR [ecx+41]
  002c3	84 d2		 test	 dl, dl
  002c5	0f 84 94 00 00
	00		 je	 $LN58@ioINILoade
  002cb	80 f2 ec	 xor	 dl, -20			; ffffffecH
  002ce	88 50 29	 mov	 BYTE PTR [eax+41], dl
  002d1	8a 51 2a	 mov	 dl, BYTE PTR [ecx+42]
  002d4	84 d2		 test	 dl, dl
  002d6	74 7f		 je	 SHORT $LN57@ioINILoade
  002d8	32 d3		 xor	 dl, bl
  002da	88 50 2a	 mov	 BYTE PTR [eax+42], dl
  002dd	8a 51 2b	 mov	 dl, BYTE PTR [ecx+43]
  002e0	84 d2		 test	 dl, dl
  002e2	74 6a		 je	 SHORT $LN56@ioINILoade
  002e4	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  002e7	88 50 2b	 mov	 BYTE PTR [eax+43], dl
  002ea	8a 51 2c	 mov	 dl, BYTE PTR [ecx+44]
  002ed	84 d2		 test	 dl, dl
  002ef	74 54		 je	 SHORT $LN55@ioINILoade
  002f1	80 f2 ed	 xor	 dl, -19			; ffffffedH
  002f4	88 50 2c	 mov	 BYTE PTR [eax+44], dl
  002f7	8a 51 2d	 mov	 dl, BYTE PTR [ecx+45]
  002fa	84 d2		 test	 dl, dl
  002fc	74 3e		 je	 SHORT $LN54@ioINILoade
  002fe	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00301	88 50 2d	 mov	 BYTE PTR [eax+45], dl
  00304	8a 51 2e	 mov	 dl, BYTE PTR [ecx+46]
  00307	84 d2		 test	 dl, dl
  00309	74 29		 je	 SHORT $LN53@ioINILoade
  0030b	32 d3		 xor	 dl, bl
  0030d	88 50 2e	 mov	 BYTE PTR [eax+46], dl
  00310	8a 51 2f	 mov	 dl, BYTE PTR [ecx+47]
  00313	84 d2		 test	 dl, dl
  00315	74 14		 je	 SHORT $LN52@ioINILoade
  00317	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0031a	88 50 2f	 mov	 BYTE PTR [eax+47], dl
  0031d	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  00320	80 f1 ed	 xor	 cl, -19			; ffffffedH
  00323	88 48 30	 mov	 BYTE PTR [eax+48], cl
  00326	e9 5d 01 00 00	 jmp	 $LN4@ioINILoade
$LN52@ioINILoade:
  0032b	c6 40 2f ea	 mov	 BYTE PTR [eax+47], -22	; ffffffeaH
  0032f	e9 54 01 00 00	 jmp	 $LN4@ioINILoade
$LN53@ioINILoade:
  00334	88 58 2e	 mov	 BYTE PTR [eax+46], bl
  00337	e9 4c 01 00 00	 jmp	 $LN4@ioINILoade
$LN54@ioINILoade:
  0033c	c6 40 2d ec	 mov	 BYTE PTR [eax+45], -20	; ffffffecH
  00340	e9 43 01 00 00	 jmp	 $LN4@ioINILoade
$LN55@ioINILoade:
  00345	c6 40 2c ed	 mov	 BYTE PTR [eax+44], -19	; ffffffedH
  00349	e9 3a 01 00 00	 jmp	 $LN4@ioINILoade
$LN56@ioINILoade:
  0034e	c6 40 2b ea	 mov	 BYTE PTR [eax+43], -22	; ffffffeaH
  00352	e9 31 01 00 00	 jmp	 $LN4@ioINILoade
$LN57@ioINILoade:
  00357	88 58 2a	 mov	 BYTE PTR [eax+42], bl
  0035a	e9 29 01 00 00	 jmp	 $LN4@ioINILoade
$LN58@ioINILoade:
  0035f	c6 40 29 ec	 mov	 BYTE PTR [eax+41], -20	; ffffffecH
  00363	e9 20 01 00 00	 jmp	 $LN4@ioINILoade
$LN59@ioINILoade:
  00368	c6 40 28 ed	 mov	 BYTE PTR [eax+40], -19	; ffffffedH
  0036c	e9 17 01 00 00	 jmp	 $LN4@ioINILoade
$LN60@ioINILoade:
  00371	c6 40 27 ea	 mov	 BYTE PTR [eax+39], -22	; ffffffeaH
  00375	e9 0e 01 00 00	 jmp	 $LN4@ioINILoade
$LN61@ioINILoade:
  0037a	88 58 26	 mov	 BYTE PTR [eax+38], bl
  0037d	e9 06 01 00 00	 jmp	 $LN4@ioINILoade
$LN62@ioINILoade:
  00382	c6 40 25 ec	 mov	 BYTE PTR [eax+37], -20	; ffffffecH
  00386	e9 fd 00 00 00	 jmp	 $LN4@ioINILoade
$LN63@ioINILoade:
  0038b	c6 40 24 ed	 mov	 BYTE PTR [eax+36], -19	; ffffffedH
  0038f	e9 f4 00 00 00	 jmp	 $LN4@ioINILoade
$LN64@ioINILoade:
  00394	c6 40 23 ea	 mov	 BYTE PTR [eax+35], -22	; ffffffeaH
  00398	e9 eb 00 00 00	 jmp	 $LN4@ioINILoade
$LN65@ioINILoade:
  0039d	88 58 22	 mov	 BYTE PTR [eax+34], bl
  003a0	e9 e3 00 00 00	 jmp	 $LN4@ioINILoade
$LN66@ioINILoade:
  003a5	c6 40 21 ec	 mov	 BYTE PTR [eax+33], -20	; ffffffecH
  003a9	e9 da 00 00 00	 jmp	 $LN4@ioINILoade
$LN67@ioINILoade:
  003ae	c6 40 20 ed	 mov	 BYTE PTR [eax+32], -19	; ffffffedH
  003b2	e9 d1 00 00 00	 jmp	 $LN4@ioINILoade
$LN68@ioINILoade:
  003b7	c6 40 1f ea	 mov	 BYTE PTR [eax+31], -22	; ffffffeaH
  003bb	e9 c8 00 00 00	 jmp	 $LN4@ioINILoade
$LN69@ioINILoade:
  003c0	88 58 1e	 mov	 BYTE PTR [eax+30], bl
  003c3	e9 c0 00 00 00	 jmp	 $LN4@ioINILoade
$LN70@ioINILoade:
  003c8	c6 40 1d ec	 mov	 BYTE PTR [eax+29], -20	; ffffffecH
  003cc	e9 b7 00 00 00	 jmp	 $LN4@ioINILoade
$LN71@ioINILoade:
  003d1	c6 40 1c ed	 mov	 BYTE PTR [eax+28], -19	; ffffffedH
  003d5	e9 ae 00 00 00	 jmp	 $LN4@ioINILoade
$LN72@ioINILoade:
  003da	c6 40 1b ea	 mov	 BYTE PTR [eax+27], -22	; ffffffeaH
  003de	e9 a5 00 00 00	 jmp	 $LN4@ioINILoade
$LN73@ioINILoade:
  003e3	88 58 1a	 mov	 BYTE PTR [eax+26], bl
  003e6	e9 9d 00 00 00	 jmp	 $LN4@ioINILoade
$LN74@ioINILoade:
  003eb	c6 40 19 ec	 mov	 BYTE PTR [eax+25], -20	; ffffffecH
  003ef	e9 94 00 00 00	 jmp	 $LN4@ioINILoade
$LN75@ioINILoade:
  003f4	c6 40 18 ed	 mov	 BYTE PTR [eax+24], -19	; ffffffedH
  003f8	e9 8b 00 00 00	 jmp	 $LN4@ioINILoade
$LN76@ioINILoade:
  003fd	c6 40 17 ea	 mov	 BYTE PTR [eax+23], -22	; ffffffeaH
  00401	e9 82 00 00 00	 jmp	 $LN4@ioINILoade
$LN77@ioINILoade:
  00406	88 58 16	 mov	 BYTE PTR [eax+22], bl
  00409	eb 7d		 jmp	 SHORT $LN4@ioINILoade
$LN78@ioINILoade:
  0040b	c6 40 15 ec	 mov	 BYTE PTR [eax+21], -20	; ffffffecH
  0040f	eb 77		 jmp	 SHORT $LN4@ioINILoade
$LN79@ioINILoade:
  00411	c6 40 14 ed	 mov	 BYTE PTR [eax+20], -19	; ffffffedH
  00415	eb 71		 jmp	 SHORT $LN4@ioINILoade
$LN80@ioINILoade:
  00417	c6 40 13 ea	 mov	 BYTE PTR [eax+19], -22	; ffffffeaH
  0041b	eb 6b		 jmp	 SHORT $LN4@ioINILoade
$LN81@ioINILoade:
  0041d	88 58 12	 mov	 BYTE PTR [eax+18], bl
  00420	eb 66		 jmp	 SHORT $LN4@ioINILoade
$LN82@ioINILoade:
  00422	c6 40 11 ec	 mov	 BYTE PTR [eax+17], -20	; ffffffecH
  00426	eb 60		 jmp	 SHORT $LN4@ioINILoade
$LN83@ioINILoade:
  00428	c6 40 10 ed	 mov	 BYTE PTR [eax+16], -19	; ffffffedH
  0042c	eb 5a		 jmp	 SHORT $LN4@ioINILoade
$LN84@ioINILoade:
  0042e	c6 40 0f ea	 mov	 BYTE PTR [eax+15], -22	; ffffffeaH
  00432	eb 54		 jmp	 SHORT $LN4@ioINILoade
$LN85@ioINILoade:
  00434	88 58 0e	 mov	 BYTE PTR [eax+14], bl
  00437	eb 4f		 jmp	 SHORT $LN4@ioINILoade
$LN86@ioINILoade:
  00439	c6 40 0d ec	 mov	 BYTE PTR [eax+13], -20	; ffffffecH
  0043d	eb 49		 jmp	 SHORT $LN4@ioINILoade
$LN87@ioINILoade:
  0043f	c6 40 0c ed	 mov	 BYTE PTR [eax+12], -19	; ffffffedH
  00443	eb 43		 jmp	 SHORT $LN4@ioINILoade
$LN88@ioINILoade:
  00445	c6 40 0b ea	 mov	 BYTE PTR [eax+11], -22	; ffffffeaH
  00449	eb 3d		 jmp	 SHORT $LN4@ioINILoade
$LN89@ioINILoade:
  0044b	88 58 0a	 mov	 BYTE PTR [eax+10], bl
  0044e	eb 38		 jmp	 SHORT $LN4@ioINILoade
$LN90@ioINILoade:
  00450	c6 40 09 ec	 mov	 BYTE PTR [eax+9], -20	; ffffffecH
  00454	eb 32		 jmp	 SHORT $LN4@ioINILoade
$LN91@ioINILoade:
  00456	c6 40 08 ed	 mov	 BYTE PTR [eax+8], -19	; ffffffedH
  0045a	eb 2c		 jmp	 SHORT $LN4@ioINILoade
$LN92@ioINILoade:
  0045c	c6 40 07 ea	 mov	 BYTE PTR [eax+7], -22	; ffffffeaH
  00460	eb 26		 jmp	 SHORT $LN4@ioINILoade
$LN93@ioINILoade:
  00462	88 58 06	 mov	 BYTE PTR [eax+6], bl
  00465	eb 21		 jmp	 SHORT $LN4@ioINILoade
$LN94@ioINILoade:
  00467	c6 40 05 ec	 mov	 BYTE PTR [eax+5], -20	; ffffffecH
  0046b	eb 1b		 jmp	 SHORT $LN4@ioINILoade
$LN95@ioINILoade:
  0046d	c6 40 04 ed	 mov	 BYTE PTR [eax+4], -19	; ffffffedH
  00471	eb 15		 jmp	 SHORT $LN4@ioINILoade
$LN96@ioINILoade:
  00473	c6 40 03 ea	 mov	 BYTE PTR [eax+3], -22	; ffffffeaH
  00477	eb 0f		 jmp	 SHORT $LN4@ioINILoade
$LN97@ioINILoade:
  00479	c6 40 02 eb	 mov	 BYTE PTR [eax+2], -21	; ffffffebH
  0047d	eb 09		 jmp	 SHORT $LN4@ioINILoade
$LN98@ioINILoade:
  0047f	c6 40 01 ec	 mov	 BYTE PTR [eax+1], -20	; ffffffecH
  00483	eb 03		 jmp	 SHORT $LN4@ioINILoade
$LN99@ioINILoade:
  00485	c6 00 ed	 mov	 BYTE PTR [eax], -19	; ffffffedH
$LN4@ioINILoade:
  00488	6a 07		 push	 7
  0048a	8b c8		 mov	 ecx, eax
  0048c	c6 40 1f 00	 mov	 BYTE PTR [eax+31], 0
  00490	5a		 pop	 edx
$LL107@ioINILoade:
  00491	81 31 ed ec eb
	ea		 xor	 DWORD PTR [ecx], -353637139 ; eaebecedH
  00497	83 c1 04	 add	 ecx, 4
  0049a	4a		 dec	 edx
  0049b	75 f4		 jne	 SHORT $LL107@ioINILoade
  0049d	6a 1c		 push	 28			; 0000001cH
  0049f	5e		 pop	 esi
$LL104@ioINILoade:
  004a0	8b ce		 mov	 ecx, esi
  004a2	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  004a8	79 05		 jns	 SHORT $LN114@ioINILoade
  004aa	49		 dec	 ecx
  004ab	83 c9 fc	 or	 ecx, -4			; fffffffcH
  004ae	41		 inc	 ecx
$LN114@ioINILoade:
  004af	b2 ed		 mov	 dl, -19			; ffffffedH
  004b1	2a d1		 sub	 dl, cl
  004b3	30 14 06	 xor	 BYTE PTR [esi+eax], dl
  004b6	46		 inc	 esi
  004b7	83 fe 1f	 cmp	 esi, 31			; 0000001fH
  004ba	7c e4		 jl	 SHORT $LL104@ioINILoade
  004bc	ff 75 0c	 push	 DWORD PTR _b$[ebp]
  004bf	8b cf		 mov	 ecx, edi
  004c1	50		 push	 eax
  004c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioINILoader@@QAE@PBD_N@Z

; 225  : 	}

  004c8	8b c7		 mov	 eax, edi
  004ca	5f		 pop	 edi
  004cb	5e		 pop	 esi
  004cc	5b		 pop	 ebx
  004cd	5d		 pop	 ebp
  004ce	c2 08 00	 ret	 8
??$?0$0CA@@ioINILoader_e@@QAE@AAY0CA@$$CBD_N@Z ENDP	; ioINILoader_e::ioINILoader_e<32>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@H@std@@HAAH@std@@YAXAAV?$allocator@H@0@PAHAAH@Z ; std::_Cons_val<std::allocator<int>,int,int &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@H@std@@HAAH@std@@YAXAAV?$allocator@H@0@PAHAAH@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@H@std@@HAAH@std@@YAXAAV?$allocator@H@0@PAHAAH@Z PROC ; std::_Cons_val<std::allocator<int>,int,int &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN7@Cons_val@3
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000f	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@Cons_val@3:

; 281  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Cons_val@V?$allocator@H@std@@HAAH@std@@YAXAAV?$allocator@H@0@PAHAAH@Z ENDP ; std::_Cons_val<std::allocator<int>,int,int &>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z ; std::_Cons_val<std::allocator<int>,int,int const &>
; Function compile flags: /Ogsp
;	COMDAT ??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z PROC ; std::_Cons_val<std::allocator<int>,int,int const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN9@Cons_val@4
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000f	89 08		 mov	 DWORD PTR [eax], ecx
$LN9@Cons_val@4:

; 281  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z ENDP ; std::_Cons_val<std::allocator<int>,int,int const &>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@PAURoomOptionInfo@@@std@@PAURoomOptionInfo@@ABQAU3@@std@@YAXAAV?$allocator@PAURoomOptionInfo@@@0@PAPAURoomOptionInfo@@ABQAU2@@Z ; std::_Cons_val<std::allocator<RoomOptionInfo *>,RoomOptionInfo *,RoomOptionInfo * const &>
; Function compile flags: /Ogsp
;	COMDAT ??$_Cons_val@V?$allocator@PAURoomOptionInfo@@@std@@PAURoomOptionInfo@@ABQAU3@@std@@YAXAAV?$allocator@PAURoomOptionInfo@@@0@PAPAURoomOptionInfo@@ABQAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@PAURoomOptionInfo@@@std@@PAURoomOptionInfo@@ABQAU3@@std@@YAXAAV?$allocator@PAURoomOptionInfo@@@0@PAPAURoomOptionInfo@@ABQAU2@@Z PROC ; std::_Cons_val<std::allocator<RoomOptionInfo *>,RoomOptionInfo *,RoomOptionInfo * const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN9@Cons_val@5
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000f	89 08		 mov	 DWORD PTR [eax], ecx
$LN9@Cons_val@5:

; 281  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Cons_val@V?$allocator@PAURoomOptionInfo@@@std@@PAURoomOptionInfo@@ABQAU3@@std@@YAXAAV?$allocator@PAURoomOptionInfo@@@0@PAPAURoomOptionInfo@@ABQAU2@@Z ENDP ; std::_Cons_val<std::allocator<RoomOptionInfo *>,RoomOptionInfo *,RoomOptionInfo * const &>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@PAUPreSetInfo@@@std@@PAUPreSetInfo@@ABQAU3@@std@@YAXAAV?$allocator@PAUPreSetInfo@@@0@PAPAUPreSetInfo@@ABQAU2@@Z ; std::_Cons_val<std::allocator<PreSetInfo *>,PreSetInfo *,PreSetInfo * const &>
; Function compile flags: /Ogsp
;	COMDAT ??$_Cons_val@V?$allocator@PAUPreSetInfo@@@std@@PAUPreSetInfo@@ABQAU3@@std@@YAXAAV?$allocator@PAUPreSetInfo@@@0@PAPAUPreSetInfo@@ABQAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@PAUPreSetInfo@@@std@@PAUPreSetInfo@@ABQAU3@@std@@YAXAAV?$allocator@PAUPreSetInfo@@@0@PAPAUPreSetInfo@@ABQAU2@@Z PROC ; std::_Cons_val<std::allocator<PreSetInfo *>,PreSetInfo *,PreSetInfo * const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN9@Cons_val@6
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000f	89 08		 mov	 DWORD PTR [eax], ecx
$LN9@Cons_val@6:

; 281  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Cons_val@V?$allocator@PAUPreSetInfo@@@std@@PAUPreSetInfo@@ABQAU3@@std@@YAXAAV?$allocator@PAUPreSetInfo@@@0@PAPAUPreSetInfo@@ABQAU2@@Z ENDP ; std::_Cons_val<std::allocator<PreSetInfo *>,PreSetInfo *,PreSetInfo * const &>
_TEXT	ENDS
PUBLIC	??$_Umove@PAPAURoomOptionInfo@@@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEPAPAURoomOptionInfo@@PAPAU2@00@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Umove<RoomOptionInfo * *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAURoomOptionInfo@@@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEPAPAURoomOptionInfo@@PAPAU2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAURoomOptionInfo@@@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEPAPAURoomOptionInfo@@PAPAU2@00@Z PROC ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Umove<RoomOptionInfo * *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	51		 push	 ecx
  00007	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAURoomOptionInfo@@PAPAU1@V?$allocator@PAURoomOptionInfo@@@std@@@std@@YAPAPAURoomOptionInfo@@PAPAU1@00AAV?$allocator@PAURoomOptionInfo@@@0@@Z ; std::_Uninitialized_move<RoomOptionInfo * *,RoomOptionInfo * *,std::allocator<RoomOptionInfo *> >
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00018	5d		 pop	 ebp
  00019	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAPAURoomOptionInfo@@@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEPAPAURoomOptionInfo@@PAPAU2@00@Z ENDP ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Umove<RoomOptionInfo * *>
_TEXT	ENDS
PUBLIC	??$_Umove@PAPAUPreSetInfo@@@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IAEPAPAUPreSetInfo@@PAPAU2@00@Z ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Umove<PreSetInfo * *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Umove@PAPAUPreSetInfo@@@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IAEPAPAUPreSetInfo@@PAPAU2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAUPreSetInfo@@@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IAEPAPAUPreSetInfo@@PAPAU2@00@Z PROC ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Umove<PreSetInfo * *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	51		 push	 ecx
  00007	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAUPreSetInfo@@PAPAU1@V?$allocator@PAUPreSetInfo@@@std@@@std@@YAPAPAUPreSetInfo@@PAPAU1@00AAV?$allocator@PAUPreSetInfo@@@0@@Z ; std::_Uninitialized_move<PreSetInfo * *,PreSetInfo * *,std::allocator<PreSetInfo *> >
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00018	5d		 pop	 ebp
  00019	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAPAUPreSetInfo@@@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IAEPAPAUPreSetInfo@@PAPAU2@00@Z ENDP ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Umove<PreSetInfo * *>
_TEXT	ENDS
PUBLIC	??0RoomOptionInfo@@QAE@XZ			; RoomOptionInfo::RoomOptionInfo
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
xdata$x	SEGMENT
__unwindtable$??0RoomOptionInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0RoomOptionInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0RoomOptionInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0RoomOptionInfo@@QAE@XZ$2
__ehfuncinfo$??0RoomOptionInfo@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0RoomOptionInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioroomoptionmanager.h
xdata$x	ENDS
;	COMDAT ??0RoomOptionInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv129 = -16						; size = 4
_value$533441 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0RoomOptionInfo@@QAE@XZ PROC				; RoomOptionInfo::RoomOptionInfo, COMDAT
; _this$ = ecx

; 12   : 	RoomOptionInfo()

  00000	6a 08		 push	 8
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0RoomOptionInfo@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  00011	e8 00 00 00 00	 call	 ??0?$CEncrypt@M@@QAE@XZ	; CEncrypt<float>::CEncrypt<float>
  00016	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_??0ioHashString@@QAE@XZ
  0001c	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00020	8d 4e 30	 lea	 ecx, DWORD PTR [esi+48]
  00023	ff d7		 call	 edi
  00025	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  00028	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0002c	ff d7		 call	 edi
  0002e	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 13   : 	{
; 14   : 		m_fValue = FLOAT1;

  00032	b8 01 00 00 00	 mov	 eax, 1
  00037	89 45 f0	 mov	 DWORD PTR tv129[ebp], eax
  0003a	db 45 f0	 fild	 DWORD PTR tv129[ebp]
  0003d	85 c0		 test	 eax, eax
  0003f	79 06		 jns	 SHORT $LN11@RoomOption
  00041	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN11@RoomOption:
  00047	8d 45 f0	 lea	 eax, DWORD PTR _value$533441[ebp]
  0004a	d9 5d f0	 fstp	 DWORD PTR _value$533441[ebp]
  0004d	50		 push	 eax
  0004e	8b ce		 mov	 ecx, esi
  00050	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 15   : 	}

  00055	8b c6		 mov	 eax, esi
  00057	e8 00 00 00 00	 call	 __EH_epilog3
  0005c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0RoomOptionInfo@@QAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@M@@UAE@XZ	; CEncrypt<float>::~CEncrypt<float>
__unwindfunclet$??0RoomOptionInfo@@QAE@XZ$1:
  00008	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 30	 add	 ecx, 48			; 00000030H
  0000e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??0RoomOptionInfo@@QAE@XZ$2:
  00014	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	83 c1 40	 add	 ecx, 64			; 00000040H
  0001a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$??0RoomOptionInfo@@QAE@XZ:
  00020	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00024	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00027	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0RoomOptionInfo@@QAE@XZ
  00036	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0RoomOptionInfo@@QAE@XZ ENDP				; RoomOptionInfo::RoomOptionInfo
PUBLIC	?Init@PreSetInfo@@QAEXXZ			; PreSetInfo::Init
EXTRN	__imp_?Clear@ioHashString@@QAEXXZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ?Init@PreSetInfo@@QAEXXZ
_TEXT	SEGMENT
_value$533458 = -4					; size = 4
_value$533454 = -4					; size = 4
?Init@PreSetInfo@@QAEXXZ PROC				; PreSetInfo::Init, COMDAT
; _this$ = ecx

; 52   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f1		 mov	 esi, ecx

; 53   : 		m_Desc.Clear();

  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Clear@ioHashString@@QAEXXZ

; 54   : 
; 55   : 		m_iTeamAttackType = 0;

  0000e	33 ff		 xor	 edi, edi

; 56   : 		m_iChangeCharType = 0;
; 57   : 		m_iCoolTimeType = 0;
; 58   : 		m_iRedHPType = 0;

  00010	8d 45 fc	 lea	 eax, DWORD PTR _value$533454[ebp]
  00013	50		 push	 eax
  00014	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
  00017	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0001a	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  0001d	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  00020	89 7d fc	 mov	 DWORD PTR _value$533454[ebp], edi
  00023	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@H@@AAEXPBD@Z ; CEncrypt<int>::EncryptValueToPool

; 59   : 		m_iBlueHPType = 0;

  00028	8d 45 fc	 lea	 eax, DWORD PTR _value$533458[ebp]
  0002b	50		 push	 eax
  0002c	8d 4e 4c	 lea	 ecx, DWORD PTR [esi+76]
  0002f	89 7d fc	 mov	 DWORD PTR _value$533458[ebp], edi
  00032	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@H@@AAEXPBD@Z ; CEncrypt<int>::EncryptValueToPool

; 60   : 		m_iDropDamageType = 0;

  00037	89 7e 7c	 mov	 DWORD PTR [esi+124], edi

; 61   : 		m_iGravityType = 0;

  0003a	89 be 80 00 00
	00		 mov	 DWORD PTR [esi+128], edi

; 62   : 		m_iGetUpType = 0;

  00040	89 be 84 00 00
	00		 mov	 DWORD PTR [esi+132], edi

; 63   : 		m_iKOType = 0;

  00046	89 be 88 00 00
	00		 mov	 DWORD PTR [esi+136], edi

; 64   : 		m_iKOEffectType = 0;

  0004c	89 be 8c 00 00
	00		 mov	 DWORD PTR [esi+140], edi

; 65   : 		m_iRedBlowType = 0;

  00052	89 be 90 00 00
	00		 mov	 DWORD PTR [esi+144], edi

; 66   : 		m_iBlueBlowType = 0;

  00058	89 be 94 00 00
	00		 mov	 DWORD PTR [esi+148], edi

; 67   : 		m_iRedMoveSpeedType = 0;

  0005e	89 be 98 00 00
	00		 mov	 DWORD PTR [esi+152], edi

; 68   : 		m_iBlueMoveSpeedType = 0;

  00064	89 be 9c 00 00
	00		 mov	 DWORD PTR [esi+156], edi

; 69   : 		m_iRedEquipType = 0;

  0006a	89 be a0 00 00
	00		 mov	 DWORD PTR [esi+160], edi

; 70   : 		m_iBlueEquipType = 0;

  00070	89 be a4 00 00
	00		 mov	 DWORD PTR [esi+164], edi

; 71   : 
; 72   : 		m_iCatchModeRoundType = 0;

  00076	89 be a8 00 00
	00		 mov	 DWORD PTR [esi+168], edi

; 73   : 		m_iCatchModeRoundTimeType = 0;

  0007c	89 be ac 00 00
	00		 mov	 DWORD PTR [esi+172], edi

; 74   : 
; 75   : 		m_iGrowthUseType = 0;

  00082	89 be b0 00 00
	00		 mov	 DWORD PTR [esi+176], edi

; 76   : 		m_iExtraItemUseType = 0;

  00088	89 be b4 00 00
	00		 mov	 DWORD PTR [esi+180], edi
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi

; 77   : 	}

  00090	c9		 leave
  00091	c3		 ret	 0
?Init@PreSetInfo@@QAEXXZ ENDP				; PreSetInfo::Init
_TEXT	ENDS
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Ogsp
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator!=
; Function compile flags: /Ogsp
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 209  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator!=
_TEXT	ENDS
PUBLIC	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove<int *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	51		 push	 ecx
  00007	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,int *,std::allocator<int> >
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00018	5d		 pop	 ebp
  00019	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove<int *>
_TEXT	ENDS
PUBLIC	?GetPreSetInfo@ioRoomOptionManager@@QAE_NHAAUPreSetInfo@@@Z ; ioRoomOptionManager::GetPreSetInfo
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioroomoptionmanager.cpp
;	COMDAT ?GetPreSetInfo@ioRoomOptionManager@@QAE_NHAAUPreSetInfo@@@Z
_TEXT	SEGMENT
_value$533621 = 8					; size = 4
_value$533616 = 8					; size = 4
_value$533607 = 8					; size = 4
_value$533598 = 8					; size = 4
_value$533593 = 8					; size = 4
_value$533584 = 8					; size = 4
_iPreSetNum$ = 8					; size = 4
_rkPreSetInfo$ = 12					; size = 4
?GetPreSetInfo@ioRoomOptionManager@@QAE_NHAAUPreSetInfo@@@Z PROC ; ioRoomOptionManager::GetPreSetInfo, COMDAT
; _this$ = ecx

; 1395 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 1396 : 	int iSize = m_PreSetList.size();

  00007	8b b7 98 01 00
	00		 mov	 esi, DWORD PTR [edi+408]
  0000d	2b b7 94 01 00
	00		 sub	 esi, DWORD PTR [edi+404]
  00013	c1 fe 02	 sar	 esi, 2

; 1397 : 
; 1398 : 	//  
; 1399 : 	if( iPreSetNum == iSize-1 )

  00016	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  00019	39 45 08	 cmp	 DWORD PTR _iPreSetNum$[ebp], eax
  0001c	75 07		 jne	 SHORT $LN2@GetPreSetI

; 1400 : 		return false;

  0001e	32 c0		 xor	 al, al
  00020	e9 71 02 00 00	 jmp	 $LN3@GetPreSetI
$LN2@GetPreSetI:
  00025	53		 push	 ebx

; 1401 : 
; 1402 : 	rkPreSetInfo.Init();

  00026	8b 5d 0c	 mov	 ebx, DWORD PTR _rkPreSetInfo$[ebp]
  00029	8b cb		 mov	 ecx, ebx
  0002b	e8 00 00 00 00	 call	 ?Init@PreSetInfo@@QAEXXZ ; PreSetInfo::Init

; 1403 : 
; 1404 : 	if( COMPARE( iPreSetNum, 0, iSize ) )

  00030	8b 45 08	 mov	 eax, DWORD PTR _iPreSetNum$[ebp]
  00033	85 c0		 test	 eax, eax
  00035	0f 88 58 02 00
	00		 js	 $LN1@GetPreSetI
  0003b	3b c6		 cmp	 eax, esi
  0003d	0f 8d 50 02 00
	00		 jge	 $LN1@GetPreSetI

; 1405 : 	{
; 1406 : 		// -1    .
; 1407 : 		rkPreSetInfo.m_iTeamAttackType = max( 0, m_PreSetList[iPreSetNum]->m_iTeamAttackType-1 );

  00043	8b f0		 mov	 esi, eax
  00045	8b 87 94 01 00
	00		 mov	 eax, DWORD PTR [edi+404]
  0004b	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  0004e	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00051	48		 dec	 eax
  00052	79 02		 jns	 SHORT $LN5@GetPreSetI
  00054	33 c0		 xor	 eax, eax
$LN5@GetPreSetI:
  00056	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 1408 : 		rkPreSetInfo.m_iChangeCharType = max( 0, m_PreSetList[iPreSetNum]->m_iChangeCharType-1 );

  00059	8b 87 94 01 00
	00		 mov	 eax, DWORD PTR [edi+404]
  0005f	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00062	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00065	48		 dec	 eax
  00066	79 02		 jns	 SHORT $LN7@GetPreSetI
  00068	33 c0		 xor	 eax, eax
$LN7@GetPreSetI:
  0006a	89 43 14	 mov	 DWORD PTR [ebx+20], eax

; 1409 : 		rkPreSetInfo.m_iCoolTimeType = max( 0, m_PreSetList[iPreSetNum]->m_iCoolTimeType-1 );

  0006d	8b 87 94 01 00
	00		 mov	 eax, DWORD PTR [edi+404]
  00073	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00076	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00079	48		 dec	 eax
  0007a	79 02		 jns	 SHORT $LN9@GetPreSetI
  0007c	33 c0		 xor	 eax, eax
$LN9@GetPreSetI:
  0007e	89 43 18	 mov	 DWORD PTR [ebx+24], eax

; 1410 : 		rkPreSetInfo.m_iRedHPType = max( 0, m_PreSetList[iPreSetNum]->m_iRedHPType-1 );

  00081	8d 45 08	 lea	 eax, DWORD PTR _value$533584[ebp]
  00084	50		 push	 eax
  00085	8b 87 94 01 00
	00		 mov	 eax, DWORD PTR [edi+404]
  0008b	8b 0c b0	 mov	 ecx, DWORD PTR [eax+esi*4]
  0008e	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00091	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ; CEncrypt<int>::DecryptValueToPool
  00096	8b 45 08	 mov	 eax, DWORD PTR _value$533584[ebp]
  00099	48		 dec	 eax
  0009a	79 04		 jns	 SHORT $LN11@GetPreSetI
  0009c	33 c0		 xor	 eax, eax
  0009e	eb 19		 jmp	 SHORT $LN12@GetPreSetI
$LN11@GetPreSetI:
  000a0	8d 45 08	 lea	 eax, DWORD PTR _value$533593[ebp]
  000a3	50		 push	 eax
  000a4	8b 87 94 01 00
	00		 mov	 eax, DWORD PTR [edi+404]
  000aa	8b 0c b0	 mov	 ecx, DWORD PTR [eax+esi*4]
  000ad	83 c1 1c	 add	 ecx, 28			; 0000001cH
  000b0	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ; CEncrypt<int>::DecryptValueToPool
  000b5	8b 45 08	 mov	 eax, DWORD PTR _value$533593[ebp]
  000b8	48		 dec	 eax
$LN12@GetPreSetI:
  000b9	89 45 08	 mov	 DWORD PTR _value$533598[ebp], eax
  000bc	8d 45 08	 lea	 eax, DWORD PTR _value$533598[ebp]
  000bf	50		 push	 eax
  000c0	8d 4b 1c	 lea	 ecx, DWORD PTR [ebx+28]
  000c3	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@H@@AAEXPBD@Z ; CEncrypt<int>::EncryptValueToPool

; 1411 : 		rkPreSetInfo.m_iBlueHPType = max( 0, m_PreSetList[iPreSetNum]->m_iBlueHPType-1 );

  000c8	8d 45 08	 lea	 eax, DWORD PTR _value$533607[ebp]
  000cb	50		 push	 eax
  000cc	8b 87 94 01 00
	00		 mov	 eax, DWORD PTR [edi+404]
  000d2	8b 0c b0	 mov	 ecx, DWORD PTR [eax+esi*4]
  000d5	83 c1 4c	 add	 ecx, 76			; 0000004cH
  000d8	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ; CEncrypt<int>::DecryptValueToPool
  000dd	8b 45 08	 mov	 eax, DWORD PTR _value$533607[ebp]
  000e0	48		 dec	 eax
  000e1	79 04		 jns	 SHORT $LN13@GetPreSetI
  000e3	33 c0		 xor	 eax, eax
  000e5	eb 19		 jmp	 SHORT $LN14@GetPreSetI
$LN13@GetPreSetI:
  000e7	8d 45 08	 lea	 eax, DWORD PTR _value$533616[ebp]
  000ea	50		 push	 eax
  000eb	8b 87 94 01 00
	00		 mov	 eax, DWORD PTR [edi+404]
  000f1	8b 0c b0	 mov	 ecx, DWORD PTR [eax+esi*4]
  000f4	83 c1 4c	 add	 ecx, 76			; 0000004cH
  000f7	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ; CEncrypt<int>::DecryptValueToPool
  000fc	8b 45 08	 mov	 eax, DWORD PTR _value$533616[ebp]
  000ff	48		 dec	 eax
$LN14@GetPreSetI:
  00100	89 45 08	 mov	 DWORD PTR _value$533621[ebp], eax
  00103	8d 45 08	 lea	 eax, DWORD PTR _value$533621[ebp]
  00106	50		 push	 eax
  00107	8d 4b 4c	 lea	 ecx, DWORD PTR [ebx+76]
  0010a	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@H@@AAEXPBD@Z ; CEncrypt<int>::EncryptValueToPool

; 1412 : 		rkPreSetInfo.m_iDropDamageType = max( 0, m_PreSetList[iPreSetNum]->m_iDropDamageType-1 );

  0010f	8b 87 94 01 00
	00		 mov	 eax, DWORD PTR [edi+404]
  00115	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00118	8b 40 7c	 mov	 eax, DWORD PTR [eax+124]
  0011b	48		 dec	 eax
  0011c	79 02		 jns	 SHORT $LN15@GetPreSetI
  0011e	33 c0		 xor	 eax, eax
$LN15@GetPreSetI:
  00120	89 43 7c	 mov	 DWORD PTR [ebx+124], eax

; 1413 : 		rkPreSetInfo.m_iGravityType = max( 0, m_PreSetList[iPreSetNum]->m_iGravityType-1 );

  00123	8b 87 94 01 00
	00		 mov	 eax, DWORD PTR [edi+404]
  00129	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  0012c	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [eax+128]
  00132	48		 dec	 eax
  00133	79 02		 jns	 SHORT $LN17@GetPreSetI
  00135	33 c0		 xor	 eax, eax
$LN17@GetPreSetI:
  00137	89 83 80 00 00
	00		 mov	 DWORD PTR [ebx+128], eax

; 1414 : 		rkPreSetInfo.m_iGetUpType = max( 0, m_PreSetList[iPreSetNum]->m_iGetUpType-1 );

  0013d	8b 87 94 01 00
	00		 mov	 eax, DWORD PTR [edi+404]
  00143	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00146	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [eax+132]
  0014c	48		 dec	 eax
  0014d	79 02		 jns	 SHORT $LN19@GetPreSetI
  0014f	33 c0		 xor	 eax, eax
$LN19@GetPreSetI:
  00151	89 83 84 00 00
	00		 mov	 DWORD PTR [ebx+132], eax

; 1415 : 		rkPreSetInfo.m_iKOType = max( 0, m_PreSetList[iPreSetNum]->m_iKOType-1 );

  00157	8b 87 94 01 00
	00		 mov	 eax, DWORD PTR [edi+404]
  0015d	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00160	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [eax+136]
  00166	48		 dec	 eax
  00167	79 02		 jns	 SHORT $LN21@GetPreSetI
  00169	33 c0		 xor	 eax, eax
$LN21@GetPreSetI:
  0016b	89 83 88 00 00
	00		 mov	 DWORD PTR [ebx+136], eax

; 1416 : 		rkPreSetInfo.m_iKOEffectType = max( 0, m_PreSetList[iPreSetNum]->m_iKOEffectType-1 );

  00171	8b 87 94 01 00
	00		 mov	 eax, DWORD PTR [edi+404]
  00177	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  0017a	8b 80 8c 00 00
	00		 mov	 eax, DWORD PTR [eax+140]
  00180	48		 dec	 eax
  00181	79 02		 jns	 SHORT $LN23@GetPreSetI
  00183	33 c0		 xor	 eax, eax
$LN23@GetPreSetI:
  00185	89 83 8c 00 00
	00		 mov	 DWORD PTR [ebx+140], eax

; 1417 : 		rkPreSetInfo.m_iRedBlowType = max( 0, m_PreSetList[iPreSetNum]->m_iRedBlowType-1 );

  0018b	8b 87 94 01 00
	00		 mov	 eax, DWORD PTR [edi+404]
  00191	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00194	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [eax+144]
  0019a	48		 dec	 eax
  0019b	79 02		 jns	 SHORT $LN25@GetPreSetI
  0019d	33 c0		 xor	 eax, eax
$LN25@GetPreSetI:
  0019f	89 83 90 00 00
	00		 mov	 DWORD PTR [ebx+144], eax

; 1418 : 		rkPreSetInfo.m_iBlueBlowType = max( 0, m_PreSetList[iPreSetNum]->m_iBlueBlowType-1 );

  001a5	8b 87 94 01 00
	00		 mov	 eax, DWORD PTR [edi+404]
  001ab	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  001ae	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [eax+148]
  001b4	48		 dec	 eax
  001b5	79 02		 jns	 SHORT $LN27@GetPreSetI
  001b7	33 c0		 xor	 eax, eax
$LN27@GetPreSetI:
  001b9	89 83 94 00 00
	00		 mov	 DWORD PTR [ebx+148], eax

; 1419 : 		rkPreSetInfo.m_iRedMoveSpeedType = max( 0, m_PreSetList[iPreSetNum]->m_iRedMoveSpeedType-1 );

  001bf	8b 87 94 01 00
	00		 mov	 eax, DWORD PTR [edi+404]
  001c5	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  001c8	8b 80 98 00 00
	00		 mov	 eax, DWORD PTR [eax+152]
  001ce	48		 dec	 eax
  001cf	79 02		 jns	 SHORT $LN29@GetPreSetI
  001d1	33 c0		 xor	 eax, eax
$LN29@GetPreSetI:
  001d3	89 83 98 00 00
	00		 mov	 DWORD PTR [ebx+152], eax

; 1420 : 		rkPreSetInfo.m_iBlueMoveSpeedType = max( 0, m_PreSetList[iPreSetNum]->m_iBlueMoveSpeedType-1 );

  001d9	8b 87 94 01 00
	00		 mov	 eax, DWORD PTR [edi+404]
  001df	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  001e2	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [eax+156]
  001e8	48		 dec	 eax
  001e9	79 02		 jns	 SHORT $LN31@GetPreSetI
  001eb	33 c0		 xor	 eax, eax
$LN31@GetPreSetI:
  001ed	89 83 9c 00 00
	00		 mov	 DWORD PTR [ebx+156], eax

; 1421 : 		rkPreSetInfo.m_iRedEquipType = max( 0, m_PreSetList[iPreSetNum]->m_iRedEquipType-1 );

  001f3	8b 87 94 01 00
	00		 mov	 eax, DWORD PTR [edi+404]
  001f9	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  001fc	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [eax+160]
  00202	48		 dec	 eax
  00203	79 02		 jns	 SHORT $LN33@GetPreSetI
  00205	33 c0		 xor	 eax, eax
$LN33@GetPreSetI:
  00207	89 83 a0 00 00
	00		 mov	 DWORD PTR [ebx+160], eax

; 1422 : 		rkPreSetInfo.m_iBlueEquipType = max( 0, m_PreSetList[iPreSetNum]->m_iBlueEquipType-1 );

  0020d	8b 87 94 01 00
	00		 mov	 eax, DWORD PTR [edi+404]
  00213	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00216	8b 80 a4 00 00
	00		 mov	 eax, DWORD PTR [eax+164]
  0021c	48		 dec	 eax
  0021d	79 02		 jns	 SHORT $LN35@GetPreSetI
  0021f	33 c0		 xor	 eax, eax
$LN35@GetPreSetI:
  00221	89 83 a4 00 00
	00		 mov	 DWORD PTR [ebx+164], eax

; 1423 : 
; 1424 : 		rkPreSetInfo.m_iCatchModeRoundType = max( 0, m_PreSetList[iPreSetNum]->m_iCatchModeRoundType-1 );

  00227	8b 87 94 01 00
	00		 mov	 eax, DWORD PTR [edi+404]
  0022d	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00230	8b 80 a8 00 00
	00		 mov	 eax, DWORD PTR [eax+168]
  00236	48		 dec	 eax
  00237	79 02		 jns	 SHORT $LN37@GetPreSetI
  00239	33 c0		 xor	 eax, eax
$LN37@GetPreSetI:
  0023b	89 83 a8 00 00
	00		 mov	 DWORD PTR [ebx+168], eax

; 1425 : 		rkPreSetInfo.m_iCatchModeRoundTimeType = max( 0, m_PreSetList[iPreSetNum]->m_iCatchModeRoundTimeType-1 );

  00241	8b 87 94 01 00
	00		 mov	 eax, DWORD PTR [edi+404]
  00247	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  0024a	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [eax+172]
  00250	48		 dec	 eax
  00251	79 02		 jns	 SHORT $LN39@GetPreSetI
  00253	33 c0		 xor	 eax, eax
$LN39@GetPreSetI:
  00255	89 83 ac 00 00
	00		 mov	 DWORD PTR [ebx+172], eax

; 1426 : 
; 1427 : 		rkPreSetInfo.m_iGrowthUseType = max( 0, m_PreSetList[iPreSetNum]->m_iGrowthUseType-1 );

  0025b	8b 87 94 01 00
	00		 mov	 eax, DWORD PTR [edi+404]
  00261	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00264	8b 80 b0 00 00
	00		 mov	 eax, DWORD PTR [eax+176]
  0026a	48		 dec	 eax
  0026b	79 02		 jns	 SHORT $LN41@GetPreSetI
  0026d	33 c0		 xor	 eax, eax
$LN41@GetPreSetI:
  0026f	89 83 b0 00 00
	00		 mov	 DWORD PTR [ebx+176], eax

; 1428 : 		rkPreSetInfo.m_iExtraItemUseType = max( 0, m_PreSetList[iPreSetNum]->m_iExtraItemUseType-1 );

  00275	8b 87 94 01 00
	00		 mov	 eax, DWORD PTR [edi+404]
  0027b	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  0027e	8b 80 b4 00 00
	00		 mov	 eax, DWORD PTR [eax+180]
  00284	48		 dec	 eax
  00285	79 02		 jns	 SHORT $LN43@GetPreSetI
  00287	33 c0		 xor	 eax, eax
$LN43@GetPreSetI:
  00289	89 83 b4 00 00
	00		 mov	 DWORD PTR [ebx+180], eax

; 1429 : 
; 1430 : 		return true;

  0028f	b0 01		 mov	 al, 1
  00291	eb 02		 jmp	 SHORT $LN139@GetPreSetI
$LN1@GetPreSetI:

; 1431 : 	}
; 1432 : 
; 1433 : 	return false;

  00293	32 c0		 xor	 al, al
$LN139@GetPreSetI:
  00295	5b		 pop	 ebx
$LN3@GetPreSetI:
  00296	5f		 pop	 edi
  00297	5e		 pop	 esi

; 1434 : }

  00298	5d		 pop	 ebp
  00299	c2 08 00	 ret	 8
?GetPreSetInfo@ioRoomOptionManager@@QAE_NHAAUPreSetInfo@@@Z ENDP ; ioRoomOptionManager::GetPreSetInfo
_TEXT	ENDS
PUBLIC	?GetDefaultInfo@ioRoomOptionManager@@QAE_NAAUPreSetInfo@@@Z ; ioRoomOptionManager::GetDefaultInfo
; Function compile flags: /Ogsp
;	COMDAT ?GetDefaultInfo@ioRoomOptionManager@@QAE_NAAUPreSetInfo@@@Z
_TEXT	SEGMENT
_value$533784 = 8					; size = 4
_value$533780 = 8					; size = 4
_value$533776 = 8					; size = 4
_value$533771 = 8					; size = 4
_value$533767 = 8					; size = 4
_value$533763 = 8					; size = 4
_rkPreSetInfo$ = 8					; size = 4
?GetDefaultInfo@ioRoomOptionManager@@QAE_NAAUPreSetInfo@@@Z PROC ; ioRoomOptionManager::GetDefaultInfo, COMDAT
; _this$ = ecx

; 1437 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1438 : 	rkPreSetInfo.Init();

  00005	8b 7d 08	 mov	 edi, DWORD PTR _rkPreSetInfo$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	8b cf		 mov	 ecx, edi
  0000c	e8 00 00 00 00	 call	 ?Init@PreSetInfo@@QAEXXZ ; PreSetInfo::Init

; 1439 : 
; 1440 : 	// -1    .
; 1441 : 	rkPreSetInfo.m_iTeamAttackType = max( 0, m_DefaultInfo.m_iTeamAttackType-1 );

  00011	8b 86 b4 01 00
	00		 mov	 eax, DWORD PTR [esi+436]
  00017	48		 dec	 eax
  00018	79 02		 jns	 SHORT $LN3@GetDefault
  0001a	33 c0		 xor	 eax, eax
$LN3@GetDefault:
  0001c	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 1442 : 	rkPreSetInfo.m_iChangeCharType = max( 0, m_DefaultInfo.m_iChangeCharType-1 );

  0001f	8b 86 b8 01 00
	00		 mov	 eax, DWORD PTR [esi+440]
  00025	48		 dec	 eax
  00026	79 02		 jns	 SHORT $LN5@GetDefault
  00028	33 c0		 xor	 eax, eax
$LN5@GetDefault:
  0002a	89 47 14	 mov	 DWORD PTR [edi+20], eax

; 1443 : 	rkPreSetInfo.m_iCoolTimeType = max( 0, m_DefaultInfo.m_iCoolTimeType-1 );

  0002d	8b 86 bc 01 00
	00		 mov	 eax, DWORD PTR [esi+444]
  00033	48		 dec	 eax
  00034	79 02		 jns	 SHORT $LN7@GetDefault
  00036	33 c0		 xor	 eax, eax
$LN7@GetDefault:
  00038	89 47 18	 mov	 DWORD PTR [edi+24], eax
  0003b	53		 push	 ebx

; 1444 : 	rkPreSetInfo.m_iRedHPType = max( 0, m_DefaultInfo.m_iRedHPType-1 );

  0003c	8d 45 08	 lea	 eax, DWORD PTR _value$533763[ebp]
  0003f	50		 push	 eax
  00040	8d 8e c0 01 00
	00		 lea	 ecx, DWORD PTR [esi+448]
  00046	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ; CEncrypt<int>::DecryptValueToPool
  0004b	8b 45 08	 mov	 eax, DWORD PTR _value$533763[ebp]
  0004e	48		 dec	 eax
  0004f	79 04		 jns	 SHORT $LN9@GetDefault
  00051	33 c0		 xor	 eax, eax
  00053	eb 13		 jmp	 SHORT $LN10@GetDefault
$LN9@GetDefault:
  00055	8d 45 08	 lea	 eax, DWORD PTR _value$533767[ebp]
  00058	50		 push	 eax
  00059	8d 8e c0 01 00
	00		 lea	 ecx, DWORD PTR [esi+448]
  0005f	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ; CEncrypt<int>::DecryptValueToPool
  00064	8b 45 08	 mov	 eax, DWORD PTR _value$533767[ebp]
  00067	48		 dec	 eax
$LN10@GetDefault:
  00068	89 45 08	 mov	 DWORD PTR _value$533771[ebp], eax
  0006b	8d 45 08	 lea	 eax, DWORD PTR _value$533771[ebp]
  0006e	50		 push	 eax
  0006f	8d 4f 1c	 lea	 ecx, DWORD PTR [edi+28]
  00072	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@H@@AAEXPBD@Z ; CEncrypt<int>::EncryptValueToPool

; 1445 : 	rkPreSetInfo.m_iBlueHPType = max( 0, m_DefaultInfo.m_iBlueHPType-1 );

  00077	8d 45 08	 lea	 eax, DWORD PTR _value$533776[ebp]
  0007a	50		 push	 eax
  0007b	8d 8e f0 01 00
	00		 lea	 ecx, DWORD PTR [esi+496]
  00081	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ; CEncrypt<int>::DecryptValueToPool
  00086	8b 45 08	 mov	 eax, DWORD PTR _value$533776[ebp]
  00089	48		 dec	 eax
  0008a	79 04		 jns	 SHORT $LN11@GetDefault
  0008c	33 c0		 xor	 eax, eax
  0008e	eb 13		 jmp	 SHORT $LN12@GetDefault
$LN11@GetDefault:
  00090	8d 45 08	 lea	 eax, DWORD PTR _value$533780[ebp]
  00093	50		 push	 eax
  00094	8d 8e f0 01 00
	00		 lea	 ecx, DWORD PTR [esi+496]
  0009a	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ; CEncrypt<int>::DecryptValueToPool
  0009f	8b 45 08	 mov	 eax, DWORD PTR _value$533780[ebp]
  000a2	48		 dec	 eax
$LN12@GetDefault:
  000a3	89 45 08	 mov	 DWORD PTR _value$533784[ebp], eax
  000a6	8d 45 08	 lea	 eax, DWORD PTR _value$533784[ebp]
  000a9	50		 push	 eax
  000aa	8d 4f 4c	 lea	 ecx, DWORD PTR [edi+76]
  000ad	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@H@@AAEXPBD@Z ; CEncrypt<int>::EncryptValueToPool

; 1446 : 	rkPreSetInfo.m_iDropDamageType = max( 0, m_DefaultInfo.m_iDropDamageType-1 );

  000b2	8b 86 20 02 00
	00		 mov	 eax, DWORD PTR [esi+544]
  000b8	48		 dec	 eax
  000b9	5b		 pop	 ebx
  000ba	79 02		 jns	 SHORT $LN13@GetDefault
  000bc	33 c0		 xor	 eax, eax
$LN13@GetDefault:
  000be	89 47 7c	 mov	 DWORD PTR [edi+124], eax

; 1447 : 	rkPreSetInfo.m_iGravityType = max( 0, m_DefaultInfo.m_iGravityType-1 );

  000c1	8b 86 24 02 00
	00		 mov	 eax, DWORD PTR [esi+548]
  000c7	48		 dec	 eax
  000c8	79 02		 jns	 SHORT $LN15@GetDefault
  000ca	33 c0		 xor	 eax, eax
$LN15@GetDefault:
  000cc	89 87 80 00 00
	00		 mov	 DWORD PTR [edi+128], eax

; 1448 : 	rkPreSetInfo.m_iGetUpType = max( 0, m_DefaultInfo.m_iGetUpType-1 );

  000d2	8b 86 28 02 00
	00		 mov	 eax, DWORD PTR [esi+552]
  000d8	48		 dec	 eax
  000d9	79 02		 jns	 SHORT $LN17@GetDefault
  000db	33 c0		 xor	 eax, eax
$LN17@GetDefault:
  000dd	89 87 84 00 00
	00		 mov	 DWORD PTR [edi+132], eax

; 1449 : 	rkPreSetInfo.m_iKOType = max( 0, m_DefaultInfo.m_iKOType-1 );

  000e3	8b 86 2c 02 00
	00		 mov	 eax, DWORD PTR [esi+556]
  000e9	48		 dec	 eax
  000ea	79 02		 jns	 SHORT $LN19@GetDefault
  000ec	33 c0		 xor	 eax, eax
$LN19@GetDefault:
  000ee	89 87 88 00 00
	00		 mov	 DWORD PTR [edi+136], eax

; 1450 : 	rkPreSetInfo.m_iKOEffectType = max( 0, m_DefaultInfo.m_iKOEffectType-1 );

  000f4	8b 86 30 02 00
	00		 mov	 eax, DWORD PTR [esi+560]
  000fa	48		 dec	 eax
  000fb	79 02		 jns	 SHORT $LN21@GetDefault
  000fd	33 c0		 xor	 eax, eax
$LN21@GetDefault:
  000ff	89 87 8c 00 00
	00		 mov	 DWORD PTR [edi+140], eax

; 1451 : 	rkPreSetInfo.m_iRedBlowType = max( 0, m_DefaultInfo.m_iRedBlowType-1 );

  00105	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  0010b	48		 dec	 eax
  0010c	79 02		 jns	 SHORT $LN23@GetDefault
  0010e	33 c0		 xor	 eax, eax
$LN23@GetDefault:
  00110	89 87 90 00 00
	00		 mov	 DWORD PTR [edi+144], eax

; 1452 : 	rkPreSetInfo.m_iBlueBlowType = max( 0, m_DefaultInfo.m_iBlueBlowType-1 );

  00116	8b 86 38 02 00
	00		 mov	 eax, DWORD PTR [esi+568]
  0011c	48		 dec	 eax
  0011d	79 02		 jns	 SHORT $LN25@GetDefault
  0011f	33 c0		 xor	 eax, eax
$LN25@GetDefault:
  00121	89 87 94 00 00
	00		 mov	 DWORD PTR [edi+148], eax

; 1453 : 	rkPreSetInfo.m_iRedMoveSpeedType = max( 0, m_DefaultInfo.m_iRedMoveSpeedType-1 );

  00127	8b 86 3c 02 00
	00		 mov	 eax, DWORD PTR [esi+572]
  0012d	48		 dec	 eax
  0012e	79 02		 jns	 SHORT $LN27@GetDefault
  00130	33 c0		 xor	 eax, eax
$LN27@GetDefault:
  00132	89 87 98 00 00
	00		 mov	 DWORD PTR [edi+152], eax

; 1454 : 	rkPreSetInfo.m_iBlueMoveSpeedType = max( 0, m_DefaultInfo.m_iBlueMoveSpeedType-1 );

  00138	8b 86 40 02 00
	00		 mov	 eax, DWORD PTR [esi+576]
  0013e	48		 dec	 eax
  0013f	79 02		 jns	 SHORT $LN29@GetDefault
  00141	33 c0		 xor	 eax, eax
$LN29@GetDefault:
  00143	89 87 9c 00 00
	00		 mov	 DWORD PTR [edi+156], eax

; 1455 : 	rkPreSetInfo.m_iRedEquipType = max( 0, m_DefaultInfo.m_iRedEquipType-1 );

  00149	8b 86 44 02 00
	00		 mov	 eax, DWORD PTR [esi+580]
  0014f	48		 dec	 eax
  00150	79 02		 jns	 SHORT $LN31@GetDefault
  00152	33 c0		 xor	 eax, eax
$LN31@GetDefault:
  00154	89 87 a0 00 00
	00		 mov	 DWORD PTR [edi+160], eax

; 1456 : 	rkPreSetInfo.m_iBlueEquipType = max( 0, m_DefaultInfo.m_iBlueEquipType-1 );

  0015a	8b 86 48 02 00
	00		 mov	 eax, DWORD PTR [esi+584]
  00160	48		 dec	 eax
  00161	79 02		 jns	 SHORT $LN33@GetDefault
  00163	33 c0		 xor	 eax, eax
$LN33@GetDefault:
  00165	89 87 a4 00 00
	00		 mov	 DWORD PTR [edi+164], eax

; 1457 : 
; 1458 : 	rkPreSetInfo.m_iCatchModeRoundType = max( 0, m_DefaultInfo.m_iCatchModeRoundType-1 );

  0016b	8b 86 4c 02 00
	00		 mov	 eax, DWORD PTR [esi+588]
  00171	48		 dec	 eax
  00172	79 02		 jns	 SHORT $LN35@GetDefault
  00174	33 c0		 xor	 eax, eax
$LN35@GetDefault:
  00176	89 87 a8 00 00
	00		 mov	 DWORD PTR [edi+168], eax

; 1459 : 	rkPreSetInfo.m_iCatchModeRoundTimeType = max( 0, m_DefaultInfo.m_iCatchModeRoundTimeType-1 );

  0017c	8b 86 50 02 00
	00		 mov	 eax, DWORD PTR [esi+592]
  00182	48		 dec	 eax
  00183	79 02		 jns	 SHORT $LN37@GetDefault
  00185	33 c0		 xor	 eax, eax
$LN37@GetDefault:
  00187	89 87 ac 00 00
	00		 mov	 DWORD PTR [edi+172], eax

; 1460 : 
; 1461 : 	rkPreSetInfo.m_iGrowthUseType = max( 0, m_DefaultInfo.m_iGrowthUseType-1 );

  0018d	8b 86 54 02 00
	00		 mov	 eax, DWORD PTR [esi+596]
  00193	48		 dec	 eax
  00194	79 02		 jns	 SHORT $LN39@GetDefault
  00196	33 c0		 xor	 eax, eax
$LN39@GetDefault:
  00198	89 87 b0 00 00
	00		 mov	 DWORD PTR [edi+176], eax

; 1462 : 	rkPreSetInfo.m_iExtraItemUseType = max( 0, m_DefaultInfo.m_iExtraItemUseType-1 );

  0019e	8b 86 58 02 00
	00		 mov	 eax, DWORD PTR [esi+600]
  001a4	48		 dec	 eax
  001a5	79 02		 jns	 SHORT $LN41@GetDefault
  001a7	33 c0		 xor	 eax, eax
$LN41@GetDefault:
  001a9	89 87 b4 00 00
	00		 mov	 DWORD PTR [edi+180], eax
  001af	5f		 pop	 edi

; 1463 : 
; 1464 : 	return true;

  001b0	b0 01		 mov	 al, 1
  001b2	5e		 pop	 esi

; 1465 : }

  001b3	5d		 pop	 ebp
  001b4	c2 04 00	 ret	 4
?GetDefaultInfo@ioRoomOptionManager@@QAE_NAAUPreSetInfo@@@Z ENDP ; ioRoomOptionManager::GetDefaultInfo
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@0@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::erase
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?erase@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Cat$533861 = 16					; size = 1
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@0@Z PROC ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	8b f1		 mov	 esi, ecx
  0000d	89 07		 mov	 DWORD PTR [edi], eax

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);
; 1193 : 
; 1194 : 		if (_First != _Last)

  0000f	3b 45 10	 cmp	 eax, DWORD PTR __Last_arg$[ebp]
  00012	74 16		 je	 SHORT $LN1@erase

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  00014	ff 75 10	 push	 DWORD PTR __Cat$533861[ebp]
  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	50		 push	 eax
  0001b	51		 push	 ecx
  0001c	ff 75 10	 push	 DWORD PTR __Last_arg$[ebp]
  0001f	e8 00 00 00 00	 call	 ??$_Move@PAPAURoomOptionInfo@@PAPAU1@@std@@YAPAPAURoomOptionInfo@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<RoomOptionInfo * *,RoomOptionInfo * *>
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);
; 1211 : 			this->_Mylast = _Ptr;

  00027	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN1@erase:

; 1212 : 			}
; 1213 : 		return (_First);

  0002a	8b c7		 mov	 eax, edi
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi

; 1214 : 		}

  0002e	5d		 pop	 ebp
  0002f	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@0@Z ENDP ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXXZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Tidy
EXTRN	__imp_?_Orphan_all@_Container_base0@std@@QAEXXZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ?_Tidy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00006	74 0e		 je	 SHORT $LN12@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  0000e	ff 36		 push	 DWORD PTR [esi]
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	59		 pop	 ecx
$LN12@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00016	83 26 00	 and	 DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

  00019	83 66 04 00	 and	 DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

  0001d	83 66 08 00	 and	 DWORD PTR [esi+8], 0
  00021	5e		 pop	 esi

; 1312 : 		}

  00022	c3		 ret	 0
?_Tidy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@2@0@Z ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::erase
; Function compile flags: /Ogsp
;	COMDAT ?erase@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Cat$534005 = 16					; size = 1
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@2@0@Z PROC ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	8b f1		 mov	 esi, ecx
  0000d	89 07		 mov	 DWORD PTR [edi], eax

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);
; 1193 : 
; 1194 : 		if (_First != _Last)

  0000f	3b 45 10	 cmp	 eax, DWORD PTR __Last_arg$[ebp]
  00012	74 16		 je	 SHORT $LN1@erase@2

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  00014	ff 75 10	 push	 DWORD PTR __Cat$534005[ebp]
  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	50		 push	 eax
  0001b	51		 push	 ecx
  0001c	ff 75 10	 push	 DWORD PTR __Last_arg$[ebp]
  0001f	e8 00 00 00 00	 call	 ??$_Move@PAPAUPreSetInfo@@PAPAU1@@std@@YAPAPAUPreSetInfo@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<PreSetInfo * *,PreSetInfo * *>
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);
; 1211 : 			this->_Mylast = _Ptr;

  00027	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN1@erase@2:

; 1212 : 			}
; 1213 : 		return (_First);

  0002a	8b c7		 mov	 eax, edi
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi

; 1214 : 		}

  0002e	5d		 pop	 ebp
  0002f	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@2@0@Z ENDP ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IAEXXZ ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Tidy
; Function compile flags: /Ogsp
;	COMDAT ?_Tidy@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00006	74 0e		 je	 SHORT $LN12@Tidy@2

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  0000e	ff 36		 push	 DWORD PTR [esi]
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	59		 pop	 ecx
$LN12@Tidy@2:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00016	83 26 00	 and	 DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

  00019	83 66 04 00	 and	 DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

  0001d	83 66 08 00	 and	 DWORD PTR [esi+8], 0
  00021	5e		 pop	 esi

; 1312 : 		}

  00022	c3		 ret	 0
?_Tidy@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?reserve@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXI@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::reserve
; Function compile flags: /Ogsp
;	COMDAT ?reserve@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?reserve@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXI@Z PROC ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 747  : 		if (max_size() < _Count)

  00003	81 7d 08 ff ff
	ff 3f		 cmp	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	76 0b		 jbe	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN43@reserve:
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  0001a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0001d	2b 06		 sub	 eax, DWORD PTR [esi]
  0001f	c1 f8 02	 sar	 eax, 2
  00022	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00025	73 52		 jae	 SHORT $LN3@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  00027	53		 push	 ebx
  00028	57		 push	 edi
  00029	6a 00		 push	 0
  0002b	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  0002e	e8 00 00 00 00	 call	 ??$_Allocate@PAURoomOptionInfo@@@std@@YAPAPAURoomOptionInfo@@IPAPAU1@@Z ; std::_Allocate<RoomOptionInfo *>

; 752  : 
; 753  : 			_TRY_BEGIN
; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00033	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00035	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  00038	52		 push	 edx
  00039	8b d8		 mov	 ebx, eax
  0003b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0003e	53		 push	 ebx
  0003f	50		 push	 eax
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAURoomOptionInfo@@PAPAU1@V?$allocator@PAURoomOptionInfo@@@std@@@std@@YAPAPAURoomOptionInfo@@PAPAU1@00AAV?$allocator@PAURoomOptionInfo@@@0@@Z ; std::_Uninitialized_move<RoomOptionInfo * *,RoomOptionInfo * *,std::allocator<RoomOptionInfo *> >

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);
; 757  : 			_RERAISE;
; 758  : 			_CATCH_END
; 759  : 
; 760  : 			size_type _Size = size();

  00046	8b 06		 mov	 eax, DWORD PTR [esi]
  00048	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0004b	2b f8		 sub	 edi, eax
  0004d	83 c4 18	 add	 esp, 24			; 00000018H
  00050	c1 ff 02	 sar	 edi, 2

; 761  : 			if (this->_Myfirst != 0)

  00053	85 c0		 test	 eax, eax
  00055	74 07		 je	 SHORT $LN39@reserve

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);
; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0005d	59		 pop	 ecx
$LN39@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  0005e	8b ce		 mov	 ecx, esi
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 769  : 			this->_Myend = _Ptr + _Count;

  00066	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00069	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]
  0006c	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 770  : 			this->_Mylast = _Ptr + _Size;

  0006f	8d 04 bb	 lea	 eax, DWORD PTR [ebx+edi*4]
  00072	5f		 pop	 edi

; 771  : 			this->_Myfirst = _Ptr;

  00073	89 1e		 mov	 DWORD PTR [esi], ebx
  00075	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00078	5b		 pop	 ebx
$LN3@reserve:
  00079	5e		 pop	 esi

; 772  : 			}
; 773  : 		}

  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
$LN42@reserve:
?reserve@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXI@Z ENDP ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::reserve
_TEXT	ENDS
PUBLIC	?reserve@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAEXI@Z ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::reserve
; Function compile flags: /Ogsp
;	COMDAT ?reserve@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?reserve@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAEXI@Z PROC ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 747  : 		if (max_size() < _Count)

  00003	81 7d 08 ff ff
	ff 3f		 cmp	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	76 0b		 jbe	 SHORT $LN5@reserve@2

; 748  : 			_Xlen();	// result too long

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN43@reserve@2:
$LN5@reserve@2:

; 749  : 		else if (capacity() < _Count)

  0001a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0001d	2b 06		 sub	 eax, DWORD PTR [esi]
  0001f	c1 f8 02	 sar	 eax, 2
  00022	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00025	73 52		 jae	 SHORT $LN3@reserve@2

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  00027	53		 push	 ebx
  00028	57		 push	 edi
  00029	6a 00		 push	 0
  0002b	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  0002e	e8 00 00 00 00	 call	 ??$_Allocate@PAUPreSetInfo@@@std@@YAPAPAUPreSetInfo@@IPAPAU1@@Z ; std::_Allocate<PreSetInfo *>

; 752  : 
; 753  : 			_TRY_BEGIN
; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00033	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00035	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  00038	52		 push	 edx
  00039	8b d8		 mov	 ebx, eax
  0003b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0003e	53		 push	 ebx
  0003f	50		 push	 eax
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAUPreSetInfo@@PAPAU1@V?$allocator@PAUPreSetInfo@@@std@@@std@@YAPAPAUPreSetInfo@@PAPAU1@00AAV?$allocator@PAUPreSetInfo@@@0@@Z ; std::_Uninitialized_move<PreSetInfo * *,PreSetInfo * *,std::allocator<PreSetInfo *> >

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);
; 757  : 			_RERAISE;
; 758  : 			_CATCH_END
; 759  : 
; 760  : 			size_type _Size = size();

  00046	8b 06		 mov	 eax, DWORD PTR [esi]
  00048	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0004b	2b f8		 sub	 edi, eax
  0004d	83 c4 18	 add	 esp, 24			; 00000018H
  00050	c1 ff 02	 sar	 edi, 2

; 761  : 			if (this->_Myfirst != 0)

  00053	85 c0		 test	 eax, eax
  00055	74 07		 je	 SHORT $LN39@reserve@2

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);
; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0005d	59		 pop	 ecx
$LN39@reserve@2:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  0005e	8b ce		 mov	 ecx, esi
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 769  : 			this->_Myend = _Ptr + _Count;

  00066	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00069	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]
  0006c	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 770  : 			this->_Mylast = _Ptr + _Size;

  0006f	8d 04 bb	 lea	 eax, DWORD PTR [ebx+edi*4]
  00072	5f		 pop	 edi

; 771  : 			this->_Myfirst = _Ptr;

  00073	89 1e		 mov	 DWORD PTR [esi], ebx
  00075	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00078	5b		 pop	 ebx
$LN3@reserve@2:
  00079	5e		 pop	 esi

; 772  : 			}
; 773  : 		}

  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
$LN42@reserve@2:
?reserve@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAEXI@Z ENDP ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::reserve
_TEXT	ENDS
PUBLIC	??0PreSetInfo@@QAE@XZ				; PreSetInfo::PreSetInfo
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioroomoptionmanager.h
xdata$x	SEGMENT
__unwindtable$??0PreSetInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0PreSetInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0PreSetInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0PreSetInfo@@QAE@XZ$2
__ehfuncinfo$??0PreSetInfo@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0PreSetInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??0PreSetInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0PreSetInfo@@QAE@XZ PROC				; PreSetInfo::PreSetInfo, COMDAT
; _this$ = ecx

; 46   : 	PreSetInfo()

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0PreSetInfo@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ
  00017	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0001b	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
  0001e	e8 00 00 00 00	 call	 ??0?$CEncrypt@H@@QAE@XZ	; CEncrypt<int>::CEncrypt<int>
  00023	8d 4e 4c	 lea	 ecx, DWORD PTR [esi+76]
  00026	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0002a	e8 00 00 00 00	 call	 ??0?$CEncrypt@H@@QAE@XZ	; CEncrypt<int>::CEncrypt<int>

; 47   : 	{
; 48   : 		Init();

  0002f	8b ce		 mov	 ecx, esi
  00031	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00035	e8 00 00 00 00	 call	 ?Init@PreSetInfo@@QAEXXZ ; PreSetInfo::Init

; 49   : 	}

  0003a	8b c6		 mov	 eax, esi
  0003c	e8 00 00 00 00	 call	 __EH_epilog3
  00041	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0PreSetInfo@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??0PreSetInfo@@QAE@XZ$1:
  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0000f	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@H@@UAE@XZ	; CEncrypt<int>::~CEncrypt<int>
__unwindfunclet$??0PreSetInfo@@QAE@XZ$2:
  00014	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0001a	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@H@@UAE@XZ	; CEncrypt<int>::~CEncrypt<int>
__ehhandler$??0PreSetInfo@@QAE@XZ:
  0001f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00023	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00026	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0PreSetInfo@@QAE@XZ
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0PreSetInfo@@QAE@XZ ENDP				; PreSetInfo::PreSetInfo
PUBLIC	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Cat$534322 = 16					; size = 1
__Last_arg$ = 16					; size = 4
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@0@Z PROC ; std::vector<int,std::allocator<int> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	8b f1		 mov	 esi, ecx
  0000d	89 07		 mov	 DWORD PTR [edi], eax

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);
; 1193 : 
; 1194 : 		if (_First != _Last)

  0000f	3b 45 10	 cmp	 eax, DWORD PTR __Last_arg$[ebp]
  00012	74 16		 je	 SHORT $LN1@erase@3

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  00014	ff 75 10	 push	 DWORD PTR __Cat$534322[ebp]
  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	50		 push	 eax
  0001b	51		 push	 ecx
  0001c	ff 75 10	 push	 DWORD PTR __Last_arg$[ebp]
  0001f	e8 00 00 00 00	 call	 ??$_Move@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<int *,int *>
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);
; 1211 : 			this->_Mylast = _Ptr;

  00027	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN1@erase@3:

; 1212 : 			}
; 1213 : 		return (_First);

  0002a	8b c7		 mov	 eax, edi
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi

; 1214 : 		}

  0002e	5d		 pop	 ebp
  0002f	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@0@Z ENDP ; std::vector<int,std::allocator<int> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Ogsp
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00006	74 0e		 je	 SHORT $LN12@Tidy@3

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  0000e	ff 36		 push	 DWORD PTR [esi]
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	59		 pop	 ecx
$LN12@Tidy@3:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00016	83 26 00	 and	 DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

  00019	83 66 04 00	 and	 DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

  0001d	83 66 08 00	 and	 DWORD PTR [esi+8], 0
  00021	5e		 pop	 esi

; 1312 : 		}

  00022	c3		 ret	 0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
PUBLIC	?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int> >::reserve
; Function compile flags: /Ogsp
;	COMDAT ?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z PROC ; std::vector<int,std::allocator<int> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 747  : 		if (max_size() < _Count)

  00003	81 7d 08 ff ff
	ff 3f		 cmp	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	76 0b		 jbe	 SHORT $LN5@reserve@3

; 748  : 			_Xlen();	// result too long

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN43@reserve@3:
$LN5@reserve@3:

; 749  : 		else if (capacity() < _Count)

  0001a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0001d	2b 06		 sub	 eax, DWORD PTR [esi]
  0001f	c1 f8 02	 sar	 eax, 2
  00022	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00025	73 52		 jae	 SHORT $LN3@reserve@3

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  00027	53		 push	 ebx
  00028	57		 push	 edi
  00029	6a 00		 push	 0
  0002b	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  0002e	e8 00 00 00 00	 call	 ??$_Allocate@H@std@@YAPAHIPAH@Z ; std::_Allocate<int>

; 752  : 
; 753  : 			_TRY_BEGIN
; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00033	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00035	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  00038	52		 push	 edx
  00039	8b d8		 mov	 ebx, eax
  0003b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0003e	53		 push	 ebx
  0003f	50		 push	 eax
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,int *,std::allocator<int> >

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);
; 757  : 			_RERAISE;
; 758  : 			_CATCH_END
; 759  : 
; 760  : 			size_type _Size = size();

  00046	8b 06		 mov	 eax, DWORD PTR [esi]
  00048	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0004b	2b f8		 sub	 edi, eax
  0004d	83 c4 18	 add	 esp, 24			; 00000018H
  00050	c1 ff 02	 sar	 edi, 2

; 761  : 			if (this->_Myfirst != 0)

  00053	85 c0		 test	 eax, eax
  00055	74 07		 je	 SHORT $LN39@reserve@3

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);
; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0005d	59		 pop	 ecx
$LN39@reserve@3:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  0005e	8b ce		 mov	 ecx, esi
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 769  : 			this->_Myend = _Ptr + _Count;

  00066	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00069	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]
  0006c	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 770  : 			this->_Mylast = _Ptr + _Size;

  0006f	8d 04 bb	 lea	 eax, DWORD PTR [ebx+edi*4]
  00072	5f		 pop	 edi

; 771  : 			this->_Myfirst = _Ptr;

  00073	89 1e		 mov	 DWORD PTR [esi], ebx
  00075	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00078	5b		 pop	 ebx
$LN3@reserve@3:
  00079	5e		 pop	 esi

; 772  : 			}
; 773  : 		}

  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
$LN42@reserve@3:
?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::reserve
_TEXT	ENDS
PUBLIC	??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >, COMDAT
; _this$ = ecx

; 705  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXXZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Tidy
??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXXZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::clear
; Function compile flags: /Ogsp
;	COMDAT ?clear@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T534485 = -4						; size = 4
?clear@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1218 : 		erase(begin(), end());

  00004	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00007	8b 11		 mov	 edx, DWORD PTR [ecx]
  00009	50		 push	 eax
  0000a	52		 push	 edx
  0000b	8d 45 fc	 lea	 eax, DWORD PTR $T534485[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?erase@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@0@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::erase

; 1219 : 		}

  00014	c9		 leave
  00015	c3		 ret	 0
?clear@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::clear
_TEXT	ENDS
PUBLIC	??1?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE@XZ ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::~vector<PreSetInfo *,std::allocator<PreSetInfo *> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::~vector<PreSetInfo *,std::allocator<PreSetInfo *> >, COMDAT
; _this$ = ecx

; 705  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IAEXXZ ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Tidy
??1?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::~vector<PreSetInfo *,std::allocator<PreSetInfo *> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAEXXZ ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::clear
; Function compile flags: /Ogsp
;	COMDAT ?clear@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T534549 = -4						; size = 4
?clear@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1218 : 		erase(begin(), end());

  00004	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00007	8b 11		 mov	 edx, DWORD PTR [ecx]
  00009	50		 push	 eax
  0000a	52		 push	 edx
  0000b	8d 45 fc	 lea	 eax, DWORD PTR $T534549[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?erase@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@2@0@Z ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::erase

; 1219 : 		}

  00014	c9		 leave
  00015	c3		 ret	 0
?clear@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::clear
_TEXT	ENDS
PUBLIC	?_Reserve@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXI@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Reserve
; Function compile flags: /Ogsp
;	COMDAT ?_Reserve@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXI@Z PROC ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1291 : 		size_type _Size = size();

  00006	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00008	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000b	2b c1		 sub	 eax, ecx

; 1292 : 		if (max_size() - _Count < _Size)

  0000d	ba ff ff ff 3f	 mov	 edx, 1073741823		; 3fffffffH
  00012	2b 55 08	 sub	 edx, DWORD PTR __Count$[ebp]
  00015	c1 f8 02	 sar	 eax, 2
  00018	3b d0		 cmp	 edx, eax
  0001a	73 0b		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN21@Reserve:
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00027	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002a	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  0002d	2b d1		 sub	 edx, ecx
  0002f	c1 fa 02	 sar	 edx, 2
  00032	3b c2		 cmp	 eax, edx
  00034	76 10		 jbe	 SHORT $LN1@Reserve

; 1295 : 			;
; 1296 : 		else
; 1297 : 			reserve(_Grow_to(_Size));

  00036	50		 push	 eax
  00037	8b ce		 mov	 ecx, esi
  00039	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IBEII@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Grow_to
  0003e	50		 push	 eax
  0003f	8b ce		 mov	 ecx, esi
  00041	e8 00 00 00 00	 call	 ?reserve@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXI@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::reserve
$LN1@Reserve:
  00046	5e		 pop	 esi

; 1298 : 		}

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN20@Reserve:
?_Reserve@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXI@Z ENDP ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Reserve
_TEXT	ENDS
PUBLIC	?_Reserve@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IAEXI@Z ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Reserve
; Function compile flags: /Ogsp
;	COMDAT ?_Reserve@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IAEXI@Z PROC ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1291 : 		size_type _Size = size();

  00006	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00008	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000b	2b c1		 sub	 eax, ecx

; 1292 : 		if (max_size() - _Count < _Size)

  0000d	ba ff ff ff 3f	 mov	 edx, 1073741823		; 3fffffffH
  00012	2b 55 08	 sub	 edx, DWORD PTR __Count$[ebp]
  00015	c1 f8 02	 sar	 eax, 2
  00018	3b d0		 cmp	 edx, eax
  0001a	73 0b		 jae	 SHORT $LN4@Reserve@2

; 1293 : 			_Xlen();

  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN21@Reserve@2:
$LN4@Reserve@2:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00027	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002a	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  0002d	2b d1		 sub	 edx, ecx
  0002f	c1 fa 02	 sar	 edx, 2
  00032	3b c2		 cmp	 eax, edx
  00034	76 10		 jbe	 SHORT $LN1@Reserve@2

; 1295 : 			;
; 1296 : 		else
; 1297 : 			reserve(_Grow_to(_Size));

  00036	50		 push	 eax
  00037	8b ce		 mov	 ecx, esi
  00039	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IBEII@Z ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Grow_to
  0003e	50		 push	 eax
  0003f	8b ce		 mov	 ecx, esi
  00041	e8 00 00 00 00	 call	 ?reserve@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAEXI@Z ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::reserve
$LN1@Reserve@2:
  00046	5e		 pop	 esi

; 1298 : 		}

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN20@Reserve@2:
?_Reserve@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IAEXI@Z ENDP ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Reserve
_TEXT	ENDS
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 705  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::clear
; Function compile flags: /Ogsp
;	COMDAT ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T534673 = -4						; size = 4
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ PROC	; std::vector<int,std::allocator<int> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1218 : 		erase(begin(), end());

  00004	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00007	8b 11		 mov	 edx, DWORD PTR [ecx]
  00009	50		 push	 eax
  0000a	52		 push	 edx
  0000b	8d 45 fc	 lea	 eax, DWORD PTR $T534673[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase

; 1219 : 		}

  00014	c9		 leave
  00015	c3		 ret	 0
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ENDP	; std::vector<int,std::allocator<int> >::clear
_TEXT	ENDS
PUBLIC	?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int> >::_Reserve
; Function compile flags: /Ogsp
;	COMDAT ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z PROC ; std::vector<int,std::allocator<int> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1291 : 		size_type _Size = size();

  00006	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00008	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000b	2b c1		 sub	 eax, ecx

; 1292 : 		if (max_size() - _Count < _Size)

  0000d	ba ff ff ff 3f	 mov	 edx, 1073741823		; 3fffffffH
  00012	2b 55 08	 sub	 edx, DWORD PTR __Count$[ebp]
  00015	c1 f8 02	 sar	 eax, 2
  00018	3b d0		 cmp	 edx, eax
  0001a	73 0b		 jae	 SHORT $LN4@Reserve@3

; 1293 : 			_Xlen();

  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN21@Reserve@3:
$LN4@Reserve@3:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00027	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002a	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  0002d	2b d1		 sub	 edx, ecx
  0002f	c1 fa 02	 sar	 edx, 2
  00032	3b c2		 cmp	 eax, edx
  00034	76 10		 jbe	 SHORT $LN1@Reserve@3

; 1295 : 			;
; 1296 : 		else
; 1297 : 			reserve(_Grow_to(_Size));

  00036	50		 push	 eax
  00037	8b ce		 mov	 ecx, esi
  00039	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z ; std::vector<int,std::allocator<int> >::_Grow_to
  0003e	50		 push	 eax
  0003f	8b ce		 mov	 ecx, esi
  00041	e8 00 00 00 00	 call	 ?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int> >::reserve
$LN1@Reserve@3:
  00046	5e		 pop	 esi

; 1298 : 		}

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN20@Reserve@3:
?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::_Reserve
_TEXT	ENDS
PUBLIC	?ClearAllInfo@ioRoomOptionManager@@IAEXXZ	; ioRoomOptionManager::ClearAllInfo
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioroomoptionmanager.cpp
;	COMDAT ?ClearAllInfo@ioRoomOptionManager@@IAEXXZ
_TEXT	SEGMENT
tv4323 = -4						; size = 4
tv4305 = -4						; size = 4
tv4287 = -4						; size = 4
tv4269 = -4						; size = 4
tv4251 = -4						; size = 4
tv4233 = -4						; size = 4
tv4215 = -4						; size = 4
tv4197 = -4						; size = 4
tv4179 = -4						; size = 4
tv4161 = -4						; size = 4
tv4143 = -4						; size = 4
tv4125 = -4						; size = 4
tv4107 = -4						; size = 4
tv4089 = -4						; size = 4
tv4071 = -4						; size = 4
tv4053 = -4						; size = 4
tv4035 = -4						; size = 4
tv4017 = -4						; size = 4
tv3999 = -4						; size = 4
tv3981 = -4						; size = 4
tv3962 = -4						; size = 4
$T538883 = -4						; size = 4
$T538702 = -4						; size = 4
$T538522 = -4						; size = 4
$T538340 = -4						; size = 4
$T538159 = -4						; size = 4
$T537978 = -4						; size = 4
$T537797 = -4						; size = 4
$T537625 = -4						; size = 4
$T537436 = -4						; size = 4
$T537254 = -4						; size = 4
$T537073 = -4						; size = 4
$T536892 = -4						; size = 4
$T536711 = -4						; size = 4
$T536531 = -4						; size = 4
$T536350 = -4						; size = 4
$T536168 = -4						; size = 4
$T535987 = -4						; size = 4
$T535806 = -4						; size = 4
$T535625 = -4						; size = 4
$T535445 = -4						; size = 4
$T535263 = -4						; size = 4
$T535082 = -4						; size = 4
$T535002 = -4						; size = 4
$T534922 = -4						; size = 4
?ClearAllInfo@ioRoomOptionManager@@IAEXXZ PROC		; ioRoomOptionManager::ClearAllInfo, COMDAT
; _this$ = ecx

; 676  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 677  : 	m_EnableOptionModeList.clear();

  00008	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0000b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0000e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	52		 push	 edx
  00013	8d 45 fc	 lea	 eax, DWORD PTR $T534922[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase

; 678  : 	m_EnableRoundOptionModeList.clear();

  0001c	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  0001f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00022	8b 11		 mov	 edx, DWORD PTR [ecx]
  00024	50		 push	 eax
  00025	52		 push	 edx
  00026	8d 45 fc	 lea	 eax, DWORD PTR $T535002[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase

; 679  : 	m_NoChallengerModeList.clear();

  0002f	8d 4e 24	 lea	 ecx, DWORD PTR [esi+36]
  00032	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00035	8b 11		 mov	 edx, DWORD PTR [ecx]
  00037	50		 push	 eax
  00038	52		 push	 edx
  00039	8d 45 fc	 lea	 eax, DWORD PTR $T535082[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase

; 680  : 
; 681  : 	for(RoomOptionInfoList::iterator iter = m_RoomChangeCharList.begin(); iter != m_RoomChangeCharList.end(); ++iter)

  00042	8b 5e 34	 mov	 ebx, DWORD PTR [esi+52]
  00045	eb 1f		 jmp	 SHORT $LN1465@ClearAllIn
$LL193@ClearAllIn:

; 682  : 	    SAFEDELETE( *iter );

  00047	8b 03		 mov	 eax, DWORD PTR [ebx]
  00049	89 45 fc	 mov	 DWORD PTR tv3962[ebp], eax
  0004c	85 c0		 test	 eax, eax
  0004e	74 13		 je	 SHORT $LN83@ClearAllIn
  00050	8b c8		 mov	 ecx, eax
  00052	e8 00 00 00 00	 call	 ??1RoomOptionInfo@@QAE@XZ
  00057	ff 75 fc	 push	 DWORD PTR tv3962[ebp]
  0005a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0005f	83 23 00	 and	 DWORD PTR [ebx], 0
  00062	59		 pop	 ecx
$LN83@ClearAllIn:

; 680  : 
; 681  : 	for(RoomOptionInfoList::iterator iter = m_RoomChangeCharList.begin(); iter != m_RoomChangeCharList.end(); ++iter)

  00063	83 c3 04	 add	 ebx, 4
$LN1465@ClearAllIn:
  00066	3b 5e 38	 cmp	 ebx, DWORD PTR [esi+56]
  00069	75 dc		 jne	 SHORT $LL193@ClearAllIn

; 683  : 	m_RoomChangeCharList.clear();

  0006b	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  0006e	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  00071	50		 push	 eax
  00072	51		 push	 ecx
  00073	8d 45 fc	 lea	 eax, DWORD PTR $T535263[ebp]
  00076	50		 push	 eax
  00077	8d 4e 34	 lea	 ecx, DWORD PTR [esi+52]
  0007a	e8 00 00 00 00	 call	 ?erase@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@0@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::erase

; 684  : 	for(RoomOptionInfoList::iterator iter = m_RoomRedHPList.begin(); iter != m_RoomRedHPList.end(); ++iter)

  0007f	8b 5e 44	 mov	 ebx, DWORD PTR [esi+68]
  00082	eb 1d		 jmp	 SHORT $LN1466@ClearAllIn
$LL252@ClearAllIn:

; 685  : 		SAFEDELETE( *iter );

  00084	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00086	89 4d fc	 mov	 DWORD PTR tv3981[ebp], ecx
  00089	85 c9		 test	 ecx, ecx
  0008b	74 11		 je	 SHORT $LN79@ClearAllIn
  0008d	e8 00 00 00 00	 call	 ??1RoomOptionInfo@@QAE@XZ
  00092	ff 75 fc	 push	 DWORD PTR tv3981[ebp]
  00095	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0009a	83 23 00	 and	 DWORD PTR [ebx], 0
  0009d	59		 pop	 ecx
$LN79@ClearAllIn:

; 684  : 	for(RoomOptionInfoList::iterator iter = m_RoomRedHPList.begin(); iter != m_RoomRedHPList.end(); ++iter)

  0009e	83 c3 04	 add	 ebx, 4
$LN1466@ClearAllIn:
  000a1	3b 5e 48	 cmp	 ebx, DWORD PTR [esi+72]
  000a4	75 de		 jne	 SHORT $LL252@ClearAllIn

; 686  : 	m_RoomRedHPList.clear();

  000a6	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  000a9	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  000ac	50		 push	 eax
  000ad	51		 push	 ecx
  000ae	8d 45 fc	 lea	 eax, DWORD PTR $T535445[ebp]
  000b1	50		 push	 eax
  000b2	8d 4e 44	 lea	 ecx, DWORD PTR [esi+68]
  000b5	e8 00 00 00 00	 call	 ?erase@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@0@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::erase

; 687  : 	for(RoomOptionInfoList::iterator iter = m_RoomBlueHPList.begin(); iter != m_RoomBlueHPList.end(); ++iter)

  000ba	8b 5e 54	 mov	 ebx, DWORD PTR [esi+84]
  000bd	eb 1d		 jmp	 SHORT $LN1467@ClearAllIn
$LL311@ClearAllIn:

; 688  : 		SAFEDELETE( *iter );

  000bf	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000c1	89 4d fc	 mov	 DWORD PTR tv3999[ebp], ecx
  000c4	85 c9		 test	 ecx, ecx
  000c6	74 11		 je	 SHORT $LN75@ClearAllIn
  000c8	e8 00 00 00 00	 call	 ??1RoomOptionInfo@@QAE@XZ
  000cd	ff 75 fc	 push	 DWORD PTR tv3999[ebp]
  000d0	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000d5	83 23 00	 and	 DWORD PTR [ebx], 0
  000d8	59		 pop	 ecx
$LN75@ClearAllIn:

; 687  : 	for(RoomOptionInfoList::iterator iter = m_RoomBlueHPList.begin(); iter != m_RoomBlueHPList.end(); ++iter)

  000d9	83 c3 04	 add	 ebx, 4
$LN1467@ClearAllIn:
  000dc	3b 5e 58	 cmp	 ebx, DWORD PTR [esi+88]
  000df	75 de		 jne	 SHORT $LL311@ClearAllIn

; 689  : 	m_RoomBlueHPList.clear();

  000e1	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  000e4	8b 4e 54	 mov	 ecx, DWORD PTR [esi+84]
  000e7	50		 push	 eax
  000e8	51		 push	 ecx
  000e9	8d 45 fc	 lea	 eax, DWORD PTR $T535625[ebp]
  000ec	50		 push	 eax
  000ed	8d 4e 54	 lea	 ecx, DWORD PTR [esi+84]
  000f0	e8 00 00 00 00	 call	 ?erase@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@0@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::erase

; 690  : 	for(RoomOptionInfoList::iterator iter = m_RoomCoolTimeList.begin(); iter != m_RoomCoolTimeList.end(); ++iter)

  000f5	8b 9e 84 00 00
	00		 mov	 ebx, DWORD PTR [esi+132]
  000fb	eb 1f		 jmp	 SHORT $LN1468@ClearAllIn
$LL370@ClearAllIn:

; 691  : 		SAFEDELETE( *iter );

  000fd	8b 03		 mov	 eax, DWORD PTR [ebx]
  000ff	89 45 fc	 mov	 DWORD PTR tv4017[ebp], eax
  00102	85 c0		 test	 eax, eax
  00104	74 13		 je	 SHORT $LN71@ClearAllIn
  00106	8b c8		 mov	 ecx, eax
  00108	e8 00 00 00 00	 call	 ??1RoomOptionInfo@@QAE@XZ
  0010d	ff 75 fc	 push	 DWORD PTR tv4017[ebp]
  00110	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00115	83 23 00	 and	 DWORD PTR [ebx], 0
  00118	59		 pop	 ecx
$LN71@ClearAllIn:

; 690  : 	for(RoomOptionInfoList::iterator iter = m_RoomCoolTimeList.begin(); iter != m_RoomCoolTimeList.end(); ++iter)

  00119	83 c3 04	 add	 ebx, 4
$LN1468@ClearAllIn:
  0011c	3b 9e 88 00 00
	00		 cmp	 ebx, DWORD PTR [esi+136]
  00122	75 d9		 jne	 SHORT $LL370@ClearAllIn

; 692  : 	m_RoomCoolTimeList.clear();

  00124	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  0012a	8b 8e 84 00 00
	00		 mov	 ecx, DWORD PTR [esi+132]
  00130	50		 push	 eax
  00131	51		 push	 ecx
  00132	8d 45 fc	 lea	 eax, DWORD PTR $T535806[ebp]
  00135	50		 push	 eax
  00136	8d 8e 84 00 00
	00		 lea	 ecx, DWORD PTR [esi+132]
  0013c	e8 00 00 00 00	 call	 ?erase@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@0@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::erase

; 693  : 	for(RoomOptionInfoList::iterator iter = m_RoomDropDamageList.begin(); iter != m_RoomDropDamageList.end(); ++iter)

  00141	8b 9e 94 00 00
	00		 mov	 ebx, DWORD PTR [esi+148]
  00147	eb 1f		 jmp	 SHORT $LN1469@ClearAllIn
$LL429@ClearAllIn:

; 694  : 		SAFEDELETE( *iter );

  00149	8b 03		 mov	 eax, DWORD PTR [ebx]
  0014b	89 45 fc	 mov	 DWORD PTR tv4035[ebp], eax
  0014e	85 c0		 test	 eax, eax
  00150	74 13		 je	 SHORT $LN67@ClearAllIn
  00152	8b c8		 mov	 ecx, eax
  00154	e8 00 00 00 00	 call	 ??1RoomOptionInfo@@QAE@XZ
  00159	ff 75 fc	 push	 DWORD PTR tv4035[ebp]
  0015c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00161	83 23 00	 and	 DWORD PTR [ebx], 0
  00164	59		 pop	 ecx
$LN67@ClearAllIn:

; 693  : 	for(RoomOptionInfoList::iterator iter = m_RoomDropDamageList.begin(); iter != m_RoomDropDamageList.end(); ++iter)

  00165	83 c3 04	 add	 ebx, 4
$LN1469@ClearAllIn:
  00168	3b 9e 98 00 00
	00		 cmp	 ebx, DWORD PTR [esi+152]
  0016e	75 d9		 jne	 SHORT $LL429@ClearAllIn

; 695  : 	m_RoomDropDamageList.clear();

  00170	8b 86 98 00 00
	00		 mov	 eax, DWORD PTR [esi+152]
  00176	8b 8e 94 00 00
	00		 mov	 ecx, DWORD PTR [esi+148]
  0017c	50		 push	 eax
  0017d	51		 push	 ecx
  0017e	8d 45 fc	 lea	 eax, DWORD PTR $T535987[ebp]
  00181	50		 push	 eax
  00182	8d 8e 94 00 00
	00		 lea	 ecx, DWORD PTR [esi+148]
  00188	e8 00 00 00 00	 call	 ?erase@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@0@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::erase

; 696  : 	for(RoomOptionInfoList::iterator iter = m_RoomGravityList.begin(); iter != m_RoomGravityList.end(); ++iter)

  0018d	8b 9e a4 00 00
	00		 mov	 ebx, DWORD PTR [esi+164]
  00193	eb 1f		 jmp	 SHORT $LN1470@ClearAllIn
$LL488@ClearAllIn:

; 697  : 		SAFEDELETE( *iter );

  00195	8b 03		 mov	 eax, DWORD PTR [ebx]
  00197	89 45 fc	 mov	 DWORD PTR tv4053[ebp], eax
  0019a	85 c0		 test	 eax, eax
  0019c	74 13		 je	 SHORT $LN63@ClearAllIn
  0019e	8b c8		 mov	 ecx, eax
  001a0	e8 00 00 00 00	 call	 ??1RoomOptionInfo@@QAE@XZ
  001a5	ff 75 fc	 push	 DWORD PTR tv4053[ebp]
  001a8	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001ad	83 23 00	 and	 DWORD PTR [ebx], 0
  001b0	59		 pop	 ecx
$LN63@ClearAllIn:

; 696  : 	for(RoomOptionInfoList::iterator iter = m_RoomGravityList.begin(); iter != m_RoomGravityList.end(); ++iter)

  001b1	83 c3 04	 add	 ebx, 4
$LN1470@ClearAllIn:
  001b4	3b 9e a8 00 00
	00		 cmp	 ebx, DWORD PTR [esi+168]
  001ba	75 d9		 jne	 SHORT $LL488@ClearAllIn

; 698  : 	m_RoomGravityList.clear();

  001bc	8b 86 a8 00 00
	00		 mov	 eax, DWORD PTR [esi+168]
  001c2	8b 8e a4 00 00
	00		 mov	 ecx, DWORD PTR [esi+164]
  001c8	50		 push	 eax
  001c9	51		 push	 ecx
  001ca	8d 45 fc	 lea	 eax, DWORD PTR $T536168[ebp]
  001cd	50		 push	 eax
  001ce	8d 8e a4 00 00
	00		 lea	 ecx, DWORD PTR [esi+164]
  001d4	e8 00 00 00 00	 call	 ?erase@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@0@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::erase

; 699  : 	for(RoomOptionInfoList::iterator iter = m_RoomTeamAttackList.begin(); iter != m_RoomTeamAttackList.end(); ++iter)

  001d9	8b 9e b4 00 00
	00		 mov	 ebx, DWORD PTR [esi+180]
  001df	eb 1f		 jmp	 SHORT $LN1471@ClearAllIn
$LL547@ClearAllIn:

; 700  : 		SAFEDELETE( *iter );

  001e1	8b 03		 mov	 eax, DWORD PTR [ebx]
  001e3	89 45 fc	 mov	 DWORD PTR tv4071[ebp], eax
  001e6	85 c0		 test	 eax, eax
  001e8	74 13		 je	 SHORT $LN59@ClearAllIn
  001ea	8b c8		 mov	 ecx, eax
  001ec	e8 00 00 00 00	 call	 ??1RoomOptionInfo@@QAE@XZ
  001f1	ff 75 fc	 push	 DWORD PTR tv4071[ebp]
  001f4	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001f9	83 23 00	 and	 DWORD PTR [ebx], 0
  001fc	59		 pop	 ecx
$LN59@ClearAllIn:

; 699  : 	for(RoomOptionInfoList::iterator iter = m_RoomTeamAttackList.begin(); iter != m_RoomTeamAttackList.end(); ++iter)

  001fd	83 c3 04	 add	 ebx, 4
$LN1471@ClearAllIn:
  00200	3b 9e b8 00 00
	00		 cmp	 ebx, DWORD PTR [esi+184]
  00206	75 d9		 jne	 SHORT $LL547@ClearAllIn

; 701  : 	m_RoomTeamAttackList.clear();

  00208	8b 86 b8 00 00
	00		 mov	 eax, DWORD PTR [esi+184]
  0020e	8b 8e b4 00 00
	00		 mov	 ecx, DWORD PTR [esi+180]
  00214	50		 push	 eax
  00215	51		 push	 ecx
  00216	8d 45 fc	 lea	 eax, DWORD PTR $T536350[ebp]
  00219	50		 push	 eax
  0021a	8d 8e b4 00 00
	00		 lea	 ecx, DWORD PTR [esi+180]
  00220	e8 00 00 00 00	 call	 ?erase@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@0@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::erase

; 702  : 	for(RoomOptionInfoList::iterator iter = m_RoomGetUpList.begin(); iter != m_RoomGetUpList.end(); ++iter)

  00225	8b 9e c4 00 00
	00		 mov	 ebx, DWORD PTR [esi+196]
  0022b	eb 1f		 jmp	 SHORT $LN1472@ClearAllIn
$LL606@ClearAllIn:

; 703  : 		SAFEDELETE( *iter );

  0022d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0022f	89 45 fc	 mov	 DWORD PTR tv4089[ebp], eax
  00232	85 c0		 test	 eax, eax
  00234	74 13		 je	 SHORT $LN55@ClearAllIn
  00236	8b c8		 mov	 ecx, eax
  00238	e8 00 00 00 00	 call	 ??1RoomOptionInfo@@QAE@XZ
  0023d	ff 75 fc	 push	 DWORD PTR tv4089[ebp]
  00240	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00245	83 23 00	 and	 DWORD PTR [ebx], 0
  00248	59		 pop	 ecx
$LN55@ClearAllIn:

; 702  : 	for(RoomOptionInfoList::iterator iter = m_RoomGetUpList.begin(); iter != m_RoomGetUpList.end(); ++iter)

  00249	83 c3 04	 add	 ebx, 4
$LN1472@ClearAllIn:
  0024c	3b 9e c8 00 00
	00		 cmp	 ebx, DWORD PTR [esi+200]
  00252	75 d9		 jne	 SHORT $LL606@ClearAllIn

; 704  : 	m_RoomGetUpList.clear();

  00254	8b 86 c8 00 00
	00		 mov	 eax, DWORD PTR [esi+200]
  0025a	8b 8e c4 00 00
	00		 mov	 ecx, DWORD PTR [esi+196]
  00260	50		 push	 eax
  00261	51		 push	 ecx
  00262	8d 45 fc	 lea	 eax, DWORD PTR $T536531[ebp]
  00265	50		 push	 eax
  00266	8d 8e c4 00 00
	00		 lea	 ecx, DWORD PTR [esi+196]
  0026c	e8 00 00 00 00	 call	 ?erase@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@0@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::erase

; 705  : 	for(RoomOptionInfoList::iterator iter = m_RoomKOList.begin(); iter != m_RoomKOList.end(); ++iter)

  00271	8b 9e d4 00 00
	00		 mov	 ebx, DWORD PTR [esi+212]
  00277	eb 1f		 jmp	 SHORT $LN1473@ClearAllIn
$LL665@ClearAllIn:

; 706  : 		SAFEDELETE( *iter );

  00279	8b 03		 mov	 eax, DWORD PTR [ebx]
  0027b	89 45 fc	 mov	 DWORD PTR tv4107[ebp], eax
  0027e	85 c0		 test	 eax, eax
  00280	74 13		 je	 SHORT $LN51@ClearAllIn
  00282	8b c8		 mov	 ecx, eax
  00284	e8 00 00 00 00	 call	 ??1RoomOptionInfo@@QAE@XZ
  00289	ff 75 fc	 push	 DWORD PTR tv4107[ebp]
  0028c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00291	83 23 00	 and	 DWORD PTR [ebx], 0
  00294	59		 pop	 ecx
$LN51@ClearAllIn:

; 705  : 	for(RoomOptionInfoList::iterator iter = m_RoomKOList.begin(); iter != m_RoomKOList.end(); ++iter)

  00295	83 c3 04	 add	 ebx, 4
$LN1473@ClearAllIn:
  00298	3b 9e d8 00 00
	00		 cmp	 ebx, DWORD PTR [esi+216]
  0029e	75 d9		 jne	 SHORT $LL665@ClearAllIn

; 707  : 	m_RoomKOList.clear();

  002a0	8b 86 d8 00 00
	00		 mov	 eax, DWORD PTR [esi+216]
  002a6	8b 8e d4 00 00
	00		 mov	 ecx, DWORD PTR [esi+212]
  002ac	50		 push	 eax
  002ad	51		 push	 ecx
  002ae	8d 45 fc	 lea	 eax, DWORD PTR $T536711[ebp]
  002b1	50		 push	 eax
  002b2	8d 8e d4 00 00
	00		 lea	 ecx, DWORD PTR [esi+212]
  002b8	e8 00 00 00 00	 call	 ?erase@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@0@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::erase

; 708  : 	for(RoomOptionInfoList::iterator iter = m_RoomKOEffectList.begin(); iter != m_RoomKOEffectList.end(); ++iter)

  002bd	8b 9e e4 00 00
	00		 mov	 ebx, DWORD PTR [esi+228]
  002c3	eb 1f		 jmp	 SHORT $LN1474@ClearAllIn
$LL724@ClearAllIn:

; 709  : 		SAFEDELETE( *iter );

  002c5	8b 03		 mov	 eax, DWORD PTR [ebx]
  002c7	89 45 fc	 mov	 DWORD PTR tv4125[ebp], eax
  002ca	85 c0		 test	 eax, eax
  002cc	74 13		 je	 SHORT $LN47@ClearAllIn
  002ce	8b c8		 mov	 ecx, eax
  002d0	e8 00 00 00 00	 call	 ??1RoomOptionInfo@@QAE@XZ
  002d5	ff 75 fc	 push	 DWORD PTR tv4125[ebp]
  002d8	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  002dd	83 23 00	 and	 DWORD PTR [ebx], 0
  002e0	59		 pop	 ecx
$LN47@ClearAllIn:

; 708  : 	for(RoomOptionInfoList::iterator iter = m_RoomKOEffectList.begin(); iter != m_RoomKOEffectList.end(); ++iter)

  002e1	83 c3 04	 add	 ebx, 4
$LN1474@ClearAllIn:
  002e4	3b 9e e8 00 00
	00		 cmp	 ebx, DWORD PTR [esi+232]
  002ea	75 d9		 jne	 SHORT $LL724@ClearAllIn

; 710  : 	m_RoomKOEffectList.clear();

  002ec	8b 86 e8 00 00
	00		 mov	 eax, DWORD PTR [esi+232]
  002f2	8b 8e e4 00 00
	00		 mov	 ecx, DWORD PTR [esi+228]
  002f8	50		 push	 eax
  002f9	51		 push	 ecx
  002fa	8d 45 fc	 lea	 eax, DWORD PTR $T536892[ebp]
  002fd	50		 push	 eax
  002fe	8d 8e e4 00 00
	00		 lea	 ecx, DWORD PTR [esi+228]
  00304	e8 00 00 00 00	 call	 ?erase@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@0@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::erase

; 711  : 	for(RoomOptionInfoList::iterator iter = m_RoomRedBlowList.begin(); iter != m_RoomRedBlowList.end(); ++iter)

  00309	8b 9e f4 00 00
	00		 mov	 ebx, DWORD PTR [esi+244]
  0030f	eb 1f		 jmp	 SHORT $LN1475@ClearAllIn
$LL783@ClearAllIn:

; 712  : 		SAFEDELETE( *iter );

  00311	8b 03		 mov	 eax, DWORD PTR [ebx]
  00313	89 45 fc	 mov	 DWORD PTR tv4143[ebp], eax
  00316	85 c0		 test	 eax, eax
  00318	74 13		 je	 SHORT $LN43@ClearAllIn
  0031a	8b c8		 mov	 ecx, eax
  0031c	e8 00 00 00 00	 call	 ??1RoomOptionInfo@@QAE@XZ
  00321	ff 75 fc	 push	 DWORD PTR tv4143[ebp]
  00324	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00329	83 23 00	 and	 DWORD PTR [ebx], 0
  0032c	59		 pop	 ecx
$LN43@ClearAllIn:

; 711  : 	for(RoomOptionInfoList::iterator iter = m_RoomRedBlowList.begin(); iter != m_RoomRedBlowList.end(); ++iter)

  0032d	83 c3 04	 add	 ebx, 4
$LN1475@ClearAllIn:
  00330	3b 9e f8 00 00
	00		 cmp	 ebx, DWORD PTR [esi+248]
  00336	75 d9		 jne	 SHORT $LL783@ClearAllIn

; 713  : 	m_RoomRedBlowList.clear();

  00338	8b 86 f8 00 00
	00		 mov	 eax, DWORD PTR [esi+248]
  0033e	8b 8e f4 00 00
	00		 mov	 ecx, DWORD PTR [esi+244]
  00344	50		 push	 eax
  00345	51		 push	 ecx
  00346	8d 45 fc	 lea	 eax, DWORD PTR $T537073[ebp]
  00349	50		 push	 eax
  0034a	8d 8e f4 00 00
	00		 lea	 ecx, DWORD PTR [esi+244]
  00350	e8 00 00 00 00	 call	 ?erase@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@0@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::erase

; 714  : 	for(RoomOptionInfoList::iterator iter = m_RoomBlueBlowList.begin(); iter != m_RoomBlueBlowList.end(); ++iter)

  00355	8b 9e 04 01 00
	00		 mov	 ebx, DWORD PTR [esi+260]
  0035b	eb 1f		 jmp	 SHORT $LN1476@ClearAllIn
$LL842@ClearAllIn:

; 715  : 		SAFEDELETE( *iter );

  0035d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0035f	89 45 fc	 mov	 DWORD PTR tv4161[ebp], eax
  00362	85 c0		 test	 eax, eax
  00364	74 13		 je	 SHORT $LN39@ClearAllIn
  00366	8b c8		 mov	 ecx, eax
  00368	e8 00 00 00 00	 call	 ??1RoomOptionInfo@@QAE@XZ
  0036d	ff 75 fc	 push	 DWORD PTR tv4161[ebp]
  00370	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00375	83 23 00	 and	 DWORD PTR [ebx], 0
  00378	59		 pop	 ecx
$LN39@ClearAllIn:

; 714  : 	for(RoomOptionInfoList::iterator iter = m_RoomBlueBlowList.begin(); iter != m_RoomBlueBlowList.end(); ++iter)

  00379	83 c3 04	 add	 ebx, 4
$LN1476@ClearAllIn:
  0037c	3b 9e 08 01 00
	00		 cmp	 ebx, DWORD PTR [esi+264]
  00382	75 d9		 jne	 SHORT $LL842@ClearAllIn

; 716  : 	m_RoomBlueBlowList.clear();

  00384	8b 86 08 01 00
	00		 mov	 eax, DWORD PTR [esi+264]
  0038a	8b 8e 04 01 00
	00		 mov	 ecx, DWORD PTR [esi+260]
  00390	50		 push	 eax
  00391	51		 push	 ecx
  00392	8d 45 fc	 lea	 eax, DWORD PTR $T537254[ebp]
  00395	50		 push	 eax
  00396	8d 8e 04 01 00
	00		 lea	 ecx, DWORD PTR [esi+260]
  0039c	e8 00 00 00 00	 call	 ?erase@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@0@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::erase

; 717  : 	for(RoomOptionInfoList::iterator iter = m_RoomRedMoveSpeedList.begin(); iter != m_RoomRedMoveSpeedList.end(); ++iter)

  003a1	8b 9e 14 01 00
	00		 mov	 ebx, DWORD PTR [esi+276]
  003a7	eb 1f		 jmp	 SHORT $LN1477@ClearAllIn
$LL901@ClearAllIn:

; 718  : 		SAFEDELETE( *iter );

  003a9	8b 03		 mov	 eax, DWORD PTR [ebx]
  003ab	89 45 fc	 mov	 DWORD PTR tv4179[ebp], eax
  003ae	85 c0		 test	 eax, eax
  003b0	74 13		 je	 SHORT $LN35@ClearAllIn
  003b2	8b c8		 mov	 ecx, eax
  003b4	e8 00 00 00 00	 call	 ??1RoomOptionInfo@@QAE@XZ
  003b9	ff 75 fc	 push	 DWORD PTR tv4179[ebp]
  003bc	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  003c1	83 23 00	 and	 DWORD PTR [ebx], 0
  003c4	59		 pop	 ecx
$LN35@ClearAllIn:

; 717  : 	for(RoomOptionInfoList::iterator iter = m_RoomRedMoveSpeedList.begin(); iter != m_RoomRedMoveSpeedList.end(); ++iter)

  003c5	83 c3 04	 add	 ebx, 4
$LN1477@ClearAllIn:
  003c8	3b 9e 18 01 00
	00		 cmp	 ebx, DWORD PTR [esi+280]
  003ce	75 d9		 jne	 SHORT $LL901@ClearAllIn

; 719  : 	m_RoomRedMoveSpeedList.clear();

  003d0	8b 86 18 01 00
	00		 mov	 eax, DWORD PTR [esi+280]
  003d6	8b 8e 14 01 00
	00		 mov	 ecx, DWORD PTR [esi+276]
  003dc	50		 push	 eax
  003dd	51		 push	 ecx
  003de	8d 45 fc	 lea	 eax, DWORD PTR $T537436[ebp]
  003e1	50		 push	 eax
  003e2	8d 8e 14 01 00
	00		 lea	 ecx, DWORD PTR [esi+276]
  003e8	e8 00 00 00 00	 call	 ?erase@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@0@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::erase

; 720  : 	for(RoomOptionInfoList::iterator iter = m_RoomBlueMoveSpeedList.begin(); iter != m_RoomBlueMoveSpeedList.end(); ++iter)

  003ed	8b 9e 24 01 00
	00		 mov	 ebx, DWORD PTR [esi+292]
  003f3	eb 1f		 jmp	 SHORT $LN1478@ClearAllIn
$LL960@ClearAllIn:

; 721  : 		SAFEDELETE( *iter );

  003f5	8b 03		 mov	 eax, DWORD PTR [ebx]
  003f7	89 45 fc	 mov	 DWORD PTR tv4197[ebp], eax
  003fa	85 c0		 test	 eax, eax
  003fc	74 13		 je	 SHORT $LN31@ClearAllIn
  003fe	8b c8		 mov	 ecx, eax
  00400	e8 00 00 00 00	 call	 ??1RoomOptionInfo@@QAE@XZ
  00405	ff 75 fc	 push	 DWORD PTR tv4197[ebp]
  00408	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0040d	83 23 00	 and	 DWORD PTR [ebx], 0
  00410	59		 pop	 ecx
$LN31@ClearAllIn:

; 720  : 	for(RoomOptionInfoList::iterator iter = m_RoomBlueMoveSpeedList.begin(); iter != m_RoomBlueMoveSpeedList.end(); ++iter)

  00411	83 c3 04	 add	 ebx, 4
$LN1478@ClearAllIn:
  00414	3b 9e 28 01 00
	00		 cmp	 ebx, DWORD PTR [esi+296]
  0041a	75 d9		 jne	 SHORT $LL960@ClearAllIn

; 722  : 	m_RoomBlueMoveSpeedList.clear();

  0041c	8b 86 28 01 00
	00		 mov	 eax, DWORD PTR [esi+296]
  00422	8b 8e 24 01 00
	00		 mov	 ecx, DWORD PTR [esi+292]
  00428	50		 push	 eax
  00429	51		 push	 ecx
  0042a	8d 45 fc	 lea	 eax, DWORD PTR $T537625[ebp]
  0042d	50		 push	 eax
  0042e	8d 8e 24 01 00
	00		 lea	 ecx, DWORD PTR [esi+292]
  00434	e8 00 00 00 00	 call	 ?erase@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@0@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::erase

; 723  : 	for(RoomOptionInfoList::iterator iter = m_RoomRedEquipList.begin(); iter != m_RoomRedEquipList.end(); ++iter)

  00439	8b 9e 34 01 00
	00		 mov	 ebx, DWORD PTR [esi+308]
  0043f	eb 1f		 jmp	 SHORT $LN1479@ClearAllIn
$LL1019@ClearAllIn:

; 724  : 		SAFEDELETE( *iter );

  00441	8b 03		 mov	 eax, DWORD PTR [ebx]
  00443	89 45 fc	 mov	 DWORD PTR tv4215[ebp], eax
  00446	85 c0		 test	 eax, eax
  00448	74 13		 je	 SHORT $LN27@ClearAllIn
  0044a	8b c8		 mov	 ecx, eax
  0044c	e8 00 00 00 00	 call	 ??1RoomOptionInfo@@QAE@XZ
  00451	ff 75 fc	 push	 DWORD PTR tv4215[ebp]
  00454	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00459	83 23 00	 and	 DWORD PTR [ebx], 0
  0045c	59		 pop	 ecx
$LN27@ClearAllIn:

; 723  : 	for(RoomOptionInfoList::iterator iter = m_RoomRedEquipList.begin(); iter != m_RoomRedEquipList.end(); ++iter)

  0045d	83 c3 04	 add	 ebx, 4
$LN1479@ClearAllIn:
  00460	3b 9e 38 01 00
	00		 cmp	 ebx, DWORD PTR [esi+312]
  00466	75 d9		 jne	 SHORT $LL1019@ClearAllIn

; 725  : 	m_RoomRedEquipList.clear();

  00468	8b 86 38 01 00
	00		 mov	 eax, DWORD PTR [esi+312]
  0046e	8b 8e 34 01 00
	00		 mov	 ecx, DWORD PTR [esi+308]
  00474	50		 push	 eax
  00475	51		 push	 ecx
  00476	8d 45 fc	 lea	 eax, DWORD PTR $T537797[ebp]
  00479	50		 push	 eax
  0047a	8d 8e 34 01 00
	00		 lea	 ecx, DWORD PTR [esi+308]
  00480	e8 00 00 00 00	 call	 ?erase@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@0@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::erase

; 726  : 	for(RoomOptionInfoList::iterator iter = m_RoomBlueEquipList.begin(); iter != m_RoomBlueEquipList.end(); ++iter)

  00485	8b 9e 44 01 00
	00		 mov	 ebx, DWORD PTR [esi+324]
  0048b	eb 1f		 jmp	 SHORT $LN1480@ClearAllIn
$LL1078@ClearAllIn:

; 727  : 		SAFEDELETE( *iter );

  0048d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0048f	89 45 fc	 mov	 DWORD PTR tv4233[ebp], eax
  00492	85 c0		 test	 eax, eax
  00494	74 13		 je	 SHORT $LN23@ClearAllIn
  00496	8b c8		 mov	 ecx, eax
  00498	e8 00 00 00 00	 call	 ??1RoomOptionInfo@@QAE@XZ
  0049d	ff 75 fc	 push	 DWORD PTR tv4233[ebp]
  004a0	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  004a5	83 23 00	 and	 DWORD PTR [ebx], 0
  004a8	59		 pop	 ecx
$LN23@ClearAllIn:

; 726  : 	for(RoomOptionInfoList::iterator iter = m_RoomBlueEquipList.begin(); iter != m_RoomBlueEquipList.end(); ++iter)

  004a9	83 c3 04	 add	 ebx, 4
$LN1480@ClearAllIn:
  004ac	3b 9e 48 01 00
	00		 cmp	 ebx, DWORD PTR [esi+328]
  004b2	75 d9		 jne	 SHORT $LL1078@ClearAllIn

; 728  : 	m_RoomBlueEquipList.clear();

  004b4	8b 86 48 01 00
	00		 mov	 eax, DWORD PTR [esi+328]
  004ba	8b 8e 44 01 00
	00		 mov	 ecx, DWORD PTR [esi+324]
  004c0	50		 push	 eax
  004c1	51		 push	 ecx
  004c2	8d 45 fc	 lea	 eax, DWORD PTR $T537978[ebp]
  004c5	50		 push	 eax
  004c6	8d 8e 44 01 00
	00		 lea	 ecx, DWORD PTR [esi+324]
  004cc	e8 00 00 00 00	 call	 ?erase@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@0@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::erase

; 729  : 	for(RoomOptionInfoList::iterator iter = m_RoomRoundTypeList.begin(); iter != m_RoomRoundTypeList.end(); ++iter)

  004d1	8b 9e 54 01 00
	00		 mov	 ebx, DWORD PTR [esi+340]
  004d7	eb 1f		 jmp	 SHORT $LN1481@ClearAllIn
$LL1137@ClearAllIn:

; 730  : 		SAFEDELETE( *iter );

  004d9	8b 03		 mov	 eax, DWORD PTR [ebx]
  004db	89 45 fc	 mov	 DWORD PTR tv4251[ebp], eax
  004de	85 c0		 test	 eax, eax
  004e0	74 13		 je	 SHORT $LN19@ClearAllIn
  004e2	8b c8		 mov	 ecx, eax
  004e4	e8 00 00 00 00	 call	 ??1RoomOptionInfo@@QAE@XZ
  004e9	ff 75 fc	 push	 DWORD PTR tv4251[ebp]
  004ec	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  004f1	83 23 00	 and	 DWORD PTR [ebx], 0
  004f4	59		 pop	 ecx
$LN19@ClearAllIn:

; 729  : 	for(RoomOptionInfoList::iterator iter = m_RoomRoundTypeList.begin(); iter != m_RoomRoundTypeList.end(); ++iter)

  004f5	83 c3 04	 add	 ebx, 4
$LN1481@ClearAllIn:
  004f8	3b 9e 58 01 00
	00		 cmp	 ebx, DWORD PTR [esi+344]
  004fe	75 d9		 jne	 SHORT $LL1137@ClearAllIn

; 731  : 	m_RoomRoundTypeList.clear();

  00500	8b 86 58 01 00
	00		 mov	 eax, DWORD PTR [esi+344]
  00506	8b 8e 54 01 00
	00		 mov	 ecx, DWORD PTR [esi+340]
  0050c	50		 push	 eax
  0050d	51		 push	 ecx
  0050e	8d 45 fc	 lea	 eax, DWORD PTR $T538159[ebp]
  00511	50		 push	 eax
  00512	8d 8e 54 01 00
	00		 lea	 ecx, DWORD PTR [esi+340]
  00518	e8 00 00 00 00	 call	 ?erase@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@0@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::erase

; 732  : 	for(RoomOptionInfoList::iterator iter = m_RoomRoundTimeTypeList.begin(); iter != m_RoomRoundTimeTypeList.end(); ++iter)

  0051d	8b 9e 64 01 00
	00		 mov	 ebx, DWORD PTR [esi+356]
  00523	eb 1f		 jmp	 SHORT $LN1482@ClearAllIn
$LL1196@ClearAllIn:

; 733  : 		SAFEDELETE( *iter );

  00525	8b 03		 mov	 eax, DWORD PTR [ebx]
  00527	89 45 fc	 mov	 DWORD PTR tv4269[ebp], eax
  0052a	85 c0		 test	 eax, eax
  0052c	74 13		 je	 SHORT $LN15@ClearAllIn
  0052e	8b c8		 mov	 ecx, eax
  00530	e8 00 00 00 00	 call	 ??1RoomOptionInfo@@QAE@XZ
  00535	ff 75 fc	 push	 DWORD PTR tv4269[ebp]
  00538	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0053d	83 23 00	 and	 DWORD PTR [ebx], 0
  00540	59		 pop	 ecx
$LN15@ClearAllIn:

; 732  : 	for(RoomOptionInfoList::iterator iter = m_RoomRoundTimeTypeList.begin(); iter != m_RoomRoundTimeTypeList.end(); ++iter)

  00541	83 c3 04	 add	 ebx, 4
$LN1482@ClearAllIn:
  00544	3b 9e 68 01 00
	00		 cmp	 ebx, DWORD PTR [esi+360]
  0054a	75 d9		 jne	 SHORT $LL1196@ClearAllIn

; 734  : 	m_RoomRoundTimeTypeList.clear();

  0054c	8b 86 68 01 00
	00		 mov	 eax, DWORD PTR [esi+360]
  00552	8b 8e 64 01 00
	00		 mov	 ecx, DWORD PTR [esi+356]
  00558	50		 push	 eax
  00559	51		 push	 ecx
  0055a	8d 45 fc	 lea	 eax, DWORD PTR $T538340[ebp]
  0055d	50		 push	 eax
  0055e	8d 8e 64 01 00
	00		 lea	 ecx, DWORD PTR [esi+356]
  00564	e8 00 00 00 00	 call	 ?erase@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@0@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::erase

; 735  : 	for(RoomOptionInfoList::iterator iter = m_RoomGrowthUseList.begin(); iter != m_RoomGrowthUseList.end(); ++iter)

  00569	8b 9e 74 01 00
	00		 mov	 ebx, DWORD PTR [esi+372]
  0056f	eb 1f		 jmp	 SHORT $LN1483@ClearAllIn
$LL1255@ClearAllIn:

; 736  : 		SAFEDELETE( *iter );

  00571	8b 03		 mov	 eax, DWORD PTR [ebx]
  00573	89 45 fc	 mov	 DWORD PTR tv4287[ebp], eax
  00576	85 c0		 test	 eax, eax
  00578	74 13		 je	 SHORT $LN11@ClearAllIn
  0057a	8b c8		 mov	 ecx, eax
  0057c	e8 00 00 00 00	 call	 ??1RoomOptionInfo@@QAE@XZ
  00581	ff 75 fc	 push	 DWORD PTR tv4287[ebp]
  00584	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00589	83 23 00	 and	 DWORD PTR [ebx], 0
  0058c	59		 pop	 ecx
$LN11@ClearAllIn:

; 735  : 	for(RoomOptionInfoList::iterator iter = m_RoomGrowthUseList.begin(); iter != m_RoomGrowthUseList.end(); ++iter)

  0058d	83 c3 04	 add	 ebx, 4
$LN1483@ClearAllIn:
  00590	3b 9e 78 01 00
	00		 cmp	 ebx, DWORD PTR [esi+376]
  00596	75 d9		 jne	 SHORT $LL1255@ClearAllIn

; 737  : 	m_RoomGrowthUseList.clear();

  00598	8b 86 78 01 00
	00		 mov	 eax, DWORD PTR [esi+376]
  0059e	8b 8e 74 01 00
	00		 mov	 ecx, DWORD PTR [esi+372]
  005a4	50		 push	 eax
  005a5	51		 push	 ecx
  005a6	8d 45 fc	 lea	 eax, DWORD PTR $T538522[ebp]
  005a9	50		 push	 eax
  005aa	8d 8e 74 01 00
	00		 lea	 ecx, DWORD PTR [esi+372]
  005b0	e8 00 00 00 00	 call	 ?erase@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@0@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::erase

; 738  : 	for(RoomOptionInfoList::iterator iter = m_RoomExtraItemUseList.begin(); iter != m_RoomExtraItemUseList.end(); ++iter)

  005b5	8b 9e 84 01 00
	00		 mov	 ebx, DWORD PTR [esi+388]
  005bb	eb 1f		 jmp	 SHORT $LN1484@ClearAllIn
$LL1314@ClearAllIn:

; 739  : 		SAFEDELETE( *iter );

  005bd	8b 03		 mov	 eax, DWORD PTR [ebx]
  005bf	89 45 fc	 mov	 DWORD PTR tv4305[ebp], eax
  005c2	85 c0		 test	 eax, eax
  005c4	74 13		 je	 SHORT $LN7@ClearAllIn
  005c6	8b c8		 mov	 ecx, eax
  005c8	e8 00 00 00 00	 call	 ??1RoomOptionInfo@@QAE@XZ
  005cd	ff 75 fc	 push	 DWORD PTR tv4305[ebp]
  005d0	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  005d5	83 23 00	 and	 DWORD PTR [ebx], 0
  005d8	59		 pop	 ecx
$LN7@ClearAllIn:

; 738  : 	for(RoomOptionInfoList::iterator iter = m_RoomExtraItemUseList.begin(); iter != m_RoomExtraItemUseList.end(); ++iter)

  005d9	83 c3 04	 add	 ebx, 4
$LN1484@ClearAllIn:
  005dc	3b 9e 88 01 00
	00		 cmp	 ebx, DWORD PTR [esi+392]
  005e2	75 d9		 jne	 SHORT $LL1314@ClearAllIn

; 740  : 	m_RoomExtraItemUseList.clear();

  005e4	8b 86 88 01 00
	00		 mov	 eax, DWORD PTR [esi+392]
  005ea	8b 8e 84 01 00
	00		 mov	 ecx, DWORD PTR [esi+388]
  005f0	50		 push	 eax
  005f1	51		 push	 ecx
  005f2	8d 45 fc	 lea	 eax, DWORD PTR $T538702[ebp]
  005f5	50		 push	 eax
  005f6	8d 8e 84 01 00
	00		 lea	 ecx, DWORD PTR [esi+388]
  005fc	e8 00 00 00 00	 call	 ?erase@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@@2@0@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::erase

; 741  : 
; 742  : 	for(PreSetInfoList::iterator iter = m_PreSetList.begin(); iter != m_PreSetList.end(); ++iter)

  00601	8b be 94 01 00
	00		 mov	 edi, DWORD PTR [esi+404]
  00607	eb 1d		 jmp	 SHORT $LN1485@ClearAllIn
$LL1373@ClearAllIn:

; 743  : 		SAFEDELETE( *iter );

  00609	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0060b	89 4d fc	 mov	 DWORD PTR tv4323[ebp], ecx
  0060e	85 c9		 test	 ecx, ecx
  00610	74 11		 je	 SHORT $LN3@ClearAllIn
  00612	e8 00 00 00 00	 call	 ??1PreSetInfo@@QAE@XZ
  00617	ff 75 fc	 push	 DWORD PTR tv4323[ebp]
  0061a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0061f	83 27 00	 and	 DWORD PTR [edi], 0
  00622	59		 pop	 ecx
$LN3@ClearAllIn:

; 741  : 
; 742  : 	for(PreSetInfoList::iterator iter = m_PreSetList.begin(); iter != m_PreSetList.end(); ++iter)

  00623	83 c7 04	 add	 edi, 4
$LN1485@ClearAllIn:
  00626	3b be 98 01 00
	00		 cmp	 edi, DWORD PTR [esi+408]
  0062c	75 db		 jne	 SHORT $LL1373@ClearAllIn

; 744  : 	m_PreSetList.clear();

  0062e	8b 86 98 01 00
	00		 mov	 eax, DWORD PTR [esi+408]
  00634	8b 8e 94 01 00
	00		 mov	 ecx, DWORD PTR [esi+404]
  0063a	50		 push	 eax
  0063b	51		 push	 ecx
  0063c	8d 45 fc	 lea	 eax, DWORD PTR $T538883[ebp]
  0063f	50		 push	 eax
  00640	8d 8e 94 01 00
	00		 lea	 ecx, DWORD PTR [esi+404]
  00646	e8 00 00 00 00	 call	 ?erase@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@@2@0@Z ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::erase
  0064b	5f		 pop	 edi
  0064c	5e		 pop	 esi
  0064d	5b		 pop	 ebx

; 745  : }

  0064e	c9		 leave
  0064f	c3		 ret	 0
?ClearAllInfo@ioRoomOptionManager@@IAEXXZ ENDP		; ioRoomOptionManager::ClearAllInfo
_TEXT	ENDS
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  00006	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 27		 jae	 SHORT $LN4@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 21		 ja	 SHORT $LN4@push_back

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 02	 sar	 edi, 2

; 980  : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN3@push_back

; 981  : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int> >::_Reserve
$LN3@push_back:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0002a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002d	85 c0		 test	 eax, eax
  0002f	74 20		 je	 SHORT $LN39@push_back
  00031	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00033	8b 0c b9	 mov	 ecx, DWORD PTR [ecx+edi*4]

; 986  : 			++this->_Mylast;
; 987  : 			}
; 988  : 		else

  00036	eb 17		 jmp	 SHORT $LN46@push_back
$LN4@push_back:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  00038	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0003b	75 09		 jne	 SHORT $LN1@push_back

; 991  : 				_Reserve(1);

  0003d	6a 01		 push	 1
  0003f	8b ce		 mov	 ecx, esi
  00041	e8 00 00 00 00	 call	 ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int> >::_Reserve
$LN1@push_back:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  00046	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00049	85 c0		 test	 eax, eax
  0004b	74 04		 je	 SHORT $LN39@push_back
  0004d	8b 0f		 mov	 ecx, DWORD PTR [edi]
$LN46@push_back:
  0004f	89 08		 mov	 DWORD PTR [eax], ecx
$LN39@push_back:

; 996  : 			++this->_Mylast;

  00051	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXABQAURoomOptionInfo@@@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::push_back
; Function compile flags: /Ogsp
;	COMDAT ?push_back@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXABQAURoomOptionInfo@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXABQAURoomOptionInfo@@@Z PROC ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  00006	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 27		 jae	 SHORT $LN4@push_back@2
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 21		 ja	 SHORT $LN4@push_back@2

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 02	 sar	 edi, 2

; 980  : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN3@push_back@2

; 981  : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXI@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Reserve
$LN3@push_back@2:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0002a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002d	85 c0		 test	 eax, eax
  0002f	74 20		 je	 SHORT $LN39@push_back@2
  00031	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00033	8b 0c b9	 mov	 ecx, DWORD PTR [ecx+edi*4]

; 986  : 			++this->_Mylast;
; 987  : 			}
; 988  : 		else

  00036	eb 17		 jmp	 SHORT $LN46@push_back@2
$LN4@push_back@2:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  00038	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0003b	75 09		 jne	 SHORT $LN1@push_back@2

; 991  : 				_Reserve(1);

  0003d	6a 01		 push	 1
  0003f	8b ce		 mov	 ecx, esi
  00041	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXI@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Reserve
$LN1@push_back@2:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  00046	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00049	85 c0		 test	 eax, eax
  0004b	74 04		 je	 SHORT $LN39@push_back@2
  0004d	8b 0f		 mov	 ecx, DWORD PTR [edi]
$LN46@push_back@2:
  0004f	89 08		 mov	 DWORD PTR [eax], ecx
$LN39@push_back@2:

; 996  : 			++this->_Mylast;

  00051	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
?push_back@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXABQAURoomOptionInfo@@@Z ENDP ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAEXABQAUPreSetInfo@@@Z ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::push_back
; Function compile flags: /Ogsp
;	COMDAT ?push_back@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAEXABQAUPreSetInfo@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAEXABQAUPreSetInfo@@@Z PROC ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  00006	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 27		 jae	 SHORT $LN4@push_back@3
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 21		 ja	 SHORT $LN4@push_back@3

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 02	 sar	 edi, 2

; 980  : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN3@push_back@3

; 981  : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IAEXI@Z ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Reserve
$LN3@push_back@3:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0002a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002d	85 c0		 test	 eax, eax
  0002f	74 20		 je	 SHORT $LN39@push_back@3
  00031	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00033	8b 0c b9	 mov	 ecx, DWORD PTR [ecx+edi*4]

; 986  : 			++this->_Mylast;
; 987  : 			}
; 988  : 		else

  00036	eb 17		 jmp	 SHORT $LN46@push_back@3
$LN4@push_back@3:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  00038	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0003b	75 09		 jne	 SHORT $LN1@push_back@3

; 991  : 				_Reserve(1);

  0003d	6a 01		 push	 1
  0003f	8b ce		 mov	 ecx, esi
  00041	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IAEXI@Z ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Reserve
$LN1@push_back@3:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  00046	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00049	85 c0		 test	 eax, eax
  0004b	74 04		 je	 SHORT $LN39@push_back@3
  0004d	8b 0f		 mov	 ecx, DWORD PTR [edi]
$LN46@push_back@3:
  0004f	89 08		 mov	 DWORD PTR [eax], ecx
$LN39@push_back@3:

; 996  : 			++this->_Mylast;

  00051	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
?push_back@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAEXABQAUPreSetInfo@@@Z ENDP ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::push_back
_TEXT	ENDS
PUBLIC	??_7ioRoomOptionManager@@6B@			; ioRoomOptionManager::`vftable'
PUBLIC	??0ioRoomOptionManager@@QAE@XZ			; ioRoomOptionManager::ioRoomOptionManager
PUBLIC	??_R4ioRoomOptionManager@@6B@			; ioRoomOptionManager::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVioRoomOptionManager@@@8			; ioRoomOptionManager `RTTI Type Descriptor'
PUBLIC	??_R3ioRoomOptionManager@@8			; ioRoomOptionManager::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioRoomOptionManager@@8			; ioRoomOptionManager::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ioRoomOptionManager@@8		; ioRoomOptionManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R13?0A@EA@?$Singleton@VioRoomOptionManager@@@@8 ; Singleton<ioRoomOptionManager>::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AV?$Singleton@VioRoomOptionManager@@@@@8	; Singleton<ioRoomOptionManager> `RTTI Type Descriptor'
PUBLIC	??_R3?$Singleton@VioRoomOptionManager@@@@8	; Singleton<ioRoomOptionManager>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$Singleton@VioRoomOptionManager@@@@8	; Singleton<ioRoomOptionManager>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$Singleton@VioRoomOptionManager@@@@8 ; Singleton<ioRoomOptionManager>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_EioRoomOptionManager@@UAEPAXI@Z:PROC		; ioRoomOptionManager::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$Singleton@VioRoomOptionManager@@@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
rdata$r	SEGMENT
??_R1A@?0A@EA@?$Singleton@VioRoomOptionManager@@@@8 DD FLAT:??_R0?AV?$Singleton@VioRoomOptionManager@@@@@8 ; Singleton<ioRoomOptionManager>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$Singleton@VioRoomOptionManager@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$Singleton@VioRoomOptionManager@@@@8
rdata$r	SEGMENT
??_R2?$Singleton@VioRoomOptionManager@@@@8 DD FLAT:??_R1A@?0A@EA@?$Singleton@VioRoomOptionManager@@@@8 ; Singleton<ioRoomOptionManager>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$Singleton@VioRoomOptionManager@@@@8
rdata$r	SEGMENT
??_R3?$Singleton@VioRoomOptionManager@@@@8 DD 00H	; Singleton<ioRoomOptionManager>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$Singleton@VioRoomOptionManager@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$Singleton@VioRoomOptionManager@@@@@8
_DATA	SEGMENT
??_R0?AV?$Singleton@VioRoomOptionManager@@@@@8 DD FLAT:??_7type_info@@6B@ ; Singleton<ioRoomOptionManager> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$Singleton@VioRoomOptionManager@@@@', 00H
_DATA	ENDS
;	COMDAT ??_R13?0A@EA@?$Singleton@VioRoomOptionManager@@@@8
rdata$r	SEGMENT
??_R13?0A@EA@?$Singleton@VioRoomOptionManager@@@@8 DD FLAT:??_R0?AV?$Singleton@VioRoomOptionManager@@@@@8 ; Singleton<ioRoomOptionManager>::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$Singleton@VioRoomOptionManager@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ioRoomOptionManager@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioRoomOptionManager@@8 DD FLAT:??_R0?AVioRoomOptionManager@@@8 ; ioRoomOptionManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioRoomOptionManager@@8
rdata$r	ENDS
;	COMDAT ??_R2ioRoomOptionManager@@8
rdata$r	SEGMENT
??_R2ioRoomOptionManager@@8 DD FLAT:??_R1A@?0A@EA@ioRoomOptionManager@@8 ; ioRoomOptionManager::`RTTI Base Class Array'
	DD	FLAT:??_R13?0A@EA@?$Singleton@VioRoomOptionManager@@@@8
rdata$r	ENDS
;	COMDAT ??_R3ioRoomOptionManager@@8
rdata$r	SEGMENT
??_R3ioRoomOptionManager@@8 DD 00H			; ioRoomOptionManager::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ioRoomOptionManager@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioRoomOptionManager@@@8
_DATA	SEGMENT
??_R0?AVioRoomOptionManager@@@8 DD FLAT:??_7type_info@@6B@ ; ioRoomOptionManager `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioRoomOptionManager@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ioRoomOptionManager@@6B@
rdata$r	SEGMENT
??_R4ioRoomOptionManager@@6B@ DD 00H			; ioRoomOptionManager::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVioRoomOptionManager@@@8
	DD	FLAT:??_R3ioRoomOptionManager@@8
rdata$r	ENDS
;	COMDAT ??_7ioRoomOptionManager@@6B@
CONST	SEGMENT
??_7ioRoomOptionManager@@6B@ DD FLAT:??_R4ioRoomOptionManager@@6B@ ; ioRoomOptionManager::`vftable'
	DD	FLAT:??_EioRoomOptionManager@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0ioRoomOptionManager@@QAE@XZ DD 019930522H
	DD	01cH
	DD	FLAT:__unwindtable$??0ioRoomOptionManager@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0ioRoomOptionManager@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$11
	DD	0bH
	DD	FLAT:__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$12
	DD	0cH
	DD	FLAT:__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$13
	DD	0dH
	DD	FLAT:__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$14
	DD	0eH
	DD	FLAT:__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$15
	DD	0fH
	DD	FLAT:__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$16
	DD	010H
	DD	FLAT:__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$17
	DD	011H
	DD	FLAT:__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$18
	DD	012H
	DD	FLAT:__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$19
	DD	013H
	DD	FLAT:__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$20
	DD	014H
	DD	FLAT:__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$21
	DD	015H
	DD	FLAT:__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$22
	DD	016H
	DD	FLAT:__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$23
	DD	017H
	DD	FLAT:__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$24
	DD	018H
	DD	FLAT:__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$25
	DD	019H
	DD	FLAT:__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$26
	DD	01aH
	DD	FLAT:__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$27
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioroomoptionmanager.cpp
xdata$x	ENDS
;	COMDAT ??0ioRoomOptionManager@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0ioRoomOptionManager@@QAE@XZ PROC			; ioRoomOptionManager::ioRoomOptionManager, COMDAT
; _this$ = ecx

; 12   : {

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0ioRoomOptionManager@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	8b c6		 mov	 eax, esi
  00013	a3 00 00 00 00	 mov	 DWORD PTR ?ms_Singleton@?$Singleton@VioRoomOptionManager@@@@1PAVioRoomOptionManager@@A, eax ; Singleton<ioRoomOptionManager>::ms_Singleton
  00018	33 c0		 xor	 eax, eax
  0001a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioRoomOptionManager@@6B@
  00020	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], eax
  00023	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00026	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00029	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0002c	89 46 14	 mov	 DWORD PTR [esi+20], eax
  0002f	89 46 18	 mov	 DWORD PTR [esi+24], eax
  00032	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  00035	89 46 24	 mov	 DWORD PTR [esi+36], eax
  00038	89 46 28	 mov	 DWORD PTR [esi+40], eax
  0003b	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  0003e	89 46 34	 mov	 DWORD PTR [esi+52], eax
  00041	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00044	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  00047	89 46 44	 mov	 DWORD PTR [esi+68], eax
  0004a	89 46 48	 mov	 DWORD PTR [esi+72], eax
  0004d	89 46 4c	 mov	 DWORD PTR [esi+76], eax
  00050	89 46 54	 mov	 DWORD PTR [esi+84], eax
  00053	89 46 58	 mov	 DWORD PTR [esi+88], eax
  00056	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  00059	89 46 64	 mov	 DWORD PTR [esi+100], eax
  0005c	89 46 68	 mov	 DWORD PTR [esi+104], eax
  0005f	89 46 6c	 mov	 DWORD PTR [esi+108], eax
  00062	89 46 74	 mov	 DWORD PTR [esi+116], eax
  00065	89 46 78	 mov	 DWORD PTR [esi+120], eax
  00068	89 46 7c	 mov	 DWORD PTR [esi+124], eax
  0006b	89 86 84 00 00
	00		 mov	 DWORD PTR [esi+132], eax
  00071	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  00077	89 86 8c 00 00
	00		 mov	 DWORD PTR [esi+140], eax
  0007d	89 86 94 00 00
	00		 mov	 DWORD PTR [esi+148], eax
  00083	89 86 98 00 00
	00		 mov	 DWORD PTR [esi+152], eax
  00089	89 86 9c 00 00
	00		 mov	 DWORD PTR [esi+156], eax
  0008f	89 86 a4 00 00
	00		 mov	 DWORD PTR [esi+164], eax
  00095	89 86 a8 00 00
	00		 mov	 DWORD PTR [esi+168], eax
  0009b	89 86 ac 00 00
	00		 mov	 DWORD PTR [esi+172], eax
  000a1	89 86 b4 00 00
	00		 mov	 DWORD PTR [esi+180], eax
  000a7	89 86 b8 00 00
	00		 mov	 DWORD PTR [esi+184], eax
  000ad	89 86 bc 00 00
	00		 mov	 DWORD PTR [esi+188], eax
  000b3	89 86 c4 00 00
	00		 mov	 DWORD PTR [esi+196], eax
  000b9	89 86 c8 00 00
	00		 mov	 DWORD PTR [esi+200], eax
  000bf	89 86 cc 00 00
	00		 mov	 DWORD PTR [esi+204], eax
  000c5	89 86 d4 00 00
	00		 mov	 DWORD PTR [esi+212], eax
  000cb	89 86 d8 00 00
	00		 mov	 DWORD PTR [esi+216], eax
  000d1	89 86 dc 00 00
	00		 mov	 DWORD PTR [esi+220], eax
  000d7	89 86 e4 00 00
	00		 mov	 DWORD PTR [esi+228], eax
  000dd	89 86 e8 00 00
	00		 mov	 DWORD PTR [esi+232], eax
  000e3	89 86 ec 00 00
	00		 mov	 DWORD PTR [esi+236], eax
  000e9	89 86 f4 00 00
	00		 mov	 DWORD PTR [esi+244], eax
  000ef	89 86 f8 00 00
	00		 mov	 DWORD PTR [esi+248], eax
  000f5	89 86 fc 00 00
	00		 mov	 DWORD PTR [esi+252], eax
  000fb	89 86 04 01 00
	00		 mov	 DWORD PTR [esi+260], eax
  00101	89 86 08 01 00
	00		 mov	 DWORD PTR [esi+264], eax
  00107	89 86 0c 01 00
	00		 mov	 DWORD PTR [esi+268], eax
  0010d	89 86 14 01 00
	00		 mov	 DWORD PTR [esi+276], eax
  00113	89 86 18 01 00
	00		 mov	 DWORD PTR [esi+280], eax
  00119	89 86 1c 01 00
	00		 mov	 DWORD PTR [esi+284], eax
  0011f	89 86 24 01 00
	00		 mov	 DWORD PTR [esi+292], eax
  00125	89 86 28 01 00
	00		 mov	 DWORD PTR [esi+296], eax
  0012b	89 86 2c 01 00
	00		 mov	 DWORD PTR [esi+300], eax
  00131	89 86 34 01 00
	00		 mov	 DWORD PTR [esi+308], eax
  00137	89 86 38 01 00
	00		 mov	 DWORD PTR [esi+312], eax
  0013d	89 86 3c 01 00
	00		 mov	 DWORD PTR [esi+316], eax
  00143	89 86 44 01 00
	00		 mov	 DWORD PTR [esi+324], eax
  00149	89 86 48 01 00
	00		 mov	 DWORD PTR [esi+328], eax
  0014f	89 86 4c 01 00
	00		 mov	 DWORD PTR [esi+332], eax
  00155	89 86 54 01 00
	00		 mov	 DWORD PTR [esi+340], eax
  0015b	89 86 58 01 00
	00		 mov	 DWORD PTR [esi+344], eax
  00161	89 86 5c 01 00
	00		 mov	 DWORD PTR [esi+348], eax
  00167	89 86 64 01 00
	00		 mov	 DWORD PTR [esi+356], eax
  0016d	89 86 68 01 00
	00		 mov	 DWORD PTR [esi+360], eax
  00173	89 86 6c 01 00
	00		 mov	 DWORD PTR [esi+364], eax
  00179	89 86 74 01 00
	00		 mov	 DWORD PTR [esi+372], eax
  0017f	89 86 78 01 00
	00		 mov	 DWORD PTR [esi+376], eax
  00185	89 86 7c 01 00
	00		 mov	 DWORD PTR [esi+380], eax
  0018b	89 86 84 01 00
	00		 mov	 DWORD PTR [esi+388], eax
  00191	89 86 88 01 00
	00		 mov	 DWORD PTR [esi+392], eax
  00197	89 86 8c 01 00
	00		 mov	 DWORD PTR [esi+396], eax
  0019d	89 86 94 01 00
	00		 mov	 DWORD PTR [esi+404], eax
  001a3	89 86 98 01 00
	00		 mov	 DWORD PTR [esi+408], eax
  001a9	89 86 9c 01 00
	00		 mov	 DWORD PTR [esi+412], eax
  001af	8d 8e a4 01 00
	00		 lea	 ecx, DWORD PTR [esi+420]
  001b5	c6 45 fc 1a	 mov	 BYTE PTR __$EHRec$[ebp+8], 26 ; 0000001aH
  001b9	e8 00 00 00 00	 call	 ??0PreSetInfo@@QAE@XZ	; PreSetInfo::PreSetInfo

; 13   : 	ClearAllInfo();

  001be	8b ce		 mov	 ecx, esi
  001c0	c6 45 fc 1b	 mov	 BYTE PTR __$EHRec$[ebp+8], 27 ; 0000001bH
  001c4	e8 00 00 00 00	 call	 ?ClearAllInfo@ioRoomOptionManager@@IAEXXZ ; ioRoomOptionManager::ClearAllInfo

; 14   : }

  001c9	8b c6		 mov	 eax, esi
  001cb	e8 00 00 00 00	 call	 __EH_epilog3
  001d0	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$Singleton@VioRoomOptionManager@@@@QAE@XZ ; Singleton<ioRoomOptionManager>::~Singleton<ioRoomOptionManager>
__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 04	 add	 ecx, 4
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$2:
  00016	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	83 c1 14	 add	 ecx, 20			; 00000014H
  0001c	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$3:
  00021	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 24	 add	 ecx, 36			; 00000024H
  00027	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$4:
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 34	 add	 ecx, 52			; 00000034H
  00032	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$5:
  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 44	 add	 ecx, 68			; 00000044H
  0003d	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$6:
  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 54	 add	 ecx, 84			; 00000054H
  00048	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$7:
  0004d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	83 c1 64	 add	 ecx, 100		; 00000064H
  00053	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$8:
  00058	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	83 c1 74	 add	 ecx, 116		; 00000074H
  0005e	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$9:
  00063	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  0006c	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$10:
  00071	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	81 c1 94 00 00
	00		 add	 ecx, 148		; 00000094H
  0007a	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$11:
  0007f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	81 c1 a4 00 00
	00		 add	 ecx, 164		; 000000a4H
  00088	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$12:
  0008d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  00096	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$13:
  0009b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009e	81 c1 c4 00 00
	00		 add	 ecx, 196		; 000000c4H
  000a4	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$14:
  000a9	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  000b2	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$15:
  000b7	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ba	81 c1 e4 00 00
	00		 add	 ecx, 228		; 000000e4H
  000c0	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$16:
  000c5	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	81 c1 f4 00 00
	00		 add	 ecx, 244		; 000000f4H
  000ce	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$17:
  000d3	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  000dc	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$18:
  000e1	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e4	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  000ea	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$19:
  000ef	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000f2	81 c1 24 01 00
	00		 add	 ecx, 292		; 00000124H
  000f8	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$20:
  000fd	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00100	81 c1 34 01 00
	00		 add	 ecx, 308		; 00000134H
  00106	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$21:
  0010b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	81 c1 44 01 00
	00		 add	 ecx, 324		; 00000144H
  00114	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$22:
  00119	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0011c	81 c1 54 01 00
	00		 add	 ecx, 340		; 00000154H
  00122	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$23:
  00127	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0012a	81 c1 64 01 00
	00		 add	 ecx, 356		; 00000164H
  00130	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$24:
  00135	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00138	81 c1 74 01 00
	00		 add	 ecx, 372		; 00000174H
  0013e	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$25:
  00143	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00146	81 c1 84 01 00
	00		 add	 ecx, 388		; 00000184H
  0014c	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$26:
  00151	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00154	81 c1 94 01 00
	00		 add	 ecx, 404		; 00000194H
  0015a	e9 00 00 00 00	 jmp	 ??1?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE@XZ ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::~vector<PreSetInfo *,std::allocator<PreSetInfo *> >
__unwindfunclet$??0ioRoomOptionManager@@QAE@XZ$27:
  0015f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00162	81 c1 a4 01 00
	00		 add	 ecx, 420		; 000001a4H
  00168	e9 00 00 00 00	 jmp	 ??1PreSetInfo@@QAE@XZ
__ehhandler$??0ioRoomOptionManager@@QAE@XZ:
  0016d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00171	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00174	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00177	33 c8		 xor	 ecx, eax
  00179	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ioRoomOptionManager@@QAE@XZ
  00183	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ioRoomOptionManager@@QAE@XZ ENDP			; ioRoomOptionManager::ioRoomOptionManager
PUBLIC	??1ioRoomOptionManager@@UAE@XZ			; ioRoomOptionManager::~ioRoomOptionManager
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\io3dengine\iosingleton.h
xdata$x	SEGMENT
__ehfuncinfo$??1ioRoomOptionManager@@UAE@XZ DD 019930522H
	DD	01cH
	DD	FLAT:__unwindtable$??1ioRoomOptionManager@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1ioRoomOptionManager@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$11
	DD	0bH
	DD	FLAT:__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$12
	DD	0cH
	DD	FLAT:__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$13
	DD	0dH
	DD	FLAT:__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$14
	DD	0eH
	DD	FLAT:__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$15
	DD	0fH
	DD	FLAT:__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$16
	DD	010H
	DD	FLAT:__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$17
	DD	011H
	DD	FLAT:__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$18
	DD	012H
	DD	FLAT:__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$19
	DD	013H
	DD	FLAT:__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$20
	DD	014H
	DD	FLAT:__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$21
	DD	015H
	DD	FLAT:__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$22
	DD	016H
	DD	FLAT:__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$23
	DD	017H
	DD	FLAT:__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$24
	DD	018H
	DD	FLAT:__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$25
	DD	019H
	DD	FLAT:__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$26
	DD	01aH
	DD	FLAT:__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$27
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioroomoptionmanager.cpp
xdata$x	ENDS
;	COMDAT ??1ioRoomOptionManager@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1ioRoomOptionManager@@UAE@XZ PROC			; ioRoomOptionManager::~ioRoomOptionManager, COMDAT
; _this$ = ecx

; 17   : {

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??1ioRoomOptionManager@@UAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioRoomOptionManager@@6B@
  00017	c7 45 fc 1b 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 27 ; 0000001bH

; 18   : 	ClearAllInfo();

  0001e	e8 00 00 00 00	 call	 ?ClearAllInfo@ioRoomOptionManager@@IAEXXZ ; ioRoomOptionManager::ClearAllInfo

; 19   : }

  00023	8d 8e a4 01 00
	00		 lea	 ecx, DWORD PTR [esi+420]
  00029	c6 45 fc 1a	 mov	 BYTE PTR __$EHRec$[ebp+8], 26 ; 0000001aH
  0002d	e8 00 00 00 00	 call	 ??1PreSetInfo@@QAE@XZ
  00032	8d 8e 94 01 00
	00		 lea	 ecx, DWORD PTR [esi+404]
  00038	c6 45 fc 19	 mov	 BYTE PTR __$EHRec$[ebp+8], 25 ; 00000019H
  0003c	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@IAEXXZ ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::_Tidy
  00041	8d 8e 84 01 00
	00		 lea	 ecx, DWORD PTR [esi+388]
  00047	c6 45 fc 18	 mov	 BYTE PTR __$EHRec$[ebp+8], 24 ; 00000018H
  0004b	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXXZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Tidy
  00050	8d 8e 74 01 00
	00		 lea	 ecx, DWORD PTR [esi+372]
  00056	c6 45 fc 17	 mov	 BYTE PTR __$EHRec$[ebp+8], 23 ; 00000017H
  0005a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXXZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Tidy
  0005f	8d 8e 64 01 00
	00		 lea	 ecx, DWORD PTR [esi+356]
  00065	c6 45 fc 16	 mov	 BYTE PTR __$EHRec$[ebp+8], 22 ; 00000016H
  00069	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXXZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Tidy
  0006e	8d 8e 54 01 00
	00		 lea	 ecx, DWORD PTR [esi+340]
  00074	c6 45 fc 15	 mov	 BYTE PTR __$EHRec$[ebp+8], 21 ; 00000015H
  00078	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXXZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Tidy
  0007d	8d 8e 44 01 00
	00		 lea	 ecx, DWORD PTR [esi+324]
  00083	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
  00087	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXXZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Tidy
  0008c	8d 8e 34 01 00
	00		 lea	 ecx, DWORD PTR [esi+308]
  00092	c6 45 fc 13	 mov	 BYTE PTR __$EHRec$[ebp+8], 19 ; 00000013H
  00096	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXXZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Tidy
  0009b	8d 8e 24 01 00
	00		 lea	 ecx, DWORD PTR [esi+292]
  000a1	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+8], 18 ; 00000012H
  000a5	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXXZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Tidy
  000aa	8d 8e 14 01 00
	00		 lea	 ecx, DWORD PTR [esi+276]
  000b0	c6 45 fc 11	 mov	 BYTE PTR __$EHRec$[ebp+8], 17 ; 00000011H
  000b4	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXXZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Tidy
  000b9	8d 8e 04 01 00
	00		 lea	 ecx, DWORD PTR [esi+260]
  000bf	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+8], 16 ; 00000010H
  000c3	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXXZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Tidy
  000c8	8d 8e f4 00 00
	00		 lea	 ecx, DWORD PTR [esi+244]
  000ce	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  000d2	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXXZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Tidy
  000d7	8d 8e e4 00 00
	00		 lea	 ecx, DWORD PTR [esi+228]
  000dd	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  000e1	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXXZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Tidy
  000e6	8d 8e d4 00 00
	00		 lea	 ecx, DWORD PTR [esi+212]
  000ec	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  000f0	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXXZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Tidy
  000f5	8d 8e c4 00 00
	00		 lea	 ecx, DWORD PTR [esi+196]
  000fb	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  000ff	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXXZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Tidy
  00104	8d 8e b4 00 00
	00		 lea	 ecx, DWORD PTR [esi+180]
  0010a	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  0010e	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXXZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Tidy
  00113	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  00117	8d 8e a4 00 00
	00		 lea	 ecx, DWORD PTR [esi+164]
  0011d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXXZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Tidy
  00122	8d 8e 94 00 00
	00		 lea	 ecx, DWORD PTR [esi+148]
  00128	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  0012c	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXXZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Tidy
  00131	8d 8e 84 00 00
	00		 lea	 ecx, DWORD PTR [esi+132]
  00137	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  0013b	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXXZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Tidy
  00140	8d 4e 74	 lea	 ecx, DWORD PTR [esi+116]
  00143	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00147	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXXZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Tidy
  0014c	8d 4e 64	 lea	 ecx, DWORD PTR [esi+100]
  0014f	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00153	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXXZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Tidy
  00158	8d 4e 54	 lea	 ecx, DWORD PTR [esi+84]
  0015b	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0015f	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXXZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Tidy
  00164	8d 4e 44	 lea	 ecx, DWORD PTR [esi+68]
  00167	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0016b	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXXZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Tidy
  00170	8d 4e 34	 lea	 ecx, DWORD PTR [esi+52]
  00173	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00177	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@IAEXXZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::_Tidy
  0017c	8d 4e 24	 lea	 ecx, DWORD PTR [esi+36]
  0017f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00183	e8 00 00 00 00	 call	 ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
  00188	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  0018b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0018f	e8 00 00 00 00	 call	 ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
  00194	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00197	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0019b	e8 00 00 00 00	 call	 ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
  001a0	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_Singleton@?$Singleton@VioRoomOptionManager@@@@1PAVioRoomOptionManager@@A, 0 ; Singleton<ioRoomOptionManager>::ms_Singleton
  001a7	e8 00 00 00 00	 call	 __EH_epilog3
  001ac	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$Singleton@VioRoomOptionManager@@@@QAE@XZ ; Singleton<ioRoomOptionManager>::~Singleton<ioRoomOptionManager>
__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 04	 add	 ecx, 4
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$2:
  00016	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	83 c1 14	 add	 ecx, 20			; 00000014H
  0001c	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$3:
  00021	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 24	 add	 ecx, 36			; 00000024H
  00027	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$4:
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 34	 add	 ecx, 52			; 00000034H
  00032	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$5:
  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 44	 add	 ecx, 68			; 00000044H
  0003d	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$6:
  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 54	 add	 ecx, 84			; 00000054H
  00048	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$7:
  0004d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	83 c1 64	 add	 ecx, 100		; 00000064H
  00053	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$8:
  00058	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	83 c1 74	 add	 ecx, 116		; 00000074H
  0005e	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$9:
  00063	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  0006c	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$10:
  00071	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	81 c1 94 00 00
	00		 add	 ecx, 148		; 00000094H
  0007a	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$11:
  0007f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	81 c1 a4 00 00
	00		 add	 ecx, 164		; 000000a4H
  00088	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$12:
  0008d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  00096	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$13:
  0009b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009e	81 c1 c4 00 00
	00		 add	 ecx, 196		; 000000c4H
  000a4	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$14:
  000a9	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  000b2	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$15:
  000b7	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ba	81 c1 e4 00 00
	00		 add	 ecx, 228		; 000000e4H
  000c0	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$16:
  000c5	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	81 c1 f4 00 00
	00		 add	 ecx, 244		; 000000f4H
  000ce	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$17:
  000d3	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  000dc	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$18:
  000e1	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e4	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  000ea	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$19:
  000ef	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000f2	81 c1 24 01 00
	00		 add	 ecx, 292		; 00000124H
  000f8	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$20:
  000fd	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00100	81 c1 34 01 00
	00		 add	 ecx, 308		; 00000134H
  00106	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$21:
  0010b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	81 c1 44 01 00
	00		 add	 ecx, 324		; 00000144H
  00114	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$22:
  00119	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0011c	81 c1 54 01 00
	00		 add	 ecx, 340		; 00000154H
  00122	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$23:
  00127	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0012a	81 c1 64 01 00
	00		 add	 ecx, 356		; 00000164H
  00130	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$24:
  00135	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00138	81 c1 74 01 00
	00		 add	 ecx, 372		; 00000174H
  0013e	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$25:
  00143	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00146	81 c1 84 01 00
	00		 add	 ecx, 388		; 00000184H
  0014c	e9 00 00 00 00	 jmp	 ??1?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::~vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >
__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$26:
  00151	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00154	81 c1 94 01 00
	00		 add	 ecx, 404		; 00000194H
  0015a	e9 00 00 00 00	 jmp	 ??1?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAE@XZ ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::~vector<PreSetInfo *,std::allocator<PreSetInfo *> >
__unwindfunclet$??1ioRoomOptionManager@@UAE@XZ$27:
  0015f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00162	81 c1 a4 01 00
	00		 add	 ecx, 420		; 000001a4H
  00168	e9 00 00 00 00	 jmp	 ??1PreSetInfo@@QAE@XZ
__ehhandler$??1ioRoomOptionManager@@UAE@XZ:
  0016d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00171	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00174	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00177	33 c8		 xor	 ecx, eax
  00179	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1ioRoomOptionManager@@UAE@XZ
  00183	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1ioRoomOptionManager@@UAE@XZ ENDP			; ioRoomOptionManager::~ioRoomOptionManager
PUBLIC	??_C@_0CI@PILLEEJG@ioRoomOptionManager?3?3LoadRoomOpt@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ	; ioRoomOptionManager::LoadRoomOptionInfo
EXTRN	__imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z:PROC
EXTRN	__imp_?GetSingleton@ioStringManager@@SAAAV1@XZ:PROC
EXTRN	__imp_??4ioHashString@@QAEAAV0@PBD@Z:PROC
EXTRN	__imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z:PROC
EXTRN	__imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	__chkstk:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_0CI@PILLEEJG@ioRoomOptionManager?3?3LoadRoomOpt@
CONST	SEGMENT
??_C@_0CI@PILLEEJG@ioRoomOptionManager?3?3LoadRoomOpt@ DB 'ioRoomOptionMa'
	DB	'nager::LoadRoomOptionInfo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ DD 019930522H
	DD	017H
	DD	FLAT:__unwindtable$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$3
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$4
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$5
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$6
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$7
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$8
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$9
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$10
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$11
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$12
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$13
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$14
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$15
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$16
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$17
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$18
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$19
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$20
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$21
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$22
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ
_TEXT	SEGMENT
tv127202 = -4924					; size = 4
tv127168 = -4924					; size = 4
tv127132 = -4924					; size = 4
tv127102 = -4924					; size = 4
tv127070 = -4924					; size = 4
tv127038 = -4924					; size = 4
tv127004 = -4924					; size = 4
tv126972 = -4924					; size = 4
tv126942 = -4924					; size = 4
tv126912 = -4924					; size = 4
tv126880 = -4924					; size = 4
tv126850 = -4924					; size = 4
tv126815 = -4924					; size = 4
tv126781 = -4924					; size = 4
tv126746 = -4924					; size = 4
tv126714 = -4924					; size = 4
tv126680 = -4924					; size = 4
tv126645 = -4924					; size = 4
tv126583 = -4924					; size = 4
tv126552 = -4924					; size = 4
$T540362 = -4924					; size = 4
$T540358 = -4924					; size = 4
$T540354 = -4924					; size = 4
$T540350 = -4924					; size = 4
$T540346 = -4924					; size = 4
$T540342 = -4924					; size = 4
$T540338 = -4924					; size = 4
$T540334 = -4924					; size = 4
$T540330 = -4924					; size = 4
$T540326 = -4924					; size = 4
$T540322 = -4924					; size = 4
$T540318 = -4924					; size = 4
$T540314 = -4924					; size = 4
$T540310 = -4924					; size = 4
$T540306 = -4924					; size = 4
$T540302 = -4924					; size = 4
$T540298 = -4924					; size = 4
$T540294 = -4924					; size = 4
$T540290 = -4924					; size = 4
$T540286 = -4924					; size = 4
$T540282 = -4924					; size = 4
_pInfo$ = -4920						; size = 4
_pInfo$520744 = -4920					; size = 4
_pInfo$520247 = -4920					; size = 4
_pInfo$519779 = -4920					; size = 4
_pInfo$519308 = -4920					; size = 4
_pInfo$518837 = -4920					; size = 4
_pInfo$518372 = -4920					; size = 4
_pInfo$517905 = -4920					; size = 4
_pInfo$517436 = -4920					; size = 4
_pInfo$516969 = -4920					; size = 4
_pInfo$516497 = -4920					; size = 4
_pInfo$516029 = -4920					; size = 4
_pInfo$515564 = -4920					; size = 4
_pInfo$515094 = -4920					; size = 4
_pInfo$514626 = -4920					; size = 4
_pInfo$514155 = -4920					; size = 4
_pInfo$513687 = -4920					; size = 4
_pInfo$513212 = -4920					; size = 4
_pInfo$512743 = -4920					; size = 4
_pInfo$512273 = -4920					; size = 4
_pInfo$511798 = -4920					; size = 4
$T540278 = -4920					; size = 4
_pInfo$511323 = -4920					; size = 4
_this$GSCopy$ = -4916					; size = 4
tv103518 = -4912					; size = 4
tv84446 = -4912						; size = 4
tv82363 = -4912						; size = 4
tv80493 = -4912						; size = 4
tv78822 = -4912						; size = 4
tv76754 = -4912						; size = 4
tv75250 = -4912						; size = 4
tv73617 = -4912						; size = 4
tv70273 = -4912						; size = 4
tv68730 = -4912						; size = 4
tv67597 = -4912						; size = 4
tv65951 = -4912						; size = 4
tv64458 = -4912						; size = 4
tv63381 = -4912						; size = 4
tv62100 = -4912						; size = 4
tv60521 = -4912						; size = 4
tv59401 = -4912						; size = 4
tv57937 = -4912						; size = 4
tv56774 = -4912						; size = 4
tv31525 = -4912						; size = 4
_iTypeCnt$ = -4912					; size = 4
_iModeIndex$511312 = -4912				; size = 4
_iModeIndex$511145 = -4912				; size = 4
_iModeIndex$510979 = -4912				; size = 4
tv125133 = -4908					; size = 4
$T540353 = -4908					; size = 4
$T540349 = -4908					; size = 4
$T540345 = -4908					; size = 4
$T540341 = -4908					; size = 4
$T540337 = -4908					; size = 4
$T540333 = -4908					; size = 4
$T540329 = -4908					; size = 4
$T540325 = -4908					; size = 4
$T540321 = -4908					; size = 4
$T540317 = -4908					; size = 4
$T540313 = -4908					; size = 4
$T540309 = -4908					; size = 4
$T540305 = -4908					; size = 4
$T540301 = -4908					; size = 4
$T540297 = -4908					; size = 4
$T540293 = -4908					; size = 4
$T540289 = -4908					; size = 4
$T540285 = -4908					; size = 4
$T540281 = -4908					; size = 4
_iOptionModeCnt$ = -4908				; size = 4
_iNoChallengerModeCnt$ = -4908				; size = 4
_iModeCnt$ = -4908					; size = 4
tv126831 = -4904					; size = 4
tv126768 = -4904					; size = 4
tv126679 = -4904					; size = 4
tv126556 = -4904					; size = 4
tv126477 = -4904					; size = 4
tv126400 = -4904					; size = 4
tv126337 = -4904					; size = 4
tv126244 = -4904					; size = 4
tv126135 = -4904					; size = 4
tv126072 = -4904					; size = 4
tv125977 = -4904					; size = 4
tv125888 = -4904					; size = 4
tv125781 = -4904					; size = 4
tv125689 = -4904					; size = 4
tv125596 = -4904					; size = 4
tv125499 = -4904					; size = 4
tv125408 = -4904					; size = 4
tv125333 = -4904					; size = 4
tv125242 = -4904					; size = 4
tv104212 = -4904					; size = 4
$T540277 = -4904					; size = 4
_i$ = -4904						; size = 4
_kLoader$ = -4900					; size = 912
_szBuf$ = -3988						; size = 260
_szKey$ = -3728						; size = 260
___encStr$511163 = -3468				; size = 28
___encStr$510996 = -3436				; size = 27
___encStr$523489 = -3404				; size = 25
___encStr$522273 = -3372				; size = 25
__k$549725 = -3340					; size = 24
___encStr$520561 = -3312				; size = 24
__k$549225 = -3284					; size = 24
___encStr$522881 = -3256				; size = 24
___encStr$522577 = -3228				; size = 24
___encStr$522121 = -3200				; size = 24
__k$541538 = -3172					; size = 24
___encStr$522729 = -3144				; size = 23
___encStr$523793 = -3116				; size = 23
__k$549113 = -3088					; size = 23
__k$547323 = -3060					; size = 23
__k$548988 = -3032					; size = 23
__k$541289 = -3004					; size = 23
__k$548725 = -2976					; size = 23
___encStr$521057 = -2948				; size = 21
___encStr$520256 = -2920				; size = 21
___encStr$520409 = -2892				; size = 21
___encStr$519622 = -2864				; size = 21
__k$541813 = -2836					; size = 21
___encStr$515876 = -2808				; size = 21
___encStr$513526 = -2780				; size = 21
___encStr$520093 = -2752				; size = 21
__k$543540 = -2724					; size = 21
___encStr$515408 = -2696				; size = 21
__k$547600 = -2668					; size = 21
__k$549988 = -2640					; size = 22
___encStr$514469 = -2612				; size = 22
__k$548850 = -2584					; size = 22
___encStr$511637 = -2556				; size = 22
___encStr$520905 = -2528				; size = 22
__k$541440 = -2500					; size = 20
__k$546744 = -2476					; size = 20
__k$544437 = -2452					; size = 20
___encStr$523641 = -2428				; size = 20
__k$544147 = -2404					; size = 20
___encStr$523185 = -2380				; size = 20
___encStr$516811 = -2356				; size = 20
___encStr$521665 = -2332				; size = 20
__k$547047 = -2308					; size = 20
__k$547750 = -2284					; size = 20
___encStr$510829 = -2260				; size = 20
___encStr$523337 = -2236				; size = 20
__k$549850 = -2212					; size = 19
___encStr$514317 = -2188				; size = 19
__k$549600 = -2164					; size = 19
__k$542960 = -2140					; size = 19
__k$549475 = -2116					; size = 19
__t$546605 = -2092					; size = 19
__k$548225 = -2068					; size = 19
___encStr$514164 = -2044				; size = 19
___encStr$511332 = -2020				; size = 19
___encStr$523033 = -1996				; size = 19
___encStr$511485 = -1972				; size = 19
___encStr$512112 = -1948				; size = 19
__k$544990 = -1924					; size = 19
___encStr$521817 = -1900				; size = 17
___encStr$516506 = -1876				; size = 17
___encStr$521513 = -1852				; size = 17
___encStr$522425 = -1828				; size = 17
__k$547859 = -1804					; size = 17
___encStr$516659 = -1780				; size = 17
__t$541164 = -1756					; size = 17
__k$543250 = -1732					; size = 17
___encStr$514940 = -1708				; size = 17
__k$549360 = -1684					; size = 18
___encStr$519317 = -1660				; size = 18
__k$542103 = -1636					; size = 18
___encStr$515573 = -1612				; size = 18
___encStr$513221 = -1588				; size = 18
___encStr$519788 = -1564				; size = 18
___encStr$513374 = -1540				; size = 18
___encStr$515725 = -1516				; size = 18
___encStr$514001 = -1492				; size = 18
___encStr$519470 = -1468				; size = 18
___encStr$515103 = -1444				; size = 18
___encStr$521209 = -1420				; size = 18
___encStr$515256 = -1396				; size = 18
___encStr$519941 = -1372				; size = 18
___encStr$521361 = -1348				; size = 16
___encStr$519151 = -1328				; size = 16
__k$548600 = -1308					; size = 16
___encStr$518219 = -1288				; size = 16
__k$548350 = -1268					; size = 16
__k$543843 = -1248					; size = 16
__k$548113 = -1228					; size = 16
___encStr$518684 = -1208				; size = 16
___encStr$511807 = -1188				; size = 16
___encStr$511960 = -1168				; size = 16
__k$541027 = -1148					; size = 16
___encStr$521969 = -1128				; size = 15
__k$546493 = -1108					; size = 15
__k$548028 = -1088					; size = 15
__k$546203 = -1068					; size = 15
__t$541978 = -1048					; size = 15
__k$545913 = -1028					; size = 15
___encStr$513696 = -1008				; size = 15
__t$546315 = -988					; size = 15
___encStr$513849 = -968					; size = 15
___encStr$517748 = -948					; size = 15
___encStr$517283 = -928					; size = 15
___encStr$520753 = -908					; size = 14
__k$545293 = -888					; size = 14
__k$548488 = -868					; size = 14
__t$544298 = -848					; size = 14
___encStr$514635 = -828					; size = 14
__k$545583 = -808					; size = 14
___encStr$514788 = -788					; size = 14
__t$546038 = -768					; size = 14
__t$545762 = -748					; size = 13
__t$544905 = -728					; size = 13
___encStr$518067 = -708					; size = 13
___encStr$516343 = -688					; size = 13
___encStr$518533 = -668					; size = 13
__t$545485 = -648					; size = 13
___encStr$518999 = -628					; size = 13
___encStr$517914 = -608					; size = 13
___encStr$512587 = -588					; size = 13
___encStr$518381 = -568					; size = 13
__t$542585 = -548					; size = 13
___encStr$518846 = -528					; size = 13
___encStr$513055 = -508					; size = 13
__t$547225 = -488					; size = 13
__t$544035 = -468					; size = 13
__k$540777 = -448					; size = 13
__k$542393 = -428					; size = 12
___encStr$517131 = -412					; size = 12
__k$542670 = -396					; size = 12
__t$542268 = -380					; size = 12
__k$544700 = -364					; size = 12
___encStr$517445 = -348					; size = 12
__t$545168 = -332					; size = 12
___encStr$516978 = -316					; size = 12
___encStr$517597 = -300					; size = 12
__t$547475 = -284					; size = 11
__t$542848 = -268					; size = 11
__t$540902 = -252					; size = 11
__k$550238 = -236					; size = 11
__t$541675 = -220					; size = 11
__t$543415 = -204					; size = 11
___encStr$512435 = -188					; size = 10
__t$546908 = -172					; size = 10
___encStr$512752 = -156					; size = 10
___encStr$516191 = -140					; size = 10
___encStr$512904 = -124					; size = 10
___encStr$512282 = -108					; size = 10
___encStr$516038 = -92					; size = 10
__t$543125 = -76					; size = 8
__t$540639 = -64					; size = 7
__t$550100 = -52					; size = 7
__t$544575 = -40					; size = 7
__t$543705 = -28					; size = 6
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ PROC	; ioRoomOptionManager::LoadRoomOptionInfo, COMDAT
; _this$ = ecx

; 22   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 30 13 00 00	 mov	 eax, 4912		; 00001330H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 658  : 
; 659  : 		wsprintf_e( szKey, "preset%d_extraitem_use", i+1 );

  00032	89 8d cc ec ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  00038	e8 00 00 00 00	 call	 ?ClearAllInfo@ioRoomOptionManager@@IAEXXZ ; ioRoomOptionManager::ClearAllInfo
  0003d	6a 07		 push	 7
  0003f	c7 85 2c f0 ff
	ff 8e 83 85 8c	 mov	 DWORD PTR _kLoader$[ebp+848], -1937407090 ; 8c85838eH
  00049	c7 85 30 f0 ff
	ff 84 8b c4 99	 mov	 DWORD PTR _kLoader$[ebp+852], -1715172476 ; 99c48b84H
  00053	c7 85 34 f0 ff
	ff 9d de b4 98	 mov	 DWORD PTR _kLoader$[ebp+856], -1732976995 ; 98b4de9dH
  0005d	c7 85 38 f0 ff
	ff 82 83 86 b5	 mov	 DWORD PTR _kLoader$[ebp+860], -1249475710 ; b5868382H
  00067	c7 85 3c f0 ff
	ff 82 9c 9f 83	 mov	 DWORD PTR _kLoader$[ebp+864], -2086691710 ; 839f9c82H
  00071	c7 85 40 f0 ff
	ff 82 82 b4 83	 mov	 DWORD PTR _kLoader$[ebp+868], -2085322110 ; 83b48282H
  0007b	c7 85 44 f0 ff
	ff 83 8a 84 c4	 mov	 DWORD PTR _kLoader$[ebp+872], -997946749 ; c4848a83H
  00085	8d 85 2c f0 ff
	ff		 lea	 eax, DWORD PTR _kLoader$[ebp+848]
  0008b	33 db		 xor	 ebx, ebx
  0008d	c7 85 48 f0 ff
	ff 84 82 82 00	 mov	 DWORD PTR _kLoader$[ebp+876], 8553092 ; 00828284H
  00097	59		 pop	 ecx
  00098	bf ed ec eb ea	 mov	 edi, -353637139		; eaebecedH
$LL8586@LoadRoomOp:

; 23   : 	ClearAllInfo();
; 24   : 
; 25   : 	ioINILoader_e kLoader( "config/sp2_room_option_info.ini" );

  0009d	31 38		 xor	 DWORD PTR [eax], edi
  0009f	83 c0 04	 add	 eax, 4
  000a2	49		 dec	 ecx
  000a3	75 f8		 jne	 SHORT $LL8586@LoadRoomOp
  000a5	6a 1c		 push	 28			; 0000001cH
  000a7	5e		 pop	 esi
$LL8583@LoadRoomOp:
  000a8	8b c6		 mov	 eax, esi
  000aa	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  000af	79 05		 jns	 SHORT $LN17507@LoadRoomOp
  000b1	48		 dec	 eax
  000b2	83 c8 fc	 or	 eax, -4			; fffffffcH
  000b5	40		 inc	 eax
$LN17507@LoadRoomOp:
  000b6	b1 ed		 mov	 cl, -19			; ffffffedH
  000b8	2a c8		 sub	 cl, al
  000ba	30 8c 35 2c f0
	ff ff		 xor	 BYTE PTR _kLoader$[ebp+esi+848], cl
  000c1	46		 inc	 esi
  000c2	83 fe 1f	 cmp	 esi, 31			; 0000001fH
  000c5	7c e1		 jl	 SHORT $LL8583@LoadRoomOp
  000c7	6a 01		 push	 1
  000c9	8d 85 2c f0 ff
	ff		 lea	 eax, DWORD PTR _kLoader$[ebp+848]
  000cf	50		 push	 eax
  000d0	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioINILoader@@QAE@PBD_N@Z

; 26   : 
; 27   : 	int i = 0;
; 28   : 	char szKey[MAX_PATH] = "";

  000dc	be 03 01 00 00	 mov	 esi, 259		; 00000103H
  000e1	56		 push	 esi
  000e2	8d 85 71 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp+1]
  000e8	53		 push	 ebx
  000e9	50		 push	 eax
  000ea	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  000ed	88 9d 70 f1 ff
	ff		 mov	 BYTE PTR _szKey$[ebp], bl
  000f3	e8 00 00 00 00	 call	 _memset

; 29   : 	char szBuf[MAX_PATH] = "";

  000f8	56		 push	 esi
  000f9	8d 85 6d f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp+1]
  000ff	53		 push	 ebx
  00100	50		 push	 eax
  00101	88 9d 6c f0 ff
	ff		 mov	 BYTE PTR _szBuf$[ebp], bl
  00107	e8 00 00 00 00	 call	 _memset
  0010c	83 c4 18	 add	 esp, 24			; 00000018H

; 30   : 
; 31   : 	// EnableLevel
; 32   : 	kLoader.SetTitle_e( "common" );

  0010f	6a 04		 push	 4
  00111	c7 45 c0 8e 83
	86 87		 mov	 DWORD PTR __t$540639[ebp], -2021227634 ; 8786838eH
  00118	31 7d c0	 xor	 DWORD PTR __t$540639[ebp], edi
  0011b	66 c7 45 c4 82
	82		 mov	 WORD PTR __t$540639[ebp+4], 33410 ; 00008282H
  00121	88 5d c6	 mov	 BYTE PTR __t$540639[ebp+6], bl
  00124	5e		 pop	 esi
$LL8689@LoadRoomOp:
  00125	8b c6		 mov	 eax, esi
  00127	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  0012c	79 05		 jns	 SHORT $LN17508@LoadRoomOp
  0012e	48		 dec	 eax
  0012f	83 c8 fc	 or	 eax, -4			; fffffffcH
  00132	40		 inc	 eax
$LN17508@LoadRoomOp:
  00133	b1 ed		 mov	 cl, -19			; ffffffedH
  00135	2a c8		 sub	 cl, al
  00137	30 4c 35 c0	 xor	 BYTE PTR __t$540639[ebp+esi], cl
  0013b	46		 inc	 esi
  0013c	83 fe 06	 cmp	 esi, 6
  0013f	7c e4		 jl	 SHORT $LL8689@LoadRoomOp
  00141	8d 45 c0	 lea	 eax, DWORD PTR __t$540639[ebp]
  00144	50		 push	 eax
  00145	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0014b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z
  00151	6a 03		 push	 3

; 33   : 	m_iEnableLevel = kLoader.LoadInt_e( "enable_level", 0 );

  00153	c7 85 40 fe ff
	ff 88 82 8a 88	 mov	 DWORD PTR __k$540777[ebp], -2004188536 ; 888a8288H
  0015d	c7 85 44 fe ff
	ff 81 89 b4 86	 mov	 DWORD PTR __k$540777[ebp+4], -2034988671 ; 86b48981H
  00167	c7 85 48 fe ff
	ff 88 9a 8e 86	 mov	 DWORD PTR __k$540777[ebp+8], -2037474680 ; 868e9a88H
  00171	8d 85 40 fe ff
	ff		 lea	 eax, DWORD PTR __k$540777[ebp]
  00177	88 9d 4c fe ff
	ff		 mov	 BYTE PTR __k$540777[ebp+12], bl
  0017d	59		 pop	 ecx
$LL8798@LoadRoomOp:
  0017e	31 38		 xor	 DWORD PTR [eax], edi
  00180	83 c0 04	 add	 eax, 4
  00183	49		 dec	 ecx
  00184	75 f8		 jne	 SHORT $LL8798@LoadRoomOp
  00186	53		 push	 ebx
  00187	8d 85 40 fe ff
	ff		 lea	 eax, DWORD PTR __k$540777[ebp]
  0018d	50		 push	 eax
  0018e	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00194	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  0019a	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  001a0	89 81 5c 02 00
	00		 mov	 DWORD PTR [ecx+604], eax
  001a6	6a 02		 push	 2

; 34   : 
; 35   : 	// EnableMode	
; 36   : 	kLoader.SetTitle_e( "EnableMode" );

  001a8	c7 85 04 ff ff
	ff a8 82 8a 88	 mov	 DWORD PTR __t$540902[ebp], -2004188504 ; 888a82a8H
  001b2	c7 85 08 ff ff
	ff 81 89 a6 85	 mov	 DWORD PTR __t$540902[ebp+4], -2052683391 ; 85a68981H
  001bc	66 c7 85 0c ff
	ff ff 89 89	 mov	 WORD PTR __t$540902[ebp+8], 35209 ; 00008989H
  001c5	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR __t$540902[ebp]
  001cb	88 9d 0e ff ff
	ff		 mov	 BYTE PTR __t$540902[ebp+10], bl
  001d1	59		 pop	 ecx
$LL8904@LoadRoomOp:
  001d2	31 38		 xor	 DWORD PTR [eax], edi
  001d4	83 c0 04	 add	 eax, 4
  001d7	49		 dec	 ecx
  001d8	75 f8		 jne	 SHORT $LL8904@LoadRoomOp
  001da	6a 08		 push	 8
  001dc	5e		 pop	 esi
$LL8901@LoadRoomOp:
  001dd	8b c6		 mov	 eax, esi
  001df	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  001e4	79 05		 jns	 SHORT $LN17509@LoadRoomOp
  001e6	48		 dec	 eax
  001e7	83 c8 fc	 or	 eax, -4			; fffffffcH
  001ea	40		 inc	 eax
$LN17509@LoadRoomOp:
  001eb	b1 ed		 mov	 cl, -19			; ffffffedH
  001ed	2a c8		 sub	 cl, al
  001ef	30 8c 35 04 ff
	ff ff		 xor	 BYTE PTR __t$540902[ebp+esi], cl
  001f6	46		 inc	 esi
  001f7	83 fe 0a	 cmp	 esi, 10			; 0000000aH
  001fa	7c e1		 jl	 SHORT $LL8901@LoadRoomOp
  001fc	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR __t$540902[ebp]
  00202	50		 push	 eax
  00203	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00209	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z
  0020f	6a 03		 push	 3

; 37   : 
; 38   : 	int iModeCnt = kLoader.LoadInt_e( "enable_mode_cnt", 0 );

  00211	c7 85 84 fb ff
	ff 88 82 8a 88	 mov	 DWORD PTR __k$541027[ebp], -2004188536 ; 888a8288H
  0021b	c7 85 88 fb ff
	ff 81 89 b4 87	 mov	 DWORD PTR __k$541027[ebp+4], -2018211455 ; 87b48981H
  00225	c7 85 8c fb ff
	ff 82 88 8e b5	 mov	 DWORD PTR __k$541027[ebp+8], -1248950142 ; b58e8882H
  0022f	8d 85 84 fb ff
	ff		 lea	 eax, DWORD PTR __k$541027[ebp]
  00235	c7 85 90 fb ff
	ff 8e 82 9f 00	 mov	 DWORD PTR __k$541027[ebp+12], 10453646 ; 009f828eH
  0023f	59		 pop	 ecx
$LL9010@LoadRoomOp:
  00240	31 38		 xor	 DWORD PTR [eax], edi
  00242	83 c0 04	 add	 eax, 4
  00245	49		 dec	 ecx
  00246	75 f8		 jne	 SHORT $LL9010@LoadRoomOp
  00248	6a 0c		 push	 12			; 0000000cH
  0024a	5e		 pop	 esi
$LL9007@LoadRoomOp:
  0024b	8b c6		 mov	 eax, esi
  0024d	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00252	79 05		 jns	 SHORT $LN17510@LoadRoomOp
  00254	48		 dec	 eax
  00255	83 c8 fc	 or	 eax, -4			; fffffffcH
  00258	40		 inc	 eax
$LN17510@LoadRoomOp:
  00259	b1 ed		 mov	 cl, -19			; ffffffedH
  0025b	2a c8		 sub	 cl, al
  0025d	30 8c 35 84 fb
	ff ff		 xor	 BYTE PTR __k$541027[ebp+esi], cl
  00264	46		 inc	 esi
  00265	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  00268	7c e1		 jl	 SHORT $LL9007@LoadRoomOp
  0026a	53		 push	 ebx
  0026b	8d 85 84 fb ff
	ff		 lea	 eax, DWORD PTR __k$541027[ebp]
  00271	50		 push	 eax
  00272	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00278	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 39   : 	for( i=0; i < iModeCnt; ++i )

  0027e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__wsprintfA
  00284	89 85 d4 ec ff
	ff		 mov	 DWORD PTR _iModeCnt$[ebp], eax
  0028a	89 9d d8 ec ff
	ff		 mov	 DWORD PTR _i$[ebp], ebx
  00290	3b c3		 cmp	 eax, ebx
  00292	0f 8e ce 00 00
	00		 jle	 $LN8408@LoadRoomOp
$LL8410@LoadRoomOp:

; 40   : 	{
; 41   : 		wsprintf_e( szKey, "enable_mode_index%d", i+1 );

  00298	6a 04		 push	 4
  0029a	c7 85 2c f7 ff
	ff 88 82 8a 88	 mov	 DWORD PTR ___encStr$510829[ebp], -2004188536 ; 888a8288H
  002a4	c7 85 30 f7 ff
	ff 81 89 b4 87	 mov	 DWORD PTR ___encStr$510829[ebp+4], -2018211455 ; 87b48981H
  002ae	c7 85 34 f7 ff
	ff 82 88 8e b5	 mov	 DWORD PTR ___encStr$510829[ebp+8], -1248950142 ; b58e8882H
  002b8	c7 85 38 f7 ff
	ff 84 82 8f 8f	 mov	 DWORD PTR ___encStr$510829[ebp+12], -1886420348 ; 8f8f8284H
  002c2	8d 85 2c f7 ff
	ff		 lea	 eax, DWORD PTR ___encStr$510829[ebp]
  002c8	c7 85 3c f7 ff
	ff 95 c9 8f 00	 mov	 DWORD PTR ___encStr$510829[ebp+16], 9423253 ; 008fc995H
  002d2	59		 pop	 ecx
$LL9018@LoadRoomOp:
  002d3	31 38		 xor	 DWORD PTR [eax], edi
  002d5	83 c0 04	 add	 eax, 4
  002d8	49		 dec	 ecx
  002d9	75 f8		 jne	 SHORT $LL9018@LoadRoomOp
  002db	6a 10		 push	 16			; 00000010H
  002dd	58		 pop	 eax
$LL9015@LoadRoomOp:
  002de	8b c8		 mov	 ecx, eax
  002e0	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  002e6	79 05		 jns	 SHORT $LN17511@LoadRoomOp
  002e8	49		 dec	 ecx
  002e9	83 c9 fc	 or	 ecx, -4			; fffffffcH
  002ec	41		 inc	 ecx
$LN17511@LoadRoomOp:
  002ed	b2 ed		 mov	 dl, -19			; ffffffedH
  002ef	2a d1		 sub	 dl, cl
  002f1	30 94 05 2c f7
	ff ff		 xor	 BYTE PTR ___encStr$510829[ebp+eax], dl
  002f8	40		 inc	 eax
  002f9	83 f8 13	 cmp	 eax, 19			; 00000013H
  002fc	7c e0		 jl	 SHORT $LL9015@LoadRoomOp
  002fe	8b 85 d8 ec ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00304	40		 inc	 eax
  00305	50		 push	 eax
  00306	89 85 d8 ec ff
	ff		 mov	 DWORD PTR tv104212[ebp], eax
  0030c	8d 85 2c f7 ff
	ff		 lea	 eax, DWORD PTR ___encStr$510829[ebp]
  00312	50		 push	 eax
  00313	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  00319	50		 push	 eax
  0031a	ff d6		 call	 esi
  0031c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 42   : 
; 43   : 		int iModeIndex = kLoader.LoadInt( szKey, 0 );

  0031f	53		 push	 ebx
  00320	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  00326	50		 push	 eax
  00327	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0032d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 44   : 		m_EnableOptionModeList.push_back( iModeIndex );

  00333	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00339	89 85 d0 ec ff
	ff		 mov	 DWORD PTR _iModeIndex$510979[ebp], eax
  0033f	8d 85 d0 ec ff
	ff		 lea	 eax, DWORD PTR _iModeIndex$510979[ebp]
  00345	50		 push	 eax
  00346	83 c1 04	 add	 ecx, 4
  00349	e8 00 00 00 00	 call	 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
  0034e	8b 85 d8 ec ff
	ff		 mov	 eax, DWORD PTR tv104212[ebp]
  00354	89 85 d8 ec ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
  0035a	3b 85 d4 ec ff
	ff		 cmp	 eax, DWORD PTR _iModeCnt$[ebp]
  00360	0f 8c 32 ff ff
	ff		 jl	 $LL8410@LoadRoomOp
$LN8408@LoadRoomOp:

; 45   : 	}
; 46   : 
; 47   : 	// no challenger
; 48   : 	kLoader.SetTitle_e( "NoChallengerMode" );

  00366	6a 04		 push	 4
  00368	c7 85 24 f9 ff
	ff a3 83 a8 82	 mov	 DWORD PTR __t$541164[ebp], -2102885469 ; 82a883a3H
  00372	c7 85 28 f9 ff
	ff 8c 80 87 8f	 mov	 DWORD PTR __t$541164[ebp+4], -1886945140 ; 8f87808cH
  0037c	c7 85 2c f9 ff
	ff 83 8b 8e 98	 mov	 DWORD PTR __t$541164[ebp+8], -1735488637 ; 988e8b83H
  00386	c7 85 30 f9 ff
	ff a0 83 8f 8f	 mov	 DWORD PTR __t$541164[ebp+12], -1886420064 ; 8f8f83a0H
  00390	8d 85 24 f9 ff
	ff		 lea	 eax, DWORD PTR __t$541164[ebp]
  00396	88 9d 34 f9 ff
	ff		 mov	 BYTE PTR __t$541164[ebp+16], bl
  0039c	59		 pop	 ecx
$LL9124@LoadRoomOp:
  0039d	31 38		 xor	 DWORD PTR [eax], edi
  0039f	83 c0 04	 add	 eax, 4
  003a2	49		 dec	 ecx
  003a3	75 f8		 jne	 SHORT $LL9124@LoadRoomOp
  003a5	8d 85 24 f9 ff
	ff		 lea	 eax, DWORD PTR __t$541164[ebp]
  003ab	50		 push	 eax
  003ac	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  003b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z
  003b8	6a 05		 push	 5

; 49   : 
; 50   : 	int iNoChallengerModeCnt = kLoader.LoadInt_e( "no_challenger_mode_cnt", 0 );

  003ba	c7 85 44 f4 ff
	ff 83 83 b4 89	 mov	 DWORD PTR __k$541289[ebp], -1984658557 ; 89b48383H
  003c4	c7 85 48 f4 ff
	ff 85 8d 87 86	 mov	 DWORD PTR __k$541289[ebp+4], -2037936763 ; 86878d85H
  003ce	c7 85 4c f4 ff
	ff 88 82 8c 8f	 mov	 DWORD PTR __k$541289[ebp+8], -1886616952 ; 8f8c8288H
  003d8	c7 85 50 f4 ff
	ff 9f b3 86 85	 mov	 DWORD PTR __k$541289[ebp+12], -2054769761 ; 8586b39fH
  003e2	c7 85 54 f4 ff
	ff 89 89 b4 89	 mov	 DWORD PTR __k$541289[ebp+16], -1984657015 ; 89b48989H
  003ec	66 c7 85 58 f4
	ff ff 83 98	 mov	 WORD PTR __k$541289[ebp+20], 39043 ; 00009883H
  003f5	8d 85 44 f4 ff
	ff		 lea	 eax, DWORD PTR __k$541289[ebp]
  003fb	88 9d 5a f4 ff
	ff		 mov	 BYTE PTR __k$541289[ebp+22], bl
  00401	59		 pop	 ecx
$LL9230@LoadRoomOp:
  00402	31 38		 xor	 DWORD PTR [eax], edi
  00404	83 c0 04	 add	 eax, 4
  00407	49		 dec	 ecx
  00408	75 f8		 jne	 SHORT $LL9230@LoadRoomOp
  0040a	6a 14		 push	 20			; 00000014H
  0040c	58		 pop	 eax
$LL9227@LoadRoomOp:
  0040d	8b c8		 mov	 ecx, eax
  0040f	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00415	79 05		 jns	 SHORT $LN17512@LoadRoomOp
  00417	49		 dec	 ecx
  00418	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0041b	41		 inc	 ecx
$LN17512@LoadRoomOp:
  0041c	b2 ed		 mov	 dl, -19			; ffffffedH
  0041e	2a d1		 sub	 dl, cl
  00420	30 94 05 44 f4
	ff ff		 xor	 BYTE PTR __k$541289[ebp+eax], dl
  00427	40		 inc	 eax
  00428	83 f8 16	 cmp	 eax, 22			; 00000016H
  0042b	7c e0		 jl	 SHORT $LL9227@LoadRoomOp
  0042d	53		 push	 ebx
  0042e	8d 85 44 f4 ff
	ff		 lea	 eax, DWORD PTR __k$541289[ebp]
  00434	50		 push	 eax
  00435	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0043b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  00441	89 85 d4 ec ff
	ff		 mov	 DWORD PTR _iNoChallengerModeCnt$[ebp], eax

; 51   : 	for( i=0; i < iNoChallengerModeCnt; ++i )

  00447	89 9d d8 ec ff
	ff		 mov	 DWORD PTR _i$[ebp], ebx
  0044d	3b c3		 cmp	 eax, ebx
  0044f	0f 8e e7 00 00
	00		 jle	 $LN8306@LoadRoomOp
$LL8308@LoadRoomOp:

; 52   : 	{
; 53   : 		wsprintf_e( szKey, "no_challenger_mode_index%d", i+1 );

  00455	6a 06		 push	 6
  00457	c7 85 94 f2 ff
	ff 83 83 b4 89	 mov	 DWORD PTR ___encStr$510996[ebp], -1984658557 ; 89b48383H
  00461	c7 85 98 f2 ff
	ff 85 8d 87 86	 mov	 DWORD PTR ___encStr$510996[ebp+4], -2037936763 ; 86878d85H
  0046b	c7 85 9c f2 ff
	ff 88 82 8c 8f	 mov	 DWORD PTR ___encStr$510996[ebp+8], -1886616952 ; 8f8c8288H
  00475	c7 85 a0 f2 ff
	ff 9f b3 86 85	 mov	 DWORD PTR ___encStr$510996[ebp+12], -2054769761 ; 8586b39fH
  0047f	c7 85 a4 f2 ff
	ff 89 89 b4 83	 mov	 DWORD PTR ___encStr$510996[ebp+16], -2085320311 ; 83b48989H
  00489	c7 85 a8 f2 ff
	ff 83 88 8e 92	 mov	 DWORD PTR ___encStr$510996[ebp+20], -1836152701 ; 928e8883H
  00493	66 c7 85 ac f2
	ff ff c8 88	 mov	 WORD PTR ___encStr$510996[ebp+24], 35016 ; 000088c8H
  0049c	8d 85 94 f2 ff
	ff		 lea	 eax, DWORD PTR ___encStr$510996[ebp]
  004a2	88 9d ae f2 ff
	ff		 mov	 BYTE PTR ___encStr$510996[ebp+26], bl
  004a8	59		 pop	 ecx
$LL9238@LoadRoomOp:
  004a9	31 38		 xor	 DWORD PTR [eax], edi
  004ab	83 c0 04	 add	 eax, 4
  004ae	49		 dec	 ecx
  004af	75 f8		 jne	 SHORT $LL9238@LoadRoomOp
  004b1	6a 18		 push	 24			; 00000018H
  004b3	58		 pop	 eax
$LL9235@LoadRoomOp:
  004b4	8b c8		 mov	 ecx, eax
  004b6	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  004bc	79 05		 jns	 SHORT $LN17513@LoadRoomOp
  004be	49		 dec	 ecx
  004bf	83 c9 fc	 or	 ecx, -4			; fffffffcH
  004c2	41		 inc	 ecx
$LN17513@LoadRoomOp:
  004c3	b2 ed		 mov	 dl, -19			; ffffffedH
  004c5	2a d1		 sub	 dl, cl
  004c7	30 94 05 94 f2
	ff ff		 xor	 BYTE PTR ___encStr$510996[ebp+eax], dl
  004ce	40		 inc	 eax
  004cf	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  004d2	7c e0		 jl	 SHORT $LL9235@LoadRoomOp
  004d4	8b 85 d8 ec ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  004da	40		 inc	 eax
  004db	50		 push	 eax
  004dc	89 85 d8 ec ff
	ff		 mov	 DWORD PTR tv104212[ebp], eax
  004e2	8d 85 94 f2 ff
	ff		 lea	 eax, DWORD PTR ___encStr$510996[ebp]
  004e8	50		 push	 eax
  004e9	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  004ef	50		 push	 eax
  004f0	ff d6		 call	 esi
  004f2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 54   : 
; 55   : 		int iModeIndex = kLoader.LoadInt( szKey, 0 );

  004f5	53		 push	 ebx
  004f6	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  004fc	50		 push	 eax
  004fd	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00503	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 56   : 		m_NoChallengerModeList.push_back( iModeIndex );

  00509	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0050f	89 85 d0 ec ff
	ff		 mov	 DWORD PTR _iModeIndex$511145[ebp], eax
  00515	8d 85 d0 ec ff
	ff		 lea	 eax, DWORD PTR _iModeIndex$511145[ebp]
  0051b	50		 push	 eax
  0051c	83 c1 24	 add	 ecx, 36			; 00000024H
  0051f	e8 00 00 00 00	 call	 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
  00524	8b 85 d8 ec ff
	ff		 mov	 eax, DWORD PTR tv104212[ebp]
  0052a	89 85 d8 ec ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
  00530	3b 85 d4 ec ff
	ff		 cmp	 eax, DWORD PTR _iNoChallengerModeCnt$[ebp]
  00536	0f 8c 19 ff ff
	ff		 jl	 $LL8308@LoadRoomOp
$LN8306@LoadRoomOp:

; 57   : 	}
; 58   : 
; 59   : 	m_iNoChallengerGrade = kLoader.LoadInt_e( "no_challenger_grade", 0 );

  0053c	6a 04		 push	 4
  0053e	c7 85 3c f6 ff
	ff 83 83 b4 89	 mov	 DWORD PTR __k$541440[ebp], -1984658557 ; 89b48383H
  00548	c7 85 40 f6 ff
	ff 85 8d 87 86	 mov	 DWORD PTR __k$541440[ebp+4], -2037936763 ; 86878d85H
  00552	c7 85 44 f6 ff
	ff 88 82 8c 8f	 mov	 DWORD PTR __k$541440[ebp+8], -1886616952 ; 8f8c8288H
  0055c	c7 85 48 f6 ff
	ff 9f b3 8c 98	 mov	 DWORD PTR __k$541440[ebp+12], -1735609441 ; 988cb39fH
  00566	8d 85 3c f6 ff
	ff		 lea	 eax, DWORD PTR __k$541440[ebp]
  0056c	c7 85 4c f6 ff
	ff 8c 88 8e 00	 mov	 DWORD PTR __k$541440[ebp+16], 9341068 ; 008e888cH
  00576	59		 pop	 ecx
$LL9344@LoadRoomOp:
  00577	31 38		 xor	 DWORD PTR [eax], edi
  00579	83 c0 04	 add	 eax, 4
  0057c	49		 dec	 ecx
  0057d	75 f8		 jne	 SHORT $LL9344@LoadRoomOp
  0057f	6a 10		 push	 16			; 00000010H
  00581	58		 pop	 eax
$LL9341@LoadRoomOp:
  00582	8b c8		 mov	 ecx, eax
  00584	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0058a	79 05		 jns	 SHORT $LN17514@LoadRoomOp
  0058c	49		 dec	 ecx
  0058d	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00590	41		 inc	 ecx
$LN17514@LoadRoomOp:
  00591	b2 ed		 mov	 dl, -19			; ffffffedH
  00593	2a d1		 sub	 dl, cl
  00595	30 94 05 3c f6
	ff ff		 xor	 BYTE PTR __k$541440[ebp+eax], dl
  0059c	40		 inc	 eax
  0059d	83 f8 13	 cmp	 eax, 19			; 00000013H
  005a0	7c e0		 jl	 SHORT $LL9341@LoadRoomOp
  005a2	53		 push	 ebx
  005a3	8d 85 3c f6 ff
	ff		 lea	 eax, DWORD PTR __k$541440[ebp]
  005a9	50		 push	 eax
  005aa	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  005b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  005b6	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  005bc	89 81 60 02 00
	00		 mov	 DWORD PTR [ecx+608], eax
  005c2	6a 05		 push	 5

; 60   : 
; 61   : 	// Enable RoundOptionMode	
; 62   : 	int iOptionModeCnt = kLoader.LoadInt_e( "enable_round_option_cnt", 0 );

  005c4	c7 85 9c f3 ff
	ff 88 82 8a 88	 mov	 DWORD PTR __k$541538[ebp], -2004188536 ; 888a8288H
  005ce	c7 85 a0 f3 ff
	ff 81 89 b4 98	 mov	 DWORD PTR __k$541538[ebp+4], -1732998783 ; 98b48981H
  005d8	c7 85 a4 f3 ff
	ff 82 99 85 8e	 mov	 DWORD PTR __k$541538[ebp+8], -1903847038 ; 8e859982H
  005e2	c7 85 a8 f3 ff
	ff b2 83 9b 9e	 mov	 DWORD PTR __k$541538[ebp+12], -1633975374 ; 9e9b83b2H
  005ec	c7 85 ac f3 ff
	ff 84 83 85 b5	 mov	 DWORD PTR __k$541538[ebp+16], -1249541244 ; b5858384H
  005f6	8d 85 9c f3 ff
	ff		 lea	 eax, DWORD PTR __k$541538[ebp]
  005fc	c7 85 b0 f3 ff
	ff 8e 82 9f 00	 mov	 DWORD PTR __k$541538[ebp+20], 10453646 ; 009f828eH
  00606	59		 pop	 ecx
$LL9450@LoadRoomOp:
  00607	31 38		 xor	 DWORD PTR [eax], edi
  00609	83 c0 04	 add	 eax, 4
  0060c	49		 dec	 ecx
  0060d	75 f8		 jne	 SHORT $LL9450@LoadRoomOp
  0060f	6a 14		 push	 20			; 00000014H
  00611	58		 pop	 eax
$LL9447@LoadRoomOp:
  00612	8b c8		 mov	 ecx, eax
  00614	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0061a	79 05		 jns	 SHORT $LN17515@LoadRoomOp
  0061c	49		 dec	 ecx
  0061d	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00620	41		 inc	 ecx
$LN17515@LoadRoomOp:
  00621	b2 ed		 mov	 dl, -19			; ffffffedH
  00623	2a d1		 sub	 dl, cl
  00625	30 94 05 9c f3
	ff ff		 xor	 BYTE PTR __k$541538[ebp+eax], dl
  0062c	40		 inc	 eax
  0062d	83 f8 17	 cmp	 eax, 23			; 00000017H
  00630	7c e0		 jl	 SHORT $LL9447@LoadRoomOp
  00632	53		 push	 ebx
  00633	8d 85 9c f3 ff
	ff		 lea	 eax, DWORD PTR __k$541538[ebp]
  00639	50		 push	 eax
  0063a	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00640	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  00646	89 85 d4 ec ff
	ff		 mov	 DWORD PTR _iOptionModeCnt$[ebp], eax

; 63   : 	for( i=0; i < iOptionModeCnt; ++i )

  0064c	89 9d d8 ec ff
	ff		 mov	 DWORD PTR _i$[ebp], ebx
  00652	3b c3		 cmp	 eax, ebx
  00654	0f 8e e2 00 00
	00		 jle	 $LN8204@LoadRoomOp
$LL8206@LoadRoomOp:

; 64   : 	{
; 65   : 		wsprintf_e( szKey, "enable_round_option_index%d", i+1 );

  0065a	6a 06		 push	 6
  0065c	c7 85 74 f2 ff
	ff 88 82 8a 88	 mov	 DWORD PTR ___encStr$511163[ebp], -2004188536 ; 888a8288H
  00666	c7 85 78 f2 ff
	ff 81 89 b4 98	 mov	 DWORD PTR ___encStr$511163[ebp+4], -1732998783 ; 98b48981H
  00670	c7 85 7c f2 ff
	ff 82 99 85 8e	 mov	 DWORD PTR ___encStr$511163[ebp+8], -1903847038 ; 8e859982H
  0067a	c7 85 80 f2 ff
	ff b2 83 9b 9e	 mov	 DWORD PTR ___encStr$511163[ebp+12], -1633975374 ; 9e9b83b2H
  00684	c7 85 84 f2 ff
	ff 84 83 85 b5	 mov	 DWORD PTR ___encStr$511163[ebp+16], -1249541244 ; b5858384H
  0068e	c7 85 88 f2 ff
	ff 84 82 8f 8f	 mov	 DWORD PTR ___encStr$511163[ebp+20], -1886420348 ; 8f8f8284H
  00698	8d 85 74 f2 ff
	ff		 lea	 eax, DWORD PTR ___encStr$511163[ebp]
  0069e	c7 85 8c f2 ff
	ff 95 c9 8f 00	 mov	 DWORD PTR ___encStr$511163[ebp+24], 9423253 ; 008fc995H
  006a8	59		 pop	 ecx
$LL9458@LoadRoomOp:
  006a9	31 38		 xor	 DWORD PTR [eax], edi
  006ab	83 c0 04	 add	 eax, 4
  006ae	49		 dec	 ecx
  006af	75 f8		 jne	 SHORT $LL9458@LoadRoomOp
  006b1	6a 18		 push	 24			; 00000018H
  006b3	58		 pop	 eax
$LL9455@LoadRoomOp:
  006b4	8b c8		 mov	 ecx, eax
  006b6	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  006bc	79 05		 jns	 SHORT $LN17516@LoadRoomOp
  006be	49		 dec	 ecx
  006bf	83 c9 fc	 or	 ecx, -4			; fffffffcH
  006c2	41		 inc	 ecx
$LN17516@LoadRoomOp:
  006c3	b2 ed		 mov	 dl, -19			; ffffffedH
  006c5	2a d1		 sub	 dl, cl
  006c7	30 94 05 74 f2
	ff ff		 xor	 BYTE PTR ___encStr$511163[ebp+eax], dl
  006ce	40		 inc	 eax
  006cf	83 f8 1b	 cmp	 eax, 27			; 0000001bH
  006d2	7c e0		 jl	 SHORT $LL9455@LoadRoomOp
  006d4	8b 85 d8 ec ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  006da	40		 inc	 eax
  006db	50		 push	 eax
  006dc	89 85 d8 ec ff
	ff		 mov	 DWORD PTR tv104212[ebp], eax
  006e2	8d 85 74 f2 ff
	ff		 lea	 eax, DWORD PTR ___encStr$511163[ebp]
  006e8	50		 push	 eax
  006e9	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  006ef	50		 push	 eax
  006f0	ff d6		 call	 esi
  006f2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 66   : 
; 67   : 		int iModeIndex = kLoader.LoadInt( szKey, 0 );

  006f5	53		 push	 ebx
  006f6	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  006fc	50		 push	 eax
  006fd	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00703	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 68   : 		m_EnableRoundOptionModeList.push_back( iModeIndex );

  00709	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0070f	89 85 d0 ec ff
	ff		 mov	 DWORD PTR _iModeIndex$511312[ebp], eax
  00715	8d 85 d0 ec ff
	ff		 lea	 eax, DWORD PTR _iModeIndex$511312[ebp]
  0071b	50		 push	 eax
  0071c	83 c1 14	 add	 ecx, 20			; 00000014H
  0071f	e8 00 00 00 00	 call	 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
  00724	8b 85 d8 ec ff
	ff		 mov	 eax, DWORD PTR tv104212[ebp]
  0072a	89 85 d8 ec ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
  00730	3b 85 d4 ec ff
	ff		 cmp	 eax, DWORD PTR _iOptionModeCnt$[ebp]
  00736	0f 8c 1e ff ff
	ff		 jl	 $LL8206@LoadRoomOp
$LN8204@LoadRoomOp:

; 69   : 	}
; 70   : 
; 71   : 
; 72   : 	// ChangeChar
; 73   : 	kLoader.SetTitle_e( "ChangeChar" );

  0073c	6a 02		 push	 2
  0073e	c7 85 24 ff ff
	ff ae 84 8a 84	 mov	 DWORD PTR __t$541675[ebp], -2071296850 ; 848a84aeH
  00748	c7 85 28 ff ff
	ff 8a 89 a8 82	 mov	 DWORD PTR __t$541675[ebp+4], -2102883958 ; 82a8898aH
  00752	66 c7 85 2c ff
	ff ff 8c 9e	 mov	 WORD PTR __t$541675[ebp+8], 40588 ; 00009e8cH
  0075b	8d 85 24 ff ff
	ff		 lea	 eax, DWORD PTR __t$541675[ebp]
  00761	88 9d 2e ff ff
	ff		 mov	 BYTE PTR __t$541675[ebp+10], bl
  00767	59		 pop	 ecx
$LL9564@LoadRoomOp:
  00768	31 38		 xor	 DWORD PTR [eax], edi
  0076a	83 c0 04	 add	 eax, 4
  0076d	49		 dec	 ecx
  0076e	75 f8		 jne	 SHORT $LL9564@LoadRoomOp
  00770	6a 08		 push	 8
  00772	58		 pop	 eax
$LL9561@LoadRoomOp:
  00773	8b c8		 mov	 ecx, eax
  00775	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0077b	79 05		 jns	 SHORT $LN17517@LoadRoomOp
  0077d	49		 dec	 ecx
  0077e	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00781	41		 inc	 ecx
$LN17517@LoadRoomOp:
  00782	b2 ed		 mov	 dl, -19			; ffffffedH
  00784	2a d1		 sub	 dl, cl
  00786	30 94 05 24 ff
	ff ff		 xor	 BYTE PTR __t$541675[ebp+eax], dl
  0078d	40		 inc	 eax
  0078e	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00791	7c e0		 jl	 SHORT $LL9561@LoadRoomOp
  00793	8d 85 24 ff ff
	ff		 lea	 eax, DWORD PTR __t$541675[ebp]
  00799	50		 push	 eax
  0079a	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  007a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z
  007a6	6a 05		 push	 5

; 74   : 
; 75   : 	int iTypeCnt = kLoader.LoadInt_e( "change_char_type_cnt", 0 );

  007a8	c7 85 ec f4 ff
	ff 8e 84 8a 84	 mov	 DWORD PTR __k$541813[ebp], -2071296882 ; 848a848eH
  007b2	c7 85 f0 f4 ff
	ff 8a 89 b4 89	 mov	 DWORD PTR __k$541813[ebp+4], -1984657014 ; 89b4898aH
  007bc	c7 85 f4 f4 ff
	ff 85 8d 99 b5	 mov	 DWORD PTR __k$541813[ebp+8], -1248227963 ; b5998d85H
  007c6	c7 85 f8 f4 ff
	ff 99 95 9b 8f	 mov	 DWORD PTR __k$541813[ebp+12], -1885629031 ; 8f9b9599H
  007d0	c7 85 fc f4 ff
	ff b2 8f 85 9e	 mov	 DWORD PTR __k$541813[ebp+16], -1635414094 ; 9e858fb2H
  007da	8d 85 ec f4 ff
	ff		 lea	 eax, DWORD PTR __k$541813[ebp]
  007e0	88 9d 00 f5 ff
	ff		 mov	 BYTE PTR __k$541813[ebp+20], bl
  007e6	59		 pop	 ecx
$LL9670@LoadRoomOp:
  007e7	31 38		 xor	 DWORD PTR [eax], edi
  007e9	83 c0 04	 add	 eax, 4
  007ec	49		 dec	 ecx
  007ed	75 f8		 jne	 SHORT $LL9670@LoadRoomOp
  007ef	53		 push	 ebx
  007f0	8d 85 ec f4 ff
	ff		 lea	 eax, DWORD PTR __k$541813[ebp]
  007f6	50		 push	 eax
  007f7	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  007fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 76   : 	for( i=0; i < iTypeCnt; ++i )

  00803	3b c3		 cmp	 eax, ebx
  00805	0f 8e a4 02 00
	00		 jle	 $LN8102@LoadRoomOp

; 74   : 
; 75   : 	int iTypeCnt = kLoader.LoadInt_e( "change_char_type_cnt", 0 );

  0080b	c7 85 d4 ec ff
	ff 01 00 00 00	 mov	 DWORD PTR tv125133[ebp], 1
  00815	89 85 d0 ec ff
	ff		 mov	 DWORD PTR tv84446[ebp], eax
$LL8104@LoadRoomOp:

; 77   : 	{
; 78   : 		RoomOptionInfo *pInfo = new RoomOptionInfo;

  0081b	6a 50		 push	 80			; 00000050H
  0081d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00822	59		 pop	 ecx
  00823	89 85 c8 ec ff
	ff		 mov	 DWORD PTR $T540278[ebp], eax
  00829	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0082d	3b c3		 cmp	 eax, ebx
  0082f	74 0f		 je	 SHORT $LN8413@LoadRoomOp
  00831	8b c8		 mov	 ecx, eax
  00833	e8 00 00 00 00	 call	 ??0RoomOptionInfo@@QAE@XZ ; RoomOptionInfo::RoomOptionInfo
  00838	89 85 d8 ec ff
	ff		 mov	 DWORD PTR $T540277[ebp], eax
  0083e	eb 06		 jmp	 SHORT $LN8414@LoadRoomOp
$LN8413@LoadRoomOp:
  00840	89 9d d8 ec ff
	ff		 mov	 DWORD PTR $T540277[ebp], ebx
$LN8414@LoadRoomOp:
  00846	8b 85 d8 ec ff
	ff		 mov	 eax, DWORD PTR $T540277[ebp]
  0084c	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  0084f	89 85 c8 ec ff
	ff		 mov	 DWORD PTR _pInfo$511323[ebp], eax

; 79   : 		if( !pInfo )

  00855	3b c3		 cmp	 eax, ebx
  00857	0f 84 40 02 00
	00		 je	 $LN8103@LoadRoomOp

; 80   : 			continue;
; 81   : 
; 82   : 		wsprintf_e( szKey, "change_char_rate%d", i+1 );

  0085d	6a 04		 push	 4
  0085f	c7 85 1c f8 ff
	ff 8e 84 8a 84	 mov	 DWORD PTR ___encStr$511332[ebp], -2071296882 ; 848a848eH
  00869	c7 85 20 f8 ff
	ff 8a 89 b4 89	 mov	 DWORD PTR ___encStr$511332[ebp+4], -1984657014 ; 89b4898aH
  00873	c7 85 24 f8 ff
	ff 85 8d 99 b5	 mov	 DWORD PTR ___encStr$511332[ebp+8], -1248227963 ; b5998d85H
  0087d	c7 85 28 f8 ff
	ff 9f 8d 9f 8f	 mov	 DWORD PTR ___encStr$511332[ebp+12], -1885368929 ; 8f9f8d9fH
  00887	66 c7 85 2c f8
	ff ff c8 88	 mov	 WORD PTR ___encStr$511332[ebp+16], 35016 ; 000088c8H
  00890	8d 85 1c f8 ff
	ff		 lea	 eax, DWORD PTR ___encStr$511332[ebp]
  00896	88 9d 2e f8 ff
	ff		 mov	 BYTE PTR ___encStr$511332[ebp+18], bl
  0089c	59		 pop	 ecx
$LL9678@LoadRoomOp:
  0089d	31 38		 xor	 DWORD PTR [eax], edi
  0089f	83 c0 04	 add	 eax, 4
  008a2	49		 dec	 ecx
  008a3	75 f8		 jne	 SHORT $LL9678@LoadRoomOp
  008a5	6a 10		 push	 16			; 00000010H
  008a7	58		 pop	 eax
$LL9675@LoadRoomOp:
  008a8	8b c8		 mov	 ecx, eax
  008aa	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  008b0	79 05		 jns	 SHORT $LN17518@LoadRoomOp
  008b2	49		 dec	 ecx
  008b3	83 c9 fc	 or	 ecx, -4			; fffffffcH
  008b6	41		 inc	 ecx
$LN17518@LoadRoomOp:
  008b7	b2 ed		 mov	 dl, -19			; ffffffedH
  008b9	2a d1		 sub	 dl, cl
  008bb	30 94 05 1c f8
	ff ff		 xor	 BYTE PTR ___encStr$511332[ebp+eax], dl
  008c2	40		 inc	 eax
  008c3	83 f8 12	 cmp	 eax, 18			; 00000012H
  008c6	7c e0		 jl	 SHORT $LL9675@LoadRoomOp
  008c8	ff b5 d4 ec ff
	ff		 push	 DWORD PTR tv125133[ebp]
  008ce	8d 85 1c f8 ff
	ff		 lea	 eax, DWORD PTR ___encStr$511332[ebp]
  008d4	50		 push	 eax
  008d5	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  008db	50		 push	 eax
  008dc	ff d6		 call	 esi
  008de	83 c4 0c	 add	 esp, 12			; 0000000cH

; 83   : 		pInfo->m_fValue = kLoader.LoadFloat( szKey, FLOAT1 );

  008e1	b8 01 00 00 00	 mov	 eax, 1
  008e6	89 85 c4 ec ff
	ff		 mov	 DWORD PTR tv127202[ebp], eax
  008ec	db 85 c4 ec ff
	ff		 fild	 DWORD PTR tv127202[ebp]
  008f2	85 c0		 test	 eax, eax
  008f4	79 06		 jns	 SHORT $LN17519@LoadRoomOp
  008f6	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN17519@LoadRoomOp:
  008fc	51		 push	 ecx
  008fd	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  00903	d9 1c 24	 fstp	 DWORD PTR [esp]
  00906	50		 push	 eax
  00907	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0090d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z
  00913	51		 push	 ecx
  00914	8b 8d d8 ec ff
	ff		 mov	 ecx, DWORD PTR $T540277[ebp]
  0091a	d9 1c 24	 fstp	 DWORD PTR [esp]
  0091d	e8 00 00 00 00	 call	 ??4?$CEncrypt@M@@QAEMM@Z ; CEncrypt<float>::operator=
  00922	dd d8		 fstp	 ST(0)
  00924	6a 04		 push	 4

; 84   : 
; 85   : 		wsprintf_e( szKey, "change_char_desc%d", i+1 );

  00926	c7 85 4c f8 ff
	ff 8e 84 8a 84	 mov	 DWORD PTR ___encStr$511485[ebp], -2071296882 ; 848a848eH
  00930	c7 85 50 f8 ff
	ff 8a 89 b4 89	 mov	 DWORD PTR ___encStr$511485[ebp+4], -1984657014 ; 89b4898aH
  0093a	c7 85 54 f8 ff
	ff 85 8d 99 b5	 mov	 DWORD PTR ___encStr$511485[ebp+8], -1248227963 ; b5998d85H
  00944	c7 85 58 f8 ff
	ff 89 89 98 89	 mov	 DWORD PTR ___encStr$511485[ebp+12], -1986492023 ; 89988989H
  0094e	66 c7 85 5c f8
	ff ff c8 88	 mov	 WORD PTR ___encStr$511485[ebp+16], 35016 ; 000088c8H
  00957	8d 85 4c f8 ff
	ff		 lea	 eax, DWORD PTR ___encStr$511485[ebp]
  0095d	88 9d 5e f8 ff
	ff		 mov	 BYTE PTR ___encStr$511485[ebp+18], bl
  00963	59		 pop	 ecx
$LL9688@LoadRoomOp:
  00964	31 38		 xor	 DWORD PTR [eax], edi
  00966	83 c0 04	 add	 eax, 4
  00969	49		 dec	 ecx
  0096a	75 f8		 jne	 SHORT $LL9688@LoadRoomOp
  0096c	6a 10		 push	 16			; 00000010H
  0096e	58		 pop	 eax
$LL9685@LoadRoomOp:
  0096f	8b c8		 mov	 ecx, eax
  00971	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00977	79 05		 jns	 SHORT $LN17520@LoadRoomOp
  00979	49		 dec	 ecx
  0097a	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0097d	41		 inc	 ecx
$LN17520@LoadRoomOp:
  0097e	b2 ed		 mov	 dl, -19			; ffffffedH
  00980	2a d1		 sub	 dl, cl
  00982	30 94 05 4c f8
	ff ff		 xor	 BYTE PTR ___encStr$511485[ebp+eax], dl
  00989	40		 inc	 eax
  0098a	83 f8 12	 cmp	 eax, 18			; 00000012H
  0098d	7c e0		 jl	 SHORT $LL9685@LoadRoomOp
  0098f	ff b5 d4 ec ff
	ff		 push	 DWORD PTR tv125133[ebp]
  00995	8d 85 4c f8 ff
	ff		 lea	 eax, DWORD PTR ___encStr$511485[ebp]
  0099b	50		 push	 eax
  0099c	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  009a2	50		 push	 eax
  009a3	ff d6		 call	 esi
  009a5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 86   : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  009a8	68 04 01 00 00	 push	 260			; 00000104H
  009ad	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  009b3	50		 push	 eax
  009b4	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  009b9	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  009bf	50		 push	 eax
  009c0	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  009c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 87   : 		pInfo->m_Desc = szBuf;

  009cc	8b 8d d8 ec ff
	ff		 mov	 ecx, DWORD PTR $T540277[ebp]
  009d2	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  009d8	50		 push	 eax
  009d9	83 c1 30	 add	 ecx, 48			; 00000030H
  009dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z
  009e2	6a 05		 push	 5

; 88   : 
; 89   : 		wsprintf_e( szKey, "change_char_ui_desc%d", i+1 );

  009e4	c7 85 04 f6 ff
	ff 8e 84 8a 84	 mov	 DWORD PTR ___encStr$511637[ebp], -2071296882 ; 848a848eH
  009ee	c7 85 08 f6 ff
	ff 8a 89 b4 89	 mov	 DWORD PTR ___encStr$511637[ebp+4], -1984657014 ; 89b4898aH
  009f8	c7 85 0c f6 ff
	ff 85 8d 99 b5	 mov	 DWORD PTR ___encStr$511637[ebp+8], -1248227963 ; b5998d85H
  00a02	c7 85 10 f6 ff
	ff 98 85 b4 8e	 mov	 DWORD PTR ___encStr$511637[ebp+12], -1900771944 ; 8eb48598H
  00a0c	c7 85 14 f6 ff
	ff 88 9f 88 cf	 mov	 DWORD PTR ___encStr$511637[ebp+16], -813129848 ; cf889f88H
  00a16	8d 85 04 f6 ff
	ff		 lea	 eax, DWORD PTR ___encStr$511637[ebp]
  00a1c	66 c7 85 18 f6
	ff ff 89 00	 mov	 WORD PTR ___encStr$511637[ebp+20], 137 ; 00000089H
  00a25	59		 pop	 ecx
$LL9696@LoadRoomOp:
  00a26	31 38		 xor	 DWORD PTR [eax], edi
  00a28	83 c0 04	 add	 eax, 4
  00a2b	49		 dec	 ecx
  00a2c	75 f8		 jne	 SHORT $LL9696@LoadRoomOp
  00a2e	ff b5 d4 ec ff
	ff		 push	 DWORD PTR tv125133[ebp]
  00a34	80 b5 18 f6 ff
	ff ed		 xor	 BYTE PTR ___encStr$511637[ebp+20], -19 ; ffffffedH
  00a3b	8d 85 04 f6 ff
	ff		 lea	 eax, DWORD PTR ___encStr$511637[ebp]
  00a41	50		 push	 eax
  00a42	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  00a48	50		 push	 eax
  00a49	ff d6		 call	 esi
  00a4b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 90   : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  00a4e	68 04 01 00 00	 push	 260			; 00000104H
  00a53	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  00a59	50		 push	 eax
  00a5a	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00a5f	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  00a65	50		 push	 eax
  00a66	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00a6c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 91   : 		pInfo->m_UIDesc = szBuf;

  00a72	8b 8d d8 ec ff
	ff		 mov	 ecx, DWORD PTR $T540277[ebp]
  00a78	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  00a7e	50		 push	 eax
  00a7f	83 c1 40	 add	 ecx, 64			; 00000040H
  00a82	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 92   : 
; 93   : 		m_RoomChangeCharList.push_back( pInfo );

  00a88	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00a8e	8d 85 c8 ec ff
	ff		 lea	 eax, DWORD PTR _pInfo$511323[ebp]
  00a94	50		 push	 eax
  00a95	83 c1 34	 add	 ecx, 52			; 00000034H
  00a98	e8 00 00 00 00	 call	 ?push_back@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXABQAURoomOptionInfo@@@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::push_back
$LN8103@LoadRoomOp:

; 76   : 	for( i=0; i < iTypeCnt; ++i )

  00a9d	ff 85 d4 ec ff
	ff		 inc	 DWORD PTR tv125133[ebp]
  00aa3	ff 8d d0 ec ff
	ff		 dec	 DWORD PTR tv84446[ebp]
  00aa9	0f 85 6c fd ff
	ff		 jne	 $LL8104@LoadRoomOp
$LN8102@LoadRoomOp:

; 94   : 	}
; 95   : 
; 96   : 
; 97   : 	// CoolTimeOption
; 98   : 	kLoader.SetTitle_e( "CoolTimeOption" );

  00aaf	6a 03		 push	 3
  00ab1	c7 85 e8 fb ff
	ff ae 83 84 86	 mov	 DWORD PTR __t$541978[ebp], -2038135890 ; 868483aeH
  00abb	c7 85 ec fb ff
	ff b9 85 86 8f	 mov	 DWORD PTR __t$541978[ebp+4], -1887009351 ; 8f8685b9H
  00ac5	c7 85 f0 fb ff
	ff a2 9c 9f 83	 mov	 DWORD PTR __t$541978[ebp+8], -2086691678 ; 839f9ca2H
  00acf	66 c7 85 f4 fb
	ff ff 82 82	 mov	 WORD PTR __t$541978[ebp+12], 33410 ; 00008282H
  00ad8	8d 85 e8 fb ff
	ff		 lea	 eax, DWORD PTR __t$541978[ebp]
  00ade	88 9d f6 fb ff
	ff		 mov	 BYTE PTR __t$541978[ebp+14], bl
  00ae4	59		 pop	 ecx
$LL9802@LoadRoomOp:
  00ae5	31 38		 xor	 DWORD PTR [eax], edi
  00ae7	83 c0 04	 add	 eax, 4
  00aea	49		 dec	 ecx
  00aeb	75 f8		 jne	 SHORT $LL9802@LoadRoomOp
  00aed	6a 0c		 push	 12			; 0000000cH
  00aef	58		 pop	 eax
$LL9799@LoadRoomOp:
  00af0	8b c8		 mov	 ecx, eax
  00af2	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00af8	79 05		 jns	 SHORT $LN17521@LoadRoomOp
  00afa	49		 dec	 ecx
  00afb	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00afe	41		 inc	 ecx
$LN17521@LoadRoomOp:
  00aff	b2 ed		 mov	 dl, -19			; ffffffedH
  00b01	2a d1		 sub	 dl, cl
  00b03	30 94 05 e8 fb
	ff ff		 xor	 BYTE PTR __t$541978[ebp+eax], dl
  00b0a	40		 inc	 eax
  00b0b	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  00b0e	7c e0		 jl	 SHORT $LL9799@LoadRoomOp
  00b10	8d 85 e8 fb ff
	ff		 lea	 eax, DWORD PTR __t$541978[ebp]
  00b16	50		 push	 eax
  00b17	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00b1d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z
  00b23	6a 04		 push	 4

; 99   : 
; 100  : 	iTypeCnt = kLoader.LoadInt_e( "cooltime_type_cnt", 0 );

  00b25	c7 85 9c f9 ff
	ff 8e 83 84 86	 mov	 DWORD PTR __k$542103[ebp], -2038135922 ; 8684838eH
  00b2f	c7 85 a0 f9 ff
	ff 99 85 86 8f	 mov	 DWORD PTR __k$542103[ebp+4], -1887009383 ; 8f868599H
  00b39	c7 85 a4 f9 ff
	ff b2 98 92 9a	 mov	 DWORD PTR __k$542103[ebp+8], -1701668686 ; 9a9298b2H
  00b43	c7 85 a8 f9 ff
	ff 88 b3 88 84	 mov	 DWORD PTR __k$542103[ebp+12], -2071415928 ; 8488b388H
  00b4d	8d 85 9c f9 ff
	ff		 lea	 eax, DWORD PTR __k$542103[ebp]
  00b53	66 c7 85 ac f9
	ff ff 99 00	 mov	 WORD PTR __k$542103[ebp+16], 153 ; 00000099H
  00b5c	59		 pop	 ecx
$LL9908@LoadRoomOp:
  00b5d	31 38		 xor	 DWORD PTR [eax], edi
  00b5f	83 c0 04	 add	 eax, 4
  00b62	49		 dec	 ecx
  00b63	75 f8		 jne	 SHORT $LL9908@LoadRoomOp
  00b65	80 b5 ac f9 ff
	ff ed		 xor	 BYTE PTR __k$542103[ebp+16], -19 ; ffffffedH
  00b6c	53		 push	 ebx
  00b6d	8d 85 9c f9 ff
	ff		 lea	 eax, DWORD PTR __k$542103[ebp]
  00b73	50		 push	 eax
  00b74	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00b7a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 101  : 	for( i=0; i < iTypeCnt; ++i )

  00b80	3b c3		 cmp	 eax, ebx
  00b82	0f 8e a1 02 00
	00		 jle	 $LN7801@LoadRoomOp

; 99   : 
; 100  : 	iTypeCnt = kLoader.LoadInt_e( "cooltime_type_cnt", 0 );

  00b88	c7 85 d8 ec ff
	ff 01 00 00 00	 mov	 DWORD PTR tv125242[ebp], 1
  00b92	89 85 d0 ec ff
	ff		 mov	 DWORD PTR tv82363[ebp], eax
$LL7803@LoadRoomOp:

; 102  : 	{
; 103  : 		RoomOptionInfo *pInfo = new RoomOptionInfo;

  00b98	6a 50		 push	 80			; 00000050H
  00b9a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00b9f	59		 pop	 ecx
  00ba0	89 85 c4 ec ff
	ff		 mov	 DWORD PTR $T540282[ebp], eax
  00ba6	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00baa	3b c3		 cmp	 eax, ebx
  00bac	74 0f		 je	 SHORT $LN8415@LoadRoomOp
  00bae	8b c8		 mov	 ecx, eax
  00bb0	e8 00 00 00 00	 call	 ??0RoomOptionInfo@@QAE@XZ ; RoomOptionInfo::RoomOptionInfo
  00bb5	89 85 d4 ec ff
	ff		 mov	 DWORD PTR $T540281[ebp], eax
  00bbb	eb 06		 jmp	 SHORT $LN8416@LoadRoomOp
$LN8415@LoadRoomOp:
  00bbd	89 9d d4 ec ff
	ff		 mov	 DWORD PTR $T540281[ebp], ebx
$LN8416@LoadRoomOp:
  00bc3	8b 85 d4 ec ff
	ff		 mov	 eax, DWORD PTR $T540281[ebp]
  00bc9	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  00bcc	89 85 c8 ec ff
	ff		 mov	 DWORD PTR _pInfo$511798[ebp], eax

; 104  : 		if( !pInfo )

  00bd2	3b c3		 cmp	 eax, ebx
  00bd4	0f 84 3d 02 00
	00		 je	 $LN7802@LoadRoomOp

; 105  : 			continue;
; 106  : 
; 107  : 		wsprintf_e( szKey, "cooltime_rate%d", i+1 );

  00bda	6a 03		 push	 3
  00bdc	c7 85 5c fb ff
	ff 8e 83 84 86	 mov	 DWORD PTR ___encStr$511807[ebp], -2038135922 ; 8684838eH
  00be6	c7 85 60 fb ff
	ff 99 85 86 8f	 mov	 DWORD PTR ___encStr$511807[ebp+4], -1887009383 ; 8f868599H
  00bf0	c7 85 64 fb ff
	ff b2 9e 8a 9e	 mov	 DWORD PTR ___encStr$511807[ebp+8], -1635082574 ; 9e8a9eb2H
  00bfa	8d 85 5c fb ff
	ff		 lea	 eax, DWORD PTR ___encStr$511807[ebp]
  00c00	c7 85 68 fb ff
	ff 88 c9 8f 00	 mov	 DWORD PTR ___encStr$511807[ebp+12], 9423240 ; 008fc988H
  00c0a	59		 pop	 ecx
$LL9916@LoadRoomOp:
  00c0b	31 38		 xor	 DWORD PTR [eax], edi
  00c0d	83 c0 04	 add	 eax, 4
  00c10	49		 dec	 ecx
  00c11	75 f8		 jne	 SHORT $LL9916@LoadRoomOp
  00c13	6a 0c		 push	 12			; 0000000cH
  00c15	58		 pop	 eax
$LL9913@LoadRoomOp:
  00c16	8b c8		 mov	 ecx, eax
  00c18	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00c1e	79 05		 jns	 SHORT $LN17522@LoadRoomOp
  00c20	49		 dec	 ecx
  00c21	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00c24	41		 inc	 ecx
$LN17522@LoadRoomOp:
  00c25	b2 ed		 mov	 dl, -19			; ffffffedH
  00c27	2a d1		 sub	 dl, cl
  00c29	30 94 05 5c fb
	ff ff		 xor	 BYTE PTR ___encStr$511807[ebp+eax], dl
  00c30	40		 inc	 eax
  00c31	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00c34	7c e0		 jl	 SHORT $LL9913@LoadRoomOp
  00c36	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv125242[ebp]
  00c3c	8d 85 5c fb ff
	ff		 lea	 eax, DWORD PTR ___encStr$511807[ebp]
  00c42	50		 push	 eax
  00c43	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  00c49	50		 push	 eax
  00c4a	ff d6		 call	 esi
  00c4c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 108  : 		pInfo->m_fValue = kLoader.LoadFloat( szKey, FLOAT1 );

  00c4f	b8 01 00 00 00	 mov	 eax, 1
  00c54	89 85 c4 ec ff
	ff		 mov	 DWORD PTR tv127168[ebp], eax
  00c5a	db 85 c4 ec ff
	ff		 fild	 DWORD PTR tv127168[ebp]
  00c60	85 c0		 test	 eax, eax
  00c62	79 06		 jns	 SHORT $LN17523@LoadRoomOp
  00c64	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN17523@LoadRoomOp:
  00c6a	51		 push	 ecx
  00c6b	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  00c71	d9 1c 24	 fstp	 DWORD PTR [esp]
  00c74	50		 push	 eax
  00c75	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00c7b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z
  00c81	51		 push	 ecx
  00c82	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540281[ebp]
  00c88	d9 1c 24	 fstp	 DWORD PTR [esp]
  00c8b	e8 00 00 00 00	 call	 ??4?$CEncrypt@M@@QAEMM@Z ; CEncrypt<float>::operator=
  00c90	dd d8		 fstp	 ST(0)
  00c92	6a 03		 push	 3

; 109  : 
; 110  : 		wsprintf_e( szKey, "cooltime_desc%d", i+1 );

  00c94	c7 85 70 fb ff
	ff 8e 83 84 86	 mov	 DWORD PTR ___encStr$511960[ebp], -2038135922 ; 8684838eH
  00c9e	c7 85 74 fb ff
	ff 99 85 86 8f	 mov	 DWORD PTR ___encStr$511960[ebp+4], -1887009383 ; 8f868599H
  00ca8	c7 85 78 fb ff
	ff b2 88 8e 99	 mov	 DWORD PTR ___encStr$511960[ebp+8], -1718712142 ; 998e88b2H
  00cb2	8d 85 70 fb ff
	ff		 lea	 eax, DWORD PTR ___encStr$511960[ebp]
  00cb8	c7 85 7c fb ff
	ff 8e c9 8f 00	 mov	 DWORD PTR ___encStr$511960[ebp+12], 9423246 ; 008fc98eH
  00cc2	59		 pop	 ecx
$LL9926@LoadRoomOp:
  00cc3	31 38		 xor	 DWORD PTR [eax], edi
  00cc5	83 c0 04	 add	 eax, 4
  00cc8	49		 dec	 ecx
  00cc9	75 f8		 jne	 SHORT $LL9926@LoadRoomOp
  00ccb	6a 0c		 push	 12			; 0000000cH
  00ccd	58		 pop	 eax
$LL9923@LoadRoomOp:
  00cce	8b c8		 mov	 ecx, eax
  00cd0	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00cd6	79 05		 jns	 SHORT $LN17524@LoadRoomOp
  00cd8	49		 dec	 ecx
  00cd9	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00cdc	41		 inc	 ecx
$LN17524@LoadRoomOp:
  00cdd	b2 ed		 mov	 dl, -19			; ffffffedH
  00cdf	2a d1		 sub	 dl, cl
  00ce1	30 94 05 70 fb
	ff ff		 xor	 BYTE PTR ___encStr$511960[ebp+eax], dl
  00ce8	40		 inc	 eax
  00ce9	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00cec	7c e0		 jl	 SHORT $LL9923@LoadRoomOp
  00cee	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv125242[ebp]
  00cf4	8d 85 70 fb ff
	ff		 lea	 eax, DWORD PTR ___encStr$511960[ebp]
  00cfa	50		 push	 eax
  00cfb	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  00d01	50		 push	 eax
  00d02	ff d6		 call	 esi
  00d04	83 c4 0c	 add	 esp, 12			; 0000000cH

; 111  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  00d07	68 04 01 00 00	 push	 260			; 00000104H
  00d0c	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  00d12	50		 push	 eax
  00d13	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00d18	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  00d1e	50		 push	 eax
  00d1f	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00d25	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 112  : 		pInfo->m_Desc = szBuf;

  00d2b	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540281[ebp]
  00d31	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  00d37	50		 push	 eax
  00d38	83 c1 30	 add	 ecx, 48			; 00000030H
  00d3b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z
  00d41	6a 04		 push	 4

; 113  : 
; 114  : 		wsprintf_e( szKey, "cooltime_ui_desc%d", i+1 );

  00d43	c7 85 64 f8 ff
	ff 8e 83 84 86	 mov	 DWORD PTR ___encStr$512112[ebp], -2038135922 ; 8684838eH
  00d4d	c7 85 68 f8 ff
	ff 99 85 86 8f	 mov	 DWORD PTR ___encStr$512112[ebp+4], -1887009383 ; 8f868599H
  00d57	c7 85 6c f8 ff
	ff b2 99 82 b5	 mov	 DWORD PTR ___encStr$512112[ebp+8], -1249732174 ; b58299b2H
  00d61	c7 85 70 f8 ff
	ff 89 89 98 89	 mov	 DWORD PTR ___encStr$512112[ebp+12], -1986492023 ; 89988989H
  00d6b	66 c7 85 74 f8
	ff ff c8 88	 mov	 WORD PTR ___encStr$512112[ebp+16], 35016 ; 000088c8H
  00d74	8d 85 64 f8 ff
	ff		 lea	 eax, DWORD PTR ___encStr$512112[ebp]
  00d7a	88 9d 76 f8 ff
	ff		 mov	 BYTE PTR ___encStr$512112[ebp+18], bl
  00d80	59		 pop	 ecx
$LL9934@LoadRoomOp:
  00d81	31 38		 xor	 DWORD PTR [eax], edi
  00d83	83 c0 04	 add	 eax, 4
  00d86	49		 dec	 ecx
  00d87	75 f8		 jne	 SHORT $LL9934@LoadRoomOp
  00d89	6a 10		 push	 16			; 00000010H
  00d8b	58		 pop	 eax
$LL9931@LoadRoomOp:
  00d8c	8b c8		 mov	 ecx, eax
  00d8e	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00d94	79 05		 jns	 SHORT $LN17525@LoadRoomOp
  00d96	49		 dec	 ecx
  00d97	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00d9a	41		 inc	 ecx
$LN17525@LoadRoomOp:
  00d9b	b2 ed		 mov	 dl, -19			; ffffffedH
  00d9d	2a d1		 sub	 dl, cl
  00d9f	30 94 05 64 f8
	ff ff		 xor	 BYTE PTR ___encStr$512112[ebp+eax], dl
  00da6	40		 inc	 eax
  00da7	83 f8 12	 cmp	 eax, 18			; 00000012H
  00daa	7c e0		 jl	 SHORT $LL9931@LoadRoomOp
  00dac	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv125242[ebp]
  00db2	8d 85 64 f8 ff
	ff		 lea	 eax, DWORD PTR ___encStr$512112[ebp]
  00db8	50		 push	 eax
  00db9	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  00dbf	50		 push	 eax
  00dc0	ff d6		 call	 esi
  00dc2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 115  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  00dc5	68 04 01 00 00	 push	 260			; 00000104H
  00dca	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  00dd0	50		 push	 eax
  00dd1	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00dd6	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  00ddc	50		 push	 eax
  00ddd	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00de3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 116  : 		pInfo->m_UIDesc = szBuf;

  00de9	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540281[ebp]
  00def	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  00df5	50		 push	 eax
  00df6	83 c1 40	 add	 ecx, 64			; 00000040H
  00df9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 117  : 
; 118  : 		m_RoomCoolTimeList.push_back( pInfo );

  00dff	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00e05	8d 85 c8 ec ff
	ff		 lea	 eax, DWORD PTR _pInfo$511798[ebp]
  00e0b	50		 push	 eax
  00e0c	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  00e12	e8 00 00 00 00	 call	 ?push_back@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXABQAURoomOptionInfo@@@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::push_back
$LN7802@LoadRoomOp:

; 101  : 	for( i=0; i < iTypeCnt; ++i )

  00e17	ff 85 d8 ec ff
	ff		 inc	 DWORD PTR tv125242[ebp]
  00e1d	ff 8d d0 ec ff
	ff		 dec	 DWORD PTR tv82363[ebp]
  00e23	0f 85 6f fd ff
	ff		 jne	 $LL7803@LoadRoomOp
$LN7801@LoadRoomOp:

; 119  : 	}
; 120  : 
; 121  : 	// RedHPOption
; 122  : 	kLoader.SetTitle_e( "RedHPOption" );

  00e29	6a 02		 push	 2
  00e2b	c7 85 84 fe ff
	ff bf 89 8f a2	 mov	 DWORD PTR __t$542268[ebp], -1567651393 ; a28f89bfH
  00e35	c7 85 88 fe ff
	ff bd a3 9b 9e	 mov	 DWORD PTR __t$542268[ebp+4], -1633967171 ; 9e9ba3bdH
  00e3f	8d 85 84 fe ff
	ff		 lea	 eax, DWORD PTR __t$542268[ebp]
  00e45	c7 85 8c fe ff
	ff 84 83 85 00	 mov	 DWORD PTR __t$542268[ebp+8], 8749956 ; 00858384H
  00e4f	59		 pop	 ecx
$LL10040@LoadRoomOp:
  00e50	31 38		 xor	 DWORD PTR [eax], edi
  00e52	83 c0 04	 add	 eax, 4
  00e55	49		 dec	 ecx
  00e56	75 f8		 jne	 SHORT $LL10040@LoadRoomOp
  00e58	6a 08		 push	 8
  00e5a	58		 pop	 eax
$LL10037@LoadRoomOp:
  00e5b	8b c8		 mov	 ecx, eax
  00e5d	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00e63	79 05		 jns	 SHORT $LN17526@LoadRoomOp
  00e65	49		 dec	 ecx
  00e66	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00e69	41		 inc	 ecx
$LN17526@LoadRoomOp:
  00e6a	b2 ed		 mov	 dl, -19			; ffffffedH
  00e6c	2a d1		 sub	 dl, cl
  00e6e	30 94 05 84 fe
	ff ff		 xor	 BYTE PTR __t$542268[ebp+eax], dl
  00e75	40		 inc	 eax
  00e76	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00e79	7c e0		 jl	 SHORT $LL10037@LoadRoomOp
  00e7b	8d 85 84 fe ff
	ff		 lea	 eax, DWORD PTR __t$542268[ebp]
  00e81	50		 push	 eax
  00e82	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00e88	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z
  00e8e	6a 02		 push	 2

; 123  : 
; 124  : 	iTypeCnt = kLoader.LoadInt_e( "hp_type_cnt", 0 );

  00e90	c7 85 54 fe ff
	ff 85 9c b4 9e	 mov	 DWORD PTR __k$542393[ebp], -1632330619 ; 9eb49c85H
  00e9a	c7 85 58 fe ff
	ff 94 9c 8e b5	 mov	 DWORD PTR __k$542393[ebp+4], -1248945004 ; b58e9c94H
  00ea4	8d 85 54 fe ff
	ff		 lea	 eax, DWORD PTR __k$542393[ebp]
  00eaa	c7 85 5c fe ff
	ff 8e 82 9f 00	 mov	 DWORD PTR __k$542393[ebp+8], 10453646 ; 009f828eH
  00eb4	59		 pop	 ecx
$LL10146@LoadRoomOp:
  00eb5	31 38		 xor	 DWORD PTR [eax], edi
  00eb7	83 c0 04	 add	 eax, 4
  00eba	49		 dec	 ecx
  00ebb	75 f8		 jne	 SHORT $LL10146@LoadRoomOp
  00ebd	6a 08		 push	 8
  00ebf	58		 pop	 eax
$LL10143@LoadRoomOp:
  00ec0	8b c8		 mov	 ecx, eax
  00ec2	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00ec8	79 05		 jns	 SHORT $LN17527@LoadRoomOp
  00eca	49		 dec	 ecx
  00ecb	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00ece	41		 inc	 ecx
$LN17527@LoadRoomOp:
  00ecf	b2 ed		 mov	 dl, -19			; ffffffedH
  00ed1	2a d1		 sub	 dl, cl
  00ed3	30 94 05 54 fe
	ff ff		 xor	 BYTE PTR __k$542393[ebp+eax], dl
  00eda	40		 inc	 eax
  00edb	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00ede	7c e0		 jl	 SHORT $LL10143@LoadRoomOp
  00ee0	53		 push	 ebx
  00ee1	8d 85 54 fe ff
	ff		 lea	 eax, DWORD PTR __k$542393[ebp]
  00ee7	50		 push	 eax
  00ee8	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00eee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 125  : 	for( i=0; i < iTypeCnt; ++i )

  00ef4	3b c3		 cmp	 eax, ebx
  00ef6	0f 8e 08 02 00
	00		 jle	 $LN7500@LoadRoomOp

; 123  : 
; 124  : 	iTypeCnt = kLoader.LoadInt_e( "hp_type_cnt", 0 );

  00efc	c7 85 d8 ec ff
	ff 01 00 00 00	 mov	 DWORD PTR tv125333[ebp], 1
  00f06	89 85 d0 ec ff
	ff		 mov	 DWORD PTR tv80493[ebp], eax
$LL7502@LoadRoomOp:

; 126  : 	{
; 127  : 		RoomOptionInfo *pInfo = new RoomOptionInfo;

  00f0c	6a 50		 push	 80			; 00000050H
  00f0e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00f13	59		 pop	 ecx
  00f14	89 85 c4 ec ff
	ff		 mov	 DWORD PTR $T540286[ebp], eax
  00f1a	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00f1e	3b c3		 cmp	 eax, ebx
  00f20	74 0f		 je	 SHORT $LN8417@LoadRoomOp
  00f22	8b c8		 mov	 ecx, eax
  00f24	e8 00 00 00 00	 call	 ??0RoomOptionInfo@@QAE@XZ ; RoomOptionInfo::RoomOptionInfo
  00f29	89 85 d4 ec ff
	ff		 mov	 DWORD PTR $T540285[ebp], eax
  00f2f	eb 06		 jmp	 SHORT $LN8418@LoadRoomOp
$LN8417@LoadRoomOp:
  00f31	89 9d d4 ec ff
	ff		 mov	 DWORD PTR $T540285[ebp], ebx
$LN8418@LoadRoomOp:
  00f37	8b 85 d4 ec ff
	ff		 mov	 eax, DWORD PTR $T540285[ebp]
  00f3d	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  00f40	89 85 c8 ec ff
	ff		 mov	 DWORD PTR _pInfo$512273[ebp], eax

; 128  : 		if( !pInfo )

  00f46	3b c3		 cmp	 eax, ebx
  00f48	0f 84 a4 01 00
	00		 je	 $LN7501@LoadRoomOp

; 129  : 			continue;
; 130  : 
; 131  : 		wsprintf_e( szKey, "hp_rate%d", i+1 );

  00f4e	6a 02		 push	 2
  00f50	c7 45 94 85 9c
	b4 98		 mov	 DWORD PTR ___encStr$512282[ebp], -1732993915 ; 98b49c85H
  00f57	c7 45 98 8c 98
	8e cf		 mov	 DWORD PTR ___encStr$512282[ebp+4], -812738420 ; cf8e988cH
  00f5e	8d 45 94	 lea	 eax, DWORD PTR ___encStr$512282[ebp]
  00f61	66 c7 45 9c 89
	00		 mov	 WORD PTR ___encStr$512282[ebp+8], 137 ; 00000089H
  00f67	59		 pop	 ecx
$LL10154@LoadRoomOp:
  00f68	31 38		 xor	 DWORD PTR [eax], edi
  00f6a	83 c0 04	 add	 eax, 4
  00f6d	49		 dec	 ecx
  00f6e	75 f8		 jne	 SHORT $LL10154@LoadRoomOp
  00f70	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv125333[ebp]
  00f76	80 75 9c ed	 xor	 BYTE PTR ___encStr$512282[ebp+8], -19 ; ffffffedH
  00f7a	8d 45 94	 lea	 eax, DWORD PTR ___encStr$512282[ebp]
  00f7d	50		 push	 eax
  00f7e	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  00f84	50		 push	 eax
  00f85	ff d6		 call	 esi
  00f87	83 c4 0c	 add	 esp, 12			; 0000000cH

; 132  : 		pInfo->m_fValue = kLoader.LoadFloat( szKey, FLOAT1 );

  00f8a	b8 01 00 00 00	 mov	 eax, 1
  00f8f	89 85 c4 ec ff
	ff		 mov	 DWORD PTR tv127132[ebp], eax
  00f95	db 85 c4 ec ff
	ff		 fild	 DWORD PTR tv127132[ebp]
  00f9b	85 c0		 test	 eax, eax
  00f9d	79 06		 jns	 SHORT $LN17528@LoadRoomOp
  00f9f	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN17528@LoadRoomOp:
  00fa5	51		 push	 ecx
  00fa6	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  00fac	d9 1c 24	 fstp	 DWORD PTR [esp]
  00faf	50		 push	 eax
  00fb0	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00fb6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z
  00fbc	51		 push	 ecx
  00fbd	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540285[ebp]
  00fc3	d9 1c 24	 fstp	 DWORD PTR [esp]
  00fc6	e8 00 00 00 00	 call	 ??4?$CEncrypt@M@@QAEMM@Z ; CEncrypt<float>::operator=
  00fcb	dd d8		 fstp	 ST(0)
  00fcd	6a 02		 push	 2

; 133  : 
; 134  : 		wsprintf_e( szKey, "hp_desc%d", i+1 );

  00fcf	c7 85 44 ff ff
	ff 85 9c b4 8e	 mov	 DWORD PTR ___encStr$512435[ebp], -1900766075 ; 8eb49c85H
  00fd9	c7 85 48 ff ff
	ff 88 9f 88 cf	 mov	 DWORD PTR ___encStr$512435[ebp+4], -813129848 ; cf889f88H
  00fe3	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR ___encStr$512435[ebp]
  00fe9	66 c7 85 4c ff
	ff ff 89 00	 mov	 WORD PTR ___encStr$512435[ebp+8], 137 ; 00000089H
  00ff2	59		 pop	 ecx
$LL10164@LoadRoomOp:
  00ff3	31 38		 xor	 DWORD PTR [eax], edi
  00ff5	83 c0 04	 add	 eax, 4
  00ff8	49		 dec	 ecx
  00ff9	75 f8		 jne	 SHORT $LL10164@LoadRoomOp
  00ffb	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv125333[ebp]
  01001	80 b5 4c ff ff
	ff ed		 xor	 BYTE PTR ___encStr$512435[ebp+8], -19 ; ffffffedH
  01008	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR ___encStr$512435[ebp]
  0100e	50		 push	 eax
  0100f	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  01015	50		 push	 eax
  01016	ff d6		 call	 esi
  01018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 135  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  0101b	68 04 01 00 00	 push	 260			; 00000104H
  01020	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  01026	50		 push	 eax
  01027	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0102c	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  01032	50		 push	 eax
  01033	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 136  : 		pInfo->m_Desc = szBuf;

  0103f	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540285[ebp]
  01045	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  0104b	50		 push	 eax
  0104c	83 c1 30	 add	 ecx, 48			; 00000030H
  0104f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z
  01055	6a 03		 push	 3

; 137  : 
; 138  : 		wsprintf_e( szKey, "hp_ui_desc%d", i+1 );

  01057	c7 85 b4 fd ff
	ff 85 9c b4 9f	 mov	 DWORD PTR ___encStr$512587[ebp], -1615553403 ; 9fb49c85H
  01061	c7 85 b8 fd ff
	ff 84 b3 8f 8f	 mov	 DWORD PTR ___encStr$512587[ebp+4], -1886407804 ; 8f8fb384H
  0106b	c7 85 bc fd ff
	ff 9e 8f ce 8e	 mov	 DWORD PTR ___encStr$512587[ebp+8], -1899065442 ; 8ece8f9eH
  01075	8d 85 b4 fd ff
	ff		 lea	 eax, DWORD PTR ___encStr$512587[ebp]
  0107b	88 9d c0 fd ff
	ff		 mov	 BYTE PTR ___encStr$512587[ebp+12], bl
  01081	59		 pop	 ecx
$LL10172@LoadRoomOp:
  01082	31 38		 xor	 DWORD PTR [eax], edi
  01084	83 c0 04	 add	 eax, 4
  01087	49		 dec	 ecx
  01088	75 f8		 jne	 SHORT $LL10172@LoadRoomOp
  0108a	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv125333[ebp]
  01090	8d 85 b4 fd ff
	ff		 lea	 eax, DWORD PTR ___encStr$512587[ebp]
  01096	50		 push	 eax
  01097	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  0109d	50		 push	 eax
  0109e	ff d6		 call	 esi
  010a0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 139  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  010a3	68 04 01 00 00	 push	 260			; 00000104H
  010a8	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  010ae	50		 push	 eax
  010af	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  010b4	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  010ba	50		 push	 eax
  010bb	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  010c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 140  : 		pInfo->m_UIDesc = szBuf;

  010c7	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540285[ebp]
  010cd	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  010d3	50		 push	 eax
  010d4	83 c1 40	 add	 ecx, 64			; 00000040H
  010d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 141  : 
; 142  : 		m_RoomRedHPList.push_back( pInfo );

  010dd	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  010e3	8d 85 c8 ec ff
	ff		 lea	 eax, DWORD PTR _pInfo$512273[ebp]
  010e9	50		 push	 eax
  010ea	83 c1 44	 add	 ecx, 68			; 00000044H
  010ed	e8 00 00 00 00	 call	 ?push_back@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXABQAURoomOptionInfo@@@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::push_back
$LN7501@LoadRoomOp:

; 125  : 	for( i=0; i < iTypeCnt; ++i )

  010f2	ff 85 d8 ec ff
	ff		 inc	 DWORD PTR tv125333[ebp]
  010f8	ff 8d d0 ec ff
	ff		 dec	 DWORD PTR tv80493[ebp]
  010fe	0f 85 08 fe ff
	ff		 jne	 $LL7502@LoadRoomOp
$LN7500@LoadRoomOp:

; 143  : 	}
; 144  : 
; 145  : 	// BlueHPOption
; 146  : 	kLoader.SetTitle_e( "BlueHPOption" );

  01104	6a 03		 push	 3
  01106	c7 85 dc fd ff
	ff af 80 9e 8f	 mov	 DWORD PTR __t$542585[ebp], -1885437777 ; 8f9e80afH
  01110	c7 85 e0 fd ff
	ff a5 bc a4 9a	 mov	 DWORD PTR __t$542585[ebp+4], -1700479835 ; 9aa4bca5H
  0111a	c7 85 e4 fd ff
	ff 99 85 84 84	 mov	 DWORD PTR __t$542585[ebp+8], -2071689831 ; 84848599H
  01124	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR __t$542585[ebp]
  0112a	88 9d e8 fd ff
	ff		 mov	 BYTE PTR __t$542585[ebp+12], bl
  01130	59		 pop	 ecx
$LL10278@LoadRoomOp:
  01131	31 38		 xor	 DWORD PTR [eax], edi
  01133	83 c0 04	 add	 eax, 4
  01136	49		 dec	 ecx
  01137	75 f8		 jne	 SHORT $LL10278@LoadRoomOp
  01139	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR __t$542585[ebp]
  0113f	50		 push	 eax
  01140	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01146	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z
  0114c	6a 02		 push	 2

; 147  : 
; 148  : 	iTypeCnt = kLoader.LoadInt_e( "hp_type_cnt", 0 );

  0114e	c7 85 74 fe ff
	ff 85 9c b4 9e	 mov	 DWORD PTR __k$542670[ebp], -1632330619 ; 9eb49c85H
  01158	c7 85 78 fe ff
	ff 94 9c 8e b5	 mov	 DWORD PTR __k$542670[ebp+4], -1248945004 ; b58e9c94H
  01162	8d 85 74 fe ff
	ff		 lea	 eax, DWORD PTR __k$542670[ebp]
  01168	c7 85 7c fe ff
	ff 8e 82 9f 00	 mov	 DWORD PTR __k$542670[ebp+8], 10453646 ; 009f828eH
  01172	59		 pop	 ecx
$LL10384@LoadRoomOp:
  01173	31 38		 xor	 DWORD PTR [eax], edi
  01175	83 c0 04	 add	 eax, 4
  01178	49		 dec	 ecx
  01179	75 f8		 jne	 SHORT $LL10384@LoadRoomOp
  0117b	6a 08		 push	 8
  0117d	58		 pop	 eax
$LL10381@LoadRoomOp:
  0117e	8b c8		 mov	 ecx, eax
  01180	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  01186	79 05		 jns	 SHORT $LN17529@LoadRoomOp
  01188	49		 dec	 ecx
  01189	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0118c	41		 inc	 ecx
$LN17529@LoadRoomOp:
  0118d	b2 ed		 mov	 dl, -19			; ffffffedH
  0118f	2a d1		 sub	 dl, cl
  01191	30 94 05 74 fe
	ff ff		 xor	 BYTE PTR __k$542670[ebp+eax], dl
  01198	40		 inc	 eax
  01199	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0119c	7c e0		 jl	 SHORT $LL10381@LoadRoomOp
  0119e	53		 push	 ebx
  0119f	8d 85 74 fe ff
	ff		 lea	 eax, DWORD PTR __k$542670[ebp]
  011a5	50		 push	 eax
  011a6	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  011ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 149  : 	for( i=0; i < iTypeCnt; ++i )

  011b2	3b c3		 cmp	 eax, ebx
  011b4	0f 8e 08 02 00
	00		 jle	 $LN7199@LoadRoomOp

; 147  : 
; 148  : 	iTypeCnt = kLoader.LoadInt_e( "hp_type_cnt", 0 );

  011ba	c7 85 d8 ec ff
	ff 01 00 00 00	 mov	 DWORD PTR tv125408[ebp], 1
  011c4	89 85 d0 ec ff
	ff		 mov	 DWORD PTR tv78822[ebp], eax
$LL7201@LoadRoomOp:

; 150  : 	{
; 151  : 		RoomOptionInfo *pInfo = new RoomOptionInfo;

  011ca	6a 50		 push	 80			; 00000050H
  011cc	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  011d1	59		 pop	 ecx
  011d2	89 85 c4 ec ff
	ff		 mov	 DWORD PTR $T540290[ebp], eax
  011d8	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  011dc	3b c3		 cmp	 eax, ebx
  011de	74 0f		 je	 SHORT $LN8419@LoadRoomOp
  011e0	8b c8		 mov	 ecx, eax
  011e2	e8 00 00 00 00	 call	 ??0RoomOptionInfo@@QAE@XZ ; RoomOptionInfo::RoomOptionInfo
  011e7	89 85 d4 ec ff
	ff		 mov	 DWORD PTR $T540289[ebp], eax
  011ed	eb 06		 jmp	 SHORT $LN8420@LoadRoomOp
$LN8419@LoadRoomOp:
  011ef	89 9d d4 ec ff
	ff		 mov	 DWORD PTR $T540289[ebp], ebx
$LN8420@LoadRoomOp:
  011f5	8b 85 d4 ec ff
	ff		 mov	 eax, DWORD PTR $T540289[ebp]
  011fb	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  011fe	89 85 c8 ec ff
	ff		 mov	 DWORD PTR _pInfo$512743[ebp], eax

; 152  : 		if( !pInfo )

  01204	3b c3		 cmp	 eax, ebx
  01206	0f 84 a4 01 00
	00		 je	 $LN7200@LoadRoomOp

; 153  : 			continue;
; 154  : 
; 155  : 		wsprintf_e( szKey, "hp_rate%d", i+1 );

  0120c	6a 02		 push	 2
  0120e	c7 85 64 ff ff
	ff 85 9c b4 98	 mov	 DWORD PTR ___encStr$512752[ebp], -1732993915 ; 98b49c85H
  01218	c7 85 68 ff ff
	ff 8c 98 8e cf	 mov	 DWORD PTR ___encStr$512752[ebp+4], -812738420 ; cf8e988cH
  01222	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR ___encStr$512752[ebp]
  01228	66 c7 85 6c ff
	ff ff 89 00	 mov	 WORD PTR ___encStr$512752[ebp+8], 137 ; 00000089H
  01231	59		 pop	 ecx
$LL10392@LoadRoomOp:
  01232	31 38		 xor	 DWORD PTR [eax], edi
  01234	83 c0 04	 add	 eax, 4
  01237	49		 dec	 ecx
  01238	75 f8		 jne	 SHORT $LL10392@LoadRoomOp
  0123a	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv125408[ebp]
  01240	80 b5 6c ff ff
	ff ed		 xor	 BYTE PTR ___encStr$512752[ebp+8], -19 ; ffffffedH
  01247	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR ___encStr$512752[ebp]
  0124d	50		 push	 eax
  0124e	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  01254	50		 push	 eax
  01255	ff d6		 call	 esi
  01257	83 c4 0c	 add	 esp, 12			; 0000000cH

; 156  : 		pInfo->m_fValue = kLoader.LoadFloat( szKey, FLOAT1 );

  0125a	b8 01 00 00 00	 mov	 eax, 1
  0125f	89 85 c4 ec ff
	ff		 mov	 DWORD PTR tv127102[ebp], eax
  01265	db 85 c4 ec ff
	ff		 fild	 DWORD PTR tv127102[ebp]
  0126b	85 c0		 test	 eax, eax
  0126d	79 06		 jns	 SHORT $LN17530@LoadRoomOp
  0126f	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN17530@LoadRoomOp:
  01275	51		 push	 ecx
  01276	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  0127c	d9 1c 24	 fstp	 DWORD PTR [esp]
  0127f	50		 push	 eax
  01280	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01286	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z
  0128c	51		 push	 ecx
  0128d	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540289[ebp]
  01293	d9 1c 24	 fstp	 DWORD PTR [esp]
  01296	e8 00 00 00 00	 call	 ??4?$CEncrypt@M@@QAEMM@Z ; CEncrypt<float>::operator=
  0129b	dd d8		 fstp	 ST(0)
  0129d	6a 02		 push	 2

; 157  : 
; 158  : 		wsprintf_e( szKey, "hp_desc%d", i+1 );

  0129f	c7 45 84 85 9c
	b4 8e		 mov	 DWORD PTR ___encStr$512904[ebp], -1900766075 ; 8eb49c85H
  012a6	c7 45 88 88 9f
	88 cf		 mov	 DWORD PTR ___encStr$512904[ebp+4], -813129848 ; cf889f88H
  012ad	8d 45 84	 lea	 eax, DWORD PTR ___encStr$512904[ebp]
  012b0	66 c7 45 8c 89
	00		 mov	 WORD PTR ___encStr$512904[ebp+8], 137 ; 00000089H
  012b6	59		 pop	 ecx
$LL10402@LoadRoomOp:
  012b7	31 38		 xor	 DWORD PTR [eax], edi
  012b9	83 c0 04	 add	 eax, 4
  012bc	49		 dec	 ecx
  012bd	75 f8		 jne	 SHORT $LL10402@LoadRoomOp
  012bf	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv125408[ebp]
  012c5	80 75 8c ed	 xor	 BYTE PTR ___encStr$512904[ebp+8], -19 ; ffffffedH
  012c9	8d 45 84	 lea	 eax, DWORD PTR ___encStr$512904[ebp]
  012cc	50		 push	 eax
  012cd	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  012d3	50		 push	 eax
  012d4	ff d6		 call	 esi
  012d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 159  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  012d9	68 04 01 00 00	 push	 260			; 00000104H
  012de	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  012e4	50		 push	 eax
  012e5	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  012ea	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  012f0	50		 push	 eax
  012f1	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  012f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 160  : 		pInfo->m_Desc = szBuf;

  012fd	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540289[ebp]
  01303	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  01309	50		 push	 eax
  0130a	83 c1 30	 add	 ecx, 48			; 00000030H
  0130d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z
  01313	6a 03		 push	 3

; 161  : 
; 162  : 		wsprintf_e( szKey, "hp_ui_desc%d", i+1 );

  01315	c7 85 04 fe ff
	ff 85 9c b4 9f	 mov	 DWORD PTR ___encStr$513055[ebp], -1615553403 ; 9fb49c85H
  0131f	c7 85 08 fe ff
	ff 84 b3 8f 8f	 mov	 DWORD PTR ___encStr$513055[ebp+4], -1886407804 ; 8f8fb384H
  01329	c7 85 0c fe ff
	ff 9e 8f ce 8e	 mov	 DWORD PTR ___encStr$513055[ebp+8], -1899065442 ; 8ece8f9eH
  01333	8d 85 04 fe ff
	ff		 lea	 eax, DWORD PTR ___encStr$513055[ebp]
  01339	88 9d 10 fe ff
	ff		 mov	 BYTE PTR ___encStr$513055[ebp+12], bl
  0133f	59		 pop	 ecx
$LL10410@LoadRoomOp:
  01340	31 38		 xor	 DWORD PTR [eax], edi
  01342	83 c0 04	 add	 eax, 4
  01345	49		 dec	 ecx
  01346	75 f8		 jne	 SHORT $LL10410@LoadRoomOp
  01348	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv125408[ebp]
  0134e	8d 85 04 fe ff
	ff		 lea	 eax, DWORD PTR ___encStr$513055[ebp]
  01354	50		 push	 eax
  01355	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  0135b	50		 push	 eax
  0135c	ff d6		 call	 esi
  0135e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 163  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  01361	68 04 01 00 00	 push	 260			; 00000104H
  01366	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  0136c	50		 push	 eax
  0136d	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  01372	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  01378	50		 push	 eax
  01379	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0137f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 164  : 		pInfo->m_UIDesc = szBuf;

  01385	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540289[ebp]
  0138b	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  01391	50		 push	 eax
  01392	83 c1 40	 add	 ecx, 64			; 00000040H
  01395	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 165  : 
; 166  : 		m_RoomBlueHPList.push_back( pInfo );

  0139b	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  013a1	8d 85 c8 ec ff
	ff		 lea	 eax, DWORD PTR _pInfo$512743[ebp]
  013a7	50		 push	 eax
  013a8	83 c1 54	 add	 ecx, 84			; 00000054H
  013ab	e8 00 00 00 00	 call	 ?push_back@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXABQAURoomOptionInfo@@@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::push_back
$LN7200@LoadRoomOp:

; 149  : 	for( i=0; i < iTypeCnt; ++i )

  013b0	ff 85 d8 ec ff
	ff		 inc	 DWORD PTR tv125408[ebp]
  013b6	ff 8d d0 ec ff
	ff		 dec	 DWORD PTR tv78822[ebp]
  013bc	0f 85 08 fe ff
	ff		 jne	 $LL7201@LoadRoomOp
$LN7199@LoadRoomOp:

; 167  : 	}
; 168  : 
; 169  : 
; 170  : 	// DropDamage
; 171  : 	kLoader.SetTitle_e( "DropDamage" );

  013c2	6a 02		 push	 2
  013c4	c7 85 f4 fe ff
	ff a9 9e 84 9a	 mov	 DWORD PTR __t$542848[ebp], -1702584663 ; 9a849ea9H
  013ce	c7 85 f8 fe ff
	ff a9 8d 86 8b	 mov	 DWORD PTR __t$542848[ebp+4], -1954116183 ; 8b868da9H
  013d8	66 c7 85 fc fe
	ff ff 8a 89	 mov	 WORD PTR __t$542848[ebp+8], 35210 ; 0000898aH
  013e1	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR __t$542848[ebp]
  013e7	88 9d fe fe ff
	ff		 mov	 BYTE PTR __t$542848[ebp+10], bl
  013ed	59		 pop	 ecx
$LL10516@LoadRoomOp:
  013ee	31 38		 xor	 DWORD PTR [eax], edi
  013f0	83 c0 04	 add	 eax, 4
  013f3	49		 dec	 ecx
  013f4	75 f8		 jne	 SHORT $LL10516@LoadRoomOp
  013f6	6a 08		 push	 8
  013f8	58		 pop	 eax
$LL10513@LoadRoomOp:
  013f9	8b c8		 mov	 ecx, eax
  013fb	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  01401	79 05		 jns	 SHORT $LN17531@LoadRoomOp
  01403	49		 dec	 ecx
  01404	83 c9 fc	 or	 ecx, -4			; fffffffcH
  01407	41		 inc	 ecx
$LN17531@LoadRoomOp:
  01408	b2 ed		 mov	 dl, -19			; ffffffedH
  0140a	2a d1		 sub	 dl, cl
  0140c	30 94 05 f4 fe
	ff ff		 xor	 BYTE PTR __t$542848[ebp+eax], dl
  01413	40		 inc	 eax
  01414	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  01417	7c e0		 jl	 SHORT $LL10513@LoadRoomOp
  01419	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR __t$542848[ebp]
  0141f	50		 push	 eax
  01420	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01426	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z
  0142c	6a 04		 push	 4

; 172  : 
; 173  : 	iTypeCnt = kLoader.LoadInt_e( "dropdamge_type_cnt", 0 );

  0142e	c7 85 a4 f7 ff
	ff 89 9e 84 9a	 mov	 DWORD PTR __k$542960[ebp], -1702584695 ; 9a849e89H
  01438	c7 85 a8 f7 ff
	ff 89 8d 86 8d	 mov	 DWORD PTR __k$542960[ebp+4], -1920561783 ; 8d868d89H
  01442	c7 85 ac f7 ff
	ff 88 b3 9f 93	 mov	 DWORD PTR __k$542960[ebp+8], -1818250360 ; 939fb388H
  0144c	c7 85 b0 f7 ff
	ff 9d 89 b4 89	 mov	 DWORD PTR __k$542960[ebp+12], -1984656995 ; 89b4899dH
  01456	66 c7 85 b4 f7
	ff ff 83 98	 mov	 WORD PTR __k$542960[ebp+16], 39043 ; 00009883H
  0145f	8d 85 a4 f7 ff
	ff		 lea	 eax, DWORD PTR __k$542960[ebp]
  01465	88 9d b6 f7 ff
	ff		 mov	 BYTE PTR __k$542960[ebp+18], bl
  0146b	59		 pop	 ecx
$LL10622@LoadRoomOp:
  0146c	31 38		 xor	 DWORD PTR [eax], edi
  0146e	83 c0 04	 add	 eax, 4
  01471	49		 dec	 ecx
  01472	75 f8		 jne	 SHORT $LL10622@LoadRoomOp
  01474	6a 10		 push	 16			; 00000010H
  01476	58		 pop	 eax
$LL10619@LoadRoomOp:
  01477	8b c8		 mov	 ecx, eax
  01479	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0147f	79 05		 jns	 SHORT $LN17532@LoadRoomOp
  01481	49		 dec	 ecx
  01482	83 c9 fc	 or	 ecx, -4			; fffffffcH
  01485	41		 inc	 ecx
$LN17532@LoadRoomOp:
  01486	b2 ed		 mov	 dl, -19			; ffffffedH
  01488	2a d1		 sub	 dl, cl
  0148a	30 94 05 a4 f7
	ff ff		 xor	 BYTE PTR __k$542960[ebp+eax], dl
  01491	40		 inc	 eax
  01492	83 f8 12	 cmp	 eax, 18			; 00000012H
  01495	7c e0		 jl	 SHORT $LL10619@LoadRoomOp
  01497	53		 push	 ebx
  01498	8d 85 a4 f7 ff
	ff		 lea	 eax, DWORD PTR __k$542960[ebp]
  0149e	50		 push	 eax
  0149f	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  014a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 174  : 	for( i=0; i < iTypeCnt; ++i )

  014ab	3b c3		 cmp	 eax, ebx
  014ad	0f 8e 59 02 00
	00		 jle	 $LN6898@LoadRoomOp

; 172  : 
; 173  : 	iTypeCnt = kLoader.LoadInt_e( "dropdamge_type_cnt", 0 );

  014b3	c7 85 d8 ec ff
	ff 01 00 00 00	 mov	 DWORD PTR tv125499[ebp], 1
  014bd	89 85 d0 ec ff
	ff		 mov	 DWORD PTR tv76754[ebp], eax
$LL6900@LoadRoomOp:

; 175  : 	{
; 176  : 		RoomOptionInfo *pInfo = new RoomOptionInfo;

  014c3	6a 50		 push	 80			; 00000050H
  014c5	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  014ca	59		 pop	 ecx
  014cb	89 85 c4 ec ff
	ff		 mov	 DWORD PTR $T540294[ebp], eax
  014d1	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  014d5	3b c3		 cmp	 eax, ebx
  014d7	74 0f		 je	 SHORT $LN8421@LoadRoomOp
  014d9	8b c8		 mov	 ecx, eax
  014db	e8 00 00 00 00	 call	 ??0RoomOptionInfo@@QAE@XZ ; RoomOptionInfo::RoomOptionInfo
  014e0	89 85 d4 ec ff
	ff		 mov	 DWORD PTR $T540293[ebp], eax
  014e6	eb 06		 jmp	 SHORT $LN8422@LoadRoomOp
$LN8421@LoadRoomOp:
  014e8	89 9d d4 ec ff
	ff		 mov	 DWORD PTR $T540293[ebp], ebx
$LN8422@LoadRoomOp:
  014ee	8b 85 d4 ec ff
	ff		 mov	 eax, DWORD PTR $T540293[ebp]
  014f4	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  014f7	89 85 c8 ec ff
	ff		 mov	 DWORD PTR _pInfo$513212[ebp], eax

; 177  : 		if( !pInfo )

  014fd	3b c3		 cmp	 eax, ebx
  014ff	0f 84 f5 01 00
	00		 je	 $LN6899@LoadRoomOp

; 178  : 			continue;
; 179  : 
; 180  : 		wsprintf_e( szKey, "dropdamage_rate%d", i+1 );

  01505	6a 04		 push	 4
  01507	c7 85 cc f9 ff
	ff 89 9e 84 9a	 mov	 DWORD PTR ___encStr$513221[ebp], -1702584695 ; 9a849e89H
  01511	c7 85 d0 f9 ff
	ff 89 8d 86 8b	 mov	 DWORD PTR ___encStr$513221[ebp+4], -1954116215 ; 8b868d89H
  0151b	c7 85 d4 f9 ff
	ff 8a 89 b4 98	 mov	 DWORD PTR ___encStr$513221[ebp+8], -1732998774 ; 98b4898aH
  01525	c7 85 d8 f9 ff
	ff 8c 98 8e cf	 mov	 DWORD PTR ___encStr$513221[ebp+12], -812738420 ; cf8e988cH
  0152f	8d 85 cc f9 ff
	ff		 lea	 eax, DWORD PTR ___encStr$513221[ebp]
  01535	66 c7 85 dc f9
	ff ff 89 00	 mov	 WORD PTR ___encStr$513221[ebp+16], 137 ; 00000089H
  0153e	59		 pop	 ecx
$LL10630@LoadRoomOp:
  0153f	31 38		 xor	 DWORD PTR [eax], edi
  01541	83 c0 04	 add	 eax, 4
  01544	49		 dec	 ecx
  01545	75 f8		 jne	 SHORT $LL10630@LoadRoomOp
  01547	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv125499[ebp]
  0154d	80 b5 dc f9 ff
	ff ed		 xor	 BYTE PTR ___encStr$513221[ebp+16], -19 ; ffffffedH
  01554	8d 85 cc f9 ff
	ff		 lea	 eax, DWORD PTR ___encStr$513221[ebp]
  0155a	50		 push	 eax
  0155b	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  01561	50		 push	 eax
  01562	ff d6		 call	 esi
  01564	83 c4 0c	 add	 esp, 12			; 0000000cH

; 181  : 		pInfo->m_fValue = kLoader.LoadFloat( szKey, FLOAT1 );

  01567	b8 01 00 00 00	 mov	 eax, 1
  0156c	89 85 c4 ec ff
	ff		 mov	 DWORD PTR tv127070[ebp], eax
  01572	db 85 c4 ec ff
	ff		 fild	 DWORD PTR tv127070[ebp]
  01578	85 c0		 test	 eax, eax
  0157a	79 06		 jns	 SHORT $LN17533@LoadRoomOp
  0157c	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN17533@LoadRoomOp:
  01582	51		 push	 ecx
  01583	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  01589	d9 1c 24	 fstp	 DWORD PTR [esp]
  0158c	50		 push	 eax
  0158d	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01593	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z
  01599	51		 push	 ecx
  0159a	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540293[ebp]
  015a0	d9 1c 24	 fstp	 DWORD PTR [esp]
  015a3	e8 00 00 00 00	 call	 ??4?$CEncrypt@M@@QAEMM@Z ; CEncrypt<float>::operator=
  015a8	dd d8		 fstp	 ST(0)
  015aa	6a 04		 push	 4

; 182  : 
; 183  : 		wsprintf_e( szKey, "dropdamage_desc%d", i+1 );

  015ac	c7 85 fc f9 ff
	ff 89 9e 84 9a	 mov	 DWORD PTR ___encStr$513374[ebp], -1702584695 ; 9a849e89H
  015b6	c7 85 00 fa ff
	ff 89 8d 86 8b	 mov	 DWORD PTR ___encStr$513374[ebp+4], -1954116215 ; 8b868d89H
  015c0	c7 85 04 fa ff
	ff 8a 89 b4 8e	 mov	 DWORD PTR ___encStr$513374[ebp+8], -1900770934 ; 8eb4898aH
  015ca	c7 85 08 fa ff
	ff 88 9f 88 cf	 mov	 DWORD PTR ___encStr$513374[ebp+12], -813129848 ; cf889f88H
  015d4	8d 85 fc f9 ff
	ff		 lea	 eax, DWORD PTR ___encStr$513374[ebp]
  015da	66 c7 85 0c fa
	ff ff 89 00	 mov	 WORD PTR ___encStr$513374[ebp+16], 137 ; 00000089H
  015e3	59		 pop	 ecx
$LL10640@LoadRoomOp:
  015e4	31 38		 xor	 DWORD PTR [eax], edi
  015e6	83 c0 04	 add	 eax, 4
  015e9	49		 dec	 ecx
  015ea	75 f8		 jne	 SHORT $LL10640@LoadRoomOp
  015ec	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv125499[ebp]
  015f2	80 b5 0c fa ff
	ff ed		 xor	 BYTE PTR ___encStr$513374[ebp+16], -19 ; ffffffedH
  015f9	8d 85 fc f9 ff
	ff		 lea	 eax, DWORD PTR ___encStr$513374[ebp]
  015ff	50		 push	 eax
  01600	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  01606	50		 push	 eax
  01607	ff d6		 call	 esi
  01609	83 c4 0c	 add	 esp, 12			; 0000000cH

; 184  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  0160c	68 04 01 00 00	 push	 260			; 00000104H
  01611	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  01617	50		 push	 eax
  01618	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0161d	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  01623	50		 push	 eax
  01624	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0162a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 185  : 		pInfo->m_Desc = szBuf;

  01630	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540293[ebp]
  01636	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  0163c	50		 push	 eax
  0163d	83 c1 30	 add	 ecx, 48			; 00000030H
  01640	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z
  01646	6a 05		 push	 5

; 186  : 
; 187  : 		wsprintf_e( szKey, "dropdamage_ui_desc%d", i+1 );

  01648	c7 85 24 f5 ff
	ff 89 9e 84 9a	 mov	 DWORD PTR ___encStr$513526[ebp], -1702584695 ; 9a849e89H
  01652	c7 85 28 f5 ff
	ff 89 8d 86 8b	 mov	 DWORD PTR ___encStr$513526[ebp+4], -1954116215 ; 8b868d89H
  0165c	c7 85 2c f5 ff
	ff 8a 89 b4 9f	 mov	 DWORD PTR ___encStr$513526[ebp+8], -1615558262 ; 9fb4898aH
  01666	c7 85 30 f5 ff
	ff 84 b3 8f 8f	 mov	 DWORD PTR ___encStr$513526[ebp+12], -1886407804 ; 8f8fb384H
  01670	c7 85 34 f5 ff
	ff 9e 8f ce 8e	 mov	 DWORD PTR ___encStr$513526[ebp+16], -1899065442 ; 8ece8f9eH
  0167a	8d 85 24 f5 ff
	ff		 lea	 eax, DWORD PTR ___encStr$513526[ebp]
  01680	88 9d 38 f5 ff
	ff		 mov	 BYTE PTR ___encStr$513526[ebp+20], bl
  01686	59		 pop	 ecx
$LL10648@LoadRoomOp:
  01687	31 38		 xor	 DWORD PTR [eax], edi
  01689	83 c0 04	 add	 eax, 4
  0168c	49		 dec	 ecx
  0168d	75 f8		 jne	 SHORT $LL10648@LoadRoomOp
  0168f	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv125499[ebp]
  01695	8d 85 24 f5 ff
	ff		 lea	 eax, DWORD PTR ___encStr$513526[ebp]
  0169b	50		 push	 eax
  0169c	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  016a2	50		 push	 eax
  016a3	ff d6		 call	 esi
  016a5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 188  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  016a8	68 04 01 00 00	 push	 260			; 00000104H
  016ad	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  016b3	50		 push	 eax
  016b4	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  016b9	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  016bf	50		 push	 eax
  016c0	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  016c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 189  : 		pInfo->m_UIDesc = szBuf;

  016cc	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540293[ebp]
  016d2	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  016d8	50		 push	 eax
  016d9	83 c1 40	 add	 ecx, 64			; 00000040H
  016dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 190  : 
; 191  : 		m_RoomDropDamageList.push_back( pInfo );

  016e2	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  016e8	8d 85 c8 ec ff
	ff		 lea	 eax, DWORD PTR _pInfo$513212[ebp]
  016ee	50		 push	 eax
  016ef	81 c1 94 00 00
	00		 add	 ecx, 148		; 00000094H
  016f5	e8 00 00 00 00	 call	 ?push_back@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXABQAURoomOptionInfo@@@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::push_back
$LN6899@LoadRoomOp:

; 174  : 	for( i=0; i < iTypeCnt; ++i )

  016fa	ff 85 d8 ec ff
	ff		 inc	 DWORD PTR tv125499[ebp]
  01700	ff 8d d0 ec ff
	ff		 dec	 DWORD PTR tv76754[ebp]
  01706	0f 85 b7 fd ff
	ff		 jne	 $LL6900@LoadRoomOp
$LN6898@LoadRoomOp:

; 192  : 	}
; 193  : 
; 194  : 
; 195  : 	// Gravity
; 196  : 	kLoader.SetTitle_e( "Gravity" );

  0170c	6a 04		 push	 4
  0170e	c7 45 b4 aa 9e
	8a 9c		 mov	 DWORD PTR __t$543125[ebp], -1668637014 ; 9c8a9eaaH
  01715	31 7d b4	 xor	 DWORD PTR __t$543125[ebp], edi
  01718	c7 45 b8 84 98
	92 00		 mov	 DWORD PTR __t$543125[ebp+4], 9607300 ; 00929884H
  0171f	58		 pop	 eax
$LL10751@LoadRoomOp:
  01720	8b c8		 mov	 ecx, eax
  01722	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  01728	79 05		 jns	 SHORT $LN17534@LoadRoomOp
  0172a	49		 dec	 ecx
  0172b	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0172e	41		 inc	 ecx
$LN17534@LoadRoomOp:
  0172f	b2 ed		 mov	 dl, -19			; ffffffedH
  01731	2a d1		 sub	 dl, cl
  01733	30 54 05 b4	 xor	 BYTE PTR __t$543125[ebp+eax], dl
  01737	40		 inc	 eax
  01738	83 f8 07	 cmp	 eax, 7
  0173b	7c e3		 jl	 SHORT $LL10751@LoadRoomOp
  0173d	8d 45 b4	 lea	 eax, DWORD PTR __t$543125[ebp]
  01740	50		 push	 eax
  01741	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01747	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z
  0174d	6a 04		 push	 4

; 197  : 
; 198  : 	iTypeCnt = kLoader.LoadInt_e( "gravity_type_cnt", 0 );

  0174f	c7 85 3c f9 ff
	ff 8a 9e 8a 9c	 mov	 DWORD PTR __k$543250[ebp], -1668637046 ; 9c8a9e8aH
  01759	c7 85 40 f9 ff
	ff 84 98 92 b5	 mov	 DWORD PTR __k$543250[ebp+4], -1248683900 ; b5929884H
  01763	c7 85 44 f9 ff
	ff 99 95 9b 8f	 mov	 DWORD PTR __k$543250[ebp+8], -1885629031 ; 8f9b9599H
  0176d	c7 85 48 f9 ff
	ff b2 8f 85 9e	 mov	 DWORD PTR __k$543250[ebp+12], -1635414094 ; 9e858fb2H
  01777	8d 85 3c f9 ff
	ff		 lea	 eax, DWORD PTR __k$543250[ebp]
  0177d	88 9d 4c f9 ff
	ff		 mov	 BYTE PTR __k$543250[ebp+16], bl
  01783	59		 pop	 ecx
$LL10860@LoadRoomOp:
  01784	31 38		 xor	 DWORD PTR [eax], edi
  01786	83 c0 04	 add	 eax, 4
  01789	49		 dec	 ecx
  0178a	75 f8		 jne	 SHORT $LL10860@LoadRoomOp
  0178c	53		 push	 ebx
  0178d	8d 85 3c f9 ff
	ff		 lea	 eax, DWORD PTR __k$543250[ebp]
  01793	50		 push	 eax
  01794	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0179a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 199  : 	for( i=0; i < iTypeCnt; ++i )

  017a0	3b c3		 cmp	 eax, ebx
  017a2	0f 8e 89 02 00
	00		 jle	 $LN6597@LoadRoomOp

; 197  : 
; 198  : 	iTypeCnt = kLoader.LoadInt_e( "gravity_type_cnt", 0 );

  017a8	c7 85 d8 ec ff
	ff 01 00 00 00	 mov	 DWORD PTR tv125596[ebp], 1
  017b2	89 85 d0 ec ff
	ff		 mov	 DWORD PTR tv75250[ebp], eax
$LL6599@LoadRoomOp:

; 200  : 	{
; 201  : 		RoomOptionInfo *pInfo = new RoomOptionInfo;

  017b8	6a 50		 push	 80			; 00000050H
  017ba	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  017bf	59		 pop	 ecx
  017c0	89 85 c4 ec ff
	ff		 mov	 DWORD PTR $T540298[ebp], eax
  017c6	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  017ca	3b c3		 cmp	 eax, ebx
  017cc	74 0f		 je	 SHORT $LN8423@LoadRoomOp
  017ce	8b c8		 mov	 ecx, eax
  017d0	e8 00 00 00 00	 call	 ??0RoomOptionInfo@@QAE@XZ ; RoomOptionInfo::RoomOptionInfo
  017d5	89 85 d4 ec ff
	ff		 mov	 DWORD PTR $T540297[ebp], eax
  017db	eb 06		 jmp	 SHORT $LN8424@LoadRoomOp
$LN8423@LoadRoomOp:
  017dd	89 9d d4 ec ff
	ff		 mov	 DWORD PTR $T540297[ebp], ebx
$LN8424@LoadRoomOp:
  017e3	8b 85 d4 ec ff
	ff		 mov	 eax, DWORD PTR $T540297[ebp]
  017e9	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  017ec	89 85 c8 ec ff
	ff		 mov	 DWORD PTR _pInfo$513687[ebp], eax

; 202  : 		if( !pInfo )

  017f2	3b c3		 cmp	 eax, ebx
  017f4	0f 84 25 02 00
	00		 je	 $LN6598@LoadRoomOp

; 203  : 			continue;
; 204  : 
; 205  : 		wsprintf_e( szKey, "gravity_rate%d", i+1 );

  017fa	6a 03		 push	 3
  017fc	c7 85 10 fc ff
	ff 8a 9e 8a 9c	 mov	 DWORD PTR ___encStr$513696[ebp], -1668637046 ; 9c8a9e8aH
  01806	c7 85 14 fc ff
	ff 84 98 92 b5	 mov	 DWORD PTR ___encStr$513696[ebp+4], -1248683900 ; b5929884H
  01810	c7 85 18 fc ff
	ff 9f 8d 9f 8f	 mov	 DWORD PTR ___encStr$513696[ebp+8], -1885368929 ; 8f9f8d9fH
  0181a	66 c7 85 1c fc
	ff ff c8 88	 mov	 WORD PTR ___encStr$513696[ebp+12], 35016 ; 000088c8H
  01823	8d 85 10 fc ff
	ff		 lea	 eax, DWORD PTR ___encStr$513696[ebp]
  01829	88 9d 1e fc ff
	ff		 mov	 BYTE PTR ___encStr$513696[ebp+14], bl
  0182f	59		 pop	 ecx
$LL10868@LoadRoomOp:
  01830	31 38		 xor	 DWORD PTR [eax], edi
  01832	83 c0 04	 add	 eax, 4
  01835	49		 dec	 ecx
  01836	75 f8		 jne	 SHORT $LL10868@LoadRoomOp
  01838	6a 0c		 push	 12			; 0000000cH
  0183a	58		 pop	 eax
$LL10865@LoadRoomOp:
  0183b	8b c8		 mov	 ecx, eax
  0183d	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  01843	79 05		 jns	 SHORT $LN17535@LoadRoomOp
  01845	49		 dec	 ecx
  01846	83 c9 fc	 or	 ecx, -4			; fffffffcH
  01849	41		 inc	 ecx
$LN17535@LoadRoomOp:
  0184a	b2 ed		 mov	 dl, -19			; ffffffedH
  0184c	2a d1		 sub	 dl, cl
  0184e	30 94 05 10 fc
	ff ff		 xor	 BYTE PTR ___encStr$513696[ebp+eax], dl
  01855	40		 inc	 eax
  01856	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  01859	7c e0		 jl	 SHORT $LL10865@LoadRoomOp
  0185b	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv125596[ebp]
  01861	8d 85 10 fc ff
	ff		 lea	 eax, DWORD PTR ___encStr$513696[ebp]
  01867	50		 push	 eax
  01868	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  0186e	50		 push	 eax
  0186f	ff d6		 call	 esi
  01871	83 c4 0c	 add	 esp, 12			; 0000000cH

; 206  : 		pInfo->m_fValue = kLoader.LoadFloat( szKey, FLOAT1 );

  01874	b8 01 00 00 00	 mov	 eax, 1
  01879	89 85 c4 ec ff
	ff		 mov	 DWORD PTR tv127038[ebp], eax
  0187f	db 85 c4 ec ff
	ff		 fild	 DWORD PTR tv127038[ebp]
  01885	85 c0		 test	 eax, eax
  01887	79 06		 jns	 SHORT $LN17536@LoadRoomOp
  01889	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN17536@LoadRoomOp:
  0188f	51		 push	 ecx
  01890	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  01896	d9 1c 24	 fstp	 DWORD PTR [esp]
  01899	50		 push	 eax
  0189a	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  018a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z
  018a6	51		 push	 ecx
  018a7	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540297[ebp]
  018ad	d9 1c 24	 fstp	 DWORD PTR [esp]
  018b0	e8 00 00 00 00	 call	 ??4?$CEncrypt@M@@QAEMM@Z ; CEncrypt<float>::operator=
  018b5	dd d8		 fstp	 ST(0)
  018b7	6a 03		 push	 3

; 207  : 
; 208  : 		wsprintf_e( szKey, "gravity_desc%d", i+1 );

  018b9	c7 85 38 fc ff
	ff 8a 9e 8a 9c	 mov	 DWORD PTR ___encStr$513849[ebp], -1668637046 ; 9c8a9e8aH
  018c3	c7 85 3c fc ff
	ff 84 98 92 b5	 mov	 DWORD PTR ___encStr$513849[ebp+4], -1248683900 ; b5929884H
  018cd	c7 85 40 fc ff
	ff 89 89 98 89	 mov	 DWORD PTR ___encStr$513849[ebp+8], -1986492023 ; 89988989H
  018d7	66 c7 85 44 fc
	ff ff c8 88	 mov	 WORD PTR ___encStr$513849[ebp+12], 35016 ; 000088c8H
  018e0	8d 85 38 fc ff
	ff		 lea	 eax, DWORD PTR ___encStr$513849[ebp]
  018e6	88 9d 46 fc ff
	ff		 mov	 BYTE PTR ___encStr$513849[ebp+14], bl
  018ec	59		 pop	 ecx
$LL10878@LoadRoomOp:
  018ed	31 38		 xor	 DWORD PTR [eax], edi
  018ef	83 c0 04	 add	 eax, 4
  018f2	49		 dec	 ecx
  018f3	75 f8		 jne	 SHORT $LL10878@LoadRoomOp
  018f5	6a 0c		 push	 12			; 0000000cH
  018f7	58		 pop	 eax
$LL10875@LoadRoomOp:
  018f8	8b c8		 mov	 ecx, eax
  018fa	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  01900	79 05		 jns	 SHORT $LN17537@LoadRoomOp
  01902	49		 dec	 ecx
  01903	83 c9 fc	 or	 ecx, -4			; fffffffcH
  01906	41		 inc	 ecx
$LN17537@LoadRoomOp:
  01907	b2 ed		 mov	 dl, -19			; ffffffedH
  01909	2a d1		 sub	 dl, cl
  0190b	30 94 05 38 fc
	ff ff		 xor	 BYTE PTR ___encStr$513849[ebp+eax], dl
  01912	40		 inc	 eax
  01913	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  01916	7c e0		 jl	 SHORT $LL10875@LoadRoomOp
  01918	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv125596[ebp]
  0191e	8d 85 38 fc ff
	ff		 lea	 eax, DWORD PTR ___encStr$513849[ebp]
  01924	50		 push	 eax
  01925	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  0192b	50		 push	 eax
  0192c	ff d6		 call	 esi
  0192e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 209  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  01931	68 04 01 00 00	 push	 260			; 00000104H
  01936	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  0193c	50		 push	 eax
  0193d	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  01942	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  01948	50		 push	 eax
  01949	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0194f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 210  : 		pInfo->m_Desc = szBuf;

  01955	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540297[ebp]
  0195b	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  01961	50		 push	 eax
  01962	83 c1 30	 add	 ecx, 48			; 00000030H
  01965	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z
  0196b	6a 04		 push	 4

; 211  : 
; 212  : 		wsprintf_e( szKey, "gravity_ui_desc%d", i+1 );

  0196d	c7 85 2c fa ff
	ff 8a 9e 8a 9c	 mov	 DWORD PTR ___encStr$514001[ebp], -1668637046 ; 9c8a9e8aH
  01977	c7 85 30 fa ff
	ff 84 98 92 b5	 mov	 DWORD PTR ___encStr$514001[ebp+4], -1248683900 ; b5929884H
  01981	c7 85 34 fa ff
	ff 98 85 b4 8e	 mov	 DWORD PTR ___encStr$514001[ebp+8], -1900771944 ; 8eb48598H
  0198b	c7 85 38 fa ff
	ff 88 9f 88 cf	 mov	 DWORD PTR ___encStr$514001[ebp+12], -813129848 ; cf889f88H
  01995	8d 85 2c fa ff
	ff		 lea	 eax, DWORD PTR ___encStr$514001[ebp]
  0199b	66 c7 85 3c fa
	ff ff 89 00	 mov	 WORD PTR ___encStr$514001[ebp+16], 137 ; 00000089H
  019a4	59		 pop	 ecx
$LL10886@LoadRoomOp:
  019a5	31 38		 xor	 DWORD PTR [eax], edi
  019a7	83 c0 04	 add	 eax, 4
  019aa	49		 dec	 ecx
  019ab	75 f8		 jne	 SHORT $LL10886@LoadRoomOp
  019ad	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv125596[ebp]
  019b3	80 b5 3c fa ff
	ff ed		 xor	 BYTE PTR ___encStr$514001[ebp+16], -19 ; ffffffedH
  019ba	8d 85 2c fa ff
	ff		 lea	 eax, DWORD PTR ___encStr$514001[ebp]
  019c0	50		 push	 eax
  019c1	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  019c7	50		 push	 eax
  019c8	ff d6		 call	 esi
  019ca	83 c4 0c	 add	 esp, 12			; 0000000cH

; 213  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  019cd	68 04 01 00 00	 push	 260			; 00000104H
  019d2	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  019d8	50		 push	 eax
  019d9	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  019de	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  019e4	50		 push	 eax
  019e5	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  019eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 214  : 		pInfo->m_UIDesc = szBuf;

  019f1	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540297[ebp]
  019f7	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  019fd	50		 push	 eax
  019fe	83 c1 40	 add	 ecx, 64			; 00000040H
  01a01	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 215  : 
; 216  : 		m_RoomGravityList.push_back( pInfo );

  01a07	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  01a0d	8d 85 c8 ec ff
	ff		 lea	 eax, DWORD PTR _pInfo$513687[ebp]
  01a13	50		 push	 eax
  01a14	81 c1 a4 00 00
	00		 add	 ecx, 164		; 000000a4H
  01a1a	e8 00 00 00 00	 call	 ?push_back@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXABQAURoomOptionInfo@@@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::push_back
$LN6598@LoadRoomOp:

; 199  : 	for( i=0; i < iTypeCnt; ++i )

  01a1f	ff 85 d8 ec ff
	ff		 inc	 DWORD PTR tv125596[ebp]
  01a25	ff 8d d0 ec ff
	ff		 dec	 DWORD PTR tv75250[ebp]
  01a2b	0f 85 87 fd ff
	ff		 jne	 $LL6599@LoadRoomOp
$LN6597@LoadRoomOp:

; 217  : 	}
; 218  : 
; 219  : 
; 220  : 	// TeamAttack
; 221  : 	kLoader.SetTitle_e( "TeamAttack" );

  01a31	6a 02		 push	 2
  01a33	c7 85 34 ff ff
	ff b9 89 8a 87	 mov	 DWORD PTR __t$543415[ebp], -2020963911 ; 878a89b9H
  01a3d	c7 85 38 ff ff
	ff ac 98 9f 8b	 mov	 DWORD PTR __t$543415[ebp+4], -1952474964 ; 8b9f98acH
  01a47	66 c7 85 3c ff
	ff ff 8e 87	 mov	 WORD PTR __t$543415[ebp+8], 34702 ; 0000878eH
  01a50	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR __t$543415[ebp]
  01a56	88 9d 3e ff ff
	ff		 mov	 BYTE PTR __t$543415[ebp+10], bl
  01a5c	59		 pop	 ecx
$LL10992@LoadRoomOp:
  01a5d	31 38		 xor	 DWORD PTR [eax], edi
  01a5f	83 c0 04	 add	 eax, 4
  01a62	49		 dec	 ecx
  01a63	75 f8		 jne	 SHORT $LL10992@LoadRoomOp
  01a65	6a 08		 push	 8
  01a67	58		 pop	 eax
$LL10989@LoadRoomOp:
  01a68	8b c8		 mov	 ecx, eax
  01a6a	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  01a70	79 05		 jns	 SHORT $LN17538@LoadRoomOp
  01a72	49		 dec	 ecx
  01a73	83 c9 fc	 or	 ecx, -4			; fffffffcH
  01a76	41		 inc	 ecx
$LN17538@LoadRoomOp:
  01a77	b2 ed		 mov	 dl, -19			; ffffffedH
  01a79	2a d1		 sub	 dl, cl
  01a7b	30 94 05 34 ff
	ff ff		 xor	 BYTE PTR __t$543415[ebp+eax], dl
  01a82	40		 inc	 eax
  01a83	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  01a86	7c e0		 jl	 SHORT $LL10989@LoadRoomOp
  01a88	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR __t$543415[ebp]
  01a8e	50		 push	 eax
  01a8f	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01a95	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z
  01a9b	6a 05		 push	 5

; 222  : 
; 223  : 	iTypeCnt = kLoader.LoadInt_e( "team_attack_type_cnt", 0 );

  01a9d	c7 85 5c f5 ff
	ff 99 89 8a 87	 mov	 DWORD PTR __k$543540[ebp], -2020963943 ; 878a8999H
  01aa7	c7 85 60 f5 ff
	ff b2 8d 9f 9e	 mov	 DWORD PTR __k$543540[ebp+4], -1633710670 ; 9e9f8db2H
  01ab1	c7 85 64 f5 ff
	ff 8c 8f 80 b5	 mov	 DWORD PTR __k$543540[ebp+8], -1249865844 ; b5808f8cH
  01abb	c7 85 68 f5 ff
	ff 99 95 9b 8f	 mov	 DWORD PTR __k$543540[ebp+12], -1885629031 ; 8f9b9599H
  01ac5	c7 85 6c f5 ff
	ff b2 8f 85 9e	 mov	 DWORD PTR __k$543540[ebp+16], -1635414094 ; 9e858fb2H
  01acf	8d 85 5c f5 ff
	ff		 lea	 eax, DWORD PTR __k$543540[ebp]
  01ad5	88 9d 70 f5 ff
	ff		 mov	 BYTE PTR __k$543540[ebp+20], bl
  01adb	59		 pop	 ecx
$LL11098@LoadRoomOp:
  01adc	31 38		 xor	 DWORD PTR [eax], edi
  01ade	83 c0 04	 add	 eax, 4
  01ae1	49		 dec	 ecx
  01ae2	75 f8		 jne	 SHORT $LL11098@LoadRoomOp
  01ae4	53		 push	 ebx
  01ae5	8d 85 5c f5 ff
	ff		 lea	 eax, DWORD PTR __k$543540[ebp]
  01aeb	50		 push	 eax
  01aec	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01af2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 224  : 	for( i=0; i < iTypeCnt; ++i )

  01af8	3b c3		 cmp	 eax, ebx
  01afa	0f 8e a7 02 00
	00		 jle	 $LN6296@LoadRoomOp

; 222  : 
; 223  : 	iTypeCnt = kLoader.LoadInt_e( "team_attack_type_cnt", 0 );

  01b00	c7 85 d8 ec ff
	ff 01 00 00 00	 mov	 DWORD PTR tv125689[ebp], 1
  01b0a	89 85 d0 ec ff
	ff		 mov	 DWORD PTR tv73617[ebp], eax
$LL6298@LoadRoomOp:

; 225  : 	{
; 226  : 		RoomOptionInfo *pInfo = new RoomOptionInfo;

  01b10	6a 50		 push	 80			; 00000050H
  01b12	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  01b17	59		 pop	 ecx
  01b18	89 85 c4 ec ff
	ff		 mov	 DWORD PTR $T540302[ebp], eax
  01b1e	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  01b22	3b c3		 cmp	 eax, ebx
  01b24	74 0f		 je	 SHORT $LN8425@LoadRoomOp
  01b26	8b c8		 mov	 ecx, eax
  01b28	e8 00 00 00 00	 call	 ??0RoomOptionInfo@@QAE@XZ ; RoomOptionInfo::RoomOptionInfo
  01b2d	89 85 d4 ec ff
	ff		 mov	 DWORD PTR $T540301[ebp], eax
  01b33	eb 06		 jmp	 SHORT $LN8426@LoadRoomOp
$LN8425@LoadRoomOp:
  01b35	89 9d d4 ec ff
	ff		 mov	 DWORD PTR $T540301[ebp], ebx
$LN8426@LoadRoomOp:
  01b3b	8b 85 d4 ec ff
	ff		 mov	 eax, DWORD PTR $T540301[ebp]
  01b41	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  01b44	89 85 c8 ec ff
	ff		 mov	 DWORD PTR _pInfo$514155[ebp], eax

; 227  : 		if( !pInfo )

  01b4a	3b c3		 cmp	 eax, ebx
  01b4c	0f 84 43 02 00
	00		 je	 $LN6297@LoadRoomOp

; 228  : 			continue;
; 229  : 
; 230  : 		wsprintf_e( szKey, "team_attack_rate%d", i+1 );

  01b52	6a 04		 push	 4
  01b54	c7 85 04 f8 ff
	ff 99 89 8a 87	 mov	 DWORD PTR ___encStr$514164[ebp], -2020963943 ; 878a8999H
  01b5e	c7 85 08 f8 ff
	ff b2 8d 9f 9e	 mov	 DWORD PTR ___encStr$514164[ebp+4], -1633710670 ; 9e9f8db2H
  01b68	c7 85 0c f8 ff
	ff 8c 8f 80 b5	 mov	 DWORD PTR ___encStr$514164[ebp+8], -1249865844 ; b5808f8cH
  01b72	c7 85 10 f8 ff
	ff 9f 8d 9f 8f	 mov	 DWORD PTR ___encStr$514164[ebp+12], -1885368929 ; 8f9f8d9fH
  01b7c	66 c7 85 14 f8
	ff ff c8 88	 mov	 WORD PTR ___encStr$514164[ebp+16], 35016 ; 000088c8H
  01b85	8d 85 04 f8 ff
	ff		 lea	 eax, DWORD PTR ___encStr$514164[ebp]
  01b8b	88 9d 16 f8 ff
	ff		 mov	 BYTE PTR ___encStr$514164[ebp+18], bl
  01b91	59		 pop	 ecx
$LL11106@LoadRoomOp:
  01b92	31 38		 xor	 DWORD PTR [eax], edi
  01b94	83 c0 04	 add	 eax, 4
  01b97	49		 dec	 ecx
  01b98	75 f8		 jne	 SHORT $LL11106@LoadRoomOp
  01b9a	6a 10		 push	 16			; 00000010H
  01b9c	58		 pop	 eax
$LL11103@LoadRoomOp:
  01b9d	8b c8		 mov	 ecx, eax
  01b9f	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  01ba5	79 05		 jns	 SHORT $LN17539@LoadRoomOp
  01ba7	49		 dec	 ecx
  01ba8	83 c9 fc	 or	 ecx, -4			; fffffffcH
  01bab	41		 inc	 ecx
$LN17539@LoadRoomOp:
  01bac	b2 ed		 mov	 dl, -19			; ffffffedH
  01bae	2a d1		 sub	 dl, cl
  01bb0	30 94 05 04 f8
	ff ff		 xor	 BYTE PTR ___encStr$514164[ebp+eax], dl
  01bb7	40		 inc	 eax
  01bb8	83 f8 12	 cmp	 eax, 18			; 00000012H
  01bbb	7c e0		 jl	 SHORT $LL11103@LoadRoomOp
  01bbd	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv125689[ebp]
  01bc3	8d 85 04 f8 ff
	ff		 lea	 eax, DWORD PTR ___encStr$514164[ebp]
  01bc9	50		 push	 eax
  01bca	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  01bd0	50		 push	 eax
  01bd1	ff d6		 call	 esi
  01bd3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 231  : 		pInfo->m_fValue = kLoader.LoadFloat( szKey, FLOAT1 );

  01bd6	b8 01 00 00 00	 mov	 eax, 1
  01bdb	89 85 c4 ec ff
	ff		 mov	 DWORD PTR tv127004[ebp], eax
  01be1	db 85 c4 ec ff
	ff		 fild	 DWORD PTR tv127004[ebp]
  01be7	85 c0		 test	 eax, eax
  01be9	79 06		 jns	 SHORT $LN17540@LoadRoomOp
  01beb	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN17540@LoadRoomOp:
  01bf1	51		 push	 ecx
  01bf2	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  01bf8	d9 1c 24	 fstp	 DWORD PTR [esp]
  01bfb	50		 push	 eax
  01bfc	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01c02	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z
  01c08	51		 push	 ecx
  01c09	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540301[ebp]
  01c0f	d9 1c 24	 fstp	 DWORD PTR [esp]
  01c12	e8 00 00 00 00	 call	 ??4?$CEncrypt@M@@QAEMM@Z ; CEncrypt<float>::operator=
  01c17	dd d8		 fstp	 ST(0)
  01c19	6a 04		 push	 4

; 232  : 
; 233  : 		wsprintf_e( szKey, "team_attack_desc%d", i+1 );

  01c1b	c7 85 74 f7 ff
	ff 99 89 8a 87	 mov	 DWORD PTR ___encStr$514317[ebp], -2020963943 ; 878a8999H
  01c25	c7 85 78 f7 ff
	ff b2 8d 9f 9e	 mov	 DWORD PTR ___encStr$514317[ebp+4], -1633710670 ; 9e9f8db2H
  01c2f	c7 85 7c f7 ff
	ff 8c 8f 80 b5	 mov	 DWORD PTR ___encStr$514317[ebp+8], -1249865844 ; b5808f8cH
  01c39	c7 85 80 f7 ff
	ff 89 89 98 89	 mov	 DWORD PTR ___encStr$514317[ebp+12], -1986492023 ; 89988989H
  01c43	66 c7 85 84 f7
	ff ff c8 88	 mov	 WORD PTR ___encStr$514317[ebp+16], 35016 ; 000088c8H
  01c4c	8d 85 74 f7 ff
	ff		 lea	 eax, DWORD PTR ___encStr$514317[ebp]
  01c52	88 9d 86 f7 ff
	ff		 mov	 BYTE PTR ___encStr$514317[ebp+18], bl
  01c58	59		 pop	 ecx
$LL11116@LoadRoomOp:
  01c59	31 38		 xor	 DWORD PTR [eax], edi
  01c5b	83 c0 04	 add	 eax, 4
  01c5e	49		 dec	 ecx
  01c5f	75 f8		 jne	 SHORT $LL11116@LoadRoomOp
  01c61	6a 10		 push	 16			; 00000010H
  01c63	58		 pop	 eax
$LL11113@LoadRoomOp:
  01c64	8b c8		 mov	 ecx, eax
  01c66	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  01c6c	79 05		 jns	 SHORT $LN17541@LoadRoomOp
  01c6e	49		 dec	 ecx
  01c6f	83 c9 fc	 or	 ecx, -4			; fffffffcH
  01c72	41		 inc	 ecx
$LN17541@LoadRoomOp:
  01c73	b2 ed		 mov	 dl, -19			; ffffffedH
  01c75	2a d1		 sub	 dl, cl
  01c77	30 94 05 74 f7
	ff ff		 xor	 BYTE PTR ___encStr$514317[ebp+eax], dl
  01c7e	40		 inc	 eax
  01c7f	83 f8 12	 cmp	 eax, 18			; 00000012H
  01c82	7c e0		 jl	 SHORT $LL11113@LoadRoomOp
  01c84	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv125689[ebp]
  01c8a	8d 85 74 f7 ff
	ff		 lea	 eax, DWORD PTR ___encStr$514317[ebp]
  01c90	50		 push	 eax
  01c91	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  01c97	50		 push	 eax
  01c98	ff d6		 call	 esi
  01c9a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 234  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  01c9d	68 04 01 00 00	 push	 260			; 00000104H
  01ca2	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  01ca8	50		 push	 eax
  01ca9	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  01cae	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  01cb4	50		 push	 eax
  01cb5	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01cbb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 235  : 		pInfo->m_Desc = szBuf;

  01cc1	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540301[ebp]
  01cc7	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  01ccd	50		 push	 eax
  01cce	83 c1 30	 add	 ecx, 48			; 00000030H
  01cd1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z
  01cd7	6a 05		 push	 5

; 236  : 
; 237  : 		wsprintf_e( szKey, "team_attack_ui_desc%d", i+1 );

  01cd9	c7 85 cc f5 ff
	ff 99 89 8a 87	 mov	 DWORD PTR ___encStr$514469[ebp], -2020963943 ; 878a8999H
  01ce3	c7 85 d0 f5 ff
	ff b2 8d 9f 9e	 mov	 DWORD PTR ___encStr$514469[ebp+4], -1633710670 ; 9e9f8db2H
  01ced	c7 85 d4 f5 ff
	ff 8c 8f 80 b5	 mov	 DWORD PTR ___encStr$514469[ebp+8], -1249865844 ; b5808f8cH
  01cf7	c7 85 d8 f5 ff
	ff 98 85 b4 8e	 mov	 DWORD PTR ___encStr$514469[ebp+12], -1900771944 ; 8eb48598H
  01d01	c7 85 dc f5 ff
	ff 88 9f 88 cf	 mov	 DWORD PTR ___encStr$514469[ebp+16], -813129848 ; cf889f88H
  01d0b	8d 85 cc f5 ff
	ff		 lea	 eax, DWORD PTR ___encStr$514469[ebp]
  01d11	66 c7 85 e0 f5
	ff ff 89 00	 mov	 WORD PTR ___encStr$514469[ebp+20], 137 ; 00000089H
  01d1a	59		 pop	 ecx
$LL11124@LoadRoomOp:
  01d1b	31 38		 xor	 DWORD PTR [eax], edi
  01d1d	83 c0 04	 add	 eax, 4
  01d20	49		 dec	 ecx
  01d21	75 f8		 jne	 SHORT $LL11124@LoadRoomOp
  01d23	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv125689[ebp]
  01d29	80 b5 e0 f5 ff
	ff ed		 xor	 BYTE PTR ___encStr$514469[ebp+20], -19 ; ffffffedH
  01d30	8d 85 cc f5 ff
	ff		 lea	 eax, DWORD PTR ___encStr$514469[ebp]
  01d36	50		 push	 eax
  01d37	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  01d3d	50		 push	 eax
  01d3e	ff d6		 call	 esi
  01d40	83 c4 0c	 add	 esp, 12			; 0000000cH

; 238  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  01d43	68 04 01 00 00	 push	 260			; 00000104H
  01d48	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  01d4e	50		 push	 eax
  01d4f	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  01d54	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  01d5a	50		 push	 eax
  01d5b	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01d61	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 239  : 		pInfo->m_UIDesc = szBuf;

  01d67	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540301[ebp]
  01d6d	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  01d73	50		 push	 eax
  01d74	83 c1 40	 add	 ecx, 64			; 00000040H
  01d77	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 240  : 
; 241  : 		m_RoomTeamAttackList.push_back( pInfo );

  01d7d	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  01d83	8d 85 c8 ec ff
	ff		 lea	 eax, DWORD PTR _pInfo$514155[ebp]
  01d89	50		 push	 eax
  01d8a	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  01d90	e8 00 00 00 00	 call	 ?push_back@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXABQAURoomOptionInfo@@@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::push_back
$LN6297@LoadRoomOp:

; 224  : 	for( i=0; i < iTypeCnt; ++i )

  01d95	ff 85 d8 ec ff
	ff		 inc	 DWORD PTR tv125689[ebp]
  01d9b	ff 8d d0 ec ff
	ff		 dec	 DWORD PTR tv73617[ebp]
  01da1	0f 85 69 fd ff
	ff		 jne	 $LL6298@LoadRoomOp
$LN6296@LoadRoomOp:

; 242  : 	}
; 243  : 
; 244  : 
; 245  : 	// Getup
; 246  : 	kLoader.SetTitle_e( "GetUp" );

  01da7	8d 45 e4	 lea	 eax, DWORD PTR __t$543705[ebp]
  01daa	c7 45 e4 aa 89
	9f bf		 mov	 DWORD PTR __t$543705[ebp], -1080063574 ; bf9f89aaH
  01db1	31 7d e4	 xor	 DWORD PTR __t$543705[ebp], edi
  01db4	50		 push	 eax
  01db5	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01dbb	66 c7 45 e8 70
	00		 mov	 WORD PTR __t$543705[ebp+4], 112 ; 00000070H
  01dc1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z
  01dc7	6a 03		 push	 3

; 247  : 
; 248  : 	iTypeCnt = kLoader.LoadInt_e( "get_up_type_cnt", 0 );

  01dc9	c7 85 20 fb ff
	ff 8a 89 9f b5	 mov	 DWORD PTR __k$543843[ebp], -1247835766 ; b59f898aH
  01dd3	c7 85 24 fb ff
	ff 98 9c b4 9e	 mov	 DWORD PTR __k$543843[ebp+4], -1632330600 ; 9eb49c98H
  01ddd	c7 85 28 fb ff
	ff 94 9c 8e b5	 mov	 DWORD PTR __k$543843[ebp+8], -1248945004 ; b58e9c94H
  01de7	8d 85 20 fb ff
	ff		 lea	 eax, DWORD PTR __k$543843[ebp]
  01ded	c7 85 2c fb ff
	ff 8e 82 9f 00	 mov	 DWORD PTR __k$543843[ebp+12], 10453646 ; 009f828eH
  01df7	59		 pop	 ecx
$LL11336@LoadRoomOp:
  01df8	31 38		 xor	 DWORD PTR [eax], edi
  01dfa	83 c0 04	 add	 eax, 4
  01dfd	49		 dec	 ecx
  01dfe	75 f8		 jne	 SHORT $LL11336@LoadRoomOp
  01e00	6a 0c		 push	 12			; 0000000cH
  01e02	58		 pop	 eax
$LL11333@LoadRoomOp:
  01e03	8b c8		 mov	 ecx, eax
  01e05	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  01e0b	79 05		 jns	 SHORT $LN17542@LoadRoomOp
  01e0d	49		 dec	 ecx
  01e0e	83 c9 fc	 or	 ecx, -4			; fffffffcH
  01e11	41		 inc	 ecx
$LN17542@LoadRoomOp:
  01e12	b2 ed		 mov	 dl, -19			; ffffffedH
  01e14	2a d1		 sub	 dl, cl
  01e16	30 94 05 20 fb
	ff ff		 xor	 BYTE PTR __k$543843[ebp+eax], dl
  01e1d	40		 inc	 eax
  01e1e	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  01e21	7c e0		 jl	 SHORT $LL11333@LoadRoomOp
  01e23	53		 push	 ebx
  01e24	8d 85 20 fb ff
	ff		 lea	 eax, DWORD PTR __k$543843[ebp]
  01e2a	50		 push	 eax
  01e2b	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01e31	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 249  : 	for( i=0; i < iTypeCnt; ++i )

  01e37	3b c3		 cmp	 eax, ebx
  01e39	0f 8e 3b 02 00
	00		 jle	 $LN5995@LoadRoomOp

; 247  : 
; 248  : 	iTypeCnt = kLoader.LoadInt_e( "get_up_type_cnt", 0 );

  01e3f	c7 85 d8 ec ff
	ff 01 00 00 00	 mov	 DWORD PTR tv125781[ebp], 1
  01e49	89 85 d0 ec ff
	ff		 mov	 DWORD PTR tv31525[ebp], eax
$LL5997@LoadRoomOp:

; 250  : 	{
; 251  : 		RoomOptionInfo *pInfo = new RoomOptionInfo;

  01e4f	6a 50		 push	 80			; 00000050H
  01e51	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  01e56	59		 pop	 ecx
  01e57	89 85 c4 ec ff
	ff		 mov	 DWORD PTR $T540306[ebp], eax
  01e5d	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  01e61	3b c3		 cmp	 eax, ebx
  01e63	74 0f		 je	 SHORT $LN8427@LoadRoomOp
  01e65	8b c8		 mov	 ecx, eax
  01e67	e8 00 00 00 00	 call	 ??0RoomOptionInfo@@QAE@XZ ; RoomOptionInfo::RoomOptionInfo
  01e6c	89 85 d4 ec ff
	ff		 mov	 DWORD PTR $T540305[ebp], eax
  01e72	eb 06		 jmp	 SHORT $LN8428@LoadRoomOp
$LN8427@LoadRoomOp:
  01e74	89 9d d4 ec ff
	ff		 mov	 DWORD PTR $T540305[ebp], ebx
$LN8428@LoadRoomOp:
  01e7a	8b 85 d4 ec ff
	ff		 mov	 eax, DWORD PTR $T540305[ebp]
  01e80	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  01e83	89 85 c8 ec ff
	ff		 mov	 DWORD PTR _pInfo$514626[ebp], eax

; 252  : 		if( !pInfo )

  01e89	3b c3		 cmp	 eax, ebx
  01e8b	0f 84 d7 01 00
	00		 je	 $LN5996@LoadRoomOp

; 253  : 			continue;
; 254  : 
; 255  : 		wsprintf_e( szKey, "get_up_rate%d", i+1 );

  01e91	6a 03		 push	 3
  01e93	c7 85 c4 fc ff
	ff 8a 89 9f b5	 mov	 DWORD PTR ___encStr$514635[ebp], -1247835766 ; b59f898aH
  01e9d	c7 85 c8 fc ff
	ff 98 9c b4 98	 mov	 DWORD PTR ___encStr$514635[ebp+4], -1732993896 ; 98b49c98H
  01ea7	c7 85 cc fc ff
	ff 8c 98 8e cf	 mov	 DWORD PTR ___encStr$514635[ebp+8], -812738420 ; cf8e988cH
  01eb1	8d 85 c4 fc ff
	ff		 lea	 eax, DWORD PTR ___encStr$514635[ebp]
  01eb7	66 c7 85 d0 fc
	ff ff 89 00	 mov	 WORD PTR ___encStr$514635[ebp+12], 137 ; 00000089H
  01ec0	59		 pop	 ecx
$LL11344@LoadRoomOp:
  01ec1	31 38		 xor	 DWORD PTR [eax], edi
  01ec3	83 c0 04	 add	 eax, 4
  01ec6	49		 dec	 ecx
  01ec7	75 f8		 jne	 SHORT $LL11344@LoadRoomOp
  01ec9	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv125781[ebp]
  01ecf	80 b5 d0 fc ff
	ff ed		 xor	 BYTE PTR ___encStr$514635[ebp+12], -19 ; ffffffedH
  01ed6	8d 85 c4 fc ff
	ff		 lea	 eax, DWORD PTR ___encStr$514635[ebp]
  01edc	50		 push	 eax
  01edd	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  01ee3	50		 push	 eax
  01ee4	ff d6		 call	 esi
  01ee6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 256  : 		pInfo->m_fValue = kLoader.LoadFloat( szKey, FLOAT1 );

  01ee9	b8 01 00 00 00	 mov	 eax, 1
  01eee	89 85 c4 ec ff
	ff		 mov	 DWORD PTR tv126972[ebp], eax
  01ef4	db 85 c4 ec ff
	ff		 fild	 DWORD PTR tv126972[ebp]
  01efa	85 c0		 test	 eax, eax
  01efc	79 06		 jns	 SHORT $LN17543@LoadRoomOp
  01efe	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN17543@LoadRoomOp:
  01f04	51		 push	 ecx
  01f05	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  01f0b	d9 1c 24	 fstp	 DWORD PTR [esp]
  01f0e	50		 push	 eax
  01f0f	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01f15	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z
  01f1b	51		 push	 ecx
  01f1c	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540305[ebp]
  01f22	d9 1c 24	 fstp	 DWORD PTR [esp]
  01f25	e8 00 00 00 00	 call	 ??4?$CEncrypt@M@@QAEMM@Z ; CEncrypt<float>::operator=
  01f2a	dd d8		 fstp	 ST(0)
  01f2c	6a 03		 push	 3

; 257  : 
; 258  : 		wsprintf_e( szKey, "get_up_desc%d", i+1 );

  01f2e	c7 85 ec fc ff
	ff 8a 89 9f b5	 mov	 DWORD PTR ___encStr$514788[ebp], -1247835766 ; b59f898aH
  01f38	c7 85 f0 fc ff
	ff 98 9c b4 8e	 mov	 DWORD PTR ___encStr$514788[ebp+4], -1900766056 ; 8eb49c98H
  01f42	c7 85 f4 fc ff
	ff 88 9f 88 cf	 mov	 DWORD PTR ___encStr$514788[ebp+8], -813129848 ; cf889f88H
  01f4c	8d 85 ec fc ff
	ff		 lea	 eax, DWORD PTR ___encStr$514788[ebp]
  01f52	66 c7 85 f8 fc
	ff ff 89 00	 mov	 WORD PTR ___encStr$514788[ebp+12], 137 ; 00000089H
  01f5b	59		 pop	 ecx
$LL11354@LoadRoomOp:
  01f5c	31 38		 xor	 DWORD PTR [eax], edi
  01f5e	83 c0 04	 add	 eax, 4
  01f61	49		 dec	 ecx
  01f62	75 f8		 jne	 SHORT $LL11354@LoadRoomOp
  01f64	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv125781[ebp]
  01f6a	80 b5 f8 fc ff
	ff ed		 xor	 BYTE PTR ___encStr$514788[ebp+12], -19 ; ffffffedH
  01f71	8d 85 ec fc ff
	ff		 lea	 eax, DWORD PTR ___encStr$514788[ebp]
  01f77	50		 push	 eax
  01f78	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  01f7e	50		 push	 eax
  01f7f	ff d6		 call	 esi
  01f81	83 c4 0c	 add	 esp, 12			; 0000000cH

; 259  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  01f84	68 04 01 00 00	 push	 260			; 00000104H
  01f89	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  01f8f	50		 push	 eax
  01f90	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  01f95	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  01f9b	50		 push	 eax
  01f9c	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01fa2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 260  : 		pInfo->m_Desc = szBuf;

  01fa8	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540305[ebp]
  01fae	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  01fb4	50		 push	 eax
  01fb5	83 c1 30	 add	 ecx, 48			; 00000030H
  01fb8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z
  01fbe	6a 04		 push	 4

; 261  : 
; 262  : 		wsprintf_e( szKey, "get_up_ui_desc%d", i+1 );

  01fc0	c7 85 54 f9 ff
	ff 8a 89 9f b5	 mov	 DWORD PTR ___encStr$514940[ebp], -1247835766 ; b59f898aH
  01fca	c7 85 58 f9 ff
	ff 98 9c b4 9f	 mov	 DWORD PTR ___encStr$514940[ebp+4], -1615553384 ; 9fb49c98H
  01fd4	c7 85 5c f9 ff
	ff 84 b3 8f 8f	 mov	 DWORD PTR ___encStr$514940[ebp+8], -1886407804 ; 8f8fb384H
  01fde	c7 85 60 f9 ff
	ff 9e 8f ce 8e	 mov	 DWORD PTR ___encStr$514940[ebp+12], -1899065442 ; 8ece8f9eH
  01fe8	8d 85 54 f9 ff
	ff		 lea	 eax, DWORD PTR ___encStr$514940[ebp]
  01fee	88 9d 64 f9 ff
	ff		 mov	 BYTE PTR ___encStr$514940[ebp+16], bl
  01ff4	59		 pop	 ecx
$LL11362@LoadRoomOp:
  01ff5	31 38		 xor	 DWORD PTR [eax], edi
  01ff7	83 c0 04	 add	 eax, 4
  01ffa	49		 dec	 ecx
  01ffb	75 f8		 jne	 SHORT $LL11362@LoadRoomOp
  01ffd	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv125781[ebp]
  02003	8d 85 54 f9 ff
	ff		 lea	 eax, DWORD PTR ___encStr$514940[ebp]
  02009	50		 push	 eax
  0200a	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  02010	50		 push	 eax
  02011	ff d6		 call	 esi
  02013	83 c4 0c	 add	 esp, 12			; 0000000cH

; 263  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  02016	68 04 01 00 00	 push	 260			; 00000104H
  0201b	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  02021	50		 push	 eax
  02022	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  02027	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  0202d	50		 push	 eax
  0202e	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 264  : 		pInfo->m_UIDesc = szBuf;

  0203a	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540305[ebp]
  02040	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  02046	50		 push	 eax
  02047	83 c1 40	 add	 ecx, 64			; 00000040H
  0204a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 265  : 
; 266  : 		m_RoomGetUpList.push_back( pInfo );

  02050	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  02056	8d 85 c8 ec ff
	ff		 lea	 eax, DWORD PTR _pInfo$514626[ebp]
  0205c	50		 push	 eax
  0205d	81 c1 c4 00 00
	00		 add	 ecx, 196		; 000000c4H
  02063	e8 00 00 00 00	 call	 ?push_back@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXABQAURoomOptionInfo@@@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::push_back
$LN5996@LoadRoomOp:

; 249  : 	for( i=0; i < iTypeCnt; ++i )

  02068	ff 85 d8 ec ff
	ff		 inc	 DWORD PTR tv125781[ebp]
  0206e	ff 8d d0 ec ff
	ff		 dec	 DWORD PTR tv31525[ebp]
  02074	0f 85 d5 fd ff
	ff		 jne	 $LL5997@LoadRoomOp
$LN5995@LoadRoomOp:

; 267  : 	}
; 268  : 
; 269  : 
; 270  : 	// MoveSpeed
; 271  : 	kLoader.SetTitle_e( "RedMoveSpeed" );

  0207a	6a 03		 push	 3
  0207c	c7 85 2c fe ff
	ff bf 89 8f a7	 mov	 DWORD PTR __t$544035[ebp], -1483765313 ; a78f89bfH
  02086	c7 85 30 fe ff
	ff 82 9a 8e b9	 mov	 DWORD PTR __t$544035[ebp+4], -1181836670 ; b98e9a82H
  02090	c7 85 34 fe ff
	ff 9d 89 8e 8e	 mov	 DWORD PTR __t$544035[ebp+8], -1903261283 ; 8e8e899dH
  0209a	8d 85 2c fe ff
	ff		 lea	 eax, DWORD PTR __t$544035[ebp]
  020a0	88 9d 38 fe ff
	ff		 mov	 BYTE PTR __t$544035[ebp+12], bl
  020a6	59		 pop	 ecx
$LL11468@LoadRoomOp:
  020a7	31 38		 xor	 DWORD PTR [eax], edi
  020a9	83 c0 04	 add	 eax, 4
  020ac	49		 dec	 ecx
  020ad	75 f8		 jne	 SHORT $LL11468@LoadRoomOp
  020af	8d 85 2c fe ff
	ff		 lea	 eax, DWORD PTR __t$544035[ebp]
  020b5	50		 push	 eax
  020b6	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  020bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z
  020c2	6a 04		 push	 4

; 272  : 
; 273  : 	iTypeCnt = kLoader.LoadInt_e( "move_speed_type_cnt", 0 );

  020c4	c7 85 9c f6 ff
	ff 80 83 9d 8f	 mov	 DWORD PTR __k$544147[ebp], -1885502592 ; 8f9d8380H
  020ce	c7 85 a0 f6 ff
	ff b2 9f 9b 8f	 mov	 DWORD PTR __k$544147[ebp+4], -1885626446 ; 8f9b9fb2H
  020d8	c7 85 a4 f6 ff
	ff 88 88 b4 9e	 mov	 DWORD PTR __k$544147[ebp+8], -1632335736 ; 9eb48888H
  020e2	c7 85 a8 f6 ff
	ff 94 9c 8e b5	 mov	 DWORD PTR __k$544147[ebp+12], -1248945004 ; b58e9c94H
  020ec	8d 85 9c f6 ff
	ff		 lea	 eax, DWORD PTR __k$544147[ebp]
  020f2	c7 85 ac f6 ff
	ff 8e 82 9f 00	 mov	 DWORD PTR __k$544147[ebp+16], 10453646 ; 009f828eH
  020fc	59		 pop	 ecx
$LL11574@LoadRoomOp:
  020fd	31 38		 xor	 DWORD PTR [eax], edi
  020ff	83 c0 04	 add	 eax, 4
  02102	49		 dec	 ecx
  02103	75 f8		 jne	 SHORT $LL11574@LoadRoomOp
  02105	6a 10		 push	 16			; 00000010H
  02107	58		 pop	 eax
$LL11571@LoadRoomOp:
  02108	8b c8		 mov	 ecx, eax
  0210a	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  02110	79 05		 jns	 SHORT $LN17544@LoadRoomOp
  02112	49		 dec	 ecx
  02113	83 c9 fc	 or	 ecx, -4			; fffffffcH
  02116	41		 inc	 ecx
$LN17544@LoadRoomOp:
  02117	b2 ed		 mov	 dl, -19			; ffffffedH
  02119	2a d1		 sub	 dl, cl
  0211b	30 94 05 9c f6
	ff ff		 xor	 BYTE PTR __k$544147[ebp+eax], dl
  02122	40		 inc	 eax
  02123	83 f8 13	 cmp	 eax, 19			; 00000013H
  02126	7c e0		 jl	 SHORT $LL11571@LoadRoomOp
  02128	53		 push	 ebx
  02129	8d 85 9c f6 ff
	ff		 lea	 eax, DWORD PTR __k$544147[ebp]
  0212f	50		 push	 eax
  02130	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02136	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 274  : 	for( i=0; i < iTypeCnt; ++i )

  0213c	3b c3		 cmp	 eax, ebx
  0213e	0f 8e 59 02 00
	00		 jle	 $LN5694@LoadRoomOp

; 272  : 
; 273  : 	iTypeCnt = kLoader.LoadInt_e( "move_speed_type_cnt", 0 );

  02144	c7 85 d8 ec ff
	ff 01 00 00 00	 mov	 DWORD PTR tv125888[ebp], 1
  0214e	89 85 d0 ec ff
	ff		 mov	 DWORD PTR tv103518[ebp], eax
$LL5696@LoadRoomOp:

; 275  : 	{
; 276  : 		RoomOptionInfo *pInfo = new RoomOptionInfo;

  02154	6a 50		 push	 80			; 00000050H
  02156	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0215b	59		 pop	 ecx
  0215c	89 85 c4 ec ff
	ff		 mov	 DWORD PTR $T540310[ebp], eax
  02162	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  02166	3b c3		 cmp	 eax, ebx
  02168	74 0f		 je	 SHORT $LN8429@LoadRoomOp
  0216a	8b c8		 mov	 ecx, eax
  0216c	e8 00 00 00 00	 call	 ??0RoomOptionInfo@@QAE@XZ ; RoomOptionInfo::RoomOptionInfo
  02171	89 85 d4 ec ff
	ff		 mov	 DWORD PTR $T540309[ebp], eax
  02177	eb 06		 jmp	 SHORT $LN8430@LoadRoomOp
$LN8429@LoadRoomOp:
  02179	89 9d d4 ec ff
	ff		 mov	 DWORD PTR $T540309[ebp], ebx
$LN8430@LoadRoomOp:
  0217f	8b 85 d4 ec ff
	ff		 mov	 eax, DWORD PTR $T540309[ebp]
  02185	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  02188	89 85 c8 ec ff
	ff		 mov	 DWORD PTR _pInfo$515094[ebp], eax

; 277  : 		if( !pInfo )

  0218e	3b c3		 cmp	 eax, ebx
  02190	0f 84 f5 01 00
	00		 je	 $LN5695@LoadRoomOp

; 278  : 			continue;
; 279  : 
; 280  : 		wsprintf_e( szKey, "move_speed_rate%d", i+1 );

  02196	6a 04		 push	 4
  02198	c7 85 5c fa ff
	ff 80 83 9d 8f	 mov	 DWORD PTR ___encStr$515103[ebp], -1885502592 ; 8f9d8380H
  021a2	c7 85 60 fa ff
	ff b2 9f 9b 8f	 mov	 DWORD PTR ___encStr$515103[ebp+4], -1885626446 ; 8f9b9fb2H
  021ac	c7 85 64 fa ff
	ff 88 88 b4 98	 mov	 DWORD PTR ___encStr$515103[ebp+8], -1732999032 ; 98b48888H
  021b6	c7 85 68 fa ff
	ff 8c 98 8e cf	 mov	 DWORD PTR ___encStr$515103[ebp+12], -812738420 ; cf8e988cH
  021c0	8d 85 5c fa ff
	ff		 lea	 eax, DWORD PTR ___encStr$515103[ebp]
  021c6	66 c7 85 6c fa
	ff ff 89 00	 mov	 WORD PTR ___encStr$515103[ebp+16], 137 ; 00000089H
  021cf	59		 pop	 ecx
$LL11582@LoadRoomOp:
  021d0	31 38		 xor	 DWORD PTR [eax], edi
  021d2	83 c0 04	 add	 eax, 4
  021d5	49		 dec	 ecx
  021d6	75 f8		 jne	 SHORT $LL11582@LoadRoomOp
  021d8	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv125888[ebp]
  021de	80 b5 6c fa ff
	ff ed		 xor	 BYTE PTR ___encStr$515103[ebp+16], -19 ; ffffffedH
  021e5	8d 85 5c fa ff
	ff		 lea	 eax, DWORD PTR ___encStr$515103[ebp]
  021eb	50		 push	 eax
  021ec	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  021f2	50		 push	 eax
  021f3	ff d6		 call	 esi
  021f5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 281  : 		pInfo->m_fValue = kLoader.LoadFloat( szKey, FLOAT1 );

  021f8	b8 01 00 00 00	 mov	 eax, 1
  021fd	89 85 c4 ec ff
	ff		 mov	 DWORD PTR tv126942[ebp], eax
  02203	db 85 c4 ec ff
	ff		 fild	 DWORD PTR tv126942[ebp]
  02209	85 c0		 test	 eax, eax
  0220b	79 06		 jns	 SHORT $LN17545@LoadRoomOp
  0220d	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN17545@LoadRoomOp:
  02213	51		 push	 ecx
  02214	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  0221a	d9 1c 24	 fstp	 DWORD PTR [esp]
  0221d	50		 push	 eax
  0221e	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02224	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z
  0222a	51		 push	 ecx
  0222b	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540309[ebp]
  02231	d9 1c 24	 fstp	 DWORD PTR [esp]
  02234	e8 00 00 00 00	 call	 ??4?$CEncrypt@M@@QAEMM@Z ; CEncrypt<float>::operator=
  02239	dd d8		 fstp	 ST(0)
  0223b	6a 04		 push	 4

; 282  : 
; 283  : 		wsprintf_e( szKey, "move_speed_desc%d", i+1 );

  0223d	c7 85 8c fa ff
	ff 80 83 9d 8f	 mov	 DWORD PTR ___encStr$515256[ebp], -1885502592 ; 8f9d8380H
  02247	c7 85 90 fa ff
	ff b2 9f 9b 8f	 mov	 DWORD PTR ___encStr$515256[ebp+4], -1885626446 ; 8f9b9fb2H
  02251	c7 85 94 fa ff
	ff 88 88 b4 8e	 mov	 DWORD PTR ___encStr$515256[ebp+8], -1900771192 ; 8eb48888H
  0225b	c7 85 98 fa ff
	ff 88 9f 88 cf	 mov	 DWORD PTR ___encStr$515256[ebp+12], -813129848 ; cf889f88H
  02265	8d 85 8c fa ff
	ff		 lea	 eax, DWORD PTR ___encStr$515256[ebp]
  0226b	66 c7 85 9c fa
	ff ff 89 00	 mov	 WORD PTR ___encStr$515256[ebp+16], 137 ; 00000089H
  02274	59		 pop	 ecx
$LL11592@LoadRoomOp:
  02275	31 38		 xor	 DWORD PTR [eax], edi
  02277	83 c0 04	 add	 eax, 4
  0227a	49		 dec	 ecx
  0227b	75 f8		 jne	 SHORT $LL11592@LoadRoomOp
  0227d	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv125888[ebp]
  02283	80 b5 9c fa ff
	ff ed		 xor	 BYTE PTR ___encStr$515256[ebp+16], -19 ; ffffffedH
  0228a	8d 85 8c fa ff
	ff		 lea	 eax, DWORD PTR ___encStr$515256[ebp]
  02290	50		 push	 eax
  02291	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  02297	50		 push	 eax
  02298	ff d6		 call	 esi
  0229a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 284  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  0229d	68 04 01 00 00	 push	 260			; 00000104H
  022a2	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  022a8	50		 push	 eax
  022a9	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  022ae	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  022b4	50		 push	 eax
  022b5	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  022bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 285  : 		pInfo->m_Desc = szBuf;

  022c1	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540309[ebp]
  022c7	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  022cd	50		 push	 eax
  022ce	83 c1 30	 add	 ecx, 48			; 00000030H
  022d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z
  022d7	6a 05		 push	 5

; 286  : 
; 287  : 		wsprintf_e( szKey, "move_speed_ui_desc%d", i+1 );

  022d9	c7 85 78 f5 ff
	ff 80 83 9d 8f	 mov	 DWORD PTR ___encStr$515408[ebp], -1885502592 ; 8f9d8380H
  022e3	c7 85 7c f5 ff
	ff b2 9f 9b 8f	 mov	 DWORD PTR ___encStr$515408[ebp+4], -1885626446 ; 8f9b9fb2H
  022ed	c7 85 80 f5 ff
	ff 88 88 b4 9f	 mov	 DWORD PTR ___encStr$515408[ebp+8], -1615558520 ; 9fb48888H
  022f7	c7 85 84 f5 ff
	ff 84 b3 8f 8f	 mov	 DWORD PTR ___encStr$515408[ebp+12], -1886407804 ; 8f8fb384H
  02301	c7 85 88 f5 ff
	ff 9e 8f ce 8e	 mov	 DWORD PTR ___encStr$515408[ebp+16], -1899065442 ; 8ece8f9eH
  0230b	8d 85 78 f5 ff
	ff		 lea	 eax, DWORD PTR ___encStr$515408[ebp]
  02311	88 9d 8c f5 ff
	ff		 mov	 BYTE PTR ___encStr$515408[ebp+20], bl
  02317	59		 pop	 ecx
$LL11600@LoadRoomOp:
  02318	31 38		 xor	 DWORD PTR [eax], edi
  0231a	83 c0 04	 add	 eax, 4
  0231d	49		 dec	 ecx
  0231e	75 f8		 jne	 SHORT $LL11600@LoadRoomOp
  02320	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv125888[ebp]
  02326	8d 85 78 f5 ff
	ff		 lea	 eax, DWORD PTR ___encStr$515408[ebp]
  0232c	50		 push	 eax
  0232d	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  02333	50		 push	 eax
  02334	ff d6		 call	 esi
  02336	83 c4 0c	 add	 esp, 12			; 0000000cH

; 288  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  02339	68 04 01 00 00	 push	 260			; 00000104H
  0233e	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  02344	50		 push	 eax
  02345	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0234a	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  02350	50		 push	 eax
  02351	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02357	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 289  : 		pInfo->m_UIDesc = szBuf;

  0235d	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540309[ebp]
  02363	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  02369	50		 push	 eax
  0236a	83 c1 40	 add	 ecx, 64			; 00000040H
  0236d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 290  : 
; 291  : 		m_RoomRedMoveSpeedList.push_back( pInfo );

  02373	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  02379	8d 85 c8 ec ff
	ff		 lea	 eax, DWORD PTR _pInfo$515094[ebp]
  0237f	50		 push	 eax
  02380	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  02386	e8 00 00 00 00	 call	 ?push_back@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXABQAURoomOptionInfo@@@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::push_back
$LN5695@LoadRoomOp:

; 274  : 	for( i=0; i < iTypeCnt; ++i )

  0238b	ff 85 d8 ec ff
	ff		 inc	 DWORD PTR tv125888[ebp]
  02391	ff 8d d0 ec ff
	ff		 dec	 DWORD PTR tv103518[ebp]
  02397	0f 85 b7 fd ff
	ff		 jne	 $LL5696@LoadRoomOp
$LN5694@LoadRoomOp:

; 292  : 	}
; 293  : 
; 294  : 	kLoader.SetTitle_e( "BlueMoveSpeed" );

  0239d	6a 03		 push	 3
  0239f	c7 85 b0 fc ff
	ff af 80 9e 8f	 mov	 DWORD PTR __t$544298[ebp], -1885437777 ; 8f9e80afH
  023a9	c7 85 b4 fc ff
	ff a0 83 9d 8f	 mov	 DWORD PTR __t$544298[ebp+4], -1885502560 ; 8f9d83a0H
  023b3	c7 85 b8 fc ff
	ff be 9c 8e 8f	 mov	 DWORD PTR __t$544298[ebp+8], -1886479170 ; 8f8e9cbeH
  023bd	8d 85 b0 fc ff
	ff		 lea	 eax, DWORD PTR __t$544298[ebp]
  023c3	66 c7 85 bc fc
	ff ff 89 00	 mov	 WORD PTR __t$544298[ebp+12], 137 ; 00000089H
  023cc	59		 pop	 ecx
$LL11706@LoadRoomOp:
  023cd	31 38		 xor	 DWORD PTR [eax], edi
  023cf	83 c0 04	 add	 eax, 4
  023d2	49		 dec	 ecx
  023d3	75 f8		 jne	 SHORT $LL11706@LoadRoomOp
  023d5	80 b5 bc fc ff
	ff ed		 xor	 BYTE PTR __t$544298[ebp+12], -19 ; ffffffedH
  023dc	8d 85 b0 fc ff
	ff		 lea	 eax, DWORD PTR __t$544298[ebp]
  023e2	50		 push	 eax
  023e3	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  023e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z
  023ef	6a 04		 push	 4

; 295  : 
; 296  : 	iTypeCnt = kLoader.LoadInt_e( "move_speed_type_cnt", 0 );

  023f1	c7 85 6c f6 ff
	ff 80 83 9d 8f	 mov	 DWORD PTR __k$544437[ebp], -1885502592 ; 8f9d8380H
  023fb	c7 85 70 f6 ff
	ff b2 9f 9b 8f	 mov	 DWORD PTR __k$544437[ebp+4], -1885626446 ; 8f9b9fb2H
  02405	c7 85 74 f6 ff
	ff 88 88 b4 9e	 mov	 DWORD PTR __k$544437[ebp+8], -1632335736 ; 9eb48888H
  0240f	c7 85 78 f6 ff
	ff 94 9c 8e b5	 mov	 DWORD PTR __k$544437[ebp+12], -1248945004 ; b58e9c94H
  02419	8d 85 6c f6 ff
	ff		 lea	 eax, DWORD PTR __k$544437[ebp]
  0241f	c7 85 7c f6 ff
	ff 8e 82 9f 00	 mov	 DWORD PTR __k$544437[ebp+16], 10453646 ; 009f828eH
  02429	59		 pop	 ecx
$LL11812@LoadRoomOp:
  0242a	31 38		 xor	 DWORD PTR [eax], edi
  0242c	83 c0 04	 add	 eax, 4
  0242f	49		 dec	 ecx
  02430	75 f8		 jne	 SHORT $LL11812@LoadRoomOp
  02432	6a 10		 push	 16			; 00000010H
  02434	58		 pop	 eax
$LL11809@LoadRoomOp:
  02435	8b c8		 mov	 ecx, eax
  02437	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0243d	79 05		 jns	 SHORT $LN17546@LoadRoomOp
  0243f	49		 dec	 ecx
  02440	83 c9 fc	 or	 ecx, -4			; fffffffcH
  02443	41		 inc	 ecx
$LN17546@LoadRoomOp:
  02444	b2 ed		 mov	 dl, -19			; ffffffedH
  02446	2a d1		 sub	 dl, cl
  02448	30 94 05 6c f6
	ff ff		 xor	 BYTE PTR __k$544437[ebp+eax], dl
  0244f	40		 inc	 eax
  02450	83 f8 13	 cmp	 eax, 19			; 00000013H
  02453	7c e0		 jl	 SHORT $LL11809@LoadRoomOp
  02455	53		 push	 ebx
  02456	8d 85 6c f6 ff
	ff		 lea	 eax, DWORD PTR __k$544437[ebp]
  0245c	50		 push	 eax
  0245d	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02463	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 297  : 	for( i=0; i < iTypeCnt; ++i )

  02469	3b c3		 cmp	 eax, ebx
  0246b	0f 8e 59 02 00
	00		 jle	 $LN5393@LoadRoomOp

; 295  : 
; 296  : 	iTypeCnt = kLoader.LoadInt_e( "move_speed_type_cnt", 0 );

  02471	c7 85 d8 ec ff
	ff 01 00 00 00	 mov	 DWORD PTR tv125977[ebp], 1
  0247b	89 85 d0 ec ff
	ff		 mov	 DWORD PTR tv70273[ebp], eax
$LL5395@LoadRoomOp:

; 298  : 	{
; 299  : 		RoomOptionInfo *pInfo = new RoomOptionInfo;

  02481	6a 50		 push	 80			; 00000050H
  02483	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  02488	59		 pop	 ecx
  02489	89 85 c4 ec ff
	ff		 mov	 DWORD PTR $T540314[ebp], eax
  0248f	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  02493	3b c3		 cmp	 eax, ebx
  02495	74 0f		 je	 SHORT $LN8431@LoadRoomOp
  02497	8b c8		 mov	 ecx, eax
  02499	e8 00 00 00 00	 call	 ??0RoomOptionInfo@@QAE@XZ ; RoomOptionInfo::RoomOptionInfo
  0249e	89 85 d4 ec ff
	ff		 mov	 DWORD PTR $T540313[ebp], eax
  024a4	eb 06		 jmp	 SHORT $LN8432@LoadRoomOp
$LN8431@LoadRoomOp:
  024a6	89 9d d4 ec ff
	ff		 mov	 DWORD PTR $T540313[ebp], ebx
$LN8432@LoadRoomOp:
  024ac	8b 85 d4 ec ff
	ff		 mov	 eax, DWORD PTR $T540313[ebp]
  024b2	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  024b5	89 85 c8 ec ff
	ff		 mov	 DWORD PTR _pInfo$515564[ebp], eax

; 300  : 		if( !pInfo )

  024bb	3b c3		 cmp	 eax, ebx
  024bd	0f 84 f5 01 00
	00		 je	 $LN5394@LoadRoomOp

; 301  : 			continue;
; 302  : 
; 303  : 		wsprintf_e( szKey, "move_speed_rate%d", i+1 );

  024c3	6a 04		 push	 4
  024c5	c7 85 b4 f9 ff
	ff 80 83 9d 8f	 mov	 DWORD PTR ___encStr$515573[ebp], -1885502592 ; 8f9d8380H
  024cf	c7 85 b8 f9 ff
	ff b2 9f 9b 8f	 mov	 DWORD PTR ___encStr$515573[ebp+4], -1885626446 ; 8f9b9fb2H
  024d9	c7 85 bc f9 ff
	ff 88 88 b4 98	 mov	 DWORD PTR ___encStr$515573[ebp+8], -1732999032 ; 98b48888H
  024e3	c7 85 c0 f9 ff
	ff 8c 98 8e cf	 mov	 DWORD PTR ___encStr$515573[ebp+12], -812738420 ; cf8e988cH
  024ed	8d 85 b4 f9 ff
	ff		 lea	 eax, DWORD PTR ___encStr$515573[ebp]
  024f3	66 c7 85 c4 f9
	ff ff 89 00	 mov	 WORD PTR ___encStr$515573[ebp+16], 137 ; 00000089H
  024fc	59		 pop	 ecx
$LL11820@LoadRoomOp:
  024fd	31 38		 xor	 DWORD PTR [eax], edi
  024ff	83 c0 04	 add	 eax, 4
  02502	49		 dec	 ecx
  02503	75 f8		 jne	 SHORT $LL11820@LoadRoomOp
  02505	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv125977[ebp]
  0250b	80 b5 c4 f9 ff
	ff ed		 xor	 BYTE PTR ___encStr$515573[ebp+16], -19 ; ffffffedH
  02512	8d 85 b4 f9 ff
	ff		 lea	 eax, DWORD PTR ___encStr$515573[ebp]
  02518	50		 push	 eax
  02519	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  0251f	50		 push	 eax
  02520	ff d6		 call	 esi
  02522	83 c4 0c	 add	 esp, 12			; 0000000cH

; 304  : 		pInfo->m_fValue = kLoader.LoadFloat( szKey, FLOAT1 );

  02525	b8 01 00 00 00	 mov	 eax, 1
  0252a	89 85 c4 ec ff
	ff		 mov	 DWORD PTR tv126912[ebp], eax
  02530	db 85 c4 ec ff
	ff		 fild	 DWORD PTR tv126912[ebp]
  02536	85 c0		 test	 eax, eax
  02538	79 06		 jns	 SHORT $LN17547@LoadRoomOp
  0253a	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN17547@LoadRoomOp:
  02540	51		 push	 ecx
  02541	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  02547	d9 1c 24	 fstp	 DWORD PTR [esp]
  0254a	50		 push	 eax
  0254b	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02551	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z
  02557	51		 push	 ecx
  02558	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540313[ebp]
  0255e	d9 1c 24	 fstp	 DWORD PTR [esp]
  02561	e8 00 00 00 00	 call	 ??4?$CEncrypt@M@@QAEMM@Z ; CEncrypt<float>::operator=
  02566	dd d8		 fstp	 ST(0)
  02568	6a 04		 push	 4

; 305  : 
; 306  : 		wsprintf_e( szKey, "move_speed_desc%d", i+1 );

  0256a	c7 85 14 fa ff
	ff 80 83 9d 8f	 mov	 DWORD PTR ___encStr$515725[ebp], -1885502592 ; 8f9d8380H
  02574	c7 85 18 fa ff
	ff b2 9f 9b 8f	 mov	 DWORD PTR ___encStr$515725[ebp+4], -1885626446 ; 8f9b9fb2H
  0257e	c7 85 1c fa ff
	ff 88 88 b4 8e	 mov	 DWORD PTR ___encStr$515725[ebp+8], -1900771192 ; 8eb48888H
  02588	c7 85 20 fa ff
	ff 88 9f 88 cf	 mov	 DWORD PTR ___encStr$515725[ebp+12], -813129848 ; cf889f88H
  02592	8d 85 14 fa ff
	ff		 lea	 eax, DWORD PTR ___encStr$515725[ebp]
  02598	66 c7 85 24 fa
	ff ff 89 00	 mov	 WORD PTR ___encStr$515725[ebp+16], 137 ; 00000089H
  025a1	59		 pop	 ecx
$LL11830@LoadRoomOp:
  025a2	31 38		 xor	 DWORD PTR [eax], edi
  025a4	83 c0 04	 add	 eax, 4
  025a7	49		 dec	 ecx
  025a8	75 f8		 jne	 SHORT $LL11830@LoadRoomOp
  025aa	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv125977[ebp]
  025b0	80 b5 24 fa ff
	ff ed		 xor	 BYTE PTR ___encStr$515725[ebp+16], -19 ; ffffffedH
  025b7	8d 85 14 fa ff
	ff		 lea	 eax, DWORD PTR ___encStr$515725[ebp]
  025bd	50		 push	 eax
  025be	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  025c4	50		 push	 eax
  025c5	ff d6		 call	 esi
  025c7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 307  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  025ca	68 04 01 00 00	 push	 260			; 00000104H
  025cf	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  025d5	50		 push	 eax
  025d6	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  025db	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  025e1	50		 push	 eax
  025e2	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  025e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 308  : 		pInfo->m_Desc = szBuf;

  025ee	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540313[ebp]
  025f4	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  025fa	50		 push	 eax
  025fb	83 c1 30	 add	 ecx, 48			; 00000030H
  025fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z
  02604	6a 05		 push	 5

; 309  : 
; 310  : 		wsprintf_e( szKey, "move_speed_ui_desc%d", i+1 );

  02606	c7 85 08 f5 ff
	ff 80 83 9d 8f	 mov	 DWORD PTR ___encStr$515876[ebp], -1885502592 ; 8f9d8380H
  02610	c7 85 0c f5 ff
	ff b2 9f 9b 8f	 mov	 DWORD PTR ___encStr$515876[ebp+4], -1885626446 ; 8f9b9fb2H
  0261a	c7 85 10 f5 ff
	ff 88 88 b4 9f	 mov	 DWORD PTR ___encStr$515876[ebp+8], -1615558520 ; 9fb48888H
  02624	c7 85 14 f5 ff
	ff 84 b3 8f 8f	 mov	 DWORD PTR ___encStr$515876[ebp+12], -1886407804 ; 8f8fb384H
  0262e	c7 85 18 f5 ff
	ff 9e 8f ce 8e	 mov	 DWORD PTR ___encStr$515876[ebp+16], -1899065442 ; 8ece8f9eH
  02638	8d 85 08 f5 ff
	ff		 lea	 eax, DWORD PTR ___encStr$515876[ebp]
  0263e	88 9d 1c f5 ff
	ff		 mov	 BYTE PTR ___encStr$515876[ebp+20], bl
  02644	59		 pop	 ecx
$LL11838@LoadRoomOp:
  02645	31 38		 xor	 DWORD PTR [eax], edi
  02647	83 c0 04	 add	 eax, 4
  0264a	49		 dec	 ecx
  0264b	75 f8		 jne	 SHORT $LL11838@LoadRoomOp
  0264d	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv125977[ebp]
  02653	8d 85 08 f5 ff
	ff		 lea	 eax, DWORD PTR ___encStr$515876[ebp]
  02659	50		 push	 eax
  0265a	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  02660	50		 push	 eax
  02661	ff d6		 call	 esi
  02663	83 c4 0c	 add	 esp, 12			; 0000000cH

; 311  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  02666	68 04 01 00 00	 push	 260			; 00000104H
  0266b	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  02671	50		 push	 eax
  02672	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  02677	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  0267d	50		 push	 eax
  0267e	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02684	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 312  : 		pInfo->m_UIDesc = szBuf;

  0268a	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540313[ebp]
  02690	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  02696	50		 push	 eax
  02697	83 c1 40	 add	 ecx, 64			; 00000040H
  0269a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 313  : 
; 314  : 		m_RoomBlueMoveSpeedList.push_back( pInfo );

  026a0	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  026a6	8d 85 c8 ec ff
	ff		 lea	 eax, DWORD PTR _pInfo$515564[ebp]
  026ac	50		 push	 eax
  026ad	81 c1 24 01 00
	00		 add	 ecx, 292		; 00000124H
  026b3	e8 00 00 00 00	 call	 ?push_back@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXABQAURoomOptionInfo@@@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::push_back
$LN5394@LoadRoomOp:

; 297  : 	for( i=0; i < iTypeCnt; ++i )

  026b8	ff 85 d8 ec ff
	ff		 inc	 DWORD PTR tv125977[ebp]
  026be	ff 8d d0 ec ff
	ff		 dec	 DWORD PTR tv70273[ebp]
  026c4	0f 85 b7 fd ff
	ff		 jne	 $LL5395@LoadRoomOp
$LN5393@LoadRoomOp:

; 315  : 	}
; 316  : 
; 317  : 
; 318  : 	// KO Type
; 319  : 	kLoader.SetTitle_e( "KOType" );

  026ca	6a 04		 push	 4
  026cc	c7 45 d8 a6 a3
	bf 93		 mov	 DWORD PTR __t$544575[ebp], -1816157274 ; 93bfa3a6H
  026d3	31 7d d8	 xor	 DWORD PTR __t$544575[ebp], edi
  026d6	66 c7 45 dc 9d
	89		 mov	 WORD PTR __t$544575[ebp+4], 35229 ; 0000899dH
  026dc	88 5d de	 mov	 BYTE PTR __t$544575[ebp+6], bl
  026df	58		 pop	 eax
$LL11941@LoadRoomOp:
  026e0	8b c8		 mov	 ecx, eax
  026e2	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  026e8	79 05		 jns	 SHORT $LN17548@LoadRoomOp
  026ea	49		 dec	 ecx
  026eb	83 c9 fc	 or	 ecx, -4			; fffffffcH
  026ee	41		 inc	 ecx
$LN17548@LoadRoomOp:
  026ef	b2 ed		 mov	 dl, -19			; ffffffedH
  026f1	2a d1		 sub	 dl, cl
  026f3	30 54 05 d8	 xor	 BYTE PTR __t$544575[ebp+eax], dl
  026f7	40		 inc	 eax
  026f8	83 f8 06	 cmp	 eax, 6
  026fb	7c e3		 jl	 SHORT $LL11941@LoadRoomOp
  026fd	8d 45 d8	 lea	 eax, DWORD PTR __t$544575[ebp]
  02700	50		 push	 eax
  02701	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02707	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z
  0270d	6a 02		 push	 2

; 320  : 
; 321  : 	iTypeCnt = kLoader.LoadInt_e( "ko_type_cnt", 0 );

  0270f	c7 85 94 fe ff
	ff 86 83 b4 9e	 mov	 DWORD PTR __k$544700[ebp], -1632337018 ; 9eb48386H
  02719	c7 85 98 fe ff
	ff 94 9c 8e b5	 mov	 DWORD PTR __k$544700[ebp+4], -1248945004 ; b58e9c94H
  02723	8d 85 94 fe ff
	ff		 lea	 eax, DWORD PTR __k$544700[ebp]
  02729	c7 85 9c fe ff
	ff 8e 82 9f 00	 mov	 DWORD PTR __k$544700[ebp+8], 10453646 ; 009f828eH
  02733	59		 pop	 ecx
$LL12050@LoadRoomOp:
  02734	31 38		 xor	 DWORD PTR [eax], edi
  02736	83 c0 04	 add	 eax, 4
  02739	49		 dec	 ecx
  0273a	75 f8		 jne	 SHORT $LL12050@LoadRoomOp
  0273c	6a 08		 push	 8
  0273e	58		 pop	 eax
$LL12047@LoadRoomOp:
  0273f	8b c8		 mov	 ecx, eax
  02741	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  02747	79 05		 jns	 SHORT $LN17549@LoadRoomOp
  02749	49		 dec	 ecx
  0274a	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0274d	41		 inc	 ecx
$LN17549@LoadRoomOp:
  0274e	b2 ed		 mov	 dl, -19			; ffffffedH
  02750	2a d1		 sub	 dl, cl
  02752	30 94 05 94 fe
	ff ff		 xor	 BYTE PTR __k$544700[ebp+eax], dl
  02759	40		 inc	 eax
  0275a	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0275d	7c e0		 jl	 SHORT $LL12047@LoadRoomOp
  0275f	53		 push	 ebx
  02760	8d 85 94 fe ff
	ff		 lea	 eax, DWORD PTR __k$544700[ebp]
  02766	50		 push	 eax
  02767	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0276d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 322  : 	for( i=0; i < iTypeCnt; ++i )

  02773	3b c3		 cmp	 eax, ebx
  02775	0f 8e 0b 02 00
	00		 jle	 $LN5092@LoadRoomOp

; 320  : 
; 321  : 	iTypeCnt = kLoader.LoadInt_e( "ko_type_cnt", 0 );

  0277b	c7 85 d8 ec ff
	ff 01 00 00 00	 mov	 DWORD PTR tv126072[ebp], 1
  02785	89 85 d0 ec ff
	ff		 mov	 DWORD PTR tv68730[ebp], eax
$LL5094@LoadRoomOp:

; 323  : 	{
; 324  : 		RoomOptionInfo *pInfo = new RoomOptionInfo;

  0278b	6a 50		 push	 80			; 00000050H
  0278d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  02792	59		 pop	 ecx
  02793	89 85 c4 ec ff
	ff		 mov	 DWORD PTR $T540318[ebp], eax
  02799	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  0279d	3b c3		 cmp	 eax, ebx
  0279f	74 0f		 je	 SHORT $LN8433@LoadRoomOp
  027a1	8b c8		 mov	 ecx, eax
  027a3	e8 00 00 00 00	 call	 ??0RoomOptionInfo@@QAE@XZ ; RoomOptionInfo::RoomOptionInfo
  027a8	89 85 d4 ec ff
	ff		 mov	 DWORD PTR $T540317[ebp], eax
  027ae	eb 06		 jmp	 SHORT $LN8434@LoadRoomOp
$LN8433@LoadRoomOp:
  027b0	89 9d d4 ec ff
	ff		 mov	 DWORD PTR $T540317[ebp], ebx
$LN8434@LoadRoomOp:
  027b6	8b 85 d4 ec ff
	ff		 mov	 eax, DWORD PTR $T540317[ebp]
  027bc	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  027bf	89 85 c8 ec ff
	ff		 mov	 DWORD PTR _pInfo$516029[ebp], eax

; 325  : 		if( !pInfo )

  027c5	3b c3		 cmp	 eax, ebx
  027c7	0f 84 a7 01 00
	00		 je	 $LN5093@LoadRoomOp

; 326  : 			continue;
; 327  : 
; 328  : 		wsprintf_e( szKey, "ko_rate%d", i+1 );

  027cd	6a 02		 push	 2
  027cf	c7 45 a4 86 83
	b4 98		 mov	 DWORD PTR ___encStr$516038[ebp], -1733000314 ; 98b48386H
  027d6	c7 45 a8 8c 98
	8e cf		 mov	 DWORD PTR ___encStr$516038[ebp+4], -812738420 ; cf8e988cH
  027dd	8d 45 a4	 lea	 eax, DWORD PTR ___encStr$516038[ebp]
  027e0	66 c7 45 ac 89
	00		 mov	 WORD PTR ___encStr$516038[ebp+8], 137 ; 00000089H
  027e6	59		 pop	 ecx
$LL12058@LoadRoomOp:
  027e7	31 38		 xor	 DWORD PTR [eax], edi
  027e9	83 c0 04	 add	 eax, 4
  027ec	49		 dec	 ecx
  027ed	75 f8		 jne	 SHORT $LL12058@LoadRoomOp
  027ef	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126072[ebp]
  027f5	80 75 ac ed	 xor	 BYTE PTR ___encStr$516038[ebp+8], -19 ; ffffffedH
  027f9	8d 45 a4	 lea	 eax, DWORD PTR ___encStr$516038[ebp]
  027fc	50		 push	 eax
  027fd	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  02803	50		 push	 eax
  02804	ff d6		 call	 esi
  02806	83 c4 0c	 add	 esp, 12			; 0000000cH

; 329  : 		pInfo->m_fValue = kLoader.LoadFloat( szKey, FLOAT1 );

  02809	b8 01 00 00 00	 mov	 eax, 1
  0280e	89 85 c4 ec ff
	ff		 mov	 DWORD PTR tv126880[ebp], eax
  02814	db 85 c4 ec ff
	ff		 fild	 DWORD PTR tv126880[ebp]
  0281a	85 c0		 test	 eax, eax
  0281c	79 06		 jns	 SHORT $LN17550@LoadRoomOp
  0281e	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN17550@LoadRoomOp:
  02824	51		 push	 ecx
  02825	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  0282b	d9 1c 24	 fstp	 DWORD PTR [esp]
  0282e	50		 push	 eax
  0282f	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02835	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z
  0283b	51		 push	 ecx
  0283c	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540317[ebp]
  02842	d9 1c 24	 fstp	 DWORD PTR [esp]
  02845	e8 00 00 00 00	 call	 ??4?$CEncrypt@M@@QAEMM@Z ; CEncrypt<float>::operator=
  0284a	dd d8		 fstp	 ST(0)
  0284c	6a 02		 push	 2

; 330  : 
; 331  : 		wsprintf_e( szKey, "ko_desc%d", i+1 );

  0284e	c7 85 74 ff ff
	ff 86 83 b4 8e	 mov	 DWORD PTR ___encStr$516191[ebp], -1900772474 ; 8eb48386H
  02858	c7 85 78 ff ff
	ff 88 9f 88 cf	 mov	 DWORD PTR ___encStr$516191[ebp+4], -813129848 ; cf889f88H
  02862	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR ___encStr$516191[ebp]
  02868	66 c7 85 7c ff
	ff ff 89 00	 mov	 WORD PTR ___encStr$516191[ebp+8], 137 ; 00000089H
  02871	59		 pop	 ecx
$LL12068@LoadRoomOp:
  02872	31 38		 xor	 DWORD PTR [eax], edi
  02874	83 c0 04	 add	 eax, 4
  02877	49		 dec	 ecx
  02878	75 f8		 jne	 SHORT $LL12068@LoadRoomOp
  0287a	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126072[ebp]
  02880	80 b5 7c ff ff
	ff ed		 xor	 BYTE PTR ___encStr$516191[ebp+8], -19 ; ffffffedH
  02887	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR ___encStr$516191[ebp]
  0288d	50		 push	 eax
  0288e	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  02894	50		 push	 eax
  02895	ff d6		 call	 esi
  02897	83 c4 0c	 add	 esp, 12			; 0000000cH

; 332  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  0289a	68 04 01 00 00	 push	 260			; 00000104H
  0289f	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  028a5	50		 push	 eax
  028a6	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  028ab	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  028b1	50		 push	 eax
  028b2	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  028b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 333  : 		pInfo->m_Desc = szBuf;

  028be	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540317[ebp]
  028c4	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  028ca	50		 push	 eax
  028cb	83 c1 30	 add	 ecx, 48			; 00000030H
  028ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z
  028d4	6a 03		 push	 3

; 334  : 
; 335  : 		wsprintf_e( szKey, "ko_ui_desc%d", i+1 );

  028d6	c7 85 50 fd ff
	ff 86 83 b4 9f	 mov	 DWORD PTR ___encStr$516343[ebp], -1615559802 ; 9fb48386H
  028e0	c7 85 54 fd ff
	ff 84 b3 8f 8f	 mov	 DWORD PTR ___encStr$516343[ebp+4], -1886407804 ; 8f8fb384H
  028ea	c7 85 58 fd ff
	ff 9e 8f ce 8e	 mov	 DWORD PTR ___encStr$516343[ebp+8], -1899065442 ; 8ece8f9eH
  028f4	8d 85 50 fd ff
	ff		 lea	 eax, DWORD PTR ___encStr$516343[ebp]
  028fa	88 9d 5c fd ff
	ff		 mov	 BYTE PTR ___encStr$516343[ebp+12], bl
  02900	59		 pop	 ecx
$LL12076@LoadRoomOp:
  02901	31 38		 xor	 DWORD PTR [eax], edi
  02903	83 c0 04	 add	 eax, 4
  02906	49		 dec	 ecx
  02907	75 f8		 jne	 SHORT $LL12076@LoadRoomOp
  02909	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126072[ebp]
  0290f	8d 85 50 fd ff
	ff		 lea	 eax, DWORD PTR ___encStr$516343[ebp]
  02915	50		 push	 eax
  02916	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  0291c	50		 push	 eax
  0291d	ff d6		 call	 esi
  0291f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  02922	68 04 01 00 00	 push	 260			; 00000104H
  02927	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  0292d	50		 push	 eax
  0292e	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  02933	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  02939	50		 push	 eax
  0293a	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02940	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 337  : 		pInfo->m_UIDesc = szBuf;

  02946	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540317[ebp]
  0294c	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  02952	50		 push	 eax
  02953	83 c1 40	 add	 ecx, 64			; 00000040H
  02956	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 338  : 
; 339  : 		m_RoomKOList.push_back( pInfo );

  0295c	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  02962	8d 85 c8 ec ff
	ff		 lea	 eax, DWORD PTR _pInfo$516029[ebp]
  02968	50		 push	 eax
  02969	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  0296f	e8 00 00 00 00	 call	 ?push_back@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXABQAURoomOptionInfo@@@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::push_back
$LN5093@LoadRoomOp:

; 322  : 	for( i=0; i < iTypeCnt; ++i )

  02974	ff 85 d8 ec ff
	ff		 inc	 DWORD PTR tv126072[ebp]
  0297a	ff 8d d0 ec ff
	ff		 dec	 DWORD PTR tv68730[ebp]
  02980	0f 85 05 fe ff
	ff		 jne	 $LL5094@LoadRoomOp
$LN5092@LoadRoomOp:

; 340  : 	}
; 341  : 
; 342  : 
; 343  : 	// KO Effect Type
; 344  : 	kLoader.SetTitle_e( "KOEffectType" );

  02986	6a 03		 push	 3
  02988	c7 85 28 fd ff
	ff a6 a3 ae 8c	 mov	 DWORD PTR __t$544905[ebp], -1934711898 ; 8caea3a6H
  02992	c7 85 2c fd ff
	ff 8b 89 88 9e	 mov	 DWORD PTR __t$544905[ebp+4], -1635219061 ; 9e88898bH
  0299c	c7 85 30 fd ff
	ff b9 95 9b 8f	 mov	 DWORD PTR __t$544905[ebp+8], -1885628999 ; 8f9b95b9H
  029a6	8d 85 28 fd ff
	ff		 lea	 eax, DWORD PTR __t$544905[ebp]
  029ac	88 9d 34 fd ff
	ff		 mov	 BYTE PTR __t$544905[ebp+12], bl
  029b2	59		 pop	 ecx
$LL12182@LoadRoomOp:
  029b3	31 38		 xor	 DWORD PTR [eax], edi
  029b5	83 c0 04	 add	 eax, 4
  029b8	49		 dec	 ecx
  029b9	75 f8		 jne	 SHORT $LL12182@LoadRoomOp
  029bb	8d 85 28 fd ff
	ff		 lea	 eax, DWORD PTR __t$544905[ebp]
  029c1	50		 push	 eax
  029c2	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  029c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z
  029ce	6a 04		 push	 4

; 345  : 
; 346  : 	iTypeCnt = kLoader.LoadInt_e( "ko_effect_type_cnt", 0 );

  029d0	c7 85 7c f8 ff
	ff 86 83 b4 8f	 mov	 DWORD PTR __k$544990[ebp], -1883995258 ; 8fb48386H
  029da	c7 85 80 f8 ff
	ff 8b 8a 8e 89	 mov	 DWORD PTR __k$544990[ebp+4], -1987147125 ; 898e8a8bH
  029e4	c7 85 84 f8 ff
	ff 99 b3 9f 93	 mov	 DWORD PTR __k$544990[ebp+8], -1818250343 ; 939fb399H
  029ee	c7 85 88 f8 ff
	ff 9d 89 b4 89	 mov	 DWORD PTR __k$544990[ebp+12], -1984656995 ; 89b4899dH
  029f8	66 c7 85 8c f8
	ff ff 83 98	 mov	 WORD PTR __k$544990[ebp+16], 39043 ; 00009883H
  02a01	8d 85 7c f8 ff
	ff		 lea	 eax, DWORD PTR __k$544990[ebp]
  02a07	88 9d 8e f8 ff
	ff		 mov	 BYTE PTR __k$544990[ebp+18], bl
  02a0d	59		 pop	 ecx
$LL12288@LoadRoomOp:
  02a0e	31 38		 xor	 DWORD PTR [eax], edi
  02a10	83 c0 04	 add	 eax, 4
  02a13	49		 dec	 ecx
  02a14	75 f8		 jne	 SHORT $LL12288@LoadRoomOp
  02a16	6a 10		 push	 16			; 00000010H
  02a18	58		 pop	 eax
$LL12285@LoadRoomOp:
  02a19	8b c8		 mov	 ecx, eax
  02a1b	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  02a21	79 05		 jns	 SHORT $LN17551@LoadRoomOp
  02a23	49		 dec	 ecx
  02a24	83 c9 fc	 or	 ecx, -4			; fffffffcH
  02a27	41		 inc	 ecx
$LN17551@LoadRoomOp:
  02a28	b2 ed		 mov	 dl, -19			; ffffffedH
  02a2a	2a d1		 sub	 dl, cl
  02a2c	30 94 05 7c f8
	ff ff		 xor	 BYTE PTR __k$544990[ebp+eax], dl
  02a33	40		 inc	 eax
  02a34	83 f8 12	 cmp	 eax, 18			; 00000012H
  02a37	7c e0		 jl	 SHORT $LL12285@LoadRoomOp
  02a39	53		 push	 ebx
  02a3a	8d 85 7c f8 ff
	ff		 lea	 eax, DWORD PTR __k$544990[ebp]
  02a40	50		 push	 eax
  02a41	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02a47	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 347  : 	for( i=0; i < iTypeCnt; ++i )

  02a4d	3b c3		 cmp	 eax, ebx
  02a4f	0f 8e 62 02 00
	00		 jle	 $LN4791@LoadRoomOp

; 345  : 
; 346  : 	iTypeCnt = kLoader.LoadInt_e( "ko_effect_type_cnt", 0 );

  02a55	c7 85 d8 ec ff
	ff 01 00 00 00	 mov	 DWORD PTR tv126135[ebp], 1
  02a5f	89 85 d0 ec ff
	ff		 mov	 DWORD PTR tv67597[ebp], eax
$LL4793@LoadRoomOp:

; 348  : 	{
; 349  : 		RoomOptionInfo *pInfo = new RoomOptionInfo;

  02a65	6a 50		 push	 80			; 00000050H
  02a67	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  02a6c	59		 pop	 ecx
  02a6d	89 85 c4 ec ff
	ff		 mov	 DWORD PTR $T540322[ebp], eax
  02a73	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  02a77	3b c3		 cmp	 eax, ebx
  02a79	74 0f		 je	 SHORT $LN8435@LoadRoomOp
  02a7b	8b c8		 mov	 ecx, eax
  02a7d	e8 00 00 00 00	 call	 ??0RoomOptionInfo@@QAE@XZ ; RoomOptionInfo::RoomOptionInfo
  02a82	89 85 d4 ec ff
	ff		 mov	 DWORD PTR $T540321[ebp], eax
  02a88	eb 06		 jmp	 SHORT $LN8436@LoadRoomOp
$LN8435@LoadRoomOp:
  02a8a	89 9d d4 ec ff
	ff		 mov	 DWORD PTR $T540321[ebp], ebx
$LN8436@LoadRoomOp:
  02a90	8b 85 d4 ec ff
	ff		 mov	 eax, DWORD PTR $T540321[ebp]
  02a96	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  02a99	89 85 c8 ec ff
	ff		 mov	 DWORD PTR _pInfo$516497[ebp], eax

; 350  : 		if( !pInfo )

  02a9f	3b c3		 cmp	 eax, ebx
  02aa1	0f 84 fe 01 00
	00		 je	 $LN4792@LoadRoomOp

; 351  : 			continue;
; 352  : 
; 353  : 		wsprintf_e( szKey, "ko_effect_rate%d", i+1 );

  02aa7	6a 04		 push	 4
  02aa9	c7 85 ac f8 ff
	ff 86 83 b4 8f	 mov	 DWORD PTR ___encStr$516506[ebp], -1883995258 ; 8fb48386H
  02ab3	c7 85 b0 f8 ff
	ff 8b 8a 8e 89	 mov	 DWORD PTR ___encStr$516506[ebp+4], -1987147125 ; 898e8a8bH
  02abd	c7 85 b4 f8 ff
	ff 99 b3 99 8b	 mov	 DWORD PTR ___encStr$516506[ebp+8], -1952861287 ; 8b99b399H
  02ac7	c7 85 b8 f8 ff
	ff 99 89 ce 8e	 mov	 DWORD PTR ___encStr$516506[ebp+12], -1899066983 ; 8ece8999H
  02ad1	8d 85 ac f8 ff
	ff		 lea	 eax, DWORD PTR ___encStr$516506[ebp]
  02ad7	88 9d bc f8 ff
	ff		 mov	 BYTE PTR ___encStr$516506[ebp+16], bl
  02add	59		 pop	 ecx
$LL12296@LoadRoomOp:
  02ade	31 38		 xor	 DWORD PTR [eax], edi
  02ae0	83 c0 04	 add	 eax, 4
  02ae3	49		 dec	 ecx
  02ae4	75 f8		 jne	 SHORT $LL12296@LoadRoomOp
  02ae6	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126135[ebp]
  02aec	8d 85 ac f8 ff
	ff		 lea	 eax, DWORD PTR ___encStr$516506[ebp]
  02af2	50		 push	 eax
  02af3	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  02af9	50		 push	 eax
  02afa	ff d6		 call	 esi
  02afc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 354  : 		pInfo->m_fValue = kLoader.LoadFloat( szKey, FLOAT1 );

  02aff	b8 01 00 00 00	 mov	 eax, 1
  02b04	89 85 c4 ec ff
	ff		 mov	 DWORD PTR tv126850[ebp], eax
  02b0a	db 85 c4 ec ff
	ff		 fild	 DWORD PTR tv126850[ebp]
  02b10	85 c0		 test	 eax, eax
  02b12	79 06		 jns	 SHORT $LN17552@LoadRoomOp
  02b14	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN17552@LoadRoomOp:
  02b1a	51		 push	 ecx
  02b1b	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  02b21	d9 1c 24	 fstp	 DWORD PTR [esp]
  02b24	50		 push	 eax
  02b25	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02b2b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z
  02b31	51		 push	 ecx
  02b32	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540321[ebp]
  02b38	d9 1c 24	 fstp	 DWORD PTR [esp]
  02b3b	e8 00 00 00 00	 call	 ??4?$CEncrypt@M@@QAEMM@Z ; CEncrypt<float>::operator=
  02b40	dd d8		 fstp	 ST(0)
  02b42	6a 04		 push	 4

; 355  : 
; 356  : 		wsprintf_e( szKey, "ko_effect_desc%d", i+1 );

  02b44	c7 85 0c f9 ff
	ff 86 83 b4 8f	 mov	 DWORD PTR ___encStr$516659[ebp], -1883995258 ; 8fb48386H
  02b4e	c7 85 10 f9 ff
	ff 8b 8a 8e 89	 mov	 DWORD PTR ___encStr$516659[ebp+4], -1987147125 ; 898e8a8bH
  02b58	c7 85 14 f9 ff
	ff 99 b3 8f 8f	 mov	 DWORD PTR ___encStr$516659[ebp+8], -1886407783 ; 8f8fb399H
  02b62	c7 85 18 f9 ff
	ff 9e 8f ce 8e	 mov	 DWORD PTR ___encStr$516659[ebp+12], -1899065442 ; 8ece8f9eH
  02b6c	8d 85 0c f9 ff
	ff		 lea	 eax, DWORD PTR ___encStr$516659[ebp]
  02b72	88 9d 1c f9 ff
	ff		 mov	 BYTE PTR ___encStr$516659[ebp+16], bl
  02b78	59		 pop	 ecx
$LL12306@LoadRoomOp:
  02b79	31 38		 xor	 DWORD PTR [eax], edi
  02b7b	83 c0 04	 add	 eax, 4
  02b7e	49		 dec	 ecx
  02b7f	75 f8		 jne	 SHORT $LL12306@LoadRoomOp
  02b81	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126135[ebp]
  02b87	8d 85 0c f9 ff
	ff		 lea	 eax, DWORD PTR ___encStr$516659[ebp]
  02b8d	50		 push	 eax
  02b8e	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  02b94	50		 push	 eax
  02b95	ff d6		 call	 esi
  02b97	83 c4 0c	 add	 esp, 12			; 0000000cH

; 357  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  02b9a	68 04 01 00 00	 push	 260			; 00000104H
  02b9f	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  02ba5	50		 push	 eax
  02ba6	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  02bab	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  02bb1	50		 push	 eax
  02bb2	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02bb8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 358  : 		pInfo->m_Desc = szBuf;

  02bbe	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540321[ebp]
  02bc4	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  02bca	50		 push	 eax
  02bcb	83 c1 30	 add	 ecx, 48			; 00000030H
  02bce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z
  02bd4	6a 04		 push	 4

; 359  : 
; 360  : 		wsprintf_e( szKey, "ko_effect_ui_desc%d", i+1 );

  02bd6	c7 85 cc f6 ff
	ff 86 83 b4 8f	 mov	 DWORD PTR ___encStr$516811[ebp], -1883995258 ; 8fb48386H
  02be0	c7 85 d0 f6 ff
	ff 8b 8a 8e 89	 mov	 DWORD PTR ___encStr$516811[ebp+4], -1987147125 ; 898e8a8bH
  02bea	c7 85 d4 f6 ff
	ff 99 b3 9e 83	 mov	 DWORD PTR ___encStr$516811[ebp+8], -2086751335 ; 839eb399H
  02bf4	c7 85 d8 f6 ff
	ff b2 88 8e 99	 mov	 DWORD PTR ___encStr$516811[ebp+12], -1718712142 ; 998e88b2H
  02bfe	8d 85 cc f6 ff
	ff		 lea	 eax, DWORD PTR ___encStr$516811[ebp]
  02c04	c7 85 dc f6 ff
	ff 8e c9 8f 00	 mov	 DWORD PTR ___encStr$516811[ebp+16], 9423246 ; 008fc98eH
  02c0e	59		 pop	 ecx
$LL12314@LoadRoomOp:
  02c0f	31 38		 xor	 DWORD PTR [eax], edi
  02c11	83 c0 04	 add	 eax, 4
  02c14	49		 dec	 ecx
  02c15	75 f8		 jne	 SHORT $LL12314@LoadRoomOp
  02c17	6a 10		 push	 16			; 00000010H
  02c19	58		 pop	 eax
$LL12311@LoadRoomOp:
  02c1a	8b c8		 mov	 ecx, eax
  02c1c	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  02c22	79 05		 jns	 SHORT $LN17553@LoadRoomOp
  02c24	49		 dec	 ecx
  02c25	83 c9 fc	 or	 ecx, -4			; fffffffcH
  02c28	41		 inc	 ecx
$LN17553@LoadRoomOp:
  02c29	b2 ed		 mov	 dl, -19			; ffffffedH
  02c2b	2a d1		 sub	 dl, cl
  02c2d	30 94 05 cc f6
	ff ff		 xor	 BYTE PTR ___encStr$516811[ebp+eax], dl
  02c34	40		 inc	 eax
  02c35	83 f8 13	 cmp	 eax, 19			; 00000013H
  02c38	7c e0		 jl	 SHORT $LL12311@LoadRoomOp
  02c3a	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126135[ebp]
  02c40	8d 85 cc f6 ff
	ff		 lea	 eax, DWORD PTR ___encStr$516811[ebp]
  02c46	50		 push	 eax
  02c47	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  02c4d	50		 push	 eax
  02c4e	ff d6		 call	 esi
  02c50	83 c4 0c	 add	 esp, 12			; 0000000cH

; 361  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  02c53	68 04 01 00 00	 push	 260			; 00000104H
  02c58	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  02c5e	50		 push	 eax
  02c5f	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  02c64	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  02c6a	50		 push	 eax
  02c6b	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02c71	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 362  : 		pInfo->m_UIDesc = szBuf;

  02c77	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540321[ebp]
  02c7d	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  02c83	50		 push	 eax
  02c84	83 c1 40	 add	 ecx, 64			; 00000040H
  02c87	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 363  : 
; 364  : 		m_RoomKOEffectList.push_back( pInfo );

  02c8d	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  02c93	8d 85 c8 ec ff
	ff		 lea	 eax, DWORD PTR _pInfo$516497[ebp]
  02c99	50		 push	 eax
  02c9a	81 c1 e4 00 00
	00		 add	 ecx, 228		; 000000e4H
  02ca0	e8 00 00 00 00	 call	 ?push_back@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXABQAURoomOptionInfo@@@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::push_back
$LN4792@LoadRoomOp:

; 347  : 	for( i=0; i < iTypeCnt; ++i )

  02ca5	ff 85 d8 ec ff
	ff		 inc	 DWORD PTR tv126135[ebp]
  02cab	ff 8d d0 ec ff
	ff		 dec	 DWORD PTR tv67597[ebp]
  02cb1	0f 85 ae fd ff
	ff		 jne	 $LL4793@LoadRoomOp
$LN4791@LoadRoomOp:

; 365  : 	}
; 366  : 
; 367  : 
; 368  : 	// Red Blow
; 369  : 	kLoader.SetTitle_e( "RedBlowType" );

  02cb7	6a 02		 push	 2
  02cb9	c7 85 b4 fe ff
	ff bf 89 8f a8	 mov	 DWORD PTR __t$545168[ebp], -1466988097 ; a88f89bfH
  02cc3	c7 85 b8 fe ff
	ff 81 83 9c be	 mov	 DWORD PTR __t$545168[ebp+4], -1097038975 ; be9c8381H
  02ccd	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR __t$545168[ebp]
  02cd3	c7 85 bc fe ff
	ff 94 9c 8e 00	 mov	 DWORD PTR __t$545168[ebp+8], 9346196 ; 008e9c94H
  02cdd	59		 pop	 ecx
$LL12420@LoadRoomOp:
  02cde	31 38		 xor	 DWORD PTR [eax], edi
  02ce0	83 c0 04	 add	 eax, 4
  02ce3	49		 dec	 ecx
  02ce4	75 f8		 jne	 SHORT $LL12420@LoadRoomOp
  02ce6	6a 08		 push	 8
  02ce8	58		 pop	 eax
$LL12417@LoadRoomOp:
  02ce9	8b c8		 mov	 ecx, eax
  02ceb	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  02cf1	79 05		 jns	 SHORT $LN17554@LoadRoomOp
  02cf3	49		 dec	 ecx
  02cf4	83 c9 fc	 or	 ecx, -4			; fffffffcH
  02cf7	41		 inc	 ecx
$LN17554@LoadRoomOp:
  02cf8	b2 ed		 mov	 dl, -19			; ffffffedH
  02cfa	2a d1		 sub	 dl, cl
  02cfc	30 94 05 b4 fe
	ff ff		 xor	 BYTE PTR __t$545168[ebp+eax], dl
  02d03	40		 inc	 eax
  02d04	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  02d07	7c e0		 jl	 SHORT $LL12417@LoadRoomOp
  02d09	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR __t$545168[ebp]
  02d0f	50		 push	 eax
  02d10	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02d16	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z
  02d1c	6a 03		 push	 3

; 370  : 
; 371  : 	iTypeCnt = kLoader.LoadInt_e( "blow_type_cnt", 0 );

  02d1e	c7 85 88 fc ff
	ff 8f 80 84 9d	 mov	 DWORD PTR __k$545293[ebp], -1652260721 ; 9d84808fH
  02d28	c7 85 8c fc ff
	ff b2 98 92 9a	 mov	 DWORD PTR __k$545293[ebp+4], -1701668686 ; 9a9298b2H
  02d32	c7 85 90 fc ff
	ff 88 b3 88 84	 mov	 DWORD PTR __k$545293[ebp+8], -2071415928 ; 8488b388H
  02d3c	8d 85 88 fc ff
	ff		 lea	 eax, DWORD PTR __k$545293[ebp]
  02d42	66 c7 85 94 fc
	ff ff 99 00	 mov	 WORD PTR __k$545293[ebp+12], 153 ; 00000099H
  02d4b	59		 pop	 ecx
$LL12526@LoadRoomOp:
  02d4c	31 38		 xor	 DWORD PTR [eax], edi
  02d4e	83 c0 04	 add	 eax, 4
  02d51	49		 dec	 ecx
  02d52	75 f8		 jne	 SHORT $LL12526@LoadRoomOp
  02d54	80 b5 94 fc ff
	ff ed		 xor	 BYTE PTR __k$545293[ebp+12], -19 ; ffffffedH
  02d5b	53		 push	 ebx
  02d5c	8d 85 88 fc ff
	ff		 lea	 eax, DWORD PTR __k$545293[ebp]
  02d62	50		 push	 eax
  02d63	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02d69	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 372  : 	for( i=0; i < iTypeCnt; ++i )

  02d6f	3b c3		 cmp	 eax, ebx
  02d71	0f 8e 83 02 00
	00		 jle	 $LN4490@LoadRoomOp

; 370  : 
; 371  : 	iTypeCnt = kLoader.LoadInt_e( "blow_type_cnt", 0 );

  02d77	c7 85 d8 ec ff
	ff 01 00 00 00	 mov	 DWORD PTR tv126244[ebp], 1
  02d81	89 85 d0 ec ff
	ff		 mov	 DWORD PTR tv65951[ebp], eax
$LL4492@LoadRoomOp:

; 373  : 	{
; 374  : 		RoomOptionInfo *pInfo = new RoomOptionInfo;

  02d87	6a 50		 push	 80			; 00000050H
  02d89	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  02d8e	59		 pop	 ecx
  02d8f	89 85 c4 ec ff
	ff		 mov	 DWORD PTR $T540326[ebp], eax
  02d95	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  02d99	3b c3		 cmp	 eax, ebx
  02d9b	74 0f		 je	 SHORT $LN8437@LoadRoomOp
  02d9d	8b c8		 mov	 ecx, eax
  02d9f	e8 00 00 00 00	 call	 ??0RoomOptionInfo@@QAE@XZ ; RoomOptionInfo::RoomOptionInfo
  02da4	89 85 d4 ec ff
	ff		 mov	 DWORD PTR $T540325[ebp], eax
  02daa	eb 06		 jmp	 SHORT $LN8438@LoadRoomOp
$LN8437@LoadRoomOp:
  02dac	89 9d d4 ec ff
	ff		 mov	 DWORD PTR $T540325[ebp], ebx
$LN8438@LoadRoomOp:
  02db2	8b 85 d4 ec ff
	ff		 mov	 eax, DWORD PTR $T540325[ebp]
  02db8	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  02dbb	89 85 c8 ec ff
	ff		 mov	 DWORD PTR _pInfo$516969[ebp], eax

; 375  : 		if( !pInfo )

  02dc1	3b c3		 cmp	 eax, ebx
  02dc3	0f 84 1f 02 00
	00		 je	 $LN4491@LoadRoomOp

; 376  : 			continue;
; 377  : 
; 378  : 		wsprintf_e( szKey, "blow_rate%d", i+1 );

  02dc9	6a 02		 push	 2
  02dcb	c7 85 c4 fe ff
	ff 8f 80 84 9d	 mov	 DWORD PTR ___encStr$516978[ebp], -1652260721 ; 9d84808fH
  02dd5	c7 85 c8 fe ff
	ff b2 9e 8a 9e	 mov	 DWORD PTR ___encStr$516978[ebp+4], -1635082574 ; 9e8a9eb2H
  02ddf	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR ___encStr$516978[ebp]
  02de5	c7 85 cc fe ff
	ff 88 c9 8f 00	 mov	 DWORD PTR ___encStr$516978[ebp+8], 9423240 ; 008fc988H
  02def	59		 pop	 ecx
$LL12534@LoadRoomOp:
  02df0	31 38		 xor	 DWORD PTR [eax], edi
  02df2	83 c0 04	 add	 eax, 4
  02df5	49		 dec	 ecx
  02df6	75 f8		 jne	 SHORT $LL12534@LoadRoomOp
  02df8	6a 08		 push	 8
  02dfa	58		 pop	 eax
$LL12531@LoadRoomOp:
  02dfb	8b c8		 mov	 ecx, eax
  02dfd	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  02e03	79 05		 jns	 SHORT $LN17555@LoadRoomOp
  02e05	49		 dec	 ecx
  02e06	83 c9 fc	 or	 ecx, -4			; fffffffcH
  02e09	41		 inc	 ecx
$LN17555@LoadRoomOp:
  02e0a	b2 ed		 mov	 dl, -19			; ffffffedH
  02e0c	2a d1		 sub	 dl, cl
  02e0e	30 94 05 c4 fe
	ff ff		 xor	 BYTE PTR ___encStr$516978[ebp+eax], dl
  02e15	40		 inc	 eax
  02e16	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  02e19	7c e0		 jl	 SHORT $LL12531@LoadRoomOp
  02e1b	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126244[ebp]
  02e21	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR ___encStr$516978[ebp]
  02e27	50		 push	 eax
  02e28	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  02e2e	50		 push	 eax
  02e2f	ff d6		 call	 esi
  02e31	83 c4 0c	 add	 esp, 12			; 0000000cH

; 379  : 		pInfo->m_fValue = kLoader.LoadFloat( szKey, FLOAT1 );

  02e34	b8 01 00 00 00	 mov	 eax, 1
  02e39	89 85 c4 ec ff
	ff		 mov	 DWORD PTR tv126815[ebp], eax
  02e3f	db 85 c4 ec ff
	ff		 fild	 DWORD PTR tv126815[ebp]
  02e45	85 c0		 test	 eax, eax
  02e47	79 06		 jns	 SHORT $LN17556@LoadRoomOp
  02e49	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN17556@LoadRoomOp:
  02e4f	51		 push	 ecx
  02e50	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  02e56	d9 1c 24	 fstp	 DWORD PTR [esp]
  02e59	50		 push	 eax
  02e5a	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02e60	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z
  02e66	51		 push	 ecx
  02e67	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540325[ebp]
  02e6d	d9 1c 24	 fstp	 DWORD PTR [esp]
  02e70	e8 00 00 00 00	 call	 ??4?$CEncrypt@M@@QAEMM@Z ; CEncrypt<float>::operator=
  02e75	dd d8		 fstp	 ST(0)
  02e77	6a 02		 push	 2

; 380  : 
; 381  : 		wsprintf_e( szKey, "blow_desc%d", i+1 );

  02e79	c7 85 64 fe ff
	ff 8f 80 84 9d	 mov	 DWORD PTR ___encStr$517131[ebp], -1652260721 ; 9d84808fH
  02e83	c7 85 68 fe ff
	ff b2 88 8e 99	 mov	 DWORD PTR ___encStr$517131[ebp+4], -1718712142 ; 998e88b2H
  02e8d	8d 85 64 fe ff
	ff		 lea	 eax, DWORD PTR ___encStr$517131[ebp]
  02e93	c7 85 6c fe ff
	ff 8e c9 8f 00	 mov	 DWORD PTR ___encStr$517131[ebp+8], 9423246 ; 008fc98eH
  02e9d	59		 pop	 ecx
$LL12544@LoadRoomOp:
  02e9e	31 38		 xor	 DWORD PTR [eax], edi
  02ea0	83 c0 04	 add	 eax, 4
  02ea3	49		 dec	 ecx
  02ea4	75 f8		 jne	 SHORT $LL12544@LoadRoomOp
  02ea6	6a 08		 push	 8
  02ea8	58		 pop	 eax
$LL12541@LoadRoomOp:
  02ea9	8b c8		 mov	 ecx, eax
  02eab	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  02eb1	79 05		 jns	 SHORT $LN17557@LoadRoomOp
  02eb3	49		 dec	 ecx
  02eb4	83 c9 fc	 or	 ecx, -4			; fffffffcH
  02eb7	41		 inc	 ecx
$LN17557@LoadRoomOp:
  02eb8	b2 ed		 mov	 dl, -19			; ffffffedH
  02eba	2a d1		 sub	 dl, cl
  02ebc	30 94 05 64 fe
	ff ff		 xor	 BYTE PTR ___encStr$517131[ebp+eax], dl
  02ec3	40		 inc	 eax
  02ec4	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  02ec7	7c e0		 jl	 SHORT $LL12541@LoadRoomOp
  02ec9	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126244[ebp]
  02ecf	8d 85 64 fe ff
	ff		 lea	 eax, DWORD PTR ___encStr$517131[ebp]
  02ed5	50		 push	 eax
  02ed6	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  02edc	50		 push	 eax
  02edd	ff d6		 call	 esi
  02edf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 382  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  02ee2	68 04 01 00 00	 push	 260			; 00000104H
  02ee7	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  02eed	50		 push	 eax
  02eee	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  02ef3	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  02ef9	50		 push	 eax
  02efa	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02f00	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 383  : 		pInfo->m_Desc = szBuf;

  02f06	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540325[ebp]
  02f0c	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  02f12	50		 push	 eax
  02f13	83 c1 30	 add	 ecx, 48			; 00000030H
  02f16	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z
  02f1c	6a 03		 push	 3

; 384  : 
; 385  : 		wsprintf_e( szKey, "blow_ui_desc%d", i+1 );

  02f1e	c7 85 60 fc ff
	ff 8f 80 84 9d	 mov	 DWORD PTR ___encStr$517283[ebp], -1652260721 ; 9d84808fH
  02f28	c7 85 64 fc ff
	ff b2 99 82 b5	 mov	 DWORD PTR ___encStr$517283[ebp+4], -1249732174 ; b58299b2H
  02f32	c7 85 68 fc ff
	ff 89 89 98 89	 mov	 DWORD PTR ___encStr$517283[ebp+8], -1986492023 ; 89988989H
  02f3c	66 c7 85 6c fc
	ff ff c8 88	 mov	 WORD PTR ___encStr$517283[ebp+12], 35016 ; 000088c8H
  02f45	8d 85 60 fc ff
	ff		 lea	 eax, DWORD PTR ___encStr$517283[ebp]
  02f4b	88 9d 6e fc ff
	ff		 mov	 BYTE PTR ___encStr$517283[ebp+14], bl
  02f51	59		 pop	 ecx
$LL12552@LoadRoomOp:
  02f52	31 38		 xor	 DWORD PTR [eax], edi
  02f54	83 c0 04	 add	 eax, 4
  02f57	49		 dec	 ecx
  02f58	75 f8		 jne	 SHORT $LL12552@LoadRoomOp
  02f5a	6a 0c		 push	 12			; 0000000cH
  02f5c	58		 pop	 eax
$LL12549@LoadRoomOp:
  02f5d	8b c8		 mov	 ecx, eax
  02f5f	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  02f65	79 05		 jns	 SHORT $LN17558@LoadRoomOp
  02f67	49		 dec	 ecx
  02f68	83 c9 fc	 or	 ecx, -4			; fffffffcH
  02f6b	41		 inc	 ecx
$LN17558@LoadRoomOp:
  02f6c	b2 ed		 mov	 dl, -19			; ffffffedH
  02f6e	2a d1		 sub	 dl, cl
  02f70	30 94 05 60 fc
	ff ff		 xor	 BYTE PTR ___encStr$517283[ebp+eax], dl
  02f77	40		 inc	 eax
  02f78	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  02f7b	7c e0		 jl	 SHORT $LL12549@LoadRoomOp
  02f7d	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126244[ebp]
  02f83	8d 85 60 fc ff
	ff		 lea	 eax, DWORD PTR ___encStr$517283[ebp]
  02f89	50		 push	 eax
  02f8a	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  02f90	50		 push	 eax
  02f91	ff d6		 call	 esi
  02f93	83 c4 0c	 add	 esp, 12			; 0000000cH

; 386  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  02f96	68 04 01 00 00	 push	 260			; 00000104H
  02f9b	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  02fa1	50		 push	 eax
  02fa2	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  02fa7	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  02fad	50		 push	 eax
  02fae	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02fb4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 387  : 		pInfo->m_UIDesc = szBuf;

  02fba	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540325[ebp]
  02fc0	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  02fc6	50		 push	 eax
  02fc7	83 c1 40	 add	 ecx, 64			; 00000040H
  02fca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 388  : 
; 389  : 		m_RoomRedBlowList.push_back( pInfo );

  02fd0	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  02fd6	8d 85 c8 ec ff
	ff		 lea	 eax, DWORD PTR _pInfo$516969[ebp]
  02fdc	50		 push	 eax
  02fdd	81 c1 f4 00 00
	00		 add	 ecx, 244		; 000000f4H
  02fe3	e8 00 00 00 00	 call	 ?push_back@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXABQAURoomOptionInfo@@@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::push_back
$LN4491@LoadRoomOp:

; 372  : 	for( i=0; i < iTypeCnt; ++i )

  02fe8	ff 85 d8 ec ff
	ff		 inc	 DWORD PTR tv126244[ebp]
  02fee	ff 8d d0 ec ff
	ff		 dec	 DWORD PTR tv65951[ebp]
  02ff4	0f 85 8d fd ff
	ff		 jne	 $LL4492@LoadRoomOp
$LN4490@LoadRoomOp:

; 390  : 	}
; 391  : 
; 392  : 	// Blue Blow
; 393  : 	kLoader.SetTitle_e( "BlueBlowType" );

  02ffa	6a 03		 push	 3
  02ffc	c7 85 78 fd ff
	ff af 80 9e 8f	 mov	 DWORD PTR __t$545485[ebp], -1885437777 ; 8f9e80afH
  03006	c7 85 7c fd ff
	ff af 80 84 9d	 mov	 DWORD PTR __t$545485[ebp+4], -1652260689 ; 9d8480afH
  03010	c7 85 80 fd ff
	ff b9 95 9b 8f	 mov	 DWORD PTR __t$545485[ebp+8], -1885628999 ; 8f9b95b9H
  0301a	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR __t$545485[ebp]
  03020	88 9d 84 fd ff
	ff		 mov	 BYTE PTR __t$545485[ebp+12], bl
  03026	59		 pop	 ecx
$LL12658@LoadRoomOp:
  03027	31 38		 xor	 DWORD PTR [eax], edi
  03029	83 c0 04	 add	 eax, 4
  0302c	49		 dec	 ecx
  0302d	75 f8		 jne	 SHORT $LL12658@LoadRoomOp
  0302f	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR __t$545485[ebp]
  03035	50		 push	 eax
  03036	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0303c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z
  03042	6a 03		 push	 3

; 394  : 
; 395  : 	iTypeCnt = kLoader.LoadInt_e( "blow_type_cnt", 0 );

  03044	c7 85 d8 fc ff
	ff 8f 80 84 9d	 mov	 DWORD PTR __k$545583[ebp], -1652260721 ; 9d84808fH
  0304e	c7 85 dc fc ff
	ff b2 98 92 9a	 mov	 DWORD PTR __k$545583[ebp+4], -1701668686 ; 9a9298b2H
  03058	c7 85 e0 fc ff
	ff 88 b3 88 84	 mov	 DWORD PTR __k$545583[ebp+8], -2071415928 ; 8488b388H
  03062	8d 85 d8 fc ff
	ff		 lea	 eax, DWORD PTR __k$545583[ebp]
  03068	66 c7 85 e4 fc
	ff ff 99 00	 mov	 WORD PTR __k$545583[ebp+12], 153 ; 00000099H
  03071	59		 pop	 ecx
$LL12764@LoadRoomOp:
  03072	31 38		 xor	 DWORD PTR [eax], edi
  03074	83 c0 04	 add	 eax, 4
  03077	49		 dec	 ecx
  03078	75 f8		 jne	 SHORT $LL12764@LoadRoomOp
  0307a	80 b5 e4 fc ff
	ff ed		 xor	 BYTE PTR __k$545583[ebp+12], -19 ; ffffffedH
  03081	53		 push	 ebx
  03082	8d 85 d8 fc ff
	ff		 lea	 eax, DWORD PTR __k$545583[ebp]
  03088	50		 push	 eax
  03089	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0308f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 396  : 	for( i=0; i < iTypeCnt; ++i )

  03095	3b c3		 cmp	 eax, ebx
  03097	0f 8e 83 02 00
	00		 jle	 $LN4189@LoadRoomOp

; 394  : 
; 395  : 	iTypeCnt = kLoader.LoadInt_e( "blow_type_cnt", 0 );

  0309d	c7 85 d8 ec ff
	ff 01 00 00 00	 mov	 DWORD PTR tv126337[ebp], 1
  030a7	89 85 d0 ec ff
	ff		 mov	 DWORD PTR tv64458[ebp], eax
$LL4191@LoadRoomOp:

; 397  : 	{
; 398  : 		RoomOptionInfo *pInfo = new RoomOptionInfo;

  030ad	6a 50		 push	 80			; 00000050H
  030af	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  030b4	59		 pop	 ecx
  030b5	89 85 c4 ec ff
	ff		 mov	 DWORD PTR $T540330[ebp], eax
  030bb	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  030bf	3b c3		 cmp	 eax, ebx
  030c1	74 0f		 je	 SHORT $LN8439@LoadRoomOp
  030c3	8b c8		 mov	 ecx, eax
  030c5	e8 00 00 00 00	 call	 ??0RoomOptionInfo@@QAE@XZ ; RoomOptionInfo::RoomOptionInfo
  030ca	89 85 d4 ec ff
	ff		 mov	 DWORD PTR $T540329[ebp], eax
  030d0	eb 06		 jmp	 SHORT $LN8440@LoadRoomOp
$LN8439@LoadRoomOp:
  030d2	89 9d d4 ec ff
	ff		 mov	 DWORD PTR $T540329[ebp], ebx
$LN8440@LoadRoomOp:
  030d8	8b 85 d4 ec ff
	ff		 mov	 eax, DWORD PTR $T540329[ebp]
  030de	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  030e1	89 85 c8 ec ff
	ff		 mov	 DWORD PTR _pInfo$517436[ebp], eax

; 399  : 		if( !pInfo )

  030e7	3b c3		 cmp	 eax, ebx
  030e9	0f 84 1f 02 00
	00		 je	 $LN4190@LoadRoomOp

; 400  : 			continue;
; 401  : 
; 402  : 		wsprintf_e( szKey, "blow_rate%d", i+1 );

  030ef	6a 02		 push	 2
  030f1	c7 85 a4 fe ff
	ff 8f 80 84 9d	 mov	 DWORD PTR ___encStr$517445[ebp], -1652260721 ; 9d84808fH
  030fb	c7 85 a8 fe ff
	ff b2 9e 8a 9e	 mov	 DWORD PTR ___encStr$517445[ebp+4], -1635082574 ; 9e8a9eb2H
  03105	8d 85 a4 fe ff
	ff		 lea	 eax, DWORD PTR ___encStr$517445[ebp]
  0310b	c7 85 ac fe ff
	ff 88 c9 8f 00	 mov	 DWORD PTR ___encStr$517445[ebp+8], 9423240 ; 008fc988H
  03115	59		 pop	 ecx
$LL12772@LoadRoomOp:
  03116	31 38		 xor	 DWORD PTR [eax], edi
  03118	83 c0 04	 add	 eax, 4
  0311b	49		 dec	 ecx
  0311c	75 f8		 jne	 SHORT $LL12772@LoadRoomOp
  0311e	6a 08		 push	 8
  03120	58		 pop	 eax
$LL12769@LoadRoomOp:
  03121	8b c8		 mov	 ecx, eax
  03123	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  03129	79 05		 jns	 SHORT $LN17559@LoadRoomOp
  0312b	49		 dec	 ecx
  0312c	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0312f	41		 inc	 ecx
$LN17559@LoadRoomOp:
  03130	b2 ed		 mov	 dl, -19			; ffffffedH
  03132	2a d1		 sub	 dl, cl
  03134	30 94 05 a4 fe
	ff ff		 xor	 BYTE PTR ___encStr$517445[ebp+eax], dl
  0313b	40		 inc	 eax
  0313c	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0313f	7c e0		 jl	 SHORT $LL12769@LoadRoomOp
  03141	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126337[ebp]
  03147	8d 85 a4 fe ff
	ff		 lea	 eax, DWORD PTR ___encStr$517445[ebp]
  0314d	50		 push	 eax
  0314e	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  03154	50		 push	 eax
  03155	ff d6		 call	 esi
  03157	83 c4 0c	 add	 esp, 12			; 0000000cH

; 403  : 		pInfo->m_fValue = kLoader.LoadFloat( szKey, FLOAT1 );

  0315a	b8 01 00 00 00	 mov	 eax, 1
  0315f	89 85 c4 ec ff
	ff		 mov	 DWORD PTR tv126781[ebp], eax
  03165	db 85 c4 ec ff
	ff		 fild	 DWORD PTR tv126781[ebp]
  0316b	85 c0		 test	 eax, eax
  0316d	79 06		 jns	 SHORT $LN17560@LoadRoomOp
  0316f	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN17560@LoadRoomOp:
  03175	51		 push	 ecx
  03176	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  0317c	d9 1c 24	 fstp	 DWORD PTR [esp]
  0317f	50		 push	 eax
  03180	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03186	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z
  0318c	51		 push	 ecx
  0318d	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540329[ebp]
  03193	d9 1c 24	 fstp	 DWORD PTR [esp]
  03196	e8 00 00 00 00	 call	 ??4?$CEncrypt@M@@QAEMM@Z ; CEncrypt<float>::operator=
  0319b	dd d8		 fstp	 ST(0)
  0319d	6a 02		 push	 2

; 404  : 
; 405  : 		wsprintf_e( szKey, "blow_desc%d", i+1 );

  0319f	c7 85 d4 fe ff
	ff 8f 80 84 9d	 mov	 DWORD PTR ___encStr$517597[ebp], -1652260721 ; 9d84808fH
  031a9	c7 85 d8 fe ff
	ff b2 88 8e 99	 mov	 DWORD PTR ___encStr$517597[ebp+4], -1718712142 ; 998e88b2H
  031b3	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR ___encStr$517597[ebp]
  031b9	c7 85 dc fe ff
	ff 8e c9 8f 00	 mov	 DWORD PTR ___encStr$517597[ebp+8], 9423246 ; 008fc98eH
  031c3	59		 pop	 ecx
$LL12782@LoadRoomOp:
  031c4	31 38		 xor	 DWORD PTR [eax], edi
  031c6	83 c0 04	 add	 eax, 4
  031c9	49		 dec	 ecx
  031ca	75 f8		 jne	 SHORT $LL12782@LoadRoomOp
  031cc	6a 08		 push	 8
  031ce	58		 pop	 eax
$LL12779@LoadRoomOp:
  031cf	8b c8		 mov	 ecx, eax
  031d1	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  031d7	79 05		 jns	 SHORT $LN17561@LoadRoomOp
  031d9	49		 dec	 ecx
  031da	83 c9 fc	 or	 ecx, -4			; fffffffcH
  031dd	41		 inc	 ecx
$LN17561@LoadRoomOp:
  031de	b2 ed		 mov	 dl, -19			; ffffffedH
  031e0	2a d1		 sub	 dl, cl
  031e2	30 94 05 d4 fe
	ff ff		 xor	 BYTE PTR ___encStr$517597[ebp+eax], dl
  031e9	40		 inc	 eax
  031ea	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  031ed	7c e0		 jl	 SHORT $LL12779@LoadRoomOp
  031ef	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126337[ebp]
  031f5	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR ___encStr$517597[ebp]
  031fb	50		 push	 eax
  031fc	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  03202	50		 push	 eax
  03203	ff d6		 call	 esi
  03205	83 c4 0c	 add	 esp, 12			; 0000000cH

; 406  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  03208	68 04 01 00 00	 push	 260			; 00000104H
  0320d	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  03213	50		 push	 eax
  03214	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  03219	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  0321f	50		 push	 eax
  03220	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03226	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 407  : 		pInfo->m_Desc = szBuf;

  0322c	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540329[ebp]
  03232	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  03238	50		 push	 eax
  03239	83 c1 30	 add	 ecx, 48			; 00000030H
  0323c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z
  03242	6a 03		 push	 3

; 408  : 
; 409  : 		wsprintf_e( szKey, "blow_ui_desc%d", i+1 );

  03244	c7 85 4c fc ff
	ff 8f 80 84 9d	 mov	 DWORD PTR ___encStr$517748[ebp], -1652260721 ; 9d84808fH
  0324e	c7 85 50 fc ff
	ff b2 99 82 b5	 mov	 DWORD PTR ___encStr$517748[ebp+4], -1249732174 ; b58299b2H
  03258	c7 85 54 fc ff
	ff 89 89 98 89	 mov	 DWORD PTR ___encStr$517748[ebp+8], -1986492023 ; 89988989H
  03262	66 c7 85 58 fc
	ff ff c8 88	 mov	 WORD PTR ___encStr$517748[ebp+12], 35016 ; 000088c8H
  0326b	8d 85 4c fc ff
	ff		 lea	 eax, DWORD PTR ___encStr$517748[ebp]
  03271	88 9d 5a fc ff
	ff		 mov	 BYTE PTR ___encStr$517748[ebp+14], bl
  03277	59		 pop	 ecx
$LL12790@LoadRoomOp:
  03278	31 38		 xor	 DWORD PTR [eax], edi
  0327a	83 c0 04	 add	 eax, 4
  0327d	49		 dec	 ecx
  0327e	75 f8		 jne	 SHORT $LL12790@LoadRoomOp
  03280	6a 0c		 push	 12			; 0000000cH
  03282	58		 pop	 eax
$LL12787@LoadRoomOp:
  03283	8b c8		 mov	 ecx, eax
  03285	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0328b	79 05		 jns	 SHORT $LN17562@LoadRoomOp
  0328d	49		 dec	 ecx
  0328e	83 c9 fc	 or	 ecx, -4			; fffffffcH
  03291	41		 inc	 ecx
$LN17562@LoadRoomOp:
  03292	b2 ed		 mov	 dl, -19			; ffffffedH
  03294	2a d1		 sub	 dl, cl
  03296	30 94 05 4c fc
	ff ff		 xor	 BYTE PTR ___encStr$517748[ebp+eax], dl
  0329d	40		 inc	 eax
  0329e	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  032a1	7c e0		 jl	 SHORT $LL12787@LoadRoomOp
  032a3	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126337[ebp]
  032a9	8d 85 4c fc ff
	ff		 lea	 eax, DWORD PTR ___encStr$517748[ebp]
  032af	50		 push	 eax
  032b0	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  032b6	50		 push	 eax
  032b7	ff d6		 call	 esi
  032b9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 410  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  032bc	68 04 01 00 00	 push	 260			; 00000104H
  032c1	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  032c7	50		 push	 eax
  032c8	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  032cd	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  032d3	50		 push	 eax
  032d4	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  032da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 411  : 		pInfo->m_UIDesc = szBuf;

  032e0	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540329[ebp]
  032e6	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  032ec	50		 push	 eax
  032ed	83 c1 40	 add	 ecx, 64			; 00000040H
  032f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 412  : 
; 413  : 		m_RoomBlueBlowList.push_back( pInfo );

  032f6	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  032fc	8d 85 c8 ec ff
	ff		 lea	 eax, DWORD PTR _pInfo$517436[ebp]
  03302	50		 push	 eax
  03303	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  03309	e8 00 00 00 00	 call	 ?push_back@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXABQAURoomOptionInfo@@@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::push_back
$LN4190@LoadRoomOp:

; 396  : 	for( i=0; i < iTypeCnt; ++i )

  0330e	ff 85 d8 ec ff
	ff		 inc	 DWORD PTR tv126337[ebp]
  03314	ff 8d d0 ec ff
	ff		 dec	 DWORD PTR tv64458[ebp]
  0331a	0f 85 8d fd ff
	ff		 jne	 $LL4191@LoadRoomOp
$LN4189@LoadRoomOp:

; 414  : 	}
; 415  : 
; 416  : 
; 417  : 	// EquipType
; 418  : 	kLoader.SetTitle_e( "RedEquipType" );

  03320	6a 03		 push	 3
  03322	c7 85 14 fd ff
	ff bf 89 8f af	 mov	 DWORD PTR __t$545762[ebp], -1349547585 ; af8f89bfH
  0332c	c7 85 18 fd ff
	ff 9c 99 82 9a	 mov	 DWORD PTR __t$545762[ebp+4], -1702717028 ; 9a82999cH
  03336	c7 85 1c fd ff
	ff b9 95 9b 8f	 mov	 DWORD PTR __t$545762[ebp+8], -1885628999 ; 8f9b95b9H
  03340	8d 85 14 fd ff
	ff		 lea	 eax, DWORD PTR __t$545762[ebp]
  03346	88 9d 20 fd ff
	ff		 mov	 BYTE PTR __t$545762[ebp+12], bl
  0334c	59		 pop	 ecx
$LL12896@LoadRoomOp:
  0334d	31 38		 xor	 DWORD PTR [eax], edi
  0334f	83 c0 04	 add	 eax, 4
  03352	49		 dec	 ecx
  03353	75 f8		 jne	 SHORT $LL12896@LoadRoomOp
  03355	8d 85 14 fd ff
	ff		 lea	 eax, DWORD PTR __t$545762[ebp]
  0335b	50		 push	 eax
  0335c	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03362	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z
  03368	6a 03		 push	 3

; 419  : 
; 420  : 	iTypeCnt = kLoader.LoadInt_e( "equip_type_cnt", 0 );

  0336a	c7 85 fc fb ff
	ff 88 9d 9e 83	 mov	 DWORD PTR __k$545913[ebp], -2086756984 ; 839e9d88H
  03374	c7 85 00 fc ff
	ff 9d b3 9f 93	 mov	 DWORD PTR __k$545913[ebp+4], -1818250339 ; 939fb39dH
  0337e	c7 85 04 fc ff
	ff 9d 89 b4 89	 mov	 DWORD PTR __k$545913[ebp+8], -1984656995 ; 89b4899dH
  03388	66 c7 85 08 fc
	ff ff 83 98	 mov	 WORD PTR __k$545913[ebp+12], 39043 ; 00009883H
  03391	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR __k$545913[ebp]
  03397	88 9d 0a fc ff
	ff		 mov	 BYTE PTR __k$545913[ebp+14], bl
  0339d	59		 pop	 ecx
$LL13002@LoadRoomOp:
  0339e	31 38		 xor	 DWORD PTR [eax], edi
  033a0	83 c0 04	 add	 eax, 4
  033a3	49		 dec	 ecx
  033a4	75 f8		 jne	 SHORT $LL13002@LoadRoomOp
  033a6	6a 0c		 push	 12			; 0000000cH
  033a8	58		 pop	 eax
$LL12999@LoadRoomOp:
  033a9	8b c8		 mov	 ecx, eax
  033ab	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  033b1	79 05		 jns	 SHORT $LN17563@LoadRoomOp
  033b3	49		 dec	 ecx
  033b4	83 c9 fc	 or	 ecx, -4			; fffffffcH
  033b7	41		 inc	 ecx
$LN17563@LoadRoomOp:
  033b8	b2 ed		 mov	 dl, -19			; ffffffedH
  033ba	2a d1		 sub	 dl, cl
  033bc	30 94 05 fc fb
	ff ff		 xor	 BYTE PTR __k$545913[ebp+eax], dl
  033c3	40		 inc	 eax
  033c4	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  033c7	7c e0		 jl	 SHORT $LL12999@LoadRoomOp
  033c9	53		 push	 ebx
  033ca	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR __k$545913[ebp]
  033d0	50		 push	 eax
  033d1	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  033d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 421  : 	for( i=0; i < iTypeCnt; ++i )

  033dd	3b c3		 cmp	 eax, ebx
  033df	0f 8e 44 02 00
	00		 jle	 $LN3888@LoadRoomOp

; 419  : 
; 420  : 	iTypeCnt = kLoader.LoadInt_e( "equip_type_cnt", 0 );

  033e5	c7 85 d8 ec ff
	ff 01 00 00 00	 mov	 DWORD PTR tv126400[ebp], 1
  033ef	89 85 d0 ec ff
	ff		 mov	 DWORD PTR tv63381[ebp], eax
$LL3890@LoadRoomOp:

; 422  : 	{
; 423  : 		RoomOptionInfo *pInfo = new RoomOptionInfo;

  033f5	6a 50		 push	 80			; 00000050H
  033f7	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  033fc	59		 pop	 ecx
  033fd	89 85 c4 ec ff
	ff		 mov	 DWORD PTR $T540334[ebp], eax
  03403	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  03407	3b c3		 cmp	 eax, ebx
  03409	74 0f		 je	 SHORT $LN8441@LoadRoomOp
  0340b	8b c8		 mov	 ecx, eax
  0340d	e8 00 00 00 00	 call	 ??0RoomOptionInfo@@QAE@XZ ; RoomOptionInfo::RoomOptionInfo
  03412	89 85 d4 ec ff
	ff		 mov	 DWORD PTR $T540333[ebp], eax
  03418	eb 06		 jmp	 SHORT $LN8442@LoadRoomOp
$LN8441@LoadRoomOp:
  0341a	89 9d d4 ec ff
	ff		 mov	 DWORD PTR $T540333[ebp], ebx
$LN8442@LoadRoomOp:
  03420	8b 85 d4 ec ff
	ff		 mov	 eax, DWORD PTR $T540333[ebp]
  03426	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  03429	89 85 c8 ec ff
	ff		 mov	 DWORD PTR _pInfo$517905[ebp], eax

; 424  : 		if( !pInfo )

  0342f	3b c3		 cmp	 eax, ebx
  03431	0f 84 e0 01 00
	00		 je	 $LN3889@LoadRoomOp

; 425  : 			continue;
; 426  : 
; 427  : 		wsprintf_e( szKey, "equip_rate%d", i+1 );

  03437	6a 03		 push	 3
  03439	c7 85 a0 fd ff
	ff 88 9d 9e 83	 mov	 DWORD PTR ___encStr$517914[ebp], -2086756984 ; 839e9d88H
  03443	c7 85 a4 fd ff
	ff 9d b3 99 8b	 mov	 DWORD PTR ___encStr$517914[ebp+4], -1952861283 ; 8b99b39dH
  0344d	c7 85 a8 fd ff
	ff 99 89 ce 8e	 mov	 DWORD PTR ___encStr$517914[ebp+8], -1899066983 ; 8ece8999H
  03457	8d 85 a0 fd ff
	ff		 lea	 eax, DWORD PTR ___encStr$517914[ebp]
  0345d	88 9d ac fd ff
	ff		 mov	 BYTE PTR ___encStr$517914[ebp+12], bl
  03463	59		 pop	 ecx
$LL13010@LoadRoomOp:
  03464	31 38		 xor	 DWORD PTR [eax], edi
  03466	83 c0 04	 add	 eax, 4
  03469	49		 dec	 ecx
  0346a	75 f8		 jne	 SHORT $LL13010@LoadRoomOp
  0346c	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126400[ebp]
  03472	8d 85 a0 fd ff
	ff		 lea	 eax, DWORD PTR ___encStr$517914[ebp]
  03478	50		 push	 eax
  03479	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  0347f	50		 push	 eax
  03480	ff d6		 call	 esi
  03482	83 c4 0c	 add	 esp, 12			; 0000000cH

; 428  : 		pInfo->m_fValue = kLoader.LoadFloat( szKey, FLOAT1 );

  03485	b8 01 00 00 00	 mov	 eax, 1
  0348a	89 85 c4 ec ff
	ff		 mov	 DWORD PTR tv126746[ebp], eax
  03490	db 85 c4 ec ff
	ff		 fild	 DWORD PTR tv126746[ebp]
  03496	85 c0		 test	 eax, eax
  03498	79 06		 jns	 SHORT $LN17564@LoadRoomOp
  0349a	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN17564@LoadRoomOp:
  034a0	51		 push	 ecx
  034a1	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  034a7	d9 1c 24	 fstp	 DWORD PTR [esp]
  034aa	50		 push	 eax
  034ab	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  034b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z
  034b7	51		 push	 ecx
  034b8	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540333[ebp]
  034be	d9 1c 24	 fstp	 DWORD PTR [esp]
  034c1	e8 00 00 00 00	 call	 ??4?$CEncrypt@M@@QAEMM@Z ; CEncrypt<float>::operator=
  034c6	dd d8		 fstp	 ST(0)
  034c8	6a 03		 push	 3

; 429  : 
; 430  : 		wsprintf_e( szKey, "equip_desc%d", i+1 );

  034ca	c7 85 3c fd ff
	ff 88 9d 9e 83	 mov	 DWORD PTR ___encStr$518067[ebp], -2086756984 ; 839e9d88H
  034d4	c7 85 40 fd ff
	ff 9d b3 8f 8f	 mov	 DWORD PTR ___encStr$518067[ebp+4], -1886407779 ; 8f8fb39dH
  034de	c7 85 44 fd ff
	ff 9e 8f ce 8e	 mov	 DWORD PTR ___encStr$518067[ebp+8], -1899065442 ; 8ece8f9eH
  034e8	8d 85 3c fd ff
	ff		 lea	 eax, DWORD PTR ___encStr$518067[ebp]
  034ee	88 9d 48 fd ff
	ff		 mov	 BYTE PTR ___encStr$518067[ebp+12], bl
  034f4	59		 pop	 ecx
$LL13020@LoadRoomOp:
  034f5	31 38		 xor	 DWORD PTR [eax], edi
  034f7	83 c0 04	 add	 eax, 4
  034fa	49		 dec	 ecx
  034fb	75 f8		 jne	 SHORT $LL13020@LoadRoomOp
  034fd	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126400[ebp]
  03503	8d 85 3c fd ff
	ff		 lea	 eax, DWORD PTR ___encStr$518067[ebp]
  03509	50		 push	 eax
  0350a	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  03510	50		 push	 eax
  03511	ff d6		 call	 esi
  03513	83 c4 0c	 add	 esp, 12			; 0000000cH

; 431  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  03516	68 04 01 00 00	 push	 260			; 00000104H
  0351b	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  03521	50		 push	 eax
  03522	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  03527	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  0352d	50		 push	 eax
  0352e	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03534	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 432  : 		pInfo->m_Desc = szBuf;

  0353a	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540333[ebp]
  03540	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  03546	50		 push	 eax
  03547	83 c1 30	 add	 ecx, 48			; 00000030H
  0354a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z
  03550	6a 03		 push	 3

; 433  : 
; 434  : 		wsprintf_e( szKey, "equip_ui_desc%d", i+1 );

  03552	c7 85 f8 fa ff
	ff 88 9d 9e 83	 mov	 DWORD PTR ___encStr$518219[ebp], -2086756984 ; 839e9d88H
  0355c	c7 85 fc fa ff
	ff 9d b3 9e 83	 mov	 DWORD PTR ___encStr$518219[ebp+4], -2086751331 ; 839eb39dH
  03566	c7 85 00 fb ff
	ff b2 88 8e 99	 mov	 DWORD PTR ___encStr$518219[ebp+8], -1718712142 ; 998e88b2H
  03570	8d 85 f8 fa ff
	ff		 lea	 eax, DWORD PTR ___encStr$518219[ebp]
  03576	c7 85 04 fb ff
	ff 8e c9 8f 00	 mov	 DWORD PTR ___encStr$518219[ebp+12], 9423246 ; 008fc98eH
  03580	59		 pop	 ecx
$LL13028@LoadRoomOp:
  03581	31 38		 xor	 DWORD PTR [eax], edi
  03583	83 c0 04	 add	 eax, 4
  03586	49		 dec	 ecx
  03587	75 f8		 jne	 SHORT $LL13028@LoadRoomOp
  03589	6a 0c		 push	 12			; 0000000cH
  0358b	58		 pop	 eax
$LL13025@LoadRoomOp:
  0358c	8b c8		 mov	 ecx, eax
  0358e	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  03594	79 05		 jns	 SHORT $LN17565@LoadRoomOp
  03596	49		 dec	 ecx
  03597	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0359a	41		 inc	 ecx
$LN17565@LoadRoomOp:
  0359b	b2 ed		 mov	 dl, -19			; ffffffedH
  0359d	2a d1		 sub	 dl, cl
  0359f	30 94 05 f8 fa
	ff ff		 xor	 BYTE PTR ___encStr$518219[ebp+eax], dl
  035a6	40		 inc	 eax
  035a7	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  035aa	7c e0		 jl	 SHORT $LL13025@LoadRoomOp
  035ac	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126400[ebp]
  035b2	8d 85 f8 fa ff
	ff		 lea	 eax, DWORD PTR ___encStr$518219[ebp]
  035b8	50		 push	 eax
  035b9	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  035bf	50		 push	 eax
  035c0	ff d6		 call	 esi
  035c2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 435  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  035c5	68 04 01 00 00	 push	 260			; 00000104H
  035ca	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  035d0	50		 push	 eax
  035d1	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  035d6	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  035dc	50		 push	 eax
  035dd	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  035e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 436  : 		pInfo->m_UIDesc = szBuf;

  035e9	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540333[ebp]
  035ef	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  035f5	50		 push	 eax
  035f6	83 c1 40	 add	 ecx, 64			; 00000040H
  035f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 437  : 
; 438  : 		m_RoomRedEquipList.push_back( pInfo );

  035ff	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  03605	8d 85 c8 ec ff
	ff		 lea	 eax, DWORD PTR _pInfo$517905[ebp]
  0360b	50		 push	 eax
  0360c	81 c1 34 01 00
	00		 add	 ecx, 308		; 00000134H
  03612	e8 00 00 00 00	 call	 ?push_back@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXABQAURoomOptionInfo@@@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::push_back
$LN3889@LoadRoomOp:

; 421  : 	for( i=0; i < iTypeCnt; ++i )

  03617	ff 85 d8 ec ff
	ff		 inc	 DWORD PTR tv126400[ebp]
  0361d	ff 8d d0 ec ff
	ff		 dec	 DWORD PTR tv63381[ebp]
  03623	0f 85 cc fd ff
	ff		 jne	 $LL3890@LoadRoomOp
$LN3888@LoadRoomOp:

; 439  : 	}
; 440  : 
; 441  : 	kLoader.SetTitle_e( "BlueEquipType" );

  03629	6a 03		 push	 3
  0362b	c7 85 00 fd ff
	ff af 80 9e 8f	 mov	 DWORD PTR __t$546038[ebp], -1885437777 ; 8f9e80afH
  03635	c7 85 04 fd ff
	ff a8 9d 9e 83	 mov	 DWORD PTR __t$546038[ebp+4], -2086756952 ; 839e9da8H
  0363f	c7 85 08 fd ff
	ff 9d b8 92 9a	 mov	 DWORD PTR __t$546038[ebp+8], -1701660515 ; 9a92b89dH
  03649	8d 85 00 fd ff
	ff		 lea	 eax, DWORD PTR __t$546038[ebp]
  0364f	66 c7 85 0c fd
	ff ff 88 00	 mov	 WORD PTR __t$546038[ebp+12], 136 ; 00000088H
  03658	59		 pop	 ecx
$LL13134@LoadRoomOp:
  03659	31 38		 xor	 DWORD PTR [eax], edi
  0365b	83 c0 04	 add	 eax, 4
  0365e	49		 dec	 ecx
  0365f	75 f8		 jne	 SHORT $LL13134@LoadRoomOp
  03661	80 b5 0c fd ff
	ff ed		 xor	 BYTE PTR __t$546038[ebp+12], -19 ; ffffffedH
  03668	8d 85 00 fd ff
	ff		 lea	 eax, DWORD PTR __t$546038[ebp]
  0366e	50		 push	 eax
  0366f	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03675	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z
  0367b	6a 03		 push	 3

; 442  : 
; 443  : 	iTypeCnt = kLoader.LoadInt_e( "equip_type_cnt", 0 );

  0367d	c7 85 d4 fb ff
	ff 88 9d 9e 83	 mov	 DWORD PTR __k$546203[ebp], -2086756984 ; 839e9d88H
  03687	c7 85 d8 fb ff
	ff 9d b3 9f 93	 mov	 DWORD PTR __k$546203[ebp+4], -1818250339 ; 939fb39dH
  03691	c7 85 dc fb ff
	ff 9d 89 b4 89	 mov	 DWORD PTR __k$546203[ebp+8], -1984656995 ; 89b4899dH
  0369b	66 c7 85 e0 fb
	ff ff 83 98	 mov	 WORD PTR __k$546203[ebp+12], 39043 ; 00009883H
  036a4	8d 85 d4 fb ff
	ff		 lea	 eax, DWORD PTR __k$546203[ebp]
  036aa	88 9d e2 fb ff
	ff		 mov	 BYTE PTR __k$546203[ebp+14], bl
  036b0	59		 pop	 ecx
$LL13240@LoadRoomOp:
  036b1	31 38		 xor	 DWORD PTR [eax], edi
  036b3	83 c0 04	 add	 eax, 4
  036b6	49		 dec	 ecx
  036b7	75 f8		 jne	 SHORT $LL13240@LoadRoomOp
  036b9	6a 0c		 push	 12			; 0000000cH
  036bb	58		 pop	 eax
$LL13237@LoadRoomOp:
  036bc	8b c8		 mov	 ecx, eax
  036be	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  036c4	79 05		 jns	 SHORT $LN17566@LoadRoomOp
  036c6	49		 dec	 ecx
  036c7	83 c9 fc	 or	 ecx, -4			; fffffffcH
  036ca	41		 inc	 ecx
$LN17566@LoadRoomOp:
  036cb	b2 ed		 mov	 dl, -19			; ffffffedH
  036cd	2a d1		 sub	 dl, cl
  036cf	30 94 05 d4 fb
	ff ff		 xor	 BYTE PTR __k$546203[ebp+eax], dl
  036d6	40		 inc	 eax
  036d7	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  036da	7c e0		 jl	 SHORT $LL13237@LoadRoomOp
  036dc	53		 push	 ebx
  036dd	8d 85 d4 fb ff
	ff		 lea	 eax, DWORD PTR __k$546203[ebp]
  036e3	50		 push	 eax
  036e4	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  036ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 444  : 	for( i=0; i < iTypeCnt; ++i )

  036f0	3b c3		 cmp	 eax, ebx
  036f2	0f 8e 44 02 00
	00		 jle	 $LN3587@LoadRoomOp

; 442  : 
; 443  : 	iTypeCnt = kLoader.LoadInt_e( "equip_type_cnt", 0 );

  036f8	c7 85 d8 ec ff
	ff 01 00 00 00	 mov	 DWORD PTR tv126477[ebp], 1
  03702	89 85 d0 ec ff
	ff		 mov	 DWORD PTR tv62100[ebp], eax
$LL3589@LoadRoomOp:

; 445  : 	{
; 446  : 		RoomOptionInfo *pInfo = new RoomOptionInfo;

  03708	6a 50		 push	 80			; 00000050H
  0370a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0370f	59		 pop	 ecx
  03710	89 85 c4 ec ff
	ff		 mov	 DWORD PTR $T540338[ebp], eax
  03716	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+8], 16 ; 00000010H
  0371a	3b c3		 cmp	 eax, ebx
  0371c	74 0f		 je	 SHORT $LN8443@LoadRoomOp
  0371e	8b c8		 mov	 ecx, eax
  03720	e8 00 00 00 00	 call	 ??0RoomOptionInfo@@QAE@XZ ; RoomOptionInfo::RoomOptionInfo
  03725	89 85 d4 ec ff
	ff		 mov	 DWORD PTR $T540337[ebp], eax
  0372b	eb 06		 jmp	 SHORT $LN8444@LoadRoomOp
$LN8443@LoadRoomOp:
  0372d	89 9d d4 ec ff
	ff		 mov	 DWORD PTR $T540337[ebp], ebx
$LN8444@LoadRoomOp:
  03733	8b 85 d4 ec ff
	ff		 mov	 eax, DWORD PTR $T540337[ebp]
  03739	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  0373c	89 85 c8 ec ff
	ff		 mov	 DWORD PTR _pInfo$518372[ebp], eax

; 447  : 		if( !pInfo )

  03742	3b c3		 cmp	 eax, ebx
  03744	0f 84 e0 01 00
	00		 je	 $LN3588@LoadRoomOp

; 448  : 			continue;
; 449  : 
; 450  : 		wsprintf_e( szKey, "equip_rate%d", i+1 );

  0374a	6a 03		 push	 3
  0374c	c7 85 c8 fd ff
	ff 88 9d 9e 83	 mov	 DWORD PTR ___encStr$518381[ebp], -2086756984 ; 839e9d88H
  03756	c7 85 cc fd ff
	ff 9d b3 99 8b	 mov	 DWORD PTR ___encStr$518381[ebp+4], -1952861283 ; 8b99b39dH
  03760	c7 85 d0 fd ff
	ff 99 89 ce 8e	 mov	 DWORD PTR ___encStr$518381[ebp+8], -1899066983 ; 8ece8999H
  0376a	8d 85 c8 fd ff
	ff		 lea	 eax, DWORD PTR ___encStr$518381[ebp]
  03770	88 9d d4 fd ff
	ff		 mov	 BYTE PTR ___encStr$518381[ebp+12], bl
  03776	59		 pop	 ecx
$LL13248@LoadRoomOp:
  03777	31 38		 xor	 DWORD PTR [eax], edi
  03779	83 c0 04	 add	 eax, 4
  0377c	49		 dec	 ecx
  0377d	75 f8		 jne	 SHORT $LL13248@LoadRoomOp
  0377f	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126477[ebp]
  03785	8d 85 c8 fd ff
	ff		 lea	 eax, DWORD PTR ___encStr$518381[ebp]
  0378b	50		 push	 eax
  0378c	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  03792	50		 push	 eax
  03793	ff d6		 call	 esi
  03795	83 c4 0c	 add	 esp, 12			; 0000000cH

; 451  : 		pInfo->m_fValue = kLoader.LoadFloat( szKey, FLOAT1 );

  03798	b8 01 00 00 00	 mov	 eax, 1
  0379d	89 85 c4 ec ff
	ff		 mov	 DWORD PTR tv126714[ebp], eax
  037a3	db 85 c4 ec ff
	ff		 fild	 DWORD PTR tv126714[ebp]
  037a9	85 c0		 test	 eax, eax
  037ab	79 06		 jns	 SHORT $LN17567@LoadRoomOp
  037ad	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN17567@LoadRoomOp:
  037b3	51		 push	 ecx
  037b4	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  037ba	d9 1c 24	 fstp	 DWORD PTR [esp]
  037bd	50		 push	 eax
  037be	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  037c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z
  037ca	51		 push	 ecx
  037cb	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540337[ebp]
  037d1	d9 1c 24	 fstp	 DWORD PTR [esp]
  037d4	e8 00 00 00 00	 call	 ??4?$CEncrypt@M@@QAEMM@Z ; CEncrypt<float>::operator=
  037d9	dd d8		 fstp	 ST(0)
  037db	6a 03		 push	 3

; 452  : 
; 453  : 		wsprintf_e( szKey, "equip_desc%d", i+1 );

  037dd	c7 85 64 fd ff
	ff 88 9d 9e 83	 mov	 DWORD PTR ___encStr$518533[ebp], -2086756984 ; 839e9d88H
  037e7	c7 85 68 fd ff
	ff 9d b3 8f 8f	 mov	 DWORD PTR ___encStr$518533[ebp+4], -1886407779 ; 8f8fb39dH
  037f1	c7 85 6c fd ff
	ff 9e 8f ce 8e	 mov	 DWORD PTR ___encStr$518533[ebp+8], -1899065442 ; 8ece8f9eH
  037fb	8d 85 64 fd ff
	ff		 lea	 eax, DWORD PTR ___encStr$518533[ebp]
  03801	88 9d 70 fd ff
	ff		 mov	 BYTE PTR ___encStr$518533[ebp+12], bl
  03807	59		 pop	 ecx
$LL13258@LoadRoomOp:
  03808	31 38		 xor	 DWORD PTR [eax], edi
  0380a	83 c0 04	 add	 eax, 4
  0380d	49		 dec	 ecx
  0380e	75 f8		 jne	 SHORT $LL13258@LoadRoomOp
  03810	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126477[ebp]
  03816	8d 85 64 fd ff
	ff		 lea	 eax, DWORD PTR ___encStr$518533[ebp]
  0381c	50		 push	 eax
  0381d	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  03823	50		 push	 eax
  03824	ff d6		 call	 esi
  03826	83 c4 0c	 add	 esp, 12			; 0000000cH

; 454  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  03829	68 04 01 00 00	 push	 260			; 00000104H
  0382e	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  03834	50		 push	 eax
  03835	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0383a	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  03840	50		 push	 eax
  03841	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03847	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 455  : 		pInfo->m_Desc = szBuf;

  0384d	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540337[ebp]
  03853	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  03859	50		 push	 eax
  0385a	83 c1 30	 add	 ecx, 48			; 00000030H
  0385d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z
  03863	6a 03		 push	 3

; 456  : 
; 457  : 		wsprintf_e( szKey, "equip_ui_desc%d", i+1 );

  03865	c7 85 48 fb ff
	ff 88 9d 9e 83	 mov	 DWORD PTR ___encStr$518684[ebp], -2086756984 ; 839e9d88H
  0386f	c7 85 4c fb ff
	ff 9d b3 9e 83	 mov	 DWORD PTR ___encStr$518684[ebp+4], -2086751331 ; 839eb39dH
  03879	c7 85 50 fb ff
	ff b2 88 8e 99	 mov	 DWORD PTR ___encStr$518684[ebp+8], -1718712142 ; 998e88b2H
  03883	8d 85 48 fb ff
	ff		 lea	 eax, DWORD PTR ___encStr$518684[ebp]
  03889	c7 85 54 fb ff
	ff 8e c9 8f 00	 mov	 DWORD PTR ___encStr$518684[ebp+12], 9423246 ; 008fc98eH
  03893	59		 pop	 ecx
$LL13266@LoadRoomOp:
  03894	31 38		 xor	 DWORD PTR [eax], edi
  03896	83 c0 04	 add	 eax, 4
  03899	49		 dec	 ecx
  0389a	75 f8		 jne	 SHORT $LL13266@LoadRoomOp
  0389c	6a 0c		 push	 12			; 0000000cH
  0389e	58		 pop	 eax
$LL13263@LoadRoomOp:
  0389f	8b c8		 mov	 ecx, eax
  038a1	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  038a7	79 05		 jns	 SHORT $LN17568@LoadRoomOp
  038a9	49		 dec	 ecx
  038aa	83 c9 fc	 or	 ecx, -4			; fffffffcH
  038ad	41		 inc	 ecx
$LN17568@LoadRoomOp:
  038ae	b2 ed		 mov	 dl, -19			; ffffffedH
  038b0	2a d1		 sub	 dl, cl
  038b2	30 94 05 48 fb
	ff ff		 xor	 BYTE PTR ___encStr$518684[ebp+eax], dl
  038b9	40		 inc	 eax
  038ba	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  038bd	7c e0		 jl	 SHORT $LL13263@LoadRoomOp
  038bf	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126477[ebp]
  038c5	8d 85 48 fb ff
	ff		 lea	 eax, DWORD PTR ___encStr$518684[ebp]
  038cb	50		 push	 eax
  038cc	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  038d2	50		 push	 eax
  038d3	ff d6		 call	 esi
  038d5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 458  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  038d8	68 04 01 00 00	 push	 260			; 00000104H
  038dd	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  038e3	50		 push	 eax
  038e4	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  038e9	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  038ef	50		 push	 eax
  038f0	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  038f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 459  : 		pInfo->m_UIDesc = szBuf;

  038fc	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540337[ebp]
  03902	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  03908	50		 push	 eax
  03909	83 c1 40	 add	 ecx, 64			; 00000040H
  0390c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 460  : 
; 461  : 		m_RoomBlueEquipList.push_back( pInfo );

  03912	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  03918	8d 85 c8 ec ff
	ff		 lea	 eax, DWORD PTR _pInfo$518372[ebp]
  0391e	50		 push	 eax
  0391f	81 c1 44 01 00
	00		 add	 ecx, 324		; 00000144H
  03925	e8 00 00 00 00	 call	 ?push_back@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXABQAURoomOptionInfo@@@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::push_back
$LN3588@LoadRoomOp:

; 444  : 	for( i=0; i < iTypeCnt; ++i )

  0392a	ff 85 d8 ec ff
	ff		 inc	 DWORD PTR tv126477[ebp]
  03930	ff 8d d0 ec ff
	ff		 dec	 DWORD PTR tv62100[ebp]
  03936	0f 85 cc fd ff
	ff		 jne	 $LL3589@LoadRoomOp
$LN3587@LoadRoomOp:

; 462  : 	}
; 463  : 
; 464  : 	// Round Type
; 465  : 	kLoader.SetTitle_e( "CatchRoundType" );

  0393c	6a 03		 push	 3
  0393e	c7 85 24 fc ff
	ff ae 8d 9f 89	 mov	 DWORD PTR __t$546315[ebp], -1986032210 ; 899f8daeH
  03948	c7 85 28 fc ff
	ff 85 be 84 9f	 mov	 DWORD PTR __t$546315[ebp+4], -1618690427 ; 9f84be85H
  03952	c7 85 2c fc ff
	ff 83 88 bf 93	 mov	 DWORD PTR __t$546315[ebp+8], -1816164221 ; 93bf8883H
  0395c	66 c7 85 30 fc
	ff ff 9d 89	 mov	 WORD PTR __t$546315[ebp+12], 35229 ; 0000899dH
  03965	8d 85 24 fc ff
	ff		 lea	 eax, DWORD PTR __t$546315[ebp]
  0396b	88 9d 32 fc ff
	ff		 mov	 BYTE PTR __t$546315[ebp+14], bl
  03971	59		 pop	 ecx
$LL13372@LoadRoomOp:
  03972	31 38		 xor	 DWORD PTR [eax], edi
  03974	83 c0 04	 add	 eax, 4
  03977	49		 dec	 ecx
  03978	75 f8		 jne	 SHORT $LL13372@LoadRoomOp
  0397a	6a 0c		 push	 12			; 0000000cH
  0397c	58		 pop	 eax
$LL13369@LoadRoomOp:
  0397d	8b c8		 mov	 ecx, eax
  0397f	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  03985	79 05		 jns	 SHORT $LN17569@LoadRoomOp
  03987	49		 dec	 ecx
  03988	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0398b	41		 inc	 ecx
$LN17569@LoadRoomOp:
  0398c	b2 ed		 mov	 dl, -19			; ffffffedH
  0398e	2a d1		 sub	 dl, cl
  03990	30 94 05 24 fc
	ff ff		 xor	 BYTE PTR __t$546315[ebp+eax], dl
  03997	40		 inc	 eax
  03998	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  0399b	7c e0		 jl	 SHORT $LL13369@LoadRoomOp
  0399d	8d 85 24 fc ff
	ff		 lea	 eax, DWORD PTR __t$546315[ebp]
  039a3	50		 push	 eax
  039a4	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  039aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z
  039b0	6a 03		 push	 3

; 466  : 
; 467  : 	iTypeCnt = kLoader.LoadInt_e( "round_type_cnt", 0 );

  039b2	c7 85 ac fb ff
	ff 9f 83 9e 84	 mov	 DWORD PTR __k$546493[ebp], -2069986401 ; 849e839fH
  039bc	c7 85 b0 fb ff
	ff 89 b3 9f 93	 mov	 DWORD PTR __k$546493[ebp+4], -1818250359 ; 939fb389H
  039c6	c7 85 b4 fb ff
	ff 9d 89 b4 89	 mov	 DWORD PTR __k$546493[ebp+8], -1984656995 ; 89b4899dH
  039d0	66 c7 85 b8 fb
	ff ff 83 98	 mov	 WORD PTR __k$546493[ebp+12], 39043 ; 00009883H
  039d9	8d 85 ac fb ff
	ff		 lea	 eax, DWORD PTR __k$546493[ebp]
  039df	88 9d ba fb ff
	ff		 mov	 BYTE PTR __k$546493[ebp+14], bl
  039e5	59		 pop	 ecx
$LL13478@LoadRoomOp:
  039e6	31 38		 xor	 DWORD PTR [eax], edi
  039e8	83 c0 04	 add	 eax, 4
  039eb	49		 dec	 ecx
  039ec	75 f8		 jne	 SHORT $LL13478@LoadRoomOp
  039ee	6a 0c		 push	 12			; 0000000cH
  039f0	58		 pop	 eax
$LL13475@LoadRoomOp:
  039f1	8b c8		 mov	 ecx, eax
  039f3	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  039f9	79 05		 jns	 SHORT $LN17570@LoadRoomOp
  039fb	49		 dec	 ecx
  039fc	83 c9 fc	 or	 ecx, -4			; fffffffcH
  039ff	41		 inc	 ecx
$LN17570@LoadRoomOp:
  03a00	b2 ed		 mov	 dl, -19			; ffffffedH
  03a02	2a d1		 sub	 dl, cl
  03a04	30 94 05 ac fb
	ff ff		 xor	 BYTE PTR __k$546493[ebp+eax], dl
  03a0b	40		 inc	 eax
  03a0c	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  03a0f	7c e0		 jl	 SHORT $LL13475@LoadRoomOp
  03a11	53		 push	 ebx
  03a12	8d 85 ac fb ff
	ff		 lea	 eax, DWORD PTR __k$546493[ebp]
  03a18	50		 push	 eax
  03a19	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03a1f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 468  : 	for( i=0; i < iTypeCnt; ++i )

  03a25	3b c3		 cmp	 eax, ebx
  03a27	0f 8e 44 02 00
	00		 jle	 $LN3286@LoadRoomOp

; 466  : 
; 467  : 	iTypeCnt = kLoader.LoadInt_e( "round_type_cnt", 0 );

  03a2d	c7 85 d8 ec ff
	ff 01 00 00 00	 mov	 DWORD PTR tv126556[ebp], 1
  03a37	89 85 d0 ec ff
	ff		 mov	 DWORD PTR tv60521[ebp], eax
$LL3288@LoadRoomOp:

; 469  : 	{
; 470  : 		RoomOptionInfo *pInfo = new RoomOptionInfo;

  03a3d	6a 50		 push	 80			; 00000050H
  03a3f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  03a44	59		 pop	 ecx
  03a45	89 85 c4 ec ff
	ff		 mov	 DWORD PTR $T540342[ebp], eax
  03a4b	c6 45 fc 11	 mov	 BYTE PTR __$EHRec$[ebp+8], 17 ; 00000011H
  03a4f	3b c3		 cmp	 eax, ebx
  03a51	74 0f		 je	 SHORT $LN8445@LoadRoomOp
  03a53	8b c8		 mov	 ecx, eax
  03a55	e8 00 00 00 00	 call	 ??0RoomOptionInfo@@QAE@XZ ; RoomOptionInfo::RoomOptionInfo
  03a5a	89 85 d4 ec ff
	ff		 mov	 DWORD PTR $T540341[ebp], eax
  03a60	eb 06		 jmp	 SHORT $LN8446@LoadRoomOp
$LN8445@LoadRoomOp:
  03a62	89 9d d4 ec ff
	ff		 mov	 DWORD PTR $T540341[ebp], ebx
$LN8446@LoadRoomOp:
  03a68	8b 85 d4 ec ff
	ff		 mov	 eax, DWORD PTR $T540341[ebp]
  03a6e	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  03a71	89 85 c8 ec ff
	ff		 mov	 DWORD PTR _pInfo$518837[ebp], eax

; 471  : 		if( !pInfo )

  03a77	3b c3		 cmp	 eax, ebx
  03a79	0f 84 e0 01 00
	00		 je	 $LN3287@LoadRoomOp

; 472  : 			continue;
; 473  : 
; 474  : 		wsprintf_e( szKey, "round_rate%d", i+1 );

  03a7f	6a 03		 push	 3
  03a81	c7 85 f0 fd ff
	ff 9f 83 9e 84	 mov	 DWORD PTR ___encStr$518846[ebp], -2069986401 ; 849e839fH
  03a8b	c7 85 f4 fd ff
	ff 89 b3 99 8b	 mov	 DWORD PTR ___encStr$518846[ebp+4], -1952861303 ; 8b99b389H
  03a95	c7 85 f8 fd ff
	ff 99 89 ce 8e	 mov	 DWORD PTR ___encStr$518846[ebp+8], -1899066983 ; 8ece8999H
  03a9f	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR ___encStr$518846[ebp]
  03aa5	88 9d fc fd ff
	ff		 mov	 BYTE PTR ___encStr$518846[ebp+12], bl
  03aab	59		 pop	 ecx
$LL13486@LoadRoomOp:
  03aac	31 38		 xor	 DWORD PTR [eax], edi
  03aae	83 c0 04	 add	 eax, 4
  03ab1	49		 dec	 ecx
  03ab2	75 f8		 jne	 SHORT $LL13486@LoadRoomOp
  03ab4	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126556[ebp]
  03aba	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR ___encStr$518846[ebp]
  03ac0	50		 push	 eax
  03ac1	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  03ac7	50		 push	 eax
  03ac8	ff d6		 call	 esi
  03aca	83 c4 0c	 add	 esp, 12			; 0000000cH

; 475  : 		pInfo->m_fValue = kLoader.LoadFloat( szKey, FLOAT1 );

  03acd	b8 01 00 00 00	 mov	 eax, 1
  03ad2	89 85 c4 ec ff
	ff		 mov	 DWORD PTR tv126680[ebp], eax
  03ad8	db 85 c4 ec ff
	ff		 fild	 DWORD PTR tv126680[ebp]
  03ade	85 c0		 test	 eax, eax
  03ae0	79 06		 jns	 SHORT $LN17571@LoadRoomOp
  03ae2	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN17571@LoadRoomOp:
  03ae8	51		 push	 ecx
  03ae9	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  03aef	d9 1c 24	 fstp	 DWORD PTR [esp]
  03af2	50		 push	 eax
  03af3	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03af9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z
  03aff	51		 push	 ecx
  03b00	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540341[ebp]
  03b06	d9 1c 24	 fstp	 DWORD PTR [esp]
  03b09	e8 00 00 00 00	 call	 ??4?$CEncrypt@M@@QAEMM@Z ; CEncrypt<float>::operator=
  03b0e	dd d8		 fstp	 ST(0)
  03b10	6a 03		 push	 3

; 476  : 
; 477  : 		wsprintf_e( szKey, "round_desc%d", i+1 );

  03b12	c7 85 8c fd ff
	ff 9f 83 9e 84	 mov	 DWORD PTR ___encStr$518999[ebp], -2069986401 ; 849e839fH
  03b1c	c7 85 90 fd ff
	ff 89 b3 8f 8f	 mov	 DWORD PTR ___encStr$518999[ebp+4], -1886407799 ; 8f8fb389H
  03b26	c7 85 94 fd ff
	ff 9e 8f ce 8e	 mov	 DWORD PTR ___encStr$518999[ebp+8], -1899065442 ; 8ece8f9eH
  03b30	8d 85 8c fd ff
	ff		 lea	 eax, DWORD PTR ___encStr$518999[ebp]
  03b36	88 9d 98 fd ff
	ff		 mov	 BYTE PTR ___encStr$518999[ebp+12], bl
  03b3c	59		 pop	 ecx
$LL13496@LoadRoomOp:
  03b3d	31 38		 xor	 DWORD PTR [eax], edi
  03b3f	83 c0 04	 add	 eax, 4
  03b42	49		 dec	 ecx
  03b43	75 f8		 jne	 SHORT $LL13496@LoadRoomOp
  03b45	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126556[ebp]
  03b4b	8d 85 8c fd ff
	ff		 lea	 eax, DWORD PTR ___encStr$518999[ebp]
  03b51	50		 push	 eax
  03b52	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  03b58	50		 push	 eax
  03b59	ff d6		 call	 esi
  03b5b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 478  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  03b5e	68 04 01 00 00	 push	 260			; 00000104H
  03b63	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  03b69	50		 push	 eax
  03b6a	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  03b6f	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  03b75	50		 push	 eax
  03b76	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03b7c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 479  : 		pInfo->m_Desc = szBuf;

  03b82	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540341[ebp]
  03b88	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  03b8e	50		 push	 eax
  03b8f	83 c1 30	 add	 ecx, 48			; 00000030H
  03b92	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z
  03b98	6a 03		 push	 3

; 480  : 
; 481  : 		wsprintf_e( szKey, "round_ui_desc%d", i+1 );

  03b9a	c7 85 d0 fa ff
	ff 9f 83 9e 84	 mov	 DWORD PTR ___encStr$519151[ebp], -2069986401 ; 849e839fH
  03ba4	c7 85 d4 fa ff
	ff 89 b3 9e 83	 mov	 DWORD PTR ___encStr$519151[ebp+4], -2086751351 ; 839eb389H
  03bae	c7 85 d8 fa ff
	ff b2 88 8e 99	 mov	 DWORD PTR ___encStr$519151[ebp+8], -1718712142 ; 998e88b2H
  03bb8	8d 85 d0 fa ff
	ff		 lea	 eax, DWORD PTR ___encStr$519151[ebp]
  03bbe	c7 85 dc fa ff
	ff 8e c9 8f 00	 mov	 DWORD PTR ___encStr$519151[ebp+12], 9423246 ; 008fc98eH
  03bc8	59		 pop	 ecx
$LL13504@LoadRoomOp:
  03bc9	31 38		 xor	 DWORD PTR [eax], edi
  03bcb	83 c0 04	 add	 eax, 4
  03bce	49		 dec	 ecx
  03bcf	75 f8		 jne	 SHORT $LL13504@LoadRoomOp
  03bd1	6a 0c		 push	 12			; 0000000cH
  03bd3	58		 pop	 eax
$LL13501@LoadRoomOp:
  03bd4	8b c8		 mov	 ecx, eax
  03bd6	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  03bdc	79 05		 jns	 SHORT $LN17572@LoadRoomOp
  03bde	49		 dec	 ecx
  03bdf	83 c9 fc	 or	 ecx, -4			; fffffffcH
  03be2	41		 inc	 ecx
$LN17572@LoadRoomOp:
  03be3	b2 ed		 mov	 dl, -19			; ffffffedH
  03be5	2a d1		 sub	 dl, cl
  03be7	30 94 05 d0 fa
	ff ff		 xor	 BYTE PTR ___encStr$519151[ebp+eax], dl
  03bee	40		 inc	 eax
  03bef	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  03bf2	7c e0		 jl	 SHORT $LL13501@LoadRoomOp
  03bf4	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126556[ebp]
  03bfa	8d 85 d0 fa ff
	ff		 lea	 eax, DWORD PTR ___encStr$519151[ebp]
  03c00	50		 push	 eax
  03c01	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  03c07	50		 push	 eax
  03c08	ff d6		 call	 esi
  03c0a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 482  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  03c0d	68 04 01 00 00	 push	 260			; 00000104H
  03c12	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  03c18	50		 push	 eax
  03c19	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  03c1e	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  03c24	50		 push	 eax
  03c25	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03c2b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 483  : 		pInfo->m_UIDesc = szBuf;

  03c31	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540341[ebp]
  03c37	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  03c3d	50		 push	 eax
  03c3e	83 c1 40	 add	 ecx, 64			; 00000040H
  03c41	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 484  : 
; 485  : 		m_RoomRoundTypeList.push_back( pInfo );

  03c47	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  03c4d	8d 85 c8 ec ff
	ff		 lea	 eax, DWORD PTR _pInfo$518837[ebp]
  03c53	50		 push	 eax
  03c54	81 c1 54 01 00
	00		 add	 ecx, 340		; 00000154H
  03c5a	e8 00 00 00 00	 call	 ?push_back@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXABQAURoomOptionInfo@@@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::push_back
$LN3287@LoadRoomOp:

; 468  : 	for( i=0; i < iTypeCnt; ++i )

  03c5f	ff 85 d8 ec ff
	ff		 inc	 DWORD PTR tv126556[ebp]
  03c65	ff 8d d0 ec ff
	ff		 dec	 DWORD PTR tv60521[ebp]
  03c6b	0f 85 cc fd ff
	ff		 jne	 $LL3288@LoadRoomOp
$LN3286@LoadRoomOp:

; 486  : 	}
; 487  : 
; 488  : 	// Round Time Type
; 489  : 	kLoader.SetTitle_e( "CatchRoundTimeType" );

  03c71	6a 04		 push	 4
  03c73	c7 85 d4 f7 ff
	ff ae 8d 9f 89	 mov	 DWORD PTR __t$546605[ebp], -1986032210 ; 899f8daeH
  03c7d	c7 85 d8 f7 ff
	ff 85 be 84 9f	 mov	 DWORD PTR __t$546605[ebp+4], -1618690427 ; 9f84be85H
  03c87	c7 85 dc f7 ff
	ff 83 88 bf 83	 mov	 DWORD PTR __t$546605[ebp+8], -2084599677 ; 83bf8883H
  03c91	c7 85 e0 f7 ff
	ff 80 89 bf 93	 mov	 DWORD PTR __t$546605[ebp+12], -1816163968 ; 93bf8980H
  03c9b	66 c7 85 e4 f7
	ff ff 9d 89	 mov	 WORD PTR __t$546605[ebp+16], 35229 ; 0000899dH
  03ca4	8d 85 d4 f7 ff
	ff		 lea	 eax, DWORD PTR __t$546605[ebp]
  03caa	88 9d e6 f7 ff
	ff		 mov	 BYTE PTR __t$546605[ebp+18], bl
  03cb0	59		 pop	 ecx
$LL13610@LoadRoomOp:
  03cb1	31 38		 xor	 DWORD PTR [eax], edi
  03cb3	83 c0 04	 add	 eax, 4
  03cb6	49		 dec	 ecx
  03cb7	75 f8		 jne	 SHORT $LL13610@LoadRoomOp
  03cb9	6a 10		 push	 16			; 00000010H
  03cbb	58		 pop	 eax
$LL13607@LoadRoomOp:
  03cbc	8b c8		 mov	 ecx, eax
  03cbe	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  03cc4	79 05		 jns	 SHORT $LN17573@LoadRoomOp
  03cc6	49		 dec	 ecx
  03cc7	83 c9 fc	 or	 ecx, -4			; fffffffcH
  03cca	41		 inc	 ecx
$LN17573@LoadRoomOp:
  03ccb	b2 ed		 mov	 dl, -19			; ffffffedH
  03ccd	2a d1		 sub	 dl, cl
  03ccf	30 94 05 d4 f7
	ff ff		 xor	 BYTE PTR __t$546605[ebp+eax], dl
  03cd6	40		 inc	 eax
  03cd7	83 f8 12	 cmp	 eax, 18			; 00000012H
  03cda	7c e0		 jl	 SHORT $LL13607@LoadRoomOp
  03cdc	8d 85 d4 f7 ff
	ff		 lea	 eax, DWORD PTR __t$546605[ebp]
  03ce2	50		 push	 eax
  03ce3	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03ce9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z
  03cef	6a 04		 push	 4

; 490  : 
; 491  : 	iTypeCnt = kLoader.LoadInt_e( "round_time_type_cnt", 0 );

  03cf1	c7 85 54 f6 ff
	ff 9f 83 9e 84	 mov	 DWORD PTR __k$546744[ebp], -2069986401 ; 849e839fH
  03cfb	c7 85 58 f6 ff
	ff 89 b3 9f 83	 mov	 DWORD PTR __k$546744[ebp+4], -2086685815 ; 839fb389H
  03d05	c7 85 5c f6 ff
	ff 80 89 b4 9e	 mov	 DWORD PTR __k$546744[ebp+8], -1632335488 ; 9eb48980H
  03d0f	c7 85 60 f6 ff
	ff 94 9c 8e b5	 mov	 DWORD PTR __k$546744[ebp+12], -1248945004 ; b58e9c94H
  03d19	8d 85 54 f6 ff
	ff		 lea	 eax, DWORD PTR __k$546744[ebp]
  03d1f	c7 85 64 f6 ff
	ff 8e 82 9f 00	 mov	 DWORD PTR __k$546744[ebp+16], 10453646 ; 009f828eH
  03d29	59		 pop	 ecx
$LL13716@LoadRoomOp:
  03d2a	31 38		 xor	 DWORD PTR [eax], edi
  03d2c	83 c0 04	 add	 eax, 4
  03d2f	49		 dec	 ecx
  03d30	75 f8		 jne	 SHORT $LL13716@LoadRoomOp
  03d32	6a 10		 push	 16			; 00000010H
  03d34	58		 pop	 eax
$LL13713@LoadRoomOp:
  03d35	8b c8		 mov	 ecx, eax
  03d37	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  03d3d	79 05		 jns	 SHORT $LN17574@LoadRoomOp
  03d3f	49		 dec	 ecx
  03d40	83 c9 fc	 or	 ecx, -4			; fffffffcH
  03d43	41		 inc	 ecx
$LN17574@LoadRoomOp:
  03d44	b2 ed		 mov	 dl, -19			; ffffffedH
  03d46	2a d1		 sub	 dl, cl
  03d48	30 94 05 54 f6
	ff ff		 xor	 BYTE PTR __k$546744[ebp+eax], dl
  03d4f	40		 inc	 eax
  03d50	83 f8 13	 cmp	 eax, 19			; 00000013H
  03d53	7c e0		 jl	 SHORT $LL13713@LoadRoomOp
  03d55	53		 push	 ebx
  03d56	8d 85 54 f6 ff
	ff		 lea	 eax, DWORD PTR __k$546744[ebp]
  03d5c	50		 push	 eax
  03d5d	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03d63	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 492  : 	for( i=0; i < iTypeCnt; ++i )

  03d69	3b c3		 cmp	 eax, ebx
  03d6b	0f 8e 59 02 00
	00		 jle	 $LN2985@LoadRoomOp

; 490  : 
; 491  : 	iTypeCnt = kLoader.LoadInt_e( "round_time_type_cnt", 0 );

  03d71	c7 85 d8 ec ff
	ff 01 00 00 00	 mov	 DWORD PTR tv126679[ebp], 1
  03d7b	89 85 d0 ec ff
	ff		 mov	 DWORD PTR tv59401[ebp], eax
$LL2987@LoadRoomOp:

; 493  : 	{
; 494  : 		RoomOptionInfo *pInfo = new RoomOptionInfo;

  03d81	6a 50		 push	 80			; 00000050H
  03d83	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  03d88	59		 pop	 ecx
  03d89	89 85 c4 ec ff
	ff		 mov	 DWORD PTR $T540346[ebp], eax
  03d8f	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+8], 18 ; 00000012H
  03d93	3b c3		 cmp	 eax, ebx
  03d95	74 0f		 je	 SHORT $LN8447@LoadRoomOp
  03d97	8b c8		 mov	 ecx, eax
  03d99	e8 00 00 00 00	 call	 ??0RoomOptionInfo@@QAE@XZ ; RoomOptionInfo::RoomOptionInfo
  03d9e	89 85 d4 ec ff
	ff		 mov	 DWORD PTR $T540345[ebp], eax
  03da4	eb 06		 jmp	 SHORT $LN8448@LoadRoomOp
$LN8447@LoadRoomOp:
  03da6	89 9d d4 ec ff
	ff		 mov	 DWORD PTR $T540345[ebp], ebx
$LN8448@LoadRoomOp:
  03dac	8b 85 d4 ec ff
	ff		 mov	 eax, DWORD PTR $T540345[ebp]
  03db2	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  03db5	89 85 c8 ec ff
	ff		 mov	 DWORD PTR _pInfo$519308[ebp], eax

; 495  : 		if( !pInfo )

  03dbb	3b c3		 cmp	 eax, ebx
  03dbd	0f 84 f5 01 00
	00		 je	 $LN2986@LoadRoomOp

; 496  : 			continue;
; 497  : 
; 498  : 		wsprintf_e( szKey, "round_time_rate%d", i+1 );

  03dc3	6a 04		 push	 4
  03dc5	c7 85 84 f9 ff
	ff 9f 83 9e 84	 mov	 DWORD PTR ___encStr$519317[ebp], -2069986401 ; 849e839fH
  03dcf	c7 85 88 f9 ff
	ff 89 b3 9f 83	 mov	 DWORD PTR ___encStr$519317[ebp+4], -2086685815 ; 839fb389H
  03dd9	c7 85 8c f9 ff
	ff 80 89 b4 98	 mov	 DWORD PTR ___encStr$519317[ebp+8], -1732998784 ; 98b48980H
  03de3	c7 85 90 f9 ff
	ff 8c 98 8e cf	 mov	 DWORD PTR ___encStr$519317[ebp+12], -812738420 ; cf8e988cH
  03ded	8d 85 84 f9 ff
	ff		 lea	 eax, DWORD PTR ___encStr$519317[ebp]
  03df3	66 c7 85 94 f9
	ff ff 89 00	 mov	 WORD PTR ___encStr$519317[ebp+16], 137 ; 00000089H
  03dfc	59		 pop	 ecx
$LL13724@LoadRoomOp:
  03dfd	31 38		 xor	 DWORD PTR [eax], edi
  03dff	83 c0 04	 add	 eax, 4
  03e02	49		 dec	 ecx
  03e03	75 f8		 jne	 SHORT $LL13724@LoadRoomOp
  03e05	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126679[ebp]
  03e0b	80 b5 94 f9 ff
	ff ed		 xor	 BYTE PTR ___encStr$519317[ebp+16], -19 ; ffffffedH
  03e12	8d 85 84 f9 ff
	ff		 lea	 eax, DWORD PTR ___encStr$519317[ebp]
  03e18	50		 push	 eax
  03e19	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  03e1f	50		 push	 eax
  03e20	ff d6		 call	 esi
  03e22	83 c4 0c	 add	 esp, 12			; 0000000cH

; 499  : 		pInfo->m_fValue = kLoader.LoadFloat( szKey, FLOAT1 );

  03e25	b8 01 00 00 00	 mov	 eax, 1
  03e2a	89 85 c4 ec ff
	ff		 mov	 DWORD PTR tv126645[ebp], eax
  03e30	db 85 c4 ec ff
	ff		 fild	 DWORD PTR tv126645[ebp]
  03e36	85 c0		 test	 eax, eax
  03e38	79 06		 jns	 SHORT $LN17575@LoadRoomOp
  03e3a	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN17575@LoadRoomOp:
  03e40	51		 push	 ecx
  03e41	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  03e47	d9 1c 24	 fstp	 DWORD PTR [esp]
  03e4a	50		 push	 eax
  03e4b	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03e51	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z
  03e57	51		 push	 ecx
  03e58	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540345[ebp]
  03e5e	d9 1c 24	 fstp	 DWORD PTR [esp]
  03e61	e8 00 00 00 00	 call	 ??4?$CEncrypt@M@@QAEMM@Z ; CEncrypt<float>::operator=
  03e66	dd d8		 fstp	 ST(0)
  03e68	6a 04		 push	 4

; 500  : 
; 501  : 		wsprintf_e( szKey, "round_time_desc%d", i+1 );

  03e6a	c7 85 44 fa ff
	ff 9f 83 9e 84	 mov	 DWORD PTR ___encStr$519470[ebp], -2069986401 ; 849e839fH
  03e74	c7 85 48 fa ff
	ff 89 b3 9f 83	 mov	 DWORD PTR ___encStr$519470[ebp+4], -2086685815 ; 839fb389H
  03e7e	c7 85 4c fa ff
	ff 80 89 b4 8e	 mov	 DWORD PTR ___encStr$519470[ebp+8], -1900770944 ; 8eb48980H
  03e88	c7 85 50 fa ff
	ff 88 9f 88 cf	 mov	 DWORD PTR ___encStr$519470[ebp+12], -813129848 ; cf889f88H
  03e92	8d 85 44 fa ff
	ff		 lea	 eax, DWORD PTR ___encStr$519470[ebp]
  03e98	66 c7 85 54 fa
	ff ff 89 00	 mov	 WORD PTR ___encStr$519470[ebp+16], 137 ; 00000089H
  03ea1	59		 pop	 ecx
$LL13734@LoadRoomOp:
  03ea2	31 38		 xor	 DWORD PTR [eax], edi
  03ea4	83 c0 04	 add	 eax, 4
  03ea7	49		 dec	 ecx
  03ea8	75 f8		 jne	 SHORT $LL13734@LoadRoomOp
  03eaa	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126679[ebp]
  03eb0	80 b5 54 fa ff
	ff ed		 xor	 BYTE PTR ___encStr$519470[ebp+16], -19 ; ffffffedH
  03eb7	8d 85 44 fa ff
	ff		 lea	 eax, DWORD PTR ___encStr$519470[ebp]
  03ebd	50		 push	 eax
  03ebe	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  03ec4	50		 push	 eax
  03ec5	ff d6		 call	 esi
  03ec7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 502  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  03eca	68 04 01 00 00	 push	 260			; 00000104H
  03ecf	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  03ed5	50		 push	 eax
  03ed6	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  03edb	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  03ee1	50		 push	 eax
  03ee2	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03ee8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 503  : 		pInfo->m_Desc = szBuf;

  03eee	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540345[ebp]
  03ef4	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  03efa	50		 push	 eax
  03efb	83 c1 30	 add	 ecx, 48			; 00000030H
  03efe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z
  03f04	6a 05		 push	 5

; 504  : 
; 505  : 		wsprintf_e( szKey, "round_time_ui_desc%d", i+1 );

  03f06	c7 85 d0 f4 ff
	ff 9f 83 9e 84	 mov	 DWORD PTR ___encStr$519622[ebp], -2069986401 ; 849e839fH
  03f10	c7 85 d4 f4 ff
	ff 89 b3 9f 83	 mov	 DWORD PTR ___encStr$519622[ebp+4], -2086685815 ; 839fb389H
  03f1a	c7 85 d8 f4 ff
	ff 80 89 b4 9f	 mov	 DWORD PTR ___encStr$519622[ebp+8], -1615558272 ; 9fb48980H
  03f24	c7 85 dc f4 ff
	ff 84 b3 8f 8f	 mov	 DWORD PTR ___encStr$519622[ebp+12], -1886407804 ; 8f8fb384H
  03f2e	c7 85 e0 f4 ff
	ff 9e 8f ce 8e	 mov	 DWORD PTR ___encStr$519622[ebp+16], -1899065442 ; 8ece8f9eH
  03f38	8d 85 d0 f4 ff
	ff		 lea	 eax, DWORD PTR ___encStr$519622[ebp]
  03f3e	88 9d e4 f4 ff
	ff		 mov	 BYTE PTR ___encStr$519622[ebp+20], bl
  03f44	59		 pop	 ecx
$LL13742@LoadRoomOp:
  03f45	31 38		 xor	 DWORD PTR [eax], edi
  03f47	83 c0 04	 add	 eax, 4
  03f4a	49		 dec	 ecx
  03f4b	75 f8		 jne	 SHORT $LL13742@LoadRoomOp
  03f4d	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126679[ebp]
  03f53	8d 85 d0 f4 ff
	ff		 lea	 eax, DWORD PTR ___encStr$519622[ebp]
  03f59	50		 push	 eax
  03f5a	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  03f60	50		 push	 eax
  03f61	ff d6		 call	 esi
  03f63	83 c4 0c	 add	 esp, 12			; 0000000cH

; 506  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  03f66	68 04 01 00 00	 push	 260			; 00000104H
  03f6b	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  03f71	50		 push	 eax
  03f72	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  03f77	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  03f7d	50		 push	 eax
  03f7e	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03f84	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 507  : 		pInfo->m_UIDesc = szBuf;

  03f8a	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540345[ebp]
  03f90	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  03f96	50		 push	 eax
  03f97	83 c1 40	 add	 ecx, 64			; 00000040H
  03f9a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 508  : 
; 509  : 		m_RoomRoundTimeTypeList.push_back( pInfo );

  03fa0	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  03fa6	8d 85 c8 ec ff
	ff		 lea	 eax, DWORD PTR _pInfo$519308[ebp]
  03fac	50		 push	 eax
  03fad	81 c1 64 01 00
	00		 add	 ecx, 356		; 00000164H
  03fb3	e8 00 00 00 00	 call	 ?push_back@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXABQAURoomOptionInfo@@@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::push_back
$LN2986@LoadRoomOp:

; 492  : 	for( i=0; i < iTypeCnt; ++i )

  03fb8	ff 85 d8 ec ff
	ff		 inc	 DWORD PTR tv126679[ebp]
  03fbe	ff 8d d0 ec ff
	ff		 dec	 DWORD PTR tv59401[ebp]
  03fc4	0f 85 b7 fd ff
	ff		 jne	 $LL2987@LoadRoomOp
$LN2985@LoadRoomOp:

; 510  : 	}
; 511  : 
; 512  : 	// GrowthUse
; 513  : 	kLoader.SetTitle_e( "GrowthUse" );

  03fca	6a 02		 push	 2
  03fcc	c7 85 54 ff ff
	ff aa 9e 84 9d	 mov	 DWORD PTR __t$546908[ebp], -1652253014 ; 9d849eaaH
  03fd6	c7 85 58 ff ff
	ff 99 84 be 99	 mov	 DWORD PTR __t$546908[ebp+4], -1715567463 ; 99be8499H
  03fe0	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR __t$546908[ebp]
  03fe6	66 c7 85 5c ff
	ff ff 88 00	 mov	 WORD PTR __t$546908[ebp+8], 136 ; 00000088H
  03fef	59		 pop	 ecx
$LL13848@LoadRoomOp:
  03ff0	31 38		 xor	 DWORD PTR [eax], edi
  03ff2	83 c0 04	 add	 eax, 4
  03ff5	49		 dec	 ecx
  03ff6	75 f8		 jne	 SHORT $LL13848@LoadRoomOp
  03ff8	80 b5 5c ff ff
	ff ed		 xor	 BYTE PTR __t$546908[ebp+8], -19 ; ffffffedH
  03fff	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR __t$546908[ebp]
  04005	50		 push	 eax
  04006	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0400c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z
  04012	6a 04		 push	 4

; 514  : 
; 515  : 	iTypeCnt = kLoader.LoadInt_e( "growth_use_type_cnt", 0 );

  04014	c7 85 fc f6 ff
	ff 8a 9e 84 9d	 mov	 DWORD PTR __k$547047[ebp], -1652253046 ; 9d849e8aH
  0401e	c7 85 00 f7 ff
	ff 99 84 b4 9f	 mov	 DWORD PTR __k$547047[ebp+4], -1615559527 ; 9fb48499H
  04028	c7 85 04 f7 ff
	ff 9e 89 b4 9e	 mov	 DWORD PTR __k$547047[ebp+8], -1632335458 ; 9eb4899eH
  04032	c7 85 08 f7 ff
	ff 94 9c 8e b5	 mov	 DWORD PTR __k$547047[ebp+12], -1248945004 ; b58e9c94H
  0403c	8d 85 fc f6 ff
	ff		 lea	 eax, DWORD PTR __k$547047[ebp]
  04042	c7 85 0c f7 ff
	ff 8e 82 9f 00	 mov	 DWORD PTR __k$547047[ebp+16], 10453646 ; 009f828eH
  0404c	59		 pop	 ecx
$LL13954@LoadRoomOp:
  0404d	31 38		 xor	 DWORD PTR [eax], edi
  0404f	83 c0 04	 add	 eax, 4
  04052	49		 dec	 ecx
  04053	75 f8		 jne	 SHORT $LL13954@LoadRoomOp
  04055	6a 10		 push	 16			; 00000010H
  04057	58		 pop	 eax
$LL13951@LoadRoomOp:
  04058	8b c8		 mov	 ecx, eax
  0405a	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  04060	79 05		 jns	 SHORT $LN17576@LoadRoomOp
  04062	49		 dec	 ecx
  04063	83 c9 fc	 or	 ecx, -4			; fffffffcH
  04066	41		 inc	 ecx
$LN17576@LoadRoomOp:
  04067	b2 ed		 mov	 dl, -19			; ffffffedH
  04069	2a d1		 sub	 dl, cl
  0406b	30 94 05 fc f6
	ff ff		 xor	 BYTE PTR __k$547047[ebp+eax], dl
  04072	40		 inc	 eax
  04073	83 f8 13	 cmp	 eax, 19			; 00000013H
  04076	7c e0		 jl	 SHORT $LL13951@LoadRoomOp
  04078	53		 push	 ebx
  04079	8d 85 fc f6 ff
	ff		 lea	 eax, DWORD PTR __k$547047[ebp]
  0407f	50		 push	 eax
  04080	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 516  : 	for( i=0; i < iTypeCnt; ++i )

  0408c	3b c3		 cmp	 eax, ebx
  0408e	0f 8e 59 02 00
	00		 jle	 $LN2684@LoadRoomOp

; 514  : 
; 515  : 	iTypeCnt = kLoader.LoadInt_e( "growth_use_type_cnt", 0 );

  04094	c7 85 d8 ec ff
	ff 01 00 00 00	 mov	 DWORD PTR tv126768[ebp], 1
  0409e	89 85 d0 ec ff
	ff		 mov	 DWORD PTR tv57937[ebp], eax
$LL2686@LoadRoomOp:

; 517  : 	{
; 518  : 		RoomOptionInfo *pInfo = new RoomOptionInfo;

  040a4	6a 50		 push	 80			; 00000050H
  040a6	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  040ab	59		 pop	 ecx
  040ac	89 85 c4 ec ff
	ff		 mov	 DWORD PTR $T540350[ebp], eax
  040b2	c6 45 fc 13	 mov	 BYTE PTR __$EHRec$[ebp+8], 19 ; 00000013H
  040b6	3b c3		 cmp	 eax, ebx
  040b8	74 0f		 je	 SHORT $LN8449@LoadRoomOp
  040ba	8b c8		 mov	 ecx, eax
  040bc	e8 00 00 00 00	 call	 ??0RoomOptionInfo@@QAE@XZ ; RoomOptionInfo::RoomOptionInfo
  040c1	89 85 d4 ec ff
	ff		 mov	 DWORD PTR $T540349[ebp], eax
  040c7	eb 06		 jmp	 SHORT $LN8450@LoadRoomOp
$LN8449@LoadRoomOp:
  040c9	89 9d d4 ec ff
	ff		 mov	 DWORD PTR $T540349[ebp], ebx
$LN8450@LoadRoomOp:
  040cf	8b 85 d4 ec ff
	ff		 mov	 eax, DWORD PTR $T540349[ebp]
  040d5	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  040d8	89 85 c8 ec ff
	ff		 mov	 DWORD PTR _pInfo$519779[ebp], eax

; 519  : 		if( !pInfo )

  040de	3b c3		 cmp	 eax, ebx
  040e0	0f 84 f5 01 00
	00		 je	 $LN2685@LoadRoomOp

; 520  : 			continue;
; 521  : 
; 522  : 		wsprintf_e( szKey, "growth_use_rate%d", i+1 );

  040e6	6a 04		 push	 4
  040e8	c7 85 e4 f9 ff
	ff 8a 9e 84 9d	 mov	 DWORD PTR ___encStr$519788[ebp], -1652253046 ; 9d849e8aH
  040f2	c7 85 e8 f9 ff
	ff 99 84 b4 9f	 mov	 DWORD PTR ___encStr$519788[ebp+4], -1615559527 ; 9fb48499H
  040fc	c7 85 ec f9 ff
	ff 9e 89 b4 98	 mov	 DWORD PTR ___encStr$519788[ebp+8], -1732998754 ; 98b4899eH
  04106	c7 85 f0 f9 ff
	ff 8c 98 8e cf	 mov	 DWORD PTR ___encStr$519788[ebp+12], -812738420 ; cf8e988cH
  04110	8d 85 e4 f9 ff
	ff		 lea	 eax, DWORD PTR ___encStr$519788[ebp]
  04116	66 c7 85 f4 f9
	ff ff 89 00	 mov	 WORD PTR ___encStr$519788[ebp+16], 137 ; 00000089H
  0411f	59		 pop	 ecx
$LL13962@LoadRoomOp:
  04120	31 38		 xor	 DWORD PTR [eax], edi
  04122	83 c0 04	 add	 eax, 4
  04125	49		 dec	 ecx
  04126	75 f8		 jne	 SHORT $LL13962@LoadRoomOp
  04128	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126768[ebp]
  0412e	80 b5 f4 f9 ff
	ff ed		 xor	 BYTE PTR ___encStr$519788[ebp+16], -19 ; ffffffedH
  04135	8d 85 e4 f9 ff
	ff		 lea	 eax, DWORD PTR ___encStr$519788[ebp]
  0413b	50		 push	 eax
  0413c	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  04142	50		 push	 eax
  04143	ff d6		 call	 esi
  04145	83 c4 0c	 add	 esp, 12			; 0000000cH

; 523  : 		pInfo->m_fValue = kLoader.LoadFloat( szKey, FLOAT1 );

  04148	b8 01 00 00 00	 mov	 eax, 1
  0414d	89 85 c4 ec ff
	ff		 mov	 DWORD PTR tv126583[ebp], eax
  04153	db 85 c4 ec ff
	ff		 fild	 DWORD PTR tv126583[ebp]
  04159	85 c0		 test	 eax, eax
  0415b	79 06		 jns	 SHORT $LN17577@LoadRoomOp
  0415d	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN17577@LoadRoomOp:
  04163	51		 push	 ecx
  04164	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  0416a	d9 1c 24	 fstp	 DWORD PTR [esp]
  0416d	50		 push	 eax
  0416e	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04174	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z
  0417a	51		 push	 ecx
  0417b	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540349[ebp]
  04181	d9 1c 24	 fstp	 DWORD PTR [esp]
  04184	e8 00 00 00 00	 call	 ??4?$CEncrypt@M@@QAEMM@Z ; CEncrypt<float>::operator=
  04189	dd d8		 fstp	 ST(0)
  0418b	6a 04		 push	 4

; 524  : 
; 525  : 		wsprintf_e( szKey, "growth_use_desc%d", i+1 );

  0418d	c7 85 a4 fa ff
	ff 8a 9e 84 9d	 mov	 DWORD PTR ___encStr$519941[ebp], -1652253046 ; 9d849e8aH
  04197	c7 85 a8 fa ff
	ff 99 84 b4 9f	 mov	 DWORD PTR ___encStr$519941[ebp+4], -1615559527 ; 9fb48499H
  041a1	c7 85 ac fa ff
	ff 9e 89 b4 8e	 mov	 DWORD PTR ___encStr$519941[ebp+8], -1900770914 ; 8eb4899eH
  041ab	c7 85 b0 fa ff
	ff 88 9f 88 cf	 mov	 DWORD PTR ___encStr$519941[ebp+12], -813129848 ; cf889f88H
  041b5	8d 85 a4 fa ff
	ff		 lea	 eax, DWORD PTR ___encStr$519941[ebp]
  041bb	66 c7 85 b4 fa
	ff ff 89 00	 mov	 WORD PTR ___encStr$519941[ebp+16], 137 ; 00000089H
  041c4	59		 pop	 ecx
$LL13972@LoadRoomOp:
  041c5	31 38		 xor	 DWORD PTR [eax], edi
  041c7	83 c0 04	 add	 eax, 4
  041ca	49		 dec	 ecx
  041cb	75 f8		 jne	 SHORT $LL13972@LoadRoomOp
  041cd	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126768[ebp]
  041d3	80 b5 b4 fa ff
	ff ed		 xor	 BYTE PTR ___encStr$519941[ebp+16], -19 ; ffffffedH
  041da	8d 85 a4 fa ff
	ff		 lea	 eax, DWORD PTR ___encStr$519941[ebp]
  041e0	50		 push	 eax
  041e1	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  041e7	50		 push	 eax
  041e8	ff d6		 call	 esi
  041ea	83 c4 0c	 add	 esp, 12			; 0000000cH

; 526  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  041ed	68 04 01 00 00	 push	 260			; 00000104H
  041f2	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  041f8	50		 push	 eax
  041f9	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  041fe	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  04204	50		 push	 eax
  04205	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0420b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 527  : 		pInfo->m_Desc = szBuf;

  04211	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540349[ebp]
  04217	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  0421d	50		 push	 eax
  0421e	83 c1 30	 add	 ecx, 48			; 00000030H
  04221	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z
  04227	6a 05		 push	 5

; 528  : 
; 529  : 		wsprintf_e( szKey, "growth_use_ui_desc%d", i+1 );

  04229	c7 85 40 f5 ff
	ff 8a 9e 84 9d	 mov	 DWORD PTR ___encStr$520093[ebp], -1652253046 ; 9d849e8aH
  04233	c7 85 44 f5 ff
	ff 99 84 b4 9f	 mov	 DWORD PTR ___encStr$520093[ebp+4], -1615559527 ; 9fb48499H
  0423d	c7 85 48 f5 ff
	ff 9e 89 b4 9f	 mov	 DWORD PTR ___encStr$520093[ebp+8], -1615558242 ; 9fb4899eH
  04247	c7 85 4c f5 ff
	ff 84 b3 8f 8f	 mov	 DWORD PTR ___encStr$520093[ebp+12], -1886407804 ; 8f8fb384H
  04251	c7 85 50 f5 ff
	ff 9e 8f ce 8e	 mov	 DWORD PTR ___encStr$520093[ebp+16], -1899065442 ; 8ece8f9eH
  0425b	8d 85 40 f5 ff
	ff		 lea	 eax, DWORD PTR ___encStr$520093[ebp]
  04261	88 9d 54 f5 ff
	ff		 mov	 BYTE PTR ___encStr$520093[ebp+20], bl
  04267	59		 pop	 ecx
$LL13980@LoadRoomOp:
  04268	31 38		 xor	 DWORD PTR [eax], edi
  0426a	83 c0 04	 add	 eax, 4
  0426d	49		 dec	 ecx
  0426e	75 f8		 jne	 SHORT $LL13980@LoadRoomOp
  04270	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126768[ebp]
  04276	8d 85 40 f5 ff
	ff		 lea	 eax, DWORD PTR ___encStr$520093[ebp]
  0427c	50		 push	 eax
  0427d	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  04283	50		 push	 eax
  04284	ff d6		 call	 esi
  04286	83 c4 0c	 add	 esp, 12			; 0000000cH

; 530  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  04289	68 04 01 00 00	 push	 260			; 00000104H
  0428e	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  04294	50		 push	 eax
  04295	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0429a	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  042a0	50		 push	 eax
  042a1	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  042a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 531  : 		pInfo->m_UIDesc = szBuf;

  042ad	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540349[ebp]
  042b3	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  042b9	50		 push	 eax
  042ba	83 c1 40	 add	 ecx, 64			; 00000040H
  042bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 532  : 
; 533  : 		m_RoomGrowthUseList.push_back( pInfo );

  042c3	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  042c9	8d 85 c8 ec ff
	ff		 lea	 eax, DWORD PTR _pInfo$519779[ebp]
  042cf	50		 push	 eax
  042d0	81 c1 74 01 00
	00		 add	 ecx, 372		; 00000174H
  042d6	e8 00 00 00 00	 call	 ?push_back@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXABQAURoomOptionInfo@@@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::push_back
$LN2685@LoadRoomOp:

; 516  : 	for( i=0; i < iTypeCnt; ++i )

  042db	ff 85 d8 ec ff
	ff		 inc	 DWORD PTR tv126768[ebp]
  042e1	ff 8d d0 ec ff
	ff		 dec	 DWORD PTR tv57937[ebp]
  042e7	0f 85 b7 fd ff
	ff		 jne	 $LL2686@LoadRoomOp
$LN2684@LoadRoomOp:

; 534  : 	}
; 535  : 
; 536  : 	// ExtraItemUse
; 537  : 	kLoader.SetTitle_e( "ExtraItemUse" );

  042ed	6a 03		 push	 3
  042ef	c7 85 18 fe ff
	ff a8 94 9f 98	 mov	 DWORD PTR __t$547225[ebp], -1734372184 ; 989f94a8H
  042f9	c7 85 1c fe ff
	ff 8c a5 9f 8f	 mov	 DWORD PTR __t$547225[ebp+4], -1885362804 ; 8f9fa58cH
  04303	c7 85 20 fe ff
	ff 80 b9 98 8f	 mov	 DWORD PTR __t$547225[ebp+8], -1885816448 ; 8f98b980H
  0430d	8d 85 18 fe ff
	ff		 lea	 eax, DWORD PTR __t$547225[ebp]
  04313	88 9d 24 fe ff
	ff		 mov	 BYTE PTR __t$547225[ebp+12], bl
  04319	59		 pop	 ecx
$LL14086@LoadRoomOp:
  0431a	31 38		 xor	 DWORD PTR [eax], edi
  0431c	83 c0 04	 add	 eax, 4
  0431f	49		 dec	 ecx
  04320	75 f8		 jne	 SHORT $LL14086@LoadRoomOp
  04322	8d 85 18 fe ff
	ff		 lea	 eax, DWORD PTR __t$547225[ebp]
  04328	50		 push	 eax
  04329	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0432f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z
  04335	6a 05		 push	 5

; 538  : 
; 539  : 	iTypeCnt = kLoader.LoadInt_e( "extraitem_use_type_cnt", 0 );

  04337	c7 85 0c f4 ff
	ff 88 94 9f 98	 mov	 DWORD PTR __k$547323[ebp], -1734372216 ; 989f9488H
  04341	c7 85 10 f4 ff
	ff 8c 85 9f 8f	 mov	 DWORD PTR __k$547323[ebp+4], -1885370996 ; 8f9f858cH
  0434b	c7 85 14 f4 ff
	ff 80 b3 9e 99	 mov	 DWORD PTR __k$547323[ebp+8], -1717652608 ; 999eb380H
  04355	c7 85 18 f4 ff
	ff 88 b3 9f 93	 mov	 DWORD PTR __k$547323[ebp+12], -1818250360 ; 939fb388H
  0435f	c7 85 1c f4 ff
	ff 9d 89 b4 89	 mov	 DWORD PTR __k$547323[ebp+16], -1984656995 ; 89b4899dH
  04369	66 c7 85 20 f4
	ff ff 83 98	 mov	 WORD PTR __k$547323[ebp+20], 39043 ; 00009883H
  04372	8d 85 0c f4 ff
	ff		 lea	 eax, DWORD PTR __k$547323[ebp]
  04378	88 9d 22 f4 ff
	ff		 mov	 BYTE PTR __k$547323[ebp+22], bl
  0437e	59		 pop	 ecx
$LL14192@LoadRoomOp:
  0437f	31 38		 xor	 DWORD PTR [eax], edi
  04381	83 c0 04	 add	 eax, 4
  04384	49		 dec	 ecx
  04385	75 f8		 jne	 SHORT $LL14192@LoadRoomOp
  04387	6a 14		 push	 20			; 00000014H
  04389	58		 pop	 eax
$LL14189@LoadRoomOp:
  0438a	8b c8		 mov	 ecx, eax
  0438c	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  04392	79 05		 jns	 SHORT $LN17578@LoadRoomOp
  04394	49		 dec	 ecx
  04395	83 c9 fc	 or	 ecx, -4			; fffffffcH
  04398	41		 inc	 ecx
$LN17578@LoadRoomOp:
  04399	b2 ed		 mov	 dl, -19			; ffffffedH
  0439b	2a d1		 sub	 dl, cl
  0439d	30 94 05 0c f4
	ff ff		 xor	 BYTE PTR __k$547323[ebp+eax], dl
  043a4	40		 inc	 eax
  043a5	83 f8 16	 cmp	 eax, 22			; 00000016H
  043a8	7c e0		 jl	 SHORT $LL14189@LoadRoomOp
  043aa	53		 push	 ebx
  043ab	8d 85 0c f4 ff
	ff		 lea	 eax, DWORD PTR __k$547323[ebp]
  043b1	50		 push	 eax
  043b2	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  043b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 540  : 	for( i=0; i < iTypeCnt; ++i )

  043be	3b c3		 cmp	 eax, ebx
  043c0	0f 8e 80 02 00
	00		 jle	 $LN2383@LoadRoomOp

; 538  : 
; 539  : 	iTypeCnt = kLoader.LoadInt_e( "extraitem_use_type_cnt", 0 );

  043c6	c7 85 d8 ec ff
	ff 01 00 00 00	 mov	 DWORD PTR tv126831[ebp], 1
  043d0	89 85 d0 ec ff
	ff		 mov	 DWORD PTR tv56774[ebp], eax
$LL2385@LoadRoomOp:

; 541  : 	{
; 542  : 		RoomOptionInfo *pInfo = new RoomOptionInfo;

  043d6	6a 50		 push	 80			; 00000050H
  043d8	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  043dd	59		 pop	 ecx
  043de	89 85 c4 ec ff
	ff		 mov	 DWORD PTR $T540354[ebp], eax
  043e4	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
  043e8	3b c3		 cmp	 eax, ebx
  043ea	74 0f		 je	 SHORT $LN8451@LoadRoomOp
  043ec	8b c8		 mov	 ecx, eax
  043ee	e8 00 00 00 00	 call	 ??0RoomOptionInfo@@QAE@XZ ; RoomOptionInfo::RoomOptionInfo
  043f3	89 85 d4 ec ff
	ff		 mov	 DWORD PTR $T540353[ebp], eax
  043f9	eb 06		 jmp	 SHORT $LN8452@LoadRoomOp
$LN8451@LoadRoomOp:
  043fb	89 9d d4 ec ff
	ff		 mov	 DWORD PTR $T540353[ebp], ebx
$LN8452@LoadRoomOp:
  04401	8b 85 d4 ec ff
	ff		 mov	 eax, DWORD PTR $T540353[ebp]
  04407	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  0440a	89 85 c8 ec ff
	ff		 mov	 DWORD PTR _pInfo$520247[ebp], eax

; 543  : 		if( !pInfo )

  04410	3b c3		 cmp	 eax, ebx
  04412	0f 84 1c 02 00
	00		 je	 $LN2384@LoadRoomOp

; 544  : 			continue;
; 545  : 
; 546  : 		wsprintf_e( szKey, "extraitem_use_rate%d", i+1 );

  04418	6a 05		 push	 5
  0441a	c7 85 98 f4 ff
	ff 88 94 9f 98	 mov	 DWORD PTR ___encStr$520256[ebp], -1734372216 ; 989f9488H
  04424	c7 85 9c f4 ff
	ff 8c 85 9f 8f	 mov	 DWORD PTR ___encStr$520256[ebp+4], -1885370996 ; 8f9f858cH
  0442e	c7 85 a0 f4 ff
	ff 80 b3 9e 99	 mov	 DWORD PTR ___encStr$520256[ebp+8], -1717652608 ; 999eb380H
  04438	c7 85 a4 f4 ff
	ff 88 b3 99 8b	 mov	 DWORD PTR ___encStr$520256[ebp+12], -1952861304 ; 8b99b388H
  04442	c7 85 a8 f4 ff
	ff 99 89 ce 8e	 mov	 DWORD PTR ___encStr$520256[ebp+16], -1899066983 ; 8ece8999H
  0444c	8d 85 98 f4 ff
	ff		 lea	 eax, DWORD PTR ___encStr$520256[ebp]
  04452	88 9d ac f4 ff
	ff		 mov	 BYTE PTR ___encStr$520256[ebp+20], bl
  04458	59		 pop	 ecx
$LL14200@LoadRoomOp:
  04459	31 38		 xor	 DWORD PTR [eax], edi
  0445b	83 c0 04	 add	 eax, 4
  0445e	49		 dec	 ecx
  0445f	75 f8		 jne	 SHORT $LL14200@LoadRoomOp
  04461	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126831[ebp]
  04467	8d 85 98 f4 ff
	ff		 lea	 eax, DWORD PTR ___encStr$520256[ebp]
  0446d	50		 push	 eax
  0446e	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  04474	50		 push	 eax
  04475	ff d6		 call	 esi
  04477	83 c4 0c	 add	 esp, 12			; 0000000cH

; 547  : 		pInfo->m_fValue = kLoader.LoadFloat( szKey, FLOAT1 );

  0447a	b8 01 00 00 00	 mov	 eax, 1
  0447f	89 85 c4 ec ff
	ff		 mov	 DWORD PTR tv126552[ebp], eax
  04485	db 85 c4 ec ff
	ff		 fild	 DWORD PTR tv126552[ebp]
  0448b	85 c0		 test	 eax, eax
  0448d	79 06		 jns	 SHORT $LN17579@LoadRoomOp
  0448f	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN17579@LoadRoomOp:
  04495	51		 push	 ecx
  04496	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  0449c	d9 1c 24	 fstp	 DWORD PTR [esp]
  0449f	50		 push	 eax
  044a0	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  044a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z
  044ac	51		 push	 ecx
  044ad	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540353[ebp]
  044b3	d9 1c 24	 fstp	 DWORD PTR [esp]
  044b6	e8 00 00 00 00	 call	 ??4?$CEncrypt@M@@QAEMM@Z ; CEncrypt<float>::operator=
  044bb	dd d8		 fstp	 ST(0)
  044bd	6a 05		 push	 5

; 548  : 
; 549  : 		wsprintf_e( szKey, "extraitem_use_desc%d", i+1 );

  044bf	c7 85 b4 f4 ff
	ff 88 94 9f 98	 mov	 DWORD PTR ___encStr$520409[ebp], -1734372216 ; 989f9488H
  044c9	c7 85 b8 f4 ff
	ff 8c 85 9f 8f	 mov	 DWORD PTR ___encStr$520409[ebp+4], -1885370996 ; 8f9f858cH
  044d3	c7 85 bc f4 ff
	ff 80 b3 9e 99	 mov	 DWORD PTR ___encStr$520409[ebp+8], -1717652608 ; 999eb380H
  044dd	c7 85 c0 f4 ff
	ff 88 b3 8f 8f	 mov	 DWORD PTR ___encStr$520409[ebp+12], -1886407800 ; 8f8fb388H
  044e7	c7 85 c4 f4 ff
	ff 9e 8f ce 8e	 mov	 DWORD PTR ___encStr$520409[ebp+16], -1899065442 ; 8ece8f9eH
  044f1	8d 85 b4 f4 ff
	ff		 lea	 eax, DWORD PTR ___encStr$520409[ebp]
  044f7	88 9d c8 f4 ff
	ff		 mov	 BYTE PTR ___encStr$520409[ebp+20], bl
  044fd	59		 pop	 ecx
$LL14210@LoadRoomOp:
  044fe	31 38		 xor	 DWORD PTR [eax], edi
  04500	83 c0 04	 add	 eax, 4
  04503	49		 dec	 ecx
  04504	75 f8		 jne	 SHORT $LL14210@LoadRoomOp
  04506	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126831[ebp]
  0450c	8d 85 b4 f4 ff
	ff		 lea	 eax, DWORD PTR ___encStr$520409[ebp]
  04512	50		 push	 eax
  04513	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  04519	50		 push	 eax
  0451a	ff d6		 call	 esi
  0451c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 550  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  0451f	68 04 01 00 00	 push	 260			; 00000104H
  04524	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  0452a	50		 push	 eax
  0452b	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  04530	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  04536	50		 push	 eax
  04537	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0453d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 551  : 		pInfo->m_Desc = szBuf;

  04543	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540353[ebp]
  04549	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  0454f	50		 push	 eax
  04550	83 c1 30	 add	 ecx, 48			; 00000030H
  04553	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z
  04559	6a 05		 push	 5

; 552  : 
; 553  : 		wsprintf_e( szKey, "extraitem_use_ui_desc%d", i+1 );

  0455b	c7 85 10 f3 ff
	ff 88 94 9f 98	 mov	 DWORD PTR ___encStr$520561[ebp], -1734372216 ; 989f9488H
  04565	c7 85 14 f3 ff
	ff 8c 85 9f 8f	 mov	 DWORD PTR ___encStr$520561[ebp+4], -1885370996 ; 8f9f858cH
  0456f	c7 85 18 f3 ff
	ff 80 b3 9e 99	 mov	 DWORD PTR ___encStr$520561[ebp+8], -1717652608 ; 999eb380H
  04579	c7 85 1c f3 ff
	ff 88 b3 9e 83	 mov	 DWORD PTR ___encStr$520561[ebp+12], -2086751352 ; 839eb388H
  04583	c7 85 20 f3 ff
	ff b2 88 8e 99	 mov	 DWORD PTR ___encStr$520561[ebp+16], -1718712142 ; 998e88b2H
  0458d	8d 85 10 f3 ff
	ff		 lea	 eax, DWORD PTR ___encStr$520561[ebp]
  04593	c7 85 24 f3 ff
	ff 8e c9 8f 00	 mov	 DWORD PTR ___encStr$520561[ebp+20], 9423246 ; 008fc98eH
  0459d	59		 pop	 ecx
$LL14218@LoadRoomOp:
  0459e	31 38		 xor	 DWORD PTR [eax], edi
  045a0	83 c0 04	 add	 eax, 4
  045a3	49		 dec	 ecx
  045a4	75 f8		 jne	 SHORT $LL14218@LoadRoomOp
  045a6	6a 14		 push	 20			; 00000014H
  045a8	58		 pop	 eax
$LL14215@LoadRoomOp:
  045a9	8b c8		 mov	 ecx, eax
  045ab	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  045b1	79 05		 jns	 SHORT $LN17580@LoadRoomOp
  045b3	49		 dec	 ecx
  045b4	83 c9 fc	 or	 ecx, -4			; fffffffcH
  045b7	41		 inc	 ecx
$LN17580@LoadRoomOp:
  045b8	b2 ed		 mov	 dl, -19			; ffffffedH
  045ba	2a d1		 sub	 dl, cl
  045bc	30 94 05 10 f3
	ff ff		 xor	 BYTE PTR ___encStr$520561[ebp+eax], dl
  045c3	40		 inc	 eax
  045c4	83 f8 17	 cmp	 eax, 23			; 00000017H
  045c7	7c e0		 jl	 SHORT $LL14215@LoadRoomOp
  045c9	ff b5 d8 ec ff
	ff		 push	 DWORD PTR tv126831[ebp]
  045cf	8d 85 10 f3 ff
	ff		 lea	 eax, DWORD PTR ___encStr$520561[ebp]
  045d5	50		 push	 eax
  045d6	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  045dc	50		 push	 eax
  045dd	ff d6		 call	 esi
  045df	83 c4 0c	 add	 esp, 12			; 0000000cH

; 554  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  045e2	68 04 01 00 00	 push	 260			; 00000104H
  045e7	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  045ed	50		 push	 eax
  045ee	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  045f3	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  045f9	50		 push	 eax
  045fa	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04600	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 555  : 		pInfo->m_UIDesc = szBuf;

  04606	8b 8d d4 ec ff
	ff		 mov	 ecx, DWORD PTR $T540353[ebp]
  0460c	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  04612	50		 push	 eax
  04613	83 c1 40	 add	 ecx, 64			; 00000040H
  04616	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 556  : 
; 557  : 		m_RoomExtraItemUseList.push_back( pInfo );

  0461c	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  04622	8d 85 c8 ec ff
	ff		 lea	 eax, DWORD PTR _pInfo$520247[ebp]
  04628	50		 push	 eax
  04629	81 c1 84 01 00
	00		 add	 ecx, 388		; 00000184H
  0462f	e8 00 00 00 00	 call	 ?push_back@?$vector@PAURoomOptionInfo@@V?$allocator@PAURoomOptionInfo@@@std@@@std@@QAEXABQAURoomOptionInfo@@@Z ; std::vector<RoomOptionInfo *,std::allocator<RoomOptionInfo *> >::push_back
$LN2384@LoadRoomOp:

; 540  : 	for( i=0; i < iTypeCnt; ++i )

  04634	ff 85 d8 ec ff
	ff		 inc	 DWORD PTR tv126831[ebp]
  0463a	ff 8d d0 ec ff
	ff		 dec	 DWORD PTR tv56774[ebp]
  04640	0f 85 90 fd ff
	ff		 jne	 $LL2385@LoadRoomOp
$LN2383@LoadRoomOp:

; 558  : 	}
; 559  : 
; 560  : 
; 561  : 	// Default
; 562  : 	kLoader.SetTitle_e( "DefaultSet" );

  04646	6a 02		 push	 2
  04648	c7 85 e4 fe ff
	ff a9 89 8d 8b	 mov	 DWORD PTR __t$547475[ebp], -1953658455 ; 8b8d89a9H
  04652	c7 85 e8 fe ff
	ff 98 80 9f b9	 mov	 DWORD PTR __t$547475[ebp+4], -1180729192 ; b99f8098H
  0465c	66 c7 85 ec fe
	ff ff 88 98	 mov	 WORD PTR __t$547475[ebp+8], 39048 ; 00009888H
  04665	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR __t$547475[ebp]
  0466b	88 9d ee fe ff
	ff		 mov	 BYTE PTR __t$547475[ebp+10], bl
  04671	59		 pop	 ecx
$LL14324@LoadRoomOp:
  04672	31 38		 xor	 DWORD PTR [eax], edi
  04674	83 c0 04	 add	 eax, 4
  04677	49		 dec	 ecx
  04678	75 f8		 jne	 SHORT $LL14324@LoadRoomOp
  0467a	6a 08		 push	 8
  0467c	58		 pop	 eax
$LL14321@LoadRoomOp:
  0467d	8b c8		 mov	 ecx, eax
  0467f	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  04685	79 05		 jns	 SHORT $LN17581@LoadRoomOp
  04687	49		 dec	 ecx
  04688	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0468b	41		 inc	 ecx
$LN17581@LoadRoomOp:
  0468c	b2 ed		 mov	 dl, -19			; ffffffedH
  0468e	2a d1		 sub	 dl, cl
  04690	30 94 05 e4 fe
	ff ff		 xor	 BYTE PTR __t$547475[ebp+eax], dl
  04697	40		 inc	 eax
  04698	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0469b	7c e0		 jl	 SHORT $LL14321@LoadRoomOp
  0469d	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR __t$547475[ebp]
  046a3	50		 push	 eax
  046a4	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  046aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z
  046b0	6a 05		 push	 5

; 563  : 
; 564  : 	m_DefaultInfo.m_iChangeCharType = kLoader.LoadInt_e( "default_charnge_char", 0 );

  046b2	c7 85 94 f5 ff
	ff 89 89 8d 8b	 mov	 DWORD PTR __k$547600[ebp], -1953658487 ; 8b8d8989H
  046bc	c7 85 98 f5 ff
	ff 98 80 9f b5	 mov	 DWORD PTR __k$547600[ebp+4], -1247838056 ; b59f8098H
  046c6	c7 85 9c f5 ff
	ff 8e 84 8a 98	 mov	 DWORD PTR __k$547600[ebp+8], -1735752562 ; 988a848eH
  046d0	c7 85 a0 f5 ff
	ff 83 8b 8e b5	 mov	 DWORD PTR __k$547600[ebp+12], -1248949373 ; b58e8b83H
  046da	c7 85 a4 f5 ff
	ff 8e 84 8a 98	 mov	 DWORD PTR __k$547600[ebp+16], -1735752562 ; 988a848eH
  046e4	8d 85 94 f5 ff
	ff		 lea	 eax, DWORD PTR __k$547600[ebp]
  046ea	88 9d a8 f5 ff
	ff		 mov	 BYTE PTR __k$547600[ebp+20], bl
  046f0	59		 pop	 ecx
$LL14430@LoadRoomOp:
  046f1	31 38		 xor	 DWORD PTR [eax], edi
  046f3	83 c0 04	 add	 eax, 4
  046f6	49		 dec	 ecx
  046f7	75 f8		 jne	 SHORT $LL14430@LoadRoomOp
  046f9	53		 push	 ebx
  046fa	8d 85 94 f5 ff
	ff		 lea	 eax, DWORD PTR __k$547600[ebp]
  04700	50		 push	 eax
  04701	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04707	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  0470d	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  04713	89 81 b8 01 00
	00		 mov	 DWORD PTR [ecx+440], eax
  04719	6a 04		 push	 4

; 565  : 	m_DefaultInfo.m_iTeamAttackType = kLoader.LoadInt_e( "default_team_attack", 0 );

  0471b	c7 85 14 f7 ff
	ff 89 89 8d 8b	 mov	 DWORD PTR __k$547750[ebp], -1953658487 ; 8b8d8989H
  04725	c7 85 18 f7 ff
	ff 98 80 9f b5	 mov	 DWORD PTR __k$547750[ebp+4], -1247838056 ; b59f8098H
  0472f	c7 85 1c f7 ff
	ff 99 89 8a 87	 mov	 DWORD PTR __k$547750[ebp+8], -2020963943 ; 878a8999H
  04739	c7 85 20 f7 ff
	ff b2 8d 9f 9e	 mov	 DWORD PTR __k$547750[ebp+12], -1633710670 ; 9e9f8db2H
  04743	8d 85 14 f7 ff
	ff		 lea	 eax, DWORD PTR __k$547750[ebp]
  04749	c7 85 24 f7 ff
	ff 8c 8f 80 00	 mov	 DWORD PTR __k$547750[ebp+16], 8425356 ; 00808f8cH
  04753	59		 pop	 ecx
$LL14536@LoadRoomOp:
  04754	31 38		 xor	 DWORD PTR [eax], edi
  04756	83 c0 04	 add	 eax, 4
  04759	49		 dec	 ecx
  0475a	75 f8		 jne	 SHORT $LL14536@LoadRoomOp
  0475c	6a 10		 push	 16			; 00000010H
  0475e	58		 pop	 eax
$LL14533@LoadRoomOp:
  0475f	8b c8		 mov	 ecx, eax
  04761	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  04767	79 05		 jns	 SHORT $LN17582@LoadRoomOp
  04769	49		 dec	 ecx
  0476a	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0476d	41		 inc	 ecx
$LN17582@LoadRoomOp:
  0476e	b2 ed		 mov	 dl, -19			; ffffffedH
  04770	2a d1		 sub	 dl, cl
  04772	30 94 05 14 f7
	ff ff		 xor	 BYTE PTR __k$547750[ebp+eax], dl
  04779	40		 inc	 eax
  0477a	83 f8 13	 cmp	 eax, 19			; 00000013H
  0477d	7c e0		 jl	 SHORT $LL14533@LoadRoomOp
  0477f	53		 push	 ebx
  04780	8d 85 14 f7 ff
	ff		 lea	 eax, DWORD PTR __k$547750[ebp]
  04786	50		 push	 eax
  04787	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0478d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  04793	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  04799	89 81 b4 01 00
	00		 mov	 DWORD PTR [ecx+436], eax
  0479f	6a 04		 push	 4

; 566  : 	m_DefaultInfo.m_iCoolTimeType = kLoader.LoadInt_e( "default_cooltime", 0 );

  047a1	c7 85 f4 f8 ff
	ff 89 89 8d 8b	 mov	 DWORD PTR __k$547859[ebp], -1953658487 ; 8b8d8989H
  047ab	c7 85 f8 f8 ff
	ff 98 80 9f b5	 mov	 DWORD PTR __k$547859[ebp+4], -1247838056 ; b59f8098H
  047b5	c7 85 fc f8 ff
	ff 8e 83 84 86	 mov	 DWORD PTR __k$547859[ebp+8], -2038135922 ; 8684838eH
  047bf	c7 85 00 f9 ff
	ff 99 85 86 8f	 mov	 DWORD PTR __k$547859[ebp+12], -1887009383 ; 8f868599H
  047c9	8d 85 f4 f8 ff
	ff		 lea	 eax, DWORD PTR __k$547859[ebp]
  047cf	88 9d 04 f9 ff
	ff		 mov	 BYTE PTR __k$547859[ebp+16], bl
  047d5	59		 pop	 ecx
$LL14642@LoadRoomOp:
  047d6	31 38		 xor	 DWORD PTR [eax], edi
  047d8	83 c0 04	 add	 eax, 4
  047db	49		 dec	 ecx
  047dc	75 f8		 jne	 SHORT $LL14642@LoadRoomOp
  047de	53		 push	 ebx
  047df	8d 85 f4 f8 ff
	ff		 lea	 eax, DWORD PTR __k$547859[ebp]
  047e5	50		 push	 eax
  047e6	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  047ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  047f2	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  047f8	89 81 bc 01 00
	00		 mov	 DWORD PTR [ecx+444], eax
  047fe	6a 03		 push	 3

; 567  : 	m_DefaultInfo.m_iRedHPType = kLoader.LoadInt_e( "default_red_hp", 0 );

  04800	c7 85 c0 fb ff
	ff 89 89 8d 8b	 mov	 DWORD PTR __k$548028[ebp], -1953658487 ; 8b8d8989H
  0480a	c7 85 c4 fb ff
	ff 98 80 9f b5	 mov	 DWORD PTR __k$548028[ebp+4], -1247838056 ; b59f8098H
  04814	c7 85 c8 fb ff
	ff 9f 89 8f b5	 mov	 DWORD PTR __k$548028[ebp+8], -1248884321 ; b58f899fH
  0481e	66 c7 85 cc fb
	ff ff 85 9c	 mov	 WORD PTR __k$548028[ebp+12], 40069 ; 00009c85H
  04827	8d 85 c0 fb ff
	ff		 lea	 eax, DWORD PTR __k$548028[ebp]
  0482d	88 9d ce fb ff
	ff		 mov	 BYTE PTR __k$548028[ebp+14], bl
  04833	59		 pop	 ecx
$LL14748@LoadRoomOp:
  04834	31 38		 xor	 DWORD PTR [eax], edi
  04836	83 c0 04	 add	 eax, 4
  04839	49		 dec	 ecx
  0483a	75 f8		 jne	 SHORT $LL14748@LoadRoomOp
  0483c	6a 0c		 push	 12			; 0000000cH
  0483e	58		 pop	 eax
$LL14745@LoadRoomOp:
  0483f	8b c8		 mov	 ecx, eax
  04841	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  04847	79 05		 jns	 SHORT $LN17583@LoadRoomOp
  04849	49		 dec	 ecx
  0484a	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0484d	41		 inc	 ecx
$LN17583@LoadRoomOp:
  0484e	b2 ed		 mov	 dl, -19			; ffffffedH
  04850	2a d1		 sub	 dl, cl
  04852	30 94 05 c0 fb
	ff ff		 xor	 BYTE PTR __k$548028[ebp+eax], dl
  04859	40		 inc	 eax
  0485a	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  0485d	7c e0		 jl	 SHORT $LL14745@LoadRoomOp
  0485f	53		 push	 ebx
  04860	8d 85 c0 fb ff
	ff		 lea	 eax, DWORD PTR __k$548028[ebp]
  04866	50		 push	 eax
  04867	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0486d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  04873	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  04879	50		 push	 eax
  0487a	81 c1 c0 01 00
	00		 add	 ecx, 448		; 000001c0H
  04880	e8 00 00 00 00	 call	 ??4?$CEncrypt@H@@QAEHH@Z ; CEncrypt<int>::operator=
  04885	6a 03		 push	 3

; 568  : 	m_DefaultInfo.m_iBlueHPType = kLoader.LoadInt_e( "default_blue_hp", 0 );

  04887	c7 85 34 fb ff
	ff 89 89 8d 8b	 mov	 DWORD PTR __k$548113[ebp], -1953658487 ; 8b8d8989H
  04891	c7 85 38 fb ff
	ff 98 80 9f b5	 mov	 DWORD PTR __k$548113[ebp+4], -1247838056 ; b59f8098H
  0489b	c7 85 3c fb ff
	ff 8f 80 9e 8f	 mov	 DWORD PTR __k$548113[ebp+8], -1885437809 ; 8f9e808fH
  048a5	8d 85 34 fb ff
	ff		 lea	 eax, DWORD PTR __k$548113[ebp]
  048ab	c7 85 40 fb ff
	ff b2 84 9b 00	 mov	 DWORD PTR __k$548113[ebp+12], 10192050 ; 009b84b2H
  048b5	59		 pop	 ecx
$LL14854@LoadRoomOp:
  048b6	31 38		 xor	 DWORD PTR [eax], edi
  048b8	83 c0 04	 add	 eax, 4
  048bb	49		 dec	 ecx
  048bc	75 f8		 jne	 SHORT $LL14854@LoadRoomOp
  048be	6a 0c		 push	 12			; 0000000cH
  048c0	58		 pop	 eax
$LL14851@LoadRoomOp:
  048c1	8b c8		 mov	 ecx, eax
  048c3	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  048c9	79 05		 jns	 SHORT $LN17584@LoadRoomOp
  048cb	49		 dec	 ecx
  048cc	83 c9 fc	 or	 ecx, -4			; fffffffcH
  048cf	41		 inc	 ecx
$LN17584@LoadRoomOp:
  048d0	b2 ed		 mov	 dl, -19			; ffffffedH
  048d2	2a d1		 sub	 dl, cl
  048d4	30 94 05 34 fb
	ff ff		 xor	 BYTE PTR __k$548113[ebp+eax], dl
  048db	40		 inc	 eax
  048dc	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  048df	7c e0		 jl	 SHORT $LL14851@LoadRoomOp
  048e1	53		 push	 ebx
  048e2	8d 85 34 fb ff
	ff		 lea	 eax, DWORD PTR __k$548113[ebp]
  048e8	50		 push	 eax
  048e9	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  048ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  048f5	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  048fb	50		 push	 eax
  048fc	81 c1 f0 01 00
	00		 add	 ecx, 496		; 000001f0H
  04902	e8 00 00 00 00	 call	 ??4?$CEncrypt@H@@QAEHH@Z ; CEncrypt<int>::operator=
  04907	6a 04		 push	 4

; 569  : 	m_DefaultInfo.m_iDropDamageType = kLoader.LoadInt_e( "default_dropdamage", 0 );

  04909	c7 85 ec f7 ff
	ff 89 89 8d 8b	 mov	 DWORD PTR __k$548225[ebp], -1953658487 ; 8b8d8989H
  04913	c7 85 f0 f7 ff
	ff 98 80 9f b5	 mov	 DWORD PTR __k$548225[ebp+4], -1247838056 ; b59f8098H
  0491d	c7 85 f4 f7 ff
	ff 89 9e 84 9a	 mov	 DWORD PTR __k$548225[ebp+8], -1702584695 ; 9a849e89H
  04927	c7 85 f8 f7 ff
	ff 89 8d 86 8b	 mov	 DWORD PTR __k$548225[ebp+12], -1954116215 ; 8b868d89H
  04931	66 c7 85 fc f7
	ff ff 8a 89	 mov	 WORD PTR __k$548225[ebp+16], 35210 ; 0000898aH
  0493a	8d 85 ec f7 ff
	ff		 lea	 eax, DWORD PTR __k$548225[ebp]
  04940	88 9d fe f7 ff
	ff		 mov	 BYTE PTR __k$548225[ebp+18], bl
  04946	59		 pop	 ecx
$LL14960@LoadRoomOp:
  04947	31 38		 xor	 DWORD PTR [eax], edi
  04949	83 c0 04	 add	 eax, 4
  0494c	49		 dec	 ecx
  0494d	75 f8		 jne	 SHORT $LL14960@LoadRoomOp
  0494f	6a 10		 push	 16			; 00000010H
  04951	58		 pop	 eax
$LL14957@LoadRoomOp:
  04952	8b c8		 mov	 ecx, eax
  04954	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0495a	79 05		 jns	 SHORT $LN17585@LoadRoomOp
  0495c	49		 dec	 ecx
  0495d	83 c9 fc	 or	 ecx, -4			; fffffffcH
  04960	41		 inc	 ecx
$LN17585@LoadRoomOp:
  04961	b2 ed		 mov	 dl, -19			; ffffffedH
  04963	2a d1		 sub	 dl, cl
  04965	30 94 05 ec f7
	ff ff		 xor	 BYTE PTR __k$548225[ebp+eax], dl
  0496c	40		 inc	 eax
  0496d	83 f8 12	 cmp	 eax, 18			; 00000012H
  04970	7c e0		 jl	 SHORT $LL14957@LoadRoomOp
  04972	53		 push	 ebx
  04973	8d 85 ec f7 ff
	ff		 lea	 eax, DWORD PTR __k$548225[ebp]
  04979	50		 push	 eax
  0497a	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04980	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  04986	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0498c	89 81 20 02 00
	00		 mov	 DWORD PTR [ecx+544], eax
  04992	6a 03		 push	 3

; 570  : 	m_DefaultInfo.m_iGravityType = kLoader.LoadInt_e( "default_gravity", 0 );

  04994	c7 85 0c fb ff
	ff 89 89 8d 8b	 mov	 DWORD PTR __k$548350[ebp], -1953658487 ; 8b8d8989H
  0499e	c7 85 10 fb ff
	ff 98 80 9f b5	 mov	 DWORD PTR __k$548350[ebp+4], -1247838056 ; b59f8098H
  049a8	c7 85 14 fb ff
	ff 8a 9e 8a 9c	 mov	 DWORD PTR __k$548350[ebp+8], -1668637046 ; 9c8a9e8aH
  049b2	8d 85 0c fb ff
	ff		 lea	 eax, DWORD PTR __k$548350[ebp]
  049b8	c7 85 18 fb ff
	ff 84 98 92 00	 mov	 DWORD PTR __k$548350[ebp+12], 9607300 ; 00929884H
  049c2	59		 pop	 ecx
$LL15066@LoadRoomOp:
  049c3	31 38		 xor	 DWORD PTR [eax], edi
  049c5	83 c0 04	 add	 eax, 4
  049c8	49		 dec	 ecx
  049c9	75 f8		 jne	 SHORT $LL15066@LoadRoomOp
  049cb	6a 0c		 push	 12			; 0000000cH
  049cd	58		 pop	 eax
$LL15063@LoadRoomOp:
  049ce	8b c8		 mov	 ecx, eax
  049d0	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  049d6	79 05		 jns	 SHORT $LN17586@LoadRoomOp
  049d8	49		 dec	 ecx
  049d9	83 c9 fc	 or	 ecx, -4			; fffffffcH
  049dc	41		 inc	 ecx
$LN17586@LoadRoomOp:
  049dd	b2 ed		 mov	 dl, -19			; ffffffedH
  049df	2a d1		 sub	 dl, cl
  049e1	30 94 05 0c fb
	ff ff		 xor	 BYTE PTR __k$548350[ebp+eax], dl
  049e8	40		 inc	 eax
  049e9	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  049ec	7c e0		 jl	 SHORT $LL15063@LoadRoomOp
  049ee	53		 push	 ebx
  049ef	8d 85 0c fb ff
	ff		 lea	 eax, DWORD PTR __k$548350[ebp]
  049f5	50		 push	 eax
  049f6	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  049fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  04a02	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  04a08	89 81 24 02 00
	00		 mov	 DWORD PTR [ecx+548], eax
  04a0e	6a 03		 push	 3

; 571  : 	m_DefaultInfo.m_iGetUpType = kLoader.LoadInt_e( "default_getup", 0 );

  04a10	c7 85 9c fc ff
	ff 89 89 8d 8b	 mov	 DWORD PTR __k$548488[ebp], -1953658487 ; 8b8d8989H
  04a1a	c7 85 a0 fc ff
	ff 98 80 9f b5	 mov	 DWORD PTR __k$548488[ebp+4], -1247838056 ; b59f8098H
  04a24	c7 85 a4 fc ff
	ff 8a 89 9f 9f	 mov	 DWORD PTR __k$548488[ebp+8], -1616934518 ; 9f9f898aH
  04a2e	8d 85 9c fc ff
	ff		 lea	 eax, DWORD PTR __k$548488[ebp]
  04a34	66 c7 85 a8 fc
	ff ff 9d 00	 mov	 WORD PTR __k$548488[ebp+12], 157 ; 0000009dH
  04a3d	59		 pop	 ecx
$LL15172@LoadRoomOp:
  04a3e	31 38		 xor	 DWORD PTR [eax], edi
  04a40	83 c0 04	 add	 eax, 4
  04a43	49		 dec	 ecx
  04a44	75 f8		 jne	 SHORT $LL15172@LoadRoomOp
  04a46	80 b5 a8 fc ff
	ff ed		 xor	 BYTE PTR __k$548488[ebp+12], -19 ; ffffffedH
  04a4d	53		 push	 ebx
  04a4e	8d 85 9c fc ff
	ff		 lea	 eax, DWORD PTR __k$548488[ebp]
  04a54	50		 push	 eax
  04a55	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04a5b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  04a61	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  04a67	89 81 28 02 00
	00		 mov	 DWORD PTR [ecx+552], eax
  04a6d	6a 03		 push	 3

; 572  : 	m_DefaultInfo.m_iKOType = kLoader.LoadInt_e( "default_ko_type", 0 );

  04a6f	c7 85 e4 fa ff
	ff 89 89 8d 8b	 mov	 DWORD PTR __k$548600[ebp], -1953658487 ; 8b8d8989H
  04a79	c7 85 e8 fa ff
	ff 98 80 9f b5	 mov	 DWORD PTR __k$548600[ebp+4], -1247838056 ; b59f8098H
  04a83	c7 85 ec fa ff
	ff 86 83 b4 9e	 mov	 DWORD PTR __k$548600[ebp+8], -1632337018 ; 9eb48386H
  04a8d	8d 85 e4 fa ff
	ff		 lea	 eax, DWORD PTR __k$548600[ebp]
  04a93	c7 85 f0 fa ff
	ff 94 9c 8e 00	 mov	 DWORD PTR __k$548600[ebp+12], 9346196 ; 008e9c94H
  04a9d	59		 pop	 ecx
$LL15278@LoadRoomOp:
  04a9e	31 38		 xor	 DWORD PTR [eax], edi
  04aa0	83 c0 04	 add	 eax, 4
  04aa3	49		 dec	 ecx
  04aa4	75 f8		 jne	 SHORT $LL15278@LoadRoomOp
  04aa6	6a 0c		 push	 12			; 0000000cH
  04aa8	58		 pop	 eax
$LL15275@LoadRoomOp:
  04aa9	8b c8		 mov	 ecx, eax
  04aab	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  04ab1	79 05		 jns	 SHORT $LN17587@LoadRoomOp
  04ab3	49		 dec	 ecx
  04ab4	83 c9 fc	 or	 ecx, -4			; fffffffcH
  04ab7	41		 inc	 ecx
$LN17587@LoadRoomOp:
  04ab8	b2 ed		 mov	 dl, -19			; ffffffedH
  04aba	2a d1		 sub	 dl, cl
  04abc	30 94 05 e4 fa
	ff ff		 xor	 BYTE PTR __k$548600[ebp+eax], dl
  04ac3	40		 inc	 eax
  04ac4	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  04ac7	7c e0		 jl	 SHORT $LL15275@LoadRoomOp
  04ac9	53		 push	 ebx
  04aca	8d 85 e4 fa ff
	ff		 lea	 eax, DWORD PTR __k$548600[ebp]
  04ad0	50		 push	 eax
  04ad1	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04ad7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  04add	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  04ae3	89 81 2c 02 00
	00		 mov	 DWORD PTR [ecx+556], eax
  04ae9	6a 05		 push	 5

; 573  : 	m_DefaultInfo.m_iKOEffectType = kLoader.LoadInt_e( "default_ko_effect_type", 0 );

  04aeb	c7 85 60 f4 ff
	ff 89 89 8d 8b	 mov	 DWORD PTR __k$548725[ebp], -1953658487 ; 8b8d8989H
  04af5	c7 85 64 f4 ff
	ff 98 80 9f b5	 mov	 DWORD PTR __k$548725[ebp+4], -1247838056 ; b59f8098H
  04aff	c7 85 68 f4 ff
	ff 86 83 b4 8f	 mov	 DWORD PTR __k$548725[ebp+8], -1883995258 ; 8fb48386H
  04b09	c7 85 6c f4 ff
	ff 8b 8a 8e 89	 mov	 DWORD PTR __k$548725[ebp+12], -1987147125 ; 898e8a8bH
  04b13	c7 85 70 f4 ff
	ff 99 b3 9f 93	 mov	 DWORD PTR __k$548725[ebp+16], -1818250343 ; 939fb399H
  04b1d	66 c7 85 74 f4
	ff ff 9d 89	 mov	 WORD PTR __k$548725[ebp+20], 35229 ; 0000899dH
  04b26	8d 85 60 f4 ff
	ff		 lea	 eax, DWORD PTR __k$548725[ebp]
  04b2c	88 9d 76 f4 ff
	ff		 mov	 BYTE PTR __k$548725[ebp+22], bl
  04b32	59		 pop	 ecx
$LL15384@LoadRoomOp:
  04b33	31 38		 xor	 DWORD PTR [eax], edi
  04b35	83 c0 04	 add	 eax, 4
  04b38	49		 dec	 ecx
  04b39	75 f8		 jne	 SHORT $LL15384@LoadRoomOp
  04b3b	6a 14		 push	 20			; 00000014H
  04b3d	58		 pop	 eax
$LL15381@LoadRoomOp:
  04b3e	8b c8		 mov	 ecx, eax
  04b40	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  04b46	79 05		 jns	 SHORT $LN17588@LoadRoomOp
  04b48	49		 dec	 ecx
  04b49	83 c9 fc	 or	 ecx, -4			; fffffffcH
  04b4c	41		 inc	 ecx
$LN17588@LoadRoomOp:
  04b4d	b2 ed		 mov	 dl, -19			; ffffffedH
  04b4f	2a d1		 sub	 dl, cl
  04b51	30 94 05 60 f4
	ff ff		 xor	 BYTE PTR __k$548725[ebp+eax], dl
  04b58	40		 inc	 eax
  04b59	83 f8 16	 cmp	 eax, 22			; 00000016H
  04b5c	7c e0		 jl	 SHORT $LL15381@LoadRoomOp
  04b5e	53		 push	 ebx
  04b5f	8d 85 60 f4 ff
	ff		 lea	 eax, DWORD PTR __k$548725[ebp]
  04b65	50		 push	 eax
  04b66	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04b6c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  04b72	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  04b78	89 81 30 02 00
	00		 mov	 DWORD PTR [ecx+560], eax
  04b7e	6a 05		 push	 5

; 574  : 	m_DefaultInfo.m_iRedBlowType = kLoader.LoadInt_e( "default_red_blow_type", 0 );

  04b80	c7 85 e8 f5 ff
	ff 89 89 8d 8b	 mov	 DWORD PTR __k$548850[ebp], -1953658487 ; 8b8d8989H
  04b8a	c7 85 ec f5 ff
	ff 98 80 9f b5	 mov	 DWORD PTR __k$548850[ebp+4], -1247838056 ; b59f8098H
  04b94	c7 85 f0 f5 ff
	ff 9f 89 8f b5	 mov	 DWORD PTR __k$548850[ebp+8], -1248884321 ; b58f899fH
  04b9e	c7 85 f4 f5 ff
	ff 8f 80 84 9d	 mov	 DWORD PTR __k$548850[ebp+12], -1652260721 ; 9d84808fH
  04ba8	c7 85 f8 f5 ff
	ff b2 98 92 9a	 mov	 DWORD PTR __k$548850[ebp+16], -1701668686 ; 9a9298b2H
  04bb2	8d 85 e8 f5 ff
	ff		 lea	 eax, DWORD PTR __k$548850[ebp]
  04bb8	66 c7 85 fc f5
	ff ff 88 00	 mov	 WORD PTR __k$548850[ebp+20], 136 ; 00000088H
  04bc1	59		 pop	 ecx
$LL15490@LoadRoomOp:
  04bc2	31 38		 xor	 DWORD PTR [eax], edi
  04bc4	83 c0 04	 add	 eax, 4
  04bc7	49		 dec	 ecx
  04bc8	75 f8		 jne	 SHORT $LL15490@LoadRoomOp
  04bca	80 b5 fc f5 ff
	ff ed		 xor	 BYTE PTR __k$548850[ebp+20], -19 ; ffffffedH
  04bd1	53		 push	 ebx
  04bd2	8d 85 e8 f5 ff
	ff		 lea	 eax, DWORD PTR __k$548850[ebp]
  04bd8	50		 push	 eax
  04bd9	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04bdf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  04be5	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  04beb	89 81 34 02 00
	00		 mov	 DWORD PTR [ecx+564], eax
  04bf1	6a 05		 push	 5

; 575  : 	m_DefaultInfo.m_iBlueBlowType = kLoader.LoadInt_e( "default_blue_blow_type", 0 );

  04bf3	c7 85 28 f4 ff
	ff 89 89 8d 8b	 mov	 DWORD PTR __k$548988[ebp], -1953658487 ; 8b8d8989H
  04bfd	c7 85 2c f4 ff
	ff 98 80 9f b5	 mov	 DWORD PTR __k$548988[ebp+4], -1247838056 ; b59f8098H
  04c07	c7 85 30 f4 ff
	ff 8f 80 9e 8f	 mov	 DWORD PTR __k$548988[ebp+8], -1885437809 ; 8f9e808fH
  04c11	c7 85 34 f4 ff
	ff b2 8e 87 85	 mov	 DWORD PTR __k$548988[ebp+12], -2054713678 ; 85878eb2H
  04c1b	c7 85 38 f4 ff
	ff 9a b3 9f 93	 mov	 DWORD PTR __k$548988[ebp+16], -1818250342 ; 939fb39aH
  04c25	66 c7 85 3c f4
	ff ff 9d 89	 mov	 WORD PTR __k$548988[ebp+20], 35229 ; 0000899dH
  04c2e	8d 85 28 f4 ff
	ff		 lea	 eax, DWORD PTR __k$548988[ebp]
  04c34	88 9d 3e f4 ff
	ff		 mov	 BYTE PTR __k$548988[ebp+22], bl
  04c3a	59		 pop	 ecx
$LL15596@LoadRoomOp:
  04c3b	31 38		 xor	 DWORD PTR [eax], edi
  04c3d	83 c0 04	 add	 eax, 4
  04c40	49		 dec	 ecx
  04c41	75 f8		 jne	 SHORT $LL15596@LoadRoomOp
  04c43	6a 14		 push	 20			; 00000014H
  04c45	58		 pop	 eax
$LL15593@LoadRoomOp:
  04c46	8b c8		 mov	 ecx, eax
  04c48	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  04c4e	79 05		 jns	 SHORT $LN17589@LoadRoomOp
  04c50	49		 dec	 ecx
  04c51	83 c9 fc	 or	 ecx, -4			; fffffffcH
  04c54	41		 inc	 ecx
$LN17589@LoadRoomOp:
  04c55	b2 ed		 mov	 dl, -19			; ffffffedH
  04c57	2a d1		 sub	 dl, cl
  04c59	30 94 05 28 f4
	ff ff		 xor	 BYTE PTR __k$548988[ebp+eax], dl
  04c60	40		 inc	 eax
  04c61	83 f8 16	 cmp	 eax, 22			; 00000016H
  04c64	7c e0		 jl	 SHORT $LL15593@LoadRoomOp
  04c66	53		 push	 ebx
  04c67	8d 85 28 f4 ff
	ff		 lea	 eax, DWORD PTR __k$548988[ebp]
  04c6d	50		 push	 eax
  04c6e	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04c74	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  04c7a	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  04c80	89 81 38 02 00
	00		 mov	 DWORD PTR [ecx+568], eax
  04c86	6a 05		 push	 5

; 576  : 	m_DefaultInfo.m_iRedMoveSpeedType = kLoader.LoadInt_e( "default_red_move_speed", 0 );

  04c88	c7 85 f0 f3 ff
	ff 89 89 8d 8b	 mov	 DWORD PTR __k$549113[ebp], -1953658487 ; 8b8d8989H
  04c92	c7 85 f4 f3 ff
	ff 98 80 9f b5	 mov	 DWORD PTR __k$549113[ebp+4], -1247838056 ; b59f8098H
  04c9c	c7 85 f8 f3 ff
	ff 9f 89 8f b5	 mov	 DWORD PTR __k$549113[ebp+8], -1248884321 ; b58f899fH
  04ca6	c7 85 fc f3 ff
	ff 80 83 9d 8f	 mov	 DWORD PTR __k$549113[ebp+12], -1885502592 ; 8f9d8380H
  04cb0	c7 85 00 f4 ff
	ff b2 9f 9b 8f	 mov	 DWORD PTR __k$549113[ebp+16], -1885626446 ; 8f9b9fb2H
  04cba	66 c7 85 04 f4
	ff ff 88 88	 mov	 WORD PTR __k$549113[ebp+20], 34952 ; 00008888H
  04cc3	8d 85 f0 f3 ff
	ff		 lea	 eax, DWORD PTR __k$549113[ebp]
  04cc9	88 9d 06 f4 ff
	ff		 mov	 BYTE PTR __k$549113[ebp+22], bl
  04ccf	59		 pop	 ecx
$LL15702@LoadRoomOp:
  04cd0	31 38		 xor	 DWORD PTR [eax], edi
  04cd2	83 c0 04	 add	 eax, 4
  04cd5	49		 dec	 ecx
  04cd6	75 f8		 jne	 SHORT $LL15702@LoadRoomOp
  04cd8	6a 14		 push	 20			; 00000014H
  04cda	58		 pop	 eax
$LL15699@LoadRoomOp:
  04cdb	8b c8		 mov	 ecx, eax
  04cdd	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  04ce3	79 05		 jns	 SHORT $LN17590@LoadRoomOp
  04ce5	49		 dec	 ecx
  04ce6	83 c9 fc	 or	 ecx, -4			; fffffffcH
  04ce9	41		 inc	 ecx
$LN17590@LoadRoomOp:
  04cea	b2 ed		 mov	 dl, -19			; ffffffedH
  04cec	2a d1		 sub	 dl, cl
  04cee	30 94 05 f0 f3
	ff ff		 xor	 BYTE PTR __k$549113[ebp+eax], dl
  04cf5	40		 inc	 eax
  04cf6	83 f8 16	 cmp	 eax, 22			; 00000016H
  04cf9	7c e0		 jl	 SHORT $LL15699@LoadRoomOp
  04cfb	53		 push	 ebx
  04cfc	8d 85 f0 f3 ff
	ff		 lea	 eax, DWORD PTR __k$549113[ebp]
  04d02	50		 push	 eax
  04d03	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04d09	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  04d0f	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  04d15	89 81 3c 02 00
	00		 mov	 DWORD PTR [ecx+572], eax
  04d1b	6a 05		 push	 5

; 577  : 	m_DefaultInfo.m_iBlueMoveSpeedType = kLoader.LoadInt_e( "default_blue_move_speed", 0 );

  04d1d	c7 85 2c f3 ff
	ff 89 89 8d 8b	 mov	 DWORD PTR __k$549225[ebp], -1953658487 ; 8b8d8989H
  04d27	c7 85 30 f3 ff
	ff 98 80 9f b5	 mov	 DWORD PTR __k$549225[ebp+4], -1247838056 ; b59f8098H
  04d31	c7 85 34 f3 ff
	ff 8f 80 9e 8f	 mov	 DWORD PTR __k$549225[ebp+8], -1885437809 ; 8f9e808fH
  04d3b	c7 85 38 f3 ff
	ff b2 81 84 9c	 mov	 DWORD PTR __k$549225[ebp+12], -1669037646 ; 9c8481b2H
  04d45	c7 85 3c f3 ff
	ff 88 b3 98 9a	 mov	 DWORD PTR __k$549225[ebp+16], -1701268600 ; 9a98b388H
  04d4f	8d 85 2c f3 ff
	ff		 lea	 eax, DWORD PTR __k$549225[ebp]
  04d55	c7 85 40 f3 ff
	ff 88 89 8f 00	 mov	 DWORD PTR __k$549225[ebp+20], 9406856 ; 008f8988H
  04d5f	59		 pop	 ecx
$LL15808@LoadRoomOp:
  04d60	31 38		 xor	 DWORD PTR [eax], edi
  04d62	83 c0 04	 add	 eax, 4
  04d65	49		 dec	 ecx
  04d66	75 f8		 jne	 SHORT $LL15808@LoadRoomOp
  04d68	6a 14		 push	 20			; 00000014H
  04d6a	58		 pop	 eax
$LL15805@LoadRoomOp:
  04d6b	8b c8		 mov	 ecx, eax
  04d6d	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  04d73	79 05		 jns	 SHORT $LN17591@LoadRoomOp
  04d75	49		 dec	 ecx
  04d76	83 c9 fc	 or	 ecx, -4			; fffffffcH
  04d79	41		 inc	 ecx
$LN17591@LoadRoomOp:
  04d7a	b2 ed		 mov	 dl, -19			; ffffffedH
  04d7c	2a d1		 sub	 dl, cl
  04d7e	30 94 05 2c f3
	ff ff		 xor	 BYTE PTR __k$549225[ebp+eax], dl
  04d85	40		 inc	 eax
  04d86	83 f8 17	 cmp	 eax, 23			; 00000017H
  04d89	7c e0		 jl	 SHORT $LL15805@LoadRoomOp
  04d8b	53		 push	 ebx
  04d8c	8d 85 2c f3 ff
	ff		 lea	 eax, DWORD PTR __k$549225[ebp]
  04d92	50		 push	 eax
  04d93	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04d99	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  04d9f	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  04da5	89 81 40 02 00
	00		 mov	 DWORD PTR [ecx+576], eax
  04dab	6a 04		 push	 4

; 578  : 	m_DefaultInfo.m_iRedEquipType = kLoader.LoadInt_e( "default_red_equip", 0 );

  04dad	c7 85 6c f9 ff
	ff 89 89 8d 8b	 mov	 DWORD PTR __k$549360[ebp], -1953658487 ; 8b8d8989H
  04db7	c7 85 70 f9 ff
	ff 98 80 9f b5	 mov	 DWORD PTR __k$549360[ebp+4], -1247838056 ; b59f8098H
  04dc1	c7 85 74 f9 ff
	ff 9f 89 8f b5	 mov	 DWORD PTR __k$549360[ebp+8], -1248884321 ; b58f899fH
  04dcb	c7 85 78 f9 ff
	ff 88 9d 9e 83	 mov	 DWORD PTR __k$549360[ebp+12], -2086756984 ; 839e9d88H
  04dd5	8d 85 6c f9 ff
	ff		 lea	 eax, DWORD PTR __k$549360[ebp]
  04ddb	66 c7 85 7c f9
	ff ff 9d 00	 mov	 WORD PTR __k$549360[ebp+16], 157 ; 0000009dH
  04de4	59		 pop	 ecx
$LL15914@LoadRoomOp:
  04de5	31 38		 xor	 DWORD PTR [eax], edi
  04de7	83 c0 04	 add	 eax, 4
  04dea	49		 dec	 ecx
  04deb	75 f8		 jne	 SHORT $LL15914@LoadRoomOp
  04ded	80 b5 7c f9 ff
	ff ed		 xor	 BYTE PTR __k$549360[ebp+16], -19 ; ffffffedH
  04df4	53		 push	 ebx
  04df5	8d 85 6c f9 ff
	ff		 lea	 eax, DWORD PTR __k$549360[ebp]
  04dfb	50		 push	 eax
  04dfc	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04e02	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  04e08	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  04e0e	89 81 44 02 00
	00		 mov	 DWORD PTR [ecx+580], eax
  04e14	6a 04		 push	 4

; 579  : 	m_DefaultInfo.m_iBlueEquipType = kLoader.LoadInt_e( "default_blue_equip", 0 );

  04e16	c7 85 bc f7 ff
	ff 89 89 8d 8b	 mov	 DWORD PTR __k$549475[ebp], -1953658487 ; 8b8d8989H
  04e20	c7 85 c0 f7 ff
	ff 98 80 9f b5	 mov	 DWORD PTR __k$549475[ebp+4], -1247838056 ; b59f8098H
  04e2a	c7 85 c4 f7 ff
	ff 8f 80 9e 8f	 mov	 DWORD PTR __k$549475[ebp+8], -1885437809 ; 8f9e808fH
  04e34	c7 85 c8 f7 ff
	ff b2 89 9a 9f	 mov	 DWORD PTR __k$549475[ebp+12], -1617262158 ; 9f9a89b2H
  04e3e	66 c7 85 cc f7
	ff ff 84 9c	 mov	 WORD PTR __k$549475[ebp+16], 40068 ; 00009c84H
  04e47	8d 85 bc f7 ff
	ff		 lea	 eax, DWORD PTR __k$549475[ebp]
  04e4d	88 9d ce f7 ff
	ff		 mov	 BYTE PTR __k$549475[ebp+18], bl
  04e53	59		 pop	 ecx
$LL16020@LoadRoomOp:
  04e54	31 38		 xor	 DWORD PTR [eax], edi
  04e56	83 c0 04	 add	 eax, 4
  04e59	49		 dec	 ecx
  04e5a	75 f8		 jne	 SHORT $LL16020@LoadRoomOp
  04e5c	6a 10		 push	 16			; 00000010H
  04e5e	58		 pop	 eax
$LL16017@LoadRoomOp:
  04e5f	8b c8		 mov	 ecx, eax
  04e61	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  04e67	79 05		 jns	 SHORT $LN17592@LoadRoomOp
  04e69	49		 dec	 ecx
  04e6a	83 c9 fc	 or	 ecx, -4			; fffffffcH
  04e6d	41		 inc	 ecx
$LN17592@LoadRoomOp:
  04e6e	b2 ed		 mov	 dl, -19			; ffffffedH
  04e70	2a d1		 sub	 dl, cl
  04e72	30 94 05 bc f7
	ff ff		 xor	 BYTE PTR __k$549475[ebp+eax], dl
  04e79	40		 inc	 eax
  04e7a	83 f8 12	 cmp	 eax, 18			; 00000012H
  04e7d	7c e0		 jl	 SHORT $LL16017@LoadRoomOp
  04e7f	53		 push	 ebx
  04e80	8d 85 bc f7 ff
	ff		 lea	 eax, DWORD PTR __k$549475[ebp]
  04e86	50		 push	 eax
  04e87	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04e8d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  04e93	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  04e99	89 81 48 02 00
	00		 mov	 DWORD PTR [ecx+584], eax
  04e9f	6a 04		 push	 4

; 580  : 
; 581  : 	m_DefaultInfo.m_iCatchModeRoundType = kLoader.LoadInt_e( "default_round_type", 0 );

  04ea1	c7 85 8c f7 ff
	ff 89 89 8d 8b	 mov	 DWORD PTR __k$549600[ebp], -1953658487 ; 8b8d8989H
  04eab	c7 85 90 f7 ff
	ff 98 80 9f b5	 mov	 DWORD PTR __k$549600[ebp+4], -1247838056 ; b59f8098H
  04eb5	c7 85 94 f7 ff
	ff 9f 83 9e 84	 mov	 DWORD PTR __k$549600[ebp+8], -2069986401 ; 849e839fH
  04ebf	c7 85 98 f7 ff
	ff 89 b3 9f 93	 mov	 DWORD PTR __k$549600[ebp+12], -1818250359 ; 939fb389H
  04ec9	66 c7 85 9c f7
	ff ff 9d 89	 mov	 WORD PTR __k$549600[ebp+16], 35229 ; 0000899dH
  04ed2	8d 85 8c f7 ff
	ff		 lea	 eax, DWORD PTR __k$549600[ebp]
  04ed8	88 9d 9e f7 ff
	ff		 mov	 BYTE PTR __k$549600[ebp+18], bl
  04ede	59		 pop	 ecx
$LL16126@LoadRoomOp:
  04edf	31 38		 xor	 DWORD PTR [eax], edi
  04ee1	83 c0 04	 add	 eax, 4
  04ee4	49		 dec	 ecx
  04ee5	75 f8		 jne	 SHORT $LL16126@LoadRoomOp
  04ee7	6a 10		 push	 16			; 00000010H
  04ee9	58		 pop	 eax
$LL16123@LoadRoomOp:
  04eea	8b c8		 mov	 ecx, eax
  04eec	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  04ef2	79 05		 jns	 SHORT $LN17593@LoadRoomOp
  04ef4	49		 dec	 ecx
  04ef5	83 c9 fc	 or	 ecx, -4			; fffffffcH
  04ef8	41		 inc	 ecx
$LN17593@LoadRoomOp:
  04ef9	b2 ed		 mov	 dl, -19			; ffffffedH
  04efb	2a d1		 sub	 dl, cl
  04efd	30 94 05 8c f7
	ff ff		 xor	 BYTE PTR __k$549600[ebp+eax], dl
  04f04	40		 inc	 eax
  04f05	83 f8 12	 cmp	 eax, 18			; 00000012H
  04f08	7c e0		 jl	 SHORT $LL16123@LoadRoomOp
  04f0a	53		 push	 ebx
  04f0b	8d 85 8c f7 ff
	ff		 lea	 eax, DWORD PTR __k$549600[ebp]
  04f11	50		 push	 eax
  04f12	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04f18	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  04f1e	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  04f24	89 81 4c 02 00
	00		 mov	 DWORD PTR [ecx+588], eax
  04f2a	6a 05		 push	 5

; 582  : 	m_DefaultInfo.m_iCatchModeRoundTimeType = kLoader.LoadInt_e( "default_round_time_type", 0 );

  04f2c	c7 85 f4 f2 ff
	ff 89 89 8d 8b	 mov	 DWORD PTR __k$549725[ebp], -1953658487 ; 8b8d8989H
  04f36	c7 85 f8 f2 ff
	ff 98 80 9f b5	 mov	 DWORD PTR __k$549725[ebp+4], -1247838056 ; b59f8098H
  04f40	c7 85 fc f2 ff
	ff 9f 83 9e 84	 mov	 DWORD PTR __k$549725[ebp+8], -2069986401 ; 849e839fH
  04f4a	c7 85 00 f3 ff
	ff 89 b3 9f 83	 mov	 DWORD PTR __k$549725[ebp+12], -2086685815 ; 839fb389H
  04f54	c7 85 04 f3 ff
	ff 80 89 b4 9e	 mov	 DWORD PTR __k$549725[ebp+16], -1632335488 ; 9eb48980H
  04f5e	8d 85 f4 f2 ff
	ff		 lea	 eax, DWORD PTR __k$549725[ebp]
  04f64	c7 85 08 f3 ff
	ff 94 9c 8e 00	 mov	 DWORD PTR __k$549725[ebp+20], 9346196 ; 008e9c94H
  04f6e	59		 pop	 ecx
$LL16232@LoadRoomOp:
  04f6f	31 38		 xor	 DWORD PTR [eax], edi
  04f71	83 c0 04	 add	 eax, 4
  04f74	49		 dec	 ecx
  04f75	75 f8		 jne	 SHORT $LL16232@LoadRoomOp
  04f77	6a 14		 push	 20			; 00000014H
  04f79	58		 pop	 eax
$LL16229@LoadRoomOp:
  04f7a	8b c8		 mov	 ecx, eax
  04f7c	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  04f82	79 05		 jns	 SHORT $LN17594@LoadRoomOp
  04f84	49		 dec	 ecx
  04f85	83 c9 fc	 or	 ecx, -4			; fffffffcH
  04f88	41		 inc	 ecx
$LN17594@LoadRoomOp:
  04f89	b2 ed		 mov	 dl, -19			; ffffffedH
  04f8b	2a d1		 sub	 dl, cl
  04f8d	30 94 05 f4 f2
	ff ff		 xor	 BYTE PTR __k$549725[ebp+eax], dl
  04f94	40		 inc	 eax
  04f95	83 f8 17	 cmp	 eax, 23			; 00000017H
  04f98	7c e0		 jl	 SHORT $LL16229@LoadRoomOp
  04f9a	53		 push	 ebx
  04f9b	8d 85 f4 f2 ff
	ff		 lea	 eax, DWORD PTR __k$549725[ebp]
  04fa1	50		 push	 eax
  04fa2	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04fa8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  04fae	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  04fb4	89 81 50 02 00
	00		 mov	 DWORD PTR [ecx+592], eax
  04fba	6a 04		 push	 4

; 583  : 
; 584  : 	m_DefaultInfo.m_iGrowthUseType = kLoader.LoadInt_e( "default_growth_use", 0 );

  04fbc	c7 85 5c f7 ff
	ff 89 89 8d 8b	 mov	 DWORD PTR __k$549850[ebp], -1953658487 ; 8b8d8989H
  04fc6	c7 85 60 f7 ff
	ff 98 80 9f b5	 mov	 DWORD PTR __k$549850[ebp+4], -1247838056 ; b59f8098H
  04fd0	c7 85 64 f7 ff
	ff 8a 9e 84 9d	 mov	 DWORD PTR __k$549850[ebp+8], -1652253046 ; 9d849e8aH
  04fda	c7 85 68 f7 ff
	ff 99 84 b4 9f	 mov	 DWORD PTR __k$549850[ebp+12], -1615559527 ; 9fb48499H
  04fe4	66 c7 85 6c f7
	ff ff 9e 89	 mov	 WORD PTR __k$549850[ebp+16], 35230 ; 0000899eH
  04fed	8d 85 5c f7 ff
	ff		 lea	 eax, DWORD PTR __k$549850[ebp]
  04ff3	88 9d 6e f7 ff
	ff		 mov	 BYTE PTR __k$549850[ebp+18], bl
  04ff9	59		 pop	 ecx
$LL16338@LoadRoomOp:
  04ffa	31 38		 xor	 DWORD PTR [eax], edi
  04ffc	83 c0 04	 add	 eax, 4
  04fff	49		 dec	 ecx
  05000	75 f8		 jne	 SHORT $LL16338@LoadRoomOp
  05002	6a 10		 push	 16			; 00000010H
  05004	58		 pop	 eax
$LL16335@LoadRoomOp:
  05005	8b c8		 mov	 ecx, eax
  05007	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0500d	79 05		 jns	 SHORT $LN17595@LoadRoomOp
  0500f	49		 dec	 ecx
  05010	83 c9 fc	 or	 ecx, -4			; fffffffcH
  05013	41		 inc	 ecx
$LN17595@LoadRoomOp:
  05014	b2 ed		 mov	 dl, -19			; ffffffedH
  05016	2a d1		 sub	 dl, cl
  05018	30 94 05 5c f7
	ff ff		 xor	 BYTE PTR __k$549850[ebp+eax], dl
  0501f	40		 inc	 eax
  05020	83 f8 12	 cmp	 eax, 18			; 00000012H
  05023	7c e0		 jl	 SHORT $LL16335@LoadRoomOp
  05025	53		 push	 ebx
  05026	8d 85 5c f7 ff
	ff		 lea	 eax, DWORD PTR __k$549850[ebp]
  0502c	50		 push	 eax
  0502d	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  05033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  05039	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0503f	89 81 54 02 00
	00		 mov	 DWORD PTR [ecx+596], eax
  05045	6a 05		 push	 5

; 585  : 	m_DefaultInfo.m_iExtraItemUseType = kLoader.LoadInt_e( "default_extraitem_use", 0 );

  05047	c7 85 b0 f5 ff
	ff 89 89 8d 8b	 mov	 DWORD PTR __k$549988[ebp], -1953658487 ; 8b8d8989H
  05051	c7 85 b4 f5 ff
	ff 98 80 9f b5	 mov	 DWORD PTR __k$549988[ebp+4], -1247838056 ; b59f8098H
  0505b	c7 85 b8 f5 ff
	ff 88 94 9f 98	 mov	 DWORD PTR __k$549988[ebp+8], -1734372216 ; 989f9488H
  05065	c7 85 bc f5 ff
	ff 8c 85 9f 8f	 mov	 DWORD PTR __k$549988[ebp+12], -1885370996 ; 8f9f858cH
  0506f	c7 85 c0 f5 ff
	ff 80 b3 9e 99	 mov	 DWORD PTR __k$549988[ebp+16], -1717652608 ; 999eb380H
  05079	8d 85 b0 f5 ff
	ff		 lea	 eax, DWORD PTR __k$549988[ebp]
  0507f	66 c7 85 c4 f5
	ff ff 88 00	 mov	 WORD PTR __k$549988[ebp+20], 136 ; 00000088H
  05088	59		 pop	 ecx
$LL16444@LoadRoomOp:
  05089	31 38		 xor	 DWORD PTR [eax], edi
  0508b	83 c0 04	 add	 eax, 4
  0508e	49		 dec	 ecx
  0508f	75 f8		 jne	 SHORT $LL16444@LoadRoomOp
  05091	80 b5 c4 f5 ff
	ff ed		 xor	 BYTE PTR __k$549988[ebp+20], -19 ; ffffffedH
  05098	53		 push	 ebx
  05099	8d 85 b0 f5 ff
	ff		 lea	 eax, DWORD PTR __k$549988[ebp]
  0509f	50		 push	 eax
  050a0	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  050a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  050ac	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  050b2	89 81 58 02 00
	00		 mov	 DWORD PTR [ecx+600], eax

; 586  : 	//
; 587  : 
; 588  : 
; 589  : 	// PreSet
; 590  : 	kLoader.SetTitle_e( "PreSet" );

  050b8	6a 04		 push	 4
  050ba	c7 45 cc bd 9e
	8e b9		 mov	 DWORD PTR __t$550100[ebp], -1181835587 ; b98e9ebdH
  050c1	31 7d cc	 xor	 DWORD PTR __t$550100[ebp], edi
  050c4	66 c7 45 d0 88
	98		 mov	 WORD PTR __t$550100[ebp+4], 39048 ; 00009888H
  050ca	88 5d d2	 mov	 BYTE PTR __t$550100[ebp+6], bl
  050cd	58		 pop	 eax
$LL16547@LoadRoomOp:
  050ce	8b c8		 mov	 ecx, eax
  050d0	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  050d6	79 05		 jns	 SHORT $LN17596@LoadRoomOp
  050d8	49		 dec	 ecx
  050d9	83 c9 fc	 or	 ecx, -4			; fffffffcH
  050dc	41		 inc	 ecx
$LN17596@LoadRoomOp:
  050dd	b2 ed		 mov	 dl, -19			; ffffffedH
  050df	2a d1		 sub	 dl, cl
  050e1	30 54 05 cc	 xor	 BYTE PTR __t$550100[ebp+eax], dl
  050e5	40		 inc	 eax
  050e6	83 f8 06	 cmp	 eax, 6
  050e9	7c e3		 jl	 SHORT $LL16547@LoadRoomOp
  050eb	8d 45 cc	 lea	 eax, DWORD PTR __t$550100[ebp]
  050ee	50		 push	 eax
  050ef	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  050f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z
  050fb	6a 02		 push	 2

; 591  : 	iTypeCnt = kLoader.LoadInt_e( "preset_cnt", 0 );

  050fd	c7 85 14 ff ff
	ff 9d 9e 8e 99	 mov	 DWORD PTR __k$550238[ebp], -1718706531 ; 998e9e9dH
  05107	c7 85 18 ff ff
	ff 88 98 b4 89	 mov	 DWORD PTR __k$550238[ebp+4], -1984653176 ; 89b49888H
  05111	66 c7 85 1c ff
	ff ff 83 98	 mov	 WORD PTR __k$550238[ebp+8], 39043 ; 00009883H
  0511a	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR __k$550238[ebp]
  05120	88 9d 1e ff ff
	ff		 mov	 BYTE PTR __k$550238[ebp+10], bl
  05126	59		 pop	 ecx
$LL16656@LoadRoomOp:
  05127	31 38		 xor	 DWORD PTR [eax], edi
  05129	83 c0 04	 add	 eax, 4
  0512c	49		 dec	 ecx
  0512d	75 f8		 jne	 SHORT $LL16656@LoadRoomOp
  0512f	6a 08		 push	 8
  05131	5f		 pop	 edi
$LL16653@LoadRoomOp:
  05132	8b c7		 mov	 eax, edi
  05134	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  05139	79 05		 jns	 SHORT $LN17597@LoadRoomOp
  0513b	48		 dec	 eax
  0513c	83 c8 fc	 or	 eax, -4			; fffffffcH
  0513f	40		 inc	 eax
$LN17597@LoadRoomOp:
  05140	b1 ed		 mov	 cl, -19			; ffffffedH
  05142	2a c8		 sub	 cl, al
  05144	30 8c 3d 14 ff
	ff ff		 xor	 BYTE PTR __k$550238[ebp+edi], cl
  0514b	47		 inc	 edi
  0514c	83 ff 0a	 cmp	 edi, 10			; 0000000aH
  0514f	7c e1		 jl	 SHORT $LL16653@LoadRoomOp
  05151	53		 push	 ebx
  05152	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR __k$550238[ebp]
  05158	50		 push	 eax
  05159	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0515f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  05165	89 85 d0 ec ff
	ff		 mov	 DWORD PTR _iTypeCnt$[ebp], eax

; 592  : 	for( i=0; i < iTypeCnt; ++i )

  0516b	89 9d d8 ec ff
	ff		 mov	 DWORD PTR _i$[ebp], ebx
  05171	3b c3		 cmp	 eax, ebx
  05173	0f 8e a8 0c 00
	00		 jle	 $LN2082@LoadRoomOp
$LL2084@LoadRoomOp:

; 593  : 	{
; 594  : 		PreSetInfo *pInfo = new PreSetInfo;

  05179	68 b8 00 00 00	 push	 184			; 000000b8H
  0517e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  05183	59		 pop	 ecx
  05184	89 85 c4 ec ff
	ff		 mov	 DWORD PTR $T540358[ebp], eax
  0518a	c6 45 fc 15	 mov	 BYTE PTR __$EHRec$[ebp+8], 21 ; 00000015H
  0518e	3b c3		 cmp	 eax, ebx
  05190	74 0b		 je	 SHORT $LN8453@LoadRoomOp
  05192	8b c8		 mov	 ecx, eax
  05194	e8 00 00 00 00	 call	 ??0PreSetInfo@@QAE@XZ	; PreSetInfo::PreSetInfo
  05199	8b f8		 mov	 edi, eax
  0519b	eb 02		 jmp	 SHORT $LN8454@LoadRoomOp
$LN8453@LoadRoomOp:
  0519d	33 ff		 xor	 edi, edi
$LN8454@LoadRoomOp:
  0519f	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  051a2	89 bd c8 ec ff
	ff		 mov	 DWORD PTR _pInfo$520744[ebp], edi

; 595  : 		if( !pInfo )

  051a8	3b fb		 cmp	 edi, ebx
  051aa	0f 84 59 0c 00
	00		 je	 $LN2083@LoadRoomOp

; 596  : 			continue;
; 597  : 
; 598  : 		wsprintf_e( szKey, "preset%d_desc", i+1 );

  051b0	6a 03		 push	 3
  051b2	c7 85 74 fc ff
	ff 9d 9e 8e 99	 mov	 DWORD PTR ___encStr$520753[ebp], -1718706531 ; 998e9e9dH
  051bc	c7 85 78 fc ff
	ff 88 98 ce 8e	 mov	 DWORD PTR ___encStr$520753[ebp+4], -1899063160 ; 8ece9888H
  051c6	c7 85 7c fc ff
	ff b2 88 8e 99	 mov	 DWORD PTR ___encStr$520753[ebp+8], -1718712142 ; 998e88b2H
  051d0	8d 85 74 fc ff
	ff		 lea	 eax, DWORD PTR ___encStr$520753[ebp]
  051d6	66 c7 85 80 fc
	ff ff 8e 00	 mov	 WORD PTR ___encStr$520753[ebp+12], 142 ; 0000008eH
  051df	59		 pop	 ecx
$LL16664@LoadRoomOp:
  051e0	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  051e6	83 c0 04	 add	 eax, 4
  051e9	49		 dec	 ecx
  051ea	75 f4		 jne	 SHORT $LL16664@LoadRoomOp
  051ec	80 b5 80 fc ff
	ff ed		 xor	 BYTE PTR ___encStr$520753[ebp+12], -19 ; ffffffedH
  051f3	8b 85 d8 ec ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  051f9	40		 inc	 eax
  051fa	50		 push	 eax
  051fb	8d 85 74 fc ff
	ff		 lea	 eax, DWORD PTR ___encStr$520753[ebp]
  05201	50		 push	 eax
  05202	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  05208	50		 push	 eax
  05209	ff d6		 call	 esi
  0520b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 599  : 		kLoader.LoadString( szKey, "", szBuf, MAX_PATH );

  0520e	68 04 01 00 00	 push	 260			; 00000104H
  05213	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  05219	50		 push	 eax
  0521a	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0521f	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  05225	50		 push	 eax
  05226	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0522c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 600  : 		pInfo->m_Desc = szBuf;

  05232	8d 85 6c f0 ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  05238	50		 push	 eax
  05239	8b cf		 mov	 ecx, edi
  0523b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z
  05241	6a 05		 push	 5

; 601  : 
; 602  : 		wsprintf_e( szKey, "preset%d_charnge_char", i+1 );

  05243	c7 85 20 f6 ff
	ff 9d 9e 8e 99	 mov	 DWORD PTR ___encStr$520905[ebp], -1718706531 ; 998e9e9dH
  0524d	c7 85 24 f6 ff
	ff 88 98 ce 8e	 mov	 DWORD PTR ___encStr$520905[ebp+4], -1899063160 ; 8ece9888H
  05257	c7 85 28 f6 ff
	ff b2 8f 83 8b	 mov	 DWORD PTR ___encStr$520905[ebp+8], -1954312270 ; 8b838fb2H
  05261	c7 85 2c f6 ff
	ff 9f 82 8c 8f	 mov	 DWORD PTR ___encStr$520905[ebp+12], -1886616929 ; 8f8c829fH
  0526b	c7 85 30 f6 ff
	ff b2 8f 83 8b	 mov	 DWORD PTR ___encStr$520905[ebp+16], -1954312270 ; 8b838fb2H
  05275	8d 85 20 f6 ff
	ff		 lea	 eax, DWORD PTR ___encStr$520905[ebp]
  0527b	66 c7 85 34 f6
	ff ff 9f 00	 mov	 WORD PTR ___encStr$520905[ebp+20], 159 ; 0000009fH
  05284	59		 pop	 ecx
$LL16672@LoadRoomOp:
  05285	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0528b	83 c0 04	 add	 eax, 4
  0528e	49		 dec	 ecx
  0528f	75 f4		 jne	 SHORT $LL16672@LoadRoomOp
  05291	80 b5 34 f6 ff
	ff ed		 xor	 BYTE PTR ___encStr$520905[ebp+20], -19 ; ffffffedH
  05298	8b 85 d8 ec ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0529e	40		 inc	 eax
  0529f	50		 push	 eax
  052a0	8d 85 20 f6 ff
	ff		 lea	 eax, DWORD PTR ___encStr$520905[ebp]
  052a6	50		 push	 eax
  052a7	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  052ad	50		 push	 eax
  052ae	ff d6		 call	 esi
  052b0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 603  : 		pInfo->m_iChangeCharType = kLoader.LoadInt( szKey, 0 );

  052b3	53		 push	 ebx
  052b4	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  052ba	50		 push	 eax
  052bb	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  052c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  052c7	89 47 14	 mov	 DWORD PTR [edi+20], eax
  052ca	6a 05		 push	 5

; 604  : 
; 605  : 		wsprintf_e( szKey, "preset%d_team_attack", i+1 );

  052cc	c7 85 7c f4 ff
	ff 9d 9e 8e 99	 mov	 DWORD PTR ___encStr$521057[ebp], -1718706531 ; 998e9e9dH
  052d6	c7 85 80 f4 ff
	ff 88 98 ce 8e	 mov	 DWORD PTR ___encStr$521057[ebp+4], -1899063160 ; 8ece9888H
  052e0	c7 85 84 f4 ff
	ff b2 98 8e 8b	 mov	 DWORD PTR ___encStr$521057[ebp+8], -1953589070 ; 8b8e98b2H
  052ea	c7 85 88 f4 ff
	ff 80 b3 8a 9e	 mov	 DWORD PTR ___encStr$521057[ebp+12], -1635077248 ; 9e8ab380H
  052f4	c7 85 8c f4 ff
	ff 99 8d 88 81	 mov	 DWORD PTR ___encStr$521057[ebp+16], -2121757287 ; 81888d99H
  052fe	8d 85 7c f4 ff
	ff		 lea	 eax, DWORD PTR ___encStr$521057[ebp]
  05304	88 9d 90 f4 ff
	ff		 mov	 BYTE PTR ___encStr$521057[ebp+20], bl
  0530a	59		 pop	 ecx
$LL16680@LoadRoomOp:
  0530b	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  05311	83 c0 04	 add	 eax, 4
  05314	49		 dec	 ecx
  05315	75 f4		 jne	 SHORT $LL16680@LoadRoomOp
  05317	8b 85 d8 ec ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0531d	40		 inc	 eax
  0531e	50		 push	 eax
  0531f	8d 85 7c f4 ff
	ff		 lea	 eax, DWORD PTR ___encStr$521057[ebp]
  05325	50		 push	 eax
  05326	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  0532c	50		 push	 eax
  0532d	ff d6		 call	 esi
  0532f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 606  : 		pInfo->m_iTeamAttackType = kLoader.LoadInt( szKey, 0 );

  05332	53		 push	 ebx
  05333	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  05339	50		 push	 eax
  0533a	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  05340	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  05346	89 47 10	 mov	 DWORD PTR [edi+16], eax
  05349	6a 04		 push	 4

; 607  : 
; 608  : 		wsprintf_e( szKey, "preset%d_cooltime", i+1 );

  0534b	c7 85 74 fa ff
	ff 9d 9e 8e 99	 mov	 DWORD PTR ___encStr$521209[ebp], -1718706531 ; 998e9e9dH
  05355	c7 85 78 fa ff
	ff 88 98 ce 8e	 mov	 DWORD PTR ___encStr$521209[ebp+4], -1899063160 ; 8ece9888H
  0535f	c7 85 7c fa ff
	ff b2 8f 84 85	 mov	 DWORD PTR ___encStr$521209[ebp+8], -2054910030 ; 85848fb2H
  05369	c7 85 80 fa ff
	ff 81 98 82 87	 mov	 DWORD PTR ___encStr$521209[ebp+12], -2021484415 ; 87829881H
  05373	8d 85 74 fa ff
	ff		 lea	 eax, DWORD PTR ___encStr$521209[ebp]
  05379	66 c7 85 84 fa
	ff ff 88 00	 mov	 WORD PTR ___encStr$521209[ebp+16], 136 ; 00000088H
  05382	59		 pop	 ecx
$LL16688@LoadRoomOp:
  05383	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  05389	83 c0 04	 add	 eax, 4
  0538c	49		 dec	 ecx
  0538d	75 f4		 jne	 SHORT $LL16688@LoadRoomOp
  0538f	80 b5 84 fa ff
	ff ed		 xor	 BYTE PTR ___encStr$521209[ebp+16], -19 ; ffffffedH
  05396	8b 85 d8 ec ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0539c	40		 inc	 eax
  0539d	50		 push	 eax
  0539e	8d 85 74 fa ff
	ff		 lea	 eax, DWORD PTR ___encStr$521209[ebp]
  053a4	50		 push	 eax
  053a5	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  053ab	50		 push	 eax
  053ac	ff d6		 call	 esi
  053ae	83 c4 0c	 add	 esp, 12			; 0000000cH

; 609  : 		pInfo->m_iCoolTimeType = kLoader.LoadInt( szKey, 0 );

  053b1	53		 push	 ebx
  053b2	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  053b8	50		 push	 eax
  053b9	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  053bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  053c5	89 47 18	 mov	 DWORD PTR [edi+24], eax
  053c8	6a 03		 push	 3

; 610  : 
; 611  : 		wsprintf_e( szKey, "preset%d_red_hp", i+1 );

  053ca	c7 85 bc fa ff
	ff 9d 9e 8e 99	 mov	 DWORD PTR ___encStr$521361[ebp], -1718706531 ; 998e9e9dH
  053d4	c7 85 c0 fa ff
	ff 88 98 ce 8e	 mov	 DWORD PTR ___encStr$521361[ebp+4], -1899063160 ; 8ece9888H
  053de	c7 85 c4 fa ff
	ff b2 9e 8e 8e	 mov	 DWORD PTR ___encStr$521361[ebp+8], -1903255886 ; 8e8e9eb2H
  053e8	8d 85 bc fa ff
	ff		 lea	 eax, DWORD PTR ___encStr$521361[ebp]
  053ee	c7 85 c8 fa ff
	ff b2 84 9b 00	 mov	 DWORD PTR ___encStr$521361[ebp+12], 10192050 ; 009b84b2H
  053f8	59		 pop	 ecx
$LL16696@LoadRoomOp:
  053f9	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  053ff	83 c0 04	 add	 eax, 4
  05402	49		 dec	 ecx
  05403	75 f4		 jne	 SHORT $LL16696@LoadRoomOp
  05405	6a 0c		 push	 12			; 0000000cH
  05407	58		 pop	 eax
$LL16693@LoadRoomOp:
  05408	8b c8		 mov	 ecx, eax
  0540a	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  05410	79 05		 jns	 SHORT $LN17598@LoadRoomOp
  05412	49		 dec	 ecx
  05413	83 c9 fc	 or	 ecx, -4			; fffffffcH
  05416	41		 inc	 ecx
$LN17598@LoadRoomOp:
  05417	b2 ed		 mov	 dl, -19			; ffffffedH
  05419	2a d1		 sub	 dl, cl
  0541b	30 94 05 bc fa
	ff ff		 xor	 BYTE PTR ___encStr$521361[ebp+eax], dl
  05422	40		 inc	 eax
  05423	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  05426	7c e0		 jl	 SHORT $LL16693@LoadRoomOp
  05428	8b 85 d8 ec ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0542e	40		 inc	 eax
  0542f	50		 push	 eax
  05430	8d 85 bc fa ff
	ff		 lea	 eax, DWORD PTR ___encStr$521361[ebp]
  05436	50		 push	 eax
  05437	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  0543d	50		 push	 eax
  0543e	ff d6		 call	 esi
  05440	83 c4 0c	 add	 esp, 12			; 0000000cH

; 612  : 		pInfo->m_iRedHPType = kLoader.LoadInt( szKey, 0 );

  05443	53		 push	 ebx
  05444	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  0544a	50		 push	 eax
  0544b	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  05451	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  05457	50		 push	 eax
  05458	8d 4f 1c	 lea	 ecx, DWORD PTR [edi+28]
  0545b	e8 00 00 00 00	 call	 ??4?$CEncrypt@H@@QAEHH@Z ; CEncrypt<int>::operator=
  05460	6a 04		 push	 4

; 613  : 
; 614  : 		wsprintf_e( szKey, "preset%d_blue_hp", i+1 );

  05462	c7 85 c4 f8 ff
	ff 9d 9e 8e 99	 mov	 DWORD PTR ___encStr$521513[ebp], -1718706531 ; 998e9e9dH
  0546c	c7 85 c8 f8 ff
	ff 88 98 ce 8e	 mov	 DWORD PTR ___encStr$521513[ebp+4], -1899063160 ; 8ece9888H
  05476	c7 85 cc f8 ff
	ff b2 8e 87 9f	 mov	 DWORD PTR ___encStr$521513[ebp+8], -1618506062 ; 9f878eb2H
  05480	c7 85 d0 f8 ff
	ff 88 b3 83 9a	 mov	 DWORD PTR ___encStr$521513[ebp+12], -1702644856 ; 9a83b388H
  0548a	8d 85 c4 f8 ff
	ff		 lea	 eax, DWORD PTR ___encStr$521513[ebp]
  05490	88 9d d4 f8 ff
	ff		 mov	 BYTE PTR ___encStr$521513[ebp+16], bl
  05496	59		 pop	 ecx
$LL16704@LoadRoomOp:
  05497	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0549d	83 c0 04	 add	 eax, 4
  054a0	49		 dec	 ecx
  054a1	75 f4		 jne	 SHORT $LL16704@LoadRoomOp
  054a3	8b 85 d8 ec ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  054a9	40		 inc	 eax
  054aa	50		 push	 eax
  054ab	8d 85 c4 f8 ff
	ff		 lea	 eax, DWORD PTR ___encStr$521513[ebp]
  054b1	50		 push	 eax
  054b2	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  054b8	50		 push	 eax
  054b9	ff d6		 call	 esi
  054bb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 615  : 		pInfo->m_iBlueHPType = kLoader.LoadInt( szKey, 0 );

  054be	53		 push	 ebx
  054bf	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  054c5	50		 push	 eax
  054c6	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  054cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  054d2	50		 push	 eax
  054d3	8d 4f 4c	 lea	 ecx, DWORD PTR [edi+76]
  054d6	e8 00 00 00 00	 call	 ??4?$CEncrypt@H@@QAEHH@Z ; CEncrypt<int>::operator=
  054db	6a 04		 push	 4

; 616  : 
; 617  : 		wsprintf_e( szKey, "preset%d_dropdamage", i+1 );

  054dd	c7 85 e4 f6 ff
	ff 9d 9e 8e 99	 mov	 DWORD PTR ___encStr$521665[ebp], -1718706531 ; 998e9e9dH
  054e7	c7 85 e8 f6 ff
	ff 88 98 ce 8e	 mov	 DWORD PTR ___encStr$521665[ebp+4], -1899063160 ; 8ece9888H
  054f1	c7 85 ec f6 ff
	ff b2 88 99 85	 mov	 DWORD PTR ___encStr$521665[ebp+8], -2053535566 ; 859988b2H
  054fb	c7 85 f0 f6 ff
	ff 9d 88 8a 87	 mov	 DWORD PTR ___encStr$521665[ebp+12], -2020964195 ; 878a889dH
  05505	8d 85 e4 f6 ff
	ff		 lea	 eax, DWORD PTR ___encStr$521665[ebp]
  0550b	c7 85 f4 f6 ff
	ff 8c 8b 8e 00	 mov	 DWORD PTR ___encStr$521665[ebp+16], 9341836 ; 008e8b8cH
  05515	59		 pop	 ecx
$LL16712@LoadRoomOp:
  05516	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0551c	83 c0 04	 add	 eax, 4
  0551f	49		 dec	 ecx
  05520	75 f4		 jne	 SHORT $LL16712@LoadRoomOp
  05522	6a 10		 push	 16			; 00000010H
  05524	58		 pop	 eax
$LL16709@LoadRoomOp:
  05525	8b c8		 mov	 ecx, eax
  05527	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0552d	79 05		 jns	 SHORT $LN17599@LoadRoomOp
  0552f	49		 dec	 ecx
  05530	83 c9 fc	 or	 ecx, -4			; fffffffcH
  05533	41		 inc	 ecx
$LN17599@LoadRoomOp:
  05534	b2 ed		 mov	 dl, -19			; ffffffedH
  05536	2a d1		 sub	 dl, cl
  05538	30 94 05 e4 f6
	ff ff		 xor	 BYTE PTR ___encStr$521665[ebp+eax], dl
  0553f	40		 inc	 eax
  05540	83 f8 13	 cmp	 eax, 19			; 00000013H
  05543	7c e0		 jl	 SHORT $LL16709@LoadRoomOp
  05545	8b 85 d8 ec ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0554b	40		 inc	 eax
  0554c	50		 push	 eax
  0554d	8d 85 e4 f6 ff
	ff		 lea	 eax, DWORD PTR ___encStr$521665[ebp]
  05553	50		 push	 eax
  05554	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  0555a	50		 push	 eax
  0555b	ff d6		 call	 esi
  0555d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 618  : 		pInfo->m_iDropDamageType = kLoader.LoadInt( szKey, 0 );

  05560	53		 push	 ebx
  05561	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  05567	50		 push	 eax
  05568	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0556e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  05574	89 47 7c	 mov	 DWORD PTR [edi+124], eax
  05577	6a 04		 push	 4

; 619  : 
; 620  : 		wsprintf_e( szKey, "preset%d_gravity", i+1 );

  05579	c7 85 94 f8 ff
	ff 9d 9e 8e 99	 mov	 DWORD PTR ___encStr$521817[ebp], -1718706531 ; 998e9e9dH
  05583	c7 85 98 f8 ff
	ff 88 98 ce 8e	 mov	 DWORD PTR ___encStr$521817[ebp+4], -1899063160 ; 8ece9888H
  0558d	c7 85 9c f8 ff
	ff b2 8b 99 8b	 mov	 DWORD PTR ___encStr$521817[ebp+8], -1952871502 ; 8b998bb2H
  05597	c7 85 a0 f8 ff
	ff 9b 85 9f 93	 mov	 DWORD PTR ___encStr$521817[ebp+12], -1818262117 ; 939f859bH
  055a1	8d 85 94 f8 ff
	ff		 lea	 eax, DWORD PTR ___encStr$521817[ebp]
  055a7	88 9d a4 f8 ff
	ff		 mov	 BYTE PTR ___encStr$521817[ebp+16], bl
  055ad	59		 pop	 ecx
$LL16720@LoadRoomOp:
  055ae	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  055b4	83 c0 04	 add	 eax, 4
  055b7	49		 dec	 ecx
  055b8	75 f4		 jne	 SHORT $LL16720@LoadRoomOp
  055ba	8b 85 d8 ec ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  055c0	40		 inc	 eax
  055c1	50		 push	 eax
  055c2	8d 85 94 f8 ff
	ff		 lea	 eax, DWORD PTR ___encStr$521817[ebp]
  055c8	50		 push	 eax
  055c9	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  055cf	50		 push	 eax
  055d0	ff d6		 call	 esi
  055d2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 621  : 		pInfo->m_iGravityType = kLoader.LoadInt( szKey, 0 );

  055d5	53		 push	 ebx
  055d6	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  055dc	50		 push	 eax
  055dd	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  055e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  055e9	89 87 80 00 00
	00		 mov	 DWORD PTR [edi+128], eax
  055ef	6a 03		 push	 3

; 622  : 
; 623  : 		wsprintf_e( szKey, "preset%d_getup", i+1 );

  055f1	c7 85 98 fb ff
	ff 9d 9e 8e 99	 mov	 DWORD PTR ___encStr$521969[ebp], -1718706531 ; 998e9e9dH
  055fb	c7 85 9c fb ff
	ff 88 98 ce 8e	 mov	 DWORD PTR ___encStr$521969[ebp+4], -1899063160 ; 8ece9888H
  05605	c7 85 a0 fb ff
	ff b2 8b 8e 9e	 mov	 DWORD PTR ___encStr$521969[ebp+8], -1634825294 ; 9e8e8bb2H
  0560f	66 c7 85 a4 fb
	ff ff 98 9c	 mov	 WORD PTR ___encStr$521969[ebp+12], 40088 ; 00009c98H
  05618	8d 85 98 fb ff
	ff		 lea	 eax, DWORD PTR ___encStr$521969[ebp]
  0561e	88 9d a6 fb ff
	ff		 mov	 BYTE PTR ___encStr$521969[ebp+14], bl
  05624	59		 pop	 ecx
$LL16728@LoadRoomOp:
  05625	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0562b	83 c0 04	 add	 eax, 4
  0562e	49		 dec	 ecx
  0562f	75 f4		 jne	 SHORT $LL16728@LoadRoomOp
  05631	6a 0c		 push	 12			; 0000000cH
  05633	58		 pop	 eax
$LL16725@LoadRoomOp:
  05634	8b c8		 mov	 ecx, eax
  05636	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0563c	79 05		 jns	 SHORT $LN17600@LoadRoomOp
  0563e	49		 dec	 ecx
  0563f	83 c9 fc	 or	 ecx, -4			; fffffffcH
  05642	41		 inc	 ecx
$LN17600@LoadRoomOp:
  05643	b2 ed		 mov	 dl, -19			; ffffffedH
  05645	2a d1		 sub	 dl, cl
  05647	30 94 05 98 fb
	ff ff		 xor	 BYTE PTR ___encStr$521969[ebp+eax], dl
  0564e	40		 inc	 eax
  0564f	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  05652	7c e0		 jl	 SHORT $LL16725@LoadRoomOp
  05654	8b 85 d8 ec ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0565a	40		 inc	 eax
  0565b	50		 push	 eax
  0565c	8d 85 98 fb ff
	ff		 lea	 eax, DWORD PTR ___encStr$521969[ebp]
  05662	50		 push	 eax
  05663	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  05669	50		 push	 eax
  0566a	ff d6		 call	 esi
  0566c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 624  : 		pInfo->m_iGetUpType = kLoader.LoadInt( szKey, 0 );

  0566f	53		 push	 ebx
  05670	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  05676	50		 push	 eax
  05677	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0567d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  05683	89 87 84 00 00
	00		 mov	 DWORD PTR [edi+132], eax
  05689	6a 05		 push	 5

; 625  : 
; 626  : 		wsprintf_e( szKey, "preset%d_red_move_speed", i+1 );

  0568b	c7 85 80 f3 ff
	ff 9d 9e 8e 99	 mov	 DWORD PTR ___encStr$522121[ebp], -1718706531 ; 998e9e9dH
  05695	c7 85 84 f3 ff
	ff 88 98 ce 8e	 mov	 DWORD PTR ___encStr$522121[ebp+4], -1899063160 ; 8ece9888H
  0569f	c7 85 88 f3 ff
	ff b2 9e 8e 8e	 mov	 DWORD PTR ___encStr$522121[ebp+8], -1903255886 ; 8e8e9eb2H
  056a9	c7 85 8c f3 ff
	ff b2 81 84 9c	 mov	 DWORD PTR ___encStr$522121[ebp+12], -1669037646 ; 9c8481b2H
  056b3	c7 85 90 f3 ff
	ff 88 b3 98 9a	 mov	 DWORD PTR ___encStr$522121[ebp+16], -1701268600 ; 9a98b388H
  056bd	8d 85 80 f3 ff
	ff		 lea	 eax, DWORD PTR ___encStr$522121[ebp]
  056c3	c7 85 94 f3 ff
	ff 88 89 8f 00	 mov	 DWORD PTR ___encStr$522121[ebp+20], 9406856 ; 008f8988H
  056cd	59		 pop	 ecx
$LL16736@LoadRoomOp:
  056ce	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  056d4	83 c0 04	 add	 eax, 4
  056d7	49		 dec	 ecx
  056d8	75 f4		 jne	 SHORT $LL16736@LoadRoomOp
  056da	6a 14		 push	 20			; 00000014H
  056dc	58		 pop	 eax
$LL16733@LoadRoomOp:
  056dd	8b c8		 mov	 ecx, eax
  056df	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  056e5	79 05		 jns	 SHORT $LN17601@LoadRoomOp
  056e7	49		 dec	 ecx
  056e8	83 c9 fc	 or	 ecx, -4			; fffffffcH
  056eb	41		 inc	 ecx
$LN17601@LoadRoomOp:
  056ec	b2 ed		 mov	 dl, -19			; ffffffedH
  056ee	2a d1		 sub	 dl, cl
  056f0	30 94 05 80 f3
	ff ff		 xor	 BYTE PTR ___encStr$522121[ebp+eax], dl
  056f7	40		 inc	 eax
  056f8	83 f8 17	 cmp	 eax, 23			; 00000017H
  056fb	7c e0		 jl	 SHORT $LL16733@LoadRoomOp
  056fd	8b 85 d8 ec ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  05703	40		 inc	 eax
  05704	50		 push	 eax
  05705	8d 85 80 f3 ff
	ff		 lea	 eax, DWORD PTR ___encStr$522121[ebp]
  0570b	50		 push	 eax
  0570c	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  05712	50		 push	 eax
  05713	ff d6		 call	 esi
  05715	83 c4 0c	 add	 esp, 12			; 0000000cH

; 627  : 		pInfo->m_iRedMoveSpeedType = kLoader.LoadInt( szKey, 0 );

  05718	53		 push	 ebx
  05719	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  0571f	50		 push	 eax
  05720	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  05726	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  0572c	89 87 98 00 00
	00		 mov	 DWORD PTR [edi+152], eax
  05732	6a 06		 push	 6

; 628  : 
; 629  : 		wsprintf_e( szKey, "preset%d_blue_move_speed", i+1 );

  05734	c7 85 d4 f2 ff
	ff 9d 9e 8e 99	 mov	 DWORD PTR ___encStr$522273[ebp], -1718706531 ; 998e9e9dH
  0573e	c7 85 d8 f2 ff
	ff 88 98 ce 8e	 mov	 DWORD PTR ___encStr$522273[ebp+4], -1899063160 ; 8ece9888H
  05748	c7 85 dc f2 ff
	ff b2 8e 87 9f	 mov	 DWORD PTR ___encStr$522273[ebp+8], -1618506062 ; 9f878eb2H
  05752	c7 85 e0 f2 ff
	ff 88 b3 86 85	 mov	 DWORD PTR ___encStr$522273[ebp+12], -2054769784 ; 8586b388H
  0575c	c7 85 e4 f2 ff
	ff 9b 89 b4 99	 mov	 DWORD PTR ___encStr$522273[ebp+16], -1716221541 ; 99b4899bH
  05766	c7 85 e8 f2 ff
	ff 9d 89 8e 8e	 mov	 DWORD PTR ___encStr$522273[ebp+20], -1903261283 ; 8e8e899dH
  05770	8d 85 d4 f2 ff
	ff		 lea	 eax, DWORD PTR ___encStr$522273[ebp]
  05776	88 9d ec f2 ff
	ff		 mov	 BYTE PTR ___encStr$522273[ebp+24], bl
  0577c	59		 pop	 ecx
$LL16744@LoadRoomOp:
  0577d	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  05783	83 c0 04	 add	 eax, 4
  05786	49		 dec	 ecx
  05787	75 f4		 jne	 SHORT $LL16744@LoadRoomOp
  05789	8b 85 d8 ec ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0578f	40		 inc	 eax
  05790	50		 push	 eax
  05791	8d 85 d4 f2 ff
	ff		 lea	 eax, DWORD PTR ___encStr$522273[ebp]
  05797	50		 push	 eax
  05798	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  0579e	50		 push	 eax
  0579f	ff d6		 call	 esi
  057a1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 630  : 		pInfo->m_iBlueMoveSpeedType = kLoader.LoadInt( szKey, 0 );

  057a4	53		 push	 ebx
  057a5	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  057ab	50		 push	 eax
  057ac	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  057b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  057b8	89 87 9c 00 00
	00		 mov	 DWORD PTR [edi+156], eax
  057be	6a 04		 push	 4

; 631  : 
; 632  : 		wsprintf_e( szKey, "preset%d_ko_type", i+1 );

  057c0	c7 85 dc f8 ff
	ff 9d 9e 8e 99	 mov	 DWORD PTR ___encStr$522425[ebp], -1718706531 ; 998e9e9dH
  057ca	c7 85 e0 f8 ff
	ff 88 98 ce 8e	 mov	 DWORD PTR ___encStr$522425[ebp+4], -1899063160 ; 8ece9888H
  057d4	c7 85 e4 f8 ff
	ff b2 87 84 b5	 mov	 DWORD PTR ___encStr$522425[ebp+8], -1249605710 ; b58487b2H
  057de	c7 85 e8 f8 ff
	ff 99 95 9b 8f	 mov	 DWORD PTR ___encStr$522425[ebp+12], -1885629031 ; 8f9b9599H
  057e8	8d 85 dc f8 ff
	ff		 lea	 eax, DWORD PTR ___encStr$522425[ebp]
  057ee	88 9d ec f8 ff
	ff		 mov	 BYTE PTR ___encStr$522425[ebp+16], bl
  057f4	59		 pop	 ecx
$LL16752@LoadRoomOp:
  057f5	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  057fb	83 c0 04	 add	 eax, 4
  057fe	49		 dec	 ecx
  057ff	75 f4		 jne	 SHORT $LL16752@LoadRoomOp
  05801	8b 85 d8 ec ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  05807	40		 inc	 eax
  05808	50		 push	 eax
  05809	8d 85 dc f8 ff
	ff		 lea	 eax, DWORD PTR ___encStr$522425[ebp]
  0580f	50		 push	 eax
  05810	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  05816	50		 push	 eax
  05817	ff d6		 call	 esi
  05819	83 c4 0c	 add	 esp, 12			; 0000000cH

; 633  : 		pInfo->m_iKOType = kLoader.LoadInt( szKey, 0 );

  0581c	53		 push	 ebx
  0581d	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  05823	50		 push	 eax
  05824	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0582a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  05830	89 87 88 00 00
	00		 mov	 DWORD PTR [edi+136], eax
  05836	6a 05		 push	 5

; 634  : 
; 635  : 		wsprintf_e( szKey, "preset%d_ko_effect_type", i+1 );

  05838	c7 85 64 f3 ff
	ff 9d 9e 8e 99	 mov	 DWORD PTR ___encStr$522577[ebp], -1718706531 ; 998e9e9dH
  05842	c7 85 68 f3 ff
	ff 88 98 ce 8e	 mov	 DWORD PTR ___encStr$522577[ebp+4], -1899063160 ; 8ece9888H
  0584c	c7 85 6c f3 ff
	ff b2 87 84 b5	 mov	 DWORD PTR ___encStr$522577[ebp+8], -1249605710 ; b58487b2H
  05856	c7 85 70 f3 ff
	ff 88 8a 8d 8f	 mov	 DWORD PTR ___encStr$522577[ebp+12], -1886549368 ; 8f8d8a88H
  05860	c7 85 74 f3 ff
	ff 8e 98 b4 9e	 mov	 DWORD PTR ___encStr$522577[ebp+16], -1632331634 ; 9eb4988eH
  0586a	8d 85 64 f3 ff
	ff		 lea	 eax, DWORD PTR ___encStr$522577[ebp]
  05870	c7 85 78 f3 ff
	ff 94 9c 8e 00	 mov	 DWORD PTR ___encStr$522577[ebp+20], 9346196 ; 008e9c94H
  0587a	59		 pop	 ecx
$LL16760@LoadRoomOp:
  0587b	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  05881	83 c0 04	 add	 eax, 4
  05884	49		 dec	 ecx
  05885	75 f4		 jne	 SHORT $LL16760@LoadRoomOp
  05887	6a 14		 push	 20			; 00000014H
  05889	58		 pop	 eax
$LL16757@LoadRoomOp:
  0588a	8b c8		 mov	 ecx, eax
  0588c	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  05892	79 05		 jns	 SHORT $LN17602@LoadRoomOp
  05894	49		 dec	 ecx
  05895	83 c9 fc	 or	 ecx, -4			; fffffffcH
  05898	41		 inc	 ecx
$LN17602@LoadRoomOp:
  05899	b2 ed		 mov	 dl, -19			; ffffffedH
  0589b	2a d1		 sub	 dl, cl
  0589d	30 94 05 64 f3
	ff ff		 xor	 BYTE PTR ___encStr$522577[ebp+eax], dl
  058a4	40		 inc	 eax
  058a5	83 f8 17	 cmp	 eax, 23			; 00000017H
  058a8	7c e0		 jl	 SHORT $LL16757@LoadRoomOp
  058aa	8b 85 d8 ec ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  058b0	40		 inc	 eax
  058b1	50		 push	 eax
  058b2	8d 85 64 f3 ff
	ff		 lea	 eax, DWORD PTR ___encStr$522577[ebp]
  058b8	50		 push	 eax
  058b9	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  058bf	50		 push	 eax
  058c0	ff d6		 call	 esi
  058c2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 636  : 		pInfo->m_iKOEffectType = kLoader.LoadInt( szKey, 0 );

  058c5	53		 push	 ebx
  058c6	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  058cc	50		 push	 eax
  058cd	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  058d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  058d9	89 87 8c 00 00
	00		 mov	 DWORD PTR [edi+140], eax
  058df	6a 05		 push	 5

; 637  : 
; 638  : 		wsprintf_e( szKey, "preset%d_red_blow_type", i+1 );

  058e1	c7 85 b8 f3 ff
	ff 9d 9e 8e 99	 mov	 DWORD PTR ___encStr$522729[ebp], -1718706531 ; 998e9e9dH
  058eb	c7 85 bc f3 ff
	ff 88 98 ce 8e	 mov	 DWORD PTR ___encStr$522729[ebp+4], -1899063160 ; 8ece9888H
  058f5	c7 85 c0 f3 ff
	ff b2 9e 8e 8e	 mov	 DWORD PTR ___encStr$522729[ebp+8], -1903255886 ; 8e8e9eb2H
  058ff	c7 85 c4 f3 ff
	ff b2 8e 87 85	 mov	 DWORD PTR ___encStr$522729[ebp+12], -2054713678 ; 85878eb2H
  05909	c7 85 c8 f3 ff
	ff 9a b3 9f 93	 mov	 DWORD PTR ___encStr$522729[ebp+16], -1818250342 ; 939fb39aH
  05913	66 c7 85 cc f3
	ff ff 9d 89	 mov	 WORD PTR ___encStr$522729[ebp+20], 35229 ; 0000899dH
  0591c	8d 85 b8 f3 ff
	ff		 lea	 eax, DWORD PTR ___encStr$522729[ebp]
  05922	88 9d ce f3 ff
	ff		 mov	 BYTE PTR ___encStr$522729[ebp+22], bl
  05928	59		 pop	 ecx
$LL16768@LoadRoomOp:
  05929	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0592f	83 c0 04	 add	 eax, 4
  05932	49		 dec	 ecx
  05933	75 f4		 jne	 SHORT $LL16768@LoadRoomOp
  05935	6a 14		 push	 20			; 00000014H
  05937	58		 pop	 eax
$LL16765@LoadRoomOp:
  05938	8b c8		 mov	 ecx, eax
  0593a	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  05940	79 05		 jns	 SHORT $LN17603@LoadRoomOp
  05942	49		 dec	 ecx
  05943	83 c9 fc	 or	 ecx, -4			; fffffffcH
  05946	41		 inc	 ecx
$LN17603@LoadRoomOp:
  05947	b2 ed		 mov	 dl, -19			; ffffffedH
  05949	2a d1		 sub	 dl, cl
  0594b	30 94 05 b8 f3
	ff ff		 xor	 BYTE PTR ___encStr$522729[ebp+eax], dl
  05952	40		 inc	 eax
  05953	83 f8 16	 cmp	 eax, 22			; 00000016H
  05956	7c e0		 jl	 SHORT $LL16765@LoadRoomOp
  05958	8b 85 d8 ec ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0595e	40		 inc	 eax
  0595f	50		 push	 eax
  05960	8d 85 b8 f3 ff
	ff		 lea	 eax, DWORD PTR ___encStr$522729[ebp]
  05966	50		 push	 eax
  05967	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  0596d	50		 push	 eax
  0596e	ff d6		 call	 esi
  05970	83 c4 0c	 add	 esp, 12			; 0000000cH

; 639  : 		pInfo->m_iRedBlowType = kLoader.LoadInt( szKey, 0 );

  05973	53		 push	 ebx
  05974	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  0597a	50		 push	 eax
  0597b	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  05981	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  05987	89 87 90 00 00
	00		 mov	 DWORD PTR [edi+144], eax
  0598d	6a 05		 push	 5

; 640  : 
; 641  : 		wsprintf_e( szKey, "preset%d_blue_blow_type", i+1 );

  0598f	c7 85 48 f3 ff
	ff 9d 9e 8e 99	 mov	 DWORD PTR ___encStr$522881[ebp], -1718706531 ; 998e9e9dH
  05999	c7 85 4c f3 ff
	ff 88 98 ce 8e	 mov	 DWORD PTR ___encStr$522881[ebp+4], -1899063160 ; 8ece9888H
  059a3	c7 85 50 f3 ff
	ff b2 8e 87 9f	 mov	 DWORD PTR ___encStr$522881[ebp+8], -1618506062 ; 9f878eb2H
  059ad	c7 85 54 f3 ff
	ff 88 b3 89 86	 mov	 DWORD PTR ___encStr$522881[ebp+12], -2037795960 ; 8689b388H
  059b7	c7 85 58 f3 ff
	ff 82 9b b4 9e	 mov	 DWORD PTR ___encStr$522881[ebp+16], -1632330878 ; 9eb49b82H
  059c1	8d 85 48 f3 ff
	ff		 lea	 eax, DWORD PTR ___encStr$522881[ebp]
  059c7	c7 85 5c f3 ff
	ff 94 9c 8e 00	 mov	 DWORD PTR ___encStr$522881[ebp+20], 9346196 ; 008e9c94H
  059d1	59		 pop	 ecx
$LL16776@LoadRoomOp:
  059d2	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  059d8	83 c0 04	 add	 eax, 4
  059db	49		 dec	 ecx
  059dc	75 f4		 jne	 SHORT $LL16776@LoadRoomOp
  059de	6a 14		 push	 20			; 00000014H
  059e0	58		 pop	 eax
$LL16773@LoadRoomOp:
  059e1	8b c8		 mov	 ecx, eax
  059e3	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  059e9	79 05		 jns	 SHORT $LN17604@LoadRoomOp
  059eb	49		 dec	 ecx
  059ec	83 c9 fc	 or	 ecx, -4			; fffffffcH
  059ef	41		 inc	 ecx
$LN17604@LoadRoomOp:
  059f0	b2 ed		 mov	 dl, -19			; ffffffedH
  059f2	2a d1		 sub	 dl, cl
  059f4	30 94 05 48 f3
	ff ff		 xor	 BYTE PTR ___encStr$522881[ebp+eax], dl
  059fb	40		 inc	 eax
  059fc	83 f8 17	 cmp	 eax, 23			; 00000017H
  059ff	7c e0		 jl	 SHORT $LL16773@LoadRoomOp
  05a01	8b 85 d8 ec ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  05a07	40		 inc	 eax
  05a08	50		 push	 eax
  05a09	8d 85 48 f3 ff
	ff		 lea	 eax, DWORD PTR ___encStr$522881[ebp]
  05a0f	50		 push	 eax
  05a10	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  05a16	50		 push	 eax
  05a17	ff d6		 call	 esi
  05a19	83 c4 0c	 add	 esp, 12			; 0000000cH

; 642  : 		pInfo->m_iBlueBlowType = kLoader.LoadInt( szKey, 0 );

  05a1c	53		 push	 ebx
  05a1d	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  05a23	50		 push	 eax
  05a24	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  05a2a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  05a30	89 87 94 00 00
	00		 mov	 DWORD PTR [edi+148], eax
  05a36	6a 04		 push	 4

; 643  : 
; 644  : 		wsprintf_e( szKey, "preset%d_red_equip", i+1 );

  05a38	c7 85 34 f8 ff
	ff 9d 9e 8e 99	 mov	 DWORD PTR ___encStr$523033[ebp], -1718706531 ; 998e9e9dH
  05a42	c7 85 38 f8 ff
	ff 88 98 ce 8e	 mov	 DWORD PTR ___encStr$523033[ebp+4], -1899063160 ; 8ece9888H
  05a4c	c7 85 3c f8 ff
	ff b2 9e 8e 8e	 mov	 DWORD PTR ___encStr$523033[ebp+8], -1903255886 ; 8e8e9eb2H
  05a56	c7 85 40 f8 ff
	ff b2 89 9a 9f	 mov	 DWORD PTR ___encStr$523033[ebp+12], -1617262158 ; 9f9a89b2H
  05a60	66 c7 85 44 f8
	ff ff 84 9c	 mov	 WORD PTR ___encStr$523033[ebp+16], 40068 ; 00009c84H
  05a69	8d 85 34 f8 ff
	ff		 lea	 eax, DWORD PTR ___encStr$523033[ebp]
  05a6f	88 9d 46 f8 ff
	ff		 mov	 BYTE PTR ___encStr$523033[ebp+18], bl
  05a75	59		 pop	 ecx
$LL16784@LoadRoomOp:
  05a76	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  05a7c	83 c0 04	 add	 eax, 4
  05a7f	49		 dec	 ecx
  05a80	75 f4		 jne	 SHORT $LL16784@LoadRoomOp
  05a82	6a 10		 push	 16			; 00000010H
  05a84	58		 pop	 eax
$LL16781@LoadRoomOp:
  05a85	8b c8		 mov	 ecx, eax
  05a87	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  05a8d	79 05		 jns	 SHORT $LN17605@LoadRoomOp
  05a8f	49		 dec	 ecx
  05a90	83 c9 fc	 or	 ecx, -4			; fffffffcH
  05a93	41		 inc	 ecx
$LN17605@LoadRoomOp:
  05a94	b2 ed		 mov	 dl, -19			; ffffffedH
  05a96	2a d1		 sub	 dl, cl
  05a98	30 94 05 34 f8
	ff ff		 xor	 BYTE PTR ___encStr$523033[ebp+eax], dl
  05a9f	40		 inc	 eax
  05aa0	83 f8 12	 cmp	 eax, 18			; 00000012H
  05aa3	7c e0		 jl	 SHORT $LL16781@LoadRoomOp
  05aa5	8b 85 d8 ec ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  05aab	40		 inc	 eax
  05aac	50		 push	 eax
  05aad	8d 85 34 f8 ff
	ff		 lea	 eax, DWORD PTR ___encStr$523033[ebp]
  05ab3	50		 push	 eax
  05ab4	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  05aba	50		 push	 eax
  05abb	ff d6		 call	 esi
  05abd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 645  : 		pInfo->m_iRedEquipType = kLoader.LoadInt( szKey, 0 );

  05ac0	53		 push	 ebx
  05ac1	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  05ac7	50		 push	 eax
  05ac8	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  05ace	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  05ad4	89 87 a0 00 00
	00		 mov	 DWORD PTR [edi+160], eax
  05ada	6a 04		 push	 4

; 646  : 
; 647  : 		wsprintf_e( szKey, "preset%d_blue_equip", i+1 );

  05adc	c7 85 b4 f6 ff
	ff 9d 9e 8e 99	 mov	 DWORD PTR ___encStr$523185[ebp], -1718706531 ; 998e9e9dH
  05ae6	c7 85 b8 f6 ff
	ff 88 98 ce 8e	 mov	 DWORD PTR ___encStr$523185[ebp+4], -1899063160 ; 8ece9888H
  05af0	c7 85 bc f6 ff
	ff b2 8e 87 9f	 mov	 DWORD PTR ___encStr$523185[ebp+8], -1618506062 ; 9f878eb2H
  05afa	c7 85 c0 f6 ff
	ff 88 b3 8e 9b	 mov	 DWORD PTR ___encStr$523185[ebp+12], -1685146744 ; 9b8eb388H
  05b04	8d 85 b4 f6 ff
	ff		 lea	 eax, DWORD PTR ___encStr$523185[ebp]
  05b0a	c7 85 c4 f6 ff
	ff 98 85 9b 00	 mov	 DWORD PTR ___encStr$523185[ebp+16], 10192280 ; 009b8598H
  05b14	59		 pop	 ecx
$LL16792@LoadRoomOp:
  05b15	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  05b1b	83 c0 04	 add	 eax, 4
  05b1e	49		 dec	 ecx
  05b1f	75 f4		 jne	 SHORT $LL16792@LoadRoomOp
  05b21	6a 10		 push	 16			; 00000010H
  05b23	58		 pop	 eax
$LL16789@LoadRoomOp:
  05b24	8b c8		 mov	 ecx, eax
  05b26	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  05b2c	79 05		 jns	 SHORT $LN17606@LoadRoomOp
  05b2e	49		 dec	 ecx
  05b2f	83 c9 fc	 or	 ecx, -4			; fffffffcH
  05b32	41		 inc	 ecx
$LN17606@LoadRoomOp:
  05b33	b2 ed		 mov	 dl, -19			; ffffffedH
  05b35	2a d1		 sub	 dl, cl
  05b37	30 94 05 b4 f6
	ff ff		 xor	 BYTE PTR ___encStr$523185[ebp+eax], dl
  05b3e	40		 inc	 eax
  05b3f	83 f8 13	 cmp	 eax, 19			; 00000013H
  05b42	7c e0		 jl	 SHORT $LL16789@LoadRoomOp
  05b44	8b 85 d8 ec ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  05b4a	40		 inc	 eax
  05b4b	50		 push	 eax
  05b4c	8d 85 b4 f6 ff
	ff		 lea	 eax, DWORD PTR ___encStr$523185[ebp]
  05b52	50		 push	 eax
  05b53	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  05b59	50		 push	 eax
  05b5a	ff d6		 call	 esi
  05b5c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 648  : 		pInfo->m_iBlueEquipType = kLoader.LoadInt( szKey, 0 );

  05b5f	53		 push	 ebx
  05b60	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  05b66	50		 push	 eax
  05b67	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  05b6d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  05b73	89 87 a4 00 00
	00		 mov	 DWORD PTR [edi+164], eax
  05b79	6a 04		 push	 4

; 649  : 
; 650  : 		wsprintf_e( szKey, "preset%d_round_type", i+1 );

  05b7b	c7 85 44 f7 ff
	ff 9d 9e 8e 99	 mov	 DWORD PTR ___encStr$523337[ebp], -1718706531 ; 998e9e9dH
  05b85	c7 85 48 f7 ff
	ff 88 98 ce 8e	 mov	 DWORD PTR ___encStr$523337[ebp+4], -1899063160 ; 8ece9888H
  05b8f	c7 85 4c f7 ff
	ff b2 9e 84 9f	 mov	 DWORD PTR ___encStr$523337[ebp+8], -1618698574 ; 9f849eb2H
  05b99	c7 85 50 f7 ff
	ff 83 88 b4 9e	 mov	 DWORD PTR ___encStr$523337[ebp+12], -1632335741 ; 9eb48883H
  05ba3	8d 85 44 f7 ff
	ff		 lea	 eax, DWORD PTR ___encStr$523337[ebp]
  05ba9	c7 85 54 f7 ff
	ff 94 9c 8e 00	 mov	 DWORD PTR ___encStr$523337[ebp+16], 9346196 ; 008e9c94H
  05bb3	59		 pop	 ecx
$LL16800@LoadRoomOp:
  05bb4	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  05bba	83 c0 04	 add	 eax, 4
  05bbd	49		 dec	 ecx
  05bbe	75 f4		 jne	 SHORT $LL16800@LoadRoomOp
  05bc0	6a 10		 push	 16			; 00000010H
  05bc2	58		 pop	 eax
$LL16797@LoadRoomOp:
  05bc3	8b c8		 mov	 ecx, eax
  05bc5	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  05bcb	79 05		 jns	 SHORT $LN17607@LoadRoomOp
  05bcd	49		 dec	 ecx
  05bce	83 c9 fc	 or	 ecx, -4			; fffffffcH
  05bd1	41		 inc	 ecx
$LN17607@LoadRoomOp:
  05bd2	b2 ed		 mov	 dl, -19			; ffffffedH
  05bd4	2a d1		 sub	 dl, cl
  05bd6	30 94 05 44 f7
	ff ff		 xor	 BYTE PTR ___encStr$523337[ebp+eax], dl
  05bdd	40		 inc	 eax
  05bde	83 f8 13	 cmp	 eax, 19			; 00000013H
  05be1	7c e0		 jl	 SHORT $LL16797@LoadRoomOp
  05be3	8b 85 d8 ec ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  05be9	40		 inc	 eax
  05bea	50		 push	 eax
  05beb	8d 85 44 f7 ff
	ff		 lea	 eax, DWORD PTR ___encStr$523337[ebp]
  05bf1	50		 push	 eax
  05bf2	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  05bf8	50		 push	 eax
  05bf9	ff d6		 call	 esi
  05bfb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 651  : 		pInfo->m_iCatchModeRoundType = kLoader.LoadInt( szKey, 0 );

  05bfe	53		 push	 ebx
  05bff	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  05c05	50		 push	 eax
  05c06	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  05c0c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  05c12	89 87 a8 00 00
	00		 mov	 DWORD PTR [edi+168], eax
  05c18	6a 06		 push	 6

; 652  : 
; 653  : 		wsprintf_e( szKey, "preset%d_round_time_type", i+1 );

  05c1a	c7 85 b4 f2 ff
	ff 9d 9e 8e 99	 mov	 DWORD PTR ___encStr$523489[ebp], -1718706531 ; 998e9e9dH
  05c24	c7 85 b8 f2 ff
	ff 88 98 ce 8e	 mov	 DWORD PTR ___encStr$523489[ebp+4], -1899063160 ; 8ece9888H
  05c2e	c7 85 bc f2 ff
	ff b2 9e 84 9f	 mov	 DWORD PTR ___encStr$523489[ebp+8], -1618698574 ; 9f849eb2H
  05c38	c7 85 c0 f2 ff
	ff 83 88 b4 9e	 mov	 DWORD PTR ___encStr$523489[ebp+12], -1632335741 ; 9eb48883H
  05c42	c7 85 c4 f2 ff
	ff 84 81 8e b5	 mov	 DWORD PTR ___encStr$523489[ebp+16], -1248951932 ; b58e8184H
  05c4c	c7 85 c8 f2 ff
	ff 99 95 9b 8f	 mov	 DWORD PTR ___encStr$523489[ebp+20], -1885629031 ; 8f9b9599H
  05c56	8d 85 b4 f2 ff
	ff		 lea	 eax, DWORD PTR ___encStr$523489[ebp]
  05c5c	88 9d cc f2 ff
	ff		 mov	 BYTE PTR ___encStr$523489[ebp+24], bl
  05c62	59		 pop	 ecx
$LL16808@LoadRoomOp:
  05c63	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  05c69	83 c0 04	 add	 eax, 4
  05c6c	49		 dec	 ecx
  05c6d	75 f4		 jne	 SHORT $LL16808@LoadRoomOp
  05c6f	8b 85 d8 ec ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  05c75	40		 inc	 eax
  05c76	50		 push	 eax
  05c77	8d 85 b4 f2 ff
	ff		 lea	 eax, DWORD PTR ___encStr$523489[ebp]
  05c7d	50		 push	 eax
  05c7e	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  05c84	50		 push	 eax
  05c85	ff d6		 call	 esi
  05c87	83 c4 0c	 add	 esp, 12			; 0000000cH

; 654  : 		pInfo->m_iCatchModeRoundTimeType = kLoader.LoadInt( szKey, 0 );

  05c8a	53		 push	 ebx
  05c8b	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  05c91	50		 push	 eax
  05c92	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  05c98	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  05c9e	89 87 ac 00 00
	00		 mov	 DWORD PTR [edi+172], eax
  05ca4	6a 04		 push	 4

; 655  : 
; 656  : 		wsprintf_e( szKey, "preset%d_growth_use", i+1 );

  05ca6	c7 85 84 f6 ff
	ff 9d 9e 8e 99	 mov	 DWORD PTR ___encStr$523641[ebp], -1718706531 ; 998e9e9dH
  05cb0	c7 85 88 f6 ff
	ff 88 98 ce 8e	 mov	 DWORD PTR ___encStr$523641[ebp+4], -1899063160 ; 8ece9888H
  05cba	c7 85 8c f6 ff
	ff b2 8b 99 85	 mov	 DWORD PTR ___encStr$523641[ebp+8], -2053534798 ; 85998bb2H
  05cc4	c7 85 90 f6 ff
	ff 9a 98 83 b5	 mov	 DWORD PTR ___encStr$523641[ebp+12], -1249666918 ; b583989aH
  05cce	8d 85 84 f6 ff
	ff		 lea	 eax, DWORD PTR ___encStr$523641[ebp]
  05cd4	c7 85 94 f6 ff
	ff 98 9f 8e 00	 mov	 DWORD PTR ___encStr$523641[ebp+16], 9346968 ; 008e9f98H
  05cde	59		 pop	 ecx
$LL16816@LoadRoomOp:
  05cdf	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  05ce5	83 c0 04	 add	 eax, 4
  05ce8	49		 dec	 ecx
  05ce9	75 f4		 jne	 SHORT $LL16816@LoadRoomOp
  05ceb	6a 10		 push	 16			; 00000010H
  05ced	58		 pop	 eax
$LL16813@LoadRoomOp:
  05cee	8b c8		 mov	 ecx, eax
  05cf0	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  05cf6	79 05		 jns	 SHORT $LN17608@LoadRoomOp
  05cf8	49		 dec	 ecx
  05cf9	83 c9 fc	 or	 ecx, -4			; fffffffcH
  05cfc	41		 inc	 ecx
$LN17608@LoadRoomOp:
  05cfd	b2 ed		 mov	 dl, -19			; ffffffedH
  05cff	2a d1		 sub	 dl, cl
  05d01	30 94 05 84 f6
	ff ff		 xor	 BYTE PTR ___encStr$523641[ebp+eax], dl
  05d08	40		 inc	 eax
  05d09	83 f8 13	 cmp	 eax, 19			; 00000013H
  05d0c	7c e0		 jl	 SHORT $LL16813@LoadRoomOp
  05d0e	8b 85 d8 ec ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  05d14	40		 inc	 eax
  05d15	50		 push	 eax
  05d16	8d 85 84 f6 ff
	ff		 lea	 eax, DWORD PTR ___encStr$523641[ebp]
  05d1c	50		 push	 eax
  05d1d	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  05d23	50		 push	 eax
  05d24	ff d6		 call	 esi
  05d26	83 c4 0c	 add	 esp, 12			; 0000000cH

; 657  : 		pInfo->m_iGrowthUseType = kLoader.LoadInt( szKey, 0 );

  05d29	53		 push	 ebx
  05d2a	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  05d30	50		 push	 eax
  05d31	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  05d37	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  05d3d	89 87 b0 00 00
	00		 mov	 DWORD PTR [edi+176], eax
  05d43	6a 05		 push	 5

; 658  : 
; 659  : 		wsprintf_e( szKey, "preset%d_extraitem_use", i+1 );

  05d45	c7 85 d4 f3 ff
	ff 9d 9e 8e 99	 mov	 DWORD PTR ___encStr$523793[ebp], -1718706531 ; 998e9e9dH
  05d4f	c7 85 d8 f3 ff
	ff 88 98 ce 8e	 mov	 DWORD PTR ___encStr$523793[ebp+4], -1899063160 ; 8ece9888H
  05d59	c7 85 dc f3 ff
	ff b2 89 93 9e	 mov	 DWORD PTR ___encStr$523793[ebp+8], -1634498126 ; 9e9389b2H
  05d63	c7 85 e0 f3 ff
	ff 9f 8d 82 9e	 mov	 DWORD PTR ___encStr$523793[ebp+12], -1635611233 ; 9e828d9fH
  05d6d	c7 85 e4 f3 ff
	ff 88 81 b4 9f	 mov	 DWORD PTR ___encStr$523793[ebp+16], -1615560312 ; 9fb48188H
  05d77	66 c7 85 e8 f3
	ff ff 9e 89	 mov	 WORD PTR ___encStr$523793[ebp+20], 35230 ; 0000899eH
  05d80	8d 85 d4 f3 ff
	ff		 lea	 eax, DWORD PTR ___encStr$523793[ebp]
  05d86	88 9d ea f3 ff
	ff		 mov	 BYTE PTR ___encStr$523793[ebp+22], bl
  05d8c	59		 pop	 ecx
$LL16824@LoadRoomOp:
  05d8d	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  05d93	83 c0 04	 add	 eax, 4
  05d96	49		 dec	 ecx
  05d97	75 f4		 jne	 SHORT $LL16824@LoadRoomOp
  05d99	6a 14		 push	 20			; 00000014H
  05d9b	58		 pop	 eax
$LL16821@LoadRoomOp:
  05d9c	8b c8		 mov	 ecx, eax
  05d9e	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  05da4	79 05		 jns	 SHORT $LN17609@LoadRoomOp
  05da6	49		 dec	 ecx
  05da7	83 c9 fc	 or	 ecx, -4			; fffffffcH
  05daa	41		 inc	 ecx
$LN17609@LoadRoomOp:
  05dab	b2 ed		 mov	 dl, -19			; ffffffedH
  05dad	2a d1		 sub	 dl, cl
  05daf	30 94 05 d4 f3
	ff ff		 xor	 BYTE PTR ___encStr$523793[ebp+eax], dl
  05db6	40		 inc	 eax
  05db7	83 f8 16	 cmp	 eax, 22			; 00000016H
  05dba	7c e0		 jl	 SHORT $LL16821@LoadRoomOp
  05dbc	8b 85 d8 ec ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  05dc2	40		 inc	 eax
  05dc3	50		 push	 eax
  05dc4	8d 85 d4 f3 ff
	ff		 lea	 eax, DWORD PTR ___encStr$523793[ebp]
  05dca	50		 push	 eax
  05dcb	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  05dd1	50		 push	 eax
  05dd2	ff d6		 call	 esi
  05dd4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 660  : 		pInfo->m_iExtraItemUseType = kLoader.LoadInt( szKey, 0 );

  05dd7	53		 push	 ebx
  05dd8	8d 85 70 f1 ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  05dde	50		 push	 eax
  05ddf	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  05de5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 661  : 
; 662  : 		m_PreSetList.push_back( pInfo );

  05deb	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  05df1	89 87 b4 00 00
	00		 mov	 DWORD PTR [edi+180], eax
  05df7	8d 85 c8 ec ff
	ff		 lea	 eax, DWORD PTR _pInfo$520744[ebp]
  05dfd	50		 push	 eax
  05dfe	81 c1 94 01 00
	00		 add	 ecx, 404		; 00000194H
  05e04	e8 00 00 00 00	 call	 ?push_back@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAEXABQAUPreSetInfo@@@Z ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::push_back
$LN2083@LoadRoomOp:

; 592  : 	for( i=0; i < iTypeCnt; ++i )

  05e09	ff 85 d8 ec ff
	ff		 inc	 DWORD PTR _i$[ebp]
  05e0f	8b 85 d8 ec ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  05e15	3b 85 d0 ec ff
	ff		 cmp	 eax, DWORD PTR _iTypeCnt$[ebp]
  05e1b	0f 8c 58 f3 ff
	ff		 jl	 $LL2084@LoadRoomOp
$LN2082@LoadRoomOp:

; 663  : 	}
; 664  : 
; 665  : 	// PreSetList  .
; 666  : 	PreSetInfo *pInfo = new PreSetInfo;

  05e21	68 b8 00 00 00	 push	 184			; 000000b8H
  05e26	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  05e2b	59		 pop	 ecx
  05e2c	89 85 c4 ec ff
	ff		 mov	 DWORD PTR $T540362[ebp], eax
  05e32	c6 45 fc 16	 mov	 BYTE PTR __$EHRec$[ebp+8], 22 ; 00000016H
  05e36	3b c3		 cmp	 eax, ebx
  05e38	74 0b		 je	 SHORT $LN8455@LoadRoomOp
  05e3a	8b c8		 mov	 ecx, eax
  05e3c	e8 00 00 00 00	 call	 ??0PreSetInfo@@QAE@XZ	; PreSetInfo::PreSetInfo
  05e41	8b f0		 mov	 esi, eax
  05e43	eb 02		 jmp	 SHORT $LN8456@LoadRoomOp
$LN8455@LoadRoomOp:
  05e45	33 f6		 xor	 esi, esi
$LN8456@LoadRoomOp:
  05e47	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  05e4a	89 b5 c8 ec ff
	ff		 mov	 DWORD PTR _pInfo$[ebp], esi

; 667  : 	if( !pInfo )

  05e50	3b f3		 cmp	 esi, ebx

; 668  : 		return;

  05e52	74 3c		 je	 SHORT $LN17610@LoadRoomOp

; 669  : 	pInfo->m_Desc = STR(1);

  05e54	53		 push	 ebx
  05e55	6a 01		 push	 1
  05e57	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  05e5c	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@PILLEEJG@ioRoomOptionManager?3?3LoadRoomOpt@
  05e61	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  05e67	8b c8		 mov	 ecx, eax
  05e69	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  05e6f	50		 push	 eax
  05e70	8b ce		 mov	 ecx, esi
  05e72	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 670  : 
; 671  : 	m_PreSetList.push_back( pInfo );

  05e78	8b 8d cc ec ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  05e7e	8d 85 c8 ec ff
	ff		 lea	 eax, DWORD PTR _pInfo$[ebp]
  05e84	50		 push	 eax
  05e85	81 c1 94 01 00
	00		 add	 ecx, 404		; 00000194H
  05e8b	e8 00 00 00 00	 call	 ?push_back@?$vector@PAUPreSetInfo@@V?$allocator@PAUPreSetInfo@@@std@@@std@@QAEXABQAUPreSetInfo@@@Z ; std::vector<PreSetInfo *,std::allocator<PreSetInfo *> >::push_back
$LN17610@LoadRoomOp:

; 672  : 
; 673  : }

  05e90	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  05e94	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  05e9a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioINILoader@@QAE@XZ
  05ea0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  05ea3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  05eaa	59		 pop	 ecx
  05eab	5f		 pop	 edi
  05eac	5e		 pop	 esi
  05ead	5b		 pop	 ebx
  05eae	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  05eb1	33 cd		 xor	 ecx, ebp
  05eb3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  05eb8	c9		 leave
  05eb9	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$0:
  00000	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1ioINILoader_e@@QAE@XZ
__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$1:
  0000b	ff b5 c8 ec ff
	ff		 push	 DWORD PTR $T540278[ebp]
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	59		 pop	 ecx
  00017	c3		 ret	 0
__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$2:
  00018	ff b5 c4 ec ff
	ff		 push	 DWORD PTR $T540282[ebp]
  0001e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00023	59		 pop	 ecx
  00024	c3		 ret	 0
__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$3:
  00025	ff b5 c4 ec ff
	ff		 push	 DWORD PTR $T540286[ebp]
  0002b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00030	59		 pop	 ecx
  00031	c3		 ret	 0
__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$4:
  00032	ff b5 c4 ec ff
	ff		 push	 DWORD PTR $T540290[ebp]
  00038	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003d	59		 pop	 ecx
  0003e	c3		 ret	 0
__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$5:
  0003f	ff b5 c4 ec ff
	ff		 push	 DWORD PTR $T540294[ebp]
  00045	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004a	59		 pop	 ecx
  0004b	c3		 ret	 0
__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$6:
  0004c	ff b5 c4 ec ff
	ff		 push	 DWORD PTR $T540298[ebp]
  00052	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00057	59		 pop	 ecx
  00058	c3		 ret	 0
__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$7:
  00059	ff b5 c4 ec ff
	ff		 push	 DWORD PTR $T540302[ebp]
  0005f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00064	59		 pop	 ecx
  00065	c3		 ret	 0
__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$8:
  00066	ff b5 c4 ec ff
	ff		 push	 DWORD PTR $T540306[ebp]
  0006c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00071	59		 pop	 ecx
  00072	c3		 ret	 0
__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$9:
  00073	ff b5 c4 ec ff
	ff		 push	 DWORD PTR $T540310[ebp]
  00079	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0007e	59		 pop	 ecx
  0007f	c3		 ret	 0
__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$10:
  00080	ff b5 c4 ec ff
	ff		 push	 DWORD PTR $T540314[ebp]
  00086	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008b	59		 pop	 ecx
  0008c	c3		 ret	 0
__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$11:
  0008d	ff b5 c4 ec ff
	ff		 push	 DWORD PTR $T540318[ebp]
  00093	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00098	59		 pop	 ecx
  00099	c3		 ret	 0
__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$12:
  0009a	ff b5 c4 ec ff
	ff		 push	 DWORD PTR $T540322[ebp]
  000a0	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a5	59		 pop	 ecx
  000a6	c3		 ret	 0
__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$13:
  000a7	ff b5 c4 ec ff
	ff		 push	 DWORD PTR $T540326[ebp]
  000ad	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000b2	59		 pop	 ecx
  000b3	c3		 ret	 0
__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$14:
  000b4	ff b5 c4 ec ff
	ff		 push	 DWORD PTR $T540330[ebp]
  000ba	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000bf	59		 pop	 ecx
  000c0	c3		 ret	 0
__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$15:
  000c1	ff b5 c4 ec ff
	ff		 push	 DWORD PTR $T540334[ebp]
  000c7	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000cc	59		 pop	 ecx
  000cd	c3		 ret	 0
__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$16:
  000ce	ff b5 c4 ec ff
	ff		 push	 DWORD PTR $T540338[ebp]
  000d4	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000d9	59		 pop	 ecx
  000da	c3		 ret	 0
__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$17:
  000db	ff b5 c4 ec ff
	ff		 push	 DWORD PTR $T540342[ebp]
  000e1	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000e6	59		 pop	 ecx
  000e7	c3		 ret	 0
__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$18:
  000e8	ff b5 c4 ec ff
	ff		 push	 DWORD PTR $T540346[ebp]
  000ee	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000f3	59		 pop	 ecx
  000f4	c3		 ret	 0
__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$19:
  000f5	ff b5 c4 ec ff
	ff		 push	 DWORD PTR $T540350[ebp]
  000fb	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00100	59		 pop	 ecx
  00101	c3		 ret	 0
__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$20:
  00102	ff b5 c4 ec ff
	ff		 push	 DWORD PTR $T540354[ebp]
  00108	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0010d	59		 pop	 ecx
  0010e	c3		 ret	 0
__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$21:
  0010f	ff b5 c4 ec ff
	ff		 push	 DWORD PTR $T540358[ebp]
  00115	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0011a	59		 pop	 ecx
  0011b	c3		 ret	 0
__unwindfunclet$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ$22:
  0011c	ff b5 c4 ec ff
	ff		 push	 DWORD PTR $T540362[ebp]
  00122	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00127	59		 pop	 ecx
  00128	c3		 ret	 0
__ehhandler$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ:
  00129	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0012d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00130	8b 8a c0 ec ff
	ff		 mov	 ecx, DWORD PTR [edx-4928]
  00136	33 c8		 xor	 ecx, eax
  00138	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00140	33 c8		 xor	 ecx, eax
  00142	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00147	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ
  0014c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadRoomOptionInfo@ioRoomOptionManager@@QAEXXZ ENDP	; ioRoomOptionManager::LoadRoomOptionInfo
; Function compile flags: /Ogsp
;	COMDAT ??_GioRoomOptionManager@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GioRoomOptionManager@@UAEPAXI@Z PROC			; ioRoomOptionManager::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1ioRoomOptionManager@@UAE@XZ ; ioRoomOptionManager::~ioRoomOptionManager
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 07		 je	 SHORT $LN1@scalar@6
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	59		 pop	 ecx
$LN1@scalar@6:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??_GioRoomOptionManager@@UAEPAXI@Z ENDP			; ioRoomOptionManager::`scalar deleting destructor'
_TEXT	ENDS
END
