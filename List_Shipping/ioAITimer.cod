; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\Lost Saga For Developer\Youtube\Tutorial\Source\src\LSClient\ioAITimer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?StartTimer@ioAITimer@@QAEXI@Z			; ioAITimer::StartTimer
EXTRN	__imp_?GetLoopSec@ioFrameTimer@@QBEKXZ:PROC
EXTRN	__imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ:PROC
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioaitimer.cpp
;	COMDAT ?StartTimer@ioAITimer@@QAEXI@Z
_TEXT	SEGMENT
_newDuration$ = 8					; size = 4
?StartTimer@ioAITimer@@QAEXI@Z PROC			; ioAITimer::StartTimer, COMDAT
; _this$ = ecx

; 5    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 6    : 	m_nStartTimeStamp = FRAMEGETTIME();

  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  0000c	8b c8		 mov	 ecx, eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ
  00014	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 7    : 	
; 8    : 	if( newDuration != 0 )

  00017	8b 45 08	 mov	 eax, DWORD PTR _newDuration$[ebp]
  0001a	85 c0		 test	 eax, eax
  0001c	74 03		 je	 SHORT $LN1@StartTimer

; 9    : 		m_nDuration = newDuration;

  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN1@StartTimer:
  00021	5e		 pop	 esi

; 10   : 
; 11   : #ifdef _DEBUG_AI_TIMER_
; 12   : 	LOG.PrintTimeAndLog( 0, "Timer started at %u with duration %u", m_nStartTimeStamp, m_nDuration );
; 13   : #endif
; 14   : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?StartTimer@ioAITimer@@QAEXI@Z ENDP			; ioAITimer::StartTimer
_TEXT	ENDS
PUBLIC	?StartTimerOnce@ioAITimer@@QAEXI@Z		; ioAITimer::StartTimerOnce
; Function compile flags: /Ogsp
;	COMDAT ?StartTimerOnce@ioAITimer@@QAEXI@Z
_TEXT	SEGMENT
_newDuration$ = 8					; size = 4
?StartTimerOnce@ioAITimer@@QAEXI@Z PROC			; ioAITimer::StartTimerOnce, COMDAT
; _this$ = ecx

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 18   : 	if( newDuration != 0 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _newDuration$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	85 c0		 test	 eax, eax
  0000b	74 03		 je	 SHORT $LN2@StartTimer@2

; 19   : 		m_nDuration = newDuration;

  0000d	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN2@StartTimer@2:

; 20   : 
; 21   : 	if( m_nDuration > 0 && m_nStartTimeStamp == 0 )

  00010	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00014	76 17		 jbe	 SHORT $LN5@StartTimer@2
  00016	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  0001a	75 11		 jne	 SHORT $LN5@StartTimer@2

; 22   : 	{
; 23   : 		StartTimer();

  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  00022	8b c8		 mov	 ecx, eax
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ
  0002a	89 46 08	 mov	 DWORD PTR [esi+8], eax
$LN5@StartTimer@2:
  0002d	5e		 pop	 esi

; 24   : 	}
; 25   : }

  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
?StartTimerOnce@ioAITimer@@QAEXI@Z ENDP			; ioAITimer::StartTimerOnce
_TEXT	ENDS
PUBLIC	?HasTimeoutOccured@ioAITimer@@QAE_NXZ		; ioAITimer::HasTimeoutOccured
; Function compile flags: /Ogsp
;	COMDAT ?HasTimeoutOccured@ioAITimer@@QAE_NXZ
_TEXT	SEGMENT
?HasTimeoutOccured@ioAITimer@@QAE_NXZ PROC		; ioAITimer::HasTimeoutOccured, COMDAT
; _this$ = ecx

; 28   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 29   : 	bool bRet = (	( m_nDuration > 0 ) &&
; 30   : 				( m_nStartTimeStamp != 0 ) &&
; 31   : 				( FRAMEGETTIME() - m_nStartTimeStamp > m_nDuration ));

  00003	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00007	76 20		 jbe	 SHORT $LN3@HasTimeout
  00009	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  0000d	74 1a		 je	 SHORT $LN3@HasTimeout
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  00015	8b c8		 mov	 ecx, eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ
  0001d	2b 46 08	 sub	 eax, DWORD PTR [esi+8]
  00020	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00023	76 04		 jbe	 SHORT $LN3@HasTimeout
  00025	b0 01		 mov	 al, 1
  00027	5e		 pop	 esi

; 32   : 
; 33   : #ifdef _DEBUG_AI_TIMER_
; 34   : 	if( bRet )
; 35   : 		LOG.PrintTimeAndLog( 0, "Time over detected at %u, started at %u with duration %u", 
; 36   : 									FRAMEGETTIME(), m_nStartTimeStamp, m_nDuration );
; 37   : #endif
; 38   : 
; 39   : 	return bRet;
; 40   : }

  00028	c3		 ret	 0
$LN3@HasTimeout:

; 29   : 	bool bRet = (	( m_nDuration > 0 ) &&
; 30   : 				( m_nStartTimeStamp != 0 ) &&
; 31   : 				( FRAMEGETTIME() - m_nStartTimeStamp > m_nDuration ));

  00029	32 c0		 xor	 al, al
  0002b	5e		 pop	 esi

; 32   : 
; 33   : #ifdef _DEBUG_AI_TIMER_
; 34   : 	if( bRet )
; 35   : 		LOG.PrintTimeAndLog( 0, "Time over detected at %u, started at %u with duration %u", 
; 36   : 									FRAMEGETTIME(), m_nStartTimeStamp, m_nDuration );
; 37   : #endif
; 38   : 
; 39   : 	return bRet;
; 40   : }

  0002c	c3		 ret	 0
?HasTimeoutOccured@ioAITimer@@QAE_NXZ ENDP		; ioAITimer::HasTimeoutOccured
_TEXT	ENDS
PUBLIC	?StopTimer@ioAITimer@@QAEXXZ			; ioAITimer::StopTimer
; Function compile flags: /Ogsp
;	COMDAT ?StopTimer@ioAITimer@@QAEXXZ
_TEXT	SEGMENT
?StopTimer@ioAITimer@@QAEXXZ PROC			; ioAITimer::StopTimer, COMDAT
; _this$ = ecx

; 44   : #ifdef _DEBUG_AI_TIMER_
; 45   : 	LOG.PrintTimeAndLog( 0, "Timer stopped at %u", FRAMEGETTIME() );
; 46   : #endif
; 47   : 
; 48   : 	m_nStartTimeStamp = 0;

  00000	83 61 08 00	 and	 DWORD PTR [ecx+8], 0

; 49   : 	m_nDuration = 0;

  00004	83 61 04 00	 and	 DWORD PTR [ecx+4], 0

; 50   : }

  00008	c3		 ret	 0
?StopTimer@ioAITimer@@QAEXXZ ENDP			; ioAITimer::StopTimer
_TEXT	ENDS
END
