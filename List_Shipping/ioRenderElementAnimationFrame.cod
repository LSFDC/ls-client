; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\Lost Saga For Developer\Youtube\Tutorial\Source\src\LSClient\GUI\ioRenderElementAnimationFrame.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??0ElementInfo@ioRenderElementAnimationFrame@@QAE@PAVioUIRenderElement@@@Z ; ioRenderElementAnimationFrame::ElementInfo::ElementInfo
EXTRN	__fltused:DWORD
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\iorenderelementanimationframe.h
;	COMDAT ??0ElementInfo@ioRenderElementAnimationFrame@@QAE@PAVioUIRenderElement@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
??0ElementInfo@ioRenderElementAnimationFrame@@QAE@PAVioUIRenderElement@@@Z PROC ; ioRenderElementAnimationFrame::ElementInfo::ElementInfo, COMDAT
; _this$ = ecx

; 33   : 		ElementInfo( ioUIRenderElement* element ) 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	0f 57 c0	 xorps	 xmm0, xmm0
  00006	8b c1		 mov	 eax, ecx
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _element$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx
  0000d	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??0ElementInfo@ioRenderElementAnimationFrame@@QAE@PAVioUIRenderElement@@@Z ENDP ; ioRenderElementAnimationFrame::ElementInfo::ElementInfo
_TEXT	ENDS
PUBLIC	?return1@@YAIXZ					; return1
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stdafx.h
;	COMDAT ?return1@@YAIXZ
_TEXT	SEGMENT
?return1@@YAIXZ PROC					; return1, COMDAT

; 17   : 	__forceinline unsigned int return1() { __asm mov eax, 1 };

  00000	b8 01 00 00 00	 mov	 eax, 1
  00005	c3		 ret	 0
?return1@@YAIXZ ENDP					; return1
_TEXT	ENDS
PUBLIC	?OnBegin@ioRenderElementAnimationFrame@@UAEXXZ	; ioRenderElementAnimationFrame::OnBegin
EXTRN	__imp_?GetLoopSec@ioFrameTimer@@QBEKXZ:PROC
EXTRN	__imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ:PROC
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\iorenderelementanimationframe.cpp
;	COMDAT ?OnBegin@ioRenderElementAnimationFrame@@UAEXXZ
_TEXT	SEGMENT
?OnBegin@ioRenderElementAnimationFrame@@UAEXXZ PROC	; ioRenderElementAnimationFrame::OnBegin, COMDAT
; _this$ = ecx

; 90   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 91   : 	m_lastupdatetime = FRAMEGETTIME();

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  00009	8b c8		 mov	 ecx, eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ
  00011	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00014	5e		 pop	 esi

; 92   : }

  00015	c3		 ret	 0
?OnBegin@ioRenderElementAnimationFrame@@UAEXXZ ENDP	; ioRenderElementAnimationFrame::OnBegin
_TEXT	ENDS
PUBLIC	?return1000@@YAIXZ				; return1000
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stdafx.h
;	COMDAT ?return1000@@YAIXZ
_TEXT	SEGMENT
?return1000@@YAIXZ PROC					; return1000, COMDAT

; 29   : 	__forceinline unsigned int return1000() { __asm mov eax, 1000 };

  00000	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  00005	c3		 ret	 0
?return1000@@YAIXZ ENDP					; return1000
_TEXT	ENDS
PUBLIC	?Update@ioRenderElementAnimationFrameEmpty@@UAE_NXZ ; ioRenderElementAnimationFrameEmpty::Update
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\iorenderelementanimationframe.cpp
;	COMDAT ?Update@ioRenderElementAnimationFrameEmpty@@UAE_NXZ
_TEXT	SEGMENT
?Update@ioRenderElementAnimationFrameEmpty@@UAE_NXZ PROC ; ioRenderElementAnimationFrameEmpty::Update, COMDAT
; _this$ = ecx

; 128  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 129  : 	DWORD dt = FRAMEGETTIME() - m_lastupdatetime;

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  00009	8b c8		 mov	 ecx, eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ
  00011	2b 46 14	 sub	 eax, DWORD PTR [esi+20]

; 130  : 	m_acctime += dt;

  00014	01 46 1c	 add	 DWORD PTR [esi+28], eax
  00017	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]

; 131  : 	return ( m_acctime >= m_targettime );

  0001a	3b 46 18	 cmp	 eax, DWORD PTR [esi+24]
  0001d	5e		 pop	 esi
  0001e	1b c0		 sbb	 eax, eax
  00020	40		 inc	 eax

; 132  : }

  00021	c3		 ret	 0
?Update@ioRenderElementAnimationFrameEmpty@@UAE_NXZ ENDP ; ioRenderElementAnimationFrameEmpty::Update
_TEXT	ENDS
PUBLIC	?OnBegin@ioRenderElementAnimationFrameEmpty@@UAEXXZ ; ioRenderElementAnimationFrameEmpty::OnBegin
; Function compile flags: /Ogsp
;	COMDAT ?OnBegin@ioRenderElementAnimationFrameEmpty@@UAEXXZ
_TEXT	SEGMENT
?OnBegin@ioRenderElementAnimationFrameEmpty@@UAEXXZ PROC ; ioRenderElementAnimationFrameEmpty::OnBegin, COMDAT
; _this$ = ecx

; 139  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 140  : 	ioRenderElementAnimationFrame::OnBegin();

  00003	e8 00 00 00 00	 call	 ?OnBegin@ioRenderElementAnimationFrame@@UAEXXZ ; ioRenderElementAnimationFrame::OnBegin

; 141  : 
; 142  : 	m_acctime = 0;

  00008	83 66 1c 00	 and	 DWORD PTR [esi+28], 0
  0000c	5e		 pop	 esi

; 143  : }

  0000d	c3		 ret	 0
?OnBegin@ioRenderElementAnimationFrameEmpty@@UAEXXZ ENDP ; ioRenderElementAnimationFrameEmpty::OnBegin
_TEXT	ENDS
PUBLIC	_fabsf
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv129 = 8						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 395  :         {return ((float)fabs((double)_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	d9 e1		 fabs
  00008	d9 5d 08	 fstp	 DWORD PTR tv129[ebp]
  0000b	d9 45 08	 fld	 DWORD PTR tv129[ebp]
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
_fabsf	ENDP
_TEXT	ENDS
PUBLIC	_sqrtf
EXTRN	__CIsqrt:PROC
; Function compile flags: /Ogsp
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv69 = 8						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 434  :         {return ((float)sqrt((double)_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	e8 00 00 00 00	 call	 __CIsqrt
  0000b	d9 5d 08	 fstp	 DWORD PTR tv69[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv69[ebp]
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	??A?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@QBEABQAVioUIRenderElement@@I@Z ; std::vector<ioUIRenderElement *,std::allocator<ioUIRenderElement *> >::operator[]
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??A?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@QBEABQAVioUIRenderElement@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@QBEABQAVioUIRenderElement@@I@Z PROC ; std::vector<ioUIRenderElement *,std::allocator<ioUIRenderElement *> >::operator[], COMDAT
; _this$ = ecx

; 912  : 		{	// subscript nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 913  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 914  : 		if (size() <= _Pos)
; 915  : 			{	// report error
; 916  : 			_DEBUG_ERROR("vector subscript out of range");
; 917  : 			_SCL_SECURE_OUT_OF_RANGE;
; 918  : 			}
; 919  : 
; 920  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 921  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 922  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 923  : 
; 924  : 		return (*(this->_Myfirst + _Pos));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pos$[ebp]
  00008	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 925  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@QBEABQAVioUIRenderElement@@I@Z ENDP ; std::vector<ioUIRenderElement *,std::allocator<ioUIRenderElement *> >::operator[]
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
  00010	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00016	8b c6		 mov	 eax, esi
  00018	5e		 pop	 esi
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?empty@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QBE_NXZ ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::empty
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?empty@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QBE_NXZ PROC ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::empty, COMDAT
; _this$ = ecx

; 889  : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00005	f7 d8		 neg	 eax
  00007	1b c0		 sbb	 eax, eax
  00009	40		 inc	 eax

; 890  : 		}

  0000a	c3		 ret	 0
?empty@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QBE_NXZ ENDP ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::empty
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogsp
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1exception@std@@UAE@XZ
  00012	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00016	74 07		 je	 SHORT $LN1@scalar
  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001e	59		 pop	 ecx
$LN1@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??A?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAEAAUD3DXVECTOR2@@I@Z ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::operator[]
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??A?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAEAAUD3DXVECTOR2@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAEAAUD3DXVECTOR2@@I@Z PROC ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pos$[ebp]
  00008	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]

; 941  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAEAAUD3DXVECTOR2@@I@Z ENDP ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::operator[]
_TEXT	ENDS
PUBLIC	?_Inside@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IBE_NPBUElementInfo@ioRenderElementAnimationFrame@@@Z ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Inside
; Function compile flags: /Ogsp
;	COMDAT ?_Inside@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IBE_NPBUElementInfo@ioRenderElementAnimationFrame@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IBE_NPBUElementInfo@ioRenderElementAnimationFrame@@@Z PROC ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 09		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 05		 ja	 SHORT $LN3@Inside
  0000f	33 c0		 xor	 eax, eax
  00011	40		 inc	 eax
  00012	eb 02		 jmp	 SHORT $LN4@Inside
$LN3@Inside:
  00014	33 c0		 xor	 eax, eax
$LN4@Inside:

; 1287 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?_Inside@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IBE_NPBUElementInfo@ioRenderElementAnimationFrame@@@Z ENDP ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Inside
_TEXT	ENDS
PUBLIC	?_Orphan_range@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IBEXPAUElementInfo@ioRenderElementAnimationFrame@@0@Z ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Orphan_range
; Function compile flags: /Ogsp
;	COMDAT ?_Orphan_range@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IBEXPAUElementInfo@ioRenderElementAnimationFrame@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IBEXPAUElementInfo@ioRenderElementAnimationFrame@@0@Z PROC ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1454 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IBEXPAUElementInfo@ioRenderElementAnimationFrame@@0@Z ENDP ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 56   : 	{	// construct array with placement at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : 	return (_Where);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 58   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogsp
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 62   : 	}

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAE@XZ ; std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::~_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??1?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::~_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::~_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@QAE@XZ ; std::allocator<ioRenderElementAnimationFrame::ElementInfo>::allocator<ioRenderElementAnimationFrame::ElementInfo>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@QAE@XZ PROC ; std::allocator<ioRenderElementAnimationFrame::ElementInfo>::allocator<ioRenderElementAnimationFrame::ElementInfo>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@QAE@XZ ENDP ; std::allocator<ioRenderElementAnimationFrame::ElementInfo>::allocator<ioRenderElementAnimationFrame::ElementInfo>
_TEXT	ENDS
PUBLIC	?size@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QBEIXZ ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::size
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?size@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QBEIXZ PROC ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 880  : 		}

  00008	c3		 ret	 0
?size@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QBEIXZ ENDP ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::size
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@XZ ; std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::~_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::~_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::~_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UD3DXVECTOR2@@@std@@QAE@XZ	; std::allocator<D3DXVECTOR2>::allocator<D3DXVECTOR2>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UD3DXVECTOR2@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UD3DXVECTOR2@@@std@@QAE@XZ PROC		; std::allocator<D3DXVECTOR2>::allocator<D3DXVECTOR2>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@UD3DXVECTOR2@@@std@@QAE@XZ ENDP		; std::allocator<D3DXVECTOR2>::allocator<D3DXVECTOR2>
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QBEABUElementInfo@ioRenderElementAnimationFrame@@XZ ; std::_Vector_const_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::operator*
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QBEABUElementInfo@ioRenderElementAnimationFrame@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QBEABUElementInfo@ioRenderElementAnimationFrame@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::operator*, COMDAT
; _this$ = ecx

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);
; 83   : 
; 84   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 85   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QBEABUElementInfo@ioRenderElementAnimationFrame@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::operator++
; Function compile flags: /Ogsp
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::operator++, COMDAT
; _this$ = ecx

; 93   : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

  00002	83 00 08	 add	 DWORD PTR [eax], 8

; 111  : 		return (*this);
; 112  : 		}

  00005	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::operator++
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QBEIXZ ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::capacity
; Function compile flags: /Ogsp
;	COMDAT ?capacity@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QBEIXZ PROC ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::capacity, COMDAT
; _this$ = ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 778  : 		}

  00008	c3		 ret	 0
?capacity@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QBEIXZ ENDP ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::capacity
_TEXT	ENDS
PUBLIC	?size@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QBEIXZ ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::size
; Function compile flags: /Ogsp
;	COMDAT ?size@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QBEIXZ PROC ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 880  : 		}

  00008	c3		 ret	 0
?size@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QBEIXZ ENDP ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::size
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IBEXXZ ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Xlen
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IBEXXZ PROC ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Xlen, COMDAT
; _this$ = ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
  0000b	cc		 int	 3
?_Xlen@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IBEXXZ ENDP ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Xlen
_TEXT	ENDS
PUBLIC	??0?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@QAE@ABV01@@Z ; std::allocator<ioRenderElementAnimationFrame::ElementInfo>::allocator<ioRenderElementAnimationFrame::ElementInfo>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@QAE@ABV01@@Z PROC ; std::allocator<ioRenderElementAnimationFrame::ElementInfo>::allocator<ioRenderElementAnimationFrame::ElementInfo>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<ioRenderElementAnimationFrame::ElementInfo>::allocator<ioRenderElementAnimationFrame::ElementInfo>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@QAEXPAUElementInfo@ioRenderElementAnimationFrame@@I@Z ; std::allocator<ioRenderElementAnimationFrame::ElementInfo>::deallocate
; Function compile flags: /Ogsp
;	COMDAT ?deallocate@?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@QAEXPAUElementInfo@ioRenderElementAnimationFrame@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@QAEXPAUElementInfo@ioRenderElementAnimationFrame@@I@Z PROC ; std::allocator<ioRenderElementAnimationFrame::ElementInfo>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 183  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
?deallocate@?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@QAEXPAUElementInfo@ioRenderElementAnimationFrame@@I@Z ENDP ; std::allocator<ioRenderElementAnimationFrame::ElementInfo>::deallocate
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QBEIXZ ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::capacity
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QBEIXZ PROC ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::capacity, COMDAT
; _this$ = ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 778  : 		}

  00008	c3		 ret	 0
?capacity@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QBEIXZ ENDP ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::capacity
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IBEXXZ ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Xlen
; Function compile flags: /Ogsp
;	COMDAT ?_Xlen@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IBEXXZ PROC ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Xlen, COMDAT
; _this$ = ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen@2:
$LN3@Xlen@2:
  0000b	cc		 int	 3
?_Xlen@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IBEXXZ ENDP ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Xlen
_TEXT	ENDS
PUBLIC	?_Orphan_range@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IBEXPAUD3DXVECTOR2@@0@Z ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Orphan_range
; Function compile flags: /Ogsp
;	COMDAT ?_Orphan_range@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IBEXPAUD3DXVECTOR2@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IBEXPAUD3DXVECTOR2@@0@Z PROC ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1454 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IBEXPAUD3DXVECTOR2@@0@Z ENDP ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??0?$allocator@UD3DXVECTOR2@@@std@@QAE@ABV01@@Z	; std::allocator<D3DXVECTOR2>::allocator<D3DXVECTOR2>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UD3DXVECTOR2@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UD3DXVECTOR2@@@std@@QAE@ABV01@@Z PROC	; std::allocator<D3DXVECTOR2>::allocator<D3DXVECTOR2>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@UD3DXVECTOR2@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<D3DXVECTOR2>::allocator<D3DXVECTOR2>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UD3DXVECTOR2@@@std@@QAEXPAUD3DXVECTOR2@@I@Z ; std::allocator<D3DXVECTOR2>::deallocate
; Function compile flags: /Ogsp
;	COMDAT ?deallocate@?$allocator@UD3DXVECTOR2@@@std@@QAEXPAUD3DXVECTOR2@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UD3DXVECTOR2@@@std@@QAEXPAUD3DXVECTOR2@@I@Z PROC ; std::allocator<D3DXVECTOR2>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 183  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
?deallocate@?$allocator@UD3DXVECTOR2@@@std@@QAEXPAUD3DXVECTOR2@@I@Z ENDP ; std::allocator<D3DXVECTOR2>::deallocate
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::_Compat
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::_Compat, COMDAT
; _this$ = ecx

; 253  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::_Compat
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@QBEIXZ ; std::allocator<ioRenderElementAnimationFrame::ElementInfo>::max_size
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@QBEIXZ PROC ; std::allocator<ioRenderElementAnimationFrame::ElementInfo>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@QBEIXZ ENDP ; std::allocator<ioRenderElementAnimationFrame::ElementInfo>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UD3DXVECTOR2@@@std@@QBEIXZ ; std::allocator<D3DXVECTOR2>::max_size
; Function compile flags: /Ogsp
;	COMDAT ?max_size@?$allocator@UD3DXVECTOR2@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UD3DXVECTOR2@@@std@@QBEIXZ PROC	; std::allocator<D3DXVECTOR2>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UD3DXVECTOR2@@@std@@QBEIXZ ENDP	; std::allocator<D3DXVECTOR2>::max_size
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >::operator+=
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >::operator+=, COMDAT
; _this$ = ecx

; 151  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 		if (this->_Getcont() == 0
; 154  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 155  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 156  : 			{	// report error
; 157  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 158  : 			_SCL_SECURE_OUT_OF_RANGE;
; 159  : 			}
; 160  : 
; 161  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 162  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 163  : 		_SCL_SECURE_VALIDATE_RANGE(
; 164  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 165  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 166  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 167  : 
; 168  : 		_Ptr += _Off;

  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00008	c1 e1 03	 shl	 ecx, 3
  0000b	01 08		 add	 DWORD PTR [eax], ecx

; 169  : 		return (*this);
; 170  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??Y?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >::operator+=
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >::_Compat
; Function compile flags: /Ogsp
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >::_Compat, COMDAT
; _this$ = ecx

; 253  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >::_Compat
_TEXT	ENDS
PUBLIC	??$min@M@std@@YAABMABM0@Z			; std::min<float>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$min@M@std@@YAABMABM0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@M@std@@YAABMABM0@Z PROC				; std::min<float>, COMDAT

; 2094 : 	{	// return smaller of _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2095 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00009	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0000d	f3 0f 10 09	 movss	 xmm1, DWORD PTR [ecx]
  00011	0f 5a c0	 cvtps2pd xmm0, xmm0
  00014	0f 5a c9	 cvtps2pd xmm1, xmm1
  00017	66 0f 2f c8	 comisd	 xmm1, xmm0
  0001b	0f 46 c1	 cmovbe	 eax, ecx

; 2096 : 	}

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$min@M@std@@YAABMABM0@Z ENDP				; std::min<float>
_TEXT	ENDS
PUBLIC	??$addressof@UElementInfo@ioRenderElementAnimationFrame@@@std@@YAPAUElementInfo@ioRenderElementAnimationFrame@@AAU12@@Z ; std::addressof<ioRenderElementAnimationFrame::ElementInfo>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$addressof@UElementInfo@ioRenderElementAnimationFrame@@@std@@YAPAUElementInfo@ioRenderElementAnimationFrame@@AAU12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@UElementInfo@ioRenderElementAnimationFrame@@@std@@YAPAUElementInfo@ioRenderElementAnimationFrame@@AAU12@@Z PROC ; std::addressof<ioRenderElementAnimationFrame::ElementInfo>, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@UElementInfo@ioRenderElementAnimationFrame@@@std@@YAPAUElementInfo@ioRenderElementAnimationFrame@@AAU12@@Z ENDP ; std::addressof<ioRenderElementAnimationFrame::ElementInfo>
_TEXT	ENDS
PUBLIC	??$forward@UElementInfo@ioRenderElementAnimationFrame@@@std@@YA$$QAUElementInfo@ioRenderElementAnimationFrame@@AAU12@@Z ; std::forward<ioRenderElementAnimationFrame::ElementInfo>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@UElementInfo@ioRenderElementAnimationFrame@@@std@@YA$$QAUElementInfo@ioRenderElementAnimationFrame@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UElementInfo@ioRenderElementAnimationFrame@@@std@@YA$$QAUElementInfo@ioRenderElementAnimationFrame@@AAU12@@Z PROC ; std::forward<ioRenderElementAnimationFrame::ElementInfo>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@UElementInfo@ioRenderElementAnimationFrame@@@std@@YA$$QAUElementInfo@ioRenderElementAnimationFrame@@AAU12@@Z ENDP ; std::forward<ioRenderElementAnimationFrame::ElementInfo>
_TEXT	ENDS
PUBLIC	??$addressof@$$CBUD3DXVECTOR2@@@std@@YAPBUD3DXVECTOR2@@ABU1@@Z ; std::addressof<D3DXVECTOR2 const >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$addressof@$$CBUD3DXVECTOR2@@@std@@YAPBUD3DXVECTOR2@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUD3DXVECTOR2@@@std@@YAPBUD3DXVECTOR2@@ABU1@@Z PROC ; std::addressof<D3DXVECTOR2 const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBUD3DXVECTOR2@@@std@@YAPBUD3DXVECTOR2@@ABU1@@Z ENDP ; std::addressof<D3DXVECTOR2 const >
_TEXT	ENDS
PUBLIC	??$addressof@UD3DXVECTOR2@@@std@@YAPAUD3DXVECTOR2@@AAU1@@Z ; std::addressof<D3DXVECTOR2>
; Function compile flags: /Ogsp
;	COMDAT ??$addressof@UD3DXVECTOR2@@@std@@YAPAUD3DXVECTOR2@@AAU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@UD3DXVECTOR2@@@std@@YAPAUD3DXVECTOR2@@AAU1@@Z PROC ; std::addressof<D3DXVECTOR2>, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@UD3DXVECTOR2@@@std@@YAPAUD3DXVECTOR2@@AAU1@@Z ENDP ; std::addressof<D3DXVECTOR2>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@UD3DXVECTOR2@@@std@@YAPAUD3DXVECTOR2@@IPAU1@@Z ; std::_Allocate<D3DXVECTOR2>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@UD3DXVECTOR2@@@std@@YAPAUD3DXVECTOR2@@IPAU1@@Z
_TEXT	SEGMENT
$T508113 = -12						; size = 12
$T508118 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UD3DXVECTOR2@@@std@@YAPAUD3DXVECTOR2@@IPAU1@@Z PROC ; std::_Allocate<D3DXVECTOR2>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 3e		 je	 SHORT $LN5@Allocate

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  00015	77 10		 ja	 SHORT $LN1@Allocate
  00017	8b c1		 mov	 eax, ecx
  00019	c1 e0 03	 shl	 eax, 3
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	59		 pop	 ecx
  00023	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00025	75 26		 jne	 SHORT $LN5@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00027	83 65 08 00	 and	 DWORD PTR $T508118[ebp], 0
  0002b	8d 45 08	 lea	 eax, DWORD PTR $T508118[ebp]
  0002e	50		 push	 eax
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T508113[ebp]
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
  00038	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003d	8d 45 f4	 lea	 eax, DWORD PTR $T508113[ebp]
  00040	50		 push	 eax
  00041	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T508113[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00048	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate:
$LN5@Allocate:

; 40   : 	}

  0004d	c9		 leave
  0004e	c3		 ret	 0
$LN9@Allocate:
??$_Allocate@UD3DXVECTOR2@@@std@@YAPAUD3DXVECTOR2@@IPAU1@@Z ENDP ; std::_Allocate<D3DXVECTOR2>
_TEXT	ENDS
PUBLIC	??$_Allocate@UElementInfo@ioRenderElementAnimationFrame@@@std@@YAPAUElementInfo@ioRenderElementAnimationFrame@@IPAU12@@Z ; std::_Allocate<ioRenderElementAnimationFrame::ElementInfo>
; Function compile flags: /Ogsp
;	COMDAT ??$_Allocate@UElementInfo@ioRenderElementAnimationFrame@@@std@@YAPAUElementInfo@ioRenderElementAnimationFrame@@IPAU12@@Z
_TEXT	SEGMENT
$T508123 = -12						; size = 12
$T508127 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UElementInfo@ioRenderElementAnimationFrame@@@std@@YAPAUElementInfo@ioRenderElementAnimationFrame@@IPAU12@@Z PROC ; std::_Allocate<ioRenderElementAnimationFrame::ElementInfo>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 3e		 je	 SHORT $LN5@Allocate@2

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  00015	77 10		 ja	 SHORT $LN1@Allocate@2
  00017	8b c1		 mov	 eax, ecx
  00019	c1 e0 03	 shl	 eax, 3
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	59		 pop	 ecx
  00023	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00025	75 26		 jne	 SHORT $LN5@Allocate@2
$LN1@Allocate@2:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00027	83 65 08 00	 and	 DWORD PTR $T508127[ebp], 0
  0002b	8d 45 08	 lea	 eax, DWORD PTR $T508127[ebp]
  0002e	50		 push	 eax
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T508123[ebp]
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
  00038	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003d	8d 45 f4	 lea	 eax, DWORD PTR $T508123[ebp]
  00040	50		 push	 eax
  00041	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T508123[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00048	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate@2:
$LN5@Allocate@2:

; 40   : 	}

  0004d	c9		 leave
  0004e	c3		 ret	 0
$LN9@Allocate@2:
??$_Allocate@UElementInfo@ioRenderElementAnimationFrame@@@std@@YAPAUElementInfo@ioRenderElementAnimationFrame@@IPAU12@@Z ENDP ; std::_Allocate<ioRenderElementAnimationFrame::ElementInfo>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@QAEXPAUElementInfo@ioRenderElementAnimationFrame@@$$QAU34@@Z ; std::allocator<ioRenderElementAnimationFrame::ElementInfo>::construct
; Function compile flags: /Ogsp
;	COMDAT ?construct@?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@QAEXPAUElementInfo@ioRenderElementAnimationFrame@@$$QAU34@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@QAEXPAUElementInfo@ioRenderElementAnimationFrame@@$$QAU34@@Z PROC ; std::allocator<ioRenderElementAnimationFrame::ElementInfo>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN3@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@construct:

; 203  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
?construct@?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@QAEXPAUElementInfo@ioRenderElementAnimationFrame@@$$QAU34@@Z ENDP ; std::allocator<ioRenderElementAnimationFrame::ElementInfo>::construct
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@UD3DXVECTOR2@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUD3DXVECTOR2@@0@Z ; std::_Ptr_cat<D3DXVECTOR2,D3DXVECTOR2>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@UD3DXVECTOR2@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUD3DXVECTOR2@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UD3DXVECTOR2@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUD3DXVECTOR2@@0@Z PROC ; std::_Ptr_cat<D3DXVECTOR2,D3DXVECTOR2>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	c9		 leave
  00008	c3		 ret	 0
??$_Ptr_cat@UD3DXVECTOR2@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUD3DXVECTOR2@@0@Z ENDP ; std::_Ptr_cat<D3DXVECTOR2,D3DXVECTOR2>
_TEXT	ENDS
PUBLIC	??$_Unchecked@PAUD3DXVECTOR2@@@std@@YAPAUD3DXVECTOR2@@PAU1@@Z ; std::_Unchecked<D3DXVECTOR2 *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Unchecked@PAUD3DXVECTOR2@@@std@@YAPAUD3DXVECTOR2@@PAU1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAUD3DXVECTOR2@@@std@@YAPAUD3DXVECTOR2@@PAU1@@Z PROC ; std::_Unchecked<D3DXVECTOR2 *>, COMDAT

; 266  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 267  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 268  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAUD3DXVECTOR2@@@std@@YAPAUD3DXVECTOR2@@PAU1@@Z ENDP ; std::_Unchecked<D3DXVECTOR2 *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAUD3DXVECTOR2@@U1@@std@@YAXPAUD3DXVECTOR2@@0ABU1@@Z ; std::_Fill<D3DXVECTOR2 *,D3DXVECTOR2>
; Function compile flags: /Ogsp
;	COMDAT ??$_Fill@PAUD3DXVECTOR2@@U1@@std@@YAXPAUD3DXVECTOR2@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUD3DXVECTOR2@@U1@@std@@YAXPAUD3DXVECTOR2@@0ABU1@@Z PROC ; std::_Fill<D3DXVECTOR2 *,D3DXVECTOR2>, COMDAT

; 2690 : 	{	// copy _Val through [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2691 : 	for (; _First != _Last; ++_First)

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00009	74 15		 je	 SHORT $LN1@Fill
  0000b	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
$LL3@Fill:

; 2692 : 		*_First = _Val;

  0000e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00010	89 10		 mov	 DWORD PTR [eax], edx
  00012	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00015	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00018	83 c0 08	 add	 eax, 8
  0001b	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001e	75 ee		 jne	 SHORT $LL3@Fill
$LN1@Fill:

; 2693 : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Fill@PAUD3DXVECTOR2@@U1@@std@@YAXPAUD3DXVECTOR2@@0ABU1@@Z ENDP ; std::_Fill<D3DXVECTOR2 *,D3DXVECTOR2>
_TEXT	ENDS
PUBLIC	??$_Copy_backward@PAUD3DXVECTOR2@@PAU1@@std@@YAPAUD3DXVECTOR2@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward<D3DXVECTOR2 *,D3DXVECTOR2 *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Copy_backward@PAUD3DXVECTOR2@@PAU1@@std@@YAPAUD3DXVECTOR2@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward@PAUD3DXVECTOR2@@PAU1@@std@@YAPAUD3DXVECTOR2@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Copy_backward<D3DXVECTOR2 *,D3DXVECTOR2 *>, COMDAT

; 2438 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2439 : 	while (_First != _Last)

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00009	39 4d 08	 cmp	 DWORD PTR __First$[ebp], ecx
  0000c	74 15		 je	 SHORT $LN1@Copy_backw
$LL2@Copy_backw:

; 2440 : 		*--_Dest = *--_Last;

  0000e	83 e9 08	 sub	 ecx, 8
  00011	8b 11		 mov	 edx, DWORD PTR [ecx]
  00013	83 e8 08	 sub	 eax, 8
  00016	89 10		 mov	 DWORD PTR [eax], edx
  00018	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0001e	3b 4d 08	 cmp	 ecx, DWORD PTR __First$[ebp]
  00021	75 eb		 jne	 SHORT $LL2@Copy_backw
$LN1@Copy_backw:

; 2441 : 	return (_Dest);
; 2442 : 	}

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$_Copy_backward@PAUD3DXVECTOR2@@PAU1@@std@@YAPAUD3DXVECTOR2@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward<D3DXVECTOR2 *,D3DXVECTOR2 *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@UElementInfo@ioRenderElementAnimationFrame@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUElementInfo@ioRenderElementAnimationFrame@@0@Z ; std::_Ptr_cat<ioRenderElementAnimationFrame::ElementInfo,ioRenderElementAnimationFrame::ElementInfo>
; Function compile flags: /Ogsp
;	COMDAT ??$_Ptr_cat@UElementInfo@ioRenderElementAnimationFrame@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUElementInfo@ioRenderElementAnimationFrame@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UElementInfo@ioRenderElementAnimationFrame@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUElementInfo@ioRenderElementAnimationFrame@@0@Z PROC ; std::_Ptr_cat<ioRenderElementAnimationFrame::ElementInfo,ioRenderElementAnimationFrame::ElementInfo>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	c9		 leave
  00008	c3		 ret	 0
??$_Ptr_cat@UElementInfo@ioRenderElementAnimationFrame@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUElementInfo@ioRenderElementAnimationFrame@@0@Z ENDP ; std::_Ptr_cat<ioRenderElementAnimationFrame::ElementInfo,ioRenderElementAnimationFrame::ElementInfo>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUD3DXVECTOR2@@@std@@YAPAUD3DXVECTOR2@@PAU1@@Z ; std::_Val_type<D3DXVECTOR2 *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Val_type@PAUD3DXVECTOR2@@@std@@YAPAUD3DXVECTOR2@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUD3DXVECTOR2@@@std@@YAPAUD3DXVECTOR2@@PAU1@@Z PROC ; std::_Val_type<D3DXVECTOR2 *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAUD3DXVECTOR2@@@std@@YAPAUD3DXVECTOR2@@PAU1@@Z ENDP ; std::_Val_type<D3DXVECTOR2 *>
_TEXT	ENDS
PUBLIC	??$move@AAUD3DXVECTOR2@@@std@@YA$$QAUD3DXVECTOR2@@AAU1@@Z ; std::move<D3DXVECTOR2 &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAUD3DXVECTOR2@@@std@@YA$$QAUD3DXVECTOR2@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUD3DXVECTOR2@@@std@@YA$$QAUD3DXVECTOR2@@AAU1@@Z PROC ; std::move<D3DXVECTOR2 &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAUD3DXVECTOR2@@@std@@YA$$QAUD3DXVECTOR2@@AAU1@@Z ENDP ; std::move<D3DXVECTOR2 &>
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 49   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUElementInfo@ioRenderElementAnimationFrame@@@std@@YAPAUElementInfo@ioRenderElementAnimationFrame@@PAU12@@Z ; std::_Val_type<ioRenderElementAnimationFrame::ElementInfo *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Val_type@PAUElementInfo@ioRenderElementAnimationFrame@@@std@@YAPAUElementInfo@ioRenderElementAnimationFrame@@PAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUElementInfo@ioRenderElementAnimationFrame@@@std@@YAPAUElementInfo@ioRenderElementAnimationFrame@@PAU12@@Z PROC ; std::_Val_type<ioRenderElementAnimationFrame::ElementInfo *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAUElementInfo@ioRenderElementAnimationFrame@@@std@@YAPAUElementInfo@ioRenderElementAnimationFrame@@PAU12@@Z ENDP ; std::_Val_type<ioRenderElementAnimationFrame::ElementInfo *>
_TEXT	ENDS
PUBLIC	??$forward@ABUD3DXVECTOR2@@@std@@YAABUD3DXVECTOR2@@ABU1@@Z ; std::forward<D3DXVECTOR2 const &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABUD3DXVECTOR2@@@std@@YAABUD3DXVECTOR2@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUD3DXVECTOR2@@@std@@YAABUD3DXVECTOR2@@ABU1@@Z PROC ; std::forward<D3DXVECTOR2 const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUD3DXVECTOR2@@@std@@YAABUD3DXVECTOR2@@ABU1@@Z ENDP ; std::forward<D3DXVECTOR2 const &>
_TEXT	ENDS
PUBLIC	??$_Destroy@UElementInfo@ioRenderElementAnimationFrame@@@std@@YAXPAUElementInfo@ioRenderElementAnimationFrame@@@Z ; std::_Destroy<ioRenderElementAnimationFrame::ElementInfo>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy@UElementInfo@ioRenderElementAnimationFrame@@@std@@YAXPAUElementInfo@ioRenderElementAnimationFrame@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UElementInfo@ioRenderElementAnimationFrame@@@std@@YAXPAUElementInfo@ioRenderElementAnimationFrame@@@Z PROC ; std::_Destroy<ioRenderElementAnimationFrame::ElementInfo>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@UElementInfo@ioRenderElementAnimationFrame@@@std@@YAXPAUElementInfo@ioRenderElementAnimationFrame@@@Z ENDP ; std::_Destroy<ioRenderElementAnimationFrame::ElementInfo>
_TEXT	ENDS
PUBLIC	??$_Construct@UD3DXVECTOR2@@ABU1@@std@@YAXPAUD3DXVECTOR2@@ABU1@@Z ; std::_Construct<D3DXVECTOR2,D3DXVECTOR2 const &>
; Function compile flags: /Ogsp
;	COMDAT ??$_Construct@UD3DXVECTOR2@@ABU1@@std@@YAXPAUD3DXVECTOR2@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UD3DXVECTOR2@@ABU1@@std@@YAXPAUD3DXVECTOR2@@ABU1@@Z PROC ; std::_Construct<D3DXVECTOR2,D3DXVECTOR2 const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN3@Construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@Construct:

; 49   : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Construct@UD3DXVECTOR2@@ABU1@@std@@YAXPAUD3DXVECTOR2@@ABU1@@Z ENDP ; std::_Construct<D3DXVECTOR2,D3DXVECTOR2 const &>
_TEXT	ENDS
PUBLIC	??$_Destroy@UD3DXVECTOR2@@@std@@YAXPAUD3DXVECTOR2@@@Z ; std::_Destroy<D3DXVECTOR2>
; Function compile flags: /Ogsp
;	COMDAT ??$_Destroy@UD3DXVECTOR2@@@std@@YAXPAUD3DXVECTOR2@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UD3DXVECTOR2@@@std@@YAXPAUD3DXVECTOR2@@@Z PROC ; std::_Destroy<D3DXVECTOR2>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@UD3DXVECTOR2@@@std@@YAXPAUD3DXVECTOR2@@@Z ENDP ; std::_Destroy<D3DXVECTOR2>
_TEXT	ENDS
PUBLIC	??$forward@UD3DXVECTOR2@@@std@@YA$$QAUD3DXVECTOR2@@AAU1@@Z ; std::forward<D3DXVECTOR2>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@UD3DXVECTOR2@@@std@@YA$$QAUD3DXVECTOR2@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UD3DXVECTOR2@@@std@@YA$$QAUD3DXVECTOR2@@AAU1@@Z PROC ; std::forward<D3DXVECTOR2>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@UD3DXVECTOR2@@@std@@YA$$QAUD3DXVECTOR2@@AAU1@@Z ENDP ; std::forward<D3DXVECTOR2>
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR2@@QAE@MM@Z			; D3DXVECTOR2::D3DXVECTOR2
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx9math.inl
;	COMDAT ??0D3DXVECTOR2@@QAE@MM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
??0D3DXVECTOR2@@QAE@MM@Z PROC				; D3DXVECTOR2::D3DXVECTOR2, COMDAT
; _this$ = ecx

; 89   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     x = fx;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00008	8b c1		 mov	 eax, ecx
  0000a	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 91   :     y = fy;

  0000e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00013	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 92   : }

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
??0D3DXVECTOR2@@QAE@MM@Z ENDP				; D3DXVECTOR2::D3DXVECTOR2
_TEXT	ENDS
PUBLIC	??GD3DXVECTOR2@@QBE?AU0@ABU0@@Z			; D3DXVECTOR2::operator-
; Function compile flags: /Ogsp
;	COMDAT ??GD3DXVECTOR2@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??GD3DXVECTOR2@@QBE?AU0@ABU0@@Z PROC			; D3DXVECTOR2::operator-, COMDAT
; _this$ = ecx

; 167  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 168  :     return D3DXVECTOR2(x - v.x, y - v.y);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00006	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0000a	f3 0f 10 0a	 movss	 xmm1, DWORD PTR [edx]
  0000e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00011	0f 5a c0	 cvtps2pd xmm0, xmm0
  00014	0f 5a c9	 cvtps2pd xmm1, xmm1
  00017	f2 0f 5c c1	 subsd	 xmm0, xmm1
  0001b	f3 0f 10 4a 04	 movss	 xmm1, DWORD PTR [edx+4]
  00020	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00024	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00028	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0002d	0f 5a c0	 cvtps2pd xmm0, xmm0
  00030	0f 5a c9	 cvtps2pd xmm1, xmm1
  00033	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00037	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0003b	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 169  : }

  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
??GD3DXVECTOR2@@QBE?AU0@ABU0@@Z ENDP			; D3DXVECTOR2::operator-
_TEXT	ENDS
PUBLIC	??DD3DXVECTOR2@@QBE?AU0@M@Z			; D3DXVECTOR2::operator*
; Function compile flags: /Ogsp
;	COMDAT ??DD3DXVECTOR2@@QBE?AU0@M@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_f$ = 12						; size = 4
??DD3DXVECTOR2@@QBE?AU0@M@Z PROC			; D3DXVECTOR2::operator*, COMDAT
; _this$ = ecx

; 173  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 174  :     return D3DXVECTOR2(x * f, y * f);

  00003	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _f$[ebp]
  00008	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000f	0f 5a c0	 cvtps2pd xmm0, xmm0
  00012	0f 5a c9	 cvtps2pd xmm1, xmm1
  00015	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00019	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _f$[ebp]
  0001e	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00022	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00026	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0002b	0f 5a c0	 cvtps2pd xmm0, xmm0
  0002e	0f 5a c9	 cvtps2pd xmm1, xmm1
  00031	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00035	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00039	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 175  : }

  0003e	5d		 pop	 ebp
  0003f	c2 08 00	 ret	 8
??DD3DXVECTOR2@@QBE?AU0@M@Z ENDP			; D3DXVECTOR2::operator*
_TEXT	ENDS
PUBLIC	?D3DXVec2Length@@YAMPBUD3DXVECTOR2@@@Z		; D3DXVec2Length
; Function compile flags: /Ogsp
;	COMDAT ?D3DXVec2Length@@YAMPBUD3DXVECTOR2@@@Z
_TEXT	SEGMENT
tv166 = 8						; size = 4
tv94 = 8						; size = 4
_pV$ = 8						; size = 4
?D3DXVec2Length@@YAMPBUD3DXVECTOR2@@@Z PROC		; D3DXVec2Length, COMDAT

; 1578 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1579 : #ifdef D3DX_DEBUG
; 1580 :     if(!pV)
; 1581 :         return 0.0f;
; 1582 : #endif
; 1583 : 
; 1584 : #ifdef __cplusplus
; 1585 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pV$[ebp]
  00006	d9 40 04	 fld	 DWORD PTR [eax+4]
  00009	d9 00		 fld	 DWORD PTR [eax]
  0000b	d9 c0		 fld	 ST(0)
  0000d	de c9		 fmulp	 ST(1), ST(0)
  0000f	d9 c1		 fld	 ST(1)
  00011	de ca		 fmulp	 ST(2), ST(0)
  00013	de c1		 faddp	 ST(1), ST(0)
  00015	d9 5d 08	 fstp	 DWORD PTR tv166[ebp]
  00018	d9 45 08	 fld	 DWORD PTR tv166[ebp]
  0001b	e8 00 00 00 00	 call	 __CIsqrt
  00020	d9 5d 08	 fstp	 DWORD PTR tv94[ebp]
  00023	d9 45 08	 fld	 DWORD PTR tv94[ebp]

; 1586 : #else
; 1587 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1588 : #endif
; 1589 : }

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?D3DXVec2Length@@YAMPBUD3DXVECTOR2@@@Z ENDP		; D3DXVec2Length
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@QBEIXZ ; std::vector<ioUIRenderElement *,std::allocator<ioUIRenderElement *> >::size
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?size@?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@QBEIXZ PROC ; std::vector<ioUIRenderElement *,std::allocator<ioUIRenderElement *> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 880  : 		}

  00008	c3		 ret	 0
?size@?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@QBEIXZ ENDP ; std::vector<ioUIRenderElement *,std::allocator<ioUIRenderElement *> >::size
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
; Function compile flags: /Ogsp
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	__real@4f800000
PUBLIC	__real@38d1b717
PUBLIC	__real@00000000
PUBLIC	?UpdateElement@ioRenderElementAnimationFrameScale@@MAE_NKAAUElementInfo@ioRenderElementAnimationFrame@@H@Z ; ioRenderElementAnimationFrameScale::UpdateElement
EXTRN	_D3DXVec2Normalize@8:PROC
EXTRN	__imp_?IsEqual@ioMath@@SA_NABUD3DXVECTOR2@@0M@Z:PROC
;	COMDAT __real@4f800000
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx9math.inl
CONST	SEGMENT
__real@4f800000 DD 04f800000r			; 4.29497e+009
CONST	ENDS
;	COMDAT __real@38d1b717
CONST	SEGMENT
__real@38d1b717 DD 038d1b717r			; 0.0001
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\iorenderelementanimationframe.cpp
CONST	ENDS
;	COMDAT ?UpdateElement@ioRenderElementAnimationFrameScale@@MAE_NKAAUElementInfo@ioRenderElementAnimationFrame@@H@Z
_TEXT	SEGMENT
$T508224 = -24						; size = 8
$T508222 = -24						; size = 8
_curscale$ = -16					; size = 8
_vec$ = -8						; size = 8
$T508223 = 8						; size = 4
_dt$ = 8						; size = 4
tv348 = 12						; size = 4
tv342 = 12						; size = 4
tv338 = 12						; size = 4
tv334 = 12						; size = 4
_distance$ = 12						; size = 4
_tickspeed$ = 12					; size = 4
_info$ = 12						; size = 4
_index$ = 16						; size = 4
?UpdateElement@ioRenderElementAnimationFrameScale@@MAE_NKAAUElementInfo@ioRenderElementAnimationFrame@@H@Z PROC ; ioRenderElementAnimationFrameScale::UpdateElement, COMDAT
; _this$ = ecx

; 179  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi

; 180  : 	if ( info.m_speed == 0.0f ) 

  00007	8b 75 0c	 mov	 esi, DWORD PTR _info$[ebp]
  0000a	f3 0f 10 46 04	 movss	 xmm0, DWORD PTR [esi+4]
  0000f	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00016	9f		 lahf
  00017	57		 push	 edi
  00018	8b f9		 mov	 edi, ecx

; 181  : 	{
; 182  : 		info.m_element->SetXScale( m_targetscale.x );

  0001a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0001c	f6 c4 44	 test	 ah, 68			; 00000044H
  0001f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00021	7a 27		 jp	 SHORT $LN2@UpdateElem
  00023	f3 0f 10 47 1c	 movss	 xmm0, DWORD PTR [edi+28]
  00028	51		 push	 ecx
  00029	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0002e	ff 50 20	 call	 DWORD PTR [eax+32]

; 183  : 		info.m_element->SetYScale( m_targetscale.y );

  00031	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00033	f3 0f 10 47 20	 movss	 xmm0, DWORD PTR [edi+32]
  00038	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003a	51		 push	 ecx
  0003b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00040	ff 50 24	 call	 DWORD PTR [eax+36]
$LN30@UpdateElem:

; 184  : 		return true;

  00043	b0 01		 mov	 al, 1
  00045	e9 a9 01 00 00	 jmp	 $LN3@UpdateElem
$LN2@UpdateElem:

; 185  : 	}
; 186  : 
; 187  : 	D3DXVECTOR2 curscale = info.m_element->GetScale();

  0004a	8d 55 f0	 lea	 edx, DWORD PTR _curscale$[ebp]
  0004d	52		 push	 edx
  0004e	ff 50 38	 call	 DWORD PTR [eax+56]

; 188  : 	D3DXVECTOR2 vec = m_targetscale - curscale;

  00051	f3 0f 10 47 1c	 movss	 xmm0, DWORD PTR [edi+28]
  00056	f3 0f 10 4d f0	 movss	 xmm1, DWORD PTR _curscale$[ebp]
  0005b	0f 5a c0	 cvtps2pd xmm0, xmm0
  0005e	0f 5a c9	 cvtps2pd xmm1, xmm1
  00061	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00065	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR _curscale$[ebp+4]
  0006a	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0006e	f3 0f 11 45 f8	 movss	 DWORD PTR _vec$[ebp], xmm0
  00073	f3 0f 10 47 20	 movss	 xmm0, DWORD PTR [edi+32]
  00078	0f 5a c0	 cvtps2pd xmm0, xmm0
  0007b	0f 5a c9	 cvtps2pd xmm1, xmm1
  0007e	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00082	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00086	f3 0f 11 45 fc	 movss	 DWORD PTR _vec$[ebp+4], xmm0

; 189  : 	if ( ioMath::IsEqual( vec, D3DXVECTOR2( 0.0f, 0.0f ) ) ) {			

  0008b	0f 57 c0	 xorps	 xmm0, xmm0
  0008e	51		 push	 ecx
  0008f	f3 0f 11 45 e8	 movss	 DWORD PTR $T508222[ebp], xmm0
  00094	f3 0f 11 45 ec	 movss	 DWORD PTR $T508222[ebp+4], xmm0
  00099	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@38d1b717
  000a1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a6	8d 45 e8	 lea	 eax, DWORD PTR $T508222[ebp]
  000a9	50		 push	 eax
  000aa	8d 45 f8	 lea	 eax, DWORD PTR _vec$[ebp]
  000ad	50		 push	 eax
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEqual@ioMath@@SA_NABUD3DXVECTOR2@@0M@Z
  000b4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b7	84 c0		 test	 al, al

; 190  : 		return true;

  000b9	75 88		 jne	 SHORT $LN30@UpdateElem

; 191  : 	}	
; 192  : 
; 193  : 	float tickspeed = info.m_speed * ( dt * FLOAT0001 );

  000bb	b8 01 00 00 00	 mov	 eax, 1
  000c0	8b c8		 mov	 ecx, eax
  000c2	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  000c7	89 4d 0c	 mov	 DWORD PTR tv348[ebp], ecx
  000ca	db 45 0c	 fild	 DWORD PTR tv348[ebp]
  000cd	85 c9		 test	 ecx, ecx
  000cf	79 06		 jns	 SHORT $LN27@UpdateElem
  000d1	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN27@UpdateElem:
  000d7	89 45 0c	 mov	 DWORD PTR tv342[ebp], eax
  000da	db 45 0c	 fild	 DWORD PTR tv342[ebp]
  000dd	85 c0		 test	 eax, eax
  000df	79 06		 jns	 SHORT $LN28@UpdateElem
  000e1	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN28@UpdateElem:
  000e7	de f9		 fdivp	 ST(1), ST(0)
  000e9	8b 45 08	 mov	 eax, DWORD PTR _dt$[ebp]
  000ec	d9 5d 0c	 fstp	 DWORD PTR tv338[ebp]
  000ef	d9 45 0c	 fld	 DWORD PTR tv338[ebp]
  000f2	db 45 08	 fild	 DWORD PTR _dt$[ebp]
  000f5	85 c0		 test	 eax, eax
  000f7	79 06		 jns	 SHORT $LN29@UpdateElem
  000f9	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN29@UpdateElem:
  000ff	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _vec$[ebp+4]
  00104	de c9		 fmulp	 ST(1), ST(0)

; 194  : 	float distance = std::min<float>( D3DXVec2Length( &vec ), tickspeed );

  00106	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _vec$[ebp]
  0010b	0f 5a c0	 cvtps2pd xmm0, xmm0
  0010e	d8 4e 04	 fmul	 DWORD PTR [esi+4]
  00111	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  00115	0f 5a c9	 cvtps2pd xmm1, xmm1
  00118	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  0011c	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00120	d9 5d 0c	 fstp	 DWORD PTR _tickspeed$[ebp]
  00123	0f 57 c0	 xorps	 xmm0, xmm0
  00126	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  0012a	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _tickspeed$[ebp]
  0012f	0f 5a c0	 cvtps2pd xmm0, xmm0
  00132	f2 0f 51 c0	 sqrtsd	 xmm0, xmm0
  00136	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0013a	f3 0f 11 45 08	 movss	 DWORD PTR $T508223[ebp], xmm0
  0013f	0f 5a c9	 cvtps2pd xmm1, xmm1
  00142	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00146	66 0f 2f c1	 comisd	 xmm0, xmm1
  0014a	8d 45 0c	 lea	 eax, DWORD PTR _tickspeed$[ebp]
  0014d	77 03		 ja	 SHORT $LN22@UpdateElem
  0014f	8d 45 08	 lea	 eax, DWORD PTR $T508223[ebp]
$LN22@UpdateElem:
  00152	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]

; 195  : 	D3DXVec2Normalize( &vec, &vec );

  00156	8d 45 f8	 lea	 eax, DWORD PTR _vec$[ebp]
  00159	50		 push	 eax
  0015a	50		 push	 eax
  0015b	f3 0f 11 45 0c	 movss	 DWORD PTR _distance$[ebp], xmm0
  00160	e8 00 00 00 00	 call	 _D3DXVec2Normalize@8

; 196  : 	vec = vec * distance;

  00165	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _vec$[ebp]
  0016a	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _distance$[ebp]
  0016f	f3 0f 10 55 0c	 movss	 xmm2, DWORD PTR _distance$[ebp]

; 197  : 
; 198  : 	info.m_element->SetXScale( curscale.x + vec.x );

  00174	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00176	0f 5a c9	 cvtps2pd xmm1, xmm1
  00179	0f 5a c0	 cvtps2pd xmm0, xmm0
  0017c	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00180	f3 0f 10 4d fc	 movss	 xmm1, DWORD PTR _vec$[ebp+4]
  00185	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00189	f3 0f 11 45 e8	 movss	 DWORD PTR $T508224[ebp], xmm0
  0018e	8b 45 e8	 mov	 eax, DWORD PTR $T508224[ebp]
  00191	0f 5a c9	 cvtps2pd xmm1, xmm1
  00194	0f 5a d2	 cvtps2pd xmm2, xmm2
  00197	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  0019b	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  0019f	f3 0f 11 4d ec	 movss	 DWORD PTR $T508224[ebp+4], xmm1
  001a4	f3 0f 10 4d f0	 movss	 xmm1, DWORD PTR _curscale$[ebp]
  001a9	89 45 f8	 mov	 DWORD PTR _vec$[ebp], eax
  001ac	8b 45 ec	 mov	 eax, DWORD PTR $T508224[ebp+4]
  001af	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  001b3	0f 5a c9	 cvtps2pd xmm1, xmm1
  001b6	89 45 fc	 mov	 DWORD PTR _vec$[ebp+4], eax
  001b9	8b 01		 mov	 eax, DWORD PTR [ecx]
  001bb	f2 0f 58 c1	 addsd	 xmm0, xmm1
  001bf	51		 push	 ecx
  001c0	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  001c4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001c9	ff 50 20	 call	 DWORD PTR [eax+32]

; 199  : 	info.m_element->SetYScale( curscale.y + vec.y );

  001cc	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001ce	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _vec$[ebp+4]
  001d3	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR _curscale$[ebp+4]
  001d8	8b 01		 mov	 eax, DWORD PTR [ecx]
  001da	0f 5a c0	 cvtps2pd xmm0, xmm0
  001dd	0f 5a c9	 cvtps2pd xmm1, xmm1
  001e0	f2 0f 58 c1	 addsd	 xmm0, xmm1
  001e4	51		 push	 ecx
  001e5	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  001e9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ee	ff 50 24	 call	 DWORD PTR [eax+36]

; 200  : 	return false;

  001f1	32 c0		 xor	 al, al
$LN3@UpdateElem:
  001f3	5f		 pop	 edi
  001f4	5e		 pop	 esi

; 201  : }

  001f5	c9		 leave
  001f6	c2 0c 00	 ret	 12			; 0000000cH
?UpdateElement@ioRenderElementAnimationFrameScale@@MAE_NKAAUElementInfo@ioRenderElementAnimationFrame@@H@Z ENDP ; ioRenderElementAnimationFrameScale::UpdateElement
_TEXT	ENDS
PUBLIC	__mask@@AbsDouble@
PUBLIC	__real@3f1a36e2e0000000
PUBLIC	?UpdateElement@ioRenderElementAnimationFrameAlpha@@MAE_NKAAUElementInfo@ioRenderElementAnimationFrame@@H@Z ; ioRenderElementAnimationFrameAlpha::UpdateElement
;	COMDAT __mask@@AbsDouble@
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stdafx.h
CONST	SEGMENT
__mask@@AbsDouble@ DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH, 0ffH
	DB	0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __real@3f1a36e2e0000000
CONST	SEGMENT
__real@3f1a36e2e0000000 DQ 03f1a36e2e0000000r	; 0.0001
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\iorenderelementanimationframe.cpp
CONST	ENDS
;	COMDAT ?UpdateElement@ioRenderElementAnimationFrameAlpha@@MAE_NKAAUElementInfo@ioRenderElementAnimationFrame@@H@Z
_TEXT	SEGMENT
$T508286 = 8						; size = 4
_dt$ = 8						; size = 4
tv258 = 12						; size = 4
tv254 = 12						; size = 4
tv248 = 12						; size = 4
tv244 = 12						; size = 4
tv230 = 12						; size = 4
tv225 = 12						; size = 4
tv166 = 12						; size = 4
$T508285 = 12						; size = 4
_speed$ = 12						; size = 4
_info$ = 12						; size = 4
_index$ = 16						; size = 4
?UpdateElement@ioRenderElementAnimationFrameAlpha@@MAE_NKAAUElementInfo@ioRenderElementAnimationFrame@@H@Z PROC ; ioRenderElementAnimationFrameAlpha::UpdateElement, COMDAT
; _this$ = ecx

; 278  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 279  : 	if ( info.m_speed == 0.0f ) 

  00004	8b 75 0c	 mov	 esi, DWORD PTR _info$[ebp]
  00007	f3 0f 10 46 04	 movss	 xmm0, DWORD PTR [esi+4]
  0000c	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00013	9f		 lahf
  00014	57		 push	 edi
  00015	8b f9		 mov	 edi, ecx

; 280  : 	{
; 281  : 		info.m_element->SetAlpha( m_targetalpha );

  00017	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00019	f6 c4 44	 test	 ah, 68			; 00000044H
  0001c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001e	7a 13		 jp	 SHORT $LN2@UpdateElem@2
  00020	f3 0f 2c 57 1c	 cvttss2si edx, DWORD PTR [edi+28]
  00025	0f b6 d2	 movzx	 edx, dl
  00028	52		 push	 edx
  00029	ff 50 30	 call	 DWORD PTR [eax+48]
$LN30@UpdateElem@2:

; 282  : 		return true;

  0002c	b0 01		 mov	 al, 1
  0002e	e9 30 01 00 00	 jmp	 $LN3@UpdateElem@2
$LN2@UpdateElem@2:

; 283  : 	}
; 284  : 
; 285  : 	float curalpha = info.m_element->GetAlpha();

  00033	ff 50 3c	 call	 DWORD PTR [eax+60]

; 286  : 	float dist = m_targetalpha - curalpha;

  00036	f3 0f 10 47 1c	 movss	 xmm0, DWORD PTR [edi+28]

; 287  : 	if ( fabsf( dist ) < ALMOST_ZERO ) {

  0003b	f2 0f 10 25 00
	00 00 00	 movsd	 xmm4, QWORD PTR __real@3f1a36e2e0000000
  00043	0f b6 c0	 movzx	 eax, al
  00046	0f 57 db	 xorps	 xmm3, xmm3
  00049	0f 5a c0	 cvtps2pd xmm0, xmm0
  0004c	f3 0f 2a d8	 cvtsi2ss xmm3, eax
  00050	0f 5a cb	 cvtps2pd xmm1, xmm3
  00053	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00057	0f 57 c9	 xorps	 xmm1, xmm1
  0005a	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0005e	f3 0f 5a c8	 cvtss2sd xmm1, xmm0
  00062	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __mask@@AbsDouble@
  0006a	66 0f 54 c8	 andpd	 xmm1, xmm0
  0006e	f2 0f 5a c9	 cvtsd2ss xmm1, xmm1
  00072	0f 57 d2	 xorps	 xmm2, xmm2
  00075	f3 0f 5a d1	 cvtss2sd xmm2, xmm1
  00079	66 0f 2f e2	 comisd	 xmm4, xmm2

; 288  : 		return true;

  0007d	77 ad		 ja	 SHORT $LN30@UpdateElem@2

; 289  : 	}
; 290  : 
; 291  : 	float speed = info.m_speed * ( dt * FLOAT0001 );

  0007f	b8 01 00 00 00	 mov	 eax, 1
  00084	8b c8		 mov	 ecx, eax
  00086	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  0008b	89 4d 0c	 mov	 DWORD PTR tv258[ebp], ecx
  0008e	db 45 0c	 fild	 DWORD PTR tv258[ebp]
  00091	85 c9		 test	 ecx, ecx
  00093	79 06		 jns	 SHORT $LN25@UpdateElem@2
  00095	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN25@UpdateElem@2:
  0009b	89 45 0c	 mov	 DWORD PTR tv254[ebp], eax
  0009e	db 45 0c	 fild	 DWORD PTR tv254[ebp]
  000a1	85 c0		 test	 eax, eax
  000a3	79 06		 jns	 SHORT $LN26@UpdateElem@2
  000a5	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN26@UpdateElem@2:
  000ab	de f9		 fdivp	 ST(1), ST(0)
  000ad	8b 45 08	 mov	 eax, DWORD PTR _dt$[ebp]
  000b0	d9 5d 0c	 fstp	 DWORD PTR tv248[ebp]
  000b3	d9 45 0c	 fld	 DWORD PTR tv248[ebp]
  000b6	db 45 08	 fild	 DWORD PTR _dt$[ebp]
  000b9	85 c0		 test	 eax, eax
  000bb	79 06		 jns	 SHORT $LN27@UpdateElem@2
  000bd	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN27@UpdateElem@2:
  000c3	de c9		 fmulp	 ST(1), ST(0)

; 292  : 	float distance = std::min<float>( fabsf( dist ), fabsf( speed ) );

  000c5	8d 45 0c	 lea	 eax, DWORD PTR $T508285[ebp]
  000c8	d8 4e 04	 fmul	 DWORD PTR [esi+4]
  000cb	d9 5d 0c	 fstp	 DWORD PTR _speed$[ebp]
  000ce	f3 0f 10 65 0c	 movss	 xmm4, DWORD PTR _speed$[ebp]
  000d3	0f 5a d4	 cvtps2pd xmm2, xmm4
  000d6	66 0f 54 d0	 andpd	 xmm2, xmm0
  000da	0f 28 c1	 movaps	 xmm0, xmm1
  000dd	f2 0f 5a d2	 cvtsd2ss xmm2, xmm2
  000e1	f3 0f 11 45 08	 movss	 DWORD PTR $T508286[ebp], xmm0
  000e6	0f 57 c9	 xorps	 xmm1, xmm1
  000e9	f3 0f 5a ca	 cvtss2sd xmm1, xmm2
  000ed	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  000f1	66 0f 2f c1	 comisd	 xmm0, xmm1
  000f5	f3 0f 11 55 0c	 movss	 DWORD PTR $T508285[ebp], xmm2
  000fa	77 03		 ja	 SHORT $LN20@UpdateElem@2
  000fc	8d 45 08	 lea	 eax, DWORD PTR $T508286[ebp]
$LN20@UpdateElem@2:

; 293  : 	info.m_element->SetAlpha( curalpha + ( distance * ( ( speed < 0.0f ) ? -FLOAT1 : FLOAT1 ) ) );

  000ff	0f 57 c9	 xorps	 xmm1, xmm1
  00102	0f 2f cc	 comiss	 xmm1, xmm4
  00105	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00109	76 19		 jbe	 SHORT $LN5@UpdateElem@2
  0010b	b8 01 00 00 00	 mov	 eax, 1
  00110	89 45 0c	 mov	 DWORD PTR tv230[ebp], eax
  00113	db 45 0c	 fild	 DWORD PTR tv230[ebp]
  00116	85 c0		 test	 eax, eax
  00118	79 06		 jns	 SHORT $LN28@UpdateElem@2
  0011a	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN28@UpdateElem@2:
  00120	d9 e0		 fchs
  00122	eb 15		 jmp	 SHORT $LN29@UpdateElem@2
$LN5@UpdateElem@2:
  00124	b8 01 00 00 00	 mov	 eax, 1
  00129	89 45 0c	 mov	 DWORD PTR tv225[ebp], eax
  0012c	db 45 0c	 fild	 DWORD PTR tv225[ebp]
  0012f	85 c0		 test	 eax, eax
  00131	79 06		 jns	 SHORT $LN29@UpdateElem@2
  00133	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN29@UpdateElem@2:
  00139	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0013b	d9 5d 0c	 fstp	 DWORD PTR tv166[ebp]
  0013e	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR tv166[ebp]
  00143	8b 01		 mov	 eax, DWORD PTR [ecx]
  00145	0f 5a c0	 cvtps2pd xmm0, xmm0
  00148	0f 5a c9	 cvtps2pd xmm1, xmm1
  0014b	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  0014f	0f 5a c3	 cvtps2pd xmm0, xmm3
  00152	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00156	f2 0f 2c d1	 cvttsd2si edx, xmm1
  0015a	0f b6 d2	 movzx	 edx, dl
  0015d	52		 push	 edx
  0015e	ff 50 30	 call	 DWORD PTR [eax+48]

; 294  : 	return false;

  00161	32 c0		 xor	 al, al
$LN3@UpdateElem@2:
  00163	5f		 pop	 edi
  00164	5e		 pop	 esi

; 295  : }

  00165	5d		 pop	 ebp
  00166	c2 0c 00	 ret	 12			; 0000000cH
?UpdateElement@ioRenderElementAnimationFrameAlpha@@MAE_NKAAUElementInfo@ioRenderElementAnimationFrame@@H@Z ENDP ; ioRenderElementAnimationFrameAlpha::UpdateElement
_TEXT	ENDS
PUBLIC	?UpdateElement@ioRenderElementAnimationFrameSize@@MAE_NKAAUElementInfo@ioRenderElementAnimationFrame@@H@Z ; ioRenderElementAnimationFrameSize::UpdateElement
; Function compile flags: /Ogsp
;	COMDAT ?UpdateElement@ioRenderElementAnimationFrameSize@@MAE_NKAAUElementInfo@ioRenderElementAnimationFrame@@H@Z
_TEXT	SEGMENT
$T508338 = -24						; size = 8
$T508336 = -24						; size = 8
_cursize$ = -16						; size = 8
_vec$ = -8						; size = 8
_dt$ = 8						; size = 4
tv424 = 12						; size = 4
tv420 = 12						; size = 4
tv416 = 12						; size = 4
tv412 = 12						; size = 4
_distance$ = 12						; size = 4
_tickspeed$ = 12					; size = 4
_info$ = 12						; size = 4
$T508337 = 16						; size = 4
_index$ = 16						; size = 4
?UpdateElement@ioRenderElementAnimationFrameSize@@MAE_NKAAUElementInfo@ioRenderElementAnimationFrame@@H@Z PROC ; ioRenderElementAnimationFrameSize::UpdateElement, COMDAT
; _this$ = ecx

; 368  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 369  : 	if ( info.m_speed == 0.0f ) 

  00003	0f 57 c0	 xorps	 xmm0, xmm0
  00006	83 ec 18	 sub	 esp, 24			; 00000018H
  00009	53		 push	 ebx
  0000a	8b 5d 0c	 mov	 ebx, DWORD PTR _info$[ebp]
  0000d	f3 0f 10 4b 04	 movss	 xmm1, DWORD PTR [ebx+4]
  00012	0f 2e c8	 ucomiss xmm1, xmm0
  00015	9f		 lahf
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx
  00019	f6 c4 44	 test	 ah, 68			; 00000044H
  0001c	7a 1c		 jp	 SHORT $LN2@UpdateElem@3

; 370  : 	{
; 371  : 		info.m_element->SetSize( m_targetsize.x, m_targetsize.y );

  0001e	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00020	8b 11		 mov	 edx, DWORD PTR [ecx]
  00022	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]
  00025	f3 0f 2c 76 20	 cvttss2si esi, DWORD PTR [esi+32]
  0002a	f3 0f 2c 00	 cvttss2si eax, DWORD PTR [eax]
  0002e	56		 push	 esi
  0002f	50		 push	 eax
  00030	ff 52 10	 call	 DWORD PTR [edx+16]

; 372  : 		return true;

  00033	b0 01		 mov	 al, 1
  00035	e9 c9 01 00 00	 jmp	 $LN3@UpdateElem@3
$LN2@UpdateElem@3:

; 373  : 	}
; 374  : 
; 375  : 	D3DXVECTOR2 cursize = m_cursizes[ index ];

  0003a	8b 46 24	 mov	 eax, DWORD PTR [esi+36]

; 376  : 	D3DXVECTOR2 vec = m_targetsize - cursize;

  0003d	f3 0f 10 4e 1c	 movss	 xmm1, DWORD PTR [esi+28]
  00042	57		 push	 edi
  00043	8b 7d 10	 mov	 edi, DWORD PTR _index$[ebp]
  00046	8b 0c f8	 mov	 ecx, DWORD PTR [eax+edi*8]
  00049	8b 44 f8 04	 mov	 eax, DWORD PTR [eax+edi*8+4]
  0004d	0f 5a c9	 cvtps2pd xmm1, xmm1
  00050	89 4d f0	 mov	 DWORD PTR _cursize$[ebp], ecx
  00053	f3 0f 10 55 f0	 movss	 xmm2, DWORD PTR _cursize$[ebp]
  00058	0f 5a d2	 cvtps2pd xmm2, xmm2
  0005b	f2 0f 5c ca	 subsd	 xmm1, xmm2
  0005f	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  00063	89 45 f4	 mov	 DWORD PTR _cursize$[ebp+4], eax
  00066	f3 0f 10 55 f4	 movss	 xmm2, DWORD PTR _cursize$[ebp+4]

; 377  : 	if ( ioMath::IsEqual( vec, D3DXVECTOR2( 0.0f, 0.0f ) ) ) {

  0006b	51		 push	 ecx
  0006c	f3 0f 11 4d f8	 movss	 DWORD PTR _vec$[ebp], xmm1
  00071	f3 0f 10 4e 20	 movss	 xmm1, DWORD PTR [esi+32]
  00076	f3 0f 11 45 e8	 movss	 DWORD PTR $T508336[ebp], xmm0
  0007b	f3 0f 11 45 ec	 movss	 DWORD PTR $T508336[ebp+4], xmm0
  00080	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@38d1b717
  00088	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0008d	8d 45 e8	 lea	 eax, DWORD PTR $T508336[ebp]
  00090	50		 push	 eax
  00091	0f 5a c9	 cvtps2pd xmm1, xmm1
  00094	0f 5a d2	 cvtps2pd xmm2, xmm2
  00097	8d 45 f8	 lea	 eax, DWORD PTR _vec$[ebp]
  0009a	f2 0f 5c ca	 subsd	 xmm1, xmm2
  0009e	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  000a2	50		 push	 eax
  000a3	f3 0f 11 4d fc	 movss	 DWORD PTR _vec$[ebp+4], xmm1
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEqual@ioMath@@SA_NABUD3DXVECTOR2@@0M@Z
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b1	84 c0		 test	 al, al
  000b3	74 07		 je	 SHORT $LN1@UpdateElem@3

; 378  : 		return true;

  000b5	b0 01		 mov	 al, 1
  000b7	e9 46 01 00 00	 jmp	 $LN37@UpdateElem@3
$LN1@UpdateElem@3:

; 379  : 	}	
; 380  : 
; 381  : 	float tickspeed = info.m_speed * ( dt * FLOAT0001 );

  000bc	b8 01 00 00 00	 mov	 eax, 1
  000c1	8b c8		 mov	 ecx, eax
  000c3	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  000c8	89 4d 0c	 mov	 DWORD PTR tv424[ebp], ecx
  000cb	db 45 0c	 fild	 DWORD PTR tv424[ebp]
  000ce	85 c9		 test	 ecx, ecx
  000d0	79 06		 jns	 SHORT $LN38@UpdateElem@3
  000d2	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN38@UpdateElem@3:
  000d8	89 45 0c	 mov	 DWORD PTR tv420[ebp], eax
  000db	db 45 0c	 fild	 DWORD PTR tv420[ebp]
  000de	85 c0		 test	 eax, eax
  000e0	79 06		 jns	 SHORT $LN39@UpdateElem@3
  000e2	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN39@UpdateElem@3:
  000e8	de f9		 fdivp	 ST(1), ST(0)
  000ea	8b 45 08	 mov	 eax, DWORD PTR _dt$[ebp]
  000ed	d9 5d 0c	 fstp	 DWORD PTR tv416[ebp]
  000f0	d9 45 0c	 fld	 DWORD PTR tv416[ebp]
  000f3	db 45 08	 fild	 DWORD PTR _dt$[ebp]
  000f6	85 c0		 test	 eax, eax
  000f8	79 06		 jns	 SHORT $LN40@UpdateElem@3
  000fa	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN40@UpdateElem@3:
  00100	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _vec$[ebp+4]
  00105	de c9		 fmulp	 ST(1), ST(0)

; 382  : 	float distance = std::min<float>( D3DXVec2Length( &vec ), tickspeed );

  00107	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _vec$[ebp]
  0010c	0f 5a c0	 cvtps2pd xmm0, xmm0
  0010f	d8 4b 04	 fmul	 DWORD PTR [ebx+4]
  00112	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  00116	0f 5a c9	 cvtps2pd xmm1, xmm1
  00119	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  0011d	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00121	d9 5d 0c	 fstp	 DWORD PTR _tickspeed$[ebp]
  00124	0f 57 c0	 xorps	 xmm0, xmm0
  00127	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  0012b	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _tickspeed$[ebp]
  00130	0f 5a c0	 cvtps2pd xmm0, xmm0
  00133	f2 0f 51 c0	 sqrtsd	 xmm0, xmm0
  00137	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0013b	f3 0f 11 45 10	 movss	 DWORD PTR $T508337[ebp], xmm0
  00140	0f 5a c9	 cvtps2pd xmm1, xmm1
  00143	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00147	66 0f 2f c1	 comisd	 xmm0, xmm1
  0014b	8d 45 0c	 lea	 eax, DWORD PTR _tickspeed$[ebp]
  0014e	77 03		 ja	 SHORT $LN24@UpdateElem@3
  00150	8d 45 10	 lea	 eax, DWORD PTR $T508337[ebp]
$LN24@UpdateElem@3:
  00153	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]

; 383  : 	D3DXVec2Normalize( &vec, &vec );

  00157	8d 45 f8	 lea	 eax, DWORD PTR _vec$[ebp]
  0015a	50		 push	 eax
  0015b	50		 push	 eax
  0015c	f3 0f 11 45 0c	 movss	 DWORD PTR _distance$[ebp], xmm0
  00161	e8 00 00 00 00	 call	 _D3DXVec2Normalize@8

; 384  : 	vec = vec * distance;

  00166	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _vec$[ebp]
  0016b	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _distance$[ebp]
  00170	f3 0f 10 55 0c	 movss	 xmm2, DWORD PTR _distance$[ebp]
  00175	0f 5a c0	 cvtps2pd xmm0, xmm0
  00178	0f 5a c9	 cvtps2pd xmm1, xmm1
  0017b	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  0017f	f3 0f 10 4d fc	 movss	 xmm1, DWORD PTR _vec$[ebp+4]
  00184	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00188	f3 0f 11 45 e8	 movss	 DWORD PTR $T508338[ebp], xmm0
  0018d	8b 45 e8	 mov	 eax, DWORD PTR $T508338[ebp]
  00190	0f 5a c9	 cvtps2pd xmm1, xmm1
  00193	89 45 f8	 mov	 DWORD PTR _vec$[ebp], eax
  00196	0f 5a d2	 cvtps2pd xmm2, xmm2
  00199	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  0019d	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  001a1	f3 0f 11 4d ec	 movss	 DWORD PTR $T508338[ebp+4], xmm1
  001a6	8b 45 ec	 mov	 eax, DWORD PTR $T508338[ebp+4]

; 385  : 
; 386  : 	m_cursizes[ index ].x = cursize.x + vec.x;

  001a9	f3 0f 10 4d f0	 movss	 xmm1, DWORD PTR _cursize$[ebp]
  001ae	89 45 fc	 mov	 DWORD PTR _vec$[ebp+4], eax
  001b1	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  001b4	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  001b8	0f 5a c9	 cvtps2pd xmm1, xmm1
  001bb	f2 0f 58 c1	 addsd	 xmm0, xmm1

; 387  : 	m_cursizes[ index ].y = cursize.y + vec.y;

  001bf	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR _cursize$[ebp+4]
  001c4	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  001c8	f3 0f 11 04 f8	 movss	 DWORD PTR [eax+edi*8], xmm0
  001cd	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _vec$[ebp+4]
  001d2	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  001d5	0f 5a c0	 cvtps2pd xmm0, xmm0
  001d8	0f 5a c9	 cvtps2pd xmm1, xmm1
  001db	f2 0f 58 c1	 addsd	 xmm0, xmm1
  001df	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  001e3	f3 0f 11 44 f8
	04		 movss	 DWORD PTR [eax+edi*8+4], xmm0

; 388  : 	info.m_element->SetSize( m_cursizes[ index ].x, m_cursizes[ index ].y );

  001e9	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  001ec	f3 0f 2c 74 f8
	04		 cvttss2si esi, DWORD PTR [eax+edi*8+4]
  001f2	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  001f4	f3 0f 2c 04 f8	 cvttss2si eax, DWORD PTR [eax+edi*8]
  001f9	8b 11		 mov	 edx, DWORD PTR [ecx]
  001fb	56		 push	 esi
  001fc	50		 push	 eax
  001fd	ff 52 10	 call	 DWORD PTR [edx+16]

; 389  : 	return false;

  00200	32 c0		 xor	 al, al
$LN37@UpdateElem@3:
  00202	5f		 pop	 edi
$LN3@UpdateElem@3:
  00203	5e		 pop	 esi
  00204	5b		 pop	 ebx

; 390  : }

  00205	c9		 leave
  00206	c2 0c 00	 ret	 12			; 0000000cH
?UpdateElement@ioRenderElementAnimationFrameSize@@MAE_NKAAUElementInfo@ioRenderElementAnimationFrame@@H@Z ENDP ; ioRenderElementAnimationFrameSize::UpdateElement
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QBEAAUElementInfo@ioRenderElementAnimationFrame@@XZ ; std::_Vector_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::operator*
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QBEAAUElementInfo@ioRenderElementAnimationFrame@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QBEAAUElementInfo@ioRenderElementAnimationFrame@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::operator*, COMDAT
; _this$ = ecx

; 322  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 323  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QBEAAUElementInfo@ioRenderElementAnimationFrame@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::operator*
_TEXT	ENDS
PUBLIC	??C?$_Vector_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QBEPAUElementInfo@ioRenderElementAnimationFrame@@XZ ; std::_Vector_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::operator->
; Function compile flags: /Ogsp
;	COMDAT ??C?$_Vector_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QBEPAUElementInfo@ioRenderElementAnimationFrame@@XZ
_TEXT	SEGMENT
??C?$_Vector_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QBEPAUElementInfo@ioRenderElementAnimationFrame@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::operator->, COMDAT
; _this$ = ecx

; 327  : 		return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 328  : 		}

  00002	c3		 ret	 0
??C?$_Vector_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QBEPAUElementInfo@ioRenderElementAnimationFrame@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::operator->
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::operator++
; Function compile flags: /Ogsp
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::operator++, COMDAT
; _this$ = ecx

; 331  : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 332  : 		++*(_Mybase *)this;

  00002	83 00 08	 add	 DWORD PTR [eax], 8

; 333  : 		return (*this);
; 334  : 		}

  00005	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::operator++
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAE@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@1@@Z ; std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAE@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAE@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@1@@Z PROC ; std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAE@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@1@@Z ENDP ; std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@V?$allocator@UD3DXVECTOR2@@@1@@Z ; std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@V?$allocator@UD3DXVECTOR2@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@V?$allocator@UD3DXVECTOR2@@@1@@Z PROC ; std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@V?$allocator@UD3DXVECTOR2@@@1@@Z ENDP ; std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::operator==
; Function compile flags: /Ogsp
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	f7 d8		 neg	 eax
  0000c	1b c0		 sbb	 eax, eax
  0000e	40		 inc	 eax

; 204  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::operator==
_TEXT	ENDS
PUBLIC	?max_size@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QBEIXZ ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::max_size
; Function compile flags: /Ogsp
;	COMDAT ?max_size@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QBEIXZ PROC ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QBEIXZ ENDP ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::max_size
_TEXT	ENDS
PUBLIC	?_Grow_to@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IBEII@Z ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Grow_to
; Function compile flags: /Ogsp
;	COMDAT ?_Grow_to@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IBEII@Z PROC ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1275 : 		size_type _Capacity = capacity();

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00008	ba ff ff ff 1f	 mov	 edx, 536870911		; 1fffffffH
  0000d	c1 f8 03	 sar	 eax, 3
  00010	8b c8		 mov	 ecx, eax
  00012	d1 e9		 shr	 ecx, 1
  00014	2b d1		 sub	 edx, ecx
  00016	3b d0		 cmp	 edx, eax
  00018	73 04		 jae	 SHORT $LN4@Grow_to
  0001a	33 c0		 xor	 eax, eax
  0001c	eb 02		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  0001e	03 c1		 add	 eax, ecx
$LN5@Grow_to:

; 1279 : 		if (_Capacity < _Count)

  00020	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]

; 1280 : 			_Capacity = _Count;

  00023	0f 42 45 08	 cmovb	 eax, DWORD PTR __Count$[ebp]

; 1281 : 		return (_Capacity);
; 1282 : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?_Grow_to@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IBEII@Z ENDP ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Grow_to
_TEXT	ENDS
PUBLIC	?max_size@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QBEIXZ ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::max_size
; Function compile flags: /Ogsp
;	COMDAT ?max_size@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QBEIXZ PROC ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QBEIXZ ENDP ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::max_size
_TEXT	ENDS
PUBLIC	?_Grow_to@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IBEII@Z ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Grow_to
; Function compile flags: /Ogsp
;	COMDAT ?_Grow_to@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IBEII@Z PROC ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1275 : 		size_type _Capacity = capacity();

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00008	ba ff ff ff 1f	 mov	 edx, 536870911		; 1fffffffH
  0000d	c1 f8 03	 sar	 eax, 3
  00010	8b c8		 mov	 ecx, eax
  00012	d1 e9		 shr	 ecx, 1
  00014	2b d1		 sub	 edx, ecx
  00016	3b d0		 cmp	 edx, eax
  00018	73 04		 jae	 SHORT $LN4@Grow_to@2
  0001a	33 c0		 xor	 eax, eax
  0001c	eb 02		 jmp	 SHORT $LN5@Grow_to@2
$LN4@Grow_to@2:
  0001e	03 c1		 add	 eax, ecx
$LN5@Grow_to@2:

; 1279 : 		if (_Capacity < _Count)

  00020	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]

; 1280 : 			_Capacity = _Count;

  00023	0f 42 45 08	 cmovb	 eax, DWORD PTR __Count$[ebp]

; 1281 : 		return (_Capacity);
; 1282 : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?_Grow_to@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IBEII@Z ENDP ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Grow_to
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UD3DXVECTOR2@@@std@@QAEPAUD3DXVECTOR2@@I@Z ; std::allocator<D3DXVECTOR2>::allocate
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UD3DXVECTOR2@@@std@@QAEPAUD3DXVECTOR2@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UD3DXVECTOR2@@@std@@QAEPAUD3DXVECTOR2@@I@Z PROC ; std::allocator<D3DXVECTOR2>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	6a 00		 push	 0
  00005	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Allocate@UD3DXVECTOR2@@@std@@YAPAUD3DXVECTOR2@@IPAU1@@Z ; std::_Allocate<D3DXVECTOR2>
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx

; 188  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?allocate@?$allocator@UD3DXVECTOR2@@@std@@QAEPAUD3DXVECTOR2@@I@Z ENDP ; std::allocator<D3DXVECTOR2>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QAE@PAUElementInfo@ioRenderElementAnimationFrame@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::_Vector_const_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QAE@PAUElementInfo@ioRenderElementAnimationFrame@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QAE@PAUElementInfo@ioRenderElementAnimationFrame@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::_Vector_const_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QAE@PAUElementInfo@ioRenderElementAnimationFrame@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::_Vector_const_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >::operator+=
; Function compile flags: /Ogsp
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >::operator+=, COMDAT
; _this$ = ecx

; 357  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 358  : 		*(_Mybase *)this += _Off;

  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00008	c1 e1 03	 shl	 ecx, 3
  0000b	01 08		 add	 DWORD PTR [eax], ecx

; 359  : 		return (*this);
; 360  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??Y?$_Vector_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >::operator+=
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@QAEPAUElementInfo@ioRenderElementAnimationFrame@@I@Z ; std::allocator<ioRenderElementAnimationFrame::ElementInfo>::allocate
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@QAEPAUElementInfo@ioRenderElementAnimationFrame@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@QAEPAUElementInfo@ioRenderElementAnimationFrame@@I@Z PROC ; std::allocator<ioRenderElementAnimationFrame::ElementInfo>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	6a 00		 push	 0
  00005	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Allocate@UElementInfo@ioRenderElementAnimationFrame@@@std@@YAPAUElementInfo@ioRenderElementAnimationFrame@@IPAU12@@Z ; std::_Allocate<ioRenderElementAnimationFrame::ElementInfo>
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx

; 188  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?allocate@?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@QAEPAUElementInfo@ioRenderElementAnimationFrame@@I@Z ENDP ; std::allocator<ioRenderElementAnimationFrame::ElementInfo>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QAE@PAUD3DXVECTOR2@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >::_Vector_const_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QAE@PAUD3DXVECTOR2@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QAE@PAUD3DXVECTOR2@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >::_Vector_const_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QAE@PAUD3DXVECTOR2@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >::_Vector_const_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >::operator==
; Function compile flags: /Ogsp
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	f7 d8		 neg	 eax
  0000c	1b c0		 sbb	 eax, eax
  0000e	40		 inc	 eax

; 204  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >::operator==
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@UElementInfo@ioRenderElementAnimationFrame@@U34@@std@@YAXAAV?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@0@PAUElementInfo@ioRenderElementAnimationFrame@@$$QAU23@@Z ; std::_Cons_val<std::allocator<ioRenderElementAnimationFrame::ElementInfo>,ioRenderElementAnimationFrame::ElementInfo,ioRenderElementAnimationFrame::ElementInfo>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@UElementInfo@ioRenderElementAnimationFrame@@U34@@std@@YAXAAV?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@0@PAUElementInfo@ioRenderElementAnimationFrame@@$$QAU23@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@UElementInfo@ioRenderElementAnimationFrame@@U34@@std@@YAXAAV?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@0@PAUElementInfo@ioRenderElementAnimationFrame@@$$QAU23@@Z PROC ; std::_Cons_val<std::allocator<ioRenderElementAnimationFrame::ElementInfo>,ioRenderElementAnimationFrame::ElementInfo,ioRenderElementAnimationFrame::ElementInfo>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN7@Cons_val
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN7@Cons_val:

; 281  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Cons_val@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@UElementInfo@ioRenderElementAnimationFrame@@U34@@std@@YAXAAV?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@0@PAUElementInfo@ioRenderElementAnimationFrame@@$$QAU23@@Z ENDP ; std::_Cons_val<std::allocator<ioRenderElementAnimationFrame::ElementInfo>,ioRenderElementAnimationFrame::ElementInfo,ioRenderElementAnimationFrame::ElementInfo>
_TEXT	ENDS
PUBLIC	??$fill@PAUD3DXVECTOR2@@U1@@std@@YAXPAUD3DXVECTOR2@@0ABU1@@Z ; std::fill<D3DXVECTOR2 *,D3DXVECTOR2>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$fill@PAUD3DXVECTOR2@@U1@@std@@YAXPAUD3DXVECTOR2@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUD3DXVECTOR2@@U1@@std@@YAXPAUD3DXVECTOR2@@0ABU1@@Z PROC ; std::fill<D3DXVECTOR2 *,D3DXVECTOR2>, COMDAT

; 2713 : 	{	// copy _Val through [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2716 : 	}

  00003	5d		 pop	 ebp

; 2714 : 	_DEBUG_RANGE(_First, _Last);
; 2715 : 	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);

  00004	e9 00 00 00 00	 jmp	 ??$_Fill@PAUD3DXVECTOR2@@U1@@std@@YAXPAUD3DXVECTOR2@@0ABU1@@Z ; std::_Fill<D3DXVECTOR2 *,D3DXVECTOR2>
??$fill@PAUD3DXVECTOR2@@U1@@std@@YAXPAUD3DXVECTOR2@@0ABU1@@Z ENDP ; std::fill<D3DXVECTOR2 *,D3DXVECTOR2>
_TEXT	ENDS
PUBLIC	??$_Copy_backward@PAUD3DXVECTOR2@@PAU1@@std@@YAPAUD3DXVECTOR2@@PAU1@00@Z ; std::_Copy_backward<D3DXVECTOR2 *,D3DXVECTOR2 *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Copy_backward@PAUD3DXVECTOR2@@PAU1@@std@@YAPAUD3DXVECTOR2@@PAU1@00@Z
_TEXT	SEGMENT
__Cat$508583 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_backward@PAUD3DXVECTOR2@@PAU1@@std@@YAPAUD3DXVECTOR2@@PAU1@00@Z PROC ; std::_Copy_backward<D3DXVECTOR2 *,D3DXVECTOR2 *>, COMDAT

; 2459 : 	{	// copy [_First, _Last) backwards to [..., _Dest), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2460 : 	return (_Copy_backward(_First, _Last,
; 2461 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$508583[ebp]
  00007	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Copy_backward@PAUD3DXVECTOR2@@PAU1@@std@@YAPAUD3DXVECTOR2@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward<D3DXVECTOR2 *,D3DXVECTOR2 *>
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 2462 : 	}

  00018	c9		 leave
  00019	c3		 ret	 0
??$_Copy_backward@PAUD3DXVECTOR2@@PAU1@@std@@YAPAUD3DXVECTOR2@@PAU1@00@Z ENDP ; std::_Copy_backward<D3DXVECTOR2 *,D3DXVECTOR2 *>
_TEXT	ENDS
PUBLIC	??$_Move@PAUD3DXVECTOR2@@PAU1@@std@@YAPAUD3DXVECTOR2@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<D3DXVECTOR2 *,D3DXVECTOR2 *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Move@PAUD3DXVECTOR2@@PAU1@@std@@YAPAUD3DXVECTOR2@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAUD3DXVECTOR2@@PAU1@@std@@YAPAUD3DXVECTOR2@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<D3DXVECTOR2 *,D3DXVECTOR2 *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN11@Move:
  00009	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  0000c	74 12		 je	 SHORT $LN1@Move

; 2514 : 		*_Dest = _STD move(*_First);

  0000e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00010	89 10		 mov	 DWORD PTR [eax], edx
  00012	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00015	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00018	83 c0 08	 add	 eax, 8
  0001b	83 c1 08	 add	 ecx, 8
  0001e	eb e9		 jmp	 SHORT $LN11@Move
$LN1@Move:

; 2515 : 	return (_Dest);
; 2516 : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Move@PAUD3DXVECTOR2@@PAU1@@std@@YAPAUD3DXVECTOR2@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<D3DXVECTOR2 *,D3DXVECTOR2 *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@QAEXPAUElementInfo@ioRenderElementAnimationFrame@@@Z ; std::allocator<ioRenderElementAnimationFrame::ElementInfo>::destroy
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@QAEXPAUElementInfo@ioRenderElementAnimationFrame@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@QAEXPAUElementInfo@ioRenderElementAnimationFrame@@@Z PROC ; std::allocator<ioRenderElementAnimationFrame::ElementInfo>::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@QAEXPAUElementInfo@ioRenderElementAnimationFrame@@@Z ENDP ; std::allocator<ioRenderElementAnimationFrame::ElementInfo>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UD3DXVECTOR2@@@std@@QAEXPAUD3DXVECTOR2@@ABU3@@Z ; std::allocator<D3DXVECTOR2>::construct
; Function compile flags: /Ogsp
;	COMDAT ?construct@?$allocator@UD3DXVECTOR2@@@std@@QAEXPAUD3DXVECTOR2@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UD3DXVECTOR2@@@std@@QAEXPAUD3DXVECTOR2@@ABU3@@Z PROC ; std::allocator<D3DXVECTOR2>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 		_Construct(_Ptr, _Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN5@construct@2
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN5@construct@2:

; 198  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
?construct@?$allocator@UD3DXVECTOR2@@@std@@QAEXPAUD3DXVECTOR2@@ABU3@@Z ENDP ; std::allocator<D3DXVECTOR2>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UD3DXVECTOR2@@@std@@QAEXPAUD3DXVECTOR2@@@Z ; std::allocator<D3DXVECTOR2>::destroy
; Function compile flags: /Ogsp
;	COMDAT ?destroy@?$allocator@UD3DXVECTOR2@@@std@@QAEXPAUD3DXVECTOR2@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UD3DXVECTOR2@@@std@@QAEXPAUD3DXVECTOR2@@@Z PROC ; std::allocator<D3DXVECTOR2>::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@UD3DXVECTOR2@@@std@@QAEXPAUD3DXVECTOR2@@@Z ENDP ; std::allocator<D3DXVECTOR2>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UD3DXVECTOR2@@@std@@QAEXPAUD3DXVECTOR2@@$$QAU3@@Z ; std::allocator<D3DXVECTOR2>::construct
; Function compile flags: /Ogsp
;	COMDAT ?construct@?$allocator@UD3DXVECTOR2@@@std@@QAEXPAUD3DXVECTOR2@@$$QAU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UD3DXVECTOR2@@@std@@QAEXPAUD3DXVECTOR2@@$$QAU3@@Z PROC ; std::allocator<D3DXVECTOR2>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN3@construct@3
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@construct@3:

; 203  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
?construct@?$allocator@UD3DXVECTOR2@@@std@@QAEXPAUD3DXVECTOR2@@$$QAU3@@Z ENDP ; std::allocator<D3DXVECTOR2>::construct
_TEXT	ENDS
PUBLIC	??0?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAE@XZ ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAE@XZ PROC ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAE@XZ ENDP ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >
_TEXT	ENDS
PUBLIC	??0?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@XZ PROC ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@XZ ENDP ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::operator!=
; Function compile flags: /Ogsp
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 209  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QAE@PAUElementInfo@ioRenderElementAnimationFrame@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::_Vector_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QAE@PAUElementInfo@ioRenderElementAnimationFrame@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QAE@PAUElementInfo@ioRenderElementAnimationFrame@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::_Vector_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 305  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@std@@QAE@PAUElementInfo@ioRenderElementAnimationFrame@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >::_Vector_iterator<std::_Vector_val<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> > >
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >::operator+
; Function compile flags: /Ogsp
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >::operator+, COMDAT
; _this$ = ecx

; 363  : 		{	// return this + integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 364  : 		_Myiter _Tmp = *this;
; 365  : 		return (_Tmp += _Off);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 0c	 mov	 ecx, DWORD PTR __Off$[ebp]
  00008	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  0000b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000e	89 08		 mov	 DWORD PTR [eax], ecx

; 366  : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??H?$_Vector_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >::operator+
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QAE@PAUD3DXVECTOR2@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >::_Vector_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QAE@PAUD3DXVECTOR2@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QAE@PAUD3DXVECTOR2@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >::_Vector_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 305  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QAE@PAUD3DXVECTOR2@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >::_Vector_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >::operator!=
; Function compile flags: /Ogsp
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 209  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<D3DXVECTOR2,std::allocator<D3DXVECTOR2> > >::operator!=
_TEXT	ENDS
PUBLIC	??$_Move@PAUD3DXVECTOR2@@PAU1@@std@@YAPAUD3DXVECTOR2@@PAU1@00@Z ; std::_Move<D3DXVECTOR2 *,D3DXVECTOR2 *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUD3DXVECTOR2@@PAU1@@std@@YAPAUD3DXVECTOR2@@PAU1@00@Z
_TEXT	SEGMENT
__Cat$508732 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAUD3DXVECTOR2@@PAU1@@std@@YAPAUD3DXVECTOR2@@PAU1@00@Z PROC ; std::_Move<D3DXVECTOR2 *,D3DXVECTOR2 *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$508732[ebp]
  00007	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Move@PAUD3DXVECTOR2@@PAU1@@std@@YAPAUD3DXVECTOR2@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<D3DXVECTOR2 *,D3DXVECTOR2 *>
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00018	c9		 leave
  00019	c3		 ret	 0
??$_Move@PAUD3DXVECTOR2@@PAU1@@std@@YAPAUD3DXVECTOR2@@PAU1@00@Z ENDP ; std::_Move<D3DXVECTOR2 *,D3DXVECTOR2 *>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@UElementInfo@ioRenderElementAnimationFrame@@@std@@YAXAAV?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@0@PAUElementInfo@ioRenderElementAnimationFrame@@@Z ; std::_Dest_val<std::allocator<ioRenderElementAnimationFrame::ElementInfo>,ioRenderElementAnimationFrame::ElementInfo>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@UElementInfo@ioRenderElementAnimationFrame@@@std@@YAXAAV?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@0@PAUElementInfo@ioRenderElementAnimationFrame@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@UElementInfo@ioRenderElementAnimationFrame@@@std@@YAXAAV?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@0@PAUElementInfo@ioRenderElementAnimationFrame@@@Z PROC ; std::_Dest_val<std::allocator<ioRenderElementAnimationFrame::ElementInfo>,ioRenderElementAnimationFrame::ElementInfo>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@UElementInfo@ioRenderElementAnimationFrame@@@std@@YAXAAV?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@0@PAUElementInfo@ioRenderElementAnimationFrame@@@Z ENDP ; std::_Dest_val<std::allocator<ioRenderElementAnimationFrame::ElementInfo>,ioRenderElementAnimationFrame::ElementInfo>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UD3DXVECTOR2@@@std@@UD3DXVECTOR2@@@std@@YAXAAV?$allocator@UD3DXVECTOR2@@@0@PAUD3DXVECTOR2@@@Z ; std::_Dest_val<std::allocator<D3DXVECTOR2>,D3DXVECTOR2>
; Function compile flags: /Ogsp
;	COMDAT ??$_Dest_val@V?$allocator@UD3DXVECTOR2@@@std@@UD3DXVECTOR2@@@std@@YAXAAV?$allocator@UD3DXVECTOR2@@@0@PAUD3DXVECTOR2@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UD3DXVECTOR2@@@std@@UD3DXVECTOR2@@@std@@YAXAAV?$allocator@UD3DXVECTOR2@@@0@PAUD3DXVECTOR2@@@Z PROC ; std::_Dest_val<std::allocator<D3DXVECTOR2>,D3DXVECTOR2>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@UD3DXVECTOR2@@@std@@UD3DXVECTOR2@@@std@@YAXAAV?$allocator@UD3DXVECTOR2@@@0@PAUD3DXVECTOR2@@@Z ENDP ; std::_Dest_val<std::allocator<D3DXVECTOR2>,D3DXVECTOR2>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UD3DXVECTOR2@@@std@@UD3DXVECTOR2@@ABU3@@std@@YAXAAV?$allocator@UD3DXVECTOR2@@@0@PAUD3DXVECTOR2@@ABU2@@Z ; std::_Cons_val<std::allocator<D3DXVECTOR2>,D3DXVECTOR2,D3DXVECTOR2 const &>
; Function compile flags: /Ogsp
;	COMDAT ??$_Cons_val@V?$allocator@UD3DXVECTOR2@@@std@@UD3DXVECTOR2@@ABU3@@std@@YAXAAV?$allocator@UD3DXVECTOR2@@@0@PAUD3DXVECTOR2@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UD3DXVECTOR2@@@std@@UD3DXVECTOR2@@ABU3@@std@@YAXAAV?$allocator@UD3DXVECTOR2@@@0@PAUD3DXVECTOR2@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<D3DXVECTOR2>,D3DXVECTOR2,D3DXVECTOR2 const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN9@Cons_val@2
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Cons_val@2:

; 281  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Cons_val@V?$allocator@UD3DXVECTOR2@@@std@@UD3DXVECTOR2@@ABU3@@std@@YAXAAV?$allocator@UD3DXVECTOR2@@@0@PAUD3DXVECTOR2@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<D3DXVECTOR2>,D3DXVECTOR2,D3DXVECTOR2 const &>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UD3DXVECTOR2@@@std@@UD3DXVECTOR2@@U3@@std@@YAXAAV?$allocator@UD3DXVECTOR2@@@0@PAUD3DXVECTOR2@@$$QAU2@@Z ; std::_Cons_val<std::allocator<D3DXVECTOR2>,D3DXVECTOR2,D3DXVECTOR2>
; Function compile flags: /Ogsp
;	COMDAT ??$_Cons_val@V?$allocator@UD3DXVECTOR2@@@std@@UD3DXVECTOR2@@U3@@std@@YAXAAV?$allocator@UD3DXVECTOR2@@@0@PAUD3DXVECTOR2@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UD3DXVECTOR2@@@std@@UD3DXVECTOR2@@U3@@std@@YAXAAV?$allocator@UD3DXVECTOR2@@@0@PAUD3DXVECTOR2@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<D3DXVECTOR2>,D3DXVECTOR2,D3DXVECTOR2>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN7@Cons_val@3
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN7@Cons_val@3:

; 281  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Cons_val@V?$allocator@UD3DXVECTOR2@@@std@@UD3DXVECTOR2@@U3@@std@@YAXAAV?$allocator@UD3DXVECTOR2@@@0@PAUD3DXVECTOR2@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<D3DXVECTOR2>,D3DXVECTOR2,D3DXVECTOR2>
_TEXT	ENDS
PUBLIC	?begin@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@2@XZ ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::begin
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?begin@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@2@XZ PROC ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 782  : 		return (iterator(this->_Myfirst, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 783  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@2@XZ ENDP ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@2@XZ ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::end
; Function compile flags: /Ogsp
;	COMDAT ?end@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@2@XZ PROC ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 792  : 		return (iterator(this->_Mylast, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 793  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@@2@XZ ENDP ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@XZ ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::begin
; Function compile flags: /Ogsp
;	COMDAT ?begin@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@XZ PROC ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 782  : 		return (iterator(this->_Myfirst, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 783  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@XZ ENDP ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@XZ ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::end
; Function compile flags: /Ogsp
;	COMDAT ?end@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@XZ PROC ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 792  : 		return (iterator(this->_Mylast, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 793  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@XZ ENDP ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::end
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@@Z ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Make_iter
; Function compile flags: /Ogsp
;	COMDAT ?_Make_iter@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@@Z PROC ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 		return (iterator(_Where._Ptr, this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 803  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?_Make_iter@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@@Z ENDP ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Make_iter
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@YAXPAUElementInfo@ioRenderElementAnimationFrame@@0AAV?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<ioRenderElementAnimationFrame::ElementInfo> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@YAXPAUElementInfo@ioRenderElementAnimationFrame@@0AAV?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@YAXPAUElementInfo@ioRenderElementAnimationFrame@@0AAV?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<ioRenderElementAnimationFrame::ElementInfo> >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@YAXPAUElementInfo@ioRenderElementAnimationFrame@@0AAV?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<ioRenderElementAnimationFrame::ElementInfo> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UD3DXVECTOR2@@@std@@@std@@YAXPAUD3DXVECTOR2@@0AAV?$allocator@UD3DXVECTOR2@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<D3DXVECTOR2> >
; Function compile flags: /Ogsp
;	COMDAT ??$_Destroy_range@V?$allocator@UD3DXVECTOR2@@@std@@@std@@YAXPAUD3DXVECTOR2@@0AAV?$allocator@UD3DXVECTOR2@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UD3DXVECTOR2@@@std@@@std@@YAXPAUD3DXVECTOR2@@0AAV?$allocator@UD3DXVECTOR2@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<D3DXVECTOR2> >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@UD3DXVECTOR2@@@std@@@std@@YAXPAUD3DXVECTOR2@@0AAV?$allocator@UD3DXVECTOR2@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<D3DXVECTOR2> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUD3DXVECTOR2@@IU1@V?$allocator@UD3DXVECTOR2@@@std@@U1@@std@@YAXPAUD3DXVECTOR2@@IPBU1@AAV?$allocator@UD3DXVECTOR2@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<D3DXVECTOR2 *,unsigned int,D3DXVECTOR2,std::allocator<D3DXVECTOR2>,D3DXVECTOR2>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAUD3DXVECTOR2@@IU1@V?$allocator@UD3DXVECTOR2@@@std@@U1@@std@@YAXPAUD3DXVECTOR2@@IPBU1@AAV?$allocator@UD3DXVECTOR2@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Pval$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUD3DXVECTOR2@@IU1@V?$allocator@UD3DXVECTOR2@@@std@@U1@@std@@YAXPAUD3DXVECTOR2@@IPBU1@AAV?$allocator@UD3DXVECTOR2@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<D3DXVECTOR2 *,unsigned int,D3DXVECTOR2,std::allocator<D3DXVECTOR2>,D3DXVECTOR2>, COMDAT

; 558  : 	{	// copy _Count * *_Pval to raw _First, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 559  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 560  : //	if (_Count < 0)
; 561  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 562  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 563  : 
; 564  : 	_FwdIt _Next = _First;
; 565  : 
; 566  : 	_TRY_BEGIN
; 567  : 	for (; 0 < _Count; --_Count, ++_First)

  00003	eb 18		 jmp	 SHORT $LN23@Uninit_fil
$LL6@Uninit_fil:

; 568  : 		_Cons_val(_Al, _First, *_Pval);

  00005	ff 75 10	 push	 DWORD PTR __Pval$[ebp]
  00008	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000b	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000e	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UD3DXVECTOR2@@@std@@UD3DXVECTOR2@@ABU3@@std@@YAXAAV?$allocator@UD3DXVECTOR2@@@0@PAUD3DXVECTOR2@@ABU2@@Z ; std::_Cons_val<std::allocator<D3DXVECTOR2>,D3DXVECTOR2,D3DXVECTOR2 const &>
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH
  00016	ff 4d 0c	 dec	 DWORD PTR __Count$[ebp]
  00019	83 45 08 08	 add	 DWORD PTR __First$[ebp], 8
$LN23@Uninit_fil:

; 559  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 560  : //	if (_Count < 0)
; 561  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 562  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 563  : 
; 564  : 	_FwdIt _Next = _First;
; 565  : 
; 566  : 	_TRY_BEGIN
; 567  : 	for (; 0 < _Count; --_Count, ++_First)

  0001d	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00021	77 e2		 ja	 SHORT $LL6@Uninit_fil

; 569  : 	_CATCH_ALL
; 570  : 	for (; _Next != _First; ++_Next)
; 571  : 		_Dest_val(_Al, _Next);
; 572  : 	_RERAISE;
; 573  : 	_CATCH_END
; 574  : 	}

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$_Uninit_fill_n@PAUD3DXVECTOR2@@IU1@V?$allocator@UD3DXVECTOR2@@@std@@U1@@std@@YAXPAUD3DXVECTOR2@@IPBU1@AAV?$allocator@UD3DXVECTOR2@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<D3DXVECTOR2 *,unsigned int,D3DXVECTOR2,std::allocator<D3DXVECTOR2>,D3DXVECTOR2>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUD3DXVECTOR2@@PAU1@V?$allocator@UD3DXVECTOR2@@@std@@U1@@std@@YAPAUD3DXVECTOR2@@PAU1@00AAV?$allocator@UD3DXVECTOR2@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<D3DXVECTOR2 *,D3DXVECTOR2 *,std::allocator<D3DXVECTOR2>,D3DXVECTOR2>
; Function compile flags: /Ogsp
;	COMDAT ??$_Uninit_move@PAUD3DXVECTOR2@@PAU1@V?$allocator@UD3DXVECTOR2@@@std@@U1@@std@@YAPAUD3DXVECTOR2@@PAU1@00AAV?$allocator@UD3DXVECTOR2@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUD3DXVECTOR2@@PAU1@V?$allocator@UD3DXVECTOR2@@@std@@U1@@std@@YAPAUD3DXVECTOR2@@PAU1@00AAV?$allocator@UD3DXVECTOR2@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<D3DXVECTOR2 *,D3DXVECTOR2 *,std::allocator<D3DXVECTOR2>,D3DXVECTOR2>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;
; 428  : 
; 429  : 	_TRY_BEGIN
; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	eb 16		 jmp	 SHORT $LN24@Uninit_mov
$LL6@Uninit_mov:

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00009	56		 push	 esi
  0000a	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000d	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UD3DXVECTOR2@@@std@@UD3DXVECTOR2@@U3@@std@@YAXAAV?$allocator@UD3DXVECTOR2@@@0@PAUD3DXVECTOR2@@$$QAU2@@Z ; std::_Cons_val<std::allocator<D3DXVECTOR2>,D3DXVECTOR2,D3DXVECTOR2>
  00015	83 45 10 08	 add	 DWORD PTR __Dest$[ebp], 8
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001c	83 c6 08	 add	 esi, 8
$LN24@Uninit_mov:

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;
; 428  : 
; 429  : 	_TRY_BEGIN
; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  0001f	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00022	75 e5		 jne	 SHORT $LL6@Uninit_mov

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  00024	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00027	5e		 pop	 esi

; 438  : 	}

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??$_Uninit_move@PAUD3DXVECTOR2@@PAU1@V?$allocator@UD3DXVECTOR2@@@std@@U1@@std@@YAPAUD3DXVECTOR2@@PAU1@00AAV?$allocator@UD3DXVECTOR2@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<D3DXVECTOR2 *,D3DXVECTOR2 *,std::allocator<D3DXVECTOR2>,D3DXVECTOR2>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUElementInfo@ioRenderElementAnimationFrame@@PAU12@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@U12@@std@@YAPAUElementInfo@ioRenderElementAnimationFrame@@PAU12@00AAV?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ioRenderElementAnimationFrame::ElementInfo *,ioRenderElementAnimationFrame::ElementInfo *,std::allocator<ioRenderElementAnimationFrame::ElementInfo>,ioRenderElementAnimationFrame::ElementInfo>
; Function compile flags: /Ogsp
;	COMDAT ??$_Uninit_move@PAUElementInfo@ioRenderElementAnimationFrame@@PAU12@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@U12@@std@@YAPAUElementInfo@ioRenderElementAnimationFrame@@PAU12@00AAV?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUElementInfo@ioRenderElementAnimationFrame@@PAU12@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@U12@@std@@YAPAUElementInfo@ioRenderElementAnimationFrame@@PAU12@00AAV?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<ioRenderElementAnimationFrame::ElementInfo *,ioRenderElementAnimationFrame::ElementInfo *,std::allocator<ioRenderElementAnimationFrame::ElementInfo>,ioRenderElementAnimationFrame::ElementInfo>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;
; 428  : 
; 429  : 	_TRY_BEGIN
; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	eb 16		 jmp	 SHORT $LN24@Uninit_mov@2
$LL6@Uninit_mov@2:

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00009	56		 push	 esi
  0000a	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000d	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@UElementInfo@ioRenderElementAnimationFrame@@U34@@std@@YAXAAV?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@0@PAUElementInfo@ioRenderElementAnimationFrame@@$$QAU23@@Z ; std::_Cons_val<std::allocator<ioRenderElementAnimationFrame::ElementInfo>,ioRenderElementAnimationFrame::ElementInfo,ioRenderElementAnimationFrame::ElementInfo>
  00015	83 45 10 08	 add	 DWORD PTR __Dest$[ebp], 8
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001c	83 c6 08	 add	 esi, 8
$LN24@Uninit_mov@2:

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;
; 428  : 
; 429  : 	_TRY_BEGIN
; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  0001f	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00022	75 e5		 jne	 SHORT $LL6@Uninit_mov@2

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  00024	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00027	5e		 pop	 esi

; 438  : 	}

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??$_Uninit_move@PAUElementInfo@ioRenderElementAnimationFrame@@PAU12@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@U12@@std@@YAPAUElementInfo@ioRenderElementAnimationFrame@@PAU12@00AAV?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<ioRenderElementAnimationFrame::ElementInfo *,ioRenderElementAnimationFrame::ElementInfo *,std::allocator<ioRenderElementAnimationFrame::ElementInfo>,ioRenderElementAnimationFrame::ElementInfo>
_TEXT	ENDS
PUBLIC	?Update@ioRenderElementAnimationFrame@@UAE_NXZ	; ioRenderElementAnimationFrame::Update
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\iorenderelementanimationframe.cpp
;	COMDAT ?Update@ioRenderElementAnimationFrame@@UAE_NXZ
_TEXT	SEGMENT
_eiter$ = -12						; size = 4
_i$506042 = -8						; size = 4
_ret$ = -1						; size = 1
?Update@ioRenderElementAnimationFrame@@UAE_NXZ PROC	; ioRenderElementAnimationFrame::Update, COMDAT
; _this$ = ecx

; 58   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 59   : 	if ( m_elements.empty() ) {

  00009	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0000f	75 04		 jne	 SHORT $LN6@Update
$LN44@Update:

; 60   : 		return true;

  00011	b0 01		 mov	 al, 1
  00013	eb 6b		 jmp	 SHORT $LN7@Update
$LN6@Update:

; 61   : 	}
; 62   : 
; 63   : 	if ( m_targettime == 0 ) 

  00015	83 7e 18 00	 cmp	 DWORD PTR [esi+24], 0
  00019	75 07		 jne	 SHORT $LN5@Update

; 64   : 	{
; 65   : 		SetTargetValue();

  0001b	8b 06		 mov	 eax, DWORD PTR [esi]
  0001d	ff 50 14	 call	 DWORD PTR [eax+20]

; 66   : 		return true;

  00020	eb ef		 jmp	 SHORT $LN44@Update
$LN5@Update:
  00022	53		 push	 ebx
  00023	57		 push	 edi

; 67   : 	}
; 68   : 
; 69   : 	DWORD dt = FRAMEGETTIME() - m_lastupdatetime;

  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  0002a	8b c8		 mov	 ecx, eax
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ

; 70   : 
; 71   : 	bool ret = true;
; 72   : 	ElementInfos::iterator iter = m_elements.begin();

  00032	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]

; 73   : 	ElementInfos::iterator eiter = m_elements.end();
; 74   : 	for ( int i = 0; iter != eiter; ++iter, ++i )

  00035	83 65 f8 00	 and	 DWORD PTR _i$506042[ebp], 0
  00039	8b f8		 mov	 edi, eax
  0003b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0003e	2b 7e 14	 sub	 edi, DWORD PTR [esi+20]
  00041	c6 45 ff 01	 mov	 BYTE PTR _ret$[ebp], 1
  00045	89 45 f4	 mov	 DWORD PTR _eiter$[ebp], eax
  00048	3b d8		 cmp	 ebx, eax
  0004a	74 1e		 je	 SHORT $LN2@Update
$LL43@Update:

; 75   : 	{	
; 76   : 		if ( !UpdateElement( dt, *iter, i ) ) {

  0004c	ff 75 f8	 push	 DWORD PTR _i$506042[ebp]
  0004f	8b 06		 mov	 eax, DWORD PTR [esi]
  00051	53		 push	 ebx
  00052	57		 push	 edi
  00053	8b ce		 mov	 ecx, esi
  00055	ff 50 10	 call	 DWORD PTR [eax+16]
  00058	84 c0		 test	 al, al
  0005a	75 03		 jne	 SHORT $LN3@Update

; 77   : 			ret = false;

  0005c	88 45 ff	 mov	 BYTE PTR _ret$[ebp], al
$LN3@Update:

; 73   : 	ElementInfos::iterator eiter = m_elements.end();
; 74   : 	for ( int i = 0; iter != eiter; ++iter, ++i )

  0005f	83 c3 08	 add	 ebx, 8
  00062	ff 45 f8	 inc	 DWORD PTR _i$506042[ebp]
  00065	3b 5d f4	 cmp	 ebx, DWORD PTR _eiter$[ebp]
  00068	75 e2		 jne	 SHORT $LL43@Update
$LN2@Update:

; 78   : 		}
; 79   : 	}
; 80   : 
; 81   : 	m_lastupdatetime = FRAMEGETTIME();

  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  00070	8b c8		 mov	 ecx, eax
  00072	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ
  00078	5f		 pop	 edi
  00079	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 82   : 	return ret;

  0007c	8a 45 ff	 mov	 al, BYTE PTR _ret$[ebp]
  0007f	5b		 pop	 ebx
$LN7@Update:
  00080	5e		 pop	 esi

; 83   : }

  00081	c9		 leave
  00082	c3		 ret	 0
?Update@ioRenderElementAnimationFrame@@UAE_NXZ ENDP	; ioRenderElementAnimationFrame::Update
_TEXT	ENDS
PUBLIC	?SetTargetValue@ioRenderElementAnimationFrameScale@@MAEXXZ ; ioRenderElementAnimationFrameScale::SetTargetValue
; Function compile flags: /Ogsp
;	COMDAT ?SetTargetValue@ioRenderElementAnimationFrameScale@@MAEXXZ
_TEXT	SEGMENT
?SetTargetValue@ioRenderElementAnimationFrameScale@@MAEXXZ PROC ; ioRenderElementAnimationFrameScale::SetTargetValue, COMDAT
; _this$ = ecx

; 208  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx

; 209  : 	ElementInfos::iterator iter = m_elements.begin();

  00005	8b 77 04	 mov	 esi, DWORD PTR [edi+4]

; 210  : 	ElementInfos::iterator eiter = m_elements.end();

  00008	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  0000b	eb 27		 jmp	 SHORT $LN42@SetTargetV

; 211  : 	for ( ; iter != eiter; ++iter )

$LL24@SetTargetV:

; 212  : 	{
; 213  : 		(*iter).m_element->SetXScale( m_targetscale.x );

  0000d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0000f	f3 0f 10 47 1c	 movss	 xmm0, DWORD PTR [edi+28]
  00014	8b 01		 mov	 eax, DWORD PTR [ecx]
  00016	51		 push	 ecx
  00017	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0001c	ff 50 20	 call	 DWORD PTR [eax+32]

; 214  : 		(*iter).m_element->SetYScale( m_targetscale.y );

  0001f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00021	f3 0f 10 47 20	 movss	 xmm0, DWORD PTR [edi+32]
  00026	8b 01		 mov	 eax, DWORD PTR [ecx]
  00028	51		 push	 ecx
  00029	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0002e	ff 50 24	 call	 DWORD PTR [eax+36]
  00031	83 c6 08	 add	 esi, 8
$LN42@SetTargetV:

; 211  : 	for ( ; iter != eiter; ++iter )

  00034	3b f3		 cmp	 esi, ebx
  00036	75 d5		 jne	 SHORT $LL24@SetTargetV

; 215  : 	}
; 216  : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	c3		 ret	 0
?SetTargetValue@ioRenderElementAnimationFrameScale@@MAEXXZ ENDP ; ioRenderElementAnimationFrameScale::SetTargetValue
_TEXT	ENDS
PUBLIC	?OnBegin@ioRenderElementAnimationFrameScale@@UAEXXZ ; ioRenderElementAnimationFrameScale::OnBegin
; Function compile flags: /Ogsp
;	COMDAT ?OnBegin@ioRenderElementAnimationFrameScale@@UAEXXZ
_TEXT	SEGMENT
$T509226 = -40						; size = 8
_curscale$506155 = -32					; size = 8
_vec$506157 = -24					; size = 8
_eiter$ = -16						; size = 4
tv360 = -12						; size = 4
tv356 = -12						; size = 4
tv349 = -12						; size = 4
$T509360 = -12						; size = 4
tv369 = -8						; size = 4
tv364 = -8						; size = 4
$T509348 = -4						; size = 4
?OnBegin@ioRenderElementAnimationFrameScale@@UAEXXZ PROC ; ioRenderElementAnimationFrameScale::OnBegin, COMDAT
; _this$ = ecx

; 223  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx

; 224  : 	ioRenderElementAnimationFrame::OnBegin();

  0000a	e8 00 00 00 00	 call	 ?OnBegin@ioRenderElementAnimationFrame@@UAEXXZ ; ioRenderElementAnimationFrame::OnBegin

; 225  : 
; 226  : 	ElementInfos::iterator iter = m_elements.begin();
; 227  : 	ElementInfos::iterator eiter = m_elements.end();

  0000f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00012	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00015	89 45 f0	 mov	 DWORD PTR _eiter$[ebp], eax

; 228  : 	for ( ; iter != eiter; ++iter )

  00018	3b f8		 cmp	 edi, eax
  0001a	0f 84 1f 01 00
	00		 je	 $LN4@OnBegin
  00020	53		 push	 ebx
$LL27@OnBegin:

; 229  : 	{	
; 230  : 		D3DXVECTOR2 curscale = iter->m_element->GetScale();

  00021	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00023	8b 01		 mov	 eax, DWORD PTR [ecx]
  00025	8d 55 e0	 lea	 edx, DWORD PTR _curscale$506155[ebp]
  00028	52		 push	 edx
  00029	ff 50 38	 call	 DWORD PTR [eax+56]

; 231  : 		D3DXVECTOR2 vec = m_targetscale - curscale;
; 232  : 		if ( m_targettime == 0 || ioMath::IsEqual( vec, D3DXVECTOR2( 0.0f, 0.0f ) ) ) 

  0002c	83 7e 18 00	 cmp	 DWORD PTR [esi+24], 0
  00030	f3 0f 10 46 1c	 movss	 xmm0, DWORD PTR [esi+28]
  00035	f3 0f 10 4d e0	 movss	 xmm1, DWORD PTR _curscale$506155[ebp]
  0003a	0f 5a c0	 cvtps2pd xmm0, xmm0
  0003d	0f 5a c9	 cvtps2pd xmm1, xmm1
  00040	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00044	f3 0f 10 4d e4	 movss	 xmm1, DWORD PTR _curscale$506155[ebp+4]
  00049	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0004d	f3 0f 11 45 e8	 movss	 DWORD PTR _vec$506157[ebp], xmm0
  00052	f3 0f 10 46 20	 movss	 xmm0, DWORD PTR [esi+32]
  00057	0f 5a c0	 cvtps2pd xmm0, xmm0
  0005a	0f 5a c9	 cvtps2pd xmm1, xmm1
  0005d	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00061	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00065	f3 0f 11 45 ec	 movss	 DWORD PTR _vec$506157[ebp+4], xmm0
  0006a	0f 84 ba 00 00
	00		 je	 $LN2@OnBegin
  00070	0f 57 c0	 xorps	 xmm0, xmm0
  00073	51		 push	 ecx
  00074	f3 0f 11 45 d8	 movss	 DWORD PTR $T509226[ebp], xmm0
  00079	f3 0f 11 45 dc	 movss	 DWORD PTR $T509226[ebp+4], xmm0
  0007e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@38d1b717
  00086	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0008b	8d 45 d8	 lea	 eax, DWORD PTR $T509226[ebp]
  0008e	50		 push	 eax
  0008f	8d 45 e8	 lea	 eax, DWORD PTR _vec$506157[ebp]
  00092	50		 push	 eax
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEqual@ioMath@@SA_NABUD3DXVECTOR2@@0M@Z
  00099	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009c	84 c0		 test	 al, al
  0009e	0f 85 86 00 00
	00		 jne	 $LN2@OnBegin

; 235  : 		}
; 236  : 		else 
; 237  : 		{
; 238  : 			float distance = D3DXVec2Length( &vec );

  000a4	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _vec$506157[ebp+4]
  000a9	f3 0f 10 4d e8	 movss	 xmm1, DWORD PTR _vec$506157[ebp]
  000ae	0f 5a c0	 cvtps2pd xmm0, xmm0
  000b1	0f 5a c9	 cvtps2pd xmm1, xmm1
  000b4	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  000b8	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  000bc	f2 0f 58 c8	 addsd	 xmm1, xmm0
  000c0	0f 57 c0	 xorps	 xmm0, xmm0
  000c3	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  000c7	f3 0f 11 45 fc	 movss	 DWORD PTR $T509348[ebp], xmm0

; 239  : 			iter->m_speed = distance / ( m_targettime * FLOAT0001 );

  000cc	b8 01 00 00 00	 mov	 eax, 1
  000d1	8b d8		 mov	 ebx, eax
  000d3	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  000d8	d9 45 fc	 fld	 DWORD PTR $T509348[ebp]
  000db	89 45 f4	 mov	 DWORD PTR $T509360[ebp], eax
  000de	e8 00 00 00 00	 call	 __CIsqrt
  000e3	d9 5d f8	 fstp	 DWORD PTR tv369[ebp]
  000e6	d9 45 f8	 fld	 DWORD PTR tv369[ebp]
  000e9	89 5d f8	 mov	 DWORD PTR tv364[ebp], ebx
  000ec	db 45 f8	 fild	 DWORD PTR tv364[ebp]
  000ef	85 db		 test	 ebx, ebx
  000f1	79 06		 jns	 SHORT $LN69@OnBegin
  000f3	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN69@OnBegin:
  000f9	8b 45 f4	 mov	 eax, DWORD PTR $T509360[ebp]
  000fc	db 45 f4	 fild	 DWORD PTR $T509360[ebp]
  000ff	85 c0		 test	 eax, eax
  00101	79 06		 jns	 SHORT $LN70@OnBegin
  00103	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN70@OnBegin:
  00109	de f9		 fdivp	 ST(1), ST(0)
  0010b	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0010e	d9 5d f4	 fstp	 DWORD PTR tv356[ebp]
  00111	d9 45 f4	 fld	 DWORD PTR tv356[ebp]
  00114	db 46 18	 fild	 DWORD PTR [esi+24]
  00117	85 c0		 test	 eax, eax
  00119	79 06		 jns	 SHORT $LN71@OnBegin
  0011b	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN71@OnBegin:
  00121	de c9		 fmulp	 ST(1), ST(0)
  00123	de f9		 fdivp	 ST(1), ST(0)
  00125	d9 5f 04	 fstp	 DWORD PTR [edi+4]
  00128	eb 08		 jmp	 SHORT $LN5@OnBegin
$LN2@OnBegin:

; 233  : 		{
; 234  : 			iter->m_speed = 0.0f;

  0012a	0f 57 c0	 xorps	 xmm0, xmm0
  0012d	f3 0f 11 47 04	 movss	 DWORD PTR [edi+4], xmm0
$LN5@OnBegin:

; 228  : 	for ( ; iter != eiter; ++iter )

  00132	83 c7 08	 add	 edi, 8
  00135	3b 7d f0	 cmp	 edi, DWORD PTR _eiter$[ebp]
  00138	0f 85 e3 fe ff
	ff		 jne	 $LL27@OnBegin
  0013e	5b		 pop	 ebx
$LN4@OnBegin:
  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi

; 240  : 		}
; 241  : 	}
; 242  : }

  00141	c9		 leave
  00142	c3		 ret	 0
?OnBegin@ioRenderElementAnimationFrameScale@@UAEXXZ ENDP ; ioRenderElementAnimationFrameScale::OnBegin
_TEXT	ENDS
PUBLIC	?SetTargetValue@ioRenderElementAnimationFrameAlpha@@MAEXXZ ; ioRenderElementAnimationFrameAlpha::SetTargetValue
; Function compile flags: /Ogsp
;	COMDAT ?SetTargetValue@ioRenderElementAnimationFrameAlpha@@MAEXXZ
_TEXT	SEGMENT
?SetTargetValue@ioRenderElementAnimationFrameAlpha@@MAEXXZ PROC ; ioRenderElementAnimationFrameAlpha::SetTargetValue, COMDAT
; _this$ = ecx

; 302  : {

  00000	53		 push	 ebx

; 303  : 	ElementInfos::iterator iter = m_elements.begin();
; 304  : 	ElementInfos::iterator eiter = m_elements.end();

  00001	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00004	56		 push	 esi
  00005	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]

; 305  : 	for ( ; iter != eiter; ++iter ) {

  00008	3b f3		 cmp	 esi, ebx
  0000a	74 1b		 je	 SHORT $LN1@SetTargetV@2
  0000c	57		 push	 edi
  0000d	8d 79 1c	 lea	 edi, DWORD PTR [ecx+28]
$LL24@SetTargetV@2:

; 306  : 		(*iter).m_element->SetAlpha( m_targetalpha );

  00010	f3 0f 2c 17	 cvttss2si edx, DWORD PTR [edi]
  00014	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	0f b6 d2	 movzx	 edx, dl
  0001b	52		 push	 edx
  0001c	ff 50 30	 call	 DWORD PTR [eax+48]
  0001f	83 c6 08	 add	 esi, 8
  00022	3b f3		 cmp	 esi, ebx
  00024	75 ea		 jne	 SHORT $LL24@SetTargetV@2
  00026	5f		 pop	 edi
$LN1@SetTargetV@2:
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx

; 307  : 	}
; 308  : }

  00029	c3		 ret	 0
?SetTargetValue@ioRenderElementAnimationFrameAlpha@@MAEXXZ ENDP ; ioRenderElementAnimationFrameAlpha::SetTargetValue
_TEXT	ENDS
PUBLIC	?OnBegin@ioRenderElementAnimationFrameAlpha@@UAEXXZ ; ioRenderElementAnimationFrameAlpha::OnBegin
; Function compile flags: /Ogsp
;	COMDAT ?OnBegin@ioRenderElementAnimationFrameAlpha@@UAEXXZ
_TEXT	SEGMENT
tv343 = -8						; size = 4
tv339 = -8						; size = 4
tv335 = -8						; size = 4
tv330 = -8						; size = 4
_dist$506227 = -4					; size = 4
?OnBegin@ioRenderElementAnimationFrameAlpha@@UAEXXZ PROC ; ioRenderElementAnimationFrameAlpha::OnBegin, COMDAT
; _this$ = ecx

; 315  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx

; 316  : 	ioRenderElementAnimationFrame::OnBegin();

  0000a	e8 00 00 00 00	 call	 ?OnBegin@ioRenderElementAnimationFrame@@UAEXXZ ; ioRenderElementAnimationFrame::OnBegin

; 317  : 
; 318  : 	ElementInfos::iterator iter = m_elements.begin();

  0000f	8b 77 04	 mov	 esi, DWORD PTR [edi+4]

; 319  : 	ElementInfos::iterator eiter = m_elements.end();

  00012	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  00015	e9 ae 00 00 00	 jmp	 $LN64@OnBegin@2

; 320  : 	for ( ; iter != eiter; ++iter )

$LL27@OnBegin@2:

; 321  : 	{	
; 322  : 		float curalpha = iter->m_element->GetAlpha();

  0001a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0001c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001e	ff 50 3c	 call	 DWORD PTR [eax+60]

; 323  : 		float dist = m_targetalpha - curalpha;
; 324  : 		if ( m_targettime == 0 || fabsf( dist ) < ALMOST_ZERO ) {

  00021	83 7f 18 00	 cmp	 DWORD PTR [edi+24], 0
  00025	f3 0f 10 4f 1c	 movss	 xmm1, DWORD PTR [edi+28]
  0002a	0f b6 c0	 movzx	 eax, al
  0002d	0f 57 c0	 xorps	 xmm0, xmm0
  00030	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00034	0f 5a c0	 cvtps2pd xmm0, xmm0
  00037	0f 5a c9	 cvtps2pd xmm1, xmm1
  0003a	f2 0f 5c c8	 subsd	 xmm1, xmm0
  0003e	0f 57 c0	 xorps	 xmm0, xmm0
  00041	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  00045	f3 0f 11 45 fc	 movss	 DWORD PTR _dist$506227[ebp], xmm0
  0004a	74 71		 je	 SHORT $LN2@OnBegin@2
  0004c	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3f1a36e2e0000000
  00054	0f 5a c0	 cvtps2pd xmm0, xmm0
  00057	66 0f 54 05 00
	00 00 00	 andpd	 xmm0, QWORD PTR __mask@@AbsDouble@
  0005f	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00063	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00067	66 0f 2f c8	 comisd	 xmm1, xmm0
  0006b	77 50		 ja	 SHORT $LN2@OnBegin@2

; 326  : 		} else {
; 327  : 			iter->m_speed = dist / ( m_targettime * FLOAT0001 );

  0006d	b8 01 00 00 00	 mov	 eax, 1
  00072	8b c8		 mov	 ecx, eax
  00074	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  00079	d9 45 fc	 fld	 DWORD PTR _dist$506227[ebp]
  0007c	89 4d f8	 mov	 DWORD PTR tv343[ebp], ecx
  0007f	db 45 f8	 fild	 DWORD PTR tv343[ebp]
  00082	85 c9		 test	 ecx, ecx
  00084	79 06		 jns	 SHORT $LN61@OnBegin@2
  00086	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN61@OnBegin@2:
  0008c	89 45 f8	 mov	 DWORD PTR tv339[ebp], eax
  0008f	db 45 f8	 fild	 DWORD PTR tv339[ebp]
  00092	85 c0		 test	 eax, eax
  00094	79 06		 jns	 SHORT $LN62@OnBegin@2
  00096	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN62@OnBegin@2:
  0009c	de f9		 fdivp	 ST(1), ST(0)
  0009e	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  000a1	d9 5d f8	 fstp	 DWORD PTR tv335[ebp]
  000a4	d9 45 f8	 fld	 DWORD PTR tv335[ebp]
  000a7	db 47 18	 fild	 DWORD PTR [edi+24]
  000aa	85 c0		 test	 eax, eax
  000ac	79 06		 jns	 SHORT $LN63@OnBegin@2
  000ae	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN63@OnBegin@2:
  000b4	de c9		 fmulp	 ST(1), ST(0)
  000b6	de f9		 fdivp	 ST(1), ST(0)
  000b8	d9 5e 04	 fstp	 DWORD PTR [esi+4]
  000bb	eb 08		 jmp	 SHORT $LN5@OnBegin@2
$LN2@OnBegin@2:

; 325  : 			iter->m_speed = 0.0f;

  000bd	0f 57 c0	 xorps	 xmm0, xmm0
  000c0	f3 0f 11 46 04	 movss	 DWORD PTR [esi+4], xmm0
$LN5@OnBegin@2:

; 320  : 	for ( ; iter != eiter; ++iter )

  000c5	83 c6 08	 add	 esi, 8
$LN64@OnBegin@2:
  000c8	3b f3		 cmp	 esi, ebx
  000ca	0f 85 4a ff ff
	ff		 jne	 $LL27@OnBegin@2
  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
  000d2	5b		 pop	 ebx

; 328  : 		}
; 329  : 	}
; 330  : }

  000d3	c9		 leave
  000d4	c3		 ret	 0
?OnBegin@ioRenderElementAnimationFrameAlpha@@UAEXXZ ENDP ; ioRenderElementAnimationFrameAlpha::OnBegin
_TEXT	ENDS
PUBLIC	?SetTargetValue@ioRenderElementAnimationFrameSize@@MAEXXZ ; ioRenderElementAnimationFrameSize::SetTargetValue
; Function compile flags: /Ogsp
;	COMDAT ?SetTargetValue@ioRenderElementAnimationFrameSize@@MAEXXZ
_TEXT	SEGMENT
_eiter$ = -4						; size = 4
?SetTargetValue@ioRenderElementAnimationFrameSize@@MAEXXZ PROC ; ioRenderElementAnimationFrameSize::SetTargetValue, COMDAT
; _this$ = ecx

; 397  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 398  : 	ElementInfos::iterator iter = m_elements.begin();
; 399  : 	ElementInfos::iterator eiter = m_elements.end();

  00004	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00007	56		 push	 esi
  00008	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000b	89 45 fc	 mov	 DWORD PTR _eiter$[ebp], eax

; 400  : 	for ( ; iter != eiter; ++iter ) {

  0000e	3b f0		 cmp	 esi, eax
  00010	74 23		 je	 SHORT $LN1@SetTargetV@3
  00012	53		 push	 ebx
  00013	57		 push	 edi
  00014	8d 79 20	 lea	 edi, DWORD PTR [ecx+32]
  00017	8d 59 1c	 lea	 ebx, DWORD PTR [ecx+28]
$LL24@SetTargetV@3:

; 401  : 		(*iter).m_element->SetSize( m_targetsize.x, m_targetsize.y );

  0001a	f3 0f 2c 17	 cvttss2si edx, DWORD PTR [edi]
  0001e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00020	8b 01		 mov	 eax, DWORD PTR [ecx]
  00022	52		 push	 edx
  00023	f3 0f 2c 13	 cvttss2si edx, DWORD PTR [ebx]
  00027	52		 push	 edx
  00028	ff 50 10	 call	 DWORD PTR [eax+16]
  0002b	83 c6 08	 add	 esi, 8
  0002e	3b 75 fc	 cmp	 esi, DWORD PTR _eiter$[ebp]
  00031	75 e7		 jne	 SHORT $LL24@SetTargetV@3
  00033	5f		 pop	 edi
  00034	5b		 pop	 ebx
$LN1@SetTargetV@3:
  00035	5e		 pop	 esi

; 402  : 	}
; 403  : }

  00036	c9		 leave
  00037	c3		 ret	 0
?SetTargetValue@ioRenderElementAnimationFrameSize@@MAEXXZ ENDP ; ioRenderElementAnimationFrameSize::SetTargetValue
_TEXT	ENDS
PUBLIC	?OnBegin@ioRenderElementAnimationFrameSize@@UAEXXZ ; ioRenderElementAnimationFrameSize::OnBegin
EXTRN	__imp_?GetSize@ioUIRenderElement@@QBE?AUD3DXVECTOR2@@XZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ?OnBegin@ioRenderElementAnimationFrameSize@@UAEXXZ
_TEXT	SEGMENT
$T509691 = -44						; size = 8
$T509692 = -36						; size = 8
_vec$506297 = -28					; size = 8
_eiter$ = -20						; size = 4
tv402 = -16						; size = 4
tv398 = -16						; size = 4
tv391 = -16						; size = 4
$T509835 = -16						; size = 4
tv411 = -12						; size = 4
tv406 = -12						; size = 4
$T509823 = -8						; size = 4
tv456 = -4						; size = 4
?OnBegin@ioRenderElementAnimationFrameSize@@UAEXXZ PROC	; ioRenderElementAnimationFrameSize::OnBegin, COMDAT
; _this$ = ecx

; 410  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	53		 push	 ebx
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx

; 411  : 	ioRenderElementAnimationFrame::OnBegin();

  0000a	e8 00 00 00 00	 call	 ?OnBegin@ioRenderElementAnimationFrame@@UAEXXZ ; ioRenderElementAnimationFrame::OnBegin

; 412  : 
; 413  : 	int cnt = 0;
; 414  : 	ElementInfos::iterator iter = m_elements.begin();
; 415  : 	ElementInfos::iterator eiter = m_elements.end();

  0000f	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00012	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  00015	89 45 ec	 mov	 DWORD PTR _eiter$[ebp], eax

; 416  : 	for ( ; iter != eiter; ++iter, ++cnt )

  00018	3b d8		 cmp	 ebx, eax
  0001a	0f 84 3d 01 00
	00		 je	 $LN4@OnBegin@3

; 411  : 	ioRenderElementAnimationFrame::OnBegin();

  00020	83 65 fc 00	 and	 DWORD PTR tv456[ebp], 0
  00024	56		 push	 esi
$LL73@OnBegin@3:

; 417  : 	{	
; 418  : 		m_cursizes[ cnt ] = iter->m_element->GetSize();

  00025	8b 77 24	 mov	 esi, DWORD PTR [edi+36]
  00028	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0002a	03 75 fc	 add	 esi, DWORD PTR tv456[ebp]
  0002d	8d 45 d4	 lea	 eax, DWORD PTR $T509691[ebp]
  00030	50		 push	 eax
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSize@ioUIRenderElement@@QBE?AUD3DXVECTOR2@@XZ
  00037	8b 08		 mov	 ecx, DWORD PTR [eax]
  00039	89 0e		 mov	 DWORD PTR [esi], ecx
  0003b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003e	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 419  : 		D3DXVECTOR2 vec = m_targetsize - m_cursizes[ cnt ];

  00041	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  00044	03 45 fc	 add	 eax, DWORD PTR tv456[ebp]

; 420  : 		if ( m_targettime == 0 || ioMath::IsEqual( vec, D3DXVECTOR2( 0.0f, 0.0f ) ) ) 

  00047	83 7f 18 00	 cmp	 DWORD PTR [edi+24], 0
  0004b	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  00050	f3 0f 10 47 20	 movss	 xmm0, DWORD PTR [edi+32]
  00055	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  00059	0f 5a c9	 cvtps2pd xmm1, xmm1
  0005c	0f 5a c0	 cvtps2pd xmm0, xmm0
  0005f	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00063	f3 0f 10 4f 1c	 movss	 xmm1, DWORD PTR [edi+28]
  00068	0f 5a c9	 cvtps2pd xmm1, xmm1
  0006b	0f 5a d2	 cvtps2pd xmm2, xmm2
  0006e	f2 0f 5c ca	 subsd	 xmm1, xmm2
  00072	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00076	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  0007a	f3 0f 11 4d e4	 movss	 DWORD PTR _vec$506297[ebp], xmm1
  0007f	f3 0f 11 45 e8	 movss	 DWORD PTR _vec$506297[ebp+4], xmm0
  00084	0f 84 ba 00 00
	00		 je	 $LN2@OnBegin@3
  0008a	0f 57 c0	 xorps	 xmm0, xmm0
  0008d	51		 push	 ecx
  0008e	f3 0f 11 45 dc	 movss	 DWORD PTR $T509692[ebp], xmm0
  00093	f3 0f 11 45 e0	 movss	 DWORD PTR $T509692[ebp+4], xmm0
  00098	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@38d1b717
  000a0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a5	8d 45 dc	 lea	 eax, DWORD PTR $T509692[ebp]
  000a8	50		 push	 eax
  000a9	8d 45 e4	 lea	 eax, DWORD PTR _vec$506297[ebp]
  000ac	50		 push	 eax
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEqual@ioMath@@SA_NABUD3DXVECTOR2@@0M@Z
  000b3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b6	84 c0		 test	 al, al
  000b8	0f 85 86 00 00
	00		 jne	 $LN2@OnBegin@3

; 423  : 		}
; 424  : 		else 
; 425  : 		{
; 426  : 			float distance = D3DXVec2Length( &vec );

  000be	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _vec$506297[ebp+4]
  000c3	f3 0f 10 4d e4	 movss	 xmm1, DWORD PTR _vec$506297[ebp]
  000c8	0f 5a c0	 cvtps2pd xmm0, xmm0
  000cb	0f 5a c9	 cvtps2pd xmm1, xmm1
  000ce	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  000d2	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  000d6	f2 0f 58 c8	 addsd	 xmm1, xmm0
  000da	0f 57 c0	 xorps	 xmm0, xmm0
  000dd	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  000e1	f3 0f 11 45 f8	 movss	 DWORD PTR $T509823[ebp], xmm0

; 427  : 			iter->m_speed = distance / ( m_targettime * FLOAT0001 );

  000e6	b8 01 00 00 00	 mov	 eax, 1
  000eb	8b f0		 mov	 esi, eax
  000ed	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  000f2	d9 45 f8	 fld	 DWORD PTR $T509823[ebp]
  000f5	89 45 f0	 mov	 DWORD PTR $T509835[ebp], eax
  000f8	e8 00 00 00 00	 call	 __CIsqrt
  000fd	d9 5d f4	 fstp	 DWORD PTR tv411[ebp]
  00100	d9 45 f4	 fld	 DWORD PTR tv411[ebp]
  00103	89 75 f4	 mov	 DWORD PTR tv406[ebp], esi
  00106	db 45 f4	 fild	 DWORD PTR tv406[ebp]
  00109	85 f6		 test	 esi, esi
  0010b	79 06		 jns	 SHORT $LN74@OnBegin@3
  0010d	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN74@OnBegin@3:
  00113	8b 45 f0	 mov	 eax, DWORD PTR $T509835[ebp]
  00116	db 45 f0	 fild	 DWORD PTR $T509835[ebp]
  00119	85 c0		 test	 eax, eax
  0011b	79 06		 jns	 SHORT $LN75@OnBegin@3
  0011d	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN75@OnBegin@3:
  00123	de f9		 fdivp	 ST(1), ST(0)
  00125	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00128	d9 5d f0	 fstp	 DWORD PTR tv398[ebp]
  0012b	d9 45 f0	 fld	 DWORD PTR tv398[ebp]
  0012e	db 47 18	 fild	 DWORD PTR [edi+24]
  00131	85 c0		 test	 eax, eax
  00133	79 06		 jns	 SHORT $LN76@OnBegin@3
  00135	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN76@OnBegin@3:
  0013b	de c9		 fmulp	 ST(1), ST(0)
  0013d	de f9		 fdivp	 ST(1), ST(0)
  0013f	d9 5b 04	 fstp	 DWORD PTR [ebx+4]
  00142	eb 08		 jmp	 SHORT $LN5@OnBegin@3
$LN2@OnBegin@3:

; 421  : 		{
; 422  : 			iter->m_speed = 0.0f;

  00144	0f 57 c0	 xorps	 xmm0, xmm0
  00147	f3 0f 11 43 04	 movss	 DWORD PTR [ebx+4], xmm0
$LN5@OnBegin@3:

; 416  : 	for ( ; iter != eiter; ++iter, ++cnt )

  0014c	83 45 fc 08	 add	 DWORD PTR tv456[ebp], 8
  00150	83 c3 08	 add	 ebx, 8
  00153	3b 5d ec	 cmp	 ebx, DWORD PTR _eiter$[ebp]
  00156	0f 85 c9 fe ff
	ff		 jne	 $LL73@OnBegin@3
  0015c	5e		 pop	 esi
$LN4@OnBegin@3:
  0015d	5f		 pop	 edi
  0015e	5b		 pop	 ebx

; 428  : 		}
; 429  : 	}
; 430  : }

  0015f	c9		 leave
  00160	c3		 ret	 0
?OnBegin@ioRenderElementAnimationFrameSize@@UAEXXZ ENDP	; ioRenderElementAnimationFrameSize::OnBegin
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@YAXPAUElementInfo@ioRenderElementAnimationFrame@@0AAV?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@0@@Z ; std::_Destroy_range<std::allocator<ioRenderElementAnimationFrame::ElementInfo> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@YAXPAUElementInfo@ioRenderElementAnimationFrame@@0AAV?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@YAXPAUElementInfo@ioRenderElementAnimationFrame@@0AAV?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@0@@Z PROC ; std::_Destroy_range<std::allocator<ioRenderElementAnimationFrame::ElementInfo> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@YAXPAUElementInfo@ioRenderElementAnimationFrame@@0AAV?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<ioRenderElementAnimationFrame::ElementInfo> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UD3DXVECTOR2@@@std@@@std@@YAXPAUD3DXVECTOR2@@0AAV?$allocator@UD3DXVECTOR2@@@0@@Z ; std::_Destroy_range<std::allocator<D3DXVECTOR2> >
; Function compile flags: /Ogsp
;	COMDAT ??$_Destroy_range@V?$allocator@UD3DXVECTOR2@@@std@@@std@@YAXPAUD3DXVECTOR2@@0AAV?$allocator@UD3DXVECTOR2@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UD3DXVECTOR2@@@std@@@std@@YAXPAUD3DXVECTOR2@@0AAV?$allocator@UD3DXVECTOR2@@@0@@Z PROC ; std::_Destroy_range<std::allocator<D3DXVECTOR2> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@UD3DXVECTOR2@@@std@@@std@@YAXPAUD3DXVECTOR2@@0AAV?$allocator@UD3DXVECTOR2@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<D3DXVECTOR2> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAUD3DXVECTOR2@@IU1@V?$allocator@UD3DXVECTOR2@@@std@@@std@@YAXPAUD3DXVECTOR2@@IPBU1@AAV?$allocator@UD3DXVECTOR2@@@0@@Z ; std::_Uninitialized_fill_n<D3DXVECTOR2 *,unsigned int,D3DXVECTOR2,std::allocator<D3DXVECTOR2> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_fill_n@PAUD3DXVECTOR2@@IU1@V?$allocator@UD3DXVECTOR2@@@std@@@std@@YAXPAUD3DXVECTOR2@@IPBU1@AAV?$allocator@UD3DXVECTOR2@@@0@@Z
_TEXT	SEGMENT
__Cat$509938 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Pval$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAUD3DXVECTOR2@@IU1@V?$allocator@UD3DXVECTOR2@@@std@@@std@@YAXPAUD3DXVECTOR2@@IPBU1@AAV?$allocator@UD3DXVECTOR2@@@0@@Z PROC ; std::_Uninitialized_fill_n<D3DXVECTOR2 *,unsigned int,D3DXVECTOR2,std::allocator<D3DXVECTOR2> >, COMDAT

; 606  : 	{	// copy _Count * *_Pval to raw _First, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 607  : 	_Uninit_fill_n(_First, _Count, _Pval, _Al,
; 608  : 		_Val_type(_First), _Ptr_cat(_First, _First));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$509938[ebp]
  00007	6a 00		 push	 0
  00009	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000c	ff 75 10	 push	 DWORD PTR __Pval$[ebp]
  0000f	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00012	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00015	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAUD3DXVECTOR2@@IU1@V?$allocator@UD3DXVECTOR2@@@std@@U1@@std@@YAXPAUD3DXVECTOR2@@IPBU1@AAV?$allocator@UD3DXVECTOR2@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<D3DXVECTOR2 *,unsigned int,D3DXVECTOR2,std::allocator<D3DXVECTOR2>,D3DXVECTOR2>
  0001a	83 c4 18	 add	 esp, 24			; 00000018H

; 609  : 	}

  0001d	c9		 leave
  0001e	c3		 ret	 0
??$_Uninitialized_fill_n@PAUD3DXVECTOR2@@IU1@V?$allocator@UD3DXVECTOR2@@@std@@@std@@YAXPAUD3DXVECTOR2@@IPBU1@AAV?$allocator@UD3DXVECTOR2@@@0@@Z ENDP ; std::_Uninitialized_fill_n<D3DXVECTOR2 *,unsigned int,D3DXVECTOR2,std::allocator<D3DXVECTOR2> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUD3DXVECTOR2@@PAU1@V?$allocator@UD3DXVECTOR2@@@std@@@std@@YAPAUD3DXVECTOR2@@PAU1@00AAV?$allocator@UD3DXVECTOR2@@@0@@Z ; std::_Uninitialized_move<D3DXVECTOR2 *,D3DXVECTOR2 *,std::allocator<D3DXVECTOR2> >
; Function compile flags: /Ogsp
;	COMDAT ??$_Uninitialized_move@PAUD3DXVECTOR2@@PAU1@V?$allocator@UD3DXVECTOR2@@@std@@@std@@YAPAUD3DXVECTOR2@@PAU1@00AAV?$allocator@UD3DXVECTOR2@@@0@@Z
_TEXT	SEGMENT
__Cat$509948 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUD3DXVECTOR2@@PAU1@V?$allocator@UD3DXVECTOR2@@@std@@@std@@YAPAUD3DXVECTOR2@@PAU1@00AAV?$allocator@UD3DXVECTOR2@@@0@@Z PROC ; std::_Uninitialized_move<D3DXVECTOR2 *,D3DXVECTOR2 *,std::allocator<D3DXVECTOR2> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$509948[ebp]
  00007	6a 00		 push	 0
  00009	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000c	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000f	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00012	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00015	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUD3DXVECTOR2@@PAU1@V?$allocator@UD3DXVECTOR2@@@std@@U1@@std@@YAPAUD3DXVECTOR2@@PAU1@00AAV?$allocator@UD3DXVECTOR2@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<D3DXVECTOR2 *,D3DXVECTOR2 *,std::allocator<D3DXVECTOR2>,D3DXVECTOR2>
  0001a	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  0001d	c9		 leave
  0001e	c3		 ret	 0
??$_Uninitialized_move@PAUD3DXVECTOR2@@PAU1@V?$allocator@UD3DXVECTOR2@@@std@@@std@@YAPAUD3DXVECTOR2@@PAU1@00AAV?$allocator@UD3DXVECTOR2@@@0@@Z ENDP ; std::_Uninitialized_move<D3DXVECTOR2 *,D3DXVECTOR2 *,std::allocator<D3DXVECTOR2> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUElementInfo@ioRenderElementAnimationFrame@@PAU12@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@YAPAUElementInfo@ioRenderElementAnimationFrame@@PAU12@00AAV?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@0@@Z ; std::_Uninitialized_move<ioRenderElementAnimationFrame::ElementInfo *,ioRenderElementAnimationFrame::ElementInfo *,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >
; Function compile flags: /Ogsp
;	COMDAT ??$_Uninitialized_move@PAUElementInfo@ioRenderElementAnimationFrame@@PAU12@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@YAPAUElementInfo@ioRenderElementAnimationFrame@@PAU12@00AAV?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@0@@Z
_TEXT	SEGMENT
__Cat$509959 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUElementInfo@ioRenderElementAnimationFrame@@PAU12@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@YAPAUElementInfo@ioRenderElementAnimationFrame@@PAU12@00AAV?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@0@@Z PROC ; std::_Uninitialized_move<ioRenderElementAnimationFrame::ElementInfo *,ioRenderElementAnimationFrame::ElementInfo *,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$509959[ebp]
  00007	6a 00		 push	 0
  00009	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000c	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000f	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00012	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00015	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUElementInfo@ioRenderElementAnimationFrame@@PAU12@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@U12@@std@@YAPAUElementInfo@ioRenderElementAnimationFrame@@PAU12@00AAV?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ioRenderElementAnimationFrame::ElementInfo *,ioRenderElementAnimationFrame::ElementInfo *,std::allocator<ioRenderElementAnimationFrame::ElementInfo>,ioRenderElementAnimationFrame::ElementInfo>
  0001a	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  0001d	c9		 leave
  0001e	c3		 ret	 0
??$_Uninitialized_move@PAUElementInfo@ioRenderElementAnimationFrame@@PAU12@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@YAPAUElementInfo@ioRenderElementAnimationFrame@@PAU12@00AAV?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@0@@Z ENDP ; std::_Uninitialized_move<ioRenderElementAnimationFrame::ElementInfo *,ioRenderElementAnimationFrame::ElementInfo *,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IAEXPAUElementInfo@ioRenderElementAnimationFrame@@0@Z ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Destroy
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IAEXPAUElementInfo@ioRenderElementAnimationFrame@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IAEXPAUElementInfo@ioRenderElementAnimationFrame@@0@Z PROC ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Destroy, COMDAT
; _this$ = ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IAEXPAUElementInfo@ioRenderElementAnimationFrame@@0@Z ENDP ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXPAUD3DXVECTOR2@@0@Z ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Destroy
; Function compile flags: /Ogsp
;	COMDAT ?_Destroy@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXPAUD3DXVECTOR2@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXPAUD3DXVECTOR2@@0@Z PROC ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Destroy, COMDAT
; _this$ = ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXPAUD3DXVECTOR2@@0@Z ENDP ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEPAUD3DXVECTOR2@@PAU3@IPBU3@@Z ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Ufill
; Function compile flags: /Ogsp
;	COMDAT ?_Ufill@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEPAUD3DXVECTOR2@@PAU3@IPBU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Pval$ = 16						; size = 4
?_Ufill@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEPAUD3DXVECTOR2@@PAU3@IPBU3@@Z PROC ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Ufill, COMDAT
; _this$ = ecx

; 1420 : 		{	// copy initializing _Count * _Val, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1421 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, this->_Alval);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Count$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  0000b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000e	51		 push	 ecx
  0000f	ff 75 10	 push	 DWORD PTR __Pval$[ebp]
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	e8 00 00 00 00	 call	 ??$_Uninitialized_fill_n@PAUD3DXVECTOR2@@IU1@V?$allocator@UD3DXVECTOR2@@@std@@@std@@YAXPAUD3DXVECTOR2@@IPBU1@AAV?$allocator@UD3DXVECTOR2@@@0@@Z ; std::_Uninitialized_fill_n<D3DXVECTOR2 *,unsigned int,D3DXVECTOR2,std::allocator<D3DXVECTOR2> >
  00019	83 c4 10	 add	 esp, 16			; 00000010H

; 1422 : 		return (_Ptr + _Count);

  0001c	8d 04 f7	 lea	 eax, DWORD PTR [edi+esi*8]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi

; 1423 : 		}

  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEPAUD3DXVECTOR2@@PAU3@IPBU3@@Z ENDP ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Ufill
_TEXT	ENDS
PUBLIC	??$_Umove@PAUD3DXVECTOR2@@@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEPAUD3DXVECTOR2@@PAU2@00@Z ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Umove<D3DXVECTOR2 *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Umove@PAUD3DXVECTOR2@@@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEPAUD3DXVECTOR2@@PAU2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUD3DXVECTOR2@@@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEPAUD3DXVECTOR2@@PAU2@00@Z PROC ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Umove<D3DXVECTOR2 *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	51		 push	 ecx
  00007	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUD3DXVECTOR2@@PAU1@V?$allocator@UD3DXVECTOR2@@@std@@@std@@YAPAUD3DXVECTOR2@@PAU1@00AAV?$allocator@UD3DXVECTOR2@@@0@@Z ; std::_Uninitialized_move<D3DXVECTOR2 *,D3DXVECTOR2 *,std::allocator<D3DXVECTOR2> >
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00018	5d		 pop	 ebp
  00019	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUD3DXVECTOR2@@@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEPAUD3DXVECTOR2@@PAU2@00@Z ENDP ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Umove<D3DXVECTOR2 *>
_TEXT	ENDS
PUBLIC	??$_Umove@PAUElementInfo@ioRenderElementAnimationFrame@@@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IAEPAUElementInfo@ioRenderElementAnimationFrame@@PAU23@00@Z ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Umove<ioRenderElementAnimationFrame::ElementInfo *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Umove@PAUElementInfo@ioRenderElementAnimationFrame@@@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IAEPAUElementInfo@ioRenderElementAnimationFrame@@PAU23@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUElementInfo@ioRenderElementAnimationFrame@@@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IAEPAUElementInfo@ioRenderElementAnimationFrame@@PAU23@00@Z PROC ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Umove<ioRenderElementAnimationFrame::ElementInfo *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	51		 push	 ecx
  00007	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUElementInfo@ioRenderElementAnimationFrame@@PAU12@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@YAPAUElementInfo@ioRenderElementAnimationFrame@@PAU12@00AAV?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@0@@Z ; std::_Uninitialized_move<ioRenderElementAnimationFrame::ElementInfo *,ioRenderElementAnimationFrame::ElementInfo *,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00018	5d		 pop	 ebp
  00019	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUElementInfo@ioRenderElementAnimationFrame@@@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IAEPAUElementInfo@ioRenderElementAnimationFrame@@PAU23@00@Z ENDP ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Umove<ioRenderElementAnimationFrame::ElementInfo *>
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IAEXXZ ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Tidy
EXTRN	__imp_?_Orphan_all@_Container_base0@std@@QAEXXZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ?_Tidy@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IAEXXZ PROC ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00006	74 0e		 je	 SHORT $LN21@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  0000e	ff 36		 push	 DWORD PTR [esi]
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	59		 pop	 ecx
$LN21@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00016	83 26 00	 and	 DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

  00019	83 66 04 00	 and	 DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

  0001d	83 66 08 00	 and	 DWORD PTR [esi+8], 0
  00021	5e		 pop	 esi

; 1312 : 		}

  00022	c3		 ret	 0
?_Tidy@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IAEXXZ ENDP ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@0@Z ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::erase
; Function compile flags: /Ogsp
;	COMDAT ?erase@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Cat$510237 = 16					; size = 1
__Last_arg$ = 16					; size = 4
?erase@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@0@Z PROC ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	8b f1		 mov	 esi, ecx
  0000d	89 07		 mov	 DWORD PTR [edi], eax

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);
; 1193 : 
; 1194 : 		if (_First != _Last)

  0000f	3b 45 10	 cmp	 eax, DWORD PTR __Last_arg$[ebp]
  00012	74 16		 je	 SHORT $LN1@erase

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  00014	ff 75 10	 push	 DWORD PTR __Cat$510237[ebp]
  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	50		 push	 eax
  0001b	51		 push	 ecx
  0001c	ff 75 10	 push	 DWORD PTR __Last_arg$[ebp]
  0001f	e8 00 00 00 00	 call	 ??$_Move@PAUD3DXVECTOR2@@PAU1@@std@@YAPAUD3DXVECTOR2@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<D3DXVECTOR2 *,D3DXVECTOR2 *>
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);
; 1211 : 			this->_Mylast = _Ptr;

  00027	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN1@erase:

; 1212 : 			}
; 1213 : 		return (_First);

  0002a	8b c7		 mov	 eax, edi
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi

; 1214 : 		}

  0002e	5d		 pop	 ebp
  0002f	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@0@Z ENDP ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXXZ ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Tidy
; Function compile flags: /Ogsp
;	COMDAT ?_Tidy@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXXZ PROC ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00006	74 0e		 je	 SHORT $LN21@Tidy@2

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  0000e	ff 36		 push	 DWORD PTR [esi]
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	59		 pop	 ecx
$LN21@Tidy@2:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00016	83 26 00	 and	 DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

  00019	83 66 04 00	 and	 DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

  0001d	83 66 08 00	 and	 DWORD PTR [esi+8], 0
  00021	5e		 pop	 esi

; 1312 : 		}

  00022	c3		 ret	 0
?_Tidy@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXXZ ENDP ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@IABUD3DXVECTOR2@@@Z ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Insert_n
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__EH_epilog3:PROC
EXTRN	__EH_prolog3_catch:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@IABUD3DXVECTOR2@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@IABUD3DXVECTOR2@@@Z$2
__catchsym$?_Insert_n@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@IABUD3DXVECTOR2@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@IABUD3DXVECTOR2@@@Z$0
__unwindtable$?_Insert_n@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@IABUD3DXVECTOR2@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@IABUD3DXVECTOR2@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@IABUD3DXVECTOR2@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@IABUD3DXVECTOR2@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@IABUD3DXVECTOR2@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@IABUD3DXVECTOR2@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@IABUD3DXVECTOR2@@@Z$5
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@IABUD3DXVECTOR2@@@Z
_TEXT	SEGMENT
__Tmp$506654 = -24					; size = 8
__Tmp$506640 = -24					; size = 8
__Capacity$506620 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$510818 = 8					; size = 1
__Cat$510706 = 8					; size = 1
__Where$ = 8						; size = 4
__Newvec$506621 = 12					; size = 4
__Count$ = 12						; size = 4
tv730 = 16						; size = 4
tv708 = 16						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@IABUD3DXVECTOR2@@@Z PROC ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Insert_n, COMDAT
; _this$ = ecx

; 1330 : 		{	// insert _Count * _Val at _Where

  00000	6a 0c		 push	 12			; 0000000cH
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?_Insert_n@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@IABUD3DXVECTOR2@@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_catch
  0000c	8b f1		 mov	 esi, ecx

; 1331 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1332 : 		if (_VICONT(_Where) != this
; 1333 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1334 : 			|| this->_Mylast < _VIPTR(_Where))
; 1335 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1336 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 
; 1338 : 		if (_Count == 0)

  0000e	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00011	85 ff		 test	 edi, edi
  00013	0f 84 b0 01 00
	00		 je	 $LN151@Insert_n

; 1339 : 			;
; 1340 : 		else if (max_size() - size() < _Count)

  00019	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  0001c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0001e	8b c3		 mov	 eax, ebx
  00020	2b c1		 sub	 eax, ecx
  00022	c1 f8 03	 sar	 eax, 3
  00025	ba ff ff ff 1f	 mov	 edx, 536870911		; 1fffffffH
  0002a	2b d0		 sub	 edx, eax
  0002c	3b d7		 cmp	 edx, edi
  0002e	73 0b		 jae	 SHORT $LN11@Insert_n

; 1341 : 			_Xlen();	// result too long

  00030	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN170@Insert_n:
$LN11@Insert_n:

; 1342 : 		else if (capacity() < size() + _Count)

  0003b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0003e	2b d1		 sub	 edx, ecx
  00040	03 c7		 add	 eax, edi
  00042	c1 fa 03	 sar	 edx, 3
  00045	3b d0		 cmp	 edx, eax
  00047	0f 83 bb 00 00
	00		 jae	 $LN9@Insert_n

; 1343 : 			{	// not enough room, reallocate
; 1344 : 			size_type _Capacity = _Grow_to(size() + _Count);

  0004d	50		 push	 eax
  0004e	8b ce		 mov	 ecx, esi
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IBEII@Z ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Grow_to

; 1345 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  00055	6a 00		 push	 0
  00057	50		 push	 eax
  00058	89 45 ec	 mov	 DWORD PTR __Capacity$506620[ebp], eax
  0005b	e8 00 00 00 00	 call	 ??$_Allocate@UD3DXVECTOR2@@@std@@YAPAUD3DXVECTOR2@@IPAU1@@Z ; std::_Allocate<D3DXVECTOR2>

; 1346 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;

  00060	8b 5d 08	 mov	 ebx, DWORD PTR __Where$[ebp]
  00063	2b 1e		 sub	 ebx, DWORD PTR [esi]

; 1347 : 			int _Ncopied = 0;
; 1348 : 
; 1349 : 			_TRY_BEGIN

  00065	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
  00069	59		 pop	 ecx
  0006a	59		 pop	 ecx

; 1350 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1351 : 				_STD addressof(_Val));	// add new stuff

  0006b	ff 75 10	 push	 DWORD PTR __Val$[ebp]
  0006e	89 45 0c	 mov	 DWORD PTR __Newvec$506621[ebp], eax
  00071	c1 fb 03	 sar	 ebx, 3
  00074	8d 04 d8	 lea	 eax, DWORD PTR [eax+ebx*8]
  00077	57		 push	 edi
  00078	50		 push	 eax
  00079	8b ce		 mov	 ecx, esi
  0007b	e8 00 00 00 00	 call	 ?_Ufill@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEPAUD3DXVECTOR2@@PAU3@IPBU3@@Z ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Ufill

; 1352 : 			++_Ncopied;
; 1353 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1354 : 				_Newvec);	// copy prefix

  00080	8b 06		 mov	 eax, DWORD PTR [esi]
  00082	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00085	51		 push	 ecx
  00086	ff 75 0c	 push	 DWORD PTR __Newvec$506621[ebp]
  00089	ff 75 08	 push	 DWORD PTR __Where$[ebp]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUD3DXVECTOR2@@PAU1@V?$allocator@UD3DXVECTOR2@@@std@@@std@@YAPAUD3DXVECTOR2@@PAU1@00AAV?$allocator@UD3DXVECTOR2@@@0@@Z ; std::_Uninitialized_move<D3DXVECTOR2 *,D3DXVECTOR2 *,std::allocator<D3DXVECTOR2> >

; 1355 : 			++_Ncopied;
; 1356 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1357 : 				_Newvec + (_Whereoff + _Count));	// copy suffix

  00092	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00095	83 c4 10	 add	 esp, 16			; 00000010H
  00098	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0009b	51		 push	 ecx
  0009c	8d 0c 3b	 lea	 ecx, DWORD PTR [ebx+edi]
  0009f	8b 5d 0c	 mov	 ebx, DWORD PTR __Newvec$506621[ebp]
  000a2	8d 0c cb	 lea	 ecx, DWORD PTR [ebx+ecx*8]
  000a5	51		 push	 ecx
  000a6	50		 push	 eax
  000a7	ff 75 08	 push	 DWORD PTR __Where$[ebp]
  000aa	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUD3DXVECTOR2@@PAU1@V?$allocator@UD3DXVECTOR2@@@std@@@std@@YAPAUD3DXVECTOR2@@PAU1@00AAV?$allocator@UD3DXVECTOR2@@@0@@Z ; std::_Uninitialized_move<D3DXVECTOR2 *,D3DXVECTOR2 *,std::allocator<D3DXVECTOR2> >

; 1365 : 			_CATCH_END
; 1366 : 
; 1367 : 			_Count += size();

  000af	8b 06		 mov	 eax, DWORD PTR [esi]
  000b1	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000b4	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  000b8	2b c8		 sub	 ecx, eax
  000ba	c1 f9 03	 sar	 ecx, 3
  000bd	83 c4 10	 add	 esp, 16			; 00000010H
  000c0	03 f9		 add	 edi, ecx
  000c2	85 c0		 test	 eax, eax
  000c4	74 12		 je	 SHORT $LN104@Insert_n

; 1368 : 			if (this->_Myfirst != 0)

  000c6	eb 03		 jmp	 SHORT $LN169@Insert_n

; 1369 : 				{	// destroy and deallocate old array
; 1370 : 				_Destroy(this->_Myfirst, this->_Mylast);

$LL95@Insert_n:
  000c8	83 c0 08	 add	 eax, 8
$LN169@Insert_n:
  000cb	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  000ce	75 f8		 jne	 SHORT $LL95@Insert_n

; 1371 : 				this->_Alval.deallocate(this->_Myfirst,
; 1372 : 					this->_Myend - this->_Myfirst);

  000d0	ff 36		 push	 DWORD PTR [esi]
  000d2	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000d7	59		 pop	 ecx
$LN104@Insert_n:

; 1373 : 				}
; 1374 : 
; 1375 : 			this->_Orphan_all();

  000d8	8b ce		 mov	 ecx, esi
  000da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 1376 : 			this->_Myend = _Newvec + _Capacity;

  000e0	8b 45 ec	 mov	 eax, DWORD PTR __Capacity$506620[ebp]
  000e3	8d 04 c3	 lea	 eax, DWORD PTR [ebx+eax*8]
  000e6	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1377 : 			this->_Mylast = _Newvec + _Count;

  000e9	8d 04 fb	 lea	 eax, DWORD PTR [ebx+edi*8]
  000ec	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1378 : 			this->_Myfirst = _Newvec;

  000ef	89 1e		 mov	 DWORD PTR [esi], ebx

; 1379 : 			}
; 1380 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))

  000f1	e9 d3 00 00 00	 jmp	 $LN151@Insert_n
__catch$?_Insert_n@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@IABUD3DXVECTOR2@@@Z$0:

; 1358 : 			_CATCH_ALL
; 1359 : 			if (1 < _Ncopied)
; 1360 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1361 : 			if (0 < _Ncopied)
; 1362 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1363 : 			this->_Alval.deallocate(_Newvec, _Capacity);

  000f6	ff 75 0c	 push	 DWORD PTR __Newvec$506621[ebp]
  000f9	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000fe	59		 pop	 ecx
__catch$?_Insert_n@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@IABUD3DXVECTOR2@@@Z$2:

; 1364 : 			_RERAISE;

  000ff	6a 00		 push	 0
  00101	6a 00		 push	 0
  00103	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN171@Insert_n:
$LN9@Insert_n:

; 1381 : 			< _Count)

  00108	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  0010b	8b c3		 mov	 eax, ebx
  0010d	2b c1		 sub	 eax, ecx
  0010f	c1 f8 03	 sar	 eax, 3
  00112	3b c7		 cmp	 eax, edi

; 1382 : 			{	// new stuff spills off end
; 1383 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

  00114	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00117	73 69		 jae	 SHORT $LN3@Insert_n
  00119	8b 10		 mov	 edx, DWORD PTR [eax]
  0011b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0011e	89 45 ec	 mov	 DWORD PTR __Tmp$506640[ebp+4], eax

; 1384 : 
; 1385 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1386 : 				_VIPTR(_Where) + _Count);	// copy suffix

  00121	8b c7		 mov	 eax, edi
  00123	c1 e0 03	 shl	 eax, 3
  00126	89 55 e8	 mov	 DWORD PTR __Tmp$506640[ebp], edx
  00129	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  0012c	52		 push	 edx
  0012d	89 45 10	 mov	 DWORD PTR tv708[ebp], eax
  00130	03 c1		 add	 eax, ecx
  00132	50		 push	 eax
  00133	53		 push	 ebx
  00134	51		 push	 ecx
  00135	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUD3DXVECTOR2@@PAU1@V?$allocator@UD3DXVECTOR2@@@std@@@std@@YAPAUD3DXVECTOR2@@PAU1@00AAV?$allocator@UD3DXVECTOR2@@@0@@Z ; std::_Uninitialized_move<D3DXVECTOR2 *,D3DXVECTOR2 *,std::allocator<D3DXVECTOR2> >

; 1387 : 
; 1388 : 			_TRY_BEGIN
; 1389 : 			_Ufill(this->_Mylast,
; 1390 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1391 : 				_STD addressof(_Tmp));	// insert new stuff off end

  0013a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0013d	ff 75 08	 push	 DWORD PTR __Cat$510706[ebp]
  00140	8b c8		 mov	 ecx, eax
  00142	2b 4d 08	 sub	 ecx, DWORD PTR __Where$[ebp]
  00145	6a 00		 push	 0
  00147	c1 f9 03	 sar	 ecx, 3
  0014a	2b f9		 sub	 edi, ecx
  0014c	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0014f	51		 push	 ecx
  00150	8d 4d e8	 lea	 ecx, DWORD PTR __Tmp$506640[ebp]
  00153	51		 push	 ecx
  00154	57		 push	 edi
  00155	50		 push	 eax
  00156	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2
  0015d	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAUD3DXVECTOR2@@IU1@V?$allocator@UD3DXVECTOR2@@@std@@U1@@std@@YAXPAUD3DXVECTOR2@@IPBU1@AAV?$allocator@UD3DXVECTOR2@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<D3DXVECTOR2 *,unsigned int,D3DXVECTOR2,std::allocator<D3DXVECTOR2>,D3DXVECTOR2>

; 1392 : 			_CATCH_ALL
; 1393 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1394 : 				this->_Mylast + _Count);
; 1395 : 			_RERAISE;
; 1396 : 			_CATCH_END
; 1397 : 
; 1398 : 			this->_Mylast += _Count;

  00162	8b 45 10	 mov	 eax, DWORD PTR tv708[ebp]
  00165	01 46 04	 add	 DWORD PTR [esi+4], eax
  00168	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  0016b	83 c4 28	 add	 esp, 40			; 00000028H

; 1399 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1400 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1401 : 				_Tmp);	// insert up to old end

  0016e	8d 4d e8	 lea	 ecx, DWORD PTR __Tmp$506640[ebp]
  00171	51		 push	 ecx
  00172	2b f0		 sub	 esi, eax
  00174	56		 push	 esi
  00175	ff 75 08	 push	 DWORD PTR __Where$[ebp]
  00178	e8 00 00 00 00	 call	 ??$_Fill@PAUD3DXVECTOR2@@U1@@std@@YAXPAUD3DXVECTOR2@@0ABU1@@Z ; std::_Fill<D3DXVECTOR2 *,D3DXVECTOR2>
  0017d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1402 : 			}
; 1403 : 		else

  00180	eb 47		 jmp	 SHORT $LN151@Insert_n
$LN3@Insert_n:

; 1404 : 			{	// new stuff can all be assigned
; 1405 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

  00182	8b 08		 mov	 ecx, DWORD PTR [eax]
  00184	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00187	89 45 ec	 mov	 DWORD PTR __Tmp$506654[ebp+4], eax

; 1406 : 
; 1407 : 			pointer _Oldend = this->_Mylast;
; 1408 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1409 : 				this->_Mylast);	// copy suffix

  0018a	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  0018d	50		 push	 eax
  0018e	53		 push	 ebx
  0018f	c1 e7 03	 shl	 edi, 3
  00192	89 5d 10	 mov	 DWORD PTR tv730[ebp], ebx
  00195	29 7d 10	 sub	 DWORD PTR tv730[ebp], edi
  00198	53		 push	 ebx
  00199	ff 75 10	 push	 DWORD PTR tv730[ebp]
  0019c	89 4d e8	 mov	 DWORD PTR __Tmp$506654[ebp], ecx
  0019f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUD3DXVECTOR2@@PAU1@V?$allocator@UD3DXVECTOR2@@@std@@@std@@YAPAUD3DXVECTOR2@@PAU1@00AAV?$allocator@UD3DXVECTOR2@@@0@@Z ; std::_Uninitialized_move<D3DXVECTOR2 *,D3DXVECTOR2 *,std::allocator<D3DXVECTOR2> >

; 1410 : 
; 1411 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1412 : 			_STD _Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1413 : 				_Oldend);	// copy hole

  001a4	ff 75 08	 push	 DWORD PTR __Cat$510818[ebp]
  001a7	89 46 04	 mov	 DWORD PTR [esi+4], eax
  001aa	53		 push	 ebx
  001ab	ff 75 10	 push	 DWORD PTR tv730[ebp]
  001ae	ff 75 08	 push	 DWORD PTR __Where$[ebp]
  001b1	e8 00 00 00 00	 call	 ??$_Copy_backward@PAUD3DXVECTOR2@@PAU1@@std@@YAPAUD3DXVECTOR2@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward<D3DXVECTOR2 *,D3DXVECTOR2 *>

; 1414 : 			_STD fill(_VIPTR(_Where),
; 1415 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole

  001b6	8d 45 e8	 lea	 eax, DWORD PTR __Tmp$506654[ebp]
  001b9	50		 push	 eax
  001ba	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  001bd	03 f8		 add	 edi, eax
  001bf	57		 push	 edi
  001c0	50		 push	 eax
  001c1	e8 00 00 00 00	 call	 ??$_Fill@PAUD3DXVECTOR2@@U1@@std@@YAXPAUD3DXVECTOR2@@0ABU1@@Z ; std::_Fill<D3DXVECTOR2 *,D3DXVECTOR2>
  001c6	83 c4 2c	 add	 esp, 44			; 0000002cH
$LN151@Insert_n:

; 1416 : 			}
; 1417 : 		}

  001c9	e8 00 00 00 00	 call	 __EH_epilog3
  001ce	c2 0c 00	 ret	 12			; 0000000cH
$LN168@Insert_n:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@IABUD3DXVECTOR2@@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@IABUD3DXVECTOR2@@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@IABUD3DXVECTOR2@@@Z ENDP ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Insert_n
PUBLIC	?reserve@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAEXI@Z ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::reserve
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Ptr$506686 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAEXI@Z PROC ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	6a 08		 push	 8
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?reserve@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAEXI@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_catch
  0000c	8b f1		 mov	 esi, ecx

; 747  : 		if (max_size() < _Count)

  0000e	81 7d 08 ff ff
	ff 1f		 cmp	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH
  00015	76 0b		 jbe	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  00017	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN56@reserve:
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  00022	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00025	2b 06		 sub	 eax, DWORD PTR [esi]
  00027	c1 f8 03	 sar	 eax, 3
  0002a	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0002d	73 65		 jae	 SHORT $LN3@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0002f	6a 00		 push	 0
  00031	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00034	e8 00 00 00 00	 call	 ??$_Allocate@UElementInfo@ioRenderElementAnimationFrame@@@std@@YAPAUElementInfo@ioRenderElementAnimationFrame@@IPAU12@@Z ; std::_Allocate<ioRenderElementAnimationFrame::ElementInfo>

; 752  : 
; 753  : 			_TRY_BEGIN
; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00039	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0003b	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
  0003f	8b d8		 mov	 ebx, eax
  00041	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00044	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  00047	52		 push	 edx
  00048	53		 push	 ebx
  00049	50		 push	 eax
  0004a	51		 push	 ecx
  0004b	89 5d ec	 mov	 DWORD PTR __Ptr$506686[ebp], ebx
  0004e	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUElementInfo@ioRenderElementAnimationFrame@@PAU12@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@YAPAUElementInfo@ioRenderElementAnimationFrame@@PAU12@00AAV?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@0@@Z ; std::_Uninitialized_move<ioRenderElementAnimationFrame::ElementInfo *,ioRenderElementAnimationFrame::ElementInfo *,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >

; 758  : 			_CATCH_END
; 759  : 
; 760  : 			size_type _Size = size();

  00053	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00056	8b 06		 mov	 eax, DWORD PTR [esi]
  00058	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0005c	8b f9		 mov	 edi, ecx
  0005e	2b f8		 sub	 edi, eax
  00060	83 c4 18	 add	 esp, 24			; 00000018H
  00063	c1 ff 03	 sar	 edi, 3
  00066	85 c0		 test	 eax, eax
  00068	74 11		 je	 SHORT $LN48@reserve

; 761  : 			if (this->_Myfirst != 0)

  0006a	eb 03		 jmp	 SHORT $LN55@reserve

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

$LL39@reserve:
  0006c	83 c0 08	 add	 eax, 8
$LN55@reserve:
  0006f	3b c1		 cmp	 eax, ecx
  00071	75 f9		 jne	 SHORT $LL39@reserve

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  00073	ff 36		 push	 DWORD PTR [esi]
  00075	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0007a	59		 pop	 ecx
$LN48@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  0007b	8b ce		 mov	 ecx, esi
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 769  : 			this->_Myend = _Ptr + _Count;

  00083	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00086	8d 04 c3	 lea	 eax, DWORD PTR [ebx+eax*8]
  00089	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 770  : 			this->_Mylast = _Ptr + _Size;

  0008c	8d 04 fb	 lea	 eax, DWORD PTR [ebx+edi*8]
  0008f	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 771  : 			this->_Myfirst = _Ptr;

  00092	89 1e		 mov	 DWORD PTR [esi], ebx
$LN3@reserve:

; 772  : 			}
; 773  : 		}

  00094	e8 00 00 00 00	 call	 __EH_epilog3
  00099	c2 04 00	 ret	 4
__catch$?reserve@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0009c	ff 75 ec	 push	 DWORD PTR __Ptr$506686[ebp]
  0009f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a4	59		 pop	 ecx

; 757  : 			_RERAISE;

  000a5	6a 00		 push	 0
  000a7	6a 00		 push	 0
  000a9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN57@reserve:
$LN54@reserve:
  000ae	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAEXI@Z ENDP ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::reserve
PUBLIC	??1?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAE@XZ ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::~vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAE@XZ PROC ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::~vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >, COMDAT
; _this$ = ecx

; 705  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IAEXXZ ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Tidy
??1?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAE@XZ ENDP ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::~vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >
_TEXT	ENDS
PUBLIC	??1?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::~vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@XZ PROC ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::~vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >, COMDAT
; _this$ = ecx

; 705  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXXZ ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Tidy
??1?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@XZ ENDP ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::~vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >
_TEXT	ENDS
PUBLIC	?resize@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAEXIUD3DXVECTOR2@@@Z ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::resize
; Function compile flags: /Ogsp
;	COMDAT ?resize@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAEXIUD3DXVECTOR2@@@Z
_TEXT	SEGMENT
$T511017 = 8						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 8
?resize@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAEXIUD3DXVECTOR2@@@Z PROC ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::resize, COMDAT
; _this$ = ecx

; 870  : 		{	// determine new length, padding with _Val elements as needed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 871  : 		if (size() < _Newsize)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  00006	56		 push	 esi
  00007	8b 31		 mov	 esi, DWORD PTR [ecx]
  00009	57		 push	 edi
  0000a	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  0000d	8b c7		 mov	 eax, edi
  0000f	2b c6		 sub	 eax, esi
  00011	c1 f8 03	 sar	 eax, 3
  00014	3b d0		 cmp	 edx, eax
  00016	76 0f		 jbe	 SHORT $LN42@resize

; 872  : 			_Insert_n(end(), _Newsize - size(), _Val);

  00018	8d 75 0c	 lea	 esi, DWORD PTR __Val$[ebp]
  0001b	56		 push	 esi
  0001c	2b d0		 sub	 edx, eax
  0001e	52		 push	 edx
  0001f	57		 push	 edi
  00020	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@IABUD3DXVECTOR2@@@Z ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Insert_n

; 873  : 		else if (_Newsize < size())

  00025	eb 10		 jmp	 SHORT $LN1@resize
$LN42@resize:
  00027	73 0e		 jae	 SHORT $LN1@resize

; 874  : 			erase(begin() + _Newsize, end());

  00029	8d 04 d6	 lea	 eax, DWORD PTR [esi+edx*8]
  0002c	57		 push	 edi
  0002d	50		 push	 eax
  0002e	8d 45 08	 lea	 eax, DWORD PTR $T511017[ebp]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ?erase@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@@2@0@Z ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::erase
$LN1@resize:
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi

; 875  : 		}

  00039	5d		 pop	 ebp
  0003a	c2 0c 00	 ret	 12			; 0000000cH
?resize@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAEXIUD3DXVECTOR2@@@Z ENDP ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::resize
_TEXT	ENDS
PUBLIC	?_Reserve@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IAEXI@Z ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Reserve
; Function compile flags: /Ogsp
;	COMDAT ?_Reserve@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IAEXI@Z PROC ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1291 : 		size_type _Size = size();

  00006	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00008	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000b	2b c1		 sub	 eax, ecx

; 1292 : 		if (max_size() - _Count < _Size)

  0000d	ba ff ff ff 1f	 mov	 edx, 536870911		; 1fffffffH
  00012	2b 55 08	 sub	 edx, DWORD PTR __Count$[ebp]
  00015	c1 f8 03	 sar	 eax, 3
  00018	3b d0		 cmp	 edx, eax
  0001a	73 0b		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN21@Reserve:
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00027	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002a	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  0002d	2b d1		 sub	 edx, ecx
  0002f	c1 fa 03	 sar	 edx, 3
  00032	3b c2		 cmp	 eax, edx
  00034	76 10		 jbe	 SHORT $LN1@Reserve

; 1295 : 			;
; 1296 : 		else
; 1297 : 			reserve(_Grow_to(_Size));

  00036	50		 push	 eax
  00037	8b ce		 mov	 ecx, esi
  00039	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IBEII@Z ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Grow_to
  0003e	50		 push	 eax
  0003f	8b ce		 mov	 ecx, esi
  00041	e8 00 00 00 00	 call	 ?reserve@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAEXI@Z ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::reserve
$LN1@Reserve:
  00046	5e		 pop	 esi

; 1298 : 		}

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN20@Reserve:
?_Reserve@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IAEXI@Z ENDP ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Reserve
_TEXT	ENDS
PUBLIC	??_7ioRenderElementAnimationFrame@@6B@		; ioRenderElementAnimationFrame::`vftable'
PUBLIC	??1ioRenderElementAnimationFrame@@UAE@XZ	; ioRenderElementAnimationFrame::~ioRenderElementAnimationFrame
PUBLIC	??_R4ioRenderElementAnimationFrame@@6B@		; ioRenderElementAnimationFrame::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVioRenderElementAnimationFrame@@@8	; ioRenderElementAnimationFrame `RTTI Type Descriptor'
PUBLIC	??_R3ioRenderElementAnimationFrame@@8		; ioRenderElementAnimationFrame::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioRenderElementAnimationFrame@@8		; ioRenderElementAnimationFrame::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ioRenderElementAnimationFrame@@8	; ioRenderElementAnimationFrame::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?OnEnd@ioRenderElementAnimationFrame@@UAEXXZ	; ioRenderElementAnimationFrame::OnEnd
PUBLIC	?SetTargetValue@ioRenderElementAnimationFrame@@MAEXXZ ; ioRenderElementAnimationFrame::SetTargetValue
EXTRN	??_EioRenderElementAnimationFrame@@UAEPAXI@Z:PROC ; ioRenderElementAnimationFrame::`vector deleting destructor'
EXTRN	__purecall:PROC
;	COMDAT ??_R1A@?0A@EA@ioRenderElementAnimationFrame@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioRenderElementAnimationFrame@@8 DD FLAT:??_R0?AVioRenderElementAnimationFrame@@@8 ; ioRenderElementAnimationFrame::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioRenderElementAnimationFrame@@8
rdata$r	ENDS
;	COMDAT ??_R2ioRenderElementAnimationFrame@@8
rdata$r	SEGMENT
??_R2ioRenderElementAnimationFrame@@8 DD FLAT:??_R1A@?0A@EA@ioRenderElementAnimationFrame@@8 ; ioRenderElementAnimationFrame::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ioRenderElementAnimationFrame@@8
rdata$r	SEGMENT
??_R3ioRenderElementAnimationFrame@@8 DD 00H		; ioRenderElementAnimationFrame::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ioRenderElementAnimationFrame@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioRenderElementAnimationFrame@@@8
_DATA	SEGMENT
??_R0?AVioRenderElementAnimationFrame@@@8 DD FLAT:??_7type_info@@6B@ ; ioRenderElementAnimationFrame `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioRenderElementAnimationFrame@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ioRenderElementAnimationFrame@@6B@
rdata$r	SEGMENT
??_R4ioRenderElementAnimationFrame@@6B@ DD 00H		; ioRenderElementAnimationFrame::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVioRenderElementAnimationFrame@@@8
	DD	FLAT:??_R3ioRenderElementAnimationFrame@@8
rdata$r	ENDS
;	COMDAT ??_7ioRenderElementAnimationFrame@@6B@
CONST	SEGMENT
??_7ioRenderElementAnimationFrame@@6B@ DD FLAT:??_R4ioRenderElementAnimationFrame@@6B@ ; ioRenderElementAnimationFrame::`vftable'
	DD	FLAT:??_EioRenderElementAnimationFrame@@UAEPAXI@Z
	DD	FLAT:?Update@ioRenderElementAnimationFrame@@UAE_NXZ
	DD	FLAT:?OnBegin@ioRenderElementAnimationFrame@@UAEXXZ
	DD	FLAT:?OnEnd@ioRenderElementAnimationFrame@@UAEXXZ
	DD	FLAT:__purecall
	DD	FLAT:?SetTargetValue@ioRenderElementAnimationFrame@@MAEXXZ
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\iorenderelementanimationframe.cpp
CONST	ENDS
;	COMDAT ??1ioRenderElementAnimationFrame@@UAE@XZ
_TEXT	SEGMENT
??1ioRenderElementAnimationFrame@@UAE@XZ PROC		; ioRenderElementAnimationFrame::~ioRenderElementAnimationFrame, COMDAT
; _this$ = ecx

; 50   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ioRenderElementAnimationFrame@@6B@

; 51   : }

  00006	83 c1 04	 add	 ecx, 4
  00009	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IAEXXZ ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Tidy
??1ioRenderElementAnimationFrame@@UAE@XZ ENDP		; ioRenderElementAnimationFrame::~ioRenderElementAnimationFrame
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\iorenderelementanimationframe.h
_TEXT	ENDS
;	COMDAT ?OnEnd@ioRenderElementAnimationFrame@@UAEXXZ
_TEXT	SEGMENT
?OnEnd@ioRenderElementAnimationFrame@@UAEXXZ PROC	; ioRenderElementAnimationFrame::OnEnd, COMDAT
; _this$ = ecx

; 62   : 	virtual void				OnEnd() {}

  00000	c3		 ret	 0
?OnEnd@ioRenderElementAnimationFrame@@UAEXXZ ENDP	; ioRenderElementAnimationFrame::OnEnd
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?SetTargetValue@ioRenderElementAnimationFrame@@MAEXXZ
_TEXT	SEGMENT
?SetTargetValue@ioRenderElementAnimationFrame@@MAEXXZ PROC ; ioRenderElementAnimationFrame::SetTargetValue, COMDAT
; _this$ = ecx

; 76   : 	virtual void				SetTargetValue() {}

  00000	c3		 ret	 0
?SetTargetValue@ioRenderElementAnimationFrame@@MAEXXZ ENDP ; ioRenderElementAnimationFrame::SetTargetValue
_TEXT	ENDS
PUBLIC	??_7ioRenderElementAnimationFrameEmpty@@6B@	; ioRenderElementAnimationFrameEmpty::`vftable'
PUBLIC	??1ioRenderElementAnimationFrameEmpty@@UAE@XZ	; ioRenderElementAnimationFrameEmpty::~ioRenderElementAnimationFrameEmpty
PUBLIC	??_R4ioRenderElementAnimationFrameEmpty@@6B@	; ioRenderElementAnimationFrameEmpty::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVioRenderElementAnimationFrameEmpty@@@8	; ioRenderElementAnimationFrameEmpty `RTTI Type Descriptor'
PUBLIC	??_R3ioRenderElementAnimationFrameEmpty@@8	; ioRenderElementAnimationFrameEmpty::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioRenderElementAnimationFrameEmpty@@8	; ioRenderElementAnimationFrameEmpty::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ioRenderElementAnimationFrameEmpty@@8 ; ioRenderElementAnimationFrameEmpty::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?UpdateElement@ioRenderElementAnimationFrameEmpty@@MAE_NKAAUElementInfo@ioRenderElementAnimationFrame@@H@Z ; ioRenderElementAnimationFrameEmpty::UpdateElement
EXTRN	??_EioRenderElementAnimationFrameEmpty@@UAEPAXI@Z:PROC ; ioRenderElementAnimationFrameEmpty::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@ioRenderElementAnimationFrameEmpty@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\iorenderelementanimationframe.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@ioRenderElementAnimationFrameEmpty@@8 DD FLAT:??_R0?AVioRenderElementAnimationFrameEmpty@@@8 ; ioRenderElementAnimationFrameEmpty::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioRenderElementAnimationFrameEmpty@@8
rdata$r	ENDS
;	COMDAT ??_R2ioRenderElementAnimationFrameEmpty@@8
rdata$r	SEGMENT
??_R2ioRenderElementAnimationFrameEmpty@@8 DD FLAT:??_R1A@?0A@EA@ioRenderElementAnimationFrameEmpty@@8 ; ioRenderElementAnimationFrameEmpty::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ioRenderElementAnimationFrame@@8
rdata$r	ENDS
;	COMDAT ??_R3ioRenderElementAnimationFrameEmpty@@8
rdata$r	SEGMENT
??_R3ioRenderElementAnimationFrameEmpty@@8 DD 00H	; ioRenderElementAnimationFrameEmpty::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ioRenderElementAnimationFrameEmpty@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioRenderElementAnimationFrameEmpty@@@8
_DATA	SEGMENT
??_R0?AVioRenderElementAnimationFrameEmpty@@@8 DD FLAT:??_7type_info@@6B@ ; ioRenderElementAnimationFrameEmpty `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioRenderElementAnimationFrameEmpty@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ioRenderElementAnimationFrameEmpty@@6B@
rdata$r	SEGMENT
??_R4ioRenderElementAnimationFrameEmpty@@6B@ DD 00H	; ioRenderElementAnimationFrameEmpty::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVioRenderElementAnimationFrameEmpty@@@8
	DD	FLAT:??_R3ioRenderElementAnimationFrameEmpty@@8
rdata$r	ENDS
;	COMDAT ??_7ioRenderElementAnimationFrameEmpty@@6B@
CONST	SEGMENT
??_7ioRenderElementAnimationFrameEmpty@@6B@ DD FLAT:??_R4ioRenderElementAnimationFrameEmpty@@6B@ ; ioRenderElementAnimationFrameEmpty::`vftable'
	DD	FLAT:??_EioRenderElementAnimationFrameEmpty@@UAEPAXI@Z
	DD	FLAT:?Update@ioRenderElementAnimationFrameEmpty@@UAE_NXZ
	DD	FLAT:?OnBegin@ioRenderElementAnimationFrameEmpty@@UAEXXZ
	DD	FLAT:?OnEnd@ioRenderElementAnimationFrame@@UAEXXZ
	DD	FLAT:?UpdateElement@ioRenderElementAnimationFrameEmpty@@MAE_NKAAUElementInfo@ioRenderElementAnimationFrame@@H@Z
	DD	FLAT:?SetTargetValue@ioRenderElementAnimationFrame@@MAEXXZ
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??1ioRenderElementAnimationFrameEmpty@@UAE@XZ
_TEXT	SEGMENT
??1ioRenderElementAnimationFrameEmpty@@UAE@XZ PROC	; ioRenderElementAnimationFrameEmpty::~ioRenderElementAnimationFrameEmpty, COMDAT
; _this$ = ecx

; 120  : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ioRenderElementAnimationFrameEmpty@@6B@

; 121  : }

  00006	e9 00 00 00 00	 jmp	 ??1ioRenderElementAnimationFrame@@UAE@XZ ; ioRenderElementAnimationFrame::~ioRenderElementAnimationFrame
??1ioRenderElementAnimationFrameEmpty@@UAE@XZ ENDP	; ioRenderElementAnimationFrameEmpty::~ioRenderElementAnimationFrameEmpty
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\iorenderelementanimationframe.h
_TEXT	ENDS
;	COMDAT ?UpdateElement@ioRenderElementAnimationFrameEmpty@@MAE_NKAAUElementInfo@ioRenderElementAnimationFrame@@H@Z
_TEXT	SEGMENT
_dt$ = 8						; size = 4
_info$ = 12						; size = 4
_index$ = 16						; size = 4
?UpdateElement@ioRenderElementAnimationFrameEmpty@@MAE_NKAAUElementInfo@ioRenderElementAnimationFrame@@H@Z PROC ; ioRenderElementAnimationFrameEmpty::UpdateElement, COMDAT
; _this$ = ecx

; 123  : 	virtual bool	UpdateElement( DWORD dt, ElementInfo& info, int index ) { return false; }

  00000	32 c0		 xor	 al, al
  00002	c2 0c 00	 ret	 12			; 0000000cH
?UpdateElement@ioRenderElementAnimationFrameEmpty@@MAE_NKAAUElementInfo@ioRenderElementAnimationFrame@@H@Z ENDP ; ioRenderElementAnimationFrameEmpty::UpdateElement
_TEXT	ENDS
PUBLIC	??_7ioRenderElementAnimationFrameScale@@6B@	; ioRenderElementAnimationFrameScale::`vftable'
PUBLIC	??1ioRenderElementAnimationFrameScale@@UAE@XZ	; ioRenderElementAnimationFrameScale::~ioRenderElementAnimationFrameScale
PUBLIC	??_R4ioRenderElementAnimationFrameScale@@6B@	; ioRenderElementAnimationFrameScale::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVioRenderElementAnimationFrameScale@@@8	; ioRenderElementAnimationFrameScale `RTTI Type Descriptor'
PUBLIC	??_R3ioRenderElementAnimationFrameScale@@8	; ioRenderElementAnimationFrameScale::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioRenderElementAnimationFrameScale@@8	; ioRenderElementAnimationFrameScale::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ioRenderElementAnimationFrameScale@@8 ; ioRenderElementAnimationFrameScale::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_EioRenderElementAnimationFrameScale@@UAEPAXI@Z:PROC ; ioRenderElementAnimationFrameScale::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@ioRenderElementAnimationFrameScale@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\iorenderelementanimationframe.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@ioRenderElementAnimationFrameScale@@8 DD FLAT:??_R0?AVioRenderElementAnimationFrameScale@@@8 ; ioRenderElementAnimationFrameScale::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioRenderElementAnimationFrameScale@@8
rdata$r	ENDS
;	COMDAT ??_R2ioRenderElementAnimationFrameScale@@8
rdata$r	SEGMENT
??_R2ioRenderElementAnimationFrameScale@@8 DD FLAT:??_R1A@?0A@EA@ioRenderElementAnimationFrameScale@@8 ; ioRenderElementAnimationFrameScale::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ioRenderElementAnimationFrame@@8
rdata$r	ENDS
;	COMDAT ??_R3ioRenderElementAnimationFrameScale@@8
rdata$r	SEGMENT
??_R3ioRenderElementAnimationFrameScale@@8 DD 00H	; ioRenderElementAnimationFrameScale::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ioRenderElementAnimationFrameScale@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioRenderElementAnimationFrameScale@@@8
_DATA	SEGMENT
??_R0?AVioRenderElementAnimationFrameScale@@@8 DD FLAT:??_7type_info@@6B@ ; ioRenderElementAnimationFrameScale `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioRenderElementAnimationFrameScale@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ioRenderElementAnimationFrameScale@@6B@
rdata$r	SEGMENT
??_R4ioRenderElementAnimationFrameScale@@6B@ DD 00H	; ioRenderElementAnimationFrameScale::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVioRenderElementAnimationFrameScale@@@8
	DD	FLAT:??_R3ioRenderElementAnimationFrameScale@@8
rdata$r	ENDS
;	COMDAT ??_7ioRenderElementAnimationFrameScale@@6B@
CONST	SEGMENT
??_7ioRenderElementAnimationFrameScale@@6B@ DD FLAT:??_R4ioRenderElementAnimationFrameScale@@6B@ ; ioRenderElementAnimationFrameScale::`vftable'
	DD	FLAT:??_EioRenderElementAnimationFrameScale@@UAEPAXI@Z
	DD	FLAT:?Update@ioRenderElementAnimationFrame@@UAE_NXZ
	DD	FLAT:?OnBegin@ioRenderElementAnimationFrameScale@@UAEXXZ
	DD	FLAT:?OnEnd@ioRenderElementAnimationFrame@@UAEXXZ
	DD	FLAT:?UpdateElement@ioRenderElementAnimationFrameScale@@MAE_NKAAUElementInfo@ioRenderElementAnimationFrame@@H@Z
	DD	FLAT:?SetTargetValue@ioRenderElementAnimationFrameScale@@MAEXXZ
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??1ioRenderElementAnimationFrameScale@@UAE@XZ
_TEXT	SEGMENT
??1ioRenderElementAnimationFrameScale@@UAE@XZ PROC	; ioRenderElementAnimationFrameScale::~ioRenderElementAnimationFrameScale, COMDAT
; _this$ = ecx

; 171  : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ioRenderElementAnimationFrameScale@@6B@

; 172  : }

  00006	e9 00 00 00 00	 jmp	 ??1ioRenderElementAnimationFrame@@UAE@XZ ; ioRenderElementAnimationFrame::~ioRenderElementAnimationFrame
??1ioRenderElementAnimationFrameScale@@UAE@XZ ENDP	; ioRenderElementAnimationFrameScale::~ioRenderElementAnimationFrameScale
_TEXT	ENDS
PUBLIC	??_7ioRenderElementAnimationFrameAlpha@@6B@	; ioRenderElementAnimationFrameAlpha::`vftable'
PUBLIC	??1ioRenderElementAnimationFrameAlpha@@UAE@XZ	; ioRenderElementAnimationFrameAlpha::~ioRenderElementAnimationFrameAlpha
PUBLIC	??_R4ioRenderElementAnimationFrameAlpha@@6B@	; ioRenderElementAnimationFrameAlpha::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVioRenderElementAnimationFrameAlpha@@@8	; ioRenderElementAnimationFrameAlpha `RTTI Type Descriptor'
PUBLIC	??_R3ioRenderElementAnimationFrameAlpha@@8	; ioRenderElementAnimationFrameAlpha::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioRenderElementAnimationFrameAlpha@@8	; ioRenderElementAnimationFrameAlpha::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ioRenderElementAnimationFrameAlpha@@8 ; ioRenderElementAnimationFrameAlpha::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_EioRenderElementAnimationFrameAlpha@@UAEPAXI@Z:PROC ; ioRenderElementAnimationFrameAlpha::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@ioRenderElementAnimationFrameAlpha@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioRenderElementAnimationFrameAlpha@@8 DD FLAT:??_R0?AVioRenderElementAnimationFrameAlpha@@@8 ; ioRenderElementAnimationFrameAlpha::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioRenderElementAnimationFrameAlpha@@8
rdata$r	ENDS
;	COMDAT ??_R2ioRenderElementAnimationFrameAlpha@@8
rdata$r	SEGMENT
??_R2ioRenderElementAnimationFrameAlpha@@8 DD FLAT:??_R1A@?0A@EA@ioRenderElementAnimationFrameAlpha@@8 ; ioRenderElementAnimationFrameAlpha::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ioRenderElementAnimationFrame@@8
rdata$r	ENDS
;	COMDAT ??_R3ioRenderElementAnimationFrameAlpha@@8
rdata$r	SEGMENT
??_R3ioRenderElementAnimationFrameAlpha@@8 DD 00H	; ioRenderElementAnimationFrameAlpha::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ioRenderElementAnimationFrameAlpha@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioRenderElementAnimationFrameAlpha@@@8
_DATA	SEGMENT
??_R0?AVioRenderElementAnimationFrameAlpha@@@8 DD FLAT:??_7type_info@@6B@ ; ioRenderElementAnimationFrameAlpha `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioRenderElementAnimationFrameAlpha@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ioRenderElementAnimationFrameAlpha@@6B@
rdata$r	SEGMENT
??_R4ioRenderElementAnimationFrameAlpha@@6B@ DD 00H	; ioRenderElementAnimationFrameAlpha::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVioRenderElementAnimationFrameAlpha@@@8
	DD	FLAT:??_R3ioRenderElementAnimationFrameAlpha@@8
rdata$r	ENDS
;	COMDAT ??_7ioRenderElementAnimationFrameAlpha@@6B@
CONST	SEGMENT
??_7ioRenderElementAnimationFrameAlpha@@6B@ DD FLAT:??_R4ioRenderElementAnimationFrameAlpha@@6B@ ; ioRenderElementAnimationFrameAlpha::`vftable'
	DD	FLAT:??_EioRenderElementAnimationFrameAlpha@@UAEPAXI@Z
	DD	FLAT:?Update@ioRenderElementAnimationFrame@@UAE_NXZ
	DD	FLAT:?OnBegin@ioRenderElementAnimationFrameAlpha@@UAEXXZ
	DD	FLAT:?OnEnd@ioRenderElementAnimationFrame@@UAEXXZ
	DD	FLAT:?UpdateElement@ioRenderElementAnimationFrameAlpha@@MAE_NKAAUElementInfo@ioRenderElementAnimationFrame@@H@Z
	DD	FLAT:?SetTargetValue@ioRenderElementAnimationFrameAlpha@@MAEXXZ
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??1ioRenderElementAnimationFrameAlpha@@UAE@XZ
_TEXT	SEGMENT
??1ioRenderElementAnimationFrameAlpha@@UAE@XZ PROC	; ioRenderElementAnimationFrameAlpha::~ioRenderElementAnimationFrameAlpha, COMDAT
; _this$ = ecx

; 270  : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ioRenderElementAnimationFrameAlpha@@6B@

; 271  : }

  00006	e9 00 00 00 00	 jmp	 ??1ioRenderElementAnimationFrame@@UAE@XZ ; ioRenderElementAnimationFrame::~ioRenderElementAnimationFrame
??1ioRenderElementAnimationFrameAlpha@@UAE@XZ ENDP	; ioRenderElementAnimationFrameAlpha::~ioRenderElementAnimationFrameAlpha
_TEXT	ENDS
PUBLIC	??_7ioRenderElementAnimationFrameSize@@6B@	; ioRenderElementAnimationFrameSize::`vftable'
PUBLIC	??1ioRenderElementAnimationFrameSize@@UAE@XZ	; ioRenderElementAnimationFrameSize::~ioRenderElementAnimationFrameSize
PUBLIC	??_R4ioRenderElementAnimationFrameSize@@6B@	; ioRenderElementAnimationFrameSize::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVioRenderElementAnimationFrameSize@@@8	; ioRenderElementAnimationFrameSize `RTTI Type Descriptor'
PUBLIC	??_R3ioRenderElementAnimationFrameSize@@8	; ioRenderElementAnimationFrameSize::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioRenderElementAnimationFrameSize@@8	; ioRenderElementAnimationFrameSize::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ioRenderElementAnimationFrameSize@@8 ; ioRenderElementAnimationFrameSize::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__EH_prolog3:PROC
EXTRN	??_EioRenderElementAnimationFrameSize@@UAEPAXI@Z:PROC ; ioRenderElementAnimationFrameSize::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@ioRenderElementAnimationFrameSize@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
rdata$r	SEGMENT
??_R1A@?0A@EA@ioRenderElementAnimationFrameSize@@8 DD FLAT:??_R0?AVioRenderElementAnimationFrameSize@@@8 ; ioRenderElementAnimationFrameSize::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioRenderElementAnimationFrameSize@@8
rdata$r	ENDS
;	COMDAT ??_R2ioRenderElementAnimationFrameSize@@8
rdata$r	SEGMENT
??_R2ioRenderElementAnimationFrameSize@@8 DD FLAT:??_R1A@?0A@EA@ioRenderElementAnimationFrameSize@@8 ; ioRenderElementAnimationFrameSize::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ioRenderElementAnimationFrame@@8
rdata$r	ENDS
;	COMDAT ??_R3ioRenderElementAnimationFrameSize@@8
rdata$r	SEGMENT
??_R3ioRenderElementAnimationFrameSize@@8 DD 00H	; ioRenderElementAnimationFrameSize::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ioRenderElementAnimationFrameSize@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioRenderElementAnimationFrameSize@@@8
_DATA	SEGMENT
??_R0?AVioRenderElementAnimationFrameSize@@@8 DD FLAT:??_7type_info@@6B@ ; ioRenderElementAnimationFrameSize `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioRenderElementAnimationFrameSize@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ioRenderElementAnimationFrameSize@@6B@
rdata$r	SEGMENT
??_R4ioRenderElementAnimationFrameSize@@6B@ DD 00H	; ioRenderElementAnimationFrameSize::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVioRenderElementAnimationFrameSize@@@8
	DD	FLAT:??_R3ioRenderElementAnimationFrameSize@@8
rdata$r	ENDS
;	COMDAT ??_7ioRenderElementAnimationFrameSize@@6B@
CONST	SEGMENT
??_7ioRenderElementAnimationFrameSize@@6B@ DD FLAT:??_R4ioRenderElementAnimationFrameSize@@6B@ ; ioRenderElementAnimationFrameSize::`vftable'
	DD	FLAT:??_EioRenderElementAnimationFrameSize@@UAEPAXI@Z
	DD	FLAT:?Update@ioRenderElementAnimationFrame@@UAE_NXZ
	DD	FLAT:?OnBegin@ioRenderElementAnimationFrameSize@@UAEXXZ
	DD	FLAT:?OnEnd@ioRenderElementAnimationFrame@@UAEXXZ
	DD	FLAT:?UpdateElement@ioRenderElementAnimationFrameSize@@MAE_NKAAUElementInfo@ioRenderElementAnimationFrame@@H@Z
	DD	FLAT:?SetTargetValue@ioRenderElementAnimationFrameSize@@MAEXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1ioRenderElementAnimationFrameSize@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1ioRenderElementAnimationFrameSize@@UAE@XZ$0
__ehfuncinfo$??1ioRenderElementAnimationFrameSize@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1ioRenderElementAnimationFrameSize@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\iorenderelementanimationframe.cpp
xdata$x	ENDS
;	COMDAT ??1ioRenderElementAnimationFrameSize@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1ioRenderElementAnimationFrameSize@@UAE@XZ PROC	; ioRenderElementAnimationFrameSize::~ioRenderElementAnimationFrameSize, COMDAT
; _this$ = ecx

; 360  : {

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??1ioRenderElementAnimationFrameSize@@UAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioRenderElementAnimationFrameSize@@6B@
  00017	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 361  : }

  0001b	8d 4e 24	 lea	 ecx, DWORD PTR [esi+36]
  0001e	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@IAEXXZ ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Tidy
  00023	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00027	8b ce		 mov	 ecx, esi
  00029	e8 00 00 00 00	 call	 ??1ioRenderElementAnimationFrame@@UAE@XZ ; ioRenderElementAnimationFrame::~ioRenderElementAnimationFrame
  0002e	e8 00 00 00 00	 call	 __EH_epilog3
  00033	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1ioRenderElementAnimationFrameSize@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1ioRenderElementAnimationFrame@@UAE@XZ ; ioRenderElementAnimationFrame::~ioRenderElementAnimationFrame
__ehhandler$??1ioRenderElementAnimationFrameSize@@UAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1ioRenderElementAnimationFrameSize@@UAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1ioRenderElementAnimationFrameSize@@UAE@XZ ENDP	; ioRenderElementAnimationFrameSize::~ioRenderElementAnimationFrameSize
PUBLIC	?push_back@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAEX$$QAUElementInfo@ioRenderElementAnimationFrame@@@Z ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::push_back
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?push_back@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAEX$$QAUElementInfo@ioRenderElementAnimationFrame@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAEX$$QAUElementInfo@ioRenderElementAnimationFrame@@@Z PROC ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::push_back, COMDAT
; _this$ = ecx

; 631  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 632  : 		if (_Inside(_STD addressof(_Val)))

  00006	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 21		 jae	 SHORT $LN4@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 1b		 ja	 SHORT $LN4@push_back

; 633  : 			{	// push back an element
; 634  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 03	 sar	 edi, 3

; 635  : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN3@push_back

; 636  : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IAEXI@Z ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Reserve
$LN3@push_back:

; 637  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 638  : 			_Cons_val(this->_Alval,
; 639  : 				this->_Mylast,
; 640  : 				_STD forward<_Ty>(this->_Myfirst[_Idx]));

  0002a	8b 06		 mov	 eax, DWORD PTR [esi]
  0002c	8d 04 f8	 lea	 eax, DWORD PTR [eax+edi*8]
  0002f	50		 push	 eax

; 641  : 			++this->_Mylast;
; 642  : 			}
; 643  : 		else

  00030	eb 0f		 jmp	 SHORT $LN24@push_back
$LN4@push_back:

; 644  : 			{	// push back a non-element
; 645  : 			if (this->_Mylast == this->_Myend)

  00032	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00035	75 09		 jne	 SHORT $LN1@push_back

; 646  : 				_Reserve(1);

  00037	6a 01		 push	 1
  00039	8b ce		 mov	 ecx, esi
  0003b	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@IAEXI@Z ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::_Reserve
$LN1@push_back:

; 647  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 648  : 			_Cons_val(this->_Alval,
; 649  : 				this->_Mylast,
; 650  : 				_STD forward<_Ty>(_Val));

  00040	57		 push	 edi
$LN24@push_back:
  00041	ff 76 04	 push	 DWORD PTR [esi+4]
  00044	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@UElementInfo@ioRenderElementAnimationFrame@@U34@@std@@YAXAAV?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@0@PAUElementInfo@ioRenderElementAnimationFrame@@$$QAU23@@Z ; std::_Cons_val<std::allocator<ioRenderElementAnimationFrame::ElementInfo>,ioRenderElementAnimationFrame::ElementInfo,ioRenderElementAnimationFrame::ElementInfo>
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 651  : 			++this->_Mylast;

  00050	83 46 04 08	 add	 DWORD PTR [esi+4], 8
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi

; 652  : 			}
; 653  : 		}

  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
?push_back@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAEX$$QAUElementInfo@ioRenderElementAnimationFrame@@@Z ENDP ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::push_back
_TEXT	ENDS
PUBLIC	??0ioRenderElementAnimationFrame@@QAE@PAVioUIRenderElement@@K@Z ; ioRenderElementAnimationFrame::ioRenderElementAnimationFrame
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\iorenderelementanimationframe.h
xdata$x	SEGMENT
__unwindtable$??0ioRenderElementAnimationFrame@@QAE@PAVioUIRenderElement@@K@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ioRenderElementAnimationFrame@@QAE@PAVioUIRenderElement@@K@Z$0
__ehfuncinfo$??0ioRenderElementAnimationFrame@@QAE@PAVioUIRenderElement@@K@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0ioRenderElementAnimationFrame@@QAE@PAVioUIRenderElement@@K@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\iorenderelementanimationframe.cpp
xdata$x	ENDS
;	COMDAT ??0ioRenderElementAnimationFrame@@QAE@PAVioUIRenderElement@@K@Z
_TEXT	SEGMENT
$T511236 = -24						; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_element$ = 8						; size = 4
_targettime$ = 12					; size = 4
??0ioRenderElementAnimationFrame@@QAE@PAVioUIRenderElement@@K@Z PROC ; ioRenderElementAnimationFrame::ioRenderElementAnimationFrame, COMDAT
; _this$ = ecx

; 31   : {

  00000	6a 0c		 push	 12			; 0000000cH
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0ioRenderElementAnimationFrame@@QAE@PAVioUIRenderElement@@K@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00014	33 c0		 xor	 eax, eax
  00016	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioRenderElementAnimationFrame@@6B@
  0001c	89 01		 mov	 DWORD PTR [ecx], eax
  0001e	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00021	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 32   : 	assert( element != 0 );
; 33   : 
; 34   : 	m_elements.push_back( ElementInfo( element ) );

  00024	0f 57 c0	 xorps	 xmm0, xmm0
  00027	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], eax
  0002a	89 46 14	 mov	 DWORD PTR [esi+20], eax
  0002d	8b 45 0c	 mov	 eax, DWORD PTR _targettime$[ebp]
  00030	89 46 18	 mov	 DWORD PTR [esi+24], eax
  00033	8b 45 08	 mov	 eax, DWORD PTR _element$[ebp]
  00036	89 45 e8	 mov	 DWORD PTR $T511236[ebp], eax
  00039	8d 45 e8	 lea	 eax, DWORD PTR $T511236[ebp]
  0003c	50		 push	 eax
  0003d	f3 0f 11 45 ec	 movss	 DWORD PTR $T511236[ebp+4], xmm0
  00042	e8 00 00 00 00	 call	 ?push_back@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAEX$$QAUElementInfo@ioRenderElementAnimationFrame@@@Z ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::push_back

; 35   : }

  00047	8b c6		 mov	 eax, esi
  00049	e8 00 00 00 00	 call	 __EH_epilog3
  0004e	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ioRenderElementAnimationFrame@@QAE@PAVioUIRenderElement@@K@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAE@XZ ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::~vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >
__ehhandler$??0ioRenderElementAnimationFrame@@QAE@PAVioUIRenderElement@@K@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ioRenderElementAnimationFrame@@QAE@PAVioUIRenderElement@@K@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ioRenderElementAnimationFrame@@QAE@PAVioUIRenderElement@@K@Z ENDP ; ioRenderElementAnimationFrame::ioRenderElementAnimationFrame
; Function compile flags: /Ogsp
;	COMDAT ??_GioRenderElementAnimationFrame@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GioRenderElementAnimationFrame@@UAEPAXI@Z PROC	; ioRenderElementAnimationFrame::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1ioRenderElementAnimationFrame@@UAE@XZ ; ioRenderElementAnimationFrame::~ioRenderElementAnimationFrame
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 07		 je	 SHORT $LN1@scalar@2
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	59		 pop	 ecx
$LN1@scalar@2:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??_GioRenderElementAnimationFrame@@UAEPAXI@Z ENDP	; ioRenderElementAnimationFrame::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0ioRenderElementAnimationFrame@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@K@Z ; ioRenderElementAnimationFrame::ioRenderElementAnimationFrame
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\iorenderelementanimationframe.h
xdata$x	SEGMENT
__unwindtable$??0ioRenderElementAnimationFrame@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@K@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ioRenderElementAnimationFrame@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@K@Z$0
__ehfuncinfo$??0ioRenderElementAnimationFrame@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@K@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0ioRenderElementAnimationFrame@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@K@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\iorenderelementanimationframe.cpp
xdata$x	ENDS
;	COMDAT ??0ioRenderElementAnimationFrame@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@K@Z
_TEXT	SEGMENT
$T511276 = -24						; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_elements$ = 8						; size = 4
_i$505896 = 12						; size = 4
_targettime$ = 12					; size = 4
??0ioRenderElementAnimationFrame@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@K@Z PROC ; ioRenderElementAnimationFrame::ioRenderElementAnimationFrame, COMDAT
; _this$ = ecx

; 40   : {

  00000	6a 0c		 push	 12			; 0000000cH
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0ioRenderElementAnimationFrame@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@K@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b d9		 mov	 ebx, ecx
  0000e	89 5d f0	 mov	 DWORD PTR _this$[ebp], ebx
  00011	33 c9		 xor	 ecx, ecx
  00013	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET ??_7ioRenderElementAnimationFrame@@6B@
  00019	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
  0001c	89 4b 08	 mov	 DWORD PTR [ebx+8], ecx
  0001f	89 4b 0c	 mov	 DWORD PTR [ebx+12], ecx
  00022	8b 45 0c	 mov	 eax, DWORD PTR _targettime$[ebp]
  00025	89 43 18	 mov	 DWORD PTR [ebx+24], eax

; 41   : 	int num = static_cast<int>( elements.size() );

  00028	8b 45 08	 mov	 eax, DWORD PTR _elements$[ebp]
  0002b	89 4b 14	 mov	 DWORD PTR [ebx+20], ecx
  0002e	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00031	2b 30		 sub	 esi, DWORD PTR [eax]
  00033	89 4d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ecx
  00036	c1 fe 02	 sar	 esi, 2

; 42   : 	for ( int i = 0; i < num; ++i )

  00039	89 4d 0c	 mov	 DWORD PTR _i$505896[ebp], ecx
  0003c	3b f1		 cmp	 esi, ecx
  0003e	7e 2c		 jle	 SHORT $LN1@ioRenderEl
  00040	eb 03		 jmp	 SHORT $LN3@ioRenderEl
$LL23@ioRenderEl:
  00042	8b 45 08	 mov	 eax, DWORD PTR _elements$[ebp]
$LN3@ioRenderEl:

; 43   : 	{
; 44   : 		assert( elements[ i ] != 0 );
; 45   : 		m_elements.push_back( ElementInfo( elements[ i ] ) );

  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	8b 4d 0c	 mov	 ecx, DWORD PTR _i$505896[ebp]
  0004a	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  0004d	0f 57 c0	 xorps	 xmm0, xmm0
  00050	89 45 e8	 mov	 DWORD PTR $T511276[ebp], eax
  00053	8d 45 e8	 lea	 eax, DWORD PTR $T511276[ebp]
  00056	50		 push	 eax
  00057	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  0005a	f3 0f 11 45 ec	 movss	 DWORD PTR $T511276[ebp+4], xmm0
  0005f	e8 00 00 00 00	 call	 ?push_back@?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAEX$$QAUElementInfo@ioRenderElementAnimationFrame@@@Z ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::push_back
  00064	ff 45 0c	 inc	 DWORD PTR _i$505896[ebp]
  00067	39 75 0c	 cmp	 DWORD PTR _i$505896[ebp], esi
  0006a	7c d6		 jl	 SHORT $LL23@ioRenderEl
$LN1@ioRenderEl:

; 46   : 	}
; 47   : }

  0006c	8b c3		 mov	 eax, ebx
  0006e	e8 00 00 00 00	 call	 __EH_epilog3
  00073	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ioRenderElementAnimationFrame@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@K@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@UElementInfo@ioRenderElementAnimationFrame@@V?$allocator@UElementInfo@ioRenderElementAnimationFrame@@@std@@@std@@QAE@XZ ; std::vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >::~vector<ioRenderElementAnimationFrame::ElementInfo,std::allocator<ioRenderElementAnimationFrame::ElementInfo> >
__ehhandler$??0ioRenderElementAnimationFrame@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@K@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ioRenderElementAnimationFrame@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@K@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ioRenderElementAnimationFrame@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@K@Z ENDP ; ioRenderElementAnimationFrame::ioRenderElementAnimationFrame
PUBLIC	??0ioRenderElementAnimationFrameEmpty@@QAE@PAVioUIRenderElement@@K@Z ; ioRenderElementAnimationFrameEmpty::ioRenderElementAnimationFrameEmpty
; Function compile flags: /Ogsp
;	COMDAT ??0ioRenderElementAnimationFrameEmpty@@QAE@PAVioUIRenderElement@@K@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
_targettime$ = 12					; size = 4
??0ioRenderElementAnimationFrameEmpty@@QAE@PAVioUIRenderElement@@K@Z PROC ; ioRenderElementAnimationFrameEmpty::ioRenderElementAnimationFrameEmpty, COMDAT
; _this$ = ecx

; 110  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	ff 75 0c	 push	 DWORD PTR _targettime$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 75 08	 push	 DWORD PTR _element$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0ioRenderElementAnimationFrame@@QAE@PAVioUIRenderElement@@K@Z ; ioRenderElementAnimationFrame::ioRenderElementAnimationFrame
  00011	83 66 1c 00	 and	 DWORD PTR [esi+28], 0
  00015	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioRenderElementAnimationFrameEmpty@@6B@

; 111  : }

  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
??0ioRenderElementAnimationFrameEmpty@@QAE@PAVioUIRenderElement@@K@Z ENDP ; ioRenderElementAnimationFrameEmpty::ioRenderElementAnimationFrameEmpty
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??_GioRenderElementAnimationFrameEmpty@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GioRenderElementAnimationFrameEmpty@@UAEPAXI@Z PROC	; ioRenderElementAnimationFrameEmpty::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioRenderElementAnimationFrameEmpty@@6B@
  0000c	e8 00 00 00 00	 call	 ??1ioRenderElementAnimationFrame@@UAE@XZ ; ioRenderElementAnimationFrame::~ioRenderElementAnimationFrame
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 07		 je	 SHORT $LN1@scalar@3
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	59		 pop	 ecx
$LN1@scalar@3:
  0001e	8b c6		 mov	 eax, esi
  00020	5e		 pop	 esi
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??_GioRenderElementAnimationFrameEmpty@@UAEPAXI@Z ENDP	; ioRenderElementAnimationFrameEmpty::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0ioRenderElementAnimationFrameEmpty@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@K@Z ; ioRenderElementAnimationFrameEmpty::ioRenderElementAnimationFrameEmpty
; Function compile flags: /Ogsp
;	COMDAT ??0ioRenderElementAnimationFrameEmpty@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@K@Z
_TEXT	SEGMENT
_elements$ = 8						; size = 4
_targettime$ = 12					; size = 4
??0ioRenderElementAnimationFrameEmpty@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@K@Z PROC ; ioRenderElementAnimationFrameEmpty::ioRenderElementAnimationFrameEmpty, COMDAT
; _this$ = ecx

; 116  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	ff 75 0c	 push	 DWORD PTR _targettime$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 75 08	 push	 DWORD PTR _elements$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0ioRenderElementAnimationFrame@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@K@Z ; ioRenderElementAnimationFrame::ioRenderElementAnimationFrame
  00011	83 66 1c 00	 and	 DWORD PTR [esi+28], 0
  00015	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioRenderElementAnimationFrameEmpty@@6B@

; 117  : }

  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
??0ioRenderElementAnimationFrameEmpty@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@K@Z ENDP ; ioRenderElementAnimationFrameEmpty::ioRenderElementAnimationFrameEmpty
_TEXT	ENDS
PUBLIC	??0ioRenderElementAnimationFrameScale@@QAE@PAVioUIRenderElement@@ABUD3DXVECTOR2@@K@Z ; ioRenderElementAnimationFrameScale::ioRenderElementAnimationFrameScale
; Function compile flags: /Ogsp
;	COMDAT ??0ioRenderElementAnimationFrameScale@@QAE@PAVioUIRenderElement@@ABUD3DXVECTOR2@@K@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
_targetscale$ = 12					; size = 4
_targettime$ = 16					; size = 4
??0ioRenderElementAnimationFrameScale@@QAE@PAVioUIRenderElement@@ABUD3DXVECTOR2@@K@Z PROC ; ioRenderElementAnimationFrameScale::ioRenderElementAnimationFrameScale, COMDAT
; _this$ = ecx

; 161  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	ff 75 10	 push	 DWORD PTR _targettime$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 75 08	 push	 DWORD PTR _element$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0ioRenderElementAnimationFrame@@QAE@PAVioUIRenderElement@@K@Z ; ioRenderElementAnimationFrame::ioRenderElementAnimationFrame
  00011	8b 45 0c	 mov	 eax, DWORD PTR _targetscale$[ebp]
  00014	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioRenderElementAnimationFrameScale@@6B@
  0001a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001c	89 4e 1c	 mov	 DWORD PTR [esi+28], ecx
  0001f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00022	89 46 20	 mov	 DWORD PTR [esi+32], eax

; 162  : }

  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi
  00028	5d		 pop	 ebp
  00029	c2 0c 00	 ret	 12			; 0000000cH
??0ioRenderElementAnimationFrameScale@@QAE@PAVioUIRenderElement@@ABUD3DXVECTOR2@@K@Z ENDP ; ioRenderElementAnimationFrameScale::ioRenderElementAnimationFrameScale
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??_GioRenderElementAnimationFrameScale@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GioRenderElementAnimationFrameScale@@UAEPAXI@Z PROC	; ioRenderElementAnimationFrameScale::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioRenderElementAnimationFrameScale@@6B@
  0000c	e8 00 00 00 00	 call	 ??1ioRenderElementAnimationFrame@@UAE@XZ ; ioRenderElementAnimationFrame::~ioRenderElementAnimationFrame
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 07		 je	 SHORT $LN1@scalar@4
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	59		 pop	 ecx
$LN1@scalar@4:
  0001e	8b c6		 mov	 eax, esi
  00020	5e		 pop	 esi
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??_GioRenderElementAnimationFrameScale@@UAEPAXI@Z ENDP	; ioRenderElementAnimationFrameScale::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0ioRenderElementAnimationFrameScale@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@ABUD3DXVECTOR2@@K@Z ; ioRenderElementAnimationFrameScale::ioRenderElementAnimationFrameScale
; Function compile flags: /Ogsp
;	COMDAT ??0ioRenderElementAnimationFrameScale@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@ABUD3DXVECTOR2@@K@Z
_TEXT	SEGMENT
_elements$ = 8						; size = 4
_targetscale$ = 12					; size = 4
_targettime$ = 16					; size = 4
??0ioRenderElementAnimationFrameScale@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@ABUD3DXVECTOR2@@K@Z PROC ; ioRenderElementAnimationFrameScale::ioRenderElementAnimationFrameScale, COMDAT
; _this$ = ecx

; 167  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	ff 75 10	 push	 DWORD PTR _targettime$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 75 08	 push	 DWORD PTR _elements$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0ioRenderElementAnimationFrame@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@K@Z ; ioRenderElementAnimationFrame::ioRenderElementAnimationFrame
  00011	8b 45 0c	 mov	 eax, DWORD PTR _targetscale$[ebp]
  00014	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioRenderElementAnimationFrameScale@@6B@
  0001a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001c	89 4e 1c	 mov	 DWORD PTR [esi+28], ecx
  0001f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00022	89 46 20	 mov	 DWORD PTR [esi+32], eax

; 168  : }

  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi
  00028	5d		 pop	 ebp
  00029	c2 0c 00	 ret	 12			; 0000000cH
??0ioRenderElementAnimationFrameScale@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@ABUD3DXVECTOR2@@K@Z ENDP ; ioRenderElementAnimationFrameScale::ioRenderElementAnimationFrameScale
_TEXT	ENDS
PUBLIC	??0ioRenderElementAnimationFrameAlpha@@QAE@PAVioUIRenderElement@@MK@Z ; ioRenderElementAnimationFrameAlpha::ioRenderElementAnimationFrameAlpha
; Function compile flags: /Ogsp
;	COMDAT ??0ioRenderElementAnimationFrameAlpha@@QAE@PAVioUIRenderElement@@MK@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
_targetalpha$ = 12					; size = 4
_targettime$ = 16					; size = 4
??0ioRenderElementAnimationFrameAlpha@@QAE@PAVioUIRenderElement@@MK@Z PROC ; ioRenderElementAnimationFrameAlpha::ioRenderElementAnimationFrameAlpha, COMDAT
; _this$ = ecx

; 260  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	ff 75 10	 push	 DWORD PTR _targettime$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 75 08	 push	 DWORD PTR _element$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0ioRenderElementAnimationFrame@@QAE@PAVioUIRenderElement@@K@Z ; ioRenderElementAnimationFrame::ioRenderElementAnimationFrame
  00011	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _targetalpha$[ebp]
  00016	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioRenderElementAnimationFrameAlpha@@6B@
  0001c	f3 0f 11 46 1c	 movss	 DWORD PTR [esi+28], xmm0

; 261  : }

  00021	8b c6		 mov	 eax, esi
  00023	5e		 pop	 esi
  00024	5d		 pop	 ebp
  00025	c2 0c 00	 ret	 12			; 0000000cH
??0ioRenderElementAnimationFrameAlpha@@QAE@PAVioUIRenderElement@@MK@Z ENDP ; ioRenderElementAnimationFrameAlpha::ioRenderElementAnimationFrameAlpha
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??_GioRenderElementAnimationFrameAlpha@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GioRenderElementAnimationFrameAlpha@@UAEPAXI@Z PROC	; ioRenderElementAnimationFrameAlpha::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioRenderElementAnimationFrameAlpha@@6B@
  0000c	e8 00 00 00 00	 call	 ??1ioRenderElementAnimationFrame@@UAE@XZ ; ioRenderElementAnimationFrame::~ioRenderElementAnimationFrame
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 07		 je	 SHORT $LN1@scalar@5
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	59		 pop	 ecx
$LN1@scalar@5:
  0001e	8b c6		 mov	 eax, esi
  00020	5e		 pop	 esi
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??_GioRenderElementAnimationFrameAlpha@@UAEPAXI@Z ENDP	; ioRenderElementAnimationFrameAlpha::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0ioRenderElementAnimationFrameAlpha@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@MK@Z ; ioRenderElementAnimationFrameAlpha::ioRenderElementAnimationFrameAlpha
; Function compile flags: /Ogsp
;	COMDAT ??0ioRenderElementAnimationFrameAlpha@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@MK@Z
_TEXT	SEGMENT
_elements$ = 8						; size = 4
_targetalpha$ = 12					; size = 4
_targettime$ = 16					; size = 4
??0ioRenderElementAnimationFrameAlpha@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@MK@Z PROC ; ioRenderElementAnimationFrameAlpha::ioRenderElementAnimationFrameAlpha, COMDAT
; _this$ = ecx

; 266  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	ff 75 10	 push	 DWORD PTR _targettime$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 75 08	 push	 DWORD PTR _elements$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0ioRenderElementAnimationFrame@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@K@Z ; ioRenderElementAnimationFrame::ioRenderElementAnimationFrame
  00011	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _targetalpha$[ebp]
  00016	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioRenderElementAnimationFrameAlpha@@6B@
  0001c	f3 0f 11 46 1c	 movss	 DWORD PTR [esi+28], xmm0

; 267  : }

  00021	8b c6		 mov	 eax, esi
  00023	5e		 pop	 esi
  00024	5d		 pop	 ebp
  00025	c2 0c 00	 ret	 12			; 0000000cH
??0ioRenderElementAnimationFrameAlpha@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@MK@Z ENDP ; ioRenderElementAnimationFrameAlpha::ioRenderElementAnimationFrameAlpha
_TEXT	ENDS
PUBLIC	??0ioRenderElementAnimationFrameSize@@QAE@PAVioUIRenderElement@@ABUD3DXVECTOR2@@K@Z ; ioRenderElementAnimationFrameSize::ioRenderElementAnimationFrameSize
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx9math.inl
xdata$x	SEGMENT
__unwindtable$??0ioRenderElementAnimationFrameSize@@QAE@PAVioUIRenderElement@@ABUD3DXVECTOR2@@K@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ioRenderElementAnimationFrameSize@@QAE@PAVioUIRenderElement@@ABUD3DXVECTOR2@@K@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0ioRenderElementAnimationFrameSize@@QAE@PAVioUIRenderElement@@ABUD3DXVECTOR2@@K@Z$1
__ehfuncinfo$??0ioRenderElementAnimationFrameSize@@QAE@PAVioUIRenderElement@@ABUD3DXVECTOR2@@K@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0ioRenderElementAnimationFrameSize@@QAE@PAVioUIRenderElement@@ABUD3DXVECTOR2@@K@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\iorenderelementanimationframe.cpp
xdata$x	ENDS
;	COMDAT ??0ioRenderElementAnimationFrameSize@@QAE@PAVioUIRenderElement@@ABUD3DXVECTOR2@@K@Z
_TEXT	SEGMENT
$T511361 = -24						; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_element$ = 8						; size = 4
_targetsize$ = 12					; size = 4
_targettime$ = 16					; size = 4
??0ioRenderElementAnimationFrameSize@@QAE@PAVioUIRenderElement@@ABUD3DXVECTOR2@@K@Z PROC ; ioRenderElementAnimationFrameSize::ioRenderElementAnimationFrameSize, COMDAT
; _this$ = ecx

; 348  : {

  00000	6a 0c		 push	 12			; 0000000cH
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0ioRenderElementAnimationFrameSize@@QAE@PAVioUIRenderElement@@ABUD3DXVECTOR2@@K@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	ff 75 10	 push	 DWORD PTR _targettime$[ebp]
  00014	ff 75 08	 push	 DWORD PTR _element$[ebp]
  00017	e8 00 00 00 00	 call	 ??0ioRenderElementAnimationFrame@@QAE@PAVioUIRenderElement@@K@Z ; ioRenderElementAnimationFrame::ioRenderElementAnimationFrame
  0001c	8b 45 0c	 mov	 eax, DWORD PTR _targetsize$[ebp]
  0001f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioRenderElementAnimationFrameSize@@6B@
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	89 4e 1c	 mov	 DWORD PTR [esi+28], ecx
  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	33 d2		 xor	 edx, edx
  0002f	8d 4e 24	 lea	 ecx, DWORD PTR [esi+36]
  00032	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00035	89 55 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edx
  00038	89 11		 mov	 DWORD PTR [ecx], edx
  0003a	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0003d	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 349  : 	m_cursizes.resize( 1, D3DXVECTOR2( 0.0f, 0.0f ) );

  00040	0f 57 c0	 xorps	 xmm0, xmm0
  00043	f3 0f 11 45 ec	 movss	 DWORD PTR $T511361[ebp+4], xmm0
  00048	ff 75 ec	 push	 DWORD PTR $T511361[ebp+4]
  0004b	f3 0f 11 45 e8	 movss	 DWORD PTR $T511361[ebp], xmm0
  00050	ff 75 e8	 push	 DWORD PTR $T511361[ebp]
  00053	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00057	6a 01		 push	 1
  00059	e8 00 00 00 00	 call	 ?resize@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAEXIUD3DXVECTOR2@@@Z ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::resize

; 350  : }

  0005e	8b c6		 mov	 eax, esi
  00060	e8 00 00 00 00	 call	 __EH_epilog3
  00065	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ioRenderElementAnimationFrameSize@@QAE@PAVioUIRenderElement@@ABUD3DXVECTOR2@@K@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1ioRenderElementAnimationFrame@@UAE@XZ ; ioRenderElementAnimationFrame::~ioRenderElementAnimationFrame
__unwindfunclet$??0ioRenderElementAnimationFrameSize@@QAE@PAVioUIRenderElement@@ABUD3DXVECTOR2@@K@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 24	 add	 ecx, 36			; 00000024H
  0000e	e9 00 00 00 00	 jmp	 ??1?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::~vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >
__ehhandler$??0ioRenderElementAnimationFrameSize@@QAE@PAVioUIRenderElement@@ABUD3DXVECTOR2@@K@Z:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ioRenderElementAnimationFrameSize@@QAE@PAVioUIRenderElement@@ABUD3DXVECTOR2@@K@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ioRenderElementAnimationFrameSize@@QAE@PAVioUIRenderElement@@ABUD3DXVECTOR2@@K@Z ENDP ; ioRenderElementAnimationFrameSize::ioRenderElementAnimationFrameSize
; Function compile flags: /Ogsp
;	COMDAT ??_GioRenderElementAnimationFrameSize@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GioRenderElementAnimationFrameSize@@UAEPAXI@Z PROC	; ioRenderElementAnimationFrameSize::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1ioRenderElementAnimationFrameSize@@UAE@XZ ; ioRenderElementAnimationFrameSize::~ioRenderElementAnimationFrameSize
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 07		 je	 SHORT $LN1@scalar@6
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	59		 pop	 ecx
$LN1@scalar@6:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??_GioRenderElementAnimationFrameSize@@UAEPAXI@Z ENDP	; ioRenderElementAnimationFrameSize::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0ioRenderElementAnimationFrameSize@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@ABUD3DXVECTOR2@@K@Z ; ioRenderElementAnimationFrameSize::ioRenderElementAnimationFrameSize
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??0ioRenderElementAnimationFrameSize@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@ABUD3DXVECTOR2@@K@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ioRenderElementAnimationFrameSize@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@ABUD3DXVECTOR2@@K@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0ioRenderElementAnimationFrameSize@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@ABUD3DXVECTOR2@@K@Z$1
__ehfuncinfo$??0ioRenderElementAnimationFrameSize@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@ABUD3DXVECTOR2@@K@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0ioRenderElementAnimationFrameSize@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@ABUD3DXVECTOR2@@K@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\iorenderelementanimationframe.cpp
xdata$x	ENDS
;	COMDAT ??0ioRenderElementAnimationFrameSize@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@ABUD3DXVECTOR2@@K@Z
_TEXT	SEGMENT
$T511402 = -24						; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_elements$ = 8						; size = 4
_targetsize$ = 12					; size = 4
_targettime$ = 16					; size = 4
??0ioRenderElementAnimationFrameSize@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@ABUD3DXVECTOR2@@K@Z PROC ; ioRenderElementAnimationFrameSize::ioRenderElementAnimationFrameSize, COMDAT
; _this$ = ecx

; 355  : {

  00000	6a 0c		 push	 12			; 0000000cH
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0ioRenderElementAnimationFrameSize@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@ABUD3DXVECTOR2@@K@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	ff 75 10	 push	 DWORD PTR _targettime$[ebp]
  00014	8b 7d 08	 mov	 edi, DWORD PTR _elements$[ebp]
  00017	57		 push	 edi
  00018	e8 00 00 00 00	 call	 ??0ioRenderElementAnimationFrame@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@K@Z ; ioRenderElementAnimationFrame::ioRenderElementAnimationFrame
  0001d	8b 45 0c	 mov	 eax, DWORD PTR _targetsize$[ebp]
  00020	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioRenderElementAnimationFrameSize@@6B@
  00026	8b 08		 mov	 ecx, DWORD PTR [eax]
  00028	89 4e 1c	 mov	 DWORD PTR [esi+28], ecx
  0002b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002e	33 d2		 xor	 edx, edx
  00030	8d 4e 24	 lea	 ecx, DWORD PTR [esi+36]
  00033	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00036	89 55 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edx
  00039	89 11		 mov	 DWORD PTR [ecx], edx
  0003b	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0003e	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 356  : 	m_cursizes.resize( elements.size(), D3DXVECTOR2( 0.0f, 0.0f ) );

  00041	0f 57 c0	 xorps	 xmm0, xmm0
  00044	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00047	2b 07		 sub	 eax, DWORD PTR [edi]
  00049	f3 0f 11 45 ec	 movss	 DWORD PTR $T511402[ebp+4], xmm0
  0004e	ff 75 ec	 push	 DWORD PTR $T511402[ebp+4]
  00051	f3 0f 11 45 e8	 movss	 DWORD PTR $T511402[ebp], xmm0
  00056	ff 75 e8	 push	 DWORD PTR $T511402[ebp]
  00059	c1 f8 02	 sar	 eax, 2
  0005c	50		 push	 eax
  0005d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00061	e8 00 00 00 00	 call	 ?resize@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAEXIUD3DXVECTOR2@@@Z ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::resize

; 357  : }

  00066	8b c6		 mov	 eax, esi
  00068	e8 00 00 00 00	 call	 __EH_epilog3
  0006d	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ioRenderElementAnimationFrameSize@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@ABUD3DXVECTOR2@@K@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1ioRenderElementAnimationFrame@@UAE@XZ ; ioRenderElementAnimationFrame::~ioRenderElementAnimationFrame
__unwindfunclet$??0ioRenderElementAnimationFrameSize@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@ABUD3DXVECTOR2@@K@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 24	 add	 ecx, 36			; 00000024H
  0000e	e9 00 00 00 00	 jmp	 ??1?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::~vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >
__ehhandler$??0ioRenderElementAnimationFrameSize@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@ABUD3DXVECTOR2@@K@Z:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ioRenderElementAnimationFrameSize@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@ABUD3DXVECTOR2@@K@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ioRenderElementAnimationFrameSize@@QAE@ABV?$vector@PAVioUIRenderElement@@V?$allocator@PAVioUIRenderElement@@@std@@@std@@ABUD3DXVECTOR2@@K@Z ENDP ; ioRenderElementAnimationFrameSize::ioRenderElementAnimationFrameSize
END
