; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\Lost Saga For Developer\Youtube\Tutorial\Source\src\LSClient\BlockKeyBoard.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?m_hHook@CBlockKeyBoard@@0PAUHHOOK__@@A		; CBlockKeyBoard::m_hHook
PUBLIC	?m_bAltTab@CBlockKeyBoard@@0_NA			; CBlockKeyBoard::m_bAltTab
_BSS	SEGMENT
?m_hHook@CBlockKeyBoard@@0PAUHHOOK__@@A DD 01H DUP (?)	; CBlockKeyBoard::m_hHook
?m_bAltTab@CBlockKeyBoard@@0_NA DB 01H DUP (?)		; CBlockKeyBoard::m_bAltTab
_BSS	ENDS
PUBLIC	??0CBlockKeyBoard@@QAE@_N@Z			; CBlockKeyBoard::CBlockKeyBoard
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\blockkeyboard.cpp
;	COMDAT ??0CBlockKeyBoard@@QAE@_N@Z
_TEXT	SEGMENT
_bWin98Series$ = 8					; size = 1
??0CBlockKeyBoard@@QAE@_N@Z PROC			; CBlockKeyBoard::CBlockKeyBoard, COMDAT
; _this$ = ecx

; 9    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 10   : 	m_bWin98Series = bWin98Series;

  00005	8a 4d 08	 mov	 cl, BYTE PTR _bWin98Series$[ebp]
  00008	88 08		 mov	 BYTE PTR [eax], cl

; 11   : 	m_bBlock = false;

  0000a	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 12   : }

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
??0CBlockKeyBoard@@QAE@_N@Z ENDP			; CBlockKeyBoard::CBlockKeyBoard
_TEXT	ENDS
PUBLIC	??1CBlockKeyBoard@@QAE@XZ			; CBlockKeyBoard::~CBlockKeyBoard
; Function compile flags: /Ogsp
;	COMDAT ??1CBlockKeyBoard@@QAE@XZ
_TEXT	SEGMENT
??1CBlockKeyBoard@@QAE@XZ PROC				; CBlockKeyBoard::~CBlockKeyBoard, COMDAT
; _this$ = ecx

; 16   : 
; 17   : }

  00000	c3		 ret	 0
??1CBlockKeyBoard@@QAE@XZ ENDP				; CBlockKeyBoard::~CBlockKeyBoard
_TEXT	ENDS
PUBLIC	?LowLevelKeyboardProc@CBlockKeyBoard@@SGJHIJ@Z	; CBlockKeyBoard::LowLevelKeyboardProc
EXTRN	__imp__CallNextHookEx@16:PROC
EXTRN	__imp__GetAsyncKeyState@4:PROC
; Function compile flags: /Ogsp
;	COMDAT ?LowLevelKeyboardProc@CBlockKeyBoard@@SGJHIJ@Z
_TEXT	SEGMENT
_nCode$ = 8						; size = 4
_wParam$ = 12						; size = 4
_lParam$ = 16						; size = 4
?LowLevelKeyboardProc@CBlockKeyBoard@@SGJHIJ@Z PROC	; CBlockKeyBoard::LowLevelKeyboardProc, COMDAT

; 20   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 21   : 	// By returning a non-zero value from the hook procedure, the
; 22   :     // message does not get passed to the target window
; 23   :     KBDLLHOOKSTRUCT *pkbhs = (KBDLLHOOKSTRUCT *) lParam;
; 24   :     BOOL bControlKeyDown = 0;
; 25   : 
; 26   : 	if(nCode >= 0)

  00003	83 7d 08 00	 cmp	 DWORD PTR _nCode$[ebp], 0
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _lParam$[ebp]
  0000b	7c 18		 jl	 SHORT $LN1@LowLevelKe

; 27   :     {    
; 28   : 		// Check to see if the CTRL key is pressed
; 29   : 		//bControlKeyDown = GetAsyncKeyState (VK_CONTROL) < 0 ;
; 30   : 
; 31   : 		// Disable CTRL+ESC
; 32   : 		//if (pkbhs->vkCode == VK_ESCAPE && bControlKeyDown)		
; 33   : 		//	return 1;		
; 34   : 		
; 35   : 		// Disable ALT+TAB
; 36   : 		//if (pkbhs->vkCode == VK_TAB && pkbhs->flags & LLKHF_ALTDOWN)
; 37   : 		//{
; 38   : 		//	m_bAltTab = true;
; 39   : 		//	return 1;
; 40   : 		//}
; 41   : 		
; 42   : 		// Disable ALT+ESC
; 43   : 		//if (pkbhs->vkCode == VK_ESCAPE && pkbhs->flags & LLKHF_ALTDOWN)
; 44   : 		//	return 1;
; 45   : 
; 46   : 		// Disable ALT+F6
; 47   : 		//if(pkbhs->vkCode == VK_F6 && pkbhs->flags & LLKHF_ALTDOWN )
; 48   : 		//	return 1;
; 49   : 
; 50   : 		// Disable ALT+F4
; 51   : 		//if(pkbhs->vkCode == VK_F4 && pkbhs->flags & LLKHF_ALTDOWN )
; 52   : 		//	return 1;
; 53   : 		
; 54   : 		// Disable Application Key ( Right Mouse Button Key )			
; 55   : 		//if(pkbhs->vkCode == VK_APPS)
; 56   : 		//	return 1;		
; 57   : 
; 58   : 		// Disable ALT, CTRL ( CTRL 키가 정상 동작하지 않음 )
; 59   : 		//if(wParam == WM_SYSKEYDOWN || wParam == WM_SYSKEYUP)
; 60   : 		//	return 1;		
; 61   : 
; 62   : 		// Ctrl down
; 63   : 		if( GetAsyncKeyState (VK_CONTROL) < 0 )

  0000d	6a 11		 push	 17			; 00000011H
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetAsyncKeyState@4
  00015	66 85 c0	 test	 ax, ax
  00018	79 05		 jns	 SHORT $LN2@LowLevelKe
$LN6@LowLevelKe:

; 64   : 			return 1;

  0001a	33 c0		 xor	 eax, eax
  0001c	40		 inc	 eax
  0001d	eb 19		 jmp	 SHORT $LN4@LowLevelKe
$LN2@LowLevelKe:

; 65   : 
; 66   : 		// Alt down
; 67   : 		if( pkbhs->flags & LLKHF_ALTDOWN )

  0001f	f6 46 08 20	 test	 BYTE PTR [esi+8], 32	; 00000020H

; 68   : 			return 1;

  00023	75 f5		 jne	 SHORT $LN6@LowLevelKe
$LN1@LowLevelKe:

; 69   :     }
; 70   : 
; 71   :     return CallNextHookEx(m_hHook, nCode, wParam, lParam);

  00025	56		 push	 esi
  00026	ff 75 0c	 push	 DWORD PTR _wParam$[ebp]
  00029	ff 75 08	 push	 DWORD PTR _nCode$[ebp]
  0002c	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_hHook@CBlockKeyBoard@@0PAUHHOOK__@@A ; CBlockKeyBoard::m_hHook
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallNextHookEx@16
$LN4@LowLevelKe:
  00038	5e		 pop	 esi

; 72   : } 

  00039	5d		 pop	 ebp
  0003a	c2 0c 00	 ret	 12			; 0000000cH
?LowLevelKeyboardProc@CBlockKeyBoard@@SGJHIJ@Z ENDP	; CBlockKeyBoard::LowLevelKeyboardProc
_TEXT	ENDS
PUBLIC	??_C@_0BA@KBGOFHBP@Disable?5Sys?5Key?$AA@	; `string'
PUBLIC	??_C@_0CC@LBLJMOIK@EXCEPT?3HOOK?5Failed?0?5Error?5Code?3?$CF@ ; `string'
PUBLIC	?DisableSysKey@CBlockKeyBoard@@QAEXPAUHINSTANCE__@@@Z ; CBlockKeyBoard::DisableSysKey
EXTRN	__imp_?LOG@@3VCLog@@A:BYTE
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__SetWindowsHookExA@16:PROC
EXTRN	__imp__SystemParametersInfoA@16:PROC
EXTRN	__imp_?PrintTimeAndLog@CLog@@QAAXHPADZZ:PROC
;	COMDAT ??_C@_0BA@KBGOFHBP@Disable?5Sys?5Key?$AA@
CONST	SEGMENT
??_C@_0BA@KBGOFHBP@Disable?5Sys?5Key?$AA@ DB 'Disable Sys Key', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LBLJMOIK@EXCEPT?3HOOK?5Failed?0?5Error?5Code?3?$CF@
CONST	SEGMENT
??_C@_0CC@LBLJMOIK@EXCEPT?3HOOK?5Failed?0?5Error?5Code?3?$CF@ DB 'EXCEPT:'
	DB	'HOOK Failed, Error Code:%d', 00H		; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?DisableSysKey@CBlockKeyBoard@@QAEXPAUHINSTANCE__@@@Z
_TEXT	SEGMENT
_nOldVal$505122 = 8					; size = 4
_hInstance$ = 8						; size = 4
?DisableSysKey@CBlockKeyBoard@@QAEXPAUHINSTANCE__@@@Z PROC ; CBlockKeyBoard::DisableSysKey, COMDAT
; _this$ = ecx

; 75   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 76   : 	if( m_bBlock )	return;

  00007	33 db		 xor	 ebx, ebx
  00009	38 5e 01	 cmp	 BYTE PTR [esi+1], bl
  0000c	75 63		 jne	 SHORT $LN5@DisableSys

; 77   : 
; 78   : 	if( m_bWin98Series )

  0000e	57		 push	 edi
  0000f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?PrintTimeAndLog@CLog@@QAAXHPADZZ

; 79   : 	{			
; 80   : 		int	nOldVal;
; 81   : 		SystemParametersInfo(SPI_SETSCREENSAVERRUNNING, TRUE, &nOldVal, 0); 

  00015	53		 push	 ebx
  00016	38 1e		 cmp	 BYTE PTR [esi], bl
  00018	74 10		 je	 SHORT $LN3@DisableSys
  0001a	8d 45 08	 lea	 eax, DWORD PTR _nOldVal$505122[ebp]
  0001d	50		 push	 eax
  0001e	6a 01		 push	 1
  00020	6a 61		 push	 97			; 00000061H
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SystemParametersInfoA@16

; 82   : 	}
; 83   : 	else

  00028	eb 31		 jmp	 SHORT $LN1@DisableSys
$LN3@DisableSys:

; 84   : 	{	
; 85   : 		m_hHook = SetWindowsHookEx(WH_KEYBOARD_LL, (HOOKPROC)LowLevelKeyboardProc, hInstance, 0);	// 키보드 후킹

  0002a	ff 75 08	 push	 DWORD PTR _hInstance$[ebp]
  0002d	68 00 00 00 00	 push	 OFFSET ?LowLevelKeyboardProc@CBlockKeyBoard@@SGJHIJ@Z ; CBlockKeyBoard::LowLevelKeyboardProc
  00032	6a 0d		 push	 13			; 0000000dH
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowsHookExA@16
  0003a	a3 00 00 00 00	 mov	 DWORD PTR ?m_hHook@CBlockKeyBoard@@0PAUHHOOK__@@A, eax ; CBlockKeyBoard::m_hHook

; 86   : 		if(m_hHook == NULL)

  0003f	3b c3		 cmp	 eax, ebx
  00041	75 18		 jne	 SHORT $LN1@DisableSys

; 87   : 		{			
; 88   : 			LOG.PrintTimeAndLog( 0,"EXCEPT:HOOK Failed, Error Code:%d", GetLastError() );

  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00049	50		 push	 eax
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@LBLJMOIK@EXCEPT?3HOOK?5Failed?0?5Error?5Code?3?$CF@
  0004f	53		 push	 ebx
  00050	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  00056	ff d7		 call	 edi
  00058	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@DisableSys:

; 89   : 		}
; 90   : 	}
; 91   : 
; 92   : 	LOG.PrintTimeAndLog( 0,"Disable Sys Key");

  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@KBGOFHBP@Disable?5Sys?5Key?$AA@
  00060	53		 push	 ebx
  00061	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  00067	ff d7		 call	 edi
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 93   : 	m_bBlock = true;

  0006c	c6 46 01 01	 mov	 BYTE PTR [esi+1], 1
  00070	5f		 pop	 edi
$LN5@DisableSys:
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx

; 94   : }

  00073	5d		 pop	 ebp
  00074	c2 04 00	 ret	 4
?DisableSysKey@CBlockKeyBoard@@QAEXPAUHINSTANCE__@@@Z ENDP ; CBlockKeyBoard::DisableSysKey
_TEXT	ENDS
PUBLIC	??_C@_0P@HMDBHOJN@Enable?5Sys?5Key?$AA@		; `string'
PUBLIC	?EnableSysKey@CBlockKeyBoard@@QAEXXZ		; CBlockKeyBoard::EnableSysKey
EXTRN	__imp__UnhookWindowsHookEx@4:PROC
;	COMDAT ??_C@_0P@HMDBHOJN@Enable?5Sys?5Key?$AA@
CONST	SEGMENT
??_C@_0P@HMDBHOJN@Enable?5Sys?5Key?$AA@ DB 'Enable Sys Key', 00H ; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?EnableSysKey@CBlockKeyBoard@@QAEXXZ
_TEXT	SEGMENT
_nOldVal$505133 = -4					; size = 4
?EnableSysKey@CBlockKeyBoard@@QAEXXZ PROC		; CBlockKeyBoard::EnableSysKey, COMDAT
; _this$ = ecx

; 97   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 98   : 	if( !m_bBlock )		return;	

  00008	33 db		 xor	 ebx, ebx
  0000a	38 5e 01	 cmp	 BYTE PTR [esi+1], bl
  0000d	74 38		 je	 SHORT $LN4@EnableSysK

; 99   : 
; 100  : 	if( m_bWin98Series )

  0000f	38 1e		 cmp	 BYTE PTR [esi], bl
  00011	74 10		 je	 SHORT $LN2@EnableSysK

; 101  : 	{			
; 102  : 		int	nOldVal;
; 103  : 		SystemParametersInfo(SPI_SETSCREENSAVERRUNNING, FALSE, &nOldVal, 0); 

  00013	53		 push	 ebx
  00014	8d 45 fc	 lea	 eax, DWORD PTR _nOldVal$505133[ebp]
  00017	50		 push	 eax
  00018	53		 push	 ebx
  00019	6a 61		 push	 97			; 00000061H
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SystemParametersInfoA@16

; 104  : 	}
; 105  : 	else

  00021	eb 0c		 jmp	 SHORT $LN1@EnableSysK
$LN2@EnableSysK:

; 106  : 	{								
; 107  : 		UnhookWindowsHookEx(m_hHook);

  00023	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_hHook@CBlockKeyBoard@@0PAUHHOOK__@@A ; CBlockKeyBoard::m_hHook
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnhookWindowsHookEx@4
$LN1@EnableSysK:

; 108  : 	}
; 109  : 
; 110  : 	LOG.PrintTimeAndLog( 0,"Enable Sys Key");	

  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0P@HMDBHOJN@Enable?5Sys?5Key?$AA@
  00034	53		 push	 ebx
  00035	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintTimeAndLog@CLog@@QAAXHPADZZ
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH

; 111  : 	m_bBlock = false;

  00044	88 5e 01	 mov	 BYTE PTR [esi+1], bl
$LN4@EnableSysK:
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx

; 112  : }

  00049	c9		 leave
  0004a	c3		 ret	 0
?EnableSysKey@CBlockKeyBoard@@QAEXXZ ENDP		; CBlockKeyBoard::EnableSysKey
_TEXT	ENDS
PUBLIC	?CheckAltTabKey@CBlockKeyBoard@@QAE_NXZ		; CBlockKeyBoard::CheckAltTabKey
; Function compile flags: /Ogsp
;	COMDAT ?CheckAltTabKey@CBlockKeyBoard@@QAE_NXZ
_TEXT	SEGMENT
?CheckAltTabKey@CBlockKeyBoard@@QAE_NXZ PROC		; CBlockKeyBoard::CheckAltTabKey, COMDAT
; _this$ = ecx

; 116  : 	if( !m_bAltTab )

  00000	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?m_bAltTab@CBlockKeyBoard@@0_NA, 0 ; CBlockKeyBoard::m_bAltTab
  00007	75 03		 jne	 SHORT $LN1@CheckAltTa

; 117  : 		return false;

  00009	32 c0		 xor	 al, al

; 121  : }

  0000b	c3		 ret	 0
$LN1@CheckAltTa:

; 118  : 
; 119  : 	m_bAltTab = false;

  0000c	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?m_bAltTab@CBlockKeyBoard@@0_NA, 0 ; CBlockKeyBoard::m_bAltTab

; 120  : 	return true;

  00013	b0 01		 mov	 al, 1

; 121  : }

  00015	c3		 ret	 0
?CheckAltTabKey@CBlockKeyBoard@@QAE_NXZ ENDP		; CBlockKeyBoard::CheckAltTabKey
_TEXT	ENDS
END
