; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\Lost Saga For Developer\Youtube\Tutorial\Source\src\LSClient\ioDummyTurret2.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_EEM_DS@?$deque@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@2HB ; std::deque<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_EEM_DS
;	COMDAT ?_EEM_DS@?$deque@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@2HB
CONST	SEGMENT
?_EEM_DS@?$deque@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@2HB DD 01H ; std::deque<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_EEM_DS
CONST	ENDS
PUBLIC	?GetBaseCharList@ioPlayStage@@QBEABV?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@XZ ; ioPlayStage::GetBaseCharList
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioplaystage.h
;	COMDAT ?GetBaseCharList@ioPlayStage@@QBEABV?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@XZ
_TEXT	SEGMENT
?GetBaseCharList@ioPlayStage@@QBEABV?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@XZ PROC ; ioPlayStage::GetBaseCharList, COMDAT
; _this$ = ecx

; 755  : 	const BaseCharList& GetBaseCharList() const { return m_BaseCharList; }

  00000	8d 41 2c	 lea	 eax, DWORD PTR [ecx+44]
  00003	c3		 ret	 0
?GetBaseCharList@ioPlayStage@@QBEABV?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@XZ ENDP ; ioPlayStage::GetBaseCharList
_TEXT	ENDS
PUBLIC	?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ	; ioBaseChar::GetCharName
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasechar.h
;	COMDAT ?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ
_TEXT	SEGMENT
?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ PROC	; ioBaseChar::GetCharName, COMDAT
; _this$ = ecx

; 2594 : 	inline const ioHashString& GetCharName() const { return m_Name; }

  00000	8d 81 d4 02 00
	00		 lea	 eax, DWORD PTR [ecx+724]
  00006	c3		 ret	 0
?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ ENDP	; ioBaseChar::GetCharName
_TEXT	ENDS
PUBLIC	_sqrtf
EXTRN	__fltused:DWORD
EXTRN	__CIsqrt:PROC
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv69 = 8						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 434  :         {return ((float)sqrt((double)_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	e8 00 00 00 00	 call	 __CIsqrt
  0000b	d9 5d 08	 fstp	 DWORD PTR tv69[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv69[ebp]
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	?GetCreator@ioBaseChar@@QAEPAVioPlayStage@@XZ	; ioBaseChar::GetCreator
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasechar.h
;	COMDAT ?GetCreator@ioBaseChar@@QAEPAVioPlayStage@@XZ
_TEXT	SEGMENT
?GetCreator@ioBaseChar@@QAEPAVioPlayStage@@XZ PROC	; ioBaseChar::GetCreator, COMDAT
; _this$ = ecx

; 4013 : 	inline ioPlayStage* GetCreator() { return m_pCreator; }

  00000	8b 81 44 03 00
	00		 mov	 eax, DWORD PTR [ecx+836]
  00006	c3		 ret	 0
?GetCreator@ioBaseChar@@QAEPAVioPlayStage@@XZ ENDP	; ioBaseChar::GetCreator
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 49   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
PUBLIC	??_R0?AVioWeapon@@@8				; ioWeapon `RTTI Type Descriptor'
PUBLIC	??_R0?AVioTraceWeapon@@@8			; ioTraceWeapon `RTTI Type Descriptor'
PUBLIC	?ToTraceWeapon@@YAPAVioTraceWeapon@@PAVioWeapon@@@Z ; ToTraceWeapon
EXTRN	___RTDynamicCast:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT ??_R0?AVioWeapon@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iotraceweapon.h
_DATA	SEGMENT
??_R0?AVioWeapon@@@8 DD FLAT:??_7type_info@@6B@		; ioWeapon `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioWeapon@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVioTraceWeapon@@@8
_DATA	SEGMENT
??_R0?AVioTraceWeapon@@@8 DD FLAT:??_7type_info@@6B@	; ioTraceWeapon `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioTraceWeapon@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToTraceWeapon@@YAPAVioTraceWeapon@@PAVioWeapon@@@Z
_TEXT	SEGMENT
_pWeapon$ = 8						; size = 4
?ToTraceWeapon@@YAPAVioTraceWeapon@@PAVioWeapon@@@Z PROC ; ToTraceWeapon, COMDAT

; 155  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 156  : 	if( !pWeapon || pWeapon->GetType() != ioWeapon::WT_TRACE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pWeapon$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 28		 je	 SHORT $LN1@ToTraceWea
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 90 10 01 00
	00		 call	 DWORD PTR [eax+272]
  00015	83 f8 14	 cmp	 eax, 20			; 00000014H
  00018	75 19		 jne	 SHORT $LN1@ToTraceWea

; 158  : 
; 159  : 	return dynamic_cast< ioTraceWeapon* >( pWeapon );

  0001a	6a 00		 push	 0
  0001c	68 00 00 00 00	 push	 OFFSET ??_R0?AVioTraceWeapon@@@8
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWeapon@@@8
  00026	6a 00		 push	 0
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002e	83 c4 14	 add	 esp, 20			; 00000014H
  00031	eb 02		 jmp	 SHORT $LN3@ToTraceWea
$LN1@ToTraceWea:

; 157  : 		return NULL;

  00033	33 c0		 xor	 eax, eax
$LN3@ToTraceWea:
  00035	5e		 pop	 esi

; 160  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?ToTraceWeapon@@YAPAVioTraceWeapon@@PAVioWeapon@@@Z ENDP ; ToTraceWeapon
_TEXT	ENDS
PUBLIC	??_7ioDummyTurret2@@6BioWorldEventReceiver@@@	; ioDummyTurret2::`vftable'
PUBLIC	??_7ioDummyTurret2@@6BioPlayEntity@@@		; ioDummyTurret2::`vftable'
PUBLIC	??0ioDummyTurret2@@QAE@PAVioEntityGroup@@PAVioPlayMode@@@Z ; ioDummyTurret2::ioDummyTurret2
PUBLIC	??_R4ioDummyTurret2@@6BioPlayEntity@@@		; ioDummyTurret2::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVioDummyTurret2@@@8			; ioDummyTurret2 `RTTI Type Descriptor'
PUBLIC	??_R3ioDummyTurret2@@8				; ioDummyTurret2::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioDummyTurret2@@8				; ioDummyTurret2::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ioDummyTurret2@@8			; ioDummyTurret2::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ioDummyChar@@8			; ioDummyChar::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVioDummyChar@@@8				; ioDummyChar `RTTI Type Descriptor'
PUBLIC	??_R3ioDummyChar@@8				; ioDummyChar::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioDummyChar@@8				; ioDummyChar::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ioPlayEntity@@8			; ioPlayEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVioPlayEntity@@@8			; ioPlayEntity `RTTI Type Descriptor'
PUBLIC	??_R3ioPlayEntity@@8				; ioPlayEntity::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioPlayEntity@@8				; ioPlayEntity::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ioGameEntity@@8			; ioGameEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVioGameEntity@@@8			; ioGameEntity `RTTI Type Descriptor'
PUBLIC	??_R3ioGameEntity@@8				; ioGameEntity::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioGameEntity@@8				; ioGameEntity::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ioEntityEvent@@8			; ioEntityEvent::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVioEntityEvent@@@8			; ioEntityEvent `RTTI Type Descriptor'
PUBLIC	??_R3ioEntityEvent@@8				; ioEntityEvent::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioEntityEvent@@8				; ioEntityEvent::`RTTI Base Class Array'
PUBLIC	??_R1BMI@?0A@EA@ioWorldEventReceiver@@8		; ioWorldEventReceiver::`RTTI Base Class Descriptor at (456,-1,0,64)'
PUBLIC	??_R0?AVioWorldEventReceiver@@@8		; ioWorldEventReceiver `RTTI Type Descriptor'
PUBLIC	??_R3ioWorldEventReceiver@@8			; ioWorldEventReceiver::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioWorldEventReceiver@@8			; ioWorldEventReceiver::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ioWorldEventReceiver@@8		; ioWorldEventReceiver::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?TranslateByConveyer@ioDummyTurret2@@UAEXABUD3DXVECTOR3@@@Z ; ioDummyTurret2::TranslateByConveyer
PUBLIC	?ApplyWeapon@ioDummyTurret2@@UAE?AW4ApplyWeaponExp@@PAVioWeapon@@@Z ; ioDummyTurret2::ApplyWeapon
PUBLIC	?LoadProperty@ioDummyTurret2@@UAEXAAVioINILoader@@@Z ; ioDummyTurret2::LoadProperty
PUBLIC	?SetTeam@ioPlayEntity@@UAEXW4TeamType@@@Z	; ioPlayEntity::SetTeam
PUBLIC	?InitDummyCharInfo@ioDummyTurret2@@UAEXHKABUD3DXVECTOR3@@0M_N@Z ; ioDummyTurret2::InitDummyCharInfo
PUBLIC	?IsActivateWeapon@ioDummyTurret2@@UAE_NXZ	; ioDummyTurret2::IsActivateWeapon
PUBLIC	?ProcessState@ioDummyTurret2@@MAEXMK@Z		; ioDummyTurret2::ProcessState
PUBLIC	?ApplyDummyCharSync@ioDummyTurret2@@UAEXPAVioPlayStage@@AAVSP2Packet@@@Z ; ioDummyTurret2::ApplyDummyCharSync
PUBLIC	?IsDummyCharMidSync@ioDummyChar@@UAE_NXZ	; ioDummyChar::IsDummyCharMidSync
PUBLIC	?SetDieState@ioDummyTurret2@@UAEX_N@Z		; ioDummyTurret2::SetDieState
PUBLIC	??_R4ioDummyTurret2@@6BioWorldEventReceiver@@@	; ioDummyTurret2::`RTTI Complete Object Locator'
PUBLIC	??_EioDummyTurret2@@WBMI@AEPAXI@Z		; [thunk]:ioDummyTurret2::`vector deleting destructor'
EXTRN	??1ioDummyChar@@UAE@XZ:PROC			; ioDummyChar::~ioDummyChar
EXTRN	__imp_??0ioHashString@@QAE@XZ:PROC
EXTRN	??0ioDummyChar@@QAE@PAVioEntityGroup@@PAVioPlayMode@@@Z:PROC ; ioDummyChar::ioDummyChar
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__EH_epilog3:PROC
EXTRN	__EH_prolog3:PROC
EXTRN	?AddEntityEvent@ioDummyChar@@UAEXPAVioEntity@@@Z:PROC ; ioDummyChar::AddEntityEvent
EXTRN	??_EioDummyTurret2@@UAEPAXI@Z:PROC		; ioDummyTurret2::`vector deleting destructor'
EXTRN	?Update@ioDummyChar@@UAEXMKK@Z:PROC		; ioDummyChar::Update
EXTRN	?UpdateAfter@ioDummyChar@@UAEXM@Z:PROC		; ioDummyChar::UpdateAfter
EXTRN	?GetTypeID@ioPlayEntity@@UBEHXZ:PROC		; ioPlayEntity::GetTypeID
EXTRN	?IsNeedCheckMapCollision@ioDummyChar@@UBE_NXZ:PROC ; ioDummyChar::IsNeedCheckMapCollision
EXTRN	?IsMountAvailable@ioDummyChar@@UBE_NXZ:PROC	; ioDummyChar::IsMountAvailable
EXTRN	?IsMountingAvailable@ioDummyChar@@UBE_NXZ:PROC	; ioDummyChar::IsMountingAvailable
EXTRN	?IsNowMountEnable@ioDummyChar@@UBE_NXZ:PROC	; ioDummyChar::IsNowMountEnable
EXTRN	?IsAllWeaponDefence@ioGameEntity@@UBE_NXZ:PROC	; ioGameEntity::IsAllWeaponDefence
EXTRN	?HasEntity@ioGameEntity@@UAE_NABVioHashString@@@Z:PROC ; ioGameEntity::HasEntity
EXTRN	?AddEntity@ioGameEntity@@UAEPAVioEntity@@ABVioHashString@@@Z:PROC ; ioGameEntity::AddEntity
EXTRN	?DestroyEntity@ioGameEntity@@UAE_NABVioHashString@@@Z:PROC ; ioGameEntity::DestroyEntity
EXTRN	?GetEntity@ioGameEntity@@UAEPAVioEntity@@ABVioHashString@@@Z:PROC ; ioGameEntity::GetEntity
EXTRN	?UpdateBound@ioGameEntity@@MBEXXZ:PROC		; ioGameEntity::UpdateBound
EXTRN	?UpdateBottomHeight@ioDummyChar@@MBEXXZ:PROC	; ioDummyChar::UpdateBottomHeight
EXTRN	?NeedUpdateBottomHeight@ioDummyChar@@UAEXXZ:PROC ; ioDummyChar::NeedUpdateBottomHeight
EXTRN	?SetWorldPosition@ioGameEntity@@UAEXABUD3DXVECTOR3@@@Z:PROC ; ioGameEntity::SetWorldPosition
EXTRN	?SetWorldOrientation@ioGameEntity@@UAEXABUD3DXQUATERNION@@@Z:PROC ; ioGameEntity::SetWorldOrientation
EXTRN	?SetWorldScale@ioGameEntity@@UAEXABUD3DXVECTOR3@@@Z:PROC ; ioGameEntity::SetWorldScale
EXTRN	?Translate@ioDummyChar@@UAEXABUD3DXVECTOR3@@@Z:PROC ; ioDummyChar::Translate
EXTRN	?TranslateByWorldEntity@ioDummyChar@@UAEXABUD3DXVECTOR3@@@Z:PROC ; ioDummyChar::TranslateByWorldEntity
EXTRN	?MapCollisionPushingTranslate@ioDummyChar@@UAEXABUD3DXVECTOR3@@@Z:PROC ; ioDummyChar::MapCollisionPushingTranslate
EXTRN	?DontMoveCollisionPushingTranslate@ioGameEntity@@UAEXPAV1@ABUD3DXVECTOR3@@@Z:PROC ; ioGameEntity::DontMoveCollisionPushingTranslate
EXTRN	?Rotate@ioGameEntity@@UAEXABUD3DXVECTOR3@@MW4TransformSpace@ioNode@@@Z:PROC ; ioGameEntity::Rotate
EXTRN	?Scale@ioGameEntity@@UAEXMMM@Z:PROC		; ioGameEntity::Scale
EXTRN	?Scale@ioGameEntity@@UAEXABUD3DXVECTOR3@@@Z:PROC ; ioGameEntity::Scale
EXTRN	?GetWorldPosition@ioGameEntity@@UBEABUD3DXVECTOR3@@XZ:PROC ; ioGameEntity::GetWorldPosition
EXTRN	?GetWorldOrientation@ioGameEntity@@UBEABUD3DXQUATERNION@@XZ:PROC ; ioGameEntity::GetWorldOrientation
EXTRN	?GetWorldScale@ioGameEntity@@UBEABUD3DXVECTOR3@@XZ:PROC ; ioGameEntity::GetWorldScale
EXTRN	?IsCollisionAvailableWeapon@ioDummyChar@@UAE_NPAVioWeapon@@@Z:PROC ; ioDummyChar::IsCollisionAvailableWeapon
EXTRN	?IsCollisionAvailableRange@ioPlayEntity@@UAE_NPAVioWeapon@@@Z:PROC ; ioPlayEntity::IsCollisionAvailableRange
EXTRN	?IsEntityCollisionSkipState@ioDummyChar@@UBE_NPAVioGameEntity@@@Z:PROC ; ioDummyChar::IsEntityCollisionSkipState
EXTRN	?IsCharCollisionSkipState@ioDummyChar@@UBE_NW4TeamType@@H@Z:PROC ; ioDummyChar::IsCharCollisionSkipState
EXTRN	?IsWoundedCollision@ioPlayEntity@@UBE_NABVioOrientBox@@PAUD3DXVECTOR3@@@Z:PROC ; ioPlayEntity::IsWoundedCollision
EXTRN	?GetAttackCollisionBox@ioDummyChar@@UAE?AVioOrientBox@@W4AniCollisionType@@_N@Z:PROC ; ioDummyChar::GetAttackCollisionBox
EXTRN	?CheckSphereDistance@ioPlayEntity@@UBE_NABUD3DXVECTOR3@@MAAM@Z:PROC ; ioPlayEntity::CheckSphereDistance
EXTRN	?CheckSpherePoint@ioPlayEntity@@UBE_NABUD3DXVECTOR3@@MAAU2@@Z:PROC ; ioPlayEntity::CheckSpherePoint
EXTRN	?CheckCylinderPoint@ioPlayEntity@@UBE_NABVioCylinder@@ABUD3DXVECTOR3@@AAU3@@Z:PROC ; ioPlayEntity::CheckCylinderPoint
EXTRN	?GetSubType@ioDummyChar@@UBE?AW4PlaySubType@ioPlayEntity@@XZ:PROC ; ioDummyChar::GetSubType
EXTRN	?GetArmorType@ioDummyChar@@UBE?AW4ArmorType@@XZ:PROC ; ioDummyChar::GetArmorType
EXTRN	?DontMoveEntityLevel@ioDummyChar@@UBEHXZ:PROC	; ioDummyChar::DontMoveEntityLevel
EXTRN	?NotifyDontMoveCollisionPushingSkip@ioPlayEntity@@UAEXPAVioGameEntity@@@Z:PROC ; ioPlayEntity::NotifyDontMoveCollisionPushingSkip
EXTRN	?GetWorldEventReceiver@ioDummyChar@@UAEPAVioWorldEventReceiver@@XZ:PROC ; ioDummyChar::GetWorldEventReceiver
EXTRN	?Revival@ioPlayEntity@@UAEXXZ:PROC		; ioPlayEntity::Revival
EXTRN	?UpdateGauge@ioDummyChar@@UAEXXZ:PROC		; ioDummyChar::UpdateGauge
EXTRN	?RenderGauge@ioDummyChar@@UAEXXZ:PROC		; ioDummyChar::RenderGauge
EXTRN	?FillMaxHP@ioPlayEntity@@UAEXXZ:PROC		; ioPlayEntity::FillMaxHP
EXTRN	?ProcessRecovery@ioPlayEntity@@MAEXXZ:PROC	; ioPlayEntity::ProcessRecovery
EXTRN	?AddHeadDamageInfo@ioPlayEntity@@UAEXH_N@Z:PROC	; ioPlayEntity::AddHeadDamageInfo
EXTRN	?RenderHeadInfoList@ioPlayEntity@@UAEXHH@Z:PROC	; ioPlayEntity::RenderHeadInfoList
EXTRN	?UpdateHeadInfoList@ioPlayEntity@@MAEXK@Z:PROC	; ioPlayEntity::UpdateHeadInfoList
EXTRN	?TestMapCollision@ioDummyChar@@UAE_NPAVioOpcodeShape@@PAVioPlayStage@@PBUD3DXMATRIX@@@Z:PROC ; ioDummyChar::TestMapCollision
EXTRN	?CheckEntityCollision@ioDummyChar@@UAEXPAVioPlayEntity@@@Z:PROC ; ioDummyChar::CheckEntityCollision
EXTRN	?GetDummyGrassType@ioDummyChar@@UAEHXZ:PROC	; ioDummyChar::GetDummyGrassType
EXTRN	?IsDummyVsDummyCollisionSkipState@ioDummyChar@@UAE_NPBV1@@Z:PROC ; ioDummyChar::IsDummyVsDummyCollisionSkipState
EXTRN	?ProcessPos@ioDummyChar@@MAEXM@Z:PROC		; ioDummyChar::ProcessPos
EXTRN	?ProcessDelayState@ioDummyChar@@MAEXM@Z:PROC	; ioDummyChar::ProcessDelayState
EXTRN	?ProcessMoveState@ioDummyChar@@MAEXM@Z:PROC	; ioDummyChar::ProcessMoveState
EXTRN	?ProcessDashState@ioDummyChar@@MAEXM@Z:PROC	; ioDummyChar::ProcessDashState
EXTRN	?ProcessAttackState@ioDummyChar@@MAEXMK@Z:PROC	; ioDummyChar::ProcessAttackState
EXTRN	?SetDelayState@ioDummyChar@@UAEX_N@Z:PROC	; ioDummyChar::SetDelayState
EXTRN	?SetMoveState@ioDummyChar@@UAEXXZ:PROC		; ioDummyChar::SetMoveState
EXTRN	?SetDieState@ioDummyChar@@UAEX_N0@Z:PROC	; ioDummyChar::SetDieState
EXTRN	?SetDashState@ioDummyChar@@UAEXXZ:PROC		; ioDummyChar::SetDashState
EXTRN	?SetAttackState@ioDummyChar@@UAEXXZ:PROC	; ioDummyChar::SetAttackState
EXTRN	?DropZoneCheck@ioDummyChar@@MAEXXZ:PROC		; ioDummyChar::DropZoneCheck
EXTRN	?SendAttackInfoToSkill@ioDummyChar@@MAEXXZ:PROC	; ioDummyChar::SendAttackInfoToSkill
EXTRN	?CheckCollisionWeapon@ioDummyChar@@UAEXPAVioBaseChar@@@Z:PROC ; ioDummyChar::CheckCollisionWeapon
EXTRN	?TranslateMountEntity@ioDummyChar@@MAEXABUD3DXVECTOR3@@@Z:PROC ; ioDummyChar::TranslateMountEntity
EXTRN	?ClearMountEntity@ioDummyChar@@MAEXXZ:PROC	; ioDummyChar::ClearMountEntity
EXTRN	?UpdateMountedEntityList@ioDummyChar@@MAEXXZ:PROC ; ioDummyChar::UpdateMountedEntityList
EXTRN	?UpdateMountedWeaponList@ioDummyChar@@MAEXXZ:PROC ; ioDummyChar::UpdateMountedWeaponList
EXTRN	?SetWorldPositionMountEntity@ioDummyChar@@MAEXM@Z:PROC ; ioDummyChar::SetWorldPositionMountEntity
EXTRN	?DummyDieClearMountEntity@ioDummyChar@@MAEXXZ:PROC ; ioDummyChar::DummyDieClearMountEntity
EXTRN	?FillDummyCharMidSync@ioDummyChar@@UAEXPAVioBaseChar@@AAVSP2Packet@@@Z:PROC ; ioDummyChar::FillDummyCharMidSync
EXTRN	?ApplyDummyCharMidSync@ioDummyChar@@UAEXPAVioBaseChar@@AAVSP2Packet@@@Z:PROC ; ioDummyChar::ApplyDummyCharMidSync
EXTRN	?GetSkillMaxActiveCnt@ioDummyChar@@UAEHXZ:PROC	; ioDummyChar::GetSkillMaxActiveCnt
EXTRN	?GetSkillCurActiveCnt@ioDummyChar@@UAEHXZ:PROC	; ioDummyChar::GetSkillCurActiveCnt
EXTRN	?OnTelepotation@ioDummyChar@@UAEXABUD3DXVECTOR3@@@Z:PROC ; ioDummyChar::OnTelepotation
EXTRN	?OnFireZoneDamage@ioDummyChar@@UAEXMABVioHashString@@@Z:PROC ; ioDummyChar::OnFireZoneDamage
EXTRN	?OnPoisonZoneDamage@ioDummyChar@@UAEXXZ:PROC	; ioDummyChar::OnPoisonZoneDamage
;	COMDAT ??_R4ioDummyTurret2@@6BioWorldEventReceiver@@@
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iodummyturret2.cpp
rdata$r	SEGMENT
??_R4ioDummyTurret2@@6BioWorldEventReceiver@@@ DD 00H	; ioDummyTurret2::`RTTI Complete Object Locator'
	DD	01c8H
	DD	00H
	DD	FLAT:??_R0?AVioDummyTurret2@@@8
	DD	FLAT:??_R3ioDummyTurret2@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ioWorldEventReceiver@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioWorldEventReceiver@@8 DD FLAT:??_R0?AVioWorldEventReceiver@@@8 ; ioWorldEventReceiver::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioWorldEventReceiver@@8
rdata$r	ENDS
;	COMDAT ??_R2ioWorldEventReceiver@@8
rdata$r	SEGMENT
??_R2ioWorldEventReceiver@@8 DD FLAT:??_R1A@?0A@EA@ioWorldEventReceiver@@8 ; ioWorldEventReceiver::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ioWorldEventReceiver@@8
rdata$r	SEGMENT
??_R3ioWorldEventReceiver@@8 DD 00H			; ioWorldEventReceiver::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ioWorldEventReceiver@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioWorldEventReceiver@@@8
_DATA	SEGMENT
??_R0?AVioWorldEventReceiver@@@8 DD FLAT:??_7type_info@@6B@ ; ioWorldEventReceiver `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioWorldEventReceiver@@', 00H
_DATA	ENDS
;	COMDAT ??_R1BMI@?0A@EA@ioWorldEventReceiver@@8
rdata$r	SEGMENT
??_R1BMI@?0A@EA@ioWorldEventReceiver@@8 DD FLAT:??_R0?AVioWorldEventReceiver@@@8 ; ioWorldEventReceiver::`RTTI Base Class Descriptor at (456,-1,0,64)'
	DD	00H
	DD	01c8H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioWorldEventReceiver@@8
rdata$r	ENDS
;	COMDAT ??_R2ioEntityEvent@@8
rdata$r	SEGMENT
??_R2ioEntityEvent@@8 DD FLAT:??_R1A@?0A@EA@ioEntityEvent@@8 ; ioEntityEvent::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ioEntityEvent@@8
rdata$r	SEGMENT
??_R3ioEntityEvent@@8 DD 00H				; ioEntityEvent::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ioEntityEvent@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioEntityEvent@@@8
_DATA	SEGMENT
??_R0?AVioEntityEvent@@@8 DD FLAT:??_7type_info@@6B@	; ioEntityEvent `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioEntityEvent@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@ioEntityEvent@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioEntityEvent@@8 DD FLAT:??_R0?AVioEntityEvent@@@8 ; ioEntityEvent::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioEntityEvent@@8
rdata$r	ENDS
;	COMDAT ??_R2ioGameEntity@@8
rdata$r	SEGMENT
??_R2ioGameEntity@@8 DD FLAT:??_R1A@?0A@EA@ioGameEntity@@8 ; ioGameEntity::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ioEntityEvent@@8
rdata$r	ENDS
;	COMDAT ??_R3ioGameEntity@@8
rdata$r	SEGMENT
??_R3ioGameEntity@@8 DD 00H				; ioGameEntity::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ioGameEntity@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioGameEntity@@@8
_DATA	SEGMENT
??_R0?AVioGameEntity@@@8 DD FLAT:??_7type_info@@6B@	; ioGameEntity `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioGameEntity@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@ioGameEntity@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioGameEntity@@8 DD FLAT:??_R0?AVioGameEntity@@@8 ; ioGameEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioGameEntity@@8
rdata$r	ENDS
;	COMDAT ??_R2ioPlayEntity@@8
rdata$r	SEGMENT
??_R2ioPlayEntity@@8 DD FLAT:??_R1A@?0A@EA@ioPlayEntity@@8 ; ioPlayEntity::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ioGameEntity@@8
	DD	FLAT:??_R1A@?0A@EA@ioEntityEvent@@8
rdata$r	ENDS
;	COMDAT ??_R3ioPlayEntity@@8
rdata$r	SEGMENT
??_R3ioPlayEntity@@8 DD 00H				; ioPlayEntity::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2ioPlayEntity@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioPlayEntity@@@8
_DATA	SEGMENT
??_R0?AVioPlayEntity@@@8 DD FLAT:??_7type_info@@6B@	; ioPlayEntity `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioPlayEntity@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@ioPlayEntity@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioPlayEntity@@8 DD FLAT:??_R0?AVioPlayEntity@@@8 ; ioPlayEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioPlayEntity@@8
rdata$r	ENDS
;	COMDAT ??_R2ioDummyChar@@8
rdata$r	SEGMENT
??_R2ioDummyChar@@8 DD FLAT:??_R1A@?0A@EA@ioDummyChar@@8 ; ioDummyChar::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ioPlayEntity@@8
	DD	FLAT:??_R1A@?0A@EA@ioGameEntity@@8
	DD	FLAT:??_R1A@?0A@EA@ioEntityEvent@@8
	DD	FLAT:??_R1BMI@?0A@EA@ioWorldEventReceiver@@8
rdata$r	ENDS
;	COMDAT ??_R3ioDummyChar@@8
rdata$r	SEGMENT
??_R3ioDummyChar@@8 DD 00H				; ioDummyChar::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	FLAT:??_R2ioDummyChar@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioDummyChar@@@8
_DATA	SEGMENT
??_R0?AVioDummyChar@@@8 DD FLAT:??_7type_info@@6B@	; ioDummyChar `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioDummyChar@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@ioDummyChar@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioDummyChar@@8 DD FLAT:??_R0?AVioDummyChar@@@8 ; ioDummyChar::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioDummyChar@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ioDummyTurret2@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioDummyTurret2@@8 DD FLAT:??_R0?AVioDummyTurret2@@@8 ; ioDummyTurret2::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	05H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioDummyTurret2@@8
rdata$r	ENDS
;	COMDAT ??_R2ioDummyTurret2@@8
rdata$r	SEGMENT
??_R2ioDummyTurret2@@8 DD FLAT:??_R1A@?0A@EA@ioDummyTurret2@@8 ; ioDummyTurret2::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ioDummyChar@@8
	DD	FLAT:??_R1A@?0A@EA@ioPlayEntity@@8
	DD	FLAT:??_R1A@?0A@EA@ioGameEntity@@8
	DD	FLAT:??_R1A@?0A@EA@ioEntityEvent@@8
	DD	FLAT:??_R1BMI@?0A@EA@ioWorldEventReceiver@@8
rdata$r	ENDS
;	COMDAT ??_R3ioDummyTurret2@@8
rdata$r	SEGMENT
??_R3ioDummyTurret2@@8 DD 00H				; ioDummyTurret2::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	06H
	DD	FLAT:??_R2ioDummyTurret2@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioDummyTurret2@@@8
_DATA	SEGMENT
??_R0?AVioDummyTurret2@@@8 DD FLAT:??_7type_info@@6B@	; ioDummyTurret2 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioDummyTurret2@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ioDummyTurret2@@6BioPlayEntity@@@
rdata$r	SEGMENT
??_R4ioDummyTurret2@@6BioPlayEntity@@@ DD 00H		; ioDummyTurret2::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVioDummyTurret2@@@8
	DD	FLAT:??_R3ioDummyTurret2@@8
rdata$r	ENDS
;	COMDAT ??_7ioDummyTurret2@@6BioWorldEventReceiver@@@
CONST	SEGMENT
??_7ioDummyTurret2@@6BioWorldEventReceiver@@@ DD FLAT:??_R4ioDummyTurret2@@6BioWorldEventReceiver@@@ ; ioDummyTurret2::`vftable'
	DD	FLAT:?OnTelepotation@ioDummyChar@@UAEXABUD3DXVECTOR3@@@Z
	DD	FLAT:?OnFireZoneDamage@ioDummyChar@@UAEXMABVioHashString@@@Z
	DD	FLAT:?OnPoisonZoneDamage@ioDummyChar@@UAEXXZ
	DD	FLAT:??_EioDummyTurret2@@WBMI@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_7ioDummyTurret2@@6BioPlayEntity@@@
CONST	SEGMENT
??_7ioDummyTurret2@@6BioPlayEntity@@@ DD FLAT:??_R4ioDummyTurret2@@6BioPlayEntity@@@ ; ioDummyTurret2::`vftable'
	DD	FLAT:?AddEntityEvent@ioDummyChar@@UAEXPAVioEntity@@@Z
	DD	FLAT:??_EioDummyTurret2@@UAEPAXI@Z
	DD	FLAT:?Update@ioDummyChar@@UAEXMKK@Z
	DD	FLAT:?UpdateAfter@ioDummyChar@@UAEXM@Z
	DD	FLAT:?GetTypeID@ioPlayEntity@@UBEHXZ
	DD	FLAT:?IsNeedCheckMapCollision@ioDummyChar@@UBE_NXZ
	DD	FLAT:?IsMountAvailable@ioDummyChar@@UBE_NXZ
	DD	FLAT:?IsMountingAvailable@ioDummyChar@@UBE_NXZ
	DD	FLAT:?IsNowMountEnable@ioDummyChar@@UBE_NXZ
	DD	FLAT:?IsAllWeaponDefence@ioGameEntity@@UBE_NXZ
	DD	FLAT:?HasEntity@ioGameEntity@@UAE_NABVioHashString@@@Z
	DD	FLAT:?AddEntity@ioGameEntity@@UAEPAVioEntity@@ABVioHashString@@@Z
	DD	FLAT:?DestroyEntity@ioGameEntity@@UAE_NABVioHashString@@@Z
	DD	FLAT:?GetEntity@ioGameEntity@@UAEPAVioEntity@@ABVioHashString@@@Z
	DD	FLAT:?UpdateBound@ioGameEntity@@MBEXXZ
	DD	FLAT:?UpdateBottomHeight@ioDummyChar@@MBEXXZ
	DD	FLAT:?NeedUpdateBottomHeight@ioDummyChar@@UAEXXZ
	DD	FLAT:?SetWorldPosition@ioGameEntity@@UAEXABUD3DXVECTOR3@@@Z
	DD	FLAT:?SetWorldOrientation@ioGameEntity@@UAEXABUD3DXQUATERNION@@@Z
	DD	FLAT:?SetWorldScale@ioGameEntity@@UAEXABUD3DXVECTOR3@@@Z
	DD	FLAT:?Translate@ioDummyChar@@UAEXABUD3DXVECTOR3@@@Z
	DD	FLAT:?TranslateByConveyer@ioDummyTurret2@@UAEXABUD3DXVECTOR3@@@Z
	DD	FLAT:?TranslateByWorldEntity@ioDummyChar@@UAEXABUD3DXVECTOR3@@@Z
	DD	FLAT:?MapCollisionPushingTranslate@ioDummyChar@@UAEXABUD3DXVECTOR3@@@Z
	DD	FLAT:?DontMoveCollisionPushingTranslate@ioGameEntity@@UAEXPAV1@ABUD3DXVECTOR3@@@Z
	DD	FLAT:?Rotate@ioGameEntity@@UAEXABUD3DXVECTOR3@@MW4TransformSpace@ioNode@@@Z
	DD	FLAT:?Scale@ioGameEntity@@UAEXMMM@Z
	DD	FLAT:?Scale@ioGameEntity@@UAEXABUD3DXVECTOR3@@@Z
	DD	FLAT:?GetWorldPosition@ioGameEntity@@UBEABUD3DXVECTOR3@@XZ
	DD	FLAT:?GetWorldOrientation@ioGameEntity@@UBEABUD3DXQUATERNION@@XZ
	DD	FLAT:?GetWorldScale@ioGameEntity@@UBEABUD3DXVECTOR3@@XZ
	DD	FLAT:?ApplyWeapon@ioDummyTurret2@@UAE?AW4ApplyWeaponExp@@PAVioWeapon@@@Z
	DD	FLAT:?IsCollisionAvailableWeapon@ioDummyChar@@UAE_NPAVioWeapon@@@Z
	DD	FLAT:?IsCollisionAvailableRange@ioPlayEntity@@UAE_NPAVioWeapon@@@Z
	DD	FLAT:?IsEntityCollisionSkipState@ioDummyChar@@UBE_NPAVioGameEntity@@@Z
	DD	FLAT:?IsCharCollisionSkipState@ioDummyChar@@UBE_NW4TeamType@@H@Z
	DD	FLAT:?IsWoundedCollision@ioPlayEntity@@UBE_NABVioOrientBox@@PAUD3DXVECTOR3@@@Z
	DD	FLAT:?GetAttackCollisionBox@ioDummyChar@@UAE?AVioOrientBox@@W4AniCollisionType@@_N@Z
	DD	FLAT:?CheckSphereDistance@ioPlayEntity@@UBE_NABUD3DXVECTOR3@@MAAM@Z
	DD	FLAT:?CheckSpherePoint@ioPlayEntity@@UBE_NABUD3DXVECTOR3@@MAAU2@@Z
	DD	FLAT:?CheckCylinderPoint@ioPlayEntity@@UBE_NABVioCylinder@@ABUD3DXVECTOR3@@AAU3@@Z
	DD	FLAT:?GetSubType@ioDummyChar@@UBE?AW4PlaySubType@ioPlayEntity@@XZ
	DD	FLAT:?GetArmorType@ioDummyChar@@UBE?AW4ArmorType@@XZ
	DD	FLAT:?DontMoveEntityLevel@ioDummyChar@@UBEHXZ
	DD	FLAT:?NotifyDontMoveCollisionPushingSkip@ioPlayEntity@@UAEXPAVioGameEntity@@@Z
	DD	FLAT:?LoadProperty@ioDummyTurret2@@UAEXAAVioINILoader@@@Z
	DD	FLAT:?GetWorldEventReceiver@ioDummyChar@@UAEPAVioWorldEventReceiver@@XZ
	DD	FLAT:?Revival@ioPlayEntity@@UAEXXZ
	DD	FLAT:?UpdateGauge@ioDummyChar@@UAEXXZ
	DD	FLAT:?RenderGauge@ioDummyChar@@UAEXXZ
	DD	FLAT:?FillMaxHP@ioPlayEntity@@UAEXXZ
	DD	FLAT:?ProcessRecovery@ioPlayEntity@@MAEXXZ
	DD	FLAT:?AddHeadDamageInfo@ioPlayEntity@@UAEXH_N@Z
	DD	FLAT:?RenderHeadInfoList@ioPlayEntity@@UAEXHH@Z
	DD	FLAT:?UpdateHeadInfoList@ioPlayEntity@@MAEXK@Z
	DD	FLAT:?SetTeam@ioPlayEntity@@UAEXW4TeamType@@@Z
	DD	FLAT:?InitDummyCharInfo@ioDummyTurret2@@UAEXHKABUD3DXVECTOR3@@0M_N@Z
	DD	FLAT:?TestMapCollision@ioDummyChar@@UAE_NPAVioOpcodeShape@@PAVioPlayStage@@PBUD3DXMATRIX@@@Z
	DD	FLAT:?CheckEntityCollision@ioDummyChar@@UAEXPAVioPlayEntity@@@Z
	DD	FLAT:?GetDummyGrassType@ioDummyChar@@UAEHXZ
	DD	FLAT:?IsActivateWeapon@ioDummyTurret2@@UAE_NXZ
	DD	FLAT:?IsDummyVsDummyCollisionSkipState@ioDummyChar@@UAE_NPBV1@@Z
	DD	FLAT:?ProcessState@ioDummyTurret2@@MAEXMK@Z
	DD	FLAT:?ProcessPos@ioDummyChar@@MAEXM@Z
	DD	FLAT:?ProcessDelayState@ioDummyChar@@MAEXM@Z
	DD	FLAT:?ProcessMoveState@ioDummyChar@@MAEXM@Z
	DD	FLAT:?ProcessDashState@ioDummyChar@@MAEXM@Z
	DD	FLAT:?ProcessAttackState@ioDummyChar@@MAEXMK@Z
	DD	FLAT:?ApplyDummyCharSync@ioDummyTurret2@@UAEXPAVioPlayStage@@AAVSP2Packet@@@Z
	DD	FLAT:?SetDelayState@ioDummyChar@@UAEX_N@Z
	DD	FLAT:?SetMoveState@ioDummyChar@@UAEXXZ
	DD	FLAT:?SetDieState@ioDummyChar@@UAEX_N0@Z
	DD	FLAT:?SetDashState@ioDummyChar@@UAEXXZ
	DD	FLAT:?SetAttackState@ioDummyChar@@UAEXXZ
	DD	FLAT:?DropZoneCheck@ioDummyChar@@MAEXXZ
	DD	FLAT:?SendAttackInfoToSkill@ioDummyChar@@MAEXXZ
	DD	FLAT:?CheckCollisionWeapon@ioDummyChar@@UAEXPAVioBaseChar@@@Z
	DD	FLAT:?TranslateMountEntity@ioDummyChar@@MAEXABUD3DXVECTOR3@@@Z
	DD	FLAT:?ClearMountEntity@ioDummyChar@@MAEXXZ
	DD	FLAT:?UpdateMountedEntityList@ioDummyChar@@MAEXXZ
	DD	FLAT:?UpdateMountedWeaponList@ioDummyChar@@MAEXXZ
	DD	FLAT:?SetWorldPositionMountEntity@ioDummyChar@@MAEXM@Z
	DD	FLAT:?DummyDieClearMountEntity@ioDummyChar@@MAEXXZ
	DD	FLAT:?IsDummyCharMidSync@ioDummyChar@@UAE_NXZ
	DD	FLAT:?FillDummyCharMidSync@ioDummyChar@@UAEXPAVioBaseChar@@AAVSP2Packet@@@Z
	DD	FLAT:?ApplyDummyCharMidSync@ioDummyChar@@UAEXPAVioBaseChar@@AAVSP2Packet@@@Z
	DD	FLAT:?GetSkillMaxActiveCnt@ioDummyChar@@UAEHXZ
	DD	FLAT:?GetSkillCurActiveCnt@ioDummyChar@@UAEHXZ
	DD	FLAT:?SetDieState@ioDummyTurret2@@UAEX_N@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ioDummyTurret2@@QAE@PAVioEntityGroup@@PAVioPlayMode@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ioDummyTurret2@@QAE@PAVioEntityGroup@@PAVioPlayMode@@@Z$0
__ehfuncinfo$??0ioDummyTurret2@@QAE@PAVioEntityGroup@@PAVioPlayMode@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0ioDummyTurret2@@QAE@PAVioEntityGroup@@PAVioPlayMode@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??0ioDummyTurret2@@QAE@PAVioEntityGroup@@PAVioPlayMode@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pGrp$ = 8						; size = 4
_pMode$ = 12						; size = 4
??0ioDummyTurret2@@QAE@PAVioEntityGroup@@PAVioPlayMode@@@Z PROC ; ioDummyTurret2::ioDummyTurret2, COMDAT
; _this$ = ecx

; 14   : {

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0ioDummyTurret2@@QAE@PAVioEntityGroup@@PAVioPlayMode@@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	ff 75 0c	 push	 DWORD PTR _pMode$[ebp]
  00014	ff 75 08	 push	 DWORD PTR _pGrp$[ebp]
  00017	e8 00 00 00 00	 call	 ??0ioDummyChar@@QAE@PAVioEntityGroup@@PAVioPlayMode@@@Z ; ioDummyChar::ioDummyChar
  0001c	33 db		 xor	 ebx, ebx
  0001e	8d 8e 94 14 00
	00		 lea	 ecx, DWORD PTR [esi+5268]
  00024	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00027	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioDummyTurret2@@6BioPlayEntity@@@
  0002d	c7 86 c8 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+456], OFFSET ??_7ioDummyTurret2@@6BioWorldEventReceiver@@@
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ

; 15   : 	m_bStartInit = false;

  0003d	88 9e 84 14 00
	00		 mov	 BYTE PTR [esi+5252], bl

; 16   : 	m_CurDirKey = ioUserKeyInput::DKI_NONE;

  00043	89 9e 5c 0d 00
	00		 mov	 DWORD PTR [esi+3420], ebx

; 17   : 	m_bSetDownKey = false;

  00049	66 89 9e 58 0d
	00 00		 mov	 WORD PTR [esi+3416], bx

; 18   : 	m_bSetUpKey = false;
; 19   : 	m_TurretState = DMS_START;

  00050	89 9e 80 14 00
	00		 mov	 DWORD PTR [esi+5248], ebx

; 20   : 
; 21   : 	m_nCurBullet = 0;

  00056	89 9e a8 14 00
	00		 mov	 DWORD PTR [esi+5288], ebx

; 22   : }

  0005c	8b c6		 mov	 eax, esi
  0005e	e8 00 00 00 00	 call	 __EH_epilog3
  00063	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ioDummyTurret2@@QAE@PAVioEntityGroup@@PAVioPlayMode@@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1ioDummyChar@@UAE@XZ	; ioDummyChar::~ioDummyChar
__ehhandler$??0ioDummyTurret2@@QAE@PAVioEntityGroup@@PAVioPlayMode@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ioDummyTurret2@@QAE@PAVioEntityGroup@@PAVioPlayMode@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ioDummyTurret2@@QAE@PAVioEntityGroup@@PAVioPlayMode@@@Z ENDP ; ioDummyTurret2::ioDummyTurret2
PUBLIC	??1ioDummyTurret2@@UAE@XZ			; ioDummyTurret2::~ioDummyTurret2
EXTRN	__imp_??1ioHashString@@QAE@XZ:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1ioDummyTurret2@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1ioDummyTurret2@@UAE@XZ$0
__ehfuncinfo$??1ioDummyTurret2@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1ioDummyTurret2@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??1ioDummyTurret2@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1ioDummyTurret2@@UAE@XZ PROC				; ioDummyTurret2::~ioDummyTurret2, COMDAT
; _this$ = ecx

; 25   : {

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??1ioDummyTurret2@@UAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioDummyTurret2@@6BioPlayEntity@@@
  00017	c7 86 c8 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+456], OFFSET ??_7ioDummyTurret2@@6BioWorldEventReceiver@@@
  00021	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 26   : }

  00025	8d 8e 94 14 00
	00		 lea	 ecx, DWORD PTR [esi+5268]
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00031	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00035	8b ce		 mov	 ecx, esi
  00037	e8 00 00 00 00	 call	 ??1ioDummyChar@@UAE@XZ	; ioDummyChar::~ioDummyChar
  0003c	e8 00 00 00 00	 call	 __EH_epilog3
  00041	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1ioDummyTurret2@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1ioDummyChar@@UAE@XZ	; ioDummyChar::~ioDummyChar
__ehhandler$??1ioDummyTurret2@@UAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1ioDummyTurret2@@UAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1ioDummyTurret2@@UAE@XZ ENDP				; ioDummyTurret2::~ioDummyTurret2
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@41200000
PUBLIC	__real@00000000
PUBLIC	__real@3f800000
PUBLIC	?ProcessStartState@ioDummyTurret2@@IAEXM@Z	; ioDummyTurret2::ProcessStartState
EXTRN	__imp_?SetLoopAni@ioEntityGroup@@QAE_NHMMMM@Z:PROC
EXTRN	__imp_?ClearAllLoopAni@ioEntityGroup@@QAEXM_N@Z:PROC
EXTRN	__imp_?ClearAllActionAni@ioEntityGroup@@QAEXM_N@Z:PROC
EXTRN	__imp_?GetAnimationIdx@ioEntityGroup@@QAEHABVioHashString@@@Z:PROC
EXTRN	__imp_?IsEmpty@ioHashString@@QBE_NXZ:PROC
EXTRN	__imp_?GetLoopSec@ioFrameTimer@@QBEKXZ:PROC
EXTRN	__imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ:PROC
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?ProcessStartState@ioDummyTurret2@@IAEXM@Z
_TEXT	SEGMENT
_fAniRate$550789 = -4					; size = 4
_fTimePerSec$ = 8					; size = 4
?ProcessStartState@ioDummyTurret2@@IAEXM@Z PROC		; ioDummyTurret2::ProcessStartState, COMDAT
; _this$ = ecx

; 103  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 104  : 	DWORD dwCurTime = FRAMEGETTIME();

  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  0000d	8b c8		 mov	 ecx, eax
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ

; 105  : 
; 106  : 	if( m_dwStartAniEndTime == 0 )

  00015	8b 8e e4 06 00
	00		 mov	 ecx, DWORD PTR [esi+1764]
  0001b	85 c9		 test	 ecx, ecx
  0001d	75 11		 jne	 SHORT $LN5@ProcessSta

; 107  : 	{
; 108  : 		SetDieState( true );

  0001f	8b 06		 mov	 eax, DWORD PTR [esi]
  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	ff 90 60 01 00
	00		 call	 DWORD PTR [eax+352]

; 109  : 		return;

  0002b	e9 e3 00 00 00	 jmp	 $LN2@ProcessSta
$LN5@ProcessSta:

; 110  : 	}
; 111  : 
; 112  : 	if( m_dwStartAniEndTime < dwCurTime )

  00030	3b c8		 cmp	 ecx, eax
  00032	0f 83 db 00 00
	00		 jae	 $LN2@ProcessSta

; 113  : 	{
; 114  : 		m_TurretState = DMS_SENSING;
; 115  : 
; 116  : 		if( !m_DelayAnimation.IsEmpty() )

  00038	57		 push	 edi
  00039	8d be a8 06 00
	00		 lea	 edi, DWORD PTR [esi+1704]
  0003f	8b cf		 mov	 ecx, edi
  00041	c7 86 80 14 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+5248], 1
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00051	84 c0		 test	 al, al
  00053	0f 85 b9 00 00
	00		 jne	 $LN8@ProcessSta

; 117  : 		{
; 118  : 			int iAniID = m_pGroup->GetAnimationIdx( m_DelayAnimation );

  00059	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0005c	57		 push	 edi
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetAnimationIdx@ioEntityGroup@@QAEHABVioHashString@@@Z
  00063	8b f8		 mov	 edi, eax

; 119  : 			if( iAniID != -1 )

  00065	83 ff ff	 cmp	 edi, -1
  00068	0f 84 a4 00 00
	00		 je	 $LN8@ProcessSta

; 120  : 			{
; 121  : 				float fAniRate = 1.0f;

  0006e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00076	f3 0f 11 45 fc	 movss	 DWORD PTR _fAniRate$550789[ebp], xmm0

; 122  : 				if( m_fDelayAniRate > 0.0f )

  0007b	f3 0f 10 86 b8
	06 00 00	 movss	 xmm0, DWORD PTR [esi+1720]
  00083	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0008a	76 05		 jbe	 SHORT $LN1@ProcessSta

; 123  : 					fAniRate = m_fDelayAniRate;

  0008c	f3 0f 11 45 fc	 movss	 DWORD PTR _fAniRate$550789[ebp], xmm0
$LN1@ProcessSta:

; 124  : 
; 125  : 				m_pGroup->ClearAllActionAni( 10.0f, true );

  00091	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41200000
  00099	6a 01		 push	 1
  0009b	51		 push	 ecx
  0009c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0009f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ClearAllActionAni@ioEntityGroup@@QAEXM_N@Z

; 126  : 				m_pGroup->ClearAllLoopAni( 10.0f, true );

  000aa	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41200000
  000b2	6a 01		 push	 1
  000b4	51		 push	 ecx
  000b5	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000b8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ClearAllLoopAni@ioEntityGroup@@QAEXM_N@Z

; 127  : 
; 128  : 				m_pGroup->SetLoopAni( iAniID, 10.0f, 1.0f, 1.0f/fAniRate );

  000c3	0f 57 c0	 xorps	 xmm0, xmm0
  000c6	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  000ce	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000d1	83 ec 10	 sub	 esp, 16			; 00000010H
  000d4	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  000da	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fAniRate$550789[ebp]
  000df	0f 5a c0	 cvtps2pd xmm0, xmm0
  000e2	f2 0f 5e c8	 divsd	 xmm1, xmm0
  000e6	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  000ea	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  000f0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000f8	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000fe	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41200000
  00106	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0010b	57		 push	 edi
  0010c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetLoopAni@ioEntityGroup@@QAE_NHMMMM@Z
$LN8@ProcessSta:
  00112	5f		 pop	 edi
$LN2@ProcessSta:
  00113	5e		 pop	 esi

; 129  : 			}
; 130  : 		}
; 131  : 	}
; 132  : }

  00114	c9		 leave
  00115	c2 04 00	 ret	 4
?ProcessStartState@ioDummyTurret2@@IAEXM@Z ENDP		; ioDummyTurret2::ProcessStartState
_TEXT	ENDS
EXTRN	__imp_?PlaySoundA@ioSoundManager@@QAEKABVioHashString@@HK@Z:PROC
EXTRN	__imp_?GetSingleton@ioSoundManager@@SAAAV1@XZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ?SetDieState@ioDummyTurret2@@UAEX_N@Z
_TEXT	SEGMENT
_bEffect$ = 8						; size = 1
?SetDieState@ioDummyTurret2@@UAEX_N@Z PROC		; ioDummyTurret2::SetDieState, COMDAT
; _this$ = ecx

; 295  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 296  : 	if ( !m_szExplosionSound.IsEmpty() )

  00007	8d b7 94 14 00
	00		 lea	 esi, DWORD PTR [edi+5268]
  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00015	84 c0		 test	 al, al
  00017	75 13		 jne	 SHORT $LN1@SetDieStat

; 297  : 	{
; 298  : 		g_SoundMgr.PlaySound( m_szExplosionSound );

  00019	6a 04		 push	 4
  0001b	6a 00		 push	 0
  0001d	56		 push	 esi
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioSoundManager@@SAAAV1@XZ
  00024	8b c8		 mov	 ecx, eax
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PlaySoundA@ioSoundManager@@QAEKABVioHashString@@HK@Z
$LN1@SetDieStat:

; 299  : 	}
; 300  : 
; 301  : 	ioDummyChar::SetDieState( bEffect );

  0002c	6a 00		 push	 0
  0002e	ff 75 08	 push	 DWORD PTR _bEffect$[ebp]
  00031	8b cf		 mov	 ecx, edi
  00033	e8 00 00 00 00	 call	 ?SetDieState@ioDummyChar@@UAEX_N0@Z ; ioDummyChar::SetDieState
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi

; 302  : }

  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
?SetDieState@ioDummyTurret2@@UAEX_N@Z ENDP		; ioDummyTurret2::SetDieState
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?IsActivateWeapon@ioDummyTurret2@@UAE_NXZ
_TEXT	SEGMENT
?IsActivateWeapon@ioDummyTurret2@@UAE_NXZ PROC		; ioDummyTurret2::IsActivateWeapon, COMDAT
; _this$ = ecx

; 306  : 	if( m_TurretState == DMS_START )

  00000	83 b9 80 14 00
	00 00		 cmp	 DWORD PTR [ecx+5248], 0
  00007	0f 95 c0	 setne	 al

; 307  : 		return false;
; 308  : 
; 309  : 	return true;
; 310  : }

  0000a	c3		 ret	 0
?IsActivateWeapon@ioDummyTurret2@@UAE_NXZ ENDP		; ioDummyTurret2::IsActivateWeapon
_TEXT	ENDS
PUBLIC	??1FireTime@@QAE@XZ				; FireTime::~FireTime
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1FireTime@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1FireTime@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1FireTime@@QAE@XZ$1
__ehfuncinfo$??1FireTime@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1FireTime@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??1FireTime@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1FireTime@@QAE@XZ PROC				; FireTime::~FireTime, COMDAT
; _this$ = ecx
  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??1FireTime@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f9		 mov	 edi, ecx
  0000e	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  00011	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00017	8d 4f 44	 lea	 ecx, DWORD PTR [edi+68]
  0001a	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00021	ff d6		 call	 esi
  00023	8d 4f 30	 lea	 ecx, DWORD PTR [edi+48]
  00026	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0002a	ff d6		 call	 esi
  0002c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00030	8d 4f 14	 lea	 ecx, DWORD PTR [edi+20]
  00033	ff d6		 call	 esi
  00035	e8 00 00 00 00	 call	 __EH_epilog3
  0003a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1FireTime@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 14	 add	 ecx, 20			; 00000014H
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??1FireTime@@QAE@XZ$1:
  0000c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 30	 add	 ecx, 48			; 00000030H
  00012	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$??1FireTime@@QAE@XZ:
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1FireTime@@QAE@XZ
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1FireTime@@QAE@XZ ENDP				; FireTime::~FireTime
; Function compile flags: /Ogsp
;	COMDAT ?TranslateByConveyer@ioDummyTurret2@@UAEXABUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_vMove$ = 8						; size = 4
?TranslateByConveyer@ioDummyTurret2@@UAEXABUD3DXVECTOR3@@@Z PROC ; ioDummyTurret2::TranslateByConveyer, COMDAT
; _this$ = ecx

; 438  : 	return;
; 439  : }

  00000	c2 04 00	 ret	 4
?TranslateByConveyer@ioDummyTurret2@@UAEXABUD3DXVECTOR3@@@Z ENDP ; ioDummyTurret2::TranslateByConveyer
_TEXT	ENDS
PUBLIC	_vPos$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	?GetOwner@ioDummyChar@@QBEPAVioBaseChar@@XZ:PROC ; ioDummyChar::GetOwner
EXTRN	?InitDummyCharInfo@ioDummyChar@@UAEXHKABUD3DXVECTOR3@@0M_N@Z:PROC ; ioDummyChar::InitDummyCharInfo
EXTRN	___security_cookie:DWORD
; Function compile flags: /Ogsp
;	COMDAT ?InitDummyCharInfo@ioDummyTurret2@@UAEXHKABUD3DXVECTOR3@@0M_N@Z
_TEXT	SEGMENT
_vPos$GSCopy$ = -24					; size = 4
_pOwner$551028 = -20					; size = 4
_vWorldPos$551032 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_dwCreateGapTime$ = 12					; size = 4
_vPos$ = 16						; size = 4
_vScale$ = 20						; size = 4
_fStartAngle$ = 24					; size = 4
_bNetWork$ = 28						; size = 1
?InitDummyCharInfo@ioDummyTurret2@@UAEXHKABUD3DXVECTOR3@@0M_N@Z PROC ; ioDummyTurret2::InitDummyCharInfo, COMDAT
; _this$ = ecx

; 442  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 14	 mov	 eax, DWORD PTR _vScale$[ebp]

; 443  : 	__super::InitDummyCharInfo( iIndex, dwCreateGapTime, vPos, vScale, fStartAngle, bNetWork );

  00013	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _fStartAngle$[ebp]
  00018	53		 push	 ebx
  00019	ff 75 1c	 push	 DWORD PTR _bNetWork$[ebp]
  0001c	8b d9		 mov	 ebx, ecx
  0001e	8b 4d 10	 mov	 ecx, DWORD PTR _vPos$[ebp]
  00021	51		 push	 ecx
  00022	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00027	50		 push	 eax
  00028	51		 push	 ecx
  00029	ff 75 0c	 push	 DWORD PTR _dwCreateGapTime$[ebp]

; 463  : 		}
; 464  : 
; 465  : 		SetWorldPosition( vWorldPos );

  0002c	89 4d e8	 mov	 DWORD PTR _vPos$GSCopy$[ebp], ecx
  0002f	ff 75 08	 push	 DWORD PTR _iIndex$[ebp]
  00032	8b cb		 mov	 ecx, ebx
  00034	e8 00 00 00 00	 call	 ?InitDummyCharInfo@ioDummyChar@@UAEXHKABUD3DXVECTOR3@@0M_N@Z ; ioDummyChar::InitDummyCharInfo
  00039	80 bb b8 14 00
	00 00		 cmp	 BYTE PTR [ebx+5304], 0
  00040	74 7d		 je	 SHORT $LN5@InitDummyC

; 444  : 
; 445  : 	if( m_bUseAirSetting )
; 446  : 	{
; 447  : 		ioBaseChar* pOwner = GetOwner();

  00042	8b cb		 mov	 ecx, ebx
  00044	e8 00 00 00 00	 call	 ?GetOwner@ioDummyChar@@QBEPAVioBaseChar@@XZ ; ioDummyChar::GetOwner
  00049	89 45 ec	 mov	 DWORD PTR _pOwner$551028[ebp], eax

; 448  : 		if( !pOwner )

  0004c	85 c0		 test	 eax, eax
  0004e	74 6f		 je	 SHORT $LN5@InitDummyC

; 449  : 			return;
; 450  : 
; 451  : 		ioPlayStage* pStage = pOwner->GetCreator();
; 452  : 		if( !pStage )

  00050	83 b8 44 03 00
	00 00		 cmp	 DWORD PTR [eax+836], 0
  00057	74 66		 je	 SHORT $LN5@InitDummyC

; 453  : 			return;
; 454  : 
; 455  : 		D3DXVECTOR3 vWorldPos = GetWorldPosition();

  00059	8b 03		 mov	 eax, DWORD PTR [ebx]
  0005b	56		 push	 esi
  0005c	57		 push	 edi
  0005d	8b cb		 mov	 ecx, ebx
  0005f	ff 50 70	 call	 DWORD PTR [eax+112]

; 456  : 		if( vPos.y < 1.0f )

  00062	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0006a	8b f0		 mov	 esi, eax
  0006c	8b 45 e8	 mov	 eax, DWORD PTR _vPos$GSCopy$[ebp]
  0006f	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  00073	8d 7d f0	 lea	 edi, DWORD PTR _vWorldPos$551032[ebp]
  00076	a5		 movsd
  00077	a5		 movsd
  00078	a5		 movsd
  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	76 17		 jbe	 SHORT $LN2@InitDummyC

; 457  : 		{
; 458  : 			vWorldPos.y = pOwner->GetWorldPosition().y + m_fAirHeightOffSet;

  0007d	8b 4d ec	 mov	 ecx, DWORD PTR _pOwner$551028[ebp]
  00080	8b 01		 mov	 eax, DWORD PTR [ecx]
  00082	ff 50 70	 call	 DWORD PTR [eax+112]
  00085	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0008a	f3 0f 10 8b bc
	14 00 00	 movss	 xmm1, DWORD PTR [ebx+5308]

; 459  : 		}
; 460  : 		else

  00092	eb 0d		 jmp	 SHORT $LN10@InitDummyC
$LN2@InitDummyC:

; 461  : 		{
; 462  : 			vWorldPos.y = vWorldPos.y + m_fAirHeightOffSet;

  00094	f3 0f 10 83 bc
	14 00 00	 movss	 xmm0, DWORD PTR [ebx+5308]
  0009c	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR _vWorldPos$551032[ebp+4]
$LN10@InitDummyC:

; 463  : 		}
; 464  : 
; 465  : 		SetWorldPosition( vWorldPos );

  000a1	8b 03		 mov	 eax, DWORD PTR [ebx]
  000a3	0f 5a c0	 cvtps2pd xmm0, xmm0
  000a6	8d 4d f0	 lea	 ecx, DWORD PTR _vWorldPos$551032[ebp]
  000a9	0f 5a c9	 cvtps2pd xmm1, xmm1
  000ac	f2 0f 58 c1	 addsd	 xmm0, xmm1
  000b0	51		 push	 ecx
  000b1	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  000b5	8b cb		 mov	 ecx, ebx
  000b7	f3 0f 11 45 f4	 movss	 DWORD PTR _vWorldPos$551032[ebp+4], xmm0
  000bc	ff 50 44	 call	 DWORD PTR [eax+68]
$LN5@InitDummyC:

; 466  : 	}
; 467  : }

  000bf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c2	33 cd		 xor	 ecx, ebp
  000c4	5b		 pop	 ebx
  000c5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ca	c9		 leave
  000cb	c2 18 00	 ret	 24			; 00000018H
?InitDummyCharInfo@ioDummyTurret2@@UAEXHKABUD3DXVECTOR3@@0M_N@Z ENDP ; ioDummyTurret2::InitDummyCharInfo
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with null pointer

  00000	8b c1		 mov	 eax, ecx
  00002	83 20 00	 and	 DWORD PTR [eax], 0

; 41   : 		}

  00005	c3		 ret	 0
??0?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBEABQAVioBaseChar@@XZ ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator*
; Function compile flags: /Ogsp
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBEABQAVioBaseChar@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBEABQAVioBaseChar@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator*, COMDAT
; _this$ = ecx

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);
; 83   : 
; 84   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 85   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBEABQAVioBaseChar@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator++
; Function compile flags: /Ogsp
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator++, COMDAT
; _this$ = ecx

; 93   : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

  00002	83 00 04	 add	 DWORD PTR [eax], 4

; 111  : 		return (*this);
; 112  : 		}

  00005	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator++
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@PAPAVioBaseChar@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@PAPAVioBaseChar@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@PAPAVioBaseChar@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@PAPAVioBaseChar@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Compat
; Function compile flags: /Ogsp
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Compat, COMDAT
; _this$ = ecx

; 253  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Compat
; Function compile flags: /Odsp
_TEXT	ENDS
;	COMDAT ??_EioDummyTurret2@@WBMI@AEPAXI@Z
_TEXT	SEGMENT
??_EioDummyTurret2@@WBMI@AEPAXI@Z PROC			; [thunk]:ioDummyTurret2::`vector deleting destructor', COMDAT
  00000	81 e9 c8 01 00
	00		 sub	 ecx, 456		; 000001c8H
  00006	e9 00 00 00 00	 jmp	 ??_EioDummyTurret2@@UAEPAXI@Z
??_EioDummyTurret2@@WBMI@AEPAXI@Z ENDP			; [thunk]:ioDummyTurret2::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx9math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR3@@QAE@XZ PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 165  :     D3DXVECTOR3() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx9math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 303  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 304  :     x = fx;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00008	8b c1		 mov	 eax, ecx
  0000a	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 305  :     y = fy;

  0000e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00013	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 306  :     z = fz;

  00018	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0001d	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 307  : }

  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
PUBLIC	??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z			; D3DXVECTOR3::operator+
; Function compile flags: /Ogsp
;	COMDAT ??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z PROC			; D3DXVECTOR3::operator+, COMDAT
; _this$ = ecx

; 380  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 381  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00006	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  0000a	f3 0f 10 09	 movss	 xmm1, DWORD PTR [ecx]
  0000e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00011	0f 5a c0	 cvtps2pd xmm0, xmm0
  00014	0f 5a c9	 cvtps2pd xmm1, xmm1
  00017	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0001b	f3 0f 10 49 04	 movss	 xmm1, DWORD PTR [ecx+4]
  00020	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00024	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00028	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [edx+4]
  0002d	0f 5a c0	 cvtps2pd xmm0, xmm0
  00030	0f 5a c9	 cvtps2pd xmm1, xmm1
  00033	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00037	f3 0f 10 49 08	 movss	 xmm1, DWORD PTR [ecx+8]
  0003c	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00040	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  00045	f3 0f 10 42 08	 movss	 xmm0, DWORD PTR [edx+8]
  0004a	0f 5a c0	 cvtps2pd xmm0, xmm0
  0004d	0f 5a c9	 cvtps2pd xmm1, xmm1
  00050	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00054	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00058	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 382  : }

  0005d	5d		 pop	 ebp
  0005e	c2 08 00	 ret	 8
??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator+
_TEXT	ENDS
PUBLIC	??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z			; D3DXVECTOR3::operator-
; Function compile flags: /Ogsp
;	COMDAT ??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z PROC			; D3DXVECTOR3::operator-, COMDAT
; _this$ = ecx

; 386  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 387  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00006	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0000a	f3 0f 10 0a	 movss	 xmm1, DWORD PTR [edx]
  0000e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00011	0f 5a c0	 cvtps2pd xmm0, xmm0
  00014	0f 5a c9	 cvtps2pd xmm1, xmm1
  00017	f2 0f 5c c1	 subsd	 xmm0, xmm1
  0001b	f3 0f 10 4a 04	 movss	 xmm1, DWORD PTR [edx+4]
  00020	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00024	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00028	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0002d	0f 5a c0	 cvtps2pd xmm0, xmm0
  00030	0f 5a c9	 cvtps2pd xmm1, xmm1
  00033	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00037	f3 0f 10 4a 08	 movss	 xmm1, DWORD PTR [edx+8]
  0003c	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00040	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  00045	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  0004a	0f 5a c0	 cvtps2pd xmm0, xmm0
  0004d	0f 5a c9	 cvtps2pd xmm1, xmm1
  00050	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00054	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00058	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 388  : }

  0005d	5d		 pop	 ebp
  0005e	c2 08 00	 ret	 8
??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator-
_TEXT	ENDS
PUBLIC	?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z		; D3DXVec3Length
; Function compile flags: /Ogsp
;	COMDAT ?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
tv169 = 8						; size = 4
tv160 = 8						; size = 4
_pV$ = 8						; size = 4
?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z PROC		; D3DXVec3Length, COMDAT

; 1710 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1711 : #ifdef D3DX_DEBUG
; 1712 :     if(!pV)
; 1713 :         return 0.0f;
; 1714 : #endif
; 1715 : 
; 1716 : #ifdef __cplusplus
; 1717 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pV$[ebp]
  00006	d9 40 04	 fld	 DWORD PTR [eax+4]
  00009	d9 00		 fld	 DWORD PTR [eax]
  0000b	d9 40 08	 fld	 DWORD PTR [eax+8]
  0000e	d9 c1		 fld	 ST(1)
  00010	de ca		 fmulp	 ST(2), ST(0)
  00012	d9 c2		 fld	 ST(2)
  00014	de cb		 fmulp	 ST(3), ST(0)
  00016	d9 c9		 fxch	 ST(1)
  00018	de c2		 faddp	 ST(2), ST(0)
  0001a	d9 c0		 fld	 ST(0)
  0001c	de c9		 fmulp	 ST(1), ST(0)
  0001e	de c1		 faddp	 ST(1), ST(0)
  00020	d9 5d 08	 fstp	 DWORD PTR tv169[ebp]
  00023	d9 45 08	 fld	 DWORD PTR tv169[ebp]
  00026	e8 00 00 00 00	 call	 __CIsqrt
  0002b	d9 5d 08	 fstp	 DWORD PTR tv160[ebp]
  0002e	d9 45 08	 fld	 DWORD PTR tv160[ebp]

; 1718 : #else
; 1719 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1720 : #endif
; 1721 : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z ENDP		; D3DXVec3Length
_TEXT	ENDS
PUBLIC	?_DECSTR@@YAXPADH@Z				; _DECSTR
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stringprotect.h
;	COMDAT ?_DECSTR@@YAXPADH@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_l$ = 12						; size = 4
?_DECSTR@@YAXPADH@Z PROC				; _DECSTR, COMDAT

; 40   : __forceinline void _DECSTR(char* s, int l){int i=0,l4=(l-1)/4,*p=(int*)s;s[l-1]=0;for(;i<l4;++i)*(p++)^=0xEAEBECED;for(i=l4*4;i<l-1;++i)s[i]^=0xED-i%4;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _l$[ebp]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  0000a	57		 push	 edi
  0000b	8d 79 ff	 lea	 edi, DWORD PTR [ecx-1]
  0000e	8b c7		 mov	 eax, edi
  00010	99		 cdq
  00011	83 e2 03	 and	 edx, 3
  00014	03 c2		 add	 eax, edx
  00016	c1 f8 02	 sar	 eax, 2
  00019	8b d6		 mov	 edx, esi
  0001b	c6 44 0e ff 00	 mov	 BYTE PTR [esi+ecx-1], 0
  00020	85 c0		 test	 eax, eax
  00022	7e 0e		 jle	 SHORT $LN4@DECSTR
  00024	8b c8		 mov	 ecx, eax
$LL6@DECSTR:
  00026	81 32 ed ec eb
	ea		 xor	 DWORD PTR [edx], -353637139 ; eaebecedH
  0002c	83 c2 04	 add	 edx, 4
  0002f	49		 dec	 ecx
  00030	75 f4		 jne	 SHORT $LL6@DECSTR
$LN4@DECSTR:
  00032	c1 e0 02	 shl	 eax, 2
  00035	eb 17		 jmp	 SHORT $LN14@DECSTR
$LL3@DECSTR:
  00037	8b c8		 mov	 ecx, eax
  00039	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0003f	79 05		 jns	 SHORT $LN13@DECSTR
  00041	49		 dec	 ecx
  00042	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00045	41		 inc	 ecx
$LN13@DECSTR:
  00046	b2 ed		 mov	 dl, -19			; ffffffedH
  00048	2a d1		 sub	 dl, cl
  0004a	30 14 30	 xor	 BYTE PTR [eax+esi], dl
  0004d	40		 inc	 eax
$LN14@DECSTR:
  0004e	3b c7		 cmp	 eax, edi
  00050	7c e5		 jl	 SHORT $LL3@DECSTR
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?_DECSTR@@YAXPADH@Z ENDP				; _DECSTR
_TEXT	ENDS
PUBLIC	??0FireTime@@QAE@XZ				; FireTime::FireTime
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\playentityhelpstruct.h
xdata$x	SEGMENT
__unwindtable$??0FireTime@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0FireTime@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0FireTime@@QAE@XZ$1
__ehfuncinfo$??0FireTime@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0FireTime@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??0FireTime@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0FireTime@@QAE@XZ PROC				; FireTime::FireTime, COMDAT
; _this$ = ecx

; 219  : 	FireTime()

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0FireTime@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_??0ioHashString@@QAE@XZ
  00017	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  0001a	ff d7		 call	 edi
  0001c	33 db		 xor	 ebx, ebx
  0001e	8d 4e 30	 lea	 ecx, DWORD PTR [esi+48]
  00021	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00024	ff d7		 call	 edi
  00026	8d 4e 44	 lea	 ecx, DWORD PTR [esi+68]
  00029	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0002d	ff d7		 call	 edi

; 220  : 	{
; 221  : 		dwStart = 0;

  0002f	89 1e		 mov	 DWORD PTR [esi], ebx

; 222  : 		dwDuration = 0;

  00031	89 5e 04	 mov	 DWORD PTR [esi+4], ebx

; 223  : 
; 224  : 		iAttributeIdx = 0;

  00034	89 5e 08	 mov	 DWORD PTR [esi+8], ebx

; 225  : 		iResistanceIdx = 0;

  00037	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx

; 226  : 
; 227  : 		bLoopWoundedAni = false;

  0003a	88 5e 10	 mov	 BYTE PTR [esi+16], bl

; 228  : 		dwWoundedAniDuration = 0;

  0003d	89 5e 24	 mov	 DWORD PTR [esi+36], ebx

; 229  : 
; 230  : 		dwWeaponIdx = 0;

  00040	89 5e 28	 mov	 DWORD PTR [esi+40], ebx

; 231  : 		eCollisionType = ACT_NONE;

  00043	c7 46 2c 06 00
	00 00		 mov	 DWORD PTR [esi+44], 6

; 232  : 		eFireTimeType = FTT_NORMAL_ATTACK;

  0004a	89 5e 40	 mov	 DWORD PTR [esi+64], ebx

; 233  : 
; 234  : 		m_iExtraValue = 0;

  0004d	89 5e 54	 mov	 DWORD PTR [esi+84], ebx

; 235  : 	}

  00050	8b c6		 mov	 eax, esi
  00052	e8 00 00 00 00	 call	 __EH_epilog3
  00057	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0FireTime@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 14	 add	 ecx, 20			; 00000014H
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??0FireTime@@QAE@XZ$1:
  0000c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 30	 add	 ecx, 48			; 00000030H
  00012	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$??0FireTime@@QAE@XZ:
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0FireTime@@QAE@XZ
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0FireTime@@QAE@XZ ENDP				; FireTime::FireTime
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iodummychar.h
;	COMDAT ?IsDummyCharMidSync@ioDummyChar@@UAE_NXZ
_TEXT	SEGMENT
?IsDummyCharMidSync@ioDummyChar@@UAE_NXZ PROC		; ioDummyChar::IsDummyCharMidSync, COMDAT
; _this$ = ecx

; 742  : 	virtual bool IsDummyCharMidSync(){ return false; }

  00000	32 c0		 xor	 al, al
  00002	c3		 ret	 0
?IsDummyCharMidSync@ioDummyChar@@UAE_NXZ ENDP		; ioDummyChar::IsDummyCharMidSync
_TEXT	ENDS
PUBLIC	?CheckWeaponBySkill@ioWeapon@@QBE_NXZ		; ioWeapon::CheckWeaponBySkill
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioweapon.h
;	COMDAT ?CheckWeaponBySkill@ioWeapon@@QBE_NXZ
_TEXT	SEGMENT
?CheckWeaponBySkill@ioWeapon@@QBE_NXZ PROC		; ioWeapon::CheckWeaponBySkill, COMDAT
; _this$ = ecx

; 484  : 	inline bool CheckWeaponBySkill() const { return m_bUseSkill; }

  00000	8a 81 7e 05 00
	00		 mov	 al, BYTE PTR [ecx+1406]
  00006	c3		 ret	 0
?CheckWeaponBySkill@ioWeapon@@QBE_NXZ ENDP		; ioWeapon::CheckWeaponBySkill
_TEXT	ENDS
PUBLIC	?CheckWeaponByStruct@ioWeapon@@QBE_NXZ		; ioWeapon::CheckWeaponByStruct
; Function compile flags: /Ogsp
;	COMDAT ?CheckWeaponByStruct@ioWeapon@@QBE_NXZ
_TEXT	SEGMENT
?CheckWeaponByStruct@ioWeapon@@QBE_NXZ PROC		; ioWeapon::CheckWeaponByStruct, COMDAT
; _this$ = ecx

; 488  : 	inline bool CheckWeaponByStruct() const { return m_bStructWeapon; }

  00000	8a 81 8c 05 00
	00		 mov	 al, BYTE PTR [ecx+1420]
  00006	c3		 ret	 0
?CheckWeaponByStruct@ioWeapon@@QBE_NXZ ENDP		; ioWeapon::CheckWeaponByStruct
_TEXT	ENDS
PUBLIC	?CheckWeaponByDummyChar@ioWeapon@@QBE_NXZ	; ioWeapon::CheckWeaponByDummyChar
; Function compile flags: /Ogsp
;	COMDAT ?CheckWeaponByDummyChar@ioWeapon@@QBE_NXZ
_TEXT	SEGMENT
?CheckWeaponByDummyChar@ioWeapon@@QBE_NXZ PROC		; ioWeapon::CheckWeaponByDummyChar, COMDAT
; _this$ = ecx

; 489  : 	inline bool CheckWeaponByDummyChar() const { return m_bDummyCharWeapon; }

  00000	8a 81 9c 05 00
	00		 mov	 al, BYTE PTR [ecx+1436]
  00006	c3		 ret	 0
?CheckWeaponByDummyChar@ioWeapon@@QBE_NXZ ENDP		; ioWeapon::CheckWeaponByDummyChar
_TEXT	ENDS
PUBLIC	?GetOwnerName@ioWeapon@@QBEABVioHashString@@XZ	; ioWeapon::GetOwnerName
; Function compile flags: /Ogsp
;	COMDAT ?GetOwnerName@ioWeapon@@QBEABVioHashString@@XZ
_TEXT	SEGMENT
?GetOwnerName@ioWeapon@@QBEABVioHashString@@XZ PROC	; ioWeapon::GetOwnerName, COMDAT
; _this$ = ecx

; 636  : 	inline const ioHashString& GetOwnerName() const { return m_OwnerName; }

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
  00003	c3		 ret	 0
?GetOwnerName@ioWeapon@@QBEABVioHashString@@XZ ENDP	; ioWeapon::GetOwnerName
_TEXT	ENDS
PUBLIC	?GetWeaponByDummyChar@ioWeapon@@QAE?BHXZ	; ioWeapon::GetWeaponByDummyChar
; Function compile flags: /Ogsp
;	COMDAT ?GetWeaponByDummyChar@ioWeapon@@QAE?BHXZ
_TEXT	SEGMENT
?GetWeaponByDummyChar@ioWeapon@@QAE?BHXZ PROC		; ioWeapon::GetWeaponByDummyChar, COMDAT
; _this$ = ecx

; 638  : 	inline const int GetWeaponByDummyChar() { return m_iDummyIndex; }

  00000	8b 81 98 05 00
	00		 mov	 eax, DWORD PTR [ecx+1432]
  00006	c3		 ret	 0
?GetWeaponByDummyChar@ioWeapon@@QAE?BHXZ ENDP		; ioWeapon::GetWeaponByDummyChar
_TEXT	ENDS
PUBLIC	?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z	; CEncrypt<float>::EncryptValueToPool
EXTRN	?EncryptByte@ccddaabb@@QAEXPBDPADH@Z:PROC	; ccddaabb::EncryptByte
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
;	COMDAT ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z PROC	; CEncrypt<float>::EncryptValueToPool, COMDAT
; _this$ = ecx

; 67   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 		m_RC5.EncryptByte( value, m_MemPool, max(m_ValueSize, DEFAULT_ENCRYPT) );

  00003	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00007	83 f8 04	 cmp	 eax, 4
  0000a	77 03		 ja	 SHORT $LN4@EncryptVal
  0000c	6a 04		 push	 4
  0000e	58		 pop	 eax
$LN4@EncryptVal:
  0000f	50		 push	 eax
  00010	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  00013	50		 push	 eax
  00014	ff 75 08	 push	 DWORD PTR _value$[ebp]
  00017	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0001a	e8 00 00 00 00	 call	 ?EncryptByte@ccddaabb@@QAEXPBDPADH@Z ; ccddaabb::EncryptByte

; 69   : 		
; 70   : 	}

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ENDP	; CEncrypt<float>::EncryptValueToPool
_TEXT	ENDS
PUBLIC	?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z	; CEncrypt<float>::DecryptValueToPool
EXTRN	?DecryptByte@ccddaabb@@QBEXPBDPADH@Z:PROC	; ccddaabb::DecryptByte
; Function compile flags: /Ogsp
;	COMDAT ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z PROC	; CEncrypt<float>::DecryptValueToPool, COMDAT
; _this$ = ecx

; 1648 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1649 : 		m_RC5.DecryptByte( m_MemPool, m_TempMem, 4 );

  00004	8d 71 28	 lea	 esi, DWORD PTR [ecx+40]
  00007	6a 04		 push	 4
  00009	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00011	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte

; 1650 : 		*value = *((float*)m_TempMem);

  00016	d9 06		 fld	 DWORD PTR [esi]
  00018	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  0001b	d9 18		 fstp	 DWORD PTR [eax]
  0001d	5e		 pop	 esi

; 1651 : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ENDP	; CEncrypt<float>::DecryptValueToPool
_TEXT	ENDS
PUBLIC	?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z	; CEncrypt<bool>::DecryptValueToPool
; Function compile flags: /Ogsp
;	COMDAT ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z PROC	; CEncrypt<bool>::DecryptValueToPool, COMDAT
; _this$ = ecx

; 219  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 220  : 		m_RC5.DecryptByte( m_MemPool, m_TempMem, 4 );

  00004	8d 71 28	 lea	 esi, DWORD PTR [ecx+40]
  00007	6a 04		 push	 4
  00009	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00011	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte

; 221  : 		*value = *((bool*)m_TempMem);

  00016	8a 06		 mov	 al, BYTE PTR [esi]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0001b	88 01		 mov	 BYTE PTR [ecx], al
  0001d	5e		 pop	 esi

; 222  : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ENDP	; CEncrypt<bool>::DecryptValueToPool
_TEXT	ENDS
PUBLIC	?EncryptValueToPool@?$CEncrypt@W4TeamType@@@@AAEXPBD@Z ; CEncrypt<enum TeamType>::EncryptValueToPool
; Function compile flags: /Ogsp
;	COMDAT ?EncryptValueToPool@?$CEncrypt@W4TeamType@@@@AAEXPBD@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?EncryptValueToPool@?$CEncrypt@W4TeamType@@@@AAEXPBD@Z PROC ; CEncrypt<enum TeamType>::EncryptValueToPool, COMDAT
; _this$ = ecx

; 67   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 		m_RC5.EncryptByte( value, m_MemPool, max(m_ValueSize, DEFAULT_ENCRYPT) );

  00003	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00007	83 f8 04	 cmp	 eax, 4
  0000a	77 03		 ja	 SHORT $LN4@EncryptVal@2
  0000c	6a 04		 push	 4
  0000e	58		 pop	 eax
$LN4@EncryptVal@2:
  0000f	50		 push	 eax
  00010	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  00013	50		 push	 eax
  00014	ff 75 08	 push	 DWORD PTR _value$[ebp]
  00017	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0001a	e8 00 00 00 00	 call	 ?EncryptByte@ccddaabb@@QAEXPBDPADH@Z ; ccddaabb::EncryptByte

; 69   : 		
; 70   : 	}

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?EncryptValueToPool@?$CEncrypt@W4TeamType@@@@AAEXPBD@Z ENDP ; CEncrypt<enum TeamType>::EncryptValueToPool
_TEXT	ENDS
PUBLIC	?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
; Function compile flags: /Ogsp
;	COMDAT ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z PROC ; CEncrypt<enum TeamType>::DecryptValueToPool, COMDAT
; _this$ = ecx

; 2959 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2960 : 		m_RC5.DecryptByte( m_MemPool, m_TempMem, sizeof(TeamType) );

  00004	8d 71 28	 lea	 esi, DWORD PTR [ecx+40]
  00007	6a 04		 push	 4
  00009	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00011	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte

; 2961 : 		*value = *((TeamType*)m_TempMem);

  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0001b	89 01		 mov	 DWORD PTR [ecx], eax
  0001d	5e		 pop	 esi

; 2962 : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ENDP ; CEncrypt<enum TeamType>::DecryptValueToPool
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogsp
;	COMDAT ??_GioDummyTurret2@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GioDummyTurret2@@UAEPAXI@Z PROC			; ioDummyTurret2::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1ioDummyTurret2@@UAE@XZ ; ioDummyTurret2::~ioDummyTurret2
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 07		 je	 SHORT $LN1@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	59		 pop	 ecx
$LN1@scalar:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??_GioDummyTurret2@@UAEPAXI@Z ENDP			; ioDummyTurret2::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	_pTarget$GSCopy$
PUBLIC	_vDir$GSCopy$
PUBLIC	_vPos$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CreateWeapon@ioDummyTurret2@@IAEXABUD3DXVECTOR3@@0PAVioBaseChar@@@Z ; ioDummyTurret2::CreateWeapon
EXTRN	??1SP2Packet@@UAE@XZ:PROC			; SP2Packet::~SP2Packet
EXTRN	?SendToAllPlayingUser@P2PNetwork@@YAXAAVSP2Packet@@PAVioBaseChar@@@Z:PROC ; P2PNetwork::SendToAllPlayingUser
EXTRN	??6SP2Packet@@QAEAAV0@ABUD3DXVECTOR3@@@Z:PROC	; SP2Packet::operator<<
EXTRN	??6SP2Packet@@QAEAAV0@H@Z:PROC			; SP2Packet::operator<<
EXTRN	??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z:PROC	; SP2Packet::operator<<
EXTRN	??0SP2Packet@@QAE@K@Z:PROC			; SP2Packet::SP2Packet
EXTRN	?SetTraceTarget@ioTraceWeapon@@QAEXAAVioHashString@@@Z:PROC ; ioTraceWeapon::SetTraceTarget
EXTRN	__imp_??0ioHashString@@QAE@ABV0@@Z:PROC
EXTRN	?SetPosition@ioWeapon@@QAEXABUD3DXVECTOR3@@@Z:PROC ; ioWeapon::SetPosition
EXTRN	?ExtendFireExplicit@ioBaseChar@@QAEPAVioWeapon@@ABUFireTime@@ABUD3DXVECTOR3@@1ABVioHashString@@@Z:PROC ; ioBaseChar::ExtendFireExplicit
EXTRN	__imp_??0ioHashString@@QAE@PBD@Z:PROC
EXTRN	?SetWeaponIndexBase@ioBaseChar@@QAEXK@Z:PROC	; ioBaseChar::SetWeaponIndexBase
EXTRN	__imp_??4ioHashString@@QAEAAV0@PBD@Z:PROC
EXTRN	?GetWeaponIndexBase@ioBaseChar@@QBEKXZ:PROC	; ioBaseChar::GetWeaponIndexBase
EXTRN	__chkstk:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasechar.h
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CreateWeapon@ioDummyTurret2@@IAEXABUD3DXVECTOR3@@0PAVioBaseChar@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateWeapon@ioDummyTurret2@@IAEXABUD3DXVECTOR3@@0PAVioBaseChar@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?CreateWeapon@ioDummyTurret2@@IAEXABUD3DXVECTOR3@@0PAVioBaseChar@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?CreateWeapon@ioDummyTurret2@@IAEXABUD3DXVECTOR3@@0PAVioBaseChar@@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?CreateWeapon@ioDummyTurret2@@IAEXABUD3DXVECTOR3@@0PAVioBaseChar@@@Z$3
__ehfuncinfo$?CreateWeapon@ioDummyTurret2@@IAEXABUD3DXVECTOR3@@0PAVioBaseChar@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?CreateWeapon@ioDummyTurret2@@IAEXABUD3DXVECTOR3@@0PAVioBaseChar@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iodummyturret2.cpp
xdata$x	ENDS
;	COMDAT ?CreateWeapon@ioDummyTurret2@@IAEXABUD3DXVECTOR3@@0PAVioBaseChar@@@Z
_TEXT	SEGMENT
_kFireTime$ = -32932					; size = 88
$T552006 = -32844					; size = 16
$T552005 = -32844					; size = 16
_vDir$GSCopy$ = -32828					; size = 4
_pTarget$GSCopy$ = -32824				; size = 4
_pOwner$ = -32820					; size = 4
_vPos$GSCopy$ = -32816					; size = 4
_pTaraceWeapon$550877 = -32812				; size = 4
_pWeapon$ = -32812					; size = 4
_kPacket$550882 = -32808				; size = 32792
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_vPos$ = 8						; size = 4
_vDir$ = 12						; size = 4
_pTarget$ = 16						; size = 4
?CreateWeapon@ioDummyTurret2@@IAEXABUD3DXVECTOR3@@0PAVioBaseChar@@@Z PROC ; ioDummyTurret2::CreateWeapon, COMDAT
; _this$ = ecx

; 315  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CreateWeapon@ioDummyTurret2@@IAEXABUD3DXVECTOR3@@0PAVioBaseChar@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 98 80 00 00	 mov	 eax, 32920		; 00008098H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00032	8b 45 08	 mov	 eax, DWORD PTR _vPos$[ebp]
  00035	8b 7d 10	 mov	 edi, DWORD PTR _pTarget$[ebp]

; 316  : 	ioBaseChar *pOwner = GetOwner();

  00038	89 85 d0 7f ff
	ff		 mov	 DWORD PTR _vPos$GSCopy$[ebp], eax
  0003e	8b 45 0c	 mov	 eax, DWORD PTR _vDir$[ebp]
  00041	8b f1		 mov	 esi, ecx
  00043	89 85 c4 7f ff
	ff		 mov	 DWORD PTR _vDir$GSCopy$[ebp], eax
  00049	89 bd c8 7f ff
	ff		 mov	 DWORD PTR _pTarget$GSCopy$[ebp], edi
  0004f	e8 00 00 00 00	 call	 ?GetOwner@ioDummyChar@@QBEPAVioBaseChar@@XZ ; ioDummyChar::GetOwner
  00054	8b c8		 mov	 ecx, eax

; 317  : 
; 318  : 	if ( !pOwner )

  00056	33 db		 xor	 ebx, ebx
  00058	89 8d cc 7f ff
	ff		 mov	 DWORD PTR _pOwner$[ebp], ecx
  0005e	3b cb		 cmp	 ecx, ebx
  00060	0f 84 1c 02 00
	00		 je	 $LN6@CreateWeap

; 319  : 		return;
; 320  : 
; 321  : 	if( !pTarget )

  00066	3b fb		 cmp	 edi, ebx
  00068	0f 84 14 02 00
	00		 je	 $LN6@CreateWeap

; 322  : 		return;
; 323  : 
; 324  : 	//m_FiredTargetList.push_back( pTarget->GetCharName() );
; 325  : 
; 326  : 	m_dwBaseWeaponIndex = pOwner->GetWeaponIndexBase() + 1;

  0006e	e8 00 00 00 00	 call	 ?GetWeaponIndexBase@ioBaseChar@@QBEKXZ ; ioBaseChar::GetWeaponIndexBase
  00073	40		 inc	 eax

; 327  : 
; 328  : 	FireTime kFireTime;

  00074	8d 8d 5c 7f ff
	ff		 lea	 ecx, DWORD PTR _kFireTime$[ebp]
  0007a	89 86 30 06 00
	00		 mov	 DWORD PTR [esi+1584], eax
  00080	e8 00 00 00 00	 call	 ??0FireTime@@QAE@XZ	; FireTime::FireTime
  00085	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx

; 329  : 	kFireTime.dwStart = FRAMEGETTIME();

  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  0008e	8b c8		 mov	 ecx, eax
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ
  00096	89 85 5c 7f ff
	ff		 mov	 DWORD PTR _kFireTime$[ebp], eax

; 330  : 
; 331  : 	kFireTime.iAttributeIdx = m_nCreateWeaponIndex;

  0009c	8b 86 90 14 00
	00		 mov	 eax, DWORD PTR [esi+5264]

; 332  : 	kFireTime.iResistanceIdx = 0;
; 333  : 	kFireTime.szWoundedAni  = "";

  000a2	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
  000a7	57		 push	 edi
  000a8	8d 8d 70 7f ff
	ff		 lea	 ecx, DWORD PTR _kFireTime$[ebp+20]
  000ae	89 85 64 7f ff
	ff		 mov	 DWORD PTR _kFireTime$[ebp+8], eax
  000b4	89 9d 68 7f ff
	ff		 mov	 DWORD PTR _kFireTime$[ebp+12], ebx
  000ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 334  : 	kFireTime.dwWoundedAniDuration = 0;
; 335  : 	kFireTime.bLoopWoundedAni = false;
; 336  : 	kFireTime.dwWeaponIdx = m_dwBaseWeaponIndex;

  000c0	8b 86 30 06 00
	00		 mov	 eax, DWORD PTR [esi+1584]

; 337  : 	kFireTime.eFireTimeType = FTT_DUMMY_CHAR_ATTACK;
; 338  : 
; 339  : 	pOwner->SetWeaponIndexBase( m_dwBaseWeaponIndex );

  000c6	8b 8d cc 7f ff
	ff		 mov	 ecx, DWORD PTR _pOwner$[ebp]
  000cc	50		 push	 eax
  000cd	89 9d 80 7f ff
	ff		 mov	 DWORD PTR _kFireTime$[ebp+36], ebx
  000d3	88 9d 6c 7f ff
	ff		 mov	 BYTE PTR _kFireTime$[ebp+16], bl
  000d9	89 85 84 7f ff
	ff		 mov	 DWORD PTR _kFireTime$[ebp+40], eax
  000df	c7 85 9c 7f ff
	ff 0b 00 00 00	 mov	 DWORD PTR _kFireTime$[ebp+64], 11 ; 0000000bH
  000e9	e8 00 00 00 00	 call	 ?SetWeaponIndexBase@ioBaseChar@@QAEXK@Z ; ioBaseChar::SetWeaponIndexBase

; 340  : 
; 341  : 	ioWeapon *pWeapon = pOwner->ExtendFireExplicit( kFireTime, vPos, vDir, "" );

  000ee	57		 push	 edi
  000ef	8d 8d b4 7f ff
	ff		 lea	 ecx, DWORD PTR $T552005[ebp]
  000f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  000fb	8b 8d cc 7f ff
	ff		 mov	 ecx, DWORD PTR _pOwner$[ebp]
  00101	8d 85 b4 7f ff
	ff		 lea	 eax, DWORD PTR $T552005[ebp]
  00107	50		 push	 eax
  00108	ff b5 c4 7f ff
	ff		 push	 DWORD PTR _vDir$GSCopy$[ebp]
  0010e	8d 85 5c 7f ff
	ff		 lea	 eax, DWORD PTR _kFireTime$[ebp]
  00114	ff b5 d0 7f ff
	ff		 push	 DWORD PTR _vPos$GSCopy$[ebp]
  0011a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 ?ExtendFireExplicit@ioBaseChar@@QAEPAVioWeapon@@ABUFireTime@@ABUD3DXVECTOR3@@1ABVioHashString@@@Z ; ioBaseChar::ExtendFireExplicit
  00124	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_??1ioHashString@@QAE@XZ
  0012a	8d 8d b4 7f ff
	ff		 lea	 ecx, DWORD PTR $T552005[ebp]
  00130	89 85 d4 7f ff
	ff		 mov	 DWORD PTR _pWeapon$[ebp], eax
  00136	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  00139	ff d7		 call	 edi

; 342  : 	if ( pWeapon )

  0013b	8b 8d d4 7f ff
	ff		 mov	 ecx, DWORD PTR _pWeapon$[ebp]
  00141	3b cb		 cmp	 ecx, ebx
  00143	74 54		 je	 SHORT $LN2@CreateWeap

; 343  : 	{
; 344  : 		pWeapon->SetPosition( vPos );

  00145	ff b5 d0 7f ff
	ff		 push	 DWORD PTR _vPos$GSCopy$[ebp]
  0014b	e8 00 00 00 00	 call	 ?SetPosition@ioWeapon@@QAEXABUD3DXVECTOR3@@@Z ; ioWeapon::SetPosition

; 345  : 		ioTraceWeapon *pTaraceWeapon = ToTraceWeapon( pWeapon );

  00150	ff b5 d4 7f ff
	ff		 push	 DWORD PTR _pWeapon$[ebp]
  00156	e8 00 00 00 00	 call	 ?ToTraceWeapon@@YAPAVioTraceWeapon@@PAVioWeapon@@@Z ; ToTraceWeapon
  0015b	59		 pop	 ecx
  0015c	89 85 d4 7f ff
	ff		 mov	 DWORD PTR _pTaraceWeapon$550877[ebp], eax

; 346  : 		if( pTaraceWeapon )

  00162	3b c3		 cmp	 eax, ebx
  00164	74 33		 je	 SHORT $LN2@CreateWeap

; 347  : 			pTaraceWeapon->SetTraceTarget( (ioHashString)pTarget->GetCharName() );

  00166	8b 85 c8 7f ff
	ff		 mov	 eax, DWORD PTR _pTarget$GSCopy$[ebp]
  0016c	05 d4 02 00 00	 add	 eax, 724		; 000002d4H
  00171	50		 push	 eax
  00172	8d 8d b4 7f ff
	ff		 lea	 ecx, DWORD PTR $T552006[ebp]
  00178	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  0017e	8b 8d d4 7f ff
	ff		 mov	 ecx, DWORD PTR _pTaraceWeapon$550877[ebp]
  00184	50		 push	 eax
  00185	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00189	e8 00 00 00 00	 call	 ?SetTraceTarget@ioTraceWeapon@@QAEXAAVioHashString@@@Z ; ioTraceWeapon::SetTraceTarget
  0018e	8d 8d b4 7f ff
	ff		 lea	 ecx, DWORD PTR $T552006[ebp]
  00194	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  00197	ff d7		 call	 edi
$LN2@CreateWeap:

; 348  : 	}	
; 349  : 
; 350  : 	m_dwNextFireTime = FRAMEGETTIME() + m_dwFireTicTime;

  00199	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  0019f	8b c8		 mov	 ecx, eax
  001a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ
  001a7	03 86 b0 14 00
	00		 add	 eax, DWORD PTR [esi+5296]

; 351  : 	m_TurretState = DMS_FIRE;
; 352  : 
; 353  : 	m_nCurBullet++;
; 354  : 
; 355  : 	//SendPacket
; 356  : 	if ( pOwner->IsNeedProcess() )

  001ad	8b 8d cc 7f ff
	ff		 mov	 ecx, DWORD PTR _pOwner$[ebp]
  001b3	ff 86 a8 14 00
	00		 inc	 DWORD PTR [esi+5288]
  001b9	89 86 b4 14 00
	00		 mov	 DWORD PTR [esi+5300], eax
  001bf	c7 86 80 14 00
	00 02 00 00 00	 mov	 DWORD PTR [esi+5248], 2
  001c9	8b 01		 mov	 eax, DWORD PTR [ecx]
  001cb	ff 90 00 01 00
	00		 call	 DWORD PTR [eax+256]
  001d1	84 c0		 test	 al, al
  001d3	0f 84 9a 00 00
	00		 je	 $LN1@CreateWeap

; 357  : 	{
; 358  : 		SP2Packet kPacket( CUPK_DUMMY_CHAR_SYNC );

  001d9	68 21 42 00 00	 push	 16929			; 00004221H
  001de	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$550882[ebp]
  001e4	e8 00 00 00 00	 call	 ??0SP2Packet@@QAE@K@Z	; SP2Packet::SP2Packet

; 359  : 		kPacket << m_OwnerName;

  001e9	8d 86 cc 01 00
	00		 lea	 eax, DWORD PTR [esi+460]
  001ef	50		 push	 eax
  001f0	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$550882[ebp]
  001f6	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  001fa	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z ; SP2Packet::operator<<

; 360  : 		kPacket << m_iCreateIndex;

  001ff	ff b6 dc 01 00
	00		 push	 DWORD PTR [esi+476]
  00205	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$550882[ebp]
  0020b	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@H@Z ; SP2Packet::operator<<

; 361  : 		kPacket << DUMMY_CHAR_NORMAL_ATT;

  00210	6a 06		 push	 6
  00212	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$550882[ebp]
  00218	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@H@Z ; SP2Packet::operator<<

; 362  : 		kPacket << pTarget->GetCharName();

  0021d	8b 85 c8 7f ff
	ff		 mov	 eax, DWORD PTR _pTarget$GSCopy$[ebp]
  00223	05 d4 02 00 00	 add	 eax, 724		; 000002d4H
  00228	50		 push	 eax
  00229	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$550882[ebp]
  0022f	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z ; SP2Packet::operator<<

; 363  : 		kPacket << vPos;

  00234	ff b5 d0 7f ff
	ff		 push	 DWORD PTR _vPos$GSCopy$[ebp]
  0023a	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$550882[ebp]
  00240	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABUD3DXVECTOR3@@@Z ; SP2Packet::operator<<

; 364  : 		kPacket << vDir;

  00245	ff b5 c4 7f ff
	ff		 push	 DWORD PTR _vDir$GSCopy$[ebp]
  0024b	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$550882[ebp]
  00251	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABUD3DXVECTOR3@@@Z ; SP2Packet::operator<<

; 365  : 		P2PNetwork::SendToAllPlayingUser( kPacket );

  00256	8d 85 d8 7f ff
	ff		 lea	 eax, DWORD PTR _kPacket$550882[ebp]
  0025c	53		 push	 ebx
  0025d	50		 push	 eax
  0025e	e8 00 00 00 00	 call	 ?SendToAllPlayingUser@P2PNetwork@@YAXAAVSP2Packet@@PAVioBaseChar@@@Z ; P2PNetwork::SendToAllPlayingUser
  00263	59		 pop	 ecx
  00264	59		 pop	 ecx

; 366  : 	}

  00265	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$550882[ebp]
  0026b	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  0026e	e8 00 00 00 00	 call	 ??1SP2Packet@@UAE@XZ	; SP2Packet::~SP2Packet
$LN1@CreateWeap:

; 367  : }

  00273	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00277	8d 8d 5c 7f ff
	ff		 lea	 ecx, DWORD PTR _kFireTime$[ebp]
  0027d	e8 00 00 00 00	 call	 ??1FireTime@@QAE@XZ
$LN6@CreateWeap:
  00282	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00285	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0028c	59		 pop	 ecx
  0028d	5f		 pop	 edi
  0028e	5e		 pop	 esi
  0028f	5b		 pop	 ebx
  00290	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00293	33 cd		 xor	 ecx, ebp
  00295	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0029a	c9		 leave
  0029b	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateWeapon@ioDummyTurret2@@IAEXABUD3DXVECTOR3@@0PAVioBaseChar@@@Z$0:
  00000	8d 8d 5c 7f ff
	ff		 lea	 ecx, DWORD PTR _kFireTime$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1FireTime@@QAE@XZ
__unwindfunclet$?CreateWeapon@ioDummyTurret2@@IAEXABUD3DXVECTOR3@@0PAVioBaseChar@@@Z$1:
  0000b	8d 8d b4 7f ff
	ff		 lea	 ecx, DWORD PTR $T552005[ebp]
  00011	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?CreateWeapon@ioDummyTurret2@@IAEXABUD3DXVECTOR3@@0PAVioBaseChar@@@Z$2:
  00017	8d 8d b4 7f ff
	ff		 lea	 ecx, DWORD PTR $T552006[ebp]
  0001d	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?CreateWeapon@ioDummyTurret2@@IAEXABUD3DXVECTOR3@@0PAVioBaseChar@@@Z$3:
  00023	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$550882[ebp]
  00029	e9 00 00 00 00	 jmp	 ??1SP2Packet@@UAE@XZ	; SP2Packet::~SP2Packet
__ehhandler$?CreateWeapon@ioDummyTurret2@@IAEXABUD3DXVECTOR3@@0PAVioBaseChar@@@Z:
  0002e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00032	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00035	8b 8a 58 7f ff
	ff		 mov	 ecx, DWORD PTR [edx-32936]
  0003b	33 c8		 xor	 ecx, eax
  0003d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00042	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00045	33 c8		 xor	 ecx, eax
  00047	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CreateWeapon@ioDummyTurret2@@IAEXABUD3DXVECTOR3@@0PAVioBaseChar@@@Z
  00051	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CreateWeapon@ioDummyTurret2@@IAEXABUD3DXVECTOR3@@0PAVioBaseChar@@@Z ENDP ; ioDummyTurret2::CreateWeapon
PUBLIC	??N?$CEncrypt@M@@QAE_NABM@Z			; CEncrypt<float>::operator<=
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
;	COMDAT ??N?$CEncrypt@M@@QAE_NABM@Z
_TEXT	SEGMENT
_value$ = -4						; size = 4
_inValue$ = 8						; size = 4
??N?$CEncrypt@M@@QAE_NABM@Z PROC			; CEncrypt<float>::operator<=, COMDAT
; _this$ = ecx

; 1821 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1822 : 		type value;
; 1823 : 		DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool

; 1824 : #ifdef _NOTUSE
; 1825 : 		Debug();
; 1826 : #endif
; 1827 : 		return (value <= inValue);

  0000d	8b 45 08	 mov	 eax, DWORD PTR _inValue$[ebp]
  00010	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  00014	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _value$[ebp]
  00019	0f 5a c0	 cvtps2pd xmm0, xmm0
  0001c	0f 5a c9	 cvtps2pd xmm1, xmm1
  0001f	33 c0		 xor	 eax, eax
  00021	66 0f 2f c8	 comisd	 xmm1, xmm0
  00025	72 01		 jb	 SHORT $LN4@operator
  00027	40		 inc	 eax
$LN4@operator:

; 1828 : 	}

  00028	c9		 leave
  00029	c2 04 00	 ret	 4
??N?$CEncrypt@M@@QAE_NABM@Z ENDP			; CEncrypt<float>::operator<=
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@XZ ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::begin
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@XZ PROC ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::begin, COMDAT
; _this$ = ecx

; 786  : 		{	// return iterator for beginning of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 787  : 		return (const_iterator(this->_Myfirst, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 788  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@XZ ENDP ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@XZ ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::end
; Function compile flags: /Ogsp
;	COMDAT ?end@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@XZ PROC ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::end, COMDAT
; _this$ = ecx

; 796  : 		{	// return iterator for end of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 797  : 		return (const_iterator(this->_Mylast, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 798  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@XZ ENDP ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::end
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator==
; Function compile flags: /Ogsp
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	f7 d8		 neg	 eax
  0000c	1b c0		 sbb	 eax, eax
  0000e	40		 inc	 eax

; 204  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator==
_TEXT	ENDS
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadString_e@$0BA@@ioINILoader@@QAEXAAY0BA@$$CBDAAY00$$CBDPADH@Z ; ioINILoader::LoadString_e<16>
EXTRN	__imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z:PROC
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\io3dengine\ioiniloader.h
;	COMDAT ??$LoadString_e@$0BA@@ioINILoader@@QAEXAAY0BA@$$CBDAAY00$$CBDPADH@Z
_TEXT	SEGMENT
_this$GSCopy$ = -28					; size = 4
__k$ = -24						; size = 16
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_d$ = 12						; size = 4
_b$ = 16						; size = 4
_i$ = 20						; size = 4
??$LoadString_e@$0BA@@ioINILoader@@QAEXAAY0BA@$$CBDAAY00$$CBDPADH@Z PROC ; ioINILoader::LoadString_e<16>, COMDAT
; _this$ = ecx

; 161  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 162  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b 75 0c	 mov	 esi, DWORD PTR _d$[ebp]
  00019	57		 push	 edi
  0001a	8b 7d 10	 mov	 edi, DWORD PTR _b$[ebp]
  0001d	89 4d e4	 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  00020	84 d2		 test	 dl, dl
  00022	0f 84 8c 01 00
	00		 je	 $LN96@LoadString
  00028	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0002b	88 55 e8	 mov	 BYTE PTR __k$[ebp], dl
  0002e	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00031	84 d2		 test	 dl, dl
  00033	0f 84 75 01 00
	00		 je	 $LN95@LoadString
  00039	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0003c	88 55 e9	 mov	 BYTE PTR __k$[ebp+1], dl
  0003f	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  00042	84 d2		 test	 dl, dl
  00044	0f 84 5e 01 00
	00		 je	 $LN94@LoadString
  0004a	b1 eb		 mov	 cl, -21			; ffffffebH
  0004c	32 d1		 xor	 dl, cl
  0004e	88 55 ea	 mov	 BYTE PTR __k$[ebp+2], dl
  00051	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  00054	84 d2		 test	 dl, dl
  00056	0f 84 46 01 00
	00		 je	 $LN93@LoadString
  0005c	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0005f	88 55 eb	 mov	 BYTE PTR __k$[ebp+3], dl
  00062	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  00065	84 d2		 test	 dl, dl
  00067	0f 84 2f 01 00
	00		 je	 $LN92@LoadString
  0006d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00070	88 55 ec	 mov	 BYTE PTR __k$[ebp+4], dl
  00073	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00076	84 d2		 test	 dl, dl
  00078	0f 84 18 01 00
	00		 je	 $LN91@LoadString
  0007e	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00081	88 55 ed	 mov	 BYTE PTR __k$[ebp+5], dl
  00084	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00087	84 d2		 test	 dl, dl
  00089	0f 84 02 01 00
	00		 je	 $LN90@LoadString
  0008f	32 d1		 xor	 dl, cl
  00091	88 55 ee	 mov	 BYTE PTR __k$[ebp+6], dl
  00094	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00097	84 d2		 test	 dl, dl
  00099	0f 84 ec 00 00
	00		 je	 $LN89@LoadString
  0009f	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000a2	88 55 ef	 mov	 BYTE PTR __k$[ebp+7], dl
  000a5	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a8	84 d2		 test	 dl, dl
  000aa	0f 84 d5 00 00
	00		 je	 $LN88@LoadString
  000b0	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000b3	88 55 f0	 mov	 BYTE PTR __k$[ebp+8], dl
  000b6	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b9	84 d2		 test	 dl, dl
  000bb	0f 84 be 00 00
	00		 je	 $LN87@LoadString
  000c1	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000c4	88 55 f1	 mov	 BYTE PTR __k$[ebp+9], dl
  000c7	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000ca	84 d2		 test	 dl, dl
  000cc	0f 84 a8 00 00
	00		 je	 $LN86@LoadString
  000d2	32 d1		 xor	 dl, cl
  000d4	88 55 f2	 mov	 BYTE PTR __k$[ebp+10], dl
  000d7	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000da	84 d2		 test	 dl, dl
  000dc	0f 84 92 00 00
	00		 je	 $LN85@LoadString
  000e2	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000e5	88 55 f3	 mov	 BYTE PTR __k$[ebp+11], dl
  000e8	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000eb	84 d2		 test	 dl, dl
  000ed	74 7f		 je	 SHORT $LN84@LoadString
  000ef	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000f2	88 55 f4	 mov	 BYTE PTR __k$[ebp+12], dl
  000f5	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000f8	84 d2		 test	 dl, dl
  000fa	74 6c		 je	 SHORT $LN83@LoadString
  000fc	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000ff	88 55 f5	 mov	 BYTE PTR __k$[ebp+13], dl
  00102	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  00105	84 d2		 test	 dl, dl
  00107	74 5a		 je	 SHORT $LN82@LoadString
  00109	32 d1		 xor	 dl, cl
  0010b	80 78 0f 00	 cmp	 BYTE PTR [eax+15], 0
  0010f	88 55 f6	 mov	 BYTE PTR __k$[ebp+14], dl
  00112	0f 84 a0 00 00
	00		 je	 $LN111@LoadString
  00118	8a 50 10	 mov	 dl, BYTE PTR [eax+16]
  0011b	84 d2		 test	 dl, dl
  0011d	74 3e		 je	 SHORT $LN80@LoadString
  0011f	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00122	88 55 f8	 mov	 BYTE PTR __k$[ebp+16], dl
  00125	8a 50 11	 mov	 dl, BYTE PTR [eax+17]
  00128	84 d2		 test	 dl, dl
  0012a	74 2b		 je	 SHORT $LN79@LoadString
  0012c	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0012f	88 55 f9	 mov	 BYTE PTR __k$[ebp+17], dl
  00132	8a 50 12	 mov	 dl, BYTE PTR [eax+18]
  00135	84 d2		 test	 dl, dl
  00137	74 19		 je	 SHORT $LN78@LoadString
  00139	8a 40 13	 mov	 al, BYTE PTR [eax+19]
  0013c	32 d1		 xor	 dl, cl
  0013e	88 55 fa	 mov	 BYTE PTR __k$[ebp+18], dl
  00141	84 c0		 test	 al, al
  00143	74 07		 je	 SHORT $LN77@LoadString
  00145	34 ea		 xor	 al, -22			; ffffffeaH
  00147	88 45 fb	 mov	 BYTE PTR __k$[ebp+19], al
  0014a	eb 6c		 jmp	 SHORT $LN111@LoadString
$LN77@LoadString:
  0014c	c6 45 fb ea	 mov	 BYTE PTR __k$[ebp+19], -22 ; ffffffeaH
  00150	eb 66		 jmp	 SHORT $LN111@LoadString
$LN78@LoadString:
  00152	88 4d fa	 mov	 BYTE PTR __k$[ebp+18], cl
  00155	eb 61		 jmp	 SHORT $LN111@LoadString
$LN79@LoadString:
  00157	c6 45 f9 ec	 mov	 BYTE PTR __k$[ebp+17], -20 ; ffffffecH
  0015b	eb 5b		 jmp	 SHORT $LN111@LoadString
$LN80@LoadString:
  0015d	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+16], -19 ; ffffffedH
  00161	eb 55		 jmp	 SHORT $LN111@LoadString
$LN82@LoadString:
  00163	88 4d f6	 mov	 BYTE PTR __k$[ebp+14], cl
  00166	eb 50		 jmp	 SHORT $LN111@LoadString
$LN83@LoadString:
  00168	c6 45 f5 ec	 mov	 BYTE PTR __k$[ebp+13], -20 ; ffffffecH
  0016c	eb 4a		 jmp	 SHORT $LN111@LoadString
$LN84@LoadString:
  0016e	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  00172	eb 44		 jmp	 SHORT $LN111@LoadString
$LN85@LoadString:
  00174	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  00178	eb 3e		 jmp	 SHORT $LN111@LoadString
$LN86@LoadString:
  0017a	88 4d f2	 mov	 BYTE PTR __k$[ebp+10], cl
  0017d	eb 39		 jmp	 SHORT $LN111@LoadString
$LN87@LoadString:
  0017f	c6 45 f1 ec	 mov	 BYTE PTR __k$[ebp+9], -20 ; ffffffecH
  00183	eb 33		 jmp	 SHORT $LN111@LoadString
$LN88@LoadString:
  00185	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  00189	eb 2d		 jmp	 SHORT $LN111@LoadString
$LN89@LoadString:
  0018b	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  0018f	eb 27		 jmp	 SHORT $LN111@LoadString
$LN90@LoadString:
  00191	88 4d ee	 mov	 BYTE PTR __k$[ebp+6], cl
  00194	eb 22		 jmp	 SHORT $LN111@LoadString
$LN91@LoadString:
  00196	c6 45 ed ec	 mov	 BYTE PTR __k$[ebp+5], -20 ; ffffffecH
  0019a	eb 1c		 jmp	 SHORT $LN111@LoadString
$LN92@LoadString:
  0019c	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  001a0	eb 16		 jmp	 SHORT $LN111@LoadString
$LN93@LoadString:
  001a2	c6 45 eb ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  001a6	eb 10		 jmp	 SHORT $LN111@LoadString
$LN94@LoadString:
  001a8	c6 45 ea eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  001ac	eb 0a		 jmp	 SHORT $LN111@LoadString
$LN95@LoadString:
  001ae	c6 45 e9 ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  001b2	eb 04		 jmp	 SHORT $LN111@LoadString
$LN96@LoadString:
  001b4	c6 45 e8 ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN111@LoadString:
  001b8	6a 03		 push	 3
  001ba	8d 45 e8	 lea	 eax, DWORD PTR __k$[ebp]
  001bd	c6 45 f7 00	 mov	 BYTE PTR __k$[ebp+15], 0
  001c1	5a		 pop	 edx
$LL104@LoadString:
  001c2	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  001c8	83 c0 04	 add	 eax, 4
  001cb	4a		 dec	 edx
  001cc	75 f4		 jne	 SHORT $LL104@LoadString
  001ce	6a 0c		 push	 12			; 0000000cH
  001d0	58		 pop	 eax
$LL101@LoadString:
  001d1	8b c8		 mov	 ecx, eax
  001d3	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  001d9	79 05		 jns	 SHORT $LN112@LoadString
  001db	49		 dec	 ecx
  001dc	83 c9 fc	 or	 ecx, -4			; fffffffcH
  001df	41		 inc	 ecx
$LN112@LoadString:
  001e0	b2 ed		 mov	 dl, -19			; ffffffedH
  001e2	2a d1		 sub	 dl, cl
  001e4	30 54 05 e8	 xor	 BYTE PTR __k$[ebp+eax], dl
  001e8	40		 inc	 eax
  001e9	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  001ec	7c e3		 jl	 SHORT $LL101@LoadString

; 163  : 		LoadString(_k, d, b, i);

  001ee	ff 75 14	 push	 DWORD PTR _i$[ebp]
  001f1	8b 4d e4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  001f4	57		 push	 edi
  001f5	56		 push	 esi
  001f6	8d 45 e8	 lea	 eax, DWORD PTR __k$[ebp]
  001f9	50		 push	 eax
  001fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 164  : 	}

  00200	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00203	5f		 pop	 edi
  00204	33 cd		 xor	 ecx, ebp
  00206	5e		 pop	 esi
  00207	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0020c	c9		 leave
  0020d	c2 10 00	 ret	 16			; 00000010H
??$LoadString_e@$0BA@@ioINILoader@@QAEXAAY0BA@$$CBDAAY00$$CBDPADH@Z ENDP ; ioINILoader::LoadString_e<16>
_TEXT	ENDS
PUBLIC	??B?$CEncrypt@M@@QAEMXZ				; CEncrypt<float>::operator float
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
;	COMDAT ??B?$CEncrypt@M@@QAEMXZ
_TEXT	SEGMENT
_value$ = -4						; size = 4
??B?$CEncrypt@M@@QAEMXZ PROC				; CEncrypt<float>::operator float, COMDAT
; _this$ = ecx

; 134  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 135  : 		type value;
; 136  : 		DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool

; 137  : 
; 138  : #ifdef _NOTUSE
; 139  : 		Debug();
; 140  : #endif
; 141  : 		return value;

  0000d	d9 45 fc	 fld	 DWORD PTR _value$[ebp]

; 142  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@M@@QAEMXZ ENDP				; CEncrypt<float>::operator float
_TEXT	ENDS
PUBLIC	??4?$CEncrypt@M@@QAEMM@Z			; CEncrypt<float>::operator=
; Function compile flags: /Ogsp
;	COMDAT ??4?$CEncrypt@M@@QAEMM@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
_inValue$ = 8						; size = 4
??4?$CEncrypt@M@@QAEMM@Z PROC				; CEncrypt<float>::operator=, COMDAT
; _this$ = ecx

; 1654 : 	{	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1655 : 		type value = inValue;

  00003	d9 45 08	 fld	 DWORD PTR _inValue$[ebp]

; 1656 : 		EncryptValueToPool((char*)&value);

  00006	8d 45 08	 lea	 eax, DWORD PTR _value$[ebp]
  00009	50		 push	 eax
  0000a	d9 5d 08	 fstp	 DWORD PTR _value$[ebp]
  0000d	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 1657 : #ifdef _NOTUSE
; 1658 : 		m_value = inValue;
; 1659 : 		Debug();
; 1660 : #endif
; 1661 : 		return value;

  00012	d9 45 08	 fld	 DWORD PTR _value$[ebp]

; 1662 : 	}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??4?$CEncrypt@M@@QAEMM@Z ENDP				; CEncrypt<float>::operator=
_TEXT	ENDS
PUBLIC	??Z?$CEncrypt@M@@QAEAAMABM@Z			; CEncrypt<float>::operator-=
; Function compile flags: /Ogsp
;	COMDAT ??Z?$CEncrypt@M@@QAEAAMABM@Z
_TEXT	SEGMENT
_value$ = -4						; size = 4
_inValue$ = 8						; size = 4
??Z?$CEncrypt@M@@QAEAAMABM@Z PROC			; CEncrypt<float>::operator-=, COMDAT
; _this$ = ecx

; 1728 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 1729 : 		type value;
; 1730 : 		DecryptValueToPool(&value);

  00005	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00008	50		 push	 eax
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool

; 1731 : 		value -= inValue;

  00010	8b 45 08	 mov	 eax, DWORD PTR _inValue$[ebp]
  00013	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _value$[ebp]
  00018	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  0001c	0f 5a c0	 cvtps2pd xmm0, xmm0
  0001f	0f 5a c9	 cvtps2pd xmm1, xmm1

; 1732 : 		EncryptValueToPool((char*)&value);

  00022	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00025	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00029	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0002d	50		 push	 eax
  0002e	8b ce		 mov	 ecx, esi
  00030	f3 0f 11 45 fc	 movss	 DWORD PTR _value$[ebp], xmm0
  00035	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 1733 : #ifdef _NOTUSE
; 1734 : 		m_value -= inValue;
; 1735 : 		Debug();
; 1736 : #endif
; 1737 : 		return value;

  0003a	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  0003d	5e		 pop	 esi

; 1738 : 	} 

  0003e	c9		 leave
  0003f	c2 04 00	 ret	 4
??Z?$CEncrypt@M@@QAEAAMABM@Z ENDP			; CEncrypt<float>::operator-=
_TEXT	ENDS
PUBLIC	??B?$CEncrypt@_N@@QAE_NXZ			; CEncrypt<bool>::operator bool
; Function compile flags: /Ogsp
;	COMDAT ??B?$CEncrypt@_N@@QAE_NXZ
_TEXT	SEGMENT
_value$ = -1						; size = 1
??B?$CEncrypt@_N@@QAE_NXZ PROC				; CEncrypt<bool>::operator bool, COMDAT
; _this$ = ecx

; 134  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 135  : 		type value;
; 136  : 		DecryptValueToPool(&value);

  00004	8d 45 ff	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool

; 137  : 
; 138  : #ifdef _NOTUSE
; 139  : 		Debug();
; 140  : #endif
; 141  : 		return value;

  0000d	8a 45 ff	 mov	 al, BYTE PTR _value$[ebp]

; 142  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@_N@@QAE_NXZ ENDP				; CEncrypt<bool>::operator bool
_TEXT	ENDS
PUBLIC	??B?$CEncrypt@_N@@QBE_NXZ			; CEncrypt<bool>::operator bool
; Function compile flags: /Ogsp
;	COMDAT ??B?$CEncrypt@_N@@QBE_NXZ
_TEXT	SEGMENT
_value$ = -1						; size = 1
??B?$CEncrypt@_N@@QBE_NXZ PROC				; CEncrypt<bool>::operator bool, COMDAT
; _this$ = ecx

; 145  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 146  : 		//UJ 130829, const    --start
; 147  : 		type value;
; 148  : 		CEncrypt<type>* pThis = const_cast<CEncrypt<type>*>(this);
; 149  : 		pThis->DecryptValueToPool(&value);

  00004	8d 45 ff	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool

; 150  : 		//// const DecryptValueToPool     .
; 151  :  		//type value;
; 152  : 		//char szTempMem[MAX_ENCRYPT];
; 153  : 		//m_RC5.DecryptByte( m_MemPool, szTempMem, max(m_ValueSize, DEFAULT_ENCRYPT) );
; 154  : 		//memcpy( &value, szTempMem, m_ValueSize );
; 155  : 		//UJ --end
; 156  : 
; 157  : #ifdef _NOTUSE
; 158  : 		Debug();
; 159  : #endif
; 160  : 		return value;

  0000d	8a 45 ff	 mov	 al, BYTE PTR _value$[ebp]

; 161  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@_N@@QBE_NXZ ENDP				; CEncrypt<bool>::operator bool
_TEXT	ENDS
PUBLIC	??B?$CEncrypt@W4TeamType@@@@QBE?AW4TeamType@@XZ	; CEncrypt<enum TeamType>::operator enum TeamType
; Function compile flags: /Ogsp
;	COMDAT ??B?$CEncrypt@W4TeamType@@@@QBE?AW4TeamType@@XZ
_TEXT	SEGMENT
_value$ = -4						; size = 4
??B?$CEncrypt@W4TeamType@@@@QBE?AW4TeamType@@XZ PROC	; CEncrypt<enum TeamType>::operator enum TeamType, COMDAT
; _this$ = ecx

; 145  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 146  : 		//UJ 130829, const    --start
; 147  : 		type value;
; 148  : 		CEncrypt<type>* pThis = const_cast<CEncrypt<type>*>(this);
; 149  : 		pThis->DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool

; 150  : 		//// const DecryptValueToPool     .
; 151  :  		//type value;
; 152  : 		//char szTempMem[MAX_ENCRYPT];
; 153  : 		//m_RC5.DecryptByte( m_MemPool, szTempMem, max(m_ValueSize, DEFAULT_ENCRYPT) );
; 154  : 		//memcpy( &value, szTempMem, m_ValueSize );
; 155  : 		//UJ --end
; 156  : 
; 157  : #ifdef _NOTUSE
; 158  : 		Debug();
; 159  : #endif
; 160  : 		return value;

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _value$[ebp]

; 161  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@W4TeamType@@@@QBE?AW4TeamType@@XZ ENDP	; CEncrypt<enum TeamType>::operator enum TeamType
_TEXT	ENDS
PUBLIC	??4?$CEncrypt@W4TeamType@@@@QAE?AW4TeamType@@W41@@Z ; CEncrypt<enum TeamType>::operator=
; Function compile flags: /Ogsp
;	COMDAT ??4?$CEncrypt@W4TeamType@@@@QAE?AW4TeamType@@W41@@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
_inValue$ = 8						; size = 4
??4?$CEncrypt@W4TeamType@@@@QAE?AW4TeamType@@W41@@Z PROC ; CEncrypt<enum TeamType>::operator=, COMDAT
; _this$ = ecx

; 2965 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2966 : 		type value = inValue;

  00003	8b 45 08	 mov	 eax, DWORD PTR _inValue$[ebp]
  00006	89 45 08	 mov	 DWORD PTR _value$[ebp], eax

; 2967 : 		EncryptValueToPool((char*)&value);

  00009	8d 45 08	 lea	 eax, DWORD PTR _value$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@W4TeamType@@@@AAEXPBD@Z ; CEncrypt<enum TeamType>::EncryptValueToPool

; 2968 : #ifdef _NOTUSE
; 2969 : 		m_value = inValue;
; 2970 : 		Debug();
; 2971 : #endif
; 2972 : 		return value;

  00012	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]

; 2973 : 	}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??4?$CEncrypt@W4TeamType@@@@QAE?AW4TeamType@@W41@@Z ENDP ; CEncrypt<enum TeamType>::operator=
_TEXT	ENDS
PUBLIC	??_C@_08INCNFABO@fire_tic?$AA@			; `string'
PUBLIC	??_C@_0L@JJNLNMLF@max_bullet?$AA@		; `string'
PUBLIC	??_C@_0BC@EKCINOKP@air_height_offset?$AA@	; `string'
PUBLIC	??_C@_0BA@JIMGFIC@use_air_setting?$AA@		; `string'
PUBLIC	??_C@_0BD@KPDPKMCC@fire_height_offset?$AA@	; `string'
PUBLIC	??_C@_0BE@GJOOGMMH@fire_land_min_range?$AA@	; `string'
PUBLIC	??_C@_0BC@DAOHDNLD@fire_search_range?$AA@	; `string'
PUBLIC	??_C@_0M@GPMGMPI@fire_weapon?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?LoadInitProperty@ioDummyTurret2@@IAEXAAVioINILoader@@@Z ; ioDummyTurret2::LoadInitProperty
EXTRN	__imp_?LoadBool@ioINILoader@@QAE_NPBD_N@Z:PROC
EXTRN	__imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z:PROC
EXTRN	__imp_?LoadInt@ioINILoader@@QAEHPBDH@Z:PROC
;	COMDAT ??_C@_08INCNFABO@fire_tic?$AA@
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stringprotect.h
CONST	SEGMENT
??_C@_08INCNFABO@fire_tic?$AA@ DB 'fire_tic', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JJNLNMLF@max_bullet?$AA@
CONST	SEGMENT
??_C@_0L@JJNLNMLF@max_bullet?$AA@ DB 'max_bullet', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EKCINOKP@air_height_offset?$AA@
CONST	SEGMENT
??_C@_0BC@EKCINOKP@air_height_offset?$AA@ DB 'air_height_offset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JIMGFIC@use_air_setting?$AA@
CONST	SEGMENT
??_C@_0BA@JIMGFIC@use_air_setting?$AA@ DB 'use_air_setting', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KPDPKMCC@fire_height_offset?$AA@
CONST	SEGMENT
??_C@_0BD@KPDPKMCC@fire_height_offset?$AA@ DB 'fire_height_offset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GJOOGMMH@fire_land_min_range?$AA@
CONST	SEGMENT
??_C@_0BE@GJOOGMMH@fire_land_min_range?$AA@ DB 'fire_land_min_range', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DAOHDNLD@fire_search_range?$AA@
CONST	SEGMENT
??_C@_0BC@DAOHDNLD@fire_search_range?$AA@ DB 'fire_search_range', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GPMGMPI@fire_weapon?$AA@
CONST	SEGMENT
??_C@_0M@GPMGMPI@fire_weapon?$AA@ DB 'fire_weapon', 00H	; `string'
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iodummyturret2.cpp
CONST	ENDS
;	COMDAT ?LoadInitProperty@ioDummyTurret2@@IAEXAAVioINILoader@@@Z
_TEXT	SEGMENT
_szBuf$ = -284						; size = 260
__k$552130 = -24					; size = 16
__$ArrayPad$ = -4					; size = 4
_rkLoader$ = 8						; size = 4
?LoadInitProperty@ioDummyTurret2@@IAEXAAVioINILoader@@@Z PROC ; ioDummyTurret2::LoadInitProperty, COMDAT
; _this$ = ecx

; 36   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 1c 01 00
	00		 sub	 esp, 284		; 0000011cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8b 7d 08	 mov	 edi, DWORD PTR _rkLoader$[ebp]

; 37   : 	char szBuf[MAX_PATH];
; 38   : 	rkLoader.LoadString_e( "explosion_sound", "", szBuf, MAX_PATH );

  00019	6a 03		 push	 3
  0001b	8b f1		 mov	 esi, ecx
  0001d	c7 45 e8 88 94
	9b 86		 mov	 DWORD PTR __k$552130[ebp], -2036624248 ; 869b9488H
  00024	c7 45 ec 82 9f
	82 85		 mov	 DWORD PTR __k$552130[ebp+4], -2055037054 ; 85829f82H
  0002b	c7 45 f0 83 b3
	98 85		 mov	 DWORD PTR __k$552130[ebp+8], -2053590141 ; 8598b383H
  00032	8d 45 e8	 lea	 eax, DWORD PTR __k$552130[ebp]
  00035	c7 45 f4 98 82
	8f 00		 mov	 DWORD PTR __k$552130[ebp+12], 9405080 ; 008f8298H
  0003c	59		 pop	 ecx
$LL106@LoadInitPr:
  0003d	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00043	83 c0 04	 add	 eax, 4
  00046	49		 dec	 ecx
  00047	75 f4		 jne	 SHORT $LL106@LoadInitPr
  00049	6a 0c		 push	 12			; 0000000cH
  0004b	58		 pop	 eax
$LL103@LoadInitPr:
  0004c	8b c8		 mov	 ecx, eax
  0004e	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00054	79 05		 jns	 SHORT $LN113@LoadInitPr
  00056	49		 dec	 ecx
  00057	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0005a	41		 inc	 ecx
$LN113@LoadInitPr:
  0005b	b2 ed		 mov	 dl, -19			; ffffffedH
  0005d	2a d1		 sub	 dl, cl
  0005f	30 54 05 e8	 xor	 BYTE PTR __k$552130[ebp+eax], dl
  00063	40		 inc	 eax
  00064	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00067	7c e3		 jl	 SHORT $LL103@LoadInitPr
  00069	68 04 01 00 00	 push	 260			; 00000104H
  0006e	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  00074	50		 push	 eax
  00075	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0007a	8d 45 e8	 lea	 eax, DWORD PTR __k$552130[ebp]
  0007d	50		 push	 eax
  0007e	8b cf		 mov	 ecx, edi
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 39   : 	m_szExplosionSound = szBuf;

  00086	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  0008c	50		 push	 eax
  0008d	8d 8e 94 14 00
	00		 lea	 ecx, DWORD PTR [esi+5268]
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 40   : 
; 41   : 	m_nCreateWeaponIndex = (DWORD)rkLoader.LoadInt( "fire_weapon", 0 );

  00099	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  0009f	6a 00		 push	 0
  000a1	68 00 00 00 00	 push	 OFFSET ??_C@_0M@GPMGMPI@fire_weapon?$AA@
  000a6	8b cf		 mov	 ecx, edi
  000a8	ff d3		 call	 ebx

; 42   : 	m_fMaxSearchingRange = rkLoader.LoadFloat( "fire_search_range",  0.f );

  000aa	0f 57 c0	 xorps	 xmm0, xmm0
  000ad	51		 push	 ecx
  000ae	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b3	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@DAOHDNLD@fire_search_range?$AA@
  000b8	8b cf		 mov	 ecx, edi
  000ba	89 86 90 14 00
	00		 mov	 DWORD PTR [esi+5264], eax
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z
  000c6	d9 9e 88 14 00
	00		 fstp	 DWORD PTR [esi+5256]

; 43   : 	m_fFireLandMinRange  = rkLoader.LoadFloat( "fire_land_min_range", 0.f );

  000cc	0f 57 c0	 xorps	 xmm0, xmm0
  000cf	51		 push	 ecx
  000d0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d5	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@GJOOGMMH@fire_land_min_range?$AA@
  000da	8b cf		 mov	 ecx, edi
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z
  000e2	d9 9e 8c 14 00
	00		 fstp	 DWORD PTR [esi+5260]

; 44   : 	m_fFireHeightOffset  = rkLoader.LoadFloat( "fire_height_offset", 0.f );

  000e8	0f 57 c0	 xorps	 xmm0, xmm0
  000eb	51		 push	 ecx
  000ec	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KPDPKMCC@fire_height_offset?$AA@
  000f6	8b cf		 mov	 ecx, edi
  000f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z
  000fe	d9 9e ac 14 00
	00		 fstp	 DWORD PTR [esi+5292]

; 45   : 
; 46   : 	m_bUseAirSetting = rkLoader.LoadBool( "use_air_setting", false );

  00104	6a 00		 push	 0
  00106	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JIMGFIC@use_air_setting?$AA@
  0010b	8b cf		 mov	 ecx, edi
  0010d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadBool@ioINILoader@@QAE_NPBD_N@Z

; 47   : 	m_fAirHeightOffSet = rkLoader.LoadFloat( "air_height_offset", 0.f );

  00113	0f 57 c0	 xorps	 xmm0, xmm0
  00116	51		 push	 ecx
  00117	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0011c	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@EKCINOKP@air_height_offset?$AA@
  00121	8b cf		 mov	 ecx, edi
  00123	88 86 b8 14 00
	00		 mov	 BYTE PTR [esi+5304], al
  00129	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z
  0012f	d9 9e bc 14 00
	00		 fstp	 DWORD PTR [esi+5308]

; 48   : 
; 49   : 	m_nMaxBullet = rkLoader.LoadInt( "max_bullet", 0 );

  00135	6a 00		 push	 0
  00137	68 00 00 00 00	 push	 OFFSET ??_C@_0L@JJNLNMLF@max_bullet?$AA@
  0013c	8b cf		 mov	 ecx, edi
  0013e	ff d3		 call	 ebx

; 50   : 	m_nCurBullet = 0;

  00140	83 a6 a8 14 00
	00 00		 and	 DWORD PTR [esi+5288], 0

; 51   : 
; 52   : 	m_dwFireTicTime = rkLoader.LoadInt( "fire_tic", 10000 );

  00147	68 10 27 00 00	 push	 10000			; 00002710H
  0014c	68 00 00 00 00	 push	 OFFSET ??_C@_08INCNFABO@fire_tic?$AA@
  00151	8b cf		 mov	 ecx, edi
  00153	89 86 a4 14 00
	00		 mov	 DWORD PTR [esi+5284], eax
  00159	ff d3		 call	 ebx

; 53   : 	m_dwNextFireTime = 0;

  0015b	83 a6 b4 14 00
	00 00		 and	 DWORD PTR [esi+5300], 0

; 54   : }

  00162	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00165	5f		 pop	 edi
  00166	89 86 b0 14 00
	00		 mov	 DWORD PTR [esi+5296], eax
  0016c	5e		 pop	 esi
  0016d	33 cd		 xor	 ecx, ebp
  0016f	5b		 pop	 ebx
  00170	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00175	c9		 leave
  00176	c2 04 00	 ret	 4
?LoadInitProperty@ioDummyTurret2@@IAEXAAVioINILoader@@@Z ENDP ; ioDummyTurret2::LoadInitProperty
_TEXT	ENDS
PUBLIC	_this$GSCopy$
EXTRN	?ApplyDummyCharSyncByType@ioDummyChar@@IAEXHAAVSP2Packet@@PAVioPlayStage@@@Z:PROC ; ioDummyChar::ApplyDummyCharSyncByType
EXTRN	?GetBaseChar@ioBaseChar@@QAEPAV1@ABVioHashString@@@Z:PROC ; ioBaseChar::GetBaseChar
EXTRN	??5SP2Packet@@QAEAAV0@AAUD3DXVECTOR3@@@Z:PROC	; SP2Packet::operator>>
EXTRN	??5SP2Packet@@QAEAAV0@AAVioHashString@@@Z:PROC	; SP2Packet::operator>>
EXTRN	??5SP2Packet@@QAEAAV0@AAH@Z:PROC		; SP2Packet::operator>>
EXTRN	__EH_epilog3_GS:PROC
EXTRN	__EH_prolog3_GS:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx9math.h
xdata$x	SEGMENT
__unwindtable$?ApplyDummyCharSync@ioDummyTurret2@@UAEXPAVioPlayStage@@AAVSP2Packet@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ApplyDummyCharSync@ioDummyTurret2@@UAEXPAVioPlayStage@@AAVSP2Packet@@@Z$0
__ehfuncinfo$?ApplyDummyCharSync@ioDummyTurret2@@UAEXPAVioPlayStage@@AAVSP2Packet@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ApplyDummyCharSync@ioDummyTurret2@@UAEXPAVioPlayStage@@AAVSP2Packet@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iodummyturret2.cpp
xdata$x	ENDS
;	COMDAT ?ApplyDummyCharSync@ioDummyTurret2@@UAEXPAVioPlayStage@@AAVSP2Packet@@@Z
_TEXT	SEGMENT
_stTargetName$550849 = -64				; size = 16
_this$GSCopy$ = -48					; size = 4
_eType$ = -44						; size = 4
_vPos$550850 = -40					; size = 12
_vDir$550851 = -28					; size = 12
__$EHRec$ = -12						; size = 12
_pStage$ = 8						; size = 4
_rkPacket$ = 12						; size = 4
?ApplyDummyCharSync@ioDummyTurret2@@UAEXPAVioPlayStage@@AAVSP2Packet@@@Z PROC ; ioDummyTurret2::ApplyDummyCharSync, COMDAT
; _this$ = ecx

; 233  : {

  00000	6a 34		 push	 52			; 00000034H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?ApplyDummyCharSync@ioDummyTurret2@@UAEXPAVioPlayStage@@AAVSP2Packet@@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000c	8b 7d 08	 mov	 edi, DWORD PTR _pStage$[ebp]
  0000f	8b 75 0c	 mov	 esi, DWORD PTR _rkPacket$[ebp]

; 274  : 	{
; 275  : 		ioHashString stTargetName;

  00012	89 4d d0	 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  00015	e8 00 00 00 00	 call	 ?GetOwner@ioDummyChar@@QBEPAVioBaseChar@@XZ ; ioDummyChar::GetOwner
  0001a	8b d8		 mov	 ebx, eax
  0001c	85 db		 test	 ebx, ebx
  0001e	74 7f		 je	 SHORT $LN1@ApplyDummy

; 234  : 	/*ioBaseChar* pOwner = GetOwner();
; 235  : 	if( !pOwner )
; 236  : 		return;
; 237  : 
; 238  : 	if( !pStage ) return;	
; 239  : 
; 240  : 	int iType;
; 241  : 	rkPacket >> iType;
; 242  : 
; 243  : 	if( iType == DMS_FIRE )
; 244  : 	{
; 245  : 		ioHashString stTargetName;
; 246  : 		D3DXVECTOR3 vPos;
; 247  : 		D3DXVECTOR3 vDir;
; 248  : 		rkPacket >>	stTargetName ;
; 249  : 		rkPacket >> vPos;
; 250  : 		rkPacket >> vDir;
; 251  : 
; 252  : 		ioBaseChar* pTarget;
; 253  : 		pTarget = pOwner->GetBaseChar( stTargetName );
; 254  : 
; 255  : 		if( pTarget )
; 256  : 			CreateWeapon( vPos, vDir, pTarget );
; 257  : 	}
; 258  : 	else if( iType == DUMMY_CHAR_DIE)
; 259  : 	{
; 260  : 		SetDieState( true );
; 261  : 	}*/
; 262  : 
; 263  : 	ioBaseChar* pOwner = GetOwner();
; 264  : 	if( !pOwner )
; 265  : 		return;
; 266  : 
; 267  : 	if( !pStage )

  00020	85 ff		 test	 edi, edi
  00022	74 7b		 je	 SHORT $LN1@ApplyDummy

; 268  : 		return;	
; 269  : 
; 270  : 	int eType;
; 271  : 	rkPacket >> eType;

  00024	8d 45 d4	 lea	 eax, DWORD PTR _eType$[ebp]
  00027	50		 push	 eax
  00028	8b ce		 mov	 ecx, esi
  0002a	e8 00 00 00 00	 call	 ??5SP2Packet@@QAEAAV0@AAH@Z ; SP2Packet::operator>>

; 272  : 
; 273  : 	if( eType == DUMMY_CHAR_NORMAL_ATT )

  0002f	83 7d d4 06	 cmp	 DWORD PTR _eType$[ebp], 6
  00033	75 5d		 jne	 SHORT $LN3@ApplyDummy

; 274  : 	{
; 275  : 		ioHashString stTargetName;

  00035	8d 4d c0	 lea	 ecx, DWORD PTR _stTargetName$550849[ebp]
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ
  0003e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 276  : 		D3DXVECTOR3 vPos;
; 277  : 		D3DXVECTOR3 vDir;
; 278  : 		rkPacket >>	stTargetName ;

  00042	8d 45 c0	 lea	 eax, DWORD PTR _stTargetName$550849[ebp]
  00045	50		 push	 eax
  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ??5SP2Packet@@QAEAAV0@AAVioHashString@@@Z ; SP2Packet::operator>>

; 279  : 		rkPacket >> vPos;

  0004d	8d 45 d8	 lea	 eax, DWORD PTR _vPos$550850[ebp]
  00050	50		 push	 eax
  00051	8b ce		 mov	 ecx, esi
  00053	e8 00 00 00 00	 call	 ??5SP2Packet@@QAEAAV0@AAUD3DXVECTOR3@@@Z ; SP2Packet::operator>>

; 280  : 		rkPacket >> vDir;

  00058	8d 45 e4	 lea	 eax, DWORD PTR _vDir$550851[ebp]
  0005b	50		 push	 eax
  0005c	8b ce		 mov	 ecx, esi
  0005e	e8 00 00 00 00	 call	 ??5SP2Packet@@QAEAAV0@AAUD3DXVECTOR3@@@Z ; SP2Packet::operator>>

; 281  : 
; 282  : 		ioBaseChar* pTarget;
; 283  : 		pTarget = pOwner->GetBaseChar( stTargetName );

  00063	8d 45 c0	 lea	 eax, DWORD PTR _stTargetName$550849[ebp]
  00066	50		 push	 eax
  00067	8b cb		 mov	 ecx, ebx
  00069	e8 00 00 00 00	 call	 ?GetBaseChar@ioBaseChar@@QAEPAV1@ABVioHashString@@@Z ; ioBaseChar::GetBaseChar

; 284  : 
; 285  : 		if( pTarget )

  0006e	85 c0		 test	 eax, eax
  00070	74 11		 je	 SHORT $LN2@ApplyDummy

; 286  : 			CreateWeapon( vPos, vDir, pTarget );

  00072	8b 4d d0	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00075	50		 push	 eax
  00076	8d 45 e4	 lea	 eax, DWORD PTR _vDir$550851[ebp]
  00079	50		 push	 eax
  0007a	8d 45 d8	 lea	 eax, DWORD PTR _vPos$550850[ebp]
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ?CreateWeapon@ioDummyTurret2@@IAEXABUD3DXVECTOR3@@0PAVioBaseChar@@@Z ; ioDummyTurret2::CreateWeapon
$LN2@ApplyDummy:

; 287  : 	}

  00083	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00087	8d 4d c0	 lea	 ecx, DWORD PTR _stTargetName$550849[ebp]
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ

; 288  : 	else

  00090	eb 0d		 jmp	 SHORT $LN1@ApplyDummy
$LN3@ApplyDummy:

; 289  : 		ApplyDummyCharSyncByType( eType, rkPacket, pStage );

  00092	8b 4d d0	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00095	57		 push	 edi
  00096	56		 push	 esi
  00097	ff 75 d4	 push	 DWORD PTR _eType$[ebp]
  0009a	e8 00 00 00 00	 call	 ?ApplyDummyCharSyncByType@ioDummyChar@@IAEXHAAVSP2Packet@@PAVioPlayStage@@@Z ; ioDummyChar::ApplyDummyCharSyncByType
$LN1@ApplyDummy:

; 290  : 
; 291  : }

  0009f	e8 00 00 00 00	 call	 __EH_epilog3_GS
  000a4	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ApplyDummyCharSync@ioDummyTurret2@@UAEXPAVioPlayStage@@AAVSP2Packet@@@Z$0:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR _stTargetName$550849[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$?ApplyDummyCharSync@ioDummyTurret2@@UAEXPAVioPlayStage@@AAVSP2Packet@@@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a bc	 mov	 ecx, DWORD PTR [edx-68]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ApplyDummyCharSync@ioDummyTurret2@@UAEXPAVioPlayStage@@AAVSP2Packet@@@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ApplyDummyCharSync@ioDummyTurret2@@UAEXPAVioPlayStage@@AAVSP2Packet@@@Z ENDP ; ioDummyTurret2::ApplyDummyCharSync
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator!=
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 209  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator!=
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioplayentity.h
_TEXT	ENDS
;	COMDAT ?SetTeam@ioPlayEntity@@UAEXW4TeamType@@@Z
_TEXT	SEGMENT
_value$552270 = 8					; size = 4
_eType$ = 8						; size = 4
?SetTeam@ioPlayEntity@@UAEXW4TeamType@@@Z PROC		; ioPlayEntity::SetTeam, COMDAT
; _this$ = ecx

; 106  : 	virtual void SetTeam( TeamType eType ) { m_TeamType = eType; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _eType$[ebp]
  00006	89 45 08	 mov	 DWORD PTR _value$552270[ebp], eax
  00009	8d 45 08	 lea	 eax, DWORD PTR _value$552270[ebp]
  0000c	50		 push	 eax
  0000d	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  00013	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@W4TeamType@@@@AAEXPBD@Z ; CEncrypt<enum TeamType>::EncryptValueToPool
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?SetTeam@ioPlayEntity@@UAEXW4TeamType@@@Z ENDP		; ioPlayEntity::SetTeam
_TEXT	ENDS
PUBLIC	?GetTeam@ioPlayEntity@@QBE?AW4TeamType@@XZ	; ioPlayEntity::GetTeam
; Function compile flags: /Ogsp
;	COMDAT ?GetTeam@ioPlayEntity@@QBE?AW4TeamType@@XZ
_TEXT	SEGMENT
_value$552276 = -4					; size = 4
?GetTeam@ioPlayEntity@@QBE?AW4TeamType@@XZ PROC		; ioPlayEntity::GetTeam, COMDAT
; _this$ = ecx

; 107  : 	inline TeamType GetTeam() const { return m_TeamType; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$552276[ebp]
  00007	50		 push	 eax
  00008	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  0000e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  00013	8b 45 fc	 mov	 eax, DWORD PTR _value$552276[ebp]
  00016	c9		 leave
  00017	c3		 ret	 0
?GetTeam@ioPlayEntity@@QBE?AW4TeamType@@XZ ENDP		; ioPlayEntity::GetTeam
_TEXT	ENDS
PUBLIC	?IsNoWoundedWeapon@ioWeapon@@QBE_NXZ		; ioWeapon::IsNoWoundedWeapon
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioweapon.h
;	COMDAT ?IsNoWoundedWeapon@ioWeapon@@QBE_NXZ
_TEXT	SEGMENT
_value$552283 = -1					; size = 1
?IsNoWoundedWeapon@ioWeapon@@QBE_NXZ PROC		; ioWeapon::IsNoWoundedWeapon, COMDAT
; _this$ = ecx

; 552  : 	inline bool IsNoWoundedWeapon() const { return m_bNoWoundedWeapon; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 ff	 lea	 eax, DWORD PTR _value$552283[ebp]
  00007	50		 push	 eax
  00008	81 c1 a0 06 00
	00		 add	 ecx, 1696		; 000006a0H
  0000e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  00013	8a 45 ff	 mov	 al, BYTE PTR _value$552283[ebp]
  00016	c9		 leave
  00017	c3		 ret	 0
?IsNoWoundedWeapon@ioWeapon@@QBE_NXZ ENDP		; ioWeapon::IsNoWoundedWeapon
_TEXT	ENDS
EXTRN	?LoadProperty@ioDummyChar@@UAEXAAVioINILoader@@@Z:PROC ; ioDummyChar::LoadProperty
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iodummyturret2.cpp
;	COMDAT ?LoadProperty@ioDummyTurret2@@UAEXAAVioINILoader@@@Z
_TEXT	SEGMENT
_rkLoader$ = 8						; size = 4
?LoadProperty@ioDummyTurret2@@UAEXAAVioINILoader@@@Z PROC ; ioDummyTurret2::LoadProperty, COMDAT
; _this$ = ecx

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 30   : 	ioDummyChar::LoadProperty( rkLoader );

  00004	ff 75 08	 push	 DWORD PTR _rkLoader$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	e8 00 00 00 00	 call	 ?LoadProperty@ioDummyChar@@UAEXAAVioINILoader@@@Z ; ioDummyChar::LoadProperty

; 31   : 
; 32   : 	LoadInitProperty( rkLoader );

  0000e	ff 75 08	 push	 DWORD PTR _rkLoader$[ebp]
  00011	8b ce		 mov	 ecx, esi
  00013	e8 00 00 00 00	 call	 ?LoadInitProperty@ioDummyTurret2@@IAEXAAVioINILoader@@@Z ; ioDummyTurret2::LoadInitProperty
  00018	5e		 pop	 esi

; 33   : }

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
?LoadProperty@ioDummyTurret2@@UAEXAAVioINILoader@@@Z ENDP ; ioDummyTurret2::LoadProperty
_TEXT	ENDS
PUBLIC	__real@3fe0000000000000
PUBLIC	??_C@_0CI@IACIOAIO@ioDummyChar?3?3ApplyWeapon?5?9?5?$CFs?5No@ ; `string'
EXTRN	?CheckEntityCollision@ioDummyCharManager@@QAEXPAVioBaseChar@@PAVioPlayEntity@@H@Z:PROC ; ioDummyCharManager::CheckEntityCollision
EXTRN	?GetSingleton@ioDummyCharManager@@SAAAV1@XZ:PROC ; ioDummyCharManager::GetSingleton
EXTRN	__imp_?Clear@ioHashString@@QAEXXZ:PROC
EXTRN	?ClearAttackFireTimeAndSkill@ioBaseChar@@QAEXW4ClearAttackFireType@@@Z:PROC ; ioBaseChar::ClearAttackFireTimeAndSkill
EXTRN	?IsCurUsingSkill@ioBaseChar@@QAE_NVioHashString@@@Z:PROC ; ioBaseChar::IsCurUsingSkill
EXTRN	?SetActionStopDuration@ioWeapon@@QAEXKM@Z:PROC	; ioWeapon::SetActionStopDuration
EXTRN	?CalcActionStopDelay@ioBaseChar@@SAKM_N@Z:PROC	; ioBaseChar::CalcActionStopDelay
EXTRN	?GetActionStopLooseRate@ioBaseChar@@SAM_N@Z:PROC ; ioBaseChar::GetActionStopLooseRate
EXTRN	?SetActionStopDelay@ioBaseChar@@QAEXM_NH@Z:PROC	; ioBaseChar::SetActionStopDelay
EXTRN	?GetShakeCamera@ioWeapon@@QBEHXZ:PROC		; ioWeapon::GetShakeCamera
EXTRN	?SetDisableAttackEmoticon@ioBaseGUISupport@@QAEXXZ:PROC ; ioBaseGUISupport::SetDisableAttackEmoticon
EXTRN	?ReverseReflectPush@ioBaseChar@@QAEXABUD3DXVECTOR3@@M@Z:PROC ; ioBaseChar::ReverseReflectPush
EXTRN	?AddNewBuff@ioBaseChar@@QAEPAVioBuff@@ABVioHashString@@00PAVioSkill@@_N@Z:PROC ; ioBaseChar::AddNewBuff
EXTRN	?IgnoreBlock@ioBaseChar@@QAE_NXZ:PROC		; ioBaseChar::IgnoreBlock
EXTRN	?IsChangeJumpping@ioWeapon@@QAE_N_N0@Z:PROC	; ioWeapon::IsChangeJumpping
EXTRN	?IsEnableAttackCancelState@ioBaseChar@@QAE_NXZ:PROC ; ioBaseChar::IsEnableAttackCancelState
EXTRN	__imp_??4ioHashString@@QAEAAV0@ABV0@@Z:PROC
EXTRN	__imp_?PrintTimeAndLog@CLog@@QAAXHPADZZ:PROC
EXTRN	__imp_?LOG@@3VCLog@@A:BYTE
EXTRN	__imp_?c_str@ioHashString@@QBEPBDXZ:PROC
EXTRN	?GetOwner@ioWeapon@@QBEPAVioBaseChar@@XZ:PROC	; ioWeapon::GetOwner
;	COMDAT __real@3fe0000000000000
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioweapon.h
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT ??_C@_0CI@IACIOAIO@ioDummyChar?3?3ApplyWeapon?5?9?5?$CFs?5No@
CONST	SEGMENT
??_C@_0CI@IACIOAIO@ioDummyChar?3?3ApplyWeapon?5?9?5?$CFs?5No@ DB 'ioDummy'
	DB	'Char::ApplyWeapon - %s Not Exist', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ApplyWeapon@ioDummyTurret2@@UAE?AW4ApplyWeaponExp@@PAVioWeapon@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ApplyWeapon@ioDummyTurret2@@UAE?AW4ApplyWeaponExp@@PAVioWeapon@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ApplyWeapon@ioDummyTurret2@@UAE?AW4ApplyWeaponExp@@PAVioWeapon@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ApplyWeapon@ioDummyTurret2@@UAE?AW4ApplyWeaponExp@@PAVioWeapon@@@Z$2
__ehfuncinfo$?ApplyWeapon@ioDummyTurret2@@UAE?AW4ApplyWeaponExp@@PAVioWeapon@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ApplyWeapon@ioDummyTurret2@@UAE?AW4ApplyWeaponExp@@PAVioWeapon@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iodummyturret2.cpp
xdata$x	ENDS
;	COMDAT ?ApplyWeapon@ioDummyTurret2@@UAE?AW4ApplyWeaponExp@@PAVioWeapon@@@Z
_TEXT	SEGMENT
$T552290 = -84						; size = 16
$T552291 = -68						; size = 16
_value$552356 = -52					; size = 4
_value$552349 = -48					; size = 4
$T552293 = -48						; size = 4
_fPushPower$ = -48					; size = 4
_value$552331 = -44					; size = 4
_value$552318 = -44					; size = 4
_fDamage$ = -40						; size = 4
_pAttacker$ = -36					; size = 4
_value$552327 = -29					; size = 1
_value$552323 = -29					; size = 1
_value$552310 = -29					; size = 1
_bStructWeapon$ = -29					; size = 1
_vAttackDir$ = -28					; size = 12
__$EHRec$ = -12						; size = 12
_pWeapon$ = 8						; size = 4
?ApplyWeapon@ioDummyTurret2@@UAE?AW4ApplyWeaponExp@@PAVioWeapon@@@Z PROC ; ioDummyTurret2::ApplyWeapon, COMDAT
; _this$ = ecx

; 145  : {

  00000	6a 48		 push	 72			; 00000048H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?ApplyWeapon@ioDummyTurret2@@UAE?AW4ApplyWeaponExp@@PAVioWeapon@@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000c	8b 75 08	 mov	 esi, DWORD PTR _pWeapon$[ebp]
  0000f	8b f9		 mov	 edi, ecx

; 146  : 	ioBaseChar *pAttacker = pWeapon->GetOwner();

  00011	8b ce		 mov	 ecx, esi
  00013	e8 00 00 00 00	 call	 ?GetOwner@ioWeapon@@QBEPAVioBaseChar@@XZ ; ioWeapon::GetOwner
  00018	89 45 dc	 mov	 DWORD PTR _pAttacker$[ebp], eax

; 147  : 	if( !pAttacker )

  0001b	85 c0		 test	 eax, eax
  0001d	75 25		 jne	 SHORT $LN19@ApplyWeapo

; 148  : 	{
; 149  : 		LOG.PrintTimeAndLog( 0, "ioDummyChar::ApplyWeapon - %s Not Exist", pWeapon->GetOwnerName().c_str() );

  0001f	8d 4e 10	 lea	 ecx, DWORD PTR [esi+16]
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00028	50		 push	 eax
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@IACIOAIO@ioDummyChar?3?3ApplyWeapon?5?9?5?$CFs?5No@
  0002e	6a 00		 push	 0
  00030	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintTimeAndLog@CLog@@QAAXHPADZZ
  0003c	83 c4 10	 add	 esp, 16			; 00000010H

; 150  : 		return AWE_EXPLOSION;

  0003f	e9 4d 03 00 00	 jmp	 $LN62@ApplyWeapo
$LN19@ApplyWeapo:

; 151  : 	}
; 152  : 
; 153  : 	if( pWeapon->IsNoWoundedWeapon() )

  00044	8d 45 e3	 lea	 eax, DWORD PTR _value$552310[ebp]
  00047	8d 8e a0 06 00
	00		 lea	 ecx, DWORD PTR [esi+1696]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  00053	80 7d e3 00	 cmp	 BYTE PTR _value$552310[ebp], 0
  00057	74 07		 je	 SHORT $LN18@ApplyWeapo

; 154  : 		return AWE_NO_EXPLOSION;

  00059	33 c0		 xor	 eax, eax
  0005b	e9 34 03 00 00	 jmp	 $LN20@ApplyWeapo
$LN18@ApplyWeapo:

; 155  : 
; 156  : 	m_LastAttacker = pWeapon->GetOwnerName();

  00060	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  00063	50		 push	 eax
  00064	8d 8f 30 05 00
	00		 lea	 ecx, DWORD PTR [edi+1328]
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@ABV0@@Z

; 157  : 
; 158  : 	float fDamage = pWeapon->GetDamage( this ) * m_fDamageRate;

  00070	8d 45 d4	 lea	 eax, DWORD PTR _value$552318[ebp]
  00073	50		 push	 eax
  00074	8d 8f d0 04 00
	00		 lea	 ecx, DWORD PTR [edi+1232]
  0007a	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  0007f	8b 06		 mov	 eax, DWORD PTR [esi]
  00081	57		 push	 edi
  00082	8b ce		 mov	 ecx, esi
  00084	ff 90 d4 00 00
	00		 call	 DWORD PTR [eax+212]
  0008a	d8 4d d4	 fmul	 DWORD PTR _value$552318[ebp]

; 159  : 	float fPushPower = pWeapon->GetDefensePushPower( fDamage );

  0008d	8b 06		 mov	 eax, DWORD PTR [esi]
  0008f	51		 push	 ecx
  00090	d9 5d d8	 fstp	 DWORD PTR _fDamage$[ebp]
  00093	8b ce		 mov	 ecx, esi
  00095	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  0009a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0009f	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]
  000a5	d9 5d d0	 fstp	 DWORD PTR _fPushPower$[ebp]

; 160  : 
; 161  : 	if( !m_bNoDamage && !m_bPiercingProtected )

  000a8	8d 45 e3	 lea	 eax, DWORD PTR _value$552323[ebp]
  000ab	50		 push	 eax
  000ac	8d 8f 80 03 00
	00		 lea	 ecx, DWORD PTR [edi+896]
  000b2	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  000b7	80 7d e3 00	 cmp	 BYTE PTR _value$552323[ebp], 0
  000bb	75 4e		 jne	 SHORT $LN39@ApplyWeapo
  000bd	8d 45 e3	 lea	 eax, DWORD PTR _value$552327[ebp]
  000c0	50		 push	 eax
  000c1	8d 8f 70 04 00
	00		 lea	 ecx, DWORD PTR [edi+1136]
  000c7	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  000cc	80 7d e3 00	 cmp	 BYTE PTR _value$552327[ebp], 0
  000d0	75 39		 jne	 SHORT $LN39@ApplyWeapo

; 162  : 		m_HP.m_fCurValue -= fDamage;

  000d2	8d 45 d4	 lea	 eax, DWORD PTR _value$552331[ebp]
  000d5	8d 9f c0 00 00
	00		 lea	 ebx, DWORD PTR [edi+192]
  000db	50		 push	 eax
  000dc	8b cb		 mov	 ecx, ebx
  000de	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  000e3	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _value$552331[ebp]
  000e8	f3 0f 10 4d d8	 movss	 xmm1, DWORD PTR _fDamage$[ebp]
  000ed	0f 5a c0	 cvtps2pd xmm0, xmm0
  000f0	0f 5a c9	 cvtps2pd xmm1, xmm1
  000f3	8d 45 d4	 lea	 eax, DWORD PTR _value$552331[ebp]
  000f6	f2 0f 5c c1	 subsd	 xmm0, xmm1
  000fa	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  000fe	50		 push	 eax
  000ff	8b cb		 mov	 ecx, ebx
  00101	f3 0f 11 45 d4	 movss	 DWORD PTR _value$552331[ebp], xmm0
  00106	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool
$LN39@ApplyWeapo:

; 163  : 	AddHeadDamageInfo( (int)fDamage );

  0010b	f3 0f 2c 4d d8	 cvttss2si ecx, DWORD PTR _fDamage$[ebp]
  00110	8b 07		 mov	 eax, DWORD PTR [edi]
  00112	6a 00		 push	 0
  00114	51		 push	 ecx
  00115	8b cf		 mov	 ecx, edi
  00117	ff 90 d0 00 00
	00		 call	 DWORD PTR [eax+208]

; 164  : 
; 165  : 	bool bContactType = false;
; 166  : 	if( pWeapon->GetType() == ioWeapon::WT_CONTACT ||
; 167  : 		pWeapon->GetType() == ioWeapon::WT_RUN_CONTACT ||
; 168  : 		pWeapon->GetType() == ioWeapon::WT_CONTACT2 )

  0011d	8b 06		 mov	 eax, DWORD PTR [esi]
  0011f	8b ce		 mov	 ecx, esi
  00121	32 db		 xor	 bl, bl
  00123	ff 90 10 01 00
	00		 call	 DWORD PTR [eax+272]
  00129	83 f8 01	 cmp	 eax, 1
  0012c	74 1e		 je	 SHORT $LN15@ApplyWeapo
  0012e	8b 06		 mov	 eax, DWORD PTR [esi]
  00130	8b ce		 mov	 ecx, esi
  00132	ff 90 10 01 00
	00		 call	 DWORD PTR [eax+272]
  00138	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  0013b	74 0f		 je	 SHORT $LN15@ApplyWeapo
  0013d	8b 06		 mov	 eax, DWORD PTR [esi]
  0013f	8b ce		 mov	 ecx, esi
  00141	ff 90 10 01 00
	00		 call	 DWORD PTR [eax+272]
  00147	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  0014a	75 02		 jne	 SHORT $LN16@ApplyWeapo
$LN15@ApplyWeapo:

; 169  : 		bContactType = true;

  0014c	b3 01		 mov	 bl, 1
$LN16@ApplyWeapo:

; 170  : 
; 171  : 	bool bStructWeapon = false;
; 172  : 	if( pWeapon->CheckWeaponByStruct() || pWeapon->CheckWeaponByDummyChar() )

  0014e	80 be 8c 05 00
	00 00		 cmp	 BYTE PTR [esi+1420], 0
  00155	c6 45 e3 00	 mov	 BYTE PTR _bStructWeapon$[ebp], 0
  00159	75 09		 jne	 SHORT $LN13@ApplyWeapo
  0015b	80 be 9c 05 00
	00 00		 cmp	 BYTE PTR [esi+1436], 0
  00162	74 04		 je	 SHORT $LN14@ApplyWeapo
$LN13@ApplyWeapo:

; 173  : 		bStructWeapon = true;

  00164	c6 45 e3 01	 mov	 BYTE PTR _bStructWeapon$[ebp], 1
$LN14@ApplyWeapo:

; 174  : 
; 175  : 	D3DXVECTOR3 vAttackDir = pWeapon->GetAttackDir(this);

  00168	8b 06		 mov	 eax, DWORD PTR [esi]
  0016a	57		 push	 edi
  0016b	8d 4d e4	 lea	 ecx, DWORD PTR _vAttackDir$[ebp]
  0016e	51		 push	 ecx
  0016f	8b ce		 mov	 ecx, esi
  00171	ff 90 fc 00 00
	00		 call	 DWORD PTR [eax+252]

; 176  : 
; 177  : 	if( bContactType && !bStructWeapon && !pWeapon->CheckWeaponBySkill() && !m_BlockBuff.IsEmpty() )

  00177	84 db		 test	 bl, bl
  00179	0f 84 d5 00 00
	00		 je	 $LN11@ApplyWeapo
  0017f	80 7d e3 00	 cmp	 BYTE PTR _bStructWeapon$[ebp], 0
  00183	0f 85 cb 00 00
	00		 jne	 $LN11@ApplyWeapo
  00189	80 be 7e 05 00
	00 00		 cmp	 BYTE PTR [esi+1406], 0
  00190	0f 85 be 00 00
	00		 jne	 $LN11@ApplyWeapo
  00196	8d 8f b0 02 00
	00		 lea	 ecx, DWORD PTR [edi+688]
  0019c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  001a2	84 c0		 test	 al, al
  001a4	0f 85 aa 00 00
	00		 jne	 $LN11@ApplyWeapo

; 178  : 	{
; 179  : 		if( pAttacker->IsEnableAttackCancelState() && !pWeapon->IsChangeJumpping( false, false )
; 180  : 			&& !pAttacker->IgnoreBlock() )

  001aa	8b 4d dc	 mov	 ecx, DWORD PTR _pAttacker$[ebp]
  001ad	e8 00 00 00 00	 call	 ?IsEnableAttackCancelState@ioBaseChar@@QAE_NXZ ; ioBaseChar::IsEnableAttackCancelState
  001b2	84 c0		 test	 al, al
  001b4	0f 84 9a 00 00
	00		 je	 $LN11@ApplyWeapo
  001ba	6a 00		 push	 0
  001bc	6a 00		 push	 0
  001be	8b ce		 mov	 ecx, esi
  001c0	e8 00 00 00 00	 call	 ?IsChangeJumpping@ioWeapon@@QAE_N_N0@Z ; ioWeapon::IsChangeJumpping
  001c5	84 c0		 test	 al, al
  001c7	0f 85 87 00 00
	00		 jne	 $LN11@ApplyWeapo
  001cd	8b 4d dc	 mov	 ecx, DWORD PTR _pAttacker$[ebp]
  001d0	e8 00 00 00 00	 call	 ?IgnoreBlock@ioBaseChar@@QAE_NXZ ; ioBaseChar::IgnoreBlock
  001d5	84 c0		 test	 al, al
  001d7	75 7b		 jne	 SHORT $LN11@ApplyWeapo

; 181  : 		{
; 182  : 			pAttacker->AddNewBuff( m_BlockBuff, "", "", NULL );

  001d9	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  001df	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  001e4	8d 4d ac	 lea	 ecx, DWORD PTR $T552290[ebp]
  001e7	ff d3		 call	 ebx
  001e9	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  001ed	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  001f2	8d 4d bc	 lea	 ecx, DWORD PTR $T552291[ebp]
  001f5	ff d3		 call	 ebx
  001f7	8b 4d dc	 mov	 ecx, DWORD PTR _pAttacker$[ebp]
  001fa	6a 00		 push	 0
  001fc	6a 00		 push	 0
  001fe	8d 45 ac	 lea	 eax, DWORD PTR $T552290[ebp]
  00201	50		 push	 eax
  00202	8d 45 bc	 lea	 eax, DWORD PTR $T552291[ebp]
  00205	50		 push	 eax
  00206	8d 87 b0 02 00
	00		 lea	 eax, DWORD PTR [edi+688]
  0020c	50		 push	 eax
  0020d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00211	e8 00 00 00 00	 call	 ?AddNewBuff@ioBaseChar@@QAEPAVioBuff@@ABVioHashString@@00PAVioSkill@@_N@Z ; ioBaseChar::AddNewBuff
  00216	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_??1ioHashString@@QAE@XZ
  0021c	8d 4d bc	 lea	 ecx, DWORD PTR $T552291[ebp]
  0021f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00223	ff d3		 call	 ebx
  00225	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00229	8d 4d ac	 lea	 ecx, DWORD PTR $T552290[ebp]
  0022c	ff d3		 call	 ebx

; 183  : 			pAttacker->ReverseReflectPush( vAttackDir, fPushPower * 0.5f );

  0022e	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _fPushPower$[ebp]
  00233	0f 5a c0	 cvtps2pd xmm0, xmm0
  00236	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fe0000000000000
  0023e	51		 push	 ecx
  0023f	8b 4d dc	 mov	 ecx, DWORD PTR _pAttacker$[ebp]
  00242	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00246	8d 45 e4	 lea	 eax, DWORD PTR _vAttackDir$[ebp]
  00249	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0024e	50		 push	 eax
  0024f	e8 00 00 00 00	 call	 ?ReverseReflectPush@ioBaseChar@@QAEXABUD3DXVECTOR3@@M@Z ; ioBaseChar::ReverseReflectPush
$LN11@ApplyWeapo:

; 184  : 		}
; 185  : 	}
; 186  : 
; 187  : 	if( !m_BlockBuff.IsEmpty() )

  00254	8d 8f b0 02 00
	00		 lea	 ecx, DWORD PTR [edi+688]
  0025a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00260	84 c0		 test	 al, al
  00262	75 0e		 jne	 SHORT $LN10@ApplyWeapo

; 188  : 		pAttacker->SetDisableAttackEmoticon();

  00264	8b 4d dc	 mov	 ecx, DWORD PTR _pAttacker$[ebp]
  00267	81 c1 cc 01 00
	00		 add	 ecx, 460		; 000001ccH
  0026d	e8 00 00 00 00	 call	 ?SetDisableAttackEmoticon@ioBaseGUISupport@@QAEXXZ ; ioBaseGUISupport::SetDisableAttackEmoticon
$LN10@ApplyWeapo:

; 189  : 
; 190  : 	int iShakeCamera = pWeapon->GetShakeCamera();

  00272	8b ce		 mov	 ecx, esi
  00274	e8 00 00 00 00	 call	 ?GetShakeCamera@ioWeapon@@QBEHXZ ; ioWeapon::GetShakeCamera
  00279	8b d8		 mov	 ebx, eax

; 191  : 	ActionStopType eActionStop = pWeapon->GetActionStopType();

  0027b	8b 06		 mov	 eax, DWORD PTR [esi]
  0027d	8b ce		 mov	 ecx, esi
  0027f	ff 90 14 01 00
	00		 call	 DWORD PTR [eax+276]

; 192  : 
; 193  : 	if( eActionStop == AST_BOTH || eActionStop == AST_ATTACKER )

  00285	83 f8 01	 cmp	 eax, 1
  00288	74 05		 je	 SHORT $LN8@ApplyWeapo
  0028a	83 f8 02	 cmp	 eax, 2
  0028d	75 3b		 jne	 SHORT $LN9@ApplyWeapo
$LN8@ApplyWeapo:

; 194  : 	{
; 195  : 		pAttacker->SetActionStopDelay( fDamage, false, iShakeCamera );

  0028f	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  00294	53		 push	 ebx
  00295	33 db		 xor	 ebx, ebx
  00297	53		 push	 ebx
  00298	51		 push	 ecx
  00299	8b 4d dc	 mov	 ecx, DWORD PTR _pAttacker$[ebp]
  0029c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002a1	e8 00 00 00 00	 call	 ?SetActionStopDelay@ioBaseChar@@QAEXM_NH@Z ; ioBaseChar::SetActionStopDelay

; 196  : 		pWeapon->SetActionStopDuration( ioBaseChar::CalcActionStopDelay( fDamage, false ),
; 197  : 			ioBaseChar::GetActionStopLooseRate( false ) );

  002a6	53		 push	 ebx
  002a7	e8 00 00 00 00	 call	 ?GetActionStopLooseRate@ioBaseChar@@SAM_N@Z ; ioBaseChar::GetActionStopLooseRate
  002ac	d9 1c 24	 fstp	 DWORD PTR [esp]
  002af	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _fDamage$[ebp]
  002b4	53		 push	 ebx
  002b5	51		 push	 ecx
  002b6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002bb	e8 00 00 00 00	 call	 ?CalcActionStopDelay@ioBaseChar@@SAKM_N@Z ; ioBaseChar::CalcActionStopDelay
  002c0	59		 pop	 ecx
  002c1	59		 pop	 ecx
  002c2	50		 push	 eax
  002c3	8b ce		 mov	 ecx, esi
  002c5	e8 00 00 00 00	 call	 ?SetActionStopDuration@ioWeapon@@QAEXKM@Z ; ioWeapon::SetActionStopDuration
$LN9@ApplyWeapo:

; 198  : 	}
; 199  : 
; 200  : 	if( m_HP.m_fCurValue <= 0.0f )

  002ca	8d 45 d0	 lea	 eax, DWORD PTR _value$552349[ebp]
  002cd	50		 push	 eax
  002ce	8d 8f c0 00 00
	00		 lea	 ecx, DWORD PTR [edi+192]
  002d4	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  002d9	0f 57 c0	 xorps	 xmm0, xmm0
  002dc	0f 2f 45 d0	 comiss	 xmm0, DWORD PTR _value$552349[ebp]
  002e0	0f 82 95 00 00
	00		 jb	 $LN2@ApplyWeapo

; 201  : 	{
; 202  : 		m_HP.m_fCurValue = 0.0f;

  002e6	8d 45 cc	 lea	 eax, DWORD PTR _value$552356[ebp]
  002e9	50		 push	 eax
  002ea	8d 8f c0 00 00
	00		 lea	 ecx, DWORD PTR [edi+192]
  002f0	f3 0f 11 45 cc	 movss	 DWORD PTR _value$552356[ebp], xmm0
  002f5	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 203  : 		SetDieState( true );

  002fa	8b 07		 mov	 eax, DWORD PTR [edi]
  002fc	6a 01		 push	 1
  002fe	8b cf		 mov	 ecx, edi
  00300	ff 90 60 01 00
	00		 call	 DWORD PTR [eax+352]

; 204  : 
; 205  : 		//     
; 206  : 		switch( m_DummyCharType )

  00306	8b 87 2c 02 00
	00		 mov	 eax, DWORD PTR [edi+556]
  0030c	83 e8 03	 sub	 eax, 3
  0030f	74 09		 je	 SHORT $LN4@ApplyWeapo
  00311	48		 dec	 eax
  00312	48		 dec	 eax
  00313	74 05		 je	 SHORT $LN4@ApplyWeapo
  00315	83 e8 18	 sub	 eax, 24			; 00000018H
  00318	75 61		 jne	 SHORT $LN2@ApplyWeapo
$LN4@ApplyWeapo:

; 207  : 		{
; 208  : 		case DCT_OWNER_CONTROL:
; 209  : 		case DCT_OWNER_CONTROL3:
; 210  : 		case DCT_OWNER_ATTACH:
; 211  : 			if( !m_ControlSkillName.IsEmpty() )

  0031a	8d 9f 98 0d 00
	00		 lea	 ebx, DWORD PTR [edi+3480]
  00320	8b cb		 mov	 ecx, ebx
  00322	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00328	84 c0		 test	 al, al
  0032a	75 4f		 jne	 SHORT $LN2@ApplyWeapo

; 212  : 			{
; 213  : 				if( GetOwner() && GetOwner()->IsCurUsingSkill( m_ControlSkillName ) )

  0032c	8b cf		 mov	 ecx, edi
  0032e	e8 00 00 00 00	 call	 ?GetOwner@ioDummyChar@@QBEPAVioBaseChar@@XZ ; ioDummyChar::GetOwner
  00333	85 c0		 test	 eax, eax
  00335	74 44		 je	 SHORT $LN2@ApplyWeapo
  00337	83 ec 10	 sub	 esp, 16			; 00000010H
  0033a	8b cc		 mov	 ecx, esp
  0033c	89 65 d0	 mov	 DWORD PTR $T552293[ebp], esp
  0033f	53		 push	 ebx
  00340	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  00346	8b cf		 mov	 ecx, edi
  00348	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  0034f	e8 00 00 00 00	 call	 ?GetOwner@ioDummyChar@@QBEPAVioBaseChar@@XZ ; ioDummyChar::GetOwner
  00354	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00358	8b c8		 mov	 ecx, eax
  0035a	e8 00 00 00 00	 call	 ?IsCurUsingSkill@ioBaseChar@@QAE_NVioHashString@@@Z ; ioBaseChar::IsCurUsingSkill
  0035f	84 c0		 test	 al, al
  00361	74 18		 je	 SHORT $LN2@ApplyWeapo

; 214  : 				{
; 215  : 					GetOwner()->ClearAttackFireTimeAndSkill( CAFT_APPLY_WOUNDED_BY_DUMMY );

  00363	6a 02		 push	 2
  00365	8b cf		 mov	 ecx, edi
  00367	e8 00 00 00 00	 call	 ?GetOwner@ioDummyChar@@QBEPAVioBaseChar@@XZ ; ioDummyChar::GetOwner
  0036c	8b c8		 mov	 ecx, eax
  0036e	e8 00 00 00 00	 call	 ?ClearAttackFireTimeAndSkill@ioBaseChar@@QAEXW4ClearAttackFireType@@@Z ; ioBaseChar::ClearAttackFireTimeAndSkill

; 216  : 					m_ControlSkillName.Clear();

  00373	8b cb		 mov	 ecx, ebx
  00375	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Clear@ioHashString@@QAEXXZ
$LN2@ApplyWeapo:

; 217  : 				}
; 218  : 			}
; 219  : 			break;
; 220  : 		}
; 221  : 	}
; 222  : 
; 223  : 	if( pWeapon )
; 224  : 	{
; 225  : 		int iDummyIndex = pWeapon->GetWeaponByDummyChar();
; 226  : 		g_DummyCharMgr.CheckEntityCollision( pAttacker, this, iDummyIndex );

  0037b	ff b6 98 05 00
	00		 push	 DWORD PTR [esi+1432]
  00381	57		 push	 edi
  00382	ff 75 dc	 push	 DWORD PTR _pAttacker$[ebp]
  00385	e8 00 00 00 00	 call	 ?GetSingleton@ioDummyCharManager@@SAAAV1@XZ ; ioDummyCharManager::GetSingleton
  0038a	8b c8		 mov	 ecx, eax
  0038c	e8 00 00 00 00	 call	 ?CheckEntityCollision@ioDummyCharManager@@QAEXPAVioBaseChar@@PAVioPlayEntity@@H@Z ; ioDummyCharManager::CheckEntityCollision
$LN62@ApplyWeapo:

; 227  : 	}
; 228  : 
; 229  : 	return AWE_EXPLOSION;

  00391	33 c0		 xor	 eax, eax
  00393	40		 inc	 eax
$LN20@ApplyWeapo:

; 230  : }

  00394	e8 00 00 00 00	 call	 __EH_epilog3_GS
  00399	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ApplyWeapon@ioDummyTurret2@@UAE?AW4ApplyWeaponExp@@PAVioWeapon@@@Z$0:
  00000	8d 4d ac	 lea	 ecx, DWORD PTR $T552290[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?ApplyWeapon@ioDummyTurret2@@UAE?AW4ApplyWeaponExp@@PAVioWeapon@@@Z$1:
  00009	8d 4d bc	 lea	 ecx, DWORD PTR $T552291[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?ApplyWeapon@ioDummyTurret2@@UAE?AW4ApplyWeaponExp@@PAVioWeapon@@@Z$2:
  00012	8b 4d d0	 mov	 ecx, DWORD PTR $T552293[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$?ApplyWeapon@ioDummyTurret2@@UAE?AW4ApplyWeaponExp@@PAVioWeapon@@@Z:
  0001b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00022	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  00025	33 c8		 xor	 ecx, eax
  00027	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002c	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002f	33 c8		 xor	 ecx, eax
  00031	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00036	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ApplyWeapon@ioDummyTurret2@@UAE?AW4ApplyWeaponExp@@PAVioWeapon@@@Z
  0003b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ApplyWeapon@ioDummyTurret2@@UAE?AW4ApplyWeaponExp@@PAVioWeapon@@@Z ENDP ; ioDummyTurret2::ApplyWeapon
PUBLIC	__real@0000000000000000
PUBLIC	_pOwner$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CheckTarget@ioDummyTurret2@@IAEXPAVioBaseChar@@@Z ; ioDummyTurret2::CheckTarget
EXTRN	?GetMapHeight@ioPlayStage@@QAEMMMPBVioGameEntity@@_NM1@Z:PROC ; ioPlayStage::GetMapHeight
EXTRN	?IsEnableTarget@ioBaseChar@@QAE_N_N0@Z:PROC	; ioBaseChar::IsEnableTarget
EXTRN	?IsSystemState@ioBaseChar@@QAE_NXZ:PROC		; ioBaseChar::IsSystemState
EXTRN	__imp_??8ioHashString@@QBE_NABV0@@Z:PROC
;	COMDAT __real@0000000000000000
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx9math.inl
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iodummyturret2.cpp
CONST	ENDS
;	COMDAT ?CheckTarget@ioDummyTurret2@@IAEXPAVioBaseChar@@@Z
_TEXT	SEGMENT
_this$GSCopy$ = -68					; size = 4
_fTargetMapHeight$551009 = -64				; size = 4
_pOwner$GSCopy$ = -60					; size = 4
_value$552459 = -56					; size = 4
_value$552472 = -52					; size = 4
_vPos$ = -48						; size = 12
_pStage$ = -36						; size = 4
_iter$ = -32						; size = 4
$T551012 = -28						; size = 12
$T551013 = -16						; size = 12
_vTargetPos$551004 = -16				; size = 12
__$ArrayPad$ = -4					; size = 4
_pOwner$ = 8						; size = 4
?CheckTarget@ioDummyTurret2@@IAEXPAVioBaseChar@@@Z PROC	; ioDummyTurret2::CheckTarget, COMDAT
; _this$ = ecx

; 372  : {		

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _pOwner$[ebp]

; 415  : 			continue;
; 416  : 
; 417  : 		//bool bContinue =  false;
; 418  : 		//    .
; 419  : 		/*for( int i = 0; i < (int)m_FiredTargetList.size(); i++ )
; 420  : 		{
; 421  : 			if( pTarget->GetCharName() == m_FiredTargetList[i] )
; 422  : 			{
; 423  : 				bContinue = true;
; 424  : 				break;
; 425  : 			}
; 426  : 		}*/
; 427  : 
; 428  : 		//if( !bContinue )
; 429  : 		{
; 430  : 			CreateWeapon( vPos + D3DXVECTOR3(0.f, m_fFireHeightOffset, 0.f ), D3DXVECTOR3( 0.f, 1.f, 0.f) , pTarget );

  00013	89 4d bc	 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  00016	89 45 c4	 mov	 DWORD PTR _pOwner$GSCopy$[ebp], eax
  00019	85 c0		 test	 eax, eax
  0001b	0f 84 15 02 00
	00		 je	 $LN8@CheckTarge

; 373  : 	if( !pOwner ) 
; 374  : 		return;
; 375  : 
; 376  : 	ioPlayStage *pStage = pOwner->GetCreator();

  00021	53		 push	 ebx
  00022	8b 98 44 03 00
	00		 mov	 ebx, DWORD PTR [eax+836]
  00028	89 5d dc	 mov	 DWORD PTR _pStage$[ebp], ebx

; 377  : 	if ( !pStage )

  0002b	85 db		 test	 ebx, ebx
  0002d	0f 84 02 02 00
	00		 je	 $LN76@CheckTarge

; 378  : 		return;
; 379  : 
; 380  : 	// 
; 381  : 	D3DXVECTOR3 vPos = GetWorldPosition();

  00033	8b 01		 mov	 eax, DWORD PTR [ecx]
  00035	56		 push	 esi
  00036	57		 push	 edi
  00037	ff 50 70	 call	 DWORD PTR [eax+112]
  0003a	8b f0		 mov	 esi, eax
  0003c	8d 7d d0	 lea	 edi, DWORD PTR _vPos$[ebp]
  0003f	a5		 movsd
  00040	a5		 movsd
  00041	a5		 movsd

; 382  : 
; 383  : 	const BaseCharList &rkTargetList = pStage->GetBaseCharList();
; 384  : 
; 385  : 	BaseCharList::const_iterator iter;
; 386  : 	for( iter = rkTargetList.begin(); iter != rkTargetList.end(); ++iter )

  00042	8b 73 2c	 mov	 esi, DWORD PTR [ebx+44]
  00045	3b 73 30	 cmp	 esi, DWORD PTR [ebx+48]
  00048	e9 5c 01 00 00	 jmp	 $LN79@CheckTarge
$LL27@CheckTarge:

; 387  : 	{
; 388  : 		ioBaseChar *pTarget = (*iter);

  0004d	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 389  : 
; 390  : 		if( !pTarget ) 

  0004f	85 db		 test	 ebx, ebx
  00051	0f 84 49 01 00
	00		 je	 $LN9@CheckTarge

; 391  : 			continue;
; 392  : 
; 393  : 		if( pOwner->GetCharName() == pTarget->GetCharName() )

  00057	8b 7d c4	 mov	 edi, DWORD PTR _pOwner$GSCopy$[ebp]
  0005a	8d 83 d4 02 00
	00		 lea	 eax, DWORD PTR [ebx+724]
  00060	50		 push	 eax
  00061	8d 8f d4 02 00
	00		 lea	 ecx, DWORD PTR [edi+724]
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??8ioHashString@@QBE_NABV0@@Z
  0006d	84 c0		 test	 al, al
  0006f	0f 85 2b 01 00
	00		 jne	 $LN9@CheckTarge

; 394  : 			continue;
; 395  : 
; 396  : 		if( pOwner->GetTeam() == pTarget->GetTeam() )	

  00075	8d 45 c8	 lea	 eax, DWORD PTR _value$552459[ebp]
  00078	50		 push	 eax
  00079	8d 8f 90 00 00
	00		 lea	 ecx, DWORD PTR [edi+144]
  0007f	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  00084	8d 45 cc	 lea	 eax, DWORD PTR _value$552472[ebp]
  00087	50		 push	 eax
  00088	8d 8b 90 00 00
	00		 lea	 ecx, DWORD PTR [ebx+144]
  0008e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  00093	8b 45 c8	 mov	 eax, DWORD PTR _value$552459[ebp]
  00096	3b 45 cc	 cmp	 eax, DWORD PTR _value$552472[ebp]
  00099	0f 84 01 01 00
	00		 je	 $LN9@CheckTarge

; 397  : 			continue;
; 398  : 
; 399  : 
; 400  : 		if( pTarget->IsSystemState() )

  0009f	8b cb		 mov	 ecx, ebx
  000a1	e8 00 00 00 00	 call	 ?IsSystemState@ioBaseChar@@QAE_NXZ ; ioBaseChar::IsSystemState
  000a6	84 c0		 test	 al, al
  000a8	0f 85 f2 00 00
	00		 jne	 $LN9@CheckTarge

; 401  : 			continue;
; 402  : 
; 403  : 		if( !pTarget->IsEnableTarget() ) 	

  000ae	6a 01		 push	 1
  000b0	6a 01		 push	 1
  000b2	8b cb		 mov	 ecx, ebx
  000b4	e8 00 00 00 00	 call	 ?IsEnableTarget@ioBaseChar@@QAE_N_N0@Z ; ioBaseChar::IsEnableTarget
  000b9	84 c0		 test	 al, al
  000bb	0f 84 df 00 00
	00		 je	 $LN9@CheckTarge

; 404  : 			continue;
; 405  : 
; 406  : 		D3DXVECTOR3 vTargetPos = pTarget->GetWorldPosition();

  000c1	8b 03		 mov	 eax, DWORD PTR [ebx]
  000c3	8b cb		 mov	 ecx, ebx
  000c5	ff 50 70	 call	 DWORD PTR [eax+112]

; 407  : 		D3DXVECTOR3 vDiff = vTargetPos - vPos;

  000c8	f3 0f 10 4d d0	 movss	 xmm1, DWORD PTR _vPos$[ebp]
  000cd	f3 0f 10 55 d4	 movss	 xmm2, DWORD PTR _vPos$[ebp+4]
  000d2	f3 0f 10 6d d8	 movss	 xmm5, DWORD PTR _vPos$[ebp+8]
  000d7	8b f0		 mov	 esi, eax
  000d9	8d 7d f0	 lea	 edi, DWORD PTR _vTargetPos$551004[ebp]
  000dc	a5		 movsd
  000dd	a5		 movsd
  000de	0f 5a c9	 cvtps2pd xmm1, xmm1
  000e1	a5		 movsd
  000e2	f3 0f 10 5d f0	 movss	 xmm3, DWORD PTR _vTargetPos$551004[ebp]
  000e7	f3 0f 10 65 f8	 movss	 xmm4, DWORD PTR _vTargetPos$551004[ebp+8]

; 408  : 		float fDist = D3DXVec3Length( &vDiff );
; 409  : 
; 410  : 		if( m_fMaxSearchingRange < fDist )

  000ec	8b 75 bc	 mov	 esi, DWORD PTR _this$GSCopy$[ebp]
  000ef	0f 5a c3	 cvtps2pd xmm0, xmm3
  000f2	f2 0f 5c c1	 subsd	 xmm0, xmm1
  000f6	0f 5a d2	 cvtps2pd xmm2, xmm2
  000f9	0f 57 c9	 xorps	 xmm1, xmm1
  000fc	66 0f 5a c8	 cvtpd2ps xmm1, xmm0
  00100	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _vTargetPos$551004[ebp+4]
  00105	0f 5a c0	 cvtps2pd xmm0, xmm0
  00108	f2 0f 5c c2	 subsd	 xmm0, xmm2
  0010c	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00110	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00114	0f 5a d4	 cvtps2pd xmm2, xmm4
  00117	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  0011b	0f 5a ed	 cvtps2pd xmm5, xmm5
  0011e	f2 0f 5c d5	 subsd	 xmm2, xmm5
  00122	f3 0f 10 ae 88
	14 00 00	 movss	 xmm5, DWORD PTR [esi+5256]
  0012a	0f 5a c9	 cvtps2pd xmm1, xmm1
  0012d	66 0f 5a d2	 cvtpd2ps xmm2, xmm2
  00131	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  00135	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00139	0f 57 c0	 xorps	 xmm0, xmm0
  0013c	f3 0f 5a d2	 cvtss2sd xmm2, xmm2
  00140	f2 0f 59 d2	 mulsd	 xmm2, xmm2
  00144	f2 0f 58 ca	 addsd	 xmm1, xmm2
  00148	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  0014c	0f 5a c0	 cvtps2pd xmm0, xmm0
  0014f	f2 0f 51 c0	 sqrtsd	 xmm0, xmm0
  00153	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00157	0f 5a ed	 cvtps2pd xmm5, xmm5
  0015a	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  0015e	66 0f 2f c5	 comisd	 xmm0, xmm5
  00162	77 39		 ja	 SHORT $LN75@CheckTarge

; 411  : 			continue;
; 412  : 
; 413  : 		float fTargetMapHeight = pStage->GetMapHeight( vTargetPos.x, vTargetPos.z );

  00164	0f 57 c0	 xorps	 xmm0, xmm0
  00167	6a 00		 push	 0
  00169	51		 push	 ecx
  0016a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0016f	6a 01		 push	 1
  00171	6a 00		 push	 0
  00173	51		 push	 ecx
  00174	51		 push	 ecx
  00175	8b 4d dc	 mov	 ecx, DWORD PTR _pStage$[ebp]
  00178	f3 0f 11 64 24
	04		 movss	 DWORD PTR [esp+4], xmm4
  0017e	f3 0f 11 1c 24	 movss	 DWORD PTR [esp], xmm3
  00183	e8 00 00 00 00	 call	 ?GetMapHeight@ioPlayStage@@QAEMMMPBVioGameEntity@@_NM1@Z ; ioPlayStage::GetMapHeight
  00188	d9 5d c0	 fstp	 DWORD PTR _fTargetMapHeight$551009[ebp]

; 414  : 		if( (vTargetPos.y - fTargetMapHeight) < m_fFireLandMinRange )

  0018b	d9 45 f4	 fld	 DWORD PTR _vTargetPos$551004[ebp+4]
  0018e	d8 65 c0	 fsub	 DWORD PTR _fTargetMapHeight$551009[ebp]
  00191	d9 86 8c 14 00
	00		 fld	 DWORD PTR [esi+5260]
  00197	df f1		 fcomip	 ST(1)
  00199	dd d8		 fstp	 ST(0)
  0019b	76 17		 jbe	 SHORT $LN1@CheckTarge
$LN75@CheckTarge:
  0019d	8b 75 e0	 mov	 esi, DWORD PTR _iter$[ebp]
$LN9@CheckTarge:

; 382  : 
; 383  : 	const BaseCharList &rkTargetList = pStage->GetBaseCharList();
; 384  : 
; 385  : 	BaseCharList::const_iterator iter;
; 386  : 	for( iter = rkTargetList.begin(); iter != rkTargetList.end(); ++iter )

  001a0	8b 45 dc	 mov	 eax, DWORD PTR _pStage$[ebp]
  001a3	83 c6 04	 add	 esi, 4
  001a6	3b 70 30	 cmp	 esi, DWORD PTR [eax+48]
$LN79@CheckTarge:
  001a9	89 75 e0	 mov	 DWORD PTR _iter$[ebp], esi
  001ac	0f 85 9b fe ff
	ff		 jne	 $LL27@CheckTarge
  001b2	eb 7f		 jmp	 SHORT $LN77@CheckTarge
$LN1@CheckTarge:

; 415  : 			continue;
; 416  : 
; 417  : 		//bool bContinue =  false;
; 418  : 		//    .
; 419  : 		/*for( int i = 0; i < (int)m_FiredTargetList.size(); i++ )
; 420  : 		{
; 421  : 			if( pTarget->GetCharName() == m_FiredTargetList[i] )
; 422  : 			{
; 423  : 				bContinue = true;
; 424  : 				break;
; 425  : 			}
; 426  : 		}*/
; 427  : 
; 428  : 		//if( !bContinue )
; 429  : 		{
; 430  : 			CreateWeapon( vPos + D3DXVECTOR3(0.f, m_fFireHeightOffset, 0.f ), D3DXVECTOR3( 0.f, 1.f, 0.f) , pTarget );

  001b4	f3 0f 10 55 d0	 movss	 xmm2, DWORD PTR _vPos$[ebp]
  001b9	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  001c1	0f 57 c0	 xorps	 xmm0, xmm0
  001c4	f3 0f 11 4d f4	 movss	 DWORD PTR $T551013[ebp+4], xmm1
  001c9	f3 0f 10 8e ac
	14 00 00	 movss	 xmm1, DWORD PTR [esi+5292]
  001d1	0f 5a d2	 cvtps2pd xmm2, xmm2
  001d4	f2 0f 58 15 00
	00 00 00	 addsd	 xmm2, QWORD PTR __real@0000000000000000
  001dc	f2 0f 5a d2	 cvtsd2ss xmm2, xmm2
  001e0	0f 5a c9	 cvtps2pd xmm1, xmm1
  001e3	f3 0f 11 55 e4	 movss	 DWORD PTR $T551012[ebp], xmm2
  001e8	f3 0f 10 55 d4	 movss	 xmm2, DWORD PTR _vPos$[ebp+4]
  001ed	0f 5a d2	 cvtps2pd xmm2, xmm2
  001f0	f2 0f 58 ca	 addsd	 xmm1, xmm2
  001f4	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  001f8	f3 0f 11 4d e8	 movss	 DWORD PTR $T551012[ebp+4], xmm1
  001fd	f3 0f 10 4d d8	 movss	 xmm1, DWORD PTR _vPos$[ebp+8]
  00202	53		 push	 ebx
  00203	8d 45 f0	 lea	 eax, DWORD PTR $T551013[ebp]
  00206	50		 push	 eax
  00207	f3 0f 11 45 f0	 movss	 DWORD PTR $T551013[ebp], xmm0
  0020c	f3 0f 11 45 f8	 movss	 DWORD PTR $T551013[ebp+8], xmm0
  00211	0f 5a c9	 cvtps2pd xmm1, xmm1
  00214	f2 0f 58 0d 00
	00 00 00	 addsd	 xmm1, QWORD PTR __real@0000000000000000
  0021c	8d 45 e4	 lea	 eax, DWORD PTR $T551012[ebp]
  0021f	0f 57 c0	 xorps	 xmm0, xmm0
  00222	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1
  00226	50		 push	 eax
  00227	8b ce		 mov	 ecx, esi
  00229	f3 0f 11 45 ec	 movss	 DWORD PTR $T551012[ebp+8], xmm0
  0022e	e8 00 00 00 00	 call	 ?CreateWeapon@ioDummyTurret2@@IAEXABUD3DXVECTOR3@@0PAVioBaseChar@@@Z ; ioDummyTurret2::CreateWeapon
$LN77@CheckTarge:
  00233	5f		 pop	 edi
  00234	5e		 pop	 esi
$LN76@CheckTarge:
  00235	5b		 pop	 ebx
$LN8@CheckTarge:

; 431  : 			return;
; 432  : 		}
; 433  : 	}
; 434  : }

  00236	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00239	33 cd		 xor	 ecx, ebp
  0023b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00240	c9		 leave
  00241	c2 04 00	 ret	 4
?CheckTarget@ioDummyTurret2@@IAEXPAVioBaseChar@@@Z ENDP	; ioDummyTurret2::CheckTarget
_TEXT	ENDS
PUBLIC	?ProcessSensingState@ioDummyTurret2@@IAEXM@Z	; ioDummyTurret2::ProcessSensingState
; Function compile flags: /Ogsp
;	COMDAT ?ProcessSensingState@ioDummyTurret2@@IAEXM@Z
_TEXT	SEGMENT
_fTimePerSec$ = 8					; size = 4
?ProcessSensingState@ioDummyTurret2@@IAEXM@Z PROC	; ioDummyTurret2::ProcessSensingState, COMDAT
; _this$ = ecx

; 135  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 136  : 	ioBaseChar *pOnwer = GetOwner();

  00004	e8 00 00 00 00	 call	 ?GetOwner@ioDummyChar@@QBEPAVioBaseChar@@XZ ; ioDummyChar::GetOwner
  00009	8b f0		 mov	 esi, eax

; 137  : 
; 138  : 	if( !pOnwer || !pOnwer->IsNeedProcess() )

  0000b	85 f6		 test	 esi, esi
  0000d	74 16		 je	 SHORT $LN1@ProcessSen
  0000f	8b 06		 mov	 eax, DWORD PTR [esi]
  00011	8b ce		 mov	 ecx, esi
  00013	ff 90 00 01 00
	00		 call	 DWORD PTR [eax+256]
  00019	84 c0		 test	 al, al
  0001b	74 08		 je	 SHORT $LN1@ProcessSen

; 139  : 		return;
; 140  : 
; 141  : 	CheckTarget( pOnwer );

  0001d	56		 push	 esi
  0001e	8b cf		 mov	 ecx, edi
  00020	e8 00 00 00 00	 call	 ?CheckTarget@ioDummyTurret2@@IAEXPAVioBaseChar@@@Z ; ioDummyTurret2::CheckTarget
$LN1@ProcessSen:

; 142  : }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	c2 04 00	 ret	 4
?ProcessSensingState@ioDummyTurret2@@IAEXM@Z ENDP	; ioDummyTurret2::ProcessSensingState
_TEXT	ENDS
EXTRN	?SendDieState@ioDummyChar@@QAEX_N@Z:PROC	; ioDummyChar::SendDieState
; Function compile flags: /Ogsp
;	COMDAT ?ProcessState@ioDummyTurret2@@MAEXMK@Z
_TEXT	SEGMENT
_fTimePerSec$ = 8					; size = 4
_dwPreTime$ = 12					; size = 4
?ProcessState@ioDummyTurret2@@MAEXMK@Z PROC		; ioDummyTurret2::ProcessState, COMDAT
; _this$ = ecx

; 57   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f1		 mov	 esi, ecx

; 58   : 	ioBaseChar* pOwner = GetOwner();

  00007	e8 00 00 00 00	 call	 ?GetOwner@ioDummyChar@@QBEPAVioBaseChar@@XZ ; ioDummyChar::GetOwner
  0000c	8b f8		 mov	 edi, eax

; 59   : 	if( !pOwner )

  0000e	85 ff		 test	 edi, edi
  00010	75 10		 jne	 SHORT $LN11@ProcessSta@2

; 60   : 	{
; 61   : 		SetDieState( false );

  00012	8b 06		 mov	 eax, DWORD PTR [esi]
  00014	57		 push	 edi
  00015	8b ce		 mov	 ecx, esi
  00017	ff 90 60 01 00
	00		 call	 DWORD PTR [eax+352]

; 62   : 		return;

  0001d	e9 bf 00 00 00	 jmp	 $LN1@ProcessSta@2
$LN11@ProcessSta@2:
  00022	53		 push	 ebx

; 63   : 	}
; 64   : 
; 65   : 	DWORD dwCurTime = FRAMEGETTIME();

  00023	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  00029	ff d3		 call	 ebx
  0002b	8b c8		 mov	 ecx, eax
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ

; 66   : 
; 67   : 	switch( m_TurretState )

  00033	8b 8e 80 14 00
	00		 mov	 ecx, DWORD PTR [esi+5248]
  00039	83 e9 00	 sub	 ecx, 0
  0003c	74 5b		 je	 SHORT $LN8@ProcessSta@2
  0003e	49		 dec	 ecx
  0003f	74 28		 je	 SHORT $LN7@ProcessSta@2
  00041	49		 dec	 ecx
  00042	74 11		 je	 SHORT $LN4@ProcessSta@2
  00044	49		 dec	 ecx
  00045	75 64		 jne	 SHORT $LN9@ProcessSta@2

; 92   : 	case DMS_END:
; 93   : 		SetDieState( true );	

  00047	8b 06		 mov	 eax, DWORD PTR [esi]
  00049	6a 01		 push	 1
  0004b	8b ce		 mov	 ecx, esi
  0004d	ff 90 60 01 00
	00		 call	 DWORD PTR [eax+352]

; 94   : 		break;

  00053	eb 56		 jmp	 SHORT $LN9@ProcessSta@2
$LN4@ProcessSta@2:

; 85   : 	case DMS_FIRE:
; 86   : 		if( dwCurTime > m_dwNextFireTime )

  00055	3b 86 b4 14 00
	00		 cmp	 eax, DWORD PTR [esi+5300]
  0005b	76 4e		 jbe	 SHORT $LN9@ProcessSta@2

; 87   : 		{
; 88   : 			m_TurretState = DMS_SENSING;

  0005d	c7 86 80 14 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+5248], 1

; 89   : 		}
; 90   : 
; 91   : 		break;

  00067	eb 42		 jmp	 SHORT $LN9@ProcessSta@2
$LN7@ProcessSta@2:

; 71   : 		break;
; 72   : 	case DMS_SENSING:
; 73   : 		if( pOwner->IsNeedProcess() )

  00069	8b 07		 mov	 eax, DWORD PTR [edi]
  0006b	8b cf		 mov	 ecx, edi
  0006d	ff 90 00 01 00
	00		 call	 DWORD PTR [eax+256]
  00073	84 c0		 test	 al, al
  00075	74 34		 je	 SHORT $LN9@ProcessSta@2

; 74   : 		{
; 75   : 			if( m_nCurBullet >= m_nMaxBullet )

  00077	8b 86 a8 14 00
	00		 mov	 eax, DWORD PTR [esi+5288]
  0007d	3b 86 a4 14 00
	00		 cmp	 eax, DWORD PTR [esi+5284]

; 76   : 			{
; 77   : 				SendDieState( true );
; 78   : 				return;

  00083	7d 52		 jge	 SHORT $LN15@ProcessSta@2

; 79   : 			}
; 80   : 
; 81   : 			ProcessSensingState( fTimePerSec );

  00085	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fTimePerSec$[ebp]
  0008a	51		 push	 ecx
  0008b	8b ce		 mov	 ecx, esi
  0008d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00092	e8 00 00 00 00	 call	 ?ProcessSensingState@ioDummyTurret2@@IAEXM@Z ; ioDummyTurret2::ProcessSensingState

; 82   : 		}
; 83   : 
; 84   : 		break;

  00097	eb 12		 jmp	 SHORT $LN9@ProcessSta@2
$LN8@ProcessSta@2:

; 68   : 	{
; 69   : 	case DMS_START:
; 70   : 		ProcessStartState( fTimePerSec );

  00099	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fTimePerSec$[ebp]
  0009e	51		 push	 ecx
  0009f	8b ce		 mov	 ecx, esi
  000a1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a6	e8 00 00 00 00	 call	 ?ProcessStartState@ioDummyTurret2@@IAEXM@Z ; ioDummyTurret2::ProcessStartState
$LN9@ProcessSta@2:

; 95   : 	}
; 96   : 
; 97   : 	if( m_dwLifeTime && (DWORD)(m_dwStartTime + m_dwLifeTime) < FRAMEGETTIME() && m_State != DCS_DIE )

  000ab	83 be 10 0b 00
	00 00		 cmp	 DWORD PTR [esi+2832], 0
  000b2	74 2c		 je	 SHORT $LN14@ProcessSta@2
  000b4	ff d3		 call	 ebx
  000b6	8b c8		 mov	 ecx, eax
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ
  000be	8b 8e 14 0b 00
	00		 mov	 ecx, DWORD PTR [esi+2836]
  000c4	03 8e 10 0b 00
	00		 add	 ecx, DWORD PTR [esi+2832]
  000ca	3b c8		 cmp	 ecx, eax
  000cc	73 12		 jae	 SHORT $LN14@ProcessSta@2
  000ce	83 be 30 02 00
	00 06		 cmp	 DWORD PTR [esi+560], 6
  000d5	74 09		 je	 SHORT $LN14@ProcessSta@2
$LN15@ProcessSta@2:

; 98   : 		SendDieState( true );

  000d7	6a 01		 push	 1
  000d9	8b ce		 mov	 ecx, esi
  000db	e8 00 00 00 00	 call	 ?SendDieState@ioDummyChar@@QAEX_N@Z ; ioDummyChar::SendDieState
$LN14@ProcessSta@2:
  000e0	5b		 pop	 ebx
$LN1@ProcessSta@2:
  000e1	5f		 pop	 edi
  000e2	5e		 pop	 esi

; 99   : }

  000e3	5d		 pop	 ebp
  000e4	c2 08 00	 ret	 8
?ProcessState@ioDummyTurret2@@MAEXMK@Z ENDP		; ioDummyTurret2::ProcessState
_TEXT	ENDS
END
