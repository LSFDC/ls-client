; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\Lost Saga For Developer\Youtube\Tutorial\Source\src\LSClient\ioHPStealBuff.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ	; ioBaseChar::GetCharName
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasechar.h
;	COMDAT ?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ
_TEXT	SEGMENT
?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ PROC	; ioBaseChar::GetCharName, COMDAT
; _this$ = ecx

; 2594 : 	inline const ioHashString& GetCharName() const { return m_Name; }

  00000	8d 81 d4 02 00
	00		 lea	 eax, DWORD PTR [ecx+724]
  00006	c3		 ret	 0
?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ ENDP	; ioBaseChar::GetCharName
_TEXT	ENDS
PUBLIC	??_7ioHPStealBuff@@6B@				; ioHPStealBuff::`vftable'
PUBLIC	??0ioHPStealBuff@@QAE@XZ			; ioHPStealBuff::ioHPStealBuff
PUBLIC	??_R4ioHPStealBuff@@6B@				; ioHPStealBuff::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVioHPStealBuff@@@8			; ioHPStealBuff `RTTI Type Descriptor'
PUBLIC	??_R3ioHPStealBuff@@8				; ioHPStealBuff::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioHPStealBuff@@8				; ioHPStealBuff::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ioHPStealBuff@@8			; ioHPStealBuff::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ioBuff@@8				; ioBuff::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVioBuff@@@8				; ioBuff `RTTI Type Descriptor'
PUBLIC	??_R3ioBuff@@8					; ioBuff::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioBuff@@8					; ioBuff::`RTTI Base Class Array'
PUBLIC	?LoadProperty@ioHPStealBuff@@UAEXAAVioINILoader@@@Z ; ioHPStealBuff::LoadProperty
PUBLIC	?Clone@ioHPStealBuff@@UAEPAVioBuff@@XZ		; ioHPStealBuff::Clone
PUBLIC	?StartBuff@ioHPStealBuff@@UAEXPAVioBaseChar@@@Z	; ioHPStealBuff::StartBuff
PUBLIC	?ApplyStartBuff@ioHPStealBuff@@UAE_NPAVioBaseChar@@KK@Z ; ioHPStealBuff::ApplyStartBuff
PUBLIC	?ProcessBuff@ioHPStealBuff@@UAEXM@Z		; ioHPStealBuff::ProcessBuff
PUBLIC	?EndBuff@ioHPStealBuff@@UAEXXZ			; ioHPStealBuff::EndBuff
PUBLIC	?IsWaitSelfRemove@ioBuff@@UAE_NXZ		; ioBuff::IsWaitSelfRemove
EXTRN	??1ioBuff@@UAE@XZ:PROC				; ioBuff::~ioBuff
EXTRN	__imp_??0ioHashString@@QAE@XZ:PROC
EXTRN	??0ioBuff@@QAE@XZ:PROC				; ioBuff::ioBuff
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__EH_epilog3:PROC
EXTRN	__EH_prolog3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?StartBuffWithAniTime@ioBuff@@UAEXPAVioBaseChar@@K@Z:PROC ; ioBuff::StartBuffWithAniTime
EXTRN	?CancelBuff@ioBuff@@UAEXXZ:PROC			; ioBuff::CancelBuff
EXTRN	?GetBuffInfo@ioBuff@@UAEXAAVSP2Packet@@@Z:PROC	; ioBuff::GetBuffInfo
EXTRN	?ApplyBuffInfo@ioBuff@@UAEXAAVSP2Packet@@@Z:PROC ; ioBuff::ApplyBuffInfo
EXTRN	?AccumulateBuff@ioBuff@@UAEXXZ:PROC		; ioBuff::AccumulateBuff
EXTRN	?IsLiveButStopped@ioBuff@@UBE_NXZ:PROC		; ioBuff::IsLiveButStopped
EXTRN	?IsCanJumpAttack@ioBuff@@UBE_NXZ:PROC		; ioBuff::IsCanJumpAttack
EXTRN	?SetAction@ioBuff@@MAEXXZ:PROC			; ioBuff::SetAction
EXTRN	?ProcessDelay@ioBuff@@MAEXM@Z:PROC		; ioBuff::ProcessDelay
EXTRN	?SetExtraDurationByGrowth@ioBuff@@UAEXM@Z:PROC	; ioBuff::SetExtraDurationByGrowth
EXTRN	?SetWeaponIndex@ioBuff@@UAEXK@Z:PROC		; ioBuff::SetWeaponIndex
EXTRN	?OnReduceGauge@ioBuff@@UBE_NXZ:PROC		; ioBuff::OnReduceGauge
EXTRN	?IsCharCollisionSkip@ioBuff@@UBE_NXZ:PROC	; ioBuff::IsCharCollisionSkip
EXTRN	?IsCollisionAvailableWeapon@ioBuff@@UBE_NXZ:PROC ; ioBuff::IsCollisionAvailableWeapon
EXTRN	?IsProtected@ioBuff@@UBE_NXZ:PROC		; ioBuff::IsProtected
EXTRN	?UseActiveCount@ioBuff@@UBE_NXZ:PROC		; ioBuff::UseActiveCount
EXTRN	?CheckActiveCount@ioBuff@@UAEXXZ:PROC		; ioBuff::CheckActiveCount
EXTRN	?CheckRemoveEquipSkillBuff@ioBuff@@UAEX_N@Z:PROC ; ioBuff::CheckRemoveEquipSkillBuff
EXTRN	?ApplyExtraBuffInfo@ioBuff@@UAEXAAVSP2Packet@@@Z:PROC ; ioBuff::ApplyExtraBuffInfo
EXTRN	?SetBuffGrapplingState@ioBuff@@UAE_NPAVioBaseChar@@ABVioHashString@@@Z:PROC ; ioBuff::SetBuffGrapplingState
EXTRN	?GetGrapplingTargetPos@ioBuff@@UAE?AUD3DXVECTOR3@@PAVioBaseChar@@@Z:PROC ; ioBuff::GetGrapplingTargetPos
EXTRN	??_EioHPStealBuff@@UAEPAXI@Z:PROC		; ioHPStealBuff::`vector deleting destructor'
;	COMDAT ??_R2ioBuff@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iohpstealbuff.cpp
rdata$r	SEGMENT
??_R2ioBuff@@8 DD FLAT:??_R1A@?0A@EA@ioBuff@@8		; ioBuff::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ioBuff@@8
rdata$r	SEGMENT
??_R3ioBuff@@8 DD 00H					; ioBuff::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ioBuff@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioBuff@@@8
_DATA	SEGMENT
??_R0?AVioBuff@@@8 DD FLAT:??_7type_info@@6B@		; ioBuff `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioBuff@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@ioBuff@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioBuff@@8 DD FLAT:??_R0?AVioBuff@@@8	; ioBuff::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioBuff@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ioHPStealBuff@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioHPStealBuff@@8 DD FLAT:??_R0?AVioHPStealBuff@@@8 ; ioHPStealBuff::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioHPStealBuff@@8
rdata$r	ENDS
;	COMDAT ??_R2ioHPStealBuff@@8
rdata$r	SEGMENT
??_R2ioHPStealBuff@@8 DD FLAT:??_R1A@?0A@EA@ioHPStealBuff@@8 ; ioHPStealBuff::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ioBuff@@8
rdata$r	ENDS
;	COMDAT ??_R3ioHPStealBuff@@8
rdata$r	SEGMENT
??_R3ioHPStealBuff@@8 DD 00H				; ioHPStealBuff::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ioHPStealBuff@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioHPStealBuff@@@8
_DATA	SEGMENT
??_R0?AVioHPStealBuff@@@8 DD FLAT:??_7type_info@@6B@	; ioHPStealBuff `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioHPStealBuff@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ioHPStealBuff@@6B@
rdata$r	SEGMENT
??_R4ioHPStealBuff@@6B@ DD 00H				; ioHPStealBuff::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVioHPStealBuff@@@8
	DD	FLAT:??_R3ioHPStealBuff@@8
rdata$r	ENDS
;	COMDAT ??_7ioHPStealBuff@@6B@
CONST	SEGMENT
??_7ioHPStealBuff@@6B@ DD FLAT:??_R4ioHPStealBuff@@6B@	; ioHPStealBuff::`vftable'
	DD	FLAT:?LoadProperty@ioHPStealBuff@@UAEXAAVioINILoader@@@Z
	DD	FLAT:?Clone@ioHPStealBuff@@UAEPAVioBuff@@XZ
	DD	FLAT:?StartBuff@ioHPStealBuff@@UAEXPAVioBaseChar@@@Z
	DD	FLAT:?StartBuffWithAniTime@ioBuff@@UAEXPAVioBaseChar@@K@Z
	DD	FLAT:?ApplyStartBuff@ioHPStealBuff@@UAE_NPAVioBaseChar@@KK@Z
	DD	FLAT:?ProcessBuff@ioHPStealBuff@@UAEXM@Z
	DD	FLAT:?EndBuff@ioHPStealBuff@@UAEXXZ
	DD	FLAT:?CancelBuff@ioBuff@@UAEXXZ
	DD	FLAT:?GetBuffInfo@ioBuff@@UAEXAAVSP2Packet@@@Z
	DD	FLAT:?ApplyBuffInfo@ioBuff@@UAEXAAVSP2Packet@@@Z
	DD	FLAT:?AccumulateBuff@ioBuff@@UAEXXZ
	DD	FLAT:?IsLiveButStopped@ioBuff@@UBE_NXZ
	DD	FLAT:?IsCanJumpAttack@ioBuff@@UBE_NXZ
	DD	FLAT:?SetAction@ioBuff@@MAEXXZ
	DD	FLAT:?ProcessDelay@ioBuff@@MAEXM@Z
	DD	FLAT:?SetExtraDurationByGrowth@ioBuff@@UAEXM@Z
	DD	FLAT:?SetWeaponIndex@ioBuff@@UAEXK@Z
	DD	FLAT:?OnReduceGauge@ioBuff@@UBE_NXZ
	DD	FLAT:?IsCharCollisionSkip@ioBuff@@UBE_NXZ
	DD	FLAT:?IsCollisionAvailableWeapon@ioBuff@@UBE_NXZ
	DD	FLAT:?IsProtected@ioBuff@@UBE_NXZ
	DD	FLAT:?UseActiveCount@ioBuff@@UBE_NXZ
	DD	FLAT:?CheckActiveCount@ioBuff@@UAEXXZ
	DD	FLAT:?CheckRemoveEquipSkillBuff@ioBuff@@UAEX_N@Z
	DD	FLAT:?ApplyExtraBuffInfo@ioBuff@@UAEXAAVSP2Packet@@@Z
	DD	FLAT:?SetBuffGrapplingState@ioBuff@@UAE_NPAVioBaseChar@@ABVioHashString@@@Z
	DD	FLAT:?GetGrapplingTargetPos@ioBuff@@UAE?AUD3DXVECTOR3@@PAVioBaseChar@@@Z
	DD	FLAT:?IsWaitSelfRemove@ioBuff@@UAE_NXZ
	DD	FLAT:??_EioHPStealBuff@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ioHPStealBuff@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ioHPStealBuff@@QAE@XZ$0
__ehfuncinfo$??0ioHPStealBuff@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0ioHPStealBuff@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??0ioHPStealBuff@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0ioHPStealBuff@@QAE@XZ PROC				; ioHPStealBuff::ioHPStealBuff, COMDAT
; _this$ = ecx

; 10   : {

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0ioHPStealBuff@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	e8 00 00 00 00	 call	 ??0ioBuff@@QAE@XZ	; ioBuff::ioBuff
  00016	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0001a	8d 8e 84 09 00
	00		 lea	 ecx, DWORD PTR [esi+2436]
  00020	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioHPStealBuff@@6B@
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ

; 11   : 	m_bGetEffectUse = false;

  0002c	c6 86 94 09 00
	00 00		 mov	 BYTE PTR [esi+2452], 0

; 12   : }

  00033	8b c6		 mov	 eax, esi
  00035	e8 00 00 00 00	 call	 __EH_epilog3
  0003a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ioHPStealBuff@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1ioBuff@@UAE@XZ	; ioBuff::~ioBuff
__ehhandler$??0ioHPStealBuff@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ioHPStealBuff@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ioHPStealBuff@@QAE@XZ ENDP				; ioHPStealBuff::ioHPStealBuff
PUBLIC	??0ioHPStealBuff@@QAE@ABV0@@Z			; ioHPStealBuff::ioHPStealBuff
EXTRN	__imp_??0ioHashString@@QAE@ABV0@@Z:PROC
EXTRN	??0ioBuff@@QAE@ABV0@@Z:PROC			; ioBuff::ioBuff
EXTRN	__fltused:DWORD
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ioHPStealBuff@@QAE@ABV0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ioHPStealBuff@@QAE@ABV0@@Z$0
__ehfuncinfo$??0ioHPStealBuff@@QAE@ABV0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0ioHPStealBuff@@QAE@ABV0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??0ioHPStealBuff@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_rhs$ = 8						; size = 4
??0ioHPStealBuff@@QAE@ABV0@@Z PROC			; ioHPStealBuff::ioHPStealBuff, COMDAT
; _this$ = ecx

; 22   : {

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0ioHPStealBuff@@QAE@ABV0@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	8b 7d 08	 mov	 edi, DWORD PTR _rhs$[ebp]
  00014	57		 push	 edi
  00015	e8 00 00 00 00	 call	 ??0ioBuff@@QAE@ABV0@@Z	; ioBuff::ioBuff
  0001a	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0001e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioHPStealBuff@@6B@
  00024	d9 87 6c 09 00
	00		 fld	 DWORD PTR [edi+2412]
  0002a	d9 9e 6c 09 00
	00		 fstp	 DWORD PTR [esi+2412]
  00030	81 c7 84 09 00
	00		 add	 edi, 2436		; 00000984H
  00036	d9 47 ec	 fld	 DWORD PTR [edi-20]
  00039	57		 push	 edi
  0003a	d9 9e 70 09 00
	00		 fstp	 DWORD PTR [esi+2416]
  00040	8d 8e 84 09 00
	00		 lea	 ecx, DWORD PTR [esi+2436]
  00046	d9 47 f0	 fld	 DWORD PTR [edi-16]
  00049	d9 9e 74 09 00
	00		 fstp	 DWORD PTR [esi+2420]
  0004f	8a 47 f4	 mov	 al, BYTE PTR [edi-12]
  00052	88 86 78 09 00
	00		 mov	 BYTE PTR [esi+2424], al
  00058	8b 47 f8	 mov	 eax, DWORD PTR [edi-8]
  0005b	89 86 7c 09 00
	00		 mov	 DWORD PTR [esi+2428], eax
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z

; 23   : 	m_bGetEffectUse = false;

  00067	c6 86 94 09 00
	00 00		 mov	 BYTE PTR [esi+2452], 0

; 24   : }

  0006e	8b c6		 mov	 eax, esi
  00070	e8 00 00 00 00	 call	 __EH_epilog3
  00075	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ioHPStealBuff@@QAE@ABV0@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1ioBuff@@UAE@XZ	; ioBuff::~ioBuff
__ehhandler$??0ioHPStealBuff@@QAE@ABV0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ioHPStealBuff@@QAE@ABV0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ioHPStealBuff@@QAE@ABV0@@Z ENDP			; ioHPStealBuff::ioHPStealBuff
PUBLIC	??1ioHPStealBuff@@UAE@XZ			; ioHPStealBuff::~ioHPStealBuff
EXTRN	__imp_??1ioHashString@@QAE@XZ:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1ioHPStealBuff@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1ioHPStealBuff@@UAE@XZ$0
__ehfuncinfo$??1ioHPStealBuff@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1ioHPStealBuff@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??1ioHPStealBuff@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1ioHPStealBuff@@UAE@XZ PROC				; ioHPStealBuff::~ioHPStealBuff, COMDAT
; _this$ = ecx

; 27   : {

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??1ioHPStealBuff@@UAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioHPStealBuff@@6B@
  00017	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 28   : }

  0001b	8d 8e 84 09 00
	00		 lea	 ecx, DWORD PTR [esi+2436]
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00027	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0002b	8b ce		 mov	 ecx, esi
  0002d	e8 00 00 00 00	 call	 ??1ioBuff@@UAE@XZ	; ioBuff::~ioBuff
  00032	e8 00 00 00 00	 call	 __EH_epilog3
  00037	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1ioHPStealBuff@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1ioBuff@@UAE@XZ	; ioBuff::~ioBuff
__ehhandler$??1ioHPStealBuff@@UAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1ioHPStealBuff@@UAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1ioHPStealBuff@@UAE@XZ ENDP				; ioHPStealBuff::~ioHPStealBuff
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Clone@ioHPStealBuff@@UAEPAVioBuff@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Clone@ioHPStealBuff@@UAEPAVioBuff@@XZ$0
__ehfuncinfo$?Clone@ioHPStealBuff@@UAEPAVioBuff@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Clone@ioHPStealBuff@@UAEPAVioBuff@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ?Clone@ioHPStealBuff@@UAEPAVioBuff@@XZ
_TEXT	SEGMENT
$T525191 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Clone@ioHPStealBuff@@UAEPAVioBuff@@XZ PROC		; ioHPStealBuff::Clone, COMDAT
; _this$ = ecx

; 48   : {

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?Clone@ioHPStealBuff@@UAEPAVioBuff@@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx

; 49   : 	return new ioHPStealBuff( *this );

  0000e	68 98 09 00 00	 push	 2456			; 00000998H
  00013	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00018	59		 pop	 ecx
  00019	8b c8		 mov	 ecx, eax
  0001b	89 4d f0	 mov	 DWORD PTR $T525191[ebp], ecx
  0001e	33 c0		 xor	 eax, eax
  00020	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], eax
  00023	3b c8		 cmp	 ecx, eax
  00025	74 06		 je	 SHORT $LN3@Clone
  00027	56		 push	 esi
  00028	e8 00 00 00 00	 call	 ??0ioHPStealBuff@@QAE@ABV0@@Z ; ioHPStealBuff::ioHPStealBuff
$LN3@Clone:

; 50   : }

  0002d	e8 00 00 00 00	 call	 __EH_epilog3
  00032	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Clone@ioHPStealBuff@@UAEPAVioBuff@@XZ$0:
  00000	ff 75 f0	 push	 DWORD PTR $T525191[ebp]
  00003	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00008	59		 pop	 ecx
  00009	c3		 ret	 0
__ehhandler$?Clone@ioHPStealBuff@@UAEPAVioBuff@@XZ:
  0000a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00011	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00014	33 c8		 xor	 ecx, eax
  00016	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Clone@ioHPStealBuff@@UAEPAVioBuff@@XZ
  00020	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Clone@ioHPStealBuff@@UAEPAVioBuff@@XZ ENDP		; ioHPStealBuff::Clone
EXTRN	__imp_?GetLoopSec@ioFrameTimer@@QBEKXZ:PROC
EXTRN	__imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ:PROC
EXTRN	?StartBuff@ioBuff@@UAEXPAVioBaseChar@@@Z:PROC	; ioBuff::StartBuff
; Function compile flags: /Ogsp
;	COMDAT ?StartBuff@ioHPStealBuff@@UAEXPAVioBaseChar@@@Z
_TEXT	SEGMENT
_pOwner$ = 8						; size = 4
?StartBuff@ioHPStealBuff@@UAEXPAVioBaseChar@@@Z PROC	; ioHPStealBuff::StartBuff, COMDAT
; _this$ = ecx

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 54   : 	ioBuff::StartBuff( pOwner );

  00004	ff 75 08	 push	 DWORD PTR _pOwner$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	e8 00 00 00 00	 call	 ?StartBuff@ioBuff@@UAEXPAVioBaseChar@@@Z ; ioBuff::StartBuff

; 55   : 	
; 56   : 	m_dwCheckTicTime = FRAMEGETTIME();

  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  00014	8b c8		 mov	 ecx, eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ
  0001c	89 86 80 09 00
	00		 mov	 DWORD PTR [esi+2432], eax

; 57   : 
; 58   : 	m_bGetEffectUse = false;

  00022	c6 86 94 09 00
	00 00		 mov	 BYTE PTR [esi+2452], 0
  00029	5e		 pop	 esi

; 59   : }

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?StartBuff@ioHPStealBuff@@UAEXPAVioBaseChar@@@Z ENDP	; ioHPStealBuff::StartBuff
_TEXT	ENDS
EXTRN	?EndBuff@ioBuff@@UAEXXZ:PROC			; ioBuff::EndBuff
; Function compile flags: /Ogsp
;	COMDAT ?EndBuff@ioHPStealBuff@@UAEXXZ
_TEXT	SEGMENT
?EndBuff@ioHPStealBuff@@UAEXXZ PROC			; ioHPStealBuff::EndBuff, COMDAT
; _this$ = ecx

; 209  : 	/*
; 210  : 	ioBaseChar *pCreator = m_pOwner->GetBaseChar( m_CreateChar );
; 211  : 	if( pCreator && m_bGetEffectUse && !m_GetEffect.IsEmpty() )
; 212  : 	{
; 213  : 		pCreator->EndEffect( m_GetEffect, false );
; 214  : 		m_bGetEffectUse = false;
; 215  : 	}
; 216  : 	*/
; 217  : 
; 218  : 	if( m_bGetEffectUse )

  00000	80 b9 94 09 00
	00 00		 cmp	 BYTE PTR [ecx+2452], 0
  00007	74 07		 je	 SHORT $LN1@EndBuff

; 219  : 		m_bGetEffectUse = false;

  00009	c6 81 94 09 00
	00 00		 mov	 BYTE PTR [ecx+2452], 0
$LN1@EndBuff:

; 220  : 
; 221  : 	ioBuff::EndBuff();

  00010	e9 00 00 00 00	 jmp	 ?EndBuff@ioBuff@@UAEXXZ	; ioBuff::EndBuff
?EndBuff@ioHPStealBuff@@UAEXXZ ENDP			; ioHPStealBuff::EndBuff
_TEXT	ENDS
PUBLIC	?_DECSTR@@YAXPADH@Z				; _DECSTR
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stringprotect.h
;	COMDAT ?_DECSTR@@YAXPADH@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_l$ = 12						; size = 4
?_DECSTR@@YAXPADH@Z PROC				; _DECSTR, COMDAT

; 40   : __forceinline void _DECSTR(char* s, int l){int i=0,l4=(l-1)/4,*p=(int*)s;s[l-1]=0;for(;i<l4;++i)*(p++)^=0xEAEBECED;for(i=l4*4;i<l-1;++i)s[i]^=0xED-i%4;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _l$[ebp]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  0000a	57		 push	 edi
  0000b	8d 79 ff	 lea	 edi, DWORD PTR [ecx-1]
  0000e	8b c7		 mov	 eax, edi
  00010	99		 cdq
  00011	83 e2 03	 and	 edx, 3
  00014	03 c2		 add	 eax, edx
  00016	c1 f8 02	 sar	 eax, 2
  00019	8b d6		 mov	 edx, esi
  0001b	c6 44 0e ff 00	 mov	 BYTE PTR [esi+ecx-1], 0
  00020	85 c0		 test	 eax, eax
  00022	7e 0e		 jle	 SHORT $LN4@DECSTR
  00024	8b c8		 mov	 ecx, eax
$LL6@DECSTR:
  00026	81 32 ed ec eb
	ea		 xor	 DWORD PTR [edx], -353637139 ; eaebecedH
  0002c	83 c2 04	 add	 edx, 4
  0002f	49		 dec	 ecx
  00030	75 f4		 jne	 SHORT $LL6@DECSTR
$LN4@DECSTR:
  00032	c1 e0 02	 shl	 eax, 2
  00035	eb 17		 jmp	 SHORT $LN14@DECSTR
$LL3@DECSTR:
  00037	8b c8		 mov	 ecx, eax
  00039	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0003f	79 05		 jns	 SHORT $LN13@DECSTR
  00041	49		 dec	 ecx
  00042	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00045	41		 inc	 ecx
$LN13@DECSTR:
  00046	b2 ed		 mov	 dl, -19			; ffffffedH
  00048	2a d1		 sub	 dl, cl
  0004a	30 14 30	 xor	 BYTE PTR [eax+esi], dl
  0004d	40		 inc	 eax
$LN14@DECSTR:
  0004e	3b c7		 cmp	 eax, edi
  00050	7c e5		 jl	 SHORT $LL3@DECSTR
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?_DECSTR@@YAXPADH@Z ENDP				; _DECSTR
_TEXT	ENDS
PUBLIC	?GetHP@ioPlayEntity@@QAEAAUStatusValue@@XZ	; ioPlayEntity::GetHP
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioplayentity.h
;	COMDAT ?GetHP@ioPlayEntity@@QAEAAUStatusValue@@XZ
_TEXT	SEGMENT
?GetHP@ioPlayEntity@@QAEAAUStatusValue@@XZ PROC		; ioPlayEntity::GetHP, COMDAT
; _this$ = ecx

; 96   : 	inline StatusValue& GetHP() { return m_HP; }

  00000	8d 81 c0 00 00
	00		 lea	 eax, DWORD PTR [ecx+192]
  00006	c3		 ret	 0
?GetHP@ioPlayEntity@@QAEAAUStatusValue@@XZ ENDP		; ioPlayEntity::GetHP
_TEXT	ENDS
PUBLIC	?GetName@ioItem@@QBEABVioHashString@@XZ		; ioItem::GetName
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioitem.h
;	COMDAT ?GetName@ioItem@@QBEABVioHashString@@XZ
_TEXT	SEGMENT
?GetName@ioItem@@QBEABVioHashString@@XZ PROC		; ioItem::GetName, COMDAT
; _this$ = ecx

; 269  : 	inline const ioHashString& GetName() const { return m_Name; }

  00000	8d 81 34 01 00
	00		 lea	 eax, DWORD PTR [ecx+308]
  00006	c3		 ret	 0
?GetName@ioItem@@QBEABVioHashString@@XZ ENDP		; ioItem::GetName
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobuff.h
_TEXT	ENDS
;	COMDAT ?IsWaitSelfRemove@ioBuff@@UAE_NXZ
_TEXT	SEGMENT
?IsWaitSelfRemove@ioBuff@@UAE_NXZ PROC			; ioBuff::IsWaitSelfRemove, COMDAT
; _this$ = ecx

; 519  : 	virtual bool IsWaitSelfRemove() { return m_bWaitSelfRemove; }

  00000	8a 81 65 09 00
	00		 mov	 al, BYTE PTR [ecx+2405]
  00006	c3		 ret	 0
?IsWaitSelfRemove@ioBuff@@UAE_NXZ ENDP			; ioBuff::IsWaitSelfRemove
_TEXT	ENDS
PUBLIC	??_7?$CEncrypt@M@@6B@				; CEncrypt<float>::`vftable'
PUBLIC	??1?$CEncrypt@M@@UAE@XZ				; CEncrypt<float>::~CEncrypt<float>
PUBLIC	??_R4?$CEncrypt@M@@6B@				; CEncrypt<float>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CEncrypt@M@@@8			; CEncrypt<float> `RTTI Type Descriptor'
PUBLIC	??_R3?$CEncrypt@M@@8				; CEncrypt<float>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CEncrypt@M@@8				; CEncrypt<float>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CEncrypt@M@@8			; CEncrypt<float>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??1ccddaabb@@UAE@XZ:PROC			; ccddaabb::~ccddaabb
EXTRN	??_E?$CEncrypt@M@@UAEPAXI@Z:PROC		; CEncrypt<float>::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$CEncrypt@M@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CEncrypt@M@@8 DD FLAT:??_R0?AV?$CEncrypt@M@@@8 ; CEncrypt<float>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CEncrypt@M@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CEncrypt@M@@8
rdata$r	SEGMENT
??_R2?$CEncrypt@M@@8 DD FLAT:??_R1A@?0A@EA@?$CEncrypt@M@@8 ; CEncrypt<float>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CEncrypt@M@@8
rdata$r	SEGMENT
??_R3?$CEncrypt@M@@8 DD 00H				; CEncrypt<float>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CEncrypt@M@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CEncrypt@M@@@8
_DATA	SEGMENT
??_R0?AV?$CEncrypt@M@@@8 DD FLAT:??_7type_info@@6B@	; CEncrypt<float> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CEncrypt@M@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$CEncrypt@M@@6B@
rdata$r	SEGMENT
??_R4?$CEncrypt@M@@6B@ DD 00H				; CEncrypt<float>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CEncrypt@M@@@8
	DD	FLAT:??_R3?$CEncrypt@M@@8
rdata$r	ENDS
;	COMDAT ??_7?$CEncrypt@M@@6B@
CONST	SEGMENT
??_7?$CEncrypt@M@@6B@ DD FLAT:??_R4?$CEncrypt@M@@6B@	; CEncrypt<float>::`vftable'
	DD	FLAT:??_E?$CEncrypt@M@@UAEPAXI@Z
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??1?$CEncrypt@M@@UAE@XZ
_TEXT	SEGMENT
??1?$CEncrypt@M@@UAE@XZ PROC				; CEncrypt<float>::~CEncrypt<float>, COMDAT
; _this$ = ecx

; 127  : 	{

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CEncrypt@M@@6B@

; 128  : 	}

  00006	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00009	e9 00 00 00 00	 jmp	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
??1?$CEncrypt@M@@UAE@XZ ENDP				; CEncrypt<float>::~CEncrypt<float>
_TEXT	ENDS
PUBLIC	??_7?$CEncrypt@K@@6B@				; CEncrypt<unsigned long>::`vftable'
PUBLIC	??1?$CEncrypt@K@@UAE@XZ				; CEncrypt<unsigned long>::~CEncrypt<unsigned long>
PUBLIC	??_R4?$CEncrypt@K@@6B@				; CEncrypt<unsigned long>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CEncrypt@K@@@8			; CEncrypt<unsigned long> `RTTI Type Descriptor'
PUBLIC	??_R3?$CEncrypt@K@@8				; CEncrypt<unsigned long>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CEncrypt@K@@8				; CEncrypt<unsigned long>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CEncrypt@K@@8			; CEncrypt<unsigned long>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_E?$CEncrypt@K@@UAEPAXI@Z:PROC		; CEncrypt<unsigned long>::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$CEncrypt@K@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CEncrypt@K@@8 DD FLAT:??_R0?AV?$CEncrypt@K@@@8 ; CEncrypt<unsigned long>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CEncrypt@K@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CEncrypt@K@@8
rdata$r	SEGMENT
??_R2?$CEncrypt@K@@8 DD FLAT:??_R1A@?0A@EA@?$CEncrypt@K@@8 ; CEncrypt<unsigned long>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CEncrypt@K@@8
rdata$r	SEGMENT
??_R3?$CEncrypt@K@@8 DD 00H				; CEncrypt<unsigned long>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CEncrypt@K@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CEncrypt@K@@@8
_DATA	SEGMENT
??_R0?AV?$CEncrypt@K@@@8 DD FLAT:??_7type_info@@6B@	; CEncrypt<unsigned long> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CEncrypt@K@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$CEncrypt@K@@6B@
rdata$r	SEGMENT
??_R4?$CEncrypt@K@@6B@ DD 00H				; CEncrypt<unsigned long>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CEncrypt@K@@@8
	DD	FLAT:??_R3?$CEncrypt@K@@8
rdata$r	ENDS
;	COMDAT ??_7?$CEncrypt@K@@6B@
CONST	SEGMENT
??_7?$CEncrypt@K@@6B@ DD FLAT:??_R4?$CEncrypt@K@@6B@	; CEncrypt<unsigned long>::`vftable'
	DD	FLAT:??_E?$CEncrypt@K@@UAEPAXI@Z
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??1?$CEncrypt@K@@UAE@XZ
_TEXT	SEGMENT
??1?$CEncrypt@K@@UAE@XZ PROC				; CEncrypt<unsigned long>::~CEncrypt<unsigned long>, COMDAT
; _this$ = ecx

; 127  : 	{

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CEncrypt@K@@6B@

; 128  : 	}

  00006	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00009	e9 00 00 00 00	 jmp	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
??1?$CEncrypt@K@@UAE@XZ ENDP				; CEncrypt<unsigned long>::~CEncrypt<unsigned long>
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??_G?$CEncrypt@M@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CEncrypt@M@@UAEPAXI@Z PROC			; CEncrypt<float>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CEncrypt@M@@6B@
  0000f	e8 00 00 00 00	 call	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
  00014	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00018	74 07		 je	 SHORT $LN1@scalar
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	59		 pop	 ecx
$LN1@scalar:
  00021	8b c6		 mov	 eax, esi
  00023	5e		 pop	 esi
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??_G?$CEncrypt@M@@UAEPAXI@Z ENDP			; CEncrypt<float>::`scalar deleting destructor'
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??_G?$CEncrypt@K@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CEncrypt@K@@UAEPAXI@Z PROC			; CEncrypt<unsigned long>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CEncrypt@K@@6B@
  0000f	e8 00 00 00 00	 call	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
  00014	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00018	74 07		 je	 SHORT $LN1@scalar@2
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	59		 pop	 ecx
$LN1@scalar@2:
  00021	8b c6		 mov	 eax, esi
  00023	5e		 pop	 esi
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??_G?$CEncrypt@K@@UAEPAXI@Z ENDP			; CEncrypt<unsigned long>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z	; CEncrypt<float>::EncryptValueToPool
EXTRN	?EncryptByte@ccddaabb@@QAEXPBDPADH@Z:PROC	; ccddaabb::EncryptByte
; Function compile flags: /Ogsp
;	COMDAT ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z PROC	; CEncrypt<float>::EncryptValueToPool, COMDAT
; _this$ = ecx

; 67   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 		m_RC5.EncryptByte( value, m_MemPool, max(m_ValueSize, DEFAULT_ENCRYPT) );

  00003	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00007	83 f8 04	 cmp	 eax, 4
  0000a	77 03		 ja	 SHORT $LN4@EncryptVal
  0000c	6a 04		 push	 4
  0000e	58		 pop	 eax
$LN4@EncryptVal:
  0000f	50		 push	 eax
  00010	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  00013	50		 push	 eax
  00014	ff 75 08	 push	 DWORD PTR _value$[ebp]
  00017	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0001a	e8 00 00 00 00	 call	 ?EncryptByte@ccddaabb@@QAEXPBDPADH@Z ; ccddaabb::EncryptByte

; 69   : 		
; 70   : 	}

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ENDP	; CEncrypt<float>::EncryptValueToPool
_TEXT	ENDS
PUBLIC	?Init@?$CEncrypt@M@@AAEXXZ			; CEncrypt<float>::Init
EXTRN	?Setup@ccddaabb@@QAEXPBDHH@Z:PROC		; ccddaabb::Setup
EXTRN	__imp__rand:PROC
EXTRN	__imp__timeGetTime@0:PROC
EXTRN	__imp__GetCurrentProcessId@0:PROC
; Function compile flags: /Ogsp
;	COMDAT ?Init@?$CEncrypt@M@@AAEXXZ
_TEXT	SEGMENT
_pid$ = -8						; size = 4
_tick$ = -4						; size = 4
?Init@?$CEncrypt@M@@AAEXXZ PROC				; CEncrypt<float>::Init, COMDAT
; _this$ = ecx

; 73   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx

; 74   : 		DWORD pid = GetCurrentProcessId();

  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcessId@0
  00010	89 45 f8	 mov	 DWORD PTR _pid$[ebp], eax

; 75   : 		DWORD tick = timeGetTime();

  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0

; 76   : 		m_ValueSize    = sizeof(type);
; 77   : 		m_MemPoolPos   = (unsigned short)( rand()+pid+tick )%(MAX_MEM_POOL-m_ValueSize);

  00019	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__rand
  0001f	89 45 fc	 mov	 DWORD PTR _tick$[ebp], eax
  00022	6a 04		 push	 4
  00024	58		 pop	 eax
  00025	66 89 46 06	 mov	 WORD PTR [esi+6], ax
  00029	ff d7		 call	 edi
  0002b	03 45 f8	 add	 eax, DWORD PTR _pid$[ebp]
  0002e	0f b7 4e 06	 movzx	 ecx, WORD PTR [esi+6]
  00032	03 45 fc	 add	 eax, DWORD PTR _tick$[ebp]
  00035	6a 0c		 push	 12			; 0000000cH
  00037	0f b7 c0	 movzx	 eax, ax
  0003a	5b		 pop	 ebx
  0003b	99		 cdq
  0003c	2b d9		 sub	 ebx, ecx
  0003e	f7 fb		 idiv	 ebx
  00040	66 89 56 04	 mov	 WORD PTR [esi+4], dx

; 78   : 		m_EncryptSeed  = (char)( rand()+pid+tick )%256;

  00044	ff d7		 call	 edi
  00046	02 45 f8	 add	 al, BYTE PTR _pid$[ebp]
  00049	02 45 fc	 add	 al, BYTE PTR _tick$[ebp]
  0004c	0f be c0	 movsx	 eax, al
  0004f	25 ff 00 00 80	 and	 eax, -2147483393	; 800000ffH
  00054	79 07		 jns	 SHORT $LN8@Init
  00056	48		 dec	 eax
  00057	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  0005c	40		 inc	 eax
$LN8@Init:
  0005d	88 46 08	 mov	 BYTE PTR [esi+8], al

; 79   : 
; 80   : 		for (int i = 0; i < MAX_MEM_POOL ; i++)

  00060	33 db		 xor	 ebx, ebx
$LL3@Init:

; 81   : 			m_MemPool[i] = (char)( rand()+pid+tick )%256; // 더미

  00062	ff d7		 call	 edi
  00064	02 45 f8	 add	 al, BYTE PTR _pid$[ebp]
  00067	02 45 fc	 add	 al, BYTE PTR _tick$[ebp]
  0006a	0f be c0	 movsx	 eax, al
  0006d	25 ff 00 00 80	 and	 eax, -2147483393	; 800000ffH
  00072	79 07		 jns	 SHORT $LN9@Init
  00074	48		 dec	 eax
  00075	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  0007a	40		 inc	 eax
$LN9@Init:
  0007b	88 44 1e 1c	 mov	 BYTE PTR [esi+ebx+28], al
  0007f	43		 inc	 ebx
  00080	83 fb 0c	 cmp	 ebx, 12			; 0000000cH
  00083	7c dd		 jl	 SHORT $LL3@Init

; 82   : 
; 83   : 		//UJ 130913, 최적화: szKey 사용안하도록 간략화
; 84   : 		//char szKey[ccddaabb::KEY_SIZE];//="";
; 85   : 		//for (int i = 0; i < ccddaabb::KEY_SIZE  ; i++)
; 86   : 		//	szKey[i] = (char)( rand()+pid+tick )%256; // 더미
; 87   : 		m_RC5.Setup( NULL, pid, tick );

  00085	ff 75 fc	 push	 DWORD PTR _tick$[ebp]
  00088	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0008b	ff 75 f8	 push	 DWORD PTR _pid$[ebp]
  0008e	6a 00		 push	 0
  00090	e8 00 00 00 00	 call	 ?Setup@ccddaabb@@QAEXPBDHH@Z ; ccddaabb::Setup
  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx

; 88   : 
; 89   : #ifdef _NOTUSE
; 90   : 		m_value        = 0;
; 91   : 		EncryptValueToPool((char*)&m_value);
; 92   : 		Debug();
; 93   : #endif
; 94   : 	}

  00098	c9		 leave
  00099	c3		 ret	 0
?Init@?$CEncrypt@M@@AAEXXZ ENDP				; CEncrypt<float>::Init
_TEXT	ENDS
PUBLIC	?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z	; CEncrypt<float>::DecryptValueToPool
EXTRN	?DecryptByte@ccddaabb@@QBEXPBDPADH@Z:PROC	; ccddaabb::DecryptByte
; Function compile flags: /Ogsp
;	COMDAT ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z PROC	; CEncrypt<float>::DecryptValueToPool, COMDAT
; _this$ = ecx

; 1648 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1649 : 		m_RC5.DecryptByte( m_MemPool, m_TempMem, 4 );

  00004	8d 71 28	 lea	 esi, DWORD PTR [ecx+40]
  00007	6a 04		 push	 4
  00009	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00011	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte

; 1650 : 		*value = *((float*)m_TempMem);

  00016	d9 06		 fld	 DWORD PTR [esi]
  00018	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  0001b	d9 18		 fstp	 DWORD PTR [eax]
  0001d	5e		 pop	 esi

; 1651 : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ENDP	; CEncrypt<float>::DecryptValueToPool
_TEXT	ENDS
PUBLIC	?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z	; CEncrypt<unsigned long>::EncryptValueToPool
; Function compile flags: /Ogsp
;	COMDAT ?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z PROC	; CEncrypt<unsigned long>::EncryptValueToPool, COMDAT
; _this$ = ecx

; 67   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 		m_RC5.EncryptByte( value, m_MemPool, max(m_ValueSize, DEFAULT_ENCRYPT) );

  00003	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00007	83 f8 04	 cmp	 eax, 4
  0000a	77 03		 ja	 SHORT $LN4@EncryptVal@2
  0000c	6a 04		 push	 4
  0000e	58		 pop	 eax
$LN4@EncryptVal@2:
  0000f	50		 push	 eax
  00010	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  00013	50		 push	 eax
  00014	ff 75 08	 push	 DWORD PTR _value$[ebp]
  00017	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0001a	e8 00 00 00 00	 call	 ?EncryptByte@ccddaabb@@QAEXPBDPADH@Z ; ccddaabb::EncryptByte

; 69   : 		
; 70   : 	}

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z ENDP	; CEncrypt<unsigned long>::EncryptValueToPool
_TEXT	ENDS
PUBLIC	?Init@?$CEncrypt@K@@AAEXXZ			; CEncrypt<unsigned long>::Init
; Function compile flags: /Ogsp
;	COMDAT ?Init@?$CEncrypt@K@@AAEXXZ
_TEXT	SEGMENT
_pid$ = -8						; size = 4
_tick$ = -4						; size = 4
?Init@?$CEncrypt@K@@AAEXXZ PROC				; CEncrypt<unsigned long>::Init, COMDAT
; _this$ = ecx

; 73   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx

; 74   : 		DWORD pid = GetCurrentProcessId();

  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcessId@0
  00010	89 45 f8	 mov	 DWORD PTR _pid$[ebp], eax

; 75   : 		DWORD tick = timeGetTime();

  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0

; 76   : 		m_ValueSize    = sizeof(type);
; 77   : 		m_MemPoolPos   = (unsigned short)( rand()+pid+tick )%(MAX_MEM_POOL-m_ValueSize);

  00019	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__rand
  0001f	89 45 fc	 mov	 DWORD PTR _tick$[ebp], eax
  00022	6a 04		 push	 4
  00024	58		 pop	 eax
  00025	66 89 46 06	 mov	 WORD PTR [esi+6], ax
  00029	ff d7		 call	 edi
  0002b	03 45 f8	 add	 eax, DWORD PTR _pid$[ebp]
  0002e	0f b7 4e 06	 movzx	 ecx, WORD PTR [esi+6]
  00032	03 45 fc	 add	 eax, DWORD PTR _tick$[ebp]
  00035	6a 0c		 push	 12			; 0000000cH
  00037	0f b7 c0	 movzx	 eax, ax
  0003a	5b		 pop	 ebx
  0003b	99		 cdq
  0003c	2b d9		 sub	 ebx, ecx
  0003e	f7 fb		 idiv	 ebx
  00040	66 89 56 04	 mov	 WORD PTR [esi+4], dx

; 78   : 		m_EncryptSeed  = (char)( rand()+pid+tick )%256;

  00044	ff d7		 call	 edi
  00046	02 45 f8	 add	 al, BYTE PTR _pid$[ebp]
  00049	02 45 fc	 add	 al, BYTE PTR _tick$[ebp]
  0004c	0f be c0	 movsx	 eax, al
  0004f	25 ff 00 00 80	 and	 eax, -2147483393	; 800000ffH
  00054	79 07		 jns	 SHORT $LN8@Init@2
  00056	48		 dec	 eax
  00057	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  0005c	40		 inc	 eax
$LN8@Init@2:
  0005d	88 46 08	 mov	 BYTE PTR [esi+8], al

; 79   : 
; 80   : 		for (int i = 0; i < MAX_MEM_POOL ; i++)

  00060	33 db		 xor	 ebx, ebx
$LL3@Init@2:

; 81   : 			m_MemPool[i] = (char)( rand()+pid+tick )%256; // 더미

  00062	ff d7		 call	 edi
  00064	02 45 f8	 add	 al, BYTE PTR _pid$[ebp]
  00067	02 45 fc	 add	 al, BYTE PTR _tick$[ebp]
  0006a	0f be c0	 movsx	 eax, al
  0006d	25 ff 00 00 80	 and	 eax, -2147483393	; 800000ffH
  00072	79 07		 jns	 SHORT $LN9@Init@2
  00074	48		 dec	 eax
  00075	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  0007a	40		 inc	 eax
$LN9@Init@2:
  0007b	88 44 1e 1c	 mov	 BYTE PTR [esi+ebx+28], al
  0007f	43		 inc	 ebx
  00080	83 fb 0c	 cmp	 ebx, 12			; 0000000cH
  00083	7c dd		 jl	 SHORT $LL3@Init@2

; 82   : 
; 83   : 		//UJ 130913, 최적화: szKey 사용안하도록 간략화
; 84   : 		//char szKey[ccddaabb::KEY_SIZE];//="";
; 85   : 		//for (int i = 0; i < ccddaabb::KEY_SIZE  ; i++)
; 86   : 		//	szKey[i] = (char)( rand()+pid+tick )%256; // 더미
; 87   : 		m_RC5.Setup( NULL, pid, tick );

  00085	ff 75 fc	 push	 DWORD PTR _tick$[ebp]
  00088	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0008b	ff 75 f8	 push	 DWORD PTR _pid$[ebp]
  0008e	6a 00		 push	 0
  00090	e8 00 00 00 00	 call	 ?Setup@ccddaabb@@QAEXPBDHH@Z ; ccddaabb::Setup
  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx

; 88   : 
; 89   : #ifdef _NOTUSE
; 90   : 		m_value        = 0;
; 91   : 		EncryptValueToPool((char*)&m_value);
; 92   : 		Debug();
; 93   : #endif
; 94   : 	}

  00098	c9		 leave
  00099	c3		 ret	 0
?Init@?$CEncrypt@K@@AAEXXZ ENDP				; CEncrypt<unsigned long>::Init
_TEXT	ENDS
PUBLIC	?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z	; CEncrypt<unsigned long>::DecryptValueToPool
; Function compile flags: /Ogsp
;	COMDAT ?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z PROC	; CEncrypt<unsigned long>::DecryptValueToPool, COMDAT
; _this$ = ecx

; 1256 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1257 : 		m_RC5.DecryptByte( m_MemPool, m_TempMem, 4 );

  00004	8d 71 28	 lea	 esi, DWORD PTR [ecx+40]
  00007	6a 04		 push	 4
  00009	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00011	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte

; 1258 : 		*value = *((DWORD*)m_TempMem);

  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0001b	89 01		 mov	 DWORD PTR [ecx], eax
  0001d	5e		 pop	 esi

; 1259 : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z ENDP	; CEncrypt<unsigned long>::DecryptValueToPool
_TEXT	ENDS
PUBLIC	?EncryptValueToPool@?$CEncrypt@_N@@AAEXPBD@Z	; CEncrypt<bool>::EncryptValueToPool
; Function compile flags: /Ogsp
;	COMDAT ?EncryptValueToPool@?$CEncrypt@_N@@AAEXPBD@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?EncryptValueToPool@?$CEncrypt@_N@@AAEXPBD@Z PROC	; CEncrypt<bool>::EncryptValueToPool, COMDAT
; _this$ = ecx

; 67   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 		m_RC5.EncryptByte( value, m_MemPool, max(m_ValueSize, DEFAULT_ENCRYPT) );

  00003	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00007	83 f8 04	 cmp	 eax, 4
  0000a	77 03		 ja	 SHORT $LN4@EncryptVal@3
  0000c	6a 04		 push	 4
  0000e	58		 pop	 eax
$LN4@EncryptVal@3:
  0000f	50		 push	 eax
  00010	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  00013	50		 push	 eax
  00014	ff 75 08	 push	 DWORD PTR _value$[ebp]
  00017	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0001a	e8 00 00 00 00	 call	 ?EncryptByte@ccddaabb@@QAEXPBDPADH@Z ; ccddaabb::EncryptByte

; 69   : 		
; 70   : 	}

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?EncryptValueToPool@?$CEncrypt@_N@@AAEXPBD@Z ENDP	; CEncrypt<bool>::EncryptValueToPool
_TEXT	ENDS
PUBLIC	?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
; Function compile flags: /Ogsp
;	COMDAT ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z PROC ; CEncrypt<enum TeamType>::DecryptValueToPool, COMDAT
; _this$ = ecx

; 2959 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2960 : 		m_RC5.DecryptByte( m_MemPool, m_TempMem, sizeof(TeamType) );

  00004	8d 71 28	 lea	 esi, DWORD PTR [ecx+40]
  00007	6a 04		 push	 4
  00009	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00011	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte

; 2961 : 		*value = *((TeamType*)m_TempMem);

  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0001b	89 01		 mov	 DWORD PTR [ecx], eax
  0001d	5e		 pop	 esi

; 2962 : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ENDP ; CEncrypt<enum TeamType>::DecryptValueToPool
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??_GioHPStealBuff@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GioHPStealBuff@@UAEPAXI@Z PROC			; ioHPStealBuff::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1ioHPStealBuff@@UAE@XZ ; ioHPStealBuff::~ioHPStealBuff
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 07		 je	 SHORT $LN1@scalar@3
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	59		 pop	 ecx
$LN1@scalar@3:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??_GioHPStealBuff@@UAEPAXI@Z ENDP			; ioHPStealBuff::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1StatusValue@@QAE@XZ				; StatusValue::~StatusValue
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1StatusValue@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1StatusValue@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1StatusValue@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1StatusValue@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1StatusValue@@QAE@XZ$3
__ehfuncinfo$??1StatusValue@@QAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??1StatusValue@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??1StatusValue@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1StatusValue@@QAE@XZ PROC				; StatusValue::~StatusValue, COMDAT
; _this$ = ecx
  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??1StatusValue@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	bf 00 00 00 00	 mov	 edi, OFFSET ??_7?$CEncrypt@K@@6B@
  00016	8d 8e cc 00 00
	00		 lea	 ecx, DWORD PTR [esi+204]
  0001c	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  00023	89 be c0 00 00
	00		 mov	 DWORD PTR [esi+192], edi
  00029	e8 00 00 00 00	 call	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
  0002e	8d 8e 9c 00 00
	00		 lea	 ecx, DWORD PTR [esi+156]
  00034	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00038	89 be 90 00 00
	00		 mov	 DWORD PTR [esi+144], edi
  0003e	e8 00 00 00 00	 call	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
  00043	bf 00 00 00 00	 mov	 edi, OFFSET ??_7?$CEncrypt@M@@6B@
  00048	8d 4e 6c	 lea	 ecx, DWORD PTR [esi+108]
  0004b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0004f	89 7e 60	 mov	 DWORD PTR [esi+96], edi
  00052	e8 00 00 00 00	 call	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
  00057	8d 4e 3c	 lea	 ecx, DWORD PTR [esi+60]
  0005a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0005e	89 7e 30	 mov	 DWORD PTR [esi+48], edi
  00061	e8 00 00 00 00	 call	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
  00066	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0006a	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0006d	89 3e		 mov	 DWORD PTR [esi], edi
  0006f	e8 00 00 00 00	 call	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
  00074	e8 00 00 00 00	 call	 __EH_epilog3
  00079	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1StatusValue@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@M@@UAE@XZ	; CEncrypt<float>::~CEncrypt<float>
__unwindfunclet$??1StatusValue@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 30	 add	 ecx, 48			; 00000030H
  0000e	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@M@@UAE@XZ	; CEncrypt<float>::~CEncrypt<float>
__unwindfunclet$??1StatusValue@@QAE@XZ$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 60	 add	 ecx, 96			; 00000060H
  00019	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@M@@UAE@XZ	; CEncrypt<float>::~CEncrypt<float>
__unwindfunclet$??1StatusValue@@QAE@XZ$3:
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  00027	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@K@@UAE@XZ	; CEncrypt<unsigned long>::~CEncrypt<unsigned long>
__ehhandler$??1StatusValue@@QAE@XZ:
  0002c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00030	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00033	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00036	33 c8		 xor	 ecx, eax
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1StatusValue@@QAE@XZ
  00042	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1StatusValue@@QAE@XZ ENDP				; StatusValue::~StatusValue
PUBLIC	??P?$CEncrypt@M@@QAE_NABM@Z			; CEncrypt<float>::operator>=
; Function compile flags: /Ogsp
;	COMDAT ??P?$CEncrypt@M@@QAE_NABM@Z
_TEXT	SEGMENT
_value$ = -4						; size = 4
_inValue$ = 8						; size = 4
??P?$CEncrypt@M@@QAE_NABM@Z PROC			; CEncrypt<float>::operator>=, COMDAT
; _this$ = ecx

; 1831 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1832 : 		type value;
; 1833 : 		DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool

; 1834 : #ifdef _NOTUSE
; 1835 : 		Debug();
; 1836 : #endif
; 1837 : 		return (value >= inValue);

  0000d	8b 45 08	 mov	 eax, DWORD PTR _inValue$[ebp]
  00010	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  00014	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _value$[ebp]
  00019	0f 5a c0	 cvtps2pd xmm0, xmm0
  0001c	0f 5a c9	 cvtps2pd xmm1, xmm1
  0001f	33 c0		 xor	 eax, eax
  00021	66 0f 2f c1	 comisd	 xmm0, xmm1
  00025	72 01		 jb	 SHORT $LN4@operator
  00027	40		 inc	 eax
$LN4@operator:

; 1838 : 	}		

  00028	c9		 leave
  00029	c2 04 00	 ret	 4
??P?$CEncrypt@M@@QAE_NABM@Z ENDP			; CEncrypt<float>::operator>=
_TEXT	ENDS
PUBLIC	??G?$CEncrypt@K@@QAEKABK@Z			; CEncrypt<unsigned long>::operator-
; Function compile flags: /Ogsp
;	COMDAT ??G?$CEncrypt@K@@QAEKABK@Z
_TEXT	SEGMENT
_value$ = -4						; size = 4
_inValue$ = 8						; size = 4
??G?$CEncrypt@K@@QAEKABK@Z PROC				; CEncrypt<unsigned long>::operator-, COMDAT
; _this$ = ecx

; 1274 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1275 : 		
; 1276 : 		type value;
; 1277 : 		DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z ; CEncrypt<unsigned long>::DecryptValueToPool

; 1278 : #ifdef _NOTUSE
; 1279 : 		Debug();
; 1280 : #endif
; 1281 : 		return value - inValue;

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _value$[ebp]
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _inValue$[ebp]
  00013	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1282 : 	}

  00015	c9		 leave
  00016	c2 04 00	 ret	 4
??G?$CEncrypt@K@@QAEKABK@Z ENDP				; CEncrypt<unsigned long>::operator-
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadFloat_e@$07@ioINILoader@@QAEMAAY07$$CBDM@Z ; ioINILoader::LoadFloat_e<8>
EXTRN	__imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z:PROC
EXTRN	___security_cookie:DWORD
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\io3dengine\ioiniloader.h
;	COMDAT ??$LoadFloat_e@$07@ioINILoader@@QAEMAAY07$$CBDM@Z
_TEXT	SEGMENT
__k$ = -16						; size = 8
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_f$ = 12						; size = 4
??$LoadFloat_e@$07@ioINILoader@@QAEMAAY07$$CBDM@Z PROC	; ioINILoader::LoadFloat_e<8>, COMDAT
; _this$ = ecx

; 135  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 136  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	84 d2		 test	 dl, dl
  0001a	0f 84 d7 00 00
	00		 je	 $LN96@LoadFloat_
  00020	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00023	88 55 f0	 mov	 BYTE PTR __k$[ebp], dl
  00026	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00029	84 d2		 test	 dl, dl
  0002b	0f 84 c0 00 00
	00		 je	 $LN95@LoadFloat_
  00031	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00034	88 55 f1	 mov	 BYTE PTR __k$[ebp+1], dl
  00037	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003a	84 d2		 test	 dl, dl
  0003c	0f 84 a9 00 00
	00		 je	 $LN94@LoadFloat_
  00042	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00045	88 55 f2	 mov	 BYTE PTR __k$[ebp+2], dl
  00048	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004b	84 d2		 test	 dl, dl
  0004d	0f 84 92 00 00
	00		 je	 $LN93@LoadFloat_
  00053	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00056	88 55 f3	 mov	 BYTE PTR __k$[ebp+3], dl
  00059	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005c	84 d2		 test	 dl, dl
  0005e	74 7f		 je	 SHORT $LN92@LoadFloat_
  00060	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00063	88 55 f4	 mov	 BYTE PTR __k$[ebp+4], dl
  00066	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00069	84 d2		 test	 dl, dl
  0006b	74 6c		 je	 SHORT $LN91@LoadFloat_
  0006d	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00070	88 55 f5	 mov	 BYTE PTR __k$[ebp+5], dl
  00073	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00076	84 d2		 test	 dl, dl
  00078	74 59		 je	 SHORT $LN90@LoadFloat_
  0007a	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0007d	80 78 07 00	 cmp	 BYTE PTR [eax+7], 0
  00081	88 55 f6	 mov	 BYTE PTR __k$[ebp+6], dl
  00084	74 75		 je	 SHORT $LN1@LoadFloat_
  00086	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  00089	84 d2		 test	 dl, dl
  0008b	74 40		 je	 SHORT $LN88@LoadFloat_
  0008d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00090	88 55 f8	 mov	 BYTE PTR __k$[ebp+8], dl
  00093	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  00096	84 d2		 test	 dl, dl
  00098	74 2d		 je	 SHORT $LN87@LoadFloat_
  0009a	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0009d	88 55 f9	 mov	 BYTE PTR __k$[ebp+9], dl
  000a0	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000a3	84 d2		 test	 dl, dl
  000a5	74 1a		 je	 SHORT $LN86@LoadFloat_
  000a7	8a 40 0b	 mov	 al, BYTE PTR [eax+11]
  000aa	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000ad	88 55 fa	 mov	 BYTE PTR __k$[ebp+10], dl
  000b0	84 c0		 test	 al, al
  000b2	74 07		 je	 SHORT $LN85@LoadFloat_
  000b4	34 ea		 xor	 al, -22			; ffffffeaH
  000b6	88 45 fb	 mov	 BYTE PTR __k$[ebp+11], al
  000b9	eb 40		 jmp	 SHORT $LN1@LoadFloat_
$LN85@LoadFloat_:
  000bb	c6 45 fb ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  000bf	eb 3a		 jmp	 SHORT $LN1@LoadFloat_
$LN86@LoadFloat_:
  000c1	c6 45 fa eb	 mov	 BYTE PTR __k$[ebp+10], -21 ; ffffffebH
  000c5	eb 34		 jmp	 SHORT $LN1@LoadFloat_
$LN87@LoadFloat_:
  000c7	c6 45 f9 ec	 mov	 BYTE PTR __k$[ebp+9], -20 ; ffffffecH
  000cb	eb 2e		 jmp	 SHORT $LN1@LoadFloat_
$LN88@LoadFloat_:
  000cd	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  000d1	eb 28		 jmp	 SHORT $LN1@LoadFloat_
$LN90@LoadFloat_:
  000d3	c6 45 f6 eb	 mov	 BYTE PTR __k$[ebp+6], -21 ; ffffffebH
  000d7	eb 22		 jmp	 SHORT $LN1@LoadFloat_
$LN91@LoadFloat_:
  000d9	c6 45 f5 ec	 mov	 BYTE PTR __k$[ebp+5], -20 ; ffffffecH
  000dd	eb 1c		 jmp	 SHORT $LN1@LoadFloat_
$LN92@LoadFloat_:
  000df	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  000e3	eb 16		 jmp	 SHORT $LN1@LoadFloat_
$LN93@LoadFloat_:
  000e5	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  000e9	eb 10		 jmp	 SHORT $LN1@LoadFloat_
$LN94@LoadFloat_:
  000eb	c6 45 f2 eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  000ef	eb 0a		 jmp	 SHORT $LN1@LoadFloat_
$LN95@LoadFloat_:
  000f1	c6 45 f1 ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  000f5	eb 04		 jmp	 SHORT $LN1@LoadFloat_
$LN96@LoadFloat_:
  000f7	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@LoadFloat_:
  000fb	81 75 f0 ed ec
	eb ea		 xor	 DWORD PTR __k$[ebp], -353637139 ; eaebecedH
  00102	6a 04		 push	 4
  00104	c6 45 f7 00	 mov	 BYTE PTR __k$[ebp+7], 0
  00108	58		 pop	 eax
$LL101@LoadFloat_:
  00109	8b c8		 mov	 ecx, eax
  0010b	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00111	79 05		 jns	 SHORT $LN111@LoadFloat_
  00113	49		 dec	 ecx
  00114	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00117	41		 inc	 ecx
$LN111@LoadFloat_:
  00118	b2 ed		 mov	 dl, -19			; ffffffedH
  0011a	2a d1		 sub	 dl, cl
  0011c	30 54 05 f0	 xor	 BYTE PTR __k$[ebp+eax], dl
  00120	40		 inc	 eax
  00121	83 f8 07	 cmp	 eax, 7
  00124	7c e3		 jl	 SHORT $LL101@LoadFloat_

; 137  : 		return LoadFloat(_k, f);

  00126	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _f$[ebp]
  0012b	51		 push	 ecx
  0012c	8d 45 f0	 lea	 eax, DWORD PTR __k$[ebp]
  0012f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00134	50		 push	 eax
  00135	8b ce		 mov	 ecx, esi
  00137	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z

; 138  : 	}

  0013d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00140	33 cd		 xor	 ecx, ebp
  00142	5e		 pop	 esi
  00143	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00148	c9		 leave
  00149	c2 08 00	 ret	 8
??$LoadFloat_e@$07@ioINILoader@@QAEMAAY07$$CBDM@Z ENDP	; ioINILoader::LoadFloat_e<8>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadFloat_e@$06@ioINILoader@@QAEMAAY06$$CBDM@Z ; ioINILoader::LoadFloat_e<7>
; Function compile flags: /Ogsp
;	COMDAT ??$LoadFloat_e@$06@ioINILoader@@QAEMAAY06$$CBDM@Z
_TEXT	SEGMENT
__k$ = -16						; size = 7
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_f$ = 12						; size = 4
??$LoadFloat_e@$06@ioINILoader@@QAEMAAY06$$CBDM@Z PROC	; ioINILoader::LoadFloat_e<7>, COMDAT
; _this$ = ecx

; 135  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 136  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	84 d2		 test	 dl, dl
  0001a	0f 84 c0 00 00
	00		 je	 $LN96@LoadFloat_@2
  00020	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00023	88 55 f0	 mov	 BYTE PTR __k$[ebp], dl
  00026	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00029	84 d2		 test	 dl, dl
  0002b	0f 84 a9 00 00
	00		 je	 $LN95@LoadFloat_@2
  00031	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00034	88 55 f1	 mov	 BYTE PTR __k$[ebp+1], dl
  00037	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003a	84 d2		 test	 dl, dl
  0003c	0f 84 92 00 00
	00		 je	 $LN94@LoadFloat_@2
  00042	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00045	88 55 f2	 mov	 BYTE PTR __k$[ebp+2], dl
  00048	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004b	84 d2		 test	 dl, dl
  0004d	74 7f		 je	 SHORT $LN93@LoadFloat_@2
  0004f	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00052	88 55 f3	 mov	 BYTE PTR __k$[ebp+3], dl
  00055	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  00058	84 d2		 test	 dl, dl
  0005a	74 6c		 je	 SHORT $LN92@LoadFloat_@2
  0005c	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0005f	88 55 f4	 mov	 BYTE PTR __k$[ebp+4], dl
  00062	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00065	84 d2		 test	 dl, dl
  00067	74 59		 je	 SHORT $LN91@LoadFloat_@2
  00069	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0006c	80 78 06 00	 cmp	 BYTE PTR [eax+6], 0
  00070	88 55 f5	 mov	 BYTE PTR __k$[ebp+5], dl
  00073	74 6f		 je	 SHORT $LN1@LoadFloat_@2
  00075	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00078	84 d2		 test	 dl, dl
  0007a	74 40		 je	 SHORT $LN89@LoadFloat_@2
  0007c	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0007f	88 55 f7	 mov	 BYTE PTR __k$[ebp+7], dl
  00082	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  00085	84 d2		 test	 dl, dl
  00087	74 2d		 je	 SHORT $LN88@LoadFloat_@2
  00089	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0008c	88 55 f8	 mov	 BYTE PTR __k$[ebp+8], dl
  0008f	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  00092	84 d2		 test	 dl, dl
  00094	74 1a		 je	 SHORT $LN87@LoadFloat_@2
  00096	8a 40 0a	 mov	 al, BYTE PTR [eax+10]
  00099	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0009c	88 55 f9	 mov	 BYTE PTR __k$[ebp+9], dl
  0009f	84 c0		 test	 al, al
  000a1	74 07		 je	 SHORT $LN86@LoadFloat_@2
  000a3	34 eb		 xor	 al, -21			; ffffffebH
  000a5	88 45 fa	 mov	 BYTE PTR __k$[ebp+10], al
  000a8	eb 3a		 jmp	 SHORT $LN1@LoadFloat_@2
$LN86@LoadFloat_@2:
  000aa	c6 45 fa eb	 mov	 BYTE PTR __k$[ebp+10], -21 ; ffffffebH
  000ae	eb 34		 jmp	 SHORT $LN1@LoadFloat_@2
$LN87@LoadFloat_@2:
  000b0	c6 45 f9 ec	 mov	 BYTE PTR __k$[ebp+9], -20 ; ffffffecH
  000b4	eb 2e		 jmp	 SHORT $LN1@LoadFloat_@2
$LN88@LoadFloat_@2:
  000b6	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  000ba	eb 28		 jmp	 SHORT $LN1@LoadFloat_@2
$LN89@LoadFloat_@2:
  000bc	c6 45 f7 ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  000c0	eb 22		 jmp	 SHORT $LN1@LoadFloat_@2
$LN91@LoadFloat_@2:
  000c2	c6 45 f5 ec	 mov	 BYTE PTR __k$[ebp+5], -20 ; ffffffecH
  000c6	eb 1c		 jmp	 SHORT $LN1@LoadFloat_@2
$LN92@LoadFloat_@2:
  000c8	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  000cc	eb 16		 jmp	 SHORT $LN1@LoadFloat_@2
$LN93@LoadFloat_@2:
  000ce	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  000d2	eb 10		 jmp	 SHORT $LN1@LoadFloat_@2
$LN94@LoadFloat_@2:
  000d4	c6 45 f2 eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  000d8	eb 0a		 jmp	 SHORT $LN1@LoadFloat_@2
$LN95@LoadFloat_@2:
  000da	c6 45 f1 ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  000de	eb 04		 jmp	 SHORT $LN1@LoadFloat_@2
$LN96@LoadFloat_@2:
  000e0	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@LoadFloat_@2:
  000e4	81 75 f0 ed ec
	eb ea		 xor	 DWORD PTR __k$[ebp], -353637139 ; eaebecedH
  000eb	6a 04		 push	 4
  000ed	c6 45 f6 00	 mov	 BYTE PTR __k$[ebp+6], 0
  000f1	58		 pop	 eax
$LL101@LoadFloat_@2:
  000f2	8b c8		 mov	 ecx, eax
  000f4	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  000fa	79 05		 jns	 SHORT $LN111@LoadFloat_@2
  000fc	49		 dec	 ecx
  000fd	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00100	41		 inc	 ecx
$LN111@LoadFloat_@2:
  00101	b2 ed		 mov	 dl, -19			; ffffffedH
  00103	2a d1		 sub	 dl, cl
  00105	30 54 05 f0	 xor	 BYTE PTR __k$[ebp+eax], dl
  00109	40		 inc	 eax
  0010a	83 f8 06	 cmp	 eax, 6
  0010d	7c e3		 jl	 SHORT $LL101@LoadFloat_@2

; 137  : 		return LoadFloat(_k, f);

  0010f	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _f$[ebp]
  00114	51		 push	 ecx
  00115	8d 45 f0	 lea	 eax, DWORD PTR __k$[ebp]
  00118	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0011d	50		 push	 eax
  0011e	8b ce		 mov	 ecx, esi
  00120	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z

; 138  : 	}

  00126	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00129	33 cd		 xor	 ecx, ebp
  0012b	5e		 pop	 esi
  0012c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00131	c9		 leave
  00132	c2 08 00	 ret	 8
??$LoadFloat_e@$06@ioINILoader@@QAEMAAY06$$CBDM@Z ENDP	; ioINILoader::LoadFloat_e<7>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadFloat_e@$09@ioINILoader@@QAEMAAY09$$CBDM@Z ; ioINILoader::LoadFloat_e<10>
; Function compile flags: /Ogsp
;	COMDAT ??$LoadFloat_e@$09@ioINILoader@@QAEMAAY09$$CBDM@Z
_TEXT	SEGMENT
__k$ = -20						; size = 10
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_f$ = 12						; size = 4
??$LoadFloat_e@$09@ioINILoader@@QAEMAAY09$$CBDM@Z PROC	; ioINILoader::LoadFloat_e<10>, COMDAT
; _this$ = ecx

; 135  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 136  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	84 d2		 test	 dl, dl
  00017	0f 84 0d 01 00
	00		 je	 $LN96@LoadFloat_@3
  0001d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00020	88 55 ec	 mov	 BYTE PTR __k$[ebp], dl
  00023	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00026	84 d2		 test	 dl, dl
  00028	0f 84 f6 00 00
	00		 je	 $LN95@LoadFloat_@3
  0002e	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00031	88 55 ed	 mov	 BYTE PTR __k$[ebp+1], dl
  00034	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  00037	84 d2		 test	 dl, dl
  00039	0f 84 df 00 00
	00		 je	 $LN94@LoadFloat_@3
  0003f	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00042	88 55 ee	 mov	 BYTE PTR __k$[ebp+2], dl
  00045	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  00048	84 d2		 test	 dl, dl
  0004a	0f 84 c8 00 00
	00		 je	 $LN93@LoadFloat_@3
  00050	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00053	88 55 ef	 mov	 BYTE PTR __k$[ebp+3], dl
  00056	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  00059	84 d2		 test	 dl, dl
  0005b	0f 84 b1 00 00
	00		 je	 $LN92@LoadFloat_@3
  00061	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00064	88 55 f0	 mov	 BYTE PTR __k$[ebp+4], dl
  00067	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006a	84 d2		 test	 dl, dl
  0006c	0f 84 9a 00 00
	00		 je	 $LN91@LoadFloat_@3
  00072	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00075	88 55 f1	 mov	 BYTE PTR __k$[ebp+5], dl
  00078	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0007b	84 d2		 test	 dl, dl
  0007d	0f 84 83 00 00
	00		 je	 $LN90@LoadFloat_@3
  00083	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00086	88 55 f2	 mov	 BYTE PTR __k$[ebp+6], dl
  00089	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0008c	84 d2		 test	 dl, dl
  0008e	74 70		 je	 SHORT $LN89@LoadFloat_@3
  00090	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00093	88 55 f3	 mov	 BYTE PTR __k$[ebp+7], dl
  00096	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  00099	84 d2		 test	 dl, dl
  0009b	74 5d		 je	 SHORT $LN88@LoadFloat_@3
  0009d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000a0	80 78 09 00	 cmp	 BYTE PTR [eax+9], 0
  000a4	88 55 f4	 mov	 BYTE PTR __k$[ebp+8], dl
  000a7	0f 84 81 00 00
	00		 je	 $LN1@LoadFloat_@3
  000ad	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000b0	84 d2		 test	 dl, dl
  000b2	74 40		 je	 SHORT $LN86@LoadFloat_@3
  000b4	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000b7	88 55 f6	 mov	 BYTE PTR __k$[ebp+10], dl
  000ba	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000bd	84 d2		 test	 dl, dl
  000bf	74 2d		 je	 SHORT $LN85@LoadFloat_@3
  000c1	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000c4	88 55 f7	 mov	 BYTE PTR __k$[ebp+11], dl
  000c7	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000ca	84 d2		 test	 dl, dl
  000cc	74 1a		 je	 SHORT $LN84@LoadFloat_@3
  000ce	8a 40 0d	 mov	 al, BYTE PTR [eax+13]
  000d1	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000d4	88 55 f8	 mov	 BYTE PTR __k$[ebp+12], dl
  000d7	84 c0		 test	 al, al
  000d9	74 07		 je	 SHORT $LN83@LoadFloat_@3
  000db	34 ec		 xor	 al, -20			; ffffffecH
  000dd	88 45 f9	 mov	 BYTE PTR __k$[ebp+13], al
  000e0	eb 4c		 jmp	 SHORT $LN1@LoadFloat_@3
$LN83@LoadFloat_@3:
  000e2	c6 45 f9 ec	 mov	 BYTE PTR __k$[ebp+13], -20 ; ffffffecH
  000e6	eb 46		 jmp	 SHORT $LN1@LoadFloat_@3
$LN84@LoadFloat_@3:
  000e8	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  000ec	eb 40		 jmp	 SHORT $LN1@LoadFloat_@3
$LN85@LoadFloat_@3:
  000ee	c6 45 f7 ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  000f2	eb 3a		 jmp	 SHORT $LN1@LoadFloat_@3
$LN86@LoadFloat_@3:
  000f4	c6 45 f6 eb	 mov	 BYTE PTR __k$[ebp+10], -21 ; ffffffebH
  000f8	eb 34		 jmp	 SHORT $LN1@LoadFloat_@3
$LN88@LoadFloat_@3:
  000fa	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  000fe	eb 2e		 jmp	 SHORT $LN1@LoadFloat_@3
$LN89@LoadFloat_@3:
  00100	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  00104	eb 28		 jmp	 SHORT $LN1@LoadFloat_@3
$LN90@LoadFloat_@3:
  00106	c6 45 f2 eb	 mov	 BYTE PTR __k$[ebp+6], -21 ; ffffffebH
  0010a	eb 22		 jmp	 SHORT $LN1@LoadFloat_@3
$LN91@LoadFloat_@3:
  0010c	c6 45 f1 ec	 mov	 BYTE PTR __k$[ebp+5], -20 ; ffffffecH
  00110	eb 1c		 jmp	 SHORT $LN1@LoadFloat_@3
$LN92@LoadFloat_@3:
  00112	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  00116	eb 16		 jmp	 SHORT $LN1@LoadFloat_@3
$LN93@LoadFloat_@3:
  00118	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  0011c	eb 10		 jmp	 SHORT $LN1@LoadFloat_@3
$LN94@LoadFloat_@3:
  0011e	c6 45 ee eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  00122	eb 0a		 jmp	 SHORT $LN1@LoadFloat_@3
$LN95@LoadFloat_@3:
  00124	c6 45 ed ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  00128	eb 04		 jmp	 SHORT $LN1@LoadFloat_@3
$LN96@LoadFloat_@3:
  0012a	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@LoadFloat_@3:
  0012e	6a 02		 push	 2
  00130	8d 45 ec	 lea	 eax, DWORD PTR __k$[ebp]
  00133	c6 45 f5 00	 mov	 BYTE PTR __k$[ebp+9], 0
  00137	5a		 pop	 edx
$LL104@LoadFloat_@3:
  00138	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0013e	83 c0 04	 add	 eax, 4
  00141	4a		 dec	 edx
  00142	75 f4		 jne	 SHORT $LL104@LoadFloat_@3

; 137  : 		return LoadFloat(_k, f);

  00144	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _f$[ebp]
  00149	80 75 f4 ed	 xor	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  0014d	51		 push	 ecx
  0014e	8d 45 ec	 lea	 eax, DWORD PTR __k$[ebp]
  00151	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00156	50		 push	 eax
  00157	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z

; 138  : 	}

  0015d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00160	33 cd		 xor	 ecx, ebp
  00162	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00167	c9		 leave
  00168	c2 08 00	 ret	 8
??$LoadFloat_e@$09@ioINILoader@@QAEMAAY09$$CBDM@Z ENDP	; ioINILoader::LoadFloat_e<10>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadBool_e@$0M@@ioINILoader@@QAE_NAAY0M@$$CBD_N@Z ; ioINILoader::LoadBool_e<12>
EXTRN	__imp_?LoadBool@ioINILoader@@QAE_NPBD_N@Z:PROC
; Function compile flags: /Ogsp
;	COMDAT ??$LoadBool_e@$0M@@ioINILoader@@QAE_NAAY0M@$$CBD_N@Z
_TEXT	SEGMENT
__k$ = -20						; size = 12
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_b$ = 12						; size = 1
??$LoadBool_e@$0M@@ioINILoader@@QAE_NAAY0M@$$CBD_N@Z PROC ; ioINILoader::LoadBool_e<12>, COMDAT
; _this$ = ecx

; 101  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 102  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	84 d2		 test	 dl, dl
  0001a	0f 84 32 01 00
	00		 je	 $LN96@LoadBool_e
  00020	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00023	88 55 ec	 mov	 BYTE PTR __k$[ebp], dl
  00026	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00029	84 d2		 test	 dl, dl
  0002b	0f 84 1b 01 00
	00		 je	 $LN95@LoadBool_e
  00031	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00034	88 55 ed	 mov	 BYTE PTR __k$[ebp+1], dl
  00037	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003a	84 d2		 test	 dl, dl
  0003c	0f 84 04 01 00
	00		 je	 $LN94@LoadBool_e
  00042	b1 eb		 mov	 cl, -21			; ffffffebH
  00044	32 d1		 xor	 dl, cl
  00046	88 55 ee	 mov	 BYTE PTR __k$[ebp+2], dl
  00049	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004c	84 d2		 test	 dl, dl
  0004e	0f 84 ec 00 00
	00		 je	 $LN93@LoadBool_e
  00054	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00057	88 55 ef	 mov	 BYTE PTR __k$[ebp+3], dl
  0005a	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005d	84 d2		 test	 dl, dl
  0005f	0f 84 d5 00 00
	00		 je	 $LN92@LoadBool_e
  00065	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00068	88 55 f0	 mov	 BYTE PTR __k$[ebp+4], dl
  0006b	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006e	84 d2		 test	 dl, dl
  00070	0f 84 be 00 00
	00		 je	 $LN91@LoadBool_e
  00076	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00079	88 55 f1	 mov	 BYTE PTR __k$[ebp+5], dl
  0007c	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0007f	84 d2		 test	 dl, dl
  00081	0f 84 a8 00 00
	00		 je	 $LN90@LoadBool_e
  00087	32 d1		 xor	 dl, cl
  00089	88 55 f2	 mov	 BYTE PTR __k$[ebp+6], dl
  0008c	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0008f	84 d2		 test	 dl, dl
  00091	0f 84 92 00 00
	00		 je	 $LN89@LoadBool_e
  00097	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009a	88 55 f3	 mov	 BYTE PTR __k$[ebp+7], dl
  0009d	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a0	84 d2		 test	 dl, dl
  000a2	74 7f		 je	 SHORT $LN88@LoadBool_e
  000a4	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000a7	88 55 f4	 mov	 BYTE PTR __k$[ebp+8], dl
  000aa	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000ad	84 d2		 test	 dl, dl
  000af	74 6c		 je	 SHORT $LN87@LoadBool_e
  000b1	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000b4	88 55 f5	 mov	 BYTE PTR __k$[ebp+9], dl
  000b7	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000ba	84 d2		 test	 dl, dl
  000bc	74 5a		 je	 SHORT $LN86@LoadBool_e
  000be	32 d1		 xor	 dl, cl
  000c0	80 78 0b 00	 cmp	 BYTE PTR [eax+11], 0
  000c4	88 55 f6	 mov	 BYTE PTR __k$[ebp+10], dl
  000c7	0f 84 89 00 00
	00		 je	 $LN1@LoadBool_e
  000cd	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000d0	84 d2		 test	 dl, dl
  000d2	74 3e		 je	 SHORT $LN84@LoadBool_e
  000d4	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000d7	88 55 f8	 mov	 BYTE PTR __k$[ebp+12], dl
  000da	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000dd	84 d2		 test	 dl, dl
  000df	74 2b		 je	 SHORT $LN83@LoadBool_e
  000e1	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000e4	88 55 f9	 mov	 BYTE PTR __k$[ebp+13], dl
  000e7	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  000ea	84 d2		 test	 dl, dl
  000ec	74 19		 je	 SHORT $LN82@LoadBool_e
  000ee	8a 40 0f	 mov	 al, BYTE PTR [eax+15]
  000f1	32 d1		 xor	 dl, cl
  000f3	88 55 fa	 mov	 BYTE PTR __k$[ebp+14], dl
  000f6	84 c0		 test	 al, al
  000f8	74 07		 je	 SHORT $LN81@LoadBool_e
  000fa	34 ea		 xor	 al, -22			; ffffffeaH
  000fc	88 45 fb	 mov	 BYTE PTR __k$[ebp+15], al
  000ff	eb 55		 jmp	 SHORT $LN1@LoadBool_e
$LN81@LoadBool_e:
  00101	c6 45 fb ea	 mov	 BYTE PTR __k$[ebp+15], -22 ; ffffffeaH
  00105	eb 4f		 jmp	 SHORT $LN1@LoadBool_e
$LN82@LoadBool_e:
  00107	88 4d fa	 mov	 BYTE PTR __k$[ebp+14], cl
  0010a	eb 4a		 jmp	 SHORT $LN1@LoadBool_e
$LN83@LoadBool_e:
  0010c	c6 45 f9 ec	 mov	 BYTE PTR __k$[ebp+13], -20 ; ffffffecH
  00110	eb 44		 jmp	 SHORT $LN1@LoadBool_e
$LN84@LoadBool_e:
  00112	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  00116	eb 3e		 jmp	 SHORT $LN1@LoadBool_e
$LN86@LoadBool_e:
  00118	88 4d f6	 mov	 BYTE PTR __k$[ebp+10], cl
  0011b	eb 39		 jmp	 SHORT $LN1@LoadBool_e
$LN87@LoadBool_e:
  0011d	c6 45 f5 ec	 mov	 BYTE PTR __k$[ebp+9], -20 ; ffffffecH
  00121	eb 33		 jmp	 SHORT $LN1@LoadBool_e
$LN88@LoadBool_e:
  00123	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  00127	eb 2d		 jmp	 SHORT $LN1@LoadBool_e
$LN89@LoadBool_e:
  00129	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  0012d	eb 27		 jmp	 SHORT $LN1@LoadBool_e
$LN90@LoadBool_e:
  0012f	88 4d f2	 mov	 BYTE PTR __k$[ebp+6], cl
  00132	eb 22		 jmp	 SHORT $LN1@LoadBool_e
$LN91@LoadBool_e:
  00134	c6 45 f1 ec	 mov	 BYTE PTR __k$[ebp+5], -20 ; ffffffecH
  00138	eb 1c		 jmp	 SHORT $LN1@LoadBool_e
$LN92@LoadBool_e:
  0013a	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  0013e	eb 16		 jmp	 SHORT $LN1@LoadBool_e
$LN93@LoadBool_e:
  00140	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  00144	eb 10		 jmp	 SHORT $LN1@LoadBool_e
$LN94@LoadBool_e:
  00146	c6 45 ee eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  0014a	eb 0a		 jmp	 SHORT $LN1@LoadBool_e
$LN95@LoadBool_e:
  0014c	c6 45 ed ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  00150	eb 04		 jmp	 SHORT $LN1@LoadBool_e
$LN96@LoadBool_e:
  00152	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@LoadBool_e:
  00156	6a 02		 push	 2
  00158	8d 45 ec	 lea	 eax, DWORD PTR __k$[ebp]
  0015b	c6 45 f7 00	 mov	 BYTE PTR __k$[ebp+11], 0
  0015f	5a		 pop	 edx
$LL104@LoadBool_e:
  00160	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00166	83 c0 04	 add	 eax, 4
  00169	4a		 dec	 edx
  0016a	75 f4		 jne	 SHORT $LL104@LoadBool_e
  0016c	6a 08		 push	 8
  0016e	58		 pop	 eax
$LL101@LoadBool_e:
  0016f	8b c8		 mov	 ecx, eax
  00171	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00177	79 05		 jns	 SHORT $LN111@LoadBool_e
  00179	49		 dec	 ecx
  0017a	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0017d	41		 inc	 ecx
$LN111@LoadBool_e:
  0017e	b2 ed		 mov	 dl, -19			; ffffffedH
  00180	2a d1		 sub	 dl, cl
  00182	30 54 05 ec	 xor	 BYTE PTR __k$[ebp+eax], dl
  00186	40		 inc	 eax
  00187	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0018a	7c e3		 jl	 SHORT $LL101@LoadBool_e

; 103  : 		return LoadBool(_k, b);

  0018c	ff 75 0c	 push	 DWORD PTR _b$[ebp]
  0018f	8d 45 ec	 lea	 eax, DWORD PTR __k$[ebp]
  00192	50		 push	 eax
  00193	8b ce		 mov	 ecx, esi
  00195	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadBool@ioINILoader@@QAE_NPBD_N@Z

; 104  : 	}

  0019b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0019e	33 cd		 xor	 ecx, ebp
  001a0	5e		 pop	 esi
  001a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a6	c9		 leave
  001a7	c2 08 00	 ret	 8
??$LoadBool_e@$0M@@ioINILoader@@QAE_NAAY0M@$$CBD_N@Z ENDP ; ioINILoader::LoadBool_e<12>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadInt_e@$09@ioINILoader@@QAEHAAY09$$CBDH@Z	; ioINILoader::LoadInt_e<10>
EXTRN	__imp_?LoadInt@ioINILoader@@QAEHPBDH@Z:PROC
; Function compile flags: /Ogsp
;	COMDAT ??$LoadInt_e@$09@ioINILoader@@QAEHAAY09$$CBDH@Z
_TEXT	SEGMENT
__k$ = -20						; size = 10
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_i$ = 12						; size = 4
??$LoadInt_e@$09@ioINILoader@@QAEHAAY09$$CBDH@Z PROC	; ioINILoader::LoadInt_e<10>, COMDAT
; _this$ = ecx

; 118  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 119  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	84 d2		 test	 dl, dl
  00017	0f 84 0d 01 00
	00		 je	 $LN96@LoadInt_e
  0001d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00020	88 55 ec	 mov	 BYTE PTR __k$[ebp], dl
  00023	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00026	84 d2		 test	 dl, dl
  00028	0f 84 f6 00 00
	00		 je	 $LN95@LoadInt_e
  0002e	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00031	88 55 ed	 mov	 BYTE PTR __k$[ebp+1], dl
  00034	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  00037	84 d2		 test	 dl, dl
  00039	0f 84 df 00 00
	00		 je	 $LN94@LoadInt_e
  0003f	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00042	88 55 ee	 mov	 BYTE PTR __k$[ebp+2], dl
  00045	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  00048	84 d2		 test	 dl, dl
  0004a	0f 84 c8 00 00
	00		 je	 $LN93@LoadInt_e
  00050	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00053	88 55 ef	 mov	 BYTE PTR __k$[ebp+3], dl
  00056	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  00059	84 d2		 test	 dl, dl
  0005b	0f 84 b1 00 00
	00		 je	 $LN92@LoadInt_e
  00061	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00064	88 55 f0	 mov	 BYTE PTR __k$[ebp+4], dl
  00067	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006a	84 d2		 test	 dl, dl
  0006c	0f 84 9a 00 00
	00		 je	 $LN91@LoadInt_e
  00072	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00075	88 55 f1	 mov	 BYTE PTR __k$[ebp+5], dl
  00078	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0007b	84 d2		 test	 dl, dl
  0007d	0f 84 83 00 00
	00		 je	 $LN90@LoadInt_e
  00083	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00086	88 55 f2	 mov	 BYTE PTR __k$[ebp+6], dl
  00089	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0008c	84 d2		 test	 dl, dl
  0008e	74 70		 je	 SHORT $LN89@LoadInt_e
  00090	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00093	88 55 f3	 mov	 BYTE PTR __k$[ebp+7], dl
  00096	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  00099	84 d2		 test	 dl, dl
  0009b	74 5d		 je	 SHORT $LN88@LoadInt_e
  0009d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000a0	80 78 09 00	 cmp	 BYTE PTR [eax+9], 0
  000a4	88 55 f4	 mov	 BYTE PTR __k$[ebp+8], dl
  000a7	0f 84 81 00 00
	00		 je	 $LN1@LoadInt_e
  000ad	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000b0	84 d2		 test	 dl, dl
  000b2	74 40		 je	 SHORT $LN86@LoadInt_e
  000b4	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000b7	88 55 f6	 mov	 BYTE PTR __k$[ebp+10], dl
  000ba	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000bd	84 d2		 test	 dl, dl
  000bf	74 2d		 je	 SHORT $LN85@LoadInt_e
  000c1	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000c4	88 55 f7	 mov	 BYTE PTR __k$[ebp+11], dl
  000c7	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000ca	84 d2		 test	 dl, dl
  000cc	74 1a		 je	 SHORT $LN84@LoadInt_e
  000ce	8a 40 0d	 mov	 al, BYTE PTR [eax+13]
  000d1	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000d4	88 55 f8	 mov	 BYTE PTR __k$[ebp+12], dl
  000d7	84 c0		 test	 al, al
  000d9	74 07		 je	 SHORT $LN83@LoadInt_e
  000db	34 ec		 xor	 al, -20			; ffffffecH
  000dd	88 45 f9	 mov	 BYTE PTR __k$[ebp+13], al
  000e0	eb 4c		 jmp	 SHORT $LN1@LoadInt_e
$LN83@LoadInt_e:
  000e2	c6 45 f9 ec	 mov	 BYTE PTR __k$[ebp+13], -20 ; ffffffecH
  000e6	eb 46		 jmp	 SHORT $LN1@LoadInt_e
$LN84@LoadInt_e:
  000e8	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  000ec	eb 40		 jmp	 SHORT $LN1@LoadInt_e
$LN85@LoadInt_e:
  000ee	c6 45 f7 ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  000f2	eb 3a		 jmp	 SHORT $LN1@LoadInt_e
$LN86@LoadInt_e:
  000f4	c6 45 f6 eb	 mov	 BYTE PTR __k$[ebp+10], -21 ; ffffffebH
  000f8	eb 34		 jmp	 SHORT $LN1@LoadInt_e
$LN88@LoadInt_e:
  000fa	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  000fe	eb 2e		 jmp	 SHORT $LN1@LoadInt_e
$LN89@LoadInt_e:
  00100	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  00104	eb 28		 jmp	 SHORT $LN1@LoadInt_e
$LN90@LoadInt_e:
  00106	c6 45 f2 eb	 mov	 BYTE PTR __k$[ebp+6], -21 ; ffffffebH
  0010a	eb 22		 jmp	 SHORT $LN1@LoadInt_e
$LN91@LoadInt_e:
  0010c	c6 45 f1 ec	 mov	 BYTE PTR __k$[ebp+5], -20 ; ffffffecH
  00110	eb 1c		 jmp	 SHORT $LN1@LoadInt_e
$LN92@LoadInt_e:
  00112	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  00116	eb 16		 jmp	 SHORT $LN1@LoadInt_e
$LN93@LoadInt_e:
  00118	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  0011c	eb 10		 jmp	 SHORT $LN1@LoadInt_e
$LN94@LoadInt_e:
  0011e	c6 45 ee eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  00122	eb 0a		 jmp	 SHORT $LN1@LoadInt_e
$LN95@LoadInt_e:
  00124	c6 45 ed ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  00128	eb 04		 jmp	 SHORT $LN1@LoadInt_e
$LN96@LoadInt_e:
  0012a	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@LoadInt_e:
  0012e	6a 02		 push	 2
  00130	8d 45 ec	 lea	 eax, DWORD PTR __k$[ebp]
  00133	c6 45 f5 00	 mov	 BYTE PTR __k$[ebp+9], 0
  00137	5a		 pop	 edx
$LL104@LoadInt_e:
  00138	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0013e	83 c0 04	 add	 eax, 4
  00141	4a		 dec	 edx
  00142	75 f4		 jne	 SHORT $LL104@LoadInt_e

; 120  : 		return LoadInt(_k, i);

  00144	ff 75 0c	 push	 DWORD PTR _i$[ebp]
  00147	80 75 f4 ed	 xor	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  0014b	8d 45 ec	 lea	 eax, DWORD PTR __k$[ebp]
  0014e	50		 push	 eax
  0014f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 121  : 	}

  00155	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00158	33 cd		 xor	 ecx, ebp
  0015a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015f	c9		 leave
  00160	c2 08 00	 ret	 8
??$LoadInt_e@$09@ioINILoader@@QAEHAAY09$$CBDH@Z ENDP	; ioINILoader::LoadInt_e<10>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadString_e@$0L@@ioINILoader@@QAEXAAY0L@$$CBDAAY00$$CBDPADH@Z ; ioINILoader::LoadString_e<11>
EXTRN	__imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z:PROC
; Function compile flags: /Ogsp
;	COMDAT ??$LoadString_e@$0L@@ioINILoader@@QAEXAAY0L@$$CBDAAY00$$CBDPADH@Z
_TEXT	SEGMENT
__k$ = -20						; size = 11
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_d$ = 12						; size = 4
_b$ = 16						; size = 4
_i$ = 20						; size = 4
??$LoadString_e@$0L@@ioINILoader@@QAEXAAY0L@$$CBDAAY00$$CBDPADH@Z PROC ; ioINILoader::LoadString_e<11>, COMDAT
; _this$ = ecx

; 161  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 162  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	8b 75 0c	 mov	 esi, DWORD PTR _d$[ebp]
  0001a	57		 push	 edi
  0001b	8b 7d 10	 mov	 edi, DWORD PTR _b$[ebp]
  0001e	84 d2		 test	 dl, dl
  00020	0f 84 1b 01 00
	00		 je	 $LN96@LoadString
  00026	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00029	88 55 ec	 mov	 BYTE PTR __k$[ebp], dl
  0002c	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002f	84 d2		 test	 dl, dl
  00031	0f 84 04 01 00
	00		 je	 $LN95@LoadString
  00037	b3 ec		 mov	 bl, -20			; ffffffecH
  00039	32 d3		 xor	 dl, bl
  0003b	88 55 ed	 mov	 BYTE PTR __k$[ebp+1], dl
  0003e	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  00041	84 d2		 test	 dl, dl
  00043	0f 84 ec 00 00
	00		 je	 $LN94@LoadString
  00049	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0004c	88 55 ee	 mov	 BYTE PTR __k$[ebp+2], dl
  0004f	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  00052	84 d2		 test	 dl, dl
  00054	0f 84 d5 00 00
	00		 je	 $LN93@LoadString
  0005a	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0005d	88 55 ef	 mov	 BYTE PTR __k$[ebp+3], dl
  00060	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  00063	84 d2		 test	 dl, dl
  00065	0f 84 be 00 00
	00		 je	 $LN92@LoadString
  0006b	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0006e	88 55 f0	 mov	 BYTE PTR __k$[ebp+4], dl
  00071	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00074	84 d2		 test	 dl, dl
  00076	0f 84 a8 00 00
	00		 je	 $LN91@LoadString
  0007c	32 d3		 xor	 dl, bl
  0007e	88 55 f1	 mov	 BYTE PTR __k$[ebp+5], dl
  00081	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00084	84 d2		 test	 dl, dl
  00086	0f 84 92 00 00
	00		 je	 $LN90@LoadString
  0008c	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0008f	88 55 f2	 mov	 BYTE PTR __k$[ebp+6], dl
  00092	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00095	84 d2		 test	 dl, dl
  00097	74 7f		 je	 SHORT $LN89@LoadString
  00099	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009c	88 55 f3	 mov	 BYTE PTR __k$[ebp+7], dl
  0009f	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a2	84 d2		 test	 dl, dl
  000a4	74 6c		 je	 SHORT $LN88@LoadString
  000a6	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000a9	88 55 f4	 mov	 BYTE PTR __k$[ebp+8], dl
  000ac	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000af	84 d2		 test	 dl, dl
  000b1	74 5a		 je	 SHORT $LN87@LoadString
  000b3	32 d3		 xor	 dl, bl
  000b5	80 78 0a 00	 cmp	 BYTE PTR [eax+10], 0
  000b9	88 55 f5	 mov	 BYTE PTR __k$[ebp+9], dl
  000bc	0f 84 83 00 00
	00		 je	 $LN1@LoadString
  000c2	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000c5	84 d2		 test	 dl, dl
  000c7	74 3e		 je	 SHORT $LN85@LoadString
  000c9	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000cc	88 55 f7	 mov	 BYTE PTR __k$[ebp+11], dl
  000cf	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000d2	84 d2		 test	 dl, dl
  000d4	74 2b		 je	 SHORT $LN84@LoadString
  000d6	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000d9	88 55 f8	 mov	 BYTE PTR __k$[ebp+12], dl
  000dc	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000df	84 d2		 test	 dl, dl
  000e1	74 19		 je	 SHORT $LN83@LoadString
  000e3	8a 40 0e	 mov	 al, BYTE PTR [eax+14]
  000e6	32 d3		 xor	 dl, bl
  000e8	88 55 f9	 mov	 BYTE PTR __k$[ebp+13], dl
  000eb	84 c0		 test	 al, al
  000ed	74 07		 je	 SHORT $LN82@LoadString
  000ef	34 eb		 xor	 al, -21			; ffffffebH
  000f1	88 45 fa	 mov	 BYTE PTR __k$[ebp+14], al
  000f4	eb 4f		 jmp	 SHORT $LN1@LoadString
$LN82@LoadString:
  000f6	c6 45 fa eb	 mov	 BYTE PTR __k$[ebp+14], -21 ; ffffffebH
  000fa	eb 49		 jmp	 SHORT $LN1@LoadString
$LN83@LoadString:
  000fc	88 5d f9	 mov	 BYTE PTR __k$[ebp+13], bl
  000ff	eb 44		 jmp	 SHORT $LN1@LoadString
$LN84@LoadString:
  00101	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  00105	eb 3e		 jmp	 SHORT $LN1@LoadString
$LN85@LoadString:
  00107	c6 45 f7 ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  0010b	eb 38		 jmp	 SHORT $LN1@LoadString
$LN87@LoadString:
  0010d	88 5d f5	 mov	 BYTE PTR __k$[ebp+9], bl
  00110	eb 33		 jmp	 SHORT $LN1@LoadString
$LN88@LoadString:
  00112	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  00116	eb 2d		 jmp	 SHORT $LN1@LoadString
$LN89@LoadString:
  00118	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  0011c	eb 27		 jmp	 SHORT $LN1@LoadString
$LN90@LoadString:
  0011e	c6 45 f2 eb	 mov	 BYTE PTR __k$[ebp+6], -21 ; ffffffebH
  00122	eb 21		 jmp	 SHORT $LN1@LoadString
$LN91@LoadString:
  00124	88 5d f1	 mov	 BYTE PTR __k$[ebp+5], bl
  00127	eb 1c		 jmp	 SHORT $LN1@LoadString
$LN92@LoadString:
  00129	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  0012d	eb 16		 jmp	 SHORT $LN1@LoadString
$LN93@LoadString:
  0012f	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  00133	eb 10		 jmp	 SHORT $LN1@LoadString
$LN94@LoadString:
  00135	c6 45 ee eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  00139	eb 0a		 jmp	 SHORT $LN1@LoadString
$LN95@LoadString:
  0013b	c6 45 ed ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  0013f	eb 04		 jmp	 SHORT $LN1@LoadString
$LN96@LoadString:
  00141	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@LoadString:
  00145	6a 02		 push	 2
  00147	8d 45 ec	 lea	 eax, DWORD PTR __k$[ebp]
  0014a	c6 45 f6 00	 mov	 BYTE PTR __k$[ebp+10], 0
  0014e	5a		 pop	 edx
$LL104@LoadString:
  0014f	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00155	83 c0 04	 add	 eax, 4
  00158	4a		 dec	 edx
  00159	75 f4		 jne	 SHORT $LL104@LoadString
  0015b	6a 08		 push	 8
  0015d	58		 pop	 eax
$LL101@LoadString:
  0015e	8b d0		 mov	 edx, eax
  00160	81 e2 03 00 00
	80		 and	 edx, -2147483645	; 80000003H
  00166	79 05		 jns	 SHORT $LN111@LoadString
  00168	4a		 dec	 edx
  00169	83 ca fc	 or	 edx, -4			; fffffffcH
  0016c	42		 inc	 edx
$LN111@LoadString:
  0016d	b3 ed		 mov	 bl, -19			; ffffffedH
  0016f	2a da		 sub	 bl, dl
  00171	30 5c 05 ec	 xor	 BYTE PTR __k$[ebp+eax], bl
  00175	40		 inc	 eax
  00176	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00179	7c e3		 jl	 SHORT $LL101@LoadString

; 163  : 		LoadString(_k, d, b, i);

  0017b	ff 75 14	 push	 DWORD PTR _i$[ebp]
  0017e	8d 45 ec	 lea	 eax, DWORD PTR __k$[ebp]
  00181	57		 push	 edi
  00182	56		 push	 esi
  00183	50		 push	 eax
  00184	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 164  : 	}

  0018a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018d	5f		 pop	 edi
  0018e	5e		 pop	 esi
  0018f	33 cd		 xor	 ecx, ebp
  00191	5b		 pop	 ebx
  00192	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00197	c9		 leave
  00198	c2 10 00	 ret	 16			; 00000010H
??$LoadString_e@$0L@@ioINILoader@@QAEXAAY0L@$$CBDAAY00$$CBDPADH@Z ENDP ; ioINILoader::LoadString_e<11>
_TEXT	ENDS
PUBLIC	??B?$CEncrypt@M@@QAEMXZ				; CEncrypt<float>::operator float
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
;	COMDAT ??B?$CEncrypt@M@@QAEMXZ
_TEXT	SEGMENT
_value$ = -4						; size = 4
??B?$CEncrypt@M@@QAEMXZ PROC				; CEncrypt<float>::operator float, COMDAT
; _this$ = ecx

; 134  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 135  : 		type value;
; 136  : 		DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool

; 137  : 
; 138  : #ifdef _NOTUSE
; 139  : 		Debug();
; 140  : #endif
; 141  : 		return value;

  0000d	d9 45 fc	 fld	 DWORD PTR _value$[ebp]

; 142  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@M@@QAEMXZ ENDP				; CEncrypt<float>::operator float
_TEXT	ENDS
PUBLIC	??B?$CEncrypt@M@@QBEMXZ				; CEncrypt<float>::operator float
; Function compile flags: /Ogsp
;	COMDAT ??B?$CEncrypt@M@@QBEMXZ
_TEXT	SEGMENT
_value$ = -4						; size = 4
??B?$CEncrypt@M@@QBEMXZ PROC				; CEncrypt<float>::operator float, COMDAT
; _this$ = ecx

; 145  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 146  : 		//UJ 130829, const도 똑같이 하면 된다 --start
; 147  : 		type value;
; 148  : 		CEncrypt<type>* pThis = const_cast<CEncrypt<type>*>(this);
; 149  : 		pThis->DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool

; 150  : 		//// const에서 DecryptValueToPool 사용할 수 없으므로 아래와 같이함.
; 151  :  		//type value;
; 152  : 		//char szTempMem[MAX_ENCRYPT];
; 153  : 		//m_RC5.DecryptByte( m_MemPool, szTempMem, max(m_ValueSize, DEFAULT_ENCRYPT) );
; 154  : 		//memcpy( &value, szTempMem, m_ValueSize );
; 155  : 		//UJ --end
; 156  : 
; 157  : #ifdef _NOTUSE
; 158  : 		Debug();
; 159  : #endif
; 160  : 		return value;

  0000d	d9 45 fc	 fld	 DWORD PTR _value$[ebp]

; 161  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@M@@QBEMXZ ENDP				; CEncrypt<float>::operator float
_TEXT	ENDS
PUBLIC	??4?$CEncrypt@M@@QAEMM@Z			; CEncrypt<float>::operator=
; Function compile flags: /Ogsp
;	COMDAT ??4?$CEncrypt@M@@QAEMM@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
_inValue$ = 8						; size = 4
??4?$CEncrypt@M@@QAEMM@Z PROC				; CEncrypt<float>::operator=, COMDAT
; _this$ = ecx

; 1654 : 	{	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1655 : 		type value = inValue;

  00003	d9 45 08	 fld	 DWORD PTR _inValue$[ebp]

; 1656 : 		EncryptValueToPool((char*)&value);

  00006	8d 45 08	 lea	 eax, DWORD PTR _value$[ebp]
  00009	50		 push	 eax
  0000a	d9 5d 08	 fstp	 DWORD PTR _value$[ebp]
  0000d	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 1657 : #ifdef _NOTUSE
; 1658 : 		m_value = inValue;
; 1659 : 		Debug();
; 1660 : #endif
; 1661 : 		return value;

  00012	d9 45 08	 fld	 DWORD PTR _value$[ebp]

; 1662 : 	}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??4?$CEncrypt@M@@QAEMM@Z ENDP				; CEncrypt<float>::operator=
_TEXT	ENDS
PUBLIC	??O?$CEncrypt@M@@QAE_NABM@Z			; CEncrypt<float>::operator>
; Function compile flags: /Ogsp
;	COMDAT ??O?$CEncrypt@M@@QAE_NABM@Z
_TEXT	SEGMENT
_value$ = -4						; size = 4
_inValue$ = 8						; size = 4
??O?$CEncrypt@M@@QAE_NABM@Z PROC			; CEncrypt<float>::operator>, COMDAT
; _this$ = ecx

; 1811 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1812 : 		type value;
; 1813 : 		DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool

; 1814 : #ifdef _NOTUSE
; 1815 : 		Debug();
; 1816 : #endif
; 1817 : 		return (value > inValue);

  0000d	8b 45 08	 mov	 eax, DWORD PTR _inValue$[ebp]
  00010	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  00014	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _value$[ebp]
  00019	0f 5a c0	 cvtps2pd xmm0, xmm0
  0001c	0f 5a c9	 cvtps2pd xmm1, xmm1
  0001f	33 c0		 xor	 eax, eax
  00021	66 0f 2f c1	 comisd	 xmm0, xmm1
  00025	76 01		 jbe	 SHORT $LN4@operator@2
  00027	40		 inc	 eax
$LN4@operator@2:

; 1818 : 	}		

  00028	c9		 leave
  00029	c2 04 00	 ret	 4
??O?$CEncrypt@M@@QAE_NABM@Z ENDP			; CEncrypt<float>::operator>
_TEXT	ENDS
PUBLIC	??B?$CEncrypt@K@@QBEKXZ				; CEncrypt<unsigned long>::operator unsigned long
; Function compile flags: /Ogsp
;	COMDAT ??B?$CEncrypt@K@@QBEKXZ
_TEXT	SEGMENT
_value$ = -4						; size = 4
??B?$CEncrypt@K@@QBEKXZ PROC				; CEncrypt<unsigned long>::operator unsigned long, COMDAT
; _this$ = ecx

; 145  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 146  : 		//UJ 130829, const도 똑같이 하면 된다 --start
; 147  : 		type value;
; 148  : 		CEncrypt<type>* pThis = const_cast<CEncrypt<type>*>(this);
; 149  : 		pThis->DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z ; CEncrypt<unsigned long>::DecryptValueToPool

; 150  : 		//// const에서 DecryptValueToPool 사용할 수 없으므로 아래와 같이함.
; 151  :  		//type value;
; 152  : 		//char szTempMem[MAX_ENCRYPT];
; 153  : 		//m_RC5.DecryptByte( m_MemPool, szTempMem, max(m_ValueSize, DEFAULT_ENCRYPT) );
; 154  : 		//memcpy( &value, szTempMem, m_ValueSize );
; 155  : 		//UJ --end
; 156  : 
; 157  : #ifdef _NOTUSE
; 158  : 		Debug();
; 159  : #endif
; 160  : 		return value;

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _value$[ebp]

; 161  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@K@@QBEKXZ ENDP				; CEncrypt<unsigned long>::operator unsigned long
_TEXT	ENDS
PUBLIC	??4?$CEncrypt@K@@QAEKK@Z			; CEncrypt<unsigned long>::operator=
; Function compile flags: /Ogsp
;	COMDAT ??4?$CEncrypt@K@@QAEKK@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
_inValue$ = 8						; size = 4
??4?$CEncrypt@K@@QAEKK@Z PROC				; CEncrypt<unsigned long>::operator=, COMDAT
; _this$ = ecx

; 1262 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1263 : 		
; 1264 : 		type value = inValue;

  00003	8b 45 08	 mov	 eax, DWORD PTR _inValue$[ebp]
  00006	89 45 08	 mov	 DWORD PTR _value$[ebp], eax

; 1265 : 		EncryptValueToPool((char*)&value);

  00009	8d 45 08	 lea	 eax, DWORD PTR _value$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z ; CEncrypt<unsigned long>::EncryptValueToPool

; 1266 : #ifdef _NOTUSE
; 1267 : 		m_value = inValue;
; 1268 : 		Debug();
; 1269 : #endif
; 1270 : 		return value;

  00012	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]

; 1271 : 	}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??4?$CEncrypt@K@@QAEKK@Z ENDP				; CEncrypt<unsigned long>::operator=
_TEXT	ENDS
PUBLIC	??4?$CEncrypt@_N@@QAE_N_N@Z			; CEncrypt<bool>::operator=
; Function compile flags: /Ogsp
;	COMDAT ??4?$CEncrypt@_N@@QAE_N_N@Z
_TEXT	SEGMENT
_inValue$ = 8						; size = 1
_value$ = 11						; size = 1
??4?$CEncrypt@_N@@QAE_N_N@Z PROC			; CEncrypt<bool>::operator=, COMDAT
; _this$ = ecx

; 225  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 226  : 		type value = inValue;

  00003	8a 45 08	 mov	 al, BYTE PTR _inValue$[ebp]
  00006	88 45 0b	 mov	 BYTE PTR _value$[ebp], al

; 227  : 		EncryptValueToPool((char*)&value);

  00009	8d 45 0b	 lea	 eax, DWORD PTR _value$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@_N@@AAEXPBD@Z ; CEncrypt<bool>::EncryptValueToPool

; 228  : #ifdef _NOTUSE
; 229  : 		m_value = inValue;
; 230  : 		Debug();
; 231  : #endif
; 232  : 		return value;

  00012	8a 45 0b	 mov	 al, BYTE PTR _value$[ebp]

; 233  : 	}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??4?$CEncrypt@_N@@QAE_N_N@Z ENDP			; CEncrypt<bool>::operator=
_TEXT	ENDS
PUBLIC	??B?$CEncrypt@W4TeamType@@@@QBE?AW4TeamType@@XZ	; CEncrypt<enum TeamType>::operator enum TeamType
; Function compile flags: /Ogsp
;	COMDAT ??B?$CEncrypt@W4TeamType@@@@QBE?AW4TeamType@@XZ
_TEXT	SEGMENT
_value$ = -4						; size = 4
??B?$CEncrypt@W4TeamType@@@@QBE?AW4TeamType@@XZ PROC	; CEncrypt<enum TeamType>::operator enum TeamType, COMDAT
; _this$ = ecx

; 145  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 146  : 		//UJ 130829, const도 똑같이 하면 된다 --start
; 147  : 		type value;
; 148  : 		CEncrypt<type>* pThis = const_cast<CEncrypt<type>*>(this);
; 149  : 		pThis->DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool

; 150  : 		//// const에서 DecryptValueToPool 사용할 수 없으므로 아래와 같이함.
; 151  :  		//type value;
; 152  : 		//char szTempMem[MAX_ENCRYPT];
; 153  : 		//m_RC5.DecryptByte( m_MemPool, szTempMem, max(m_ValueSize, DEFAULT_ENCRYPT) );
; 154  : 		//memcpy( &value, szTempMem, m_ValueSize );
; 155  : 		//UJ --end
; 156  : 
; 157  : #ifdef _NOTUSE
; 158  : 		Debug();
; 159  : #endif
; 160  : 		return value;

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _value$[ebp]

; 161  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@W4TeamType@@@@QBE?AW4TeamType@@XZ ENDP	; CEncrypt<enum TeamType>::operator enum TeamType
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	_rkLoader$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	__imp_??4ioHashString@@QAEAAV0@PBD@Z:PROC
EXTRN	?LoadProperty@ioBuff@@UAEXAAVioINILoader@@@Z:PROC ; ioBuff::LoadProperty
EXTRN	_memset:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stringprotect.h
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iohpstealbuff.cpp
CONST	ENDS
;	COMDAT ?LoadProperty@ioHPStealBuff@@UAEXAAVioINILoader@@@Z
_TEXT	SEGMENT
_rkLoader$GSCopy$ = -284				; size = 4
_szBuf$ = -280						; size = 260
__k$526115 = -20					; size = 11
__k$525990 = -20					; size = 10
__k$525865 = -20					; size = 12
__k$525740 = -20					; size = 10
__k$525633 = -16					; size = 7
__k$525503 = -16					; size = 8
__$ArrayPad$ = -4					; size = 4
_rkLoader$ = 8						; size = 4
?LoadProperty@ioHPStealBuff@@UAEXAAVioINILoader@@@Z PROC ; ioHPStealBuff::LoadProperty, COMDAT
; _this$ = ecx

; 31   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 1c 01 00
	00		 sub	 esp, 284		; 0000011cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _rkLoader$[ebp]
  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	57		 push	 edi

; 32   : 	ioBuff::LoadProperty( rkLoader );

  00019	50		 push	 eax
  0001a	8b f1		 mov	 esi, ecx

; 43   : 	rkLoader.LoadString_e( "get_effect", "", szBuf, MAX_PATH );

  0001c	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _rkLoader$GSCopy$[ebp], eax
  00022	e8 00 00 00 00	 call	 ?LoadProperty@ioBuff@@UAEXAAVioINILoader@@@Z ; ioBuff::LoadProperty
  00027	bf ed ec eb ea	 mov	 edi, -353637139		; eaebecedH
  0002c	6a 04		 push	 4
  0002e	c7 45 f0 81 83
	98 8f		 mov	 DWORD PTR __k$525503[ebp], -1885830271 ; 8f988381H
  00035	33 db		 xor	 ebx, ebx
  00037	31 7d f0	 xor	 DWORD PTR __k$525503[ebp], edi
  0003a	c7 45 f4 b2 84
	9b 00		 mov	 DWORD PTR __k$525503[ebp+4], 10192050 ; 009b84b2H
  00041	58		 pop	 eax
$LL103@LoadProper:

; 33   : 
; 34   : 	m_fLoseHP = rkLoader.LoadFloat_e( "lose_hp", 0.0f );

  00042	8b c8		 mov	 ecx, eax
  00044	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0004a	79 05		 jns	 SHORT $LN663@LoadProper
  0004c	49		 dec	 ecx
  0004d	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00050	41		 inc	 ecx
$LN663@LoadProper:
  00051	b2 ed		 mov	 dl, -19			; ffffffedH
  00053	2a d1		 sub	 dl, cl
  00055	30 54 05 f0	 xor	 BYTE PTR __k$525503[ebp+eax], dl
  00059	40		 inc	 eax
  0005a	83 f8 07	 cmp	 eax, 7
  0005d	7c e3		 jl	 SHORT $LL103@LoadProper
  0005f	0f 57 c0	 xorps	 xmm0, xmm0
  00062	51		 push	 ecx
  00063	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _rkLoader$GSCopy$[ebp]
  00069	8d 45 f0	 lea	 eax, DWORD PTR __k$525503[ebp]
  0006c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00071	50		 push	 eax
  00072	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z
  00078	d9 9e 6c 09 00
	00		 fstp	 DWORD PTR [esi+2412]

; 35   : 	m_fGetHP = rkLoader.LoadFloat_e( "get_hp", 0.0f );

  0007e	6a 04		 push	 4
  00080	c7 45 f0 8a 89
	9f b5		 mov	 DWORD PTR __k$525633[ebp], -1247835766 ; b59f898aH
  00087	31 7d f0	 xor	 DWORD PTR __k$525633[ebp], edi
  0008a	66 c7 45 f4 85
	9c		 mov	 WORD PTR __k$525633[ebp+4], 40069 ; 00009c85H
  00090	88 5d f6	 mov	 BYTE PTR __k$525633[ebp+6], bl
  00093	58		 pop	 eax
$LL209@LoadProper:
  00094	8b c8		 mov	 ecx, eax
  00096	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0009c	79 05		 jns	 SHORT $LN664@LoadProper
  0009e	49		 dec	 ecx
  0009f	83 c9 fc	 or	 ecx, -4			; fffffffcH
  000a2	41		 inc	 ecx
$LN664@LoadProper:
  000a3	b2 ed		 mov	 dl, -19			; ffffffedH
  000a5	2a d1		 sub	 dl, cl
  000a7	30 54 05 f0	 xor	 BYTE PTR __k$525633[ebp+eax], dl
  000ab	40		 inc	 eax
  000ac	83 f8 06	 cmp	 eax, 6
  000af	7c e3		 jl	 SHORT $LL209@LoadProper
  000b1	0f 57 c0	 xorps	 xmm0, xmm0
  000b4	51		 push	 ecx
  000b5	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _rkLoader$GSCopy$[ebp]
  000bb	8d 45 f0	 lea	 eax, DWORD PTR __k$525633[ebp]
  000be	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c3	50		 push	 eax
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z
  000ca	d9 9e 70 09 00
	00		 fstp	 DWORD PTR [esi+2416]
  000d0	6a 02		 push	 2

; 36   : 	m_fGetGauge = rkLoader.LoadFloat_e( "get_gauge", 0.0f );

  000d2	c7 45 ec 8a 89
	9f b5		 mov	 DWORD PTR __k$525740[ebp], -1247835766 ; b59f898aH
  000d9	c7 45 f0 8a 8d
	9e 8d		 mov	 DWORD PTR __k$525740[ebp+4], -1918988918 ; 8d9e8d8aH
  000e0	8d 45 ec	 lea	 eax, DWORD PTR __k$525740[ebp]
  000e3	66 c7 45 f4 88
	00		 mov	 WORD PTR __k$525740[ebp+8], 136 ; 00000088H
  000e9	59		 pop	 ecx
$LL318@LoadProper:
  000ea	31 38		 xor	 DWORD PTR [eax], edi
  000ec	83 c0 04	 add	 eax, 4
  000ef	49		 dec	 ecx
  000f0	75 f8		 jne	 SHORT $LL318@LoadProper
  000f2	0f 57 c0	 xorps	 xmm0, xmm0
  000f5	80 75 f4 ed	 xor	 BYTE PTR __k$525740[ebp+8], -19 ; ffffffedH
  000f9	51		 push	 ecx
  000fa	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _rkLoader$GSCopy$[ebp]
  00100	8d 45 ec	 lea	 eax, DWORD PTR __k$525740[ebp]
  00103	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00108	50		 push	 eax
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z
  0010f	d9 9e 74 09 00
	00		 fstp	 DWORD PTR [esi+2420]
  00115	6a 02		 push	 2

; 37   : 
; 38   : 	m_bSelfGauge = rkLoader.LoadBool_e( "target_self", false );

  00117	c7 45 ec 99 8d
	99 8d		 mov	 DWORD PTR __k$525865[ebp], -1919316583 ; 8d998d99H
  0011e	c7 45 f0 88 98
	b4 99		 mov	 DWORD PTR __k$525865[ebp+4], -1716217720 ; 99b49888H
  00125	8d 45 ec	 lea	 eax, DWORD PTR __k$525865[ebp]
  00128	c7 45 f4 88 80
	8d 00		 mov	 DWORD PTR __k$525865[ebp+8], 9273480 ; 008d8088H
  0012f	59		 pop	 ecx
$LL424@LoadProper:
  00130	31 38		 xor	 DWORD PTR [eax], edi
  00132	83 c0 04	 add	 eax, 4
  00135	49		 dec	 ecx
  00136	75 f8		 jne	 SHORT $LL424@LoadProper
  00138	6a 08		 push	 8
  0013a	58		 pop	 eax
$LL421@LoadProper:
  0013b	8b c8		 mov	 ecx, eax
  0013d	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00143	79 05		 jns	 SHORT $LN665@LoadProper
  00145	49		 dec	 ecx
  00146	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00149	41		 inc	 ecx
$LN665@LoadProper:
  0014a	b2 ed		 mov	 dl, -19			; ffffffedH
  0014c	2a d1		 sub	 dl, cl
  0014e	30 54 05 ec	 xor	 BYTE PTR __k$525865[ebp+eax], dl
  00152	40		 inc	 eax
  00153	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00156	7c e3		 jl	 SHORT $LL421@LoadProper
  00158	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _rkLoader$GSCopy$[ebp]
  0015e	53		 push	 ebx
  0015f	8d 45 ec	 lea	 eax, DWORD PTR __k$525865[ebp]
  00162	50		 push	 eax
  00163	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadBool@ioINILoader@@QAE_NPBD_N@Z
  00169	6a 02		 push	 2
  0016b	88 86 78 09 00
	00		 mov	 BYTE PTR [esi+2424], al

; 39   : 
; 40   : 	m_dwStealTic = (DWORD)rkLoader.LoadInt_e( "steal_tic", 0 );

  00171	c7 45 ec 9e 98
	8e 8b		 mov	 DWORD PTR __k$525990[ebp], -1953589090 ; 8b8e989eH
  00178	c7 45 f0 81 b3
	9f 83		 mov	 DWORD PTR __k$525990[ebp+4], -2086685823 ; 839fb381H
  0017f	8d 45 ec	 lea	 eax, DWORD PTR __k$525990[ebp]
  00182	66 c7 45 f4 8e
	00		 mov	 WORD PTR __k$525990[ebp+8], 142 ; 0000008eH
  00188	59		 pop	 ecx
$LL530@LoadProper:
  00189	31 38		 xor	 DWORD PTR [eax], edi
  0018b	83 c0 04	 add	 eax, 4
  0018e	49		 dec	 ecx
  0018f	75 f8		 jne	 SHORT $LL530@LoadProper
  00191	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _rkLoader$GSCopy$[ebp]
  00197	80 75 f4 ed	 xor	 BYTE PTR __k$525990[ebp+8], -19 ; ffffffedH
  0019b	53		 push	 ebx
  0019c	8d 45 ec	 lea	 eax, DWORD PTR __k$525990[ebp]
  0019f	50		 push	 eax
  001a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 41   : 
; 42   : 	char szBuf[MAX_PATH] = "";

  001a6	68 03 01 00 00	 push	 259			; 00000103H
  001ab	89 86 7c 09 00
	00		 mov	 DWORD PTR [esi+2428], eax
  001b1	8d 85 e9 fe ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp+1]
  001b7	53		 push	 ebx
  001b8	50		 push	 eax
  001b9	88 9d e8 fe ff
	ff		 mov	 BYTE PTR _szBuf$[ebp], bl
  001bf	e8 00 00 00 00	 call	 _memset
  001c4	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c7	6a 02		 push	 2

; 43   : 	rkLoader.LoadString_e( "get_effect", "", szBuf, MAX_PATH );

  001c9	c7 45 ec 8a 89
	9f b5		 mov	 DWORD PTR __k$526115[ebp], -1247835766 ; b59f898aH
  001d0	c7 45 f0 88 8a
	8d 8f		 mov	 DWORD PTR __k$526115[ebp+4], -1886549368 ; 8f8d8a88H
  001d7	66 c7 45 f4 8e
	98		 mov	 WORD PTR __k$526115[ebp+8], 39054 ; 0000988eH
  001dd	8d 45 ec	 lea	 eax, DWORD PTR __k$526115[ebp]
  001e0	88 5d f6	 mov	 BYTE PTR __k$526115[ebp+10], bl
  001e3	59		 pop	 ecx
$LL636@LoadProper:
  001e4	31 38		 xor	 DWORD PTR [eax], edi
  001e6	83 c0 04	 add	 eax, 4
  001e9	49		 dec	 ecx
  001ea	75 f8		 jne	 SHORT $LL636@LoadProper
  001ec	6a 08		 push	 8
  001ee	58		 pop	 eax
$LL633@LoadProper:
  001ef	8b c8		 mov	 ecx, eax
  001f1	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  001f7	79 05		 jns	 SHORT $LN666@LoadProper
  001f9	49		 dec	 ecx
  001fa	83 c9 fc	 or	 ecx, -4			; fffffffcH
  001fd	41		 inc	 ecx
$LN666@LoadProper:
  001fe	b2 ed		 mov	 dl, -19			; ffffffedH
  00200	2a d1		 sub	 dl, cl
  00202	30 54 05 ec	 xor	 BYTE PTR __k$526115[ebp+eax], dl
  00206	40		 inc	 eax
  00207	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0020a	7c e3		 jl	 SHORT $LL633@LoadProper
  0020c	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _rkLoader$GSCopy$[ebp]
  00212	68 04 01 00 00	 push	 260			; 00000104H
  00217	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  0021d	50		 push	 eax
  0021e	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00223	8d 45 ec	 lea	 eax, DWORD PTR __k$526115[ebp]
  00226	50		 push	 eax
  00227	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 44   : 	m_GetEffect = szBuf;

  0022d	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  00233	50		 push	 eax
  00234	8d 8e 84 09 00
	00		 lea	 ecx, DWORD PTR [esi+2436]
  0023a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 45   : }

  00240	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00243	5f		 pop	 edi
  00244	5e		 pop	 esi
  00245	33 cd		 xor	 ecx, ebp
  00247	5b		 pop	 ebx
  00248	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0024d	c9		 leave
  0024e	c2 04 00	 ret	 4
?LoadProperty@ioHPStealBuff@@UAEXAAVioINILoader@@@Z ENDP ; ioHPStealBuff::LoadProperty
_TEXT	ENDS
EXTRN	?CheckBuffDesc@ioBuff@@IAEXXZ:PROC		; ioBuff::CheckBuffDesc
EXTRN	?CheckChangeColor@ioBuff@@IAEX_N@Z:PROC		; ioBuff::CheckChangeColor
EXTRN	?CheckChangeSkill@ioBuff@@IAEX_N@Z:PROC		; ioBuff::CheckChangeSkill
EXTRN	?CheckInvisibleHelmet@ioBuff@@IAEX_N@Z:PROC	; ioBuff::CheckInvisibleHelmet
EXTRN	?CheckInvisibleCloak@ioBuff@@IAEX_N@Z:PROC	; ioBuff::CheckInvisibleCloak
EXTRN	?CheckInvisibleWeapon@ioBuff@@IAEX_N@Z:PROC	; ioBuff::CheckInvisibleWeapon
EXTRN	?GetBuffDuration@ioBuff@@IAEKXZ:PROC		; ioBuff::GetBuffDuration
EXTRN	?CalcGlobalGapTime@ioGlobalTimer@@QBEKK@Z:PROC	; ioGlobalTimer::CalcGlobalGapTime
EXTRN	?GetSingleton@ioGlobalTimer@@SAAAV1@XZ:PROC	; ioGlobalTimer::GetSingleton
; Function compile flags: /Ogsp
;	COMDAT ?ApplyStartBuff@ioHPStealBuff@@UAE_NPAVioBaseChar@@KK@Z
_TEXT	SEGMENT
_value$526277 = 8					; size = 4
_value$526272 = 8					; size = 4
_value$526268 = 8					; size = 4
_value$526263 = 8					; size = 4
_dwGlobalTimeGap$ = 8					; size = 4
_pOwner$ = 8						; size = 4
_value$526282 = 11					; size = 1
$T526260 = 12						; size = 4
_dwGlobalTime$ = 12					; size = 4
_dwGapTime$ = 16					; size = 4
?ApplyStartBuff@ioHPStealBuff@@UAE_NPAVioBaseChar@@KK@Z PROC ; ioHPStealBuff::ApplyStartBuff, COMDAT
; _this$ = ecx

; 62   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 63   : 	m_pOwner = pOwner;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pOwner$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 64   : 	DWORD dwGlobalTimeGap = g_GlobalTimer.CalcGlobalGapTime( dwGlobalTime );

  00009	ff 75 0c	 push	 DWORD PTR _dwGlobalTime$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 86 74 02 00
	00		 mov	 DWORD PTR [esi+628], eax
  00014	e8 00 00 00 00	 call	 ?GetSingleton@ioGlobalTimer@@SAAAV1@XZ ; ioGlobalTimer::GetSingleton
  00019	8b c8		 mov	 ecx, eax
  0001b	e8 00 00 00 00	 call	 ?CalcGlobalGapTime@ioGlobalTimer@@QBEKK@Z ; ioGlobalTimer::CalcGlobalGapTime

; 65   : 
; 66   : 	if( m_iOperationType != OT_SWITCH )

  00020	83 be d0 03 00
	00 02		 cmp	 DWORD PTR [esi+976], 2
  00027	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  0002d	89 45 08	 mov	 DWORD PTR _dwGlobalTimeGap$[ebp], eax
  00030	74 60		 je	 SHORT $LN9@ApplyStart

; 67   : 	{
; 68   : 		if( dwGlobalTimeGap > dwGapTime )

  00032	8b 7d 10	 mov	 edi, DWORD PTR _dwGapTime$[ebp]
  00035	3b c7		 cmp	 eax, edi
  00037	76 07		 jbe	 SHORT $LN1@ApplyStart

; 69   : 			return false;

  00039	32 c0		 xor	 al, al
  0003b	e9 bd 00 00 00	 jmp	 $LN3@ApplyStart
$LN1@ApplyStart:

; 70   : 
; 71   : 		dwGapTime -= dwGlobalTimeGap;
; 72   : 		m_dwBuffEndTime = FRAMEGETTIME() + dwGapTime;

  00040	ff d3		 call	 ebx
  00042	8b c8		 mov	 ecx, eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ
  0004a	2b 7d 08	 sub	 edi, DWORD PTR _dwGlobalTimeGap$[ebp]
  0004d	8d 8e 9c 03 00
	00		 lea	 ecx, DWORD PTR [esi+924]
  00053	03 c7		 add	 eax, edi
  00055	89 45 08	 mov	 DWORD PTR _value$526263[ebp], eax
  00058	8d 45 08	 lea	 eax, DWORD PTR _value$526263[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z ; CEncrypt<unsigned long>::EncryptValueToPool

; 73   : 		m_dwBuffStartTime = m_dwBuffEndTime - GetBuffDuration();

  00061	8b ce		 mov	 ecx, esi
  00063	e8 00 00 00 00	 call	 ?GetBuffDuration@ioBuff@@IAEKXZ ; ioBuff::GetBuffDuration
  00068	89 45 0c	 mov	 DWORD PTR $T526260[ebp], eax
  0006b	8d 45 08	 lea	 eax, DWORD PTR _value$526268[ebp]
  0006e	50		 push	 eax
  0006f	8d 8e 9c 03 00
	00		 lea	 ecx, DWORD PTR [esi+924]
  00075	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z ; CEncrypt<unsigned long>::DecryptValueToPool
  0007a	8b 45 08	 mov	 eax, DWORD PTR _value$526268[ebp]
  0007d	2b 45 0c	 sub	 eax, DWORD PTR $T526260[ebp]
  00080	8d 8e 6c 03 00
	00		 lea	 ecx, DWORD PTR [esi+876]
  00086	89 45 08	 mov	 DWORD PTR _value$526272[ebp], eax
  00089	8d 45 08	 lea	 eax, DWORD PTR _value$526272[ebp]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z ; CEncrypt<unsigned long>::EncryptValueToPool
$LN9@ApplyStart:

; 74   : 	}
; 75   : 
; 76   : 	m_bGetEffectUse = false;

  00092	c6 86 94 09 00
	00 00		 mov	 BYTE PTR [esi+2452], 0

; 77   : 	m_dwCheckTime = FRAMEGETTIME();

  00099	ff d3		 call	 ebx
  0009b	8b c8		 mov	 ecx, eax
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ
  000a3	89 45 08	 mov	 DWORD PTR _value$526277[ebp], eax
  000a6	8d 45 08	 lea	 eax, DWORD PTR _value$526277[ebp]
  000a9	50		 push	 eax
  000aa	8d 8e 3c 03 00
	00		 lea	 ecx, DWORD PTR [esi+828]
  000b0	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z ; CEncrypt<unsigned long>::EncryptValueToPool

; 78   : 	m_bLive = true;

  000b5	8d 45 0b	 lea	 eax, DWORD PTR _value$526282[ebp]
  000b8	50		 push	 eax
  000b9	8d 8e 70 07 00
	00		 lea	 ecx, DWORD PTR [esi+1904]
  000bf	c6 45 0b 01	 mov	 BYTE PTR _value$526282[ebp], 1
  000c3	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@_N@@AAEXPBD@Z ; CEncrypt<bool>::EncryptValueToPool

; 79   : 
; 80   : 	CheckInvisibleWeapon( false );

  000c8	33 ff		 xor	 edi, edi
  000ca	57		 push	 edi
  000cb	8b ce		 mov	 ecx, esi
  000cd	e8 00 00 00 00	 call	 ?CheckInvisibleWeapon@ioBuff@@IAEX_N@Z ; ioBuff::CheckInvisibleWeapon

; 81   : 	CheckInvisibleCloak( false );

  000d2	57		 push	 edi
  000d3	8b ce		 mov	 ecx, esi
  000d5	e8 00 00 00 00	 call	 ?CheckInvisibleCloak@ioBuff@@IAEX_N@Z ; ioBuff::CheckInvisibleCloak

; 82   : 	CheckInvisibleHelmet( false );

  000da	57		 push	 edi
  000db	8b ce		 mov	 ecx, esi
  000dd	e8 00 00 00 00	 call	 ?CheckInvisibleHelmet@ioBuff@@IAEX_N@Z ; ioBuff::CheckInvisibleHelmet

; 83   : 	CheckChangeSkill( true );

  000e2	6a 01		 push	 1
  000e4	8b ce		 mov	 ecx, esi
  000e6	e8 00 00 00 00	 call	 ?CheckChangeSkill@ioBuff@@IAEX_N@Z ; ioBuff::CheckChangeSkill

; 84   : 	CheckChangeColor( true );

  000eb	6a 01		 push	 1
  000ed	8b ce		 mov	 ecx, esi
  000ef	e8 00 00 00 00	 call	 ?CheckChangeColor@ioBuff@@IAEX_N@Z ; ioBuff::CheckChangeColor

; 85   : 	CheckBuffDesc();

  000f4	8b ce		 mov	 ecx, esi
  000f6	e8 00 00 00 00	 call	 ?CheckBuffDesc@ioBuff@@IAEXXZ ; ioBuff::CheckBuffDesc

; 86   : 
; 87   : 	return true;

  000fb	b0 01		 mov	 al, 1
$LN3@ApplyStart:
  000fd	5f		 pop	 edi
  000fe	5e		 pop	 esi
  000ff	5b		 pop	 ebx

; 88   : }

  00100	5d		 pop	 ebp
  00101	c2 0c 00	 ret	 12			; 0000000cH
?ApplyStartBuff@ioHPStealBuff@@UAE_NPAVioBaseChar@@KK@Z ENDP ; ioHPStealBuff::ApplyStartBuff
_TEXT	ENDS
PUBLIC	??0?$CEncrypt@K@@QAE@ABV0@@Z			; CEncrypt<unsigned long>::CEncrypt<unsigned long>
EXTRN	??0ccddaabb@@QAE@XZ:PROC			; ccddaabb::ccddaabb
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
xdata$x	SEGMENT
__unwindtable$??0?$CEncrypt@K@@QAE@ABV0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CEncrypt@K@@QAE@ABV0@@Z$0
__ehfuncinfo$??0?$CEncrypt@K@@QAE@ABV0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CEncrypt@K@@QAE@ABV0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??0?$CEncrypt@K@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_value$526294 = 8					; size = 4
_value$526289 = 8					; size = 4
_inValue$ = 8						; size = 4
??0?$CEncrypt@K@@QAE@ABV0@@Z PROC			; CEncrypt<unsigned long>::CEncrypt<unsigned long>, COMDAT
; _this$ = ecx

; 120  : 	CEncrypt( const CEncrypt<type> &inValue )   // 선언과 동시에 값을 대입하기 위해서

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0?$CEncrypt@K@@QAE@ABV0@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00014	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CEncrypt@K@@6B@
  0001a	e8 00 00 00 00	 call	 ??0ccddaabb@@QAE@XZ	; ccddaabb::ccddaabb
  0001f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 121  : 	{
; 122  : 		Init();

  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?Init@?$CEncrypt@K@@AAEXXZ ; CEncrypt<unsigned long>::Init

; 123  : 		*this = inValue;

  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _inValue$[ebp]
  0002d	8d 45 08	 lea	 eax, DWORD PTR _value$526289[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z ; CEncrypt<unsigned long>::DecryptValueToPool
  00036	8b 45 08	 mov	 eax, DWORD PTR _value$526289[ebp]
  00039	89 45 08	 mov	 DWORD PTR _value$526294[ebp], eax
  0003c	8d 45 08	 lea	 eax, DWORD PTR _value$526294[ebp]
  0003f	50		 push	 eax
  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z ; CEncrypt<unsigned long>::EncryptValueToPool

; 124  : 	}

  00047	8b c6		 mov	 eax, esi
  00049	e8 00 00 00 00	 call	 __EH_epilog3
  0004e	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CEncrypt@K@@QAE@ABV0@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	e9 00 00 00 00	 jmp	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
__ehhandler$??0?$CEncrypt@K@@QAE@ABV0@@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$CEncrypt@K@@QAE@ABV0@@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$CEncrypt@K@@QAE@ABV0@@Z ENDP			; CEncrypt<unsigned long>::CEncrypt<unsigned long>
PUBLIC	?GetTeam@ioPlayEntity@@QBE?AW4TeamType@@XZ	; ioPlayEntity::GetTeam
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioplayentity.h
;	COMDAT ?GetTeam@ioPlayEntity@@QBE?AW4TeamType@@XZ
_TEXT	SEGMENT
_value$526307 = -4					; size = 4
?GetTeam@ioPlayEntity@@QBE?AW4TeamType@@XZ PROC		; ioPlayEntity::GetTeam, COMDAT
; _this$ = ecx

; 107  : 	inline TeamType GetTeam() const { return m_TeamType; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$526307[ebp]
  00007	50		 push	 eax
  00008	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  0000e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  00013	8b 45 fc	 mov	 eax, DWORD PTR _value$526307[ebp]
  00016	c9		 leave
  00017	c3		 ret	 0
?GetTeam@ioPlayEntity@@QBE?AW4TeamType@@XZ ENDP		; ioPlayEntity::GetTeam
_TEXT	ENDS
PUBLIC	?GetCurSkillGuage@ioItem@@QBEMXZ		; ioItem::GetCurSkillGuage
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioitem.h
;	COMDAT ?GetCurSkillGuage@ioItem@@QBEMXZ
_TEXT	SEGMENT
_value$526314 = -4					; size = 4
?GetCurSkillGuage@ioItem@@QBEMXZ PROC			; ioItem::GetCurSkillGuage, COMDAT
; _this$ = ecx

; 367  : 	inline float GetCurSkillGuage() const { return m_fCurSkillGauge; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$526314[ebp]
  00007	50		 push	 eax
  00008	81 c1 f4 03 00
	00		 add	 ecx, 1012		; 000003f4H
  0000e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  00013	d9 45 fc	 fld	 DWORD PTR _value$526314[ebp]
  00016	c9		 leave
  00017	c3		 ret	 0
?GetCurSkillGuage@ioItem@@QBEMXZ ENDP			; ioItem::GetCurSkillGuage
_TEXT	ENDS
PUBLIC	??0?$CEncrypt@M@@QAE@ABV0@@Z			; CEncrypt<float>::CEncrypt<float>
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
xdata$x	SEGMENT
__unwindtable$??0?$CEncrypt@M@@QAE@ABV0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CEncrypt@M@@QAE@ABV0@@Z$0
__ehfuncinfo$??0?$CEncrypt@M@@QAE@ABV0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CEncrypt@M@@QAE@ABV0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??0?$CEncrypt@M@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_value$526327 = 8					; size = 4
_value$526322 = 8					; size = 4
_inValue$ = 8						; size = 4
??0?$CEncrypt@M@@QAE@ABV0@@Z PROC			; CEncrypt<float>::CEncrypt<float>, COMDAT
; _this$ = ecx

; 120  : 	CEncrypt( const CEncrypt<type> &inValue )   // 선언과 동시에 값을 대입하기 위해서

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0?$CEncrypt@M@@QAE@ABV0@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00014	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CEncrypt@M@@6B@
  0001a	e8 00 00 00 00	 call	 ??0ccddaabb@@QAE@XZ	; ccddaabb::ccddaabb
  0001f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 121  : 	{
; 122  : 		Init();

  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?Init@?$CEncrypt@M@@AAEXXZ ; CEncrypt<float>::Init

; 123  : 		*this = inValue;

  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _inValue$[ebp]
  0002d	8d 45 08	 lea	 eax, DWORD PTR _value$526322[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  00036	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _value$526322[ebp]
  0003b	8d 45 08	 lea	 eax, DWORD PTR _value$526327[ebp]
  0003e	50		 push	 eax
  0003f	8b ce		 mov	 ecx, esi
  00041	f3 0f 11 45 08	 movss	 DWORD PTR _value$526327[ebp], xmm0
  00046	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 124  : 	}

  0004b	8b c6		 mov	 eax, esi
  0004d	e8 00 00 00 00	 call	 __EH_epilog3
  00052	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CEncrypt@M@@QAE@ABV0@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	e9 00 00 00 00	 jmp	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
__ehhandler$??0?$CEncrypt@M@@QAE@ABV0@@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$CEncrypt@M@@QAE@ABV0@@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$CEncrypt@M@@QAE@ABV0@@Z ENDP			; CEncrypt<float>::CEncrypt<float>
PUBLIC	??0StatusValue@@QAE@ABU0@@Z			; StatusValue::StatusValue
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0StatusValue@@QAE@ABU0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0StatusValue@@QAE@ABU0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0StatusValue@@QAE@ABU0@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0StatusValue@@QAE@ABU0@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0StatusValue@@QAE@ABU0@@Z$3
__ehfuncinfo$??0StatusValue@@QAE@ABU0@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0StatusValue@@QAE@ABU0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??0StatusValue@@QAE@ABU0@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0StatusValue@@QAE@ABU0@@Z PROC			; StatusValue::StatusValue, COMDAT
; _this$ = ecx
  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0StatusValue@@QAE@ABU0@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00014	57		 push	 edi
  00015	e8 00 00 00 00	 call	 ??0?$CEncrypt@M@@QAE@ABV0@@Z ; CEncrypt<float>::CEncrypt<float>
  0001a	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0001e	8d 47 30	 lea	 eax, DWORD PTR [edi+48]
  00021	50		 push	 eax
  00022	8d 4e 30	 lea	 ecx, DWORD PTR [esi+48]
  00025	e8 00 00 00 00	 call	 ??0?$CEncrypt@M@@QAE@ABV0@@Z ; CEncrypt<float>::CEncrypt<float>
  0002a	8d 47 60	 lea	 eax, DWORD PTR [edi+96]
  0002d	50		 push	 eax
  0002e	8d 4e 60	 lea	 ecx, DWORD PTR [esi+96]
  00031	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00035	e8 00 00 00 00	 call	 ??0?$CEncrypt@M@@QAE@ABV0@@Z ; CEncrypt<float>::CEncrypt<float>
  0003a	8d 87 90 00 00
	00		 lea	 eax, DWORD PTR [edi+144]
  00040	50		 push	 eax
  00041	8d 8e 90 00 00
	00		 lea	 ecx, DWORD PTR [esi+144]
  00047	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0004b	e8 00 00 00 00	 call	 ??0?$CEncrypt@K@@QAE@ABV0@@Z ; CEncrypt<unsigned long>::CEncrypt<unsigned long>
  00050	81 c7 c0 00 00
	00		 add	 edi, 192		; 000000c0H
  00056	57		 push	 edi
  00057	8d 8e c0 00 00
	00		 lea	 ecx, DWORD PTR [esi+192]
  0005d	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00061	e8 00 00 00 00	 call	 ??0?$CEncrypt@K@@QAE@ABV0@@Z ; CEncrypt<unsigned long>::CEncrypt<unsigned long>
  00066	8b c6		 mov	 eax, esi
  00068	e8 00 00 00 00	 call	 __EH_epilog3
  0006d	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0StatusValue@@QAE@ABU0@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@M@@UAE@XZ	; CEncrypt<float>::~CEncrypt<float>
__unwindfunclet$??0StatusValue@@QAE@ABU0@@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 30	 add	 ecx, 48			; 00000030H
  0000e	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@M@@UAE@XZ	; CEncrypt<float>::~CEncrypt<float>
__unwindfunclet$??0StatusValue@@QAE@ABU0@@Z$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 60	 add	 ecx, 96			; 00000060H
  00019	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@M@@UAE@XZ	; CEncrypt<float>::~CEncrypt<float>
__unwindfunclet$??0StatusValue@@QAE@ABU0@@Z$3:
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  00027	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@K@@UAE@XZ	; CEncrypt<unsigned long>::~CEncrypt<unsigned long>
__ehhandler$??0StatusValue@@QAE@ABU0@@Z:
  0002c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00030	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00033	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00036	33 c8		 xor	 ecx, eax
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0StatusValue@@QAE@ABU0@@Z
  00042	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0StatusValue@@QAE@ABU0@@Z ENDP			; StatusValue::StatusValue
PUBLIC	__mask@@NegFloat@
PUBLIC	__real@00000000
PUBLIC	?CheckSteal@ioHPStealBuff@@IAEXXZ		; ioHPStealBuff::CheckSteal
EXTRN	?SetReserveEndBuff@ioBuff@@QAEXXZ:PROC		; ioBuff::SetReserveEndBuff
EXTRN	?AttachEffect@ioBaseChar@@QAEPAVioEffect@@ABVioHashString@@PAVioEntityEvent@@_N@Z:PROC ; ioBaseChar::AttachEffect
EXTRN	__imp_?IsEmpty@ioHashString@@QBE_NXZ:PROC
EXTRN	?SetCurSkillGauge@ioItem@@QAEXM@Z:PROC		; ioItem::SetCurSkillGauge
EXTRN	?GetMaxSkillGauge@ioItem@@QAEMABVioHashString@@@Z:PROC ; ioItem::GetMaxSkillGauge
EXTRN	__imp_??9ioHashString@@QBE_NABV0@@Z:PROC
EXTRN	?GetEquipedSkill@ioBaseChar@@QAEPAVioSkill@@H@Z:PROC ; ioBaseChar::GetEquipedSkill
EXTRN	?GetEquipedItem@ioBaseChar@@QAEPAVioItem@@H@Z:PROC ; ioBaseChar::GetEquipedItem
EXTRN	?RecoveryHP@ioBaseChar@@QAEXM@Z:PROC		; ioBaseChar::RecoveryHP
EXTRN	?GetMemberBalanceRateForDamage@ioBaseChar@@QAEMW4TeamType@@@Z:PROC ; ioBaseChar::GetMemberBalanceRateForDamage
EXTRN	?IsEnableStealHP@ioBaseChar@@QAE_NXZ:PROC	; ioBaseChar::IsEnableStealHP
EXTRN	?GetBaseChar@ioBaseChar@@QAEPAV1@ABVioHashString@@@Z:PROC ; ioBaseChar::GetBaseChar
EXTRN	__EH_epilog3_GS:PROC
EXTRN	__EH_prolog3_GS:PROC
;	COMDAT __mask@@NegFloat@
CONST	SEGMENT
__mask@@NegFloat@ DB 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CheckSteal@ioHPStealBuff@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CheckSteal@ioHPStealBuff@@IAEXXZ$0
__ehfuncinfo$?CheckSteal@ioHPStealBuff@@IAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CheckSteal@ioHPStealBuff@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iohpstealbuff.cpp
xdata$x	ENDS
;	COMDAT ?CheckSteal@ioHPStealBuff@@IAEXXZ
_TEXT	SEGMENT
_fRate$ = -284						; size = 4
_value$526434 = -280					; size = 4
_dwCurTime$ = -276					; size = 4
_value$526449 = -272					; size = 4
_fCurLoseHP$523852 = -268				; size = 4
_pCreator$ = -264					; size = 4
_value$526376 = -260					; size = 4
_value$526363 = -260					; size = 4
_iSlot$523871 = -260					; size = 4
_iSlot$523859 = -260					; size = 4
_rkHP$523851 = -256					; size = 240
__$EHRec$ = -12						; size = 12
?CheckSteal@ioHPStealBuff@@IAEXXZ PROC			; ioHPStealBuff::CheckSteal, COMDAT
; _this$ = ecx

; 108  : {

  00000	68 10 01 00 00	 push	 272			; 00000110H
  00005	b8 00 00 00 00	 mov	 eax, __ehhandler$?CheckSteal@ioHPStealBuff@@IAEXXZ
  0000a	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000f	8b f1		 mov	 esi, ecx

; 109  : 	ioBaseChar *pCreator = m_pOwner->GetBaseChar( m_CreateChar );

  00011	8b 8e 74 02 00
	00		 mov	 ecx, DWORD PTR [esi+628]
  00017	8d 86 88 02 00
	00		 lea	 eax, DWORD PTR [esi+648]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ?GetBaseChar@ioBaseChar@@QAEPAV1@ABVioHashString@@@Z ; ioBaseChar::GetBaseChar
  00023	8b c8		 mov	 ecx, eax

; 110  : 	if( !pCreator || !pCreator->IsEnableStealHP() )

  00025	33 db		 xor	 ebx, ebx
  00027	89 8d f8 fe ff
	ff		 mov	 DWORD PTR _pCreator$[ebp], ecx
  0002d	3b cb		 cmp	 ecx, ebx
  0002f	0f 84 76 03 00
	00		 je	 $LN26@CheckSteal
  00035	e8 00 00 00 00	 call	 ?IsEnableStealHP@ioBaseChar@@QAE_NXZ ; ioBaseChar::IsEnableStealHP
  0003a	84 c0		 test	 al, al
  0003c	0f 84 69 03 00
	00		 je	 $LN26@CheckSteal

; 113  : 		return;
; 114  : 	}
; 115  : 
; 116  : 	if( m_dwStealTic == 0 )

  00042	39 9e 7c 09 00
	00		 cmp	 DWORD PTR [esi+2428], ebx

; 117  : 	{
; 118  : 		SetReserveEndBuff();
; 119  : 		return;

  00048	0f 84 5d 03 00
	00		 je	 $LN26@CheckSteal

; 120  : 	}
; 121  : 
; 122  : 	DWORD dwCurTime = FRAMEGETTIME();

  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  00054	8b c8		 mov	 ecx, eax
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ
  0005c	8b f8		 mov	 edi, eax

; 123  : 	DWORD dwGapTime = dwCurTime - m_dwCheckTicTime;
; 124  : 
; 125  : 	TeamType eTeam = TEAM_NONE;
; 126  : 	if( m_pOwner->GetTeam() == TEAM_RED )

  0005e	8b 86 74 02 00
	00		 mov	 eax, DWORD PTR [esi+628]
  00064	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _value$526363[ebp]
  0006a	51		 push	 ecx
  0006b	89 bd ec fe ff
	ff		 mov	 DWORD PTR _dwCurTime$[ebp], edi
  00071	2b be 80 09 00
	00		 sub	 edi, DWORD PTR [esi+2432]
  00077	8d 88 90 00 00
	00		 lea	 ecx, DWORD PTR [eax+144]
  0007d	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  00082	83 bd fc fe ff
	ff 01		 cmp	 DWORD PTR _value$526363[ebp], 1
  00089	75 05		 jne	 SHORT $LN24@CheckSteal

; 127  : 		eTeam = TEAM_BLUE;

  0008b	6a 02		 push	 2
  0008d	5b		 pop	 ebx
  0008e	eb 24		 jmp	 SHORT $LN22@CheckSteal
$LN24@CheckSteal:

; 128  : 	else if( m_pOwner->GetTeam() == TEAM_BLUE )

  00090	8b 8e 74 02 00
	00		 mov	 ecx, DWORD PTR [esi+628]
  00096	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _value$526376[ebp]
  0009c	8d 89 90 00 00
	00		 lea	 ecx, DWORD PTR [ecx+144]
  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  000a8	83 bd fc fe ff
	ff 02		 cmp	 DWORD PTR _value$526376[ebp], 2
  000af	75 03		 jne	 SHORT $LN22@CheckSteal

; 129  : 		eTeam = TEAM_RED;

  000b1	33 db		 xor	 ebx, ebx
  000b3	43		 inc	 ebx
$LN22@CheckSteal:

; 130  : 
; 131  : 	float fRate = m_pOwner->GetMemberBalanceRateForDamage( eTeam );

  000b4	8b 8e 74 02 00
	00		 mov	 ecx, DWORD PTR [esi+628]
  000ba	53		 push	 ebx
  000bb	e8 00 00 00 00	 call	 ?GetMemberBalanceRateForDamage@ioBaseChar@@QAEMW4TeamType@@@Z ; ioBaseChar::GetMemberBalanceRateForDamage
  000c0	d9 9d e4 fe ff
	ff		 fstp	 DWORD PTR _fRate$[ebp]
  000c6	e9 ba 02 00 00	 jmp	 $LN83@CheckSteal
$LL21@CheckSteal:

; 134  : 	{
; 135  : 		// lose
; 136  : 		float fLoseHP = 0.0f;
; 137  : 		StatusValue rkHP = m_pOwner->GetHP();

  000cb	8b 86 74 02 00
	00		 mov	 eax, DWORD PTR [esi+628]
  000d1	05 c0 00 00 00	 add	 eax, 192		; 000000c0H
  000d6	50		 push	 eax
  000d7	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _rkHP$523851[ebp]
  000dd	e8 00 00 00 00	 call	 ??0StatusValue@@QAE@ABU0@@Z

; 138  : 
; 139  : 		float fCurLoseHP = m_fLoseHP * fRate;

  000e2	f3 0f 10 85 e4
	fe ff ff	 movss	 xmm0, DWORD PTR _fRate$[ebp]
  000ea	f3 0f 10 8e 6c
	09 00 00	 movss	 xmm1, DWORD PTR [esi+2412]

; 140  : 		if( rkHP.m_fCurValue > 0.0f )

  000f2	6a 04		 push	 4
  000f4	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR _rkHP$523851[ebp+40]
  000fa	50		 push	 eax
  000fb	0f 5a c0	 cvtps2pd xmm0, xmm0
  000fe	0f 5a c9	 cvtps2pd xmm1, xmm1
  00101	8d 85 1c ff ff
	ff		 lea	 eax, DWORD PTR _rkHP$523851[ebp+28]
  00107	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  0010b	33 db		 xor	 ebx, ebx
  0010d	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00111	50		 push	 eax
  00112	8d 8d 0c ff ff
	ff		 lea	 ecx, DWORD PTR _rkHP$523851[ebp+12]
  00118	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  0011b	f3 0f 11 85 f4
	fe ff ff	 movss	 DWORD PTR _fCurLoseHP$523852[ebp], xmm0
  00123	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte
  00128	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _rkHP$523851[ebp+40]
  00130	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00137	0f 86 56 02 00
	00		 jbe	 $LN19@CheckSteal

; 141  : 		{
; 142  : 			if( rkHP.m_fCurValue >= fCurLoseHP )

  0013d	6a 04		 push	 4
  0013f	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR _rkHP$523851[ebp+40]
  00145	50		 push	 eax
  00146	8d 85 1c ff ff
	ff		 lea	 eax, DWORD PTR _rkHP$523851[ebp+28]
  0014c	50		 push	 eax
  0014d	8d 8d 0c ff ff
	ff		 lea	 ecx, DWORD PTR _rkHP$523851[ebp+12]
  00153	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte
  00158	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _rkHP$523851[ebp+40]
  00160	0f 57 c9	 xorps	 xmm1, xmm1
  00163	0f 5a c8	 cvtps2pd xmm1, xmm0
  00166	f3 0f 10 85 f4
	fe ff ff	 movss	 xmm0, DWORD PTR _fCurLoseHP$523852[ebp]
  0016e	0f 5a d0	 cvtps2pd xmm2, xmm0
  00171	66 0f 2f ca	 comisd	 xmm1, xmm2

; 143  : 				fLoseHP = fCurLoseHP;
; 144  : 			else

  00175	73 23		 jae	 SHORT $LN17@CheckSteal

; 145  : 				fLoseHP = rkHP.m_fCurValue;

  00177	6a 04		 push	 4
  00179	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR _rkHP$523851[ebp+40]
  0017f	50		 push	 eax
  00180	8d 85 1c ff ff
	ff		 lea	 eax, DWORD PTR _rkHP$523851[ebp+28]
  00186	50		 push	 eax
  00187	8d 8d 0c ff ff
	ff		 lea	 ecx, DWORD PTR _rkHP$523851[ebp+12]
  0018d	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte
  00192	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _rkHP$523851[ebp+40]
$LN17@CheckSteal:

; 146  : 
; 147  : 			m_pOwner->RecoveryHP( -fLoseHP );

  0019a	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __mask@@NegFloat@
  001a1	51		 push	 ecx
  001a2	8b 8e 74 02 00
	00		 mov	 ecx, DWORD PTR [esi+628]
  001a8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ad	e8 00 00 00 00	 call	 ?RecoveryHP@ioBaseChar@@QAEXM@Z ; ioBaseChar::RecoveryHP

; 153  : 		}
; 154  : 
; 155  : 		// get hp
; 156  : 		pCreator->RecoveryHP( m_fGetHP );

  001b2	f3 0f 10 86 70
	09 00 00	 movss	 xmm0, DWORD PTR [esi+2416]
  001ba	51		 push	 ecx
  001bb	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _pCreator$[ebp]
  001c1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001c6	e8 00 00 00 00	 call	 ?RecoveryHP@ioBaseChar@@QAEXM@Z ; ioBaseChar::RecoveryHP

; 157  : 
; 158  : 		// get gauge
; 159  : 		if( m_bSelfGauge )
; 160  : 		{
; 161  : 			for( int iSlot=0; iSlot < 4; ++iSlot )

  001cb	89 9d fc fe ff
	ff		 mov	 DWORD PTR _iSlot$523859[ebp], ebx
  001d1	38 9e 78 09 00
	00		 cmp	 BYTE PTR [esi+2424], bl
  001d7	0f 84 ae 00 00
	00		 je	 $LN7@CheckSteal
$LN14@CheckSteal:

; 162  : 			{
; 163  : 				ioItem *pItem = pCreator->GetEquipedItem( iSlot );

  001dd	ff b5 fc fe ff
	ff		 push	 DWORD PTR _iSlot$523859[ebp]
  001e3	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _pCreator$[ebp]
  001e9	e8 00 00 00 00	 call	 ?GetEquipedItem@ioBaseChar@@QAEPAVioItem@@H@Z ; ioBaseChar::GetEquipedItem

; 164  : 				ioSkill *pSkill = pCreator->GetEquipedSkill( iSlot );

  001ee	ff b5 fc fe ff
	ff		 push	 DWORD PTR _iSlot$523859[ebp]
  001f4	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _pCreator$[ebp]
  001fa	8b d8		 mov	 ebx, eax
  001fc	e8 00 00 00 00	 call	 ?GetEquipedSkill@ioBaseChar@@QAEPAVioSkill@@H@Z ; ioBaseChar::GetEquipedSkill

; 165  : 
; 166  : 				if( !pItem || !pSkill ) continue;

  00201	85 db		 test	 ebx, ebx
  00203	74 1b		 je	 SHORT $LN13@CheckSteal
  00205	85 c0		 test	 eax, eax
  00207	74 17		 je	 SHORT $LN13@CheckSteal

; 167  : 				if( pItem->GetName() != m_ItemName ) continue;

  00209	8d 86 44 02 00
	00		 lea	 eax, DWORD PTR [esi+580]
  0020f	50		 push	 eax
  00210	8d 8b 34 01 00
	00		 lea	 ecx, DWORD PTR [ebx+308]
  00216	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??9ioHashString@@QBE_NABV0@@Z
  0021c	84 c0		 test	 al, al
  0021e	74 14		 je	 SHORT $LN9@CheckSteal
$LN13@CheckSteal:

; 157  : 
; 158  : 		// get gauge
; 159  : 		if( m_bSelfGauge )
; 160  : 		{
; 161  : 			for( int iSlot=0; iSlot < 4; ++iSlot )

  00220	ff 85 fc fe ff
	ff		 inc	 DWORD PTR _iSlot$523859[ebp]
  00226	83 bd fc fe ff
	ff 04		 cmp	 DWORD PTR _iSlot$523859[ebp], 4
  0022d	7c ae		 jl	 SHORT $LN14@CheckSteal

; 110  : 	if( !pCreator || !pCreator->IsEnableStealHP() )

  0022f	e9 fc 00 00 00	 jmp	 $LN5@CheckSteal
$LN9@CheckSteal:

; 168  : 
; 169  : 				float fMaxGauge = pItem->GetMaxSkillGauge(pCreator->GetCharName());

  00234	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _pCreator$[ebp]
  0023a	05 d4 02 00 00	 add	 eax, 724		; 000002d4H
  0023f	50		 push	 eax
  00240	8b cb		 mov	 ecx, ebx
  00242	e8 00 00 00 00	 call	 ?GetMaxSkillGauge@ioItem@@QAEMABVioHashString@@@Z ; ioItem::GetMaxSkillGauge
  00247	dd d8		 fstp	 ST(0)

; 170  : 				float fCurGauge = pItem->GetCurSkillGuage();

  00249	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _value$526434[ebp]
  0024f	8d 8b f4 03 00
	00		 lea	 ecx, DWORD PTR [ebx+1012]
  00255	50		 push	 eax
  00256	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool

; 171  : 
; 172  : 				fCurGauge += m_fGetGauge;

  0025b	f3 0f 10 86 74
	09 00 00	 movss	 xmm0, DWORD PTR [esi+2420]
  00263	f3 0f 10 8d e8
	fe ff ff	 movss	 xmm1, DWORD PTR _value$526434[ebp]
  0026b	0f 5a c0	 cvtps2pd xmm0, xmm0
  0026e	0f 5a c9	 cvtps2pd xmm1, xmm1

; 173  : 				pItem->SetCurSkillGauge( fCurGauge );

  00271	51		 push	 ecx
  00272	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00276	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0027a	8b cb		 mov	 ecx, ebx
  0027c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00281	e8 00 00 00 00	 call	 ?SetCurSkillGauge@ioItem@@QAEXM@Z ; ioItem::SetCurSkillGauge

; 174  : 				break;
; 175  : 			}
; 176  : 		}
; 177  : 		else

  00286	e9 a5 00 00 00	 jmp	 $LN5@CheckSteal
$LN7@CheckSteal:

; 180  : 			{
; 181  : 				ioItem *pItem = pCreator->GetEquipedItem( iSlot );

  0028b	ff b5 fc fe ff
	ff		 push	 DWORD PTR _iSlot$523871[ebp]
  00291	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _pCreator$[ebp]
  00297	e8 00 00 00 00	 call	 ?GetEquipedItem@ioBaseChar@@QAEPAVioItem@@H@Z ; ioBaseChar::GetEquipedItem

; 182  : 				ioSkill *pSkill = pCreator->GetEquipedSkill( iSlot );

  0029c	ff b5 fc fe ff
	ff		 push	 DWORD PTR _iSlot$523871[ebp]
  002a2	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _pCreator$[ebp]
  002a8	8b d8		 mov	 ebx, eax
  002aa	e8 00 00 00 00	 call	 ?GetEquipedSkill@ioBaseChar@@QAEPAVioSkill@@H@Z ; ioBaseChar::GetEquipedSkill

; 183  : 
; 184  : 				if( !pItem || !pSkill ) continue;

  002af	85 db		 test	 ebx, ebx
  002b1	74 6a		 je	 SHORT $LN6@CheckSteal
  002b3	85 c0		 test	 eax, eax
  002b5	74 66		 je	 SHORT $LN6@CheckSteal

; 185  : 				if( pSkill->CheckUseBuff( pCreator ) ) continue;

  002b7	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _pCreator$[ebp]
  002bd	8b 10		 mov	 edx, DWORD PTR [eax]
  002bf	8b c8		 mov	 ecx, eax
  002c1	ff 92 e8 00 00
	00		 call	 DWORD PTR [edx+232]
  002c7	84 c0		 test	 al, al
  002c9	75 52		 jne	 SHORT $LN6@CheckSteal

; 186  : 
; 187  : 				float fMaxGauge = pItem->GetMaxSkillGauge(pCreator->GetCharName());

  002cb	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _pCreator$[ebp]
  002d1	05 d4 02 00 00	 add	 eax, 724		; 000002d4H
  002d6	50		 push	 eax
  002d7	8b cb		 mov	 ecx, ebx
  002d9	e8 00 00 00 00	 call	 ?GetMaxSkillGauge@ioItem@@QAEMABVioHashString@@@Z ; ioItem::GetMaxSkillGauge
  002de	dd d8		 fstp	 ST(0)

; 188  : 				float fCurGauge = pItem->GetCurSkillGuage();

  002e0	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _value$526449[ebp]
  002e6	8d 8b f4 03 00
	00		 lea	 ecx, DWORD PTR [ebx+1012]
  002ec	50		 push	 eax
  002ed	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool

; 189  : 
; 190  : 				fCurGauge += m_fGetGauge;

  002f2	f3 0f 10 86 74
	09 00 00	 movss	 xmm0, DWORD PTR [esi+2420]
  002fa	f3 0f 10 8d f0
	fe ff ff	 movss	 xmm1, DWORD PTR _value$526449[ebp]
  00302	0f 5a c0	 cvtps2pd xmm0, xmm0
  00305	0f 5a c9	 cvtps2pd xmm1, xmm1

; 191  : 				pItem->SetCurSkillGauge( fCurGauge );

  00308	51		 push	 ecx
  00309	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0030d	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00311	8b cb		 mov	 ecx, ebx
  00313	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00318	e8 00 00 00 00	 call	 ?SetCurSkillGauge@ioItem@@QAEXM@Z ; ioItem::SetCurSkillGauge
$LN6@CheckSteal:

; 178  : 		{
; 179  : 			for( int iSlot=0; iSlot < 4; ++iSlot )

  0031d	ff 85 fc fe ff
	ff		 inc	 DWORD PTR _iSlot$523871[ebp]
  00323	83 bd fc fe ff
	ff 04		 cmp	 DWORD PTR _iSlot$523871[ebp], 4
  0032a	0f 8c 5b ff ff
	ff		 jl	 $LN7@CheckSteal
$LN5@CheckSteal:

; 192  : 			}
; 193  : 		}
; 194  : 
; 195  : 		dwGapTime -= m_dwStealTic;

  00330	2b be 7c 09 00
	00		 sub	 edi, DWORD PTR [esi+2428]

; 196  : 
; 197  : 		m_dwCheckTicTime = dwCurTime - dwGapTime;

  00336	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _dwCurTime$[ebp]
  0033c	2b c7		 sub	 eax, edi

; 198  : 
; 199  : 		if( !m_bGetEffectUse && !m_GetEffect.IsEmpty() )

  0033e	80 be 94 09 00
	00 00		 cmp	 BYTE PTR [esi+2452], 0
  00345	89 86 80 09 00
	00		 mov	 DWORD PTR [esi+2432], eax
  0034b	75 29		 jne	 SHORT $LN1@CheckSteal
  0034d	8d 9e 84 09 00
	00		 lea	 ebx, DWORD PTR [esi+2436]
  00353	8b cb		 mov	 ecx, ebx
  00355	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  0035b	84 c0		 test	 al, al
  0035d	75 17		 jne	 SHORT $LN1@CheckSteal

; 200  : 		{
; 201  : 			pCreator->AttachEffect( m_GetEffect, NULL );

  0035f	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _pCreator$[ebp]
  00365	6a 01		 push	 1
  00367	6a 00		 push	 0
  00369	53		 push	 ebx
  0036a	e8 00 00 00 00	 call	 ?AttachEffect@ioBaseChar@@QAEPAVioEffect@@ABVioHashString@@PAVioEntityEvent@@_N@Z ; ioBaseChar::AttachEffect

; 202  : 			m_bGetEffectUse = true;

  0036f	c6 86 94 09 00
	00 01		 mov	 BYTE PTR [esi+2452], 1
$LN1@CheckSteal:

; 203  : 		}
; 204  : 	}

  00376	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0037a	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _rkHP$523851[ebp]
  00380	e8 00 00 00 00	 call	 ??1StatusValue@@QAE@XZ
$LN83@CheckSteal:

; 132  : 
; 133  : 	while( dwGapTime > m_dwStealTic )

  00385	3b be 7c 09 00
	00		 cmp	 edi, DWORD PTR [esi+2428]
  0038b	0f 87 3a fd ff
	ff		 ja	 $LL21@CheckSteal
  00391	eb 1f		 jmp	 SHORT $LN20@CheckSteal
$LN19@CheckSteal:

; 148  : 		}
; 149  : 		else
; 150  : 		{
; 151  : 			SetReserveEndBuff();

  00393	8b ce		 mov	 ecx, esi
  00395	e8 00 00 00 00	 call	 ?SetReserveEndBuff@ioBuff@@QAEXXZ ; ioBuff::SetReserveEndBuff

; 152  : 			return;

  0039a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0039e	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _rkHP$523851[ebp]
  003a4	e8 00 00 00 00	 call	 ??1StatusValue@@QAE@XZ
  003a9	eb 07		 jmp	 SHORT $LN20@CheckSteal
$LN26@CheckSteal:

; 111  : 	{
; 112  : 		SetReserveEndBuff();

  003ab	8b ce		 mov	 ecx, esi
  003ad	e8 00 00 00 00	 call	 ?SetReserveEndBuff@ioBuff@@QAEXXZ ; ioBuff::SetReserveEndBuff
$LN20@CheckSteal:

; 205  : }

  003b2	e8 00 00 00 00	 call	 __EH_epilog3_GS
  003b7	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CheckSteal@ioHPStealBuff@@IAEXXZ$0:
  00000	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _rkHP$523851[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1StatusValue@@QAE@XZ
__ehhandler$?CheckSteal@ioHPStealBuff@@IAEXXZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a e0 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-288]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CheckSteal@ioHPStealBuff@@IAEXXZ
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CheckSteal@ioHPStealBuff@@IAEXXZ ENDP			; ioHPStealBuff::CheckSteal
EXTRN	?CheckCallingAreaWeapon@ioBuff@@IAEXXZ:PROC	; ioBuff::CheckCallingAreaWeapon
EXTRN	?ProcessBuff@ioBuff@@UAEXM@Z:PROC		; ioBuff::ProcessBuff
; Function compile flags: /Ogsp
;	COMDAT ?ProcessBuff@ioHPStealBuff@@UAEXM@Z
_TEXT	SEGMENT
_fTimePerSec$ = 8					; size = 4
?ProcessBuff@ioHPStealBuff@@UAEXM@Z PROC		; ioHPStealBuff::ProcessBuff, COMDAT
; _this$ = ecx

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 92   : 	switch( m_iOperationType )

  00006	8b 86 d0 03 00
	00		 mov	 eax, DWORD PTR [esi+976]
  0000c	85 c0		 test	 eax, eax
  0000e	74 18		 je	 SHORT $LN1@ProcessBuf
  00010	48		 dec	 eax
  00011	83 f8 02	 cmp	 eax, 2
  00014	77 17		 ja	 SHORT $LN3@ProcessBuf

; 93   : 	{
; 94   : 	case OT_SWITCH:
; 95   : 	case OT_DELAY:
; 96   : 	case OT_ACTIVE:
; 97   : 		ioBuff::ProcessBuff( fTimePerSec );

  00016	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fTimePerSec$[ebp]
  0001b	51		 push	 ecx
  0001c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00021	e8 00 00 00 00	 call	 ?ProcessBuff@ioBuff@@UAEXM@Z ; ioBuff::ProcessBuff

; 98   : 		break;

  00026	eb 05		 jmp	 SHORT $LN3@ProcessBuf
$LN1@ProcessBuf:

; 99   : 	case OT_PASSIVE:
; 100  : 		CheckCallingAreaWeapon();

  00028	e8 00 00 00 00	 call	 ?CheckCallingAreaWeapon@ioBuff@@IAEXXZ ; ioBuff::CheckCallingAreaWeapon
$LN3@ProcessBuf:

; 101  : 		break;
; 102  : 	}
; 103  : 
; 104  : 	CheckSteal();

  0002d	8b ce		 mov	 ecx, esi
  0002f	e8 00 00 00 00	 call	 ?CheckSteal@ioHPStealBuff@@IAEXXZ ; ioHPStealBuff::CheckSteal
  00034	5e		 pop	 esi

; 105  : }

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
?ProcessBuff@ioHPStealBuff@@UAEXM@Z ENDP		; ioHPStealBuff::ProcessBuff
_TEXT	ENDS
END
