; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\Lost Saga For Developer\Youtube\Tutorial\Source\src\LSClient\ioDefenseAttackSkill.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?return1@@YAIXZ					; return1
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stdafx.h
;	COMDAT ?return1@@YAIXZ
_TEXT	SEGMENT
?return1@@YAIXZ PROC					; return1, COMDAT

; 17   : 	__forceinline unsigned int return1() { __asm mov eax, 1 };

  00000	b8 01 00 00 00	 mov	 eax, 1
  00005	c3		 ret	 0
?return1@@YAIXZ ENDP					; return1
_TEXT	ENDS
PUBLIC	?return100@@YAIXZ				; return100
; Function compile flags: /Ogsp
;	COMDAT ?return100@@YAIXZ
_TEXT	SEGMENT
?return100@@YAIXZ PROC					; return100, COMDAT

; 25   : 	__forceinline unsigned int return100() { __asm mov eax, 100 };

  00000	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  00005	c3		 ret	 0
?return100@@YAIXZ ENDP					; return100
_TEXT	ENDS
PUBLIC	?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ	; ioBaseChar::GetCharName
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasechar.h
;	COMDAT ?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ
_TEXT	SEGMENT
?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ PROC	; ioBaseChar::GetCharName, COMDAT
; _this$ = ecx

; 2594 : 	inline const ioHashString& GetCharName() const { return m_Name; }

  00000	8d 81 d4 02 00
	00		 lea	 eax, DWORD PTR [ecx+724]
  00006	c3		 ret	 0
?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ ENDP	; ioBaseChar::GetCharName
_TEXT	ENDS
PUBLIC	?SetCurJumpPowerAmt@ioBaseChar@@QAEXM@Z		; ioBaseChar::SetCurJumpPowerAmt
EXTRN	__fltused:DWORD
; Function compile flags: /Ogsp
;	COMDAT ?SetCurJumpPowerAmt@ioBaseChar@@QAEXM@Z
_TEXT	SEGMENT
_fAmt$ = 8						; size = 4
?SetCurJumpPowerAmt@ioBaseChar@@QAEXM@Z PROC		; ioBaseChar::SetCurJumpPowerAmt, COMDAT
; _this$ = ecx

; 2628 : 	inline void SetCurJumpPowerAmt( float fAmt ) { m_fCurJumpPowerAmt = fAmt; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fAmt$[ebp]
  00008	f3 0f 11 81 90
	0e 00 00	 movss	 DWORD PTR [ecx+3728], xmm0
  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?SetCurJumpPowerAmt@ioBaseChar@@QAEXM@Z ENDP		; ioBaseChar::SetCurJumpPowerAmt
_TEXT	ENDS
PUBLIC	??_7ioDefenseAttackSkill@@6B@			; ioDefenseAttackSkill::`vftable'
PUBLIC	??0ioDefenseAttackSkill@@QAE@XZ			; ioDefenseAttackSkill::ioDefenseAttackSkill
PUBLIC	??_R4ioDefenseAttackSkill@@6B@			; ioDefenseAttackSkill::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVioDefenseAttackSkill@@@8		; ioDefenseAttackSkill `RTTI Type Descriptor'
PUBLIC	??_R3ioDefenseAttackSkill@@8			; ioDefenseAttackSkill::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioDefenseAttackSkill@@8			; ioDefenseAttackSkill::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ioDefenseAttackSkill@@8		; ioDefenseAttackSkill::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ioAttackSkill@@8			; ioAttackSkill::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVioAttackSkill@@@8			; ioAttackSkill `RTTI Type Descriptor'
PUBLIC	??_R3ioAttackSkill@@8				; ioAttackSkill::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioAttackSkill@@8				; ioAttackSkill::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ioSkill@@8			; ioSkill::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVioSkill@@@8				; ioSkill `RTTI Type Descriptor'
PUBLIC	??_R3ioSkill@@8					; ioSkill::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioSkill@@8					; ioSkill::`RTTI Base Class Array'
PUBLIC	?LoadProperty@ioDefenseAttackSkill@@UAEXAAVioINILoader@@@Z ; ioDefenseAttackSkill::LoadProperty
PUBLIC	?Clone@ioDefenseAttackSkill@@UAEPAVioSkill@@XZ	; ioDefenseAttackSkill::Clone
PUBLIC	?IsProtected@ioDefenseAttackSkill@@UBE_NH@Z	; ioDefenseAttackSkill::IsProtected
PUBLIC	?IsCanDefenseStateSkill@ioDefenseAttackSkill@@UAE_NXZ ; ioDefenseAttackSkill::IsCanDefenseStateSkill
PUBLIC	?SetDefenseStateSkill@ioDefenseAttackSkill@@UAEXPAVioBaseChar@@@Z ; ioDefenseAttackSkill::SetDefenseStateSkill
PUBLIC	?GetDefenseSkillBreakeType@ioSkill@@UBE?AW4DefenseBreakType@@XZ ; ioSkill::GetDefenseSkillBreakeType
PUBLIC	?IsSkillMotionEnd@ioDefenseAttackSkill@@UBE_NKPAVioBaseChar@@@Z ; ioDefenseAttackSkill::IsSkillMotionEnd
PUBLIC	?GetSkillEndNextJumpAmt@ioSkill@@UBEMXZ		; ioSkill::GetSkillEndNextJumpAmt
PUBLIC	?GetSkillEndNextLandRate@ioSkill@@UBEMXZ	; ioSkill::GetSkillEndNextLandRate
PUBLIC	?GetSkillEndNextJumpMustEnable@ioSkill@@UAE?AW4SkillEndJumpType@@XZ ; ioSkill::GetSkillEndNextJumpMustEnable
PUBLIC	?EnableChangeGrapplingTargetPos@ioSkill@@UBE_NXZ ; ioSkill::EnableChangeGrapplingTargetPos
PUBLIC	?OnSkillStart@ioDefenseAttackSkill@@UAE_NPAVioBaseChar@@@Z ; ioDefenseAttackSkill::OnSkillStart
PUBLIC	?OnProcessState@ioDefenseAttackSkill@@UAEXPAVioBaseChar@@PAVioPlayStage@@@Z ; ioDefenseAttackSkill::OnProcessState
PUBLIC	?OnSkillEnd@ioDefenseAttackSkill@@UAEXPAVioBaseChar@@@Z ; ioDefenseAttackSkill::OnSkillEnd
PUBLIC	?ApplyAttributeToWeapon@ioDefenseAttackSkill@@UAEXPAVioWeapon@@PAVioPlayStage@@@Z ; ioDefenseAttackSkill::ApplyAttributeToWeapon
PUBLIC	?CheckUseItemMesh@ioDefenseAttackSkill@@UAE_NXZ	; ioDefenseAttackSkill::CheckUseItemMesh
PUBLIC	?IsInvisibleBottomCircle@ioSkill@@UAE_NPAVioBaseChar@@@Z ; ioSkill::IsInvisibleBottomCircle
PUBLIC	?IsCanJumpingSkill@ioSkill@@UBE_NXZ		; ioSkill::IsCanJumpingSkill
PUBLIC	?IsCanJumpingSkillOnBlowWound@ioSkill@@UBE_NXZ	; ioSkill::IsCanJumpingSkillOnBlowWound
PUBLIC	?IsCanDownSkill@ioSkill@@UBE_NXZ		; ioSkill::IsCanDownSkill
PUBLIC	?IsCanBlowWoundSkill@ioSkill@@UBE_NXZ		; ioSkill::IsCanBlowWoundSkill
PUBLIC	?IsCanWoundSkill@ioSkill@@UBE_NXZ		; ioSkill::IsCanWoundSkill
PUBLIC	?IsUseActiveCnt@ioSkill@@UBE_NXZ		; ioSkill::IsUseActiveCnt
PUBLIC	?GetMaxActiveCnt@ioSkill@@UBEHPAVioBaseChar@@@Z	; ioSkill::GetMaxActiveCnt
PUBLIC	?GetCurActiveCnt@ioSkill@@UBEHPAVioBaseChar@@@Z	; ioSkill::GetCurActiveCnt
PUBLIC	?AttackSkillFire@ioDefenseAttackSkill@@MAEXPAVioBaseChar@@@Z ; ioDefenseAttackSkill::AttackSkillFire
EXTRN	??1ioAttackSkill@@UAE@XZ:PROC			; ioAttackSkill::~ioAttackSkill
EXTRN	__imp_??0ioHashString@@QAE@XZ:PROC
EXTRN	??0ioAttackSkill@@QAE@XZ:PROC			; ioAttackSkill::ioAttackSkill
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__EH_epilog3:PROC
EXTRN	__EH_prolog3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?GetTypeID@ioAttackSkill@@UBEHXZ:PROC		; ioAttackSkill::GetTypeID
EXTRN	?IsCanSwitchSkill@ioSkill@@UBE_NXZ:PROC		; ioSkill::IsCanSwitchSkill
EXTRN	?IsCanSemiSwitchSkill@ioSkill@@UBE_NXZ:PROC	; ioSkill::IsCanSemiSwitchSkill
EXTRN	?IsCanCancelBySkill@ioSkill@@UBE_NPAVioBaseChar@@AAH@Z:PROC ; ioSkill::IsCanCancelBySkill
EXTRN	?IsCanUseZeroHP@ioSkill@@UBE_NPAVioBaseChar@@@Z:PROC ; ioSkill::IsCanUseZeroHP
EXTRN	?IsCanUseSkillWithCrown@ioSkill@@UAE_NPAVioBaseChar@@@Z:PROC ; ioSkill::IsCanUseSkillWithCrown
EXTRN	?IsCanUseBoss@ioSkill@@UBE_NPAVioBaseChar@@@Z:PROC ; ioSkill::IsCanUseBoss
EXTRN	?IsCanUseFootball@ioSkill@@UBE_NXZ:PROC		; ioSkill::IsCanUseFootball
EXTRN	?IsCanUseGangSiMode@ioSkill@@UBE_NXZ:PROC	; ioSkill::IsCanUseGangSiMode
EXTRN	?IsCanUseByWeaponType@ioSkill@@UBE_NPAVioBaseChar@@@Z:PROC ; ioSkill::IsCanUseByWeaponType
EXTRN	?IsCanUseThunderBirdHold@ioSkill@@UBE_NPAVioBaseChar@@@Z:PROC ; ioSkill::IsCanUseThunderBirdHold
EXTRN	?IsCanUseLimitHP@ioSkill@@UBE_NPAVioBaseChar@@@Z:PROC ; ioSkill::IsCanUseLimitHP
EXTRN	?IsCanUseSkill@ioAttackSkill@@UAE_NPAVioBaseChar@@_N@Z:PROC ; ioAttackSkill::IsCanUseSkill
EXTRN	?IsOnOffEnable@ioSkill@@UAE_NXZ:PROC		; ioSkill::IsOnOffEnable
EXTRN	?HasBuff@ioSkill@@UBE_NH@Z:PROC			; ioSkill::HasBuff
EXTRN	?GetBuffType@ioSkill@@UAEHH@Z:PROC		; ioSkill::GetBuffType
EXTRN	?IsEnableReserve@ioSkill@@UBE_NXZ:PROC		; ioSkill::IsEnableReserve
EXTRN	?IsCharSkipState@ioSkill@@UBE?AW4SkillCharColType@@XZ:PROC ; ioSkill::IsCharSkipState
EXTRN	?IsEntityCollisionSkipState@ioSkill@@UBE_NXZ:PROC ; ioSkill::IsEntityCollisionSkipState
EXTRN	?IsEndState@ioSkill@@UBE_NXZ:PROC		; ioSkill::IsEndState
EXTRN	?IsAttackEndState@ioAttackSkill@@UBE_NXZ:PROC	; ioAttackSkill::IsAttackEndState
EXTRN	?IsJumpState@ioSkill@@UBE_NXZ:PROC		; ioSkill::IsJumpState
EXTRN	?IsDownState@ioSkill@@UBE_NXZ:PROC		; ioSkill::IsDownState
EXTRN	?IsNoDropState@ioSkill@@UBE_NXZ:PROC		; ioSkill::IsNoDropState
EXTRN	?IsCanSendControl@ioSkill@@UBE_NXZ:PROC		; ioSkill::IsCanSendControl
EXTRN	?IsSkipState@ioSkill@@UBE_NXZ:PROC		; ioSkill::IsSkipState
EXTRN	?GetSkillMoveRate@ioSkill@@UBEMXZ:PROC		; ioSkill::GetSkillMoveRate
EXTRN	?SetSkillGrapplingState@ioSkill@@UAE_NPAVioBaseChar@@ABVioHashString@@@Z:PROC ; ioSkill::SetSkillGrapplingState
EXTRN	?GetGrapplingTargetPos@ioSkill@@UAE?AUD3DXVECTOR3@@PAVioBaseChar@@0@Z:PROC ; ioSkill::GetGrapplingTargetPos
EXTRN	?GetGrapplingTargetPos@ioSkill@@UAE?AUD3DXVECTOR3@@PAVioBaseChar@@@Z:PROC ; ioSkill::GetGrapplingTargetPos
EXTRN	?GetSkillWoundGrapplingInfo@ioSkill@@UAE?AUGrapplingSkillWoundedInfo@@XZ:PROC ; ioSkill::GetSkillWoundGrapplingInfo
EXTRN	?SetCreateWeaponDependency@ioSkill@@UAEXPAVioBaseChar@@PAVioPlayStage@@@Z:PROC ; ioSkill::SetCreateWeaponDependency
EXTRN	?SetNextSkillState@ioSkill@@UAEXPAVioBaseChar@@PAVioWeapon@@@Z:PROC ; ioSkill::SetNextSkillState
EXTRN	?OnSkillEndByWounded@ioSkill@@UAEXPAVioBaseChar@@@Z:PROC ; ioSkill::OnSkillEndByWounded
EXTRN	?OnProcessNotUseSkill@ioSkill@@UAEXPAVioBaseChar@@PAVioPlayStage@@@Z:PROC ; ioSkill::OnProcessNotUseSkill
EXTRN	?OnSkillItemRelease@ioSkill@@UAEXPAVioBaseChar@@@Z:PROC ; ioSkill::OnSkillItemRelease
EXTRN	?ApplyExtraSkillInfo@ioAttackSkill@@UAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z:PROC ; ioAttackSkill::ApplyExtraSkillInfo
EXTRN	?ApplyEquipSlotSkillExtraInfo@ioSkill@@UAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z:PROC ; ioSkill::ApplyEquipSlotSkillExtraInfo
EXTRN	?ApplyExtraPassiveSkillInfo@ioSkill@@UAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z:PROC ; ioSkill::ApplyExtraPassiveSkillInfo
EXTRN	?StartPreDelayEffect@ioAttackSkill@@UAEXPAVioBaseChar@@@Z:PROC ; ioAttackSkill::StartPreDelayEffect
EXTRN	?EndPreDelayEffect@ioAttackSkill@@UAEXPAVioBaseChar@@@Z:PROC ; ioAttackSkill::EndPreDelayEffect
EXTRN	?IsUseAutoTargetValue@ioAttackSkill@@UAE_NXZ:PROC ; ioAttackSkill::IsUseAutoTargetValue
EXTRN	?IsAutoTargetDownState@ioSkill@@UAE_NXZ:PROC	; ioSkill::IsAutoTargetDownState
EXTRN	?CheckUseBuff@ioSkill@@UAE_NPAVioBaseChar@@@Z:PROC ; ioSkill::CheckUseBuff
EXTRN	?CheckUseActiveCount@ioSkill@@UAE_NXZ:PROC	; ioSkill::CheckUseActiveCount
EXTRN	?CheckAniRotate@ioSkill@@UAEXPAVioBaseChar@@@Z:PROC ; ioSkill::CheckAniRotate
EXTRN	?IsEnableDashCheck@ioSkill@@UAE_NPAVioBaseChar@@@Z:PROC ; ioSkill::IsEnableDashCheck
EXTRN	?IsEnableMultiActive@ioSkill@@UAE_NPAVioBaseChar@@@Z:PROC ; ioSkill::IsEnableMultiActive
EXTRN	?GetAutoTargetValue@ioSkill@@UAEXAAM00@Z:PROC	; ioSkill::GetAutoTargetValue
EXTRN	?GetSkillGravityRate@ioSkill@@UAEMXZ:PROC	; ioSkill::GetSkillGravityRate
EXTRN	?GetSkillMotionName@ioSkill@@UBEABVioHashString@@XZ:PROC ; ioSkill::GetSkillMotionName
EXTRN	?HasSkillMotion@ioSkill@@UBE_NXZ:PROC		; ioSkill::HasSkillMotion
EXTRN	?GetSkillMotionRate@ioSkill@@UBEMXZ:PROC	; ioSkill::GetSkillMotionRate
EXTRN	?IsPreDelayProtect@ioSkill@@UBE_NXZ:PROC	; ioSkill::IsPreDelayProtect
EXTRN	?GetPreDelayAniName@ioSkill@@UBEABVioHashString@@XZ:PROC ; ioSkill::GetPreDelayAniName
EXTRN	?GetPreDelayTime@ioSkill@@UBEKXZ:PROC		; ioSkill::GetPreDelayTime
EXTRN	?GetPreDelayOwnerEffect@ioSkill@@UBEABVioHashString@@XZ:PROC ; ioSkill::GetPreDelayOwnerEffect
EXTRN	?GetPreDelayOtherEffect@ioSkill@@UBEABVioHashString@@XZ:PROC ; ioSkill::GetPreDelayOtherEffect
EXTRN	?SetCancelSkill@ioSkill@@UAEXPAVioBaseChar@@@Z:PROC ; ioSkill::SetCancelSkill
EXTRN	?ClearAirJump@ioSkill@@MAEXXZ:PROC		; ioSkill::ClearAirJump
EXTRN	?SetAirJump@ioSkill@@MAEXPAVioBaseChar@@HM@Z:PROC ; ioSkill::SetAirJump
EXTRN	?CheckAirJump@ioSkill@@MAEXPAVioBaseChar@@@Z:PROC ; ioSkill::CheckAirJump
EXTRN	?UseActiveCount@ioSkill@@UAE_NPAVioBaseChar@@@Z:PROC ; ioSkill::UseActiveCount
EXTRN	?GetMaxActiveCount@ioSkill@@UAEHPAVioBaseChar@@@Z:PROC ; ioSkill::GetMaxActiveCount
EXTRN	?GetCurActiveCount@ioSkill@@UAEHPAVioBaseChar@@@Z:PROC ; ioSkill::GetCurActiveCount
EXTRN	?HideHPGauge@ioSkill@@UAE_NXZ:PROC		; ioSkill::HideHPGauge
EXTRN	?SetInfoByApplyWeapon@ioSkill@@UAEXPAVioBaseChar@@0K_N@Z:PROC ; ioSkill::SetInfoByApplyWeapon
EXTRN	?SetCollisionByApplySkill@ioSkill@@UAEXXZ:PROC	; ioSkill::SetCollisionByApplySkill
EXTRN	?SetChargingRateForWeapon@ioSkill@@UAEXPAVioWeapon@@@Z:PROC ; ioSkill::SetChargingRateForWeapon
EXTRN	?CheckExceptionCamera@ioSkill@@UAE_NXZ:PROC	; ioSkill::CheckExceptionCamera
EXTRN	?GetExceptionCameraPos@ioSkill@@UAE?AUD3DXVECTOR3@@PAVioBaseChar@@@Z:PROC ; ioSkill::GetExceptionCameraPos
EXTRN	?IsFixedExceptionCamera@ioSkill@@UAE_NXZ:PROC	; ioSkill::IsFixedExceptionCamera
EXTRN	??_EioDefenseAttackSkill@@UAEPAXI@Z:PROC	; ioDefenseAttackSkill::`vector deleting destructor'
EXTRN	?StartPreDelayAnimation@ioAttackSkill@@MAE_NPAVioBaseChar@@@Z:PROC ; ioAttackSkill::StartPreDelayAnimation
EXTRN	?GetAttackTimeRate@ioAttackSkill@@MBEMXZ:PROC	; ioAttackSkill::GetAttackTimeRate
EXTRN	?GetAttackEndTimeRate@ioAttackSkill@@MBEMXZ:PROC ; ioAttackSkill::GetAttackEndTimeRate
EXTRN	?LoadNormalAttribute@ioAttackSkill@@MAEXAAVioINILoader@@@Z:PROC ; ioAttackSkill::LoadNormalAttribute
EXTRN	?LoadDownAttribute@ioAttackSkill@@MAEXAAVioINILoader@@@Z:PROC ; ioAttackSkill::LoadDownAttribute
EXTRN	?LoadJumpAttribute@ioAttackSkill@@MAEXAAVioINILoader@@@Z:PROC ; ioAttackSkill::LoadJumpAttribute
EXTRN	?GetAttribute@ioAttackSkill@@UAEAAUAttackAttribute@@XZ:PROC ; ioAttackSkill::GetAttribute
EXTRN	?GetAttributeConst@ioAttackSkill@@UBEABUAttackAttribute@@XZ:PROC ; ioAttackSkill::GetAttributeConst
EXTRN	?IsCanStateEscape@ioAttackSkill@@UBE_NXZ:PROC	; ioAttackSkill::IsCanStateEscape
EXTRN	?IsCanStateEscapeOnStand@ioAttackSkill@@UBE_NPAVioBaseChar@@@Z:PROC ; ioAttackSkill::IsCanStateEscapeOnStand
EXTRN	?IsCanStateEscapeOnAir@ioAttackSkill@@UBE_NPAVioBaseChar@@@Z:PROC ; ioAttackSkill::IsCanStateEscapeOnAir
EXTRN	?IsCanStateEscapeOnDown@ioAttackSkill@@UBE_NPAVioBaseChar@@@Z:PROC ; ioAttackSkill::IsCanStateEscapeOnDown
;	COMDAT ??_R2ioSkill@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iodefenseattackskill.cpp
rdata$r	SEGMENT
??_R2ioSkill@@8 DD FLAT:??_R1A@?0A@EA@ioSkill@@8	; ioSkill::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ioSkill@@8
rdata$r	SEGMENT
??_R3ioSkill@@8 DD 00H					; ioSkill::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ioSkill@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioSkill@@@8
_DATA	SEGMENT
??_R0?AVioSkill@@@8 DD FLAT:??_7type_info@@6B@		; ioSkill `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioSkill@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@ioSkill@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioSkill@@8 DD FLAT:??_R0?AVioSkill@@@8	; ioSkill::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioSkill@@8
rdata$r	ENDS
;	COMDAT ??_R2ioAttackSkill@@8
rdata$r	SEGMENT
??_R2ioAttackSkill@@8 DD FLAT:??_R1A@?0A@EA@ioAttackSkill@@8 ; ioAttackSkill::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ioSkill@@8
rdata$r	ENDS
;	COMDAT ??_R3ioAttackSkill@@8
rdata$r	SEGMENT
??_R3ioAttackSkill@@8 DD 00H				; ioAttackSkill::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ioAttackSkill@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioAttackSkill@@@8
_DATA	SEGMENT
??_R0?AVioAttackSkill@@@8 DD FLAT:??_7type_info@@6B@	; ioAttackSkill `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioAttackSkill@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@ioAttackSkill@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioAttackSkill@@8 DD FLAT:??_R0?AVioAttackSkill@@@8 ; ioAttackSkill::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioAttackSkill@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ioDefenseAttackSkill@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioDefenseAttackSkill@@8 DD FLAT:??_R0?AVioDefenseAttackSkill@@@8 ; ioDefenseAttackSkill::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioDefenseAttackSkill@@8
rdata$r	ENDS
;	COMDAT ??_R2ioDefenseAttackSkill@@8
rdata$r	SEGMENT
??_R2ioDefenseAttackSkill@@8 DD FLAT:??_R1A@?0A@EA@ioDefenseAttackSkill@@8 ; ioDefenseAttackSkill::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ioAttackSkill@@8
	DD	FLAT:??_R1A@?0A@EA@ioSkill@@8
rdata$r	ENDS
;	COMDAT ??_R3ioDefenseAttackSkill@@8
rdata$r	SEGMENT
??_R3ioDefenseAttackSkill@@8 DD 00H			; ioDefenseAttackSkill::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2ioDefenseAttackSkill@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioDefenseAttackSkill@@@8
_DATA	SEGMENT
??_R0?AVioDefenseAttackSkill@@@8 DD FLAT:??_7type_info@@6B@ ; ioDefenseAttackSkill `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioDefenseAttackSkill@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ioDefenseAttackSkill@@6B@
rdata$r	SEGMENT
??_R4ioDefenseAttackSkill@@6B@ DD 00H			; ioDefenseAttackSkill::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVioDefenseAttackSkill@@@8
	DD	FLAT:??_R3ioDefenseAttackSkill@@8
rdata$r	ENDS
;	COMDAT ??_7ioDefenseAttackSkill@@6B@
CONST	SEGMENT
??_7ioDefenseAttackSkill@@6B@ DD FLAT:??_R4ioDefenseAttackSkill@@6B@ ; ioDefenseAttackSkill::`vftable'
	DD	FLAT:?LoadProperty@ioDefenseAttackSkill@@UAEXAAVioINILoader@@@Z
	DD	FLAT:?Clone@ioDefenseAttackSkill@@UAEPAVioSkill@@XZ
	DD	FLAT:?GetTypeID@ioAttackSkill@@UBEHXZ
	DD	FLAT:?IsProtected@ioDefenseAttackSkill@@UBE_NH@Z
	DD	FLAT:?IsCanSwitchSkill@ioSkill@@UBE_NXZ
	DD	FLAT:?IsCanSemiSwitchSkill@ioSkill@@UBE_NXZ
	DD	FLAT:?IsCanCancelBySkill@ioSkill@@UBE_NPAVioBaseChar@@AAH@Z
	DD	FLAT:?IsCanUseZeroHP@ioSkill@@UBE_NPAVioBaseChar@@@Z
	DD	FLAT:?IsCanUseSkillWithCrown@ioSkill@@UAE_NPAVioBaseChar@@@Z
	DD	FLAT:?IsCanUseBoss@ioSkill@@UBE_NPAVioBaseChar@@@Z
	DD	FLAT:?IsCanUseFootball@ioSkill@@UBE_NXZ
	DD	FLAT:?IsCanUseGangSiMode@ioSkill@@UBE_NXZ
	DD	FLAT:?IsCanUseByWeaponType@ioSkill@@UBE_NPAVioBaseChar@@@Z
	DD	FLAT:?IsCanUseThunderBirdHold@ioSkill@@UBE_NPAVioBaseChar@@@Z
	DD	FLAT:?IsCanUseLimitHP@ioSkill@@UBE_NPAVioBaseChar@@@Z
	DD	FLAT:?IsCanUseSkill@ioAttackSkill@@UAE_NPAVioBaseChar@@_N@Z
	DD	FLAT:?IsOnOffEnable@ioSkill@@UAE_NXZ
	DD	FLAT:?IsCanDefenseStateSkill@ioDefenseAttackSkill@@UAE_NXZ
	DD	FLAT:?SetDefenseStateSkill@ioDefenseAttackSkill@@UAEXPAVioBaseChar@@@Z
	DD	FLAT:?GetDefenseSkillBreakeType@ioSkill@@UBE?AW4DefenseBreakType@@XZ
	DD	FLAT:?HasBuff@ioSkill@@UBE_NH@Z
	DD	FLAT:?GetBuffType@ioSkill@@UAEHH@Z
	DD	FLAT:?IsEnableReserve@ioSkill@@UBE_NXZ
	DD	FLAT:?IsSkillMotionEnd@ioDefenseAttackSkill@@UBE_NKPAVioBaseChar@@@Z
	DD	FLAT:?IsCharSkipState@ioSkill@@UBE?AW4SkillCharColType@@XZ
	DD	FLAT:?IsEntityCollisionSkipState@ioSkill@@UBE_NXZ
	DD	FLAT:?GetSkillEndNextJumpAmt@ioSkill@@UBEMXZ
	DD	FLAT:?GetSkillEndNextLandRate@ioSkill@@UBEMXZ
	DD	FLAT:?GetSkillEndNextJumpMustEnable@ioSkill@@UAE?AW4SkillEndJumpType@@XZ
	DD	FLAT:?IsEndState@ioSkill@@UBE_NXZ
	DD	FLAT:?IsAttackEndState@ioAttackSkill@@UBE_NXZ
	DD	FLAT:?IsJumpState@ioSkill@@UBE_NXZ
	DD	FLAT:?IsDownState@ioSkill@@UBE_NXZ
	DD	FLAT:?IsNoDropState@ioSkill@@UBE_NXZ
	DD	FLAT:?IsCanSendControl@ioSkill@@UBE_NXZ
	DD	FLAT:?IsSkipState@ioSkill@@UBE_NXZ
	DD	FLAT:?GetSkillMoveRate@ioSkill@@UBEMXZ
	DD	FLAT:?SetSkillGrapplingState@ioSkill@@UAE_NPAVioBaseChar@@ABVioHashString@@@Z
	DD	FLAT:?GetGrapplingTargetPos@ioSkill@@UAE?AUD3DXVECTOR3@@PAVioBaseChar@@0@Z
	DD	FLAT:?GetGrapplingTargetPos@ioSkill@@UAE?AUD3DXVECTOR3@@PAVioBaseChar@@@Z
	DD	FLAT:?EnableChangeGrapplingTargetPos@ioSkill@@UBE_NXZ
	DD	FLAT:?GetSkillWoundGrapplingInfo@ioSkill@@UAE?AUGrapplingSkillWoundedInfo@@XZ
	DD	FLAT:?SetCreateWeaponDependency@ioSkill@@UAEXPAVioBaseChar@@PAVioPlayStage@@@Z
	DD	FLAT:?SetNextSkillState@ioSkill@@UAEXPAVioBaseChar@@PAVioWeapon@@@Z
	DD	FLAT:?OnSkillStart@ioDefenseAttackSkill@@UAE_NPAVioBaseChar@@@Z
	DD	FLAT:?OnProcessState@ioDefenseAttackSkill@@UAEXPAVioBaseChar@@PAVioPlayStage@@@Z
	DD	FLAT:?OnSkillEndByWounded@ioSkill@@UAEXPAVioBaseChar@@@Z
	DD	FLAT:?OnSkillEnd@ioDefenseAttackSkill@@UAEXPAVioBaseChar@@@Z
	DD	FLAT:?OnProcessNotUseSkill@ioSkill@@UAEXPAVioBaseChar@@PAVioPlayStage@@@Z
	DD	FLAT:?OnSkillItemRelease@ioSkill@@UAEXPAVioBaseChar@@@Z
	DD	FLAT:?ApplyAttributeToWeapon@ioDefenseAttackSkill@@UAEXPAVioWeapon@@PAVioPlayStage@@@Z
	DD	FLAT:?ApplyExtraSkillInfo@ioAttackSkill@@UAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z
	DD	FLAT:?ApplyEquipSlotSkillExtraInfo@ioSkill@@UAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z
	DD	FLAT:?ApplyExtraPassiveSkillInfo@ioSkill@@UAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z
	DD	FLAT:?StartPreDelayEffect@ioAttackSkill@@UAEXPAVioBaseChar@@@Z
	DD	FLAT:?EndPreDelayEffect@ioAttackSkill@@UAEXPAVioBaseChar@@@Z
	DD	FLAT:?IsUseAutoTargetValue@ioAttackSkill@@UAE_NXZ
	DD	FLAT:?IsAutoTargetDownState@ioSkill@@UAE_NXZ
	DD	FLAT:?CheckUseBuff@ioSkill@@UAE_NPAVioBaseChar@@@Z
	DD	FLAT:?CheckUseItemMesh@ioDefenseAttackSkill@@UAE_NXZ
	DD	FLAT:?CheckUseActiveCount@ioSkill@@UAE_NXZ
	DD	FLAT:?CheckAniRotate@ioSkill@@UAEXPAVioBaseChar@@@Z
	DD	FLAT:?IsEnableDashCheck@ioSkill@@UAE_NPAVioBaseChar@@@Z
	DD	FLAT:?IsEnableMultiActive@ioSkill@@UAE_NPAVioBaseChar@@@Z
	DD	FLAT:?IsInvisibleBottomCircle@ioSkill@@UAE_NPAVioBaseChar@@@Z
	DD	FLAT:?GetAutoTargetValue@ioSkill@@UAEXAAM00@Z
	DD	FLAT:?IsCanJumpingSkill@ioSkill@@UBE_NXZ
	DD	FLAT:?IsCanJumpingSkillOnBlowWound@ioSkill@@UBE_NXZ
	DD	FLAT:?IsCanDownSkill@ioSkill@@UBE_NXZ
	DD	FLAT:?IsCanBlowWoundSkill@ioSkill@@UBE_NXZ
	DD	FLAT:?IsCanWoundSkill@ioSkill@@UBE_NXZ
	DD	FLAT:?GetSkillGravityRate@ioSkill@@UAEMXZ
	DD	FLAT:?GetSkillMotionName@ioSkill@@UBEABVioHashString@@XZ
	DD	FLAT:?HasSkillMotion@ioSkill@@UBE_NXZ
	DD	FLAT:?GetSkillMotionRate@ioSkill@@UBEMXZ
	DD	FLAT:?IsPreDelayProtect@ioSkill@@UBE_NXZ
	DD	FLAT:?GetPreDelayAniName@ioSkill@@UBEABVioHashString@@XZ
	DD	FLAT:?GetPreDelayTime@ioSkill@@UBEKXZ
	DD	FLAT:?GetPreDelayOwnerEffect@ioSkill@@UBEABVioHashString@@XZ
	DD	FLAT:?GetPreDelayOtherEffect@ioSkill@@UBEABVioHashString@@XZ
	DD	FLAT:?SetCancelSkill@ioSkill@@UAEXPAVioBaseChar@@@Z
	DD	FLAT:?ClearAirJump@ioSkill@@MAEXXZ
	DD	FLAT:?SetAirJump@ioSkill@@MAEXPAVioBaseChar@@HM@Z
	DD	FLAT:?CheckAirJump@ioSkill@@MAEXPAVioBaseChar@@@Z
	DD	FLAT:?UseActiveCount@ioSkill@@UAE_NPAVioBaseChar@@@Z
	DD	FLAT:?GetMaxActiveCount@ioSkill@@UAEHPAVioBaseChar@@@Z
	DD	FLAT:?GetCurActiveCount@ioSkill@@UAEHPAVioBaseChar@@@Z
	DD	FLAT:?HideHPGauge@ioSkill@@UAE_NXZ
	DD	FLAT:?SetInfoByApplyWeapon@ioSkill@@UAEXPAVioBaseChar@@0K_N@Z
	DD	FLAT:?SetCollisionByApplySkill@ioSkill@@UAEXXZ
	DD	FLAT:?SetChargingRateForWeapon@ioSkill@@UAEXPAVioWeapon@@@Z
	DD	FLAT:?CheckExceptionCamera@ioSkill@@UAE_NXZ
	DD	FLAT:?GetExceptionCameraPos@ioSkill@@UAE?AUD3DXVECTOR3@@PAVioBaseChar@@@Z
	DD	FLAT:?IsFixedExceptionCamera@ioSkill@@UAE_NXZ
	DD	FLAT:?IsUseActiveCnt@ioSkill@@UBE_NXZ
	DD	FLAT:?GetMaxActiveCnt@ioSkill@@UBEHPAVioBaseChar@@@Z
	DD	FLAT:?GetCurActiveCnt@ioSkill@@UBEHPAVioBaseChar@@@Z
	DD	FLAT:??_EioDefenseAttackSkill@@UAEPAXI@Z
	DD	FLAT:?StartPreDelayAnimation@ioAttackSkill@@MAE_NPAVioBaseChar@@@Z
	DD	FLAT:?AttackSkillFire@ioDefenseAttackSkill@@MAEXPAVioBaseChar@@@Z
	DD	FLAT:?GetAttackTimeRate@ioAttackSkill@@MBEMXZ
	DD	FLAT:?GetAttackEndTimeRate@ioAttackSkill@@MBEMXZ
	DD	FLAT:?LoadNormalAttribute@ioAttackSkill@@MAEXAAVioINILoader@@@Z
	DD	FLAT:?LoadDownAttribute@ioAttackSkill@@MAEXAAVioINILoader@@@Z
	DD	FLAT:?LoadJumpAttribute@ioAttackSkill@@MAEXAAVioINILoader@@@Z
	DD	FLAT:?GetAttribute@ioAttackSkill@@UAEAAUAttackAttribute@@XZ
	DD	FLAT:?GetAttributeConst@ioAttackSkill@@UBEABUAttackAttribute@@XZ
	DD	FLAT:?IsCanStateEscape@ioAttackSkill@@UBE_NXZ
	DD	FLAT:?IsCanStateEscapeOnStand@ioAttackSkill@@UBE_NPAVioBaseChar@@@Z
	DD	FLAT:?IsCanStateEscapeOnAir@ioAttackSkill@@UBE_NPAVioBaseChar@@@Z
	DD	FLAT:?IsCanStateEscapeOnDown@ioAttackSkill@@UBE_NPAVioBaseChar@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ioDefenseAttackSkill@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ioDefenseAttackSkill@@QAE@XZ$0
__ehfuncinfo$??0ioDefenseAttackSkill@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0ioDefenseAttackSkill@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??0ioDefenseAttackSkill@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0ioDefenseAttackSkill@@QAE@XZ PROC			; ioDefenseAttackSkill::ioDefenseAttackSkill, COMDAT
; _this$ = ecx

; 9    : {

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0ioDefenseAttackSkill@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	e8 00 00 00 00	 call	 ??0ioAttackSkill@@QAE@XZ ; ioAttackSkill::ioAttackSkill
  00016	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0001a	8d 8e e8 10 00
	00		 lea	 ecx, DWORD PTR [esi+4328]
  00020	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioDefenseAttackSkill@@6B@
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ

; 10   : 	m_bSetHandMesh = false;
; 11   : 	m_SkillState = SS_NONE;

  0002c	83 a6 e4 10 00
	00 00		 and	 DWORD PTR [esi+4324], 0
  00033	c6 86 0a 0f 00
	00 00		 mov	 BYTE PTR [esi+3850], 0

; 12   : }

  0003a	8b c6		 mov	 eax, esi
  0003c	e8 00 00 00 00	 call	 __EH_epilog3
  00041	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ioDefenseAttackSkill@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1ioAttackSkill@@UAE@XZ ; ioAttackSkill::~ioAttackSkill
__ehhandler$??0ioDefenseAttackSkill@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ioDefenseAttackSkill@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ioDefenseAttackSkill@@QAE@XZ ENDP			; ioDefenseAttackSkill::ioDefenseAttackSkill
PUBLIC	??0ioDefenseAttackSkill@@QAE@ABV0@@Z		; ioDefenseAttackSkill::ioDefenseAttackSkill
EXTRN	__imp_??0ioHashString@@QAE@ABV0@@Z:PROC
EXTRN	??0ioAttackSkill@@QAE@ABV0@@Z:PROC		; ioAttackSkill::ioAttackSkill
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ioDefenseAttackSkill@@QAE@ABV0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ioDefenseAttackSkill@@QAE@ABV0@@Z$0
__ehfuncinfo$??0ioDefenseAttackSkill@@QAE@ABV0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0ioDefenseAttackSkill@@QAE@ABV0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??0ioDefenseAttackSkill@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_rhs$ = 8						; size = 4
??0ioDefenseAttackSkill@@QAE@ABV0@@Z PROC		; ioDefenseAttackSkill::ioDefenseAttackSkill, COMDAT
; _this$ = ecx

; 18   : {

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0ioDefenseAttackSkill@@QAE@ABV0@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	8b 7d 08	 mov	 edi, DWORD PTR _rhs$[ebp]
  00014	57		 push	 edi
  00015	e8 00 00 00 00	 call	 ??0ioAttackSkill@@QAE@ABV0@@Z ; ioAttackSkill::ioAttackSkill
  0001a	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0001e	8d 87 e8 10 00
	00		 lea	 eax, DWORD PTR [edi+4328]
  00024	50		 push	 eax
  00025	8d 8e e8 10 00
	00		 lea	 ecx, DWORD PTR [esi+4328]
  0002b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioDefenseAttackSkill@@6B@
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  00037	d9 87 f8 10 00
	00		 fld	 DWORD PTR [edi+4344]

; 19   : 	m_bSetHandMesh = false;
; 20   : 	m_SkillState = SS_NONE;

  0003d	83 a6 e4 10 00
	00 00		 and	 DWORD PTR [esi+4324], 0
  00044	d9 9e f8 10 00
	00		 fstp	 DWORD PTR [esi+4344]
  0004a	c6 86 0a 0f 00
	00 00		 mov	 BYTE PTR [esi+3850], 0

; 21   : }

  00051	8b c6		 mov	 eax, esi
  00053	e8 00 00 00 00	 call	 __EH_epilog3
  00058	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ioDefenseAttackSkill@@QAE@ABV0@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1ioAttackSkill@@UAE@XZ ; ioAttackSkill::~ioAttackSkill
__ehhandler$??0ioDefenseAttackSkill@@QAE@ABV0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ioDefenseAttackSkill@@QAE@ABV0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ioDefenseAttackSkill@@QAE@ABV0@@Z ENDP		; ioDefenseAttackSkill::ioDefenseAttackSkill
PUBLIC	??1ioDefenseAttackSkill@@UAE@XZ			; ioDefenseAttackSkill::~ioDefenseAttackSkill
EXTRN	__imp_??1ioHashString@@QAE@XZ:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1ioDefenseAttackSkill@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1ioDefenseAttackSkill@@UAE@XZ$0
__ehfuncinfo$??1ioDefenseAttackSkill@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1ioDefenseAttackSkill@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??1ioDefenseAttackSkill@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1ioDefenseAttackSkill@@UAE@XZ PROC			; ioDefenseAttackSkill::~ioDefenseAttackSkill, COMDAT
; _this$ = ecx

; 24   : {

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??1ioDefenseAttackSkill@@UAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioDefenseAttackSkill@@6B@
  00017	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 25   : }

  0001b	8d 8e e8 10 00
	00		 lea	 ecx, DWORD PTR [esi+4328]
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00027	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0002b	8b ce		 mov	 ecx, esi
  0002d	e8 00 00 00 00	 call	 ??1ioAttackSkill@@UAE@XZ ; ioAttackSkill::~ioAttackSkill
  00032	e8 00 00 00 00	 call	 __EH_epilog3
  00037	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1ioDefenseAttackSkill@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1ioAttackSkill@@UAE@XZ ; ioAttackSkill::~ioAttackSkill
__ehhandler$??1ioDefenseAttackSkill@@UAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1ioDefenseAttackSkill@@UAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1ioDefenseAttackSkill@@UAE@XZ ENDP			; ioDefenseAttackSkill::~ioDefenseAttackSkill
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Clone@ioDefenseAttackSkill@@UAEPAVioSkill@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Clone@ioDefenseAttackSkill@@UAEPAVioSkill@@XZ$0
__ehfuncinfo$?Clone@ioDefenseAttackSkill@@UAEPAVioSkill@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Clone@ioDefenseAttackSkill@@UAEPAVioSkill@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ?Clone@ioDefenseAttackSkill@@UAEPAVioSkill@@XZ
_TEXT	SEGMENT
$T524775 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Clone@ioDefenseAttackSkill@@UAEPAVioSkill@@XZ PROC	; ioDefenseAttackSkill::Clone, COMDAT
; _this$ = ecx

; 39   : {

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?Clone@ioDefenseAttackSkill@@UAEPAVioSkill@@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx

; 40   : 	return new ioDefenseAttackSkill( *this );

  0000e	68 fc 10 00 00	 push	 4348			; 000010fcH
  00013	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00018	59		 pop	 ecx
  00019	8b c8		 mov	 ecx, eax
  0001b	89 4d f0	 mov	 DWORD PTR $T524775[ebp], ecx
  0001e	33 c0		 xor	 eax, eax
  00020	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], eax
  00023	3b c8		 cmp	 ecx, eax
  00025	74 06		 je	 SHORT $LN3@Clone
  00027	56		 push	 esi
  00028	e8 00 00 00 00	 call	 ??0ioDefenseAttackSkill@@QAE@ABV0@@Z ; ioDefenseAttackSkill::ioDefenseAttackSkill
$LN3@Clone:

; 41   : }

  0002d	e8 00 00 00 00	 call	 __EH_epilog3
  00032	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Clone@ioDefenseAttackSkill@@UAEPAVioSkill@@XZ$0:
  00000	ff 75 f0	 push	 DWORD PTR $T524775[ebp]
  00003	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00008	59		 pop	 ecx
  00009	c3		 ret	 0
__ehhandler$?Clone@ioDefenseAttackSkill@@UAEPAVioSkill@@XZ:
  0000a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00011	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00014	33 c8		 xor	 ecx, eax
  00016	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Clone@ioDefenseAttackSkill@@UAEPAVioSkill@@XZ
  00020	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Clone@ioDefenseAttackSkill@@UAEPAVioSkill@@XZ ENDP	; ioDefenseAttackSkill::Clone
PUBLIC	?SetSkillActionState@ioDefenseAttackSkill@@IAEXPAVioBaseChar@@@Z ; ioDefenseAttackSkill::SetSkillActionState
; Function compile flags: /Ogsp
;	COMDAT ?SetSkillActionState@ioDefenseAttackSkill@@IAEXPAVioBaseChar@@@Z
_TEXT	SEGMENT
_pChar$ = 8						; size = 4
?SetSkillActionState@ioDefenseAttackSkill@@IAEXPAVioBaseChar@@@Z PROC ; ioDefenseAttackSkill::SetSkillActionState, COMDAT
; _this$ = ecx

; 133  : 	m_SkillState = SS_FIRE;

  00000	c7 81 e4 10 00
	00 02 00 00 00	 mov	 DWORD PTR [ecx+4324], 2

; 134  : }

  0000a	c2 04 00	 ret	 4
?SetSkillActionState@ioDefenseAttackSkill@@IAEXPAVioBaseChar@@@Z ENDP ; ioDefenseAttackSkill::SetSkillActionState
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?CheckUseItemMesh@ioDefenseAttackSkill@@UAE_NXZ
_TEXT	SEGMENT
?CheckUseItemMesh@ioDefenseAttackSkill@@UAE_NXZ PROC	; ioDefenseAttackSkill::CheckUseItemMesh, COMDAT
; _this$ = ecx

; 160  : 	return m_bUseItemMesh;

  00000	8a 81 08 0f 00
	00		 mov	 al, BYTE PTR [ecx+3848]

; 161  : }

  00006	c3		 ret	 0
?CheckUseItemMesh@ioDefenseAttackSkill@@UAE_NXZ ENDP	; ioDefenseAttackSkill::CheckUseItemMesh
_TEXT	ENDS
EXTRN	?ApplyAttributeToWeapon@ioSkill@@UAEXPAVioWeapon@@PAVioPlayStage@@@Z:PROC ; ioSkill::ApplyAttributeToWeapon
; Function compile flags: /Ogsp
;	COMDAT ?ApplyAttributeToWeapon@ioDefenseAttackSkill@@UAEXPAVioWeapon@@PAVioPlayStage@@@Z
_TEXT	SEGMENT
_pWeapon$ = 8						; size = 4
_pStage$ = 12						; size = 4
?ApplyAttributeToWeapon@ioDefenseAttackSkill@@UAEXPAVioWeapon@@PAVioPlayStage@@@Z PROC ; ioDefenseAttackSkill::ApplyAttributeToWeapon, COMDAT
; _this$ = ecx

; 164  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 165  : 	ioSkill::ApplyAttributeToWeapon( pWeapon, pStage );

  00004	ff 75 0c	 push	 DWORD PTR _pStage$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 75 08	 push	 DWORD PTR _pWeapon$[ebp]
  0000c	e8 00 00 00 00	 call	 ?ApplyAttributeToWeapon@ioSkill@@UAEXPAVioWeapon@@PAVioPlayStage@@@Z ; ioSkill::ApplyAttributeToWeapon

; 166  : 
; 167  : 	SetChargingRateForWeapon( pWeapon );

  00011	ff 75 08	 push	 DWORD PTR _pWeapon$[ebp]
  00014	8b 06		 mov	 eax, DWORD PTR [esi]
  00016	8b ce		 mov	 ecx, esi
  00018	ff 90 68 01 00
	00		 call	 DWORD PTR [eax+360]
  0001e	5e		 pop	 esi

; 168  : }

  0001f	5d		 pop	 ebp
  00020	c2 08 00	 ret	 8
?ApplyAttributeToWeapon@ioDefenseAttackSkill@@UAEXPAVioWeapon@@PAVioPlayStage@@@Z ENDP ; ioDefenseAttackSkill::ApplyAttributeToWeapon
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?IsCanDefenseStateSkill@ioDefenseAttackSkill@@UAE_NXZ
_TEXT	SEGMENT
?IsCanDefenseStateSkill@ioDefenseAttackSkill@@UAE_NXZ PROC ; ioDefenseAttackSkill::IsCanDefenseStateSkill, COMDAT
; _this$ = ecx

; 205  : 	switch( m_SkillState )

  00000	8b 81 e4 10 00
	00		 mov	 eax, DWORD PTR [ecx+4324]
  00006	48		 dec	 eax
  00007	74 03		 je	 SHORT $LN1@IsCanDefen

; 209  : 	}
; 210  : 
; 211  : 	return false;

  00009	32 c0		 xor	 al, al

; 212  : }

  0000b	c3		 ret	 0
$LN1@IsCanDefen:

; 206  : 	{
; 207  : 	case SS_LOOP:
; 208  : 		return true;

  0000c	b0 01		 mov	 al, 1

; 212  : }

  0000e	c3		 ret	 0
?IsCanDefenseStateSkill@ioDefenseAttackSkill@@UAE_NXZ ENDP ; ioDefenseAttackSkill::IsCanDefenseStateSkill
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?SetDefenseStateSkill@ioDefenseAttackSkill@@UAEXPAVioBaseChar@@@Z
_TEXT	SEGMENT
_pChar$ = 8						; size = 4
?SetDefenseStateSkill@ioDefenseAttackSkill@@UAEXPAVioBaseChar@@@Z PROC ; ioDefenseAttackSkill::SetDefenseStateSkill, COMDAT
; _this$ = ecx

; 215  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 216  : 	if( !pChar ) return;

  00003	83 7d 08 00	 cmp	 DWORD PTR _pChar$[ebp], 0
  00007	74 09		 je	 SHORT $LN2@SetDefense

; 217  : 
; 218  : 	AttackSkillFire( pChar );

  00009	8b 01		 mov	 eax, DWORD PTR [ecx]

; 219  : }

  0000b	5d		 pop	 ebp

; 217  : 
; 218  : 	AttackSkillFire( pChar );

  0000c	ff a0 8c 01 00
	00		 jmp	 DWORD PTR [eax+396]
$LN2@SetDefense:

; 219  : }

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetDefenseStateSkill@ioDefenseAttackSkill@@UAEXPAVioBaseChar@@@Z ENDP ; ioDefenseAttackSkill::SetDefenseStateSkill
_TEXT	ENDS
EXTRN	__imp_?GetLoopSec@ioFrameTimer@@QBEKXZ:PROC
EXTRN	__imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ?IsSkillMotionEnd@ioDefenseAttackSkill@@UBE_NKPAVioBaseChar@@@Z
_TEXT	SEGMENT
_dwActionStop$ = 8					; size = 4
_pOwner$ = 12						; size = 4
?IsSkillMotionEnd@ioDefenseAttackSkill@@UBE_NKPAVioBaseChar@@@Z PROC ; ioDefenseAttackSkill::IsSkillMotionEnd, COMDAT
; _this$ = ecx

; 222  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 223  : 	DWORD dwCurTime = FRAMEGETTIME();

  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  0000c	8b c8		 mov	 ecx, eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ

; 224  : 
; 225  : 	if( m_dwPreDelayStartTime > 0 )

  00014	83 be 20 02 00
	00 00		 cmp	 DWORD PTR [esi+544], 0

; 226  : 		return false;

  0001b	77 1c		 ja	 SHORT $LN3@IsSkillMot

; 227  : 
; 228  : 	switch( m_SkillState )

  0001d	8b 8e e4 10 00
	00		 mov	 ecx, DWORD PTR [esi+4324]
  00023	49		 dec	 ecx
  00024	83 f9 01	 cmp	 ecx, 1
  00027	77 10		 ja	 SHORT $LN3@IsSkillMot

; 229  : 	{
; 230  : 	case SS_LOOP:
; 231  : 	case SS_FIRE:
; 232  : 		if( m_dwMotionEndTime + dwActionStop < dwCurTime )

  00029	8b 8e d8 02 00
	00		 mov	 ecx, DWORD PTR [esi+728]
  0002f	03 4d 08	 add	 ecx, DWORD PTR _dwActionStop$[ebp]
  00032	3b c8		 cmp	 ecx, eax
  00034	0f 92 c0	 setb	 al

; 233  : 			return true;
; 234  : 
; 235  : 		return false;

  00037	eb 02		 jmp	 SHORT $LN6@IsSkillMot
$LN3@IsSkillMot:

; 236  : 	}
; 237  : 
; 238  : 	return false;

  00039	32 c0		 xor	 al, al
$LN6@IsSkillMot:
  0003b	5e		 pop	 esi

; 239  : }

  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
?IsSkillMotionEnd@ioDefenseAttackSkill@@UBE_NKPAVioBaseChar@@@Z ENDP ; ioDefenseAttackSkill::IsSkillMotionEnd
_TEXT	ENDS
PUBLIC	?_DECSTR@@YAXPADH@Z				; _DECSTR
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stringprotect.h
;	COMDAT ?_DECSTR@@YAXPADH@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_l$ = 12						; size = 4
?_DECSTR@@YAXPADH@Z PROC				; _DECSTR, COMDAT

; 40   : __forceinline void _DECSTR(char* s, int l){int i=0,l4=(l-1)/4,*p=(int*)s;s[l-1]=0;for(;i<l4;++i)*(p++)^=0xEAEBECED;for(i=l4*4;i<l-1;++i)s[i]^=0xED-i%4;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _l$[ebp]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  0000a	57		 push	 edi
  0000b	8d 79 ff	 lea	 edi, DWORD PTR [ecx-1]
  0000e	8b c7		 mov	 eax, edi
  00010	99		 cdq
  00011	83 e2 03	 and	 edx, 3
  00014	03 c2		 add	 eax, edx
  00016	c1 f8 02	 sar	 eax, 2
  00019	8b d6		 mov	 edx, esi
  0001b	c6 44 0e ff 00	 mov	 BYTE PTR [esi+ecx-1], 0
  00020	85 c0		 test	 eax, eax
  00022	7e 0e		 jle	 SHORT $LN4@DECSTR
  00024	8b c8		 mov	 ecx, eax
$LL6@DECSTR:
  00026	81 32 ed ec eb
	ea		 xor	 DWORD PTR [edx], -353637139 ; eaebecedH
  0002c	83 c2 04	 add	 edx, 4
  0002f	49		 dec	 ecx
  00030	75 f4		 jne	 SHORT $LL6@DECSTR
$LN4@DECSTR:
  00032	c1 e0 02	 shl	 eax, 2
  00035	eb 17		 jmp	 SHORT $LN14@DECSTR
$LL3@DECSTR:
  00037	8b c8		 mov	 ecx, eax
  00039	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0003f	79 05		 jns	 SHORT $LN13@DECSTR
  00041	49		 dec	 ecx
  00042	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00045	41		 inc	 ecx
$LN13@DECSTR:
  00046	b2 ed		 mov	 dl, -19			; ffffffedH
  00048	2a d1		 sub	 dl, cl
  0004a	30 14 30	 xor	 BYTE PTR [eax+esi], dl
  0004d	40		 inc	 eax
$LN14@DECSTR:
  0004e	3b c7		 cmp	 eax, edi
  00050	7c e5		 jl	 SHORT $LL3@DECSTR
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?_DECSTR@@YAXPADH@Z ENDP				; _DECSTR
_TEXT	ENDS
PUBLIC	?GetGroup@ioGameEntity@@QBEPAVioEntityGroup@@XZ	; ioGameEntity::GetGroup
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iogameentity.h
;	COMDAT ?GetGroup@ioGameEntity@@QBEPAVioEntityGroup@@XZ
_TEXT	SEGMENT
?GetGroup@ioGameEntity@@QBEPAVioEntityGroup@@XZ PROC	; ioGameEntity::GetGroup, COMDAT
; _this$ = ecx

; 166  : 	inline ioEntityGroup* GetGroup() const { return m_pGroup; }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetGroup@ioGameEntity@@QBEPAVioEntityGroup@@XZ ENDP	; ioGameEntity::GetGroup
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioskill.h
_TEXT	ENDS
;	COMDAT ?GetDefenseSkillBreakeType@ioSkill@@UBE?AW4DefenseBreakType@@XZ
_TEXT	SEGMENT
?GetDefenseSkillBreakeType@ioSkill@@UBE?AW4DefenseBreakType@@XZ PROC ; ioSkill::GetDefenseSkillBreakeType, COMDAT
; _this$ = ecx

; 327  : 	virtual DefenseBreakType GetDefenseSkillBreakeType() const { return m_eDefenseSkillBreakType; }

  00000	8b 81 30 0e 00
	00		 mov	 eax, DWORD PTR [ecx+3632]
  00006	c3		 ret	 0
?GetDefenseSkillBreakeType@ioSkill@@UBE?AW4DefenseBreakType@@XZ ENDP ; ioSkill::GetDefenseSkillBreakeType
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?GetSkillEndNextJumpAmt@ioSkill@@UBEMXZ
_TEXT	SEGMENT
?GetSkillEndNextJumpAmt@ioSkill@@UBEMXZ PROC		; ioSkill::GetSkillEndNextJumpAmt, COMDAT
; _this$ = ecx

; 335  : 	virtual float GetSkillEndNextJumpAmt() const { return m_fSkillEndNextJumpAmt; }

  00000	d9 81 4c 05 00
	00		 fld	 DWORD PTR [ecx+1356]
  00006	c3		 ret	 0
?GetSkillEndNextJumpAmt@ioSkill@@UBEMXZ ENDP		; ioSkill::GetSkillEndNextJumpAmt
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?GetSkillEndNextLandRate@ioSkill@@UBEMXZ
_TEXT	SEGMENT
?GetSkillEndNextLandRate@ioSkill@@UBEMXZ PROC		; ioSkill::GetSkillEndNextLandRate, COMDAT
; _this$ = ecx

; 336  : 	virtual float GetSkillEndNextLandRate() const { return m_fSkillEndNextLandRate; }

  00000	d9 81 50 05 00
	00		 fld	 DWORD PTR [ecx+1360]
  00006	c3		 ret	 0
?GetSkillEndNextLandRate@ioSkill@@UBEMXZ ENDP		; ioSkill::GetSkillEndNextLandRate
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?GetSkillEndNextJumpMustEnable@ioSkill@@UAE?AW4SkillEndJumpType@@XZ
_TEXT	SEGMENT
?GetSkillEndNextJumpMustEnable@ioSkill@@UAE?AW4SkillEndJumpType@@XZ PROC ; ioSkill::GetSkillEndNextJumpMustEnable, COMDAT
; _this$ = ecx

; 337  : 	virtual SkillEndJumpType GetSkillEndNextJumpMustEnable(){ return SEJT_DEFAULT; }

  00000	33 c0		 xor	 eax, eax
  00002	c3		 ret	 0
?GetSkillEndNextJumpMustEnable@ioSkill@@UAE?AW4SkillEndJumpType@@XZ ENDP ; ioSkill::GetSkillEndNextJumpMustEnable
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?EnableChangeGrapplingTargetPos@ioSkill@@UBE_NXZ
_TEXT	SEGMENT
?EnableChangeGrapplingTargetPos@ioSkill@@UBE_NXZ PROC	; ioSkill::EnableChangeGrapplingTargetPos, COMDAT
; _this$ = ecx

; 355  : 	virtual bool EnableChangeGrapplingTargetPos() const { return m_bChangeGrapplingTargetPos; }

  00000	8a 81 40 09 00
	00		 mov	 al, BYTE PTR [ecx+2368]
  00006	c3		 ret	 0
?EnableChangeGrapplingTargetPos@ioSkill@@UBE_NXZ ENDP	; ioSkill::EnableChangeGrapplingTargetPos
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?IsInvisibleBottomCircle@ioSkill@@UAE_NPAVioBaseChar@@@Z
_TEXT	SEGMENT
_pChar$ = 8						; size = 4
?IsInvisibleBottomCircle@ioSkill@@UAE_NPAVioBaseChar@@@Z PROC ; ioSkill::IsInvisibleBottomCircle, COMDAT
; _this$ = ecx

; 393  : 	virtual bool IsInvisibleBottomCircle( ioBaseChar *pChar ) { return false; }

  00000	32 c0		 xor	 al, al
  00002	c2 04 00	 ret	 4
?IsInvisibleBottomCircle@ioSkill@@UAE_NPAVioBaseChar@@@Z ENDP ; ioSkill::IsInvisibleBottomCircle
_TEXT	ENDS
PUBLIC	?GetOwnerItem@ioSkill@@QBEPAVioItem@@XZ		; ioSkill::GetOwnerItem
; Function compile flags: /Ogsp
;	COMDAT ?GetOwnerItem@ioSkill@@QBEPAVioItem@@XZ
_TEXT	SEGMENT
?GetOwnerItem@ioSkill@@QBEPAVioItem@@XZ PROC		; ioSkill::GetOwnerItem, COMDAT
; _this$ = ecx

; 397  : 	inline ioItem *GetOwnerItem() const { return m_pOwnerItem; }

  00000	8b 81 a4 02 00
	00		 mov	 eax, DWORD PTR [ecx+676]
  00006	c3		 ret	 0
?GetOwnerItem@ioSkill@@QBEPAVioItem@@XZ ENDP		; ioSkill::GetOwnerItem
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?IsUseActiveCnt@ioSkill@@UBE_NXZ
_TEXT	SEGMENT
?IsUseActiveCnt@ioSkill@@UBE_NXZ PROC			; ioSkill::IsUseActiveCnt, COMDAT
; _this$ = ecx

; 544  : 	virtual bool IsUseActiveCnt() const { return false; }

  00000	32 c0		 xor	 al, al
  00002	c3		 ret	 0
?IsUseActiveCnt@ioSkill@@UBE_NXZ ENDP			; ioSkill::IsUseActiveCnt
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?GetMaxActiveCnt@ioSkill@@UBEHPAVioBaseChar@@@Z
_TEXT	SEGMENT
_pChar$ = 8						; size = 4
?GetMaxActiveCnt@ioSkill@@UBEHPAVioBaseChar@@@Z PROC	; ioSkill::GetMaxActiveCnt, COMDAT
; _this$ = ecx

; 545  : 	virtual int GetMaxActiveCnt( ioBaseChar *pChar ) const { return 0; }

  00000	33 c0		 xor	 eax, eax
  00002	c2 04 00	 ret	 4
?GetMaxActiveCnt@ioSkill@@UBEHPAVioBaseChar@@@Z ENDP	; ioSkill::GetMaxActiveCnt
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?GetCurActiveCnt@ioSkill@@UBEHPAVioBaseChar@@@Z
_TEXT	SEGMENT
_pChar$ = 8						; size = 4
?GetCurActiveCnt@ioSkill@@UBEHPAVioBaseChar@@@Z PROC	; ioSkill::GetCurActiveCnt, COMDAT
; _this$ = ecx

; 546  : 	virtual int GetCurActiveCnt( ioBaseChar *pChar ) const { return 0; }

  00000	33 c0		 xor	 eax, eax
  00002	c2 04 00	 ret	 4
?GetCurActiveCnt@ioSkill@@UBEHPAVioBaseChar@@@Z ENDP	; ioSkill::GetCurActiveCnt
_TEXT	ENDS
PUBLIC	?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z	; CEncrypt<float>::EncryptValueToPool
EXTRN	?EncryptByte@ccddaabb@@QAEXPBDPADH@Z:PROC	; ccddaabb::EncryptByte
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
;	COMDAT ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z PROC	; CEncrypt<float>::EncryptValueToPool, COMDAT
; _this$ = ecx

; 67   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 		m_RC5.EncryptByte( value, m_MemPool, max(m_ValueSize, DEFAULT_ENCRYPT) );

  00003	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00007	83 f8 04	 cmp	 eax, 4
  0000a	77 03		 ja	 SHORT $LN4@EncryptVal
  0000c	6a 04		 push	 4
  0000e	58		 pop	 eax
$LN4@EncryptVal:
  0000f	50		 push	 eax
  00010	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  00013	50		 push	 eax
  00014	ff 75 08	 push	 DWORD PTR _value$[ebp]
  00017	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0001a	e8 00 00 00 00	 call	 ?EncryptByte@ccddaabb@@QAEXPBDPADH@Z ; ccddaabb::EncryptByte

; 69   : 		
; 70   : 	}

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ENDP	; CEncrypt<float>::EncryptValueToPool
_TEXT	ENDS
PUBLIC	?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z	; CEncrypt<unsigned long>::EncryptValueToPool
; Function compile flags: /Ogsp
;	COMDAT ?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z PROC	; CEncrypt<unsigned long>::EncryptValueToPool, COMDAT
; _this$ = ecx

; 67   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 		m_RC5.EncryptByte( value, m_MemPool, max(m_ValueSize, DEFAULT_ENCRYPT) );

  00003	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00007	83 f8 04	 cmp	 eax, 4
  0000a	77 03		 ja	 SHORT $LN4@EncryptVal@2
  0000c	6a 04		 push	 4
  0000e	58		 pop	 eax
$LN4@EncryptVal@2:
  0000f	50		 push	 eax
  00010	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  00013	50		 push	 eax
  00014	ff 75 08	 push	 DWORD PTR _value$[ebp]
  00017	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0001a	e8 00 00 00 00	 call	 ?EncryptByte@ccddaabb@@QAEXPBDPADH@Z ; ccddaabb::EncryptByte

; 69   : 		
; 70   : 	}

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z ENDP	; CEncrypt<unsigned long>::EncryptValueToPool
_TEXT	ENDS
PUBLIC	?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z	; CEncrypt<bool>::DecryptValueToPool
EXTRN	?DecryptByte@ccddaabb@@QBEXPBDPADH@Z:PROC	; ccddaabb::DecryptByte
; Function compile flags: /Ogsp
;	COMDAT ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z PROC	; CEncrypt<bool>::DecryptValueToPool, COMDAT
; _this$ = ecx

; 219  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 220  : 		m_RC5.DecryptByte( m_MemPool, m_TempMem, 4 );

  00004	8d 71 28	 lea	 esi, DWORD PTR [ecx+40]
  00007	6a 04		 push	 4
  00009	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00011	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte

; 221  : 		*value = *((bool*)m_TempMem);

  00016	8a 06		 mov	 al, BYTE PTR [esi]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0001b	88 01		 mov	 BYTE PTR [ecx], al
  0001d	5e		 pop	 esi

; 222  : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ENDP	; CEncrypt<bool>::DecryptValueToPool
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??_GioDefenseAttackSkill@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GioDefenseAttackSkill@@UAEPAXI@Z PROC		; ioDefenseAttackSkill::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1ioDefenseAttackSkill@@UAE@XZ ; ioDefenseAttackSkill::~ioDefenseAttackSkill
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 07		 je	 SHORT $LN1@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	59		 pop	 ecx
$LN1@scalar:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??_GioDefenseAttackSkill@@UAEPAXI@Z ENDP		; ioDefenseAttackSkill::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	?AttackSkillFire@ioAttackSkill@@MAEXPAVioBaseChar@@@Z:PROC ; ioAttackSkill::AttackSkillFire
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iodefenseattackskill.cpp
;	COMDAT ?AttackSkillFire@ioDefenseAttackSkill@@MAEXPAVioBaseChar@@@Z
_TEXT	SEGMENT
_pChar$ = 8						; size = 4
?AttackSkillFire@ioDefenseAttackSkill@@MAEXPAVioBaseChar@@@Z PROC ; ioDefenseAttackSkill::AttackSkillFire, COMDAT
; _this$ = ecx

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 126  : 	ioAttackSkill::AttackSkillFire( pChar );

  00004	ff 75 08	 push	 DWORD PTR _pChar$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	e8 00 00 00 00	 call	 ?AttackSkillFire@ioAttackSkill@@MAEXPAVioBaseChar@@@Z ; ioAttackSkill::AttackSkillFire

; 127  : 
; 128  : 	SetSkillActionState( pChar );

  0000e	c7 86 e4 10 00
	00 02 00 00 00	 mov	 DWORD PTR [esi+4324], 2
  00018	5e		 pop	 esi

; 129  : }

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
?AttackSkillFire@ioDefenseAttackSkill@@MAEXPAVioBaseChar@@@Z ENDP ; ioDefenseAttackSkill::AttackSkillFire
_TEXT	ENDS
EXTRN	?RestoreSkillWeaponMesh@ioBaseChar@@QAE_NPAVioSkill@@ABVioHashString@@_N2@Z:PROC ; ioBaseChar::RestoreSkillWeaponMesh
EXTRN	__imp_?IsEmpty@ioHashString@@QBE_NXZ:PROC
EXTRN	?ShowWeaponItemMesh@ioBaseChar@@QAEX_N0@Z:PROC	; ioBaseChar::ShowWeaponItemMesh
EXTRN	?OnSkillEnd@ioAttackSkill@@UAEXPAVioBaseChar@@@Z:PROC ; ioAttackSkill::OnSkillEnd
; Function compile flags: /Ogsp
;	COMDAT ?OnSkillEnd@ioDefenseAttackSkill@@UAEXPAVioBaseChar@@@Z
_TEXT	SEGMENT
_pChar$ = 8						; size = 4
?OnSkillEnd@ioDefenseAttackSkill@@UAEXPAVioBaseChar@@@Z PROC ; ioDefenseAttackSkill::OnSkillEnd, COMDAT
; _this$ = ecx

; 137  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 138  : 	ioAttackSkill::OnSkillEnd( pChar );

  00006	ff 75 08	 push	 DWORD PTR _pChar$[ebp]
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ?OnSkillEnd@ioAttackSkill@@UAEXPAVioBaseChar@@@Z ; ioAttackSkill::OnSkillEnd

; 139  : 	
; 140  : 	if( GetOwnerItem() )

  00010	8b 8e a4 02 00
	00		 mov	 ecx, DWORD PTR [esi+676]
  00016	33 db		 xor	 ebx, ebx
  00018	3b cb		 cmp	 ecx, ebx
  0001a	74 08		 je	 SHORT $LN3@OnSkillEnd

; 141  : 		GetOwnerItem()->ClearCurChargeRateForSkill();

  0001c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001e	ff 90 84 00 00
	00		 call	 DWORD PTR [eax+132]
$LN3@OnSkillEnd:

; 142  : 
; 143  : 	//  
; 144  : 	if( m_bUseItemMesh )

  00024	38 9e 08 0f 00
	00		 cmp	 BYTE PTR [esi+3848], bl
  0002a	74 0b		 je	 SHORT $LN2@OnSkillEnd

; 145  : 	{
; 146  : 		pChar->ShowWeaponItemMesh( true );

  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _pChar$[ebp]
  0002f	53		 push	 ebx
  00030	6a 01		 push	 1
  00032	e8 00 00 00 00	 call	 ?ShowWeaponItemMesh@ioBaseChar@@QAEX_N0@Z ; ioBaseChar::ShowWeaponItemMesh
$LN2@OnSkillEnd:

; 147  : 	}
; 148  : 
; 149  : 	if( !m_HandMesh.IsEmpty() )

  00037	8d be f8 0e 00
	00		 lea	 edi, DWORD PTR [esi+3832]
  0003d	8b cf		 mov	 ecx, edi
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00045	84 c0		 test	 al, al
  00047	75 13		 jne	 SHORT $LN1@OnSkillEnd

; 150  : 	{
; 151  : 		pChar->RestoreSkillWeaponMesh( this, m_HandMesh, m_bVisibleEquipMesh );

  00049	0f b6 86 09 0f
	00 00		 movzx	 eax, BYTE PTR [esi+3849]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _pChar$[ebp]
  00053	53		 push	 ebx
  00054	50		 push	 eax
  00055	57		 push	 edi
  00056	56		 push	 esi
  00057	e8 00 00 00 00	 call	 ?RestoreSkillWeaponMesh@ioBaseChar@@QAE_NPAVioSkill@@ABVioHashString@@_N2@Z ; ioBaseChar::RestoreSkillWeaponMesh
$LN1@OnSkillEnd:

; 152  : 	}
; 153  : 
; 154  : 	m_bSetHandMesh = false;

  0005c	5f		 pop	 edi
  0005d	88 9e 0a 0f 00
	00		 mov	 BYTE PTR [esi+3850], bl

; 155  : 	m_SkillState = SS_NONE;

  00063	89 9e e4 10 00
	00		 mov	 DWORD PTR [esi+4324], ebx
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx

; 156  : }

  0006b	5d		 pop	 ebp
  0006c	c2 04 00	 ret	 4
?OnSkillEnd@ioDefenseAttackSkill@@UAEXPAVioBaseChar@@@Z ENDP ; ioDefenseAttackSkill::OnSkillEnd
_TEXT	ENDS
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadString_e@$0BB@@ioINILoader@@QAEXAAY0BB@$$CBDAAY00$$CBDPADH@Z ; ioINILoader::LoadString_e<17>
EXTRN	__imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z:PROC
EXTRN	___security_cookie:DWORD
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\io3dengine\ioiniloader.h
;	COMDAT ??$LoadString_e@$0BB@@ioINILoader@@QAEXAAY0BB@$$CBDAAY00$$CBDPADH@Z
_TEXT	SEGMENT
_this$GSCopy$ = -32					; size = 4
__k$ = -28						; size = 17
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_d$ = 12						; size = 4
_b$ = 16						; size = 4
_i$ = 20						; size = 4
??$LoadString_e@$0BB@@ioINILoader@@QAEXAAY0BB@$$CBDAAY00$$CBDPADH@Z PROC ; ioINILoader::LoadString_e<17>, COMDAT
; _this$ = ecx

; 161  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 162  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b 75 0c	 mov	 esi, DWORD PTR _d$[ebp]
  00019	57		 push	 edi
  0001a	8b 7d 10	 mov	 edi, DWORD PTR _b$[ebp]
  0001d	89 4d e0	 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  00020	84 d2		 test	 dl, dl
  00022	0f 84 a7 01 00
	00		 je	 $LN96@LoadString
  00028	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0002b	88 55 e4	 mov	 BYTE PTR __k$[ebp], dl
  0002e	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00031	84 d2		 test	 dl, dl
  00033	0f 84 90 01 00
	00		 je	 $LN95@LoadString
  00039	b1 ec		 mov	 cl, -20			; ffffffecH
  0003b	32 d1		 xor	 dl, cl
  0003d	88 55 e5	 mov	 BYTE PTR __k$[ebp+1], dl
  00040	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  00043	84 d2		 test	 dl, dl
  00045	0f 84 78 01 00
	00		 je	 $LN94@LoadString
  0004b	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0004e	88 55 e6	 mov	 BYTE PTR __k$[ebp+2], dl
  00051	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  00054	84 d2		 test	 dl, dl
  00056	0f 84 61 01 00
	00		 je	 $LN93@LoadString
  0005c	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0005f	88 55 e7	 mov	 BYTE PTR __k$[ebp+3], dl
  00062	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  00065	84 d2		 test	 dl, dl
  00067	0f 84 4a 01 00
	00		 je	 $LN92@LoadString
  0006d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00070	88 55 e8	 mov	 BYTE PTR __k$[ebp+4], dl
  00073	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00076	84 d2		 test	 dl, dl
  00078	0f 84 34 01 00
	00		 je	 $LN91@LoadString
  0007e	32 d1		 xor	 dl, cl
  00080	88 55 e9	 mov	 BYTE PTR __k$[ebp+5], dl
  00083	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00086	84 d2		 test	 dl, dl
  00088	0f 84 1e 01 00
	00		 je	 $LN90@LoadString
  0008e	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00091	88 55 ea	 mov	 BYTE PTR __k$[ebp+6], dl
  00094	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00097	84 d2		 test	 dl, dl
  00099	0f 84 07 01 00
	00		 je	 $LN89@LoadString
  0009f	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000a2	88 55 eb	 mov	 BYTE PTR __k$[ebp+7], dl
  000a5	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a8	84 d2		 test	 dl, dl
  000aa	0f 84 f0 00 00
	00		 je	 $LN88@LoadString
  000b0	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000b3	88 55 ec	 mov	 BYTE PTR __k$[ebp+8], dl
  000b6	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b9	84 d2		 test	 dl, dl
  000bb	0f 84 da 00 00
	00		 je	 $LN87@LoadString
  000c1	32 d1		 xor	 dl, cl
  000c3	88 55 ed	 mov	 BYTE PTR __k$[ebp+9], dl
  000c6	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c9	84 d2		 test	 dl, dl
  000cb	0f 84 c4 00 00
	00		 je	 $LN86@LoadString
  000d1	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000d4	88 55 ee	 mov	 BYTE PTR __k$[ebp+10], dl
  000d7	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000da	84 d2		 test	 dl, dl
  000dc	0f 84 ad 00 00
	00		 je	 $LN85@LoadString
  000e2	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000e5	88 55 ef	 mov	 BYTE PTR __k$[ebp+11], dl
  000e8	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000eb	84 d2		 test	 dl, dl
  000ed	0f 84 96 00 00
	00		 je	 $LN84@LoadString
  000f3	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000f6	88 55 f0	 mov	 BYTE PTR __k$[ebp+12], dl
  000f9	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000fc	84 d2		 test	 dl, dl
  000fe	0f 84 80 00 00
	00		 je	 $LN83@LoadString
  00104	32 d1		 xor	 dl, cl
  00106	88 55 f1	 mov	 BYTE PTR __k$[ebp+13], dl
  00109	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  0010c	84 d2		 test	 dl, dl
  0010e	74 6e		 je	 SHORT $LN82@LoadString
  00110	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00113	88 55 f2	 mov	 BYTE PTR __k$[ebp+14], dl
  00116	8a 50 0f	 mov	 dl, BYTE PTR [eax+15]
  00119	84 d2		 test	 dl, dl
  0011b	74 5b		 je	 SHORT $LN81@LoadString
  0011d	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00120	80 78 10 00	 cmp	 BYTE PTR [eax+16], 0
  00124	88 55 f3	 mov	 BYTE PTR __k$[ebp+15], dl
  00127	0f 84 a6 00 00
	00		 je	 $LN111@LoadString
  0012d	8a 50 11	 mov	 dl, BYTE PTR [eax+17]
  00130	84 d2		 test	 dl, dl
  00132	74 3f		 je	 SHORT $LN79@LoadString
  00134	32 d1		 xor	 dl, cl
  00136	88 55 f5	 mov	 BYTE PTR __k$[ebp+17], dl
  00139	8a 50 12	 mov	 dl, BYTE PTR [eax+18]
  0013c	84 d2		 test	 dl, dl
  0013e	74 2d		 je	 SHORT $LN78@LoadString
  00140	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00143	88 55 f6	 mov	 BYTE PTR __k$[ebp+18], dl
  00146	8a 50 13	 mov	 dl, BYTE PTR [eax+19]
  00149	84 d2		 test	 dl, dl
  0014b	74 1a		 je	 SHORT $LN77@LoadString
  0014d	8a 40 14	 mov	 al, BYTE PTR [eax+20]
  00150	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00153	88 55 f7	 mov	 BYTE PTR __k$[ebp+19], dl
  00156	84 c0		 test	 al, al
  00158	74 07		 je	 SHORT $LN76@LoadString
  0015a	34 ed		 xor	 al, -19			; ffffffedH
  0015c	88 45 f8	 mov	 BYTE PTR __k$[ebp+20], al
  0015f	eb 72		 jmp	 SHORT $LN111@LoadString
$LN76@LoadString:
  00161	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+20], -19 ; ffffffedH
  00165	eb 6c		 jmp	 SHORT $LN111@LoadString
$LN77@LoadString:
  00167	c6 45 f7 ea	 mov	 BYTE PTR __k$[ebp+19], -22 ; ffffffeaH
  0016b	eb 66		 jmp	 SHORT $LN111@LoadString
$LN78@LoadString:
  0016d	c6 45 f6 eb	 mov	 BYTE PTR __k$[ebp+18], -21 ; ffffffebH
  00171	eb 60		 jmp	 SHORT $LN111@LoadString
$LN79@LoadString:
  00173	88 4d f5	 mov	 BYTE PTR __k$[ebp+17], cl
  00176	eb 5b		 jmp	 SHORT $LN111@LoadString
$LN81@LoadString:
  00178	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+15], -22 ; ffffffeaH
  0017c	eb 55		 jmp	 SHORT $LN111@LoadString
$LN82@LoadString:
  0017e	c6 45 f2 eb	 mov	 BYTE PTR __k$[ebp+14], -21 ; ffffffebH
  00182	eb 4f		 jmp	 SHORT $LN111@LoadString
$LN83@LoadString:
  00184	88 4d f1	 mov	 BYTE PTR __k$[ebp+13], cl
  00187	eb 4a		 jmp	 SHORT $LN111@LoadString
$LN84@LoadString:
  00189	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  0018d	eb 44		 jmp	 SHORT $LN111@LoadString
$LN85@LoadString:
  0018f	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  00193	eb 3e		 jmp	 SHORT $LN111@LoadString
$LN86@LoadString:
  00195	c6 45 ee eb	 mov	 BYTE PTR __k$[ebp+10], -21 ; ffffffebH
  00199	eb 38		 jmp	 SHORT $LN111@LoadString
$LN87@LoadString:
  0019b	88 4d ed	 mov	 BYTE PTR __k$[ebp+9], cl
  0019e	eb 33		 jmp	 SHORT $LN111@LoadString
$LN88@LoadString:
  001a0	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  001a4	eb 2d		 jmp	 SHORT $LN111@LoadString
$LN89@LoadString:
  001a6	c6 45 eb ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  001aa	eb 27		 jmp	 SHORT $LN111@LoadString
$LN90@LoadString:
  001ac	c6 45 ea eb	 mov	 BYTE PTR __k$[ebp+6], -21 ; ffffffebH
  001b0	eb 21		 jmp	 SHORT $LN111@LoadString
$LN91@LoadString:
  001b2	88 4d e9	 mov	 BYTE PTR __k$[ebp+5], cl
  001b5	eb 1c		 jmp	 SHORT $LN111@LoadString
$LN92@LoadString:
  001b7	c6 45 e8 ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  001bb	eb 16		 jmp	 SHORT $LN111@LoadString
$LN93@LoadString:
  001bd	c6 45 e7 ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  001c1	eb 10		 jmp	 SHORT $LN111@LoadString
$LN94@LoadString:
  001c3	c6 45 e6 eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  001c7	eb 0a		 jmp	 SHORT $LN111@LoadString
$LN95@LoadString:
  001c9	c6 45 e5 ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  001cd	eb 04		 jmp	 SHORT $LN111@LoadString
$LN96@LoadString:
  001cf	c6 45 e4 ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN111@LoadString:
  001d3	6a 04		 push	 4
  001d5	8d 45 e4	 lea	 eax, DWORD PTR __k$[ebp]
  001d8	c6 45 f4 00	 mov	 BYTE PTR __k$[ebp+16], 0
  001dc	5a		 pop	 edx
$LL104@LoadString:
  001dd	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  001e3	83 c0 04	 add	 eax, 4
  001e6	4a		 dec	 edx
  001e7	75 f4		 jne	 SHORT $LL104@LoadString

; 163  : 		LoadString(_k, d, b, i);

  001e9	ff 75 14	 push	 DWORD PTR _i$[ebp]
  001ec	8b 4d e0	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  001ef	57		 push	 edi
  001f0	56		 push	 esi
  001f1	8d 45 e4	 lea	 eax, DWORD PTR __k$[ebp]
  001f4	50		 push	 eax
  001f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 164  : 	}

  001fb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001fe	5f		 pop	 edi
  001ff	33 cd		 xor	 ecx, ebp
  00201	5e		 pop	 esi
  00202	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00207	c9		 leave
  00208	c2 10 00	 ret	 16			; 00000010H
??$LoadString_e@$0BB@@ioINILoader@@QAEXAAY0BB@$$CBDAAY00$$CBDPADH@Z ENDP ; ioINILoader::LoadString_e<17>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadFloat_e@$0BG@@ioINILoader@@QAEMAAY0BG@$$CBDM@Z ; ioINILoader::LoadFloat_e<22>
EXTRN	__imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z:PROC
; Function compile flags: /Ogsp
;	COMDAT ??$LoadFloat_e@$0BG@@ioINILoader@@QAEMAAY0BG@$$CBDM@Z
_TEXT	SEGMENT
__k$ = -32						; size = 22
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_f$ = 12						; size = 4
??$LoadFloat_e@$0BG@@ioINILoader@@QAEMAAY0BG@$$CBDM@Z PROC ; ioINILoader::LoadFloat_e<22>, COMDAT
; _this$ = ecx

; 135  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 136  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx
  00019	84 d2		 test	 dl, dl
  0001b	0f 84 15 02 00
	00		 je	 $LN96@LoadFloat_
  00021	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00024	88 55 e0	 mov	 BYTE PTR __k$[ebp], dl
  00027	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002a	84 d2		 test	 dl, dl
  0002c	0f 84 fe 01 00
	00		 je	 $LN95@LoadFloat_
  00032	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00035	88 55 e1	 mov	 BYTE PTR __k$[ebp+1], dl
  00038	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003b	84 d2		 test	 dl, dl
  0003d	0f 84 e7 01 00
	00		 je	 $LN94@LoadFloat_
  00043	b1 eb		 mov	 cl, -21			; ffffffebH
  00045	32 d1		 xor	 dl, cl
  00047	88 55 e2	 mov	 BYTE PTR __k$[ebp+2], dl
  0004a	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004d	84 d2		 test	 dl, dl
  0004f	0f 84 cf 01 00
	00		 je	 $LN93@LoadFloat_
  00055	b3 ea		 mov	 bl, -22			; ffffffeaH
  00057	32 d3		 xor	 dl, bl
  00059	88 55 e3	 mov	 BYTE PTR __k$[ebp+3], dl
  0005c	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005f	84 d2		 test	 dl, dl
  00061	0f 84 b7 01 00
	00		 je	 $LN92@LoadFloat_
  00067	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0006a	88 55 e4	 mov	 BYTE PTR __k$[ebp+4], dl
  0006d	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00070	84 d2		 test	 dl, dl
  00072	0f 84 a0 01 00
	00		 je	 $LN91@LoadFloat_
  00078	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0007b	88 55 e5	 mov	 BYTE PTR __k$[ebp+5], dl
  0007e	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00081	84 d2		 test	 dl, dl
  00083	0f 84 8a 01 00
	00		 je	 $LN90@LoadFloat_
  00089	32 d1		 xor	 dl, cl
  0008b	88 55 e6	 mov	 BYTE PTR __k$[ebp+6], dl
  0008e	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00091	84 d2		 test	 dl, dl
  00093	0f 84 75 01 00
	00		 je	 $LN89@LoadFloat_
  00099	32 d3		 xor	 dl, bl
  0009b	88 55 e7	 mov	 BYTE PTR __k$[ebp+7], dl
  0009e	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a1	84 d2		 test	 dl, dl
  000a3	0f 84 5f 01 00
	00		 je	 $LN88@LoadFloat_
  000a9	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ac	88 55 e8	 mov	 BYTE PTR __k$[ebp+8], dl
  000af	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b2	84 d2		 test	 dl, dl
  000b4	0f 84 48 01 00
	00		 je	 $LN87@LoadFloat_
  000ba	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000bd	88 55 e9	 mov	 BYTE PTR __k$[ebp+9], dl
  000c0	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c3	84 d2		 test	 dl, dl
  000c5	0f 84 32 01 00
	00		 je	 $LN86@LoadFloat_
  000cb	32 d1		 xor	 dl, cl
  000cd	88 55 ea	 mov	 BYTE PTR __k$[ebp+10], dl
  000d0	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000d3	84 d2		 test	 dl, dl
  000d5	0f 84 1d 01 00
	00		 je	 $LN85@LoadFloat_
  000db	32 d3		 xor	 dl, bl
  000dd	88 55 eb	 mov	 BYTE PTR __k$[ebp+11], dl
  000e0	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000e3	84 d2		 test	 dl, dl
  000e5	0f 84 07 01 00
	00		 je	 $LN84@LoadFloat_
  000eb	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ee	88 55 ec	 mov	 BYTE PTR __k$[ebp+12], dl
  000f1	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000f4	84 d2		 test	 dl, dl
  000f6	0f 84 f0 00 00
	00		 je	 $LN83@LoadFloat_
  000fc	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000ff	88 55 ed	 mov	 BYTE PTR __k$[ebp+13], dl
  00102	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  00105	84 d2		 test	 dl, dl
  00107	0f 84 da 00 00
	00		 je	 $LN82@LoadFloat_
  0010d	32 d1		 xor	 dl, cl
  0010f	88 55 ee	 mov	 BYTE PTR __k$[ebp+14], dl
  00112	8a 50 0f	 mov	 dl, BYTE PTR [eax+15]
  00115	84 d2		 test	 dl, dl
  00117	0f 84 c5 00 00
	00		 je	 $LN81@LoadFloat_
  0011d	32 d3		 xor	 dl, bl
  0011f	88 55 ef	 mov	 BYTE PTR __k$[ebp+15], dl
  00122	8a 50 10	 mov	 dl, BYTE PTR [eax+16]
  00125	84 d2		 test	 dl, dl
  00127	0f 84 af 00 00
	00		 je	 $LN80@LoadFloat_
  0012d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00130	88 55 f0	 mov	 BYTE PTR __k$[ebp+16], dl
  00133	8a 50 11	 mov	 dl, BYTE PTR [eax+17]
  00136	84 d2		 test	 dl, dl
  00138	0f 84 98 00 00
	00		 je	 $LN79@LoadFloat_
  0013e	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00141	88 55 f1	 mov	 BYTE PTR __k$[ebp+17], dl
  00144	8a 50 12	 mov	 dl, BYTE PTR [eax+18]
  00147	84 d2		 test	 dl, dl
  00149	0f 84 82 00 00
	00		 je	 $LN78@LoadFloat_
  0014f	32 d1		 xor	 dl, cl
  00151	88 55 f2	 mov	 BYTE PTR __k$[ebp+18], dl
  00154	8a 50 13	 mov	 dl, BYTE PTR [eax+19]
  00157	84 d2		 test	 dl, dl
  00159	74 71		 je	 SHORT $LN77@LoadFloat_
  0015b	32 d3		 xor	 dl, bl
  0015d	88 55 f3	 mov	 BYTE PTR __k$[ebp+19], dl
  00160	8a 50 14	 mov	 dl, BYTE PTR [eax+20]
  00163	84 d2		 test	 dl, dl
  00165	74 5f		 je	 SHORT $LN76@LoadFloat_
  00167	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0016a	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0016e	88 55 f4	 mov	 BYTE PTR __k$[ebp+20], dl
  00171	0f 84 c3 00 00
	00		 je	 $LN1@LoadFloat_
  00177	8a 50 16	 mov	 dl, BYTE PTR [eax+22]
  0017a	84 d2		 test	 dl, dl
  0017c	74 43		 je	 SHORT $LN74@LoadFloat_
  0017e	32 d1		 xor	 dl, cl
  00180	88 55 f6	 mov	 BYTE PTR __k$[ebp+22], dl
  00183	8a 50 17	 mov	 dl, BYTE PTR [eax+23]
  00186	84 d2		 test	 dl, dl
  00188	74 32		 je	 SHORT $LN73@LoadFloat_
  0018a	32 d3		 xor	 dl, bl
  0018c	88 55 f7	 mov	 BYTE PTR __k$[ebp+23], dl
  0018f	8a 50 18	 mov	 dl, BYTE PTR [eax+24]
  00192	84 d2		 test	 dl, dl
  00194	74 20		 je	 SHORT $LN72@LoadFloat_
  00196	8a 40 19	 mov	 al, BYTE PTR [eax+25]
  00199	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0019c	88 55 f8	 mov	 BYTE PTR __k$[ebp+24], dl
  0019f	84 c0		 test	 al, al
  001a1	74 0a		 je	 SHORT $LN71@LoadFloat_
  001a3	34 ec		 xor	 al, -20			; ffffffecH
  001a5	88 45 f9	 mov	 BYTE PTR __k$[ebp+25], al
  001a8	e9 8d 00 00 00	 jmp	 $LN1@LoadFloat_
$LN71@LoadFloat_:
  001ad	c6 45 f9 ec	 mov	 BYTE PTR __k$[ebp+25], -20 ; ffffffecH
  001b1	e9 84 00 00 00	 jmp	 $LN1@LoadFloat_
$LN72@LoadFloat_:
  001b6	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+24], -19 ; ffffffedH
  001ba	eb 7e		 jmp	 SHORT $LN1@LoadFloat_
$LN73@LoadFloat_:
  001bc	88 5d f7	 mov	 BYTE PTR __k$[ebp+23], bl
  001bf	eb 79		 jmp	 SHORT $LN1@LoadFloat_
$LN74@LoadFloat_:
  001c1	88 4d f6	 mov	 BYTE PTR __k$[ebp+22], cl
  001c4	eb 74		 jmp	 SHORT $LN1@LoadFloat_
$LN76@LoadFloat_:
  001c6	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+20], -19 ; ffffffedH
  001ca	eb 6e		 jmp	 SHORT $LN1@LoadFloat_
$LN77@LoadFloat_:
  001cc	88 5d f3	 mov	 BYTE PTR __k$[ebp+19], bl
  001cf	eb 69		 jmp	 SHORT $LN1@LoadFloat_
$LN78@LoadFloat_:
  001d1	88 4d f2	 mov	 BYTE PTR __k$[ebp+18], cl
  001d4	eb 64		 jmp	 SHORT $LN1@LoadFloat_
$LN79@LoadFloat_:
  001d6	c6 45 f1 ec	 mov	 BYTE PTR __k$[ebp+17], -20 ; ffffffecH
  001da	eb 5e		 jmp	 SHORT $LN1@LoadFloat_
$LN80@LoadFloat_:
  001dc	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+16], -19 ; ffffffedH
  001e0	eb 58		 jmp	 SHORT $LN1@LoadFloat_
$LN81@LoadFloat_:
  001e2	88 5d ef	 mov	 BYTE PTR __k$[ebp+15], bl
  001e5	eb 53		 jmp	 SHORT $LN1@LoadFloat_
$LN82@LoadFloat_:
  001e7	88 4d ee	 mov	 BYTE PTR __k$[ebp+14], cl
  001ea	eb 4e		 jmp	 SHORT $LN1@LoadFloat_
$LN83@LoadFloat_:
  001ec	c6 45 ed ec	 mov	 BYTE PTR __k$[ebp+13], -20 ; ffffffecH
  001f0	eb 48		 jmp	 SHORT $LN1@LoadFloat_
$LN84@LoadFloat_:
  001f2	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  001f6	eb 42		 jmp	 SHORT $LN1@LoadFloat_
$LN85@LoadFloat_:
  001f8	88 5d eb	 mov	 BYTE PTR __k$[ebp+11], bl
  001fb	eb 3d		 jmp	 SHORT $LN1@LoadFloat_
$LN86@LoadFloat_:
  001fd	88 4d ea	 mov	 BYTE PTR __k$[ebp+10], cl
  00200	eb 38		 jmp	 SHORT $LN1@LoadFloat_
$LN87@LoadFloat_:
  00202	c6 45 e9 ec	 mov	 BYTE PTR __k$[ebp+9], -20 ; ffffffecH
  00206	eb 32		 jmp	 SHORT $LN1@LoadFloat_
$LN88@LoadFloat_:
  00208	c6 45 e8 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  0020c	eb 2c		 jmp	 SHORT $LN1@LoadFloat_
$LN89@LoadFloat_:
  0020e	88 5d e7	 mov	 BYTE PTR __k$[ebp+7], bl
  00211	eb 27		 jmp	 SHORT $LN1@LoadFloat_
$LN90@LoadFloat_:
  00213	88 4d e6	 mov	 BYTE PTR __k$[ebp+6], cl
  00216	eb 22		 jmp	 SHORT $LN1@LoadFloat_
$LN91@LoadFloat_:
  00218	c6 45 e5 ec	 mov	 BYTE PTR __k$[ebp+5], -20 ; ffffffecH
  0021c	eb 1c		 jmp	 SHORT $LN1@LoadFloat_
$LN92@LoadFloat_:
  0021e	c6 45 e4 ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  00222	eb 16		 jmp	 SHORT $LN1@LoadFloat_
$LN93@LoadFloat_:
  00224	c6 45 e3 ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  00228	eb 10		 jmp	 SHORT $LN1@LoadFloat_
$LN94@LoadFloat_:
  0022a	c6 45 e2 eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  0022e	eb 0a		 jmp	 SHORT $LN1@LoadFloat_
$LN95@LoadFloat_:
  00230	c6 45 e1 ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  00234	eb 04		 jmp	 SHORT $LN1@LoadFloat_
$LN96@LoadFloat_:
  00236	c6 45 e0 ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@LoadFloat_:
  0023a	6a 05		 push	 5
  0023c	8d 45 e0	 lea	 eax, DWORD PTR __k$[ebp]
  0023f	c6 45 f5 00	 mov	 BYTE PTR __k$[ebp+21], 0
  00243	5a		 pop	 edx
$LL104@LoadFloat_:
  00244	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0024a	83 c0 04	 add	 eax, 4
  0024d	4a		 dec	 edx
  0024e	75 f4		 jne	 SHORT $LL104@LoadFloat_

; 137  : 		return LoadFloat(_k, f);

  00250	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _f$[ebp]
  00255	80 75 f4 ed	 xor	 BYTE PTR __k$[ebp+20], -19 ; ffffffedH
  00259	51		 push	 ecx
  0025a	8d 45 e0	 lea	 eax, DWORD PTR __k$[ebp]
  0025d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00262	50		 push	 eax
  00263	8b ce		 mov	 ecx, esi
  00265	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z

; 138  : 	}

  0026b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0026e	5e		 pop	 esi
  0026f	33 cd		 xor	 ecx, ebp
  00271	5b		 pop	 ebx
  00272	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00277	c9		 leave
  00278	c2 08 00	 ret	 8
??$LoadFloat_e@$0BG@@ioINILoader@@QAEMAAY0BG@$$CBDM@Z ENDP ; ioINILoader::LoadFloat_e<22>
_TEXT	ENDS
PUBLIC	??$GetAnimationEventTime_e@$0L@@ioEntityGroup@@QAEMHAAY0L@$$CBD@Z ; ioEntityGroup::GetAnimationEventTime_e<11>
EXTRN	__imp_?GetAnimationEventTime@ioEntityGroup@@QAEMHABVioHashString@@@Z:PROC
EXTRN	__imp_??0ioHashString@@QAE@PBD@Z:PROC
EXTRN	__EH_epilog3_GS:PROC
EXTRN	__EH_prolog3_GS:PROC
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stringprotect.h
xdata$x	SEGMENT
__unwindtable$??$GetAnimationEventTime_e@$0L@@ioEntityGroup@@QAEMHAAY0L@$$CBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetAnimationEventTime_e@$0L@@ioEntityGroup@@QAEMHAAY0L@$$CBD@Z$0
__ehfuncinfo$??$GetAnimationEventTime_e@$0L@@ioEntityGroup@@QAEMHAAY0L@$$CBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$GetAnimationEventTime_e@$0L@@ioEntityGroup@@QAEMHAAY0L@$$CBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\io3dengine\ioentitygroup.h
xdata$x	ENDS
;	COMDAT ??$GetAnimationEventTime_e@$0L@@ioEntityGroup@@QAEMHAAY0L@$$CBD@Z
_TEXT	SEGMENT
$T524919 = -52						; size = 16
$T524918 = -36						; size = 4
_szEncEventType$ = -32					; size = 11
__$EHRec$ = -12						; size = 12
_id$ = 8						; size = 4
_szEventType$ = 12					; size = 4
??$GetAnimationEventTime_e@$0L@@ioEntityGroup@@QAEMHAAY0L@$$CBD@Z PROC ; ioEntityGroup::GetAnimationEventTime_e<11>, COMDAT
; _this$ = ecx

; 414  : 	{

  00000	6a 28		 push	 40			; 00000028H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??$GetAnimationEventTime_e@$0L@@ioEntityGroup@@QAEMHAAY0L@$$CBD@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000c	8b 45 0c	 mov	 eax, DWORD PTR _szEventType$[ebp]
  0000f	8b f1		 mov	 esi, ecx

; 415  : 		_ENCSTR(szEventType, szEncEventType);

  00011	8a 08		 mov	 cl, BYTE PTR [eax]
  00013	84 c9		 test	 cl, cl
  00015	0f 84 1b 01 00
	00		 je	 $LN96@GetAnimati
  0001b	b2 ed		 mov	 dl, -19			; ffffffedH
  0001d	32 ca		 xor	 cl, dl
  0001f	88 4d e0	 mov	 BYTE PTR _szEncEventType$[ebp], cl
  00022	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00025	84 c9		 test	 cl, cl
  00027	0f 84 03 01 00
	00		 je	 $LN95@GetAnimati
  0002d	80 f1 ec	 xor	 cl, -20			; ffffffecH
  00030	88 4d e1	 mov	 BYTE PTR _szEncEventType$[ebp+1], cl
  00033	8a 48 02	 mov	 cl, BYTE PTR [eax+2]
  00036	84 c9		 test	 cl, cl
  00038	0f 84 ec 00 00
	00		 je	 $LN94@GetAnimati
  0003e	80 f1 eb	 xor	 cl, -21			; ffffffebH
  00041	88 4d e2	 mov	 BYTE PTR _szEncEventType$[ebp+2], cl
  00044	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  00047	84 c9		 test	 cl, cl
  00049	0f 84 d5 00 00
	00		 je	 $LN93@GetAnimati
  0004f	80 f1 ea	 xor	 cl, -22			; ffffffeaH
  00052	88 4d e3	 mov	 BYTE PTR _szEncEventType$[ebp+3], cl
  00055	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  00058	84 c9		 test	 cl, cl
  0005a	0f 84 bf 00 00
	00		 je	 $LN92@GetAnimati
  00060	32 ca		 xor	 cl, dl
  00062	88 4d e4	 mov	 BYTE PTR _szEncEventType$[ebp+4], cl
  00065	8a 48 05	 mov	 cl, BYTE PTR [eax+5]
  00068	84 c9		 test	 cl, cl
  0006a	0f 84 a9 00 00
	00		 je	 $LN91@GetAnimati
  00070	80 f1 ec	 xor	 cl, -20			; ffffffecH
  00073	88 4d e5	 mov	 BYTE PTR _szEncEventType$[ebp+5], cl
  00076	8a 48 06	 mov	 cl, BYTE PTR [eax+6]
  00079	84 c9		 test	 cl, cl
  0007b	0f 84 92 00 00
	00		 je	 $LN90@GetAnimati
  00081	80 f1 eb	 xor	 cl, -21			; ffffffebH
  00084	88 4d e6	 mov	 BYTE PTR _szEncEventType$[ebp+6], cl
  00087	8a 48 07	 mov	 cl, BYTE PTR [eax+7]
  0008a	84 c9		 test	 cl, cl
  0008c	74 7f		 je	 SHORT $LN89@GetAnimati
  0008e	80 f1 ea	 xor	 cl, -22			; ffffffeaH
  00091	88 4d e7	 mov	 BYTE PTR _szEncEventType$[ebp+7], cl
  00094	8a 48 08	 mov	 cl, BYTE PTR [eax+8]
  00097	84 c9		 test	 cl, cl
  00099	74 6d		 je	 SHORT $LN88@GetAnimati
  0009b	32 ca		 xor	 cl, dl
  0009d	88 4d e8	 mov	 BYTE PTR _szEncEventType$[ebp+8], cl
  000a0	8a 48 09	 mov	 cl, BYTE PTR [eax+9]
  000a3	84 c9		 test	 cl, cl
  000a5	74 5b		 je	 SHORT $LN87@GetAnimati
  000a7	80 f1 ec	 xor	 cl, -20			; ffffffecH
  000aa	80 78 0a 00	 cmp	 BYTE PTR [eax+10], 0
  000ae	88 4d e9	 mov	 BYTE PTR _szEncEventType$[ebp+9], cl
  000b1	0f 84 83 00 00
	00		 je	 $LN1@GetAnimati
  000b7	8a 48 0b	 mov	 cl, BYTE PTR [eax+11]
  000ba	84 c9		 test	 cl, cl
  000bc	74 3e		 je	 SHORT $LN85@GetAnimati
  000be	80 f1 ea	 xor	 cl, -22			; ffffffeaH
  000c1	88 4d eb	 mov	 BYTE PTR _szEncEventType$[ebp+11], cl
  000c4	8a 48 0c	 mov	 cl, BYTE PTR [eax+12]
  000c7	84 c9		 test	 cl, cl
  000c9	74 2c		 je	 SHORT $LN84@GetAnimati
  000cb	32 ca		 xor	 cl, dl
  000cd	88 4d ec	 mov	 BYTE PTR _szEncEventType$[ebp+12], cl
  000d0	8a 48 0d	 mov	 cl, BYTE PTR [eax+13]
  000d3	84 c9		 test	 cl, cl
  000d5	74 1a		 je	 SHORT $LN83@GetAnimati
  000d7	8a 40 0e	 mov	 al, BYTE PTR [eax+14]
  000da	80 f1 ec	 xor	 cl, -20			; ffffffecH
  000dd	88 4d ed	 mov	 BYTE PTR _szEncEventType$[ebp+13], cl
  000e0	84 c0		 test	 al, al
  000e2	74 07		 je	 SHORT $LN82@GetAnimati
  000e4	34 eb		 xor	 al, -21			; ffffffebH
  000e6	88 45 ee	 mov	 BYTE PTR _szEncEventType$[ebp+14], al
  000e9	eb 4f		 jmp	 SHORT $LN1@GetAnimati
$LN82@GetAnimati:
  000eb	c6 45 ee eb	 mov	 BYTE PTR _szEncEventType$[ebp+14], -21 ; ffffffebH
  000ef	eb 49		 jmp	 SHORT $LN1@GetAnimati
$LN83@GetAnimati:
  000f1	c6 45 ed ec	 mov	 BYTE PTR _szEncEventType$[ebp+13], -20 ; ffffffecH
  000f5	eb 43		 jmp	 SHORT $LN1@GetAnimati
$LN84@GetAnimati:
  000f7	88 55 ec	 mov	 BYTE PTR _szEncEventType$[ebp+12], dl
  000fa	eb 3e		 jmp	 SHORT $LN1@GetAnimati
$LN85@GetAnimati:
  000fc	c6 45 eb ea	 mov	 BYTE PTR _szEncEventType$[ebp+11], -22 ; ffffffeaH
  00100	eb 38		 jmp	 SHORT $LN1@GetAnimati
$LN87@GetAnimati:
  00102	c6 45 e9 ec	 mov	 BYTE PTR _szEncEventType$[ebp+9], -20 ; ffffffecH
  00106	eb 32		 jmp	 SHORT $LN1@GetAnimati
$LN88@GetAnimati:
  00108	88 55 e8	 mov	 BYTE PTR _szEncEventType$[ebp+8], dl
  0010b	eb 2d		 jmp	 SHORT $LN1@GetAnimati
$LN89@GetAnimati:
  0010d	c6 45 e7 ea	 mov	 BYTE PTR _szEncEventType$[ebp+7], -22 ; ffffffeaH
  00111	eb 27		 jmp	 SHORT $LN1@GetAnimati
$LN90@GetAnimati:
  00113	c6 45 e6 eb	 mov	 BYTE PTR _szEncEventType$[ebp+6], -21 ; ffffffebH
  00117	eb 21		 jmp	 SHORT $LN1@GetAnimati
$LN91@GetAnimati:
  00119	c6 45 e5 ec	 mov	 BYTE PTR _szEncEventType$[ebp+5], -20 ; ffffffecH
  0011d	eb 1b		 jmp	 SHORT $LN1@GetAnimati
$LN92@GetAnimati:
  0011f	88 55 e4	 mov	 BYTE PTR _szEncEventType$[ebp+4], dl
  00122	eb 16		 jmp	 SHORT $LN1@GetAnimati
$LN93@GetAnimati:
  00124	c6 45 e3 ea	 mov	 BYTE PTR _szEncEventType$[ebp+3], -22 ; ffffffeaH
  00128	eb 10		 jmp	 SHORT $LN1@GetAnimati
$LN94@GetAnimati:
  0012a	c6 45 e2 eb	 mov	 BYTE PTR _szEncEventType$[ebp+2], -21 ; ffffffebH
  0012e	eb 0a		 jmp	 SHORT $LN1@GetAnimati
$LN95@GetAnimati:
  00130	c6 45 e1 ec	 mov	 BYTE PTR _szEncEventType$[ebp+1], -20 ; ffffffecH
  00134	eb 04		 jmp	 SHORT $LN1@GetAnimati
$LN96@GetAnimati:
  00136	c6 45 e0 ed	 mov	 BYTE PTR _szEncEventType$[ebp], -19 ; ffffffedH
$LN1@GetAnimati:
  0013a	6a 02		 push	 2
  0013c	8d 45 e0	 lea	 eax, DWORD PTR _szEncEventType$[ebp]
  0013f	c6 45 ea 00	 mov	 BYTE PTR _szEncEventType$[ebp+10], 0
  00143	59		 pop	 ecx
$LL105@GetAnimati:
  00144	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0014a	83 c0 04	 add	 eax, 4
  0014d	49		 dec	 ecx
  0014e	75 f4		 jne	 SHORT $LL105@GetAnimati
  00150	6a 08		 push	 8
  00152	58		 pop	 eax
$LL102@GetAnimati:
  00153	8b c8		 mov	 ecx, eax
  00155	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0015b	79 05		 jns	 SHORT $LN113@GetAnimati
  0015d	49		 dec	 ecx
  0015e	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00161	41		 inc	 ecx
$LN113@GetAnimati:
  00162	b2 ed		 mov	 dl, -19			; ffffffedH
  00164	2a d1		 sub	 dl, cl
  00166	30 54 05 e0	 xor	 BYTE PTR _szEncEventType$[ebp+eax], dl
  0016a	40		 inc	 eax
  0016b	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0016e	7c e3		 jl	 SHORT $LL102@GetAnimati

; 416  : 		return GetAnimationEventTime(id, szEncEventType);

  00170	8d 45 e0	 lea	 eax, DWORD PTR _szEncEventType$[ebp]
  00173	50		 push	 eax
  00174	8d 4d cc	 lea	 ecx, DWORD PTR $T524919[ebp]
  00177	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  0017d	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00181	8d 45 cc	 lea	 eax, DWORD PTR $T524919[ebp]
  00184	50		 push	 eax
  00185	ff 75 08	 push	 DWORD PTR _id$[ebp]
  00188	8b ce		 mov	 ecx, esi
  0018a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetAnimationEventTime@ioEntityGroup@@QAEMHABVioHashString@@@Z
  00190	d9 5d dc	 fstp	 DWORD PTR $T524918[ebp]
  00193	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00197	8d 4d cc	 lea	 ecx, DWORD PTR $T524919[ebp]
  0019a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  001a0	d9 45 dc	 fld	 DWORD PTR $T524918[ebp]

; 417  : 	}

  001a3	e8 00 00 00 00	 call	 __EH_epilog3_GS
  001a8	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetAnimationEventTime_e@$0L@@ioEntityGroup@@QAEMHAAY0L@$$CBD@Z$0:
  00000	8d 4d cc	 lea	 ecx, DWORD PTR $T524919[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$??$GetAnimationEventTime_e@$0L@@ioEntityGroup@@QAEMHAAY0L@$$CBD@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$GetAnimationEventTime_e@$0L@@ioEntityGroup@@QAEMHAAY0L@$$CBD@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$GetAnimationEventTime_e@$0L@@ioEntityGroup@@QAEMHAAY0L@$$CBD@Z ENDP ; ioEntityGroup::GetAnimationEventTime_e<11>
PUBLIC	??4?$CEncrypt@M@@QAEMM@Z			; CEncrypt<float>::operator=
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
;	COMDAT ??4?$CEncrypt@M@@QAEMM@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
_inValue$ = 8						; size = 4
??4?$CEncrypt@M@@QAEMM@Z PROC				; CEncrypt<float>::operator=, COMDAT
; _this$ = ecx

; 1654 : 	{	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1655 : 		type value = inValue;

  00003	d9 45 08	 fld	 DWORD PTR _inValue$[ebp]

; 1656 : 		EncryptValueToPool((char*)&value);

  00006	8d 45 08	 lea	 eax, DWORD PTR _value$[ebp]
  00009	50		 push	 eax
  0000a	d9 5d 08	 fstp	 DWORD PTR _value$[ebp]
  0000d	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 1657 : #ifdef _NOTUSE
; 1658 : 		m_value = inValue;
; 1659 : 		Debug();
; 1660 : #endif
; 1661 : 		return value;

  00012	d9 45 08	 fld	 DWORD PTR _value$[ebp]

; 1662 : 	}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??4?$CEncrypt@M@@QAEMM@Z ENDP				; CEncrypt<float>::operator=
_TEXT	ENDS
PUBLIC	??4?$CEncrypt@K@@QAEKK@Z			; CEncrypt<unsigned long>::operator=
; Function compile flags: /Ogsp
;	COMDAT ??4?$CEncrypt@K@@QAEKK@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
_inValue$ = 8						; size = 4
??4?$CEncrypt@K@@QAEKK@Z PROC				; CEncrypt<unsigned long>::operator=, COMDAT
; _this$ = ecx

; 1262 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1263 : 		
; 1264 : 		type value = inValue;

  00003	8b 45 08	 mov	 eax, DWORD PTR _inValue$[ebp]
  00006	89 45 08	 mov	 DWORD PTR _value$[ebp], eax

; 1265 : 		EncryptValueToPool((char*)&value);

  00009	8d 45 08	 lea	 eax, DWORD PTR _value$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z ; CEncrypt<unsigned long>::EncryptValueToPool

; 1266 : #ifdef _NOTUSE
; 1267 : 		m_value = inValue;
; 1268 : 		Debug();
; 1269 : #endif
; 1270 : 		return value;

  00012	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]

; 1271 : 	}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??4?$CEncrypt@K@@QAEKK@Z ENDP				; CEncrypt<unsigned long>::operator=
_TEXT	ENDS
PUBLIC	??B?$CEncrypt@_N@@QAE_NXZ			; CEncrypt<bool>::operator bool
; Function compile flags: /Ogsp
;	COMDAT ??B?$CEncrypt@_N@@QAE_NXZ
_TEXT	SEGMENT
_value$ = -1						; size = 1
??B?$CEncrypt@_N@@QAE_NXZ PROC				; CEncrypt<bool>::operator bool, COMDAT
; _this$ = ecx

; 134  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 135  : 		type value;
; 136  : 		DecryptValueToPool(&value);

  00004	8d 45 ff	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool

; 137  : 
; 138  : #ifdef _NOTUSE
; 139  : 		Debug();
; 140  : #endif
; 141  : 		return value;

  0000d	8a 45 ff	 mov	 al, BYTE PTR _value$[ebp]

; 142  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@_N@@QAE_NXZ ENDP				; CEncrypt<bool>::operator bool
_TEXT	ENDS
PUBLIC	??B?$CEncrypt@_N@@QBE_NXZ			; CEncrypt<bool>::operator bool
; Function compile flags: /Ogsp
;	COMDAT ??B?$CEncrypt@_N@@QBE_NXZ
_TEXT	SEGMENT
_value$ = -1						; size = 1
??B?$CEncrypt@_N@@QBE_NXZ PROC				; CEncrypt<bool>::operator bool, COMDAT
; _this$ = ecx

; 145  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 146  : 		//UJ 130829, const    --start
; 147  : 		type value;
; 148  : 		CEncrypt<type>* pThis = const_cast<CEncrypt<type>*>(this);
; 149  : 		pThis->DecryptValueToPool(&value);

  00004	8d 45 ff	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool

; 150  : 		//// const DecryptValueToPool     .
; 151  :  		//type value;
; 152  : 		//char szTempMem[MAX_ENCRYPT];
; 153  : 		//m_RC5.DecryptByte( m_MemPool, szTempMem, max(m_ValueSize, DEFAULT_ENCRYPT) );
; 154  : 		//memcpy( &value, szTempMem, m_ValueSize );
; 155  : 		//UJ --end
; 156  : 
; 157  : #ifdef _NOTUSE
; 158  : 		Debug();
; 159  : #endif
; 160  : 		return value;

  0000d	8a 45 ff	 mov	 al, BYTE PTR _value$[ebp]

; 161  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@_N@@QBE_NXZ ENDP				; CEncrypt<bool>::operator bool
_TEXT	ENDS
PUBLIC	?SetGravityAmt@ioBaseChar@@QAEXM@Z		; ioBaseChar::SetGravityAmt
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasechar.h
;	COMDAT ?SetGravityAmt@ioBaseChar@@QAEXM@Z
_TEXT	SEGMENT
_value$524961 = 8					; size = 4
_fAmt$ = 8						; size = 4
?SetGravityAmt@ioBaseChar@@QAEXM@Z PROC			; ioBaseChar::SetGravityAmt, COMDAT
; _this$ = ecx

; 2631 : 	inline void SetGravityAmt( float fAmt ) { m_fGravityAmt = fAmt; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fAmt$[ebp]
  00008	8d 45 08	 lea	 eax, DWORD PTR _value$524961[ebp]
  0000b	50		 push	 eax
  0000c	81 c1 e8 0b 00
	00		 add	 ecx, 3048		; 00000be8H
  00012	f3 0f 11 45 08	 movss	 DWORD PTR _value$524961[ebp], xmm0
  00017	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?SetGravityAmt@ioBaseChar@@QAEXM@Z ENDP			; ioBaseChar::SetGravityAmt
_TEXT	ENDS
PUBLIC	__real@4f800000
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp_??4ioHashString@@QAEAAV0@PBD@Z:PROC
EXTRN	?LoadProperty@ioAttackSkill@@UAEXAAVioINILoader@@@Z:PROC ; ioAttackSkill::LoadProperty
EXTRN	_memset:PROC
;	COMDAT __real@4f800000
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stringprotect.h
CONST	SEGMENT
__real@4f800000 DD 04f800000r			; 4.29497e+009
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iodefenseattackskill.cpp
CONST	ENDS
;	COMDAT ?LoadProperty@ioDefenseAttackSkill@@UAEXAAVioINILoader@@@Z
_TEXT	SEGMENT
tv2004 = -296						; size = 4
_szBuf$ = -292						; size = 260
__k$525141 = -32					; size = 22
__k$524993 = -28					; size = 17
__$ArrayPad$ = -4					; size = 4
_rkLoader$ = 8						; size = 4
?LoadProperty@ioDefenseAttackSkill@@UAEXAAVioINILoader@@@Z PROC ; ioDefenseAttackSkill::LoadProperty, COMDAT
; _this$ = ecx

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 28 01 00
	00		 sub	 esp, 296		; 00000128H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _rkLoader$[ebp]

; 29   : 	ioAttackSkill::LoadProperty( rkLoader );

  00018	57		 push	 edi
  00019	8b f1		 mov	 esi, ecx
  0001b	e8 00 00 00 00	 call	 ?LoadProperty@ioAttackSkill@@UAEXAAVioINILoader@@@Z ; ioAttackSkill::LoadProperty

; 30   : 
; 31   : 	char szBuf[MAX_PATH] = "";

  00020	68 03 01 00 00	 push	 259			; 00000103H
  00025	8d 85 dd fe ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp+1]
  0002b	6a 00		 push	 0
  0002d	50		 push	 eax
  0002e	c6 85 dc fe ff
	ff 00		 mov	 BYTE PTR _szBuf$[ebp], 0
  00035	e8 00 00 00 00	 call	 _memset
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 32   : 
; 33   : 	rkLoader.LoadString_e( "defense_loop_ani", "", szBuf, MAX_PATH );

  0003d	6a 04		 push	 4
  0003f	c7 45 e4 89 89
	8d 8f		 mov	 DWORD PTR __k$524993[ebp], -1886549623 ; 8f8d8989H
  00046	c7 45 e8 83 9f
	8e b5		 mov	 DWORD PTR __k$524993[ebp+4], -1248944253 ; b58e9f83H
  0004d	c7 45 ec 81 83
	84 9a		 mov	 DWORD PTR __k$524993[ebp+8], -1702591615 ; 9a848381H
  00054	c7 45 f0 b2 8d
	85 83		 mov	 DWORD PTR __k$524993[ebp+12], -2088399438 ; 83858db2H
  0005b	8d 45 e4	 lea	 eax, DWORD PTR __k$524993[ebp]
  0005e	c6 45 f4 00	 mov	 BYTE PTR __k$524993[ebp+16], 0
  00062	59		 pop	 ecx
$LL106@LoadProper:
  00063	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00069	83 c0 04	 add	 eax, 4
  0006c	49		 dec	 ecx
  0006d	75 f4		 jne	 SHORT $LL106@LoadProper
  0006f	68 04 01 00 00	 push	 260			; 00000104H
  00074	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  0007a	50		 push	 eax
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00080	8d 45 e4	 lea	 eax, DWORD PTR __k$524993[ebp]
  00083	50		 push	 eax
  00084	8b cf		 mov	 ecx, edi
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 34   : 	m_DefenseLoopAni = szBuf;

  0008c	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  00092	50		 push	 eax
  00093	8d 8e e8 10 00
	00		 lea	 ecx, DWORD PTR [esi+4328]
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 35   : 	m_fDefenseLoopAniRate = rkLoader.LoadFloat_e( "defense_loop_ani_rate", FLOAT1 );

  0009f	b8 01 00 00 00	 mov	 eax, 1
  000a4	6a 05		 push	 5
  000a6	c7 45 e0 89 89
	8d 8f		 mov	 DWORD PTR __k$525141[ebp], -1886549623 ; 8f8d8989H
  000ad	c7 45 e4 83 9f
	8e b5		 mov	 DWORD PTR __k$525141[ebp+4], -1248944253 ; b58e9f83H
  000b4	c7 45 e8 81 83
	84 9a		 mov	 DWORD PTR __k$525141[ebp+8], -1702591615 ; 9a848381H
  000bb	c7 45 ec b2 8d
	85 83		 mov	 DWORD PTR __k$525141[ebp+12], -2088399438 ; 83858db2H
  000c2	c7 45 f0 b2 9e
	8a 9e		 mov	 DWORD PTR __k$525141[ebp+16], -1635082574 ; 9e8a9eb2H
  000c9	8d 4d e0	 lea	 ecx, DWORD PTR __k$525141[ebp]
  000cc	66 c7 45 f4 88
	00		 mov	 WORD PTR __k$525141[ebp+20], 136 ; 00000088H
  000d2	5a		 pop	 edx
$LL214@LoadProper:
  000d3	81 31 ed ec eb
	ea		 xor	 DWORD PTR [ecx], -353637139 ; eaebecedH
  000d9	83 c1 04	 add	 ecx, 4
  000dc	4a		 dec	 edx
  000dd	75 f4		 jne	 SHORT $LL214@LoadProper
  000df	80 75 f4 ed	 xor	 BYTE PTR __k$525141[ebp+20], -19 ; ffffffedH
  000e3	89 85 d8 fe ff
	ff		 mov	 DWORD PTR tv2004[ebp], eax
  000e9	db 85 d8 fe ff
	ff		 fild	 DWORD PTR tv2004[ebp]
  000ef	85 c0		 test	 eax, eax
  000f1	79 06		 jns	 SHORT $LN225@LoadProper
  000f3	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN225@LoadProper:
  000f9	51		 push	 ecx
  000fa	8d 45 e0	 lea	 eax, DWORD PTR __k$525141[ebp]
  000fd	d9 1c 24	 fstp	 DWORD PTR [esp]
  00100	50		 push	 eax
  00101	8b cf		 mov	 ecx, edi
  00103	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadFloat@ioINILoader@@QAEMPBDM@Z
  00109	d9 9e f8 10 00
	00		 fstp	 DWORD PTR [esi+4344]

; 36   : }

  0010f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00112	5f		 pop	 edi
  00113	33 cd		 xor	 ecx, ebp
  00115	5e		 pop	 esi
  00116	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011b	c9		 leave
  0011c	c2 04 00	 ret	 4
?LoadProperty@ioDefenseAttackSkill@@UAEXAAVioINILoader@@@Z ENDP ; ioDefenseAttackSkill::LoadProperty
_TEXT	ENDS
PUBLIC	__real@41f0000000000000
PUBLIC	?SetDefenseLoopState@ioDefenseAttackSkill@@IAEXPAVioBaseChar@@@Z ; ioDefenseAttackSkill::SetDefenseLoopState
EXTRN	?ReduceNeedGaugeBySkill@ioBaseChar@@QAEMPAVioSkill@@M@Z:PROC ; ioBaseChar::ReduceNeedGaugeBySkill
EXTRN	?GetNeedGauge@ioSkill@@QAEMABVioHashString@@@Z:PROC ; ioSkill::GetNeedGauge
EXTRN	?ChangeSkillWeaponMesh@ioBaseChar@@QAE_NPAVioSkill@@ABVioHashString@@_N@Z:PROC ; ioBaseChar::ChangeSkillWeaponMesh
EXTRN	__imp_?GetAnimationFullTime@ioEntityGroup@@QAEMH@Z:PROC
EXTRN	__imp_?SetActionAni@ioEntityGroup@@QAE_NHMMMMMM_N0@Z:PROC
EXTRN	__imp_?ClearAllLoopAni@ioEntityGroup@@QAEXM_N@Z:PROC
EXTRN	__imp_?ClearAllActionAni@ioEntityGroup@@QAEXM_N@Z:PROC
EXTRN	__imp_?GetAnimationIdx@ioEntityGroup@@QAEHABVioHashString@@@Z:PROC
EXTRN	__ftol2:PROC
;	COMDAT __real@41f0000000000000
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasechar.h
CONST	SEGMENT
__real@41f0000000000000 DQ 041f0000000000000r	; 4.29497e+009
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iodefenseattackskill.cpp
CONST	ENDS
;	COMDAT ?SetDefenseLoopState@ioDefenseAttackSkill@@IAEXPAVioBaseChar@@@Z
_TEXT	SEGMENT
tv206 = -20						; size = 4
tv337 = -16						; size = 4
tv332 = -16						; size = 4
tv326 = -16						; size = 4
tv309 = -16						; size = 4
tv307 = -16						; size = 4
_value$525268 = -16					; size = 4
$T525261 = -16						; size = 4
tv317 = -12						; size = 4
tv314 = -12						; size = 4
tv312 = -12						; size = 4
_iAniID$ = -8						; size = 4
_fTimeRate$ = -4					; size = 4
_pChar$ = 8						; size = 4
?SetDefenseLoopState@ioDefenseAttackSkill@@IAEXPAVioBaseChar@@@Z PROC ; ioDefenseAttackSkill::SetDefenseLoopState, COMDAT
; _this$ = ecx

; 171  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 172  : 	if( !pChar ) return;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pChar$[ebp]
  00006	83 ec 14	 sub	 esp, 20			; 00000014H
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	85 c0		 test	 eax, eax
  0000e	0f 84 e6 01 00
	00		 je	 $LN1@SetDefense@2

; 173  : 
; 174  : 	ioEntityGroup *pGrp = pChar->GetGroup();

  00014	57		 push	 edi
  00015	8b 78 04	 mov	 edi, DWORD PTR [eax+4]

; 175  : 	int iAniID = pGrp->GetAnimationIdx( m_DefenseLoopAni );

  00018	8d 86 e8 10 00
	00		 lea	 eax, DWORD PTR [esi+4328]
  0001e	50		 push	 eax
  0001f	8b cf		 mov	 ecx, edi
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetAnimationIdx@ioEntityGroup@@QAEHABVioHashString@@@Z

; 176  : 	float fTimeRate = m_fDefenseLoopAniRate;

  00027	f3 0f 10 86 f8
	10 00 00	 movss	 xmm0, DWORD PTR [esi+4344]

; 177  : 	if( fTimeRate <= 0.0f )

  0002f	0f 57 c9	 xorps	 xmm1, xmm1
  00032	0f 2f c8	 comiss	 xmm1, xmm0
  00035	89 45 f8	 mov	 DWORD PTR _iAniID$[ebp], eax
  00038	f3 0f 11 45 fc	 movss	 DWORD PTR _fTimeRate$[ebp], xmm0
  0003d	72 18		 jb	 SHORT $LN3@SetDefense@2

; 178  : 		fTimeRate = FLOAT1;

  0003f	b8 01 00 00 00	 mov	 eax, 1
  00044	89 45 f0	 mov	 DWORD PTR tv337[ebp], eax
  00047	db 45 f0	 fild	 DWORD PTR tv337[ebp]
  0004a	85 c0		 test	 eax, eax
  0004c	79 06		 jns	 SHORT $LN30@SetDefense@2
  0004e	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN30@SetDefense@2:
  00054	d9 5d fc	 fstp	 DWORD PTR _fTimeRate$[ebp]
$LN3@SetDefense@2:
  00057	53		 push	 ebx

; 179  : 
; 180  : 	pGrp->ClearAllActionAni( FLOAT100, true );

  00058	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  0005d	33 db		 xor	 ebx, ebx
  0005f	43		 inc	 ebx
  00060	89 45 f0	 mov	 DWORD PTR tv332[ebp], eax
  00063	db 45 f0	 fild	 DWORD PTR tv332[ebp]
  00066	53		 push	 ebx
  00067	85 c0		 test	 eax, eax
  00069	79 06		 jns	 SHORT $LN31@SetDefense@2
  0006b	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN31@SetDefense@2:
  00071	51		 push	 ecx
  00072	8b cf		 mov	 ecx, edi
  00074	d9 1c 24	 fstp	 DWORD PTR [esp]
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ClearAllActionAni@ioEntityGroup@@QAEXM_N@Z

; 181  : 	pGrp->ClearAllLoopAni( FLOAT100, true );

  0007d	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  00082	89 45 f0	 mov	 DWORD PTR tv326[ebp], eax
  00085	db 45 f0	 fild	 DWORD PTR tv326[ebp]
  00088	53		 push	 ebx
  00089	85 c0		 test	 eax, eax
  0008b	79 06		 jns	 SHORT $LN32@SetDefense@2
  0008d	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN32@SetDefense@2:
  00093	51		 push	 ecx
  00094	8b cf		 mov	 ecx, edi
  00096	d9 1c 24	 fstp	 DWORD PTR [esp]
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ClearAllLoopAni@ioEntityGroup@@QAEXM_N@Z

; 182  : 
; 183  : 	pGrp->SetActionAni( iAniID, FLOAT100, FLOAT100, FLOAT1, FLOAT1/fTimeRate, 0.0f, 0.0f, true );

  0009f	b8 01 00 00 00	 mov	 eax, 1
  000a4	8b c8		 mov	 ecx, eax
  000a6	b8 01 00 00 00	 mov	 eax, 1
  000ab	8b d0		 mov	 edx, eax
  000ad	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  000b2	89 45 f0	 mov	 DWORD PTR $T525261[ebp], eax
  000b5	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  000ba	0f 57 c0	 xorps	 xmm0, xmm0
  000bd	53		 push	 ebx
  000be	53		 push	 ebx
  000bf	83 ec 18	 sub	 esp, 24			; 00000018H
  000c2	89 4d f4	 mov	 DWORD PTR tv317[ebp], ecx
  000c5	db 45 f4	 fild	 DWORD PTR tv317[ebp]
  000c8	f3 0f 11 44 24
	14		 movss	 DWORD PTR [esp+20], xmm0
  000ce	f3 0f 11 44 24
	10		 movss	 DWORD PTR [esp+16], xmm0
  000d4	85 c9		 test	 ecx, ecx
  000d6	79 06		 jns	 SHORT $LN33@SetDefense@2
  000d8	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN33@SetDefense@2:
  000de	d8 75 fc	 fdiv	 DWORD PTR _fTimeRate$[ebp]
  000e1	d9 5d f4	 fstp	 DWORD PTR tv314[ebp]
  000e4	d9 45 f4	 fld	 DWORD PTR tv314[ebp]
  000e7	d9 5c 24 0c	 fstp	 DWORD PTR [esp+12]
  000eb	89 55 f4	 mov	 DWORD PTR tv312[ebp], edx
  000ee	db 45 f4	 fild	 DWORD PTR tv312[ebp]
  000f1	85 d2		 test	 edx, edx
  000f3	79 06		 jns	 SHORT $LN34@SetDefense@2
  000f5	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN34@SetDefense@2:
  000fb	8b 4d f0	 mov	 ecx, DWORD PTR $T525261[ebp]
  000fe	d9 5c 24 08	 fstp	 DWORD PTR [esp+8]
  00102	db 45 f0	 fild	 DWORD PTR $T525261[ebp]
  00105	85 c9		 test	 ecx, ecx
  00107	79 06		 jns	 SHORT $LN35@SetDefense@2
  00109	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN35@SetDefense@2:
  0010f	d9 5c 24 04	 fstp	 DWORD PTR [esp+4]
  00113	89 45 f0	 mov	 DWORD PTR tv307[ebp], eax
  00116	db 45 f0	 fild	 DWORD PTR tv307[ebp]
  00119	85 c0		 test	 eax, eax
  0011b	79 06		 jns	 SHORT $LN36@SetDefense@2
  0011d	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN36@SetDefense@2:
  00123	d9 1c 24	 fstp	 DWORD PTR [esp]
  00126	ff 75 f8	 push	 DWORD PTR _iAniID$[ebp]
  00129	8b cf		 mov	 ecx, edi
  0012b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetActionAni@ioEntityGroup@@QAE_NHMMMMMM_N0@Z

; 184  : 
; 185  : 	m_dwMotionStartTime = m_dwMotionEndTime = FRAMEGETTIME();

  00131	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  00137	8b c8		 mov	 ecx, eax
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ
  0013f	89 86 d8 02 00
	00		 mov	 DWORD PTR [esi+728], eax
  00145	89 45 f0	 mov	 DWORD PTR _value$525268[ebp], eax
  00148	8d 45 f0	 lea	 eax, DWORD PTR _value$525268[ebp]
  0014b	50		 push	 eax
  0014c	8d 8e a8 02 00
	00		 lea	 ecx, DWORD PTR [esi+680]
  00152	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z ; CEncrypt<unsigned long>::EncryptValueToPool

; 186  : 	m_dwMotionEndTime += pGrp->GetAnimationFullTime( iAniID ) * fTimeRate;

  00157	ff 75 f8	 push	 DWORD PTR _iAniID$[ebp]
  0015a	8b cf		 mov	 ecx, edi
  0015c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetAnimationFullTime@ioEntityGroup@@QAEMH@Z
  00162	d8 4d fc	 fmul	 DWORD PTR _fTimeRate$[ebp]
  00165	8b 86 d8 02 00
	00		 mov	 eax, DWORD PTR [esi+728]
  0016b	db 86 d8 02 00
	00		 fild	 DWORD PTR [esi+728]
  00171	85 c0		 test	 eax, eax
  00173	79 06		 jns	 SHORT $LN37@SetDefense@2
  00175	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$LN37@SetDefense@2:
  0017b	de c1		 faddp	 ST(1), ST(0)
  0017d	e8 00 00 00 00	 call	 __ftol2

; 187  : 
; 188  : 	m_SkillState = SS_LOOP;
; 189  : 
; 190  : 	if( !m_bSetHandMesh && m_bUseItemMesh && !m_HandMesh.IsEmpty() )

  00182	80 be 0a 0f 00
	00 00		 cmp	 BYTE PTR [esi+3850], 0
  00189	89 86 d8 02 00
	00		 mov	 DWORD PTR [esi+728], eax
  0018f	89 9e e4 10 00
	00		 mov	 DWORD PTR [esi+4324], ebx
  00195	75 33		 jne	 SHORT $LN27@SetDefense@2
  00197	80 be 08 0f 00
	00 00		 cmp	 BYTE PTR [esi+3848], 0
  0019e	74 2a		 je	 SHORT $LN27@SetDefense@2
  001a0	8d be f8 0e 00
	00		 lea	 edi, DWORD PTR [esi+3832]
  001a6	8b cf		 mov	 ecx, edi
  001a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  001ae	84 c0		 test	 al, al
  001b0	75 18		 jne	 SHORT $LN27@SetDefense@2

; 191  : 	{
; 192  : 		pChar->ChangeSkillWeaponMesh( this, m_HandMesh, m_bVisibleEquipMesh );

  001b2	0f b6 86 09 0f
	00 00		 movzx	 eax, BYTE PTR [esi+3849]
  001b9	8b 4d 08	 mov	 ecx, DWORD PTR _pChar$[ebp]
  001bc	50		 push	 eax
  001bd	57		 push	 edi
  001be	56		 push	 esi
  001bf	e8 00 00 00 00	 call	 ?ChangeSkillWeaponMesh@ioBaseChar@@QAE_NPAVioSkill@@ABVioHashString@@_N@Z ; ioBaseChar::ChangeSkillWeaponMesh

; 193  : 		m_bSetHandMesh = true;

  001c4	88 9e 0a 0f 00
	00		 mov	 BYTE PTR [esi+3850], bl
$LN27@SetDefense@2:

; 194  : 	}
; 195  : 
; 196  : 	if( !m_bReduceGauge )

  001ca	80 be 50 03 00
	00 00		 cmp	 BYTE PTR [esi+848], 0
  001d1	75 25		 jne	 SHORT $LN29@SetDefense@2

; 197  : 	{
; 198  : 		pChar->ReduceNeedGaugeBySkill( this, GetNeedGauge(pChar->GetCharName()) );

  001d3	8b 7d 08	 mov	 edi, DWORD PTR _pChar$[ebp]
  001d6	8d 87 d4 02 00
	00		 lea	 eax, DWORD PTR [edi+724]
  001dc	50		 push	 eax
  001dd	8b ce		 mov	 ecx, esi
  001df	e8 00 00 00 00	 call	 ?GetNeedGauge@ioSkill@@QAEMABVioHashString@@@Z ; ioSkill::GetNeedGauge
  001e4	51		 push	 ecx
  001e5	d9 1c 24	 fstp	 DWORD PTR [esp]
  001e8	56		 push	 esi
  001e9	8b cf		 mov	 ecx, edi
  001eb	e8 00 00 00 00	 call	 ?ReduceNeedGaugeBySkill@ioBaseChar@@QAEMPAVioSkill@@M@Z ; ioBaseChar::ReduceNeedGaugeBySkill
  001f0	dd d8		 fstp	 ST(0)

; 199  : 		m_bReduceGauge = true;

  001f2	88 9e 50 03 00
	00		 mov	 BYTE PTR [esi+848], bl
$LN29@SetDefense@2:
  001f8	5b		 pop	 ebx
  001f9	5f		 pop	 edi
$LN1@SetDefense@2:
  001fa	5e		 pop	 esi

; 200  : 	}
; 201  : }

  001fb	c9		 leave
  001fc	c2 04 00	 ret	 4
?SetDefenseLoopState@ioDefenseAttackSkill@@IAEXPAVioBaseChar@@@Z ENDP ; ioDefenseAttackSkill::SetDefenseLoopState
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?IsProtected@ioDefenseAttackSkill@@UBE_NH@Z
_TEXT	SEGMENT
_value$525294 = -1					; size = 1
_iDefenseBreakType$ = 8					; size = 4
?IsProtected@ioDefenseAttackSkill@@UBE_NH@Z PROC	; ioDefenseAttackSkill::IsProtected, COMDAT
; _this$ = ecx

; 242  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 243  : 	if( m_bDisableSkillProtect )

  00007	8d 45 ff	 lea	 eax, DWORD PTR _value$525294[ebp]
  0000a	50		 push	 eax
  0000b	8d 8e a8 00 00
	00		 lea	 ecx, DWORD PTR [esi+168]
  00011	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  00016	80 7d ff 00	 cmp	 BYTE PTR _value$525294[ebp], 0
  0001a	74 04		 je	 SHORT $LN10@IsProtecte
$LN16@IsProtecte:

; 244  : 		return false;

  0001c	32 c0		 xor	 al, al
  0001e	eb 55		 jmp	 SHORT $LN11@IsProtecte
$LN10@IsProtecte:

; 245  : 
; 246  : 	if( DBT_NONE != (DefenseBreakType)m_ProtectCancelType )

  00020	8b 86 a4 00 00
	00		 mov	 eax, DWORD PTR [esi+164]
  00026	85 c0		 test	 eax, eax
  00028	74 05		 je	 SHORT $LN8@IsProtecte

; 247  : 	{
; 248  : 		if( iDefenseBreakType == m_ProtectCancelType )   //   

  0002a	39 45 08	 cmp	 DWORD PTR _iDefenseBreakType$[ebp], eax

; 249  : 			return false;

  0002d	74 ed		 je	 SHORT $LN16@IsProtecte
$LN8@IsProtecte:
  0002f	57		 push	 edi

; 250  : 	}
; 251  : 
; 252  : 	DWORD dwCurTime = FRAMEGETTIME();

  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  00036	8b c8		 mov	 ecx, eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ
  0003e	8b f8		 mov	 edi, eax

; 253  : 
; 254  : 	if( IsPreDelayProtect() )

  00040	8b 06		 mov	 eax, DWORD PTR [esi]
  00042	8b ce		 mov	 ecx, esi
  00044	ff 90 2c 01 00
	00		 call	 DWORD PTR [eax+300]
  0004a	84 c0		 test	 al, al
  0004c	74 0d		 je	 SHORT $LN6@IsProtecte

; 255  : 	{
; 256  : 		if( m_dwPreDelayStartTime != 0 )

  0004e	83 be 20 02 00
	00 00		 cmp	 DWORD PTR [esi+544], 0
  00055	74 04		 je	 SHORT $LN6@IsProtecte

; 257  : 			return true;

  00057	b0 01		 mov	 al, 1
  00059	eb 19		 jmp	 SHORT $LN15@IsProtecte
$LN6@IsProtecte:

; 258  : 	}
; 259  : 
; 260  : 	switch( m_SkillState )

  0005b	8b 86 e4 10 00
	00		 mov	 eax, DWORD PTR [esi+4324]
  00061	48		 dec	 eax
  00062	74 0e		 je	 SHORT $LN3@IsProtecte
  00064	48		 dec	 eax

; 269  : 	}
; 270  : 
; 271  : 	return false;

  00065	75 0b		 jne	 SHORT $LN3@IsProtecte

; 264  : 	case SS_FIRE:
; 265  : 		if( m_dwFireMotionEndTime > dwCurTime )

  00067	39 be 24 02 00
	00		 cmp	 DWORD PTR [esi+548], edi
  0006d	0f 97 c0	 seta	 al

; 266  : 			return true;
; 267  : 
; 268  : 		return false;

  00070	eb 02		 jmp	 SHORT $LN15@IsProtecte
$LN3@IsProtecte:

; 261  : 	{
; 262  : 	case SS_LOOP:
; 263  : 		return false;

  00072	32 c0		 xor	 al, al
$LN15@IsProtecte:
  00074	5f		 pop	 edi
$LN11@IsProtecte:
  00075	5e		 pop	 esi

; 272  : }

  00076	c9		 leave
  00077	c2 04 00	 ret	 4
?IsProtected@ioDefenseAttackSkill@@UBE_NH@Z ENDP	; ioDefenseAttackSkill::IsProtected
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?OnProcessState@ioDefenseAttackSkill@@UAEXPAVioBaseChar@@PAVioPlayStage@@@Z
_TEXT	SEGMENT
_pChar$ = 8						; size = 4
_pStage$ = 12						; size = 4
?OnProcessState@ioDefenseAttackSkill@@UAEXPAVioBaseChar@@PAVioPlayStage@@@Z PROC ; ioDefenseAttackSkill::OnProcessState, COMDAT
; _this$ = ecx

; 275  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f1		 mov	 esi, ecx

; 276  : 	DWORD dwCurTime = FRAMEGETTIME();

  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  0000d	8b c8		 mov	 ecx, eax
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ

; 277  : 
; 278  : 	switch( m_SkillState )

  00015	83 be e4 10 00
	00 00		 cmp	 DWORD PTR [esi+4324], 0
  0001c	8b f8		 mov	 edi, eax
  0001e	75 34		 jne	 SHORT $LN3@OnProcessS

; 279  : 	{
; 280  : 	case SS_NONE:
; 281  : 		{
; 282  : 			DWORD dwPreDelay = GetPreDelayTime();

  00020	8b 06		 mov	 eax, DWORD PTR [esi]
  00022	8b ce		 mov	 ecx, esi
  00024	ff 90 34 01 00
	00		 call	 DWORD PTR [eax+308]

; 283  : 			if( m_dwPreDelayStartTime + dwPreDelay < dwCurTime )

  0002a	8b 96 20 02 00
	00		 mov	 edx, DWORD PTR [esi+544]
  00030	03 d0		 add	 edx, eax
  00032	3b d7		 cmp	 edx, edi
  00034	73 1e		 jae	 SHORT $LN3@OnProcessS

; 284  : 			{
; 285  : 				m_dwPreDelayStartTime = 0;
; 286  : 				EndPreDelayEffect( pChar );

  00036	ff 75 08	 push	 DWORD PTR _pChar$[ebp]
  00039	8b 06		 mov	 eax, DWORD PTR [esi]
  0003b	83 a6 20 02 00
	00 00		 and	 DWORD PTR [esi+544], 0
  00042	8b ce		 mov	 ecx, esi
  00044	ff 90 dc 00 00
	00		 call	 DWORD PTR [eax+220]

; 287  : 
; 288  : 				SetDefenseLoopState( pChar );

  0004a	ff 75 08	 push	 DWORD PTR _pChar$[ebp]
  0004d	8b ce		 mov	 ecx, esi
  0004f	e8 00 00 00 00	 call	 ?SetDefenseLoopState@ioDefenseAttackSkill@@IAEXPAVioBaseChar@@@Z ; ioDefenseAttackSkill::SetDefenseLoopState
$LN3@OnProcessS:
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi

; 289  : 			}
; 290  : 		}
; 291  : 		break;
; 292  : 	case SS_LOOP:
; 293  : 		break;
; 294  : 	case SS_FIRE:
; 295  : 		break;
; 296  : 	}
; 297  : }

  00056	5d		 pop	 ebp
  00057	c2 08 00	 ret	 8
?OnProcessState@ioDefenseAttackSkill@@UAEXPAVioBaseChar@@PAVioPlayStage@@@Z ENDP ; ioDefenseAttackSkill::OnProcessState
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioskill.h
_TEXT	ENDS
;	COMDAT ?IsCanJumpingSkill@ioSkill@@UBE_NXZ
_TEXT	SEGMENT
_value$525305 = -1					; size = 1
?IsCanJumpingSkill@ioSkill@@UBE_NXZ PROC		; ioSkill::IsCanJumpingSkill, COMDAT
; _this$ = ecx

; 431  : 	virtual bool IsCanJumpingSkill() const { return m_bEnableJumpingSkill; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 ff	 lea	 eax, DWORD PTR _value$525305[ebp]
  00007	50		 push	 eax
  00008	81 c1 9c 03 00
	00		 add	 ecx, 924		; 0000039cH
  0000e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  00013	8a 45 ff	 mov	 al, BYTE PTR _value$525305[ebp]
  00016	c9		 leave
  00017	c3		 ret	 0
?IsCanJumpingSkill@ioSkill@@UBE_NXZ ENDP		; ioSkill::IsCanJumpingSkill
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?IsCanJumpingSkillOnBlowWound@ioSkill@@UBE_NXZ
_TEXT	SEGMENT
_value$525312 = -1					; size = 1
?IsCanJumpingSkillOnBlowWound@ioSkill@@UBE_NXZ PROC	; ioSkill::IsCanJumpingSkillOnBlowWound, COMDAT
; _this$ = ecx

; 432  : 	virtual bool IsCanJumpingSkillOnBlowWound() const { return m_bEnableJumpingSkillOnBlowWound; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 ff	 lea	 eax, DWORD PTR _value$525312[ebp]
  00007	50		 push	 eax
  00008	81 c1 cc 03 00
	00		 add	 ecx, 972		; 000003ccH
  0000e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  00013	8a 45 ff	 mov	 al, BYTE PTR _value$525312[ebp]
  00016	c9		 leave
  00017	c3		 ret	 0
?IsCanJumpingSkillOnBlowWound@ioSkill@@UBE_NXZ ENDP	; ioSkill::IsCanJumpingSkillOnBlowWound
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?IsCanDownSkill@ioSkill@@UBE_NXZ
_TEXT	SEGMENT
_value$525320 = -1					; size = 1
?IsCanDownSkill@ioSkill@@UBE_NXZ PROC			; ioSkill::IsCanDownSkill, COMDAT
; _this$ = ecx

; 437  : 	virtual bool IsCanDownSkill() const { return m_bEnableDownSkill; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 ff	 lea	 eax, DWORD PTR _value$525320[ebp]
  00007	50		 push	 eax
  00008	81 c1 5c 04 00
	00		 add	 ecx, 1116		; 0000045cH
  0000e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  00013	8a 45 ff	 mov	 al, BYTE PTR _value$525320[ebp]
  00016	c9		 leave
  00017	c3		 ret	 0
?IsCanDownSkill@ioSkill@@UBE_NXZ ENDP			; ioSkill::IsCanDownSkill
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?IsCanBlowWoundSkill@ioSkill@@UBE_NXZ
_TEXT	SEGMENT
_value$525327 = -1					; size = 1
?IsCanBlowWoundSkill@ioSkill@@UBE_NXZ PROC		; ioSkill::IsCanBlowWoundSkill, COMDAT
; _this$ = ecx

; 440  : 	virtual bool IsCanBlowWoundSkill() const { return m_bEnableBlowWoundSkill; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 ff	 lea	 eax, DWORD PTR _value$525327[ebp]
  00007	50		 push	 eax
  00008	81 c1 8c 04 00
	00		 add	 ecx, 1164		; 0000048cH
  0000e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  00013	8a 45 ff	 mov	 al, BYTE PTR _value$525327[ebp]
  00016	c9		 leave
  00017	c3		 ret	 0
?IsCanBlowWoundSkill@ioSkill@@UBE_NXZ ENDP		; ioSkill::IsCanBlowWoundSkill
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?IsCanWoundSkill@ioSkill@@UBE_NXZ
_TEXT	SEGMENT
_value$525334 = -1					; size = 1
?IsCanWoundSkill@ioSkill@@UBE_NXZ PROC			; ioSkill::IsCanWoundSkill, COMDAT
; _this$ = ecx

; 446  : 	virtual bool IsCanWoundSkill() const { return m_bEnableWoundSkill; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 ff	 lea	 eax, DWORD PTR _value$525334[ebp]
  00007	50		 push	 eax
  00008	81 c1 54 05 00
	00		 add	 ecx, 1364		; 00000554H
  0000e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  00013	8a 45 ff	 mov	 al, BYTE PTR _value$525334[ebp]
  00016	c9		 leave
  00017	c3		 ret	 0
?IsCanWoundSkill@ioSkill@@UBE_NXZ ENDP			; ioSkill::IsCanWoundSkill
_TEXT	ENDS
PUBLIC	_pChar$GSCopy$
EXTRN	?SetSkillNameChatBubble@ioSkill@@IAEXPAVioBaseChar@@@Z:PROC ; ioSkill::SetSkillNameChatBubble
EXTRN	?CheckSkillDesc@ioSkill@@IAEXPAVioBaseChar@@@Z:PROC ; ioSkill::CheckSkillDesc
EXTRN	?SetAutoTargetTrackingEndTime@ioBaseChar@@QAEXK@Z:PROC ; ioBaseChar::SetAutoTargetTrackingEndTime
EXTRN	?SetAutoTarget@ioBaseChar@@QAEXW4AutoTargetType@@@Z:PROC ; ioBaseChar::SetAutoTarget
EXTRN	?IncreaseWeaponIndexBase@ioBaseChar@@QAEKXZ:PROC ; ioBaseChar::IncreaseWeaponIndexBase
EXTRN	?InitExtraAniJump@ioSkill@@IAEXXZ:PROC		; ioSkill::InitExtraAniJump
EXTRN	?SetSkillProtection@ioBaseChar@@QAEXXZ:PROC	; ioBaseChar::SetSkillProtection
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
xdata$x	SEGMENT
__unwindtable$?OnSkillStart@ioDefenseAttackSkill@@UAE_NPAVioBaseChar@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnSkillStart@ioDefenseAttackSkill@@UAE_NPAVioBaseChar@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?OnSkillStart@ioDefenseAttackSkill@@UAE_NPAVioBaseChar@@@Z$1
__ehfuncinfo$?OnSkillStart@ioDefenseAttackSkill@@UAE_NPAVioBaseChar@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?OnSkillStart@ioDefenseAttackSkill@@UAE_NPAVioBaseChar@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iodefenseattackskill.cpp
xdata$x	ENDS
;	COMDAT ?OnSkillStart@ioDefenseAttackSkill@@UAE_NPAVioBaseChar@@@Z
_TEXT	SEGMENT
_szPreDelay$523816 = -80				; size = 16
$T525367 = -64						; size = 16
_value$525342 = -48					; size = 4
_pGrp$523814 = -48					; size = 4
_value$525480 = -41					; size = 1
_value$525492 = -40					; size = 4
$T525366 = -40						; size = 4
_dwPreDelay$523824 = -40				; size = 4
_iAniID$523817 = -40					; size = 4
_pChar$GSCopy$ = -36					; size = 4
_szEncEventType$525370 = -32				; size = 11
__$EHRec$ = -12						; size = 12
_pChar$ = 8						; size = 4
?OnSkillStart@ioDefenseAttackSkill@@UAE_NPAVioBaseChar@@@Z PROC ; ioDefenseAttackSkill::OnSkillStart, COMDAT
; _this$ = ecx

; 44   : {

  00000	6a 44		 push	 68			; 00000044H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?OnSkillStart@ioDefenseAttackSkill@@UAE_NPAVioBaseChar@@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000c	8b 7d 08	 mov	 edi, DWORD PTR _pChar$[ebp]
  0000f	8b f1		 mov	 esi, ecx

; 45   : 	if( !HasSkillMotion() )

  00011	8b 06		 mov	 eax, DWORD PTR [esi]

; 64   : 		m_dwEnableSwitchTime = FRAMEGETTIME() + m_dwSwitchSkill;

  00013	89 7d dc	 mov	 DWORD PTR _pChar$GSCopy$[ebp], edi
  00016	ff 90 24 01 00
	00		 call	 DWORD PTR [eax+292]
  0001c	84 c0		 test	 al, al
  0001e	0f 84 49 02 00
	00		 je	 $LN13@OnSkillSta
$LN12@OnSkillSta:

; 46   : 		return false;
; 47   : 
; 48   : 	pChar->SetSkillProtection();

  00024	8b cf		 mov	 ecx, edi
  00026	e8 00 00 00 00	 call	 ?SetSkillProtection@ioBaseChar@@QAEXXZ ; ioBaseChar::SetSkillProtection

; 49   : 
; 50   : 	m_bReduceGauge = false;

  0002b	33 db		 xor	 ebx, ebx

; 51   : 	m_dwAttackEndTime = 0;
; 52   : 
; 53   : 	InitExtraAniJump();

  0002d	8b ce		 mov	 ecx, esi
  0002f	88 9e 50 03 00
	00		 mov	 BYTE PTR [esi+848], bl
  00035	89 9e 50 10 00
	00		 mov	 DWORD PTR [esi+4176], ebx
  0003b	e8 00 00 00 00	 call	 ?InitExtraAniJump@ioSkill@@IAEXXZ ; ioSkill::InitExtraAniJump

; 54   : 
; 55   : 	m_dwAniRotateTime = 0;
; 56   : 	m_fAniRotateAngle = 0.0f;

  00040	0f 57 c0	 xorps	 xmm0, xmm0
  00043	89 9e 2c 07 00
	00		 mov	 DWORD PTR [esi+1836], ebx
  00049	f3 0f 11 86 30
	07 00 00	 movss	 DWORD PTR [esi+1840], xmm0

; 57   : 
; 58   : 	m_iCurAniRotate = 0;

  00051	89 9e 28 07 00
	00		 mov	 DWORD PTR [esi+1832], ebx

; 59   : 
; 60   : 	m_dwEnableSwitchTime = 0;

  00057	89 9e 5c 03 00
	00		 mov	 DWORD PTR [esi+860], ebx

; 61   : 	m_dwEnableSemiSwitchTime = 0;

  0005d	89 9e 64 03 00
	00		 mov	 DWORD PTR [esi+868], ebx

; 62   : 
; 63   : 	if( m_dwSwitchSkill > 0 )

  00063	39 9e 58 03 00
	00		 cmp	 DWORD PTR [esi+856], ebx
  00069	76 1a		 jbe	 SHORT $LN11@OnSkillSta

; 64   : 		m_dwEnableSwitchTime = FRAMEGETTIME() + m_dwSwitchSkill;

  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  00071	8b c8		 mov	 ecx, eax
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ
  00079	03 86 58 03 00
	00		 add	 eax, DWORD PTR [esi+856]
  0007f	89 86 5c 03 00
	00		 mov	 DWORD PTR [esi+860], eax
$LN11@OnSkillSta:

; 65   : 	if( m_dwSemiSwitchSkill > 0 )

  00085	39 9e 60 03 00
	00		 cmp	 DWORD PTR [esi+864], ebx
  0008b	76 1a		 jbe	 SHORT $LN10@OnSkillSta

; 66   : 		m_dwEnableSemiSwitchTime = FRAMEGETTIME() + m_dwSemiSwitchSkill;

  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  00093	8b c8		 mov	 ecx, eax
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ
  0009b	03 86 60 03 00
	00		 add	 eax, DWORD PTR [esi+864]
  000a1	89 86 64 03 00
	00		 mov	 DWORD PTR [esi+868], eax
$LN10@OnSkillSta:

; 67   : 
; 68   : 	m_dwSkillStartTime = FRAMEGETTIME();

  000a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  000ad	8b c8		 mov	 ecx, eax
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ
  000b5	89 45 d0	 mov	 DWORD PTR _value$525342[ebp], eax
  000b8	8d 45 d0	 lea	 eax, DWORD PTR _value$525342[ebp]
  000bb	50		 push	 eax
  000bc	8d 8e 94 0e 00
	00		 lea	 ecx, DWORD PTR [esi+3732]
  000c2	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z ; CEncrypt<unsigned long>::EncryptValueToPool

; 69   : 
; 70   : 	m_bSetHandMesh = false;

  000c7	88 9e 0a 0f 00
	00		 mov	 BYTE PTR [esi+3850], bl

; 71   : 	m_SkillState = SS_NONE;

  000cd	89 9e e4 10 00
	00		 mov	 DWORD PTR [esi+4324], ebx

; 72   : 
; 73   : 	//    
; 74   : 	if( m_bUseItemMesh )

  000d3	38 9e 08 0f 00
	00		 cmp	 BYTE PTR [esi+3848], bl
  000d9	74 09		 je	 SHORT $LN9@OnSkillSta

; 75   : 	{
; 76   : 		pChar->ShowWeaponItemMesh( false );

  000db	53		 push	 ebx
  000dc	53		 push	 ebx
  000dd	8b cf		 mov	 ecx, edi
  000df	e8 00 00 00 00	 call	 ?ShowWeaponItemMesh@ioBaseChar@@QAEX_N0@Z ; ioBaseChar::ShowWeaponItemMesh
$LN9@OnSkillSta:

; 77   : 	}
; 78   : 
; 79   : 	m_dwWeaponBaseIndex = pChar->IncreaseWeaponIndexBase();

  000e4	8b cf		 mov	 ecx, edi
  000e6	e8 00 00 00 00	 call	 ?IncreaseWeaponIndexBase@ioBaseChar@@QAEKXZ ; ioBaseChar::IncreaseWeaponIndexBase
  000eb	89 46 78	 mov	 DWORD PTR [esi+120], eax

; 80   : 	if( !StartPreDelayAnimation( pChar ) )	// Delay Animation 

  000ee	8b 06		 mov	 eax, DWORD PTR [esi]
  000f0	57		 push	 edi
  000f1	8b ce		 mov	 ecx, esi
  000f3	ff 90 88 01 00
	00		 call	 DWORD PTR [eax+392]
  000f9	84 c0		 test	 al, al
  000fb	75 0d		 jne	 SHORT $LN8@OnSkillSta

; 81   : 	{
; 82   : 		SetDefenseLoopState( pChar );

  000fd	57		 push	 edi
  000fe	8b ce		 mov	 ecx, esi
  00100	e8 00 00 00 00	 call	 ?SetDefenseLoopState@ioDefenseAttackSkill@@IAEXPAVioBaseChar@@@Z ; ioDefenseAttackSkill::SetDefenseLoopState

; 83   : 	}
; 84   : 	else

  00105	e9 1b 01 00 00	 jmp	 $LN2@OnSkillSta
$LN8@OnSkillSta:

; 85   : 	{
; 86   : 		DWORD dwTrackingTime = 0;
; 87   : 		ioEntityGroup *pGrp = pChar->GetGroup();

  0010a	8b 45 dc	 mov	 eax, DWORD PTR _pChar$GSCopy$[ebp]
  0010d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00110	33 ff		 xor	 edi, edi
  00112	89 45 d0	 mov	 DWORD PTR _pGrp$523814[ebp], eax

; 88   : 		if( pGrp )

  00115	3b c3		 cmp	 eax, ebx
  00117	0f 84 bf 00 00
	00		 je	 $LN6@OnSkillSta

; 89   : 		{
; 90   : 			ioHashString szPreDelay = GetPreDelayAniName();

  0011d	8b 06		 mov	 eax, DWORD PTR [esi]
  0011f	8b ce		 mov	 ecx, esi
  00121	ff 90 30 01 00
	00		 call	 DWORD PTR [eax+304]
  00127	50		 push	 eax
  00128	8d 4d b0	 lea	 ecx, DWORD PTR _szPreDelay$523816[ebp]
  0012b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z

; 91   : 
; 92   : 			int iAniID = pGrp->GetAnimationIdx( szPreDelay );

  00131	8b 4d d0	 mov	 ecx, DWORD PTR _pGrp$523814[ebp]
  00134	8d 45 b0	 lea	 eax, DWORD PTR _szPreDelay$523816[ebp]
  00137	50		 push	 eax
  00138	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  0013b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetAnimationIdx@ioEntityGroup@@QAEHABVioHashString@@@Z
  00141	89 45 d8	 mov	 DWORD PTR _iAniID$523817[ebp], eax

; 93   : 			if( iAniID != -1 )

  00144	83 f8 ff	 cmp	 eax, -1
  00147	0f 84 82 00 00
	00		 je	 $LN5@OnSkillSta

; 94   : 				dwTrackingTime = pGrp->GetAnimationEventTime_e( iAniID, "tracking_e" );

  0014d	6a 02		 push	 2
  0014f	c7 45 e0 99 9e
	8a 89		 mov	 DWORD PTR _szEncEventType$525370[ebp], -1987404135 ; 898a9e99H
  00156	c7 45 e4 86 85
	85 8d		 mov	 DWORD PTR _szEncEventType$525370[ebp+4], -1920629370 ; 8d858586H
  0015d	66 c7 45 e8 b2
	89		 mov	 WORD PTR _szEncEventType$525370[ebp+8], 35250 ; 000089b2H
  00163	8d 45 e0	 lea	 eax, DWORD PTR _szEncEventType$525370[ebp]
  00166	88 5d ea	 mov	 BYTE PTR _szEncEventType$525370[ebp+10], bl
  00169	59		 pop	 ecx
$LL124@OnSkillSta:
  0016a	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00170	83 c0 04	 add	 eax, 4
  00173	49		 dec	 ecx
  00174	75 f4		 jne	 SHORT $LL124@OnSkillSta
  00176	6a 08		 push	 8
  00178	5f		 pop	 edi
$LL121@OnSkillSta:
  00179	8b c7		 mov	 eax, edi
  0017b	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00180	79 05		 jns	 SHORT $LN143@OnSkillSta
  00182	48		 dec	 eax
  00183	83 c8 fc	 or	 eax, -4			; fffffffcH
  00186	40		 inc	 eax
$LN143@OnSkillSta:
  00187	b1 ed		 mov	 cl, -19			; ffffffedH
  00189	2a c8		 sub	 cl, al
  0018b	30 4c 3d e0	 xor	 BYTE PTR _szEncEventType$525370[ebp+edi], cl
  0018f	47		 inc	 edi
  00190	83 ff 0a	 cmp	 edi, 10			; 0000000aH
  00193	7c e4		 jl	 SHORT $LL121@OnSkillSta
  00195	8d 45 e0	 lea	 eax, DWORD PTR _szEncEventType$525370[ebp]
  00198	50		 push	 eax
  00199	8d 4d c0	 lea	 ecx, DWORD PTR $T525367[ebp]
  0019c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  001a2	8b 4d d0	 mov	 ecx, DWORD PTR _pGrp$523814[ebp]
  001a5	8d 45 c0	 lea	 eax, DWORD PTR $T525367[ebp]
  001a8	50		 push	 eax
  001a9	ff 75 d8	 push	 DWORD PTR _iAniID$523817[ebp]
  001ac	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  001b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetAnimationEventTime@ioEntityGroup@@QAEMHABVioHashString@@@Z
  001b6	d9 5d d8	 fstp	 DWORD PTR $T525366[ebp]
  001b9	8d 4d c0	 lea	 ecx, DWORD PTR $T525367[ebp]
  001bc	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  001bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  001c5	d9 45 d8	 fld	 DWORD PTR $T525366[ebp]
  001c8	e8 00 00 00 00	 call	 __ftol2
  001cd	8b f8		 mov	 edi, eax
$LN5@OnSkillSta:

; 95   : 		}

  001cf	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  001d3	8d 4d b0	 lea	 ecx, DWORD PTR _szPreDelay$523816[ebp]
  001d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
$LN6@OnSkillSta:

; 96   : 
; 97   : 		DWORD dwPreDelay = GetPreDelayTime();

  001dc	8b 06		 mov	 eax, DWORD PTR [esi]
  001de	8b ce		 mov	 ecx, esi
  001e0	ff 90 34 01 00
	00		 call	 DWORD PTR [eax+308]
  001e6	89 45 d8	 mov	 DWORD PTR _dwPreDelay$523824[ebp], eax

; 98   : 
; 99   : 		if( dwTrackingTime > 0 )
; 100  : 			dwTrackingTime += FRAMEGETTIME();

  001e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  001ef	8b c8		 mov	 ecx, eax
  001f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ
  001f7	3b fb		 cmp	 edi, ebx
  001f9	76 04		 jbe	 SHORT $LN4@OnSkillSta
  001fb	03 f8		 add	 edi, eax

; 101  : 		else

  001fd	eb 05		 jmp	 SHORT $LN3@OnSkillSta
$LN4@OnSkillSta:

; 102  : 			dwTrackingTime = FRAMEGETTIME() + dwPreDelay;

  001ff	8b f8		 mov	 edi, eax
  00201	03 7d d8	 add	 edi, DWORD PTR _dwPreDelay$523824[ebp]
$LN3@OnSkillSta:

; 103  : 
; 104  : 		if( IsUseAutoTargetValue() )

  00204	8b 06		 mov	 eax, DWORD PTR [esi]
  00206	8b ce		 mov	 ecx, esi
  00208	ff 90 e0 00 00
	00		 call	 DWORD PTR [eax+224]
  0020e	84 c0		 test	 al, al
  00210	74 13		 je	 SHORT $LN2@OnSkillSta

; 105  : 		{
; 106  : 			pChar->SetAutoTarget( ATT_SKILL );

  00212	8b 4d dc	 mov	 ecx, DWORD PTR _pChar$GSCopy$[ebp]
  00215	6a 04		 push	 4
  00217	e8 00 00 00 00	 call	 ?SetAutoTarget@ioBaseChar@@QAEXW4AutoTargetType@@@Z ; ioBaseChar::SetAutoTarget

; 107  : 			pChar->SetAutoTargetTrackingEndTime( dwTrackingTime );

  0021c	8b 4d dc	 mov	 ecx, DWORD PTR _pChar$GSCopy$[ebp]
  0021f	57		 push	 edi
  00220	e8 00 00 00 00	 call	 ?SetAutoTargetTrackingEndTime@ioBaseChar@@QAEXK@Z ; ioBaseChar::SetAutoTargetTrackingEndTime
$LN2@OnSkillSta:

; 108  : 		}
; 109  : 	}
; 110  : 
; 111  : 	CheckSkillDesc( pChar );

  00225	8b 7d dc	 mov	 edi, DWORD PTR _pChar$GSCopy$[ebp]
  00228	57		 push	 edi
  00229	8b ce		 mov	 ecx, esi
  0022b	e8 00 00 00 00	 call	 ?CheckSkillDesc@ioSkill@@IAEXPAVioBaseChar@@@Z ; ioSkill::CheckSkillDesc

; 112  : 
; 113  : 	if( m_bInitJumpPower )

  00230	8d 45 d7	 lea	 eax, DWORD PTR _value$525480[ebp]
  00233	50		 push	 eax
  00234	8d 8e f4 05 00
	00		 lea	 ecx, DWORD PTR [esi+1524]
  0023a	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  0023f	38 5d d7	 cmp	 BYTE PTR _value$525480[ebp], bl
  00242	74 1f		 je	 SHORT $LN133@OnSkillSta

; 114  : 	{
; 115  : 		pChar->SetCurJumpPowerAmt( 0.0f );

  00244	0f 57 c0	 xorps	 xmm0, xmm0

; 116  : 		pChar->SetGravityAmt( 0.0f );

  00247	8d 45 d8	 lea	 eax, DWORD PTR _value$525492[ebp]
  0024a	50		 push	 eax
  0024b	8d 8f e8 0b 00
	00		 lea	 ecx, DWORD PTR [edi+3048]
  00251	f3 0f 11 87 90
	0e 00 00	 movss	 DWORD PTR [edi+3728], xmm0
  00259	f3 0f 11 45 d8	 movss	 DWORD PTR _value$525492[ebp], xmm0
  0025e	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool
$LN133@OnSkillSta:

; 117  : 	}
; 118  : 
; 119  : 	SetSkillNameChatBubble( pChar );

  00263	57		 push	 edi
  00264	8b ce		 mov	 ecx, esi
  00266	e8 00 00 00 00	 call	 ?SetSkillNameChatBubble@ioSkill@@IAEXPAVioBaseChar@@@Z ; ioSkill::SetSkillNameChatBubble

; 120  : 
; 121  : 	return true;

  0026b	b0 01		 mov	 al, 1
$LN13@OnSkillSta:

; 122  : }

  0026d	e8 00 00 00 00	 call	 __EH_epilog3_GS
  00272	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnSkillStart@ioDefenseAttackSkill@@UAE_NPAVioBaseChar@@@Z$0:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR _szPreDelay$523816[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?OnSkillStart@ioDefenseAttackSkill@@UAE_NPAVioBaseChar@@@Z$1:
  00009	8d 4d c0	 lea	 ecx, DWORD PTR $T525367[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$?OnSkillStart@ioDefenseAttackSkill@@UAE_NPAVioBaseChar@@@Z:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnSkillStart@ioDefenseAttackSkill@@UAE_NPAVioBaseChar@@@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnSkillStart@ioDefenseAttackSkill@@UAE_NPAVioBaseChar@@@Z ENDP ; ioDefenseAttackSkill::OnSkillStart
END
