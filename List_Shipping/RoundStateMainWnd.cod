; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\Lost Saga For Developer\Youtube\Tutorial\Source\src\LSClient\GUI\RoundStateMainWnd.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_EEM_DS@?$deque@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@2HB ; std::deque<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_EEM_DS
;	COMDAT ?_EEM_DS@?$deque@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@2HB
CONST	SEGMENT
?_EEM_DS@?$deque@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@2HB DD 01H ; std::deque<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_EEM_DS
CONST	ENDS
PUBLIC	?GetPlayMode@ioPlayStage@@QBEPAVioPlayMode@@XZ	; ioPlayStage::GetPlayMode
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioplaystage.h
;	COMDAT ?GetPlayMode@ioPlayStage@@QBEPAVioPlayMode@@XZ
_TEXT	SEGMENT
?GetPlayMode@ioPlayStage@@QBEPAVioPlayMode@@XZ PROC	; ioPlayStage::GetPlayMode, COMDAT
; _this$ = ecx

; 780  : 	inline ioPlayMode* GetPlayMode() const { return m_pPlayMode; }

  00000	8b 81 10 01 00
	00		 mov	 eax, DWORD PTR [ecx+272]
  00006	c3		 ret	 0
?GetPlayMode@ioPlayStage@@QBEPAVioPlayMode@@XZ ENDP	; ioPlayStage::GetPlayMode
_TEXT	ENDS
PUBLIC	?GetModeSubNum@ioPlayStage@@QAEHXZ		; ioPlayStage::GetModeSubNum
; Function compile flags: /Ogsp
;	COMDAT ?GetModeSubNum@ioPlayStage@@QAEHXZ
_TEXT	SEGMENT
?GetModeSubNum@ioPlayStage@@QAEHXZ PROC			; ioPlayStage::GetModeSubNum, COMDAT
; _this$ = ecx

; 784  : 	int GetModeSubNum(){ return m_iModeSubNum; }

  00000	8b 81 24 01 00
	00		 mov	 eax, DWORD PTR [ecx+292]
  00006	c3		 ret	 0
?GetModeSubNum@ioPlayStage@@QAEHXZ ENDP			; ioPlayStage::GetModeSubNum
_TEXT	ENDS
PUBLIC	?return100@@YAIXZ				; return100
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stdafx.h
;	COMDAT ?return100@@YAIXZ
_TEXT	SEGMENT
?return100@@YAIXZ PROC					; return100, COMDAT

; 25   : 	__forceinline unsigned int return100() { __asm mov eax, 100 };

  00000	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  00005	c3		 ret	 0
?return100@@YAIXZ ENDP					; return100
_TEXT	ENDS
PUBLIC	?GetState@ioBaseChar@@QBE?AW4CharState@@XZ	; ioBaseChar::GetState
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasechar.h
;	COMDAT ?GetState@ioBaseChar@@QBE?AW4CharState@@XZ
_TEXT	SEGMENT
?GetState@ioBaseChar@@QBE?AW4CharState@@XZ PROC		; ioBaseChar::GetState, COMDAT
; _this$ = ecx

; 2156 : 	inline CharState GetState() const { return m_CharState; }	

  00000	8a 81 10 03 00
	00		 mov	 al, BYTE PTR [ecx+784]
  00006	c3		 ret	 0
?GetState@ioBaseChar@@QBE?AW4CharState@@XZ ENDP		; ioBaseChar::GetState
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
  00010	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00016	8b c6		 mov	 eax, esi
  00018	5e		 pop	 esi
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogsp
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1exception@std@@UAE@XZ
  00012	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00016	74 07		 je	 SHORT $LN1@scalar
  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001e	59		 pop	 ecx
$LN1@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 56   : 	{	// construct array with placement at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : 	return (_Where);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 58   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogsp
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 62   : 	}

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?GetMasterName@ioHouseMode@@QAEAAVioHashString@@XZ ; ioHouseMode::GetMasterName
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iohousemode.h
;	COMDAT ?GetMasterName@ioHouseMode@@QAEAAVioHashString@@XZ
_TEXT	SEGMENT
?GetMasterName@ioHouseMode@@QAEAAVioHashString@@XZ PROC	; ioHouseMode::GetMasterName, COMDAT
; _this$ = ecx

; 156  : 	inline ioHashString &GetMasterName(){ return m_szMasterName; }

  00000	8d 81 f4 04 00
	00		 lea	 eax, DWORD PTR [ecx+1268]
  00006	c3		 ret	 0
?GetMasterName@ioHouseMode@@QAEAAVioHashString@@XZ ENDP	; ioHouseMode::GetMasterName
_TEXT	ENDS
PUBLIC	?GetTournamentStartTeamCount@TournamentNode@@QAEKXZ ; TournamentNode::GetTournamentStartTeamCount
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\tournamentnode.h
;	COMDAT ?GetTournamentStartTeamCount@TournamentNode@@QAEKXZ
_TEXT	SEGMENT
?GetTournamentStartTeamCount@TournamentNode@@QAEKXZ PROC ; TournamentNode::GetTournamentStartTeamCount, COMDAT
; _this$ = ecx

; 350  : 	inline DWORD GetTournamentStartTeamCount(){ return m_TournamentStartTeamCount; }

  00000	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00003	c3		 ret	 0
?GetTournamentStartTeamCount@TournamentNode@@QAEKXZ ENDP ; TournamentNode::GetTournamentStartTeamCount
_TEXT	ENDS
PUBLIC	?GetTeamName@TeamGlobalData@@QAEAAVioHashString@@XZ ; TeamGlobalData::GetTeamName
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iotournamentteammanager.h
;	COMDAT ?GetTeamName@TeamGlobalData@@QAEAAVioHashString@@XZ
_TEXT	SEGMENT
?GetTeamName@TeamGlobalData@@QAEAAVioHashString@@XZ PROC ; TeamGlobalData::GetTeamName, COMDAT
; _this$ = ecx

; 38   : 	inline ioHashString &GetTeamName(){ return m_DefaultData.m_szTeamName; }

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
  00003	c3		 ret	 0
?GetTeamName@TeamGlobalData@@QAEAAVioHashString@@XZ ENDP ; TeamGlobalData::GetTeamName
_TEXT	ENDS
PUBLIC	?GetTourPos@TeamGlobalData@@QAEEXZ		; TeamGlobalData::GetTourPos
; Function compile flags: /Ogsp
;	COMDAT ?GetTourPos@TeamGlobalData@@QAEEXZ
_TEXT	SEGMENT
?GetTourPos@TeamGlobalData@@QAEEXZ PROC			; TeamGlobalData::GetTourPos, COMDAT
; _this$ = ecx

; 43   : 	inline BYTE  GetTourPos(){ return m_TourPos; }

  00000	8a 41 38	 mov	 al, BYTE PTR [ecx+56]
  00003	c3		 ret	 0
?GetTourPos@TeamGlobalData@@QAEEXZ ENDP			; TeamGlobalData::GetTourPos
_TEXT	ENDS
PUBLIC	?GetName@ioShuffleRoomMgr@@QAE?AVioHashString@@XZ ; ioShuffleRoomMgr::GetName
EXTRN	__imp_??0ioHashString@@QAE@ABV0@@Z:PROC
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioshuffleroommgr.h
;	COMDAT ?GetName@ioShuffleRoomMgr@@QAE?AVioHashString@@XZ
_TEXT	SEGMENT
$T556933 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetName@ioShuffleRoomMgr@@QAE?AVioHashString@@XZ PROC	; ioShuffleRoomMgr::GetName, COMDAT
; _this$ = ecx

; 182  : 	inline ioHashString GetName()      { return m_ShuffleRoom.m_szName; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	83 65 fc 00	 and	 DWORD PTR $T556933[ebp], 0
  00008	83 c1 08	 add	 ecx, 8
  0000b	51		 push	 ecx
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  00015	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00018	c9		 leave
  00019	c2 04 00	 ret	 4
?GetName@ioShuffleRoomMgr@@QAE?AVioHashString@@XZ ENDP	; ioShuffleRoomMgr::GetName
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 49   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
PUBLIC	?GetMaxUserCount@PlazaMainWnd@@QAEHXZ		; PlazaMainWnd::GetMaxUserCount
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\plazamainwnd.h
;	COMDAT ?GetMaxUserCount@PlazaMainWnd@@QAEHXZ
_TEXT	SEGMENT
?GetMaxUserCount@PlazaMainWnd@@QAEHXZ PROC		; PlazaMainWnd::GetMaxUserCount, COMDAT
; _this$ = ecx

; 532  : 	int GetMaxUserCount(){ return m_PlazaInfo.m_iMaxUserCount; }

  00000	8b 81 00 02 00
	00		 mov	 eax, DWORD PTR [ecx+512]
  00006	c3		 ret	 0
?GetMaxUserCount@PlazaMainWnd@@QAEHXZ ENDP		; PlazaMainWnd::GetMaxUserCount
_TEXT	ENDS
PUBLIC	?GetPlazaName@PlazaMainWnd@@QAEABVioHashString@@XZ ; PlazaMainWnd::GetPlazaName
; Function compile flags: /Ogsp
;	COMDAT ?GetPlazaName@PlazaMainWnd@@QAEABVioHashString@@XZ
_TEXT	SEGMENT
?GetPlazaName@PlazaMainWnd@@QAEABVioHashString@@XZ PROC	; PlazaMainWnd::GetPlazaName, COMDAT
; _this$ = ecx

; 535  : 	const ioHashString &GetPlazaName(){ return m_PlazaInfo.m_szRoomName; }

  00000	8d 81 ac 01 00
	00		 lea	 eax, DWORD PTR [ecx+428]
  00006	c3		 ret	 0
?GetPlazaName@PlazaMainWnd@@QAEABVioHashString@@XZ ENDP	; PlazaMainWnd::GetPlazaName
_TEXT	ENDS
PUBLIC	?IsRoomPW@PlazaMainWnd@@QAE_NXZ			; PlazaMainWnd::IsRoomPW
; Function compile flags: /Ogsp
;	COMDAT ?IsRoomPW@PlazaMainWnd@@QAE_NXZ
_TEXT	SEGMENT
?IsRoomPW@PlazaMainWnd@@QAE_NXZ PROC			; PlazaMainWnd::IsRoomPW, COMDAT
; _this$ = ecx

; 538  : 	bool IsRoomPW(){ return m_PlazaInfo.m_bRoomPW; }

  00000	8a 81 08 02 00
	00		 mov	 al, BYTE PTR [ecx+520]
  00006	c3		 ret	 0
?IsRoomPW@PlazaMainWnd@@QAE_NXZ ENDP			; PlazaMainWnd::IsRoomPW
_TEXT	ENDS
PUBLIC	?IsHeroMatchMode@ioLadderTeamMgr@@QAE_NXZ	; ioLadderTeamMgr::IsHeroMatchMode
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioladderteammgr.h
;	COMDAT ?IsHeroMatchMode@ioLadderTeamMgr@@QAE_NXZ
_TEXT	SEGMENT
?IsHeroMatchMode@ioLadderTeamMgr@@QAE_NXZ PROC		; ioLadderTeamMgr::IsHeroMatchMode, COMDAT
; _this$ = ecx

; 274  : 	bool IsHeroMatchMode(){ return m_bHeroMatchMode; }

  00000	8a 81 be 04 00
	00		 mov	 al, BYTE PTR [ecx+1214]
  00006	c3		 ret	 0
?IsHeroMatchMode@ioLadderTeamMgr@@QAE_NXZ ENDP		; ioLadderTeamMgr::IsHeroMatchMode
_TEXT	ENDS
PUBLIC	?GetLadderTeamName@ioLadderTeamMgr@@QAEABVioHashString@@XZ ; ioLadderTeamMgr::GetLadderTeamName
; Function compile flags: /Ogsp
;	COMDAT ?GetLadderTeamName@ioLadderTeamMgr@@QAEABVioHashString@@XZ
_TEXT	SEGMENT
?GetLadderTeamName@ioLadderTeamMgr@@QAEABVioHashString@@XZ PROC ; ioLadderTeamMgr::GetLadderTeamName, COMDAT
; _this$ = ecx

; 306  : 	const ioHashString &GetLadderTeamName(){ return m_LadderTeam.m_szTeamName; }

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
  00003	c3		 ret	 0
?GetLadderTeamName@ioLadderTeamMgr@@QAEABVioHashString@@XZ ENDP ; ioLadderTeamMgr::GetLadderTeamName
_TEXT	ENDS
PUBLIC	?GetLadderTeamPW@ioLadderTeamMgr@@QAEABVioHashString@@XZ ; ioLadderTeamMgr::GetLadderTeamPW
; Function compile flags: /Ogsp
;	COMDAT ?GetLadderTeamPW@ioLadderTeamMgr@@QAEABVioHashString@@XZ
_TEXT	SEGMENT
?GetLadderTeamPW@ioLadderTeamMgr@@QAEABVioHashString@@XZ PROC ; ioLadderTeamMgr::GetLadderTeamPW, COMDAT
; _this$ = ecx

; 307  : 	const ioHashString &GetLadderTeamPW(){ return m_LadderTeam.m_szTeamPW; }

  00000	8d 41 20	 lea	 eax, DWORD PTR [ecx+32]
  00003	c3		 ret	 0
?GetLadderTeamPW@ioLadderTeamMgr@@QAEABVioHashString@@XZ ENDP ; ioLadderTeamMgr::GetLadderTeamPW
_TEXT	ENDS
PUBLIC	?GetHeroMatchOtherInfo@ioLadderTeamMgr@@QAEAAUtagLadderHeroUserInfo@@XZ ; ioLadderTeamMgr::GetHeroMatchOtherInfo
; Function compile flags: /Ogsp
;	COMDAT ?GetHeroMatchOtherInfo@ioLadderTeamMgr@@QAEAAUtagLadderHeroUserInfo@@XZ
_TEXT	SEGMENT
?GetHeroMatchOtherInfo@ioLadderTeamMgr@@QAEAAUtagLadderHeroUserInfo@@XZ PROC ; ioLadderTeamMgr::GetHeroMatchOtherInfo, COMDAT
; _this$ = ecx

; 344  : 	LadderHeroUserInfo &GetHeroMatchOtherInfo(){ return m_HeroMatchOtherInfo; }

  00000	8d 81 ec 00 00
	00		 lea	 eax, DWORD PTR [ecx+236]
  00006	c3		 ret	 0
?GetHeroMatchOtherInfo@ioLadderTeamMgr@@QAEAAUtagLadderHeroUserInfo@@XZ ENDP ; ioLadderTeamMgr::GetHeroMatchOtherInfo
_TEXT	ENDS
PUBLIC	?SetWindowTeam@RoundStateUserWnd@@QAEXW4TeamType@@@Z ; RoundStateUserWnd::SetWindowTeam
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
;	COMDAT ?SetWindowTeam@RoundStateUserWnd@@QAEXW4TeamType@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?SetWindowTeam@RoundStateUserWnd@@QAEXW4TeamType@@@Z PROC ; RoundStateUserWnd::SetWindowTeam, COMDAT
; _this$ = ecx

; 517  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 518  : 	m_eWindowTeam = eTeam; 

  00003	8b 45 08	 mov	 eax, DWORD PTR _eTeam$[ebp]
  00006	89 81 58 02 00
	00		 mov	 DWORD PTR [ecx+600], eax

; 519  : }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?SetWindowTeam@RoundStateUserWnd@@QAEXW4TeamType@@@Z ENDP ; RoundStateUserWnd::SetWindowTeam
_TEXT	ENDS
PUBLIC	?SetPlayStage@RoundStateUserWnd@@QAEXPAVioPlayStage@@@Z ; RoundStateUserWnd::SetPlayStage
; Function compile flags: /Ogsp
;	COMDAT ?SetPlayStage@RoundStateUserWnd@@QAEXPAVioPlayStage@@@Z
_TEXT	SEGMENT
_pPlayStage$ = 8					; size = 4
?SetPlayStage@RoundStateUserWnd@@QAEXPAVioPlayStage@@@Z PROC ; RoundStateUserWnd::SetPlayStage, COMDAT
; _this$ = ecx

; 522  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 523  : 	m_pPlayStage = pPlayStage;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pPlayStage$[ebp]
  00006	89 81 94 02 00
	00		 mov	 DWORD PTR [ecx+660], eax

; 524  : }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?SetPlayStage@RoundStateUserWnd@@QAEXPAVioPlayStage@@@Z ENDP ; RoundStateUserWnd::SetPlayStage
_TEXT	ENDS
PUBLIC	?SetTournamentTeamName@RoundStateUserWnd@@QAEXVioHashString@@@Z ; RoundStateUserWnd::SetTournamentTeamName
EXTRN	__imp_??1ioHashString@@QAE@XZ:PROC
EXTRN	__imp_??4ioHashString@@QAEAAV0@ABV0@@Z:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__EH_epilog3:PROC
EXTRN	__EH_prolog3:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetTournamentTeamName@RoundStateUserWnd@@QAEXVioHashString@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetTournamentTeamName@RoundStateUserWnd@@QAEXVioHashString@@@Z$0
__ehfuncinfo$?SetTournamentTeamName@RoundStateUserWnd@@QAEXVioHashString@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetTournamentTeamName@RoundStateUserWnd@@QAEXVioHashString@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ?SetTournamentTeamName@RoundStateUserWnd@@QAEXVioHashString@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_szName$ = 8						; size = 16
?SetTournamentTeamName@RoundStateUserWnd@@QAEXVioHashString@@@Z PROC ; RoundStateUserWnd::SetTournamentTeamName, COMDAT
; _this$ = ecx

; 537  : {

  00000	6a 00		 push	 0
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetTournamentTeamName@RoundStateUserWnd@@QAEXVioHashString@@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 538  : 	m_szTournamentTeamName = szName;

  00010	8d 45 08	 lea	 eax, DWORD PTR _szName$[ebp]
  00013	50		 push	 eax
  00014	81 c1 d4 02 00
	00		 add	 ecx, 724		; 000002d4H
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@ABV0@@Z

; 539  : }

  00020	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00024	8d 4d 08	 lea	 ecx, DWORD PTR _szName$[ebp]
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  0002d	e8 00 00 00 00	 call	 __EH_epilog3
  00032	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetTournamentTeamName@RoundStateUserWnd@@QAEXVioHashString@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _szName$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$?SetTournamentTeamName@RoundStateUserWnd@@QAEXVioHashString@@@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetTournamentTeamName@RoundStateUserWnd@@QAEXVioHashString@@@Z
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetTournamentTeamName@RoundStateUserWnd@@QAEXVioHashString@@@Z ENDP ; RoundStateUserWnd::SetTournamentTeamName
PUBLIC	?SetPlazaScore@RoundStateUserWnd@@QAEXH@Z	; RoundStateUserWnd::SetPlazaScore
; Function compile flags: /Ogsp
;	COMDAT ?SetPlazaScore@RoundStateUserWnd@@QAEXH@Z
_TEXT	SEGMENT
_iMaxSlot$ = 8						; size = 4
?SetPlazaScore@RoundStateUserWnd@@QAEXH@Z PROC		; RoundStateUserWnd::SetPlazaScore, COMDAT
; _this$ = ecx

; 542  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 543  : 	m_iMaxSlot = iMaxSlot;

  00003	8b 45 08	 mov	 eax, DWORD PTR _iMaxSlot$[ebp]
  00006	89 81 60 02 00
	00		 mov	 DWORD PTR [ecx+608], eax

; 544  : }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?SetPlazaScore@RoundStateUserWnd@@QAEXH@Z ENDP		; RoundStateUserWnd::SetPlazaScore
_TEXT	ENDS
PUBLIC	?SetHeadequartersScore@RoundStateUserWnd@@QAEXH@Z ; RoundStateUserWnd::SetHeadequartersScore
; Function compile flags: /Ogsp
;	COMDAT ?SetHeadequartersScore@RoundStateUserWnd@@QAEXH@Z
_TEXT	SEGMENT
_iMaxSlot$ = 8						; size = 4
?SetHeadequartersScore@RoundStateUserWnd@@QAEXH@Z PROC	; RoundStateUserWnd::SetHeadequartersScore, COMDAT
; _this$ = ecx

; 547  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 548  : 	m_iMaxSlot = iMaxSlot;

  00003	8b 45 08	 mov	 eax, DWORD PTR _iMaxSlot$[ebp]
  00006	89 81 60 02 00
	00		 mov	 DWORD PTR [ecx+608], eax

; 549  : }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?SetHeadequartersScore@RoundStateUserWnd@@QAEXH@Z ENDP	; RoundStateUserWnd::SetHeadequartersScore
_TEXT	ENDS
PUBLIC	?SetDungeonsScore@RoundStateUserWnd@@QAEXHH@Z	; RoundStateUserWnd::SetDungeonsScore
; Function compile flags: /Ogsp
;	COMDAT ?SetDungeonsScore@RoundStateUserWnd@@QAEXHH@Z
_TEXT	SEGMENT
_iMaxSlot$ = 8						; size = 4
_iCurrentFloor$ = 12					; size = 4
?SetDungeonsScore@RoundStateUserWnd@@QAEXHH@Z PROC	; RoundStateUserWnd::SetDungeonsScore, COMDAT
; _this$ = ecx

; 586  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 587  : 	m_iMaxSlot = iMaxSlot;

  00003	8b 45 08	 mov	 eax, DWORD PTR _iMaxSlot$[ebp]
  00006	89 81 60 02 00
	00		 mov	 DWORD PTR [ecx+608], eax

; 588  : 	m_iCurrentFloor = iCurrentFloor;

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _iCurrentFloor$[ebp]
  0000f	89 81 64 02 00
	00		 mov	 DWORD PTR [ecx+612], eax

; 589  : }

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?SetDungeonsScore@RoundStateUserWnd@@QAEXHH@Z ENDP	; RoundStateUserWnd::SetDungeonsScore
_TEXT	ENDS
PUBLIC	?SetTeamScore@RoundStateUserWnd@@QAEXHH@Z	; RoundStateUserWnd::SetTeamScore
EXTRN	?IsLadderTeam@ioLadderTeamMgr@@QAE_NXZ:PROC	; ioLadderTeamMgr::IsLadderTeam
EXTRN	?GetSingleton@ioLadderTeamMgr@@SAAAV1@XZ:PROC	; ioLadderTeamMgr::GetSingleton
; Function compile flags: /Ogsp
;	COMDAT ?SetTeamScore@RoundStateUserWnd@@QAEXHH@Z
_TEXT	SEGMENT
_iMaxSlot$ = 8						; size = 4
_iScore$ = 12						; size = 4
?SetTeamScore@RoundStateUserWnd@@QAEXHH@Z PROC		; RoundStateUserWnd::SetTeamScore, COMDAT
; _this$ = ecx

; 592  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 	m_iMaxSlot = iMaxSlot;

  00003	8b 45 08	 mov	 eax, DWORD PTR _iMaxSlot$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	89 86 60 02 00
	00		 mov	 DWORD PTR [esi+608], eax

; 594  : 	m_iCurrentScore = iScore;

  0000f	8b 45 0c	 mov	 eax, DWORD PTR _iScore$[ebp]
  00012	89 86 6c 02 00
	00		 mov	 DWORD PTR [esi+620], eax

; 595  : 
; 596  : 	if( g_LadderTeamMgr.IsLadderTeam() )

  00018	e8 00 00 00 00	 call	 ?GetSingleton@ioLadderTeamMgr@@SAAAV1@XZ ; ioLadderTeamMgr::GetSingleton
  0001d	8b c8		 mov	 ecx, eax
  0001f	e8 00 00 00 00	 call	 ?IsLadderTeam@ioLadderTeamMgr@@QAE_NXZ ; ioLadderTeamMgr::IsLadderTeam
  00024	84 c0		 test	 al, al
  00026	74 0a		 je	 SHORT $LN1@SetTeamSco

; 597  : 		m_iNameLimit = 113;

  00028	c7 86 90 02 00
	00 71 00 00 00	 mov	 DWORD PTR [esi+656], 113 ; 00000071H
$LN1@SetTeamSco:
  00032	5e		 pop	 esi

; 598  : }

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
?SetTeamScore@RoundStateUserWnd@@QAEXHH@Z ENDP		; RoundStateUserWnd::SetTeamScore
_TEXT	ENDS
PUBLIC	?iwm_create@RoundStateUserWnd@@UAEXXZ		; RoundStateUserWnd::iwm_create
EXTRN	?Create@PingStepWnd@@QAEXXZ:PROC		; PingStepWnd::Create
; Function compile flags: /Ogsp
;	COMDAT ?iwm_create@RoundStateUserWnd@@UAEXXZ
_TEXT	SEGMENT
?iwm_create@RoundStateUserWnd@@UAEXXZ PROC		; RoundStateUserWnd::iwm_create, COMDAT
; _this$ = ecx

; 602  : 	m_PingStep.Create();

  00000	81 c1 a8 02 00
	00		 add	 ecx, 680		; 000002a8H
  00006	e9 00 00 00 00	 jmp	 ?Create@PingStepWnd@@QAEXXZ ; PingStepWnd::Create
?iwm_create@RoundStateUserWnd@@UAEXXZ ENDP		; RoundStateUserWnd::iwm_create
_TEXT	ENDS
PUBLIC	?iwm_hide@RoundStateUserWnd@@UAEXXZ		; RoundStateUserWnd::iwm_hide
; Function compile flags: /Ogsp
;	COMDAT ?iwm_hide@RoundStateUserWnd@@UAEXXZ
_TEXT	SEGMENT
?iwm_hide@RoundStateUserWnd@@UAEXXZ PROC		; RoundStateUserWnd::iwm_hide, COMDAT
; _this$ = ecx

; 636  : }

  00000	c3		 ret	 0
?iwm_hide@RoundStateUserWnd@@UAEXXZ ENDP		; RoundStateUserWnd::iwm_hide
_TEXT	ENDS
PUBLIC	?OnRenderTowerDefLine@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderTowerDefLine
EXTRN	__fltused:DWORD
; Function compile flags: /Ogsp
;	COMDAT ?OnRenderTowerDefLine@RoundStateUserWnd@@IAEXHH@Z
_TEXT	SEGMENT
tv254 = 8						; size = 4
_iXPos$ = 8						; size = 4
_i$549725 = 12						; size = 4
_iYPos$ = 12						; size = 4
?OnRenderTowerDefLine@RoundStateUserWnd@@IAEXHH@Z PROC	; RoundStateUserWnd::OnRenderTowerDefLine, COMDAT
; _this$ = ecx

; 855  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 856  : 	if( !m_pBlueDark || !m_pBlueLight ) return;

  00006	83 be 68 01 00
	00 00		 cmp	 DWORD PTR [esi+360], 0
  0000d	0f 84 b1 00 00
	00		 je	 $LN6@OnRenderTo
  00013	83 be 6c 01 00
	00 00		 cmp	 DWORD PTR [esi+364], 0
  0001a	0f 84 a4 00 00
	00		 je	 $LN6@OnRenderTo

; 857  : 
; 858  : 	int iRealXPos = iXPos;
; 859  : 	int iRealYPos = iYPos;
; 860  : 
; 861  : 	m_pBlueDark->SetSize(514, 21);

  00020	8b 8e 68 01 00
	00		 mov	 ecx, DWORD PTR [esi+360]
  00026	8b 01		 mov	 eax, DWORD PTR [ecx]
  00028	53		 push	 ebx
  00029	8b 5d 0c	 mov	 ebx, DWORD PTR _iYPos$[ebp]
  0002c	57		 push	 edi
  0002d	6a 15		 push	 21			; 00000015H
  0002f	bf 02 02 00 00	 mov	 edi, 514		; 00000202H
  00034	57		 push	 edi
  00035	ff 50 10	 call	 DWORD PTR [eax+16]

; 862  : 	m_pBlueLight->SetSize(514, 21);

  00038	8b 8e 6c 01 00
	00		 mov	 ecx, DWORD PTR [esi+364]
  0003e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00040	6a 15		 push	 21			; 00000015H
  00042	57		 push	 edi
  00043	ff 50 10	 call	 DWORD PTR [eax+16]

; 863  : 
; 864  : 	for(int i = 0;i < m_iMaxLine/2;i++)

  00046	8b 86 74 02 00
	00		 mov	 eax, DWORD PTR [esi+628]
  0004c	99		 cdq
  0004d	2b c2		 sub	 eax, edx
  0004f	33 ff		 xor	 edi, edi
  00051	d1 f8		 sar	 eax, 1
  00053	89 7d 0c	 mov	 DWORD PTR _i$549725[ebp], edi
  00056	85 c0		 test	 eax, eax
  00058	7e 68		 jle	 SHORT $LN13@OnRenderTo
  0005a	66 0f 6e 45 08	 movd	 xmm0, DWORD PTR _iXPos$[ebp]
  0005f	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00062	f3 0f 11 45 08	 movss	 DWORD PTR tv254[ebp], xmm0
  00067	eb 05		 jmp	 SHORT $LN5@OnRenderTo
$LL12@OnRenderTo:
  00069	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR tv254[ebp]
$LN5@OnRenderTo:

; 865  : 	{
; 866  : 		if( i%2 == 0 )

  0006e	8b 45 0c	 mov	 eax, DWORD PTR _i$549725[ebp]
  00071	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00076	79 05		 jns	 SHORT $LN15@OnRenderTo
  00078	48		 dec	 eax
  00079	83 c8 fe	 or	 eax, -2			; fffffffeH
  0007c	40		 inc	 eax
$LN15@OnRenderTo:

; 867  : 			m_pBlueDark->Render( iRealXPos, iRealYPos );

  0007d	57		 push	 edi
  0007e	57		 push	 edi
  0007f	57		 push	 edi
  00080	0f 57 c9	 xorps	 xmm1, xmm1
  00083	f3 0f 2a cb	 cvtsi2ss xmm1, ebx
  00087	57		 push	 edi
  00088	75 08		 jne	 SHORT $LN2@OnRenderTo
  0008a	8b 8e 68 01 00
	00		 mov	 ecx, DWORD PTR [esi+360]

; 868  : 		else

  00090	eb 06		 jmp	 SHORT $LN16@OnRenderTo
$LN2@OnRenderTo:

; 869  : 			m_pBlueLight->Render( iRealXPos, iRealYPos );

  00092	8b 8e 6c 01 00
	00		 mov	 ecx, DWORD PTR [esi+364]
$LN16@OnRenderTo:
  00098	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009a	51		 push	 ecx
  0009b	51		 push	 ecx
  0009c	f3 0f 11 4c 24
	04		 movss	 DWORD PTR [esp+4], xmm1
  000a2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a7	ff 10		 call	 DWORD PTR [eax]
  000a9	8b 86 74 02 00
	00		 mov	 eax, DWORD PTR [esi+628]

; 870  : 
; 871  : 		iRealYPos += m_iLineHeight;

  000af	03 9e 8c 02 00
	00		 add	 ebx, DWORD PTR [esi+652]
  000b5	ff 45 0c	 inc	 DWORD PTR _i$549725[ebp]
  000b8	99		 cdq
  000b9	2b c2		 sub	 eax, edx
  000bb	d1 f8		 sar	 eax, 1
  000bd	39 45 0c	 cmp	 DWORD PTR _i$549725[ebp], eax
  000c0	7c a7		 jl	 SHORT $LL12@OnRenderTo
$LN13@OnRenderTo:
  000c2	5f		 pop	 edi
  000c3	5b		 pop	 ebx
$LN6@OnRenderTo:
  000c4	5e		 pop	 esi

; 872  : 	}
; 873  : }

  000c5	5d		 pop	 ebp
  000c6	c2 08 00	 ret	 8
?OnRenderTowerDefLine@RoundStateUserWnd@@IAEXHH@Z ENDP	; RoundStateUserWnd::OnRenderTowerDefLine
_TEXT	ENDS
PUBLIC	?OnRenderGuildMark@RoundStateUserWnd@@IAEHABURoundInfo@@HH@Z ; RoundStateUserWnd::OnRenderGuildMark
EXTRN	?GetGuildSmallMarkSize@ioGuildMarkMgr@@QAEHKK@Z:PROC ; ioGuildMarkMgr::GetGuildSmallMarkSize
EXTRN	?RenderSmallMark@ioGuildMarkMgr@@QAEXKKMMW4UIRenderType@@@Z:PROC ; ioGuildMarkMgr::RenderSmallMark
EXTRN	?GetSingleton@ioGuildMarkMgr@@SAAAV1@XZ:PROC	; ioGuildMarkMgr::GetSingleton
EXTRN	?GetGuildInfo@ioUserInfoMgr@@QAEXABVioHashString@@AAK1@Z:PROC ; ioUserInfoMgr::GetGuildInfo
EXTRN	?GetSingleton@ioUserInfoMgr@@SAAAV1@XZ:PROC	; ioUserInfoMgr::GetSingleton
; Function compile flags: /Ogsp
;	COMDAT ?OnRenderGuildMark@RoundStateUserWnd@@IAEHABURoundInfo@@HH@Z
_TEXT	SEGMENT
_dwGuildMark$ = -4					; size = 4
_dwGuildIndex$ = 8					; size = 4
_rkInfo$ = 8						; size = 4
_iXPos$ = 12						; size = 4
_iYPos$ = 16						; size = 4
?OnRenderGuildMark@RoundStateUserWnd@@IAEHABURoundInfo@@HH@Z PROC ; RoundStateUserWnd::OnRenderGuildMark, COMDAT
; _this$ = ecx

; 953  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 954  : 	// 길드마크
; 955  : 	DWORD dwGuildIndex, dwGuildMark;
; 956  : 	g_UserInfoMgr.GetGuildInfo( rkInfo.m_szName, dwGuildIndex, dwGuildMark );

  00004	8d 45 fc	 lea	 eax, DWORD PTR _dwGuildMark$[ebp]
  00007	50		 push	 eax
  00008	8d 45 08	 lea	 eax, DWORD PTR _dwGuildIndex$[ebp]
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR _rkInfo$[ebp]
  0000f	e8 00 00 00 00	 call	 ?GetSingleton@ioUserInfoMgr@@SAAAV1@XZ ; ioUserInfoMgr::GetSingleton
  00014	8b c8		 mov	 ecx, eax
  00016	e8 00 00 00 00	 call	 ?GetGuildInfo@ioUserInfoMgr@@QAEXABVioHashString@@AAK1@Z ; ioUserInfoMgr::GetGuildInfo

; 957  : 	g_GuildMarkMgr.RenderSmallMark( dwGuildIndex, dwGuildMark, iXPos + 3, iYPos );	

  0001b	66 0f 6e 45 10	 movd	 xmm0, DWORD PTR _iYPos$[ebp]
  00020	8b 45 0c	 mov	 eax, DWORD PTR _iXPos$[ebp]
  00023	6a 00		 push	 0
  00025	51		 push	 ecx
  00026	51		 push	 ecx
  00027	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0002a	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00030	83 c0 03	 add	 eax, 3
  00033	0f 57 c0	 xorps	 xmm0, xmm0
  00036	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0003a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003f	ff 75 fc	 push	 DWORD PTR _dwGuildMark$[ebp]
  00042	ff 75 08	 push	 DWORD PTR _dwGuildIndex$[ebp]
  00045	e8 00 00 00 00	 call	 ?GetSingleton@ioGuildMarkMgr@@SAAAV1@XZ ; ioGuildMarkMgr::GetSingleton
  0004a	8b c8		 mov	 ecx, eax
  0004c	e8 00 00 00 00	 call	 ?RenderSmallMark@ioGuildMarkMgr@@QAEXKKMMW4UIRenderType@@@Z ; ioGuildMarkMgr::RenderSmallMark

; 958  : 	if( dwGuildIndex == 0 )

  00051	83 7d 08 00	 cmp	 DWORD PTR _dwGuildIndex$[ebp], 0
  00055	75 04		 jne	 SHORT $LN1@OnRenderGu

; 959  : 		return 0;

  00057	33 c0		 xor	 eax, eax
  00059	eb 15		 jmp	 SHORT $LN2@OnRenderGu
$LN1@OnRenderGu:

; 960  : 	return g_GuildMarkMgr.GetGuildSmallMarkSize( dwGuildIndex, dwGuildMark ) + 3;

  0005b	ff 75 fc	 push	 DWORD PTR _dwGuildMark$[ebp]
  0005e	ff 75 08	 push	 DWORD PTR _dwGuildIndex$[ebp]
  00061	e8 00 00 00 00	 call	 ?GetSingleton@ioGuildMarkMgr@@SAAAV1@XZ ; ioGuildMarkMgr::GetSingleton
  00066	8b c8		 mov	 ecx, eax
  00068	e8 00 00 00 00	 call	 ?GetGuildSmallMarkSize@ioGuildMarkMgr@@QAEHKK@Z ; ioGuildMarkMgr::GetGuildSmallMarkSize
  0006d	83 c0 03	 add	 eax, 3
$LN2@OnRenderGu:

; 961  : }

  00070	c9		 leave
  00071	c2 0c 00	 ret	 12			; 0000000cH
?OnRenderGuildMark@RoundStateUserWnd@@IAEHABURoundInfo@@HH@Z ENDP ; RoundStateUserWnd::OnRenderGuildMark
_TEXT	ENDS
PUBLIC	__real@3f800000
PUBLIC	?OnRenderBonus@RoundStateUserWnd@@IAEXABURoundInfo@@HH@Z ; RoundStateUserWnd::OnRenderBonus
EXTRN	__imp_?RenderNum@ioUIRenderImage@@QAEXMMHMMW4UIRenderType@@W4TextureFilterOption@@0W4RenerNumerFormatting@1@@Z:PROC
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?OnRenderBonus@RoundStateUserWnd@@IAEXABURoundInfo@@HH@Z
_TEXT	SEGMENT
_rkInfo$ = 8						; size = 4
_iXPos$ = 12						; size = 4
_iYPos$ = 16						; size = 4
?OnRenderBonus@RoundStateUserWnd@@IAEXABURoundInfo@@HH@Z PROC ; RoundStateUserWnd::OnRenderBonus, COMDAT
; _this$ = ecx

; 964  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 965  : 	// (PC방,길드,친구,연승)
; 966  : 	if( rkInfo.m_bPCRoomBonus )

  00006	8b 7d 08	 mov	 edi, DWORD PTR _rkInfo$[ebp]
  00009	33 db		 xor	 ebx, ebx
  0000b	8b f1		 mov	 esi, ecx
  0000d	38 5f 55	 cmp	 BYTE PTR [edi+85], bl
  00010	74 38		 je	 SHORT $LN28@OnRenderBo

; 967  : 	{
; 968  : 		if( rkInfo.m_Team == TEAM_BLUE && m_pPCRoomBlue )

  00012	8b 7f 10	 mov	 edi, DWORD PTR [edi+16]
  00015	83 ff 02	 cmp	 edi, 2
  00018	75 13		 jne	 SHORT $LN27@OnRenderBo
  0001a	39 9e 80 01 00
	00		 cmp	 DWORD PTR [esi+384], ebx
  00020	74 0b		 je	 SHORT $LN27@OnRenderBo

; 969  : 			m_pPCRoomBlue->Render( iXPos, iYPos );

  00022	8b 86 80 01 00
	00		 mov	 eax, DWORD PTR [esi+384]
  00028	e9 8f 00 00 00	 jmp	 $LN37@OnRenderBo
$LN27@OnRenderBo:

; 970  : 		else if( rkInfo.m_Team == TEAM_RED && m_pPCRoomRed )

  0002d	83 ff 01	 cmp	 edi, 1
  00030	0f 85 5b 02 00
	00		 jne	 $LN1@OnRenderBo
  00036	39 9e 84 01 00
	00		 cmp	 DWORD PTR [esi+388], ebx
  0003c	0f 84 4f 02 00
	00		 je	 $LN1@OnRenderBo

; 971  : 			m_pPCRoomRed->Render( iXPos, iYPos );

  00042	8b 86 84 01 00
	00		 mov	 eax, DWORD PTR [esi+388]

; 972  : 	}

  00048	eb 72		 jmp	 SHORT $LN37@OnRenderBo
$LN28@OnRenderBo:

; 973  : 	else if( rkInfo.m_bGuildBonus )

  0004a	38 5f 57	 cmp	 BYTE PTR [edi+87], bl
  0004d	74 35		 je	 SHORT $LN23@OnRenderBo

; 974  : 	{
; 975  : 		if( rkInfo.m_Team == TEAM_BLUE && m_pGuildBlue )

  0004f	8b 7f 10	 mov	 edi, DWORD PTR [edi+16]
  00052	83 ff 02	 cmp	 edi, 2
  00055	75 10		 jne	 SHORT $LN22@OnRenderBo
  00057	39 9e 88 01 00
	00		 cmp	 DWORD PTR [esi+392], ebx
  0005d	74 08		 je	 SHORT $LN22@OnRenderBo

; 976  : 			m_pGuildBlue->Render( iXPos, iYPos );

  0005f	8b 86 88 01 00
	00		 mov	 eax, DWORD PTR [esi+392]
  00065	eb 55		 jmp	 SHORT $LN37@OnRenderBo
$LN22@OnRenderBo:

; 977  : 		else if( rkInfo.m_Team == TEAM_RED && m_pGuildRed )

  00067	83 ff 01	 cmp	 edi, 1
  0006a	0f 85 21 02 00
	00		 jne	 $LN1@OnRenderBo
  00070	39 9e 8c 01 00
	00		 cmp	 DWORD PTR [esi+396], ebx
  00076	0f 84 15 02 00
	00		 je	 $LN1@OnRenderBo

; 978  : 			m_pGuildRed->Render( iXPos, iYPos );

  0007c	8b 86 8c 01 00
	00		 mov	 eax, DWORD PTR [esi+396]

; 979  : 	}

  00082	eb 38		 jmp	 SHORT $LN37@OnRenderBo
$LN23@OnRenderBo:

; 980  : 	else if( rkInfo.m_bFriendBonus )

  00084	38 5f 56	 cmp	 BYTE PTR [edi+86], bl
  00087	74 5f		 je	 SHORT $LN18@OnRenderBo

; 981  : 	{
; 982  : 		if( rkInfo.m_Team == TEAM_BLUE && m_pFriendBlue )

  00089	8b 7f 10	 mov	 edi, DWORD PTR [edi+16]
  0008c	83 ff 02	 cmp	 edi, 2
  0008f	75 10		 jne	 SHORT $LN17@OnRenderBo
  00091	39 9e 90 01 00
	00		 cmp	 DWORD PTR [esi+400], ebx
  00097	74 08		 je	 SHORT $LN17@OnRenderBo

; 983  : 			m_pFriendBlue->Render( iXPos, iYPos );

  00099	8b 86 90 01 00
	00		 mov	 eax, DWORD PTR [esi+400]
  0009f	eb 1b		 jmp	 SHORT $LN37@OnRenderBo
$LN17@OnRenderBo:

; 984  : 		else if( rkInfo.m_Team == TEAM_RED && m_pFriendRed )

  000a1	83 ff 01	 cmp	 edi, 1
  000a4	0f 85 e7 01 00
	00		 jne	 $LN1@OnRenderBo
  000aa	39 9e 94 01 00
	00		 cmp	 DWORD PTR [esi+404], ebx
  000b0	0f 84 db 01 00
	00		 je	 $LN1@OnRenderBo

; 985  : 			m_pFriendRed->Render( iXPos, iYPos );

  000b6	8b 86 94 01 00
	00		 mov	 eax, DWORD PTR [esi+404]
$LN37@OnRenderBo:
  000bc	66 0f 6e 45 10	 movd	 xmm0, DWORD PTR _iYPos$[ebp]
  000c1	8b 10		 mov	 edx, DWORD PTR [eax]
  000c3	53		 push	 ebx
  000c4	53		 push	 ebx
  000c5	53		 push	 ebx
  000c6	53		 push	 ebx
  000c7	51		 push	 ecx
  000c8	51		 push	 ecx
  000c9	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000cc	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000d2	66 0f 6e 45 0c	 movd	 xmm0, DWORD PTR _iXPos$[ebp]
  000d7	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000da	8b c8		 mov	 ecx, eax
  000dc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e1	ff 12		 call	 DWORD PTR [edx]

; 986  : 	}

  000e3	e9 a9 01 00 00	 jmp	 $LN1@OnRenderBo
$LN18@OnRenderBo:

; 987  : 	else if( rkInfo.m_iVictories > 1 )

  000e8	8b 47 3c	 mov	 eax, DWORD PTR [edi+60]
  000eb	83 f8 01	 cmp	 eax, 1
  000ee	0f 8e 9d 01 00
	00		 jle	 $LN1@OnRenderBo

; 988  : 	{
; 989  : 		if( rkInfo.m_iVictories < 10 )
; 990  : 		{
; 991  : 			if( rkInfo.m_Team == TEAM_BLUE && m_pVictoriesBlue1 )

  000f4	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  000f7	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  000fa	0f 8d b2 00 00
	00		 jge	 $LN12@OnRenderBo
  00100	83 f9 02	 cmp	 ecx, 2
  00103	75 65		 jne	 SHORT $LN11@OnRenderBo
  00105	39 9e 98 01 00
	00		 cmp	 DWORD PTR [esi+408], ebx
  0010b	74 5d		 je	 SHORT $LN11@OnRenderBo

; 992  : 			{
; 993  : 				m_pVictoriesBlue1->Render( iXPos, iYPos );

  0010d	8b 8e 98 01 00
	00		 mov	 ecx, DWORD PTR [esi+408]
  00113	66 0f 6e 45 10	 movd	 xmm0, DWORD PTR _iYPos$[ebp]
  00118	8b 01		 mov	 eax, DWORD PTR [ecx]
  0011a	53		 push	 ebx
  0011b	53		 push	 ebx
  0011c	53		 push	 ebx
  0011d	53		 push	 ebx
  0011e	51		 push	 ecx
  0011f	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00122	51		 push	 ecx
  00123	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00129	66 0f 6e 45 0c	 movd	 xmm0, DWORD PTR _iXPos$[ebp]
  0012e	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00131	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00136	ff 10		 call	 DWORD PTR [eax]

; 994  : 				if( m_pVictoriesNumBlue )

  00138	8b 8e a8 01 00
	00		 mov	 ecx, DWORD PTR [esi+424]
$LN36@OnRenderBo:
  0013e	3b cb		 cmp	 ecx, ebx
  00140	0f 84 4b 01 00
	00		 je	 $LN1@OnRenderBo

; 995  : 					m_pVictoriesNumBlue->RenderNum( iXPos + 4, iYPos + 4, rkInfo.m_iVictories );

  00146	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0014e	53		 push	 ebx
  0014f	53		 push	 ebx
  00150	53		 push	 ebx
  00151	53		 push	 ebx
  00152	51		 push	 ecx
  00153	51		 push	 ecx
  00154	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0015a	0f 57 c0	 xorps	 xmm0, xmm0
  0015d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00162	ff 77 3c	 push	 DWORD PTR [edi+60]

; 996  : 			}

  00165	e9 fa 00 00 00	 jmp	 $LN35@OnRenderBo
$LN11@OnRenderBo:

; 997  : 			else if( rkInfo.m_Team == TEAM_RED && m_pVictoriesRed1 )

  0016a	83 f9 01	 cmp	 ecx, 1
  0016d	0f 85 1e 01 00
	00		 jne	 $LN1@OnRenderBo
  00173	39 9e 9c 01 00
	00		 cmp	 DWORD PTR [esi+412], ebx
  00179	0f 84 12 01 00
	00		 je	 $LN1@OnRenderBo

; 998  : 			{
; 999  : 				m_pVictoriesRed1->Render( iXPos, iYPos );

  0017f	8b 8e 9c 01 00
	00		 mov	 ecx, DWORD PTR [esi+412]
  00185	66 0f 6e 45 10	 movd	 xmm0, DWORD PTR _iYPos$[ebp]
  0018a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0018c	53		 push	 ebx
  0018d	53		 push	 ebx
  0018e	53		 push	 ebx
  0018f	53		 push	 ebx
  00190	51		 push	 ecx
  00191	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00194	51		 push	 ecx
  00195	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0019b	66 0f 6e 45 0c	 movd	 xmm0, DWORD PTR _iXPos$[ebp]
  001a0	0f 5b c0	 cvtdq2ps xmm0, xmm0
  001a3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001a8	ff 10		 call	 DWORD PTR [eax]

; 1000 : 				if( m_pVictoriesNumRed )

  001aa	8b 8e ac 01 00
	00		 mov	 ecx, DWORD PTR [esi+428]

; 1001 : 					m_pVictoriesNumRed->RenderNum( iXPos + 4, iYPos + 4, rkInfo.m_iVictories );
; 1002 : 			}
; 1003 : 		}
; 1004 : 		else

  001b0	eb 8c		 jmp	 SHORT $LN36@OnRenderBo
$LN12@OnRenderBo:

; 1005 : 		{
; 1006 : 			if( rkInfo.m_Team == TEAM_BLUE && m_pVictoriesBlue2 )

  001b2	83 f9 02	 cmp	 ecx, 2
  001b5	75 3b		 jne	 SHORT $LN5@OnRenderBo
  001b7	39 9e a0 01 00
	00		 cmp	 DWORD PTR [esi+416], ebx
  001bd	74 33		 je	 SHORT $LN5@OnRenderBo

; 1007 : 			{	
; 1008 : 				m_pVictoriesBlue2->Render( iXPos, iYPos );

  001bf	8b 8e a0 01 00
	00		 mov	 ecx, DWORD PTR [esi+416]
  001c5	66 0f 6e 45 10	 movd	 xmm0, DWORD PTR _iYPos$[ebp]
  001ca	8b 01		 mov	 eax, DWORD PTR [ecx]
  001cc	53		 push	 ebx
  001cd	53		 push	 ebx
  001ce	53		 push	 ebx
  001cf	53		 push	 ebx
  001d0	51		 push	 ecx
  001d1	0f 5b c0	 cvtdq2ps xmm0, xmm0
  001d4	51		 push	 ecx
  001d5	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  001db	66 0f 6e 45 0c	 movd	 xmm0, DWORD PTR _iXPos$[ebp]
  001e0	0f 5b c0	 cvtdq2ps xmm0, xmm0
  001e3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e8	ff 10		 call	 DWORD PTR [eax]

; 1009 : 				if( m_pVictoriesNumBlue )

  001ea	8b 8e a8 01 00
	00		 mov	 ecx, DWORD PTR [esi+424]

; 1010 : 					m_pVictoriesNumBlue->RenderNum( iXPos + 4, iYPos + 4, min( 99, rkInfo.m_iVictories ) );
; 1011 : 			}

  001f0	eb 46		 jmp	 SHORT $LN38@OnRenderBo
$LN5@OnRenderBo:

; 1012 : 			else if( rkInfo.m_Team == TEAM_RED && m_pVictoriesRed2 )

  001f2	83 f9 01	 cmp	 ecx, 1
  001f5	0f 85 96 00 00
	00		 jne	 $LN1@OnRenderBo
  001fb	39 9e a4 01 00
	00		 cmp	 DWORD PTR [esi+420], ebx
  00201	0f 84 8a 00 00
	00		 je	 $LN1@OnRenderBo

; 1013 : 			{
; 1014 : 				m_pVictoriesRed2->Render( iXPos, iYPos );

  00207	8b 8e a4 01 00
	00		 mov	 ecx, DWORD PTR [esi+420]
  0020d	66 0f 6e 45 10	 movd	 xmm0, DWORD PTR _iYPos$[ebp]
  00212	8b 01		 mov	 eax, DWORD PTR [ecx]
  00214	53		 push	 ebx
  00215	53		 push	 ebx
  00216	53		 push	 ebx
  00217	53		 push	 ebx
  00218	51		 push	 ecx
  00219	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0021c	51		 push	 ecx
  0021d	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00223	66 0f 6e 45 0c	 movd	 xmm0, DWORD PTR _iXPos$[ebp]
  00228	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0022b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00230	ff 10		 call	 DWORD PTR [eax]

; 1015 : 				if( m_pVictoriesNumRed )

  00232	8b 8e ac 01 00
	00		 mov	 ecx, DWORD PTR [esi+428]
$LN38@OnRenderBo:
  00238	3b cb		 cmp	 ecx, ebx
  0023a	74 55		 je	 SHORT $LN1@OnRenderBo

; 1016 : 					m_pVictoriesNumRed->RenderNum( iXPos + 4, iYPos + 4, min( 99, rkInfo.m_iVictories ) );

  0023c	8b 7f 3c	 mov	 edi, DWORD PTR [edi+60]
  0023f	83 ff 63	 cmp	 edi, 99			; 00000063H
  00242	7e 03		 jle	 SHORT $LN33@OnRenderBo
  00244	6a 63		 push	 99			; 00000063H
  00246	5f		 pop	 edi
$LN33@OnRenderBo:
  00247	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0024f	53		 push	 ebx
  00250	53		 push	 ebx
  00251	53		 push	 ebx
  00252	53		 push	 ebx
  00253	51		 push	 ecx
  00254	51		 push	 ecx
  00255	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0025b	0f 57 c0	 xorps	 xmm0, xmm0
  0025e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00263	57		 push	 edi
$LN35@OnRenderBo:
  00264	8b 45 10	 mov	 eax, DWORD PTR _iYPos$[ebp]
  00267	83 c0 04	 add	 eax, 4
  0026a	0f 57 c0	 xorps	 xmm0, xmm0
  0026d	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00271	8b 45 0c	 mov	 eax, DWORD PTR _iXPos$[ebp]
  00274	51		 push	 ecx
  00275	51		 push	 ecx
  00276	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0027c	83 c0 04	 add	 eax, 4
  0027f	0f 57 c0	 xorps	 xmm0, xmm0
  00282	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00286	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0028b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?RenderNum@ioUIRenderImage@@QAEXMMHMMW4UIRenderType@@W4TextureFilterOption@@0W4RenerNumerFormatting@1@@Z
$LN1@OnRenderBo:
  00291	5f		 pop	 edi
  00292	5e		 pop	 esi
  00293	5b		 pop	 ebx

; 1017 : 			}
; 1018 : 		}
; 1019 : 	}
; 1020 : }

  00294	5d		 pop	 ebp
  00295	c2 0c 00	 ret	 12			; 0000000cH
?OnRenderBonus@RoundStateUserWnd@@IAEXABURoundInfo@@HH@Z ENDP ; RoundStateUserWnd::OnRenderBonus
_TEXT	ENDS
PUBLIC	__real@4f800000
PUBLIC	?OnRenderMonsterCoin@RoundStateUserWnd@@IAEXABURoundInfo@@HH@Z ; RoundStateUserWnd::OnRenderMonsterCoin
EXTRN	__imp_?SetHorzFormatting@ioUIRenderImage@@QAEXW4HorzFormatting@1@@Z:PROC
;	COMDAT __real@4f800000
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stdafx.h
CONST	SEGMENT
__real@4f800000 DD 04f800000r			; 4.29497e+009
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
CONST	ENDS
;	COMDAT ?OnRenderMonsterCoin@RoundStateUserWnd@@IAEXABURoundInfo@@HH@Z
_TEXT	SEGMENT
tv276 = -4						; size = 4
tv311 = 8						; size = 4
tv278 = 8						; size = 4
_rkInfo$ = 8						; size = 4
tv308 = 12						; size = 4
tv282 = 12						; size = 4
_iXPos$ = 12						; size = 4
tv294 = 16						; size = 4
_iYPos$ = 16						; size = 4
?OnRenderMonsterCoin@RoundStateUserWnd@@IAEXABURoundInfo@@HH@Z PROC ; RoundStateUserWnd::OnRenderMonsterCoin, COMDAT
; _this$ = ecx

; 1023 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 1024 : 	if( m_pGoldMonsterCoin && m_pMonsterCoin && m_pCoinNumber && m_pCoinUnlimited )

  00008	33 f6		 xor	 esi, esi
  0000a	39 b7 28 02 00
	00		 cmp	 DWORD PTR [edi+552], esi
  00010	0f 84 cc 01 00
	00		 je	 $LN1@OnRenderMo
  00016	39 b7 2c 02 00
	00		 cmp	 DWORD PTR [edi+556], esi
  0001c	0f 84 c0 01 00
	00		 je	 $LN1@OnRenderMo
  00022	8b 8f 34 02 00
	00		 mov	 ecx, DWORD PTR [edi+564]
  00028	3b ce		 cmp	 ecx, esi
  0002a	0f 84 b2 01 00
	00		 je	 $LN1@OnRenderMo
  00030	39 b7 38 02 00
	00		 cmp	 DWORD PTR [edi+568], esi
  00036	0f 84 a6 01 00
	00		 je	 $LN1@OnRenderMo

; 1025 : 	{
; 1026 : 		m_pCoinNumber->SetHorzFormatting( ioUIRenderImage::HF_CENTER );

  0003c	53		 push	 ebx
  0003d	6a 02		 push	 2
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetHorzFormatting@ioUIRenderImage@@QAEXW4HorzFormatting@1@@Z

; 1027 : 		// 몬스터 코인 표시
; 1028 : 		m_pMonsterCoin->Render( iXPos, iYPos );

  00045	8b 8f 2c 02 00
	00		 mov	 ecx, DWORD PTR [edi+556]
  0004b	66 0f 6e 45 10	 movd	 xmm0, DWORD PTR _iYPos$[ebp]
  00050	8b 5d 0c	 mov	 ebx, DWORD PTR _iXPos$[ebp]
  00053	8b 01		 mov	 eax, DWORD PTR [ecx]
  00055	56		 push	 esi
  00056	56		 push	 esi
  00057	56		 push	 esi
  00058	56		 push	 esi
  00059	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0005c	51		 push	 ecx
  0005d	51		 push	 ecx
  0005e	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00064	f3 0f 11 45 fc	 movss	 DWORD PTR tv276[ebp], xmm0
  00069	0f 57 c0	 xorps	 xmm0, xmm0
  0006c	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  00070	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00075	ff 10		 call	 DWORD PTR [eax]

; 1029 : 		if( rkInfo.m_iMonsterCoin >= FLOAT100 )

  00077	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  0007c	8b 4d 08	 mov	 ecx, DWORD PTR _rkInfo$[ebp]
  0007f	8b 49 48	 mov	 ecx, DWORD PTR [ecx+72]
  00082	89 4d 0c	 mov	 DWORD PTR tv282[ebp], ecx
  00085	db 45 0c	 fild	 DWORD PTR tv282[ebp]
  00088	89 45 0c	 mov	 DWORD PTR tv308[ebp], eax
  0008b	db 45 0c	 fild	 DWORD PTR tv308[ebp]
  0008e	85 c0		 test	 eax, eax
  00090	79 06		 jns	 SHORT $LN13@OnRenderMo
  00092	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN13@OnRenderMo:

; 1030 : 			m_pCoinUnlimited->Render( iXPos + 4, iYPos + 6 );

  00098	8b 45 10	 mov	 eax, DWORD PTR _iYPos$[ebp]
  0009b	d9 c9		 fxch	 ST(1)
  0009d	56		 push	 esi
  0009e	56		 push	 esi
  0009f	56		 push	 esi
  000a0	df f1		 fcomip	 ST(1)
  000a2	dd d8		 fstp	 ST(0)
  000a4	0f 57 c0	 xorps	 xmm0, xmm0
  000a7	56		 push	 esi
  000a8	72 2f		 jb	 SHORT $LN4@OnRenderMo
  000aa	8b 8f 38 02 00
	00		 mov	 ecx, DWORD PTR [edi+568]
  000b0	83 c0 06	 add	 eax, 6
  000b3	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000b7	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b9	51		 push	 ecx
  000ba	51		 push	 ecx
  000bb	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000c1	f3 0f 11 45 10	 movss	 DWORD PTR tv294[ebp], xmm0
  000c6	8d 53 04	 lea	 edx, DWORD PTR [ebx+4]
  000c9	0f 57 c0	 xorps	 xmm0, xmm0
  000cc	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  000d0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d5	ff 10		 call	 DWORD PTR [eax]

; 1031 : 		else

  000d7	eb 48		 jmp	 SHORT $LN3@OnRenderMo
$LN4@OnRenderMo:

; 1032 : 			m_pCoinNumber->RenderNum( iXPos + 9, iYPos + 6, rkInfo.m_iMonsterCoin );

  000d9	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  000e1	51		 push	 ecx
  000e2	51		 push	 ecx
  000e3	f3 0f 11 4c 24
	04		 movss	 DWORD PTR [esp+4], xmm1
  000e9	0f 57 c9	 xorps	 xmm1, xmm1
  000ec	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  000f1	51		 push	 ecx
  000f2	51		 push	 ecx
  000f3	83 c0 06	 add	 eax, 6
  000f6	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000fa	51		 push	 ecx
  000fb	8b 8f 34 02 00
	00		 mov	 ecx, DWORD PTR [edi+564]
  00101	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00107	f3 0f 11 45 10	 movss	 DWORD PTR tv294[ebp], xmm0
  0010c	8d 43 09	 lea	 eax, DWORD PTR [ebx+9]
  0010f	0f 57 c0	 xorps	 xmm0, xmm0
  00112	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00116	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0011b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?RenderNum@ioUIRenderImage@@QAEXMMHMMW4UIRenderType@@W4TextureFilterOption@@0W4RenerNumerFormatting@1@@Z
$LN3@OnRenderMo:

; 1033 : 		
; 1034 : 		// 골드 몬스터 코인 표시
; 1035 : 		m_pGoldMonsterCoin->Render( iXPos + 18, iYPos );

  00121	8b 8f 28 02 00
	00		 mov	 ecx, DWORD PTR [edi+552]
  00127	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR tv276[ebp]
  0012c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0012e	56		 push	 esi
  0012f	56		 push	 esi
  00130	56		 push	 esi
  00131	56		 push	 esi
  00132	51		 push	 ecx
  00133	51		 push	 ecx
  00134	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0013a	8d 53 12	 lea	 edx, DWORD PTR [ebx+18]
  0013d	0f 57 c0	 xorps	 xmm0, xmm0
  00140	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  00144	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00149	ff 10		 call	 DWORD PTR [eax]

; 1036 : 		if( rkInfo.m_iGoldMonsterCoin >= FLOAT100 )

  0014b	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  00150	8b 4d 08	 mov	 ecx, DWORD PTR _rkInfo$[ebp]
  00153	8b 49 4c	 mov	 ecx, DWORD PTR [ecx+76]
  00156	89 4d 08	 mov	 DWORD PTR tv311[ebp], ecx
  00159	db 45 08	 fild	 DWORD PTR tv311[ebp]
  0015c	89 45 08	 mov	 DWORD PTR tv278[ebp], eax
  0015f	db 45 08	 fild	 DWORD PTR tv278[ebp]
  00162	85 c0		 test	 eax, eax
  00164	79 06		 jns	 SHORT $LN14@OnRenderMo
  00166	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN14@OnRenderMo:

; 1037 : 			m_pCoinUnlimited->Render( iXPos + 22, iYPos + 6 );

  0016c	56		 push	 esi
  0016d	d9 c9		 fxch	 ST(1)
  0016f	56		 push	 esi
  00170	56		 push	 esi
  00171	df f1		 fcomip	 ST(1)
  00173	dd d8		 fstp	 ST(0)
  00175	56		 push	 esi
  00176	72 28		 jb	 SHORT $LN2@OnRenderMo
  00178	8b 8f 38 02 00
	00		 mov	 ecx, DWORD PTR [edi+568]
  0017e	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR tv294[ebp]
  00183	8b 01		 mov	 eax, DWORD PTR [ecx]
  00185	51		 push	 ecx
  00186	51		 push	 ecx
  00187	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0018d	83 c3 16	 add	 ebx, 22			; 00000016H
  00190	0f 57 c0	 xorps	 xmm0, xmm0
  00193	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  00197	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0019c	ff 10		 call	 DWORD PTR [eax]

; 1038 : 		else

  0019e	eb 41		 jmp	 SHORT $LN12@OnRenderMo
$LN2@OnRenderMo:

; 1039 : 			m_pCoinNumber->RenderNum( iXPos + 27, iYPos + 6, rkInfo.m_iGoldMonsterCoin );

  001a0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001a8	51		 push	 ecx
  001a9	51		 push	 ecx
  001aa	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  001b0	0f 57 c0	 xorps	 xmm0, xmm0
  001b3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001b8	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR tv294[ebp]
  001bd	51		 push	 ecx
  001be	51		 push	 ecx
  001bf	51		 push	 ecx
  001c0	8b 8f 34 02 00
	00		 mov	 ecx, DWORD PTR [edi+564]
  001c6	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  001cc	83 c3 1b	 add	 ebx, 27			; 0000001bH
  001cf	0f 57 c0	 xorps	 xmm0, xmm0
  001d2	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  001d6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?RenderNum@ioUIRenderImage@@QAEXMMHMMW4UIRenderType@@W4TextureFilterOption@@0W4RenerNumerFormatting@1@@Z
$LN12@OnRenderMo:
  001e1	5b		 pop	 ebx
$LN1@OnRenderMo:
  001e2	5f		 pop	 edi
  001e3	5e		 pop	 esi

; 1040 : 	}
; 1041 : }

  001e4	c9		 leave
  001e5	c2 0c 00	 ret	 12			; 0000000cH
?OnRenderMonsterCoin@RoundStateUserWnd@@IAEXABURoundInfo@@HH@Z ENDP ; RoundStateUserWnd::OnRenderMonsterCoin
_TEXT	ENDS
PUBLIC	__real@3f19999a
PUBLIC	??_C@_0CH@MBMGOCPE@RoundStateUserWnd?3?3OnRenderLadde@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?OnRenderLadderPoint@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderLadderPoint
EXTRN	__imp_?PrintText@ioFontManager@@QAEXMMMPBDH@Z:PROC
EXTRN	__imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z:PROC
EXTRN	__imp_?GetSingleton@ioStringManager@@SAAAV1@XZ:PROC
EXTRN	__imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z:PROC
EXTRN	__imp_?SetTextColor@ioFontManager@@QAEXK@Z:PROC
EXTRN	__imp_?SetTextStyle@ioFontManager@@QAEXW4TextStyle@@@Z:PROC
EXTRN	__imp_?SetBkColor@ioFontManager@@QAEXHHH@Z:PROC
EXTRN	__imp_?GetSingleton@ioFontManager@@SAAAV1@XZ:PROC
;	COMDAT __real@3f19999a
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT ??_C@_0CH@MBMGOCPE@RoundStateUserWnd?3?3OnRenderLadde@
CONST	SEGMENT
??_C@_0CH@MBMGOCPE@RoundStateUserWnd?3?3OnRenderLadde@ DB 'RoundStateUser'
	DB	'Wnd::OnRenderLadderPoint', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?OnRenderLadderPoint@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z
_TEXT	SEGMENT
_rkInfo$ = 8						; size = 4
_iXPos$ = 12						; size = 4
_iYPos$ = 16						; size = 4
_bOver$ = 20						; size = 1
?OnRenderLadderPoint@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z PROC ; RoundStateUserWnd::OnRenderLadderPoint, COMDAT
; _this$ = ecx

; 1044 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 1045 : 	g_FontMgr.SetBkColor( 0, 0, 0 );

  00005	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  0000b	57		 push	 edi
  0000c	33 db		 xor	 ebx, ebx
  0000e	53		 push	 ebx
  0000f	53		 push	 ebx
  00010	53		 push	 ebx
  00011	ff d6		 call	 esi
  00013	8b c8		 mov	 ecx, eax
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetBkColor@ioFontManager@@QAEXHHH@Z

; 1046 : 	g_FontMgr.SetTextStyle( TS_NORMAL );

  0001b	53		 push	 ebx
  0001c	ff d6		 call	 esi
  0001e	8b c8		 mov	 ecx, eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextStyle@ioFontManager@@QAEXW4TextStyle@@@Z

; 1047 : 
; 1048 : 	if( bOver )

  00026	8b 7d 08	 mov	 edi, DWORD PTR _rkInfo$[ebp]
  00029	38 5d 14	 cmp	 BYTE PTR _bOver$[ebp], bl
  0002c	74 04		 je	 SHORT $LN5@OnRenderLa

; 1049 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_WHITE );

  0002e	6a ff		 push	 -1
  00030	eb 19		 jmp	 SHORT $LN8@OnRenderLa
$LN5@OnRenderLa:

; 1050 : 	else if( rkInfo.m_Team == TEAM_BLUE )

  00032	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00035	83 f8 02	 cmp	 eax, 2
  00038	75 07		 jne	 SHORT $LN3@OnRenderLa

; 1051 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_BLUE );

  0003a	68 b2 46 16 ff	 push	 -15317326		; ff1646b2H
  0003f	eb 0a		 jmp	 SHORT $LN8@OnRenderLa
$LN3@OnRenderLa:

; 1052 : 	else if( rkInfo.m_Team == TEAM_RED )

  00041	83 f8 01	 cmp	 eax, 1
  00044	75 0f		 jne	 SHORT $LN1@OnRenderLa

; 1053 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_RED );

  00046	68 00 16 b9 ff	 push	 -4647424		; ffb91600H
$LN8@OnRenderLa:
  0004b	ff d6		 call	 esi
  0004d	8b c8		 mov	 ecx, eax
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextColor@ioFontManager@@QAEXK@Z
$LN1@OnRenderLa:

; 1054 : 	g_FontMgr.SetAlignType( TAT_CENTER );

  00055	6a 01		 push	 1
  00057	ff d6		 call	 esi
  00059	8b c8		 mov	 ecx, eax
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 1055 : 
; 1056 : 	g_FontMgr.PrintText( iXPos, iYPos, FONT_SIZE_12, STR(1), rkInfo.m_iLadderPoint );

  00061	ff 77 40	 push	 DWORD PTR [edi+64]
  00064	53		 push	 ebx
  00065	6a 01		 push	 1
  00067	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@MBMGOCPE@RoundStateUserWnd?3?3OnRenderLadde@
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00077	8b c8		 mov	 ecx, eax
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0007f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00087	50		 push	 eax
  00088	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0008b	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00091	66 0f 6e 45 10	 movd	 xmm0, DWORD PTR _iYPos$[ebp]
  00096	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00099	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0009f	66 0f 6e 45 0c	 movd	 xmm0, DWORD PTR _iXPos$[ebp]
  000a4	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000a7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ac	ff d6		 call	 esi
  000ae	8b c8		 mov	 ecx, eax
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAEXMMMPBDH@Z
  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5b		 pop	 ebx

; 1057 : }

  000b9	5d		 pop	 ebp
  000ba	c2 10 00	 ret	 16			; 00000010H
?OnRenderLadderPoint@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ENDP ; RoundStateUserWnd::OnRenderLadderPoint
_TEXT	ENDS
PUBLIC	??_C@_0CF@NELCIAGJ@RoundStateUserWnd?3?3OnRenderKillD@ ; `string'
PUBLIC	?OnRenderKillDeath@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderKillDeath
EXTRN	__imp_?PrintText@ioFontManager@@QAEXMMMPBDHH@Z:PROC
;	COMDAT ??_C@_0CF@NELCIAGJ@RoundStateUserWnd?3?3OnRenderKillD@
CONST	SEGMENT
??_C@_0CF@NELCIAGJ@RoundStateUserWnd?3?3OnRenderKillD@ DB 'RoundStateUser'
	DB	'Wnd::OnRenderKillDeath', 00H		; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?OnRenderKillDeath@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z
_TEXT	SEGMENT
_rkInfo$ = 8						; size = 4
_iXPos$ = 12						; size = 4
_iYPos$ = 16						; size = 4
_bOver$ = 20						; size = 1
?OnRenderKillDeath@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z PROC ; RoundStateUserWnd::OnRenderKillDeath, COMDAT
; _this$ = ecx

; 1060 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 1061 : 	g_FontMgr.SetBkColor( 0, 0, 0 );

  00005	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  0000b	57		 push	 edi
  0000c	33 db		 xor	 ebx, ebx
  0000e	53		 push	 ebx
  0000f	53		 push	 ebx
  00010	53		 push	 ebx
  00011	ff d6		 call	 esi
  00013	8b c8		 mov	 ecx, eax
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetBkColor@ioFontManager@@QAEXHHH@Z

; 1062 : 	g_FontMgr.SetTextStyle( TS_NORMAL );

  0001b	53		 push	 ebx
  0001c	ff d6		 call	 esi
  0001e	8b c8		 mov	 ecx, eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextStyle@ioFontManager@@QAEXW4TextStyle@@@Z

; 1063 : 
; 1064 : 	if( bOver )

  00026	8b 7d 08	 mov	 edi, DWORD PTR _rkInfo$[ebp]
  00029	38 5d 14	 cmp	 BYTE PTR _bOver$[ebp], bl
  0002c	74 04		 je	 SHORT $LN5@OnRenderKi

; 1065 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_WHITE );

  0002e	6a ff		 push	 -1
  00030	eb 19		 jmp	 SHORT $LN8@OnRenderKi
$LN5@OnRenderKi:

; 1066 : 	else if( rkInfo.m_Team == TEAM_BLUE )

  00032	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00035	83 f8 02	 cmp	 eax, 2
  00038	75 07		 jne	 SHORT $LN3@OnRenderKi

; 1067 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_BLUE );

  0003a	68 b2 46 16 ff	 push	 -15317326		; ff1646b2H
  0003f	eb 0a		 jmp	 SHORT $LN8@OnRenderKi
$LN3@OnRenderKi:

; 1068 : 	else if( rkInfo.m_Team == TEAM_RED )

  00041	83 f8 01	 cmp	 eax, 1
  00044	75 0f		 jne	 SHORT $LN1@OnRenderKi

; 1069 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_RED );

  00046	68 00 16 b9 ff	 push	 -4647424		; ffb91600H
$LN8@OnRenderKi:
  0004b	ff d6		 call	 esi
  0004d	8b c8		 mov	 ecx, eax
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextColor@ioFontManager@@QAEXK@Z
$LN1@OnRenderKi:

; 1070 : 	g_FontMgr.SetAlignType( TAT_CENTER );

  00055	6a 01		 push	 1
  00057	ff d6		 call	 esi
  00059	8b c8		 mov	 ecx, eax
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 1071 : 
; 1072 : 	g_FontMgr.PrintText( iXPos, iYPos, FONT_SIZE_12, STR(1), rkInfo.m_iUniqueTotalKill, rkInfo.m_iUniqueTotalDeath );

  00061	ff 77 38	 push	 DWORD PTR [edi+56]
  00064	ff 77 34	 push	 DWORD PTR [edi+52]
  00067	53		 push	 ebx
  00068	6a 01		 push	 1
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NELCIAGJ@RoundStateUserWnd?3?3OnRenderKillD@
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  0007a	8b c8		 mov	 ecx, eax
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  00082	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  0008a	50		 push	 eax
  0008b	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0008e	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00094	66 0f 6e 45 10	 movd	 xmm0, DWORD PTR _iYPos$[ebp]
  00099	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0009c	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000a2	66 0f 6e 45 0c	 movd	 xmm0, DWORD PTR _iXPos$[ebp]
  000a7	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000aa	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000af	ff d6		 call	 esi
  000b1	8b c8		 mov	 ecx, eax
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAEXMMMPBDHH@Z
  000b9	5f		 pop	 edi
  000ba	5e		 pop	 esi
  000bb	5b		 pop	 ebx

; 1073 : }

  000bc	5d		 pop	 ebp
  000bd	c2 10 00	 ret	 16			; 00000010H
?OnRenderKillDeath@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ENDP ; RoundStateUserWnd::OnRenderKillDeath
_TEXT	ENDS
PUBLIC	??_C@_0CG@EMBEHADG@RoundStateUserWnd?3?3OnRenderContr@ ; `string'
PUBLIC	?OnRenderContribute@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderContribute
EXTRN	?IsTournamentModeType@ioBattleRoomMgr@@QAE_NXZ:PROC ; ioBattleRoomMgr::IsTournamentModeType
EXTRN	?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ:PROC	; ioBattleRoomMgr::GetSingleton
;	COMDAT ??_C@_0CG@EMBEHADG@RoundStateUserWnd?3?3OnRenderContr@
CONST	SEGMENT
??_C@_0CG@EMBEHADG@RoundStateUserWnd?3?3OnRenderContr@ DB 'RoundStateUser'
	DB	'Wnd::OnRenderContribute', 00H		; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?OnRenderContribute@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z
_TEXT	SEGMENT
_rkInfo$ = 8						; size = 4
_iXPos$ = 12						; size = 4
_iYPos$ = 16						; size = 4
_bOver$ = 20						; size = 1
?OnRenderContribute@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z PROC ; RoundStateUserWnd::OnRenderContribute, COMDAT
; _this$ = ecx

; 1076 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1077 : 	if( g_BattleRoomMgr.IsTournamentModeType() )

  00003	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  00008	8b c8		 mov	 ecx, eax
  0000a	e8 00 00 00 00	 call	 ?IsTournamentModeType@ioBattleRoomMgr@@QAE_NXZ ; ioBattleRoomMgr::IsTournamentModeType
  0000f	84 c0		 test	 al, al
  00011	0f 85 b6 00 00
	00		 jne	 $LN7@OnRenderCo

; 1078 : 		return;
; 1079 : 
; 1080 : 	g_FontMgr.SetBkColor( 0, 0, 0 );

  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  0001f	57		 push	 edi
  00020	33 db		 xor	 ebx, ebx
  00022	53		 push	 ebx
  00023	53		 push	 ebx
  00024	53		 push	 ebx
  00025	ff d6		 call	 esi
  00027	8b c8		 mov	 ecx, eax
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetBkColor@ioFontManager@@QAEXHHH@Z

; 1081 : 	g_FontMgr.SetTextStyle( TS_NORMAL );

  0002f	53		 push	 ebx
  00030	ff d6		 call	 esi
  00032	8b c8		 mov	 ecx, eax
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextStyle@ioFontManager@@QAEXW4TextStyle@@@Z

; 1082 : 
; 1083 : 	if( bOver )

  0003a	8b 7d 08	 mov	 edi, DWORD PTR _rkInfo$[ebp]
  0003d	38 5d 14	 cmp	 BYTE PTR _bOver$[ebp], bl
  00040	74 04		 je	 SHORT $LN5@OnRenderCo

; 1084 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_WHITE );

  00042	6a ff		 push	 -1
  00044	eb 19		 jmp	 SHORT $LN9@OnRenderCo
$LN5@OnRenderCo:

; 1085 : 	else if( rkInfo.m_Team == TEAM_BLUE )

  00046	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00049	83 f8 02	 cmp	 eax, 2
  0004c	75 07		 jne	 SHORT $LN3@OnRenderCo

; 1086 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_BLUE );

  0004e	68 b2 46 16 ff	 push	 -15317326		; ff1646b2H
  00053	eb 0a		 jmp	 SHORT $LN9@OnRenderCo
$LN3@OnRenderCo:

; 1087 : 	else if( rkInfo.m_Team == TEAM_RED )

  00055	83 f8 01	 cmp	 eax, 1
  00058	75 0f		 jne	 SHORT $LN1@OnRenderCo

; 1088 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_RED );

  0005a	68 00 16 b9 ff	 push	 -4647424		; ffb91600H
$LN9@OnRenderCo:
  0005f	ff d6		 call	 esi
  00061	8b c8		 mov	 ecx, eax
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextColor@ioFontManager@@QAEXK@Z
$LN1@OnRenderCo:

; 1089 : 	g_FontMgr.SetAlignType( TAT_CENTER );

  00069	6a 01		 push	 1
  0006b	ff d6		 call	 esi
  0006d	8b c8		 mov	 ecx, eax
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 1090 : 
; 1091 : 	g_FontMgr.PrintText( iXPos, iYPos, FONT_SIZE_12, STR(1), rkInfo.m_iContributePer );

  00075	ff 77 18	 push	 DWORD PTR [edi+24]
  00078	53		 push	 ebx
  00079	6a 01		 push	 1
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@EMBEHADG@RoundStateUserWnd?3?3OnRenderContr@
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  0008b	8b c8		 mov	 ecx, eax
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  00093	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  0009b	50		 push	 eax
  0009c	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0009f	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  000a5	66 0f 6e 45 10	 movd	 xmm0, DWORD PTR _iYPos$[ebp]
  000aa	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000ad	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000b3	66 0f 6e 45 0c	 movd	 xmm0, DWORD PTR _iXPos$[ebp]
  000b8	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000bb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c0	ff d6		 call	 esi
  000c2	8b c8		 mov	 ecx, eax
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAEXMMMPBDH@Z
  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
$LN7@OnRenderCo:

; 1092 : }

  000cd	5d		 pop	 ebp
  000ce	c2 10 00	 ret	 16			; 00000010H
?OnRenderContribute@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ENDP ; RoundStateUserWnd::OnRenderContribute
_TEXT	ENDS
PUBLIC	??_C@_0CE@GHDNLAHN@RoundStateUserWnd?3?3OnRenderFight@ ; `string'
PUBLIC	?OnRenderFightWin@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderFightWin
;	COMDAT ??_C@_0CE@GHDNLAHN@RoundStateUserWnd?3?3OnRenderFight@
CONST	SEGMENT
??_C@_0CE@GHDNLAHN@RoundStateUserWnd?3?3OnRenderFight@ DB 'RoundStateUser'
	DB	'Wnd::OnRenderFightWin', 00H			; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?OnRenderFightWin@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z
_TEXT	SEGMENT
_rkInfo$ = 8						; size = 4
_iXPos$ = 12						; size = 4
_iYPos$ = 16						; size = 4
_bOver$ = 20						; size = 1
?OnRenderFightWin@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z PROC ; RoundStateUserWnd::OnRenderFightWin, COMDAT
; _this$ = ecx

; 1095 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 1096 : 	g_FontMgr.SetBkColor( 0, 0, 0 );

  00005	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  0000b	57		 push	 edi
  0000c	33 db		 xor	 ebx, ebx
  0000e	53		 push	 ebx
  0000f	53		 push	 ebx
  00010	53		 push	 ebx
  00011	ff d6		 call	 esi
  00013	8b c8		 mov	 ecx, eax
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetBkColor@ioFontManager@@QAEXHHH@Z

; 1097 : 	g_FontMgr.SetTextStyle( TS_NORMAL );

  0001b	53		 push	 ebx
  0001c	ff d6		 call	 esi
  0001e	8b c8		 mov	 ecx, eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextStyle@ioFontManager@@QAEXW4TextStyle@@@Z

; 1098 : 
; 1099 : 	if( bOver )

  00026	8b 7d 08	 mov	 edi, DWORD PTR _rkInfo$[ebp]
  00029	38 5d 14	 cmp	 BYTE PTR _bOver$[ebp], bl
  0002c	74 04		 je	 SHORT $LN5@OnRenderFi

; 1100 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_WHITE );

  0002e	6a ff		 push	 -1
  00030	eb 19		 jmp	 SHORT $LN8@OnRenderFi
$LN5@OnRenderFi:

; 1101 : 	else if( rkInfo.m_Team == TEAM_BLUE )

  00032	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00035	83 f8 02	 cmp	 eax, 2
  00038	75 07		 jne	 SHORT $LN3@OnRenderFi

; 1102 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_BLUE );

  0003a	68 b2 46 16 ff	 push	 -15317326		; ff1646b2H
  0003f	eb 0a		 jmp	 SHORT $LN8@OnRenderFi
$LN3@OnRenderFi:

; 1103 : 	else if( rkInfo.m_Team == TEAM_RED )

  00041	83 f8 01	 cmp	 eax, 1
  00044	75 0f		 jne	 SHORT $LN1@OnRenderFi

; 1104 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_RED );

  00046	68 00 16 b9 ff	 push	 -4647424		; ffb91600H
$LN8@OnRenderFi:
  0004b	ff d6		 call	 esi
  0004d	8b c8		 mov	 ecx, eax
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextColor@ioFontManager@@QAEXK@Z
$LN1@OnRenderFi:

; 1105 : 	g_FontMgr.SetAlignType( TAT_CENTER );

  00055	6a 01		 push	 1
  00057	ff d6		 call	 esi
  00059	8b c8		 mov	 ecx, eax
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 1106 : 
; 1107 : 	g_FontMgr.PrintText( iXPos, iYPos, FONT_SIZE_12, STR(1), rkInfo.m_iFightWin );

  00061	ff 77 68	 push	 DWORD PTR [edi+104]
  00064	53		 push	 ebx
  00065	6a 01		 push	 1
  00067	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@GHDNLAHN@RoundStateUserWnd?3?3OnRenderFight@
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00077	8b c8		 mov	 ecx, eax
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0007f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00087	50		 push	 eax
  00088	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0008b	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00091	66 0f 6e 45 10	 movd	 xmm0, DWORD PTR _iYPos$[ebp]
  00096	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00099	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0009f	66 0f 6e 45 0c	 movd	 xmm0, DWORD PTR _iXPos$[ebp]
  000a4	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000a7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ac	ff d6		 call	 esi
  000ae	8b c8		 mov	 ecx, eax
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAEXMMMPBDH@Z
  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5b		 pop	 ebx

; 1108 : }

  000b9	5d		 pop	 ebp
  000ba	c2 10 00	 ret	 16			; 00000010H
?OnRenderFightWin@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ENDP ; RoundStateUserWnd::OnRenderFightWin
_TEXT	ENDS
PUBLIC	??_C@_0CF@BAPMGGLP@RoundStateUserWnd?3?3OnRenderFight@ ; `string'
PUBLIC	?OnRenderFightLose@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderFightLose
;	COMDAT ??_C@_0CF@BAPMGGLP@RoundStateUserWnd?3?3OnRenderFight@
CONST	SEGMENT
??_C@_0CF@BAPMGGLP@RoundStateUserWnd?3?3OnRenderFight@ DB 'RoundStateUser'
	DB	'Wnd::OnRenderFightLose', 00H		; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?OnRenderFightLose@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z
_TEXT	SEGMENT
_rkInfo$ = 8						; size = 4
_iXPos$ = 12						; size = 4
_iYPos$ = 16						; size = 4
_bOver$ = 20						; size = 1
?OnRenderFightLose@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z PROC ; RoundStateUserWnd::OnRenderFightLose, COMDAT
; _this$ = ecx

; 1111 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 1112 : 	g_FontMgr.SetBkColor( 0, 0, 0 );

  00005	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  0000b	57		 push	 edi
  0000c	33 db		 xor	 ebx, ebx
  0000e	53		 push	 ebx
  0000f	53		 push	 ebx
  00010	53		 push	 ebx
  00011	ff d6		 call	 esi
  00013	8b c8		 mov	 ecx, eax
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetBkColor@ioFontManager@@QAEXHHH@Z

; 1113 : 	g_FontMgr.SetTextStyle( TS_NORMAL );

  0001b	53		 push	 ebx
  0001c	ff d6		 call	 esi
  0001e	8b c8		 mov	 ecx, eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextStyle@ioFontManager@@QAEXW4TextStyle@@@Z

; 1114 : 
; 1115 : 	if( bOver )

  00026	8b 7d 08	 mov	 edi, DWORD PTR _rkInfo$[ebp]
  00029	38 5d 14	 cmp	 BYTE PTR _bOver$[ebp], bl
  0002c	74 04		 je	 SHORT $LN5@OnRenderFi@2

; 1116 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_WHITE );

  0002e	6a ff		 push	 -1
  00030	eb 19		 jmp	 SHORT $LN8@OnRenderFi@2
$LN5@OnRenderFi@2:

; 1117 : 	else if( rkInfo.m_Team == TEAM_BLUE )

  00032	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00035	83 f8 02	 cmp	 eax, 2
  00038	75 07		 jne	 SHORT $LN3@OnRenderFi@2

; 1118 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_BLUE );

  0003a	68 b2 46 16 ff	 push	 -15317326		; ff1646b2H
  0003f	eb 0a		 jmp	 SHORT $LN8@OnRenderFi@2
$LN3@OnRenderFi@2:

; 1119 : 	else if( rkInfo.m_Team == TEAM_RED )

  00041	83 f8 01	 cmp	 eax, 1
  00044	75 0f		 jne	 SHORT $LN1@OnRenderFi@2

; 1120 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_RED );

  00046	68 00 16 b9 ff	 push	 -4647424		; ffb91600H
$LN8@OnRenderFi@2:
  0004b	ff d6		 call	 esi
  0004d	8b c8		 mov	 ecx, eax
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextColor@ioFontManager@@QAEXK@Z
$LN1@OnRenderFi@2:

; 1121 : 	g_FontMgr.SetAlignType( TAT_CENTER );

  00055	6a 01		 push	 1
  00057	ff d6		 call	 esi
  00059	8b c8		 mov	 ecx, eax
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 1122 : 	
; 1123 : 	g_FontMgr.PrintText( iXPos, iYPos, FONT_SIZE_12, STR(1), rkInfo.m_iFightLose );

  00061	ff 77 6c	 push	 DWORD PTR [edi+108]
  00064	53		 push	 ebx
  00065	6a 01		 push	 1
  00067	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@BAPMGGLP@RoundStateUserWnd?3?3OnRenderFight@
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00077	8b c8		 mov	 ecx, eax
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0007f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00087	50		 push	 eax
  00088	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0008b	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00091	66 0f 6e 45 10	 movd	 xmm0, DWORD PTR _iYPos$[ebp]
  00096	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00099	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0009f	66 0f 6e 45 0c	 movd	 xmm0, DWORD PTR _iXPos$[ebp]
  000a4	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000a7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ac	ff d6		 call	 esi
  000ae	8b c8		 mov	 ecx, eax
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAEXMMMPBDH@Z
  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5b		 pop	 ebx

; 1124 : }

  000b9	5d		 pop	 ebp
  000ba	c2 10 00	 ret	 16			; 00000010H
?OnRenderFightLose@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ENDP ; RoundStateUserWnd::OnRenderFightLose
_TEXT	ENDS
PUBLIC	??_C@_0CA@OFKNPED@RoundStateUserWnd?3?3OnRenderGoal?$AA@ ; `string'
PUBLIC	?OnRenderGoal@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderGoal
;	COMDAT ??_C@_0CA@OFKNPED@RoundStateUserWnd?3?3OnRenderGoal?$AA@
CONST	SEGMENT
??_C@_0CA@OFKNPED@RoundStateUserWnd?3?3OnRenderGoal?$AA@ DB 'RoundStateUs'
	DB	'erWnd::OnRenderGoal', 00H			; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?OnRenderGoal@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z
_TEXT	SEGMENT
_rkInfo$ = 8						; size = 4
_iXPos$ = 12						; size = 4
_iYPos$ = 16						; size = 4
_bOver$ = 20						; size = 1
?OnRenderGoal@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z PROC ; RoundStateUserWnd::OnRenderGoal, COMDAT
; _this$ = ecx

; 1127 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 1128 : 	g_FontMgr.SetBkColor( 0, 0, 0 );

  00005	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  0000b	57		 push	 edi
  0000c	33 db		 xor	 ebx, ebx
  0000e	53		 push	 ebx
  0000f	53		 push	 ebx
  00010	53		 push	 ebx
  00011	ff d6		 call	 esi
  00013	8b c8		 mov	 ecx, eax
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetBkColor@ioFontManager@@QAEXHHH@Z

; 1129 : 	g_FontMgr.SetTextStyle( TS_NORMAL );

  0001b	53		 push	 ebx
  0001c	ff d6		 call	 esi
  0001e	8b c8		 mov	 ecx, eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextStyle@ioFontManager@@QAEXW4TextStyle@@@Z

; 1130 : 
; 1131 : 	if( bOver )

  00026	8b 7d 08	 mov	 edi, DWORD PTR _rkInfo$[ebp]
  00029	38 5d 14	 cmp	 BYTE PTR _bOver$[ebp], bl
  0002c	74 04		 je	 SHORT $LN5@OnRenderGo

; 1132 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_WHITE );

  0002e	6a ff		 push	 -1
  00030	eb 19		 jmp	 SHORT $LN8@OnRenderGo
$LN5@OnRenderGo:

; 1133 : 	else if( rkInfo.m_Team == TEAM_BLUE )

  00032	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00035	83 f8 02	 cmp	 eax, 2
  00038	75 07		 jne	 SHORT $LN3@OnRenderGo

; 1134 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_BLUE );

  0003a	68 b2 46 16 ff	 push	 -15317326		; ff1646b2H
  0003f	eb 0a		 jmp	 SHORT $LN8@OnRenderGo
$LN3@OnRenderGo:

; 1135 : 	else if( rkInfo.m_Team == TEAM_RED )

  00041	83 f8 01	 cmp	 eax, 1
  00044	75 0f		 jne	 SHORT $LN1@OnRenderGo

; 1136 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_RED );

  00046	68 00 16 b9 ff	 push	 -4647424		; ffb91600H
$LN8@OnRenderGo:
  0004b	ff d6		 call	 esi
  0004d	8b c8		 mov	 ecx, eax
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextColor@ioFontManager@@QAEXK@Z
$LN1@OnRenderGo:

; 1137 : 	g_FontMgr.SetAlignType( TAT_CENTER );

  00055	6a 01		 push	 1
  00057	ff d6		 call	 esi
  00059	8b c8		 mov	 ecx, eax
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 1138 : 
; 1139 : 	g_FontMgr.PrintText( iXPos, iYPos, FONT_SIZE_12, STR(1), rkInfo.m_iGoal, rkInfo.m_iGoalAssist );

  00061	ff 77 64	 push	 DWORD PTR [edi+100]
  00064	ff 77 60	 push	 DWORD PTR [edi+96]
  00067	53		 push	 ebx
  00068	6a 01		 push	 1
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@OFKNPED@RoundStateUserWnd?3?3OnRenderGoal?$AA@
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  0007a	8b c8		 mov	 ecx, eax
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  00082	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  0008a	50		 push	 eax
  0008b	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0008e	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00094	66 0f 6e 45 10	 movd	 xmm0, DWORD PTR _iYPos$[ebp]
  00099	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0009c	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000a2	66 0f 6e 45 0c	 movd	 xmm0, DWORD PTR _iXPos$[ebp]
  000a7	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000aa	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000af	ff d6		 call	 esi
  000b1	8b c8		 mov	 ecx, eax
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAEXMMMPBDHH@Z
  000b9	5f		 pop	 edi
  000ba	5e		 pop	 esi
  000bb	5b		 pop	 ebx

; 1140 : }

  000bc	5d		 pop	 ebp
  000bd	c2 10 00	 ret	 16			; 00000010H
?OnRenderGoal@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ENDP ; RoundStateUserWnd::OnRenderGoal
_TEXT	ENDS
PUBLIC	??_C@_01GFHCPBMG@C?$AA@				; `string'
PUBLIC	??_C@_01HMGJMAIH@B?$AA@				; `string'
PUBLIC	??_C@_01FHEEJDEE@A?$AA@				; `string'
PUBLIC	??_C@_01CPLAODJH@S?$AA@				; `string'
PUBLIC	_rkInfo$GSCopy$
PUBLIC	?OnRenderTowerDefRank@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderTowerDefRank
EXTRN	__imp_?PrintText@ioFontManager@@QAAXMMMPBDZZ:PROC
EXTRN	__imp_?c_str@ioHashString@@QBEPBDXZ:PROC
EXTRN	__imp_??4ioHashString@@QAEAAV0@PBD@Z:PROC
EXTRN	__imp_?Clear@ioHashString@@QAEXXZ:PROC
EXTRN	?ContributeRank@ioPlayStage@@QAEHABVioHashString@@AAH111@Z:PROC ; ioPlayStage::ContributeRank
EXTRN	__imp_??0ioHashString@@QAE@XZ:PROC
EXTRN	__EH_epilog3_GS:PROC
EXTRN	__EH_prolog3_GS:PROC
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT
??_C@_01GFHCPBMG@C?$AA@ DB 'C', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HMGJMAIH@B?$AA@
CONST	SEGMENT
??_C@_01HMGJMAIH@B?$AA@ DB 'B', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01FHEEJDEE@A?$AA@
CONST	SEGMENT
??_C@_01FHEEJDEE@A?$AA@ DB 'A', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01CPLAODJH@S?$AA@
CONST	SEGMENT
??_C@_01CPLAODJH@S?$AA@ DB 'S', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?OnRenderTowerDefRank@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnRenderTowerDefRank@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z$0
__ehfuncinfo$?OnRenderTowerDefRank@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?OnRenderTowerDefRank@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ?OnRenderTowerDefRank@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z
_TEXT	SEGMENT
_szRank$ = -56						; size = 16
tv205 = -40						; size = 4
_rkInfo$GSCopy$ = -36					; size = 4
_nPosX$ = -36						; size = 4
_nRank$ = -32						; size = 16
__$EHRec$ = -12						; size = 12
_rkInfo$ = 8						; size = 4
_iXPos$ = 12						; size = 4
_iYPos$ = 16						; size = 4
_bOver$ = 20						; size = 1
?OnRenderTowerDefRank@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z PROC ; RoundStateUserWnd::OnRenderTowerDefRank, COMDAT
; _this$ = ecx

; 1162 : {

  00000	6a 2c		 push	 44			; 0000002cH
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?OnRenderTowerDefRank@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000c	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$[ebp]

; 1163 : 	g_FontMgr.SetBkColor( 0, 0, 0 );

  0000f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  00015	33 ff		 xor	 edi, edi
  00017	57		 push	 edi
  00018	57		 push	 edi
  00019	57		 push	 edi
  0001a	8b d9		 mov	 ebx, ecx

; 1170 : 
; 1171 : 	g_FontMgr.SetAlignType( TAT_CENTER );

  0001c	89 45 dc	 mov	 DWORD PTR _rkInfo$GSCopy$[ebp], eax
  0001f	ff d6		 call	 esi
  00021	8b c8		 mov	 ecx, eax
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetBkColor@ioFontManager@@QAEXHHH@Z
  00029	57		 push	 edi
  0002a	ff d6		 call	 esi
  0002c	8b c8		 mov	 ecx, eax
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextStyle@ioFontManager@@QAEXW4TextStyle@@@Z
  00034	80 7d 14 00	 cmp	 BYTE PTR _bOver$[ebp], 0
  00038	74 04		 je	 SHORT $LN12@OnRenderTo@2

; 1164 : 	g_FontMgr.SetTextStyle( TS_NORMAL );
; 1165 : 
; 1166 : 	if( bOver )
; 1167 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_WHITE );

  0003a	6a ff		 push	 -1

; 1168 : 	else 

  0003c	eb 05		 jmp	 SHORT $LN19@OnRenderTo@2
$LN12@OnRenderTo@2:

; 1169 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_BLUE );

  0003e	68 b2 46 16 ff	 push	 -15317326		; ff1646b2H
$LN19@OnRenderTo@2:
  00043	ff d6		 call	 esi
  00045	8b c8		 mov	 ecx, eax
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextColor@ioFontManager@@QAEXK@Z

; 1170 : 
; 1171 : 	g_FontMgr.SetAlignType( TAT_CENTER );

  0004d	6a 01		 push	 1
  0004f	ff d6		 call	 esi
  00051	8b c8		 mov	 ecx, eax
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 1172 : 
; 1173 : 	ioHashString szRank;

  00059	8d 4d c8	 lea	 ecx, DWORD PTR _szRank$[ebp]
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ

; 1174 : 
; 1175 : 	int nRank[4];
; 1176 : 	nRank[0] = 3;
; 1177 : 	nRank[1] = 3;
; 1178 : 	nRank[2] = 3;
; 1179 : 	nRank[3] = 3;
; 1180 : 
; 1181 : 	int nPlayer = 0;
; 1182 : 
; 1183 : 	if(m_pPlayStage)

  00062	8b 8b 94 02 00
	00		 mov	 ecx, DWORD PTR [ebx+660]
  00068	6a 03		 push	 3
  0006a	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  0006d	5f		 pop	 edi
  0006e	89 7d e0	 mov	 DWORD PTR _nRank$[ebp], edi
  00071	89 7d e4	 mov	 DWORD PTR _nRank$[ebp+4], edi
  00074	89 7d e8	 mov	 DWORD PTR _nRank$[ebp+8], edi
  00077	89 7d ec	 mov	 DWORD PTR _nRank$[ebp+12], edi
  0007a	85 c9		 test	 ecx, ecx
  0007c	74 18		 je	 SHORT $LN10@OnRenderTo@2

; 1184 : 		nPlayer = m_pPlayStage->ContributeRank(rkInfo.m_szName, nRank[0], nRank[1], nRank[2], nRank[3]);

  0007e	8d 45 ec	 lea	 eax, DWORD PTR _nRank$[ebp+12]
  00081	50		 push	 eax
  00082	8d 45 e8	 lea	 eax, DWORD PTR _nRank$[ebp+8]
  00085	50		 push	 eax
  00086	8d 45 e4	 lea	 eax, DWORD PTR _nRank$[ebp+4]
  00089	50		 push	 eax
  0008a	8d 45 e0	 lea	 eax, DWORD PTR _nRank$[ebp]
  0008d	50		 push	 eax
  0008e	ff 75 dc	 push	 DWORD PTR _rkInfo$GSCopy$[ebp]
  00091	e8 00 00 00 00	 call	 ?ContributeRank@ioPlayStage@@QAEHABVioHashString@@AAH111@Z ; ioPlayStage::ContributeRank
$LN10@OnRenderTo@2:

; 1185 : 
; 1186 : 	int nPosX = iXPos;

  00096	8b 45 0c	 mov	 eax, DWORD PTR _iXPos$[ebp]

; 1199 : 	}
; 1200 : }

  00099	66 0f 6e 45 10	 movd	 xmm0, DWORD PTR _iYPos$[ebp]
  0009e	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000a1	89 45 dc	 mov	 DWORD PTR _nPosX$[ebp], eax
  000a4	33 db		 xor	 ebx, ebx
  000a6	f3 0f 11 45 d8	 movss	 DWORD PTR tv205[ebp], xmm0
$LL9@OnRenderTo@2:

; 1187 : 
; 1188 : 	for(int i = 0; i < 3; i++)
; 1189 : 	{
; 1190 : 		szRank.Clear();

  000ab	8d 4d c8	 lea	 ecx, DWORD PTR _szRank$[ebp]
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Clear@ioHashString@@QAEXXZ

; 1191 : 
; 1192 : 		if( nRank[i] == 0) szRank = "S";

  000b4	8b 44 9d e0	 mov	 eax, DWORD PTR _nRank$[ebp+ebx*4]
  000b8	85 c0		 test	 eax, eax
  000ba	75 07		 jne	 SHORT $LN6@OnRenderTo@2
  000bc	68 00 00 00 00	 push	 OFFSET ??_C@_01CPLAODJH@S?$AA@
  000c1	eb 1d		 jmp	 SHORT $LN20@OnRenderTo@2
$LN6@OnRenderTo@2:

; 1193 : 		else if( nRank[i] == 1) szRank = "A";

  000c3	83 f8 01	 cmp	 eax, 1
  000c6	75 07		 jne	 SHORT $LN4@OnRenderTo@2
  000c8	68 00 00 00 00	 push	 OFFSET ??_C@_01FHEEJDEE@A?$AA@
  000cd	eb 11		 jmp	 SHORT $LN20@OnRenderTo@2
$LN4@OnRenderTo@2:

; 1194 : 		else if( nRank[i] == 2) szRank = "B";

  000cf	83 f8 02	 cmp	 eax, 2
  000d2	75 07		 jne	 SHORT $LN2@OnRenderTo@2
  000d4	68 00 00 00 00	 push	 OFFSET ??_C@_01HMGJMAIH@B?$AA@
  000d9	eb 05		 jmp	 SHORT $LN20@OnRenderTo@2
$LN2@OnRenderTo@2:

; 1195 : 		else szRank = "C";

  000db	68 00 00 00 00	 push	 OFFSET ??_C@_01GFHCPBMG@C?$AA@
$LN20@OnRenderTo@2:
  000e0	8d 4d c8	 lea	 ecx, DWORD PTR _szRank$[ebp]
  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 1196 : 
; 1197 : 		g_FontMgr.PrintText( nPosX, iYPos, FONT_SIZE_12, szRank.c_str());	

  000e9	8d 4d c8	 lea	 ecx, DWORD PTR _szRank$[ebp]
  000ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  000f2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  000fa	50		 push	 eax
  000fb	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000fe	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00104	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR tv205[ebp]
  00109	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0010f	66 0f 6e 45 dc	 movd	 xmm0, DWORD PTR _nPosX$[ebp]
  00114	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00117	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0011c	ff d6		 call	 esi
  0011e	50		 push	 eax
  0011f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAAXMMMPBDZZ

; 1198 : 		nPosX += 51;

  00125	83 45 dc 33	 add	 DWORD PTR _nPosX$[ebp], 51 ; 00000033H
  00129	83 c4 14	 add	 esp, 20			; 00000014H
  0012c	43		 inc	 ebx
  0012d	3b df		 cmp	 ebx, edi
  0012f	0f 8c 76 ff ff
	ff		 jl	 $LL9@OnRenderTo@2

; 1199 : 	}
; 1200 : }

  00135	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00139	8d 4d c8	 lea	 ecx, DWORD PTR _szRank$[ebp]
  0013c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00142	e8 00 00 00 00	 call	 __EH_epilog3_GS
  00147	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnRenderTowerDefRank@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z$0:
  00000	8d 4d c8	 lea	 ecx, DWORD PTR _szRank$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$?OnRenderTowerDefRank@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnRenderTowerDefRank@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnRenderTowerDefRank@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ENDP ; RoundStateUserWnd::OnRenderTowerDefRank
PUBLIC	??_C@_0CF@GOKIIFDL@RoundStateUserWnd?3?3OnRenderStarC@ ; `string'
PUBLIC	?OnRenderStarCount@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderStarCount
;	COMDAT ??_C@_0CF@GOKIIFDL@RoundStateUserWnd?3?3OnRenderStarC@
CONST	SEGMENT
??_C@_0CF@GOKIIFDL@RoundStateUserWnd?3?3OnRenderStarC@ DB 'RoundStateUser'
	DB	'Wnd::OnRenderStarCount', 00H		; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?OnRenderStarCount@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z
_TEXT	SEGMENT
_rkInfo$ = 8						; size = 4
_iXPos$ = 12						; size = 4
_iYPos$ = 16						; size = 4
_bOver$ = 20						; size = 1
?OnRenderStarCount@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z PROC ; RoundStateUserWnd::OnRenderStarCount, COMDAT
; _this$ = ecx

; 1203 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 1204 : 	g_FontMgr.SetBkColor( 0, 0, 0 );

  00005	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  0000b	57		 push	 edi
  0000c	33 db		 xor	 ebx, ebx
  0000e	53		 push	 ebx
  0000f	53		 push	 ebx
  00010	53		 push	 ebx
  00011	ff d6		 call	 esi
  00013	8b c8		 mov	 ecx, eax
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetBkColor@ioFontManager@@QAEXHHH@Z

; 1205 : 	g_FontMgr.SetTextStyle( TS_NORMAL );

  0001b	53		 push	 ebx
  0001c	ff d6		 call	 esi
  0001e	8b c8		 mov	 ecx, eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextStyle@ioFontManager@@QAEXW4TextStyle@@@Z

; 1206 : 
; 1207 : 	if( bOver )

  00026	8b 7d 08	 mov	 edi, DWORD PTR _rkInfo$[ebp]
  00029	38 5d 14	 cmp	 BYTE PTR _bOver$[ebp], bl
  0002c	74 04		 je	 SHORT $LN5@OnRenderSt

; 1208 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_WHITE );

  0002e	6a ff		 push	 -1
  00030	eb 19		 jmp	 SHORT $LN8@OnRenderSt
$LN5@OnRenderSt:

; 1209 : 	else if( rkInfo.m_Team == TEAM_BLUE )

  00032	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00035	83 f8 02	 cmp	 eax, 2
  00038	75 07		 jne	 SHORT $LN3@OnRenderSt

; 1210 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_BLUE );

  0003a	68 b2 46 16 ff	 push	 -15317326		; ff1646b2H
  0003f	eb 0a		 jmp	 SHORT $LN8@OnRenderSt
$LN3@OnRenderSt:

; 1211 : 	else if( rkInfo.m_Team == TEAM_RED )

  00041	83 f8 01	 cmp	 eax, 1
  00044	75 0f		 jne	 SHORT $LN1@OnRenderSt

; 1212 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_RED );

  00046	68 00 16 b9 ff	 push	 -4647424		; ffb91600H
$LN8@OnRenderSt:
  0004b	ff d6		 call	 esi
  0004d	8b c8		 mov	 ecx, eax
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextColor@ioFontManager@@QAEXK@Z
$LN1@OnRenderSt:

; 1213 : 	g_FontMgr.SetAlignType( TAT_CENTER );

  00055	6a 01		 push	 1
  00057	ff d6		 call	 esi
  00059	8b c8		 mov	 ecx, eax
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 1214 : 
; 1215 : 	g_FontMgr.PrintText( iXPos, iYPos, FONT_SIZE_12, STR(1), rkInfo.m_iStarCnt );

  00061	ff 77 74	 push	 DWORD PTR [edi+116]
  00064	53		 push	 ebx
  00065	6a 01		 push	 1
  00067	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@GOKIIFDL@RoundStateUserWnd?3?3OnRenderStarC@
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00077	8b c8		 mov	 ecx, eax
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0007f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00087	50		 push	 eax
  00088	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0008b	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00091	66 0f 6e 45 10	 movd	 xmm0, DWORD PTR _iYPos$[ebp]
  00096	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00099	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0009f	66 0f 6e 45 0c	 movd	 xmm0, DWORD PTR _iXPos$[ebp]
  000a4	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000a7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ac	ff d6		 call	 esi
  000ae	8b c8		 mov	 ecx, eax
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAEXMMMPBDH@Z
  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5b		 pop	 ebx

; 1216 : }

  000b9	5d		 pop	 ebp
  000ba	c2 10 00	 ret	 16			; 00000010H
?OnRenderStarCount@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ENDP ; RoundStateUserWnd::OnRenderStarCount
_TEXT	ENDS
PUBLIC	?OnRenderRaidCoinCount@RoundStateUserWnd@@IAEXABURoundInfo@@HH@Z ; RoundStateUserWnd::OnRenderRaidCoinCount
; Function compile flags: /Ogsp
;	COMDAT ?OnRenderRaidCoinCount@RoundStateUserWnd@@IAEXABURoundInfo@@HH@Z
_TEXT	SEGMENT
_rkInfo$ = 8						; size = 4
_iXPos$ = 12						; size = 4
_iYPos$ = 16						; size = 4
?OnRenderRaidCoinCount@RoundStateUserWnd@@IAEXABURoundInfo@@HH@Z PROC ; RoundStateUserWnd::OnRenderRaidCoinCount, COMDAT
; _this$ = ecx

; 1219 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 1220 : 	if( m_pRaidCoin && m_pCoinNumber && m_pCoinUnlimited )

  00007	33 f6		 xor	 esi, esi
  00009	39 b7 30 02 00
	00		 cmp	 DWORD PTR [edi+560], esi
  0000f	0f 84 d6 00 00
	00		 je	 $LN1@OnRenderRa
  00015	39 b7 34 02 00
	00		 cmp	 DWORD PTR [edi+564], esi
  0001b	0f 84 ca 00 00
	00		 je	 $LN1@OnRenderRa
  00021	39 b7 38 02 00
	00		 cmp	 DWORD PTR [edi+568], esi
  00027	0f 84 be 00 00
	00		 je	 $LN1@OnRenderRa

; 1221 : 	{
; 1222 : 		m_pRaidCoin->Render( iXPos, iYPos );

  0002d	8b 8f 30 02 00
	00		 mov	 ecx, DWORD PTR [edi+560]
  00033	8b 01		 mov	 eax, DWORD PTR [ecx]
  00035	53		 push	 ebx
  00036	8b 5d 10	 mov	 ebx, DWORD PTR _iYPos$[ebp]
  00039	56		 push	 esi
  0003a	56		 push	 esi
  0003b	56		 push	 esi
  0003c	56		 push	 esi
  0003d	0f 57 c0	 xorps	 xmm0, xmm0
  00040	51		 push	 ecx
  00041	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  00045	51		 push	 ecx
  00046	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0004c	66 0f 6e 45 0c	 movd	 xmm0, DWORD PTR _iXPos$[ebp]
  00051	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00054	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00059	ff 10		 call	 DWORD PTR [eax]

; 1223 : 		if( rkInfo.m_iRaidCoin >= 100 )

  0005b	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$[ebp]
  0005e	8b 40 50	 mov	 eax, DWORD PTR [eax+80]

; 1224 : 			m_pCoinUnlimited->Render( iXPos + 8, iYPos + 5 );

  00061	56		 push	 esi
  00062	56		 push	 esi
  00063	83 c3 05	 add	 ebx, 5
  00066	56		 push	 esi
  00067	56		 push	 esi
  00068	83 f8 64	 cmp	 eax, 100		; 00000064H
  0006b	7c 2d		 jl	 SHORT $LN4@OnRenderRa
  0006d	8b 8f 38 02 00
	00		 mov	 ecx, DWORD PTR [edi+568]
  00073	8b 55 0c	 mov	 edx, DWORD PTR _iXPos$[ebp]
  00076	8b 01		 mov	 eax, DWORD PTR [ecx]
  00078	0f 57 c0	 xorps	 xmm0, xmm0
  0007b	51		 push	 ecx
  0007c	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  00080	51		 push	 ecx
  00081	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00087	83 c2 08	 add	 edx, 8
  0008a	0f 57 c0	 xorps	 xmm0, xmm0
  0008d	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  00091	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00096	ff 10		 call	 DWORD PTR [eax]
  00098	eb 50		 jmp	 SHORT $LN8@OnRenderRa
$LN4@OnRenderRa:

; 1225 : 		else if( rkInfo.m_iRaidCoin >= 10 )
; 1226 : 			m_pCoinNumber->RenderNum( iXPos + 7, iYPos + 5, rkInfo.m_iRaidCoin );

  0009a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000a2	51		 push	 ecx
  000a3	51		 push	 ecx
  000a4	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000aa	0f 57 c0	 xorps	 xmm0, xmm0
  000ad	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b2	50		 push	 eax
  000b3	51		 push	 ecx
  000b4	0f 57 c0	 xorps	 xmm0, xmm0
  000b7	51		 push	 ecx
  000b8	8b 8f 34 02 00
	00		 mov	 ecx, DWORD PTR [edi+564]
  000be	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  000c2	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000c8	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  000cb	8b 45 0c	 mov	 eax, DWORD PTR _iXPos$[ebp]
  000ce	0f 57 c0	 xorps	 xmm0, xmm0
  000d1	7c 05		 jl	 SHORT $LN2@OnRenderRa
  000d3	83 c0 07	 add	 eax, 7

; 1227 : 		else

  000d6	eb 03		 jmp	 SHORT $LN9@OnRenderRa
$LN2@OnRenderRa:

; 1228 : 			m_pCoinNumber->RenderNum( iXPos + 10, iYPos + 5, rkInfo.m_iRaidCoin );

  000d8	83 c0 0a	 add	 eax, 10			; 0000000aH
$LN9@OnRenderRa:
  000db	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000df	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?RenderNum@ioUIRenderImage@@QAEXMMHMMW4UIRenderType@@W4TextureFilterOption@@0W4RenerNumerFormatting@1@@Z
$LN8@OnRenderRa:
  000ea	5b		 pop	 ebx
$LN1@OnRenderRa:
  000eb	5f		 pop	 edi
  000ec	5e		 pop	 esi

; 1229 : 	}
; 1230 : }

  000ed	5d		 pop	 ebp
  000ee	c2 0c 00	 ret	 12			; 0000000cH
?OnRenderRaidCoinCount@RoundStateUserWnd@@IAEXABURoundInfo@@HH@Z ENDP ; RoundStateUserWnd::OnRenderRaidCoinCount
_TEXT	ENDS
PUBLIC	??0tagLadderTeamInfo@@QAE@ABU0@@Z		; tagLadderTeamInfo::tagLadderTeamInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0tagLadderTeamInfo@@QAE@ABU0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0tagLadderTeamInfo@@QAE@ABU0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0tagLadderTeamInfo@@QAE@ABU0@@Z$1
__ehfuncinfo$??0tagLadderTeamInfo@@QAE@ABU0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0tagLadderTeamInfo@@QAE@ABU0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??0tagLadderTeamInfo@@QAE@ABU0@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0tagLadderTeamInfo@@QAE@ABU0@@Z PROC			; tagLadderTeamInfo::tagLadderTeamInfo, COMDAT
; _this$ = ecx
  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0tagLadderTeamInfo@@QAE@ABU0@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00014	8b 07		 mov	 eax, DWORD PTR [edi]
  00016	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  0001c	89 06		 mov	 DWORD PTR [esi], eax
  0001e	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00021	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00024	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00027	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0002a	8d 47 0c	 lea	 eax, DWORD PTR [edi+12]
  0002d	50		 push	 eax
  0002e	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00031	ff d3		 call	 ebx
  00033	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00037	8d 47 1c	 lea	 eax, DWORD PTR [edi+28]
  0003a	50		 push	 eax
  0003b	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
  0003e	ff d3		 call	 ebx
  00040	8d 47 2c	 lea	 eax, DWORD PTR [edi+44]
  00043	50		 push	 eax
  00044	8d 4e 2c	 lea	 ecx, DWORD PTR [esi+44]
  00047	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0004b	ff d3		 call	 ebx
  0004d	8b 47 3c	 mov	 eax, DWORD PTR [edi+60]
  00050	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  00053	8b 47 40	 mov	 eax, DWORD PTR [edi+64]
  00056	89 46 40	 mov	 DWORD PTR [esi+64], eax
  00059	8b 47 44	 mov	 eax, DWORD PTR [edi+68]
  0005c	89 46 44	 mov	 DWORD PTR [esi+68], eax
  0005f	8b 47 48	 mov	 eax, DWORD PTR [edi+72]
  00062	89 46 48	 mov	 DWORD PTR [esi+72], eax
  00065	8b 47 4c	 mov	 eax, DWORD PTR [edi+76]
  00068	89 46 4c	 mov	 DWORD PTR [esi+76], eax
  0006b	8b 47 50	 mov	 eax, DWORD PTR [edi+80]
  0006e	89 46 50	 mov	 DWORD PTR [esi+80], eax
  00071	8b 47 54	 mov	 eax, DWORD PTR [edi+84]
  00074	89 46 54	 mov	 DWORD PTR [esi+84], eax
  00077	8b 47 58	 mov	 eax, DWORD PTR [edi+88]
  0007a	89 46 58	 mov	 DWORD PTR [esi+88], eax
  0007d	8b 47 5c	 mov	 eax, DWORD PTR [edi+92]
  00080	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  00083	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  00086	89 46 60	 mov	 DWORD PTR [esi+96], eax
  00089	8b 47 64	 mov	 eax, DWORD PTR [edi+100]
  0008c	89 46 64	 mov	 DWORD PTR [esi+100], eax
  0008f	8b 47 68	 mov	 eax, DWORD PTR [edi+104]
  00092	89 46 68	 mov	 DWORD PTR [esi+104], eax
  00095	8b c6		 mov	 eax, esi
  00097	e8 00 00 00 00	 call	 __EH_epilog3
  0009c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0tagLadderTeamInfo@@QAE@ABU0@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??0tagLadderTeamInfo@@QAE@ABU0@@Z$1:
  0000c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00012	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$??0tagLadderTeamInfo@@QAE@ABU0@@Z:
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0tagLadderTeamInfo@@QAE@ABU0@@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0tagLadderTeamInfo@@QAE@ABU0@@Z ENDP			; tagLadderTeamInfo::tagLadderTeamInfo
PUBLIC	??1tagLadderTeamInfo@@QAE@XZ			; tagLadderTeamInfo::~tagLadderTeamInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1tagLadderTeamInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1tagLadderTeamInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1tagLadderTeamInfo@@QAE@XZ$1
__ehfuncinfo$??1tagLadderTeamInfo@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1tagLadderTeamInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??1tagLadderTeamInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1tagLadderTeamInfo@@QAE@XZ PROC			; tagLadderTeamInfo::~tagLadderTeamInfo, COMDAT
; _this$ = ecx
  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??1tagLadderTeamInfo@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f9		 mov	 edi, ecx
  0000e	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  00011	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00017	8d 4f 2c	 lea	 ecx, DWORD PTR [edi+44]
  0001a	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00021	ff d6		 call	 esi
  00023	8d 4f 1c	 lea	 ecx, DWORD PTR [edi+28]
  00026	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0002a	ff d6		 call	 esi
  0002c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00030	8d 4f 0c	 lea	 ecx, DWORD PTR [edi+12]
  00033	ff d6		 call	 esi
  00035	e8 00 00 00 00	 call	 __EH_epilog3
  0003a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1tagLadderTeamInfo@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??1tagLadderTeamInfo@@QAE@XZ$1:
  0000c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00012	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$??1tagLadderTeamInfo@@QAE@XZ:
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1tagLadderTeamInfo@@QAE@XZ
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1tagLadderTeamInfo@@QAE@XZ ENDP			; tagLadderTeamInfo::~tagLadderTeamInfo
PUBLIC	??__G@YGXPAX0IHP6EPAX00@Z@Z			; `vector copy constructor iterator'
; Function compile flags: /Ogsp
;	COMDAT ??__G@YGXPAX0IHP6EPAX00@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___u$ = 12						; size = 4
___s$ = 16						; size = 4
___n$ = 20						; size = 4
___f$ = 24						; size = 4
??__G@YGXPAX0IHP6EPAX00@Z@Z PROC			; `vector copy constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	ff 4d 14	 dec	 DWORD PTR ___n$[ebp]
  00006	78 1b		 js	 SHORT $LN1@vector
  00008	56		 push	 esi
  00009	8b 75 0c	 mov	 esi, DWORD PTR ___u$[ebp]
  0000c	57		 push	 edi
  0000d	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
  00010	2b fe		 sub	 edi, esi
$LL2@vector:
  00012	56		 push	 esi
  00013	8d 0c 37	 lea	 ecx, DWORD PTR [edi+esi]
  00016	ff 55 18	 call	 DWORD PTR ___f$[ebp]
  00019	03 75 10	 add	 esi, DWORD PTR ___s$[ebp]
  0001c	ff 4d 14	 dec	 DWORD PTR ___n$[ebp]
  0001f	79 f1		 jns	 SHORT $LL2@vector
  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
$LN1@vector:
  00023	5d		 pop	 ebp
  00024	c2 14 00	 ret	 20			; 00000014H
??__G@YGXPAX0IHP6EPAX00@Z@Z ENDP			; `vector copy constructor iterator'
_TEXT	ENDS
PUBLIC	?SetPlayStage@RoundStateMainWnd@@QAEXPAVioPlayStage@@@Z ; RoundStateMainWnd::SetPlayStage
; Function compile flags: /Ogsp
;	COMDAT ?SetPlayStage@RoundStateMainWnd@@QAEXPAVioPlayStage@@@Z
_TEXT	SEGMENT
_pPlayStage$ = 8					; size = 4
?SetPlayStage@RoundStateMainWnd@@QAEXPAVioPlayStage@@@Z PROC ; RoundStateMainWnd::SetPlayStage, COMDAT
; _this$ = ecx

; 2310 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2311 : 	m_pPlayStage = pPlayStage;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pPlayStage$[ebp]
  00006	89 81 60 01 00
	00		 mov	 DWORD PTR [ecx+352], eax

; 2312 : }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?SetPlayStage@RoundStateMainWnd@@QAEXPAVioPlayStage@@@Z ENDP ; RoundStateMainWnd::SetPlayStage
_TEXT	ENDS
PUBLIC	?iwm_show@RoundStateMainWnd@@UAEXXZ		; RoundStateMainWnd::iwm_show
EXTRN	?Width@Setting@@SAHXZ:PROC			; Setting::Width
EXTRN	?Height@Setting@@SAHXZ:PROC			; Setting::Height
EXTRN	__imp_?GetHeight@ioWnd@@QBEHXZ:PROC
EXTRN	__imp_?GetWidth@ioWnd@@QBEHXZ:PROC
EXTRN	__imp_?GetYPos@ioWnd@@QBEHXZ:PROC
EXTRN	__imp_?FindChildWnd@ioWnd@@QAEPAV1@K@Z:PROC
EXTRN	__imp_?HideChildWnd@ioWnd@@QAEXK_N@Z:PROC
EXTRN	__imp_?SetWndPos@ioWnd@@QAEXHH@Z:PROC
EXTRN	?IsShuffleRoom@ioShuffleRoomMgr@@QAE_NXZ:PROC	; ioShuffleRoomMgr::IsShuffleRoom
EXTRN	?GetSingleton@ioShuffleRoomMgr@@SAAAV1@XZ:PROC	; ioShuffleRoomMgr::GetSingleton
EXTRN	?GetModeType@ioPlayStage@@QBE?AW4ModeType@@XZ:PROC ; ioPlayStage::GetModeType
; Function compile flags: /Ogsp
;	COMDAT ?iwm_show@RoundStateMainWnd@@UAEXXZ
_TEXT	SEGMENT
tv192 = -4						; size = 4
?iwm_show@RoundStateMainWnd@@UAEXXZ PROC		; RoundStateMainWnd::iwm_show, COMDAT
; _this$ = ecx

; 2904 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 2905 : 	if( !m_pPlayStage ) return;

  00007	8b 8e 60 01 00
	00		 mov	 ecx, DWORD PTR [esi+352]
  0000d	85 c9		 test	 ecx, ecx
  0000f	0f 84 dd 00 00
	00		 je	 $LN10@iwm_show

; 2906 : 
; 2907 : 	switch( m_pPlayStage->GetModeType() )

  00015	e8 00 00 00 00	 call	 ?GetModeType@ioPlayStage@@QBE?AW4ModeType@@XZ ; ioPlayStage::GetModeType
  0001a	83 f8 04	 cmp	 eax, 4
  0001d	74 31		 je	 SHORT $LN6@iwm_show
  0001f	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  00022	74 2c		 je	 SHORT $LN6@iwm_show
  00024	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00027	7e 0f		 jle	 SHORT $LN4@iwm_show
  00029	83 f8 12	 cmp	 eax, 18			; 00000012H
  0002c	7e 16		 jle	 SHORT $LN5@iwm_show
  0002e	83 f8 15	 cmp	 eax, 21			; 00000015H
  00031	74 11		 je	 SHORT $LN5@iwm_show
  00033	83 f8 17	 cmp	 eax, 23			; 00000017H
  00036	74 18		 je	 SHORT $LN6@iwm_show
$LN4@iwm_show:

; 2920 : 	default:
; 2921 : 		SetSize( MODE_WIDTH, MODE_HEIGHT );

  00038	68 46 01 00 00	 push	 326			; 00000146H
  0003d	68 9e 02 00 00	 push	 670			; 0000029eH

; 2922 : 		break;

  00042	eb 16		 jmp	 SHORT $LN12@iwm_show
$LN5@iwm_show:

; 2913 : 		break;
; 2914 : 	case MT_TOWER_DEFENSE:
; 2915 : 	case MT_DARK_XMAS:
; 2916 : 	case MT_FIRE_TEMPLE:
; 2917 : 	case MT_FACTORY:
; 2918 : 		SetSize(TOWER_MODE_WIDTH, TOWER_MODE_HEIGHT);

  00044	68 46 01 00 00	 push	 326			; 00000146H
  00049	68 32 02 00 00	 push	 562			; 00000232H

; 2919 : 		break;

  0004e	eb 0a		 jmp	 SHORT $LN12@iwm_show
$LN6@iwm_show:

; 2908 : 	{
; 2909 : 	case MT_TRAINING:
; 2910 : 	case MT_HEADQUARTERS:
; 2911 : 	case MT_HOUSE:
; 2912 : 		SetSize( PLAZA_WIDTH, PLAZA_HEIGHT );

  00050	68 13 01 00 00	 push	 275			; 00000113H
  00055	68 a0 02 00 00	 push	 672			; 000002a0H
$LN12@iwm_show:
  0005a	8b 06		 mov	 eax, DWORD PTR [esi]
  0005c	8b ce		 mov	 ecx, esi
  0005e	ff 50 2c	 call	 DWORD PTR [eax+44]
  00061	53		 push	 ebx
  00062	57		 push	 edi

; 2923 : 	}
; 2924 : 
; 2925 : 	if( g_ShuffleRoomMgr.IsShuffleRoom() )

  00063	e8 00 00 00 00	 call	 ?GetSingleton@ioShuffleRoomMgr@@SAAAV1@XZ ; ioShuffleRoomMgr::GetSingleton
  00068	8b c8		 mov	 ecx, eax
  0006a	e8 00 00 00 00	 call	 ?IsShuffleRoom@ioShuffleRoomMgr@@QAE_NXZ ; ioShuffleRoomMgr::IsShuffleRoom
  0006f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?SetWndPos@ioWnd@@QAEXHH@Z

; 2926 : 	{
; 2927 : 		HideChildWnd( ID_ROOM_INFO );

  00075	8b ce		 mov	 ecx, esi
  00077	84 c0		 test	 al, al
  00079	74 0c		 je	 SHORT $LN3@iwm_show
  0007b	6a 00		 push	 0
  0007d	6a 01		 push	 1
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?HideChildWnd@ioWnd@@QAEXK_N@Z

; 2928 : 	}
; 2929 : 	else

  00085	eb 27		 jmp	 SHORT $LN1@iwm_show
$LN3@iwm_show:

; 2930 : 	{
; 2931 : 		ioWnd *pRoomInfo = FindChildWnd( ID_ROOM_INFO );

  00087	6a 01		 push	 1
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?FindChildWnd@ioWnd@@QAEPAV1@K@Z
  0008f	8b d8		 mov	 ebx, eax

; 2932 : 		if( pRoomInfo )

  00091	85 db		 test	 ebx, ebx
  00093	74 19		 je	 SHORT $LN1@iwm_show

; 2933 : 			pRoomInfo->SetWndPos( GetWidth() - ROOM_INFO_BTN_RIGHT_GAP, pRoomInfo->GetYPos() );

  00095	8b cb		 mov	 ecx, ebx
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetYPos@ioWnd@@QBEHXZ
  0009d	50		 push	 eax
  0009e	8b ce		 mov	 ecx, esi
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetWidth@ioWnd@@QBEHXZ
  000a6	83 e8 36	 sub	 eax, 54			; 00000036H
  000a9	50		 push	 eax
  000aa	8b cb		 mov	 ecx, ebx
  000ac	ff d7		 call	 edi
$LN1@iwm_show:

; 2934 : 	}
; 2935 : 
; 2936 : 	SetWndPos( ( Setting::Width() / 2 ) - ( GetWidth() / 2 ),
; 2937 : 			   ( Setting::Height() / 2 ) - ( GetHeight() / 2 ) - 20 );

  000ae	8b ce		 mov	 ecx, esi
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetHeight@ioWnd@@QBEHXZ
  000b6	99		 cdq
  000b7	2b c2		 sub	 eax, edx
  000b9	8b d8		 mov	 ebx, eax
  000bb	8b ce		 mov	 ecx, esi
  000bd	d1 fb		 sar	 ebx, 1
  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetWidth@ioWnd@@QBEHXZ
  000c5	99		 cdq
  000c6	2b c2		 sub	 eax, edx
  000c8	89 45 fc	 mov	 DWORD PTR tv192[ebp], eax
  000cb	d1 7d fc	 sar	 DWORD PTR tv192[ebp], 1
  000ce	e8 00 00 00 00	 call	 ?Height@Setting@@SAHXZ	; Setting::Height
  000d3	99		 cdq
  000d4	2b c2		 sub	 eax, edx
  000d6	d1 f8		 sar	 eax, 1
  000d8	2b c3		 sub	 eax, ebx
  000da	83 e8 14	 sub	 eax, 20			; 00000014H
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 ?Width@Setting@@SAHXZ	; Setting::Width
  000e3	99		 cdq
  000e4	2b c2		 sub	 eax, edx
  000e6	d1 f8		 sar	 eax, 1
  000e8	2b 45 fc	 sub	 eax, DWORD PTR tv192[ebp]
  000eb	8b ce		 mov	 ecx, esi
  000ed	50		 push	 eax
  000ee	ff d7		 call	 edi
  000f0	5f		 pop	 edi
  000f1	5b		 pop	 ebx
$LN10@iwm_show:
  000f2	5e		 pop	 esi

; 2938 : }

  000f3	c9		 leave
  000f4	c3		 ret	 0
?iwm_show@RoundStateMainWnd@@UAEXXZ ENDP		; RoundStateMainWnd::iwm_show
_TEXT	ENDS
PUBLIC	?iwm_hide@RoundStateMainWnd@@UAEXXZ		; RoundStateMainWnd::iwm_hide
; Function compile flags: /Ogsp
;	COMDAT ?iwm_hide@RoundStateMainWnd@@UAEXXZ
_TEXT	SEGMENT
?iwm_hide@RoundStateMainWnd@@UAEXXZ PROC		; RoundStateMainWnd::iwm_hide, COMDAT
; _this$ = ecx

; 2942 : }

  00000	c3		 ret	 0
?iwm_hide@RoundStateMainWnd@@UAEXXZ ENDP		; RoundStateMainWnd::iwm_hide
_TEXT	ENDS
PUBLIC	__real@44110000
PUBLIC	?OnRender@RoundStateMainWnd@@MAEXXZ		; RoundStateMainWnd::OnRender
EXTRN	?PrintFullTextWidthCut@ioComplexStringPrinter@@QAEXMMW4TextAlignType@@ME@Z:PROC ; ioComplexStringPrinter::PrintFullTextWidthCut
EXTRN	__imp_?GetDerivedPosX@ioWnd@@QBEHXZ:PROC
EXTRN	__imp_?GetDerivedPosY@ioWnd@@QBEHXZ:PROC
EXTRN	__imp_?OnRender@ioWnd@@MAEXXZ:PROC
;	COMDAT __real@44110000
CONST	SEGMENT
__real@44110000 DD 044110000r			; 580
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?OnRender@RoundStateMainWnd@@MAEXXZ
_TEXT	SEGMENT
?OnRender@RoundStateMainWnd@@MAEXXZ PROC		; RoundStateMainWnd::OnRender, COMDAT
; _this$ = ecx

; 3060 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3061 : 	ioWnd::OnRender();

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?OnRender@ioWnd@@MAEXXZ

; 3062 : 
; 3063 : 	m_Title.PrintFullTextWidthCut( GetDerivedPosX() + 13, GetDerivedPosY() + 11, TAT_LEFT, 580.0f );

  00009	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@44110000
  00011	68 ff 00 00 00	 push	 255			; 000000ffH
  00016	51		 push	 ecx
  00017	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0001c	6a 00		 push	 0
  0001e	8b ce		 mov	 ecx, esi
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetDerivedPosY@ioWnd@@QBEHXZ
  00026	83 c0 0b	 add	 eax, 11			; 0000000bH
  00029	51		 push	 ecx
  0002a	0f 57 c0	 xorps	 xmm0, xmm0
  0002d	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00031	8b ce		 mov	 ecx, esi
  00033	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetDerivedPosX@ioWnd@@QBEHXZ
  0003e	83 c0 0d	 add	 eax, 13			; 0000000dH
  00041	51		 push	 ecx
  00042	0f 57 c0	 xorps	 xmm0, xmm0
  00045	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00049	8d 8e 74 01 00
	00		 lea	 ecx, DWORD PTR [esi+372]
  0004f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00054	e8 00 00 00 00	 call	 ?PrintFullTextWidthCut@ioComplexStringPrinter@@QAEXMMW4TextAlignType@@ME@Z ; ioComplexStringPrinter::PrintFullTextWidthCut
  00059	5e		 pop	 esi

; 3064 : }

  0005a	c3		 ret	 0
?OnRender@RoundStateMainWnd@@MAEXXZ ENDP		; RoundStateMainWnd::OnRender
_TEXT	ENDS
PUBLIC	?iwm_show@RoundResultMainWnd@@UAEXXZ		; RoundResultMainWnd::iwm_show
EXTRN	?IsKeyDown@CDirectInput@@QAI_NG@Z:PROC		; CDirectInput::IsKeyDown
EXTRN	?GetSingleton@CDirectInput@@SAAAV1@XZ:PROC	; CDirectInput::GetSingleton
EXTRN	?HideHelpDirectly@ioModeHelpManager@@QAEXXZ:PROC ; ioModeHelpManager::HideHelpDirectly
EXTRN	?GetSingleton@ioModeHelpManager@@SAAAV1@XZ:PROC	; ioModeHelpManager::GetSingleton
EXTRN	__imp_?HideWnd@ioGUIManager@@QAEXK_N@Z:PROC
EXTRN	?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ:PROC	; ioSP2GUIManager::GetSingleton
; Function compile flags: /Ogsp
;	COMDAT ?iwm_show@RoundResultMainWnd@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?iwm_show@RoundResultMainWnd@@UAEXXZ PROC		; RoundResultMainWnd::iwm_show, COMDAT
; _this$ = ecx

; 3076 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3077 : 	RoundStateMainWnd::iwm_show();

  0000a	e8 00 00 00 00	 call	 ?iwm_show@RoundStateMainWnd@@UAEXXZ ; RoundStateMainWnd::iwm_show

; 3078 : 
; 3079 : 	g_GUIMgr.HideWnd( MINIMAP_WND );

  0000f	33 ff		 xor	 edi, edi
  00011	57		 push	 edi
  00012	68 74 17 00 00	 push	 6004			; 00001774H
  00017	e8 00 00 00 00	 call	 ?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ ; ioSP2GUIManager::GetSingleton
  0001c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?HideWnd@ioGUIManager@@QAEXK_N@Z
  00022	8b c8		 mov	 ecx, eax
  00024	ff d6		 call	 esi

; 3080 : 	g_GUIMgr.HideWnd( TIME_SCORE_WND );

  00026	57		 push	 edi
  00027	68 b9 13 00 00	 push	 5049			; 000013b9H
  0002c	e8 00 00 00 00	 call	 ?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ ; ioSP2GUIManager::GetSingleton
  00031	8b c8		 mov	 ecx, eax
  00033	ff d6		 call	 esi

; 3081 : 	g_GUIMgr.HideWnd( SKILL_LIST_WND );

  00035	57		 push	 edi
  00036	68 89 13 00 00	 push	 5001			; 00001389H
  0003b	e8 00 00 00 00	 call	 ?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ ; ioSP2GUIManager::GetSingleton
  00040	8b c8		 mov	 ecx, eax
  00042	ff d6		 call	 esi

; 3082 : 	g_GUIMgr.HideWnd( ACCESSORY_SKILL_LIST_WND );

  00044	57		 push	 edi
  00045	68 9c 18 00 00	 push	 6300			; 0000189cH
  0004a	e8 00 00 00 00	 call	 ?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ ; ioSP2GUIManager::GetSingleton
  0004f	8b c8		 mov	 ecx, eax
  00051	ff d6		 call	 esi

; 3083 : 	g_GUIMgr.HideWnd( CENTER_INFO_WND );

  00053	57		 push	 edi
  00054	68 b8 13 00 00	 push	 5048			; 000013b8H
  00059	e8 00 00 00 00	 call	 ?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ ; ioSP2GUIManager::GetSingleton
  0005e	8b c8		 mov	 ecx, eax
  00060	ff d6		 call	 esi

; 3084 : 	g_GUIMgr.HideWnd( MODE_RANK_WND );

  00062	57		 push	 edi
  00063	68 8d 13 00 00	 push	 5005			; 0000138dH
  00068	e8 00 00 00 00	 call	 ?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ ; ioSP2GUIManager::GetSingleton
  0006d	8b c8		 mov	 ecx, eax
  0006f	ff d6		 call	 esi

; 3085 : 	g_GUIMgr.HideWnd( FIGHTCLUB_TIME_GAUGE_WND );

  00071	57		 push	 edi
  00072	68 d1 13 00 00	 push	 5073			; 000013d1H
  00077	e8 00 00 00 00	 call	 ?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ ; ioSP2GUIManager::GetSingleton
  0007c	8b c8		 mov	 ecx, eax
  0007e	ff d6		 call	 esi

; 3086 : 	g_GUIMgr.HideWnd( FIGHTCLUB_ROUND_END_WND );

  00080	57		 push	 edi
  00081	68 d3 13 00 00	 push	 5075			; 000013d3H
  00086	e8 00 00 00 00	 call	 ?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ ; ioSP2GUIManager::GetSingleton
  0008b	8b c8		 mov	 ecx, eax
  0008d	ff d6		 call	 esi

; 3087 : 	g_GUIMgr.HideWnd( FIGHTCLUB_CHALLENGER_WND );

  0008f	57		 push	 edi
  00090	bb d5 13 00 00	 mov	 ebx, 5077		; 000013d5H
  00095	53		 push	 ebx
  00096	e8 00 00 00 00	 call	 ?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ ; ioSP2GUIManager::GetSingleton
  0009b	8b c8		 mov	 ecx, eax
  0009d	ff d6		 call	 esi

; 3088 : 	g_GUIMgr.HideWnd( TOWERDEF_USER_GAUGE_WND );

  0009f	57		 push	 edi
  000a0	68 d4 13 00 00	 push	 5076			; 000013d4H
  000a5	e8 00 00 00 00	 call	 ?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ ; ioSP2GUIManager::GetSingleton
  000aa	8b c8		 mov	 ecx, eax
  000ac	ff d6		 call	 esi

; 3089 : 	g_GUIMgr.HideWnd( MINI_SOLDIER_SELECT_WND );

  000ae	57		 push	 edi
  000af	68 a0 13 00 00	 push	 5024			; 000013a0H
  000b4	e8 00 00 00 00	 call	 ?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ ; ioSP2GUIManager::GetSingleton
  000b9	8b c8		 mov	 ecx, eax
  000bb	ff d6		 call	 esi

; 3090 : 	g_GUIMgr.HideWnd( FIGHTCLUB_CHALLENGER_WND );

  000bd	57		 push	 edi
  000be	53		 push	 ebx
  000bf	e8 00 00 00 00	 call	 ?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ ; ioSP2GUIManager::GetSingleton
  000c4	8b c8		 mov	 ecx, eax
  000c6	ff d6		 call	 esi

; 3091 : 	g_GUIMgr.HideWnd( FIGHTCLUB_CONTINUE_WND );

  000c8	57		 push	 edi
  000c9	68 d6 13 00 00	 push	 5078			; 000013d6H
  000ce	e8 00 00 00 00	 call	 ?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ ; ioSP2GUIManager::GetSingleton
  000d3	8b c8		 mov	 ecx, eax
  000d5	ff d6		 call	 esi

; 3092 : 	g_GUIMgr.HideWnd( TUTORIAL_KEYBOARD_WND );

  000d7	57		 push	 edi
  000d8	68 a2 13 00 00	 push	 5026			; 000013a2H
  000dd	e8 00 00 00 00	 call	 ?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ ; ioSP2GUIManager::GetSingleton
  000e2	8b c8		 mov	 ecx, eax
  000e4	ff d6		 call	 esi

; 3093 : 	g_GUIMgr.HideWnd( TRAINING_FUNC_MENU );

  000e6	57		 push	 edi
  000e7	68 87 18 00 00	 push	 6279			; 00001887H
  000ec	e8 00 00 00 00	 call	 ?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ ; ioSP2GUIManager::GetSingleton
  000f1	8b c8		 mov	 ecx, eax
  000f3	ff d6		 call	 esi

; 3094 : 	g_ModeHelpMgr.HideHelpDirectly();

  000f5	e8 00 00 00 00	 call	 ?GetSingleton@ioModeHelpManager@@SAAAV1@XZ ; ioModeHelpManager::GetSingleton
  000fa	8b c8		 mov	 ecx, eax
  000fc	e8 00 00 00 00	 call	 ?HideHelpDirectly@ioModeHelpManager@@QAEXXZ ; ioModeHelpManager::HideHelpDirectly

; 3095 : 
; 3096 : 	if( g_Input.IsKeyDown( KEY_TAB ) )

  00101	e8 00 00 00 00	 call	 ?GetSingleton@CDirectInput@@SAAAV1@XZ ; CDirectInput::GetSingleton
  00106	6a 09		 push	 9
  00108	5a		 pop	 edx
  00109	8b c8		 mov	 ecx, eax
  0010b	e8 00 00 00 00	 call	 ?IsKeyDown@CDirectInput@@QAI_NG@Z ; CDirectInput::IsKeyDown
  00110	5f		 pop	 edi
  00111	5e		 pop	 esi
  00112	5b		 pop	 ebx
  00113	84 c0		 test	 al, al
  00115	74 15		 je	 SHORT $LN1@iwm_show@2

; 3097 : 	{
; 3098 : 		SetWndPos( Setting::Width(), Setting::Height() );

  00117	e8 00 00 00 00	 call	 ?Height@Setting@@SAHXZ	; Setting::Height
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 ?Width@Setting@@SAHXZ	; Setting::Width
  00122	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00125	50		 push	 eax
  00126	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetWndPos@ioWnd@@QAEXHH@Z
$LN1@iwm_show@2:

; 3099 : 	}
; 3100 : }

  0012c	c9		 leave
  0012d	c3		 ret	 0
?iwm_show@RoundResultMainWnd@@UAEXXZ ENDP		; RoundResultMainWnd::iwm_show
_TEXT	ENDS
PUBLIC	?size@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QBEIXZ ; std::vector<RoundInfo,std::allocator<RoundInfo> >::size
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?size@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<RoundInfo,std::allocator<RoundInfo> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 07	 sar	 eax, 7

; 880  : 		}

  00008	c3		 ret	 0
?size@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<RoundInfo,std::allocator<RoundInfo> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEAAURoundInfo@@I@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::operator[]
; Function compile flags: /Ogsp
;	COMDAT ??A?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEAAURoundInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEAAURoundInfo@@I@Z PROC ; std::vector<RoundInfo,std::allocator<RoundInfo> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00006	c1 e0 07	 shl	 eax, 7
  00009	03 01		 add	 eax, DWORD PTR [ecx]

; 941  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEAAURoundInfo@@I@Z ENDP ; std::vector<RoundInfo,std::allocator<RoundInfo> >::operator[]
_TEXT	ENDS
PUBLIC	?_Inside@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IBE_NPBURoundInfo@@@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Inside
; Function compile flags: /Ogsp
;	COMDAT ?_Inside@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IBE_NPBURoundInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IBE_NPBURoundInfo@@@Z PROC ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 09		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 05		 ja	 SHORT $LN3@Inside
  0000f	33 c0		 xor	 eax, eax
  00011	40		 inc	 eax
  00012	eb 02		 jmp	 SHORT $LN4@Inside
$LN3@Inside:
  00014	33 c0		 xor	 eax, eax
$LN4@Inside:

; 1287 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?_Inside@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IBE_NPBURoundInfo@@@Z ENDP ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Inside
_TEXT	ENDS
PUBLIC	?_Orphan_range@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IBEXPAURoundInfo@@0@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Orphan_range
; Function compile flags: /Ogsp
;	COMDAT ?_Orphan_range@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IBEXPAURoundInfo@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IBEXPAURoundInfo@@0@Z PROC ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1454 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IBEXPAURoundInfo@@0@Z ENDP ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<RoundInfo,std::allocator<RoundInfo> >::~_Vector_val<RoundInfo,std::allocator<RoundInfo> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<RoundInfo,std::allocator<RoundInfo> >::~_Vector_val<RoundInfo,std::allocator<RoundInfo> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<RoundInfo,std::allocator<RoundInfo> >::~_Vector_val<RoundInfo,std::allocator<RoundInfo> >
_TEXT	ENDS
PUBLIC	??0?$allocator@URoundInfo@@@std@@QAE@XZ		; std::allocator<RoundInfo>::allocator<RoundInfo>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@URoundInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@URoundInfo@@@std@@QAE@XZ PROC		; std::allocator<RoundInfo>::allocator<RoundInfo>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@URoundInfo@@@std@@QAE@XZ ENDP		; std::allocator<RoundInfo>::allocator<RoundInfo>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QBEIXZ ; std::vector<RoundInfo,std::allocator<RoundInfo> >::capacity
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?capacity@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<RoundInfo,std::allocator<RoundInfo> >::capacity, COMDAT
; _this$ = ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 07	 sar	 eax, 7

; 778  : 		}

  00008	c3		 ret	 0
?capacity@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<RoundInfo,std::allocator<RoundInfo> >::capacity
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IBEXXZ ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Xlen
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IBEXXZ PROC ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Xlen, COMDAT
; _this$ = ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
  0000b	cc		 int	 3
?_Xlen@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IBEXXZ ENDP ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Xlen
_TEXT	ENDS
PUBLIC	??0?$allocator@URoundInfo@@@std@@QAE@ABV01@@Z	; std::allocator<RoundInfo>::allocator<RoundInfo>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@URoundInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@URoundInfo@@@std@@QAE@ABV01@@Z PROC	; std::allocator<RoundInfo>::allocator<RoundInfo>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@URoundInfo@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<RoundInfo>::allocator<RoundInfo>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@I@Z ; std::allocator<RoundInfo>::deallocate
; Function compile flags: /Ogsp
;	COMDAT ?deallocate@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@I@Z PROC ; std::allocator<RoundInfo>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 183  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
?deallocate@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@I@Z ENDP ; std::allocator<RoundInfo>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QAE@PAURoundInfo@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >::_Vector_const_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QAE@PAURoundInfo@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QAE@PAURoundInfo@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >::_Vector_const_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QAE@PAURoundInfo@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >::_Vector_const_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@URoundInfo@@@std@@QBEIXZ	; std::allocator<RoundInfo>::max_size
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@URoundInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@URoundInfo@@@std@@QBEIXZ PROC	; std::allocator<RoundInfo>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 01	 mov	 eax, 33554431		; 01ffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@URoundInfo@@@std@@QBEIXZ ENDP	; std::allocator<RoundInfo>::max_size
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >::_Compat
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >::_Compat, COMDAT
; _this$ = ecx

; 253  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >::_Compat
_TEXT	ENDS
PUBLIC	??$addressof@$$CBURoundInfo@@@std@@YAPBURoundInfo@@ABU1@@Z ; std::addressof<RoundInfo const >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$addressof@$$CBURoundInfo@@@std@@YAPBURoundInfo@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBURoundInfo@@@std@@YAPBURoundInfo@@ABU1@@Z PROC ; std::addressof<RoundInfo const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBURoundInfo@@@std@@YAPBURoundInfo@@ABU1@@Z ENDP ; std::addressof<RoundInfo const >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@URoundInfo@@@std@@YAPAURoundInfo@@IPAU1@@Z ; std::_Allocate<RoundInfo>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@URoundInfo@@@std@@YAPAURoundInfo@@IPAU1@@Z
_TEXT	SEGMENT
$T557168 = -12						; size = 12
$T557173 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@URoundInfo@@@std@@YAPAURoundInfo@@IPAU1@@Z PROC ; std::_Allocate<RoundInfo>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 3c		 je	 SHORT $LN5@Allocate

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 ff ff ff
	01		 cmp	 ecx, 33554431		; 01ffffffH
  00015	77 0e		 ja	 SHORT $LN1@Allocate
  00017	c1 e1 07	 shl	 ecx, 7
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00020	59		 pop	 ecx
  00021	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00023	75 26		 jne	 SHORT $LN5@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00025	83 65 08 00	 and	 DWORD PTR $T557173[ebp], 0
  00029	8d 45 08	 lea	 eax, DWORD PTR $T557173[ebp]
  0002c	50		 push	 eax
  0002d	8d 4d f4	 lea	 ecx, DWORD PTR $T557168[ebp]
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
  00036	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003b	8d 45 f4	 lea	 eax, DWORD PTR $T557168[ebp]
  0003e	50		 push	 eax
  0003f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T557168[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00046	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate:
$LN5@Allocate:

; 40   : 	}

  0004b	c9		 leave
  0004c	c3		 ret	 0
$LN9@Allocate:
??$_Allocate@URoundInfo@@@std@@YAPAURoundInfo@@IPAU1@@Z ENDP ; std::_Allocate<RoundInfo>
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >::operator-
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??G?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >::operator-, COMDAT
; _this$ = ecx

; 190  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 191  : 		_Compat(_Right);
; 192  : 		return (this->_Ptr - _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	c1 f8 07	 sar	 eax, 7

; 193  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??G?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >::operator-
_TEXT	ENDS
PUBLIC	??$forward@AAURoundInfo@@@std@@YAAAURoundInfo@@AAU1@@Z ; std::forward<RoundInfo &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@AAURoundInfo@@@std@@YAAAURoundInfo@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAURoundInfo@@@std@@YAAAURoundInfo@@AAU1@@Z PROC ; std::forward<RoundInfo &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAURoundInfo@@@std@@YAAAURoundInfo@@AAU1@@Z ENDP ; std::forward<RoundInfo &>
_TEXT	ENDS
PUBLIC	??$forward@ABURoundInfo@@@std@@YAABURoundInfo@@ABU1@@Z ; std::forward<RoundInfo const &>
; Function compile flags: /Ogsp
;	COMDAT ??$forward@ABURoundInfo@@@std@@YAABURoundInfo@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABURoundInfo@@@std@@YAABURoundInfo@@ABU1@@Z PROC ; std::forward<RoundInfo const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABURoundInfo@@@std@@YAABURoundInfo@@ABU1@@Z ENDP ; std::forward<RoundInfo const &>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@URoundInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURoundInfo@@0@Z ; std::_Ptr_cat<RoundInfo,RoundInfo>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@URoundInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURoundInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@URoundInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURoundInfo@@0@Z PROC ; std::_Ptr_cat<RoundInfo,RoundInfo>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	c9		 leave
  00008	c3		 ret	 0
??$_Ptr_cat@URoundInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURoundInfo@@0@Z ENDP ; std::_Ptr_cat<RoundInfo,RoundInfo>
_TEXT	ENDS
PUBLIC	??0RoundInfo@@QAE@ABU0@@Z			; RoundInfo::RoundInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0RoundInfo@@QAE@ABU0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0RoundInfo@@QAE@ABU0@@Z$0
__ehfuncinfo$??0RoundInfo@@QAE@ABU0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0RoundInfo@@QAE@ABU0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??0RoundInfo@@QAE@ABU0@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0RoundInfo@@QAE@ABU0@@Z PROC				; RoundInfo::RoundInfo, COMDAT
; _this$ = ecx
  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0RoundInfo@@QAE@ABU0@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00014	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  0001a	57		 push	 edi
  0001b	ff d3		 call	 ebx
  0001d	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00020	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00024	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00027	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  0002a	89 46 14	 mov	 DWORD PTR [esi+20], eax
  0002d	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00030	89 46 18	 mov	 DWORD PTR [esi+24], eax
  00033	8d 47 1c	 lea	 eax, DWORD PTR [edi+28]
  00036	50		 push	 eax
  00037	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
  0003a	ff d3		 call	 ebx
  0003c	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  0003f	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  00042	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  00045	89 46 30	 mov	 DWORD PTR [esi+48], eax
  00048	8b 47 34	 mov	 eax, DWORD PTR [edi+52]
  0004b	89 46 34	 mov	 DWORD PTR [esi+52], eax
  0004e	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  00051	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00054	8b 47 3c	 mov	 eax, DWORD PTR [edi+60]
  00057	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  0005a	8b 47 40	 mov	 eax, DWORD PTR [edi+64]
  0005d	89 46 40	 mov	 DWORD PTR [esi+64], eax
  00060	8b 47 44	 mov	 eax, DWORD PTR [edi+68]
  00063	89 46 44	 mov	 DWORD PTR [esi+68], eax
  00066	8b 47 48	 mov	 eax, DWORD PTR [edi+72]
  00069	89 46 48	 mov	 DWORD PTR [esi+72], eax
  0006c	8b 47 4c	 mov	 eax, DWORD PTR [edi+76]
  0006f	89 46 4c	 mov	 DWORD PTR [esi+76], eax
  00072	8b 47 50	 mov	 eax, DWORD PTR [edi+80]
  00075	89 46 50	 mov	 DWORD PTR [esi+80], eax
  00078	8a 47 54	 mov	 al, BYTE PTR [edi+84]
  0007b	88 46 54	 mov	 BYTE PTR [esi+84], al
  0007e	8a 47 55	 mov	 al, BYTE PTR [edi+85]
  00081	88 46 55	 mov	 BYTE PTR [esi+85], al
  00084	8a 47 56	 mov	 al, BYTE PTR [edi+86]
  00087	88 46 56	 mov	 BYTE PTR [esi+86], al
  0008a	8a 47 57	 mov	 al, BYTE PTR [edi+87]
  0008d	88 46 57	 mov	 BYTE PTR [esi+87], al
  00090	8b 47 58	 mov	 eax, DWORD PTR [edi+88]
  00093	89 46 58	 mov	 DWORD PTR [esi+88], eax
  00096	8b 47 5c	 mov	 eax, DWORD PTR [edi+92]
  00099	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  0009c	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  0009f	89 46 60	 mov	 DWORD PTR [esi+96], eax
  000a2	8b 47 64	 mov	 eax, DWORD PTR [edi+100]
  000a5	89 46 64	 mov	 DWORD PTR [esi+100], eax
  000a8	8b 47 68	 mov	 eax, DWORD PTR [edi+104]
  000ab	89 46 68	 mov	 DWORD PTR [esi+104], eax
  000ae	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]
  000b1	89 46 6c	 mov	 DWORD PTR [esi+108], eax
  000b4	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  000b7	89 46 70	 mov	 DWORD PTR [esi+112], eax
  000ba	8b 47 74	 mov	 eax, DWORD PTR [edi+116]
  000bd	89 46 74	 mov	 DWORD PTR [esi+116], eax
  000c0	8a 47 78	 mov	 al, BYTE PTR [edi+120]
  000c3	88 46 78	 mov	 BYTE PTR [esi+120], al
  000c6	8a 47 79	 mov	 al, BYTE PTR [edi+121]
  000c9	88 46 79	 mov	 BYTE PTR [esi+121], al
  000cc	8b 47 7c	 mov	 eax, DWORD PTR [edi+124]
  000cf	89 46 7c	 mov	 DWORD PTR [esi+124], eax
  000d2	8b c6		 mov	 eax, esi
  000d4	e8 00 00 00 00	 call	 __EH_epilog3
  000d9	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0RoundInfo@@QAE@ABU0@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$??0RoundInfo@@QAE@ABU0@@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0RoundInfo@@QAE@ABU0@@Z
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0RoundInfo@@QAE@ABU0@@Z ENDP				; RoundInfo::RoundInfo
PUBLIC	??4RoundInfo@@QAEAAU0@ABU0@@Z			; RoundInfo::operator=
; Function compile flags: /Ogsp
;	COMDAT ??4RoundInfo@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4RoundInfo@@QAEAAU0@ABU0@@Z PROC			; RoundInfo::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_??4ioHashString@@QAEAAV0@ABV0@@Z
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  0000f	57		 push	 edi
  00010	8b f1		 mov	 esi, ecx
  00012	ff d3		 call	 ebx
  00014	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00017	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0001a	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  0001d	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00020	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00023	89 46 18	 mov	 DWORD PTR [esi+24], eax
  00026	8d 47 1c	 lea	 eax, DWORD PTR [edi+28]
  00029	50		 push	 eax
  0002a	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
  0002d	ff d3		 call	 ebx
  0002f	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00032	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  00035	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  00038	89 46 30	 mov	 DWORD PTR [esi+48], eax
  0003b	8b 47 34	 mov	 eax, DWORD PTR [edi+52]
  0003e	89 46 34	 mov	 DWORD PTR [esi+52], eax
  00041	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  00044	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00047	8b 47 3c	 mov	 eax, DWORD PTR [edi+60]
  0004a	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  0004d	8b 47 40	 mov	 eax, DWORD PTR [edi+64]
  00050	89 46 40	 mov	 DWORD PTR [esi+64], eax
  00053	8b 47 44	 mov	 eax, DWORD PTR [edi+68]
  00056	89 46 44	 mov	 DWORD PTR [esi+68], eax
  00059	8b 47 48	 mov	 eax, DWORD PTR [edi+72]
  0005c	89 46 48	 mov	 DWORD PTR [esi+72], eax
  0005f	8b 47 4c	 mov	 eax, DWORD PTR [edi+76]
  00062	89 46 4c	 mov	 DWORD PTR [esi+76], eax
  00065	8b 47 50	 mov	 eax, DWORD PTR [edi+80]
  00068	89 46 50	 mov	 DWORD PTR [esi+80], eax
  0006b	8a 47 54	 mov	 al, BYTE PTR [edi+84]
  0006e	88 46 54	 mov	 BYTE PTR [esi+84], al
  00071	8a 47 55	 mov	 al, BYTE PTR [edi+85]
  00074	88 46 55	 mov	 BYTE PTR [esi+85], al
  00077	8a 47 56	 mov	 al, BYTE PTR [edi+86]
  0007a	88 46 56	 mov	 BYTE PTR [esi+86], al
  0007d	8a 47 57	 mov	 al, BYTE PTR [edi+87]
  00080	88 46 57	 mov	 BYTE PTR [esi+87], al
  00083	8b 47 58	 mov	 eax, DWORD PTR [edi+88]
  00086	89 46 58	 mov	 DWORD PTR [esi+88], eax
  00089	8b 47 5c	 mov	 eax, DWORD PTR [edi+92]
  0008c	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  0008f	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  00092	89 46 60	 mov	 DWORD PTR [esi+96], eax
  00095	8b 47 64	 mov	 eax, DWORD PTR [edi+100]
  00098	89 46 64	 mov	 DWORD PTR [esi+100], eax
  0009b	8b 47 68	 mov	 eax, DWORD PTR [edi+104]
  0009e	89 46 68	 mov	 DWORD PTR [esi+104], eax
  000a1	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]
  000a4	89 46 6c	 mov	 DWORD PTR [esi+108], eax
  000a7	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  000aa	89 46 70	 mov	 DWORD PTR [esi+112], eax
  000ad	8b 47 74	 mov	 eax, DWORD PTR [edi+116]
  000b0	89 46 74	 mov	 DWORD PTR [esi+116], eax
  000b3	8a 47 78	 mov	 al, BYTE PTR [edi+120]
  000b6	88 46 78	 mov	 BYTE PTR [esi+120], al
  000b9	8a 47 79	 mov	 al, BYTE PTR [edi+121]
  000bc	88 46 79	 mov	 BYTE PTR [esi+121], al
  000bf	8b 47 7c	 mov	 eax, DWORD PTR [edi+124]
  000c2	89 46 7c	 mov	 DWORD PTR [esi+124], eax
  000c5	5f		 pop	 edi
  000c6	8b c6		 mov	 eax, esi
  000c8	5e		 pop	 esi
  000c9	5b		 pop	 ebx
  000ca	5d		 pop	 ebp
  000cb	c2 04 00	 ret	 4
??4RoundInfo@@QAEAAU0@ABU0@@Z ENDP			; RoundInfo::operator=
_TEXT	ENDS
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QBEPAURoundInfo@@XZ ; std::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >::_Unchecked
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QBEPAURoundInfo@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QBEPAURoundInfo@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >::_Unchecked, COMDAT
; _this$ = ecx

; 317  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 318  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QBEPAURoundInfo@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >::_Unchecked
_TEXT	ENDS
PUBLIC	??$move@AAURoundInfo@@@std@@YA$$QAURoundInfo@@AAU1@@Z ; std::move<RoundInfo &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAURoundInfo@@@std@@YA$$QAURoundInfo@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAURoundInfo@@@std@@YA$$QAURoundInfo@@AAU1@@Z PROC ; std::move<RoundInfo &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAURoundInfo@@@std@@YA$$QAURoundInfo@@AAU1@@Z ENDP ; std::move<RoundInfo &>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAURoundInfo@@@std@@YAPAURoundInfo@@PAU1@@Z ; std::_Val_type<RoundInfo *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAURoundInfo@@@std@@YAPAURoundInfo@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAURoundInfo@@@std@@YAPAURoundInfo@@PAU1@@Z PROC ; std::_Val_type<RoundInfo *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAURoundInfo@@@std@@YAPAURoundInfo@@PAU1@@Z ENDP ; std::_Val_type<RoundInfo *>
_TEXT	ENDS
PUBLIC	??$_Unchecked@PAURoundInfo@@@std@@YAPAURoundInfo@@PAU1@@Z ; std::_Unchecked<RoundInfo *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Unchecked@PAURoundInfo@@@std@@YAPAURoundInfo@@PAU1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAURoundInfo@@@std@@YAPAURoundInfo@@PAU1@@Z PROC ; std::_Unchecked<RoundInfo *>, COMDAT

; 266  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 267  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 268  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAURoundInfo@@@std@@YAPAURoundInfo@@PAU1@@Z ENDP ; std::_Unchecked<RoundInfo *>
_TEXT	ENDS
PUBLIC	??$_Dist_type@PAURoundInfo@@@std@@YAPAHPAURoundInfo@@@Z ; std::_Dist_type<RoundInfo *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Dist_type@PAURoundInfo@@@std@@YAPAHPAURoundInfo@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAURoundInfo@@@std@@YAPAHPAURoundInfo@@@Z PROC ; std::_Dist_type<RoundInfo *>, COMDAT

; 850  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 851  : 	}

  00002	c3		 ret	 0
??$_Dist_type@PAURoundInfo@@@std@@YAPAHPAURoundInfo@@@Z ENDP ; std::_Dist_type<RoundInfo *>
_TEXT	ENDS
PUBLIC	??1RoundInfo@@QAE@XZ				; RoundInfo::~RoundInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1RoundInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1RoundInfo@@QAE@XZ$0
__ehfuncinfo$??1RoundInfo@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1RoundInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??1RoundInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1RoundInfo@@QAE@XZ PROC				; RoundInfo::~RoundInfo, COMDAT
; _this$ = ecx
  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??1RoundInfo@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f9		 mov	 edi, ecx
  0000e	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  00011	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00017	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0001b	8d 4f 1c	 lea	 ecx, DWORD PTR [edi+28]
  0001e	ff d6		 call	 esi
  00020	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00024	8b cf		 mov	 ecx, edi
  00026	ff d6		 call	 esi
  00028	e8 00 00 00 00	 call	 __EH_epilog3
  0002d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1RoundInfo@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$??1RoundInfo@@QAE@XZ:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1RoundInfo@@QAE@XZ
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1RoundInfo@@QAE@XZ ENDP				; RoundInfo::~RoundInfo
PUBLIC	??_GRoundInfo@@QAEPAXI@Z			; RoundInfo::`scalar deleting destructor'
; Function compile flags: /Ogsp
;	COMDAT ??_GRoundInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GRoundInfo@@QAEPAXI@Z PROC				; RoundInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1RoundInfo@@QAE@XZ
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 07		 je	 SHORT $LN1@scalar@2
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	59		 pop	 ecx
$LN1@scalar@2:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??_GRoundInfo@@QAEPAXI@Z ENDP				; RoundInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$forward@AAPAURoundInfo@@@std@@YAAAPAURoundInfo@@AAPAU1@@Z ; std::forward<RoundInfo * &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@AAPAURoundInfo@@@std@@YAAAPAURoundInfo@@AAPAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAURoundInfo@@@std@@YAAAPAURoundInfo@@AAPAU1@@Z PROC ; std::forward<RoundInfo * &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAURoundInfo@@@std@@YAAAPAURoundInfo@@AAPAU1@@Z ENDP ; std::forward<RoundInfo * &>
_TEXT	ENDS
PUBLIC	??$?0AAPAURoundInfo@@AAPAU0@@?$_Pair_base@PAURoundInfo@@PAU1@@std@@QAE@AAPAURoundInfo@@0@Z ; std::_Pair_base<RoundInfo *,RoundInfo *>::_Pair_base<RoundInfo *,RoundInfo *><RoundInfo * &,RoundInfo * &>
; Function compile flags: /Ogsp
;	COMDAT ??$?0AAPAURoundInfo@@AAPAU0@@?$_Pair_base@PAURoundInfo@@PAU1@@std@@QAE@AAPAURoundInfo@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAURoundInfo@@AAPAU0@@?$_Pair_base@PAURoundInfo@@PAU1@@std@@QAE@AAPAURoundInfo@@0@Z PROC ; std::_Pair_base<RoundInfo *,RoundInfo *>::_Pair_base<RoundInfo *,RoundInfo *><RoundInfo * &,RoundInfo * &>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00011	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 164  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAPAURoundInfo@@AAPAU0@@?$_Pair_base@PAURoundInfo@@PAU1@@std@@QAE@AAPAURoundInfo@@0@Z ENDP ; std::_Pair_base<RoundInfo *,RoundInfo *>::_Pair_base<RoundInfo *,RoundInfo *><RoundInfo * &,RoundInfo * &>
_TEXT	ENDS
PUBLIC	??$_Move@AAURoundInfo@@@std@@YA$$QAURoundInfo@@AAU1@@Z ; std::_Move<RoundInfo &>
; Function compile flags: /Ogsp
;	COMDAT ??$_Move@AAURoundInfo@@@std@@YA$$QAURoundInfo@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAURoundInfo@@@std@@YA$$QAURoundInfo@@AAU1@@Z PROC ; std::_Move<RoundInfo &>, COMDAT

; 94   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Move@AAURoundInfo@@@std@@YA$$QAURoundInfo@@AAU1@@Z ENDP ; std::_Move<RoundInfo &>
_TEXT	ENDS
PUBLIC	??$forward@URoundInfo@@@std@@YA$$QAURoundInfo@@AAU1@@Z ; std::forward<RoundInfo>
; Function compile flags: /Ogsp
;	COMDAT ??$forward@URoundInfo@@@std@@YA$$QAURoundInfo@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@URoundInfo@@@std@@YA$$QAURoundInfo@@AAU1@@Z PROC ; std::forward<RoundInfo>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@URoundInfo@@@std@@YA$$QAURoundInfo@@AAU1@@Z ENDP ; std::forward<RoundInfo>
_TEXT	ENDS
PUBLIC	??$_Move_backward@PAURoundInfo@@PAU1@@std@@YAPAURoundInfo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move_backward<RoundInfo *,RoundInfo *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move_backward@PAURoundInfo@@PAU1@@std@@YAPAURoundInfo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move_backward@PAURoundInfo@@PAU1@@std@@YAPAURoundInfo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move_backward<RoundInfo *,RoundInfo *>, COMDAT

; 2617 : 	{	// move [_First, _Last) backwards to [..., _Dest), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 2618 : 	while (_First != _Last)

  00004	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  00007	39 7d 08	 cmp	 DWORD PTR __First$[ebp], edi
  0000a	74 1a		 je	 SHORT $LN9@Move_backw
  0000c	56		 push	 esi
  0000d	be 80 00 00 00	 mov	 esi, 128		; 00000080H
$LL2@Move_backw:

; 2619 : 		*--_Dest = _STD move(*--_Last);

  00012	29 75 10	 sub	 DWORD PTR __Dest$[ebp], esi
  00015	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00018	2b fe		 sub	 edi, esi
  0001a	57		 push	 edi
  0001b	e8 00 00 00 00	 call	 ??4RoundInfo@@QAEAAU0@ABU0@@Z
  00020	3b 7d 08	 cmp	 edi, DWORD PTR __First$[ebp]
  00023	75 ed		 jne	 SHORT $LL2@Move_backw
  00025	5e		 pop	 esi
$LN9@Move_backw:

; 2620 : 	return (_Dest);

  00026	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00029	5f		 pop	 edi

; 2621 : 	}

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Move_backward@PAURoundInfo@@PAU1@@std@@YAPAURoundInfo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move_backward<RoundInfo *,RoundInfo *>
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogsp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	ff 4d 10	 dec	 DWORD PTR ___n$[ebp]
  00006	78 12		 js	 SHORT $LN1@vector@2
  00008	56		 push	 esi
  00009	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector@2:
  0000c	8b ce		 mov	 ecx, esi
  0000e	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  00011	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00014	ff 4d 10	 dec	 DWORD PTR ___n$[ebp]
  00017	79 f3		 jns	 SHORT $LL2@vector@2
  00019	5e		 pop	 esi
$LN1@vector@2:
  0001a	5d		 pop	 ebp
  0001b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?_DECSTR@@YAXPADH@Z				; _DECSTR
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stringprotect.h
;	COMDAT ?_DECSTR@@YAXPADH@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_l$ = 12						; size = 4
?_DECSTR@@YAXPADH@Z PROC				; _DECSTR, COMDAT

; 40   : __forceinline void _DECSTR(char* s, int l){int i=0,l4=(l-1)/4,*p=(int*)s;s[l-1]=0;for(;i<l4;++i)*(p++)^=0xEAEBECED;for(i=l4*4;i<l-1;++i)s[i]^=0xED-i%4;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _l$[ebp]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  0000a	57		 push	 edi
  0000b	8d 79 ff	 lea	 edi, DWORD PTR [ecx-1]
  0000e	8b c7		 mov	 eax, edi
  00010	99		 cdq
  00011	83 e2 03	 and	 edx, 3
  00014	03 c2		 add	 eax, edx
  00016	c1 f8 02	 sar	 eax, 2
  00019	8b d6		 mov	 edx, esi
  0001b	c6 44 0e ff 00	 mov	 BYTE PTR [esi+ecx-1], 0
  00020	85 c0		 test	 eax, eax
  00022	7e 0e		 jle	 SHORT $LN4@DECSTR
  00024	8b c8		 mov	 ecx, eax
$LL6@DECSTR:
  00026	81 32 ed ec eb
	ea		 xor	 DWORD PTR [edx], -353637139 ; eaebecedH
  0002c	83 c2 04	 add	 edx, 4
  0002f	49		 dec	 ecx
  00030	75 f4		 jne	 SHORT $LL6@DECSTR
$LN4@DECSTR:
  00032	c1 e0 02	 shl	 eax, 2
  00035	eb 17		 jmp	 SHORT $LN14@DECSTR
$LL3@DECSTR:
  00037	8b c8		 mov	 ecx, eax
  00039	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0003f	79 05		 jns	 SHORT $LN13@DECSTR
  00041	49		 dec	 ecx
  00042	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00045	41		 inc	 ecx
$LN13@DECSTR:
  00046	b2 ed		 mov	 dl, -19			; ffffffedH
  00048	2a d1		 sub	 dl, cl
  0004a	30 14 30	 xor	 BYTE PTR [eax+esi], dl
  0004d	40		 inc	 eax
$LN14@DECSTR:
  0004e	3b c7		 cmp	 eax, edi
  00050	7c e5		 jl	 SHORT $LL3@DECSTR
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?_DECSTR@@YAXPADH@Z ENDP				; _DECSTR
_TEXT	ENDS
PUBLIC	??0tagCostumeEquipInfo@@QAE@ABU0@@Z		; tagCostumeEquipInfo::tagCostumeEquipInfo
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\costumeenumtype.h
;	COMDAT ??0tagCostumeEquipInfo@@QAE@ABU0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??0tagCostumeEquipInfo@@QAE@ABU0@@Z PROC		; tagCostumeEquipInfo::tagCostumeEquipInfo, COMDAT
; _this$ = ecx

; 42   : 	tagCostumeEquipInfo( const tagCostumeEquipInfo &rhs )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 43   : 	{
; 44   : 		m_CostumeIdx = rhs.m_CostumeIdx;

  00005	8b 4d 08	 mov	 ecx, DWORD PTR _rhs$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	89 10		 mov	 DWORD PTR [eax], edx

; 45   : 		m_CostumeCode = rhs.m_CostumeCode;

  0000c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0000f	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 46   : 		m_Costume_Male_Custom = rhs.m_Costume_Male_Custom;  

  00012	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00015	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 47   : 		m_Costume_Female_Custom = rhs.m_Costume_Female_Custom;

  00018	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  0001b	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 48   : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??0tagCostumeEquipInfo@@QAE@ABU0@@Z ENDP		; tagCostumeEquipInfo::tagCostumeEquipInfo
_TEXT	ENDS
PUBLIC	??0tagAccessoryEquipInfo@@QAE@ABU0@@Z		; tagAccessoryEquipInfo::tagAccessoryEquipInfo
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\accessoryenumtype.h
;	COMDAT ??0tagAccessoryEquipInfo@@QAE@ABU0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??0tagAccessoryEquipInfo@@QAE@ABU0@@Z PROC		; tagAccessoryEquipInfo::tagAccessoryEquipInfo, COMDAT
; _this$ = ecx

; 33   : 	tagAccessoryEquipInfo( const tagAccessoryEquipInfo &rhs )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 34   : 	{
; 35   : 		m_iAccessoryIdx = rhs.m_iAccessoryIdx;

  00005	8b 4d 08	 mov	 ecx, DWORD PTR _rhs$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	89 10		 mov	 DWORD PTR [eax], edx

; 36   : 		m_iAccessoryCode = rhs.m_iAccessoryCode;

  0000c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0000f	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 37   : 		m_iRandomNumber = rhs.m_iRandomNumber;

  00012	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00015	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 38   : 	}

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0tagAccessoryEquipInfo@@QAE@ABU0@@Z ENDP		; tagAccessoryEquipInfo::tagAccessoryEquipInfo
_TEXT	ENDS
PUBLIC	?GetServerDelayMS@ioGlobalTimer@@QBEKXZ		; ioGlobalTimer::GetServerDelayMS
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioglobaltimer.h
;	COMDAT ?GetServerDelayMS@ioGlobalTimer@@QBEKXZ
_TEXT	SEGMENT
?GetServerDelayMS@ioGlobalTimer@@QBEKXZ PROC		; ioGlobalTimer::GetServerDelayMS, COMDAT
; _this$ = ecx

; 48   : 	inline DWORD GetServerDelayMS() const { return m_server_delay_ms; }

  00000	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00003	c3		 ret	 0
?GetServerDelayMS@ioGlobalTimer@@QBEKXZ ENDP		; ioGlobalTimer::GetServerDelayMS
_TEXT	ENDS
PUBLIC	?IsMouseShowing@ioLSMouse@@QBE_NXZ		; ioLSMouse::IsMouseShowing
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iolsmouse.h
;	COMDAT ?IsMouseShowing@ioLSMouse@@QBE_NXZ
_TEXT	SEGMENT
?IsMouseShowing@ioLSMouse@@QBE_NXZ PROC			; ioLSMouse::IsMouseShowing, COMDAT
; _this$ = ecx

; 46   : 	bool IsMouseShowing() const { return m_bMouseShowing; }

  00000	8a 41 7c	 mov	 al, BYTE PTR [ecx+124]
  00003	c3		 ret	 0
?IsMouseShowing@ioLSMouse@@QBE_NXZ ENDP			; ioLSMouse::IsMouseShowing
_TEXT	ENDS
PUBLIC	?GetMouse@ioApplication@@QAEPAVioLSMouse@@XZ	; ioApplication::GetMouse
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioapplication.h
;	COMDAT ?GetMouse@ioApplication@@QAEPAVioLSMouse@@XZ
_TEXT	SEGMENT
?GetMouse@ioApplication@@QAEPAVioLSMouse@@XZ PROC	; ioApplication::GetMouse, COMDAT
; _this$ = ecx

; 796  : 	inline ioLSMouse* GetMouse(){ return &m_Mouse;	}

  00000	8d 81 90 00 00
	00		 lea	 eax, DWORD PTR [ecx+144]
  00006	c3		 ret	 0
?GetMouse@ioApplication@@QAEPAVioLSMouse@@XZ ENDP	; ioApplication::GetMouse
_TEXT	ENDS
PUBLIC	?GetPublicID@ioMyInfo@@QBEABVioHashString@@XZ	; ioMyInfo::GetPublicID
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iomyinfo.h
;	COMDAT ?GetPublicID@ioMyInfo@@QBEABVioHashString@@XZ
_TEXT	SEGMENT
?GetPublicID@ioMyInfo@@QBEABVioHashString@@XZ PROC	; ioMyInfo::GetPublicID, COMDAT
; _this$ = ecx

; 517  : 	const ioHashString& GetPublicID() const { return m_user_data.m_public_id; }    

  00000	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  00003	c3		 ret	 0
?GetPublicID@ioMyInfo@@QBEABVioHashString@@XZ ENDP	; ioMyInfo::GetPublicID
_TEXT	ENDS
PUBLIC	?GetHeroTodayRank@ioMyInfo@@QBEHXZ		; ioMyInfo::GetHeroTodayRank
; Function compile flags: /Ogsp
;	COMDAT ?GetHeroTodayRank@ioMyInfo@@QBEHXZ
_TEXT	SEGMENT
?GetHeroTodayRank@ioMyInfo@@QBEHXZ PROC			; ioMyInfo::GetHeroTodayRank, COMDAT
; _this$ = ecx

; 524  : 	int GetHeroTodayRank() const { return m_UserHeroData.m_iHeroTodayRank; }

  00000	8b 81 d8 01 00
	00		 mov	 eax, DWORD PTR [ecx+472]
  00006	c3		 ret	 0
?GetHeroTodayRank@ioMyInfo@@QBEHXZ ENDP			; ioMyInfo::GetHeroTodayRank
_TEXT	ENDS
PUBLIC	?GetGuildIndex@ioGuildData@@QAEKXZ		; ioGuildData::GetGuildIndex
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioguildinfo.h
;	COMDAT ?GetGuildIndex@ioGuildData@@QAEKXZ
_TEXT	SEGMENT
?GetGuildIndex@ioGuildData@@QAEKXZ PROC			; ioGuildData::GetGuildIndex, COMDAT
; _this$ = ecx

; 90   : 	inline DWORD GetGuildIndex(){ return m_dwGuildIndex; }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetGuildIndex@ioGuildData@@QAEKXZ ENDP			; ioGuildData::GetGuildIndex
_TEXT	ENDS
PUBLIC	?GetGuildMark@ioGuildData@@QAEKXZ		; ioGuildData::GetGuildMark
; Function compile flags: /Ogsp
;	COMDAT ?GetGuildMark@ioGuildData@@QAEKXZ
_TEXT	SEGMENT
?GetGuildMark@ioGuildData@@QAEKXZ PROC			; ioGuildData::GetGuildMark, COMDAT
; _this$ = ecx

; 91   : 	inline DWORD GetGuildMark(){ return m_dwGuildMark; }

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	c3		 ret	 0
?GetGuildMark@ioGuildData@@QAEKXZ ENDP			; ioGuildData::GetGuildMark
_TEXT	ENDS
PUBLIC	?GetMaxPlayer@ioBattleRoomMgr@@QAEHXZ		; ioBattleRoomMgr::GetMaxPlayer
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobattleroommgr.h
;	COMDAT ?GetMaxPlayer@ioBattleRoomMgr@@QAEHXZ
_TEXT	SEGMENT
?GetMaxPlayer@ioBattleRoomMgr@@QAEHXZ PROC		; ioBattleRoomMgr::GetMaxPlayer, COMDAT
; _this$ = ecx

; 461  : 	int GetMaxPlayer(){ return m_BattleRoom.m_iMaxPlayerBlue + m_BattleRoom.m_iMaxPlayerRed; }

  00000	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  00003	03 41 40	 add	 eax, DWORD PTR [ecx+64]
  00006	c3		 ret	 0
?GetMaxPlayer@ioBattleRoomMgr@@QAEHXZ ENDP		; ioBattleRoomMgr::GetMaxPlayer
_TEXT	ENDS
PUBLIC	?GetMaxPlayerBlue@ioBattleRoomMgr@@QAEHXZ	; ioBattleRoomMgr::GetMaxPlayerBlue
; Function compile flags: /Ogsp
;	COMDAT ?GetMaxPlayerBlue@ioBattleRoomMgr@@QAEHXZ
_TEXT	SEGMENT
?GetMaxPlayerBlue@ioBattleRoomMgr@@QAEHXZ PROC		; ioBattleRoomMgr::GetMaxPlayerBlue, COMDAT
; _this$ = ecx

; 462  : 	int GetMaxPlayerBlue(){ return m_BattleRoom.m_iMaxPlayerBlue; }

  00000	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]
  00003	c3		 ret	 0
?GetMaxPlayerBlue@ioBattleRoomMgr@@QAEHXZ ENDP		; ioBattleRoomMgr::GetMaxPlayerBlue
_TEXT	ENDS
PUBLIC	?GetMaxPlayerRed@ioBattleRoomMgr@@QAEHXZ	; ioBattleRoomMgr::GetMaxPlayerRed
; Function compile flags: /Ogsp
;	COMDAT ?GetMaxPlayerRed@ioBattleRoomMgr@@QAEHXZ
_TEXT	SEGMENT
?GetMaxPlayerRed@ioBattleRoomMgr@@QAEHXZ PROC		; ioBattleRoomMgr::GetMaxPlayerRed, COMDAT
; _this$ = ecx

; 463  : 	int GetMaxPlayerRed(){ return m_BattleRoom.m_iMaxPlayerRed; }

  00000	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  00003	c3		 ret	 0
?GetMaxPlayerRed@ioBattleRoomMgr@@QAEHXZ ENDP		; ioBattleRoomMgr::GetMaxPlayerRed
_TEXT	ENDS
PUBLIC	?GetName@ioBattleRoomMgr@@QAE?AVioHashString@@XZ ; ioBattleRoomMgr::GetName
; Function compile flags: /Ogsp
;	COMDAT ?GetName@ioBattleRoomMgr@@QAE?AVioHashString@@XZ
_TEXT	SEGMENT
$T557295 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetName@ioBattleRoomMgr@@QAE?AVioHashString@@XZ PROC	; ioBattleRoomMgr::GetName, COMDAT
; _this$ = ecx

; 506  : 	ioHashString GetName(){ return m_BattleRoom.m_szName; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	83 65 fc 00	 and	 DWORD PTR $T557295[ebp], 0
  00008	83 c1 08	 add	 ecx, 8
  0000b	51		 push	 ecx
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  00015	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00018	c9		 leave
  00019	c2 04 00	 ret	 4
?GetName@ioBattleRoomMgr@@QAE?AVioHashString@@XZ ENDP	; ioBattleRoomMgr::GetName
_TEXT	ENDS
PUBLIC	?GetPW@ioBattleRoomMgr@@QAE?AVioHashString@@XZ	; ioBattleRoomMgr::GetPW
; Function compile flags: /Ogsp
;	COMDAT ?GetPW@ioBattleRoomMgr@@QAE?AVioHashString@@XZ
_TEXT	SEGMENT
$T557300 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetPW@ioBattleRoomMgr@@QAE?AVioHashString@@XZ PROC	; ioBattleRoomMgr::GetPW, COMDAT
; _this$ = ecx

; 508  : 	ioHashString GetPW(){ return m_BattleRoom.m_szPassword; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	83 65 fc 00	 and	 DWORD PTR $T557300[ebp], 0
  00008	83 c1 28	 add	 ecx, 40			; 00000028H
  0000b	51		 push	 ecx
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  00015	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00018	c9		 leave
  00019	c2 04 00	 ret	 4
?GetPW@ioBattleRoomMgr@@QAE?AVioHashString@@XZ ENDP	; ioBattleRoomMgr::GetPW
_TEXT	ENDS
PUBLIC	?GetTournamentIndex@ioBattleRoomMgr@@QAEKXZ	; ioBattleRoomMgr::GetTournamentIndex
; Function compile flags: /Ogsp
;	COMDAT ?GetTournamentIndex@ioBattleRoomMgr@@QAEKXZ
_TEXT	SEGMENT
?GetTournamentIndex@ioBattleRoomMgr@@QAEKXZ PROC	; ioBattleRoomMgr::GetTournamentIndex, COMDAT
; _this$ = ecx

; 605  : 	DWORD GetTournamentIndex(){ return m_BattleRoom.m_dwTourIndex; }

  00000	8b 81 80 01 00
	00		 mov	 eax, DWORD PTR [ecx+384]
  00006	c3		 ret	 0
?GetTournamentIndex@ioBattleRoomMgr@@QAEKXZ ENDP	; ioBattleRoomMgr::GetTournamentIndex
_TEXT	ENDS
PUBLIC	?GetTournamentBlueIndex@ioBattleRoomMgr@@QAEKXZ	; ioBattleRoomMgr::GetTournamentBlueIndex
; Function compile flags: /Ogsp
;	COMDAT ?GetTournamentBlueIndex@ioBattleRoomMgr@@QAEKXZ
_TEXT	SEGMENT
?GetTournamentBlueIndex@ioBattleRoomMgr@@QAEKXZ PROC	; ioBattleRoomMgr::GetTournamentBlueIndex, COMDAT
; _this$ = ecx

; 606  : 	DWORD GetTournamentBlueIndex(){ return m_BattleRoom.m_dwBlueTeamIndex; }

  00000	8b 81 84 01 00
	00		 mov	 eax, DWORD PTR [ecx+388]
  00006	c3		 ret	 0
?GetTournamentBlueIndex@ioBattleRoomMgr@@QAEKXZ ENDP	; ioBattleRoomMgr::GetTournamentBlueIndex
_TEXT	ENDS
PUBLIC	?GetTournamentRedIndex@ioBattleRoomMgr@@QAEKXZ	; ioBattleRoomMgr::GetTournamentRedIndex
; Function compile flags: /Ogsp
;	COMDAT ?GetTournamentRedIndex@ioBattleRoomMgr@@QAEKXZ
_TEXT	SEGMENT
?GetTournamentRedIndex@ioBattleRoomMgr@@QAEKXZ PROC	; ioBattleRoomMgr::GetTournamentRedIndex, COMDAT
; _this$ = ecx

; 607  : 	DWORD GetTournamentRedIndex(){ return m_BattleRoom.m_dwRedTeamIndex; }

  00000	8b 81 88 01 00
	00		 mov	 eax, DWORD PTR [ecx+392]
  00006	c3		 ret	 0
?GetTournamentRedIndex@ioBattleRoomMgr@@QAEKXZ ENDP	; ioBattleRoomMgr::GetTournamentRedIndex
_TEXT	ENDS
PUBLIC	?GetModeState@ioPlayMode@@QBE?AW4ModeState@1@XZ	; ioPlayMode::GetModeState
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioplaymode.h
;	COMDAT ?GetModeState@ioPlayMode@@QBE?AW4ModeState@1@XZ
_TEXT	SEGMENT
?GetModeState@ioPlayMode@@QBE?AW4ModeState@1@XZ PROC	; ioPlayMode::GetModeState, COMDAT
; _this$ = ecx

; 632  : 	inline ModeState GetModeState() const { return m_ModeState; }

  00000	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00003	c3		 ret	 0
?GetModeState@ioPlayMode@@QBE?AW4ModeState@1@XZ ENDP	; ioPlayMode::GetModeState
_TEXT	ENDS
PUBLIC	?GetMasterName@ioHeadquartersMode@@QAEAAVioHashString@@XZ ; ioHeadquartersMode::GetMasterName
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioheadquartersmode.h
;	COMDAT ?GetMasterName@ioHeadquartersMode@@QAEAAVioHashString@@XZ
_TEXT	SEGMENT
?GetMasterName@ioHeadquartersMode@@QAEAAVioHashString@@XZ PROC ; ioHeadquartersMode::GetMasterName, COMDAT
; _this$ = ecx

; 193  : 	inline ioHashString &GetMasterName(){ return m_szMasterName; }

  00000	8d 81 f4 04 00
	00		 lea	 eax, DWORD PTR [ecx+1268]
  00006	c3		 ret	 0
?GetMasterName@ioHeadquartersMode@@QAEAAVioHashString@@XZ ENDP ; ioHeadquartersMode::GetMasterName
_TEXT	ENDS
PUBLIC	??RRoundInfoSort@@QBE_NABURoundInfo@@0@Z	; RoundInfoSort::operator()
EXTRN	__imp__stricmp:PROC
EXTRN	__imp_?IsEmpty@ioHashString@@QBE_NXZ:PROC
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\resultinfo.h
;	COMDAT ??RRoundInfoSort@@QBE_NABURoundInfo@@0@Z
_TEXT	SEGMENT
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??RRoundInfoSort@@QBE_NABURoundInfo@@0@Z PROC		; RoundInfoSort::operator(), COMDAT
; _this$ = ecx

; 78   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 79   : 		if( lhs.m_szName.IsEmpty() )

  00004	8b 75 08	 mov	 esi, DWORD PTR _lhs$[ebp]
  00007	8b ce		 mov	 ecx, esi
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  0000f	84 c0		 test	 al, al
  00011	74 10		 je	 SHORT $LN12@operator

; 80   : 		{
; 81   : 			if( rhs.m_szName.IsEmpty() )

  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _rhs$[ebp]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  0001c	84 c0		 test	 al, al
  0001e	0f 95 c0	 setne	 al

; 82   : 				return true;
; 83   : 			else
; 84   : 				return false;

  00021	eb 59		 jmp	 SHORT $LN13@operator
$LN12@operator:
  00023	57		 push	 edi

; 85   : 		}
; 86   : 		else if( !lhs.m_szName.IsEmpty() && rhs.m_szName.IsEmpty() )

  00024	8b ce		 mov	 ecx, esi
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  0002c	8b 7d 0c	 mov	 edi, DWORD PTR _rhs$[ebp]
  0002f	84 c0		 test	 al, al
  00031	75 0c		 jne	 SHORT $LN8@operator
  00033	8b cf		 mov	 ecx, edi
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  0003b	84 c0		 test	 al, al

; 87   : 		{
; 88   : 			return true;

  0003d	75 36		 jne	 SHORT $LN18@operator
$LN8@operator:

; 89   : 		}
; 90   : 
; 91   : 
; 92   : 		if( lhs.m_iContribute > rhs.m_iContribute )

  0003f	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00042	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  00045	3b c1		 cmp	 eax, ecx

; 93   : 		{
; 94   : 			return true;

  00047	7f 2c		 jg	 SHORT $LN18@operator

; 95   : 		}
; 96   : 		else if( lhs.m_iContribute == rhs.m_iContribute )

  00049	75 2e		 jne	 SHORT $LN1@operator

; 97   : 		{
; 98   : 			if( lhs.m_iLevel > rhs.m_iLevel )         

  0004b	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  0004e	8b 4f 44	 mov	 ecx, DWORD PTR [edi+68]
  00051	3b c1		 cmp	 eax, ecx

; 99   : 			{
; 100  : 				return true;

  00053	7f 20		 jg	 SHORT $LN18@operator

; 101  : 			}
; 102  : 			else if( lhs.m_iLevel == rhs.m_iLevel )

  00055	75 22		 jne	 SHORT $LN1@operator

; 103  : 			{
; 104  : 				int iCmpValue = stricmp( lhs.m_szName.c_str(), rhs.m_szName.c_str() );     

  00057	8b cf		 mov	 ecx, edi
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  0005f	50		 push	 eax
  00060	8b ce		 mov	 ecx, esi
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00068	50		 push	 eax
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__stricmp
  0006f	59		 pop	 ecx
  00070	59		 pop	 ecx

; 105  : 				if( iCmpValue < 0 )

  00071	85 c0		 test	 eax, eax
  00073	79 04		 jns	 SHORT $LN1@operator
$LN18@operator:

; 106  : 					return true;

  00075	b0 01		 mov	 al, 1
  00077	eb 02		 jmp	 SHORT $LN15@operator
$LN1@operator:

; 107  : 			}
; 108  : 		}	
; 109  : 		return false;

  00079	32 c0		 xor	 al, al
$LN15@operator:
  0007b	5f		 pop	 edi
$LN13@operator:
  0007c	5e		 pop	 esi

; 110  : 	}

  0007d	5d		 pop	 ebp
  0007e	c2 08 00	 ret	 8
??RRoundInfoSort@@QBE_NABURoundInfo@@0@Z ENDP		; RoundInfoSort::operator()
_TEXT	ENDS
PUBLIC	??RRoundInfoKoSort@@QBE_NABURoundInfo@@0@Z	; RoundInfoKoSort::operator()
; Function compile flags: /Ogsp
;	COMDAT ??RRoundInfoKoSort@@QBE_NABURoundInfo@@0@Z
_TEXT	SEGMENT
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??RRoundInfoKoSort@@QBE_NABURoundInfo@@0@Z PROC		; RoundInfoKoSort::operator(), COMDAT
; _this$ = ecx

; 117  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 118  : 		if( lhs.m_szName.IsEmpty() )

  00004	8b 75 08	 mov	 esi, DWORD PTR _lhs$[ebp]
  00007	8b ce		 mov	 ecx, esi
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  0000f	84 c0		 test	 al, al
  00011	74 10		 je	 SHORT $LN15@operator@2

; 119  : 		{
; 120  : 			if( rhs.m_szName.IsEmpty() )

  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _rhs$[ebp]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  0001c	84 c0		 test	 al, al
  0001e	0f 95 c0	 setne	 al

; 121  : 				return true;
; 122  : 			else
; 123  : 				return false;

  00021	eb 65		 jmp	 SHORT $LN16@operator@2
$LN15@operator@2:
  00023	57		 push	 edi

; 124  : 		}
; 125  : 		else if( !lhs.m_szName.IsEmpty() && rhs.m_szName.IsEmpty() )

  00024	8b ce		 mov	 ecx, esi
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  0002c	8b 7d 0c	 mov	 edi, DWORD PTR _rhs$[ebp]
  0002f	84 c0		 test	 al, al
  00031	75 0c		 jne	 SHORT $LN11@operator@2
  00033	8b cf		 mov	 ecx, edi
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  0003b	84 c0		 test	 al, al

; 126  : 		{
; 127  : 			return true;

  0003d	75 42		 jne	 SHORT $LN22@operator@2
$LN11@operator@2:

; 128  : 		}
; 129  : 
; 130  : 		if( lhs.m_iUniqueTotalKill > rhs.m_iUniqueTotalKill )  

  0003f	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00042	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  00045	3b c1		 cmp	 eax, ecx

; 131  : 		{
; 132  : 			return true;

  00047	7f 38		 jg	 SHORT $LN22@operator@2

; 133  : 		}
; 134  : 		else if( lhs.m_iUniqueTotalKill == rhs.m_iUniqueTotalKill )

  00049	75 3a		 jne	 SHORT $LN1@operator@2

; 135  : 		{
; 136  : 			if( lhs.m_iUniqueTotalDeath < rhs.m_iUniqueTotalDeath )

  0004b	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  0004e	8b 4f 38	 mov	 ecx, DWORD PTR [edi+56]
  00051	3b c1		 cmp	 eax, ecx

; 137  : 			{
; 138  : 				return true;

  00053	7c 2c		 jl	 SHORT $LN22@operator@2

; 139  : 			}
; 140  : 			else if( lhs.m_iUniqueTotalDeath == rhs.m_iUniqueTotalDeath	)

  00055	75 2e		 jne	 SHORT $LN1@operator@2

; 141  : 			{
; 142  : 				if( lhs.m_iLevel > rhs.m_iLevel )

  00057	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  0005a	8b 4f 44	 mov	 ecx, DWORD PTR [edi+68]
  0005d	3b c1		 cmp	 eax, ecx

; 143  : 				{
; 144  : 					return true;

  0005f	7f 20		 jg	 SHORT $LN22@operator@2

; 145  : 				}
; 146  : 				else if( lhs.m_iLevel == rhs.m_iLevel )

  00061	75 22		 jne	 SHORT $LN1@operator@2

; 147  : 				{
; 148  : 					int iCmpValue = stricmp( lhs.m_szName.c_str(), rhs.m_szName.c_str() );     

  00063	8b cf		 mov	 ecx, edi
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  0006b	50		 push	 eax
  0006c	8b ce		 mov	 ecx, esi
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00074	50		 push	 eax
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__stricmp
  0007b	59		 pop	 ecx
  0007c	59		 pop	 ecx

; 149  : 					if( iCmpValue < 0 )

  0007d	85 c0		 test	 eax, eax
  0007f	79 04		 jns	 SHORT $LN1@operator@2
$LN22@operator@2:

; 150  : 						return true;

  00081	b0 01		 mov	 al, 1
  00083	eb 02		 jmp	 SHORT $LN18@operator@2
$LN1@operator@2:

; 151  : 				}
; 152  : 			}
; 153  : 		}		
; 154  : 		return false;

  00085	32 c0		 xor	 al, al
$LN18@operator@2:
  00087	5f		 pop	 edi
$LN16@operator@2:
  00088	5e		 pop	 esi

; 155  : 	}

  00089	5d		 pop	 ebp
  0008a	c2 08 00	 ret	 8
??RRoundInfoKoSort@@QBE_NABURoundInfo@@0@Z ENDP		; RoundInfoKoSort::operator()
_TEXT	ENDS
PUBLIC	??RRoundInfoStarSort@@QBE_NABURoundInfo@@0@Z	; RoundInfoStarSort::operator()
; Function compile flags: /Ogsp
;	COMDAT ??RRoundInfoStarSort@@QBE_NABURoundInfo@@0@Z
_TEXT	SEGMENT
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??RRoundInfoStarSort@@QBE_NABURoundInfo@@0@Z PROC	; RoundInfoStarSort::operator(), COMDAT
; _this$ = ecx

; 193  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 194  : 		if( lhs.m_szName.IsEmpty() )

  00004	8b 75 08	 mov	 esi, DWORD PTR _lhs$[ebp]
  00007	8b ce		 mov	 ecx, esi
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  0000f	84 c0		 test	 al, al
  00011	74 10		 je	 SHORT $LN18@operator@3

; 195  : 		{
; 196  : 			if( rhs.m_szName.IsEmpty() )

  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _rhs$[ebp]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  0001c	84 c0		 test	 al, al
  0001e	0f 95 c0	 setne	 al

; 197  : 				return true;
; 198  : 			else
; 199  : 				return false;

  00021	eb 71		 jmp	 SHORT $LN19@operator@3
$LN18@operator@3:
  00023	57		 push	 edi

; 200  : 		}
; 201  : 		else if( !lhs.m_szName.IsEmpty() && rhs.m_szName.IsEmpty() )

  00024	8b ce		 mov	 ecx, esi
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  0002c	8b 7d 0c	 mov	 edi, DWORD PTR _rhs$[ebp]
  0002f	84 c0		 test	 al, al
  00031	75 0c		 jne	 SHORT $LN14@operator@3
  00033	8b cf		 mov	 ecx, edi
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  0003b	84 c0		 test	 al, al

; 202  : 		{
; 203  : 			return true;

  0003d	75 4e		 jne	 SHORT $LN26@operator@3
$LN14@operator@3:

; 204  : 		}
; 205  : 
; 206  : 		if( lhs.m_iStarCnt > rhs.m_iStarCnt )  

  0003f	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  00042	8b 4f 74	 mov	 ecx, DWORD PTR [edi+116]
  00045	3b c1		 cmp	 eax, ecx

; 207  : 		{
; 208  : 			return true;

  00047	7f 44		 jg	 SHORT $LN26@operator@3

; 209  : 		}
; 210  : 		else if( lhs.m_iStarCnt == rhs.m_iStarCnt )

  00049	75 46		 jne	 SHORT $LN1@operator@3

; 211  : 		{
; 212  : 			if( lhs.m_iUniqueTotalKill > rhs.m_iUniqueTotalKill )  

  0004b	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0004e	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  00051	3b c1		 cmp	 eax, ecx

; 213  : 			{
; 214  : 				return true;

  00053	7f 38		 jg	 SHORT $LN26@operator@3

; 215  : 			}
; 216  : 			else if( lhs.m_iUniqueTotalKill == rhs.m_iUniqueTotalKill )

  00055	75 3a		 jne	 SHORT $LN1@operator@3

; 217  : 			{
; 218  : 				if( lhs.m_iUniqueTotalDeath < rhs.m_iUniqueTotalDeath )

  00057	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  0005a	8b 4f 38	 mov	 ecx, DWORD PTR [edi+56]
  0005d	3b c1		 cmp	 eax, ecx

; 219  : 				{
; 220  : 					return true;

  0005f	7c 2c		 jl	 SHORT $LN26@operator@3

; 221  : 				}
; 222  : 				else if( lhs.m_iUniqueTotalDeath == rhs.m_iUniqueTotalDeath	)

  00061	75 2e		 jne	 SHORT $LN1@operator@3

; 223  : 				{
; 224  : 					if( lhs.m_iLevel > rhs.m_iLevel )

  00063	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  00066	8b 4f 44	 mov	 ecx, DWORD PTR [edi+68]
  00069	3b c1		 cmp	 eax, ecx

; 225  : 					{
; 226  : 						return true;

  0006b	7f 20		 jg	 SHORT $LN26@operator@3

; 227  : 					}
; 228  : 					else if( lhs.m_iLevel == rhs.m_iLevel )

  0006d	75 22		 jne	 SHORT $LN1@operator@3

; 229  : 					{
; 230  : 						int iCmpValue = stricmp( lhs.m_szName.c_str(), rhs.m_szName.c_str() );     

  0006f	8b cf		 mov	 ecx, edi
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00077	50		 push	 eax
  00078	8b ce		 mov	 ecx, esi
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00080	50		 push	 eax
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__stricmp
  00087	59		 pop	 ecx
  00088	59		 pop	 ecx

; 231  : 						if( iCmpValue < 0 )

  00089	85 c0		 test	 eax, eax
  0008b	79 04		 jns	 SHORT $LN1@operator@3
$LN26@operator@3:

; 232  : 							return true;

  0008d	b0 01		 mov	 al, 1
  0008f	eb 02		 jmp	 SHORT $LN21@operator@3
$LN1@operator@3:

; 233  : 					}
; 234  : 				}
; 235  : 			}
; 236  : 		}		
; 237  : 		return false;

  00091	32 c0		 xor	 al, al
$LN21@operator@3:
  00093	5f		 pop	 edi
$LN19@operator@3:
  00094	5e		 pop	 esi

; 238  : 	}

  00095	5d		 pop	 ebp
  00096	c2 08 00	 ret	 8
??RRoundInfoStarSort@@QBE_NABURoundInfo@@0@Z ENDP	; RoundInfoStarSort::operator()
_TEXT	ENDS
PUBLIC	?GetPreOverWnd@ioSP2GUIManager@@QAEPAVioWnd@@XZ	; ioSP2GUIManager::GetPreOverWnd
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\iosp2guimanager.h
;	COMDAT ?GetPreOverWnd@ioSP2GUIManager@@QAEPAVioWnd@@XZ
_TEXT	SEGMENT
?GetPreOverWnd@ioSP2GUIManager@@QAEPAVioWnd@@XZ PROC	; ioSP2GUIManager::GetPreOverWnd, COMDAT
; _this$ = ecx

; 220  : 	ioWnd *GetPreOverWnd(){ return m_pPreOverWnd; }

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00003	c3		 ret	 0
?GetPreOverWnd@ioSP2GUIManager@@QAEPAVioWnd@@XZ ENDP	; ioSP2GUIManager::GetPreOverWnd
_TEXT	ENDS
PUBLIC	??_7?$CEncrypt@_N@@6B@				; CEncrypt<bool>::`vftable'
PUBLIC	??1?$CEncrypt@_N@@UAE@XZ			; CEncrypt<bool>::~CEncrypt<bool>
PUBLIC	??_R4?$CEncrypt@_N@@6B@				; CEncrypt<bool>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CEncrypt@_N@@@8			; CEncrypt<bool> `RTTI Type Descriptor'
PUBLIC	??_R3?$CEncrypt@_N@@8				; CEncrypt<bool>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CEncrypt@_N@@8				; CEncrypt<bool>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CEncrypt@_N@@8			; CEncrypt<bool>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??1ccddaabb@@UAE@XZ:PROC			; ccddaabb::~ccddaabb
EXTRN	??_E?$CEncrypt@_N@@UAEPAXI@Z:PROC		; CEncrypt<bool>::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$CEncrypt@_N@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CEncrypt@_N@@8 DD FLAT:??_R0?AV?$CEncrypt@_N@@@8 ; CEncrypt<bool>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CEncrypt@_N@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CEncrypt@_N@@8
rdata$r	SEGMENT
??_R2?$CEncrypt@_N@@8 DD FLAT:??_R1A@?0A@EA@?$CEncrypt@_N@@8 ; CEncrypt<bool>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CEncrypt@_N@@8
rdata$r	SEGMENT
??_R3?$CEncrypt@_N@@8 DD 00H				; CEncrypt<bool>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CEncrypt@_N@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CEncrypt@_N@@@8
_DATA	SEGMENT
??_R0?AV?$CEncrypt@_N@@@8 DD FLAT:??_7type_info@@6B@	; CEncrypt<bool> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CEncrypt@_N@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$CEncrypt@_N@@6B@
rdata$r	SEGMENT
??_R4?$CEncrypt@_N@@6B@ DD 00H				; CEncrypt<bool>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CEncrypt@_N@@@8
	DD	FLAT:??_R3?$CEncrypt@_N@@8
rdata$r	ENDS
;	COMDAT ??_7?$CEncrypt@_N@@6B@
CONST	SEGMENT
??_7?$CEncrypt@_N@@6B@ DD FLAT:??_R4?$CEncrypt@_N@@6B@	; CEncrypt<bool>::`vftable'
	DD	FLAT:??_E?$CEncrypt@_N@@UAEPAXI@Z
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??1?$CEncrypt@_N@@UAE@XZ
_TEXT	SEGMENT
??1?$CEncrypt@_N@@UAE@XZ PROC				; CEncrypt<bool>::~CEncrypt<bool>, COMDAT
; _this$ = ecx

; 127  : 	{

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CEncrypt@_N@@6B@

; 128  : 	}

  00006	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00009	e9 00 00 00 00	 jmp	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
??1?$CEncrypt@_N@@UAE@XZ ENDP				; CEncrypt<bool>::~CEncrypt<bool>
_TEXT	ENDS
PUBLIC	??_7?$CEncrypt@H@@6B@				; CEncrypt<int>::`vftable'
PUBLIC	??1?$CEncrypt@H@@UAE@XZ				; CEncrypt<int>::~CEncrypt<int>
PUBLIC	??_R4?$CEncrypt@H@@6B@				; CEncrypt<int>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CEncrypt@H@@@8			; CEncrypt<int> `RTTI Type Descriptor'
PUBLIC	??_R3?$CEncrypt@H@@8				; CEncrypt<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CEncrypt@H@@8				; CEncrypt<int>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CEncrypt@H@@8			; CEncrypt<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_E?$CEncrypt@H@@UAEPAXI@Z:PROC		; CEncrypt<int>::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$CEncrypt@H@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CEncrypt@H@@8 DD FLAT:??_R0?AV?$CEncrypt@H@@@8 ; CEncrypt<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CEncrypt@H@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CEncrypt@H@@8
rdata$r	SEGMENT
??_R2?$CEncrypt@H@@8 DD FLAT:??_R1A@?0A@EA@?$CEncrypt@H@@8 ; CEncrypt<int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CEncrypt@H@@8
rdata$r	SEGMENT
??_R3?$CEncrypt@H@@8 DD 00H				; CEncrypt<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CEncrypt@H@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CEncrypt@H@@@8
_DATA	SEGMENT
??_R0?AV?$CEncrypt@H@@@8 DD FLAT:??_7type_info@@6B@	; CEncrypt<int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CEncrypt@H@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$CEncrypt@H@@6B@
rdata$r	SEGMENT
??_R4?$CEncrypt@H@@6B@ DD 00H				; CEncrypt<int>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CEncrypt@H@@@8
	DD	FLAT:??_R3?$CEncrypt@H@@8
rdata$r	ENDS
;	COMDAT ??_7?$CEncrypt@H@@6B@
CONST	SEGMENT
??_7?$CEncrypt@H@@6B@ DD FLAT:??_R4?$CEncrypt@H@@6B@	; CEncrypt<int>::`vftable'
	DD	FLAT:??_E?$CEncrypt@H@@UAEPAXI@Z
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??1?$CEncrypt@H@@UAE@XZ
_TEXT	SEGMENT
??1?$CEncrypt@H@@UAE@XZ PROC				; CEncrypt<int>::~CEncrypt<int>, COMDAT
; _this$ = ecx

; 127  : 	{

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CEncrypt@H@@6B@

; 128  : 	}

  00006	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00009	e9 00 00 00 00	 jmp	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
??1?$CEncrypt@H@@UAE@XZ ENDP				; CEncrypt<int>::~CEncrypt<int>
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??_G?$CEncrypt@_N@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CEncrypt@_N@@UAEPAXI@Z PROC			; CEncrypt<bool>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CEncrypt@_N@@6B@
  0000f	e8 00 00 00 00	 call	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
  00014	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00018	74 07		 je	 SHORT $LN1@scalar@3
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	59		 pop	 ecx
$LN1@scalar@3:
  00021	8b c6		 mov	 eax, esi
  00023	5e		 pop	 esi
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??_G?$CEncrypt@_N@@UAEPAXI@Z ENDP			; CEncrypt<bool>::`scalar deleting destructor'
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??_G?$CEncrypt@H@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CEncrypt@H@@UAEPAXI@Z PROC			; CEncrypt<int>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CEncrypt@H@@6B@
  0000f	e8 00 00 00 00	 call	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
  00014	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00018	74 07		 je	 SHORT $LN1@scalar@4
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	59		 pop	 ecx
$LN1@scalar@4:
  00021	8b c6		 mov	 eax, esi
  00023	5e		 pop	 esi
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??_G?$CEncrypt@H@@UAEPAXI@Z ENDP			; CEncrypt<int>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?EncryptValueToPool@?$CEncrypt@_N@@AAEXPBD@Z	; CEncrypt<bool>::EncryptValueToPool
EXTRN	?EncryptByte@ccddaabb@@QAEXPBDPADH@Z:PROC	; ccddaabb::EncryptByte
; Function compile flags: /Ogsp
;	COMDAT ?EncryptValueToPool@?$CEncrypt@_N@@AAEXPBD@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?EncryptValueToPool@?$CEncrypt@_N@@AAEXPBD@Z PROC	; CEncrypt<bool>::EncryptValueToPool, COMDAT
; _this$ = ecx

; 67   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 		m_RC5.EncryptByte( value, m_MemPool, max(m_ValueSize, DEFAULT_ENCRYPT) );

  00003	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00007	83 f8 04	 cmp	 eax, 4
  0000a	77 03		 ja	 SHORT $LN4@EncryptVal
  0000c	6a 04		 push	 4
  0000e	58		 pop	 eax
$LN4@EncryptVal:
  0000f	50		 push	 eax
  00010	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  00013	50		 push	 eax
  00014	ff 75 08	 push	 DWORD PTR _value$[ebp]
  00017	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0001a	e8 00 00 00 00	 call	 ?EncryptByte@ccddaabb@@QAEXPBDPADH@Z ; ccddaabb::EncryptByte

; 69   : 		
; 70   : 	}

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?EncryptValueToPool@?$CEncrypt@_N@@AAEXPBD@Z ENDP	; CEncrypt<bool>::EncryptValueToPool
_TEXT	ENDS
PUBLIC	?Init@?$CEncrypt@_N@@AAEXXZ			; CEncrypt<bool>::Init
EXTRN	?Setup@ccddaabb@@QAEXPBDHH@Z:PROC		; ccddaabb::Setup
EXTRN	__imp__rand:PROC
EXTRN	__imp__timeGetTime@0:PROC
EXTRN	__imp__GetCurrentProcessId@0:PROC
; Function compile flags: /Ogsp
;	COMDAT ?Init@?$CEncrypt@_N@@AAEXXZ
_TEXT	SEGMENT
_pid$ = -8						; size = 4
_tick$ = -4						; size = 4
?Init@?$CEncrypt@_N@@AAEXXZ PROC			; CEncrypt<bool>::Init, COMDAT
; _this$ = ecx

; 73   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx

; 74   : 		DWORD pid = GetCurrentProcessId();

  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcessId@0
  00010	89 45 f8	 mov	 DWORD PTR _pid$[ebp], eax

; 75   : 		DWORD tick = timeGetTime();

  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0

; 76   : 		m_ValueSize    = sizeof(type);
; 77   : 		m_MemPoolPos   = (unsigned short)( rand()+pid+tick )%(MAX_MEM_POOL-m_ValueSize);

  00019	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__rand
  0001f	89 45 fc	 mov	 DWORD PTR _tick$[ebp], eax
  00022	33 c0		 xor	 eax, eax
  00024	40		 inc	 eax
  00025	66 89 46 06	 mov	 WORD PTR [esi+6], ax
  00029	ff d7		 call	 edi
  0002b	03 45 f8	 add	 eax, DWORD PTR _pid$[ebp]
  0002e	0f b7 4e 06	 movzx	 ecx, WORD PTR [esi+6]
  00032	03 45 fc	 add	 eax, DWORD PTR _tick$[ebp]
  00035	6a 0c		 push	 12			; 0000000cH
  00037	0f b7 c0	 movzx	 eax, ax
  0003a	5b		 pop	 ebx
  0003b	99		 cdq
  0003c	2b d9		 sub	 ebx, ecx
  0003e	f7 fb		 idiv	 ebx
  00040	66 89 56 04	 mov	 WORD PTR [esi+4], dx

; 78   : 		m_EncryptSeed  = (char)( rand()+pid+tick )%256;

  00044	ff d7		 call	 edi
  00046	02 45 f8	 add	 al, BYTE PTR _pid$[ebp]
  00049	02 45 fc	 add	 al, BYTE PTR _tick$[ebp]
  0004c	0f be c0	 movsx	 eax, al
  0004f	25 ff 00 00 80	 and	 eax, -2147483393	; 800000ffH
  00054	79 07		 jns	 SHORT $LN8@Init
  00056	48		 dec	 eax
  00057	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  0005c	40		 inc	 eax
$LN8@Init:
  0005d	88 46 08	 mov	 BYTE PTR [esi+8], al

; 79   : 
; 80   : 		for (int i = 0; i < MAX_MEM_POOL ; i++)

  00060	33 db		 xor	 ebx, ebx
$LL3@Init:

; 81   : 			m_MemPool[i] = (char)( rand()+pid+tick )%256; // 더미

  00062	ff d7		 call	 edi
  00064	02 45 f8	 add	 al, BYTE PTR _pid$[ebp]
  00067	02 45 fc	 add	 al, BYTE PTR _tick$[ebp]
  0006a	0f be c0	 movsx	 eax, al
  0006d	25 ff 00 00 80	 and	 eax, -2147483393	; 800000ffH
  00072	79 07		 jns	 SHORT $LN9@Init
  00074	48		 dec	 eax
  00075	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  0007a	40		 inc	 eax
$LN9@Init:
  0007b	88 44 1e 1c	 mov	 BYTE PTR [esi+ebx+28], al
  0007f	43		 inc	 ebx
  00080	83 fb 0c	 cmp	 ebx, 12			; 0000000cH
  00083	7c dd		 jl	 SHORT $LL3@Init

; 82   : 
; 83   : 		//UJ 130913, 최적화: szKey 사용안하도록 간략화
; 84   : 		//char szKey[ccddaabb::KEY_SIZE];//="";
; 85   : 		//for (int i = 0; i < ccddaabb::KEY_SIZE  ; i++)
; 86   : 		//	szKey[i] = (char)( rand()+pid+tick )%256; // 더미
; 87   : 		m_RC5.Setup( NULL, pid, tick );

  00085	ff 75 fc	 push	 DWORD PTR _tick$[ebp]
  00088	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0008b	ff 75 f8	 push	 DWORD PTR _pid$[ebp]
  0008e	6a 00		 push	 0
  00090	e8 00 00 00 00	 call	 ?Setup@ccddaabb@@QAEXPBDHH@Z ; ccddaabb::Setup
  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx

; 88   : 
; 89   : #ifdef _NOTUSE
; 90   : 		m_value        = 0;
; 91   : 		EncryptValueToPool((char*)&m_value);
; 92   : 		Debug();
; 93   : #endif
; 94   : 	}

  00098	c9		 leave
  00099	c3		 ret	 0
?Init@?$CEncrypt@_N@@AAEXXZ ENDP			; CEncrypt<bool>::Init
_TEXT	ENDS
PUBLIC	?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z	; CEncrypt<bool>::DecryptValueToPool
EXTRN	?DecryptByte@ccddaabb@@QBEXPBDPADH@Z:PROC	; ccddaabb::DecryptByte
; Function compile flags: /Ogsp
;	COMDAT ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z PROC	; CEncrypt<bool>::DecryptValueToPool, COMDAT
; _this$ = ecx

; 219  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 220  : 		m_RC5.DecryptByte( m_MemPool, m_TempMem, 4 );

  00004	8d 71 28	 lea	 esi, DWORD PTR [ecx+40]
  00007	6a 04		 push	 4
  00009	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00011	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte

; 221  : 		*value = *((bool*)m_TempMem);

  00016	8a 06		 mov	 al, BYTE PTR [esi]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0001b	88 01		 mov	 BYTE PTR [ecx], al
  0001d	5e		 pop	 esi

; 222  : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ENDP	; CEncrypt<bool>::DecryptValueToPool
_TEXT	ENDS
PUBLIC	?EncryptValueToPool@?$CEncrypt@H@@AAEXPBD@Z	; CEncrypt<int>::EncryptValueToPool
; Function compile flags: /Ogsp
;	COMDAT ?EncryptValueToPool@?$CEncrypt@H@@AAEXPBD@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?EncryptValueToPool@?$CEncrypt@H@@AAEXPBD@Z PROC	; CEncrypt<int>::EncryptValueToPool, COMDAT
; _this$ = ecx

; 67   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 		m_RC5.EncryptByte( value, m_MemPool, max(m_ValueSize, DEFAULT_ENCRYPT) );

  00003	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00007	83 f8 04	 cmp	 eax, 4
  0000a	77 03		 ja	 SHORT $LN4@EncryptVal@2
  0000c	6a 04		 push	 4
  0000e	58		 pop	 eax
$LN4@EncryptVal@2:
  0000f	50		 push	 eax
  00010	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  00013	50		 push	 eax
  00014	ff 75 08	 push	 DWORD PTR _value$[ebp]
  00017	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0001a	e8 00 00 00 00	 call	 ?EncryptByte@ccddaabb@@QAEXPBDPADH@Z ; ccddaabb::EncryptByte

; 69   : 		
; 70   : 	}

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?EncryptValueToPool@?$CEncrypt@H@@AAEXPBD@Z ENDP	; CEncrypt<int>::EncryptValueToPool
_TEXT	ENDS
PUBLIC	?Init@?$CEncrypt@H@@AAEXXZ			; CEncrypt<int>::Init
; Function compile flags: /Ogsp
;	COMDAT ?Init@?$CEncrypt@H@@AAEXXZ
_TEXT	SEGMENT
_pid$ = -8						; size = 4
_tick$ = -4						; size = 4
?Init@?$CEncrypt@H@@AAEXXZ PROC				; CEncrypt<int>::Init, COMDAT
; _this$ = ecx

; 73   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx

; 74   : 		DWORD pid = GetCurrentProcessId();

  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcessId@0
  00010	89 45 f8	 mov	 DWORD PTR _pid$[ebp], eax

; 75   : 		DWORD tick = timeGetTime();

  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0

; 76   : 		m_ValueSize    = sizeof(type);
; 77   : 		m_MemPoolPos   = (unsigned short)( rand()+pid+tick )%(MAX_MEM_POOL-m_ValueSize);

  00019	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__rand
  0001f	89 45 fc	 mov	 DWORD PTR _tick$[ebp], eax
  00022	6a 04		 push	 4
  00024	58		 pop	 eax
  00025	66 89 46 06	 mov	 WORD PTR [esi+6], ax
  00029	ff d7		 call	 edi
  0002b	03 45 f8	 add	 eax, DWORD PTR _pid$[ebp]
  0002e	0f b7 4e 06	 movzx	 ecx, WORD PTR [esi+6]
  00032	03 45 fc	 add	 eax, DWORD PTR _tick$[ebp]
  00035	6a 0c		 push	 12			; 0000000cH
  00037	0f b7 c0	 movzx	 eax, ax
  0003a	5b		 pop	 ebx
  0003b	99		 cdq
  0003c	2b d9		 sub	 ebx, ecx
  0003e	f7 fb		 idiv	 ebx
  00040	66 89 56 04	 mov	 WORD PTR [esi+4], dx

; 78   : 		m_EncryptSeed  = (char)( rand()+pid+tick )%256;

  00044	ff d7		 call	 edi
  00046	02 45 f8	 add	 al, BYTE PTR _pid$[ebp]
  00049	02 45 fc	 add	 al, BYTE PTR _tick$[ebp]
  0004c	0f be c0	 movsx	 eax, al
  0004f	25 ff 00 00 80	 and	 eax, -2147483393	; 800000ffH
  00054	79 07		 jns	 SHORT $LN8@Init@2
  00056	48		 dec	 eax
  00057	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  0005c	40		 inc	 eax
$LN8@Init@2:
  0005d	88 46 08	 mov	 BYTE PTR [esi+8], al

; 79   : 
; 80   : 		for (int i = 0; i < MAX_MEM_POOL ; i++)

  00060	33 db		 xor	 ebx, ebx
$LL3@Init@2:

; 81   : 			m_MemPool[i] = (char)( rand()+pid+tick )%256; // 더미

  00062	ff d7		 call	 edi
  00064	02 45 f8	 add	 al, BYTE PTR _pid$[ebp]
  00067	02 45 fc	 add	 al, BYTE PTR _tick$[ebp]
  0006a	0f be c0	 movsx	 eax, al
  0006d	25 ff 00 00 80	 and	 eax, -2147483393	; 800000ffH
  00072	79 07		 jns	 SHORT $LN9@Init@2
  00074	48		 dec	 eax
  00075	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  0007a	40		 inc	 eax
$LN9@Init@2:
  0007b	88 44 1e 1c	 mov	 BYTE PTR [esi+ebx+28], al
  0007f	43		 inc	 ebx
  00080	83 fb 0c	 cmp	 ebx, 12			; 0000000cH
  00083	7c dd		 jl	 SHORT $LL3@Init@2

; 82   : 
; 83   : 		//UJ 130913, 최적화: szKey 사용안하도록 간략화
; 84   : 		//char szKey[ccddaabb::KEY_SIZE];//="";
; 85   : 		//for (int i = 0; i < ccddaabb::KEY_SIZE  ; i++)
; 86   : 		//	szKey[i] = (char)( rand()+pid+tick )%256; // 더미
; 87   : 		m_RC5.Setup( NULL, pid, tick );

  00085	ff 75 fc	 push	 DWORD PTR _tick$[ebp]
  00088	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0008b	ff 75 f8	 push	 DWORD PTR _pid$[ebp]
  0008e	6a 00		 push	 0
  00090	e8 00 00 00 00	 call	 ?Setup@ccddaabb@@QAEXPBDHH@Z ; ccddaabb::Setup
  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx

; 88   : 
; 89   : #ifdef _NOTUSE
; 90   : 		m_value        = 0;
; 91   : 		EncryptValueToPool((char*)&m_value);
; 92   : 		Debug();
; 93   : #endif
; 94   : 	}

  00098	c9		 leave
  00099	c3		 ret	 0
?Init@?$CEncrypt@H@@AAEXXZ ENDP				; CEncrypt<int>::Init
_TEXT	ENDS
PUBLIC	?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z	; CEncrypt<int>::DecryptValueToPool
; Function compile flags: /Ogsp
;	COMDAT ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z PROC	; CEncrypt<int>::DecryptValueToPool, COMDAT
; _this$ = ecx

; 837  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 838  : 		m_RC5.DecryptByte( m_MemPool, m_TempMem, 4 );

  00004	8d 71 28	 lea	 esi, DWORD PTR [ecx+40]
  00007	6a 04		 push	 4
  00009	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00011	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte

; 839  : 		*value = *((int*)m_TempMem);

  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0001b	89 01		 mov	 DWORD PTR [ecx], eax
  0001d	5e		 pop	 esi

; 840  : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ENDP	; CEncrypt<int>::DecryptValueToPool
_TEXT	ENDS
PUBLIC	?DecryptValueToPool@?$CEncrypt@W4ModeType@@@@QAEXPAW4ModeType@@@Z ; CEncrypt<enum ModeType>::DecryptValueToPool
; Function compile flags: /Ogsp
;	COMDAT ?DecryptValueToPool@?$CEncrypt@W4ModeType@@@@QAEXPAW4ModeType@@@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?DecryptValueToPool@?$CEncrypt@W4ModeType@@@@QAEXPAW4ModeType@@@Z PROC ; CEncrypt<enum ModeType>::DecryptValueToPool, COMDAT
; _this$ = ecx

; 3039 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3040 : 		m_RC5.DecryptByte( m_MemPool, m_TempMem, sizeof(ModeType) );

  00004	8d 71 28	 lea	 esi, DWORD PTR [ecx+40]
  00007	6a 04		 push	 4
  00009	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00011	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte

; 3041 : 		*value = *((ModeType*)m_TempMem);

  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0001b	89 01		 mov	 DWORD PTR [ecx], eax
  0001d	5e		 pop	 esi

; 3042 : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?DecryptValueToPool@?$CEncrypt@W4ModeType@@@@QAEXPAW4ModeType@@@Z ENDP ; CEncrypt<enum ModeType>::DecryptValueToPool
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
; Function compile flags: /Ogsp
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?IsMyTeam@RoundStateUserWnd@@IAE_NXZ		; RoundStateUserWnd::IsMyTeam
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
;	COMDAT ?IsMyTeam@RoundStateUserWnd@@IAE_NXZ
_TEXT	SEGMENT
?IsMyTeam@RoundStateUserWnd@@IAE_NXZ PROC		; RoundStateUserWnd::IsMyTeam, COMDAT
; _this$ = ecx

; 484  : 	for(int i = 0;i < (int)m_RoundInfoList.size();i++)

  00000	8b 81 9c 02 00
	00		 mov	 eax, DWORD PTR [ecx+668]
  00006	2b 81 98 02 00
	00		 sub	 eax, DWORD PTR [ecx+664]
  0000c	33 d2		 xor	 edx, edx
  0000e	c1 f8 07	 sar	 eax, 7
  00011	85 c0		 test	 eax, eax
  00013	7e 16		 jle	 SHORT $LN2@IsMyTeam
  00015	8b 89 98 02 00
	00		 mov	 ecx, DWORD PTR [ecx+664]
  0001b	83 c1 54	 add	 ecx, 84			; 00000054H
$LL4@IsMyTeam:

; 485  : 	{
; 486  : 		RoundInfo &rkInfo = m_RoundInfoList[i];
; 487  : 		if( rkInfo.m_bOwner )

  0001e	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00021	75 0b		 jne	 SHORT $LN12@IsMyTeam

; 484  : 	for(int i = 0;i < (int)m_RoundInfoList.size();i++)

  00023	42		 inc	 edx
  00024	83 e9 80	 sub	 ecx, -128		; ffffff80H
  00027	3b d0		 cmp	 edx, eax
  00029	7c f3		 jl	 SHORT $LL4@IsMyTeam
$LN2@IsMyTeam:

; 489  : 	}
; 490  : 	return false;

  0002b	32 c0		 xor	 al, al

; 491  : }

  0002d	c3		 ret	 0
$LN12@IsMyTeam:

; 488  : 			return true;

  0002e	b0 01		 mov	 al, 1

; 491  : }

  00030	c3		 ret	 0
?IsMyTeam@RoundStateUserWnd@@IAE_NXZ ENDP		; RoundStateUserWnd::IsMyTeam
_TEXT	ENDS
PUBLIC	?GetUserTeam@RoundStateUserWnd@@IAE?AW4TeamType@@H@Z ; RoundStateUserWnd::GetUserTeam
; Function compile flags: /Ogsp
;	COMDAT ?GetUserTeam@RoundStateUserWnd@@IAE?AW4TeamType@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetUserTeam@RoundStateUserWnd@@IAE?AW4TeamType@@H@Z PROC ; RoundStateUserWnd::GetUserTeam, COMDAT
; _this$ = ecx

; 510  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 511  : 	if( !COMPARE( iIndex, 0, (int)m_RoundInfoList.size() ) ) return TEAM_NONE;

  00003	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 1d		 js	 SHORT $LN1@GetUserTea
  0000a	8d 81 98 02 00
	00		 lea	 eax, DWORD PTR [ecx+664]
  00010	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00013	2b 08		 sub	 ecx, DWORD PTR [eax]
  00015	c1 f9 07	 sar	 ecx, 7
  00018	3b d1		 cmp	 edx, ecx
  0001a	7d 0b		 jge	 SHORT $LN1@GetUserTea

; 512  : 
; 513  : 	return m_RoundInfoList[iIndex].m_Team;

  0001c	8b 00		 mov	 eax, DWORD PTR [eax]
  0001e	c1 e2 07	 shl	 edx, 7
  00021	8b 44 02 10	 mov	 eax, DWORD PTR [edx+eax+16]
  00025	eb 02		 jmp	 SHORT $LN3@GetUserTea
$LN1@GetUserTea:

; 511  : 	if( !COMPARE( iIndex, 0, (int)m_RoundInfoList.size() ) ) return TEAM_NONE;

  00027	33 c0		 xor	 eax, eax
$LN3@GetUserTea:

; 514  : }

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?GetUserTeam@RoundStateUserWnd@@IAE?AW4TeamType@@H@Z ENDP ; RoundStateUserWnd::GetUserTeam
_TEXT	ENDS
PUBLIC	?SetSingleScore@RoundStateUserWnd@@QAEXH@Z	; RoundStateUserWnd::SetSingleScore
; Function compile flags: /Ogsp
;	COMDAT ?SetSingleScore@RoundStateUserWnd@@QAEXH@Z
_TEXT	SEGMENT
_iMaxSlot$ = 8						; size = 4
?SetSingleScore@RoundStateUserWnd@@QAEXH@Z PROC		; RoundStateUserWnd::SetSingleScore, COMDAT
; _this$ = ecx

; 552  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 553  : 	m_iMaxSlot = iMaxSlot;

  00003	8b 45 08	 mov	 eax, DWORD PTR _iMaxSlot$[ebp]

; 554  : 	m_iCurrentRank = 0;

  00006	83 a1 68 02 00
	00 00		 and	 DWORD PTR [ecx+616], 0
  0000d	89 81 60 02 00
	00		 mov	 DWORD PTR [ecx+608], eax

; 555  : 	m_iNameLimit   = 113;

  00013	c7 81 90 02 00
	00 71 00 00 00	 mov	 DWORD PTR [ecx+656], 113 ; 00000071H

; 556  : 
; 557  : 	for(int i = 0;i < (int)m_RoundInfoList.size();i++)

  0001d	8b 81 9c 02 00
	00		 mov	 eax, DWORD PTR [ecx+668]
  00023	2b 81 98 02 00
	00		 sub	 eax, DWORD PTR [ecx+664]
  00029	56		 push	 esi
  0002a	c1 f8 07	 sar	 eax, 7
  0002d	33 f6		 xor	 esi, esi
  0002f	85 c0		 test	 eax, eax
  00031	7e 1e		 jle	 SHORT $LN3@SetSingleS

; 553  : 	m_iMaxSlot = iMaxSlot;

  00033	8b 91 98 02 00
	00		 mov	 edx, DWORD PTR [ecx+664]
  00039	83 c2 54	 add	 edx, 84			; 00000054H
$LL5@SetSingleS:

; 556  : 
; 557  : 	for(int i = 0;i < (int)m_RoundInfoList.size();i++)

  0003c	46		 inc	 esi

; 558  : 	{
; 559  : 		RoundInfo &rkInfo = m_RoundInfoList[i];
; 560  : 		if( rkInfo.m_bOwner )

  0003d	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00040	75 09		 jne	 SHORT $LN15@SetSingleS

; 556  : 
; 557  : 	for(int i = 0;i < (int)m_RoundInfoList.size();i++)

  00042	83 ea 80	 sub	 edx, -128		; ffffff80H
  00045	3b f0		 cmp	 esi, eax
  00047	7c f3		 jl	 SHORT $LL5@SetSingleS

; 558  : 	{
; 559  : 		RoundInfo &rkInfo = m_RoundInfoList[i];
; 560  : 		if( rkInfo.m_bOwner )

  00049	eb 06		 jmp	 SHORT $LN3@SetSingleS
$LN15@SetSingleS:

; 561  : 		{
; 562  : 			m_iCurrentRank = i + 1;

  0004b	89 b1 68 02 00
	00		 mov	 DWORD PTR [ecx+616], esi
$LN3@SetSingleS:

; 563  : 			break;
; 564  : 		}
; 565  : 	}
; 566  : 
; 567  : 	if( m_iCurrentRank == 0 )

  00051	83 b9 68 02 00
	00 00		 cmp	 DWORD PTR [ecx+616], 0
  00058	5e		 pop	 esi
  00059	75 15		 jne	 SHORT $LN1@SetSingleS

; 568  : 		m_iCurrentRank = m_RoundInfoList.size();

  0005b	8b 81 9c 02 00
	00		 mov	 eax, DWORD PTR [ecx+668]
  00061	2b 81 98 02 00
	00		 sub	 eax, DWORD PTR [ecx+664]
  00067	c1 f8 07	 sar	 eax, 7
  0006a	89 81 68 02 00
	00		 mov	 DWORD PTR [ecx+616], eax
$LN1@SetSingleS:

; 569  : }

  00070	5d		 pop	 ebp
  00071	c2 04 00	 ret	 4
?SetSingleScore@RoundStateUserWnd@@QAEXH@Z ENDP		; RoundStateUserWnd::SetSingleScore
_TEXT	ENDS
PUBLIC	?SetGangsiScore@RoundStateUserWnd@@QAEXH@Z	; RoundStateUserWnd::SetGangsiScore
; Function compile flags: /Ogsp
;	COMDAT ?SetGangsiScore@RoundStateUserWnd@@QAEXH@Z
_TEXT	SEGMENT
_iMaxSlot$ = 8						; size = 4
?SetGangsiScore@RoundStateUserWnd@@QAEXH@Z PROC		; RoundStateUserWnd::SetGangsiScore, COMDAT
; _this$ = ecx

; 572  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 	m_iMaxSlot = iMaxSlot;

  00003	8b 45 08	 mov	 eax, DWORD PTR _iMaxSlot$[ebp]

; 574  : 	m_iCurrentRank = 0;

  00006	33 d2		 xor	 edx, edx
  00008	89 81 60 02 00
	00		 mov	 DWORD PTR [ecx+608], eax
  0000e	89 91 68 02 00
	00		 mov	 DWORD PTR [ecx+616], edx

; 575  : 	m_iNameLimit   = 113;

  00014	c7 81 90 02 00
	00 71 00 00 00	 mov	 DWORD PTR [ecx+656], 113 ; 00000071H

; 576  : 	m_iCurrentLiveUser = 0;

  0001e	89 91 70 02 00
	00		 mov	 DWORD PTR [ecx+624], edx

; 577  : 	for(int i = 0;i < (int)m_RoundInfoList.size();i++)

  00024	8b 81 9c 02 00
	00		 mov	 eax, DWORD PTR [ecx+668]
  0002a	2b 81 98 02 00
	00		 sub	 eax, DWORD PTR [ecx+664]
  00030	a9 80 ff ff ff	 test	 eax, -128		; ffffff80H
  00035	7e 2d		 jle	 SHORT $LN2@SetGangsiS

; 573  : 	m_iMaxSlot = iMaxSlot;

  00037	8b 81 98 02 00
	00		 mov	 eax, DWORD PTR [ecx+664]
  0003d	83 c0 10	 add	 eax, 16			; 00000010H
  00040	56		 push	 esi
$LL4@SetGangsiS:

; 578  : 	{
; 579  : 		RoundInfo &rkInfo = m_RoundInfoList[i];
; 580  : 		if( rkInfo.m_Team == TEAM_RED )

  00041	83 38 01	 cmp	 DWORD PTR [eax], 1
  00044	75 06		 jne	 SHORT $LN3@SetGangsiS

; 581  : 			m_iCurrentLiveUser++;

  00046	ff 81 70 02 00
	00		 inc	 DWORD PTR [ecx+624]
$LN3@SetGangsiS:

; 577  : 	for(int i = 0;i < (int)m_RoundInfoList.size();i++)

  0004c	8b b1 9c 02 00
	00		 mov	 esi, DWORD PTR [ecx+668]
  00052	2b b1 98 02 00
	00		 sub	 esi, DWORD PTR [ecx+664]
  00058	42		 inc	 edx
  00059	c1 fe 07	 sar	 esi, 7
  0005c	83 e8 80	 sub	 eax, -128		; ffffff80H
  0005f	3b d6		 cmp	 edx, esi
  00061	7c de		 jl	 SHORT $LL4@SetGangsiS
  00063	5e		 pop	 esi
$LN2@SetGangsiS:

; 582  : 	}
; 583  : }

  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
?SetGangsiScore@RoundStateUserWnd@@QAEXH@Z ENDP		; RoundStateUserWnd::SetGangsiScore
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?ProcessSiteClick@RoundStateUserWnd@@IAEXXZ	; RoundStateUserWnd::ProcessSiteClick
EXTRN	?SetToolTipID@ioLSMouse@@QAEXABVioHashString@@H@Z:PROC ; ioLSMouse::SetToolTipID
EXTRN	?OpenMannerWnd@ioApplication@@QAEXPBD_NW4ChatType@@@Z:PROC ; ioApplication::OpenMannerWnd
EXTRN	__imp_?IsLBtnUp@ioMouse@@QBE_NXZ:PROC
EXTRN	__imp__PtInRect@12:PROC
EXTRN	__imp_?GetMousePos@ioMouse@@QBEABUtagPOINT@@XZ:PROC
EXTRN	?IsVisibleMouse@ioApplication@@QAE_NXZ:PROC	; ioApplication::IsVisibleMouse
EXTRN	?GetSingleton@ioApplication@@SAAAV1@XZ:PROC	; ioApplication::GetSingleton
EXTRN	___security_cookie:DWORD
; Function compile flags: /Ogsp
;	COMDAT ?ProcessSiteClick@RoundStateUserWnd@@IAEXXZ
_TEXT	SEGMENT
_iUserSize$ = -40					; size = 4
_pMouse$ = -36						; size = 4
tv405 = -32						; size = 4
tv403 = -28						; size = 4
_i$549640 = -24						; size = 4
_rcNameRect$549647 = -20				; size = 16
__$ArrayPad$ = -4					; size = 4
?ProcessSiteClick@RoundStateUserWnd@@IAEXXZ PROC	; RoundStateUserWnd::ProcessSiteClick, COMDAT
; _this$ = ecx

; 639  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b f1		 mov	 esi, ecx

; 640  : 	m_MouseOverIndex = -1;

  00013	83 8e 5c 02 00
	00 ff		 or	 DWORD PTR [esi+604], -1

; 641  : 
; 642  : 	if( !g_App.IsVisibleMouse() || g_GUIMgr.GetPreOverWnd() != this )

  0001a	e8 00 00 00 00	 call	 ?GetSingleton@ioApplication@@SAAAV1@XZ ; ioApplication::GetSingleton
  0001f	8b c8		 mov	 ecx, eax
  00021	e8 00 00 00 00	 call	 ?IsVisibleMouse@ioApplication@@QAE_NXZ ; ioApplication::IsVisibleMouse
  00026	84 c0		 test	 al, al
  00028	0f 84 4e 01 00
	00		 je	 $LN3@ProcessSit
  0002e	e8 00 00 00 00	 call	 ?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ ; ioSP2GUIManager::GetSingleton
  00033	39 70 10	 cmp	 DWORD PTR [eax+16], esi
  00036	0f 85 40 01 00
	00		 jne	 $LN3@ProcessSit

; 643  : 		return;
; 644  : 
; 645  : 	int iXPos, iYPos;
; 646  : 	iXPos = GetDerivedPosX() + m_iLineStartX;

  0003c	53		 push	 ebx
  0003d	57		 push	 edi
  0003e	8b ce		 mov	 ecx, esi
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetDerivedPosX@ioWnd@@QBEHXZ
  00046	8b d8		 mov	 ebx, eax
  00048	03 9e 80 02 00
	00		 add	 ebx, DWORD PTR [esi+640]

; 647  : 	iYPos = GetDerivedPosY() + m_iLineStartY;

  0004e	8b ce		 mov	 ecx, esi
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetDerivedPosY@ioWnd@@QBEHXZ
  00056	8b f8		 mov	 edi, eax

; 648  : 
; 649  : 	int iUserSize = m_RoundInfoList.size();

  00058	8b 86 9c 02 00
	00		 mov	 eax, DWORD PTR [esi+668]
  0005e	2b 86 98 02 00
	00		 sub	 eax, DWORD PTR [esi+664]
  00064	03 be 84 02 00
	00		 add	 edi, DWORD PTR [esi+644]
  0006a	c1 f8 07	 sar	 eax, 7
  0006d	89 45 d8	 mov	 DWORD PTR _iUserSize$[ebp], eax

; 650  : 	ioLSMouse *pMouse = g_App.GetMouse();

  00070	e8 00 00 00 00	 call	 ?GetSingleton@ioApplication@@SAAAV1@XZ ; ioApplication::GetSingleton

; 651  : 	for(int i = 0;i < iUserSize;i++)

  00075	33 c9		 xor	 ecx, ecx
  00077	05 90 00 00 00	 add	 eax, 144		; 00000090H
  0007c	89 45 dc	 mov	 DWORD PTR _pMouse$[ebp], eax
  0007f	89 4d e8	 mov	 DWORD PTR _i$549640[ebp], ecx
  00082	39 4d d8	 cmp	 DWORD PTR _iUserSize$[ebp], ecx
  00085	0f 8e ef 00 00
	00		 jle	 $LN35@ProcessSit

; 643  : 		return;
; 644  : 
; 645  : 	int iXPos, iYPos;
; 646  : 	iXPos = GetDerivedPosX() + m_iLineStartX;

  0008b	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv403[ebp], 1
  00092	89 4d e0	 mov	 DWORD PTR tv405[ebp], ecx
  00095	eb 03		 jmp	 SHORT $LN12@ProcessSit
$LL34@ProcessSit:
  00097	8b 45 dc	 mov	 eax, DWORD PTR _pMouse$[ebp]
$LN12@ProcessSit:

; 652  : 	{
; 653  : 		if( m_RoundInfoList[i].m_bNPC )

  0009a	8b 8e 98 02 00
	00		 mov	 ecx, DWORD PTR [esi+664]
  000a0	8b 55 e0	 mov	 edx, DWORD PTR tv405[ebp]
  000a3	80 7c 11 78 00	 cmp	 BYTE PTR [ecx+edx+120], 0

; 654  : 		{
; 655  : 			if( 0 == ( i + 1 ) % m_iLinePlayer )
; 656  : 			{
; 657  : 				iXPos += m_iLinePlayerGap;
; 658  : 				iYPos = GetDerivedPosY() + m_iLineStartY;
; 659  : 			}
; 660  : 			else
; 661  : 			{
; 662  : 				iYPos += m_iLineHeight;
; 663  : 			}
; 664  : 			continue;

  000a8	75 37		 jne	 SHORT $LN38@ProcessSit

; 665  : 		}
; 666  : 
; 667  : 		RECT rcNameRect;
; 668  : 		rcNameRect.left   = iXPos;
; 669  : 		rcNameRect.top    = iYPos;
; 670  : 		rcNameRect.right  = rcNameRect.left + m_iLineWidth;

  000aa	8b 8e 88 02 00
	00		 mov	 ecx, DWORD PTR [esi+648]
  000b0	03 cb		 add	 ecx, ebx
  000b2	89 4d f4	 mov	 DWORD PTR _rcNameRect$549647[ebp+8], ecx

; 671  : 		rcNameRect.bottom = rcNameRect.top + m_iLineHeight;

  000b5	8b 8e 8c 02 00
	00		 mov	 ecx, DWORD PTR [esi+652]
  000bb	03 cf		 add	 ecx, edi
  000bd	89 4d f8	 mov	 DWORD PTR _rcNameRect$549647[ebp+12], ecx

; 672  : 
; 673  : 		if( ::PtInRect( &rcNameRect, pMouse->GetMousePos() ) )

  000c0	8b c8		 mov	 ecx, eax
  000c2	89 5d ec	 mov	 DWORD PTR _rcNameRect$549647[ebp], ebx
  000c5	89 7d f0	 mov	 DWORD PTR _rcNameRect$549647[ebp+4], edi
  000c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetMousePos@ioMouse@@QBEABUtagPOINT@@XZ
  000ce	ff 70 04	 push	 DWORD PTR [eax+4]
  000d1	ff 30		 push	 DWORD PTR [eax]
  000d3	8d 45 ec	 lea	 eax, DWORD PTR _rcNameRect$549647[ebp]
  000d6	50		 push	 eax
  000d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PtInRect@12
  000dd	85 c0		 test	 eax, eax
  000df	75 44		 jne	 SHORT $LN32@ProcessSit
$LN38@ProcessSit:

; 682  : 			break;
; 683  : 		}
; 684  : 
; 685  : 		if( 0 == ( i + 1 ) % m_iLinePlayer )

  000e1	8b 45 e4	 mov	 eax, DWORD PTR tv403[ebp]
  000e4	99		 cdq
  000e5	f7 be 78 02 00
	00		 idiv	 DWORD PTR [esi+632]
  000eb	85 d2		 test	 edx, edx
  000ed	75 18		 jne	 SHORT $LN2@ProcessSit

; 686  : 		{
; 687  : 			iXPos += m_iLinePlayerGap;

  000ef	03 9e 7c 02 00
	00		 add	 ebx, DWORD PTR [esi+636]

; 688  : 			iYPos = GetDerivedPosY() + m_iLineStartY;

  000f5	8b ce		 mov	 ecx, esi
  000f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetDerivedPosY@ioWnd@@QBEHXZ
  000fd	8b f8		 mov	 edi, eax
  000ff	03 be 84 02 00
	00		 add	 edi, DWORD PTR [esi+644]

; 689  : 		}
; 690  : 		else

  00105	eb 06		 jmp	 SHORT $LN11@ProcessSit
$LN2@ProcessSit:

; 691  : 		{
; 692  : 			iYPos += m_iLineHeight;

  00107	03 be 8c 02 00
	00		 add	 edi, DWORD PTR [esi+652]
$LN11@ProcessSit:

; 651  : 	for(int i = 0;i < iUserSize;i++)

  0010d	ff 45 e8	 inc	 DWORD PTR _i$549640[ebp]
  00110	83 6d e0 80	 sub	 DWORD PTR tv405[ebp], -128 ; ffffff80H
  00114	8b 45 e8	 mov	 eax, DWORD PTR _i$549640[ebp]
  00117	ff 45 e4	 inc	 DWORD PTR tv403[ebp]
  0011a	3b 45 d8	 cmp	 eax, DWORD PTR _iUserSize$[ebp]
  0011d	0f 8c 74 ff ff
	ff		 jl	 $LL34@ProcessSit

; 672  : 
; 673  : 		if( ::PtInRect( &rcNameRect, pMouse->GetMousePos() ) )

  00123	eb 55		 jmp	 SHORT $LN35@ProcessSit
$LN32@ProcessSit:

; 674  : 		{
; 675  : 			m_MouseOverIndex = i;
; 676  : 			if( pMouse->IsLBtnUp() )

  00125	8b 5d dc	 mov	 ebx, DWORD PTR _pMouse$[ebp]
  00128	8b 7d e8	 mov	 edi, DWORD PTR _i$549640[ebp]
  0012b	8b cb		 mov	 ecx, ebx
  0012d	89 be 5c 02 00
	00		 mov	 DWORD PTR [esi+604], edi
  00133	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsLBtnUp@ioMouse@@QBE_NXZ
  00139	84 c0		 test	 al, al
  0013b	74 24		 je	 SHORT $LN5@ProcessSit

; 677  : 			{
; 678  : 				g_App.OpenMannerWnd( m_RoundInfoList[i].m_szName.c_str(), true );

  0013d	c1 e7 07	 shl	 edi, 7
  00140	03 be 98 02 00
	00		 add	 edi, DWORD PTR [esi+664]
  00146	6a ff		 push	 -1
  00148	8b cf		 mov	 ecx, edi
  0014a	6a 01		 push	 1
  0014c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00152	50		 push	 eax
  00153	e8 00 00 00 00	 call	 ?GetSingleton@ioApplication@@SAAAV1@XZ ; ioApplication::GetSingleton
  00158	8b c8		 mov	 ecx, eax
  0015a	e8 00 00 00 00	 call	 ?OpenMannerWnd@ioApplication@@QAEXPBD_NW4ChatType@@@Z ; ioApplication::OpenMannerWnd
  0015f	eb 19		 jmp	 SHORT $LN35@ProcessSit
$LN5@ProcessSit:

; 679  : 			}
; 680  : 			else if( pMouse->IsMouseShowing() )

  00161	80 7b 7c 00	 cmp	 BYTE PTR [ebx+124], 0
  00165	74 13		 je	 SHORT $LN35@ProcessSit

; 681  : 				pMouse->SetToolTipID( m_RoundInfoList[i].m_szName, UserInfoToolTip::TT_ROOM );

  00167	c1 e7 07	 shl	 edi, 7
  0016a	03 be 98 02 00
	00		 add	 edi, DWORD PTR [esi+664]
  00170	6a fe		 push	 -2			; fffffffeH
  00172	57		 push	 edi
  00173	8b cb		 mov	 ecx, ebx
  00175	e8 00 00 00 00	 call	 ?SetToolTipID@ioLSMouse@@QAEXABVioHashString@@H@Z ; ioLSMouse::SetToolTipID
$LN35@ProcessSit:
  0017a	5f		 pop	 edi
  0017b	5b		 pop	 ebx
$LN3@ProcessSit:

; 693  : 		}
; 694  : 	}
; 695  : }

  0017c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0017f	33 cd		 xor	 ecx, ebp
  00181	5e		 pop	 esi
  00182	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00187	c9		 leave
  00188	c3		 ret	 0
?ProcessSiteClick@RoundStateUserWnd@@IAEXXZ ENDP	; RoundStateUserWnd::ProcessSiteClick
_TEXT	ENDS
PUBLIC	?OnProcess@RoundStateUserWnd@@MAEXM@Z		; RoundStateUserWnd::OnProcess
EXTRN	__imp_?IsShow@ioWnd@@QBE_NXZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ?OnProcess@RoundStateUserWnd@@MAEXM@Z
_TEXT	SEGMENT
_fTimePerSec$ = 8					; size = 4
?OnProcess@RoundStateUserWnd@@MAEXM@Z PROC		; RoundStateUserWnd::OnProcess, COMDAT
; _this$ = ecx

; 698  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 699  : 	if( !IsShow() ) return;

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsShow@ioWnd@@QBE_NXZ
  00009	84 c0		 test	 al, al
  0000b	74 07		 je	 SHORT $LN2@OnProcess

; 700  : 
; 701  : 	ProcessSiteClick();

  0000d	8b ce		 mov	 ecx, esi
  0000f	e8 00 00 00 00	 call	 ?ProcessSiteClick@RoundStateUserWnd@@IAEXXZ ; RoundStateUserWnd::ProcessSiteClick
$LN2@OnProcess:
  00014	5e		 pop	 esi

; 702  : }

  00015	c2 04 00	 ret	 4
?OnProcess@RoundStateUserWnd@@MAEXM@Z ENDP		; RoundStateUserWnd::OnProcess
_TEXT	ENDS
PUBLIC	?OnRenderBack@RoundStateUserWnd@@IAEXHH@Z	; RoundStateUserWnd::OnRenderBack
; Function compile flags: /Ogsp
;	COMDAT ?OnRenderBack@RoundStateUserWnd@@IAEXHH@Z
_TEXT	SEGMENT
_i$549702 = -4						; size = 4
_iRealYPos$ = 8						; size = 4
_iXPos$ = 8						; size = 4
_iYPos$ = 12						; size = 4
?OnRenderBack@RoundStateUserWnd@@IAEXHH@Z PROC		; RoundStateUserWnd::OnRenderBack, COMDAT
; _this$ = ecx

; 815  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f1		 mov	 esi, ecx

; 816  : 	if( !m_pCurrentDark || !m_pCurrentLight ) return;

  00008	33 ff		 xor	 edi, edi
  0000a	39 be 3c 02 00
	00		 cmp	 DWORD PTR [esi+572], edi
  00010	0f 84 0b 01 00
	00		 je	 $LN13@OnRenderBa
  00016	39 be 40 02 00
	00		 cmp	 DWORD PTR [esi+576], edi
  0001c	0f 84 ff 00 00
	00		 je	 $LN13@OnRenderBa

; 817  : 
; 818  : 	int iRealXPos = iXPos;
; 819  : 	int iRealYPos = iYPos;

  00022	8b 45 0c	 mov	 eax, DWORD PTR _iYPos$[ebp]
  00025	53		 push	 ebx
  00026	8b 5d 08	 mov	 ebx, DWORD PTR _iXPos$[ebp]
  00029	89 45 08	 mov	 DWORD PTR _iRealYPos$[ebp], eax

; 820  : 	for(int i = 0;i < m_iMaxLine;i++)

  0002c	89 7d fc	 mov	 DWORD PTR _i$549702[ebp], edi
  0002f	39 be 74 02 00
	00		 cmp	 DWORD PTR [esi+628], edi
  00035	0f 8e e5 00 00
	00		 jle	 $LN22@OnRenderBa
$LL21@OnRenderBa:

; 821  : 	{
; 822  : 		if( i%2 == 0 )

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _i$549702[ebp]
  0003e	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00043	79 05		 jns	 SHORT $LN23@OnRenderBa
  00045	48		 dec	 eax
  00046	83 c8 fe	 or	 eax, -2			; fffffffeH
  00049	40		 inc	 eax
$LN23@OnRenderBa:

; 823  : 			m_pCurrentDark->Render( iRealXPos, iRealYPos );

  0004a	66 0f 6e 45 08	 movd	 xmm0, DWORD PTR _iRealYPos$[ebp]
  0004f	57		 push	 edi
  00050	57		 push	 edi
  00051	57		 push	 edi
  00052	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00055	57		 push	 edi
  00056	75 08		 jne	 SHORT $LN9@OnRenderBa
  00058	8b 8e 3c 02 00
	00		 mov	 ecx, DWORD PTR [esi+572]

; 824  : 		else

  0005e	eb 06		 jmp	 SHORT $LN24@OnRenderBa
$LN9@OnRenderBa:

; 825  : 			m_pCurrentLight->Render( iRealXPos, iRealYPos );

  00060	8b 8e 40 02 00
	00		 mov	 ecx, DWORD PTR [esi+576]
$LN24@OnRenderBa:
  00066	8b 01		 mov	 eax, DWORD PTR [ecx]
  00068	51		 push	 ecx
  00069	51		 push	 ecx
  0006a	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00070	0f 57 c0	 xorps	 xmm0, xmm0
  00073	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  00077	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007c	ff 10		 call	 DWORD PTR [eax]

; 826  : 
; 827  : 		if( i >= (int)m_RoundInfoList.size() )

  0007e	8b 8e 9c 02 00
	00		 mov	 ecx, DWORD PTR [esi+668]
  00084	2b 8e 98 02 00
	00		 sub	 ecx, DWORD PTR [esi+664]
  0008a	8b 45 fc	 mov	 eax, DWORD PTR _i$549702[ebp]
  0008d	c1 f9 07	 sar	 ecx, 7
  00090	3b c1		 cmp	 eax, ecx
  00092	7c 52		 jl	 SHORT $LN3@OnRenderBa

; 828  : 		{
; 829  : 			if( i < m_iMaxSlot )

  00094	3b 86 60 02 00
	00		 cmp	 eax, DWORD PTR [esi+608]
  0009a	7d 10		 jge	 SHORT $LN6@OnRenderBa

; 830  : 			{
; 831  : 				if( m_pOrangeMan )

  0009c	39 be b4 01 00
	00		 cmp	 DWORD PTR [esi+436], edi
  000a2	74 42		 je	 SHORT $LN3@OnRenderBa

; 832  : 					m_pOrangeMan->Render( iRealXPos + 4, iRealYPos + 2 );

  000a4	8b 8e b4 01 00
	00		 mov	 ecx, DWORD PTR [esi+436]

; 833  : 			}
; 834  : 			else

  000aa	eb 0e		 jmp	 SHORT $LN25@OnRenderBa
$LN6@OnRenderBa:

; 835  : 			{
; 836  : 				if( m_pGrayMan )

  000ac	39 be b8 01 00
	00		 cmp	 DWORD PTR [esi+440], edi
  000b2	74 32		 je	 SHORT $LN3@OnRenderBa

; 837  : 					m_pGrayMan->Render( iRealXPos + 4, iRealYPos + 2 );

  000b4	8b 8e b8 01 00
	00		 mov	 ecx, DWORD PTR [esi+440]
$LN25@OnRenderBa:
  000ba	8b 55 08	 mov	 edx, DWORD PTR _iRealYPos$[ebp]
  000bd	8b 01		 mov	 eax, DWORD PTR [ecx]
  000bf	57		 push	 edi
  000c0	57		 push	 edi
  000c1	57		 push	 edi
  000c2	57		 push	 edi
  000c3	51		 push	 ecx
  000c4	0f 57 c0	 xorps	 xmm0, xmm0
  000c7	83 c2 02	 add	 edx, 2
  000ca	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  000ce	51		 push	 ecx
  000cf	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000d5	8d 53 04	 lea	 edx, DWORD PTR [ebx+4]
  000d8	0f 57 c0	 xorps	 xmm0, xmm0
  000db	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  000df	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e4	ff 10		 call	 DWORD PTR [eax]
$LN3@OnRenderBa:

; 838  : 			}
; 839  : 		}
; 840  : 
; 841  : 		if( 0 == ( i + 1 ) % m_iLinePlayer )

  000e6	8b 4d fc	 mov	 ecx, DWORD PTR _i$549702[ebp]
  000e9	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  000ec	99		 cdq
  000ed	f7 be 78 02 00
	00		 idiv	 DWORD PTR [esi+632]
  000f3	85 d2		 test	 edx, edx
  000f5	75 0e		 jne	 SHORT $LN2@OnRenderBa

; 842  : 		{
; 843  : 			iRealXPos += m_iLinePlayerGap;
; 844  : 			iRealYPos = iYPos;

  000f7	8b 45 0c	 mov	 eax, DWORD PTR _iYPos$[ebp]
  000fa	03 9e 7c 02 00
	00		 add	 ebx, DWORD PTR [esi+636]
  00100	89 45 08	 mov	 DWORD PTR _iRealYPos$[ebp], eax

; 845  : 		}
; 846  : 		else

  00103	eb 09		 jmp	 SHORT $LN11@OnRenderBa
$LN2@OnRenderBa:

; 847  : 		{
; 848  : 			iRealYPos += m_iLineHeight;

  00105	8b 86 8c 02 00
	00		 mov	 eax, DWORD PTR [esi+652]
  0010b	01 45 08	 add	 DWORD PTR _iRealYPos$[ebp], eax
$LN11@OnRenderBa:

; 820  : 	for(int i = 0;i < m_iMaxLine;i++)

  0010e	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00111	89 45 fc	 mov	 DWORD PTR _i$549702[ebp], eax
  00114	3b 86 74 02 00
	00		 cmp	 eax, DWORD PTR [esi+628]
  0011a	0f 8c 1b ff ff
	ff		 jl	 $LL21@OnRenderBa
$LN22@OnRenderBa:
  00120	5b		 pop	 ebx
$LN13@OnRenderBa:
  00121	5f		 pop	 edi
  00122	5e		 pop	 esi

; 849  : 		}
; 850  : 	}
; 851  : }

  00123	c9		 leave
  00124	c2 08 00	 ret	 8
?OnRenderBack@RoundStateUserWnd@@IAEXHH@Z ENDP		; RoundStateUserWnd::OnRenderBack
_TEXT	ENDS
PUBLIC	?OnRenderGangsiBack@RoundStateUserWnd@@IAEXHH@Z	; RoundStateUserWnd::OnRenderGangsiBack
; Function compile flags: /Ogsp
;	COMDAT ?OnRenderGangsiBack@RoundStateUserWnd@@IAEXHH@Z
_TEXT	SEGMENT
_i$549740 = -4						; size = 4
_iRealYPos$ = 8						; size = 4
_iXPos$ = 8						; size = 4
_iYPos$ = 12						; size = 4
?OnRenderGangsiBack@RoundStateUserWnd@@IAEXHH@Z PROC	; RoundStateUserWnd::OnRenderGangsiBack, COMDAT
; _this$ = ecx

; 877  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f1		 mov	 esi, ecx

; 878  : 	if( !m_pCurrentDark || !m_pCurrentLight || !m_pBlueDark || !m_pBlueLight ) return;

  00008	33 ff		 xor	 edi, edi
  0000a	39 be 3c 02 00
	00		 cmp	 DWORD PTR [esi+572], edi
  00010	0f 84 58 01 00
	00		 je	 $LN17@OnRenderGa
  00016	39 be 40 02 00
	00		 cmp	 DWORD PTR [esi+576], edi
  0001c	0f 84 4c 01 00
	00		 je	 $LN17@OnRenderGa
  00022	39 be 68 01 00
	00		 cmp	 DWORD PTR [esi+360], edi
  00028	0f 84 40 01 00
	00		 je	 $LN17@OnRenderGa
  0002e	39 be 6c 01 00
	00		 cmp	 DWORD PTR [esi+364], edi
  00034	0f 84 34 01 00
	00		 je	 $LN17@OnRenderGa

; 879  : 
; 880  : 	int iRealXPos = iXPos;
; 881  : 	int iRealYPos = iYPos;

  0003a	8b 45 0c	 mov	 eax, DWORD PTR _iYPos$[ebp]
  0003d	53		 push	 ebx
  0003e	8b 5d 08	 mov	 ebx, DWORD PTR _iXPos$[ebp]
  00041	89 45 08	 mov	 DWORD PTR _iRealYPos$[ebp], eax

; 882  : 	for(int i = 0;i < m_iMaxLine;i++)

  00044	89 7d fc	 mov	 DWORD PTR _i$549740[ebp], edi
  00047	39 be 74 02 00
	00		 cmp	 DWORD PTR [esi+628], edi
  0004d	0f 8e 1a 01 00
	00		 jle	 $LN26@OnRenderGa
$LL25@OnRenderGa:

; 883  : 	{
; 884  : 		if( i%2 == 0 )

  00053	8b 45 fc	 mov	 eax, DWORD PTR _i$549740[ebp]
  00056	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  0005b	79 05		 jns	 SHORT $LN27@OnRenderGa
  0005d	48		 dec	 eax
  0005e	83 c8 fe	 or	 eax, -2			; fffffffeH
  00061	40		 inc	 eax
$LN27@OnRenderGa:

; 885  : 		{
; 886  : 			if( GetUserTeam( i ) == TEAM_BLUE )

  00062	ff 75 fc	 push	 DWORD PTR _i$549740[ebp]
  00065	8b ce		 mov	 ecx, esi
  00067	75 26		 jne	 SHORT $LN13@OnRenderGa
  00069	e8 00 00 00 00	 call	 ?GetUserTeam@RoundStateUserWnd@@IAE?AW4TeamType@@H@Z ; RoundStateUserWnd::GetUserTeam

; 887  : 				m_pBlueDark->Render( iRealXPos, iRealYPos );

  0006e	66 0f 6e 45 08	 movd	 xmm0, DWORD PTR _iRealYPos$[ebp]
  00073	57		 push	 edi
  00074	57		 push	 edi
  00075	57		 push	 edi
  00076	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00079	57		 push	 edi
  0007a	83 f8 02	 cmp	 eax, 2
  0007d	75 08		 jne	 SHORT $LN12@OnRenderGa
  0007f	8b 8e 68 01 00
	00		 mov	 ecx, DWORD PTR [esi+360]

; 888  : 			else

  00085	eb 2c		 jmp	 SHORT $LN28@OnRenderGa
$LN12@OnRenderGa:

; 889  : 				m_pCurrentDark->Render( iRealXPos, iRealYPos );

  00087	8b 8e 3c 02 00
	00		 mov	 ecx, DWORD PTR [esi+572]

; 890  : 		}
; 891  : 		else

  0008d	eb 24		 jmp	 SHORT $LN28@OnRenderGa
$LN13@OnRenderGa:

; 892  : 		{
; 893  : 			if( GetUserTeam( i ) == TEAM_BLUE )

  0008f	e8 00 00 00 00	 call	 ?GetUserTeam@RoundStateUserWnd@@IAE?AW4TeamType@@H@Z ; RoundStateUserWnd::GetUserTeam

; 894  : 				m_pBlueLight->Render( iRealXPos, iRealYPos );

  00094	66 0f 6e 45 08	 movd	 xmm0, DWORD PTR _iRealYPos$[ebp]
  00099	57		 push	 edi
  0009a	57		 push	 edi
  0009b	57		 push	 edi
  0009c	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0009f	57		 push	 edi
  000a0	83 f8 02	 cmp	 eax, 2
  000a3	75 08		 jne	 SHORT $LN9@OnRenderGa
  000a5	8b 8e 6c 01 00
	00		 mov	 ecx, DWORD PTR [esi+364]

; 895  : 			else

  000ab	eb 06		 jmp	 SHORT $LN28@OnRenderGa
$LN9@OnRenderGa:

; 896  : 				m_pCurrentLight->Render( iRealXPos, iRealYPos );

  000ad	8b 8e 40 02 00
	00		 mov	 ecx, DWORD PTR [esi+576]
$LN28@OnRenderGa:
  000b3	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b5	51		 push	 ecx
  000b6	51		 push	 ecx
  000b7	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000bd	0f 57 c0	 xorps	 xmm0, xmm0
  000c0	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  000c4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c9	ff 10		 call	 DWORD PTR [eax]

; 897  : 		}
; 898  : 
; 899  : 		if( i >= (int)m_RoundInfoList.size() )

  000cb	8b 8e 9c 02 00
	00		 mov	 ecx, DWORD PTR [esi+668]
  000d1	2b 8e 98 02 00
	00		 sub	 ecx, DWORD PTR [esi+664]
  000d7	8b 45 fc	 mov	 eax, DWORD PTR _i$549740[ebp]
  000da	c1 f9 07	 sar	 ecx, 7
  000dd	3b c1		 cmp	 eax, ecx
  000df	7c 52		 jl	 SHORT $LN3@OnRenderGa

; 900  : 		{
; 901  : 			if( i < m_iMaxSlot )

  000e1	3b 86 60 02 00
	00		 cmp	 eax, DWORD PTR [esi+608]
  000e7	7d 10		 jge	 SHORT $LN6@OnRenderGa

; 902  : 			{
; 903  : 				if( m_pOrangeMan )

  000e9	39 be b4 01 00
	00		 cmp	 DWORD PTR [esi+436], edi
  000ef	74 42		 je	 SHORT $LN3@OnRenderGa

; 904  : 					m_pOrangeMan->Render( iRealXPos + 4, iRealYPos + 2 );

  000f1	8b 8e b4 01 00
	00		 mov	 ecx, DWORD PTR [esi+436]

; 905  : 			}
; 906  : 			else

  000f7	eb 0e		 jmp	 SHORT $LN29@OnRenderGa
$LN6@OnRenderGa:

; 907  : 			{
; 908  : 				if( m_pGrayMan )

  000f9	39 be b8 01 00
	00		 cmp	 DWORD PTR [esi+440], edi
  000ff	74 32		 je	 SHORT $LN3@OnRenderGa

; 909  : 					m_pGrayMan->Render( iRealXPos + 4, iRealYPos + 2 );

  00101	8b 8e b8 01 00
	00		 mov	 ecx, DWORD PTR [esi+440]
$LN29@OnRenderGa:
  00107	8b 55 08	 mov	 edx, DWORD PTR _iRealYPos$[ebp]
  0010a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0010c	57		 push	 edi
  0010d	57		 push	 edi
  0010e	57		 push	 edi
  0010f	57		 push	 edi
  00110	51		 push	 ecx
  00111	0f 57 c0	 xorps	 xmm0, xmm0
  00114	83 c2 02	 add	 edx, 2
  00117	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  0011b	51		 push	 ecx
  0011c	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00122	8d 53 04	 lea	 edx, DWORD PTR [ebx+4]
  00125	0f 57 c0	 xorps	 xmm0, xmm0
  00128	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  0012c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00131	ff 10		 call	 DWORD PTR [eax]
$LN3@OnRenderGa:

; 910  : 			}
; 911  : 		}
; 912  : 
; 913  : 		if( 0 == ( i + 1 ) % m_iLinePlayer )

  00133	8b 4d fc	 mov	 ecx, DWORD PTR _i$549740[ebp]
  00136	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00139	99		 cdq
  0013a	f7 be 78 02 00
	00		 idiv	 DWORD PTR [esi+632]
  00140	85 d2		 test	 edx, edx
  00142	75 0e		 jne	 SHORT $LN2@OnRenderGa

; 914  : 		{
; 915  : 			iRealXPos += m_iLinePlayerGap;
; 916  : 			iRealYPos = iYPos;

  00144	8b 45 0c	 mov	 eax, DWORD PTR _iYPos$[ebp]
  00147	03 9e 7c 02 00
	00		 add	 ebx, DWORD PTR [esi+636]
  0014d	89 45 08	 mov	 DWORD PTR _iRealYPos$[ebp], eax

; 917  : 		}
; 918  : 		else

  00150	eb 09		 jmp	 SHORT $LN15@OnRenderGa
$LN2@OnRenderGa:

; 919  : 		{
; 920  : 			iRealYPos += m_iLineHeight;

  00152	8b 86 8c 02 00
	00		 mov	 eax, DWORD PTR [esi+652]
  00158	01 45 08	 add	 DWORD PTR _iRealYPos$[ebp], eax
$LN15@OnRenderGa:

; 882  : 	for(int i = 0;i < m_iMaxLine;i++)

  0015b	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0015e	89 45 fc	 mov	 DWORD PTR _i$549740[ebp], eax
  00161	3b 86 74 02 00
	00		 cmp	 eax, DWORD PTR [esi+628]
  00167	0f 8c e6 fe ff
	ff		 jl	 $LL25@OnRenderGa
$LN26@OnRenderGa:
  0016d	5b		 pop	 ebx
$LN17@OnRenderGa:
  0016e	5f		 pop	 edi
  0016f	5e		 pop	 esi

; 921  : 		}
; 922  : 	}
; 923  : }

  00170	c9		 leave
  00171	c2 08 00	 ret	 8
?OnRenderGangsiBack@RoundStateUserWnd@@IAEXHH@Z ENDP	; RoundStateUserWnd::OnRenderGangsiBack
_TEXT	ENDS
PUBLIC	?OnRenderPing@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderPing
EXTRN	?RenderPing@PingStepWnd@@QAEXHHH_NW4UIRenderType@@@Z:PROC ; PingStepWnd::RenderPing
EXTRN	?GetPingStep@PingStepWnd@@QAEHH@Z:PROC		; PingStepWnd::GetPingStep
EXTRN	?IsServerRelay@P2PNetwork@@YA_NABVioHashString@@@Z:PROC ; P2PNetwork::IsServerRelay
EXTRN	?GetP2pPingTime@P2PNetwork@@YAHABVioHashString@@@Z:PROC ; P2PNetwork::GetP2pPingTime
EXTRN	?GetSingleton@ioGlobalTimer@@SAAAV1@XZ:PROC	; ioGlobalTimer::GetSingleton
; Function compile flags: /Ogsp
;	COMDAT ?OnRenderPing@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z
_TEXT	SEGMENT
_bServerRelay$ = -4					; size = 1
_rkInfo$ = 8						; size = 4
_iXPos$ = 12						; size = 4
_iYPos$ = 16						; size = 4
_bOver$ = 20						; size = 1
?OnRenderPing@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z PROC ; RoundStateUserWnd::OnRenderPing, COMDAT
; _this$ = ecx

; 1143 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 1144 : 	bool bServerRelay = false;
; 1145 : 	int  iPingStep = 0;
; 1146 : 	if( rkInfo.m_bOwner )

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _rkInfo$[ebp]
  00008	80 7b 54 00	 cmp	 BYTE PTR [ebx+84], 0
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	8b f9		 mov	 edi, ecx
  00010	c6 45 fc 00	 mov	 BYTE PTR _bServerRelay$[ebp], 0
  00014	74 0a		 je	 SHORT $LN3@OnRenderPi

; 1147 : 	{
; 1148 : 		iPingStep = g_GlobalTimer.GetServerDelayMS();	

  00016	e8 00 00 00 00	 call	 ?GetSingleton@ioGlobalTimer@@SAAAV1@XZ ; ioGlobalTimer::GetSingleton
  0001b	8b 70 18	 mov	 esi, DWORD PTR [eax+24]

; 1149 : 	}			
; 1150 : 	else

  0001e	eb 1d		 jmp	 SHORT $LN1@OnRenderPi
$LN3@OnRenderPi:

; 1151 : 	{
; 1152 : 		iPingStep = abs(  P2PNetwork::GetP2pPingTime( rkInfo.m_szName ) );

  00020	53		 push	 ebx
  00021	e8 00 00 00 00	 call	 ?GetP2pPingTime@P2PNetwork@@YAHABVioHashString@@@Z ; P2PNetwork::GetP2pPingTime
  00026	99		 cdq
  00027	8b f0		 mov	 esi, eax
  00029	33 f2		 xor	 esi, edx

; 1153 : 		if( P2PNetwork::IsServerRelay( rkInfo.m_szName ) )

  0002b	53		 push	 ebx
  0002c	2b f2		 sub	 esi, edx
  0002e	e8 00 00 00 00	 call	 ?IsServerRelay@P2PNetwork@@YA_NABVioHashString@@@Z ; P2PNetwork::IsServerRelay
  00033	59		 pop	 ecx
  00034	59		 pop	 ecx
  00035	84 c0		 test	 al, al
  00037	74 04		 je	 SHORT $LN1@OnRenderPi

; 1154 : 			bServerRelay = true;

  00039	c6 45 fc 01	 mov	 BYTE PTR _bServerRelay$[ebp], 1
$LN1@OnRenderPi:

; 1155 : 	}
; 1156 : 
; 1157 : 	int iPingCnt = m_PingStep.GetPingStep(iPingStep);

  0003d	56		 push	 esi
  0003e	8d 8f a8 02 00
	00		 lea	 ecx, DWORD PTR [edi+680]
  00044	e8 00 00 00 00	 call	 ?GetPingStep@PingStepWnd@@QAEHH@Z ; PingStepWnd::GetPingStep

; 1158 : 	m_PingStep.RenderPing( iXPos, iYPos, iPingCnt, bServerRelay );

  00049	6a 00		 push	 0
  0004b	ff 75 fc	 push	 DWORD PTR _bServerRelay$[ebp]
  0004e	8d 8f a8 02 00
	00		 lea	 ecx, DWORD PTR [edi+680]
  00054	50		 push	 eax
  00055	ff 75 10	 push	 DWORD PTR _iYPos$[ebp]
  00058	ff 75 0c	 push	 DWORD PTR _iXPos$[ebp]
  0005b	e8 00 00 00 00	 call	 ?RenderPing@PingStepWnd@@QAEXHHH_NW4UIRenderType@@@Z ; PingStepWnd::RenderPing
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx

; 1159 : }

  00063	c9		 leave
  00064	c2 10 00	 ret	 16			; 00000010H
?OnRenderPing@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ENDP ; RoundStateUserWnd::OnRenderPing
_TEXT	ENDS
PUBLIC	??1tagBattleRoomInfo@@QAE@XZ			; tagBattleRoomInfo::~tagBattleRoomInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1tagBattleRoomInfo@@QAE@XZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??1tagBattleRoomInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1tagBattleRoomInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1tagBattleRoomInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1tagBattleRoomInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1tagBattleRoomInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1tagBattleRoomInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1tagBattleRoomInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1tagBattleRoomInfo@@QAE@XZ$5
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??1tagBattleRoomInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1tagBattleRoomInfo@@QAE@XZ PROC			; tagBattleRoomInfo::~tagBattleRoomInfo, COMDAT
; _this$ = ecx
  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??1tagBattleRoomInfo@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	bf 00 00 00 00	 mov	 edi, OFFSET ??_7?$CEncrypt@H@@6B@
  00016	8d 8e 14 01 00
	00		 lea	 ecx, DWORD PTR [esi+276]
  0001c	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5
  00023	89 be 08 01 00
	00		 mov	 DWORD PTR [esi+264], edi
  00029	e8 00 00 00 00	 call	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
  0002e	8d 8e e4 00 00
	00		 lea	 ecx, DWORD PTR [esi+228]
  00034	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00038	89 be d8 00 00
	00		 mov	 DWORD PTR [esi+216], edi
  0003e	e8 00 00 00 00	 call	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
  00043	8d 8e a8 00 00
	00		 lea	 ecx, DWORD PTR [esi+168]
  00049	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0004d	89 be 9c 00 00
	00		 mov	 DWORD PTR [esi+156], edi
  00053	e8 00 00 00 00	 call	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
  00058	8d 4e 78	 lea	 ecx, DWORD PTR [esi+120]
  0005b	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0005f	c7 46 6c 00 00
	00 00		 mov	 DWORD PTR [esi+108], OFFSET ??_7?$CEncrypt@_N@@6B@
  00066	e8 00 00 00 00	 call	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
  0006b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00071	8d 4e 24	 lea	 ecx, DWORD PTR [esi+36]
  00074	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00078	ff d7		 call	 edi
  0007a	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  0007d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00081	ff d7		 call	 edi
  00083	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00087	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0008a	ff d7		 call	 edi
  0008c	e8 00 00 00 00	 call	 __EH_epilog3
  00091	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1tagBattleRoomInfo@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??1tagBattleRoomInfo@@QAE@XZ$1:
  0000c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 14	 add	 ecx, 20			; 00000014H
  00012	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??1tagBattleRoomInfo@@QAE@XZ$2:
  00018	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 c1 24	 add	 ecx, 36			; 00000024H
  0001e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??1tagBattleRoomInfo@@QAE@XZ$3:
  00024	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	83 c1 6c	 add	 ecx, 108		; 0000006cH
  0002a	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@_N@@UAE@XZ ; CEncrypt<bool>::~CEncrypt<bool>
__unwindfunclet$??1tagBattleRoomInfo@@QAE@XZ$4:
  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
  00038	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@H@@UAE@XZ	; CEncrypt<int>::~CEncrypt<int>
__unwindfunclet$??1tagBattleRoomInfo@@QAE@XZ$5:
  0003d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	81 c1 d8 00 00
	00		 add	 ecx, 216		; 000000d8H
  00046	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@H@@UAE@XZ	; CEncrypt<int>::~CEncrypt<int>
__ehhandler$??1tagBattleRoomInfo@@QAE@XZ:
  0004b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0004f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00052	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00055	33 c8		 xor	 ecx, eax
  00057	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1tagBattleRoomInfo@@QAE@XZ
  00061	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1tagBattleRoomInfo@@QAE@XZ ENDP			; tagBattleRoomInfo::~tagBattleRoomInfo
PUBLIC	??_R0?AVioWnd@@@8				; ioWnd `RTTI Type Descriptor'
PUBLIC	??_R0?AVRoundStateUserWnd@@@8			; RoundStateUserWnd `RTTI Type Descriptor'
PUBLIC	?SetTournamentData@RoundStateMainWnd@@QAEXXZ	; RoundStateMainWnd::SetTournamentData
EXTRN	?TournamentCurrentRoundWithTeam@Help@@YAHHH@Z:PROC ; Help::TournamentCurrentRoundWithTeam
EXTRN	?GetTeamData@ioTournamentTeamManager@@QAEPAVTeamGlobalData@@K_N@Z:PROC ; ioTournamentTeamManager::GetTeamData
EXTRN	?GetSingleton@ioTournamentTeamManager@@SAAAV1@XZ:PROC ; ioTournamentTeamManager::GetSingleton
EXTRN	?GetTournament@ioTournamentManager@@QAEPAVTournamentNode@@K_N@Z:PROC ; ioTournamentManager::GetTournament
EXTRN	?GetSingleton@ioTournamentManager@@SAAAV1@XZ:PROC ; ioTournamentManager::GetSingleton
EXTRN	?IsBattleRoom@ioBattleRoomMgr@@QAE_NXZ:PROC	; ioBattleRoomMgr::IsBattleRoom
EXTRN	___RTDynamicCast:PROC
;	COMDAT ??_R0?AVioWnd@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\tournamentnode.h
_DATA	SEGMENT
??_R0?AVioWnd@@@8 DD FLAT:??_7type_info@@6B@		; ioWnd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioWnd@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVRoundStateUserWnd@@@8
_DATA	SEGMENT
??_R0?AVRoundStateUserWnd@@@8 DD FLAT:??_7type_info@@6B@ ; RoundStateUserWnd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRoundStateUserWnd@@', 00H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
_DATA	ENDS
;	COMDAT ?SetTournamentData@RoundStateMainWnd@@QAEXXZ
_TEXT	SEGMENT
$T557556 = -12						; size = 4
$T557555 = -12						; size = 4
_pRedWnd$551006 = -8					; size = 4
_pBlueWnd$550999 = -8					; size = 4
_pTournament$550995 = -4				; size = 4
?SetTournamentData@RoundStateMainWnd@@QAEXXZ PROC	; RoundStateMainWnd::SetTournamentData, COMDAT
; _this$ = ecx

; 2945 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx

; 2946 : 	m_iTournamentCurrentRound = 0;

  0000b	33 ff		 xor	 edi, edi
  0000d	89 be 94 01 00
	00		 mov	 DWORD PTR [esi+404], edi

; 2947 : 	if( g_BattleRoomMgr.IsBattleRoom() && g_BattleRoomMgr.IsTournamentModeType() )

  00013	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 ?IsBattleRoom@ioBattleRoomMgr@@QAE_NXZ ; ioBattleRoomMgr::IsBattleRoom
  0001f	84 c0		 test	 al, al
  00021	0f 84 4a 01 00
	00		 je	 $LN8@SetTournam
  00027	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  0002c	8b c8		 mov	 ecx, eax
  0002e	e8 00 00 00 00	 call	 ?IsTournamentModeType@ioBattleRoomMgr@@QAE_NXZ ; ioBattleRoomMgr::IsTournamentModeType
  00033	84 c0		 test	 al, al
  00035	0f 84 36 01 00
	00		 je	 $LN8@SetTournam

; 2948 : 	{
; 2949 : 		DWORD dwTournamentIndex = g_BattleRoomMgr.GetTournamentIndex();

  0003b	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  00040	8b 80 80 01 00
	00		 mov	 eax, DWORD PTR [eax+384]

; 2950 : 		TournamentNode *pTournament = g_TournamentMgr.GetTournament( dwTournamentIndex );

  00046	6a 01		 push	 1
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 ?GetSingleton@ioTournamentManager@@SAAAV1@XZ ; ioTournamentManager::GetSingleton
  0004e	8b c8		 mov	 ecx, eax
  00050	e8 00 00 00 00	 call	 ?GetTournament@ioTournamentManager@@QAEPAVTournamentNode@@K_N@Z ; ioTournamentManager::GetTournament
  00055	89 45 fc	 mov	 DWORD PTR _pTournament$550995[ebp], eax

; 2951 : 		if( pTournament )

  00058	3b c7		 cmp	 eax, edi
  0005a	0f 84 06 01 00
	00		 je	 $LN32@SetTournam

; 2952 : 		{
; 2953 : 			TeamGlobalData* pBlue = g_TournamentTeamMgr.GetTeamData(  g_BattleRoomMgr.GetTournamentBlueIndex(), false );

  00060	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  00065	8b 80 84 01 00
	00		 mov	 eax, DWORD PTR [eax+388]
  0006b	57		 push	 edi
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 ?GetSingleton@ioTournamentTeamManager@@SAAAV1@XZ ; ioTournamentTeamManager::GetSingleton
  00072	8b c8		 mov	 ecx, eax
  00074	e8 00 00 00 00	 call	 ?GetTeamData@ioTournamentTeamManager@@QAEPAVTeamGlobalData@@K_N@Z ; ioTournamentTeamManager::GetTeamData
  00079	8b d8		 mov	 ebx, eax

; 2954 : 			if( pBlue )

  0007b	3b df		 cmp	 ebx, edi
  0007d	74 64		 je	 SHORT $LN31@SetTournam

; 2955 : 			{
; 2956 : 				RoundStateUserWnd *pBlueWnd = dynamic_cast<RoundStateUserWnd *>(FindChildWnd( ID_BLUE_WND ));

  0007f	57		 push	 edi
  00080	68 00 00 00 00	 push	 OFFSET ??_R0?AVRoundStateUserWnd@@@8
  00085	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWnd@@@8
  0008a	57		 push	 edi
  0008b	6a 04		 push	 4
  0008d	8b ce		 mov	 ecx, esi
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?FindChildWnd@ioWnd@@QAEPAV1@K@Z
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ___RTDynamicCast
  0009b	83 c4 14	 add	 esp, 20			; 00000014H
  0009e	89 45 f8	 mov	 DWORD PTR _pBlueWnd$550999[ebp], eax

; 2957 : 				if( pBlueWnd )

  000a1	3b c7		 cmp	 eax, edi
  000a3	74 3e		 je	 SHORT $LN31@SetTournam

; 2958 : 				{
; 2959 : 					pBlueWnd->SetTournamentTeamName( pBlue->GetTeamName() );

  000a5	83 ec 10	 sub	 esp, 16			; 00000010H
  000a8	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
  000ab	8b cc		 mov	 ecx, esp
  000ad	89 65 f4	 mov	 DWORD PTR $T557555[ebp], esp
  000b0	50		 push	 eax
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  000b7	8b 4d f8	 mov	 ecx, DWORD PTR _pBlueWnd$550999[ebp]
  000ba	e8 00 00 00 00	 call	 ?SetTournamentTeamName@RoundStateUserWnd@@QAEXVioHashString@@@Z ; RoundStateUserWnd::SetTournamentTeamName

; 2960 : 
; 2961 : 					if( m_iTournamentCurrentRound == 0 )

  000bf	39 be 94 01 00
	00		 cmp	 DWORD PTR [esi+404], edi
  000c5	75 1c		 jne	 SHORT $LN31@SetTournam

; 2962 : 						m_iTournamentCurrentRound = Help::TournamentCurrentRoundWithTeam( pTournament->GetTournamentStartTeamCount(), pBlue->GetTourPos() - 1 );

  000c7	8a 5b 38	 mov	 bl, BYTE PTR [ebx+56]
  000ca	8b 45 fc	 mov	 eax, DWORD PTR _pTournament$550995[ebp]
  000cd	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  000d0	0f b6 cb	 movzx	 ecx, bl
  000d3	49		 dec	 ecx
  000d4	51		 push	 ecx
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 ?TournamentCurrentRoundWithTeam@Help@@YAHHH@Z ; Help::TournamentCurrentRoundWithTeam
  000db	59		 pop	 ecx
  000dc	59		 pop	 ecx
  000dd	89 86 94 01 00
	00		 mov	 DWORD PTR [esi+404], eax
$LN31@SetTournam:

; 2963 : 					
; 2964 : 
; 2965 : 				}
; 2966 : 			}
; 2967 : 
; 2968 : 			TeamGlobalData* pRed = g_TournamentTeamMgr.GetTeamData( g_BattleRoomMgr.GetTournamentRedIndex(), false );

  000e3	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  000e8	8b 80 88 01 00
	00		 mov	 eax, DWORD PTR [eax+392]
  000ee	57		 push	 edi
  000ef	50		 push	 eax
  000f0	e8 00 00 00 00	 call	 ?GetSingleton@ioTournamentTeamManager@@SAAAV1@XZ ; ioTournamentTeamManager::GetSingleton
  000f5	8b c8		 mov	 ecx, eax
  000f7	e8 00 00 00 00	 call	 ?GetTeamData@ioTournamentTeamManager@@QAEPAVTeamGlobalData@@K_N@Z ; ioTournamentTeamManager::GetTeamData
  000fc	8b d8		 mov	 ebx, eax

; 2969 : 			if( pRed )

  000fe	3b df		 cmp	 ebx, edi
  00100	74 64		 je	 SHORT $LN32@SetTournam

; 2970 : 			{
; 2971 : 				RoundStateUserWnd *pRedWnd = dynamic_cast<RoundStateUserWnd *>(FindChildWnd( ID_RED_WND ));

  00102	57		 push	 edi
  00103	68 00 00 00 00	 push	 OFFSET ??_R0?AVRoundStateUserWnd@@@8
  00108	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWnd@@@8
  0010d	57		 push	 edi
  0010e	6a 05		 push	 5
  00110	8b ce		 mov	 ecx, esi
  00112	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?FindChildWnd@ioWnd@@QAEPAV1@K@Z
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 ___RTDynamicCast
  0011e	83 c4 14	 add	 esp, 20			; 00000014H
  00121	89 45 f8	 mov	 DWORD PTR _pRedWnd$551006[ebp], eax

; 2972 : 				if( pRedWnd )

  00124	3b c7		 cmp	 eax, edi
  00126	74 3e		 je	 SHORT $LN32@SetTournam

; 2973 : 				{
; 2974 : 					pRedWnd->SetTournamentTeamName( pRed->GetTeamName() );

  00128	83 ec 10	 sub	 esp, 16			; 00000010H
  0012b	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
  0012e	8b cc		 mov	 ecx, esp
  00130	89 65 f4	 mov	 DWORD PTR $T557556[ebp], esp
  00133	50		 push	 eax
  00134	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  0013a	8b 4d f8	 mov	 ecx, DWORD PTR _pRedWnd$551006[ebp]
  0013d	e8 00 00 00 00	 call	 ?SetTournamentTeamName@RoundStateUserWnd@@QAEXVioHashString@@@Z ; RoundStateUserWnd::SetTournamentTeamName

; 2975 : 
; 2976 : 					if( m_iTournamentCurrentRound == 0 )

  00142	39 be 94 01 00
	00		 cmp	 DWORD PTR [esi+404], edi
  00148	75 1c		 jne	 SHORT $LN32@SetTournam

; 2977 : 						m_iTournamentCurrentRound = Help::TournamentCurrentRoundWithTeam( pTournament->GetTournamentStartTeamCount(), pRed->GetTourPos() - 1 );

  0014a	8a 5b 38	 mov	 bl, BYTE PTR [ebx+56]
  0014d	8b 45 fc	 mov	 eax, DWORD PTR _pTournament$550995[ebp]
  00150	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00153	0f b6 cb	 movzx	 ecx, bl
  00156	49		 dec	 ecx
  00157	51		 push	 ecx
  00158	50		 push	 eax
  00159	e8 00 00 00 00	 call	 ?TournamentCurrentRoundWithTeam@Help@@YAHHH@Z ; Help::TournamentCurrentRoundWithTeam
  0015e	59		 pop	 ecx
  0015f	59		 pop	 ecx
  00160	89 86 94 01 00
	00		 mov	 DWORD PTR [esi+404], eax
$LN32@SetTournam:

; 2978 : 				}
; 2979 : 			}
; 2980 : 		}
; 2981 : 		HideChildWnd( ID_EXIT_BTN );

  00166	57		 push	 edi
  00167	6a 01		 push	 1
  00169	8b ce		 mov	 ecx, esi
  0016b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?HideChildWnd@ioWnd@@QAEXK_N@Z
$LN8@SetTournam:

; 2982 : 	}
; 2983 : }

  00171	5f		 pop	 edi
  00172	5e		 pop	 esi
  00173	5b		 pop	 ebx
  00174	c9		 leave
  00175	c3		 ret	 0
?SetTournamentData@RoundStateMainWnd@@QAEXXZ ENDP	; RoundStateMainWnd::SetTournamentData
_TEXT	ENDS
PUBLIC	?iwm_hide@RoundResultMainWnd@@UAEXXZ		; RoundResultMainWnd::iwm_hide
EXTRN	__imp_?ShowWnd@ioGUIManager@@QAEXK_N@Z:PROC
; Function compile flags: /Ogsp
;	COMDAT ?iwm_hide@RoundResultMainWnd@@UAEXXZ
_TEXT	SEGMENT
?iwm_hide@RoundResultMainWnd@@UAEXXZ PROC		; RoundResultMainWnd::iwm_hide, COMDAT
; _this$ = ecx

; 3104 : 	if( m_RoundInfoList.size() != 0 )

  00000	8d 81 64 01 00
	00		 lea	 eax, DWORD PTR [ecx+356]
  00006	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00009	2b 08		 sub	 ecx, DWORD PTR [eax]
  0000b	f7 c1 80 ff ff
	ff		 test	 ecx, -128		; ffffff80H
  00011	74 57		 je	 SHORT $LN1@iwm_hide

; 3105 : 	{
; 3106 : 		g_GUIMgr.ShowWnd( MINIMAP_WND );

  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	33 ff		 xor	 edi, edi
  00017	57		 push	 edi
  00018	68 74 17 00 00	 push	 6004			; 00001774H
  0001d	e8 00 00 00 00	 call	 ?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ ; ioSP2GUIManager::GetSingleton
  00022	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?ShowWnd@ioGUIManager@@QAEXK_N@Z
  00028	8b c8		 mov	 ecx, eax
  0002a	ff d6		 call	 esi

; 3107 : 		g_GUIMgr.ShowWnd( TIME_SCORE_WND );

  0002c	57		 push	 edi
  0002d	68 b9 13 00 00	 push	 5049			; 000013b9H
  00032	e8 00 00 00 00	 call	 ?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ ; ioSP2GUIManager::GetSingleton
  00037	8b c8		 mov	 ecx, eax
  00039	ff d6		 call	 esi

; 3108 : 		g_GUIMgr.ShowWnd( SKILL_LIST_WND );

  0003b	57		 push	 edi
  0003c	68 89 13 00 00	 push	 5001			; 00001389H
  00041	e8 00 00 00 00	 call	 ?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ ; ioSP2GUIManager::GetSingleton
  00046	8b c8		 mov	 ecx, eax
  00048	ff d6		 call	 esi

; 3109 : 		g_GUIMgr.ShowWnd( ACCESSORY_SKILL_LIST_WND );

  0004a	57		 push	 edi
  0004b	68 9c 18 00 00	 push	 6300			; 0000189cH
  00050	e8 00 00 00 00	 call	 ?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ ; ioSP2GUIManager::GetSingleton
  00055	8b c8		 mov	 ecx, eax
  00057	ff d6		 call	 esi

; 3110 : 		g_GUIMgr.ShowWnd( FIGHTCLUB_TIME_GAUGE_WND );

  00059	57		 push	 edi
  0005a	68 d1 13 00 00	 push	 5073			; 000013d1H
  0005f	e8 00 00 00 00	 call	 ?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ ; ioSP2GUIManager::GetSingleton
  00064	8b c8		 mov	 ecx, eax
  00066	ff d6		 call	 esi
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
$LN1@iwm_hide:

; 3111 : 	}	
; 3112 : 	RoundStateMainWnd::iwm_hide();
; 3113 : }

  0006a	c3		 ret	 0
?iwm_hide@RoundResultMainWnd@@UAEXXZ ENDP		; RoundResultMainWnd::iwm_hide
_TEXT	ENDS
PUBLIC	?OnProcess@RoundResultMainWnd@@MAEXM@Z		; RoundResultMainWnd::OnProcess
EXTRN	__imp_?HideWnd@ioWnd@@QAEXXZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ?OnProcess@RoundResultMainWnd@@MAEXM@Z
_TEXT	SEGMENT
_fTimePerSec$ = 8					; size = 4
?OnProcess@RoundResultMainWnd@@MAEXM@Z PROC		; RoundResultMainWnd::OnProcess, COMDAT
; _this$ = ecx

; 3116 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3117 : 	if( !IsShow() )	return;

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsShow@ioWnd@@QBE_NXZ
  00009	84 c0		 test	 al, al
  0000b	0f 84 92 00 00
	00		 je	 $LN1@OnProcess@2

; 3118 : 
; 3119 : 	if( g_Input.IsKeyDown( KEY_TAB ) )

  00011	e8 00 00 00 00	 call	 ?GetSingleton@CDirectInput@@SAAAV1@XZ ; CDirectInput::GetSingleton
  00016	6a 09		 push	 9
  00018	5a		 pop	 edx
  00019	8b c8		 mov	 ecx, eax
  0001b	e8 00 00 00 00	 call	 ?IsKeyDown@CDirectInput@@QAI_NG@Z ; CDirectInput::IsKeyDown
  00020	84 c0		 test	 al, al
  00022	74 16		 je	 SHORT $LN5@OnProcess@2

; 3120 : 	{
; 3121 : 		SetWndPos( Setting::Width(), Setting::Height() );

  00024	e8 00 00 00 00	 call	 ?Height@Setting@@SAHXZ	; Setting::Height
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?Width@Setting@@SAHXZ	; Setting::Width
  0002f	50		 push	 eax
  00030	8b ce		 mov	 ecx, esi
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetWndPos@ioWnd@@QAEXHH@Z

; 3122 : 	}
; 3123 : 	else

  00038	eb 47		 jmp	 SHORT $LN4@OnProcess@2
$LN5@OnProcess@2:
  0003a	53		 push	 ebx
  0003b	57		 push	 edi

; 3124 : 	{
; 3125 : 		SetWndPos( ( Setting::Width() / 2 ) - ( GetWidth() / 2 ),
; 3126 : 				   ( Setting::Height() / 2 ) - ( GetHeight() / 2 ) - 20 );

  0003c	8b ce		 mov	 ecx, esi
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetHeight@ioWnd@@QBEHXZ
  00044	99		 cdq
  00045	2b c2		 sub	 eax, edx
  00047	8b f8		 mov	 edi, eax
  00049	8b ce		 mov	 ecx, esi
  0004b	d1 ff		 sar	 edi, 1
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetWidth@ioWnd@@QBEHXZ
  00053	99		 cdq
  00054	2b c2		 sub	 eax, edx
  00056	8b d8		 mov	 ebx, eax
  00058	d1 fb		 sar	 ebx, 1
  0005a	e8 00 00 00 00	 call	 ?Height@Setting@@SAHXZ	; Setting::Height
  0005f	99		 cdq
  00060	2b c2		 sub	 eax, edx
  00062	d1 f8		 sar	 eax, 1
  00064	2b c7		 sub	 eax, edi
  00066	83 e8 14	 sub	 eax, 20			; 00000014H
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 ?Width@Setting@@SAHXZ	; Setting::Width
  0006f	99		 cdq
  00070	2b c2		 sub	 eax, edx
  00072	d1 f8		 sar	 eax, 1
  00074	2b c3		 sub	 eax, ebx
  00076	50		 push	 eax
  00077	8b ce		 mov	 ecx, esi
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetWndPos@ioWnd@@QAEXHH@Z
  0007f	5f		 pop	 edi
  00080	5b		 pop	 ebx
$LN4@OnProcess@2:

; 3127 : 	}
; 3128 : 
; 3129 : 	if( m_pPlayStage )

  00081	8b 86 60 01 00
	00		 mov	 eax, DWORD PTR [esi+352]
  00087	85 c0		 test	 eax, eax
  00089	74 18		 je	 SHORT $LN1@OnProcess@2

; 3130 : 	{
; 3131 : 		ioPlayMode *pPlayMode = m_pPlayStage->GetPlayMode();

  0008b	8b 80 10 01 00
	00		 mov	 eax, DWORD PTR [eax+272]

; 3132 : 		if( !pPlayMode ) return;

  00091	85 c0		 test	 eax, eax
  00093	74 0e		 je	 SHORT $LN1@OnProcess@2

; 3133 : 		if( pPlayMode->GetModeState() == ioPlayMode::MS_PLAY )

  00095	83 78 38 01	 cmp	 DWORD PTR [eax+56], 1
  00099	75 08		 jne	 SHORT $LN1@OnProcess@2

; 3134 : 		{
; 3135 : 			HideWnd();

  0009b	8b ce		 mov	 ecx, esi
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?HideWnd@ioWnd@@QAEXXZ
$LN1@OnProcess@2:
  000a3	5e		 pop	 esi

; 3136 : 		}
; 3137 : 	}
; 3138 : }

  000a4	c2 04 00	 ret	 4
?OnProcess@RoundResultMainWnd@@MAEXM@Z ENDP		; RoundResultMainWnd::OnProcess
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE@V?$allocator@URoundInfo@@@1@@Z ; std::_Vector_val<RoundInfo,std::allocator<RoundInfo> >::_Vector_val<RoundInfo,std::allocator<RoundInfo> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE@V?$allocator@URoundInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE@V?$allocator@URoundInfo@@@1@@Z PROC ; std::_Vector_val<RoundInfo,std::allocator<RoundInfo> >::_Vector_val<RoundInfo,std::allocator<RoundInfo> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE@V?$allocator@URoundInfo@@@1@@Z ENDP ; std::_Vector_val<RoundInfo,std::allocator<RoundInfo> >::_Vector_val<RoundInfo,std::allocator<RoundInfo> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QAE@PAURoundInfo@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QAE@PAURoundInfo@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QAE@PAURoundInfo@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 305  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QAE@PAURoundInfo@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Make_iter
; Function compile flags: /Ogsp
;	COMDAT ?_Make_iter@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@@Z PROC ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 		return (iterator(_Where._Ptr, this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 803  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?_Make_iter@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@@Z ENDP ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QBEIXZ ; std::vector<RoundInfo,std::allocator<RoundInfo> >::max_size
; Function compile flags: /Ogsp
;	COMDAT ?max_size@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<RoundInfo,std::allocator<RoundInfo> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 01	 mov	 eax, 33554431		; 01ffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<RoundInfo,std::allocator<RoundInfo> >::max_size
_TEXT	ENDS
PUBLIC	?_Grow_to@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IBEII@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Grow_to
; Function compile flags: /Ogsp
;	COMDAT ?_Grow_to@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IBEII@Z PROC ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1275 : 		size_type _Capacity = capacity();

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00008	ba ff ff ff 01	 mov	 edx, 33554431		; 01ffffffH
  0000d	c1 f8 07	 sar	 eax, 7
  00010	8b c8		 mov	 ecx, eax
  00012	d1 e9		 shr	 ecx, 1
  00014	2b d1		 sub	 edx, ecx
  00016	3b d0		 cmp	 edx, eax
  00018	73 04		 jae	 SHORT $LN4@Grow_to
  0001a	33 c0		 xor	 eax, eax
  0001c	eb 02		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  0001e	03 c1		 add	 eax, ecx
$LN5@Grow_to:

; 1279 : 		if (_Capacity < _Count)

  00020	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]

; 1280 : 			_Capacity = _Count;

  00023	0f 42 45 08	 cmovb	 eax, DWORD PTR __Count$[ebp]

; 1281 : 		return (_Capacity);
; 1282 : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?_Grow_to@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IBEII@Z ENDP ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Grow_to
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@URoundInfo@@@std@@QAEPAURoundInfo@@I@Z ; std::allocator<RoundInfo>::allocate
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@URoundInfo@@@std@@QAEPAURoundInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@URoundInfo@@@std@@QAEPAURoundInfo@@I@Z PROC ; std::allocator<RoundInfo>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	6a 00		 push	 0
  00005	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Allocate@URoundInfo@@@std@@YAPAURoundInfo@@IPAU1@@Z ; std::_Allocate<RoundInfo>
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx

; 188  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?allocate@?$allocator@URoundInfo@@@std@@QAEPAURoundInfo@@I@Z ENDP ; std::allocator<RoundInfo>::allocate
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >::operator==
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	f7 d8		 neg	 eax
  0000c	1b c0		 sbb	 eax, eax
  0000e	40		 inc	 eax

; 204  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >::operator==
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$?8$09@@YA_NABVioHashString@@AAY09$$CBD@Z	; operator==<10>
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\io3dengine\iohashstring.h
;	COMDAT ??$?8$09@@YA_NABVioHashString@@AAY09$$CBD@Z
_TEXT	SEGMENT
__t$ = -20						; size = 10
__$ArrayPad$ = -4					; size = 4
_lhs$ = 8						; size = 4
_t$ = 12						; size = 4
??$?8$09@@YA_NABVioHashString@@AAY09$$CBD@Z PROC	; operator==<10>, COMDAT

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]

; 147  : 	_ENCSTR(t, _t); return ( strcmp( lhs.c_str(), _t ) == 0 );

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _lhs$[ebp]
  00018	84 d2		 test	 dl, dl
  0001a	0f 84 0d 01 00
	00		 je	 $LN96@operator@4
  00020	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00023	88 55 ec	 mov	 BYTE PTR __t$[ebp], dl
  00026	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00029	84 d2		 test	 dl, dl
  0002b	0f 84 f6 00 00
	00		 je	 $LN95@operator@4
  00031	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00034	88 55 ed	 mov	 BYTE PTR __t$[ebp+1], dl
  00037	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003a	84 d2		 test	 dl, dl
  0003c	0f 84 df 00 00
	00		 je	 $LN94@operator@4
  00042	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00045	88 55 ee	 mov	 BYTE PTR __t$[ebp+2], dl
  00048	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004b	84 d2		 test	 dl, dl
  0004d	0f 84 c8 00 00
	00		 je	 $LN93@operator@4
  00053	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00056	88 55 ef	 mov	 BYTE PTR __t$[ebp+3], dl
  00059	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005c	84 d2		 test	 dl, dl
  0005e	0f 84 b1 00 00
	00		 je	 $LN92@operator@4
  00064	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00067	88 55 f0	 mov	 BYTE PTR __t$[ebp+4], dl
  0006a	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006d	84 d2		 test	 dl, dl
  0006f	0f 84 9a 00 00
	00		 je	 $LN91@operator@4
  00075	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00078	88 55 f1	 mov	 BYTE PTR __t$[ebp+5], dl
  0007b	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0007e	84 d2		 test	 dl, dl
  00080	0f 84 83 00 00
	00		 je	 $LN90@operator@4
  00086	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00089	88 55 f2	 mov	 BYTE PTR __t$[ebp+6], dl
  0008c	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0008f	84 d2		 test	 dl, dl
  00091	74 70		 je	 SHORT $LN89@operator@4
  00093	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00096	88 55 f3	 mov	 BYTE PTR __t$[ebp+7], dl
  00099	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  0009c	84 d2		 test	 dl, dl
  0009e	74 5d		 je	 SHORT $LN88@operator@4
  000a0	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000a3	80 78 09 00	 cmp	 BYTE PTR [eax+9], 0
  000a7	88 55 f4	 mov	 BYTE PTR __t$[ebp+8], dl
  000aa	0f 84 81 00 00
	00		 je	 $LN1@operator@4
  000b0	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000b3	84 d2		 test	 dl, dl
  000b5	74 40		 je	 SHORT $LN86@operator@4
  000b7	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000ba	88 55 f6	 mov	 BYTE PTR __t$[ebp+10], dl
  000bd	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000c0	84 d2		 test	 dl, dl
  000c2	74 2d		 je	 SHORT $LN85@operator@4
  000c4	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000c7	88 55 f7	 mov	 BYTE PTR __t$[ebp+11], dl
  000ca	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000cd	84 d2		 test	 dl, dl
  000cf	74 1a		 je	 SHORT $LN84@operator@4
  000d1	8a 40 0d	 mov	 al, BYTE PTR [eax+13]
  000d4	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000d7	88 55 f8	 mov	 BYTE PTR __t$[ebp+12], dl
  000da	84 c0		 test	 al, al
  000dc	74 07		 je	 SHORT $LN83@operator@4
  000de	34 ec		 xor	 al, -20			; ffffffecH
  000e0	88 45 f9	 mov	 BYTE PTR __t$[ebp+13], al
  000e3	eb 4c		 jmp	 SHORT $LN1@operator@4
$LN83@operator@4:
  000e5	c6 45 f9 ec	 mov	 BYTE PTR __t$[ebp+13], -20 ; ffffffecH
  000e9	eb 46		 jmp	 SHORT $LN1@operator@4
$LN84@operator@4:
  000eb	c6 45 f8 ed	 mov	 BYTE PTR __t$[ebp+12], -19 ; ffffffedH
  000ef	eb 40		 jmp	 SHORT $LN1@operator@4
$LN85@operator@4:
  000f1	c6 45 f7 ea	 mov	 BYTE PTR __t$[ebp+11], -22 ; ffffffeaH
  000f5	eb 3a		 jmp	 SHORT $LN1@operator@4
$LN86@operator@4:
  000f7	c6 45 f6 eb	 mov	 BYTE PTR __t$[ebp+10], -21 ; ffffffebH
  000fb	eb 34		 jmp	 SHORT $LN1@operator@4
$LN88@operator@4:
  000fd	c6 45 f4 ed	 mov	 BYTE PTR __t$[ebp+8], -19 ; ffffffedH
  00101	eb 2e		 jmp	 SHORT $LN1@operator@4
$LN89@operator@4:
  00103	c6 45 f3 ea	 mov	 BYTE PTR __t$[ebp+7], -22 ; ffffffeaH
  00107	eb 28		 jmp	 SHORT $LN1@operator@4
$LN90@operator@4:
  00109	c6 45 f2 eb	 mov	 BYTE PTR __t$[ebp+6], -21 ; ffffffebH
  0010d	eb 22		 jmp	 SHORT $LN1@operator@4
$LN91@operator@4:
  0010f	c6 45 f1 ec	 mov	 BYTE PTR __t$[ebp+5], -20 ; ffffffecH
  00113	eb 1c		 jmp	 SHORT $LN1@operator@4
$LN92@operator@4:
  00115	c6 45 f0 ed	 mov	 BYTE PTR __t$[ebp+4], -19 ; ffffffedH
  00119	eb 16		 jmp	 SHORT $LN1@operator@4
$LN93@operator@4:
  0011b	c6 45 ef ea	 mov	 BYTE PTR __t$[ebp+3], -22 ; ffffffeaH
  0011f	eb 10		 jmp	 SHORT $LN1@operator@4
$LN94@operator@4:
  00121	c6 45 ee eb	 mov	 BYTE PTR __t$[ebp+2], -21 ; ffffffebH
  00125	eb 0a		 jmp	 SHORT $LN1@operator@4
$LN95@operator@4:
  00127	c6 45 ed ec	 mov	 BYTE PTR __t$[ebp+1], -20 ; ffffffecH
  0012b	eb 04		 jmp	 SHORT $LN1@operator@4
$LN96@operator@4:
  0012d	c6 45 ec ed	 mov	 BYTE PTR __t$[ebp], -19	; ffffffedH
$LN1@operator@4:
  00131	6a 02		 push	 2
  00133	8d 45 ec	 lea	 eax, DWORD PTR __t$[ebp]
  00136	c6 45 f5 00	 mov	 BYTE PTR __t$[ebp+9], 0
  0013a	5a		 pop	 edx
$LL104@operator@4:
  0013b	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00141	83 c0 04	 add	 eax, 4
  00144	4a		 dec	 edx
  00145	75 f4		 jne	 SHORT $LL104@operator@4
  00147	80 75 f4 ed	 xor	 BYTE PTR __t$[ebp+8], -19 ; ffffffedH
  0014b	56		 push	 esi
  0014c	8d 75 ec	 lea	 esi, DWORD PTR __t$[ebp]
  0014f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL111@operator@4:
  00155	8a 08		 mov	 cl, BYTE PTR [eax]
  00157	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00159	75 1a		 jne	 SHORT $LN112@operator@4
  0015b	84 c9		 test	 cl, cl
  0015d	74 12		 je	 SHORT $LN113@operator@4
  0015f	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00162	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  00165	75 0e		 jne	 SHORT $LN112@operator@4
  00167	83 c0 02	 add	 eax, 2
  0016a	83 c6 02	 add	 esi, 2
  0016d	84 c9		 test	 cl, cl
  0016f	75 e4		 jne	 SHORT $LL111@operator@4
$LN113@operator@4:
  00171	33 c0		 xor	 eax, eax
  00173	eb 05		 jmp	 SHORT $LN114@operator@4
$LN112@operator@4:
  00175	1b c0		 sbb	 eax, eax
  00177	83 d8 ff	 sbb	 eax, -1
$LN114@operator@4:
  0017a	33 c9		 xor	 ecx, ecx
  0017c	85 c0		 test	 eax, eax
  0017e	0f 94 c0	 sete	 al

; 148  : }

  00181	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00184	33 cd		 xor	 ecx, ebp
  00186	5e		 pop	 esi
  00187	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0018c	c9		 leave
  0018d	c3		 ret	 0
??$?8$09@@YA_NABVioHashString@@AAY09$$CBD@Z ENDP	; operator==<10>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$?8$0N@@@YA_NABVioHashString@@AAY0N@$$CBD@Z	; operator==<13>
; Function compile flags: /Ogsp
;	COMDAT ??$?8$0N@@@YA_NABVioHashString@@AAY0N@$$CBD@Z
_TEXT	SEGMENT
__t$ = -24						; size = 13
__$ArrayPad$ = -4					; size = 4
_lhs$ = 8						; size = 4
_t$ = 12						; size = 4
??$?8$0N@@@YA_NABVioHashString@@AAY0N@$$CBD@Z PROC	; operator==<13>, COMDAT

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]

; 147  : 	_ENCSTR(t, _t); return ( strcmp( lhs.c_str(), _t ) == 0 );

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	8b 7d 08	 mov	 edi, DWORD PTR _lhs$[ebp]
  0001a	84 d2		 test	 dl, dl
  0001c	0f 84 4d 01 00
	00		 je	 $LN96@operator@5
  00022	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00025	88 55 e8	 mov	 BYTE PTR __t$[ebp], dl
  00028	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002b	84 d2		 test	 dl, dl
  0002d	0f 84 36 01 00
	00		 je	 $LN95@operator@5
  00033	b1 ec		 mov	 cl, -20			; ffffffecH
  00035	32 d1		 xor	 dl, cl
  00037	88 55 e9	 mov	 BYTE PTR __t$[ebp+1], dl
  0003a	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003d	84 d2		 test	 dl, dl
  0003f	0f 84 1e 01 00
	00		 je	 $LN94@operator@5
  00045	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00048	88 55 ea	 mov	 BYTE PTR __t$[ebp+2], dl
  0004b	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004e	84 d2		 test	 dl, dl
  00050	0f 84 07 01 00
	00		 je	 $LN93@operator@5
  00056	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00059	88 55 eb	 mov	 BYTE PTR __t$[ebp+3], dl
  0005c	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005f	84 d2		 test	 dl, dl
  00061	0f 84 f0 00 00
	00		 je	 $LN92@operator@5
  00067	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0006a	88 55 ec	 mov	 BYTE PTR __t$[ebp+4], dl
  0006d	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00070	84 d2		 test	 dl, dl
  00072	0f 84 da 00 00
	00		 je	 $LN91@operator@5
  00078	32 d1		 xor	 dl, cl
  0007a	88 55 ed	 mov	 BYTE PTR __t$[ebp+5], dl
  0007d	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00080	84 d2		 test	 dl, dl
  00082	0f 84 c4 00 00
	00		 je	 $LN90@operator@5
  00088	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0008b	88 55 ee	 mov	 BYTE PTR __t$[ebp+6], dl
  0008e	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00091	84 d2		 test	 dl, dl
  00093	0f 84 ad 00 00
	00		 je	 $LN89@operator@5
  00099	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009c	88 55 ef	 mov	 BYTE PTR __t$[ebp+7], dl
  0009f	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a2	84 d2		 test	 dl, dl
  000a4	0f 84 96 00 00
	00		 je	 $LN88@operator@5
  000aa	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ad	88 55 f0	 mov	 BYTE PTR __t$[ebp+8], dl
  000b0	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b3	84 d2		 test	 dl, dl
  000b5	0f 84 80 00 00
	00		 je	 $LN87@operator@5
  000bb	32 d1		 xor	 dl, cl
  000bd	88 55 f1	 mov	 BYTE PTR __t$[ebp+9], dl
  000c0	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c3	84 d2		 test	 dl, dl
  000c5	74 6e		 je	 SHORT $LN86@operator@5
  000c7	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000ca	88 55 f2	 mov	 BYTE PTR __t$[ebp+10], dl
  000cd	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000d0	84 d2		 test	 dl, dl
  000d2	74 5b		 je	 SHORT $LN85@operator@5
  000d4	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000d7	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  000db	88 55 f3	 mov	 BYTE PTR __t$[ebp+11], dl
  000de	0f 84 8f 00 00
	00		 je	 $LN1@operator@5
  000e4	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000e7	84 d2		 test	 dl, dl
  000e9	74 3f		 je	 SHORT $LN83@operator@5
  000eb	32 d1		 xor	 dl, cl
  000ed	88 55 f5	 mov	 BYTE PTR __t$[ebp+13], dl
  000f0	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  000f3	84 d2		 test	 dl, dl
  000f5	74 2d		 je	 SHORT $LN82@operator@5
  000f7	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000fa	88 55 f6	 mov	 BYTE PTR __t$[ebp+14], dl
  000fd	8a 50 0f	 mov	 dl, BYTE PTR [eax+15]
  00100	84 d2		 test	 dl, dl
  00102	74 1a		 je	 SHORT $LN81@operator@5
  00104	8a 40 10	 mov	 al, BYTE PTR [eax+16]
  00107	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0010a	88 55 f7	 mov	 BYTE PTR __t$[ebp+15], dl
  0010d	84 c0		 test	 al, al
  0010f	74 07		 je	 SHORT $LN80@operator@5
  00111	34 ed		 xor	 al, -19			; ffffffedH
  00113	88 45 f8	 mov	 BYTE PTR __t$[ebp+16], al
  00116	eb 5b		 jmp	 SHORT $LN1@operator@5
$LN80@operator@5:
  00118	c6 45 f8 ed	 mov	 BYTE PTR __t$[ebp+16], -19 ; ffffffedH
  0011c	eb 55		 jmp	 SHORT $LN1@operator@5
$LN81@operator@5:
  0011e	c6 45 f7 ea	 mov	 BYTE PTR __t$[ebp+15], -22 ; ffffffeaH
  00122	eb 4f		 jmp	 SHORT $LN1@operator@5
$LN82@operator@5:
  00124	c6 45 f6 eb	 mov	 BYTE PTR __t$[ebp+14], -21 ; ffffffebH
  00128	eb 49		 jmp	 SHORT $LN1@operator@5
$LN83@operator@5:
  0012a	88 4d f5	 mov	 BYTE PTR __t$[ebp+13], cl
  0012d	eb 44		 jmp	 SHORT $LN1@operator@5
$LN85@operator@5:
  0012f	c6 45 f3 ea	 mov	 BYTE PTR __t$[ebp+11], -22 ; ffffffeaH
  00133	eb 3e		 jmp	 SHORT $LN1@operator@5
$LN86@operator@5:
  00135	c6 45 f2 eb	 mov	 BYTE PTR __t$[ebp+10], -21 ; ffffffebH
  00139	eb 38		 jmp	 SHORT $LN1@operator@5
$LN87@operator@5:
  0013b	88 4d f1	 mov	 BYTE PTR __t$[ebp+9], cl
  0013e	eb 33		 jmp	 SHORT $LN1@operator@5
$LN88@operator@5:
  00140	c6 45 f0 ed	 mov	 BYTE PTR __t$[ebp+8], -19 ; ffffffedH
  00144	eb 2d		 jmp	 SHORT $LN1@operator@5
$LN89@operator@5:
  00146	c6 45 ef ea	 mov	 BYTE PTR __t$[ebp+7], -22 ; ffffffeaH
  0014a	eb 27		 jmp	 SHORT $LN1@operator@5
$LN90@operator@5:
  0014c	c6 45 ee eb	 mov	 BYTE PTR __t$[ebp+6], -21 ; ffffffebH
  00150	eb 21		 jmp	 SHORT $LN1@operator@5
$LN91@operator@5:
  00152	88 4d ed	 mov	 BYTE PTR __t$[ebp+5], cl
  00155	eb 1c		 jmp	 SHORT $LN1@operator@5
$LN92@operator@5:
  00157	c6 45 ec ed	 mov	 BYTE PTR __t$[ebp+4], -19 ; ffffffedH
  0015b	eb 16		 jmp	 SHORT $LN1@operator@5
$LN93@operator@5:
  0015d	c6 45 eb ea	 mov	 BYTE PTR __t$[ebp+3], -22 ; ffffffeaH
  00161	eb 10		 jmp	 SHORT $LN1@operator@5
$LN94@operator@5:
  00163	c6 45 ea eb	 mov	 BYTE PTR __t$[ebp+2], -21 ; ffffffebH
  00167	eb 0a		 jmp	 SHORT $LN1@operator@5
$LN95@operator@5:
  00169	c6 45 e9 ec	 mov	 BYTE PTR __t$[ebp+1], -20 ; ffffffecH
  0016d	eb 04		 jmp	 SHORT $LN1@operator@5
$LN96@operator@5:
  0016f	c6 45 e8 ed	 mov	 BYTE PTR __t$[ebp], -19	; ffffffedH
$LN1@operator@5:
  00173	6a 03		 push	 3
  00175	8d 45 e8	 lea	 eax, DWORD PTR __t$[ebp]
  00178	c6 45 f4 00	 mov	 BYTE PTR __t$[ebp+12], 0
  0017c	5a		 pop	 edx
$LL104@operator@5:
  0017d	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00183	83 c0 04	 add	 eax, 4
  00186	4a		 dec	 edx
  00187	75 f4		 jne	 SHORT $LL104@operator@5
  00189	8b cf		 mov	 ecx, edi
  0018b	8d 75 e8	 lea	 esi, DWORD PTR __t$[ebp]
  0018e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL111@operator@5:
  00194	8a 08		 mov	 cl, BYTE PTR [eax]
  00196	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00198	75 1a		 jne	 SHORT $LN112@operator@5
  0019a	84 c9		 test	 cl, cl
  0019c	74 12		 je	 SHORT $LN113@operator@5
  0019e	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  001a1	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  001a4	75 0e		 jne	 SHORT $LN112@operator@5
  001a6	83 c0 02	 add	 eax, 2
  001a9	83 c6 02	 add	 esi, 2
  001ac	84 c9		 test	 cl, cl
  001ae	75 e4		 jne	 SHORT $LL111@operator@5
$LN113@operator@5:
  001b0	33 c0		 xor	 eax, eax
  001b2	eb 05		 jmp	 SHORT $LN114@operator@5
$LN112@operator@5:
  001b4	1b c0		 sbb	 eax, eax
  001b6	83 d8 ff	 sbb	 eax, -1
$LN114@operator@5:
  001b9	33 c9		 xor	 ecx, ecx
  001bb	85 c0		 test	 eax, eax
  001bd	0f 94 c0	 sete	 al

; 148  : }

  001c0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c3	5f		 pop	 edi
  001c4	33 cd		 xor	 ecx, ebp
  001c6	5e		 pop	 esi
  001c7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001cc	c9		 leave
  001cd	c3		 ret	 0
??$?8$0N@@@YA_NABVioHashString@@AAY0N@$$CBD@Z ENDP	; operator==<13>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$?8$08@@YA_NABVioHashString@@AAY08$$CBD@Z	; operator==<9>
; Function compile flags: /Ogsp
;	COMDAT ??$?8$08@@YA_NABVioHashString@@AAY08$$CBD@Z
_TEXT	SEGMENT
__t$ = -20						; size = 9
__$ArrayPad$ = -4					; size = 4
_lhs$ = 8						; size = 4
_t$ = 12						; size = 4
??$?8$08@@YA_NABVioHashString@@AAY08$$CBD@Z PROC	; operator==<9>, COMDAT

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]

; 147  : 	_ENCSTR(t, _t); return ( strcmp( lhs.c_str(), _t ) == 0 );

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _lhs$[ebp]
  00018	84 d2		 test	 dl, dl
  0001a	0f 84 ee 00 00
	00		 je	 $LN96@operator@6
  00020	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00023	88 55 ec	 mov	 BYTE PTR __t$[ebp], dl
  00026	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00029	84 d2		 test	 dl, dl
  0002b	0f 84 d7 00 00
	00		 je	 $LN95@operator@6
  00031	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00034	88 55 ed	 mov	 BYTE PTR __t$[ebp+1], dl
  00037	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003a	84 d2		 test	 dl, dl
  0003c	0f 84 c0 00 00
	00		 je	 $LN94@operator@6
  00042	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00045	88 55 ee	 mov	 BYTE PTR __t$[ebp+2], dl
  00048	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004b	84 d2		 test	 dl, dl
  0004d	0f 84 a9 00 00
	00		 je	 $LN93@operator@6
  00053	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00056	88 55 ef	 mov	 BYTE PTR __t$[ebp+3], dl
  00059	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005c	84 d2		 test	 dl, dl
  0005e	0f 84 92 00 00
	00		 je	 $LN92@operator@6
  00064	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00067	88 55 f0	 mov	 BYTE PTR __t$[ebp+4], dl
  0006a	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006d	84 d2		 test	 dl, dl
  0006f	74 7f		 je	 SHORT $LN91@operator@6
  00071	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00074	88 55 f1	 mov	 BYTE PTR __t$[ebp+5], dl
  00077	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0007a	84 d2		 test	 dl, dl
  0007c	74 6c		 je	 SHORT $LN90@operator@6
  0007e	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00081	88 55 f2	 mov	 BYTE PTR __t$[ebp+6], dl
  00084	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00087	84 d2		 test	 dl, dl
  00089	74 59		 je	 SHORT $LN89@operator@6
  0008b	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0008e	80 78 08 00	 cmp	 BYTE PTR [eax+8], 0
  00092	88 55 f3	 mov	 BYTE PTR __t$[ebp+7], dl
  00095	74 7b		 je	 SHORT $LN1@operator@6
  00097	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  0009a	84 d2		 test	 dl, dl
  0009c	74 40		 je	 SHORT $LN87@operator@6
  0009e	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000a1	88 55 f5	 mov	 BYTE PTR __t$[ebp+9], dl
  000a4	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000a7	84 d2		 test	 dl, dl
  000a9	74 2d		 je	 SHORT $LN86@operator@6
  000ab	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000ae	88 55 f6	 mov	 BYTE PTR __t$[ebp+10], dl
  000b1	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000b4	84 d2		 test	 dl, dl
  000b6	74 1a		 je	 SHORT $LN85@operator@6
  000b8	8a 40 0c	 mov	 al, BYTE PTR [eax+12]
  000bb	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000be	88 55 f7	 mov	 BYTE PTR __t$[ebp+11], dl
  000c1	84 c0		 test	 al, al
  000c3	74 07		 je	 SHORT $LN84@operator@6
  000c5	34 ed		 xor	 al, -19			; ffffffedH
  000c7	88 45 f8	 mov	 BYTE PTR __t$[ebp+12], al
  000ca	eb 46		 jmp	 SHORT $LN1@operator@6
$LN84@operator@6:
  000cc	c6 45 f8 ed	 mov	 BYTE PTR __t$[ebp+12], -19 ; ffffffedH
  000d0	eb 40		 jmp	 SHORT $LN1@operator@6
$LN85@operator@6:
  000d2	c6 45 f7 ea	 mov	 BYTE PTR __t$[ebp+11], -22 ; ffffffeaH
  000d6	eb 3a		 jmp	 SHORT $LN1@operator@6
$LN86@operator@6:
  000d8	c6 45 f6 eb	 mov	 BYTE PTR __t$[ebp+10], -21 ; ffffffebH
  000dc	eb 34		 jmp	 SHORT $LN1@operator@6
$LN87@operator@6:
  000de	c6 45 f5 ec	 mov	 BYTE PTR __t$[ebp+9], -20 ; ffffffecH
  000e2	eb 2e		 jmp	 SHORT $LN1@operator@6
$LN89@operator@6:
  000e4	c6 45 f3 ea	 mov	 BYTE PTR __t$[ebp+7], -22 ; ffffffeaH
  000e8	eb 28		 jmp	 SHORT $LN1@operator@6
$LN90@operator@6:
  000ea	c6 45 f2 eb	 mov	 BYTE PTR __t$[ebp+6], -21 ; ffffffebH
  000ee	eb 22		 jmp	 SHORT $LN1@operator@6
$LN91@operator@6:
  000f0	c6 45 f1 ec	 mov	 BYTE PTR __t$[ebp+5], -20 ; ffffffecH
  000f4	eb 1c		 jmp	 SHORT $LN1@operator@6
$LN92@operator@6:
  000f6	c6 45 f0 ed	 mov	 BYTE PTR __t$[ebp+4], -19 ; ffffffedH
  000fa	eb 16		 jmp	 SHORT $LN1@operator@6
$LN93@operator@6:
  000fc	c6 45 ef ea	 mov	 BYTE PTR __t$[ebp+3], -22 ; ffffffeaH
  00100	eb 10		 jmp	 SHORT $LN1@operator@6
$LN94@operator@6:
  00102	c6 45 ee eb	 mov	 BYTE PTR __t$[ebp+2], -21 ; ffffffebH
  00106	eb 0a		 jmp	 SHORT $LN1@operator@6
$LN95@operator@6:
  00108	c6 45 ed ec	 mov	 BYTE PTR __t$[ebp+1], -20 ; ffffffecH
  0010c	eb 04		 jmp	 SHORT $LN1@operator@6
$LN96@operator@6:
  0010e	c6 45 ec ed	 mov	 BYTE PTR __t$[ebp], -19	; ffffffedH
$LN1@operator@6:
  00112	6a 02		 push	 2
  00114	8d 45 ec	 lea	 eax, DWORD PTR __t$[ebp]
  00117	c6 45 f4 00	 mov	 BYTE PTR __t$[ebp+8], 0
  0011b	5a		 pop	 edx
$LL104@operator@6:
  0011c	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00122	83 c0 04	 add	 eax, 4
  00125	4a		 dec	 edx
  00126	75 f4		 jne	 SHORT $LL104@operator@6
  00128	56		 push	 esi
  00129	8d 75 ec	 lea	 esi, DWORD PTR __t$[ebp]
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL111@operator@6:
  00132	8a 08		 mov	 cl, BYTE PTR [eax]
  00134	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00136	75 1a		 jne	 SHORT $LN112@operator@6
  00138	84 c9		 test	 cl, cl
  0013a	74 12		 je	 SHORT $LN113@operator@6
  0013c	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  0013f	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  00142	75 0e		 jne	 SHORT $LN112@operator@6
  00144	83 c0 02	 add	 eax, 2
  00147	83 c6 02	 add	 esi, 2
  0014a	84 c9		 test	 cl, cl
  0014c	75 e4		 jne	 SHORT $LL111@operator@6
$LN113@operator@6:
  0014e	33 c0		 xor	 eax, eax
  00150	eb 05		 jmp	 SHORT $LN114@operator@6
$LN112@operator@6:
  00152	1b c0		 sbb	 eax, eax
  00154	83 d8 ff	 sbb	 eax, -1
$LN114@operator@6:
  00157	33 c9		 xor	 ecx, ecx
  00159	85 c0		 test	 eax, eax
  0015b	0f 94 c0	 sete	 al

; 148  : }

  0015e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00161	33 cd		 xor	 ecx, ebp
  00163	5e		 pop	 esi
  00164	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00169	c9		 leave
  0016a	c3		 ret	 0
??$?8$08@@YA_NABVioHashString@@AAY08$$CBD@Z ENDP	; operator==<9>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$?8$07@@YA_NABVioHashString@@AAY07$$CBD@Z	; operator==<8>
; Function compile flags: /Ogsp
;	COMDAT ??$?8$07@@YA_NABVioHashString@@AAY07$$CBD@Z
_TEXT	SEGMENT
__t$ = -16						; size = 8
__$ArrayPad$ = -4					; size = 4
_lhs$ = 8						; size = 4
_t$ = 12						; size = 4
??$?8$07@@YA_NABVioHashString@@AAY07$$CBD@Z PROC	; operator==<8>, COMDAT

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]

; 147  : 	_ENCSTR(t, _t); return ( strcmp( lhs.c_str(), _t ) == 0 );

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	8b 7d 08	 mov	 edi, DWORD PTR _lhs$[ebp]
  0001a	84 d2		 test	 dl, dl
  0001c	0f 84 d7 00 00
	00		 je	 $LN96@operator@7
  00022	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00025	88 55 f0	 mov	 BYTE PTR __t$[ebp], dl
  00028	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002b	84 d2		 test	 dl, dl
  0002d	0f 84 c0 00 00
	00		 je	 $LN95@operator@7
  00033	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00036	88 55 f1	 mov	 BYTE PTR __t$[ebp+1], dl
  00039	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003c	84 d2		 test	 dl, dl
  0003e	0f 84 a9 00 00
	00		 je	 $LN94@operator@7
  00044	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00047	88 55 f2	 mov	 BYTE PTR __t$[ebp+2], dl
  0004a	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004d	84 d2		 test	 dl, dl
  0004f	0f 84 92 00 00
	00		 je	 $LN93@operator@7
  00055	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00058	88 55 f3	 mov	 BYTE PTR __t$[ebp+3], dl
  0005b	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005e	84 d2		 test	 dl, dl
  00060	74 7f		 je	 SHORT $LN92@operator@7
  00062	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00065	88 55 f4	 mov	 BYTE PTR __t$[ebp+4], dl
  00068	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006b	84 d2		 test	 dl, dl
  0006d	74 6c		 je	 SHORT $LN91@operator@7
  0006f	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00072	88 55 f5	 mov	 BYTE PTR __t$[ebp+5], dl
  00075	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00078	84 d2		 test	 dl, dl
  0007a	74 59		 je	 SHORT $LN90@operator@7
  0007c	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0007f	80 78 07 00	 cmp	 BYTE PTR [eax+7], 0
  00083	88 55 f6	 mov	 BYTE PTR __t$[ebp+6], dl
  00086	74 75		 je	 SHORT $LN1@operator@7
  00088	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  0008b	84 d2		 test	 dl, dl
  0008d	74 40		 je	 SHORT $LN88@operator@7
  0008f	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00092	88 55 f8	 mov	 BYTE PTR __t$[ebp+8], dl
  00095	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  00098	84 d2		 test	 dl, dl
  0009a	74 2d		 je	 SHORT $LN87@operator@7
  0009c	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0009f	88 55 f9	 mov	 BYTE PTR __t$[ebp+9], dl
  000a2	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000a5	84 d2		 test	 dl, dl
  000a7	74 1a		 je	 SHORT $LN86@operator@7
  000a9	8a 40 0b	 mov	 al, BYTE PTR [eax+11]
  000ac	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000af	88 55 fa	 mov	 BYTE PTR __t$[ebp+10], dl
  000b2	84 c0		 test	 al, al
  000b4	74 07		 je	 SHORT $LN85@operator@7
  000b6	34 ea		 xor	 al, -22			; ffffffeaH
  000b8	88 45 fb	 mov	 BYTE PTR __t$[ebp+11], al
  000bb	eb 40		 jmp	 SHORT $LN1@operator@7
$LN85@operator@7:
  000bd	c6 45 fb ea	 mov	 BYTE PTR __t$[ebp+11], -22 ; ffffffeaH
  000c1	eb 3a		 jmp	 SHORT $LN1@operator@7
$LN86@operator@7:
  000c3	c6 45 fa eb	 mov	 BYTE PTR __t$[ebp+10], -21 ; ffffffebH
  000c7	eb 34		 jmp	 SHORT $LN1@operator@7
$LN87@operator@7:
  000c9	c6 45 f9 ec	 mov	 BYTE PTR __t$[ebp+9], -20 ; ffffffecH
  000cd	eb 2e		 jmp	 SHORT $LN1@operator@7
$LN88@operator@7:
  000cf	c6 45 f8 ed	 mov	 BYTE PTR __t$[ebp+8], -19 ; ffffffedH
  000d3	eb 28		 jmp	 SHORT $LN1@operator@7
$LN90@operator@7:
  000d5	c6 45 f6 eb	 mov	 BYTE PTR __t$[ebp+6], -21 ; ffffffebH
  000d9	eb 22		 jmp	 SHORT $LN1@operator@7
$LN91@operator@7:
  000db	c6 45 f5 ec	 mov	 BYTE PTR __t$[ebp+5], -20 ; ffffffecH
  000df	eb 1c		 jmp	 SHORT $LN1@operator@7
$LN92@operator@7:
  000e1	c6 45 f4 ed	 mov	 BYTE PTR __t$[ebp+4], -19 ; ffffffedH
  000e5	eb 16		 jmp	 SHORT $LN1@operator@7
$LN93@operator@7:
  000e7	c6 45 f3 ea	 mov	 BYTE PTR __t$[ebp+3], -22 ; ffffffeaH
  000eb	eb 10		 jmp	 SHORT $LN1@operator@7
$LN94@operator@7:
  000ed	c6 45 f2 eb	 mov	 BYTE PTR __t$[ebp+2], -21 ; ffffffebH
  000f1	eb 0a		 jmp	 SHORT $LN1@operator@7
$LN95@operator@7:
  000f3	c6 45 f1 ec	 mov	 BYTE PTR __t$[ebp+1], -20 ; ffffffecH
  000f7	eb 04		 jmp	 SHORT $LN1@operator@7
$LN96@operator@7:
  000f9	c6 45 f0 ed	 mov	 BYTE PTR __t$[ebp], -19	; ffffffedH
$LN1@operator@7:
  000fd	81 75 f0 ed ec
	eb ea		 xor	 DWORD PTR __t$[ebp], -353637139 ; eaebecedH
  00104	6a 04		 push	 4
  00106	c6 45 f7 00	 mov	 BYTE PTR __t$[ebp+7], 0
  0010a	58		 pop	 eax
$LL101@operator@7:
  0010b	8b c8		 mov	 ecx, eax
  0010d	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00113	79 05		 jns	 SHORT $LN115@operator@7
  00115	49		 dec	 ecx
  00116	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00119	41		 inc	 ecx
$LN115@operator@7:
  0011a	b2 ed		 mov	 dl, -19			; ffffffedH
  0011c	2a d1		 sub	 dl, cl
  0011e	30 54 05 f0	 xor	 BYTE PTR __t$[ebp+eax], dl
  00122	40		 inc	 eax
  00123	83 f8 07	 cmp	 eax, 7
  00126	7c e3		 jl	 SHORT $LL101@operator@7
  00128	8b cf		 mov	 ecx, edi
  0012a	8d 75 f0	 lea	 esi, DWORD PTR __t$[ebp]
  0012d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL111@operator@7:
  00133	8a 08		 mov	 cl, BYTE PTR [eax]
  00135	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00137	75 1a		 jne	 SHORT $LN112@operator@7
  00139	84 c9		 test	 cl, cl
  0013b	74 12		 je	 SHORT $LN113@operator@7
  0013d	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00140	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  00143	75 0e		 jne	 SHORT $LN112@operator@7
  00145	83 c0 02	 add	 eax, 2
  00148	83 c6 02	 add	 esi, 2
  0014b	84 c9		 test	 cl, cl
  0014d	75 e4		 jne	 SHORT $LL111@operator@7
$LN113@operator@7:
  0014f	33 c0		 xor	 eax, eax
  00151	eb 05		 jmp	 SHORT $LN114@operator@7
$LN112@operator@7:
  00153	1b c0		 sbb	 eax, eax
  00155	83 d8 ff	 sbb	 eax, -1
$LN114@operator@7:
  00158	33 c9		 xor	 ecx, ecx
  0015a	85 c0		 test	 eax, eax
  0015c	0f 94 c0	 sete	 al

; 148  : }

  0015f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00162	5f		 pop	 edi
  00163	33 cd		 xor	 ecx, ebp
  00165	5e		 pop	 esi
  00166	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016b	c9		 leave
  0016c	c3		 ret	 0
??$?8$07@@YA_NABVioHashString@@AAY07$$CBD@Z ENDP	; operator==<8>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$?8$0L@@@YA_NABVioHashString@@AAY0L@$$CBD@Z	; operator==<11>
; Function compile flags: /Ogsp
;	COMDAT ??$?8$0L@@@YA_NABVioHashString@@AAY0L@$$CBD@Z
_TEXT	SEGMENT
__t$ = -20						; size = 11
__$ArrayPad$ = -4					; size = 4
_lhs$ = 8						; size = 4
_t$ = 12						; size = 4
??$?8$0L@@@YA_NABVioHashString@@AAY0L@$$CBD@Z PROC	; operator==<11>, COMDAT

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]

; 147  : 	_ENCSTR(t, _t); return ( strcmp( lhs.c_str(), _t ) == 0 );

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	8b 7d 08	 mov	 edi, DWORD PTR _lhs$[ebp]
  0001a	84 d2		 test	 dl, dl
  0001c	0f 84 24 01 00
	00		 je	 $LN96@operator@8
  00022	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00025	88 55 ec	 mov	 BYTE PTR __t$[ebp], dl
  00028	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002b	84 d2		 test	 dl, dl
  0002d	0f 84 0d 01 00
	00		 je	 $LN95@operator@8
  00033	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00036	88 55 ed	 mov	 BYTE PTR __t$[ebp+1], dl
  00039	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003c	84 d2		 test	 dl, dl
  0003e	0f 84 f6 00 00
	00		 je	 $LN94@operator@8
  00044	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00047	88 55 ee	 mov	 BYTE PTR __t$[ebp+2], dl
  0004a	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004d	84 d2		 test	 dl, dl
  0004f	0f 84 df 00 00
	00		 je	 $LN93@operator@8
  00055	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00058	88 55 ef	 mov	 BYTE PTR __t$[ebp+3], dl
  0005b	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005e	84 d2		 test	 dl, dl
  00060	0f 84 c8 00 00
	00		 je	 $LN92@operator@8
  00066	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00069	88 55 f0	 mov	 BYTE PTR __t$[ebp+4], dl
  0006c	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006f	84 d2		 test	 dl, dl
  00071	0f 84 b1 00 00
	00		 je	 $LN91@operator@8
  00077	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0007a	88 55 f1	 mov	 BYTE PTR __t$[ebp+5], dl
  0007d	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00080	84 d2		 test	 dl, dl
  00082	0f 84 9a 00 00
	00		 je	 $LN90@operator@8
  00088	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0008b	88 55 f2	 mov	 BYTE PTR __t$[ebp+6], dl
  0008e	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00091	84 d2		 test	 dl, dl
  00093	0f 84 83 00 00
	00		 je	 $LN89@operator@8
  00099	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009c	88 55 f3	 mov	 BYTE PTR __t$[ebp+7], dl
  0009f	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a2	84 d2		 test	 dl, dl
  000a4	74 70		 je	 SHORT $LN88@operator@8
  000a6	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000a9	88 55 f4	 mov	 BYTE PTR __t$[ebp+8], dl
  000ac	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000af	84 d2		 test	 dl, dl
  000b1	74 5d		 je	 SHORT $LN87@operator@8
  000b3	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000b6	80 78 0a 00	 cmp	 BYTE PTR [eax+10], 0
  000ba	88 55 f5	 mov	 BYTE PTR __t$[ebp+9], dl
  000bd	0f 84 87 00 00
	00		 je	 $LN1@operator@8
  000c3	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000c6	84 d2		 test	 dl, dl
  000c8	74 40		 je	 SHORT $LN85@operator@8
  000ca	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000cd	88 55 f7	 mov	 BYTE PTR __t$[ebp+11], dl
  000d0	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000d3	84 d2		 test	 dl, dl
  000d5	74 2d		 je	 SHORT $LN84@operator@8
  000d7	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000da	88 55 f8	 mov	 BYTE PTR __t$[ebp+12], dl
  000dd	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000e0	84 d2		 test	 dl, dl
  000e2	74 1a		 je	 SHORT $LN83@operator@8
  000e4	8a 40 0e	 mov	 al, BYTE PTR [eax+14]
  000e7	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000ea	88 55 f9	 mov	 BYTE PTR __t$[ebp+13], dl
  000ed	84 c0		 test	 al, al
  000ef	74 07		 je	 SHORT $LN82@operator@8
  000f1	34 eb		 xor	 al, -21			; ffffffebH
  000f3	88 45 fa	 mov	 BYTE PTR __t$[ebp+14], al
  000f6	eb 52		 jmp	 SHORT $LN1@operator@8
$LN82@operator@8:
  000f8	c6 45 fa eb	 mov	 BYTE PTR __t$[ebp+14], -21 ; ffffffebH
  000fc	eb 4c		 jmp	 SHORT $LN1@operator@8
$LN83@operator@8:
  000fe	c6 45 f9 ec	 mov	 BYTE PTR __t$[ebp+13], -20 ; ffffffecH
  00102	eb 46		 jmp	 SHORT $LN1@operator@8
$LN84@operator@8:
  00104	c6 45 f8 ed	 mov	 BYTE PTR __t$[ebp+12], -19 ; ffffffedH
  00108	eb 40		 jmp	 SHORT $LN1@operator@8
$LN85@operator@8:
  0010a	c6 45 f7 ea	 mov	 BYTE PTR __t$[ebp+11], -22 ; ffffffeaH
  0010e	eb 3a		 jmp	 SHORT $LN1@operator@8
$LN87@operator@8:
  00110	c6 45 f5 ec	 mov	 BYTE PTR __t$[ebp+9], -20 ; ffffffecH
  00114	eb 34		 jmp	 SHORT $LN1@operator@8
$LN88@operator@8:
  00116	c6 45 f4 ed	 mov	 BYTE PTR __t$[ebp+8], -19 ; ffffffedH
  0011a	eb 2e		 jmp	 SHORT $LN1@operator@8
$LN89@operator@8:
  0011c	c6 45 f3 ea	 mov	 BYTE PTR __t$[ebp+7], -22 ; ffffffeaH
  00120	eb 28		 jmp	 SHORT $LN1@operator@8
$LN90@operator@8:
  00122	c6 45 f2 eb	 mov	 BYTE PTR __t$[ebp+6], -21 ; ffffffebH
  00126	eb 22		 jmp	 SHORT $LN1@operator@8
$LN91@operator@8:
  00128	c6 45 f1 ec	 mov	 BYTE PTR __t$[ebp+5], -20 ; ffffffecH
  0012c	eb 1c		 jmp	 SHORT $LN1@operator@8
$LN92@operator@8:
  0012e	c6 45 f0 ed	 mov	 BYTE PTR __t$[ebp+4], -19 ; ffffffedH
  00132	eb 16		 jmp	 SHORT $LN1@operator@8
$LN93@operator@8:
  00134	c6 45 ef ea	 mov	 BYTE PTR __t$[ebp+3], -22 ; ffffffeaH
  00138	eb 10		 jmp	 SHORT $LN1@operator@8
$LN94@operator@8:
  0013a	c6 45 ee eb	 mov	 BYTE PTR __t$[ebp+2], -21 ; ffffffebH
  0013e	eb 0a		 jmp	 SHORT $LN1@operator@8
$LN95@operator@8:
  00140	c6 45 ed ec	 mov	 BYTE PTR __t$[ebp+1], -20 ; ffffffecH
  00144	eb 04		 jmp	 SHORT $LN1@operator@8
$LN96@operator@8:
  00146	c6 45 ec ed	 mov	 BYTE PTR __t$[ebp], -19	; ffffffedH
$LN1@operator@8:
  0014a	6a 02		 push	 2
  0014c	8d 45 ec	 lea	 eax, DWORD PTR __t$[ebp]
  0014f	c6 45 f6 00	 mov	 BYTE PTR __t$[ebp+10], 0
  00153	5a		 pop	 edx
$LL104@operator@8:
  00154	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0015a	83 c0 04	 add	 eax, 4
  0015d	4a		 dec	 edx
  0015e	75 f4		 jne	 SHORT $LL104@operator@8
  00160	6a 08		 push	 8
  00162	58		 pop	 eax
$LL101@operator@8:
  00163	8b c8		 mov	 ecx, eax
  00165	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0016b	79 05		 jns	 SHORT $LN115@operator@8
  0016d	49		 dec	 ecx
  0016e	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00171	41		 inc	 ecx
$LN115@operator@8:
  00172	b2 ed		 mov	 dl, -19			; ffffffedH
  00174	2a d1		 sub	 dl, cl
  00176	30 54 05 ec	 xor	 BYTE PTR __t$[ebp+eax], dl
  0017a	40		 inc	 eax
  0017b	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0017e	7c e3		 jl	 SHORT $LL101@operator@8
  00180	8b cf		 mov	 ecx, edi
  00182	8d 75 ec	 lea	 esi, DWORD PTR __t$[ebp]
  00185	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL111@operator@8:
  0018b	8a 08		 mov	 cl, BYTE PTR [eax]
  0018d	3a 0e		 cmp	 cl, BYTE PTR [esi]
  0018f	75 1a		 jne	 SHORT $LN112@operator@8
  00191	84 c9		 test	 cl, cl
  00193	74 12		 je	 SHORT $LN113@operator@8
  00195	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00198	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  0019b	75 0e		 jne	 SHORT $LN112@operator@8
  0019d	83 c0 02	 add	 eax, 2
  001a0	83 c6 02	 add	 esi, 2
  001a3	84 c9		 test	 cl, cl
  001a5	75 e4		 jne	 SHORT $LL111@operator@8
$LN113@operator@8:
  001a7	33 c0		 xor	 eax, eax
  001a9	eb 05		 jmp	 SHORT $LN114@operator@8
$LN112@operator@8:
  001ab	1b c0		 sbb	 eax, eax
  001ad	83 d8 ff	 sbb	 eax, -1
$LN114@operator@8:
  001b0	33 c9		 xor	 ecx, ecx
  001b2	85 c0		 test	 eax, eax
  001b4	0f 94 c0	 sete	 al

; 148  : }

  001b7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ba	5f		 pop	 edi
  001bb	33 cd		 xor	 ecx, ebp
  001bd	5e		 pop	 esi
  001be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c3	c9		 leave
  001c4	c3		 ret	 0
??$?8$0L@@@YA_NABVioHashString@@AAY0L@$$CBD@Z ENDP	; operator==<11>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$?8$0P@@@YA_NABVioHashString@@AAY0P@$$CBD@Z	; operator==<15>
; Function compile flags: /Ogsp
;	COMDAT ??$?8$0P@@@YA_NABVioHashString@@AAY0P@$$CBD@Z
_TEXT	SEGMENT
__t$ = -24						; size = 15
__$ArrayPad$ = -4					; size = 4
_lhs$ = 8						; size = 4
_t$ = 12						; size = 4
??$?8$0P@@@YA_NABVioHashString@@AAY0P@$$CBD@Z PROC	; operator==<15>, COMDAT

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]

; 147  : 	_ENCSTR(t, _t); return ( strcmp( lhs.c_str(), _t ) == 0 );

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	8b 7d 08	 mov	 edi, DWORD PTR _lhs$[ebp]
  0001a	84 d2		 test	 dl, dl
  0001c	0f 84 75 01 00
	00		 je	 $LN96@operator@9
  00022	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00025	88 55 e8	 mov	 BYTE PTR __t$[ebp], dl
  00028	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002b	84 d2		 test	 dl, dl
  0002d	0f 84 5e 01 00
	00		 je	 $LN95@operator@9
  00033	b1 ec		 mov	 cl, -20			; ffffffecH
  00035	32 d1		 xor	 dl, cl
  00037	88 55 e9	 mov	 BYTE PTR __t$[ebp+1], dl
  0003a	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003d	84 d2		 test	 dl, dl
  0003f	0f 84 46 01 00
	00		 je	 $LN94@operator@9
  00045	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00048	88 55 ea	 mov	 BYTE PTR __t$[ebp+2], dl
  0004b	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004e	84 d2		 test	 dl, dl
  00050	0f 84 2f 01 00
	00		 je	 $LN93@operator@9
  00056	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00059	88 55 eb	 mov	 BYTE PTR __t$[ebp+3], dl
  0005c	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005f	84 d2		 test	 dl, dl
  00061	0f 84 18 01 00
	00		 je	 $LN92@operator@9
  00067	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0006a	88 55 ec	 mov	 BYTE PTR __t$[ebp+4], dl
  0006d	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00070	84 d2		 test	 dl, dl
  00072	0f 84 02 01 00
	00		 je	 $LN91@operator@9
  00078	32 d1		 xor	 dl, cl
  0007a	88 55 ed	 mov	 BYTE PTR __t$[ebp+5], dl
  0007d	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00080	84 d2		 test	 dl, dl
  00082	0f 84 ec 00 00
	00		 je	 $LN90@operator@9
  00088	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0008b	88 55 ee	 mov	 BYTE PTR __t$[ebp+6], dl
  0008e	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00091	84 d2		 test	 dl, dl
  00093	0f 84 d5 00 00
	00		 je	 $LN89@operator@9
  00099	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009c	88 55 ef	 mov	 BYTE PTR __t$[ebp+7], dl
  0009f	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a2	84 d2		 test	 dl, dl
  000a4	0f 84 be 00 00
	00		 je	 $LN88@operator@9
  000aa	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ad	88 55 f0	 mov	 BYTE PTR __t$[ebp+8], dl
  000b0	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b3	84 d2		 test	 dl, dl
  000b5	0f 84 a8 00 00
	00		 je	 $LN87@operator@9
  000bb	32 d1		 xor	 dl, cl
  000bd	88 55 f1	 mov	 BYTE PTR __t$[ebp+9], dl
  000c0	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c3	84 d2		 test	 dl, dl
  000c5	0f 84 92 00 00
	00		 je	 $LN86@operator@9
  000cb	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000ce	88 55 f2	 mov	 BYTE PTR __t$[ebp+10], dl
  000d1	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000d4	84 d2		 test	 dl, dl
  000d6	74 7f		 je	 SHORT $LN85@operator@9
  000d8	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000db	88 55 f3	 mov	 BYTE PTR __t$[ebp+11], dl
  000de	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000e1	84 d2		 test	 dl, dl
  000e3	74 6c		 je	 SHORT $LN84@operator@9
  000e5	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000e8	88 55 f4	 mov	 BYTE PTR __t$[ebp+12], dl
  000eb	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000ee	84 d2		 test	 dl, dl
  000f0	74 5a		 je	 SHORT $LN83@operator@9
  000f2	32 d1		 xor	 dl, cl
  000f4	80 78 0e 00	 cmp	 BYTE PTR [eax+14], 0
  000f8	88 55 f5	 mov	 BYTE PTR __t$[ebp+13], dl
  000fb	0f 84 9a 00 00
	00		 je	 $LN1@operator@9
  00101	8a 50 0f	 mov	 dl, BYTE PTR [eax+15]
  00104	84 d2		 test	 dl, dl
  00106	74 3e		 je	 SHORT $LN81@operator@9
  00108	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0010b	88 55 f7	 mov	 BYTE PTR __t$[ebp+15], dl
  0010e	8a 50 10	 mov	 dl, BYTE PTR [eax+16]
  00111	84 d2		 test	 dl, dl
  00113	74 2b		 je	 SHORT $LN80@operator@9
  00115	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00118	88 55 f8	 mov	 BYTE PTR __t$[ebp+16], dl
  0011b	8a 50 11	 mov	 dl, BYTE PTR [eax+17]
  0011e	84 d2		 test	 dl, dl
  00120	74 19		 je	 SHORT $LN79@operator@9
  00122	8a 40 12	 mov	 al, BYTE PTR [eax+18]
  00125	32 d1		 xor	 dl, cl
  00127	88 55 f9	 mov	 BYTE PTR __t$[ebp+17], dl
  0012a	84 c0		 test	 al, al
  0012c	74 07		 je	 SHORT $LN78@operator@9
  0012e	34 eb		 xor	 al, -21			; ffffffebH
  00130	88 45 fa	 mov	 BYTE PTR __t$[ebp+18], al
  00133	eb 66		 jmp	 SHORT $LN1@operator@9
$LN78@operator@9:
  00135	c6 45 fa eb	 mov	 BYTE PTR __t$[ebp+18], -21 ; ffffffebH
  00139	eb 60		 jmp	 SHORT $LN1@operator@9
$LN79@operator@9:
  0013b	88 4d f9	 mov	 BYTE PTR __t$[ebp+17], cl
  0013e	eb 5b		 jmp	 SHORT $LN1@operator@9
$LN80@operator@9:
  00140	c6 45 f8 ed	 mov	 BYTE PTR __t$[ebp+16], -19 ; ffffffedH
  00144	eb 55		 jmp	 SHORT $LN1@operator@9
$LN81@operator@9:
  00146	c6 45 f7 ea	 mov	 BYTE PTR __t$[ebp+15], -22 ; ffffffeaH
  0014a	eb 4f		 jmp	 SHORT $LN1@operator@9
$LN83@operator@9:
  0014c	88 4d f5	 mov	 BYTE PTR __t$[ebp+13], cl
  0014f	eb 4a		 jmp	 SHORT $LN1@operator@9
$LN84@operator@9:
  00151	c6 45 f4 ed	 mov	 BYTE PTR __t$[ebp+12], -19 ; ffffffedH
  00155	eb 44		 jmp	 SHORT $LN1@operator@9
$LN85@operator@9:
  00157	c6 45 f3 ea	 mov	 BYTE PTR __t$[ebp+11], -22 ; ffffffeaH
  0015b	eb 3e		 jmp	 SHORT $LN1@operator@9
$LN86@operator@9:
  0015d	c6 45 f2 eb	 mov	 BYTE PTR __t$[ebp+10], -21 ; ffffffebH
  00161	eb 38		 jmp	 SHORT $LN1@operator@9
$LN87@operator@9:
  00163	88 4d f1	 mov	 BYTE PTR __t$[ebp+9], cl
  00166	eb 33		 jmp	 SHORT $LN1@operator@9
$LN88@operator@9:
  00168	c6 45 f0 ed	 mov	 BYTE PTR __t$[ebp+8], -19 ; ffffffedH
  0016c	eb 2d		 jmp	 SHORT $LN1@operator@9
$LN89@operator@9:
  0016e	c6 45 ef ea	 mov	 BYTE PTR __t$[ebp+7], -22 ; ffffffeaH
  00172	eb 27		 jmp	 SHORT $LN1@operator@9
$LN90@operator@9:
  00174	c6 45 ee eb	 mov	 BYTE PTR __t$[ebp+6], -21 ; ffffffebH
  00178	eb 21		 jmp	 SHORT $LN1@operator@9
$LN91@operator@9:
  0017a	88 4d ed	 mov	 BYTE PTR __t$[ebp+5], cl
  0017d	eb 1c		 jmp	 SHORT $LN1@operator@9
$LN92@operator@9:
  0017f	c6 45 ec ed	 mov	 BYTE PTR __t$[ebp+4], -19 ; ffffffedH
  00183	eb 16		 jmp	 SHORT $LN1@operator@9
$LN93@operator@9:
  00185	c6 45 eb ea	 mov	 BYTE PTR __t$[ebp+3], -22 ; ffffffeaH
  00189	eb 10		 jmp	 SHORT $LN1@operator@9
$LN94@operator@9:
  0018b	c6 45 ea eb	 mov	 BYTE PTR __t$[ebp+2], -21 ; ffffffebH
  0018f	eb 0a		 jmp	 SHORT $LN1@operator@9
$LN95@operator@9:
  00191	c6 45 e9 ec	 mov	 BYTE PTR __t$[ebp+1], -20 ; ffffffecH
  00195	eb 04		 jmp	 SHORT $LN1@operator@9
$LN96@operator@9:
  00197	c6 45 e8 ed	 mov	 BYTE PTR __t$[ebp], -19	; ffffffedH
$LN1@operator@9:
  0019b	6a 03		 push	 3
  0019d	8d 45 e8	 lea	 eax, DWORD PTR __t$[ebp]
  001a0	c6 45 f6 00	 mov	 BYTE PTR __t$[ebp+14], 0
  001a4	5a		 pop	 edx
$LL104@operator@9:
  001a5	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  001ab	83 c0 04	 add	 eax, 4
  001ae	4a		 dec	 edx
  001af	75 f4		 jne	 SHORT $LL104@operator@9
  001b1	6a 0c		 push	 12			; 0000000cH
  001b3	58		 pop	 eax
$LL101@operator@9:
  001b4	8b c8		 mov	 ecx, eax
  001b6	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  001bc	79 05		 jns	 SHORT $LN115@operator@9
  001be	49		 dec	 ecx
  001bf	83 c9 fc	 or	 ecx, -4			; fffffffcH
  001c2	41		 inc	 ecx
$LN115@operator@9:
  001c3	b2 ed		 mov	 dl, -19			; ffffffedH
  001c5	2a d1		 sub	 dl, cl
  001c7	30 54 05 e8	 xor	 BYTE PTR __t$[ebp+eax], dl
  001cb	40		 inc	 eax
  001cc	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  001cf	7c e3		 jl	 SHORT $LL101@operator@9
  001d1	8b cf		 mov	 ecx, edi
  001d3	8d 75 e8	 lea	 esi, DWORD PTR __t$[ebp]
  001d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL111@operator@9:
  001dc	8a 08		 mov	 cl, BYTE PTR [eax]
  001de	3a 0e		 cmp	 cl, BYTE PTR [esi]
  001e0	75 1a		 jne	 SHORT $LN112@operator@9
  001e2	84 c9		 test	 cl, cl
  001e4	74 12		 je	 SHORT $LN113@operator@9
  001e6	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  001e9	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  001ec	75 0e		 jne	 SHORT $LN112@operator@9
  001ee	83 c0 02	 add	 eax, 2
  001f1	83 c6 02	 add	 esi, 2
  001f4	84 c9		 test	 cl, cl
  001f6	75 e4		 jne	 SHORT $LL111@operator@9
$LN113@operator@9:
  001f8	33 c0		 xor	 eax, eax
  001fa	eb 05		 jmp	 SHORT $LN114@operator@9
$LN112@operator@9:
  001fc	1b c0		 sbb	 eax, eax
  001fe	83 d8 ff	 sbb	 eax, -1
$LN114@operator@9:
  00201	33 c9		 xor	 ecx, ecx
  00203	85 c0		 test	 eax, eax
  00205	0f 94 c0	 sete	 al

; 148  : }

  00208	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0020b	5f		 pop	 edi
  0020c	33 cd		 xor	 ecx, ebp
  0020e	5e		 pop	 esi
  0020f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00214	c9		 leave
  00215	c3		 ret	 0
??$?8$0P@@@YA_NABVioHashString@@AAY0P@$$CBD@Z ENDP	; operator==<15>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$?8$0O@@@YA_NABVioHashString@@AAY0O@$$CBD@Z	; operator==<14>
; Function compile flags: /Ogsp
;	COMDAT ??$?8$0O@@@YA_NABVioHashString@@AAY0O@$$CBD@Z
_TEXT	SEGMENT
__t$ = -24						; size = 14
__$ArrayPad$ = -4					; size = 4
_lhs$ = 8						; size = 4
_t$ = 12						; size = 4
??$?8$0O@@@YA_NABVioHashString@@AAY0O@$$CBD@Z PROC	; operator==<14>, COMDAT

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]

; 147  : 	_ENCSTR(t, _t); return ( strcmp( lhs.c_str(), _t ) == 0 );

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	8b 7d 08	 mov	 edi, DWORD PTR _lhs$[ebp]
  0001a	84 d2		 test	 dl, dl
  0001c	0f 84 64 01 00
	00		 je	 $LN96@operator@10
  00022	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00025	88 55 e8	 mov	 BYTE PTR __t$[ebp], dl
  00028	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002b	84 d2		 test	 dl, dl
  0002d	0f 84 4d 01 00
	00		 je	 $LN95@operator@10
  00033	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00036	88 55 e9	 mov	 BYTE PTR __t$[ebp+1], dl
  00039	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003c	84 d2		 test	 dl, dl
  0003e	0f 84 36 01 00
	00		 je	 $LN94@operator@10
  00044	b1 eb		 mov	 cl, -21			; ffffffebH
  00046	32 d1		 xor	 dl, cl
  00048	88 55 ea	 mov	 BYTE PTR __t$[ebp+2], dl
  0004b	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004e	84 d2		 test	 dl, dl
  00050	0f 84 1e 01 00
	00		 je	 $LN93@operator@10
  00056	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00059	88 55 eb	 mov	 BYTE PTR __t$[ebp+3], dl
  0005c	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005f	84 d2		 test	 dl, dl
  00061	0f 84 07 01 00
	00		 je	 $LN92@operator@10
  00067	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0006a	88 55 ec	 mov	 BYTE PTR __t$[ebp+4], dl
  0006d	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00070	84 d2		 test	 dl, dl
  00072	0f 84 f0 00 00
	00		 je	 $LN91@operator@10
  00078	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0007b	88 55 ed	 mov	 BYTE PTR __t$[ebp+5], dl
  0007e	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00081	84 d2		 test	 dl, dl
  00083	0f 84 da 00 00
	00		 je	 $LN90@operator@10
  00089	32 d1		 xor	 dl, cl
  0008b	88 55 ee	 mov	 BYTE PTR __t$[ebp+6], dl
  0008e	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00091	84 d2		 test	 dl, dl
  00093	0f 84 c4 00 00
	00		 je	 $LN89@operator@10
  00099	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009c	88 55 ef	 mov	 BYTE PTR __t$[ebp+7], dl
  0009f	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a2	84 d2		 test	 dl, dl
  000a4	0f 84 ad 00 00
	00		 je	 $LN88@operator@10
  000aa	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ad	88 55 f0	 mov	 BYTE PTR __t$[ebp+8], dl
  000b0	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b3	84 d2		 test	 dl, dl
  000b5	0f 84 96 00 00
	00		 je	 $LN87@operator@10
  000bb	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000be	88 55 f1	 mov	 BYTE PTR __t$[ebp+9], dl
  000c1	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c4	84 d2		 test	 dl, dl
  000c6	0f 84 80 00 00
	00		 je	 $LN86@operator@10
  000cc	32 d1		 xor	 dl, cl
  000ce	88 55 f2	 mov	 BYTE PTR __t$[ebp+10], dl
  000d1	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000d4	84 d2		 test	 dl, dl
  000d6	74 6e		 je	 SHORT $LN85@operator@10
  000d8	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000db	88 55 f3	 mov	 BYTE PTR __t$[ebp+11], dl
  000de	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000e1	84 d2		 test	 dl, dl
  000e3	74 5b		 je	 SHORT $LN84@operator@10
  000e5	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000e8	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000ec	88 55 f4	 mov	 BYTE PTR __t$[ebp+12], dl
  000ef	0f 84 95 00 00
	00		 je	 $LN1@operator@10
  000f5	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  000f8	84 d2		 test	 dl, dl
  000fa	74 3f		 je	 SHORT $LN82@operator@10
  000fc	32 d1		 xor	 dl, cl
  000fe	88 55 f6	 mov	 BYTE PTR __t$[ebp+14], dl
  00101	8a 50 0f	 mov	 dl, BYTE PTR [eax+15]
  00104	84 d2		 test	 dl, dl
  00106	74 2d		 je	 SHORT $LN81@operator@10
  00108	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0010b	88 55 f7	 mov	 BYTE PTR __t$[ebp+15], dl
  0010e	8a 50 10	 mov	 dl, BYTE PTR [eax+16]
  00111	84 d2		 test	 dl, dl
  00113	74 1a		 je	 SHORT $LN80@operator@10
  00115	8a 40 11	 mov	 al, BYTE PTR [eax+17]
  00118	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0011b	88 55 f8	 mov	 BYTE PTR __t$[ebp+16], dl
  0011e	84 c0		 test	 al, al
  00120	74 07		 je	 SHORT $LN79@operator@10
  00122	34 ec		 xor	 al, -20			; ffffffecH
  00124	88 45 f9	 mov	 BYTE PTR __t$[ebp+17], al
  00127	eb 61		 jmp	 SHORT $LN1@operator@10
$LN79@operator@10:
  00129	c6 45 f9 ec	 mov	 BYTE PTR __t$[ebp+17], -20 ; ffffffecH
  0012d	eb 5b		 jmp	 SHORT $LN1@operator@10
$LN80@operator@10:
  0012f	c6 45 f8 ed	 mov	 BYTE PTR __t$[ebp+16], -19 ; ffffffedH
  00133	eb 55		 jmp	 SHORT $LN1@operator@10
$LN81@operator@10:
  00135	c6 45 f7 ea	 mov	 BYTE PTR __t$[ebp+15], -22 ; ffffffeaH
  00139	eb 4f		 jmp	 SHORT $LN1@operator@10
$LN82@operator@10:
  0013b	88 4d f6	 mov	 BYTE PTR __t$[ebp+14], cl
  0013e	eb 4a		 jmp	 SHORT $LN1@operator@10
$LN84@operator@10:
  00140	c6 45 f4 ed	 mov	 BYTE PTR __t$[ebp+12], -19 ; ffffffedH
  00144	eb 44		 jmp	 SHORT $LN1@operator@10
$LN85@operator@10:
  00146	c6 45 f3 ea	 mov	 BYTE PTR __t$[ebp+11], -22 ; ffffffeaH
  0014a	eb 3e		 jmp	 SHORT $LN1@operator@10
$LN86@operator@10:
  0014c	88 4d f2	 mov	 BYTE PTR __t$[ebp+10], cl
  0014f	eb 39		 jmp	 SHORT $LN1@operator@10
$LN87@operator@10:
  00151	c6 45 f1 ec	 mov	 BYTE PTR __t$[ebp+9], -20 ; ffffffecH
  00155	eb 33		 jmp	 SHORT $LN1@operator@10
$LN88@operator@10:
  00157	c6 45 f0 ed	 mov	 BYTE PTR __t$[ebp+8], -19 ; ffffffedH
  0015b	eb 2d		 jmp	 SHORT $LN1@operator@10
$LN89@operator@10:
  0015d	c6 45 ef ea	 mov	 BYTE PTR __t$[ebp+7], -22 ; ffffffeaH
  00161	eb 27		 jmp	 SHORT $LN1@operator@10
$LN90@operator@10:
  00163	88 4d ee	 mov	 BYTE PTR __t$[ebp+6], cl
  00166	eb 22		 jmp	 SHORT $LN1@operator@10
$LN91@operator@10:
  00168	c6 45 ed ec	 mov	 BYTE PTR __t$[ebp+5], -20 ; ffffffecH
  0016c	eb 1c		 jmp	 SHORT $LN1@operator@10
$LN92@operator@10:
  0016e	c6 45 ec ed	 mov	 BYTE PTR __t$[ebp+4], -19 ; ffffffedH
  00172	eb 16		 jmp	 SHORT $LN1@operator@10
$LN93@operator@10:
  00174	c6 45 eb ea	 mov	 BYTE PTR __t$[ebp+3], -22 ; ffffffeaH
  00178	eb 10		 jmp	 SHORT $LN1@operator@10
$LN94@operator@10:
  0017a	c6 45 ea eb	 mov	 BYTE PTR __t$[ebp+2], -21 ; ffffffebH
  0017e	eb 0a		 jmp	 SHORT $LN1@operator@10
$LN95@operator@10:
  00180	c6 45 e9 ec	 mov	 BYTE PTR __t$[ebp+1], -20 ; ffffffecH
  00184	eb 04		 jmp	 SHORT $LN1@operator@10
$LN96@operator@10:
  00186	c6 45 e8 ed	 mov	 BYTE PTR __t$[ebp], -19	; ffffffedH
$LN1@operator@10:
  0018a	6a 03		 push	 3
  0018c	8d 45 e8	 lea	 eax, DWORD PTR __t$[ebp]
  0018f	c6 45 f5 00	 mov	 BYTE PTR __t$[ebp+13], 0
  00193	5a		 pop	 edx
$LL104@operator@10:
  00194	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0019a	83 c0 04	 add	 eax, 4
  0019d	4a		 dec	 edx
  0019e	75 f4		 jne	 SHORT $LL104@operator@10
  001a0	80 75 f4 ed	 xor	 BYTE PTR __t$[ebp+12], -19 ; ffffffedH
  001a4	8b cf		 mov	 ecx, edi
  001a6	8d 75 e8	 lea	 esi, DWORD PTR __t$[ebp]
  001a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL111@operator@10:
  001af	8a 08		 mov	 cl, BYTE PTR [eax]
  001b1	3a 0e		 cmp	 cl, BYTE PTR [esi]
  001b3	75 1a		 jne	 SHORT $LN112@operator@10
  001b5	84 c9		 test	 cl, cl
  001b7	74 12		 je	 SHORT $LN113@operator@10
  001b9	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  001bc	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  001bf	75 0e		 jne	 SHORT $LN112@operator@10
  001c1	83 c0 02	 add	 eax, 2
  001c4	83 c6 02	 add	 esi, 2
  001c7	84 c9		 test	 cl, cl
  001c9	75 e4		 jne	 SHORT $LL111@operator@10
$LN113@operator@10:
  001cb	33 c0		 xor	 eax, eax
  001cd	eb 05		 jmp	 SHORT $LN114@operator@10
$LN112@operator@10:
  001cf	1b c0		 sbb	 eax, eax
  001d1	83 d8 ff	 sbb	 eax, -1
$LN114@operator@10:
  001d4	33 c9		 xor	 ecx, ecx
  001d6	85 c0		 test	 eax, eax
  001d8	0f 94 c0	 sete	 al

; 148  : }

  001db	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001de	5f		 pop	 edi
  001df	33 cd		 xor	 ecx, ebp
  001e1	5e		 pop	 esi
  001e2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e7	c9		 leave
  001e8	c3		 ret	 0
??$?8$0O@@@YA_NABVioHashString@@AAY0O@$$CBD@Z ENDP	; operator==<14>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$?8$0BB@@@YA_NABVioHashString@@AAY0BB@$$CBD@Z	; operator==<17>
; Function compile flags: /Ogsp
;	COMDAT ??$?8$0BB@@@YA_NABVioHashString@@AAY0BB@$$CBD@Z
_TEXT	SEGMENT
__t$ = -28						; size = 17
__$ArrayPad$ = -4					; size = 4
_lhs$ = 8						; size = 4
_t$ = 12						; size = 4
??$?8$0BB@@@YA_NABVioHashString@@AAY0BB@$$CBD@Z PROC	; operator==<17>, COMDAT

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]

; 147  : 	_ENCSTR(t, _t); return ( strcmp( lhs.c_str(), _t ) == 0 );

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	8b 7d 08	 mov	 edi, DWORD PTR _lhs$[ebp]
  0001a	84 d2		 test	 dl, dl
  0001c	0f 84 a7 01 00
	00		 je	 $LN96@operator@11
  00022	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00025	88 55 e4	 mov	 BYTE PTR __t$[ebp], dl
  00028	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002b	84 d2		 test	 dl, dl
  0002d	0f 84 90 01 00
	00		 je	 $LN95@operator@11
  00033	b1 ec		 mov	 cl, -20			; ffffffecH
  00035	32 d1		 xor	 dl, cl
  00037	88 55 e5	 mov	 BYTE PTR __t$[ebp+1], dl
  0003a	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003d	84 d2		 test	 dl, dl
  0003f	0f 84 78 01 00
	00		 je	 $LN94@operator@11
  00045	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00048	88 55 e6	 mov	 BYTE PTR __t$[ebp+2], dl
  0004b	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004e	84 d2		 test	 dl, dl
  00050	0f 84 61 01 00
	00		 je	 $LN93@operator@11
  00056	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00059	88 55 e7	 mov	 BYTE PTR __t$[ebp+3], dl
  0005c	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005f	84 d2		 test	 dl, dl
  00061	0f 84 4a 01 00
	00		 je	 $LN92@operator@11
  00067	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0006a	88 55 e8	 mov	 BYTE PTR __t$[ebp+4], dl
  0006d	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00070	84 d2		 test	 dl, dl
  00072	0f 84 34 01 00
	00		 je	 $LN91@operator@11
  00078	32 d1		 xor	 dl, cl
  0007a	88 55 e9	 mov	 BYTE PTR __t$[ebp+5], dl
  0007d	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00080	84 d2		 test	 dl, dl
  00082	0f 84 1e 01 00
	00		 je	 $LN90@operator@11
  00088	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0008b	88 55 ea	 mov	 BYTE PTR __t$[ebp+6], dl
  0008e	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00091	84 d2		 test	 dl, dl
  00093	0f 84 07 01 00
	00		 je	 $LN89@operator@11
  00099	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009c	88 55 eb	 mov	 BYTE PTR __t$[ebp+7], dl
  0009f	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a2	84 d2		 test	 dl, dl
  000a4	0f 84 f0 00 00
	00		 je	 $LN88@operator@11
  000aa	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ad	88 55 ec	 mov	 BYTE PTR __t$[ebp+8], dl
  000b0	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b3	84 d2		 test	 dl, dl
  000b5	0f 84 da 00 00
	00		 je	 $LN87@operator@11
  000bb	32 d1		 xor	 dl, cl
  000bd	88 55 ed	 mov	 BYTE PTR __t$[ebp+9], dl
  000c0	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c3	84 d2		 test	 dl, dl
  000c5	0f 84 c4 00 00
	00		 je	 $LN86@operator@11
  000cb	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000ce	88 55 ee	 mov	 BYTE PTR __t$[ebp+10], dl
  000d1	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000d4	84 d2		 test	 dl, dl
  000d6	0f 84 ad 00 00
	00		 je	 $LN85@operator@11
  000dc	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000df	88 55 ef	 mov	 BYTE PTR __t$[ebp+11], dl
  000e2	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000e5	84 d2		 test	 dl, dl
  000e7	0f 84 96 00 00
	00		 je	 $LN84@operator@11
  000ed	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000f0	88 55 f0	 mov	 BYTE PTR __t$[ebp+12], dl
  000f3	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000f6	84 d2		 test	 dl, dl
  000f8	0f 84 80 00 00
	00		 je	 $LN83@operator@11
  000fe	32 d1		 xor	 dl, cl
  00100	88 55 f1	 mov	 BYTE PTR __t$[ebp+13], dl
  00103	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  00106	84 d2		 test	 dl, dl
  00108	74 6e		 je	 SHORT $LN82@operator@11
  0010a	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0010d	88 55 f2	 mov	 BYTE PTR __t$[ebp+14], dl
  00110	8a 50 0f	 mov	 dl, BYTE PTR [eax+15]
  00113	84 d2		 test	 dl, dl
  00115	74 5b		 je	 SHORT $LN81@operator@11
  00117	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0011a	80 78 10 00	 cmp	 BYTE PTR [eax+16], 0
  0011e	88 55 f3	 mov	 BYTE PTR __t$[ebp+15], dl
  00121	0f 84 a6 00 00
	00		 je	 $LN1@operator@11
  00127	8a 50 11	 mov	 dl, BYTE PTR [eax+17]
  0012a	84 d2		 test	 dl, dl
  0012c	74 3f		 je	 SHORT $LN79@operator@11
  0012e	32 d1		 xor	 dl, cl
  00130	88 55 f5	 mov	 BYTE PTR __t$[ebp+17], dl
  00133	8a 50 12	 mov	 dl, BYTE PTR [eax+18]
  00136	84 d2		 test	 dl, dl
  00138	74 2d		 je	 SHORT $LN78@operator@11
  0013a	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0013d	88 55 f6	 mov	 BYTE PTR __t$[ebp+18], dl
  00140	8a 50 13	 mov	 dl, BYTE PTR [eax+19]
  00143	84 d2		 test	 dl, dl
  00145	74 1a		 je	 SHORT $LN77@operator@11
  00147	8a 40 14	 mov	 al, BYTE PTR [eax+20]
  0014a	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0014d	88 55 f7	 mov	 BYTE PTR __t$[ebp+19], dl
  00150	84 c0		 test	 al, al
  00152	74 07		 je	 SHORT $LN76@operator@11
  00154	34 ed		 xor	 al, -19			; ffffffedH
  00156	88 45 f8	 mov	 BYTE PTR __t$[ebp+20], al
  00159	eb 72		 jmp	 SHORT $LN1@operator@11
$LN76@operator@11:
  0015b	c6 45 f8 ed	 mov	 BYTE PTR __t$[ebp+20], -19 ; ffffffedH
  0015f	eb 6c		 jmp	 SHORT $LN1@operator@11
$LN77@operator@11:
  00161	c6 45 f7 ea	 mov	 BYTE PTR __t$[ebp+19], -22 ; ffffffeaH
  00165	eb 66		 jmp	 SHORT $LN1@operator@11
$LN78@operator@11:
  00167	c6 45 f6 eb	 mov	 BYTE PTR __t$[ebp+18], -21 ; ffffffebH
  0016b	eb 60		 jmp	 SHORT $LN1@operator@11
$LN79@operator@11:
  0016d	88 4d f5	 mov	 BYTE PTR __t$[ebp+17], cl
  00170	eb 5b		 jmp	 SHORT $LN1@operator@11
$LN81@operator@11:
  00172	c6 45 f3 ea	 mov	 BYTE PTR __t$[ebp+15], -22 ; ffffffeaH
  00176	eb 55		 jmp	 SHORT $LN1@operator@11
$LN82@operator@11:
  00178	c6 45 f2 eb	 mov	 BYTE PTR __t$[ebp+14], -21 ; ffffffebH
  0017c	eb 4f		 jmp	 SHORT $LN1@operator@11
$LN83@operator@11:
  0017e	88 4d f1	 mov	 BYTE PTR __t$[ebp+13], cl
  00181	eb 4a		 jmp	 SHORT $LN1@operator@11
$LN84@operator@11:
  00183	c6 45 f0 ed	 mov	 BYTE PTR __t$[ebp+12], -19 ; ffffffedH
  00187	eb 44		 jmp	 SHORT $LN1@operator@11
$LN85@operator@11:
  00189	c6 45 ef ea	 mov	 BYTE PTR __t$[ebp+11], -22 ; ffffffeaH
  0018d	eb 3e		 jmp	 SHORT $LN1@operator@11
$LN86@operator@11:
  0018f	c6 45 ee eb	 mov	 BYTE PTR __t$[ebp+10], -21 ; ffffffebH
  00193	eb 38		 jmp	 SHORT $LN1@operator@11
$LN87@operator@11:
  00195	88 4d ed	 mov	 BYTE PTR __t$[ebp+9], cl
  00198	eb 33		 jmp	 SHORT $LN1@operator@11
$LN88@operator@11:
  0019a	c6 45 ec ed	 mov	 BYTE PTR __t$[ebp+8], -19 ; ffffffedH
  0019e	eb 2d		 jmp	 SHORT $LN1@operator@11
$LN89@operator@11:
  001a0	c6 45 eb ea	 mov	 BYTE PTR __t$[ebp+7], -22 ; ffffffeaH
  001a4	eb 27		 jmp	 SHORT $LN1@operator@11
$LN90@operator@11:
  001a6	c6 45 ea eb	 mov	 BYTE PTR __t$[ebp+6], -21 ; ffffffebH
  001aa	eb 21		 jmp	 SHORT $LN1@operator@11
$LN91@operator@11:
  001ac	88 4d e9	 mov	 BYTE PTR __t$[ebp+5], cl
  001af	eb 1c		 jmp	 SHORT $LN1@operator@11
$LN92@operator@11:
  001b1	c6 45 e8 ed	 mov	 BYTE PTR __t$[ebp+4], -19 ; ffffffedH
  001b5	eb 16		 jmp	 SHORT $LN1@operator@11
$LN93@operator@11:
  001b7	c6 45 e7 ea	 mov	 BYTE PTR __t$[ebp+3], -22 ; ffffffeaH
  001bb	eb 10		 jmp	 SHORT $LN1@operator@11
$LN94@operator@11:
  001bd	c6 45 e6 eb	 mov	 BYTE PTR __t$[ebp+2], -21 ; ffffffebH
  001c1	eb 0a		 jmp	 SHORT $LN1@operator@11
$LN95@operator@11:
  001c3	c6 45 e5 ec	 mov	 BYTE PTR __t$[ebp+1], -20 ; ffffffecH
  001c7	eb 04		 jmp	 SHORT $LN1@operator@11
$LN96@operator@11:
  001c9	c6 45 e4 ed	 mov	 BYTE PTR __t$[ebp], -19	; ffffffedH
$LN1@operator@11:
  001cd	6a 04		 push	 4
  001cf	8d 45 e4	 lea	 eax, DWORD PTR __t$[ebp]
  001d2	c6 45 f4 00	 mov	 BYTE PTR __t$[ebp+16], 0
  001d6	5a		 pop	 edx
$LL104@operator@11:
  001d7	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  001dd	83 c0 04	 add	 eax, 4
  001e0	4a		 dec	 edx
  001e1	75 f4		 jne	 SHORT $LL104@operator@11
  001e3	8b cf		 mov	 ecx, edi
  001e5	8d 75 e4	 lea	 esi, DWORD PTR __t$[ebp]
  001e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL111@operator@11:
  001ee	8a 08		 mov	 cl, BYTE PTR [eax]
  001f0	3a 0e		 cmp	 cl, BYTE PTR [esi]
  001f2	75 1a		 jne	 SHORT $LN112@operator@11
  001f4	84 c9		 test	 cl, cl
  001f6	74 12		 je	 SHORT $LN113@operator@11
  001f8	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  001fb	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  001fe	75 0e		 jne	 SHORT $LN112@operator@11
  00200	83 c0 02	 add	 eax, 2
  00203	83 c6 02	 add	 esi, 2
  00206	84 c9		 test	 cl, cl
  00208	75 e4		 jne	 SHORT $LL111@operator@11
$LN113@operator@11:
  0020a	33 c0		 xor	 eax, eax
  0020c	eb 05		 jmp	 SHORT $LN114@operator@11
$LN112@operator@11:
  0020e	1b c0		 sbb	 eax, eax
  00210	83 d8 ff	 sbb	 eax, -1
$LN114@operator@11:
  00213	33 c9		 xor	 ecx, ecx
  00215	85 c0		 test	 eax, eax
  00217	0f 94 c0	 sete	 al

; 148  : }

  0021a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0021d	5f		 pop	 edi
  0021e	33 cd		 xor	 ecx, ebp
  00220	5e		 pop	 esi
  00221	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00226	c9		 leave
  00227	c3		 ret	 0
??$?8$0BB@@@YA_NABVioHashString@@AAY0BB@$$CBD@Z ENDP	; operator==<17>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$?8$0BA@@@YA_NABVioHashString@@AAY0BA@$$CBD@Z	; operator==<16>
; Function compile flags: /Ogsp
;	COMDAT ??$?8$0BA@@@YA_NABVioHashString@@AAY0BA@$$CBD@Z
_TEXT	SEGMENT
__t$ = -24						; size = 16
__$ArrayPad$ = -4					; size = 4
_lhs$ = 8						; size = 4
_t$ = 12						; size = 4
??$?8$0BA@@@YA_NABVioHashString@@AAY0BA@$$CBD@Z PROC	; operator==<16>, COMDAT

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]

; 147  : 	_ENCSTR(t, _t); return ( strcmp( lhs.c_str(), _t ) == 0 );

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	8b 7d 08	 mov	 edi, DWORD PTR _lhs$[ebp]
  0001a	84 d2		 test	 dl, dl
  0001c	0f 84 8c 01 00
	00		 je	 $LN96@operator@12
  00022	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00025	88 55 e8	 mov	 BYTE PTR __t$[ebp], dl
  00028	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002b	84 d2		 test	 dl, dl
  0002d	0f 84 75 01 00
	00		 je	 $LN95@operator@12
  00033	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00036	88 55 e9	 mov	 BYTE PTR __t$[ebp+1], dl
  00039	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003c	84 d2		 test	 dl, dl
  0003e	0f 84 5e 01 00
	00		 je	 $LN94@operator@12
  00044	b1 eb		 mov	 cl, -21			; ffffffebH
  00046	32 d1		 xor	 dl, cl
  00048	88 55 ea	 mov	 BYTE PTR __t$[ebp+2], dl
  0004b	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004e	84 d2		 test	 dl, dl
  00050	0f 84 46 01 00
	00		 je	 $LN93@operator@12
  00056	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00059	88 55 eb	 mov	 BYTE PTR __t$[ebp+3], dl
  0005c	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005f	84 d2		 test	 dl, dl
  00061	0f 84 2f 01 00
	00		 je	 $LN92@operator@12
  00067	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0006a	88 55 ec	 mov	 BYTE PTR __t$[ebp+4], dl
  0006d	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00070	84 d2		 test	 dl, dl
  00072	0f 84 18 01 00
	00		 je	 $LN91@operator@12
  00078	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0007b	88 55 ed	 mov	 BYTE PTR __t$[ebp+5], dl
  0007e	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00081	84 d2		 test	 dl, dl
  00083	0f 84 02 01 00
	00		 je	 $LN90@operator@12
  00089	32 d1		 xor	 dl, cl
  0008b	88 55 ee	 mov	 BYTE PTR __t$[ebp+6], dl
  0008e	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00091	84 d2		 test	 dl, dl
  00093	0f 84 ec 00 00
	00		 je	 $LN89@operator@12
  00099	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009c	88 55 ef	 mov	 BYTE PTR __t$[ebp+7], dl
  0009f	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a2	84 d2		 test	 dl, dl
  000a4	0f 84 d5 00 00
	00		 je	 $LN88@operator@12
  000aa	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ad	88 55 f0	 mov	 BYTE PTR __t$[ebp+8], dl
  000b0	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b3	84 d2		 test	 dl, dl
  000b5	0f 84 be 00 00
	00		 je	 $LN87@operator@12
  000bb	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000be	88 55 f1	 mov	 BYTE PTR __t$[ebp+9], dl
  000c1	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c4	84 d2		 test	 dl, dl
  000c6	0f 84 a8 00 00
	00		 je	 $LN86@operator@12
  000cc	32 d1		 xor	 dl, cl
  000ce	88 55 f2	 mov	 BYTE PTR __t$[ebp+10], dl
  000d1	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000d4	84 d2		 test	 dl, dl
  000d6	0f 84 92 00 00
	00		 je	 $LN85@operator@12
  000dc	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000df	88 55 f3	 mov	 BYTE PTR __t$[ebp+11], dl
  000e2	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000e5	84 d2		 test	 dl, dl
  000e7	74 7f		 je	 SHORT $LN84@operator@12
  000e9	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ec	88 55 f4	 mov	 BYTE PTR __t$[ebp+12], dl
  000ef	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000f2	84 d2		 test	 dl, dl
  000f4	74 6c		 je	 SHORT $LN83@operator@12
  000f6	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000f9	88 55 f5	 mov	 BYTE PTR __t$[ebp+13], dl
  000fc	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  000ff	84 d2		 test	 dl, dl
  00101	74 5a		 je	 SHORT $LN82@operator@12
  00103	32 d1		 xor	 dl, cl
  00105	80 78 0f 00	 cmp	 BYTE PTR [eax+15], 0
  00109	88 55 f6	 mov	 BYTE PTR __t$[ebp+14], dl
  0010c	0f 84 a0 00 00
	00		 je	 $LN1@operator@12
  00112	8a 50 10	 mov	 dl, BYTE PTR [eax+16]
  00115	84 d2		 test	 dl, dl
  00117	74 3e		 je	 SHORT $LN80@operator@12
  00119	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0011c	88 55 f8	 mov	 BYTE PTR __t$[ebp+16], dl
  0011f	8a 50 11	 mov	 dl, BYTE PTR [eax+17]
  00122	84 d2		 test	 dl, dl
  00124	74 2b		 je	 SHORT $LN79@operator@12
  00126	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00129	88 55 f9	 mov	 BYTE PTR __t$[ebp+17], dl
  0012c	8a 50 12	 mov	 dl, BYTE PTR [eax+18]
  0012f	84 d2		 test	 dl, dl
  00131	74 19		 je	 SHORT $LN78@operator@12
  00133	8a 40 13	 mov	 al, BYTE PTR [eax+19]
  00136	32 d1		 xor	 dl, cl
  00138	88 55 fa	 mov	 BYTE PTR __t$[ebp+18], dl
  0013b	84 c0		 test	 al, al
  0013d	74 07		 je	 SHORT $LN77@operator@12
  0013f	34 ea		 xor	 al, -22			; ffffffeaH
  00141	88 45 fb	 mov	 BYTE PTR __t$[ebp+19], al
  00144	eb 6c		 jmp	 SHORT $LN1@operator@12
$LN77@operator@12:
  00146	c6 45 fb ea	 mov	 BYTE PTR __t$[ebp+19], -22 ; ffffffeaH
  0014a	eb 66		 jmp	 SHORT $LN1@operator@12
$LN78@operator@12:
  0014c	88 4d fa	 mov	 BYTE PTR __t$[ebp+18], cl
  0014f	eb 61		 jmp	 SHORT $LN1@operator@12
$LN79@operator@12:
  00151	c6 45 f9 ec	 mov	 BYTE PTR __t$[ebp+17], -20 ; ffffffecH
  00155	eb 5b		 jmp	 SHORT $LN1@operator@12
$LN80@operator@12:
  00157	c6 45 f8 ed	 mov	 BYTE PTR __t$[ebp+16], -19 ; ffffffedH
  0015b	eb 55		 jmp	 SHORT $LN1@operator@12
$LN82@operator@12:
  0015d	88 4d f6	 mov	 BYTE PTR __t$[ebp+14], cl
  00160	eb 50		 jmp	 SHORT $LN1@operator@12
$LN83@operator@12:
  00162	c6 45 f5 ec	 mov	 BYTE PTR __t$[ebp+13], -20 ; ffffffecH
  00166	eb 4a		 jmp	 SHORT $LN1@operator@12
$LN84@operator@12:
  00168	c6 45 f4 ed	 mov	 BYTE PTR __t$[ebp+12], -19 ; ffffffedH
  0016c	eb 44		 jmp	 SHORT $LN1@operator@12
$LN85@operator@12:
  0016e	c6 45 f3 ea	 mov	 BYTE PTR __t$[ebp+11], -22 ; ffffffeaH
  00172	eb 3e		 jmp	 SHORT $LN1@operator@12
$LN86@operator@12:
  00174	88 4d f2	 mov	 BYTE PTR __t$[ebp+10], cl
  00177	eb 39		 jmp	 SHORT $LN1@operator@12
$LN87@operator@12:
  00179	c6 45 f1 ec	 mov	 BYTE PTR __t$[ebp+9], -20 ; ffffffecH
  0017d	eb 33		 jmp	 SHORT $LN1@operator@12
$LN88@operator@12:
  0017f	c6 45 f0 ed	 mov	 BYTE PTR __t$[ebp+8], -19 ; ffffffedH
  00183	eb 2d		 jmp	 SHORT $LN1@operator@12
$LN89@operator@12:
  00185	c6 45 ef ea	 mov	 BYTE PTR __t$[ebp+7], -22 ; ffffffeaH
  00189	eb 27		 jmp	 SHORT $LN1@operator@12
$LN90@operator@12:
  0018b	88 4d ee	 mov	 BYTE PTR __t$[ebp+6], cl
  0018e	eb 22		 jmp	 SHORT $LN1@operator@12
$LN91@operator@12:
  00190	c6 45 ed ec	 mov	 BYTE PTR __t$[ebp+5], -20 ; ffffffecH
  00194	eb 1c		 jmp	 SHORT $LN1@operator@12
$LN92@operator@12:
  00196	c6 45 ec ed	 mov	 BYTE PTR __t$[ebp+4], -19 ; ffffffedH
  0019a	eb 16		 jmp	 SHORT $LN1@operator@12
$LN93@operator@12:
  0019c	c6 45 eb ea	 mov	 BYTE PTR __t$[ebp+3], -22 ; ffffffeaH
  001a0	eb 10		 jmp	 SHORT $LN1@operator@12
$LN94@operator@12:
  001a2	c6 45 ea eb	 mov	 BYTE PTR __t$[ebp+2], -21 ; ffffffebH
  001a6	eb 0a		 jmp	 SHORT $LN1@operator@12
$LN95@operator@12:
  001a8	c6 45 e9 ec	 mov	 BYTE PTR __t$[ebp+1], -20 ; ffffffecH
  001ac	eb 04		 jmp	 SHORT $LN1@operator@12
$LN96@operator@12:
  001ae	c6 45 e8 ed	 mov	 BYTE PTR __t$[ebp], -19	; ffffffedH
$LN1@operator@12:
  001b2	6a 03		 push	 3
  001b4	8d 45 e8	 lea	 eax, DWORD PTR __t$[ebp]
  001b7	c6 45 f7 00	 mov	 BYTE PTR __t$[ebp+15], 0
  001bb	5a		 pop	 edx
$LL104@operator@12:
  001bc	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  001c2	83 c0 04	 add	 eax, 4
  001c5	4a		 dec	 edx
  001c6	75 f4		 jne	 SHORT $LL104@operator@12
  001c8	6a 0c		 push	 12			; 0000000cH
  001ca	58		 pop	 eax
$LL101@operator@12:
  001cb	8b c8		 mov	 ecx, eax
  001cd	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  001d3	79 05		 jns	 SHORT $LN115@operator@12
  001d5	49		 dec	 ecx
  001d6	83 c9 fc	 or	 ecx, -4			; fffffffcH
  001d9	41		 inc	 ecx
$LN115@operator@12:
  001da	b2 ed		 mov	 dl, -19			; ffffffedH
  001dc	2a d1		 sub	 dl, cl
  001de	30 54 05 e8	 xor	 BYTE PTR __t$[ebp+eax], dl
  001e2	40		 inc	 eax
  001e3	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  001e6	7c e3		 jl	 SHORT $LL101@operator@12
  001e8	8b cf		 mov	 ecx, edi
  001ea	8d 75 e8	 lea	 esi, DWORD PTR __t$[ebp]
  001ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL111@operator@12:
  001f3	8a 08		 mov	 cl, BYTE PTR [eax]
  001f5	3a 0e		 cmp	 cl, BYTE PTR [esi]
  001f7	75 1a		 jne	 SHORT $LN112@operator@12
  001f9	84 c9		 test	 cl, cl
  001fb	74 12		 je	 SHORT $LN113@operator@12
  001fd	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00200	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  00203	75 0e		 jne	 SHORT $LN112@operator@12
  00205	83 c0 02	 add	 eax, 2
  00208	83 c6 02	 add	 esi, 2
  0020b	84 c9		 test	 cl, cl
  0020d	75 e4		 jne	 SHORT $LL111@operator@12
$LN113@operator@12:
  0020f	33 c0		 xor	 eax, eax
  00211	eb 05		 jmp	 SHORT $LN114@operator@12
$LN112@operator@12:
  00213	1b c0		 sbb	 eax, eax
  00215	83 d8 ff	 sbb	 eax, -1
$LN114@operator@12:
  00218	33 c9		 xor	 ecx, ecx
  0021a	85 c0		 test	 eax, eax
  0021c	0f 94 c0	 sete	 al

; 148  : }

  0021f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00222	5f		 pop	 edi
  00223	33 cd		 xor	 ecx, ebp
  00225	5e		 pop	 esi
  00226	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0022b	c9		 leave
  0022c	c3		 ret	 0
??$?8$0BA@@@YA_NABVioHashString@@AAY0BA@$$CBD@Z ENDP	; operator==<16>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$?8$0BC@@@YA_NABVioHashString@@AAY0BC@$$CBD@Z	; operator==<18>
; Function compile flags: /Ogsp
;	COMDAT ??$?8$0BC@@@YA_NABVioHashString@@AAY0BC@$$CBD@Z
_TEXT	SEGMENT
__t$ = -28						; size = 18
__$ArrayPad$ = -4					; size = 4
_lhs$ = 8						; size = 4
_t$ = 12						; size = 4
??$?8$0BC@@@YA_NABVioHashString@@AAY0BC@$$CBD@Z PROC	; operator==<18>, COMDAT

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]

; 147  : 	_ENCSTR(t, _t); return ( strcmp( lhs.c_str(), _t ) == 0 );

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	8b 7d 08	 mov	 edi, DWORD PTR _lhs$[ebp]
  0001a	84 d2		 test	 dl, dl
  0001c	0f 84 be 01 00
	00		 je	 $LN96@operator@13
  00022	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00025	88 55 e4	 mov	 BYTE PTR __t$[ebp], dl
  00028	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002b	84 d2		 test	 dl, dl
  0002d	0f 84 a7 01 00
	00		 je	 $LN95@operator@13
  00033	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00036	88 55 e5	 mov	 BYTE PTR __t$[ebp+1], dl
  00039	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003c	84 d2		 test	 dl, dl
  0003e	0f 84 90 01 00
	00		 je	 $LN94@operator@13
  00044	b1 eb		 mov	 cl, -21			; ffffffebH
  00046	32 d1		 xor	 dl, cl
  00048	88 55 e6	 mov	 BYTE PTR __t$[ebp+2], dl
  0004b	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004e	84 d2		 test	 dl, dl
  00050	0f 84 78 01 00
	00		 je	 $LN93@operator@13
  00056	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00059	88 55 e7	 mov	 BYTE PTR __t$[ebp+3], dl
  0005c	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005f	84 d2		 test	 dl, dl
  00061	0f 84 61 01 00
	00		 je	 $LN92@operator@13
  00067	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0006a	88 55 e8	 mov	 BYTE PTR __t$[ebp+4], dl
  0006d	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00070	84 d2		 test	 dl, dl
  00072	0f 84 4a 01 00
	00		 je	 $LN91@operator@13
  00078	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0007b	88 55 e9	 mov	 BYTE PTR __t$[ebp+5], dl
  0007e	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00081	84 d2		 test	 dl, dl
  00083	0f 84 34 01 00
	00		 je	 $LN90@operator@13
  00089	32 d1		 xor	 dl, cl
  0008b	88 55 ea	 mov	 BYTE PTR __t$[ebp+6], dl
  0008e	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00091	84 d2		 test	 dl, dl
  00093	0f 84 1e 01 00
	00		 je	 $LN89@operator@13
  00099	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009c	88 55 eb	 mov	 BYTE PTR __t$[ebp+7], dl
  0009f	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a2	84 d2		 test	 dl, dl
  000a4	0f 84 07 01 00
	00		 je	 $LN88@operator@13
  000aa	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ad	88 55 ec	 mov	 BYTE PTR __t$[ebp+8], dl
  000b0	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b3	84 d2		 test	 dl, dl
  000b5	0f 84 f0 00 00
	00		 je	 $LN87@operator@13
  000bb	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000be	88 55 ed	 mov	 BYTE PTR __t$[ebp+9], dl
  000c1	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c4	84 d2		 test	 dl, dl
  000c6	0f 84 da 00 00
	00		 je	 $LN86@operator@13
  000cc	32 d1		 xor	 dl, cl
  000ce	88 55 ee	 mov	 BYTE PTR __t$[ebp+10], dl
  000d1	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000d4	84 d2		 test	 dl, dl
  000d6	0f 84 c4 00 00
	00		 je	 $LN85@operator@13
  000dc	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000df	88 55 ef	 mov	 BYTE PTR __t$[ebp+11], dl
  000e2	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000e5	84 d2		 test	 dl, dl
  000e7	0f 84 ad 00 00
	00		 je	 $LN84@operator@13
  000ed	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000f0	88 55 f0	 mov	 BYTE PTR __t$[ebp+12], dl
  000f3	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000f6	84 d2		 test	 dl, dl
  000f8	0f 84 96 00 00
	00		 je	 $LN83@operator@13
  000fe	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00101	88 55 f1	 mov	 BYTE PTR __t$[ebp+13], dl
  00104	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  00107	84 d2		 test	 dl, dl
  00109	0f 84 80 00 00
	00		 je	 $LN82@operator@13
  0010f	32 d1		 xor	 dl, cl
  00111	88 55 f2	 mov	 BYTE PTR __t$[ebp+14], dl
  00114	8a 50 0f	 mov	 dl, BYTE PTR [eax+15]
  00117	84 d2		 test	 dl, dl
  00119	74 6e		 je	 SHORT $LN81@operator@13
  0011b	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0011e	88 55 f3	 mov	 BYTE PTR __t$[ebp+15], dl
  00121	8a 50 10	 mov	 dl, BYTE PTR [eax+16]
  00124	84 d2		 test	 dl, dl
  00126	74 5b		 je	 SHORT $LN80@operator@13
  00128	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0012b	80 78 11 00	 cmp	 BYTE PTR [eax+17], 0
  0012f	88 55 f4	 mov	 BYTE PTR __t$[ebp+16], dl
  00132	0f 84 ac 00 00
	00		 je	 $LN1@operator@13
  00138	8a 50 12	 mov	 dl, BYTE PTR [eax+18]
  0013b	84 d2		 test	 dl, dl
  0013d	74 3f		 je	 SHORT $LN78@operator@13
  0013f	32 d1		 xor	 dl, cl
  00141	88 55 f6	 mov	 BYTE PTR __t$[ebp+18], dl
  00144	8a 50 13	 mov	 dl, BYTE PTR [eax+19]
  00147	84 d2		 test	 dl, dl
  00149	74 2d		 je	 SHORT $LN77@operator@13
  0014b	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0014e	88 55 f7	 mov	 BYTE PTR __t$[ebp+19], dl
  00151	8a 50 14	 mov	 dl, BYTE PTR [eax+20]
  00154	84 d2		 test	 dl, dl
  00156	74 1a		 je	 SHORT $LN76@operator@13
  00158	8a 40 15	 mov	 al, BYTE PTR [eax+21]
  0015b	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0015e	88 55 f8	 mov	 BYTE PTR __t$[ebp+20], dl
  00161	84 c0		 test	 al, al
  00163	74 07		 je	 SHORT $LN75@operator@13
  00165	34 ec		 xor	 al, -20			; ffffffecH
  00167	88 45 f9	 mov	 BYTE PTR __t$[ebp+21], al
  0016a	eb 78		 jmp	 SHORT $LN1@operator@13
$LN75@operator@13:
  0016c	c6 45 f9 ec	 mov	 BYTE PTR __t$[ebp+21], -20 ; ffffffecH
  00170	eb 72		 jmp	 SHORT $LN1@operator@13
$LN76@operator@13:
  00172	c6 45 f8 ed	 mov	 BYTE PTR __t$[ebp+20], -19 ; ffffffedH
  00176	eb 6c		 jmp	 SHORT $LN1@operator@13
$LN77@operator@13:
  00178	c6 45 f7 ea	 mov	 BYTE PTR __t$[ebp+19], -22 ; ffffffeaH
  0017c	eb 66		 jmp	 SHORT $LN1@operator@13
$LN78@operator@13:
  0017e	88 4d f6	 mov	 BYTE PTR __t$[ebp+18], cl
  00181	eb 61		 jmp	 SHORT $LN1@operator@13
$LN80@operator@13:
  00183	c6 45 f4 ed	 mov	 BYTE PTR __t$[ebp+16], -19 ; ffffffedH
  00187	eb 5b		 jmp	 SHORT $LN1@operator@13
$LN81@operator@13:
  00189	c6 45 f3 ea	 mov	 BYTE PTR __t$[ebp+15], -22 ; ffffffeaH
  0018d	eb 55		 jmp	 SHORT $LN1@operator@13
$LN82@operator@13:
  0018f	88 4d f2	 mov	 BYTE PTR __t$[ebp+14], cl
  00192	eb 50		 jmp	 SHORT $LN1@operator@13
$LN83@operator@13:
  00194	c6 45 f1 ec	 mov	 BYTE PTR __t$[ebp+13], -20 ; ffffffecH
  00198	eb 4a		 jmp	 SHORT $LN1@operator@13
$LN84@operator@13:
  0019a	c6 45 f0 ed	 mov	 BYTE PTR __t$[ebp+12], -19 ; ffffffedH
  0019e	eb 44		 jmp	 SHORT $LN1@operator@13
$LN85@operator@13:
  001a0	c6 45 ef ea	 mov	 BYTE PTR __t$[ebp+11], -22 ; ffffffeaH
  001a4	eb 3e		 jmp	 SHORT $LN1@operator@13
$LN86@operator@13:
  001a6	88 4d ee	 mov	 BYTE PTR __t$[ebp+10], cl
  001a9	eb 39		 jmp	 SHORT $LN1@operator@13
$LN87@operator@13:
  001ab	c6 45 ed ec	 mov	 BYTE PTR __t$[ebp+9], -20 ; ffffffecH
  001af	eb 33		 jmp	 SHORT $LN1@operator@13
$LN88@operator@13:
  001b1	c6 45 ec ed	 mov	 BYTE PTR __t$[ebp+8], -19 ; ffffffedH
  001b5	eb 2d		 jmp	 SHORT $LN1@operator@13
$LN89@operator@13:
  001b7	c6 45 eb ea	 mov	 BYTE PTR __t$[ebp+7], -22 ; ffffffeaH
  001bb	eb 27		 jmp	 SHORT $LN1@operator@13
$LN90@operator@13:
  001bd	88 4d ea	 mov	 BYTE PTR __t$[ebp+6], cl
  001c0	eb 22		 jmp	 SHORT $LN1@operator@13
$LN91@operator@13:
  001c2	c6 45 e9 ec	 mov	 BYTE PTR __t$[ebp+5], -20 ; ffffffecH
  001c6	eb 1c		 jmp	 SHORT $LN1@operator@13
$LN92@operator@13:
  001c8	c6 45 e8 ed	 mov	 BYTE PTR __t$[ebp+4], -19 ; ffffffedH
  001cc	eb 16		 jmp	 SHORT $LN1@operator@13
$LN93@operator@13:
  001ce	c6 45 e7 ea	 mov	 BYTE PTR __t$[ebp+3], -22 ; ffffffeaH
  001d2	eb 10		 jmp	 SHORT $LN1@operator@13
$LN94@operator@13:
  001d4	c6 45 e6 eb	 mov	 BYTE PTR __t$[ebp+2], -21 ; ffffffebH
  001d8	eb 0a		 jmp	 SHORT $LN1@operator@13
$LN95@operator@13:
  001da	c6 45 e5 ec	 mov	 BYTE PTR __t$[ebp+1], -20 ; ffffffecH
  001de	eb 04		 jmp	 SHORT $LN1@operator@13
$LN96@operator@13:
  001e0	c6 45 e4 ed	 mov	 BYTE PTR __t$[ebp], -19	; ffffffedH
$LN1@operator@13:
  001e4	6a 04		 push	 4
  001e6	8d 45 e4	 lea	 eax, DWORD PTR __t$[ebp]
  001e9	c6 45 f5 00	 mov	 BYTE PTR __t$[ebp+17], 0
  001ed	5a		 pop	 edx
$LL104@operator@13:
  001ee	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  001f4	83 c0 04	 add	 eax, 4
  001f7	4a		 dec	 edx
  001f8	75 f4		 jne	 SHORT $LL104@operator@13
  001fa	80 75 f4 ed	 xor	 BYTE PTR __t$[ebp+16], -19 ; ffffffedH
  001fe	8b cf		 mov	 ecx, edi
  00200	8d 75 e4	 lea	 esi, DWORD PTR __t$[ebp]
  00203	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL111@operator@13:
  00209	8a 08		 mov	 cl, BYTE PTR [eax]
  0020b	3a 0e		 cmp	 cl, BYTE PTR [esi]
  0020d	75 1a		 jne	 SHORT $LN112@operator@13
  0020f	84 c9		 test	 cl, cl
  00211	74 12		 je	 SHORT $LN113@operator@13
  00213	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00216	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  00219	75 0e		 jne	 SHORT $LN112@operator@13
  0021b	83 c0 02	 add	 eax, 2
  0021e	83 c6 02	 add	 esi, 2
  00221	84 c9		 test	 cl, cl
  00223	75 e4		 jne	 SHORT $LL111@operator@13
$LN113@operator@13:
  00225	33 c0		 xor	 eax, eax
  00227	eb 05		 jmp	 SHORT $LN114@operator@13
$LN112@operator@13:
  00229	1b c0		 sbb	 eax, eax
  0022b	83 d8 ff	 sbb	 eax, -1
$LN114@operator@13:
  0022e	33 c9		 xor	 ecx, ecx
  00230	85 c0		 test	 eax, eax
  00232	0f 94 c0	 sete	 al

; 148  : }

  00235	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00238	5f		 pop	 edi
  00239	33 cd		 xor	 ecx, ebp
  0023b	5e		 pop	 esi
  0023c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00241	c9		 leave
  00242	c3		 ret	 0
??$?8$0BC@@@YA_NABVioHashString@@AAY0BC@$$CBD@Z ENDP	; operator==<18>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$?8$0BG@@@YA_NABVioHashString@@AAY0BG@$$CBD@Z	; operator==<22>
; Function compile flags: /Ogsp
;	COMDAT ??$?8$0BG@@@YA_NABVioHashString@@AAY0BG@$$CBD@Z
_TEXT	SEGMENT
__t$ = -32						; size = 22
__$ArrayPad$ = -4					; size = 4
_lhs$ = 8						; size = 4
_t$ = 12						; size = 4
??$?8$0BG@@@YA_NABVioHashString@@AAY0BG@$$CBD@Z PROC	; operator==<22>, COMDAT

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]

; 147  : 	_ENCSTR(t, _t); return ( strcmp( lhs.c_str(), _t ) == 0 );

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	8b 7d 08	 mov	 edi, DWORD PTR _lhs$[ebp]
  0001b	84 d2		 test	 dl, dl
  0001d	0f 84 15 02 00
	00		 je	 $LN96@operator@14
  00023	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00026	88 55 e0	 mov	 BYTE PTR __t$[ebp], dl
  00029	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002c	84 d2		 test	 dl, dl
  0002e	0f 84 fe 01 00
	00		 je	 $LN95@operator@14
  00034	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00037	88 55 e1	 mov	 BYTE PTR __t$[ebp+1], dl
  0003a	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003d	84 d2		 test	 dl, dl
  0003f	0f 84 e7 01 00
	00		 je	 $LN94@operator@14
  00045	b1 eb		 mov	 cl, -21			; ffffffebH
  00047	32 d1		 xor	 dl, cl
  00049	88 55 e2	 mov	 BYTE PTR __t$[ebp+2], dl
  0004c	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004f	84 d2		 test	 dl, dl
  00051	0f 84 cf 01 00
	00		 je	 $LN93@operator@14
  00057	b3 ea		 mov	 bl, -22			; ffffffeaH
  00059	32 d3		 xor	 dl, bl
  0005b	88 55 e3	 mov	 BYTE PTR __t$[ebp+3], dl
  0005e	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  00061	84 d2		 test	 dl, dl
  00063	0f 84 b7 01 00
	00		 je	 $LN92@operator@14
  00069	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0006c	88 55 e4	 mov	 BYTE PTR __t$[ebp+4], dl
  0006f	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00072	84 d2		 test	 dl, dl
  00074	0f 84 a0 01 00
	00		 je	 $LN91@operator@14
  0007a	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0007d	88 55 e5	 mov	 BYTE PTR __t$[ebp+5], dl
  00080	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00083	84 d2		 test	 dl, dl
  00085	0f 84 8a 01 00
	00		 je	 $LN90@operator@14
  0008b	32 d1		 xor	 dl, cl
  0008d	88 55 e6	 mov	 BYTE PTR __t$[ebp+6], dl
  00090	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00093	84 d2		 test	 dl, dl
  00095	0f 84 75 01 00
	00		 je	 $LN89@operator@14
  0009b	32 d3		 xor	 dl, bl
  0009d	88 55 e7	 mov	 BYTE PTR __t$[ebp+7], dl
  000a0	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a3	84 d2		 test	 dl, dl
  000a5	0f 84 5f 01 00
	00		 je	 $LN88@operator@14
  000ab	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ae	88 55 e8	 mov	 BYTE PTR __t$[ebp+8], dl
  000b1	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b4	84 d2		 test	 dl, dl
  000b6	0f 84 48 01 00
	00		 je	 $LN87@operator@14
  000bc	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000bf	88 55 e9	 mov	 BYTE PTR __t$[ebp+9], dl
  000c2	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c5	84 d2		 test	 dl, dl
  000c7	0f 84 32 01 00
	00		 je	 $LN86@operator@14
  000cd	32 d1		 xor	 dl, cl
  000cf	88 55 ea	 mov	 BYTE PTR __t$[ebp+10], dl
  000d2	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000d5	84 d2		 test	 dl, dl
  000d7	0f 84 1d 01 00
	00		 je	 $LN85@operator@14
  000dd	32 d3		 xor	 dl, bl
  000df	88 55 eb	 mov	 BYTE PTR __t$[ebp+11], dl
  000e2	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000e5	84 d2		 test	 dl, dl
  000e7	0f 84 07 01 00
	00		 je	 $LN84@operator@14
  000ed	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000f0	88 55 ec	 mov	 BYTE PTR __t$[ebp+12], dl
  000f3	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000f6	84 d2		 test	 dl, dl
  000f8	0f 84 f0 00 00
	00		 je	 $LN83@operator@14
  000fe	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00101	88 55 ed	 mov	 BYTE PTR __t$[ebp+13], dl
  00104	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  00107	84 d2		 test	 dl, dl
  00109	0f 84 da 00 00
	00		 je	 $LN82@operator@14
  0010f	32 d1		 xor	 dl, cl
  00111	88 55 ee	 mov	 BYTE PTR __t$[ebp+14], dl
  00114	8a 50 0f	 mov	 dl, BYTE PTR [eax+15]
  00117	84 d2		 test	 dl, dl
  00119	0f 84 c5 00 00
	00		 je	 $LN81@operator@14
  0011f	32 d3		 xor	 dl, bl
  00121	88 55 ef	 mov	 BYTE PTR __t$[ebp+15], dl
  00124	8a 50 10	 mov	 dl, BYTE PTR [eax+16]
  00127	84 d2		 test	 dl, dl
  00129	0f 84 af 00 00
	00		 je	 $LN80@operator@14
  0012f	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00132	88 55 f0	 mov	 BYTE PTR __t$[ebp+16], dl
  00135	8a 50 11	 mov	 dl, BYTE PTR [eax+17]
  00138	84 d2		 test	 dl, dl
  0013a	0f 84 98 00 00
	00		 je	 $LN79@operator@14
  00140	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00143	88 55 f1	 mov	 BYTE PTR __t$[ebp+17], dl
  00146	8a 50 12	 mov	 dl, BYTE PTR [eax+18]
  00149	84 d2		 test	 dl, dl
  0014b	0f 84 82 00 00
	00		 je	 $LN78@operator@14
  00151	32 d1		 xor	 dl, cl
  00153	88 55 f2	 mov	 BYTE PTR __t$[ebp+18], dl
  00156	8a 50 13	 mov	 dl, BYTE PTR [eax+19]
  00159	84 d2		 test	 dl, dl
  0015b	74 71		 je	 SHORT $LN77@operator@14
  0015d	32 d3		 xor	 dl, bl
  0015f	88 55 f3	 mov	 BYTE PTR __t$[ebp+19], dl
  00162	8a 50 14	 mov	 dl, BYTE PTR [eax+20]
  00165	84 d2		 test	 dl, dl
  00167	74 5f		 je	 SHORT $LN76@operator@14
  00169	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0016c	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00170	88 55 f4	 mov	 BYTE PTR __t$[ebp+20], dl
  00173	0f 84 c3 00 00
	00		 je	 $LN1@operator@14
  00179	8a 50 16	 mov	 dl, BYTE PTR [eax+22]
  0017c	84 d2		 test	 dl, dl
  0017e	74 43		 je	 SHORT $LN74@operator@14
  00180	32 d1		 xor	 dl, cl
  00182	88 55 f6	 mov	 BYTE PTR __t$[ebp+22], dl
  00185	8a 50 17	 mov	 dl, BYTE PTR [eax+23]
  00188	84 d2		 test	 dl, dl
  0018a	74 32		 je	 SHORT $LN73@operator@14
  0018c	32 d3		 xor	 dl, bl
  0018e	88 55 f7	 mov	 BYTE PTR __t$[ebp+23], dl
  00191	8a 50 18	 mov	 dl, BYTE PTR [eax+24]
  00194	84 d2		 test	 dl, dl
  00196	74 20		 je	 SHORT $LN72@operator@14
  00198	8a 40 19	 mov	 al, BYTE PTR [eax+25]
  0019b	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0019e	88 55 f8	 mov	 BYTE PTR __t$[ebp+24], dl
  001a1	84 c0		 test	 al, al
  001a3	74 0a		 je	 SHORT $LN71@operator@14
  001a5	34 ec		 xor	 al, -20			; ffffffecH
  001a7	88 45 f9	 mov	 BYTE PTR __t$[ebp+25], al
  001aa	e9 8d 00 00 00	 jmp	 $LN1@operator@14
$LN71@operator@14:
  001af	c6 45 f9 ec	 mov	 BYTE PTR __t$[ebp+25], -20 ; ffffffecH
  001b3	e9 84 00 00 00	 jmp	 $LN1@operator@14
$LN72@operator@14:
  001b8	c6 45 f8 ed	 mov	 BYTE PTR __t$[ebp+24], -19 ; ffffffedH
  001bc	eb 7e		 jmp	 SHORT $LN1@operator@14
$LN73@operator@14:
  001be	88 5d f7	 mov	 BYTE PTR __t$[ebp+23], bl
  001c1	eb 79		 jmp	 SHORT $LN1@operator@14
$LN74@operator@14:
  001c3	88 4d f6	 mov	 BYTE PTR __t$[ebp+22], cl
  001c6	eb 74		 jmp	 SHORT $LN1@operator@14
$LN76@operator@14:
  001c8	c6 45 f4 ed	 mov	 BYTE PTR __t$[ebp+20], -19 ; ffffffedH
  001cc	eb 6e		 jmp	 SHORT $LN1@operator@14
$LN77@operator@14:
  001ce	88 5d f3	 mov	 BYTE PTR __t$[ebp+19], bl
  001d1	eb 69		 jmp	 SHORT $LN1@operator@14
$LN78@operator@14:
  001d3	88 4d f2	 mov	 BYTE PTR __t$[ebp+18], cl
  001d6	eb 64		 jmp	 SHORT $LN1@operator@14
$LN79@operator@14:
  001d8	c6 45 f1 ec	 mov	 BYTE PTR __t$[ebp+17], -20 ; ffffffecH
  001dc	eb 5e		 jmp	 SHORT $LN1@operator@14
$LN80@operator@14:
  001de	c6 45 f0 ed	 mov	 BYTE PTR __t$[ebp+16], -19 ; ffffffedH
  001e2	eb 58		 jmp	 SHORT $LN1@operator@14
$LN81@operator@14:
  001e4	88 5d ef	 mov	 BYTE PTR __t$[ebp+15], bl
  001e7	eb 53		 jmp	 SHORT $LN1@operator@14
$LN82@operator@14:
  001e9	88 4d ee	 mov	 BYTE PTR __t$[ebp+14], cl
  001ec	eb 4e		 jmp	 SHORT $LN1@operator@14
$LN83@operator@14:
  001ee	c6 45 ed ec	 mov	 BYTE PTR __t$[ebp+13], -20 ; ffffffecH
  001f2	eb 48		 jmp	 SHORT $LN1@operator@14
$LN84@operator@14:
  001f4	c6 45 ec ed	 mov	 BYTE PTR __t$[ebp+12], -19 ; ffffffedH
  001f8	eb 42		 jmp	 SHORT $LN1@operator@14
$LN85@operator@14:
  001fa	88 5d eb	 mov	 BYTE PTR __t$[ebp+11], bl
  001fd	eb 3d		 jmp	 SHORT $LN1@operator@14
$LN86@operator@14:
  001ff	88 4d ea	 mov	 BYTE PTR __t$[ebp+10], cl
  00202	eb 38		 jmp	 SHORT $LN1@operator@14
$LN87@operator@14:
  00204	c6 45 e9 ec	 mov	 BYTE PTR __t$[ebp+9], -20 ; ffffffecH
  00208	eb 32		 jmp	 SHORT $LN1@operator@14
$LN88@operator@14:
  0020a	c6 45 e8 ed	 mov	 BYTE PTR __t$[ebp+8], -19 ; ffffffedH
  0020e	eb 2c		 jmp	 SHORT $LN1@operator@14
$LN89@operator@14:
  00210	88 5d e7	 mov	 BYTE PTR __t$[ebp+7], bl
  00213	eb 27		 jmp	 SHORT $LN1@operator@14
$LN90@operator@14:
  00215	88 4d e6	 mov	 BYTE PTR __t$[ebp+6], cl
  00218	eb 22		 jmp	 SHORT $LN1@operator@14
$LN91@operator@14:
  0021a	c6 45 e5 ec	 mov	 BYTE PTR __t$[ebp+5], -20 ; ffffffecH
  0021e	eb 1c		 jmp	 SHORT $LN1@operator@14
$LN92@operator@14:
  00220	c6 45 e4 ed	 mov	 BYTE PTR __t$[ebp+4], -19 ; ffffffedH
  00224	eb 16		 jmp	 SHORT $LN1@operator@14
$LN93@operator@14:
  00226	c6 45 e3 ea	 mov	 BYTE PTR __t$[ebp+3], -22 ; ffffffeaH
  0022a	eb 10		 jmp	 SHORT $LN1@operator@14
$LN94@operator@14:
  0022c	c6 45 e2 eb	 mov	 BYTE PTR __t$[ebp+2], -21 ; ffffffebH
  00230	eb 0a		 jmp	 SHORT $LN1@operator@14
$LN95@operator@14:
  00232	c6 45 e1 ec	 mov	 BYTE PTR __t$[ebp+1], -20 ; ffffffecH
  00236	eb 04		 jmp	 SHORT $LN1@operator@14
$LN96@operator@14:
  00238	c6 45 e0 ed	 mov	 BYTE PTR __t$[ebp], -19	; ffffffedH
$LN1@operator@14:
  0023c	6a 05		 push	 5
  0023e	8d 45 e0	 lea	 eax, DWORD PTR __t$[ebp]
  00241	c6 45 f5 00	 mov	 BYTE PTR __t$[ebp+21], 0
  00245	5a		 pop	 edx
$LL104@operator@14:
  00246	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0024c	83 c0 04	 add	 eax, 4
  0024f	4a		 dec	 edx
  00250	75 f4		 jne	 SHORT $LL104@operator@14
  00252	80 75 f4 ed	 xor	 BYTE PTR __t$[ebp+20], -19 ; ffffffedH
  00256	8b cf		 mov	 ecx, edi
  00258	8d 75 e0	 lea	 esi, DWORD PTR __t$[ebp]
  0025b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL111@operator@14:
  00261	8a 08		 mov	 cl, BYTE PTR [eax]
  00263	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00265	75 1a		 jne	 SHORT $LN112@operator@14
  00267	84 c9		 test	 cl, cl
  00269	74 12		 je	 SHORT $LN113@operator@14
  0026b	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  0026e	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  00271	75 0e		 jne	 SHORT $LN112@operator@14
  00273	83 c0 02	 add	 eax, 2
  00276	83 c6 02	 add	 esi, 2
  00279	84 c9		 test	 cl, cl
  0027b	75 e4		 jne	 SHORT $LL111@operator@14
$LN113@operator@14:
  0027d	33 c0		 xor	 eax, eax
  0027f	eb 05		 jmp	 SHORT $LN114@operator@14
$LN112@operator@14:
  00281	1b c0		 sbb	 eax, eax
  00283	83 d8 ff	 sbb	 eax, -1
$LN114@operator@14:
  00286	33 c9		 xor	 ecx, ecx
  00288	85 c0		 test	 eax, eax
  0028a	0f 94 c0	 sete	 al

; 148  : }

  0028d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00290	5f		 pop	 edi
  00291	5e		 pop	 esi
  00292	33 cd		 xor	 ecx, ebp
  00294	5b		 pop	 ebx
  00295	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0029a	c9		 leave
  0029b	c3		 ret	 0
??$?8$0BG@@@YA_NABVioHashString@@AAY0BG@$$CBD@Z ENDP	; operator==<22>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$?8$06@@YA_NABVioHashString@@AAY06$$CBD@Z	; operator==<7>
; Function compile flags: /Ogsp
;	COMDAT ??$?8$06@@YA_NABVioHashString@@AAY06$$CBD@Z
_TEXT	SEGMENT
__t$ = -16						; size = 7
__$ArrayPad$ = -4					; size = 4
_lhs$ = 8						; size = 4
_t$ = 12						; size = 4
??$?8$06@@YA_NABVioHashString@@AAY06$$CBD@Z PROC	; operator==<7>, COMDAT

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]

; 147  : 	_ENCSTR(t, _t); return ( strcmp( lhs.c_str(), _t ) == 0 );

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	8b 7d 08	 mov	 edi, DWORD PTR _lhs$[ebp]
  0001a	84 d2		 test	 dl, dl
  0001c	0f 84 c0 00 00
	00		 je	 $LN96@operator@15
  00022	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00025	88 55 f0	 mov	 BYTE PTR __t$[ebp], dl
  00028	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002b	84 d2		 test	 dl, dl
  0002d	0f 84 a9 00 00
	00		 je	 $LN95@operator@15
  00033	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00036	88 55 f1	 mov	 BYTE PTR __t$[ebp+1], dl
  00039	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003c	84 d2		 test	 dl, dl
  0003e	0f 84 92 00 00
	00		 je	 $LN94@operator@15
  00044	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00047	88 55 f2	 mov	 BYTE PTR __t$[ebp+2], dl
  0004a	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004d	84 d2		 test	 dl, dl
  0004f	74 7f		 je	 SHORT $LN93@operator@15
  00051	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00054	88 55 f3	 mov	 BYTE PTR __t$[ebp+3], dl
  00057	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005a	84 d2		 test	 dl, dl
  0005c	74 6c		 je	 SHORT $LN92@operator@15
  0005e	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00061	88 55 f4	 mov	 BYTE PTR __t$[ebp+4], dl
  00064	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00067	84 d2		 test	 dl, dl
  00069	74 59		 je	 SHORT $LN91@operator@15
  0006b	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0006e	80 78 06 00	 cmp	 BYTE PTR [eax+6], 0
  00072	88 55 f5	 mov	 BYTE PTR __t$[ebp+5], dl
  00075	74 6f		 je	 SHORT $LN1@operator@15
  00077	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0007a	84 d2		 test	 dl, dl
  0007c	74 40		 je	 SHORT $LN89@operator@15
  0007e	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00081	88 55 f7	 mov	 BYTE PTR __t$[ebp+7], dl
  00084	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  00087	84 d2		 test	 dl, dl
  00089	74 2d		 je	 SHORT $LN88@operator@15
  0008b	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0008e	88 55 f8	 mov	 BYTE PTR __t$[ebp+8], dl
  00091	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  00094	84 d2		 test	 dl, dl
  00096	74 1a		 je	 SHORT $LN87@operator@15
  00098	8a 40 0a	 mov	 al, BYTE PTR [eax+10]
  0009b	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0009e	88 55 f9	 mov	 BYTE PTR __t$[ebp+9], dl
  000a1	84 c0		 test	 al, al
  000a3	74 07		 je	 SHORT $LN86@operator@15
  000a5	34 eb		 xor	 al, -21			; ffffffebH
  000a7	88 45 fa	 mov	 BYTE PTR __t$[ebp+10], al
  000aa	eb 3a		 jmp	 SHORT $LN1@operator@15
$LN86@operator@15:
  000ac	c6 45 fa eb	 mov	 BYTE PTR __t$[ebp+10], -21 ; ffffffebH
  000b0	eb 34		 jmp	 SHORT $LN1@operator@15
$LN87@operator@15:
  000b2	c6 45 f9 ec	 mov	 BYTE PTR __t$[ebp+9], -20 ; ffffffecH
  000b6	eb 2e		 jmp	 SHORT $LN1@operator@15
$LN88@operator@15:
  000b8	c6 45 f8 ed	 mov	 BYTE PTR __t$[ebp+8], -19 ; ffffffedH
  000bc	eb 28		 jmp	 SHORT $LN1@operator@15
$LN89@operator@15:
  000be	c6 45 f7 ea	 mov	 BYTE PTR __t$[ebp+7], -22 ; ffffffeaH
  000c2	eb 22		 jmp	 SHORT $LN1@operator@15
$LN91@operator@15:
  000c4	c6 45 f5 ec	 mov	 BYTE PTR __t$[ebp+5], -20 ; ffffffecH
  000c8	eb 1c		 jmp	 SHORT $LN1@operator@15
$LN92@operator@15:
  000ca	c6 45 f4 ed	 mov	 BYTE PTR __t$[ebp+4], -19 ; ffffffedH
  000ce	eb 16		 jmp	 SHORT $LN1@operator@15
$LN93@operator@15:
  000d0	c6 45 f3 ea	 mov	 BYTE PTR __t$[ebp+3], -22 ; ffffffeaH
  000d4	eb 10		 jmp	 SHORT $LN1@operator@15
$LN94@operator@15:
  000d6	c6 45 f2 eb	 mov	 BYTE PTR __t$[ebp+2], -21 ; ffffffebH
  000da	eb 0a		 jmp	 SHORT $LN1@operator@15
$LN95@operator@15:
  000dc	c6 45 f1 ec	 mov	 BYTE PTR __t$[ebp+1], -20 ; ffffffecH
  000e0	eb 04		 jmp	 SHORT $LN1@operator@15
$LN96@operator@15:
  000e2	c6 45 f0 ed	 mov	 BYTE PTR __t$[ebp], -19	; ffffffedH
$LN1@operator@15:
  000e6	81 75 f0 ed ec
	eb ea		 xor	 DWORD PTR __t$[ebp], -353637139 ; eaebecedH
  000ed	6a 04		 push	 4
  000ef	c6 45 f6 00	 mov	 BYTE PTR __t$[ebp+6], 0
  000f3	58		 pop	 eax
$LL101@operator@15:
  000f4	8b c8		 mov	 ecx, eax
  000f6	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  000fc	79 05		 jns	 SHORT $LN115@operator@15
  000fe	49		 dec	 ecx
  000ff	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00102	41		 inc	 ecx
$LN115@operator@15:
  00103	b2 ed		 mov	 dl, -19			; ffffffedH
  00105	2a d1		 sub	 dl, cl
  00107	30 54 05 f0	 xor	 BYTE PTR __t$[ebp+eax], dl
  0010b	40		 inc	 eax
  0010c	83 f8 06	 cmp	 eax, 6
  0010f	7c e3		 jl	 SHORT $LL101@operator@15
  00111	8b cf		 mov	 ecx, edi
  00113	8d 75 f0	 lea	 esi, DWORD PTR __t$[ebp]
  00116	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL111@operator@15:
  0011c	8a 08		 mov	 cl, BYTE PTR [eax]
  0011e	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00120	75 1a		 jne	 SHORT $LN112@operator@15
  00122	84 c9		 test	 cl, cl
  00124	74 12		 je	 SHORT $LN113@operator@15
  00126	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00129	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  0012c	75 0e		 jne	 SHORT $LN112@operator@15
  0012e	83 c0 02	 add	 eax, 2
  00131	83 c6 02	 add	 esi, 2
  00134	84 c9		 test	 cl, cl
  00136	75 e4		 jne	 SHORT $LL111@operator@15
$LN113@operator@15:
  00138	33 c0		 xor	 eax, eax
  0013a	eb 05		 jmp	 SHORT $LN114@operator@15
$LN112@operator@15:
  0013c	1b c0		 sbb	 eax, eax
  0013e	83 d8 ff	 sbb	 eax, -1
$LN114@operator@15:
  00141	33 c9		 xor	 ecx, ecx
  00143	85 c0		 test	 eax, eax
  00145	0f 94 c0	 sete	 al

; 148  : }

  00148	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014b	5f		 pop	 edi
  0014c	33 cd		 xor	 ecx, ebp
  0014e	5e		 pop	 esi
  0014f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00154	c9		 leave
  00155	c3		 ret	 0
??$?8$06@@YA_NABVioHashString@@AAY06$$CBD@Z ENDP	; operator==<7>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$?8$0M@@@YA_NABVioHashString@@AAY0M@$$CBD@Z	; operator==<12>
; Function compile flags: /Ogsp
;	COMDAT ??$?8$0M@@@YA_NABVioHashString@@AAY0M@$$CBD@Z
_TEXT	SEGMENT
__t$ = -20						; size = 12
__$ArrayPad$ = -4					; size = 4
_lhs$ = 8						; size = 4
_t$ = 12						; size = 4
??$?8$0M@@@YA_NABVioHashString@@AAY0M@$$CBD@Z PROC	; operator==<12>, COMDAT

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]

; 147  : 	_ENCSTR(t, _t); return ( strcmp( lhs.c_str(), _t ) == 0 );

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	8b 7d 08	 mov	 edi, DWORD PTR _lhs$[ebp]
  0001a	84 d2		 test	 dl, dl
  0001c	0f 84 32 01 00
	00		 je	 $LN96@operator@16
  00022	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00025	88 55 ec	 mov	 BYTE PTR __t$[ebp], dl
  00028	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002b	84 d2		 test	 dl, dl
  0002d	0f 84 1b 01 00
	00		 je	 $LN95@operator@16
  00033	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00036	88 55 ed	 mov	 BYTE PTR __t$[ebp+1], dl
  00039	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003c	84 d2		 test	 dl, dl
  0003e	0f 84 04 01 00
	00		 je	 $LN94@operator@16
  00044	b1 eb		 mov	 cl, -21			; ffffffebH
  00046	32 d1		 xor	 dl, cl
  00048	88 55 ee	 mov	 BYTE PTR __t$[ebp+2], dl
  0004b	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004e	84 d2		 test	 dl, dl
  00050	0f 84 ec 00 00
	00		 je	 $LN93@operator@16
  00056	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00059	88 55 ef	 mov	 BYTE PTR __t$[ebp+3], dl
  0005c	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005f	84 d2		 test	 dl, dl
  00061	0f 84 d5 00 00
	00		 je	 $LN92@operator@16
  00067	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0006a	88 55 f0	 mov	 BYTE PTR __t$[ebp+4], dl
  0006d	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00070	84 d2		 test	 dl, dl
  00072	0f 84 be 00 00
	00		 je	 $LN91@operator@16
  00078	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0007b	88 55 f1	 mov	 BYTE PTR __t$[ebp+5], dl
  0007e	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00081	84 d2		 test	 dl, dl
  00083	0f 84 a8 00 00
	00		 je	 $LN90@operator@16
  00089	32 d1		 xor	 dl, cl
  0008b	88 55 f2	 mov	 BYTE PTR __t$[ebp+6], dl
  0008e	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00091	84 d2		 test	 dl, dl
  00093	0f 84 92 00 00
	00		 je	 $LN89@operator@16
  00099	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009c	88 55 f3	 mov	 BYTE PTR __t$[ebp+7], dl
  0009f	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a2	84 d2		 test	 dl, dl
  000a4	74 7f		 je	 SHORT $LN88@operator@16
  000a6	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000a9	88 55 f4	 mov	 BYTE PTR __t$[ebp+8], dl
  000ac	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000af	84 d2		 test	 dl, dl
  000b1	74 6c		 je	 SHORT $LN87@operator@16
  000b3	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000b6	88 55 f5	 mov	 BYTE PTR __t$[ebp+9], dl
  000b9	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000bc	84 d2		 test	 dl, dl
  000be	74 5a		 je	 SHORT $LN86@operator@16
  000c0	32 d1		 xor	 dl, cl
  000c2	80 78 0b 00	 cmp	 BYTE PTR [eax+11], 0
  000c6	88 55 f6	 mov	 BYTE PTR __t$[ebp+10], dl
  000c9	0f 84 89 00 00
	00		 je	 $LN1@operator@16
  000cf	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000d2	84 d2		 test	 dl, dl
  000d4	74 3e		 je	 SHORT $LN84@operator@16
  000d6	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000d9	88 55 f8	 mov	 BYTE PTR __t$[ebp+12], dl
  000dc	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000df	84 d2		 test	 dl, dl
  000e1	74 2b		 je	 SHORT $LN83@operator@16
  000e3	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000e6	88 55 f9	 mov	 BYTE PTR __t$[ebp+13], dl
  000e9	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  000ec	84 d2		 test	 dl, dl
  000ee	74 19		 je	 SHORT $LN82@operator@16
  000f0	8a 40 0f	 mov	 al, BYTE PTR [eax+15]
  000f3	32 d1		 xor	 dl, cl
  000f5	88 55 fa	 mov	 BYTE PTR __t$[ebp+14], dl
  000f8	84 c0		 test	 al, al
  000fa	74 07		 je	 SHORT $LN81@operator@16
  000fc	34 ea		 xor	 al, -22			; ffffffeaH
  000fe	88 45 fb	 mov	 BYTE PTR __t$[ebp+15], al
  00101	eb 55		 jmp	 SHORT $LN1@operator@16
$LN81@operator@16:
  00103	c6 45 fb ea	 mov	 BYTE PTR __t$[ebp+15], -22 ; ffffffeaH
  00107	eb 4f		 jmp	 SHORT $LN1@operator@16
$LN82@operator@16:
  00109	88 4d fa	 mov	 BYTE PTR __t$[ebp+14], cl
  0010c	eb 4a		 jmp	 SHORT $LN1@operator@16
$LN83@operator@16:
  0010e	c6 45 f9 ec	 mov	 BYTE PTR __t$[ebp+13], -20 ; ffffffecH
  00112	eb 44		 jmp	 SHORT $LN1@operator@16
$LN84@operator@16:
  00114	c6 45 f8 ed	 mov	 BYTE PTR __t$[ebp+12], -19 ; ffffffedH
  00118	eb 3e		 jmp	 SHORT $LN1@operator@16
$LN86@operator@16:
  0011a	88 4d f6	 mov	 BYTE PTR __t$[ebp+10], cl
  0011d	eb 39		 jmp	 SHORT $LN1@operator@16
$LN87@operator@16:
  0011f	c6 45 f5 ec	 mov	 BYTE PTR __t$[ebp+9], -20 ; ffffffecH
  00123	eb 33		 jmp	 SHORT $LN1@operator@16
$LN88@operator@16:
  00125	c6 45 f4 ed	 mov	 BYTE PTR __t$[ebp+8], -19 ; ffffffedH
  00129	eb 2d		 jmp	 SHORT $LN1@operator@16
$LN89@operator@16:
  0012b	c6 45 f3 ea	 mov	 BYTE PTR __t$[ebp+7], -22 ; ffffffeaH
  0012f	eb 27		 jmp	 SHORT $LN1@operator@16
$LN90@operator@16:
  00131	88 4d f2	 mov	 BYTE PTR __t$[ebp+6], cl
  00134	eb 22		 jmp	 SHORT $LN1@operator@16
$LN91@operator@16:
  00136	c6 45 f1 ec	 mov	 BYTE PTR __t$[ebp+5], -20 ; ffffffecH
  0013a	eb 1c		 jmp	 SHORT $LN1@operator@16
$LN92@operator@16:
  0013c	c6 45 f0 ed	 mov	 BYTE PTR __t$[ebp+4], -19 ; ffffffedH
  00140	eb 16		 jmp	 SHORT $LN1@operator@16
$LN93@operator@16:
  00142	c6 45 ef ea	 mov	 BYTE PTR __t$[ebp+3], -22 ; ffffffeaH
  00146	eb 10		 jmp	 SHORT $LN1@operator@16
$LN94@operator@16:
  00148	c6 45 ee eb	 mov	 BYTE PTR __t$[ebp+2], -21 ; ffffffebH
  0014c	eb 0a		 jmp	 SHORT $LN1@operator@16
$LN95@operator@16:
  0014e	c6 45 ed ec	 mov	 BYTE PTR __t$[ebp+1], -20 ; ffffffecH
  00152	eb 04		 jmp	 SHORT $LN1@operator@16
$LN96@operator@16:
  00154	c6 45 ec ed	 mov	 BYTE PTR __t$[ebp], -19	; ffffffedH
$LN1@operator@16:
  00158	6a 02		 push	 2
  0015a	8d 45 ec	 lea	 eax, DWORD PTR __t$[ebp]
  0015d	c6 45 f7 00	 mov	 BYTE PTR __t$[ebp+11], 0
  00161	5a		 pop	 edx
$LL104@operator@16:
  00162	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00168	83 c0 04	 add	 eax, 4
  0016b	4a		 dec	 edx
  0016c	75 f4		 jne	 SHORT $LL104@operator@16
  0016e	6a 08		 push	 8
  00170	58		 pop	 eax
$LL101@operator@16:
  00171	8b c8		 mov	 ecx, eax
  00173	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00179	79 05		 jns	 SHORT $LN115@operator@16
  0017b	49		 dec	 ecx
  0017c	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0017f	41		 inc	 ecx
$LN115@operator@16:
  00180	b2 ed		 mov	 dl, -19			; ffffffedH
  00182	2a d1		 sub	 dl, cl
  00184	30 54 05 ec	 xor	 BYTE PTR __t$[ebp+eax], dl
  00188	40		 inc	 eax
  00189	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0018c	7c e3		 jl	 SHORT $LL101@operator@16
  0018e	8b cf		 mov	 ecx, edi
  00190	8d 75 ec	 lea	 esi, DWORD PTR __t$[ebp]
  00193	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL111@operator@16:
  00199	8a 08		 mov	 cl, BYTE PTR [eax]
  0019b	3a 0e		 cmp	 cl, BYTE PTR [esi]
  0019d	75 1a		 jne	 SHORT $LN112@operator@16
  0019f	84 c9		 test	 cl, cl
  001a1	74 12		 je	 SHORT $LN113@operator@16
  001a3	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  001a6	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  001a9	75 0e		 jne	 SHORT $LN112@operator@16
  001ab	83 c0 02	 add	 eax, 2
  001ae	83 c6 02	 add	 esi, 2
  001b1	84 c9		 test	 cl, cl
  001b3	75 e4		 jne	 SHORT $LL111@operator@16
$LN113@operator@16:
  001b5	33 c0		 xor	 eax, eax
  001b7	eb 05		 jmp	 SHORT $LN114@operator@16
$LN112@operator@16:
  001b9	1b c0		 sbb	 eax, eax
  001bb	83 d8 ff	 sbb	 eax, -1
$LN114@operator@16:
  001be	33 c9		 xor	 ecx, ecx
  001c0	85 c0		 test	 eax, eax
  001c2	0f 94 c0	 sete	 al

; 148  : }

  001c5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c8	5f		 pop	 edi
  001c9	33 cd		 xor	 ecx, ebp
  001cb	5e		 pop	 esi
  001cc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d1	c9		 leave
  001d2	c3		 ret	 0
??$?8$0M@@@YA_NABVioHashString@@AAY0M@$$CBD@Z ENDP	; operator==<12>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$GetIntAttribute_e@$07@ioXMLElement@@QBEHAAY07$$CBD@Z ; ioXMLElement::GetIntAttribute_e<8>
EXTRN	__imp_?GetIntAttribute@ioXMLElement@@QBEHPBD@Z:PROC
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\io3dengine\ioxmlelement.h
;	COMDAT ??$GetIntAttribute_e@$07@ioXMLElement@@QBEHAAY07$$CBD@Z
_TEXT	SEGMENT
__k$ = -16						; size = 8
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
??$GetIntAttribute_e@$07@ioXMLElement@@QBEHAAY07$$CBD@Z PROC ; ioXMLElement::GetIntAttribute_e<8>, COMDAT
; _this$ = ecx

; 86   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 87   : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	84 d2		 test	 dl, dl
  0001a	0f 84 d7 00 00
	00		 je	 $LN96@GetIntAttr
  00020	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00023	88 55 f0	 mov	 BYTE PTR __k$[ebp], dl
  00026	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00029	84 d2		 test	 dl, dl
  0002b	0f 84 c0 00 00
	00		 je	 $LN95@GetIntAttr
  00031	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00034	88 55 f1	 mov	 BYTE PTR __k$[ebp+1], dl
  00037	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003a	84 d2		 test	 dl, dl
  0003c	0f 84 a9 00 00
	00		 je	 $LN94@GetIntAttr
  00042	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00045	88 55 f2	 mov	 BYTE PTR __k$[ebp+2], dl
  00048	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004b	84 d2		 test	 dl, dl
  0004d	0f 84 92 00 00
	00		 je	 $LN93@GetIntAttr
  00053	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00056	88 55 f3	 mov	 BYTE PTR __k$[ebp+3], dl
  00059	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005c	84 d2		 test	 dl, dl
  0005e	74 7f		 je	 SHORT $LN92@GetIntAttr
  00060	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00063	88 55 f4	 mov	 BYTE PTR __k$[ebp+4], dl
  00066	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00069	84 d2		 test	 dl, dl
  0006b	74 6c		 je	 SHORT $LN91@GetIntAttr
  0006d	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00070	88 55 f5	 mov	 BYTE PTR __k$[ebp+5], dl
  00073	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00076	84 d2		 test	 dl, dl
  00078	74 59		 je	 SHORT $LN90@GetIntAttr
  0007a	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0007d	80 78 07 00	 cmp	 BYTE PTR [eax+7], 0
  00081	88 55 f6	 mov	 BYTE PTR __k$[ebp+6], dl
  00084	74 75		 je	 SHORT $LN1@GetIntAttr
  00086	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  00089	84 d2		 test	 dl, dl
  0008b	74 40		 je	 SHORT $LN88@GetIntAttr
  0008d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00090	88 55 f8	 mov	 BYTE PTR __k$[ebp+8], dl
  00093	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  00096	84 d2		 test	 dl, dl
  00098	74 2d		 je	 SHORT $LN87@GetIntAttr
  0009a	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0009d	88 55 f9	 mov	 BYTE PTR __k$[ebp+9], dl
  000a0	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000a3	84 d2		 test	 dl, dl
  000a5	74 1a		 je	 SHORT $LN86@GetIntAttr
  000a7	8a 40 0b	 mov	 al, BYTE PTR [eax+11]
  000aa	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000ad	88 55 fa	 mov	 BYTE PTR __k$[ebp+10], dl
  000b0	84 c0		 test	 al, al
  000b2	74 07		 je	 SHORT $LN85@GetIntAttr
  000b4	34 ea		 xor	 al, -22			; ffffffeaH
  000b6	88 45 fb	 mov	 BYTE PTR __k$[ebp+11], al
  000b9	eb 40		 jmp	 SHORT $LN1@GetIntAttr
$LN85@GetIntAttr:
  000bb	c6 45 fb ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  000bf	eb 3a		 jmp	 SHORT $LN1@GetIntAttr
$LN86@GetIntAttr:
  000c1	c6 45 fa eb	 mov	 BYTE PTR __k$[ebp+10], -21 ; ffffffebH
  000c5	eb 34		 jmp	 SHORT $LN1@GetIntAttr
$LN87@GetIntAttr:
  000c7	c6 45 f9 ec	 mov	 BYTE PTR __k$[ebp+9], -20 ; ffffffecH
  000cb	eb 2e		 jmp	 SHORT $LN1@GetIntAttr
$LN88@GetIntAttr:
  000cd	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  000d1	eb 28		 jmp	 SHORT $LN1@GetIntAttr
$LN90@GetIntAttr:
  000d3	c6 45 f6 eb	 mov	 BYTE PTR __k$[ebp+6], -21 ; ffffffebH
  000d7	eb 22		 jmp	 SHORT $LN1@GetIntAttr
$LN91@GetIntAttr:
  000d9	c6 45 f5 ec	 mov	 BYTE PTR __k$[ebp+5], -20 ; ffffffecH
  000dd	eb 1c		 jmp	 SHORT $LN1@GetIntAttr
$LN92@GetIntAttr:
  000df	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  000e3	eb 16		 jmp	 SHORT $LN1@GetIntAttr
$LN93@GetIntAttr:
  000e5	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  000e9	eb 10		 jmp	 SHORT $LN1@GetIntAttr
$LN94@GetIntAttr:
  000eb	c6 45 f2 eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  000ef	eb 0a		 jmp	 SHORT $LN1@GetIntAttr
$LN95@GetIntAttr:
  000f1	c6 45 f1 ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  000f5	eb 04		 jmp	 SHORT $LN1@GetIntAttr
$LN96@GetIntAttr:
  000f7	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@GetIntAttr:
  000fb	81 75 f0 ed ec
	eb ea		 xor	 DWORD PTR __k$[ebp], -353637139 ; eaebecedH
  00102	6a 04		 push	 4
  00104	c6 45 f7 00	 mov	 BYTE PTR __k$[ebp+7], 0
  00108	58		 pop	 eax
$LL101@GetIntAttr:
  00109	8b c8		 mov	 ecx, eax
  0010b	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00111	79 05		 jns	 SHORT $LN111@GetIntAttr
  00113	49		 dec	 ecx
  00114	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00117	41		 inc	 ecx
$LN111@GetIntAttr:
  00118	b2 ed		 mov	 dl, -19			; ffffffedH
  0011a	2a d1		 sub	 dl, cl
  0011c	30 54 05 f0	 xor	 BYTE PTR __k$[ebp+eax], dl
  00120	40		 inc	 eax
  00121	83 f8 07	 cmp	 eax, 7
  00124	7c e3		 jl	 SHORT $LL101@GetIntAttr

; 88   : 		return GetIntAttribute(_k);

  00126	8d 45 f0	 lea	 eax, DWORD PTR __k$[ebp]
  00129	50		 push	 eax
  0012a	8b ce		 mov	 ecx, esi
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetIntAttribute@ioXMLElement@@QBEHPBD@Z

; 89   : 	}

  00132	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00135	33 cd		 xor	 ecx, ebp
  00137	5e		 pop	 esi
  00138	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013d	c9		 leave
  0013e	c2 04 00	 ret	 4
??$GetIntAttribute_e@$07@ioXMLElement@@QBEHAAY07$$CBD@Z ENDP ; ioXMLElement::GetIntAttribute_e<8>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$GetIntAttribute_e@$0L@@ioXMLElement@@QBEHAAY0L@$$CBD@Z ; ioXMLElement::GetIntAttribute_e<11>
; Function compile flags: /Ogsp
;	COMDAT ??$GetIntAttribute_e@$0L@@ioXMLElement@@QBEHAAY0L@$$CBD@Z
_TEXT	SEGMENT
__k$ = -20						; size = 11
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
??$GetIntAttribute_e@$0L@@ioXMLElement@@QBEHAAY0L@$$CBD@Z PROC ; ioXMLElement::GetIntAttribute_e<11>, COMDAT
; _this$ = ecx

; 86   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 87   : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	84 d2		 test	 dl, dl
  0001a	0f 84 24 01 00
	00		 je	 $LN96@GetIntAttr@2
  00020	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00023	88 55 ec	 mov	 BYTE PTR __k$[ebp], dl
  00026	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00029	84 d2		 test	 dl, dl
  0002b	0f 84 0d 01 00
	00		 je	 $LN95@GetIntAttr@2
  00031	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00034	88 55 ed	 mov	 BYTE PTR __k$[ebp+1], dl
  00037	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003a	84 d2		 test	 dl, dl
  0003c	0f 84 f6 00 00
	00		 je	 $LN94@GetIntAttr@2
  00042	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00045	88 55 ee	 mov	 BYTE PTR __k$[ebp+2], dl
  00048	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004b	84 d2		 test	 dl, dl
  0004d	0f 84 df 00 00
	00		 je	 $LN93@GetIntAttr@2
  00053	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00056	88 55 ef	 mov	 BYTE PTR __k$[ebp+3], dl
  00059	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005c	84 d2		 test	 dl, dl
  0005e	0f 84 c8 00 00
	00		 je	 $LN92@GetIntAttr@2
  00064	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00067	88 55 f0	 mov	 BYTE PTR __k$[ebp+4], dl
  0006a	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006d	84 d2		 test	 dl, dl
  0006f	0f 84 b1 00 00
	00		 je	 $LN91@GetIntAttr@2
  00075	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00078	88 55 f1	 mov	 BYTE PTR __k$[ebp+5], dl
  0007b	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0007e	84 d2		 test	 dl, dl
  00080	0f 84 9a 00 00
	00		 je	 $LN90@GetIntAttr@2
  00086	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00089	88 55 f2	 mov	 BYTE PTR __k$[ebp+6], dl
  0008c	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0008f	84 d2		 test	 dl, dl
  00091	0f 84 83 00 00
	00		 je	 $LN89@GetIntAttr@2
  00097	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009a	88 55 f3	 mov	 BYTE PTR __k$[ebp+7], dl
  0009d	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a0	84 d2		 test	 dl, dl
  000a2	74 70		 je	 SHORT $LN88@GetIntAttr@2
  000a4	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000a7	88 55 f4	 mov	 BYTE PTR __k$[ebp+8], dl
  000aa	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000ad	84 d2		 test	 dl, dl
  000af	74 5d		 je	 SHORT $LN87@GetIntAttr@2
  000b1	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000b4	80 78 0a 00	 cmp	 BYTE PTR [eax+10], 0
  000b8	88 55 f5	 mov	 BYTE PTR __k$[ebp+9], dl
  000bb	0f 84 87 00 00
	00		 je	 $LN1@GetIntAttr@2
  000c1	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000c4	84 d2		 test	 dl, dl
  000c6	74 40		 je	 SHORT $LN85@GetIntAttr@2
  000c8	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000cb	88 55 f7	 mov	 BYTE PTR __k$[ebp+11], dl
  000ce	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000d1	84 d2		 test	 dl, dl
  000d3	74 2d		 je	 SHORT $LN84@GetIntAttr@2
  000d5	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000d8	88 55 f8	 mov	 BYTE PTR __k$[ebp+12], dl
  000db	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000de	84 d2		 test	 dl, dl
  000e0	74 1a		 je	 SHORT $LN83@GetIntAttr@2
  000e2	8a 40 0e	 mov	 al, BYTE PTR [eax+14]
  000e5	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000e8	88 55 f9	 mov	 BYTE PTR __k$[ebp+13], dl
  000eb	84 c0		 test	 al, al
  000ed	74 07		 je	 SHORT $LN82@GetIntAttr@2
  000ef	34 eb		 xor	 al, -21			; ffffffebH
  000f1	88 45 fa	 mov	 BYTE PTR __k$[ebp+14], al
  000f4	eb 52		 jmp	 SHORT $LN1@GetIntAttr@2
$LN82@GetIntAttr@2:
  000f6	c6 45 fa eb	 mov	 BYTE PTR __k$[ebp+14], -21 ; ffffffebH
  000fa	eb 4c		 jmp	 SHORT $LN1@GetIntAttr@2
$LN83@GetIntAttr@2:
  000fc	c6 45 f9 ec	 mov	 BYTE PTR __k$[ebp+13], -20 ; ffffffecH
  00100	eb 46		 jmp	 SHORT $LN1@GetIntAttr@2
$LN84@GetIntAttr@2:
  00102	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  00106	eb 40		 jmp	 SHORT $LN1@GetIntAttr@2
$LN85@GetIntAttr@2:
  00108	c6 45 f7 ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  0010c	eb 3a		 jmp	 SHORT $LN1@GetIntAttr@2
$LN87@GetIntAttr@2:
  0010e	c6 45 f5 ec	 mov	 BYTE PTR __k$[ebp+9], -20 ; ffffffecH
  00112	eb 34		 jmp	 SHORT $LN1@GetIntAttr@2
$LN88@GetIntAttr@2:
  00114	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  00118	eb 2e		 jmp	 SHORT $LN1@GetIntAttr@2
$LN89@GetIntAttr@2:
  0011a	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  0011e	eb 28		 jmp	 SHORT $LN1@GetIntAttr@2
$LN90@GetIntAttr@2:
  00120	c6 45 f2 eb	 mov	 BYTE PTR __k$[ebp+6], -21 ; ffffffebH
  00124	eb 22		 jmp	 SHORT $LN1@GetIntAttr@2
$LN91@GetIntAttr@2:
  00126	c6 45 f1 ec	 mov	 BYTE PTR __k$[ebp+5], -20 ; ffffffecH
  0012a	eb 1c		 jmp	 SHORT $LN1@GetIntAttr@2
$LN92@GetIntAttr@2:
  0012c	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  00130	eb 16		 jmp	 SHORT $LN1@GetIntAttr@2
$LN93@GetIntAttr@2:
  00132	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  00136	eb 10		 jmp	 SHORT $LN1@GetIntAttr@2
$LN94@GetIntAttr@2:
  00138	c6 45 ee eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  0013c	eb 0a		 jmp	 SHORT $LN1@GetIntAttr@2
$LN95@GetIntAttr@2:
  0013e	c6 45 ed ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  00142	eb 04		 jmp	 SHORT $LN1@GetIntAttr@2
$LN96@GetIntAttr@2:
  00144	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@GetIntAttr@2:
  00148	6a 02		 push	 2
  0014a	8d 45 ec	 lea	 eax, DWORD PTR __k$[ebp]
  0014d	c6 45 f6 00	 mov	 BYTE PTR __k$[ebp+10], 0
  00151	5a		 pop	 edx
$LL104@GetIntAttr@2:
  00152	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00158	83 c0 04	 add	 eax, 4
  0015b	4a		 dec	 edx
  0015c	75 f4		 jne	 SHORT $LL104@GetIntAttr@2
  0015e	6a 08		 push	 8
  00160	58		 pop	 eax
$LL101@GetIntAttr@2:
  00161	8b c8		 mov	 ecx, eax
  00163	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00169	79 05		 jns	 SHORT $LN111@GetIntAttr@2
  0016b	49		 dec	 ecx
  0016c	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0016f	41		 inc	 ecx
$LN111@GetIntAttr@2:
  00170	b2 ed		 mov	 dl, -19			; ffffffedH
  00172	2a d1		 sub	 dl, cl
  00174	30 54 05 ec	 xor	 BYTE PTR __k$[ebp+eax], dl
  00178	40		 inc	 eax
  00179	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0017c	7c e3		 jl	 SHORT $LL101@GetIntAttr@2

; 88   : 		return GetIntAttribute(_k);

  0017e	8d 45 ec	 lea	 eax, DWORD PTR __k$[ebp]
  00181	50		 push	 eax
  00182	8b ce		 mov	 ecx, esi
  00184	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetIntAttribute@ioXMLElement@@QBEHPBD@Z

; 89   : 	}

  0018a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018d	33 cd		 xor	 ecx, ebp
  0018f	5e		 pop	 esi
  00190	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00195	c9		 leave
  00196	c2 04 00	 ret	 4
??$GetIntAttribute_e@$0L@@ioXMLElement@@QBEHAAY0L@$$CBD@Z ENDP ; ioXMLElement::GetIntAttribute_e<11>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$GetIntAttribute_e@$0O@@ioXMLElement@@QBEHAAY0O@$$CBD@Z ; ioXMLElement::GetIntAttribute_e<14>
; Function compile flags: /Ogsp
;	COMDAT ??$GetIntAttribute_e@$0O@@ioXMLElement@@QBEHAAY0O@$$CBD@Z
_TEXT	SEGMENT
__k$ = -24						; size = 14
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
??$GetIntAttribute_e@$0O@@ioXMLElement@@QBEHAAY0O@$$CBD@Z PROC ; ioXMLElement::GetIntAttribute_e<14>, COMDAT
; _this$ = ecx

; 86   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 87   : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	84 d2		 test	 dl, dl
  0001a	0f 84 64 01 00
	00		 je	 $LN96@GetIntAttr@3
  00020	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00023	88 55 e8	 mov	 BYTE PTR __k$[ebp], dl
  00026	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00029	84 d2		 test	 dl, dl
  0002b	0f 84 4d 01 00
	00		 je	 $LN95@GetIntAttr@3
  00031	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00034	88 55 e9	 mov	 BYTE PTR __k$[ebp+1], dl
  00037	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003a	84 d2		 test	 dl, dl
  0003c	0f 84 36 01 00
	00		 je	 $LN94@GetIntAttr@3
  00042	b1 eb		 mov	 cl, -21			; ffffffebH
  00044	32 d1		 xor	 dl, cl
  00046	88 55 ea	 mov	 BYTE PTR __k$[ebp+2], dl
  00049	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004c	84 d2		 test	 dl, dl
  0004e	0f 84 1e 01 00
	00		 je	 $LN93@GetIntAttr@3
  00054	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00057	88 55 eb	 mov	 BYTE PTR __k$[ebp+3], dl
  0005a	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005d	84 d2		 test	 dl, dl
  0005f	0f 84 07 01 00
	00		 je	 $LN92@GetIntAttr@3
  00065	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00068	88 55 ec	 mov	 BYTE PTR __k$[ebp+4], dl
  0006b	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006e	84 d2		 test	 dl, dl
  00070	0f 84 f0 00 00
	00		 je	 $LN91@GetIntAttr@3
  00076	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00079	88 55 ed	 mov	 BYTE PTR __k$[ebp+5], dl
  0007c	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0007f	84 d2		 test	 dl, dl
  00081	0f 84 da 00 00
	00		 je	 $LN90@GetIntAttr@3
  00087	32 d1		 xor	 dl, cl
  00089	88 55 ee	 mov	 BYTE PTR __k$[ebp+6], dl
  0008c	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0008f	84 d2		 test	 dl, dl
  00091	0f 84 c4 00 00
	00		 je	 $LN89@GetIntAttr@3
  00097	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009a	88 55 ef	 mov	 BYTE PTR __k$[ebp+7], dl
  0009d	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a0	84 d2		 test	 dl, dl
  000a2	0f 84 ad 00 00
	00		 je	 $LN88@GetIntAttr@3
  000a8	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ab	88 55 f0	 mov	 BYTE PTR __k$[ebp+8], dl
  000ae	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b1	84 d2		 test	 dl, dl
  000b3	0f 84 96 00 00
	00		 je	 $LN87@GetIntAttr@3
  000b9	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000bc	88 55 f1	 mov	 BYTE PTR __k$[ebp+9], dl
  000bf	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c2	84 d2		 test	 dl, dl
  000c4	0f 84 80 00 00
	00		 je	 $LN86@GetIntAttr@3
  000ca	32 d1		 xor	 dl, cl
  000cc	88 55 f2	 mov	 BYTE PTR __k$[ebp+10], dl
  000cf	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000d2	84 d2		 test	 dl, dl
  000d4	74 6e		 je	 SHORT $LN85@GetIntAttr@3
  000d6	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000d9	88 55 f3	 mov	 BYTE PTR __k$[ebp+11], dl
  000dc	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000df	84 d2		 test	 dl, dl
  000e1	74 5b		 je	 SHORT $LN84@GetIntAttr@3
  000e3	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000e6	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000ea	88 55 f4	 mov	 BYTE PTR __k$[ebp+12], dl
  000ed	0f 84 95 00 00
	00		 je	 $LN1@GetIntAttr@3
  000f3	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  000f6	84 d2		 test	 dl, dl
  000f8	74 3f		 je	 SHORT $LN82@GetIntAttr@3
  000fa	32 d1		 xor	 dl, cl
  000fc	88 55 f6	 mov	 BYTE PTR __k$[ebp+14], dl
  000ff	8a 50 0f	 mov	 dl, BYTE PTR [eax+15]
  00102	84 d2		 test	 dl, dl
  00104	74 2d		 je	 SHORT $LN81@GetIntAttr@3
  00106	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00109	88 55 f7	 mov	 BYTE PTR __k$[ebp+15], dl
  0010c	8a 50 10	 mov	 dl, BYTE PTR [eax+16]
  0010f	84 d2		 test	 dl, dl
  00111	74 1a		 je	 SHORT $LN80@GetIntAttr@3
  00113	8a 40 11	 mov	 al, BYTE PTR [eax+17]
  00116	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00119	88 55 f8	 mov	 BYTE PTR __k$[ebp+16], dl
  0011c	84 c0		 test	 al, al
  0011e	74 07		 je	 SHORT $LN79@GetIntAttr@3
  00120	34 ec		 xor	 al, -20			; ffffffecH
  00122	88 45 f9	 mov	 BYTE PTR __k$[ebp+17], al
  00125	eb 61		 jmp	 SHORT $LN1@GetIntAttr@3
$LN79@GetIntAttr@3:
  00127	c6 45 f9 ec	 mov	 BYTE PTR __k$[ebp+17], -20 ; ffffffecH
  0012b	eb 5b		 jmp	 SHORT $LN1@GetIntAttr@3
$LN80@GetIntAttr@3:
  0012d	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+16], -19 ; ffffffedH
  00131	eb 55		 jmp	 SHORT $LN1@GetIntAttr@3
$LN81@GetIntAttr@3:
  00133	c6 45 f7 ea	 mov	 BYTE PTR __k$[ebp+15], -22 ; ffffffeaH
  00137	eb 4f		 jmp	 SHORT $LN1@GetIntAttr@3
$LN82@GetIntAttr@3:
  00139	88 4d f6	 mov	 BYTE PTR __k$[ebp+14], cl
  0013c	eb 4a		 jmp	 SHORT $LN1@GetIntAttr@3
$LN84@GetIntAttr@3:
  0013e	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  00142	eb 44		 jmp	 SHORT $LN1@GetIntAttr@3
$LN85@GetIntAttr@3:
  00144	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  00148	eb 3e		 jmp	 SHORT $LN1@GetIntAttr@3
$LN86@GetIntAttr@3:
  0014a	88 4d f2	 mov	 BYTE PTR __k$[ebp+10], cl
  0014d	eb 39		 jmp	 SHORT $LN1@GetIntAttr@3
$LN87@GetIntAttr@3:
  0014f	c6 45 f1 ec	 mov	 BYTE PTR __k$[ebp+9], -20 ; ffffffecH
  00153	eb 33		 jmp	 SHORT $LN1@GetIntAttr@3
$LN88@GetIntAttr@3:
  00155	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  00159	eb 2d		 jmp	 SHORT $LN1@GetIntAttr@3
$LN89@GetIntAttr@3:
  0015b	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  0015f	eb 27		 jmp	 SHORT $LN1@GetIntAttr@3
$LN90@GetIntAttr@3:
  00161	88 4d ee	 mov	 BYTE PTR __k$[ebp+6], cl
  00164	eb 22		 jmp	 SHORT $LN1@GetIntAttr@3
$LN91@GetIntAttr@3:
  00166	c6 45 ed ec	 mov	 BYTE PTR __k$[ebp+5], -20 ; ffffffecH
  0016a	eb 1c		 jmp	 SHORT $LN1@GetIntAttr@3
$LN92@GetIntAttr@3:
  0016c	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  00170	eb 16		 jmp	 SHORT $LN1@GetIntAttr@3
$LN93@GetIntAttr@3:
  00172	c6 45 eb ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  00176	eb 10		 jmp	 SHORT $LN1@GetIntAttr@3
$LN94@GetIntAttr@3:
  00178	c6 45 ea eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  0017c	eb 0a		 jmp	 SHORT $LN1@GetIntAttr@3
$LN95@GetIntAttr@3:
  0017e	c6 45 e9 ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  00182	eb 04		 jmp	 SHORT $LN1@GetIntAttr@3
$LN96@GetIntAttr@3:
  00184	c6 45 e8 ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@GetIntAttr@3:
  00188	6a 03		 push	 3
  0018a	8d 45 e8	 lea	 eax, DWORD PTR __k$[ebp]
  0018d	c6 45 f5 00	 mov	 BYTE PTR __k$[ebp+13], 0
  00191	5a		 pop	 edx
$LL104@GetIntAttr@3:
  00192	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00198	83 c0 04	 add	 eax, 4
  0019b	4a		 dec	 edx
  0019c	75 f4		 jne	 SHORT $LL104@GetIntAttr@3
  0019e	80 75 f4 ed	 xor	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH

; 88   : 		return GetIntAttribute(_k);

  001a2	8d 45 e8	 lea	 eax, DWORD PTR __k$[ebp]
  001a5	50		 push	 eax
  001a6	8b ce		 mov	 ecx, esi
  001a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetIntAttribute@ioXMLElement@@QBEHPBD@Z

; 89   : 	}

  001ae	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b1	33 cd		 xor	 ecx, ebp
  001b3	5e		 pop	 esi
  001b4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b9	c9		 leave
  001ba	c2 04 00	 ret	 4
??$GetIntAttribute_e@$0O@@ioXMLElement@@QBEHAAY0O@$$CBD@Z ENDP ; ioXMLElement::GetIntAttribute_e<14>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$GetIntAttribute_e@$09@ioXMLElement@@QBEHAAY09$$CBD@Z ; ioXMLElement::GetIntAttribute_e<10>
; Function compile flags: /Ogsp
;	COMDAT ??$GetIntAttribute_e@$09@ioXMLElement@@QBEHAAY09$$CBD@Z
_TEXT	SEGMENT
__k$ = -20						; size = 10
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
??$GetIntAttribute_e@$09@ioXMLElement@@QBEHAAY09$$CBD@Z PROC ; ioXMLElement::GetIntAttribute_e<10>, COMDAT
; _this$ = ecx

; 86   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 87   : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	84 d2		 test	 dl, dl
  00017	0f 84 0d 01 00
	00		 je	 $LN96@GetIntAttr@4
  0001d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00020	88 55 ec	 mov	 BYTE PTR __k$[ebp], dl
  00023	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00026	84 d2		 test	 dl, dl
  00028	0f 84 f6 00 00
	00		 je	 $LN95@GetIntAttr@4
  0002e	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00031	88 55 ed	 mov	 BYTE PTR __k$[ebp+1], dl
  00034	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  00037	84 d2		 test	 dl, dl
  00039	0f 84 df 00 00
	00		 je	 $LN94@GetIntAttr@4
  0003f	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00042	88 55 ee	 mov	 BYTE PTR __k$[ebp+2], dl
  00045	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  00048	84 d2		 test	 dl, dl
  0004a	0f 84 c8 00 00
	00		 je	 $LN93@GetIntAttr@4
  00050	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00053	88 55 ef	 mov	 BYTE PTR __k$[ebp+3], dl
  00056	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  00059	84 d2		 test	 dl, dl
  0005b	0f 84 b1 00 00
	00		 je	 $LN92@GetIntAttr@4
  00061	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00064	88 55 f0	 mov	 BYTE PTR __k$[ebp+4], dl
  00067	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006a	84 d2		 test	 dl, dl
  0006c	0f 84 9a 00 00
	00		 je	 $LN91@GetIntAttr@4
  00072	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00075	88 55 f1	 mov	 BYTE PTR __k$[ebp+5], dl
  00078	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0007b	84 d2		 test	 dl, dl
  0007d	0f 84 83 00 00
	00		 je	 $LN90@GetIntAttr@4
  00083	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00086	88 55 f2	 mov	 BYTE PTR __k$[ebp+6], dl
  00089	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0008c	84 d2		 test	 dl, dl
  0008e	74 70		 je	 SHORT $LN89@GetIntAttr@4
  00090	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00093	88 55 f3	 mov	 BYTE PTR __k$[ebp+7], dl
  00096	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  00099	84 d2		 test	 dl, dl
  0009b	74 5d		 je	 SHORT $LN88@GetIntAttr@4
  0009d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000a0	80 78 09 00	 cmp	 BYTE PTR [eax+9], 0
  000a4	88 55 f4	 mov	 BYTE PTR __k$[ebp+8], dl
  000a7	0f 84 81 00 00
	00		 je	 $LN1@GetIntAttr@4
  000ad	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000b0	84 d2		 test	 dl, dl
  000b2	74 40		 je	 SHORT $LN86@GetIntAttr@4
  000b4	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000b7	88 55 f6	 mov	 BYTE PTR __k$[ebp+10], dl
  000ba	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000bd	84 d2		 test	 dl, dl
  000bf	74 2d		 je	 SHORT $LN85@GetIntAttr@4
  000c1	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000c4	88 55 f7	 mov	 BYTE PTR __k$[ebp+11], dl
  000c7	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000ca	84 d2		 test	 dl, dl
  000cc	74 1a		 je	 SHORT $LN84@GetIntAttr@4
  000ce	8a 40 0d	 mov	 al, BYTE PTR [eax+13]
  000d1	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000d4	88 55 f8	 mov	 BYTE PTR __k$[ebp+12], dl
  000d7	84 c0		 test	 al, al
  000d9	74 07		 je	 SHORT $LN83@GetIntAttr@4
  000db	34 ec		 xor	 al, -20			; ffffffecH
  000dd	88 45 f9	 mov	 BYTE PTR __k$[ebp+13], al
  000e0	eb 4c		 jmp	 SHORT $LN1@GetIntAttr@4
$LN83@GetIntAttr@4:
  000e2	c6 45 f9 ec	 mov	 BYTE PTR __k$[ebp+13], -20 ; ffffffecH
  000e6	eb 46		 jmp	 SHORT $LN1@GetIntAttr@4
$LN84@GetIntAttr@4:
  000e8	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  000ec	eb 40		 jmp	 SHORT $LN1@GetIntAttr@4
$LN85@GetIntAttr@4:
  000ee	c6 45 f7 ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  000f2	eb 3a		 jmp	 SHORT $LN1@GetIntAttr@4
$LN86@GetIntAttr@4:
  000f4	c6 45 f6 eb	 mov	 BYTE PTR __k$[ebp+10], -21 ; ffffffebH
  000f8	eb 34		 jmp	 SHORT $LN1@GetIntAttr@4
$LN88@GetIntAttr@4:
  000fa	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  000fe	eb 2e		 jmp	 SHORT $LN1@GetIntAttr@4
$LN89@GetIntAttr@4:
  00100	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  00104	eb 28		 jmp	 SHORT $LN1@GetIntAttr@4
$LN90@GetIntAttr@4:
  00106	c6 45 f2 eb	 mov	 BYTE PTR __k$[ebp+6], -21 ; ffffffebH
  0010a	eb 22		 jmp	 SHORT $LN1@GetIntAttr@4
$LN91@GetIntAttr@4:
  0010c	c6 45 f1 ec	 mov	 BYTE PTR __k$[ebp+5], -20 ; ffffffecH
  00110	eb 1c		 jmp	 SHORT $LN1@GetIntAttr@4
$LN92@GetIntAttr@4:
  00112	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  00116	eb 16		 jmp	 SHORT $LN1@GetIntAttr@4
$LN93@GetIntAttr@4:
  00118	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  0011c	eb 10		 jmp	 SHORT $LN1@GetIntAttr@4
$LN94@GetIntAttr@4:
  0011e	c6 45 ee eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  00122	eb 0a		 jmp	 SHORT $LN1@GetIntAttr@4
$LN95@GetIntAttr@4:
  00124	c6 45 ed ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  00128	eb 04		 jmp	 SHORT $LN1@GetIntAttr@4
$LN96@GetIntAttr@4:
  0012a	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@GetIntAttr@4:
  0012e	6a 02		 push	 2
  00130	8d 45 ec	 lea	 eax, DWORD PTR __k$[ebp]
  00133	c6 45 f5 00	 mov	 BYTE PTR __k$[ebp+9], 0
  00137	5a		 pop	 edx
$LL104@GetIntAttr@4:
  00138	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0013e	83 c0 04	 add	 eax, 4
  00141	4a		 dec	 edx
  00142	75 f4		 jne	 SHORT $LL104@GetIntAttr@4
  00144	80 75 f4 ed	 xor	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH

; 88   : 		return GetIntAttribute(_k);

  00148	8d 45 ec	 lea	 eax, DWORD PTR __k$[ebp]
  0014b	50		 push	 eax
  0014c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetIntAttribute@ioXMLElement@@QBEHPBD@Z

; 89   : 	}

  00152	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00155	33 cd		 xor	 ecx, ebp
  00157	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015c	c9		 leave
  0015d	c2 04 00	 ret	 4
??$GetIntAttribute_e@$09@ioXMLElement@@QBEHAAY09$$CBD@Z ENDP ; ioXMLElement::GetIntAttribute_e<10>
_TEXT	ENDS
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@1@@Z ; std::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >::operator-
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >::operator-, COMDAT
; _this$ = ecx

; 380  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 381  : 		return (*(_Mybase *)this - _Right);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	c1 f8 07	 sar	 eax, 7

; 382  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??G?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >::operator-
_TEXT	ENDS
PUBLIC	??$_Unchecked@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@YAPAURoundInfo@@V?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >
; Function compile flags: /Ogsp
;	COMDAT ??$_Unchecked@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@YAPAURoundInfo@@V?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@YAPAURoundInfo@@V?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >, COMDAT

; 393  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 394  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 395  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@YAPAURoundInfo@@V?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >
_TEXT	ENDS
PUBLIC	??$construct@AAURoundInfo@@@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@AAU2@@Z ; std::allocator<RoundInfo>::construct<RoundInfo &>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??$construct@AAURoundInfo@@@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAURoundInfo@@@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@AAU2@@Z$0
__ehfuncinfo$??$construct@AAURoundInfo@@@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAURoundInfo@@@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$construct@AAURoundInfo@@@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@AAU2@@Z
_TEXT	SEGMENT
$T558126 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAURoundInfo@@@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@AAU2@@Z PROC ; std::allocator<RoundInfo>::construct<RoundInfo &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??$construct@AAURoundInfo@@@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@AAU2@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000f	89 4d f0	 mov	 DWORD PTR $T558126[ebp], ecx
  00012	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00016	85 c9		 test	 ecx, ecx
  00018	74 08		 je	 SHORT $LN3@construct
  0001a	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  0001d	e8 00 00 00 00	 call	 ??0RoundInfo@@QAE@ABU0@@Z
$LN3@construct:

; 209  : 		}

  00022	e8 00 00 00 00	 call	 __EH_epilog3
  00027	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAURoundInfo@@@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@AAU2@@Z$0:
  00000	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00003	ff 75 f0	 push	 DWORD PTR $T558126[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000b	59		 pop	 ecx
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
__ehhandler$??$construct@AAURoundInfo@@@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@AAU2@@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAURoundInfo@@@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@AAU2@@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAURoundInfo@@@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@AAU2@@Z ENDP ; std::allocator<RoundInfo>::construct<RoundInfo &>
PUBLIC	??$_Move@PAURoundInfo@@PAU1@@std@@YAPAURoundInfo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<RoundInfo *,RoundInfo *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAURoundInfo@@PAU1@@std@@YAPAURoundInfo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAURoundInfo@@PAU1@@std@@YAPAURoundInfo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<RoundInfo *,RoundInfo *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00004	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  00007	3b 7d 0c	 cmp	 edi, DWORD PTR __Last$[ebp]
  0000a	74 1a		 je	 SHORT $LN10@Move
  0000c	56		 push	 esi
  0000d	be 80 00 00 00	 mov	 esi, 128		; 00000080H
$LL3@Move:

; 2514 : 		*_Dest = _STD move(*_First);

  00012	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00015	57		 push	 edi
  00016	e8 00 00 00 00	 call	 ??4RoundInfo@@QAEAAU0@ABU0@@Z
  0001b	01 75 10	 add	 DWORD PTR __Dest$[ebp], esi
  0001e	03 fe		 add	 edi, esi
  00020	3b 7d 0c	 cmp	 edi, DWORD PTR __Last$[ebp]
  00023	75 ed		 jne	 SHORT $LL3@Move
  00025	5e		 pop	 esi
$LN10@Move:

; 2515 : 	return (_Dest);

  00026	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00029	5f		 pop	 edi

; 2516 : 	}

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Move@PAURoundInfo@@PAU1@@std@@YAPAURoundInfo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<RoundInfo *,RoundInfo *>
_TEXT	ENDS
PUBLIC	??$_Construct@URoundInfo@@ABU1@@std@@YAXPAURoundInfo@@ABU1@@Z ; std::_Construct<RoundInfo,RoundInfo const &>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??$_Construct@URoundInfo@@ABU1@@std@@YAXPAURoundInfo@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@URoundInfo@@ABU1@@std@@YAXPAURoundInfo@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@URoundInfo@@ABU1@@std@@YAXPAURoundInfo@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@URoundInfo@@ABU1@@std@@YAXPAURoundInfo@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@URoundInfo@@ABU1@@std@@YAXPAURoundInfo@@ABU1@@Z
_TEXT	SEGMENT
$T558153 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$ = 8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@URoundInfo@@ABU1@@std@@YAXPAURoundInfo@@ABU1@@Z PROC ; std::_Construct<RoundInfo,RoundInfo const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??$_Construct@URoundInfo@@ABU1@@std@@YAXPAURoundInfo@@ABU1@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3

; 47   : 	void _FARQ *_Vptr = _Ptr;

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000f	89 4d 08	 mov	 DWORD PTR __Vptr$[ebp], ecx

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00012	89 4d f0	 mov	 DWORD PTR $T558153[ebp], ecx
  00015	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00019	85 c9		 test	 ecx, ecx
  0001b	74 08		 je	 SHORT $LN3@Construct
  0001d	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  00020	e8 00 00 00 00	 call	 ??0RoundInfo@@QAE@ABU0@@Z
$LN3@Construct:

; 49   : 	}

  00025	e8 00 00 00 00	 call	 __EH_epilog3
  0002a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@URoundInfo@@ABU1@@std@@YAXPAURoundInfo@@ABU1@@Z$0:
  00000	ff 75 08	 push	 DWORD PTR __Vptr$[ebp]
  00003	ff 75 f0	 push	 DWORD PTR $T558153[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000b	59		 pop	 ecx
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
__ehhandler$??$_Construct@URoundInfo@@ABU1@@std@@YAXPAURoundInfo@@ABU1@@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@URoundInfo@@ABU1@@std@@YAXPAURoundInfo@@ABU1@@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@URoundInfo@@ABU1@@std@@YAXPAURoundInfo@@ABU1@@Z ENDP ; std::_Construct<RoundInfo,RoundInfo const &>
PUBLIC	??$?0AAPAURoundInfo@@AAPAU0@@?$pair@PAURoundInfo@@PAU1@@std@@QAE@AAPAURoundInfo@@0@Z ; std::pair<RoundInfo *,RoundInfo *>::pair<RoundInfo *,RoundInfo *><RoundInfo * &,RoundInfo * &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0AAPAURoundInfo@@AAPAU0@@?$pair@PAURoundInfo@@PAU1@@std@@QAE@AAPAURoundInfo@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAURoundInfo@@AAPAU0@@?$pair@PAURoundInfo@@PAU1@@std@@QAE@AAPAURoundInfo@@0@Z PROC ; std::pair<RoundInfo *,RoundInfo *>::pair<RoundInfo *,RoundInfo *><RoundInfo * &,RoundInfo * &>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00011	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 248  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAPAURoundInfo@@AAPAU0@@?$pair@PAURoundInfo@@PAU1@@std@@QAE@AAPAURoundInfo@@0@Z ENDP ; std::pair<RoundInfo *,RoundInfo *>::pair<RoundInfo *,RoundInfo *><RoundInfo * &,RoundInfo * &>
_TEXT	ENDS
PUBLIC	??$_Destroy@URoundInfo@@@std@@YAXPAURoundInfo@@@Z ; std::_Destroy<RoundInfo>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy@URoundInfo@@@std@@YAXPAURoundInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@URoundInfo@@@std@@YAXPAURoundInfo@@@Z PROC	; std::_Destroy<RoundInfo>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 63   : 	_Ptr->~_Ty();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 64   : 	}

  00006	5d		 pop	 ebp

; 63   : 	_Ptr->~_Ty();

  00007	e9 00 00 00 00	 jmp	 ??1RoundInfo@@QAE@XZ
??$_Destroy@URoundInfo@@@std@@YAXPAURoundInfo@@@Z ENDP	; std::_Destroy<RoundInfo>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@$$QAU3@@Z ; std::allocator<RoundInfo>::construct
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@$$QAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@$$QAU3@@Z$0
__ehfuncinfo$?construct@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@$$QAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@$$QAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@$$QAU3@@Z
_TEXT	SEGMENT
$T558201 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@$$QAU3@@Z PROC ; std::allocator<RoundInfo>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?construct@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@$$QAU3@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000f	89 4d f0	 mov	 DWORD PTR $T558201[ebp], ecx
  00012	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00016	85 c9		 test	 ecx, ecx
  00018	74 08		 je	 SHORT $LN3@construct@2
  0001a	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  0001d	e8 00 00 00 00	 call	 ??0RoundInfo@@QAE@ABU0@@Z
$LN3@construct@2:

; 203  : 		}

  00022	e8 00 00 00 00	 call	 __EH_epilog3
  00027	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@$$QAU3@@Z$0:
  00000	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00003	ff 75 f0	 push	 DWORD PTR $T558201[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000b	59		 pop	 ecx
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
__ehhandler$?construct@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@$$QAU3@@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@$$QAU3@@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@$$QAU3@@Z ENDP ; std::allocator<RoundInfo>::construct
PUBLIC	??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z	; std::swap<RoundInfo>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z$0
__ehfuncinfo$??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z
_TEXT	SEGMENT
__Tmp$ = -140						; size = 128
__$EHRec$ = -12						; size = 12
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z PROC	; std::swap<RoundInfo>, COMDAT

; 101  : 	{	// exchange values stored at _Left and _Right

  00000	68 80 00 00 00	 push	 128			; 00000080H
  00005	b8 00 00 00 00	 mov	 eax, __ehhandler$??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z
  0000a	e8 00 00 00 00	 call	 __EH_prolog3

; 102  : 	_Ty _Tmp = _Move(_Left);

  0000f	ff 75 08	 push	 DWORD PTR __Left$[ebp]
  00012	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00018	e8 00 00 00 00	 call	 ??0RoundInfo@@QAE@ABU0@@Z

; 103  : 	_Left = _Move(_Right);

  0001d	ff 75 0c	 push	 DWORD PTR __Right$[ebp]
  00020	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00023	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00027	e8 00 00 00 00	 call	 ??4RoundInfo@@QAEAAU0@ABU0@@Z

; 104  : 	_Right = _Move(_Tmp);

  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0002f	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR __Tmp$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??4RoundInfo@@QAEAAU0@ABU0@@Z

; 105  : 	}

  0003b	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0003f	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00045	e8 00 00 00 00	 call	 ??1RoundInfo@@QAE@XZ
  0004a	e8 00 00 00 00	 call	 __EH_epilog3
  0004f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z$0:
  00000	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1RoundInfo@@QAE@XZ
__ehhandler$??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 70 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-144]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z ENDP	; std::swap<RoundInfo>
PUBLIC	??$_Move_backward@PAURoundInfo@@PAU1@@std@@YAPAURoundInfo@@PAU1@00@Z ; std::_Move_backward<RoundInfo *,RoundInfo *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move_backward@PAURoundInfo@@PAU1@@std@@YAPAURoundInfo@@PAU1@00@Z
_TEXT	SEGMENT
__Cat$558240 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move_backward@PAURoundInfo@@PAU1@@std@@YAPAURoundInfo@@PAU1@00@Z PROC ; std::_Move_backward<RoundInfo *,RoundInfo *>, COMDAT

; 2638 : 	{	// move [_First, _Last) backwards to [..., _Dest), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2639 : 	return (_Move_backward(_First, _Last,
; 2640 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$558240[ebp]
  00007	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Move_backward@PAURoundInfo@@PAU1@@std@@YAPAURoundInfo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move_backward<RoundInfo *,RoundInfo *>
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 2641 : 	}

  00018	c9		 leave
  00019	c3		 ret	 0
??$_Move_backward@PAURoundInfo@@PAU1@@std@@YAPAURoundInfo@@PAU1@00@Z ENDP ; std::_Move_backward<RoundInfo *,RoundInfo *>
_TEXT	ENDS
PUBLIC	??$_Push_heap@PAURoundInfo@@HU1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoKoSort@@@Z ; std::_Push_heap<RoundInfo *,int,RoundInfo,RoundInfoKoSort>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\algorithm
;	COMDAT ??$_Push_heap@PAURoundInfo@@HU1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoKoSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Push_heap@PAURoundInfo@@HU1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoKoSort@@@Z PROC ; std::_Push_heap<RoundInfo *,int,RoundInfo,RoundInfoKoSort>, COMDAT

; 2455 : 	{	// percolate _Hole to _Top or where _Val belongs, using operator<

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 2456 : 	for (_Diff _Idx = (_Hole - 1) / 2;

  00005	8b 7d 0c	 mov	 edi, DWORD PTR __Hole$[ebp]
  00008	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  0000b	99		 cdq
  0000c	2b c2		 sub	 eax, edx
  0000e	8b f0		 mov	 esi, eax
  00010	d1 fe		 sar	 esi, 1

; 2457 : 		_Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val);
; 2458 : 		_Idx = (_Hole - 1) / 2)

  00012	39 7d 10	 cmp	 DWORD PTR __Top$[ebp], edi
  00015	7d 39		 jge	 SHORT $LN1@Push_heap
  00017	53		 push	 ebx
$LL3@Push_heap:
  00018	ff 75 14	 push	 DWORD PTR __Val$[ebp]
  0001b	8b de		 mov	 ebx, esi
  0001d	c1 e3 07	 shl	 ebx, 7
  00020	03 5d 08	 add	 ebx, DWORD PTR __First$[ebp]
  00023	8d 4d 18	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00026	53		 push	 ebx
  00027	e8 00 00 00 00	 call	 ??RRoundInfoKoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoKoSort::operator()
  0002c	84 c0		 test	 al, al
  0002e	74 1f		 je	 SHORT $LN12@Push_heap

; 2459 : 		{	// move _Hole up to parent
; 2460 : 		*(_First + _Hole) = _Move(*(_First + _Idx));

  00030	8b cf		 mov	 ecx, edi
  00032	c1 e1 07	 shl	 ecx, 7
  00035	03 4d 08	 add	 ecx, DWORD PTR __First$[ebp]
  00038	53		 push	 ebx
  00039	e8 00 00 00 00	 call	 ??4RoundInfo@@QAEAAU0@ABU0@@Z
  0003e	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  00041	99		 cdq
  00042	2b c2		 sub	 eax, edx

; 2461 : 		_Hole = _Idx;

  00044	8b fe		 mov	 edi, esi
  00046	d1 f8		 sar	 eax, 1
  00048	8b f0		 mov	 esi, eax
  0004a	39 7d 10	 cmp	 DWORD PTR __Top$[ebp], edi
  0004d	7c c9		 jl	 SHORT $LL3@Push_heap
$LN12@Push_heap:
  0004f	5b		 pop	 ebx
$LN1@Push_heap:

; 2462 : 		}
; 2463 : 
; 2464 : 	*(_First + _Hole) = _Move(_Val);	// drop _Val into final hole

  00050	ff 75 14	 push	 DWORD PTR __Val$[ebp]
  00053	8b cf		 mov	 ecx, edi
  00055	c1 e1 07	 shl	 ecx, 7
  00058	03 4d 08	 add	 ecx, DWORD PTR __First$[ebp]
  0005b	e8 00 00 00 00	 call	 ??4RoundInfo@@QAEAAU0@ABU0@@Z
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi

; 2465 : 	}

  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
??$_Push_heap@PAURoundInfo@@HU1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoKoSort@@@Z ENDP ; std::_Push_heap<RoundInfo *,int,RoundInfo,RoundInfoKoSort>
_TEXT	ENDS
PUBLIC	??$_Push_heap@PAURoundInfo@@HU1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoSort@@@Z ; std::_Push_heap<RoundInfo *,int,RoundInfo,RoundInfoSort>
; Function compile flags: /Ogsp
;	COMDAT ??$_Push_heap@PAURoundInfo@@HU1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Push_heap@PAURoundInfo@@HU1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoSort@@@Z PROC ; std::_Push_heap<RoundInfo *,int,RoundInfo,RoundInfoSort>, COMDAT

; 2455 : 	{	// percolate _Hole to _Top or where _Val belongs, using operator<

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 2456 : 	for (_Diff _Idx = (_Hole - 1) / 2;

  00005	8b 7d 0c	 mov	 edi, DWORD PTR __Hole$[ebp]
  00008	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  0000b	99		 cdq
  0000c	2b c2		 sub	 eax, edx
  0000e	8b f0		 mov	 esi, eax
  00010	d1 fe		 sar	 esi, 1

; 2457 : 		_Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val);
; 2458 : 		_Idx = (_Hole - 1) / 2)

  00012	39 7d 10	 cmp	 DWORD PTR __Top$[ebp], edi
  00015	7d 39		 jge	 SHORT $LN1@Push_heap@2
  00017	53		 push	 ebx
$LL3@Push_heap@2:
  00018	ff 75 14	 push	 DWORD PTR __Val$[ebp]
  0001b	8b de		 mov	 ebx, esi
  0001d	c1 e3 07	 shl	 ebx, 7
  00020	03 5d 08	 add	 ebx, DWORD PTR __First$[ebp]
  00023	8d 4d 18	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00026	53		 push	 ebx
  00027	e8 00 00 00 00	 call	 ??RRoundInfoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoSort::operator()
  0002c	84 c0		 test	 al, al
  0002e	74 1f		 je	 SHORT $LN12@Push_heap@2

; 2459 : 		{	// move _Hole up to parent
; 2460 : 		*(_First + _Hole) = _Move(*(_First + _Idx));

  00030	8b cf		 mov	 ecx, edi
  00032	c1 e1 07	 shl	 ecx, 7
  00035	03 4d 08	 add	 ecx, DWORD PTR __First$[ebp]
  00038	53		 push	 ebx
  00039	e8 00 00 00 00	 call	 ??4RoundInfo@@QAEAAU0@ABU0@@Z
  0003e	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  00041	99		 cdq
  00042	2b c2		 sub	 eax, edx

; 2461 : 		_Hole = _Idx;

  00044	8b fe		 mov	 edi, esi
  00046	d1 f8		 sar	 eax, 1
  00048	8b f0		 mov	 esi, eax
  0004a	39 7d 10	 cmp	 DWORD PTR __Top$[ebp], edi
  0004d	7c c9		 jl	 SHORT $LL3@Push_heap@2
$LN12@Push_heap@2:
  0004f	5b		 pop	 ebx
$LN1@Push_heap@2:

; 2462 : 		}
; 2463 : 
; 2464 : 	*(_First + _Hole) = _Move(_Val);	// drop _Val into final hole

  00050	ff 75 14	 push	 DWORD PTR __Val$[ebp]
  00053	8b cf		 mov	 ecx, edi
  00055	c1 e1 07	 shl	 ecx, 7
  00058	03 4d 08	 add	 ecx, DWORD PTR __First$[ebp]
  0005b	e8 00 00 00 00	 call	 ??4RoundInfo@@QAEAAU0@ABU0@@Z
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi

; 2465 : 	}

  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
??$_Push_heap@PAURoundInfo@@HU1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoSort@@@Z ENDP ; std::_Push_heap<RoundInfo *,int,RoundInfo,RoundInfoSort>
_TEXT	ENDS
PUBLIC	??$_Push_heap@PAURoundInfo@@HU1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoStarSort@@@Z ; std::_Push_heap<RoundInfo *,int,RoundInfo,RoundInfoStarSort>
; Function compile flags: /Ogsp
;	COMDAT ??$_Push_heap@PAURoundInfo@@HU1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoStarSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Push_heap@PAURoundInfo@@HU1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoStarSort@@@Z PROC ; std::_Push_heap<RoundInfo *,int,RoundInfo,RoundInfoStarSort>, COMDAT

; 2455 : 	{	// percolate _Hole to _Top or where _Val belongs, using operator<

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 2456 : 	for (_Diff _Idx = (_Hole - 1) / 2;

  00005	8b 7d 0c	 mov	 edi, DWORD PTR __Hole$[ebp]
  00008	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  0000b	99		 cdq
  0000c	2b c2		 sub	 eax, edx
  0000e	8b f0		 mov	 esi, eax
  00010	d1 fe		 sar	 esi, 1

; 2457 : 		_Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val);
; 2458 : 		_Idx = (_Hole - 1) / 2)

  00012	39 7d 10	 cmp	 DWORD PTR __Top$[ebp], edi
  00015	7d 39		 jge	 SHORT $LN1@Push_heap@3
  00017	53		 push	 ebx
$LL3@Push_heap@3:
  00018	ff 75 14	 push	 DWORD PTR __Val$[ebp]
  0001b	8b de		 mov	 ebx, esi
  0001d	c1 e3 07	 shl	 ebx, 7
  00020	03 5d 08	 add	 ebx, DWORD PTR __First$[ebp]
  00023	8d 4d 18	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00026	53		 push	 ebx
  00027	e8 00 00 00 00	 call	 ??RRoundInfoStarSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoStarSort::operator()
  0002c	84 c0		 test	 al, al
  0002e	74 1f		 je	 SHORT $LN12@Push_heap@3

; 2459 : 		{	// move _Hole up to parent
; 2460 : 		*(_First + _Hole) = _Move(*(_First + _Idx));

  00030	8b cf		 mov	 ecx, edi
  00032	c1 e1 07	 shl	 ecx, 7
  00035	03 4d 08	 add	 ecx, DWORD PTR __First$[ebp]
  00038	53		 push	 ebx
  00039	e8 00 00 00 00	 call	 ??4RoundInfo@@QAEAAU0@ABU0@@Z
  0003e	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  00041	99		 cdq
  00042	2b c2		 sub	 eax, edx

; 2461 : 		_Hole = _Idx;

  00044	8b fe		 mov	 edi, esi
  00046	d1 f8		 sar	 eax, 1
  00048	8b f0		 mov	 esi, eax
  0004a	39 7d 10	 cmp	 DWORD PTR __Top$[ebp], edi
  0004d	7c c9		 jl	 SHORT $LL3@Push_heap@3
$LN12@Push_heap@3:
  0004f	5b		 pop	 ebx
$LN1@Push_heap@3:

; 2462 : 		}
; 2463 : 
; 2464 : 	*(_First + _Hole) = _Move(_Val);	// drop _Val into final hole

  00050	ff 75 14	 push	 DWORD PTR __Val$[ebp]
  00053	8b cf		 mov	 ecx, edi
  00055	c1 e1 07	 shl	 ecx, 7
  00058	03 4d 08	 add	 ecx, DWORD PTR __First$[ebp]
  0005b	e8 00 00 00 00	 call	 ??4RoundInfo@@QAEAAU0@ABU0@@Z
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi

; 2465 : 	}

  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
??$_Push_heap@PAURoundInfo@@HU1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoStarSort@@@Z ENDP ; std::_Push_heap<RoundInfo *,int,RoundInfo,RoundInfoStarSort>
_TEXT	ENDS
PUBLIC	??1CHARACTER@@QAE@XZ				; CHARACTER::~CHARACTER
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CHARACTER@@QAE@XZ DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$??1CHARACTER@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CHARACTER@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CHARACTER@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CHARACTER@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CHARACTER@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CHARACTER@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CHARACTER@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CHARACTER@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CHARACTER@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CHARACTER@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??1CHARACTER@@QAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??1CHARACTER@@QAE@XZ$9
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??1CHARACTER@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CHARACTER@@QAE@XZ PROC				; CHARACTER::~CHARACTER, COMDAT
; _this$ = ecx
  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??1CHARACTER@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	68 00 00 00 00	 push	 OFFSET ??1?$CEncrypt@H@@UAE@XZ ; CEncrypt<int>::~CEncrypt<int>
  00016	6a 04		 push	 4
  00018	6a 30		 push	 48			; 00000030H
  0001a	8d 86 e0 01 00
	00		 lea	 eax, DWORD PTR [esi+480]
  00020	50		 push	 eax
  00021	c7 45 fc 09 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 9
  00028	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  0002d	bf 00 00 00 00	 mov	 edi, OFFSET ??_7?$CEncrypt@H@@6B@
  00032	8d 8e bc 01 00
	00		 lea	 ecx, DWORD PTR [esi+444]
  00038	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  0003c	89 be b0 01 00
	00		 mov	 DWORD PTR [esi+432], edi
  00042	e8 00 00 00 00	 call	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
  00047	8d 8e 8c 01 00
	00		 lea	 ecx, DWORD PTR [esi+396]
  0004d	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00051	89 be 80 01 00
	00		 mov	 DWORD PTR [esi+384], edi
  00057	e8 00 00 00 00	 call	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
  0005c	8d 8e 5c 01 00
	00		 lea	 ecx, DWORD PTR [esi+348]
  00062	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00066	89 be 50 01 00
	00		 mov	 DWORD PTR [esi+336], edi
  0006c	e8 00 00 00 00	 call	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
  00071	8d 8e 2c 01 00
	00		 lea	 ecx, DWORD PTR [esi+300]
  00077	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0007b	89 be 20 01 00
	00		 mov	 DWORD PTR [esi+288], edi
  00081	e8 00 00 00 00	 call	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
  00086	8d 8e fc 00 00
	00		 lea	 ecx, DWORD PTR [esi+252]
  0008c	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00090	89 be f0 00 00
	00		 mov	 DWORD PTR [esi+240], edi
  00096	e8 00 00 00 00	 call	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
  0009b	8d 8e cc 00 00
	00		 lea	 ecx, DWORD PTR [esi+204]
  000a1	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000a5	89 be c0 00 00
	00		 mov	 DWORD PTR [esi+192], edi
  000ab	e8 00 00 00 00	 call	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
  000b0	8d 8e 9c 00 00
	00		 lea	 ecx, DWORD PTR [esi+156]
  000b6	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000ba	89 be 90 00 00
	00		 mov	 DWORD PTR [esi+144], edi
  000c0	e8 00 00 00 00	 call	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
  000c5	8d 4e 6c	 lea	 ecx, DWORD PTR [esi+108]
  000c8	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000cc	89 7e 60	 mov	 DWORD PTR [esi+96], edi
  000cf	e8 00 00 00 00	 call	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
  000d4	8d 4e 3c	 lea	 ecx, DWORD PTR [esi+60]
  000d7	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000db	89 7e 30	 mov	 DWORD PTR [esi+48], edi
  000de	e8 00 00 00 00	 call	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
  000e3	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000e7	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  000ea	89 3e		 mov	 DWORD PTR [esi], edi
  000ec	e8 00 00 00 00	 call	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
  000f1	e8 00 00 00 00	 call	 __EH_epilog3
  000f6	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CHARACTER@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@H@@UAE@XZ	; CEncrypt<int>::~CEncrypt<int>
__unwindfunclet$??1CHARACTER@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 30	 add	 ecx, 48			; 00000030H
  0000e	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@H@@UAE@XZ	; CEncrypt<int>::~CEncrypt<int>
__unwindfunclet$??1CHARACTER@@QAE@XZ$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 60	 add	 ecx, 96			; 00000060H
  00019	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@H@@UAE@XZ	; CEncrypt<int>::~CEncrypt<int>
__unwindfunclet$??1CHARACTER@@QAE@XZ$3:
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  00027	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@H@@UAE@XZ	; CEncrypt<int>::~CEncrypt<int>
__unwindfunclet$??1CHARACTER@@QAE@XZ$4:
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	81 c1 c0 00 00
	00		 add	 ecx, 192		; 000000c0H
  00035	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@H@@UAE@XZ	; CEncrypt<int>::~CEncrypt<int>
__unwindfunclet$??1CHARACTER@@QAE@XZ$5:
  0003a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	81 c1 f0 00 00
	00		 add	 ecx, 240		; 000000f0H
  00043	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@H@@UAE@XZ	; CEncrypt<int>::~CEncrypt<int>
__unwindfunclet$??1CHARACTER@@QAE@XZ$6:
  00048	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	81 c1 20 01 00
	00		 add	 ecx, 288		; 00000120H
  00051	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@H@@UAE@XZ	; CEncrypt<int>::~CEncrypt<int>
__unwindfunclet$??1CHARACTER@@QAE@XZ$7:
  00056	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	81 c1 50 01 00
	00		 add	 ecx, 336		; 00000150H
  0005f	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@H@@UAE@XZ	; CEncrypt<int>::~CEncrypt<int>
__unwindfunclet$??1CHARACTER@@QAE@XZ$8:
  00064	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	81 c1 80 01 00
	00		 add	 ecx, 384		; 00000180H
  0006d	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@H@@UAE@XZ	; CEncrypt<int>::~CEncrypt<int>
__unwindfunclet$??1CHARACTER@@QAE@XZ$9:
  00072	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	81 c1 b0 01 00
	00		 add	 ecx, 432		; 000001b0H
  0007b	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@H@@UAE@XZ	; CEncrypt<int>::~CEncrypt<int>
__ehhandler$??1CHARACTER@@QAE@XZ:
  00080	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00084	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00087	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0008a	33 c8		 xor	 ecx, eax
  0008c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00091	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CHARACTER@@QAE@XZ
  00096	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CHARACTER@@QAE@XZ ENDP				; CHARACTER::~CHARACTER
PUBLIC	??0?$CEncrypt@_N@@QAE@XZ			; CEncrypt<bool>::CEncrypt<bool>
EXTRN	??0ccddaabb@@QAE@XZ:PROC			; ccddaabb::ccddaabb
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
xdata$x	SEGMENT
__unwindtable$??0?$CEncrypt@_N@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CEncrypt@_N@@QAE@XZ$0
__ehfuncinfo$??0?$CEncrypt@_N@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CEncrypt@_N@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??0?$CEncrypt@_N@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$CEncrypt@_N@@QAE@XZ PROC				; CEncrypt<bool>::CEncrypt<bool>, COMDAT
; _this$ = ecx

; 109  : 	CEncrypt()

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0?$CEncrypt@_N@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00014	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CEncrypt@_N@@6B@
  0001a	e8 00 00 00 00	 call	 ??0ccddaabb@@QAE@XZ	; ccddaabb::ccddaabb
  0001f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 110  : 	{
; 111  : 		Init();

  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?Init@?$CEncrypt@_N@@AAEXXZ ; CEncrypt<bool>::Init

; 112  : 	}

  0002a	8b c6		 mov	 eax, esi
  0002c	e8 00 00 00 00	 call	 __EH_epilog3
  00031	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CEncrypt@_N@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	e9 00 00 00 00	 jmp	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
__ehhandler$??0?$CEncrypt@_N@@QAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$CEncrypt@_N@@QAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$CEncrypt@_N@@QAE@XZ ENDP				; CEncrypt<bool>::CEncrypt<bool>
PUBLIC	??B?$CEncrypt@_N@@QAE_NXZ			; CEncrypt<bool>::operator bool
; Function compile flags: /Ogsp
;	COMDAT ??B?$CEncrypt@_N@@QAE_NXZ
_TEXT	SEGMENT
_value$ = -1						; size = 1
??B?$CEncrypt@_N@@QAE_NXZ PROC				; CEncrypt<bool>::operator bool, COMDAT
; _this$ = ecx

; 134  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 135  : 		type value;
; 136  : 		DecryptValueToPool(&value);

  00004	8d 45 ff	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool

; 137  : 
; 138  : #ifdef _NOTUSE
; 139  : 		Debug();
; 140  : #endif
; 141  : 		return value;

  0000d	8a 45 ff	 mov	 al, BYTE PTR _value$[ebp]

; 142  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@_N@@QAE_NXZ ENDP				; CEncrypt<bool>::operator bool
_TEXT	ENDS
PUBLIC	??B?$CEncrypt@_N@@QBE_NXZ			; CEncrypt<bool>::operator bool
; Function compile flags: /Ogsp
;	COMDAT ??B?$CEncrypt@_N@@QBE_NXZ
_TEXT	SEGMENT
_value$ = -1						; size = 1
??B?$CEncrypt@_N@@QBE_NXZ PROC				; CEncrypt<bool>::operator bool, COMDAT
; _this$ = ecx

; 145  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 146  : 		//UJ 130829, const도 똑같이 하면 된다 --start
; 147  : 		type value;
; 148  : 		CEncrypt<type>* pThis = const_cast<CEncrypt<type>*>(this);
; 149  : 		pThis->DecryptValueToPool(&value);

  00004	8d 45 ff	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool

; 150  : 		//// const에서 DecryptValueToPool 사용할 수 없으므로 아래와 같이함.
; 151  :  		//type value;
; 152  : 		//char szTempMem[MAX_ENCRYPT];
; 153  : 		//m_RC5.DecryptByte( m_MemPool, szTempMem, max(m_ValueSize, DEFAULT_ENCRYPT) );
; 154  : 		//memcpy( &value, szTempMem, m_ValueSize );
; 155  : 		//UJ --end
; 156  : 
; 157  : #ifdef _NOTUSE
; 158  : 		Debug();
; 159  : #endif
; 160  : 		return value;

  0000d	8a 45 ff	 mov	 al, BYTE PTR _value$[ebp]

; 161  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@_N@@QBE_NXZ ENDP				; CEncrypt<bool>::operator bool
_TEXT	ENDS
PUBLIC	??4?$CEncrypt@_N@@QAE_N_N@Z			; CEncrypt<bool>::operator=
; Function compile flags: /Ogsp
;	COMDAT ??4?$CEncrypt@_N@@QAE_N_N@Z
_TEXT	SEGMENT
_inValue$ = 8						; size = 1
_value$ = 11						; size = 1
??4?$CEncrypt@_N@@QAE_N_N@Z PROC			; CEncrypt<bool>::operator=, COMDAT
; _this$ = ecx

; 225  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 226  : 		type value = inValue;

  00003	8a 45 08	 mov	 al, BYTE PTR _inValue$[ebp]
  00006	88 45 0b	 mov	 BYTE PTR _value$[ebp], al

; 227  : 		EncryptValueToPool((char*)&value);

  00009	8d 45 0b	 lea	 eax, DWORD PTR _value$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@_N@@AAEXPBD@Z ; CEncrypt<bool>::EncryptValueToPool

; 228  : #ifdef _NOTUSE
; 229  : 		m_value = inValue;
; 230  : 		Debug();
; 231  : #endif
; 232  : 		return value;

  00012	8a 45 0b	 mov	 al, BYTE PTR _value$[ebp]

; 233  : 	}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??4?$CEncrypt@_N@@QAE_N_N@Z ENDP			; CEncrypt<bool>::operator=
_TEXT	ENDS
PUBLIC	??0?$CEncrypt@H@@QAE@XZ				; CEncrypt<int>::CEncrypt<int>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$CEncrypt@H@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CEncrypt@H@@QAE@XZ$0
__ehfuncinfo$??0?$CEncrypt@H@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CEncrypt@H@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??0?$CEncrypt@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$CEncrypt@H@@QAE@XZ PROC				; CEncrypt<int>::CEncrypt<int>, COMDAT
; _this$ = ecx

; 109  : 	CEncrypt()

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0?$CEncrypt@H@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00014	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CEncrypt@H@@6B@
  0001a	e8 00 00 00 00	 call	 ??0ccddaabb@@QAE@XZ	; ccddaabb::ccddaabb
  0001f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 110  : 	{
; 111  : 		Init();

  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?Init@?$CEncrypt@H@@AAEXXZ ; CEncrypt<int>::Init

; 112  : 	}

  0002a	8b c6		 mov	 eax, esi
  0002c	e8 00 00 00 00	 call	 __EH_epilog3
  00031	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CEncrypt@H@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	e9 00 00 00 00	 jmp	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
__ehhandler$??0?$CEncrypt@H@@QAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$CEncrypt@H@@QAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$CEncrypt@H@@QAE@XZ ENDP				; CEncrypt<int>::CEncrypt<int>
PUBLIC	??B?$CEncrypt@H@@QBEHXZ				; CEncrypt<int>::operator int
; Function compile flags: /Ogsp
;	COMDAT ??B?$CEncrypt@H@@QBEHXZ
_TEXT	SEGMENT
_value$ = -4						; size = 4
??B?$CEncrypt@H@@QBEHXZ PROC				; CEncrypt<int>::operator int, COMDAT
; _this$ = ecx

; 145  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 146  : 		//UJ 130829, const도 똑같이 하면 된다 --start
; 147  : 		type value;
; 148  : 		CEncrypt<type>* pThis = const_cast<CEncrypt<type>*>(this);
; 149  : 		pThis->DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ; CEncrypt<int>::DecryptValueToPool

; 150  : 		//// const에서 DecryptValueToPool 사용할 수 없으므로 아래와 같이함.
; 151  :  		//type value;
; 152  : 		//char szTempMem[MAX_ENCRYPT];
; 153  : 		//m_RC5.DecryptByte( m_MemPool, szTempMem, max(m_ValueSize, DEFAULT_ENCRYPT) );
; 154  : 		//memcpy( &value, szTempMem, m_ValueSize );
; 155  : 		//UJ --end
; 156  : 
; 157  : #ifdef _NOTUSE
; 158  : 		Debug();
; 159  : #endif
; 160  : 		return value;

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _value$[ebp]

; 161  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@H@@QBEHXZ ENDP				; CEncrypt<int>::operator int
_TEXT	ENDS
PUBLIC	??4?$CEncrypt@H@@QAEHH@Z			; CEncrypt<int>::operator=
; Function compile flags: /Ogsp
;	COMDAT ??4?$CEncrypt@H@@QAEHH@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
_inValue$ = 8						; size = 4
??4?$CEncrypt@H@@QAEHH@Z PROC				; CEncrypt<int>::operator=, COMDAT
; _this$ = ecx

; 843  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 844  : 		type value = inValue;

  00003	8b 45 08	 mov	 eax, DWORD PTR _inValue$[ebp]
  00006	89 45 08	 mov	 DWORD PTR _value$[ebp], eax

; 845  : 		EncryptValueToPool((char*)&value);

  00009	8d 45 08	 lea	 eax, DWORD PTR _value$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@H@@AAEXPBD@Z ; CEncrypt<int>::EncryptValueToPool

; 846  : #ifdef _NOTUSE
; 847  : 		m_value = inValue;
; 848  : 		Debug();
; 849  : #endif
; 850  : 		return value;

  00012	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]

; 851  : 	}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??4?$CEncrypt@H@@QAEHH@Z ENDP				; CEncrypt<int>::operator=
_TEXT	ENDS
PUBLIC	??B?$CEncrypt@W4ModeType@@@@QAE?AW4ModeType@@XZ	; CEncrypt<enum ModeType>::operator enum ModeType
; Function compile flags: /Ogsp
;	COMDAT ??B?$CEncrypt@W4ModeType@@@@QAE?AW4ModeType@@XZ
_TEXT	SEGMENT
_value$ = -4						; size = 4
??B?$CEncrypt@W4ModeType@@@@QAE?AW4ModeType@@XZ PROC	; CEncrypt<enum ModeType>::operator enum ModeType, COMDAT
; _this$ = ecx

; 134  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 135  : 		type value;
; 136  : 		DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4ModeType@@@@QAEXPAW4ModeType@@@Z ; CEncrypt<enum ModeType>::DecryptValueToPool

; 137  : 
; 138  : #ifdef _NOTUSE
; 139  : 		Debug();
; 140  : #endif
; 141  : 		return value;

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _value$[ebp]

; 142  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@W4ModeType@@@@QAE?AW4ModeType@@XZ ENDP	; CEncrypt<enum ModeType>::operator enum ModeType
_TEXT	ENDS
PUBLIC	?IsPrisonerMode@ioBaseChar@@QBE_NXZ		; ioBaseChar::IsPrisonerMode
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasechar.h
;	COMDAT ?IsPrisonerMode@ioBaseChar@@QBE_NXZ
_TEXT	SEGMENT
_value$558378 = -1					; size = 1
?IsPrisonerMode@ioBaseChar@@QBE_NXZ PROC		; ioBaseChar::IsPrisonerMode, COMDAT
; _this$ = ecx

; 2130 : 	inline bool IsPrisonerMode() const { return m_bPrisonerMode; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 ff	 lea	 eax, DWORD PTR _value$558378[ebp]
  00007	50		 push	 eax
  00008	81 c1 cc 14 00
	00		 add	 ecx, 5324		; 000014ccH
  0000e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  00013	8a 45 ff	 mov	 al, BYTE PTR _value$558378[ebp]
  00016	c9		 leave
  00017	c3		 ret	 0
?IsPrisonerMode@ioBaseChar@@QBE_NXZ ENDP		; ioBaseChar::IsPrisonerMode
_TEXT	ENDS
PUBLIC	_szType$GSCopy$
PUBLIC	_pFrame$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?AddRenderFrame@RoundStateUserWnd@@MAEXABVioHashString@@PAVioUIRenderFrame@@@Z ; RoundStateUserWnd::AddRenderFrame
EXTRN	__imp_?AddRenderFrame@ioWnd@@UAEXABVioHashString@@PAVioUIRenderFrame@@@Z:PROC
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
;	COMDAT ?AddRenderFrame@RoundStateUserWnd@@MAEXABVioHashString@@PAVioUIRenderFrame@@@Z
_TEXT	SEGMENT
_szType$GSCopy$ = -36					; size = 4
_pFrame$GSCopy$ = -32					; size = 4
_this$GSCopy$ = -28					; size = 4
__t$558543 = -24					; size = 13
__t$558418 = -24					; size = 10
__$ArrayPad$ = -4					; size = 4
_szType$ = 8						; size = 4
_pFrame$ = 12						; size = 4
?AddRenderFrame@RoundStateUserWnd@@MAEXABVioHashString@@PAVioUIRenderFrame@@@Z PROC ; RoundStateUserWnd::AddRenderFrame, COMDAT
; _this$ = ecx

; 170  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _pFrame$[ebp]
  00013	8b 55 08	 mov	 edx, DWORD PTR _szType$[ebp]
  00016	56		 push	 esi
  00017	57		 push	 edi

; 171  : 	if( szType == "MyTeamFrm" )

  00018	6a 02		 push	 2
  0001a	89 4d e4	 mov	 DWORD PTR _this$GSCopy$[ebp], ecx

; 177  : 	{
; 178  : 		SAFEDELETE( m_pGuildMarkFrm );

  0001d	89 45 e0	 mov	 DWORD PTR _pFrame$GSCopy$[ebp], eax
  00020	89 55 dc	 mov	 DWORD PTR _szType$GSCopy$[ebp], edx
  00023	c7 45 e8 a0 95
	bf 8f		 mov	 DWORD PTR __t$558418[ebp], -1883269728 ; 8fbf95a0H
  0002a	c7 45 ec 8c 81
	ad 98		 mov	 DWORD PTR __t$558418[ebp+4], -1733459572 ; 98ad818cH
  00031	8d 45 e8	 lea	 eax, DWORD PTR __t$558418[ebp]
  00034	66 c7 45 f0 80
	00		 mov	 WORD PTR __t$558418[ebp+8], 128 ; 00000080H
  0003a	59		 pop	 ecx
  0003b	bf ed ec eb ea	 mov	 edi, -353637139		; eaebecedH
$LL116@AddRenderF:

; 171  : 	if( szType == "MyTeamFrm" )

  00040	31 38		 xor	 DWORD PTR [eax], edi
  00042	83 c0 04	 add	 eax, 4
  00045	49		 dec	 ecx
  00046	75 f8		 jne	 SHORT $LL116@AddRenderF
  00048	80 75 f0 ed	 xor	 BYTE PTR __t$558418[ebp+8], -19 ; ffffffedH
  0004c	8b ca		 mov	 ecx, edx
  0004e	8d 75 e8	 lea	 esi, DWORD PTR __t$558418[ebp]
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL234@AddRenderF:
  00057	8a 08		 mov	 cl, BYTE PTR [eax]
  00059	3a 0e		 cmp	 cl, BYTE PTR [esi]
  0005b	75 1a		 jne	 SHORT $LN235@AddRenderF
  0005d	84 c9		 test	 cl, cl
  0005f	74 12		 je	 SHORT $LN236@AddRenderF
  00061	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00064	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  00067	75 0e		 jne	 SHORT $LN235@AddRenderF
  00069	83 c0 02	 add	 eax, 2
  0006c	83 c6 02	 add	 esi, 2
  0006f	84 c9		 test	 cl, cl
  00071	75 e4		 jne	 SHORT $LL234@AddRenderF
$LN236@AddRenderF:
  00073	33 c0		 xor	 eax, eax
  00075	eb 05		 jmp	 SHORT $LN237@AddRenderF
$LN235@AddRenderF:
  00077	1b c0		 sbb	 eax, eax
  00079	83 d8 ff	 sbb	 eax, -1
$LN237@AddRenderF:
  0007c	85 c0		 test	 eax, eax
  0007e	75 29		 jne	 SHORT $LN233@AddRenderF

; 172  : 	{
; 173  : 		SAFEDELETE( m_pMyTeamFrm );

  00080	8b 75 e4	 mov	 esi, DWORD PTR _this$GSCopy$[ebp]
  00083	8b 8e 60 01 00
	00		 mov	 ecx, DWORD PTR [esi+352]
  00089	85 c9		 test	 ecx, ecx
  0008b	74 0e		 je	 SHORT $LN5@AddRenderF
  0008d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0008f	6a 01		 push	 1
  00091	ff 50 40	 call	 DWORD PTR [eax+64]
  00094	83 a6 60 01 00
	00 00		 and	 DWORD PTR [esi+352], 0
$LN5@AddRenderF:

; 174  : 		m_pMyTeamFrm = pFrame;

  0009b	8b 45 e0	 mov	 eax, DWORD PTR _pFrame$GSCopy$[ebp]
  0009e	89 86 60 01 00
	00		 mov	 DWORD PTR [esi+352], eax
  000a4	e9 91 00 00 00	 jmp	 $LN1@AddRenderF
$LN233@AddRenderF:

; 175  : 	}
; 176  : 	else if( szType == "GuildMarkFrm" )

  000a9	6a 03		 push	 3
  000ab	c7 45 e8 aa 99
	82 86		 mov	 DWORD PTR __t$558543[ebp], -2038261334 ; 868299aaH
  000b2	c7 45 ec 89 a1
	8a 98		 mov	 DWORD PTR __t$558543[ebp+4], -1735745143 ; 988aa189H
  000b9	c7 45 f0 86 aa
	99 87		 mov	 DWORD PTR __t$558543[ebp+8], -2019972474 ; 8799aa86H
  000c0	8d 45 e8	 lea	 eax, DWORD PTR __t$558543[ebp]
  000c3	c6 45 f4 00	 mov	 BYTE PTR __t$558543[ebp+12], 0
  000c7	59		 pop	 ecx
$LL222@AddRenderF:
  000c8	31 38		 xor	 DWORD PTR [eax], edi
  000ca	83 c0 04	 add	 eax, 4
  000cd	49		 dec	 ecx
  000ce	75 f8		 jne	 SHORT $LL222@AddRenderF
  000d0	8b 4d dc	 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  000d3	8d 75 e8	 lea	 esi, DWORD PTR __t$558543[ebp]
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL238@AddRenderF:
  000dc	8a 08		 mov	 cl, BYTE PTR [eax]
  000de	3a 0e		 cmp	 cl, BYTE PTR [esi]
  000e0	75 1a		 jne	 SHORT $LN239@AddRenderF
  000e2	84 c9		 test	 cl, cl
  000e4	74 12		 je	 SHORT $LN240@AddRenderF
  000e6	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  000e9	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  000ec	75 0e		 jne	 SHORT $LN239@AddRenderF
  000ee	83 c0 02	 add	 eax, 2
  000f1	83 c6 02	 add	 esi, 2
  000f4	84 c9		 test	 cl, cl
  000f6	75 e4		 jne	 SHORT $LL238@AddRenderF
$LN240@AddRenderF:
  000f8	33 c0		 xor	 eax, eax
  000fa	eb 05		 jmp	 SHORT $LN241@AddRenderF
$LN239@AddRenderF:
  000fc	1b c0		 sbb	 eax, eax
  000fe	83 d8 ff	 sbb	 eax, -1
$LN241@AddRenderF:
  00101	85 c0		 test	 eax, eax
  00103	75 26		 jne	 SHORT $LN3@AddRenderF

; 177  : 	{
; 178  : 		SAFEDELETE( m_pGuildMarkFrm );

  00105	8b 75 e4	 mov	 esi, DWORD PTR _this$GSCopy$[ebp]
  00108	8b 8e 64 01 00
	00		 mov	 ecx, DWORD PTR [esi+356]
  0010e	85 c9		 test	 ecx, ecx
  00110	74 0e		 je	 SHORT $LN2@AddRenderF
  00112	8b 01		 mov	 eax, DWORD PTR [ecx]
  00114	6a 01		 push	 1
  00116	ff 50 40	 call	 DWORD PTR [eax+64]
  00119	83 a6 64 01 00
	00 00		 and	 DWORD PTR [esi+356], 0
$LN2@AddRenderF:

; 179  : 		m_pGuildMarkFrm = pFrame;

  00120	8b 45 e0	 mov	 eax, DWORD PTR _pFrame$GSCopy$[ebp]
  00123	89 86 64 01 00
	00		 mov	 DWORD PTR [esi+356], eax

; 180  : 	}
; 181  : 	else

  00129	eb 0f		 jmp	 SHORT $LN1@AddRenderF
$LN3@AddRenderF:

; 182  : 	{
; 183  : 		ioWnd::AddRenderFrame( szType, pFrame );

  0012b	ff 75 e0	 push	 DWORD PTR _pFrame$GSCopy$[ebp]
  0012e	8b 4d e4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00131	ff 75 dc	 push	 DWORD PTR _szType$GSCopy$[ebp]
  00134	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?AddRenderFrame@ioWnd@@UAEXABVioHashString@@PAVioUIRenderFrame@@@Z
$LN1@AddRenderF:

; 184  : 	}
; 185  : }

  0013a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013d	5f		 pop	 edi
  0013e	33 cd		 xor	 ecx, ebp
  00140	5e		 pop	 esi
  00141	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00146	c9		 leave
  00147	c2 08 00	 ret	 8
?AddRenderFrame@RoundStateUserWnd@@MAEXABVioHashString@@PAVioUIRenderFrame@@@Z ENDP ; RoundStateUserWnd::AddRenderFrame
_TEXT	ENDS
PUBLIC	_pImage$GSCopy$
PUBLIC	_szType$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?AddRenderImage@RoundStateUserWnd@@MAEXABVioHashString@@PAVioUIRenderImage@@@Z ; RoundStateUserWnd::AddRenderImage
EXTRN	__imp_?AddRenderImage@ioWnd@@UAEXABVioHashString@@PAVioUIRenderImage@@@Z:PROC
; Function compile flags: /Ogsp
;	COMDAT ?AddRenderImage@RoundStateUserWnd@@MAEXABVioHashString@@PAVioUIRenderImage@@@Z
_TEXT	SEGMENT
_pImage$GSCopy$ = -988					; size = 4
_szType$GSCopy$ = -984					; size = 4
__t$565160 = -980					; size = 9
__t$565548 = -964					; size = 9
__t$563798 = -948					; size = 9
__t$559173 = -932					; size = 9
__t$558923 = -916					; size = 9
__t$559423 = -900					; size = 9
__t$563298 = -884					; size = 9
__t$561548 = -868					; size = 9
__t$560036 = -852					; size = 9
__t$564285 = -836					; size = 13
__t$564410 = -816					; size = 13
__t$564660 = -796					; size = 13
__t$561147 = -776					; size = 13
__t$561785 = -756					; size = 17
__t$562147 = -732					; size = 17
__t$562285 = -708					; size = 17
__t$560897 = -684					; size = 17
__t$559897 = -660					; size = 10
__t$563022 = -644					; size = 10
__t$562022 = -628					; size = 14
__t$561933 = -608					; size = 18
__t$565285 = -584					; size = 11
__t$560535 = -568					; size = 14
__t$564910 = -548					; size = 16
__t$559647 = -528					; size = 11
__t$564022 = -512					; size = 16
__t$561285 = -492					; size = 10
__t$561022 = -476					; size = 16
__t$559022 = -456					; size = 10
__t$564772 = -440					; size = 15
__t$560772 = -420					; size = 14
__t$564535 = -400					; size = 15
__t$565022 = -380					; size = 12
__t$562410 = -364					; size = 15
__t$562772 = -344					; size = 11
__t$560647 = -328					; size = 15
__t$563660 = -308					; size = 10
__t$560410 = -292					; size = 15
__t$562897 = -272					; size = 10
__t$565410 = -256					; size = 14
__t$560285 = -236					; size = 10
__t$564147 = -220					; size = 14
__t$559772 = -200					; size = 10
__t$563897 = -184					; size = 14
__t$562522 = -164					; size = 22
__t$562660 = -136					; size = 14
__t$560160 = -116					; size = 11
__t$563397 = -100					; size = 8
__t$559272 = -88					; size = 8
__t$563147 = -76					; size = 8
__t$565647 = -64					; size = 8
__t$561647 = -52					; size = 8
__t$561397 = -40					; size = 8
__t$559522 = -28					; size = 8
__t$563522 = -16					; size = 7
__$ArrayPad$ = -4					; size = 4
_szType$ = 8						; size = 4
_pImage$ = 12						; size = 4
?AddRenderImage@RoundStateUserWnd@@MAEXABVioHashString@@PAVioUIRenderImage@@@Z PROC ; RoundStateUserWnd::AddRenderImage, COMDAT
; _this$ = ecx

; 188  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 03 00
	00		 sub	 esp, 988		; 000003dcH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _szType$[ebp]
  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	57		 push	 edi

; 465  : 	{
; 466  : 		ioWnd::AddRenderImage( szType, pImage );

  00019	89 85 28 fc ff
	ff		 mov	 DWORD PTR _szType$GSCopy$[ebp], eax
  0001f	8b 45 0c	 mov	 eax, DWORD PTR _pImage$[ebp]
  00022	33 db		 xor	 ebx, ebx
  00024	6a 02		 push	 2
  00026	8b f9		 mov	 edi, ecx
  00028	89 85 24 fc ff
	ff		 mov	 DWORD PTR _pImage$GSCopy$[ebp], eax
  0002e	c7 85 6c fc ff
	ff af 80 9e 8f	 mov	 DWORD PTR __t$558923[ebp], -1885437777 ; 8f9e80afH
  00038	c7 85 70 fc ff
	ff a9 8d 99 81	 mov	 DWORD PTR __t$558923[ebp+4], -2120643159 ; 81998da9H
  00042	8d 85 6c fc ff
	ff		 lea	 eax, DWORD PTR __t$558923[ebp]
  00048	88 9d 74 fc ff
	ff		 mov	 BYTE PTR __t$558923[ebp+8], bl
  0004e	59		 pop	 ecx
$LL381@AddRenderI:

; 189  : 	if( szType == "BlueDark" )

  0004f	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00055	83 c0 04	 add	 eax, 4
  00058	49		 dec	 ecx
  00059	75 f4		 jne	 SHORT $LL381@AddRenderI
  0005b	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  00061	8d b5 6c fc ff
	ff		 lea	 esi, DWORD PTR __t$558923[ebp]
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6382@AddRenderI:
  0006d	8a 08		 mov	 cl, BYTE PTR [eax]
  0006f	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00071	75 1a		 jne	 SHORT $LN6383@AddRenderI
  00073	3a cb		 cmp	 cl, bl
  00075	74 12		 je	 SHORT $LN6602@AddRenderI
  00077	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  0007a	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  0007d	75 0e		 jne	 SHORT $LN6383@AddRenderI
  0007f	83 c0 02	 add	 eax, 2
  00082	83 c6 02	 add	 esi, 2
  00085	3a cb		 cmp	 cl, bl
  00087	75 e4		 jne	 SHORT $LL6382@AddRenderI
$LN6602@AddRenderI:
  00089	33 c0		 xor	 eax, eax
  0008b	eb 05		 jmp	 SHORT $LN6385@AddRenderI
$LN6383@AddRenderI:
  0008d	1b c0		 sbb	 eax, eax
  0008f	83 d8 ff	 sbb	 eax, -1
$LN6385@AddRenderI:
  00092	3b c3		 cmp	 eax, ebx
  00094	75 30		 jne	 SHORT $LN6328@AddRenderI

; 190  : 	{
; 191  : 		SAFEDELETE( m_pBlueDark );

  00096	39 9f 68 01 00
	00		 cmp	 DWORD PTR [edi+360], ebx
  0009c	74 17		 je	 SHORT $LN164@AddRenderI
  0009e	8b 8f 68 01 00
	00		 mov	 ecx, DWORD PTR [edi+360]
  000a4	3b cb		 cmp	 ecx, ebx
  000a6	74 07		 je	 SHORT $LN168@AddRenderI
  000a8	8b 01		 mov	 eax, DWORD PTR [ecx]
  000aa	6a 01		 push	 1
  000ac	ff 50 40	 call	 DWORD PTR [eax+64]
$LN168@AddRenderI:
  000af	89 9f 68 01 00
	00		 mov	 DWORD PTR [edi+360], ebx
$LN164@AddRenderI:

; 192  : 		m_pBlueDark = pImage;

  000b5	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  000bb	89 87 68 01 00
	00		 mov	 DWORD PTR [edi+360], eax
  000c1	e9 9b 24 00 00	 jmp	 $LN1@AddRenderI
$LN6328@AddRenderI:

; 193  : 	}
; 194  : 	else if( szType == "BlueLight" )

  000c6	6a 02		 push	 2
  000c8	c7 85 38 fe ff
	ff af 80 9e 8f	 mov	 DWORD PTR __t$559022[ebp], -1885437777 ; 8f9e80afH
  000d2	c7 85 3c fe ff
	ff a1 85 8c 82	 mov	 DWORD PTR __t$559022[ebp+4], -2104719967 ; 828c85a1H
  000dc	8d 85 38 fe ff
	ff		 lea	 eax, DWORD PTR __t$559022[ebp]
  000e2	66 c7 85 40 fe
	ff ff 99 00	 mov	 WORD PTR __t$559022[ebp+8], 153 ; 00000099H
  000eb	59		 pop	 ecx
$LL487@AddRenderI:
  000ec	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  000f2	83 c0 04	 add	 eax, 4
  000f5	49		 dec	 ecx
  000f6	75 f4		 jne	 SHORT $LL487@AddRenderI
  000f8	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  000fe	80 b5 40 fe ff
	ff ed		 xor	 BYTE PTR __t$559022[ebp+8], -19 ; ffffffedH
  00105	8d b5 38 fe ff
	ff		 lea	 esi, DWORD PTR __t$559022[ebp]
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6386@AddRenderI:
  00111	8a 08		 mov	 cl, BYTE PTR [eax]
  00113	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00115	75 1a		 jne	 SHORT $LN6387@AddRenderI
  00117	3a cb		 cmp	 cl, bl
  00119	74 12		 je	 SHORT $LN6603@AddRenderI
  0011b	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  0011e	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  00121	75 0e		 jne	 SHORT $LN6387@AddRenderI
  00123	83 c0 02	 add	 eax, 2
  00126	83 c6 02	 add	 esi, 2
  00129	3a cb		 cmp	 cl, bl
  0012b	75 e4		 jne	 SHORT $LL6386@AddRenderI
$LN6603@AddRenderI:
  0012d	33 c0		 xor	 eax, eax
  0012f	eb 05		 jmp	 SHORT $LN6389@AddRenderI
$LN6387@AddRenderI:
  00131	1b c0		 sbb	 eax, eax
  00133	83 d8 ff	 sbb	 eax, -1
$LN6389@AddRenderI:
  00136	3b c3		 cmp	 eax, ebx
  00138	75 30		 jne	 SHORT $LN6329@AddRenderI

; 195  : 	{
; 196  : 		SAFEDELETE( m_pBlueLight );

  0013a	39 9f 6c 01 00
	00		 cmp	 DWORD PTR [edi+364], ebx
  00140	74 17		 je	 SHORT $LN161@AddRenderI
  00142	8b 8f 6c 01 00
	00		 mov	 ecx, DWORD PTR [edi+364]
  00148	3b cb		 cmp	 ecx, ebx
  0014a	74 07		 je	 SHORT $LN170@AddRenderI
  0014c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0014e	6a 01		 push	 1
  00150	ff 50 40	 call	 DWORD PTR [eax+64]
$LN170@AddRenderI:
  00153	89 9f 6c 01 00
	00		 mov	 DWORD PTR [edi+364], ebx
$LN161@AddRenderI:

; 197  : 		m_pBlueLight = pImage;

  00159	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  0015f	89 87 6c 01 00
	00		 mov	 DWORD PTR [edi+364], eax
  00165	e9 f7 23 00 00	 jmp	 $LN1@AddRenderI
$LN6329@AddRenderI:

; 198  : 	}
; 199  : 	else if( szType == "BlueOver" )

  0016a	6a 02		 push	 2
  0016c	c7 85 5c fc ff
	ff af 80 9e 8f	 mov	 DWORD PTR __t$559173[ebp], -1885437777 ; 8f9e80afH
  00176	c7 85 60 fc ff
	ff a2 9a 8e 98	 mov	 DWORD PTR __t$559173[ebp+4], -1735484766 ; 988e9aa2H
  00180	8d 85 5c fc ff
	ff		 lea	 eax, DWORD PTR __t$559173[ebp]
  00186	88 9d 64 fc ff
	ff		 mov	 BYTE PTR __t$559173[ebp+8], bl
  0018c	59		 pop	 ecx
$LL593@AddRenderI:
  0018d	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00193	83 c0 04	 add	 eax, 4
  00196	49		 dec	 ecx
  00197	75 f4		 jne	 SHORT $LL593@AddRenderI
  00199	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  0019f	8d b5 5c fc ff
	ff		 lea	 esi, DWORD PTR __t$559173[ebp]
  001a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6390@AddRenderI:
  001ab	8a 08		 mov	 cl, BYTE PTR [eax]
  001ad	3a 0e		 cmp	 cl, BYTE PTR [esi]
  001af	75 1a		 jne	 SHORT $LN6391@AddRenderI
  001b1	3a cb		 cmp	 cl, bl
  001b3	74 12		 je	 SHORT $LN6392@AddRenderI
  001b5	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  001b8	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  001bb	75 0e		 jne	 SHORT $LN6391@AddRenderI
  001bd	83 c0 02	 add	 eax, 2
  001c0	83 c6 02	 add	 esi, 2
  001c3	3a cb		 cmp	 cl, bl
  001c5	75 e4		 jne	 SHORT $LL6390@AddRenderI
$LN6392@AddRenderI:
  001c7	33 c0		 xor	 eax, eax
  001c9	eb 05		 jmp	 SHORT $LN6393@AddRenderI
$LN6391@AddRenderI:
  001cb	1b c0		 sbb	 eax, eax
  001cd	83 d8 ff	 sbb	 eax, -1
$LN6393@AddRenderI:
  001d0	3b c3		 cmp	 eax, ebx
  001d2	75 30		 jne	 SHORT $LN6330@AddRenderI

; 200  : 	{
; 201  : 		SAFEDELETE( m_pBlueOver );

  001d4	39 9f 70 01 00
	00		 cmp	 DWORD PTR [edi+368], ebx
  001da	74 17		 je	 SHORT $LN158@AddRenderI
  001dc	8b 8f 70 01 00
	00		 mov	 ecx, DWORD PTR [edi+368]
  001e2	3b cb		 cmp	 ecx, ebx
  001e4	74 07		 je	 SHORT $LN172@AddRenderI
  001e6	8b 01		 mov	 eax, DWORD PTR [ecx]
  001e8	6a 01		 push	 1
  001ea	ff 50 40	 call	 DWORD PTR [eax+64]
$LN172@AddRenderI:
  001ed	89 9f 70 01 00
	00		 mov	 DWORD PTR [edi+368], ebx
$LN158@AddRenderI:

; 202  : 		m_pBlueOver = pImage;

  001f3	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  001f9	89 87 70 01 00
	00		 mov	 DWORD PTR [edi+368], eax
  001ff	e9 5d 23 00 00	 jmp	 $LN1@AddRenderI
$LN6330@AddRenderI:

; 203  : 	}
; 204  : 	else if( szType == "RedDark" )

  00204	6a 04		 push	 4
  00206	c7 45 a8 bf 89
	8f ae		 mov	 DWORD PTR __t$559272[ebp], -1366324801 ; ae8f89bfH
  0020d	81 75 a8 ed ec
	eb ea		 xor	 DWORD PTR __t$559272[ebp], -353637139 ; eaebecedH
  00214	c7 45 ac 8c 9e
	80 00		 mov	 DWORD PTR __t$559272[ebp+4], 8429196 ; 00809e8cH
  0021b	58		 pop	 eax
$LL696@AddRenderI:
  0021c	8b c8		 mov	 ecx, eax
  0021e	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00224	79 05		 jns	 SHORT $LN6623@AddRenderI
  00226	49		 dec	 ecx
  00227	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0022a	41		 inc	 ecx
$LN6623@AddRenderI:
  0022b	b2 ed		 mov	 dl, -19			; ffffffedH
  0022d	2a d1		 sub	 dl, cl
  0022f	30 54 05 a8	 xor	 BYTE PTR __t$559272[ebp+eax], dl
  00233	40		 inc	 eax
  00234	83 f8 07	 cmp	 eax, 7
  00237	7c e3		 jl	 SHORT $LL696@AddRenderI
  00239	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  0023f	8d 75 a8	 lea	 esi, DWORD PTR __t$559272[ebp]
  00242	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6394@AddRenderI:
  00248	8a 08		 mov	 cl, BYTE PTR [eax]
  0024a	3a 0e		 cmp	 cl, BYTE PTR [esi]
  0024c	75 1a		 jne	 SHORT $LN6395@AddRenderI
  0024e	3a cb		 cmp	 cl, bl
  00250	74 12		 je	 SHORT $LN6604@AddRenderI
  00252	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00255	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  00258	75 0e		 jne	 SHORT $LN6395@AddRenderI
  0025a	83 c0 02	 add	 eax, 2
  0025d	83 c6 02	 add	 esi, 2
  00260	3a cb		 cmp	 cl, bl
  00262	75 e4		 jne	 SHORT $LL6394@AddRenderI
$LN6604@AddRenderI:
  00264	33 c0		 xor	 eax, eax
  00266	eb 05		 jmp	 SHORT $LN6397@AddRenderI
$LN6395@AddRenderI:
  00268	1b c0		 sbb	 eax, eax
  0026a	83 d8 ff	 sbb	 eax, -1
$LN6397@AddRenderI:
  0026d	3b c3		 cmp	 eax, ebx
  0026f	75 30		 jne	 SHORT $LN6331@AddRenderI

; 205  : 	{
; 206  : 		SAFEDELETE( m_pRedDark );

  00271	39 9f 74 01 00
	00		 cmp	 DWORD PTR [edi+372], ebx
  00277	74 17		 je	 SHORT $LN155@AddRenderI
  00279	8b 8f 74 01 00
	00		 mov	 ecx, DWORD PTR [edi+372]
  0027f	3b cb		 cmp	 ecx, ebx
  00281	74 07		 je	 SHORT $LN174@AddRenderI
  00283	8b 01		 mov	 eax, DWORD PTR [ecx]
  00285	6a 01		 push	 1
  00287	ff 50 40	 call	 DWORD PTR [eax+64]
$LN174@AddRenderI:
  0028a	89 9f 74 01 00
	00		 mov	 DWORD PTR [edi+372], ebx
$LN155@AddRenderI:

; 207  : 		m_pRedDark = pImage;

  00290	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  00296	89 87 74 01 00
	00		 mov	 DWORD PTR [edi+372], eax
  0029c	e9 c0 22 00 00	 jmp	 $LN1@AddRenderI
$LN6331@AddRenderI:

; 208  : 	}
; 209  : 	else if( szType == "RedLight" )

  002a1	6a 02		 push	 2
  002a3	c7 85 7c fc ff
	ff bf 89 8f a6	 mov	 DWORD PTR __t$559423[ebp], -1500542529 ; a68f89bfH
  002ad	c7 85 80 fc ff
	ff 84 8b 83 9e	 mov	 DWORD PTR __t$559423[ebp+4], -1635546236 ; 9e838b84H
  002b7	8d 85 7c fc ff
	ff		 lea	 eax, DWORD PTR __t$559423[ebp]
  002bd	88 9d 84 fc ff
	ff		 mov	 BYTE PTR __t$559423[ebp+8], bl
  002c3	59		 pop	 ecx
$LL805@AddRenderI:
  002c4	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  002ca	83 c0 04	 add	 eax, 4
  002cd	49		 dec	 ecx
  002ce	75 f4		 jne	 SHORT $LL805@AddRenderI
  002d0	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  002d6	8d b5 7c fc ff
	ff		 lea	 esi, DWORD PTR __t$559423[ebp]
  002dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6398@AddRenderI:
  002e2	8a 08		 mov	 cl, BYTE PTR [eax]
  002e4	3a 0e		 cmp	 cl, BYTE PTR [esi]
  002e6	75 1a		 jne	 SHORT $LN6399@AddRenderI
  002e8	3a cb		 cmp	 cl, bl
  002ea	74 12		 je	 SHORT $LN6400@AddRenderI
  002ec	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  002ef	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  002f2	75 0e		 jne	 SHORT $LN6399@AddRenderI
  002f4	83 c0 02	 add	 eax, 2
  002f7	83 c6 02	 add	 esi, 2
  002fa	3a cb		 cmp	 cl, bl
  002fc	75 e4		 jne	 SHORT $LL6398@AddRenderI
$LN6400@AddRenderI:
  002fe	33 c0		 xor	 eax, eax
  00300	eb 05		 jmp	 SHORT $LN6401@AddRenderI
$LN6399@AddRenderI:
  00302	1b c0		 sbb	 eax, eax
  00304	83 d8 ff	 sbb	 eax, -1
$LN6401@AddRenderI:
  00307	3b c3		 cmp	 eax, ebx
  00309	75 30		 jne	 SHORT $LN6332@AddRenderI

; 210  : 	{
; 211  : 		SAFEDELETE( m_pRedLight );

  0030b	39 9f 78 01 00
	00		 cmp	 DWORD PTR [edi+376], ebx
  00311	74 17		 je	 SHORT $LN152@AddRenderI
  00313	8b 8f 78 01 00
	00		 mov	 ecx, DWORD PTR [edi+376]
  00319	3b cb		 cmp	 ecx, ebx
  0031b	74 07		 je	 SHORT $LN176@AddRenderI
  0031d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0031f	6a 01		 push	 1
  00321	ff 50 40	 call	 DWORD PTR [eax+64]
$LN176@AddRenderI:
  00324	89 9f 78 01 00
	00		 mov	 DWORD PTR [edi+376], ebx
$LN152@AddRenderI:

; 212  : 		m_pRedLight = pImage;

  0032a	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  00330	89 87 78 01 00
	00		 mov	 DWORD PTR [edi+376], eax
  00336	e9 26 22 00 00	 jmp	 $LN1@AddRenderI
$LN6332@AddRenderI:

; 213  : 	}
; 214  : 	else if( szType == "RedOver" )

  0033b	6a 04		 push	 4
  0033d	c7 45 e4 bf 89
	8f a5		 mov	 DWORD PTR __t$559522[ebp], -1517319745 ; a58f89bfH
  00344	81 75 e4 ed ec
	eb ea		 xor	 DWORD PTR __t$559522[ebp], -353637139 ; eaebecedH
  0034b	c7 45 e8 9b 89
	99 00		 mov	 DWORD PTR __t$559522[ebp+4], 10062235 ; 0099899bH
  00352	58		 pop	 eax
$LL908@AddRenderI:
  00353	8b c8		 mov	 ecx, eax
  00355	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0035b	79 05		 jns	 SHORT $LN6624@AddRenderI
  0035d	49		 dec	 ecx
  0035e	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00361	41		 inc	 ecx
$LN6624@AddRenderI:
  00362	b2 ed		 mov	 dl, -19			; ffffffedH
  00364	2a d1		 sub	 dl, cl
  00366	30 54 05 e4	 xor	 BYTE PTR __t$559522[ebp+eax], dl
  0036a	40		 inc	 eax
  0036b	83 f8 07	 cmp	 eax, 7
  0036e	7c e3		 jl	 SHORT $LL908@AddRenderI
  00370	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  00376	8d 75 e4	 lea	 esi, DWORD PTR __t$559522[ebp]
  00379	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6402@AddRenderI:
  0037f	8a 08		 mov	 cl, BYTE PTR [eax]
  00381	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00383	75 1a		 jne	 SHORT $LN6403@AddRenderI
  00385	3a cb		 cmp	 cl, bl
  00387	74 12		 je	 SHORT $LN6605@AddRenderI
  00389	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  0038c	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  0038f	75 0e		 jne	 SHORT $LN6403@AddRenderI
  00391	83 c0 02	 add	 eax, 2
  00394	83 c6 02	 add	 esi, 2
  00397	3a cb		 cmp	 cl, bl
  00399	75 e4		 jne	 SHORT $LL6402@AddRenderI
$LN6605@AddRenderI:
  0039b	33 c0		 xor	 eax, eax
  0039d	eb 05		 jmp	 SHORT $LN6405@AddRenderI
$LN6403@AddRenderI:
  0039f	1b c0		 sbb	 eax, eax
  003a1	83 d8 ff	 sbb	 eax, -1
$LN6405@AddRenderI:
  003a4	3b c3		 cmp	 eax, ebx
  003a6	75 30		 jne	 SHORT $LN6333@AddRenderI

; 215  : 	{
; 216  : 		SAFEDELETE( m_pRedOver );

  003a8	39 9f 7c 01 00
	00		 cmp	 DWORD PTR [edi+380], ebx
  003ae	74 17		 je	 SHORT $LN149@AddRenderI
  003b0	8b 8f 7c 01 00
	00		 mov	 ecx, DWORD PTR [edi+380]
  003b6	3b cb		 cmp	 ecx, ebx
  003b8	74 07		 je	 SHORT $LN178@AddRenderI
  003ba	8b 01		 mov	 eax, DWORD PTR [ecx]
  003bc	6a 01		 push	 1
  003be	ff 50 40	 call	 DWORD PTR [eax+64]
$LN178@AddRenderI:
  003c1	89 9f 7c 01 00
	00		 mov	 DWORD PTR [edi+380], ebx
$LN149@AddRenderI:

; 217  : 		m_pRedOver = pImage;

  003c7	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  003cd	89 87 7c 01 00
	00		 mov	 DWORD PTR [edi+380], eax
  003d3	e9 89 21 00 00	 jmp	 $LN1@AddRenderI
$LN6333@AddRenderI:

; 218  : 	}
; 219  : 	else if( szType == "PCRoomBlue" )

  003d8	6a 02		 push	 2
  003da	c7 85 f0 fd ff
	ff bd af b9 85	 mov	 DWORD PTR __t$559647[ebp], -2051428419 ; 85b9afbdH
  003e4	c7 85 f4 fd ff
	ff 82 81 a9 86	 mov	 DWORD PTR __t$559647[ebp+4], -2035711614 ; 86a98182H
  003ee	66 c7 85 f8 fd
	ff ff 98 89	 mov	 WORD PTR __t$559647[ebp+8], 35224 ; 00008998H
  003f7	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR __t$559647[ebp]
  003fd	88 9d fa fd ff
	ff		 mov	 BYTE PTR __t$559647[ebp+10], bl
  00403	59		 pop	 ecx
$LL1017@AddRenderI:
  00404	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0040a	83 c0 04	 add	 eax, 4
  0040d	49		 dec	 ecx
  0040e	75 f4		 jne	 SHORT $LL1017@AddRenderI
  00410	6a 08		 push	 8
  00412	58		 pop	 eax
$LL1014@AddRenderI:
  00413	8b c8		 mov	 ecx, eax
  00415	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0041b	79 05		 jns	 SHORT $LN6625@AddRenderI
  0041d	49		 dec	 ecx
  0041e	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00421	41		 inc	 ecx
$LN6625@AddRenderI:
  00422	b2 ed		 mov	 dl, -19			; ffffffedH
  00424	2a d1		 sub	 dl, cl
  00426	30 94 05 f0 fd
	ff ff		 xor	 BYTE PTR __t$559647[ebp+eax], dl
  0042d	40		 inc	 eax
  0042e	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00431	7c e0		 jl	 SHORT $LL1014@AddRenderI
  00433	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  00439	8d b5 f0 fd ff
	ff		 lea	 esi, DWORD PTR __t$559647[ebp]
  0043f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6406@AddRenderI:
  00445	8a 08		 mov	 cl, BYTE PTR [eax]
  00447	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00449	75 1a		 jne	 SHORT $LN6407@AddRenderI
  0044b	3a cb		 cmp	 cl, bl
  0044d	74 12		 je	 SHORT $LN6606@AddRenderI
  0044f	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00452	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  00455	75 0e		 jne	 SHORT $LN6407@AddRenderI
  00457	83 c0 02	 add	 eax, 2
  0045a	83 c6 02	 add	 esi, 2
  0045d	3a cb		 cmp	 cl, bl
  0045f	75 e4		 jne	 SHORT $LL6406@AddRenderI
$LN6606@AddRenderI:
  00461	33 c0		 xor	 eax, eax
  00463	eb 05		 jmp	 SHORT $LN6409@AddRenderI
$LN6407@AddRenderI:
  00465	1b c0		 sbb	 eax, eax
  00467	83 d8 ff	 sbb	 eax, -1
$LN6409@AddRenderI:
  0046a	3b c3		 cmp	 eax, ebx
  0046c	75 30		 jne	 SHORT $LN6334@AddRenderI

; 220  : 	{
; 221  : 		SAFEDELETE( m_pPCRoomBlue );

  0046e	39 9f 80 01 00
	00		 cmp	 DWORD PTR [edi+384], ebx
  00474	74 17		 je	 SHORT $LN146@AddRenderI
  00476	8b 8f 80 01 00
	00		 mov	 ecx, DWORD PTR [edi+384]
  0047c	3b cb		 cmp	 ecx, ebx
  0047e	74 07		 je	 SHORT $LN180@AddRenderI
  00480	8b 01		 mov	 eax, DWORD PTR [ecx]
  00482	6a 01		 push	 1
  00484	ff 50 40	 call	 DWORD PTR [eax+64]
$LN180@AddRenderI:
  00487	89 9f 80 01 00
	00		 mov	 DWORD PTR [edi+384], ebx
$LN146@AddRenderI:

; 222  : 		m_pPCRoomBlue = pImage;

  0048d	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  00493	89 87 80 01 00
	00		 mov	 DWORD PTR [edi+384], eax
  00499	e9 c3 20 00 00	 jmp	 $LN1@AddRenderI
$LN6334@AddRenderI:

; 223  : 	}
; 224  : 	else if( szType == "PCRoomRed" )

  0049e	6a 02		 push	 2
  004a0	c7 85 38 ff ff
	ff bd af b9 85	 mov	 DWORD PTR __t$559772[ebp], -2051428419 ; 85b9afbdH
  004aa	c7 85 3c ff ff
	ff 82 81 b9 8f	 mov	 DWORD PTR __t$559772[ebp+4], -1883668094 ; 8fb98182H
  004b4	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR __t$559772[ebp]
  004ba	66 c7 85 40 ff
	ff ff 89 00	 mov	 WORD PTR __t$559772[ebp+8], 137 ; 00000089H
  004c3	59		 pop	 ecx
$LL1123@AddRenderI:
  004c4	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  004ca	83 c0 04	 add	 eax, 4
  004cd	49		 dec	 ecx
  004ce	75 f4		 jne	 SHORT $LL1123@AddRenderI
  004d0	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  004d6	80 b5 40 ff ff
	ff ed		 xor	 BYTE PTR __t$559772[ebp+8], -19 ; ffffffedH
  004dd	8d b5 38 ff ff
	ff		 lea	 esi, DWORD PTR __t$559772[ebp]
  004e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6410@AddRenderI:
  004e9	8a 08		 mov	 cl, BYTE PTR [eax]
  004eb	3a 0e		 cmp	 cl, BYTE PTR [esi]
  004ed	75 1a		 jne	 SHORT $LN6411@AddRenderI
  004ef	3a cb		 cmp	 cl, bl
  004f1	74 12		 je	 SHORT $LN6607@AddRenderI
  004f3	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  004f6	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  004f9	75 0e		 jne	 SHORT $LN6411@AddRenderI
  004fb	83 c0 02	 add	 eax, 2
  004fe	83 c6 02	 add	 esi, 2
  00501	3a cb		 cmp	 cl, bl
  00503	75 e4		 jne	 SHORT $LL6410@AddRenderI
$LN6607@AddRenderI:
  00505	33 c0		 xor	 eax, eax
  00507	eb 05		 jmp	 SHORT $LN6413@AddRenderI
$LN6411@AddRenderI:
  00509	1b c0		 sbb	 eax, eax
  0050b	83 d8 ff	 sbb	 eax, -1
$LN6413@AddRenderI:
  0050e	3b c3		 cmp	 eax, ebx
  00510	75 30		 jne	 SHORT $LN6335@AddRenderI

; 225  : 	{
; 226  : 		SAFEDELETE( m_pPCRoomRed );

  00512	39 9f 84 01 00
	00		 cmp	 DWORD PTR [edi+388], ebx
  00518	74 17		 je	 SHORT $LN143@AddRenderI
  0051a	8b 8f 84 01 00
	00		 mov	 ecx, DWORD PTR [edi+388]
  00520	3b cb		 cmp	 ecx, ebx
  00522	74 07		 je	 SHORT $LN182@AddRenderI
  00524	8b 01		 mov	 eax, DWORD PTR [ecx]
  00526	6a 01		 push	 1
  00528	ff 50 40	 call	 DWORD PTR [eax+64]
$LN182@AddRenderI:
  0052b	89 9f 84 01 00
	00		 mov	 DWORD PTR [edi+388], ebx
$LN143@AddRenderI:

; 227  : 		m_pPCRoomRed = pImage;

  00531	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  00537	89 87 84 01 00
	00		 mov	 DWORD PTR [edi+388], eax
  0053d	e9 1f 20 00 00	 jmp	 $LN1@AddRenderI
$LN6335@AddRenderI:

; 228  : 	}
; 229  : 	else if( szType == "GuildBlue" )

  00542	6a 02		 push	 2
  00544	c7 85 6c fd ff
	ff aa 99 82 86	 mov	 DWORD PTR __t$559897[ebp], -2038261334 ; 868299aaH
  0054e	c7 85 70 fd ff
	ff 89 ae 87 9f	 mov	 DWORD PTR __t$559897[ebp+4], -1618497911 ; 9f87ae89H
  00558	8d 85 6c fd ff
	ff		 lea	 eax, DWORD PTR __t$559897[ebp]
  0055e	66 c7 85 74 fd
	ff ff 88 00	 mov	 WORD PTR __t$559897[ebp+8], 136 ; 00000088H
  00567	59		 pop	 ecx
$LL1229@AddRenderI:
  00568	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0056e	83 c0 04	 add	 eax, 4
  00571	49		 dec	 ecx
  00572	75 f4		 jne	 SHORT $LL1229@AddRenderI
  00574	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  0057a	80 b5 74 fd ff
	ff ed		 xor	 BYTE PTR __t$559897[ebp+8], -19 ; ffffffedH
  00581	8d b5 6c fd ff
	ff		 lea	 esi, DWORD PTR __t$559897[ebp]
  00587	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6414@AddRenderI:
  0058d	8a 08		 mov	 cl, BYTE PTR [eax]
  0058f	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00591	75 1a		 jne	 SHORT $LN6415@AddRenderI
  00593	3a cb		 cmp	 cl, bl
  00595	74 12		 je	 SHORT $LN6608@AddRenderI
  00597	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  0059a	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  0059d	75 0e		 jne	 SHORT $LN6415@AddRenderI
  0059f	83 c0 02	 add	 eax, 2
  005a2	83 c6 02	 add	 esi, 2
  005a5	3a cb		 cmp	 cl, bl
  005a7	75 e4		 jne	 SHORT $LL6414@AddRenderI
$LN6608@AddRenderI:
  005a9	33 c0		 xor	 eax, eax
  005ab	eb 05		 jmp	 SHORT $LN6417@AddRenderI
$LN6415@AddRenderI:
  005ad	1b c0		 sbb	 eax, eax
  005af	83 d8 ff	 sbb	 eax, -1
$LN6417@AddRenderI:
  005b2	3b c3		 cmp	 eax, ebx
  005b4	75 30		 jne	 SHORT $LN6336@AddRenderI

; 230  : 	{
; 231  : 		SAFEDELETE( m_pGuildBlue );

  005b6	39 9f 88 01 00
	00		 cmp	 DWORD PTR [edi+392], ebx
  005bc	74 17		 je	 SHORT $LN140@AddRenderI
  005be	8b 8f 88 01 00
	00		 mov	 ecx, DWORD PTR [edi+392]
  005c4	3b cb		 cmp	 ecx, ebx
  005c6	74 07		 je	 SHORT $LN184@AddRenderI
  005c8	8b 01		 mov	 eax, DWORD PTR [ecx]
  005ca	6a 01		 push	 1
  005cc	ff 50 40	 call	 DWORD PTR [eax+64]
$LN184@AddRenderI:
  005cf	89 9f 88 01 00
	00		 mov	 DWORD PTR [edi+392], ebx
$LN140@AddRenderI:

; 232  : 		m_pGuildBlue = pImage;

  005d5	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  005db	89 87 88 01 00
	00		 mov	 DWORD PTR [edi+392], eax
  005e1	e9 7b 1f 00 00	 jmp	 $LN1@AddRenderI
$LN6336@AddRenderI:

; 233  : 	}
; 234  : 	else if( szType == "GuildRed" )

  005e6	6a 02		 push	 2
  005e8	c7 85 ac fc ff
	ff aa 99 82 86	 mov	 DWORD PTR __t$560036[ebp], -2038261334 ; 868299aaH
  005f2	c7 85 b0 fc ff
	ff 89 be 8e 8e	 mov	 DWORD PTR __t$560036[ebp+4], -1903247735 ; 8e8ebe89H
  005fc	8d 85 ac fc ff
	ff		 lea	 eax, DWORD PTR __t$560036[ebp]
  00602	88 9d b4 fc ff
	ff		 mov	 BYTE PTR __t$560036[ebp+8], bl
  00608	59		 pop	 ecx
$LL1335@AddRenderI:
  00609	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0060f	83 c0 04	 add	 eax, 4
  00612	49		 dec	 ecx
  00613	75 f4		 jne	 SHORT $LL1335@AddRenderI
  00615	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  0061b	8d b5 ac fc ff
	ff		 lea	 esi, DWORD PTR __t$560036[ebp]
  00621	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6418@AddRenderI:
  00627	8a 08		 mov	 cl, BYTE PTR [eax]
  00629	3a 0e		 cmp	 cl, BYTE PTR [esi]
  0062b	75 1a		 jne	 SHORT $LN6419@AddRenderI
  0062d	3a cb		 cmp	 cl, bl
  0062f	74 12		 je	 SHORT $LN6609@AddRenderI
  00631	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00634	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  00637	75 0e		 jne	 SHORT $LN6419@AddRenderI
  00639	83 c0 02	 add	 eax, 2
  0063c	83 c6 02	 add	 esi, 2
  0063f	3a cb		 cmp	 cl, bl
  00641	75 e4		 jne	 SHORT $LL6418@AddRenderI
$LN6609@AddRenderI:
  00643	33 c0		 xor	 eax, eax
  00645	eb 05		 jmp	 SHORT $LN6421@AddRenderI
$LN6419@AddRenderI:
  00647	1b c0		 sbb	 eax, eax
  00649	83 d8 ff	 sbb	 eax, -1
$LN6421@AddRenderI:
  0064c	3b c3		 cmp	 eax, ebx
  0064e	75 30		 jne	 SHORT $LN6337@AddRenderI

; 235  : 	{
; 236  : 		SAFEDELETE( m_pGuildRed );

  00650	39 9f 8c 01 00
	00		 cmp	 DWORD PTR [edi+396], ebx
  00656	74 17		 je	 SHORT $LN137@AddRenderI
  00658	8b 8f 8c 01 00
	00		 mov	 ecx, DWORD PTR [edi+396]
  0065e	3b cb		 cmp	 ecx, ebx
  00660	74 07		 je	 SHORT $LN186@AddRenderI
  00662	8b 01		 mov	 eax, DWORD PTR [ecx]
  00664	6a 01		 push	 1
  00666	ff 50 40	 call	 DWORD PTR [eax+64]
$LN186@AddRenderI:
  00669	89 9f 8c 01 00
	00		 mov	 DWORD PTR [edi+396], ebx
$LN137@AddRenderI:

; 237  : 		m_pGuildRed = pImage;

  0066f	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  00675	89 87 8c 01 00
	00		 mov	 DWORD PTR [edi+396], eax
  0067b	e9 e1 1e 00 00	 jmp	 $LN1@AddRenderI
$LN6337@AddRenderI:

; 238  : 	}
; 239  : 	else if( szType == "FriendBlue" )

  00680	6a 02		 push	 2
  00682	c7 45 8c ab 9e
	82 8f		 mov	 DWORD PTR __t$560160[ebp], -1887265109 ; 8f829eabH
  00689	c7 45 90 83 88
	a9 86		 mov	 DWORD PTR __t$560160[ebp+4], -2035709821 ; 86a98883H
  00690	66 c7 45 94 98
	89		 mov	 WORD PTR __t$560160[ebp+8], 35224 ; 00008998H
  00696	8d 45 8c	 lea	 eax, DWORD PTR __t$560160[ebp]
  00699	88 5d 96	 mov	 BYTE PTR __t$560160[ebp+10], bl
  0069c	59		 pop	 ecx
$LL1441@AddRenderI:
  0069d	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  006a3	83 c0 04	 add	 eax, 4
  006a6	49		 dec	 ecx
  006a7	75 f4		 jne	 SHORT $LL1441@AddRenderI
  006a9	6a 08		 push	 8
  006ab	58		 pop	 eax
$LL1438@AddRenderI:
  006ac	8b c8		 mov	 ecx, eax
  006ae	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  006b4	79 05		 jns	 SHORT $LN6626@AddRenderI
  006b6	49		 dec	 ecx
  006b7	83 c9 fc	 or	 ecx, -4			; fffffffcH
  006ba	41		 inc	 ecx
$LN6626@AddRenderI:
  006bb	b2 ed		 mov	 dl, -19			; ffffffedH
  006bd	2a d1		 sub	 dl, cl
  006bf	30 54 05 8c	 xor	 BYTE PTR __t$560160[ebp+eax], dl
  006c3	40		 inc	 eax
  006c4	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  006c7	7c e3		 jl	 SHORT $LL1438@AddRenderI
  006c9	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  006cf	8d 75 8c	 lea	 esi, DWORD PTR __t$560160[ebp]
  006d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6422@AddRenderI:
  006d8	8a 08		 mov	 cl, BYTE PTR [eax]
  006da	3a 0e		 cmp	 cl, BYTE PTR [esi]
  006dc	75 1a		 jne	 SHORT $LN6423@AddRenderI
  006de	3a cb		 cmp	 cl, bl
  006e0	74 12		 je	 SHORT $LN6610@AddRenderI
  006e2	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  006e5	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  006e8	75 0e		 jne	 SHORT $LN6423@AddRenderI
  006ea	83 c0 02	 add	 eax, 2
  006ed	83 c6 02	 add	 esi, 2
  006f0	3a cb		 cmp	 cl, bl
  006f2	75 e4		 jne	 SHORT $LL6422@AddRenderI
$LN6610@AddRenderI:
  006f4	33 c0		 xor	 eax, eax
  006f6	eb 05		 jmp	 SHORT $LN6425@AddRenderI
$LN6423@AddRenderI:
  006f8	1b c0		 sbb	 eax, eax
  006fa	83 d8 ff	 sbb	 eax, -1
$LN6425@AddRenderI:
  006fd	3b c3		 cmp	 eax, ebx
  006ff	75 30		 jne	 SHORT $LN6338@AddRenderI

; 240  : 	{
; 241  : 		SAFEDELETE( m_pFriendBlue );

  00701	39 9f 90 01 00
	00		 cmp	 DWORD PTR [edi+400], ebx
  00707	74 17		 je	 SHORT $LN134@AddRenderI
  00709	8b 8f 90 01 00
	00		 mov	 ecx, DWORD PTR [edi+400]
  0070f	3b cb		 cmp	 ecx, ebx
  00711	74 07		 je	 SHORT $LN188@AddRenderI
  00713	8b 01		 mov	 eax, DWORD PTR [ecx]
  00715	6a 01		 push	 1
  00717	ff 50 40	 call	 DWORD PTR [eax+64]
$LN188@AddRenderI:
  0071a	89 9f 90 01 00
	00		 mov	 DWORD PTR [edi+400], ebx
$LN134@AddRenderI:

; 242  : 		m_pFriendBlue = pImage;

  00720	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  00726	89 87 90 01 00
	00		 mov	 DWORD PTR [edi+400], eax
  0072c	e9 30 1e 00 00	 jmp	 $LN1@AddRenderI
$LN6338@AddRenderI:

; 243  : 	}
; 244  : 	else if( szType == "FriendRed" )

  00731	6a 02		 push	 2
  00733	c7 85 14 ff ff
	ff ab 9e 82 8f	 mov	 DWORD PTR __t$560285[ebp], -1887265109 ; 8f829eabH
  0073d	c7 85 18 ff ff
	ff 83 88 b9 8f	 mov	 DWORD PTR __t$560285[ebp+4], -1883666301 ; 8fb98883H
  00747	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR __t$560285[ebp]
  0074d	66 c7 85 1c ff
	ff ff 89 00	 mov	 WORD PTR __t$560285[ebp+8], 137 ; 00000089H
  00756	59		 pop	 ecx
$LL1547@AddRenderI:
  00757	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0075d	83 c0 04	 add	 eax, 4
  00760	49		 dec	 ecx
  00761	75 f4		 jne	 SHORT $LL1547@AddRenderI
  00763	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  00769	80 b5 1c ff ff
	ff ed		 xor	 BYTE PTR __t$560285[ebp+8], -19 ; ffffffedH
  00770	8d b5 14 ff ff
	ff		 lea	 esi, DWORD PTR __t$560285[ebp]
  00776	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6426@AddRenderI:
  0077c	8a 08		 mov	 cl, BYTE PTR [eax]
  0077e	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00780	75 1a		 jne	 SHORT $LN6427@AddRenderI
  00782	3a cb		 cmp	 cl, bl
  00784	74 12		 je	 SHORT $LN6428@AddRenderI
  00786	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00789	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  0078c	75 0e		 jne	 SHORT $LN6427@AddRenderI
  0078e	83 c0 02	 add	 eax, 2
  00791	83 c6 02	 add	 esi, 2
  00794	3a cb		 cmp	 cl, bl
  00796	75 e4		 jne	 SHORT $LL6426@AddRenderI
$LN6428@AddRenderI:
  00798	33 c0		 xor	 eax, eax
  0079a	eb 05		 jmp	 SHORT $LN6429@AddRenderI
$LN6427@AddRenderI:
  0079c	1b c0		 sbb	 eax, eax
  0079e	83 d8 ff	 sbb	 eax, -1
$LN6429@AddRenderI:
  007a1	3b c3		 cmp	 eax, ebx
  007a3	75 30		 jne	 SHORT $LN6339@AddRenderI

; 245  : 	{
; 246  : 		SAFEDELETE( m_pFriendRed );

  007a5	39 9f 94 01 00
	00		 cmp	 DWORD PTR [edi+404], ebx
  007ab	74 17		 je	 SHORT $LN131@AddRenderI
  007ad	8b 8f 94 01 00
	00		 mov	 ecx, DWORD PTR [edi+404]
  007b3	3b cb		 cmp	 ecx, ebx
  007b5	74 07		 je	 SHORT $LN190@AddRenderI
  007b7	8b 01		 mov	 eax, DWORD PTR [ecx]
  007b9	6a 01		 push	 1
  007bb	ff 50 40	 call	 DWORD PTR [eax+64]
$LN190@AddRenderI:
  007be	89 9f 94 01 00
	00		 mov	 DWORD PTR [edi+404], ebx
$LN131@AddRenderI:

; 247  : 		m_pFriendRed = pImage;

  007c4	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  007ca	89 87 94 01 00
	00		 mov	 DWORD PTR [edi+404], eax
  007d0	e9 8c 1d 00 00	 jmp	 $LN1@AddRenderI
$LN6339@AddRenderI:

; 248  : 	}
; 249  : 	else if( szType == "VictoriesBlue1" )

  007d5	6a 03		 push	 3
  007d7	c7 85 dc fe ff
	ff bb 85 88 9e	 mov	 DWORD PTR __t$560410[ebp], -1635220037 ; 9e8885bbH
  007e1	c7 85 e0 fe ff
	ff 82 9e 82 8f	 mov	 DWORD PTR __t$560410[ebp+4], -1887265150 ; 8f829e82H
  007eb	c7 85 e4 fe ff
	ff 9e ae 87 9f	 mov	 DWORD PTR __t$560410[ebp+8], -1618497890 ; 9f87ae9eH
  007f5	66 c7 85 e8 fe
	ff ff 88 dd	 mov	 WORD PTR __t$560410[ebp+12], 56712 ; 0000dd88H
  007fe	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR __t$560410[ebp]
  00804	88 9d ea fe ff
	ff		 mov	 BYTE PTR __t$560410[ebp+14], bl
  0080a	59		 pop	 ecx
$LL1653@AddRenderI:
  0080b	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00811	83 c0 04	 add	 eax, 4
  00814	49		 dec	 ecx
  00815	75 f4		 jne	 SHORT $LL1653@AddRenderI
  00817	6a 0c		 push	 12			; 0000000cH
  00819	58		 pop	 eax
$LL1650@AddRenderI:
  0081a	8b c8		 mov	 ecx, eax
  0081c	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00822	79 05		 jns	 SHORT $LN6627@AddRenderI
  00824	49		 dec	 ecx
  00825	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00828	41		 inc	 ecx
$LN6627@AddRenderI:
  00829	b2 ed		 mov	 dl, -19			; ffffffedH
  0082b	2a d1		 sub	 dl, cl
  0082d	30 94 05 dc fe
	ff ff		 xor	 BYTE PTR __t$560410[ebp+eax], dl
  00834	40		 inc	 eax
  00835	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  00838	7c e0		 jl	 SHORT $LL1650@AddRenderI
  0083a	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  00840	8d b5 dc fe ff
	ff		 lea	 esi, DWORD PTR __t$560410[ebp]
  00846	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6430@AddRenderI:
  0084c	8a 08		 mov	 cl, BYTE PTR [eax]
  0084e	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00850	75 1a		 jne	 SHORT $LN6431@AddRenderI
  00852	3a cb		 cmp	 cl, bl
  00854	74 12		 je	 SHORT $LN6432@AddRenderI
  00856	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00859	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  0085c	75 0e		 jne	 SHORT $LN6431@AddRenderI
  0085e	83 c0 02	 add	 eax, 2
  00861	83 c6 02	 add	 esi, 2
  00864	3a cb		 cmp	 cl, bl
  00866	75 e4		 jne	 SHORT $LL6430@AddRenderI
$LN6432@AddRenderI:
  00868	33 c0		 xor	 eax, eax
  0086a	eb 05		 jmp	 SHORT $LN6433@AddRenderI
$LN6431@AddRenderI:
  0086c	1b c0		 sbb	 eax, eax
  0086e	83 d8 ff	 sbb	 eax, -1
$LN6433@AddRenderI:
  00871	3b c3		 cmp	 eax, ebx
  00873	75 30		 jne	 SHORT $LN6340@AddRenderI

; 250  : 	{
; 251  : 		SAFEDELETE( m_pVictoriesBlue1 );

  00875	39 9f 98 01 00
	00		 cmp	 DWORD PTR [edi+408], ebx
  0087b	74 17		 je	 SHORT $LN128@AddRenderI
  0087d	8b 8f 98 01 00
	00		 mov	 ecx, DWORD PTR [edi+408]
  00883	3b cb		 cmp	 ecx, ebx
  00885	74 07		 je	 SHORT $LN192@AddRenderI
  00887	8b 01		 mov	 eax, DWORD PTR [ecx]
  00889	6a 01		 push	 1
  0088b	ff 50 40	 call	 DWORD PTR [eax+64]
$LN192@AddRenderI:
  0088e	89 9f 98 01 00
	00		 mov	 DWORD PTR [edi+408], ebx
$LN128@AddRenderI:

; 252  : 		m_pVictoriesBlue1 = pImage;

  00894	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  0089a	89 87 98 01 00
	00		 mov	 DWORD PTR [edi+408], eax
  008a0	e9 bc 1c 00 00	 jmp	 $LN1@AddRenderI
$LN6340@AddRenderI:

; 253  : 	}
; 254  : 	else if( szType == "VictoriesRed1" )

  008a5	6a 03		 push	 3
  008a7	c7 85 c8 fd ff
	ff bb 85 88 9e	 mov	 DWORD PTR __t$560535[ebp], -1635220037 ; 9e8885bbH
  008b1	c7 85 cc fd ff
	ff 82 9e 82 8f	 mov	 DWORD PTR __t$560535[ebp+4], -1887265150 ; 8f829e82H
  008bb	c7 85 d0 fd ff
	ff 9e be 8e 8e	 mov	 DWORD PTR __t$560535[ebp+8], -1903247714 ; 8e8ebe9eH
  008c5	8d 85 c8 fd ff
	ff		 lea	 eax, DWORD PTR __t$560535[ebp]
  008cb	66 c7 85 d4 fd
	ff ff dc 00	 mov	 WORD PTR __t$560535[ebp+12], 220 ; 000000dcH
  008d4	59		 pop	 ecx
$LL1759@AddRenderI:
  008d5	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  008db	83 c0 04	 add	 eax, 4
  008de	49		 dec	 ecx
  008df	75 f4		 jne	 SHORT $LL1759@AddRenderI
  008e1	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  008e7	80 b5 d4 fd ff
	ff ed		 xor	 BYTE PTR __t$560535[ebp+12], -19 ; ffffffedH
  008ee	8d b5 c8 fd ff
	ff		 lea	 esi, DWORD PTR __t$560535[ebp]
  008f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6434@AddRenderI:
  008fa	8a 08		 mov	 cl, BYTE PTR [eax]
  008fc	3a 0e		 cmp	 cl, BYTE PTR [esi]
  008fe	75 1a		 jne	 SHORT $LN6435@AddRenderI
  00900	3a cb		 cmp	 cl, bl
  00902	74 12		 je	 SHORT $LN6436@AddRenderI
  00904	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00907	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  0090a	75 0e		 jne	 SHORT $LN6435@AddRenderI
  0090c	83 c0 02	 add	 eax, 2
  0090f	83 c6 02	 add	 esi, 2
  00912	3a cb		 cmp	 cl, bl
  00914	75 e4		 jne	 SHORT $LL6434@AddRenderI
$LN6436@AddRenderI:
  00916	33 c0		 xor	 eax, eax
  00918	eb 05		 jmp	 SHORT $LN6437@AddRenderI
$LN6435@AddRenderI:
  0091a	1b c0		 sbb	 eax, eax
  0091c	83 d8 ff	 sbb	 eax, -1
$LN6437@AddRenderI:
  0091f	3b c3		 cmp	 eax, ebx
  00921	75 30		 jne	 SHORT $LN6341@AddRenderI

; 255  : 	{
; 256  : 		SAFEDELETE( m_pVictoriesRed1 );

  00923	39 9f 9c 01 00
	00		 cmp	 DWORD PTR [edi+412], ebx
  00929	74 17		 je	 SHORT $LN125@AddRenderI
  0092b	8b 8f 9c 01 00
	00		 mov	 ecx, DWORD PTR [edi+412]
  00931	3b cb		 cmp	 ecx, ebx
  00933	74 07		 je	 SHORT $LN194@AddRenderI
  00935	8b 01		 mov	 eax, DWORD PTR [ecx]
  00937	6a 01		 push	 1
  00939	ff 50 40	 call	 DWORD PTR [eax+64]
$LN194@AddRenderI:
  0093c	89 9f 9c 01 00
	00		 mov	 DWORD PTR [edi+412], ebx
$LN125@AddRenderI:

; 257  : 		m_pVictoriesRed1 = pImage;

  00942	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  00948	89 87 9c 01 00
	00		 mov	 DWORD PTR [edi+412], eax
  0094e	e9 0e 1c 00 00	 jmp	 $LN1@AddRenderI
$LN6341@AddRenderI:

; 258  : 	}
; 259  : 	else if( szType == "VictoriesBlue2" )

  00953	6a 03		 push	 3
  00955	c7 85 b8 fe ff
	ff bb 85 88 9e	 mov	 DWORD PTR __t$560647[ebp], -1635220037 ; 9e8885bbH
  0095f	c7 85 bc fe ff
	ff 82 9e 82 8f	 mov	 DWORD PTR __t$560647[ebp+4], -1887265150 ; 8f829e82H
  00969	c7 85 c0 fe ff
	ff 9e ae 87 9f	 mov	 DWORD PTR __t$560647[ebp+8], -1618497890 ; 9f87ae9eH
  00973	66 c7 85 c4 fe
	ff ff 88 de	 mov	 WORD PTR __t$560647[ebp+12], 56968 ; 0000de88H
  0097c	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR __t$560647[ebp]
  00982	88 9d c6 fe ff
	ff		 mov	 BYTE PTR __t$560647[ebp+14], bl
  00988	59		 pop	 ecx
$LL1865@AddRenderI:
  00989	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0098f	83 c0 04	 add	 eax, 4
  00992	49		 dec	 ecx
  00993	75 f4		 jne	 SHORT $LL1865@AddRenderI
  00995	6a 0c		 push	 12			; 0000000cH
  00997	58		 pop	 eax
$LL1862@AddRenderI:
  00998	8b c8		 mov	 ecx, eax
  0099a	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  009a0	79 05		 jns	 SHORT $LN6628@AddRenderI
  009a2	49		 dec	 ecx
  009a3	83 c9 fc	 or	 ecx, -4			; fffffffcH
  009a6	41		 inc	 ecx
$LN6628@AddRenderI:
  009a7	b2 ed		 mov	 dl, -19			; ffffffedH
  009a9	2a d1		 sub	 dl, cl
  009ab	30 94 05 b8 fe
	ff ff		 xor	 BYTE PTR __t$560647[ebp+eax], dl
  009b2	40		 inc	 eax
  009b3	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  009b6	7c e0		 jl	 SHORT $LL1862@AddRenderI
  009b8	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  009be	8d b5 b8 fe ff
	ff		 lea	 esi, DWORD PTR __t$560647[ebp]
  009c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6438@AddRenderI:
  009ca	8a 08		 mov	 cl, BYTE PTR [eax]
  009cc	3a 0e		 cmp	 cl, BYTE PTR [esi]
  009ce	75 1a		 jne	 SHORT $LN6439@AddRenderI
  009d0	3a cb		 cmp	 cl, bl
  009d2	74 12		 je	 SHORT $LN6440@AddRenderI
  009d4	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  009d7	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  009da	75 0e		 jne	 SHORT $LN6439@AddRenderI
  009dc	83 c0 02	 add	 eax, 2
  009df	83 c6 02	 add	 esi, 2
  009e2	3a cb		 cmp	 cl, bl
  009e4	75 e4		 jne	 SHORT $LL6438@AddRenderI
$LN6440@AddRenderI:
  009e6	33 c0		 xor	 eax, eax
  009e8	eb 05		 jmp	 SHORT $LN6441@AddRenderI
$LN6439@AddRenderI:
  009ea	1b c0		 sbb	 eax, eax
  009ec	83 d8 ff	 sbb	 eax, -1
$LN6441@AddRenderI:
  009ef	3b c3		 cmp	 eax, ebx
  009f1	75 30		 jne	 SHORT $LN6342@AddRenderI

; 260  : 	{
; 261  : 		SAFEDELETE( m_pVictoriesBlue2 );

  009f3	39 9f a0 01 00
	00		 cmp	 DWORD PTR [edi+416], ebx
  009f9	74 17		 je	 SHORT $LN122@AddRenderI
  009fb	8b 8f a0 01 00
	00		 mov	 ecx, DWORD PTR [edi+416]
  00a01	3b cb		 cmp	 ecx, ebx
  00a03	74 07		 je	 SHORT $LN196@AddRenderI
  00a05	8b 01		 mov	 eax, DWORD PTR [ecx]
  00a07	6a 01		 push	 1
  00a09	ff 50 40	 call	 DWORD PTR [eax+64]
$LN196@AddRenderI:
  00a0c	89 9f a0 01 00
	00		 mov	 DWORD PTR [edi+416], ebx
$LN122@AddRenderI:

; 262  : 		m_pVictoriesBlue2 = pImage;

  00a12	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  00a18	89 87 a0 01 00
	00		 mov	 DWORD PTR [edi+416], eax
  00a1e	e9 3e 1b 00 00	 jmp	 $LN1@AddRenderI
$LN6342@AddRenderI:

; 263  : 	}
; 264  : 	else if( szType == "VictoriesRed2" )

  00a23	6a 03		 push	 3
  00a25	c7 85 5c fe ff
	ff bb 85 88 9e	 mov	 DWORD PTR __t$560772[ebp], -1635220037 ; 9e8885bbH
  00a2f	c7 85 60 fe ff
	ff 82 9e 82 8f	 mov	 DWORD PTR __t$560772[ebp+4], -1887265150 ; 8f829e82H
  00a39	c7 85 64 fe ff
	ff 9e be 8e 8e	 mov	 DWORD PTR __t$560772[ebp+8], -1903247714 ; 8e8ebe9eH
  00a43	8d 85 5c fe ff
	ff		 lea	 eax, DWORD PTR __t$560772[ebp]
  00a49	66 c7 85 68 fe
	ff ff df 00	 mov	 WORD PTR __t$560772[ebp+12], 223 ; 000000dfH
  00a52	59		 pop	 ecx
$LL1971@AddRenderI:
  00a53	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00a59	83 c0 04	 add	 eax, 4
  00a5c	49		 dec	 ecx
  00a5d	75 f4		 jne	 SHORT $LL1971@AddRenderI
  00a5f	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  00a65	80 b5 68 fe ff
	ff ed		 xor	 BYTE PTR __t$560772[ebp+12], -19 ; ffffffedH
  00a6c	8d b5 5c fe ff
	ff		 lea	 esi, DWORD PTR __t$560772[ebp]
  00a72	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6442@AddRenderI:
  00a78	8a 08		 mov	 cl, BYTE PTR [eax]
  00a7a	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00a7c	75 1a		 jne	 SHORT $LN6443@AddRenderI
  00a7e	3a cb		 cmp	 cl, bl
  00a80	74 12		 je	 SHORT $LN6444@AddRenderI
  00a82	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00a85	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  00a88	75 0e		 jne	 SHORT $LN6443@AddRenderI
  00a8a	83 c0 02	 add	 eax, 2
  00a8d	83 c6 02	 add	 esi, 2
  00a90	3a cb		 cmp	 cl, bl
  00a92	75 e4		 jne	 SHORT $LL6442@AddRenderI
$LN6444@AddRenderI:
  00a94	33 c0		 xor	 eax, eax
  00a96	eb 05		 jmp	 SHORT $LN6445@AddRenderI
$LN6443@AddRenderI:
  00a98	1b c0		 sbb	 eax, eax
  00a9a	83 d8 ff	 sbb	 eax, -1
$LN6445@AddRenderI:
  00a9d	3b c3		 cmp	 eax, ebx
  00a9f	75 30		 jne	 SHORT $LN6343@AddRenderI

; 265  : 	{
; 266  : 		SAFEDELETE( m_pVictoriesRed2 );

  00aa1	39 9f a4 01 00
	00		 cmp	 DWORD PTR [edi+420], ebx
  00aa7	74 17		 je	 SHORT $LN119@AddRenderI
  00aa9	8b 8f a4 01 00
	00		 mov	 ecx, DWORD PTR [edi+420]
  00aaf	3b cb		 cmp	 ecx, ebx
  00ab1	74 07		 je	 SHORT $LN198@AddRenderI
  00ab3	8b 01		 mov	 eax, DWORD PTR [ecx]
  00ab5	6a 01		 push	 1
  00ab7	ff 50 40	 call	 DWORD PTR [eax+64]
$LN198@AddRenderI:
  00aba	89 9f a4 01 00
	00		 mov	 DWORD PTR [edi+420], ebx
$LN119@AddRenderI:

; 267  : 		m_pVictoriesRed2 = pImage;

  00ac0	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  00ac6	89 87 a4 01 00
	00		 mov	 DWORD PTR [edi+420], eax
  00acc	e9 90 1a 00 00	 jmp	 $LN1@AddRenderI
$LN6343@AddRenderI:

; 268  : 	}
; 269  : 	else if( szType == "VictoriesNumBlue" )

  00ad1	6a 04		 push	 4
  00ad3	c7 85 54 fd ff
	ff bb 85 88 9e	 mov	 DWORD PTR __t$560897[ebp], -1635220037 ; 9e8885bbH
  00add	c7 85 58 fd ff
	ff 82 9e 82 8f	 mov	 DWORD PTR __t$560897[ebp+4], -1887265150 ; 8f829e82H
  00ae7	c7 85 5c fd ff
	ff 9e a2 9e 87	 mov	 DWORD PTR __t$560897[ebp+8], -2019646818 ; 879ea29eH
  00af1	c7 85 60 fd ff
	ff af 80 9e 8f	 mov	 DWORD PTR __t$560897[ebp+12], -1885437777 ; 8f9e80afH
  00afb	8d 85 54 fd ff
	ff		 lea	 eax, DWORD PTR __t$560897[ebp]
  00b01	88 9d 64 fd ff
	ff		 mov	 BYTE PTR __t$560897[ebp+16], bl
  00b07	59		 pop	 ecx
$LL2077@AddRenderI:
  00b08	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00b0e	83 c0 04	 add	 eax, 4
  00b11	49		 dec	 ecx
  00b12	75 f4		 jne	 SHORT $LL2077@AddRenderI
  00b14	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  00b1a	8d b5 54 fd ff
	ff		 lea	 esi, DWORD PTR __t$560897[ebp]
  00b20	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6446@AddRenderI:
  00b26	8a 08		 mov	 cl, BYTE PTR [eax]
  00b28	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00b2a	75 1a		 jne	 SHORT $LN6447@AddRenderI
  00b2c	3a cb		 cmp	 cl, bl
  00b2e	74 12		 je	 SHORT $LN6448@AddRenderI
  00b30	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00b33	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  00b36	75 0e		 jne	 SHORT $LN6447@AddRenderI
  00b38	83 c0 02	 add	 eax, 2
  00b3b	83 c6 02	 add	 esi, 2
  00b3e	3a cb		 cmp	 cl, bl
  00b40	75 e4		 jne	 SHORT $LL6446@AddRenderI
$LN6448@AddRenderI:
  00b42	33 c0		 xor	 eax, eax
  00b44	eb 05		 jmp	 SHORT $LN6449@AddRenderI
$LN6447@AddRenderI:
  00b46	1b c0		 sbb	 eax, eax
  00b48	83 d8 ff	 sbb	 eax, -1
$LN6449@AddRenderI:
  00b4b	3b c3		 cmp	 eax, ebx
  00b4d	75 30		 jne	 SHORT $LN6344@AddRenderI

; 270  : 	{
; 271  : 		SAFEDELETE( m_pVictoriesNumBlue );

  00b4f	39 9f a8 01 00
	00		 cmp	 DWORD PTR [edi+424], ebx
  00b55	74 17		 je	 SHORT $LN116@AddRenderI
  00b57	8b 8f a8 01 00
	00		 mov	 ecx, DWORD PTR [edi+424]
  00b5d	3b cb		 cmp	 ecx, ebx
  00b5f	74 07		 je	 SHORT $LN200@AddRenderI
  00b61	8b 01		 mov	 eax, DWORD PTR [ecx]
  00b63	6a 01		 push	 1
  00b65	ff 50 40	 call	 DWORD PTR [eax+64]
$LN200@AddRenderI:
  00b68	89 9f a8 01 00
	00		 mov	 DWORD PTR [edi+424], ebx
$LN116@AddRenderI:

; 272  : 		m_pVictoriesNumBlue = pImage;

  00b6e	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  00b74	89 87 a8 01 00
	00		 mov	 DWORD PTR [edi+424], eax
  00b7a	e9 e2 19 00 00	 jmp	 $LN1@AddRenderI
$LN6344@AddRenderI:

; 273  : 	}
; 274  : 	else if( szType == "VictoriesNumRed" )

  00b7f	6a 03		 push	 3
  00b81	c7 85 24 fe ff
	ff bb 85 88 9e	 mov	 DWORD PTR __t$561022[ebp], -1635220037 ; 9e8885bbH
  00b8b	c7 85 28 fe ff
	ff 82 9e 82 8f	 mov	 DWORD PTR __t$561022[ebp+4], -1887265150 ; 8f829e82H
  00b95	c7 85 2c fe ff
	ff 9e a2 9e 87	 mov	 DWORD PTR __t$561022[ebp+8], -2019646818 ; 879ea29eH
  00b9f	8d 85 24 fe ff
	ff		 lea	 eax, DWORD PTR __t$561022[ebp]
  00ba5	c7 85 30 fe ff
	ff bf 89 8f 00	 mov	 DWORD PTR __t$561022[ebp+12], 9406911 ; 008f89bfH
  00baf	59		 pop	 ecx
$LL2183@AddRenderI:
  00bb0	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00bb6	83 c0 04	 add	 eax, 4
  00bb9	49		 dec	 ecx
  00bba	75 f4		 jne	 SHORT $LL2183@AddRenderI
  00bbc	6a 0c		 push	 12			; 0000000cH
  00bbe	58		 pop	 eax
$LL2180@AddRenderI:
  00bbf	8b c8		 mov	 ecx, eax
  00bc1	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00bc7	79 05		 jns	 SHORT $LN6629@AddRenderI
  00bc9	49		 dec	 ecx
  00bca	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00bcd	41		 inc	 ecx
$LN6629@AddRenderI:
  00bce	b2 ed		 mov	 dl, -19			; ffffffedH
  00bd0	2a d1		 sub	 dl, cl
  00bd2	30 94 05 24 fe
	ff ff		 xor	 BYTE PTR __t$561022[ebp+eax], dl
  00bd9	40		 inc	 eax
  00bda	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00bdd	7c e0		 jl	 SHORT $LL2180@AddRenderI
  00bdf	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  00be5	8d b5 24 fe ff
	ff		 lea	 esi, DWORD PTR __t$561022[ebp]
  00beb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6450@AddRenderI:
  00bf1	8a 08		 mov	 cl, BYTE PTR [eax]
  00bf3	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00bf5	75 1a		 jne	 SHORT $LN6451@AddRenderI
  00bf7	3a cb		 cmp	 cl, bl
  00bf9	74 12		 je	 SHORT $LN6452@AddRenderI
  00bfb	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00bfe	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  00c01	75 0e		 jne	 SHORT $LN6451@AddRenderI
  00c03	83 c0 02	 add	 eax, 2
  00c06	83 c6 02	 add	 esi, 2
  00c09	3a cb		 cmp	 cl, bl
  00c0b	75 e4		 jne	 SHORT $LL6450@AddRenderI
$LN6452@AddRenderI:
  00c0d	33 c0		 xor	 eax, eax
  00c0f	eb 05		 jmp	 SHORT $LN6453@AddRenderI
$LN6451@AddRenderI:
  00c11	1b c0		 sbb	 eax, eax
  00c13	83 d8 ff	 sbb	 eax, -1
$LN6453@AddRenderI:
  00c16	3b c3		 cmp	 eax, ebx
  00c18	75 30		 jne	 SHORT $LN6345@AddRenderI

; 275  : 	{
; 276  : 		SAFEDELETE( m_pVictoriesNumRed );

  00c1a	39 9f ac 01 00
	00		 cmp	 DWORD PTR [edi+428], ebx
  00c20	74 17		 je	 SHORT $LN113@AddRenderI
  00c22	8b 8f ac 01 00
	00		 mov	 ecx, DWORD PTR [edi+428]
  00c28	3b cb		 cmp	 ecx, ebx
  00c2a	74 07		 je	 SHORT $LN202@AddRenderI
  00c2c	8b 01		 mov	 eax, DWORD PTR [ecx]
  00c2e	6a 01		 push	 1
  00c30	ff 50 40	 call	 DWORD PTR [eax+64]
$LN202@AddRenderI:
  00c33	89 9f ac 01 00
	00		 mov	 DWORD PTR [edi+428], ebx
$LN113@AddRenderI:

; 277  : 		m_pVictoriesNumRed = pImage;

  00c39	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  00c3f	89 87 ac 01 00
	00		 mov	 DWORD PTR [edi+428], eax
  00c45	e9 17 19 00 00	 jmp	 $LN1@AddRenderI
$LN6345@AddRenderI:

; 278  : 	}
; 279  : 	else if( szType == "ModeIconBack" )

  00c4a	6a 03		 push	 3
  00c4c	c7 85 f8 fc ff
	ff a0 83 8f 8f	 mov	 DWORD PTR __t$561147[ebp], -1886420064 ; 8f8f83a0H
  00c56	c7 85 fc fc ff
	ff a4 8f 84 84	 mov	 DWORD PTR __t$561147[ebp+4], -2071687260 ; 84848fa4H
  00c60	c7 85 00 fd ff
	ff af 8d 88 81	 mov	 DWORD PTR __t$561147[ebp+8], -2121757265 ; 81888dafH
  00c6a	8d 85 f8 fc ff
	ff		 lea	 eax, DWORD PTR __t$561147[ebp]
  00c70	88 9d 04 fd ff
	ff		 mov	 BYTE PTR __t$561147[ebp+12], bl
  00c76	59		 pop	 ecx
$LL2289@AddRenderI:
  00c77	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00c7d	83 c0 04	 add	 eax, 4
  00c80	49		 dec	 ecx
  00c81	75 f4		 jne	 SHORT $LL2289@AddRenderI
  00c83	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  00c89	8d b5 f8 fc ff
	ff		 lea	 esi, DWORD PTR __t$561147[ebp]
  00c8f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6454@AddRenderI:
  00c95	8a 08		 mov	 cl, BYTE PTR [eax]
  00c97	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00c99	75 1a		 jne	 SHORT $LN6455@AddRenderI
  00c9b	3a cb		 cmp	 cl, bl
  00c9d	74 12		 je	 SHORT $LN6611@AddRenderI
  00c9f	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00ca2	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  00ca5	75 0e		 jne	 SHORT $LN6455@AddRenderI
  00ca7	83 c0 02	 add	 eax, 2
  00caa	83 c6 02	 add	 esi, 2
  00cad	3a cb		 cmp	 cl, bl
  00caf	75 e4		 jne	 SHORT $LL6454@AddRenderI
$LN6611@AddRenderI:
  00cb1	33 c0		 xor	 eax, eax
  00cb3	eb 05		 jmp	 SHORT $LN6457@AddRenderI
$LN6455@AddRenderI:
  00cb5	1b c0		 sbb	 eax, eax
  00cb7	83 d8 ff	 sbb	 eax, -1
$LN6457@AddRenderI:
  00cba	3b c3		 cmp	 eax, ebx
  00cbc	75 30		 jne	 SHORT $LN6346@AddRenderI

; 280  : 	{
; 281  : 		SAFEDELETE( m_pModeIconBack );

  00cbe	39 9f b0 01 00
	00		 cmp	 DWORD PTR [edi+432], ebx
  00cc4	74 17		 je	 SHORT $LN110@AddRenderI
  00cc6	8b 8f b0 01 00
	00		 mov	 ecx, DWORD PTR [edi+432]
  00ccc	3b cb		 cmp	 ecx, ebx
  00cce	74 07		 je	 SHORT $LN204@AddRenderI
  00cd0	8b 01		 mov	 eax, DWORD PTR [ecx]
  00cd2	6a 01		 push	 1
  00cd4	ff 50 40	 call	 DWORD PTR [eax+64]
$LN204@AddRenderI:
  00cd7	89 9f b0 01 00
	00		 mov	 DWORD PTR [edi+432], ebx
$LN110@AddRenderI:

; 282  : 		m_pModeIconBack = pImage;

  00cdd	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  00ce3	89 87 b0 01 00
	00		 mov	 DWORD PTR [edi+432], eax
  00ce9	e9 73 18 00 00	 jmp	 $LN1@AddRenderI
$LN6346@AddRenderI:

; 283  : 	}
; 284  : 	else if( szType == "OrangeMan" )

  00cee	6a 02		 push	 2
  00cf0	c7 85 14 fe ff
	ff a2 9e 8a 84	 mov	 DWORD PTR __t$561285[ebp], -2071290206 ; 848a9ea2H
  00cfa	c7 85 18 fe ff
	ff 8a 89 a6 8b	 mov	 DWORD PTR __t$561285[ebp+4], -1952020086 ; 8ba6898aH
  00d04	8d 85 14 fe ff
	ff		 lea	 eax, DWORD PTR __t$561285[ebp]
  00d0a	66 c7 85 1c fe
	ff ff 83 00	 mov	 WORD PTR __t$561285[ebp+8], 131 ; 00000083H
  00d13	59		 pop	 ecx
$LL2395@AddRenderI:
  00d14	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00d1a	83 c0 04	 add	 eax, 4
  00d1d	49		 dec	 ecx
  00d1e	75 f4		 jne	 SHORT $LL2395@AddRenderI
  00d20	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  00d26	80 b5 1c fe ff
	ff ed		 xor	 BYTE PTR __t$561285[ebp+8], -19 ; ffffffedH
  00d2d	8d b5 14 fe ff
	ff		 lea	 esi, DWORD PTR __t$561285[ebp]
  00d33	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6458@AddRenderI:
  00d39	8a 08		 mov	 cl, BYTE PTR [eax]
  00d3b	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00d3d	75 1a		 jne	 SHORT $LN6459@AddRenderI
  00d3f	3a cb		 cmp	 cl, bl
  00d41	74 12		 je	 SHORT $LN6460@AddRenderI
  00d43	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00d46	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  00d49	75 0e		 jne	 SHORT $LN6459@AddRenderI
  00d4b	83 c0 02	 add	 eax, 2
  00d4e	83 c6 02	 add	 esi, 2
  00d51	3a cb		 cmp	 cl, bl
  00d53	75 e4		 jne	 SHORT $LL6458@AddRenderI
$LN6460@AddRenderI:
  00d55	33 c0		 xor	 eax, eax
  00d57	eb 05		 jmp	 SHORT $LN6461@AddRenderI
$LN6459@AddRenderI:
  00d59	1b c0		 sbb	 eax, eax
  00d5b	83 d8 ff	 sbb	 eax, -1
$LN6461@AddRenderI:
  00d5e	3b c3		 cmp	 eax, ebx
  00d60	75 30		 jne	 SHORT $LN6347@AddRenderI

; 285  : 	{
; 286  : 		SAFEDELETE( m_pOrangeMan );

  00d62	39 9f b4 01 00
	00		 cmp	 DWORD PTR [edi+436], ebx
  00d68	74 17		 je	 SHORT $LN107@AddRenderI
  00d6a	8b 8f b4 01 00
	00		 mov	 ecx, DWORD PTR [edi+436]
  00d70	3b cb		 cmp	 ecx, ebx
  00d72	74 07		 je	 SHORT $LN206@AddRenderI
  00d74	8b 01		 mov	 eax, DWORD PTR [ecx]
  00d76	6a 01		 push	 1
  00d78	ff 50 40	 call	 DWORD PTR [eax+64]
$LN206@AddRenderI:
  00d7b	89 9f b4 01 00
	00		 mov	 DWORD PTR [edi+436], ebx
$LN107@AddRenderI:

; 287  : 		m_pOrangeMan = pImage;

  00d81	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  00d87	89 87 b4 01 00
	00		 mov	 DWORD PTR [edi+436], eax
  00d8d	e9 cf 17 00 00	 jmp	 $LN1@AddRenderI
$LN6347@AddRenderI:

; 288  : 	}
; 289  : 	else if( szType == "GrayMan" )

  00d92	6a 04		 push	 4
  00d94	c7 45 d8 aa 9e
	8a 93		 mov	 DWORD PTR __t$561397[ebp], -1819631958 ; 938a9eaaH
  00d9b	81 75 d8 ed ec
	eb ea		 xor	 DWORD PTR __t$561397[ebp], -353637139 ; eaebecedH
  00da2	c7 45 dc a0 8d
	85 00		 mov	 DWORD PTR __t$561397[ebp+4], 8752544 ; 00858da0H
  00da9	58		 pop	 eax
$LL2498@AddRenderI:
  00daa	8b c8		 mov	 ecx, eax
  00dac	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00db2	79 05		 jns	 SHORT $LN6630@AddRenderI
  00db4	49		 dec	 ecx
  00db5	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00db8	41		 inc	 ecx
$LN6630@AddRenderI:
  00db9	b2 ed		 mov	 dl, -19			; ffffffedH
  00dbb	2a d1		 sub	 dl, cl
  00dbd	30 54 05 d8	 xor	 BYTE PTR __t$561397[ebp+eax], dl
  00dc1	40		 inc	 eax
  00dc2	83 f8 07	 cmp	 eax, 7
  00dc5	7c e3		 jl	 SHORT $LL2498@AddRenderI
  00dc7	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  00dcd	8d 75 d8	 lea	 esi, DWORD PTR __t$561397[ebp]
  00dd0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6462@AddRenderI:
  00dd6	8a 08		 mov	 cl, BYTE PTR [eax]
  00dd8	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00dda	75 1a		 jne	 SHORT $LN6463@AddRenderI
  00ddc	3a cb		 cmp	 cl, bl
  00dde	74 12		 je	 SHORT $LN6612@AddRenderI
  00de0	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00de3	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  00de6	75 0e		 jne	 SHORT $LN6463@AddRenderI
  00de8	83 c0 02	 add	 eax, 2
  00deb	83 c6 02	 add	 esi, 2
  00dee	3a cb		 cmp	 cl, bl
  00df0	75 e4		 jne	 SHORT $LL6462@AddRenderI
$LN6612@AddRenderI:
  00df2	33 c0		 xor	 eax, eax
  00df4	eb 05		 jmp	 SHORT $LN6465@AddRenderI
$LN6463@AddRenderI:
  00df6	1b c0		 sbb	 eax, eax
  00df8	83 d8 ff	 sbb	 eax, -1
$LN6465@AddRenderI:
  00dfb	3b c3		 cmp	 eax, ebx
  00dfd	75 30		 jne	 SHORT $LN6348@AddRenderI

; 290  : 	{
; 291  : 		SAFEDELETE( m_pGrayMan );

  00dff	39 9f b8 01 00
	00		 cmp	 DWORD PTR [edi+440], ebx
  00e05	74 17		 je	 SHORT $LN104@AddRenderI
  00e07	8b 8f b8 01 00
	00		 mov	 ecx, DWORD PTR [edi+440]
  00e0d	3b cb		 cmp	 ecx, ebx
  00e0f	74 07		 je	 SHORT $LN208@AddRenderI
  00e11	8b 01		 mov	 eax, DWORD PTR [ecx]
  00e13	6a 01		 push	 1
  00e15	ff 50 40	 call	 DWORD PTR [eax+64]
$LN208@AddRenderI:
  00e18	89 9f b8 01 00
	00		 mov	 DWORD PTR [edi+440], ebx
$LN104@AddRenderI:

; 292  : 		m_pGrayMan = pImage;

  00e1e	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  00e24	89 87 b8 01 00
	00		 mov	 DWORD PTR [edi+440], eax
  00e2a	e9 32 17 00 00	 jmp	 $LN1@AddRenderI
$LN6348@AddRenderI:

; 293  : 	}
; 294  : 	else if( szType == "BlueVert" )

  00e2f	6a 02		 push	 2
  00e31	c7 85 9c fc ff
	ff af 80 9e 8f	 mov	 DWORD PTR __t$561548[ebp], -1885437777 ; 8f9e80afH
  00e3b	c7 85 a0 fc ff
	ff bb 89 99 9e	 mov	 DWORD PTR __t$561548[ebp+4], -1634104901 ; 9e9989bbH
  00e45	8d 85 9c fc ff
	ff		 lea	 eax, DWORD PTR __t$561548[ebp]
  00e4b	88 9d a4 fc ff
	ff		 mov	 BYTE PTR __t$561548[ebp+8], bl
  00e51	59		 pop	 ecx
$LL2607@AddRenderI:
  00e52	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00e58	83 c0 04	 add	 eax, 4
  00e5b	49		 dec	 ecx
  00e5c	75 f4		 jne	 SHORT $LL2607@AddRenderI
  00e5e	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  00e64	8d b5 9c fc ff
	ff		 lea	 esi, DWORD PTR __t$561548[ebp]
  00e6a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6466@AddRenderI:
  00e70	8a 08		 mov	 cl, BYTE PTR [eax]
  00e72	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00e74	75 1a		 jne	 SHORT $LN6467@AddRenderI
  00e76	3a cb		 cmp	 cl, bl
  00e78	74 12		 je	 SHORT $LN6468@AddRenderI
  00e7a	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00e7d	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  00e80	75 0e		 jne	 SHORT $LN6467@AddRenderI
  00e82	83 c0 02	 add	 eax, 2
  00e85	83 c6 02	 add	 esi, 2
  00e88	3a cb		 cmp	 cl, bl
  00e8a	75 e4		 jne	 SHORT $LL6466@AddRenderI
$LN6468@AddRenderI:
  00e8c	33 c0		 xor	 eax, eax
  00e8e	eb 05		 jmp	 SHORT $LN6469@AddRenderI
$LN6467@AddRenderI:
  00e90	1b c0		 sbb	 eax, eax
  00e92	83 d8 ff	 sbb	 eax, -1
$LN6469@AddRenderI:
  00e95	3b c3		 cmp	 eax, ebx
  00e97	75 30		 jne	 SHORT $LN6349@AddRenderI

; 295  : 	{
; 296  : 		SAFEDELETE( m_pBlueVert );

  00e99	39 9f bc 01 00
	00		 cmp	 DWORD PTR [edi+444], ebx
  00e9f	74 17		 je	 SHORT $LN101@AddRenderI
  00ea1	8b 8f bc 01 00
	00		 mov	 ecx, DWORD PTR [edi+444]
  00ea7	3b cb		 cmp	 ecx, ebx
  00ea9	74 07		 je	 SHORT $LN210@AddRenderI
  00eab	8b 01		 mov	 eax, DWORD PTR [ecx]
  00ead	6a 01		 push	 1
  00eaf	ff 50 40	 call	 DWORD PTR [eax+64]
$LN210@AddRenderI:
  00eb2	89 9f bc 01 00
	00		 mov	 DWORD PTR [edi+444], ebx
$LN101@AddRenderI:

; 297  : 		m_pBlueVert = pImage;

  00eb8	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  00ebe	89 87 bc 01 00
	00		 mov	 DWORD PTR [edi+444], eax
  00ec4	e9 98 16 00 00	 jmp	 $LN1@AddRenderI
$LN6349@AddRenderI:

; 298  : 	}	
; 299  : 	else if( szType == "RedVert" )

  00ec9	6a 04		 push	 4
  00ecb	c7 45 cc bf 89
	8f bc		 mov	 DWORD PTR __t$561647[ebp], -1131443777 ; bc8f89bfH
  00ed2	81 75 cc ed ec
	eb ea		 xor	 DWORD PTR __t$561647[ebp], -353637139 ; eaebecedH
  00ed9	c7 45 d0 88 9e
	9f 00		 mov	 DWORD PTR __t$561647[ebp+4], 10460808 ; 009f9e88H
  00ee0	58		 pop	 eax
$LL2710@AddRenderI:
  00ee1	8b c8		 mov	 ecx, eax
  00ee3	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00ee9	79 05		 jns	 SHORT $LN6631@AddRenderI
  00eeb	49		 dec	 ecx
  00eec	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00eef	41		 inc	 ecx
$LN6631@AddRenderI:
  00ef0	b2 ed		 mov	 dl, -19			; ffffffedH
  00ef2	2a d1		 sub	 dl, cl
  00ef4	30 54 05 cc	 xor	 BYTE PTR __t$561647[ebp+eax], dl
  00ef8	40		 inc	 eax
  00ef9	83 f8 07	 cmp	 eax, 7
  00efc	7c e3		 jl	 SHORT $LL2710@AddRenderI
  00efe	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  00f04	8d 75 cc	 lea	 esi, DWORD PTR __t$561647[ebp]
  00f07	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6470@AddRenderI:
  00f0d	8a 08		 mov	 cl, BYTE PTR [eax]
  00f0f	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00f11	75 1a		 jne	 SHORT $LN6471@AddRenderI
  00f13	3a cb		 cmp	 cl, bl
  00f15	74 12		 je	 SHORT $LN6472@AddRenderI
  00f17	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00f1a	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  00f1d	75 0e		 jne	 SHORT $LN6471@AddRenderI
  00f1f	83 c0 02	 add	 eax, 2
  00f22	83 c6 02	 add	 esi, 2
  00f25	3a cb		 cmp	 cl, bl
  00f27	75 e4		 jne	 SHORT $LL6470@AddRenderI
$LN6472@AddRenderI:
  00f29	33 c0		 xor	 eax, eax
  00f2b	eb 05		 jmp	 SHORT $LN6473@AddRenderI
$LN6471@AddRenderI:
  00f2d	1b c0		 sbb	 eax, eax
  00f2f	83 d8 ff	 sbb	 eax, -1
$LN6473@AddRenderI:
  00f32	3b c3		 cmp	 eax, ebx
  00f34	75 30		 jne	 SHORT $LN6350@AddRenderI

; 300  : 	{
; 301  : 		SAFEDELETE( m_pRedVert );

  00f36	39 9f c0 01 00
	00		 cmp	 DWORD PTR [edi+448], ebx
  00f3c	74 17		 je	 SHORT $LN98@AddRenderI
  00f3e	8b 8f c0 01 00
	00		 mov	 ecx, DWORD PTR [edi+448]
  00f44	3b cb		 cmp	 ecx, ebx
  00f46	74 07		 je	 SHORT $LN212@AddRenderI
  00f48	8b 01		 mov	 eax, DWORD PTR [ecx]
  00f4a	6a 01		 push	 1
  00f4c	ff 50 40	 call	 DWORD PTR [eax+64]
$LN212@AddRenderI:
  00f4f	89 9f c0 01 00
	00		 mov	 DWORD PTR [edi+448], ebx
$LN98@AddRenderI:

; 302  : 		m_pRedVert = pImage;

  00f55	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  00f5b	89 87 c0 01 00
	00		 mov	 DWORD PTR [edi+448], eax
  00f61	e9 fb 15 00 00	 jmp	 $LN1@AddRenderI
$LN6350@AddRenderI:

; 303  : 	}	
; 304  : 	else if( szType == "MonsterModeTitle" )

  00f66	6a 04		 push	 4
  00f68	c7 85 0c fd ff
	ff a0 83 85 99	 mov	 DWORD PTR __t$561785[ebp], -1719303264 ; 998583a0H
  00f72	c7 85 10 fd ff
	ff 99 89 99 a7	 mov	 DWORD PTR __t$561785[ebp+4], -1483109991 ; a7998999H
  00f7c	c7 85 14 fd ff
	ff 82 88 8e be	 mov	 DWORD PTR __t$561785[ebp+8], -1097955198 ; be8e8882H
  00f86	c7 85 18 fd ff
	ff 84 98 87 8f	 mov	 DWORD PTR __t$561785[ebp+12], -1886939004 ; 8f879884H
  00f90	8d 85 0c fd ff
	ff		 lea	 eax, DWORD PTR __t$561785[ebp]
  00f96	88 9d 1c fd ff
	ff		 mov	 BYTE PTR __t$561785[ebp+16], bl
  00f9c	59		 pop	 ecx
$LL2819@AddRenderI:
  00f9d	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00fa3	83 c0 04	 add	 eax, 4
  00fa6	49		 dec	 ecx
  00fa7	75 f4		 jne	 SHORT $LL2819@AddRenderI
  00fa9	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  00faf	8d b5 0c fd ff
	ff		 lea	 esi, DWORD PTR __t$561785[ebp]
  00fb5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6474@AddRenderI:
  00fbb	8a 08		 mov	 cl, BYTE PTR [eax]
  00fbd	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00fbf	75 1a		 jne	 SHORT $LN6475@AddRenderI
  00fc1	3a cb		 cmp	 cl, bl
  00fc3	74 12		 je	 SHORT $LN6476@AddRenderI
  00fc5	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00fc8	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  00fcb	75 0e		 jne	 SHORT $LN6475@AddRenderI
  00fcd	83 c0 02	 add	 eax, 2
  00fd0	83 c6 02	 add	 esi, 2
  00fd3	3a cb		 cmp	 cl, bl
  00fd5	75 e4		 jne	 SHORT $LL6474@AddRenderI
$LN6476@AddRenderI:
  00fd7	33 c0		 xor	 eax, eax
  00fd9	eb 05		 jmp	 SHORT $LN6477@AddRenderI
$LN6475@AddRenderI:
  00fdb	1b c0		 sbb	 eax, eax
  00fdd	83 d8 ff	 sbb	 eax, -1
$LN6477@AddRenderI:
  00fe0	3b c3		 cmp	 eax, ebx
  00fe2	75 30		 jne	 SHORT $LN6351@AddRenderI

; 305  : 	{
; 306  : 		SAFEDELETE( m_pMonsterModeTitle );

  00fe4	39 9f c4 01 00
	00		 cmp	 DWORD PTR [edi+452], ebx
  00fea	74 17		 je	 SHORT $LN95@AddRenderI
  00fec	8b 8f c4 01 00
	00		 mov	 ecx, DWORD PTR [edi+452]
  00ff2	3b cb		 cmp	 ecx, ebx
  00ff4	74 07		 je	 SHORT $LN214@AddRenderI
  00ff6	8b 01		 mov	 eax, DWORD PTR [ecx]
  00ff8	6a 01		 push	 1
  00ffa	ff 50 40	 call	 DWORD PTR [eax+64]
$LN214@AddRenderI:
  00ffd	89 9f c4 01 00
	00		 mov	 DWORD PTR [edi+452], ebx
$LN95@AddRenderI:

; 307  : 		m_pMonsterModeTitle = pImage;

  01003	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  01009	89 87 c4 01 00
	00		 mov	 DWORD PTR [edi+452], eax
  0100f	e9 4d 15 00 00	 jmp	 $LN1@AddRenderI
$LN6351@AddRenderI:

; 308  : 	}	
; 309  : 	else if( szType == "SurvivalModeTitle" )

  01014	6a 04		 push	 4
  01016	c7 85 a0 fd ff
	ff be 99 99 9c	 mov	 DWORD PTR __t$561933[ebp], -1667655234 ; 9c9999beH
  01020	c7 85 a4 fd ff
	ff 84 9a 8a 86	 mov	 DWORD PTR __t$561933[ebp+4], -2037736828 ; 868a9a84H
  0102a	c7 85 a8 fd ff
	ff a0 83 8f 8f	 mov	 DWORD PTR __t$561933[ebp+8], -1886420064 ; 8f8f83a0H
  01034	c7 85 ac fd ff
	ff b9 85 9f 86	 mov	 DWORD PTR __t$561933[ebp+12], -2036365895 ; 869f85b9H
  0103e	8d 85 a0 fd ff
	ff		 lea	 eax, DWORD PTR __t$561933[ebp]
  01044	66 c7 85 b0 fd
	ff ff 88 00	 mov	 WORD PTR __t$561933[ebp+16], 136 ; 00000088H
  0104d	59		 pop	 ecx
$LL2925@AddRenderI:
  0104e	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  01054	83 c0 04	 add	 eax, 4
  01057	49		 dec	 ecx
  01058	75 f4		 jne	 SHORT $LL2925@AddRenderI
  0105a	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  01060	80 b5 b0 fd ff
	ff ed		 xor	 BYTE PTR __t$561933[ebp+16], -19 ; ffffffedH
  01067	8d b5 a0 fd ff
	ff		 lea	 esi, DWORD PTR __t$561933[ebp]
  0106d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6478@AddRenderI:
  01073	8a 08		 mov	 cl, BYTE PTR [eax]
  01075	3a 0e		 cmp	 cl, BYTE PTR [esi]
  01077	75 1a		 jne	 SHORT $LN6479@AddRenderI
  01079	3a cb		 cmp	 cl, bl
  0107b	74 12		 je	 SHORT $LN6480@AddRenderI
  0107d	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  01080	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  01083	75 0e		 jne	 SHORT $LN6479@AddRenderI
  01085	83 c0 02	 add	 eax, 2
  01088	83 c6 02	 add	 esi, 2
  0108b	3a cb		 cmp	 cl, bl
  0108d	75 e4		 jne	 SHORT $LL6478@AddRenderI
$LN6480@AddRenderI:
  0108f	33 c0		 xor	 eax, eax
  01091	eb 05		 jmp	 SHORT $LN6481@AddRenderI
$LN6479@AddRenderI:
  01093	1b c0		 sbb	 eax, eax
  01095	83 d8 ff	 sbb	 eax, -1
$LN6481@AddRenderI:
  01098	3b c3		 cmp	 eax, ebx
  0109a	75 30		 jne	 SHORT $LN6352@AddRenderI

; 310  : 	{
; 311  : 		SAFEDELETE( m_pSurvivalModeTitle );

  0109c	39 9f c8 01 00
	00		 cmp	 DWORD PTR [edi+456], ebx
  010a2	74 17		 je	 SHORT $LN92@AddRenderI
  010a4	8b 8f c8 01 00
	00		 mov	 ecx, DWORD PTR [edi+456]
  010aa	3b cb		 cmp	 ecx, ebx
  010ac	74 07		 je	 SHORT $LN216@AddRenderI
  010ae	8b 01		 mov	 eax, DWORD PTR [ecx]
  010b0	6a 01		 push	 1
  010b2	ff 50 40	 call	 DWORD PTR [eax+64]
$LN216@AddRenderI:
  010b5	89 9f c8 01 00
	00		 mov	 DWORD PTR [edi+456], ebx
$LN92@AddRenderI:

; 312  : 		m_pSurvivalModeTitle = pImage;

  010bb	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  010c1	89 87 c8 01 00
	00		 mov	 DWORD PTR [edi+456], eax
  010c7	e9 95 14 00 00	 jmp	 $LN1@AddRenderI
$LN6352@AddRenderI:

; 313  : 	}	
; 314  : 	else if( szType == "BossModeTitle" )

  010cc	6a 03		 push	 3
  010ce	c7 85 8c fd ff
	ff af 83 98 99	 mov	 DWORD PTR __t$562022[ebp], -1718058065 ; 999883afH
  010d8	c7 85 90 fd ff
	ff a0 83 8f 8f	 mov	 DWORD PTR __t$562022[ebp+4], -1886420064 ; 8f8f83a0H
  010e2	c7 85 94 fd ff
	ff b9 85 9f 86	 mov	 DWORD PTR __t$562022[ebp+8], -2036365895 ; 869f85b9H
  010ec	8d 85 8c fd ff
	ff		 lea	 eax, DWORD PTR __t$562022[ebp]
  010f2	66 c7 85 98 fd
	ff ff 88 00	 mov	 WORD PTR __t$562022[ebp+12], 136 ; 00000088H
  010fb	59		 pop	 ecx
$LL3031@AddRenderI:
  010fc	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  01102	83 c0 04	 add	 eax, 4
  01105	49		 dec	 ecx
  01106	75 f4		 jne	 SHORT $LL3031@AddRenderI
  01108	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  0110e	80 b5 98 fd ff
	ff ed		 xor	 BYTE PTR __t$562022[ebp+12], -19 ; ffffffedH
  01115	8d b5 8c fd ff
	ff		 lea	 esi, DWORD PTR __t$562022[ebp]
  0111b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6482@AddRenderI:
  01121	8a 08		 mov	 cl, BYTE PTR [eax]
  01123	3a 0e		 cmp	 cl, BYTE PTR [esi]
  01125	75 1a		 jne	 SHORT $LN6483@AddRenderI
  01127	3a cb		 cmp	 cl, bl
  01129	74 12		 je	 SHORT $LN6484@AddRenderI
  0112b	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  0112e	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  01131	75 0e		 jne	 SHORT $LN6483@AddRenderI
  01133	83 c0 02	 add	 eax, 2
  01136	83 c6 02	 add	 esi, 2
  01139	3a cb		 cmp	 cl, bl
  0113b	75 e4		 jne	 SHORT $LL6482@AddRenderI
$LN6484@AddRenderI:
  0113d	33 c0		 xor	 eax, eax
  0113f	eb 05		 jmp	 SHORT $LN6485@AddRenderI
$LN6483@AddRenderI:
  01141	1b c0		 sbb	 eax, eax
  01143	83 d8 ff	 sbb	 eax, -1
$LN6485@AddRenderI:
  01146	3b c3		 cmp	 eax, ebx
  01148	75 30		 jne	 SHORT $LN6353@AddRenderI

; 315  : 	{
; 316  : 		SAFEDELETE( m_pBossModeTitle );

  0114a	39 9f cc 01 00
	00		 cmp	 DWORD PTR [edi+460], ebx
  01150	74 17		 je	 SHORT $LN89@AddRenderI
  01152	8b 8f cc 01 00
	00		 mov	 ecx, DWORD PTR [edi+460]
  01158	3b cb		 cmp	 ecx, ebx
  0115a	74 07		 je	 SHORT $LN218@AddRenderI
  0115c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0115e	6a 01		 push	 1
  01160	ff 50 40	 call	 DWORD PTR [eax+64]
$LN218@AddRenderI:
  01163	89 9f cc 01 00
	00		 mov	 DWORD PTR [edi+460], ebx
$LN89@AddRenderI:

; 317  : 		m_pBossModeTitle = pImage;

  01169	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  0116f	89 87 cc 01 00
	00		 mov	 DWORD PTR [edi+460], eax
  01175	e9 e7 13 00 00	 jmp	 $LN1@AddRenderI
$LN6353@AddRenderI:

; 318  : 	}	
; 319  : 	else if( szType == "GangsiModeTitle1" )

  0117a	6a 04		 push	 4
  0117c	c7 85 24 fd ff
	ff aa 8d 85 8d	 mov	 DWORD PTR __t$562147[ebp], -1920627286 ; 8d858daaH
  01186	c7 85 28 fd ff
	ff 9e 85 a6 85	 mov	 DWORD PTR __t$562147[ebp+4], -2052684386 ; 85a6859eH
  01190	c7 85 2c fd ff
	ff 89 89 bf 83	 mov	 DWORD PTR __t$562147[ebp+8], -2084599415 ; 83bf8989H
  0119a	c7 85 30 fd ff
	ff 99 80 8e db	 mov	 DWORD PTR __t$562147[ebp+12], -611417959 ; db8e8099H
  011a4	8d 85 24 fd ff
	ff		 lea	 eax, DWORD PTR __t$562147[ebp]
  011aa	88 9d 34 fd ff
	ff		 mov	 BYTE PTR __t$562147[ebp+16], bl
  011b0	59		 pop	 ecx
$LL3137@AddRenderI:
  011b1	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  011b7	83 c0 04	 add	 eax, 4
  011ba	49		 dec	 ecx
  011bb	75 f4		 jne	 SHORT $LL3137@AddRenderI
  011bd	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  011c3	8d b5 24 fd ff
	ff		 lea	 esi, DWORD PTR __t$562147[ebp]
  011c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6486@AddRenderI:
  011cf	8a 08		 mov	 cl, BYTE PTR [eax]
  011d1	3a 0e		 cmp	 cl, BYTE PTR [esi]
  011d3	75 1a		 jne	 SHORT $LN6487@AddRenderI
  011d5	3a cb		 cmp	 cl, bl
  011d7	74 12		 je	 SHORT $LN6488@AddRenderI
  011d9	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  011dc	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  011df	75 0e		 jne	 SHORT $LN6487@AddRenderI
  011e1	83 c0 02	 add	 eax, 2
  011e4	83 c6 02	 add	 esi, 2
  011e7	3a cb		 cmp	 cl, bl
  011e9	75 e4		 jne	 SHORT $LL6486@AddRenderI
$LN6488@AddRenderI:
  011eb	33 c0		 xor	 eax, eax
  011ed	eb 05		 jmp	 SHORT $LN6489@AddRenderI
$LN6487@AddRenderI:
  011ef	1b c0		 sbb	 eax, eax
  011f1	83 d8 ff	 sbb	 eax, -1
$LN6489@AddRenderI:
  011f4	3b c3		 cmp	 eax, ebx
  011f6	75 30		 jne	 SHORT $LN6354@AddRenderI

; 320  : 	{
; 321  : 		SAFEDELETE( m_pGangsiModeTitle1 );

  011f8	39 9f d0 01 00
	00		 cmp	 DWORD PTR [edi+464], ebx
  011fe	74 17		 je	 SHORT $LN86@AddRenderI
  01200	8b 8f d0 01 00
	00		 mov	 ecx, DWORD PTR [edi+464]
  01206	3b cb		 cmp	 ecx, ebx
  01208	74 07		 je	 SHORT $LN220@AddRenderI
  0120a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0120c	6a 01		 push	 1
  0120e	ff 50 40	 call	 DWORD PTR [eax+64]
$LN220@AddRenderI:
  01211	89 9f d0 01 00
	00		 mov	 DWORD PTR [edi+464], ebx
$LN86@AddRenderI:

; 322  : 		m_pGangsiModeTitle1 = pImage;

  01217	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  0121d	89 87 d0 01 00
	00		 mov	 DWORD PTR [edi+464], eax
  01223	e9 39 13 00 00	 jmp	 $LN1@AddRenderI
$LN6354@AddRenderI:

; 323  : 	}	
; 324  : 	else if( szType == "GangsiModeTitle2" )

  01228	6a 04		 push	 4
  0122a	c7 85 3c fd ff
	ff aa 8d 85 8d	 mov	 DWORD PTR __t$562285[ebp], -1920627286 ; 8d858daaH
  01234	c7 85 40 fd ff
	ff 9e 85 a6 85	 mov	 DWORD PTR __t$562285[ebp+4], -2052684386 ; 85a6859eH
  0123e	c7 85 44 fd ff
	ff 89 89 bf 83	 mov	 DWORD PTR __t$562285[ebp+8], -2084599415 ; 83bf8989H
  01248	c7 85 48 fd ff
	ff 99 80 8e d8	 mov	 DWORD PTR __t$562285[ebp+12], -661749607 ; d88e8099H
  01252	8d 85 3c fd ff
	ff		 lea	 eax, DWORD PTR __t$562285[ebp]
  01258	88 9d 4c fd ff
	ff		 mov	 BYTE PTR __t$562285[ebp+16], bl
  0125e	59		 pop	 ecx
$LL3243@AddRenderI:
  0125f	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  01265	83 c0 04	 add	 eax, 4
  01268	49		 dec	 ecx
  01269	75 f4		 jne	 SHORT $LL3243@AddRenderI
  0126b	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  01271	8d b5 3c fd ff
	ff		 lea	 esi, DWORD PTR __t$562285[ebp]
  01277	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6490@AddRenderI:
  0127d	8a 08		 mov	 cl, BYTE PTR [eax]
  0127f	3a 0e		 cmp	 cl, BYTE PTR [esi]
  01281	75 1a		 jne	 SHORT $LN6491@AddRenderI
  01283	3a cb		 cmp	 cl, bl
  01285	74 12		 je	 SHORT $LN6492@AddRenderI
  01287	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  0128a	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  0128d	75 0e		 jne	 SHORT $LN6491@AddRenderI
  0128f	83 c0 02	 add	 eax, 2
  01292	83 c6 02	 add	 esi, 2
  01295	3a cb		 cmp	 cl, bl
  01297	75 e4		 jne	 SHORT $LL6490@AddRenderI
$LN6492@AddRenderI:
  01299	33 c0		 xor	 eax, eax
  0129b	eb 05		 jmp	 SHORT $LN6493@AddRenderI
$LN6491@AddRenderI:
  0129d	1b c0		 sbb	 eax, eax
  0129f	83 d8 ff	 sbb	 eax, -1
$LN6493@AddRenderI:
  012a2	3b c3		 cmp	 eax, ebx
  012a4	75 30		 jne	 SHORT $LN6355@AddRenderI

; 325  : 	{
; 326  : 		SAFEDELETE( m_pGangsiModeTitle2 );

  012a6	39 9f d4 01 00
	00		 cmp	 DWORD PTR [edi+468], ebx
  012ac	74 17		 je	 SHORT $LN83@AddRenderI
  012ae	8b 8f d4 01 00
	00		 mov	 ecx, DWORD PTR [edi+468]
  012b4	3b cb		 cmp	 ecx, ebx
  012b6	74 07		 je	 SHORT $LN222@AddRenderI
  012b8	8b 01		 mov	 eax, DWORD PTR [ecx]
  012ba	6a 01		 push	 1
  012bc	ff 50 40	 call	 DWORD PTR [eax+64]
$LN222@AddRenderI:
  012bf	89 9f d4 01 00
	00		 mov	 DWORD PTR [edi+468], ebx
$LN83@AddRenderI:

; 327  : 		m_pGangsiModeTitle2 = pImage;

  012c5	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  012cb	89 87 d4 01 00
	00		 mov	 DWORD PTR [edi+468], eax
  012d1	e9 8b 12 00 00	 jmp	 $LN1@AddRenderI
$LN6355@AddRenderI:

; 328  : 	}	
; 329  : 	else if( szType == "FightModeTitle" )

  012d6	6a 03		 push	 3
  012d8	c7 85 94 fe ff
	ff ab 85 8c 82	 mov	 DWORD PTR __t$562410[ebp], -2104719957 ; 828c85abH
  012e2	c7 85 98 fe ff
	ff 99 a1 84 8e	 mov	 DWORD PTR __t$562410[ebp+4], -1903910503 ; 8e84a199H
  012ec	c7 85 9c fe ff
	ff 88 b8 82 9e	 mov	 DWORD PTR __t$562410[ebp+8], -1635600248 ; 9e82b888H
  012f6	66 c7 85 a0 fe
	ff ff 81 89	 mov	 WORD PTR __t$562410[ebp+12], 35201 ; 00008981H
  012ff	8d 85 94 fe ff
	ff		 lea	 eax, DWORD PTR __t$562410[ebp]
  01305	88 9d a2 fe ff
	ff		 mov	 BYTE PTR __t$562410[ebp+14], bl
  0130b	59		 pop	 ecx
$LL3349@AddRenderI:
  0130c	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  01312	83 c0 04	 add	 eax, 4
  01315	49		 dec	 ecx
  01316	75 f4		 jne	 SHORT $LL3349@AddRenderI
  01318	6a 0c		 push	 12			; 0000000cH
  0131a	58		 pop	 eax
$LL3346@AddRenderI:
  0131b	8b c8		 mov	 ecx, eax
  0131d	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  01323	79 05		 jns	 SHORT $LN6632@AddRenderI
  01325	49		 dec	 ecx
  01326	83 c9 fc	 or	 ecx, -4			; fffffffcH
  01329	41		 inc	 ecx
$LN6632@AddRenderI:
  0132a	b2 ed		 mov	 dl, -19			; ffffffedH
  0132c	2a d1		 sub	 dl, cl
  0132e	30 94 05 94 fe
	ff ff		 xor	 BYTE PTR __t$562410[ebp+eax], dl
  01335	40		 inc	 eax
  01336	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  01339	7c e0		 jl	 SHORT $LL3346@AddRenderI
  0133b	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  01341	8d b5 94 fe ff
	ff		 lea	 esi, DWORD PTR __t$562410[ebp]
  01347	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6494@AddRenderI:
  0134d	8a 08		 mov	 cl, BYTE PTR [eax]
  0134f	3a 0e		 cmp	 cl, BYTE PTR [esi]
  01351	75 1a		 jne	 SHORT $LN6495@AddRenderI
  01353	3a cb		 cmp	 cl, bl
  01355	74 12		 je	 SHORT $LN6496@AddRenderI
  01357	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  0135a	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  0135d	75 0e		 jne	 SHORT $LN6495@AddRenderI
  0135f	83 c0 02	 add	 eax, 2
  01362	83 c6 02	 add	 esi, 2
  01365	3a cb		 cmp	 cl, bl
  01367	75 e4		 jne	 SHORT $LL6494@AddRenderI
$LN6496@AddRenderI:
  01369	33 c0		 xor	 eax, eax
  0136b	eb 05		 jmp	 SHORT $LN6497@AddRenderI
$LN6495@AddRenderI:
  0136d	1b c0		 sbb	 eax, eax
  0136f	83 d8 ff	 sbb	 eax, -1
$LN6497@AddRenderI:
  01372	3b c3		 cmp	 eax, ebx
  01374	75 30		 jne	 SHORT $LN6356@AddRenderI

; 330  : 	{
; 331  : 		SAFEDELETE( m_pFightModeTitle );

  01376	39 9f d8 01 00
	00		 cmp	 DWORD PTR [edi+472], ebx
  0137c	74 17		 je	 SHORT $LN80@AddRenderI
  0137e	8b 8f d8 01 00
	00		 mov	 ecx, DWORD PTR [edi+472]
  01384	3b cb		 cmp	 ecx, ebx
  01386	74 07		 je	 SHORT $LN224@AddRenderI
  01388	8b 01		 mov	 eax, DWORD PTR [ecx]
  0138a	6a 01		 push	 1
  0138c	ff 50 40	 call	 DWORD PTR [eax+64]
$LN224@AddRenderI:
  0138f	89 9f d8 01 00
	00		 mov	 DWORD PTR [edi+472], ebx
$LN80@AddRenderI:

; 332  : 		m_pFightModeTitle = pImage;

  01395	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  0139b	89 87 d8 01 00
	00		 mov	 DWORD PTR [edi+472], eax
  013a1	e9 bb 11 00 00	 jmp	 $LN1@AddRenderI
$LN6356@AddRenderI:

; 333  : 	}
; 334  : 	else if( szType == "ShuffleBonusModeTitle" )

  013a6	6a 05		 push	 5
  013a8	c7 85 5c ff ff
	ff be 84 9e 8c	 mov	 DWORD PTR __t$562522[ebp], -1935768386 ; 8c9e84beH
  013b2	c7 85 60 ff ff
	ff 8b 80 8e a8	 mov	 DWORD PTR __t$562522[ebp+4], -1467055989 ; a88e808bH
  013bc	c7 85 64 ff ff
	ff 82 82 9e 99	 mov	 DWORD PTR __t$562522[ebp+8], -1717665150 ; 999e8282H
  013c6	c7 85 68 ff ff
	ff a0 83 8f 8f	 mov	 DWORD PTR __t$562522[ebp+12], -1886420064 ; 8f8f83a0H
  013d0	c7 85 6c ff ff
	ff b9 85 9f 86	 mov	 DWORD PTR __t$562522[ebp+16], -2036365895 ; 869f85b9H
  013da	8d 85 5c ff ff
	ff		 lea	 eax, DWORD PTR __t$562522[ebp]
  013e0	66 c7 85 70 ff
	ff ff 88 00	 mov	 WORD PTR __t$562522[ebp+20], 136 ; 00000088H
  013e9	59		 pop	 ecx
$LL3455@AddRenderI:
  013ea	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  013f0	83 c0 04	 add	 eax, 4
  013f3	49		 dec	 ecx
  013f4	75 f4		 jne	 SHORT $LL3455@AddRenderI
  013f6	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  013fc	80 b5 70 ff ff
	ff ed		 xor	 BYTE PTR __t$562522[ebp+20], -19 ; ffffffedH
  01403	8d b5 5c ff ff
	ff		 lea	 esi, DWORD PTR __t$562522[ebp]
  01409	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6498@AddRenderI:
  0140f	8a 08		 mov	 cl, BYTE PTR [eax]
  01411	3a 0e		 cmp	 cl, BYTE PTR [esi]
  01413	75 1a		 jne	 SHORT $LN6499@AddRenderI
  01415	3a cb		 cmp	 cl, bl
  01417	74 12		 je	 SHORT $LN6500@AddRenderI
  01419	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  0141c	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  0141f	75 0e		 jne	 SHORT $LN6499@AddRenderI
  01421	83 c0 02	 add	 eax, 2
  01424	83 c6 02	 add	 esi, 2
  01427	3a cb		 cmp	 cl, bl
  01429	75 e4		 jne	 SHORT $LL6498@AddRenderI
$LN6500@AddRenderI:
  0142b	33 c0		 xor	 eax, eax
  0142d	eb 05		 jmp	 SHORT $LN6501@AddRenderI
$LN6499@AddRenderI:
  0142f	1b c0		 sbb	 eax, eax
  01431	83 d8 ff	 sbb	 eax, -1
$LN6501@AddRenderI:
  01434	3b c3		 cmp	 eax, ebx
  01436	75 30		 jne	 SHORT $LN6357@AddRenderI

; 335  : 	{
; 336  : 		SAFEDELETE( m_pShuffleBonusModeTitle );

  01438	39 9f dc 01 00
	00		 cmp	 DWORD PTR [edi+476], ebx
  0143e	74 17		 je	 SHORT $LN77@AddRenderI
  01440	8b 8f dc 01 00
	00		 mov	 ecx, DWORD PTR [edi+476]
  01446	3b cb		 cmp	 ecx, ebx
  01448	74 07		 je	 SHORT $LN226@AddRenderI
  0144a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0144c	6a 01		 push	 1
  0144e	ff 50 40	 call	 DWORD PTR [eax+64]
$LN226@AddRenderI:
  01451	89 9f dc 01 00
	00		 mov	 DWORD PTR [edi+476], ebx
$LN77@AddRenderI:

; 337  : 		m_pShuffleBonusModeTitle = pImage;

  01457	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  0145d	89 87 dc 01 00
	00		 mov	 DWORD PTR [edi+476], eax
  01463	e9 f9 10 00 00	 jmp	 $LN1@AddRenderI
$LN6357@AddRenderI:

; 338  : 	}
; 339  : 	else if( szType == "RaidModeTitle" )

  01468	6a 03		 push	 3
  0146a	c7 85 78 ff ff
	ff bf 8d 82 8e	 mov	 DWORD PTR __t$562660[ebp], -1904046657 ; 8e828dbfH
  01474	c7 85 7c ff ff
	ff a0 83 8f 8f	 mov	 DWORD PTR __t$562660[ebp+4], -1886420064 ; 8f8f83a0H
  0147e	c7 45 80 b9 85
	9f 86		 mov	 DWORD PTR __t$562660[ebp+8], -2036365895 ; 869f85b9H
  01485	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR __t$562660[ebp]
  0148b	66 c7 45 84 88
	00		 mov	 WORD PTR __t$562660[ebp+12], 136 ; 00000088H
  01491	59		 pop	 ecx
$LL3561@AddRenderI:
  01492	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  01498	83 c0 04	 add	 eax, 4
  0149b	49		 dec	 ecx
  0149c	75 f4		 jne	 SHORT $LL3561@AddRenderI
  0149e	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  014a4	80 75 84 ed	 xor	 BYTE PTR __t$562660[ebp+12], -19 ; ffffffedH
  014a8	8d b5 78 ff ff
	ff		 lea	 esi, DWORD PTR __t$562660[ebp]
  014ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6502@AddRenderI:
  014b4	8a 08		 mov	 cl, BYTE PTR [eax]
  014b6	3a 0e		 cmp	 cl, BYTE PTR [esi]
  014b8	75 1a		 jne	 SHORT $LN6503@AddRenderI
  014ba	3a cb		 cmp	 cl, bl
  014bc	74 12		 je	 SHORT $LN6613@AddRenderI
  014be	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  014c1	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  014c4	75 0e		 jne	 SHORT $LN6503@AddRenderI
  014c6	83 c0 02	 add	 eax, 2
  014c9	83 c6 02	 add	 esi, 2
  014cc	3a cb		 cmp	 cl, bl
  014ce	75 e4		 jne	 SHORT $LL6502@AddRenderI
$LN6613@AddRenderI:
  014d0	33 c0		 xor	 eax, eax
  014d2	eb 05		 jmp	 SHORT $LN6505@AddRenderI
$LN6503@AddRenderI:
  014d4	1b c0		 sbb	 eax, eax
  014d6	83 d8 ff	 sbb	 eax, -1
$LN6505@AddRenderI:
  014d9	3b c3		 cmp	 eax, ebx
  014db	75 30		 jne	 SHORT $LN6358@AddRenderI

; 340  : 	{
; 341  : 		SAFEDELETE( m_pRaidModeTitle );

  014dd	39 9f e0 01 00
	00		 cmp	 DWORD PTR [edi+480], ebx
  014e3	74 17		 je	 SHORT $LN74@AddRenderI
  014e5	8b 8f e0 01 00
	00		 mov	 ecx, DWORD PTR [edi+480]
  014eb	3b cb		 cmp	 ecx, ebx
  014ed	74 07		 je	 SHORT $LN228@AddRenderI
  014ef	8b 01		 mov	 eax, DWORD PTR [ecx]
  014f1	6a 01		 push	 1
  014f3	ff 50 40	 call	 DWORD PTR [eax+64]
$LN228@AddRenderI:
  014f6	89 9f e0 01 00
	00		 mov	 DWORD PTR [edi+480], ebx
$LN74@AddRenderI:

; 342  : 		m_pRaidModeTitle = pImage;

  014fc	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  01502	89 87 e0 01 00
	00		 mov	 DWORD PTR [edi+480], eax
  01508	e9 54 10 00 00	 jmp	 $LN1@AddRenderI
$LN6358@AddRenderI:

; 343  : 	}
; 344  : 	else if( szType == "BlueNumber" )

  0150d	6a 02		 push	 2
  0150f	c7 85 a8 fe ff
	ff af 80 9e 8f	 mov	 DWORD PTR __t$562772[ebp], -1885437777 ; 8f9e80afH
  01519	c7 85 ac fe ff
	ff a3 99 86 88	 mov	 DWORD PTR __t$562772[ebp+4], -2004444765 ; 888699a3H
  01523	66 c7 85 b0 fe
	ff ff 88 9e	 mov	 WORD PTR __t$562772[ebp+8], 40584 ; 00009e88H
  0152c	8d 85 a8 fe ff
	ff		 lea	 eax, DWORD PTR __t$562772[ebp]
  01532	88 9d b2 fe ff
	ff		 mov	 BYTE PTR __t$562772[ebp+10], bl
  01538	59		 pop	 ecx
$LL3667@AddRenderI:
  01539	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0153f	83 c0 04	 add	 eax, 4
  01542	49		 dec	 ecx
  01543	75 f4		 jne	 SHORT $LL3667@AddRenderI
  01545	6a 08		 push	 8
  01547	58		 pop	 eax
$LL3664@AddRenderI:
  01548	8b c8		 mov	 ecx, eax
  0154a	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  01550	79 05		 jns	 SHORT $LN6633@AddRenderI
  01552	49		 dec	 ecx
  01553	83 c9 fc	 or	 ecx, -4			; fffffffcH
  01556	41		 inc	 ecx
$LN6633@AddRenderI:
  01557	b2 ed		 mov	 dl, -19			; ffffffedH
  01559	2a d1		 sub	 dl, cl
  0155b	30 94 05 a8 fe
	ff ff		 xor	 BYTE PTR __t$562772[ebp+eax], dl
  01562	40		 inc	 eax
  01563	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  01566	7c e0		 jl	 SHORT $LL3664@AddRenderI
  01568	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  0156e	8d b5 a8 fe ff
	ff		 lea	 esi, DWORD PTR __t$562772[ebp]
  01574	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6506@AddRenderI:
  0157a	8a 08		 mov	 cl, BYTE PTR [eax]
  0157c	3a 0e		 cmp	 cl, BYTE PTR [esi]
  0157e	75 1a		 jne	 SHORT $LN6507@AddRenderI
  01580	3a cb		 cmp	 cl, bl
  01582	74 12		 je	 SHORT $LN6614@AddRenderI
  01584	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  01587	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  0158a	75 0e		 jne	 SHORT $LN6507@AddRenderI
  0158c	83 c0 02	 add	 eax, 2
  0158f	83 c6 02	 add	 esi, 2
  01592	3a cb		 cmp	 cl, bl
  01594	75 e4		 jne	 SHORT $LL6506@AddRenderI
$LN6614@AddRenderI:
  01596	33 c0		 xor	 eax, eax
  01598	eb 05		 jmp	 SHORT $LN6509@AddRenderI
$LN6507@AddRenderI:
  0159a	1b c0		 sbb	 eax, eax
  0159c	83 d8 ff	 sbb	 eax, -1
$LN6509@AddRenderI:
  0159f	3b c3		 cmp	 eax, ebx
  015a1	75 30		 jne	 SHORT $LN6359@AddRenderI

; 345  : 	{
; 346  : 		SAFEDELETE( m_pBlueNumber );

  015a3	39 9f e4 01 00
	00		 cmp	 DWORD PTR [edi+484], ebx
  015a9	74 17		 je	 SHORT $LN71@AddRenderI
  015ab	8b 8f e4 01 00
	00		 mov	 ecx, DWORD PTR [edi+484]
  015b1	3b cb		 cmp	 ecx, ebx
  015b3	74 07		 je	 SHORT $LN230@AddRenderI
  015b5	8b 01		 mov	 eax, DWORD PTR [ecx]
  015b7	6a 01		 push	 1
  015b9	ff 50 40	 call	 DWORD PTR [eax+64]
$LN230@AddRenderI:
  015bc	89 9f e4 01 00
	00		 mov	 DWORD PTR [edi+484], ebx
$LN71@AddRenderI:

; 347  : 		m_pBlueNumber = pImage;

  015c2	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  015c8	89 87 e4 01 00
	00		 mov	 DWORD PTR [edi+484], eax
  015ce	e9 8e 0f 00 00	 jmp	 $LN1@AddRenderI
$LN6359@AddRenderI:

; 348  : 	}	
; 349  : 	else if( szType == "RedNumber" )

  015d3	6a 02		 push	 2
  015d5	c7 85 f0 fe ff
	ff bf 89 8f a4	 mov	 DWORD PTR __t$562897[ebp], -1534096961 ; a48f89bfH
  015df	c7 85 f4 fe ff
	ff 98 81 89 8f	 mov	 DWORD PTR __t$562897[ebp+4], -1886813800 ; 8f898198H
  015e9	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR __t$562897[ebp]
  015ef	66 c7 85 f8 fe
	ff ff 9f 00	 mov	 WORD PTR __t$562897[ebp+8], 159 ; 0000009fH
  015f8	59		 pop	 ecx
$LL3773@AddRenderI:
  015f9	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  015ff	83 c0 04	 add	 eax, 4
  01602	49		 dec	 ecx
  01603	75 f4		 jne	 SHORT $LL3773@AddRenderI
  01605	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  0160b	80 b5 f8 fe ff
	ff ed		 xor	 BYTE PTR __t$562897[ebp+8], -19 ; ffffffedH
  01612	8d b5 f0 fe ff
	ff		 lea	 esi, DWORD PTR __t$562897[ebp]
  01618	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6510@AddRenderI:
  0161e	8a 08		 mov	 cl, BYTE PTR [eax]
  01620	3a 0e		 cmp	 cl, BYTE PTR [esi]
  01622	75 1a		 jne	 SHORT $LN6511@AddRenderI
  01624	3a cb		 cmp	 cl, bl
  01626	74 12		 je	 SHORT $LN6615@AddRenderI
  01628	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  0162b	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  0162e	75 0e		 jne	 SHORT $LN6511@AddRenderI
  01630	83 c0 02	 add	 eax, 2
  01633	83 c6 02	 add	 esi, 2
  01636	3a cb		 cmp	 cl, bl
  01638	75 e4		 jne	 SHORT $LL6510@AddRenderI
$LN6615@AddRenderI:
  0163a	33 c0		 xor	 eax, eax
  0163c	eb 05		 jmp	 SHORT $LN6513@AddRenderI
$LN6511@AddRenderI:
  0163e	1b c0		 sbb	 eax, eax
  01640	83 d8 ff	 sbb	 eax, -1
$LN6513@AddRenderI:
  01643	3b c3		 cmp	 eax, ebx
  01645	75 30		 jne	 SHORT $LN6360@AddRenderI

; 350  : 	{
; 351  : 		SAFEDELETE( m_pRedNumber );

  01647	39 9f e8 01 00
	00		 cmp	 DWORD PTR [edi+488], ebx
  0164d	74 17		 je	 SHORT $LN68@AddRenderI
  0164f	8b 8f e8 01 00
	00		 mov	 ecx, DWORD PTR [edi+488]
  01655	3b cb		 cmp	 ecx, ebx
  01657	74 07		 je	 SHORT $LN232@AddRenderI
  01659	8b 01		 mov	 eax, DWORD PTR [ecx]
  0165b	6a 01		 push	 1
  0165d	ff 50 40	 call	 DWORD PTR [eax+64]
$LN232@AddRenderI:
  01660	89 9f e8 01 00
	00		 mov	 DWORD PTR [edi+488], ebx
$LN68@AddRenderI:

; 352  : 		m_pRedNumber = pImage;

  01666	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  0166c	89 87 e8 01 00
	00		 mov	 DWORD PTR [edi+488], eax
  01672	e9 ea 0e 00 00	 jmp	 $LN1@AddRenderI
$LN6360@AddRenderI:

; 353  : 	}	
; 354  : 	else if( szType == "BlueFloor" )

  01677	6a 02		 push	 2
  01679	c7 85 7c fd ff
	ff af 80 9e 8f	 mov	 DWORD PTR __t$563022[ebp], -1885437777 ; 8f9e80afH
  01683	c7 85 80 fd ff
	ff ab 80 84 85	 mov	 DWORD PTR __t$563022[ebp+4], -2054913877 ; 858480abH
  0168d	8d 85 7c fd ff
	ff		 lea	 eax, DWORD PTR __t$563022[ebp]
  01693	66 c7 85 84 fd
	ff ff 9f 00	 mov	 WORD PTR __t$563022[ebp+8], 159 ; 0000009fH
  0169c	59		 pop	 ecx
$LL3879@AddRenderI:
  0169d	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  016a3	83 c0 04	 add	 eax, 4
  016a6	49		 dec	 ecx
  016a7	75 f4		 jne	 SHORT $LL3879@AddRenderI
  016a9	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  016af	80 b5 84 fd ff
	ff ed		 xor	 BYTE PTR __t$563022[ebp+8], -19 ; ffffffedH
  016b6	8d b5 7c fd ff
	ff		 lea	 esi, DWORD PTR __t$563022[ebp]
  016bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6514@AddRenderI:
  016c2	8a 08		 mov	 cl, BYTE PTR [eax]
  016c4	3a 0e		 cmp	 cl, BYTE PTR [esi]
  016c6	75 1a		 jne	 SHORT $LN6515@AddRenderI
  016c8	3a cb		 cmp	 cl, bl
  016ca	74 12		 je	 SHORT $LN6516@AddRenderI
  016cc	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  016cf	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  016d2	75 0e		 jne	 SHORT $LN6515@AddRenderI
  016d4	83 c0 02	 add	 eax, 2
  016d7	83 c6 02	 add	 esi, 2
  016da	3a cb		 cmp	 cl, bl
  016dc	75 e4		 jne	 SHORT $LL6514@AddRenderI
$LN6516@AddRenderI:
  016de	33 c0		 xor	 eax, eax
  016e0	eb 05		 jmp	 SHORT $LN6517@AddRenderI
$LN6515@AddRenderI:
  016e2	1b c0		 sbb	 eax, eax
  016e4	83 d8 ff	 sbb	 eax, -1
$LN6517@AddRenderI:
  016e7	3b c3		 cmp	 eax, ebx
  016e9	75 30		 jne	 SHORT $LN6361@AddRenderI

; 355  : 	{
; 356  : 		SAFEDELETE( m_pBlueFloor );

  016eb	39 9f ec 01 00
	00		 cmp	 DWORD PTR [edi+492], ebx
  016f1	74 17		 je	 SHORT $LN65@AddRenderI
  016f3	8b 8f ec 01 00
	00		 mov	 ecx, DWORD PTR [edi+492]
  016f9	3b cb		 cmp	 ecx, ebx
  016fb	74 07		 je	 SHORT $LN234@AddRenderI
  016fd	8b 01		 mov	 eax, DWORD PTR [ecx]
  016ff	6a 01		 push	 1
  01701	ff 50 40	 call	 DWORD PTR [eax+64]
$LN234@AddRenderI:
  01704	89 9f ec 01 00
	00		 mov	 DWORD PTR [edi+492], ebx
$LN65@AddRenderI:

; 357  : 		m_pBlueFloor = pImage;

  0170a	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  01710	89 87 ec 01 00
	00		 mov	 DWORD PTR [edi+492], eax
  01716	e9 46 0e 00 00	 jmp	 $LN1@AddRenderI
$LN6361@AddRenderI:

; 358  : 	}	
; 359  : 	else if( szType == "RedRank" )

  0171b	6a 04		 push	 4
  0171d	c7 45 b4 bf 89
	8f b8		 mov	 DWORD PTR __t$563147[ebp], -1198552641 ; b88f89bfH
  01724	81 75 b4 ed ec
	eb ea		 xor	 DWORD PTR __t$563147[ebp], -353637139 ; eaebecedH
  0172b	c7 45 b8 8c 82
	80 00		 mov	 DWORD PTR __t$563147[ebp+4], 8422028 ; 0080828cH
  01732	58		 pop	 eax
$LL3982@AddRenderI:
  01733	8b c8		 mov	 ecx, eax
  01735	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0173b	79 05		 jns	 SHORT $LN6634@AddRenderI
  0173d	49		 dec	 ecx
  0173e	83 c9 fc	 or	 ecx, -4			; fffffffcH
  01741	41		 inc	 ecx
$LN6634@AddRenderI:
  01742	b2 ed		 mov	 dl, -19			; ffffffedH
  01744	2a d1		 sub	 dl, cl
  01746	30 54 05 b4	 xor	 BYTE PTR __t$563147[ebp+eax], dl
  0174a	40		 inc	 eax
  0174b	83 f8 07	 cmp	 eax, 7
  0174e	7c e3		 jl	 SHORT $LL3982@AddRenderI
  01750	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  01756	8d 75 b4	 lea	 esi, DWORD PTR __t$563147[ebp]
  01759	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6518@AddRenderI:
  0175f	8a 08		 mov	 cl, BYTE PTR [eax]
  01761	3a 0e		 cmp	 cl, BYTE PTR [esi]
  01763	75 1a		 jne	 SHORT $LN6519@AddRenderI
  01765	3a cb		 cmp	 cl, bl
  01767	74 12		 je	 SHORT $LN6616@AddRenderI
  01769	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  0176c	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  0176f	75 0e		 jne	 SHORT $LN6519@AddRenderI
  01771	83 c0 02	 add	 eax, 2
  01774	83 c6 02	 add	 esi, 2
  01777	3a cb		 cmp	 cl, bl
  01779	75 e4		 jne	 SHORT $LL6518@AddRenderI
$LN6616@AddRenderI:
  0177b	33 c0		 xor	 eax, eax
  0177d	eb 05		 jmp	 SHORT $LN6521@AddRenderI
$LN6519@AddRenderI:
  0177f	1b c0		 sbb	 eax, eax
  01781	83 d8 ff	 sbb	 eax, -1
$LN6521@AddRenderI:
  01784	3b c3		 cmp	 eax, ebx
  01786	75 30		 jne	 SHORT $LN6362@AddRenderI

; 360  : 	{
; 361  : 		SAFEDELETE( m_pRedRank );

  01788	39 9f f0 01 00
	00		 cmp	 DWORD PTR [edi+496], ebx
  0178e	74 17		 je	 SHORT $LN62@AddRenderI
  01790	8b 8f f0 01 00
	00		 mov	 ecx, DWORD PTR [edi+496]
  01796	3b cb		 cmp	 ecx, ebx
  01798	74 07		 je	 SHORT $LN236@AddRenderI
  0179a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0179c	6a 01		 push	 1
  0179e	ff 50 40	 call	 DWORD PTR [eax+64]
$LN236@AddRenderI:
  017a1	89 9f f0 01 00
	00		 mov	 DWORD PTR [edi+496], ebx
$LN62@AddRenderI:

; 362  : 		m_pRedRank = pImage;

  017a7	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  017ad	89 87 f0 01 00
	00		 mov	 DWORD PTR [edi+496], eax
  017b3	e9 a9 0d 00 00	 jmp	 $LN1@AddRenderI
$LN6362@AddRenderI:

; 363  : 	}
; 364  : 	else if( szType == "BlueRank" )

  017b8	6a 02		 push	 2
  017ba	c7 85 8c fc ff
	ff af 80 9e 8f	 mov	 DWORD PTR __t$563298[ebp], -1885437777 ; 8f9e80afH
  017c4	c7 85 90 fc ff
	ff bf 8d 85 81	 mov	 DWORD PTR __t$563298[ebp+4], -2121953857 ; 81858dbfH
  017ce	8d 85 8c fc ff
	ff		 lea	 eax, DWORD PTR __t$563298[ebp]
  017d4	88 9d 94 fc ff
	ff		 mov	 BYTE PTR __t$563298[ebp+8], bl
  017da	59		 pop	 ecx
$LL4091@AddRenderI:
  017db	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  017e1	83 c0 04	 add	 eax, 4
  017e4	49		 dec	 ecx
  017e5	75 f4		 jne	 SHORT $LL4091@AddRenderI
  017e7	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  017ed	8d b5 8c fc ff
	ff		 lea	 esi, DWORD PTR __t$563298[ebp]
  017f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6522@AddRenderI:
  017f9	8a 08		 mov	 cl, BYTE PTR [eax]
  017fb	3a 0e		 cmp	 cl, BYTE PTR [esi]
  017fd	75 1a		 jne	 SHORT $LN6523@AddRenderI
  017ff	3a cb		 cmp	 cl, bl
  01801	74 12		 je	 SHORT $LN6524@AddRenderI
  01803	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  01806	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  01809	75 0e		 jne	 SHORT $LN6523@AddRenderI
  0180b	83 c0 02	 add	 eax, 2
  0180e	83 c6 02	 add	 esi, 2
  01811	3a cb		 cmp	 cl, bl
  01813	75 e4		 jne	 SHORT $LL6522@AddRenderI
$LN6524@AddRenderI:
  01815	33 c0		 xor	 eax, eax
  01817	eb 05		 jmp	 SHORT $LN6525@AddRenderI
$LN6523@AddRenderI:
  01819	1b c0		 sbb	 eax, eax
  0181b	83 d8 ff	 sbb	 eax, -1
$LN6525@AddRenderI:
  0181e	3b c3		 cmp	 eax, ebx
  01820	75 30		 jne	 SHORT $LN6363@AddRenderI

; 365  : 	{
; 366  : 		SAFEDELETE( m_pBlueRank );

  01822	39 9f f4 01 00
	00		 cmp	 DWORD PTR [edi+500], ebx
  01828	74 17		 je	 SHORT $LN59@AddRenderI
  0182a	8b 8f f4 01 00
	00		 mov	 ecx, DWORD PTR [edi+500]
  01830	3b cb		 cmp	 ecx, ebx
  01832	74 07		 je	 SHORT $LN238@AddRenderI
  01834	8b 01		 mov	 eax, DWORD PTR [ecx]
  01836	6a 01		 push	 1
  01838	ff 50 40	 call	 DWORD PTR [eax+64]
$LN238@AddRenderI:
  0183b	89 9f f4 01 00
	00		 mov	 DWORD PTR [edi+500], ebx
$LN59@AddRenderI:

; 367  : 		m_pBlueRank = pImage;

  01841	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  01847	89 87 f4 01 00
	00		 mov	 DWORD PTR [edi+500], eax
  0184d	e9 0f 0d 00 00	 jmp	 $LN1@AddRenderI
$LN6363@AddRenderI:

; 368  : 	}	
; 369  : 	else if( szType == "BluePer" )

  01852	6a 04		 push	 4
  01854	c7 45 9c af 80
	9e 8f		 mov	 DWORD PTR __t$563397[ebp], -1885437777 ; 8f9e80afH
  0185b	81 75 9c ed ec
	eb ea		 xor	 DWORD PTR __t$563397[ebp], -353637139 ; eaebecedH
  01862	c7 45 a0 bd 89
	99 00		 mov	 DWORD PTR __t$563397[ebp+4], 10062269 ; 009989bdH
  01869	58		 pop	 eax
$LL4194@AddRenderI:
  0186a	8b c8		 mov	 ecx, eax
  0186c	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  01872	79 05		 jns	 SHORT $LN6635@AddRenderI
  01874	49		 dec	 ecx
  01875	83 c9 fc	 or	 ecx, -4			; fffffffcH
  01878	41		 inc	 ecx
$LN6635@AddRenderI:
  01879	b2 ed		 mov	 dl, -19			; ffffffedH
  0187b	2a d1		 sub	 dl, cl
  0187d	30 54 05 9c	 xor	 BYTE PTR __t$563397[ebp+eax], dl
  01881	40		 inc	 eax
  01882	83 f8 07	 cmp	 eax, 7
  01885	7c e3		 jl	 SHORT $LL4194@AddRenderI
  01887	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  0188d	8d 75 9c	 lea	 esi, DWORD PTR __t$563397[ebp]
  01890	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6526@AddRenderI:
  01896	8a 08		 mov	 cl, BYTE PTR [eax]
  01898	3a 0e		 cmp	 cl, BYTE PTR [esi]
  0189a	75 1a		 jne	 SHORT $LN6527@AddRenderI
  0189c	3a cb		 cmp	 cl, bl
  0189e	74 12		 je	 SHORT $LN6528@AddRenderI
  018a0	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  018a3	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  018a6	75 0e		 jne	 SHORT $LN6527@AddRenderI
  018a8	83 c0 02	 add	 eax, 2
  018ab	83 c6 02	 add	 esi, 2
  018ae	3a cb		 cmp	 cl, bl
  018b0	75 e4		 jne	 SHORT $LL6526@AddRenderI
$LN6528@AddRenderI:
  018b2	33 c0		 xor	 eax, eax
  018b4	eb 05		 jmp	 SHORT $LN6529@AddRenderI
$LN6527@AddRenderI:
  018b6	1b c0		 sbb	 eax, eax
  018b8	83 d8 ff	 sbb	 eax, -1
$LN6529@AddRenderI:
  018bb	3b c3		 cmp	 eax, ebx
  018bd	75 30		 jne	 SHORT $LN6364@AddRenderI

; 370  : 	{
; 371  : 		SAFEDELETE( m_pBluePer );

  018bf	39 9f f8 01 00
	00		 cmp	 DWORD PTR [edi+504], ebx
  018c5	74 17		 je	 SHORT $LN56@AddRenderI
  018c7	8b 8f f8 01 00
	00		 mov	 ecx, DWORD PTR [edi+504]
  018cd	3b cb		 cmp	 ecx, ebx
  018cf	74 07		 je	 SHORT $LN240@AddRenderI
  018d1	8b 01		 mov	 eax, DWORD PTR [ecx]
  018d3	6a 01		 push	 1
  018d5	ff 50 40	 call	 DWORD PTR [eax+64]
$LN240@AddRenderI:
  018d8	89 9f f8 01 00
	00		 mov	 DWORD PTR [edi+504], ebx
$LN56@AddRenderI:

; 372  : 		m_pBluePer = pImage;

  018de	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  018e4	89 87 f8 01 00
	00		 mov	 DWORD PTR [edi+504], eax
  018ea	e9 72 0c 00 00	 jmp	 $LN1@AddRenderI
$LN6364@AddRenderI:

; 373  : 	}	
; 374  : 	else if( szType == "RedPer" )

  018ef	6a 04		 push	 4
  018f1	c7 45 f0 bf 89
	8f ba		 mov	 DWORD PTR __t$563522[ebp], -1164998209 ; ba8f89bfH
  018f8	81 75 f0 ed ec
	eb ea		 xor	 DWORD PTR __t$563522[ebp], -353637139 ; eaebecedH
  018ff	66 c7 45 f4 88
	9e		 mov	 WORD PTR __t$563522[ebp+4], 40584 ; 00009e88H
  01905	88 5d f6	 mov	 BYTE PTR __t$563522[ebp+6], bl
  01908	58		 pop	 eax
$LL4300@AddRenderI:
  01909	8b c8		 mov	 ecx, eax
  0190b	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  01911	79 05		 jns	 SHORT $LN6636@AddRenderI
  01913	49		 dec	 ecx
  01914	83 c9 fc	 or	 ecx, -4			; fffffffcH
  01917	41		 inc	 ecx
$LN6636@AddRenderI:
  01918	b2 ed		 mov	 dl, -19			; ffffffedH
  0191a	2a d1		 sub	 dl, cl
  0191c	30 54 05 f0	 xor	 BYTE PTR __t$563522[ebp+eax], dl
  01920	40		 inc	 eax
  01921	83 f8 06	 cmp	 eax, 6
  01924	7c e3		 jl	 SHORT $LL4300@AddRenderI
  01926	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  0192c	8d 75 f0	 lea	 esi, DWORD PTR __t$563522[ebp]
  0192f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6530@AddRenderI:
  01935	8a 08		 mov	 cl, BYTE PTR [eax]
  01937	3a 0e		 cmp	 cl, BYTE PTR [esi]
  01939	75 1a		 jne	 SHORT $LN6531@AddRenderI
  0193b	3a cb		 cmp	 cl, bl
  0193d	74 12		 je	 SHORT $LN6617@AddRenderI
  0193f	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  01942	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  01945	75 0e		 jne	 SHORT $LN6531@AddRenderI
  01947	83 c0 02	 add	 eax, 2
  0194a	83 c6 02	 add	 esi, 2
  0194d	3a cb		 cmp	 cl, bl
  0194f	75 e4		 jne	 SHORT $LL6530@AddRenderI
$LN6617@AddRenderI:
  01951	33 c0		 xor	 eax, eax
  01953	eb 05		 jmp	 SHORT $LN6533@AddRenderI
$LN6531@AddRenderI:
  01955	1b c0		 sbb	 eax, eax
  01957	83 d8 ff	 sbb	 eax, -1
$LN6533@AddRenderI:
  0195a	3b c3		 cmp	 eax, ebx
  0195c	75 30		 jne	 SHORT $LN6365@AddRenderI

; 375  : 	{
; 376  : 		SAFEDELETE( m_pRedPer );

  0195e	39 9f fc 01 00
	00		 cmp	 DWORD PTR [edi+508], ebx
  01964	74 17		 je	 SHORT $LN53@AddRenderI
  01966	8b 8f fc 01 00
	00		 mov	 ecx, DWORD PTR [edi+508]
  0196c	3b cb		 cmp	 ecx, ebx
  0196e	74 07		 je	 SHORT $LN242@AddRenderI
  01970	8b 01		 mov	 eax, DWORD PTR [ecx]
  01972	6a 01		 push	 1
  01974	ff 50 40	 call	 DWORD PTR [eax+64]
$LN242@AddRenderI:
  01977	89 9f fc 01 00
	00		 mov	 DWORD PTR [edi+508], ebx
$LN53@AddRenderI:

; 377  : 		m_pRedPer = pImage;

  0197d	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  01983	89 87 fc 01 00
	00		 mov	 DWORD PTR [edi+508], eax
  01989	e9 d3 0b 00 00	 jmp	 $LN1@AddRenderI
$LN6365@AddRenderI:

; 378  : 	}	
; 379  : 	else if( szType == "BluePoint" )

  0198e	6a 02		 push	 2
  01990	c7 85 cc fe ff
	ff af 80 9e 8f	 mov	 DWORD PTR __t$563660[ebp], -1885437777 ; 8f9e80afH
  0199a	c7 85 d0 fe ff
	ff bd 83 82 84	 mov	 DWORD PTR __t$563660[ebp+4], -2071821379 ; 848283bdH
  019a4	8d 85 cc fe ff
	ff		 lea	 eax, DWORD PTR __t$563660[ebp]
  019aa	66 c7 85 d4 fe
	ff ff 99 00	 mov	 WORD PTR __t$563660[ebp+8], 153 ; 00000099H
  019b3	59		 pop	 ecx
$LL4409@AddRenderI:
  019b4	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  019ba	83 c0 04	 add	 eax, 4
  019bd	49		 dec	 ecx
  019be	75 f4		 jne	 SHORT $LL4409@AddRenderI
  019c0	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  019c6	80 b5 d4 fe ff
	ff ed		 xor	 BYTE PTR __t$563660[ebp+8], -19 ; ffffffedH
  019cd	8d b5 cc fe ff
	ff		 lea	 esi, DWORD PTR __t$563660[ebp]
  019d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6534@AddRenderI:
  019d9	8a 08		 mov	 cl, BYTE PTR [eax]
  019db	3a 0e		 cmp	 cl, BYTE PTR [esi]
  019dd	75 1a		 jne	 SHORT $LN6535@AddRenderI
  019df	3a cb		 cmp	 cl, bl
  019e1	74 12		 je	 SHORT $LN6618@AddRenderI
  019e3	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  019e6	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  019e9	75 0e		 jne	 SHORT $LN6535@AddRenderI
  019eb	83 c0 02	 add	 eax, 2
  019ee	83 c6 02	 add	 esi, 2
  019f1	3a cb		 cmp	 cl, bl
  019f3	75 e4		 jne	 SHORT $LL6534@AddRenderI
$LN6618@AddRenderI:
  019f5	33 c0		 xor	 eax, eax
  019f7	eb 05		 jmp	 SHORT $LN6537@AddRenderI
$LN6535@AddRenderI:
  019f9	1b c0		 sbb	 eax, eax
  019fb	83 d8 ff	 sbb	 eax, -1
$LN6537@AddRenderI:
  019fe	3b c3		 cmp	 eax, ebx
  01a00	75 30		 jne	 SHORT $LN6366@AddRenderI

; 380  : 	{
; 381  : 		SAFEDELETE( m_pBluePoint );

  01a02	39 9f 00 02 00
	00		 cmp	 DWORD PTR [edi+512], ebx
  01a08	74 17		 je	 SHORT $LN50@AddRenderI
  01a0a	8b 8f 00 02 00
	00		 mov	 ecx, DWORD PTR [edi+512]
  01a10	3b cb		 cmp	 ecx, ebx
  01a12	74 07		 je	 SHORT $LN244@AddRenderI
  01a14	8b 01		 mov	 eax, DWORD PTR [ecx]
  01a16	6a 01		 push	 1
  01a18	ff 50 40	 call	 DWORD PTR [eax+64]
$LN244@AddRenderI:
  01a1b	89 9f 00 02 00
	00		 mov	 DWORD PTR [edi+512], ebx
$LN50@AddRenderI:

; 382  : 		m_pBluePoint = pImage;

  01a21	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  01a27	89 87 00 02 00
	00		 mov	 DWORD PTR [edi+512], eax
  01a2d	e9 2f 0b 00 00	 jmp	 $LN1@AddRenderI
$LN6366@AddRenderI:

; 383  : 	}	
; 384  : 	else if( szType == "RedPoint" )

  01a32	6a 02		 push	 2
  01a34	c7 85 4c fc ff
	ff bf 89 8f ba	 mov	 DWORD PTR __t$563798[ebp], -1164998209 ; ba8f89bfH
  01a3e	c7 85 50 fc ff
	ff 82 85 85 9e	 mov	 DWORD PTR __t$563798[ebp+4], -1635416702 ; 9e858582H
  01a48	8d 85 4c fc ff
	ff		 lea	 eax, DWORD PTR __t$563798[ebp]
  01a4e	88 9d 54 fc ff
	ff		 mov	 BYTE PTR __t$563798[ebp+8], bl
  01a54	59		 pop	 ecx
$LL4515@AddRenderI:
  01a55	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  01a5b	83 c0 04	 add	 eax, 4
  01a5e	49		 dec	 ecx
  01a5f	75 f4		 jne	 SHORT $LL4515@AddRenderI
  01a61	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  01a67	8d b5 4c fc ff
	ff		 lea	 esi, DWORD PTR __t$563798[ebp]
  01a6d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6538@AddRenderI:
  01a73	8a 08		 mov	 cl, BYTE PTR [eax]
  01a75	3a 0e		 cmp	 cl, BYTE PTR [esi]
  01a77	75 1a		 jne	 SHORT $LN6539@AddRenderI
  01a79	3a cb		 cmp	 cl, bl
  01a7b	74 12		 je	 SHORT $LN6540@AddRenderI
  01a7d	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  01a80	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  01a83	75 0e		 jne	 SHORT $LN6539@AddRenderI
  01a85	83 c0 02	 add	 eax, 2
  01a88	83 c6 02	 add	 esi, 2
  01a8b	3a cb		 cmp	 cl, bl
  01a8d	75 e4		 jne	 SHORT $LL6538@AddRenderI
$LN6540@AddRenderI:
  01a8f	33 c0		 xor	 eax, eax
  01a91	eb 05		 jmp	 SHORT $LN6541@AddRenderI
$LN6539@AddRenderI:
  01a93	1b c0		 sbb	 eax, eax
  01a95	83 d8 ff	 sbb	 eax, -1
$LN6541@AddRenderI:
  01a98	3b c3		 cmp	 eax, ebx
  01a9a	75 30		 jne	 SHORT $LN6367@AddRenderI

; 385  : 	{
; 386  : 		SAFEDELETE( m_pRedPoint );

  01a9c	39 9f 04 02 00
	00		 cmp	 DWORD PTR [edi+516], ebx
  01aa2	74 17		 je	 SHORT $LN47@AddRenderI
  01aa4	8b 8f 04 02 00
	00		 mov	 ecx, DWORD PTR [edi+516]
  01aaa	3b cb		 cmp	 ecx, ebx
  01aac	74 07		 je	 SHORT $LN246@AddRenderI
  01aae	8b 01		 mov	 eax, DWORD PTR [ecx]
  01ab0	6a 01		 push	 1
  01ab2	ff 50 40	 call	 DWORD PTR [eax+64]
$LN246@AddRenderI:
  01ab5	89 9f 04 02 00
	00		 mov	 DWORD PTR [edi+516], ebx
$LN47@AddRenderI:

; 387  : 		m_pRedPoint = pImage;

  01abb	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  01ac1	89 87 04 02 00
	00		 mov	 DWORD PTR [edi+516], eax
  01ac7	e9 95 0a 00 00	 jmp	 $LN1@AddRenderI
$LN6367@AddRenderI:

; 388  : 	}
; 389  : 	else if( szType == "TowerDefTitle" )

  01acc	6a 03		 push	 3
  01ace	c7 85 48 ff ff
	ff b9 83 9c 8f	 mov	 DWORD PTR __t$563897[ebp], -1885568071 ; 8f9c83b9H
  01ad8	c7 85 4c ff ff
	ff 9f a8 8e 8c	 mov	 DWORD PTR __t$563897[ebp+4], -1936807777 ; 8c8ea89fH
  01ae2	c7 85 50 ff ff
	ff b9 85 9f 86	 mov	 DWORD PTR __t$563897[ebp+8], -2036365895 ; 869f85b9H
  01aec	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR __t$563897[ebp]
  01af2	66 c7 85 54 ff
	ff ff 88 00	 mov	 WORD PTR __t$563897[ebp+12], 136 ; 00000088H
  01afb	59		 pop	 ecx
$LL4621@AddRenderI:
  01afc	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  01b02	83 c0 04	 add	 eax, 4
  01b05	49		 dec	 ecx
  01b06	75 f4		 jne	 SHORT $LL4621@AddRenderI
  01b08	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  01b0e	80 b5 54 ff ff
	ff ed		 xor	 BYTE PTR __t$563897[ebp+12], -19 ; ffffffedH
  01b15	8d b5 48 ff ff
	ff		 lea	 esi, DWORD PTR __t$563897[ebp]
  01b1b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6542@AddRenderI:
  01b21	8a 08		 mov	 cl, BYTE PTR [eax]
  01b23	3a 0e		 cmp	 cl, BYTE PTR [esi]
  01b25	75 1a		 jne	 SHORT $LN6543@AddRenderI
  01b27	3a cb		 cmp	 cl, bl
  01b29	74 12		 je	 SHORT $LN6544@AddRenderI
  01b2b	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  01b2e	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  01b31	75 0e		 jne	 SHORT $LN6543@AddRenderI
  01b33	83 c0 02	 add	 eax, 2
  01b36	83 c6 02	 add	 esi, 2
  01b39	3a cb		 cmp	 cl, bl
  01b3b	75 e4		 jne	 SHORT $LL6542@AddRenderI
$LN6544@AddRenderI:
  01b3d	33 c0		 xor	 eax, eax
  01b3f	eb 05		 jmp	 SHORT $LN6545@AddRenderI
$LN6543@AddRenderI:
  01b41	1b c0		 sbb	 eax, eax
  01b43	83 d8 ff	 sbb	 eax, -1
$LN6545@AddRenderI:
  01b46	3b c3		 cmp	 eax, ebx
  01b48	75 30		 jne	 SHORT $LN6368@AddRenderI

; 390  : 	{
; 391  : 		SAFEDELETE( m_pTowerDefTitle );

  01b4a	39 9f 08 02 00
	00		 cmp	 DWORD PTR [edi+520], ebx
  01b50	74 17		 je	 SHORT $LN44@AddRenderI
  01b52	8b 8f 08 02 00
	00		 mov	 ecx, DWORD PTR [edi+520]
  01b58	3b cb		 cmp	 ecx, ebx
  01b5a	74 07		 je	 SHORT $LN248@AddRenderI
  01b5c	8b 01		 mov	 eax, DWORD PTR [ecx]
  01b5e	6a 01		 push	 1
  01b60	ff 50 40	 call	 DWORD PTR [eax+64]
$LN248@AddRenderI:
  01b63	89 9f 08 02 00
	00		 mov	 DWORD PTR [edi+520], ebx
$LN44@AddRenderI:

; 392  : 		m_pTowerDefTitle = pImage;

  01b69	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  01b6f	89 87 08 02 00
	00		 mov	 DWORD PTR [edi+520], eax
  01b75	e9 e7 09 00 00	 jmp	 $LN1@AddRenderI
$LN6368@AddRenderI:

; 393  : 	}
; 394  : 	else if( szType == "FireTempleTitle" )

  01b7a	6a 03		 push	 3
  01b7c	c7 85 00 fe ff
	ff ab 85 99 8f	 mov	 DWORD PTR __t$564022[ebp], -1885764181 ; 8f9985abH
  01b86	c7 85 04 fe ff
	ff b9 89 86 9a	 mov	 DWORD PTR __t$564022[ebp+4], -1702458951 ; 9a8689b9H
  01b90	c7 85 08 fe ff
	ff 81 89 bf 83	 mov	 DWORD PTR __t$564022[ebp+8], -2084599423 ; 83bf8981H
  01b9a	8d 85 00 fe ff
	ff		 lea	 eax, DWORD PTR __t$564022[ebp]
  01ba0	c7 85 0c fe ff
	ff 99 80 8e 00	 mov	 DWORD PTR __t$564022[ebp+12], 9339033 ; 008e8099H
  01baa	59		 pop	 ecx
$LL4727@AddRenderI:
  01bab	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  01bb1	83 c0 04	 add	 eax, 4
  01bb4	49		 dec	 ecx
  01bb5	75 f4		 jne	 SHORT $LL4727@AddRenderI
  01bb7	6a 0c		 push	 12			; 0000000cH
  01bb9	58		 pop	 eax
$LL4724@AddRenderI:
  01bba	8b c8		 mov	 ecx, eax
  01bbc	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  01bc2	79 05		 jns	 SHORT $LN6637@AddRenderI
  01bc4	49		 dec	 ecx
  01bc5	83 c9 fc	 or	 ecx, -4			; fffffffcH
  01bc8	41		 inc	 ecx
$LN6637@AddRenderI:
  01bc9	b2 ed		 mov	 dl, -19			; ffffffedH
  01bcb	2a d1		 sub	 dl, cl
  01bcd	30 94 05 00 fe
	ff ff		 xor	 BYTE PTR __t$564022[ebp+eax], dl
  01bd4	40		 inc	 eax
  01bd5	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  01bd8	7c e0		 jl	 SHORT $LL4724@AddRenderI
  01bda	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  01be0	8d b5 00 fe ff
	ff		 lea	 esi, DWORD PTR __t$564022[ebp]
  01be6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6546@AddRenderI:
  01bec	8a 08		 mov	 cl, BYTE PTR [eax]
  01bee	3a 0e		 cmp	 cl, BYTE PTR [esi]
  01bf0	75 1a		 jne	 SHORT $LN6547@AddRenderI
  01bf2	3a cb		 cmp	 cl, bl
  01bf4	74 12		 je	 SHORT $LN6548@AddRenderI
  01bf6	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  01bf9	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  01bfc	75 0e		 jne	 SHORT $LN6547@AddRenderI
  01bfe	83 c0 02	 add	 eax, 2
  01c01	83 c6 02	 add	 esi, 2
  01c04	3a cb		 cmp	 cl, bl
  01c06	75 e4		 jne	 SHORT $LL6546@AddRenderI
$LN6548@AddRenderI:
  01c08	33 c0		 xor	 eax, eax
  01c0a	eb 05		 jmp	 SHORT $LN6549@AddRenderI
$LN6547@AddRenderI:
  01c0c	1b c0		 sbb	 eax, eax
  01c0e	83 d8 ff	 sbb	 eax, -1
$LN6549@AddRenderI:
  01c11	3b c3		 cmp	 eax, ebx
  01c13	75 30		 jne	 SHORT $LN6369@AddRenderI

; 395  : 	{
; 396  : 		SAFEDELETE( m_pFireTempleTitle );

  01c15	39 9f 10 02 00
	00		 cmp	 DWORD PTR [edi+528], ebx
  01c1b	74 17		 je	 SHORT $LN41@AddRenderI
  01c1d	8b 8f 10 02 00
	00		 mov	 ecx, DWORD PTR [edi+528]
  01c23	3b cb		 cmp	 ecx, ebx
  01c25	74 07		 je	 SHORT $LN250@AddRenderI
  01c27	8b 01		 mov	 eax, DWORD PTR [ecx]
  01c29	6a 01		 push	 1
  01c2b	ff 50 40	 call	 DWORD PTR [eax+64]
$LN250@AddRenderI:
  01c2e	89 9f 10 02 00
	00		 mov	 DWORD PTR [edi+528], ebx
$LN41@AddRenderI:

; 397  : 		m_pFireTempleTitle = pImage;

  01c34	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  01c3a	89 87 10 02 00
	00		 mov	 DWORD PTR [edi+528], eax
  01c40	e9 1c 09 00 00	 jmp	 $LN1@AddRenderI
$LN6369@AddRenderI:

; 398  : 	}
; 399  : 	else if( szType == "SnowTownTitle" )

  01c45	6a 03		 push	 3
  01c47	c7 85 24 ff ff
	ff be 82 84 9d	 mov	 DWORD PTR __t$564147[ebp], -1652260162 ; 9d8482beH
  01c51	c7 85 28 ff ff
	ff b9 83 9c 84	 mov	 DWORD PTR __t$564147[ebp+4], -2070117447 ; 849c83b9H
  01c5b	c7 85 2c ff ff
	ff b9 85 9f 86	 mov	 DWORD PTR __t$564147[ebp+8], -2036365895 ; 869f85b9H
  01c65	8d 85 24 ff ff
	ff		 lea	 eax, DWORD PTR __t$564147[ebp]
  01c6b	66 c7 85 30 ff
	ff ff 88 00	 mov	 WORD PTR __t$564147[ebp+12], 136 ; 00000088H
  01c74	59		 pop	 ecx
$LL4833@AddRenderI:
  01c75	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  01c7b	83 c0 04	 add	 eax, 4
  01c7e	49		 dec	 ecx
  01c7f	75 f4		 jne	 SHORT $LL4833@AddRenderI
  01c81	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  01c87	80 b5 30 ff ff
	ff ed		 xor	 BYTE PTR __t$564147[ebp+12], -19 ; ffffffedH
  01c8e	8d b5 24 ff ff
	ff		 lea	 esi, DWORD PTR __t$564147[ebp]
  01c94	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6550@AddRenderI:
  01c9a	8a 08		 mov	 cl, BYTE PTR [eax]
  01c9c	3a 0e		 cmp	 cl, BYTE PTR [esi]
  01c9e	75 1a		 jne	 SHORT $LN6551@AddRenderI
  01ca0	3a cb		 cmp	 cl, bl
  01ca2	74 12		 je	 SHORT $LN6552@AddRenderI
  01ca4	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  01ca7	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  01caa	75 0e		 jne	 SHORT $LN6551@AddRenderI
  01cac	83 c0 02	 add	 eax, 2
  01caf	83 c6 02	 add	 esi, 2
  01cb2	3a cb		 cmp	 cl, bl
  01cb4	75 e4		 jne	 SHORT $LL6550@AddRenderI
$LN6552@AddRenderI:
  01cb6	33 c0		 xor	 eax, eax
  01cb8	eb 05		 jmp	 SHORT $LN6553@AddRenderI
$LN6551@AddRenderI:
  01cba	1b c0		 sbb	 eax, eax
  01cbc	83 d8 ff	 sbb	 eax, -1
$LN6553@AddRenderI:
  01cbf	3b c3		 cmp	 eax, ebx
  01cc1	75 30		 jne	 SHORT $LN6370@AddRenderI

; 400  : 	{
; 401  : 		SAFEDELETE( m_pSnowTownTitle );

  01cc3	39 9f 0c 02 00
	00		 cmp	 DWORD PTR [edi+524], ebx
  01cc9	74 17		 je	 SHORT $LN38@AddRenderI
  01ccb	8b 8f 0c 02 00
	00		 mov	 ecx, DWORD PTR [edi+524]
  01cd1	3b cb		 cmp	 ecx, ebx
  01cd3	74 07		 je	 SHORT $LN252@AddRenderI
  01cd5	8b 01		 mov	 eax, DWORD PTR [ecx]
  01cd7	6a 01		 push	 1
  01cd9	ff 50 40	 call	 DWORD PTR [eax+64]
$LN252@AddRenderI:
  01cdc	89 9f 0c 02 00
	00		 mov	 DWORD PTR [edi+524], ebx
$LN38@AddRenderI:

; 402  : 		m_pSnowTownTitle = pImage;

  01ce2	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  01ce8	89 87 0c 02 00
	00		 mov	 DWORD PTR [edi+524], eax
  01cee	e9 6e 08 00 00	 jmp	 $LN1@AddRenderI
$LN6370@AddRenderI:

; 403  : 	}
; 404  : 	else if( szType == "FactoryTitle" )

  01cf3	6a 03		 push	 3
  01cf5	c7 85 bc fc ff
	ff ab 8d 88 9e	 mov	 DWORD PTR __t$564285[ebp], -1635218005 ; 9e888dabH
  01cff	c7 85 c0 fc ff
	ff 82 9e 92 be	 mov	 DWORD PTR __t$564285[ebp+4], -1097687422 ; be929e82H
  01d09	c7 85 c4 fc ff
	ff 84 98 87 8f	 mov	 DWORD PTR __t$564285[ebp+8], -1886939004 ; 8f879884H
  01d13	8d 85 bc fc ff
	ff		 lea	 eax, DWORD PTR __t$564285[ebp]
  01d19	88 9d c8 fc ff
	ff		 mov	 BYTE PTR __t$564285[ebp+12], bl
  01d1f	59		 pop	 ecx
$LL4939@AddRenderI:
  01d20	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  01d26	83 c0 04	 add	 eax, 4
  01d29	49		 dec	 ecx
  01d2a	75 f4		 jne	 SHORT $LL4939@AddRenderI
  01d2c	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  01d32	8d b5 bc fc ff
	ff		 lea	 esi, DWORD PTR __t$564285[ebp]
  01d38	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6554@AddRenderI:
  01d3e	8a 08		 mov	 cl, BYTE PTR [eax]
  01d40	3a 0e		 cmp	 cl, BYTE PTR [esi]
  01d42	75 1a		 jne	 SHORT $LN6555@AddRenderI
  01d44	3a cb		 cmp	 cl, bl
  01d46	74 12		 je	 SHORT $LN6556@AddRenderI
  01d48	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  01d4b	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  01d4e	75 0e		 jne	 SHORT $LN6555@AddRenderI
  01d50	83 c0 02	 add	 eax, 2
  01d53	83 c6 02	 add	 esi, 2
  01d56	3a cb		 cmp	 cl, bl
  01d58	75 e4		 jne	 SHORT $LL6554@AddRenderI
$LN6556@AddRenderI:
  01d5a	33 c0		 xor	 eax, eax
  01d5c	eb 05		 jmp	 SHORT $LN6557@AddRenderI
$LN6555@AddRenderI:
  01d5e	1b c0		 sbb	 eax, eax
  01d60	83 d8 ff	 sbb	 eax, -1
$LN6557@AddRenderI:
  01d63	3b c3		 cmp	 eax, ebx
  01d65	75 30		 jne	 SHORT $LN6371@AddRenderI

; 405  : 	{
; 406  : 		SAFEDELETE( m_pFactoryTitle );

  01d67	39 9f 14 02 00
	00		 cmp	 DWORD PTR [edi+532], ebx
  01d6d	74 17		 je	 SHORT $LN35@AddRenderI
  01d6f	8b 8f 14 02 00
	00		 mov	 ecx, DWORD PTR [edi+532]
  01d75	3b cb		 cmp	 ecx, ebx
  01d77	74 07		 je	 SHORT $LN254@AddRenderI
  01d79	8b 01		 mov	 eax, DWORD PTR [ecx]
  01d7b	6a 01		 push	 1
  01d7d	ff 50 40	 call	 DWORD PTR [eax+64]
$LN254@AddRenderI:
  01d80	89 9f 14 02 00
	00		 mov	 DWORD PTR [edi+532], ebx
$LN35@AddRenderI:

; 407  : 		m_pFactoryTitle = pImage;

  01d86	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  01d8c	89 87 14 02 00
	00		 mov	 DWORD PTR [edi+532], eax
  01d92	e9 ca 07 00 00	 jmp	 $LN1@AddRenderI
$LN6371@AddRenderI:

; 408  : 	}
; 409  : 	else if( szType == "TowerDefEasy" )

  01d97	6a 03		 push	 3
  01d99	c7 85 d0 fc ff
	ff b9 83 9c 8f	 mov	 DWORD PTR __t$564410[ebp], -1885568071 ; 8f9c83b9H
  01da3	c7 85 d4 fc ff
	ff 9f a8 8e 8c	 mov	 DWORD PTR __t$564410[ebp+4], -1936807777 ; 8c8ea89fH
  01dad	c7 85 d8 fc ff
	ff a8 8d 98 93	 mov	 DWORD PTR __t$564410[ebp+8], -1818718808 ; 93988da8H
  01db7	8d 85 d0 fc ff
	ff		 lea	 eax, DWORD PTR __t$564410[ebp]
  01dbd	88 9d dc fc ff
	ff		 mov	 BYTE PTR __t$564410[ebp+12], bl
  01dc3	59		 pop	 ecx
$LL5045@AddRenderI:
  01dc4	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  01dca	83 c0 04	 add	 eax, 4
  01dcd	49		 dec	 ecx
  01dce	75 f4		 jne	 SHORT $LL5045@AddRenderI
  01dd0	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  01dd6	8d b5 d0 fc ff
	ff		 lea	 esi, DWORD PTR __t$564410[ebp]
  01ddc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6558@AddRenderI:
  01de2	8a 08		 mov	 cl, BYTE PTR [eax]
  01de4	3a 0e		 cmp	 cl, BYTE PTR [esi]
  01de6	75 1a		 jne	 SHORT $LN6559@AddRenderI
  01de8	3a cb		 cmp	 cl, bl
  01dea	74 12		 je	 SHORT $LN6560@AddRenderI
  01dec	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  01def	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  01df2	75 0e		 jne	 SHORT $LN6559@AddRenderI
  01df4	83 c0 02	 add	 eax, 2
  01df7	83 c6 02	 add	 esi, 2
  01dfa	3a cb		 cmp	 cl, bl
  01dfc	75 e4		 jne	 SHORT $LL6558@AddRenderI
$LN6560@AddRenderI:
  01dfe	33 c0		 xor	 eax, eax
  01e00	eb 05		 jmp	 SHORT $LN6561@AddRenderI
$LN6559@AddRenderI:
  01e02	1b c0		 sbb	 eax, eax
  01e04	83 d8 ff	 sbb	 eax, -1
$LN6561@AddRenderI:
  01e07	3b c3		 cmp	 eax, ebx
  01e09	75 30		 jne	 SHORT $LN6372@AddRenderI

; 410  : 	{
; 411  : 		SAFEDELETE( m_pTowerDefDiff[TOWERDEF_EASY] );

  01e0b	39 9f 18 02 00
	00		 cmp	 DWORD PTR [edi+536], ebx
  01e11	74 17		 je	 SHORT $LN32@AddRenderI
  01e13	8b 8f 18 02 00
	00		 mov	 ecx, DWORD PTR [edi+536]
  01e19	3b cb		 cmp	 ecx, ebx
  01e1b	74 07		 je	 SHORT $LN256@AddRenderI
  01e1d	8b 01		 mov	 eax, DWORD PTR [ecx]
  01e1f	6a 01		 push	 1
  01e21	ff 50 40	 call	 DWORD PTR [eax+64]
$LN256@AddRenderI:
  01e24	89 9f 18 02 00
	00		 mov	 DWORD PTR [edi+536], ebx
$LN32@AddRenderI:

; 412  : 		m_pTowerDefDiff[TOWERDEF_EASY] = pImage;

  01e2a	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  01e30	89 87 18 02 00
	00		 mov	 DWORD PTR [edi+536], eax
  01e36	e9 26 07 00 00	 jmp	 $LN1@AddRenderI
$LN6372@AddRenderI:

; 413  : 	}
; 414  : 	else if( szType == "TowerDefNoraml" )

  01e3b	6a 03		 push	 3
  01e3d	c7 85 70 fe ff
	ff b9 83 9c 8f	 mov	 DWORD PTR __t$564535[ebp], -1885568071 ; 8f9c83b9H
  01e47	c7 85 74 fe ff
	ff 9f a8 8e 8c	 mov	 DWORD PTR __t$564535[ebp+4], -1936807777 ; 8c8ea89fH
  01e51	c7 85 78 fe ff
	ff a3 83 99 8b	 mov	 DWORD PTR __t$564535[ebp+8], -1952873565 ; 8b9983a3H
  01e5b	66 c7 85 7c fe
	ff ff 80 80	 mov	 WORD PTR __t$564535[ebp+12], 32896 ; 00008080H
  01e64	8d 85 70 fe ff
	ff		 lea	 eax, DWORD PTR __t$564535[ebp]
  01e6a	88 9d 7e fe ff
	ff		 mov	 BYTE PTR __t$564535[ebp+14], bl
  01e70	59		 pop	 ecx
$LL5151@AddRenderI:
  01e71	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  01e77	83 c0 04	 add	 eax, 4
  01e7a	49		 dec	 ecx
  01e7b	75 f4		 jne	 SHORT $LL5151@AddRenderI
  01e7d	6a 0c		 push	 12			; 0000000cH
  01e7f	58		 pop	 eax
$LL5148@AddRenderI:
  01e80	8b c8		 mov	 ecx, eax
  01e82	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  01e88	79 05		 jns	 SHORT $LN6638@AddRenderI
  01e8a	49		 dec	 ecx
  01e8b	83 c9 fc	 or	 ecx, -4			; fffffffcH
  01e8e	41		 inc	 ecx
$LN6638@AddRenderI:
  01e8f	b2 ed		 mov	 dl, -19			; ffffffedH
  01e91	2a d1		 sub	 dl, cl
  01e93	30 94 05 70 fe
	ff ff		 xor	 BYTE PTR __t$564535[ebp+eax], dl
  01e9a	40		 inc	 eax
  01e9b	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  01e9e	7c e0		 jl	 SHORT $LL5148@AddRenderI
  01ea0	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  01ea6	8d b5 70 fe ff
	ff		 lea	 esi, DWORD PTR __t$564535[ebp]
  01eac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6562@AddRenderI:
  01eb2	8a 08		 mov	 cl, BYTE PTR [eax]
  01eb4	3a 0e		 cmp	 cl, BYTE PTR [esi]
  01eb6	75 1a		 jne	 SHORT $LN6563@AddRenderI
  01eb8	3a cb		 cmp	 cl, bl
  01eba	74 12		 je	 SHORT $LN6564@AddRenderI
  01ebc	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  01ebf	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  01ec2	75 0e		 jne	 SHORT $LN6563@AddRenderI
  01ec4	83 c0 02	 add	 eax, 2
  01ec7	83 c6 02	 add	 esi, 2
  01eca	3a cb		 cmp	 cl, bl
  01ecc	75 e4		 jne	 SHORT $LL6562@AddRenderI
$LN6564@AddRenderI:
  01ece	33 c0		 xor	 eax, eax
  01ed0	eb 05		 jmp	 SHORT $LN6565@AddRenderI
$LN6563@AddRenderI:
  01ed2	1b c0		 sbb	 eax, eax
  01ed4	83 d8 ff	 sbb	 eax, -1
$LN6565@AddRenderI:
  01ed7	3b c3		 cmp	 eax, ebx
  01ed9	75 30		 jne	 SHORT $LN6373@AddRenderI

; 415  : 	{
; 416  : 		SAFEDELETE( m_pTowerDefDiff[TOWERDEF_NORMAL] );

  01edb	39 9f 1c 02 00
	00		 cmp	 DWORD PTR [edi+540], ebx
  01ee1	74 17		 je	 SHORT $LN29@AddRenderI
  01ee3	8b 8f 1c 02 00
	00		 mov	 ecx, DWORD PTR [edi+540]
  01ee9	3b cb		 cmp	 ecx, ebx
  01eeb	74 07		 je	 SHORT $LN258@AddRenderI
  01eed	8b 01		 mov	 eax, DWORD PTR [ecx]
  01eef	6a 01		 push	 1
  01ef1	ff 50 40	 call	 DWORD PTR [eax+64]
$LN258@AddRenderI:
  01ef4	89 9f 1c 02 00
	00		 mov	 DWORD PTR [edi+540], ebx
$LN29@AddRenderI:

; 417  : 		m_pTowerDefDiff[TOWERDEF_NORMAL] = pImage;

  01efa	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  01f00	89 87 1c 02 00
	00		 mov	 DWORD PTR [edi+540], eax
  01f06	e9 56 06 00 00	 jmp	 $LN1@AddRenderI
$LN6373@AddRenderI:

; 418  : 	}
; 419  : 	else if( szType == "TowerDefHard" )

  01f0b	6a 03		 push	 3
  01f0d	c7 85 e4 fc ff
	ff b9 83 9c 8f	 mov	 DWORD PTR __t$564660[ebp], -1885568071 ; 8f9c83b9H
  01f17	c7 85 e8 fc ff
	ff 9f a8 8e 8c	 mov	 DWORD PTR __t$564660[ebp+4], -1936807777 ; 8c8ea89fH
  01f21	c7 85 ec fc ff
	ff a5 8d 99 8e	 mov	 DWORD PTR __t$564660[ebp+8], -1902539355 ; 8e998da5H
  01f2b	8d 85 e4 fc ff
	ff		 lea	 eax, DWORD PTR __t$564660[ebp]
  01f31	88 9d f0 fc ff
	ff		 mov	 BYTE PTR __t$564660[ebp+12], bl
  01f37	59		 pop	 ecx
$LL5257@AddRenderI:
  01f38	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  01f3e	83 c0 04	 add	 eax, 4
  01f41	49		 dec	 ecx
  01f42	75 f4		 jne	 SHORT $LL5257@AddRenderI
  01f44	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  01f4a	8d b5 e4 fc ff
	ff		 lea	 esi, DWORD PTR __t$564660[ebp]
  01f50	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6566@AddRenderI:
  01f56	8a 08		 mov	 cl, BYTE PTR [eax]
  01f58	3a 0e		 cmp	 cl, BYTE PTR [esi]
  01f5a	75 1a		 jne	 SHORT $LN6567@AddRenderI
  01f5c	3a cb		 cmp	 cl, bl
  01f5e	74 12		 je	 SHORT $LN6568@AddRenderI
  01f60	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  01f63	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  01f66	75 0e		 jne	 SHORT $LN6567@AddRenderI
  01f68	83 c0 02	 add	 eax, 2
  01f6b	83 c6 02	 add	 esi, 2
  01f6e	3a cb		 cmp	 cl, bl
  01f70	75 e4		 jne	 SHORT $LL6566@AddRenderI
$LN6568@AddRenderI:
  01f72	33 c0		 xor	 eax, eax
  01f74	eb 05		 jmp	 SHORT $LN6569@AddRenderI
$LN6567@AddRenderI:
  01f76	1b c0		 sbb	 eax, eax
  01f78	83 d8 ff	 sbb	 eax, -1
$LN6569@AddRenderI:
  01f7b	3b c3		 cmp	 eax, ebx
  01f7d	75 30		 jne	 SHORT $LN6374@AddRenderI

; 420  : 	{
; 421  : 		SAFEDELETE( m_pTowerDefDiff[TOWERDEF_HARD] );

  01f7f	39 9f 20 02 00
	00		 cmp	 DWORD PTR [edi+544], ebx
  01f85	74 17		 je	 SHORT $LN26@AddRenderI
  01f87	8b 8f 20 02 00
	00		 mov	 ecx, DWORD PTR [edi+544]
  01f8d	3b cb		 cmp	 ecx, ebx
  01f8f	74 07		 je	 SHORT $LN260@AddRenderI
  01f91	8b 01		 mov	 eax, DWORD PTR [ecx]
  01f93	6a 01		 push	 1
  01f95	ff 50 40	 call	 DWORD PTR [eax+64]
$LN260@AddRenderI:
  01f98	89 9f 20 02 00
	00		 mov	 DWORD PTR [edi+544], ebx
$LN26@AddRenderI:

; 422  : 		m_pTowerDefDiff[TOWERDEF_HARD] = pImage;

  01f9e	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  01fa4	89 87 20 02 00
	00		 mov	 DWORD PTR [edi+544], eax
  01faa	e9 b2 05 00 00	 jmp	 $LN1@AddRenderI
$LN6374@AddRenderI:

; 423  : 	}
; 424  : 	else if( szType == "TowerDefMaster" )

  01faf	6a 03		 push	 3
  01fb1	c7 85 48 fe ff
	ff b9 83 9c 8f	 mov	 DWORD PTR __t$564772[ebp], -1885568071 ; 8f9c83b9H
  01fbb	c7 85 4c fe ff
	ff 9f a8 8e 8c	 mov	 DWORD PTR __t$564772[ebp+4], -1936807777 ; 8c8ea89fH
  01fc5	c7 85 50 fe ff
	ff a0 8d 98 9e	 mov	 DWORD PTR __t$564772[ebp+8], -1634169440 ; 9e988da0H
  01fcf	66 c7 85 54 fe
	ff ff 88 9e	 mov	 WORD PTR __t$564772[ebp+12], 40584 ; 00009e88H
  01fd8	8d 85 48 fe ff
	ff		 lea	 eax, DWORD PTR __t$564772[ebp]
  01fde	88 9d 56 fe ff
	ff		 mov	 BYTE PTR __t$564772[ebp+14], bl
  01fe4	59		 pop	 ecx
$LL5363@AddRenderI:
  01fe5	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  01feb	83 c0 04	 add	 eax, 4
  01fee	49		 dec	 ecx
  01fef	75 f4		 jne	 SHORT $LL5363@AddRenderI
  01ff1	6a 0c		 push	 12			; 0000000cH
  01ff3	58		 pop	 eax
$LL5360@AddRenderI:
  01ff4	8b c8		 mov	 ecx, eax
  01ff6	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  01ffc	79 05		 jns	 SHORT $LN6639@AddRenderI
  01ffe	49		 dec	 ecx
  01fff	83 c9 fc	 or	 ecx, -4			; fffffffcH
  02002	41		 inc	 ecx
$LN6639@AddRenderI:
  02003	b2 ed		 mov	 dl, -19			; ffffffedH
  02005	2a d1		 sub	 dl, cl
  02007	30 94 05 48 fe
	ff ff		 xor	 BYTE PTR __t$564772[ebp+eax], dl
  0200e	40		 inc	 eax
  0200f	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  02012	7c e0		 jl	 SHORT $LL5360@AddRenderI
  02014	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  0201a	8d b5 48 fe ff
	ff		 lea	 esi, DWORD PTR __t$564772[ebp]
  02020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6570@AddRenderI:
  02026	8a 08		 mov	 cl, BYTE PTR [eax]
  02028	3a 0e		 cmp	 cl, BYTE PTR [esi]
  0202a	75 1a		 jne	 SHORT $LN6571@AddRenderI
  0202c	3a cb		 cmp	 cl, bl
  0202e	74 12		 je	 SHORT $LN6572@AddRenderI
  02030	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  02033	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  02036	75 0e		 jne	 SHORT $LN6571@AddRenderI
  02038	83 c0 02	 add	 eax, 2
  0203b	83 c6 02	 add	 esi, 2
  0203e	3a cb		 cmp	 cl, bl
  02040	75 e4		 jne	 SHORT $LL6570@AddRenderI
$LN6572@AddRenderI:
  02042	33 c0		 xor	 eax, eax
  02044	eb 05		 jmp	 SHORT $LN6573@AddRenderI
$LN6571@AddRenderI:
  02046	1b c0		 sbb	 eax, eax
  02048	83 d8 ff	 sbb	 eax, -1
$LN6573@AddRenderI:
  0204b	3b c3		 cmp	 eax, ebx
  0204d	75 30		 jne	 SHORT $LN6375@AddRenderI

; 425  : 	{
; 426  : 		SAFEDELETE( m_pTowerDefDiff[TOWERDEF_MASTER] );

  0204f	39 9f 24 02 00
	00		 cmp	 DWORD PTR [edi+548], ebx
  02055	74 17		 je	 SHORT $LN23@AddRenderI
  02057	8b 8f 24 02 00
	00		 mov	 ecx, DWORD PTR [edi+548]
  0205d	3b cb		 cmp	 ecx, ebx
  0205f	74 07		 je	 SHORT $LN262@AddRenderI
  02061	8b 01		 mov	 eax, DWORD PTR [ecx]
  02063	6a 01		 push	 1
  02065	ff 50 40	 call	 DWORD PTR [eax+64]
$LN262@AddRenderI:
  02068	89 9f 24 02 00
	00		 mov	 DWORD PTR [edi+548], ebx
$LN23@AddRenderI:

; 427  : 		m_pTowerDefDiff[TOWERDEF_MASTER] = pImage;

  0206e	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  02074	89 87 24 02 00
	00		 mov	 DWORD PTR [edi+548], eax
  0207a	e9 e2 04 00 00	 jmp	 $LN1@AddRenderI
$LN6375@AddRenderI:

; 428  : 	}
; 429  : 	else if( szType == "GoldMonsterCoin" )

  0207f	6a 03		 push	 3
  02081	c7 85 dc fd ff
	ff aa 83 87 8e	 mov	 DWORD PTR __t$564910[ebp], -1903721558 ; 8e8783aaH
  0208b	c7 85 e0 fd ff
	ff a0 83 85 99	 mov	 DWORD PTR __t$564910[ebp+4], -1719303264 ; 998583a0H
  02095	c7 85 e4 fd ff
	ff 99 89 99 a9	 mov	 DWORD PTR __t$564910[ebp+8], -1449555559 ; a9998999H
  0209f	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR __t$564910[ebp]
  020a5	c7 85 e8 fd ff
	ff 82 85 85 00	 mov	 DWORD PTR __t$564910[ebp+12], 8750466 ; 00858582H
  020af	59		 pop	 ecx
$LL5469@AddRenderI:
  020b0	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  020b6	83 c0 04	 add	 eax, 4
  020b9	49		 dec	 ecx
  020ba	75 f4		 jne	 SHORT $LL5469@AddRenderI
  020bc	6a 0c		 push	 12			; 0000000cH
  020be	58		 pop	 eax
$LL5466@AddRenderI:
  020bf	8b c8		 mov	 ecx, eax
  020c1	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  020c7	79 05		 jns	 SHORT $LN6640@AddRenderI
  020c9	49		 dec	 ecx
  020ca	83 c9 fc	 or	 ecx, -4			; fffffffcH
  020cd	41		 inc	 ecx
$LN6640@AddRenderI:
  020ce	b2 ed		 mov	 dl, -19			; ffffffedH
  020d0	2a d1		 sub	 dl, cl
  020d2	30 94 05 dc fd
	ff ff		 xor	 BYTE PTR __t$564910[ebp+eax], dl
  020d9	40		 inc	 eax
  020da	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  020dd	7c e0		 jl	 SHORT $LL5466@AddRenderI
  020df	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  020e5	8d b5 dc fd ff
	ff		 lea	 esi, DWORD PTR __t$564910[ebp]
  020eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6574@AddRenderI:
  020f1	8a 08		 mov	 cl, BYTE PTR [eax]
  020f3	3a 0e		 cmp	 cl, BYTE PTR [esi]
  020f5	75 1a		 jne	 SHORT $LN6575@AddRenderI
  020f7	3a cb		 cmp	 cl, bl
  020f9	74 12		 je	 SHORT $LN6619@AddRenderI
  020fb	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  020fe	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  02101	75 0e		 jne	 SHORT $LN6575@AddRenderI
  02103	83 c0 02	 add	 eax, 2
  02106	83 c6 02	 add	 esi, 2
  02109	3a cb		 cmp	 cl, bl
  0210b	75 e4		 jne	 SHORT $LL6574@AddRenderI
$LN6619@AddRenderI:
  0210d	33 c0		 xor	 eax, eax
  0210f	eb 05		 jmp	 SHORT $LN6577@AddRenderI
$LN6575@AddRenderI:
  02111	1b c0		 sbb	 eax, eax
  02113	83 d8 ff	 sbb	 eax, -1
$LN6577@AddRenderI:
  02116	3b c3		 cmp	 eax, ebx
  02118	75 30		 jne	 SHORT $LN6376@AddRenderI

; 430  : 	{
; 431  : 		SAFEDELETE( m_pGoldMonsterCoin );

  0211a	39 9f 28 02 00
	00		 cmp	 DWORD PTR [edi+552], ebx
  02120	74 17		 je	 SHORT $LN20@AddRenderI
  02122	8b 8f 28 02 00
	00		 mov	 ecx, DWORD PTR [edi+552]
  02128	3b cb		 cmp	 ecx, ebx
  0212a	74 07		 je	 SHORT $LN264@AddRenderI
  0212c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0212e	6a 01		 push	 1
  02130	ff 50 40	 call	 DWORD PTR [eax+64]
$LN264@AddRenderI:
  02133	89 9f 28 02 00
	00		 mov	 DWORD PTR [edi+552], ebx
$LN20@AddRenderI:

; 432  : 		m_pGoldMonsterCoin = pImage;

  02139	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  0213f	89 87 28 02 00
	00		 mov	 DWORD PTR [edi+552], eax
  02145	e9 17 04 00 00	 jmp	 $LN1@AddRenderI
$LN6376@AddRenderI:

; 433  : 	}	
; 434  : 	else if( szType == "MonsterCoin" )

  0214a	6a 02		 push	 2
  0214c	c7 85 84 fe ff
	ff a0 83 85 99	 mov	 DWORD PTR __t$565022[ebp], -1719303264 ; 998583a0H
  02156	c7 85 88 fe ff
	ff 99 89 99 a9	 mov	 DWORD PTR __t$565022[ebp+4], -1449555559 ; a9998999H
  02160	8d 85 84 fe ff
	ff		 lea	 eax, DWORD PTR __t$565022[ebp]
  02166	c7 85 8c fe ff
	ff 82 85 85 00	 mov	 DWORD PTR __t$565022[ebp+8], 8750466 ; 00858582H
  02170	59		 pop	 ecx
$LL5575@AddRenderI:
  02171	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  02177	83 c0 04	 add	 eax, 4
  0217a	49		 dec	 ecx
  0217b	75 f4		 jne	 SHORT $LL5575@AddRenderI
  0217d	6a 08		 push	 8
  0217f	58		 pop	 eax
$LL5572@AddRenderI:
  02180	8b c8		 mov	 ecx, eax
  02182	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  02188	79 05		 jns	 SHORT $LN6641@AddRenderI
  0218a	49		 dec	 ecx
  0218b	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0218e	41		 inc	 ecx
$LN6641@AddRenderI:
  0218f	b2 ed		 mov	 dl, -19			; ffffffedH
  02191	2a d1		 sub	 dl, cl
  02193	30 94 05 84 fe
	ff ff		 xor	 BYTE PTR __t$565022[ebp+eax], dl
  0219a	40		 inc	 eax
  0219b	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0219e	7c e0		 jl	 SHORT $LL5572@AddRenderI
  021a0	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  021a6	8d b5 84 fe ff
	ff		 lea	 esi, DWORD PTR __t$565022[ebp]
  021ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6578@AddRenderI:
  021b2	8a 08		 mov	 cl, BYTE PTR [eax]
  021b4	3a 0e		 cmp	 cl, BYTE PTR [esi]
  021b6	75 1a		 jne	 SHORT $LN6579@AddRenderI
  021b8	3a cb		 cmp	 cl, bl
  021ba	74 12		 je	 SHORT $LN6620@AddRenderI
  021bc	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  021bf	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  021c2	75 0e		 jne	 SHORT $LN6579@AddRenderI
  021c4	83 c0 02	 add	 eax, 2
  021c7	83 c6 02	 add	 esi, 2
  021ca	3a cb		 cmp	 cl, bl
  021cc	75 e4		 jne	 SHORT $LL6578@AddRenderI
$LN6620@AddRenderI:
  021ce	33 c0		 xor	 eax, eax
  021d0	eb 05		 jmp	 SHORT $LN6581@AddRenderI
$LN6579@AddRenderI:
  021d2	1b c0		 sbb	 eax, eax
  021d4	83 d8 ff	 sbb	 eax, -1
$LN6581@AddRenderI:
  021d7	3b c3		 cmp	 eax, ebx
  021d9	75 30		 jne	 SHORT $LN6377@AddRenderI

; 435  : 	{
; 436  : 		SAFEDELETE( m_pMonsterCoin );

  021db	39 9f 2c 02 00
	00		 cmp	 DWORD PTR [edi+556], ebx
  021e1	74 17		 je	 SHORT $LN17@AddRenderI
  021e3	8b 8f 2c 02 00
	00		 mov	 ecx, DWORD PTR [edi+556]
  021e9	3b cb		 cmp	 ecx, ebx
  021eb	74 07		 je	 SHORT $LN266@AddRenderI
  021ed	8b 01		 mov	 eax, DWORD PTR [ecx]
  021ef	6a 01		 push	 1
  021f1	ff 50 40	 call	 DWORD PTR [eax+64]
$LN266@AddRenderI:
  021f4	89 9f 2c 02 00
	00		 mov	 DWORD PTR [edi+556], ebx
$LN17@AddRenderI:

; 437  : 		m_pMonsterCoin = pImage;

  021fa	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  02200	89 87 2c 02 00
	00		 mov	 DWORD PTR [edi+556], eax
  02206	e9 56 03 00 00	 jmp	 $LN1@AddRenderI
$LN6377@AddRenderI:

; 438  : 	}	
; 439  : 	else if( szType == "RaidCoin" )

  0220b	6a 02		 push	 2
  0220d	c7 85 2c fc ff
	ff bf 8d 82 8e	 mov	 DWORD PTR __t$565160[ebp], -1904046657 ; 8e828dbfH
  02217	c7 85 30 fc ff
	ff ae 83 82 84	 mov	 DWORD PTR __t$565160[ebp+4], -2071821394 ; 848283aeH
  02221	8d 85 2c fc ff
	ff		 lea	 eax, DWORD PTR __t$565160[ebp]
  02227	88 9d 34 fc ff
	ff		 mov	 BYTE PTR __t$565160[ebp+8], bl
  0222d	59		 pop	 ecx
$LL5681@AddRenderI:
  0222e	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  02234	83 c0 04	 add	 eax, 4
  02237	49		 dec	 ecx
  02238	75 f4		 jne	 SHORT $LL5681@AddRenderI
  0223a	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  02240	8d b5 2c fc ff
	ff		 lea	 esi, DWORD PTR __t$565160[ebp]
  02246	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6582@AddRenderI:
  0224c	8a 08		 mov	 cl, BYTE PTR [eax]
  0224e	3a 0e		 cmp	 cl, BYTE PTR [esi]
  02250	75 1a		 jne	 SHORT $LN6583@AddRenderI
  02252	3a cb		 cmp	 cl, bl
  02254	74 12		 je	 SHORT $LN6621@AddRenderI
  02256	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  02259	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  0225c	75 0e		 jne	 SHORT $LN6583@AddRenderI
  0225e	83 c0 02	 add	 eax, 2
  02261	83 c6 02	 add	 esi, 2
  02264	3a cb		 cmp	 cl, bl
  02266	75 e4		 jne	 SHORT $LL6582@AddRenderI
$LN6621@AddRenderI:
  02268	33 c0		 xor	 eax, eax
  0226a	eb 05		 jmp	 SHORT $LN6585@AddRenderI
$LN6583@AddRenderI:
  0226c	1b c0		 sbb	 eax, eax
  0226e	83 d8 ff	 sbb	 eax, -1
$LN6585@AddRenderI:
  02271	3b c3		 cmp	 eax, ebx
  02273	75 30		 jne	 SHORT $LN6378@AddRenderI

; 440  : 	{
; 441  : 		SAFEDELETE( m_pRaidCoin );

  02275	39 9f 30 02 00
	00		 cmp	 DWORD PTR [edi+560], ebx
  0227b	74 17		 je	 SHORT $LN14@AddRenderI
  0227d	8b 8f 30 02 00
	00		 mov	 ecx, DWORD PTR [edi+560]
  02283	3b cb		 cmp	 ecx, ebx
  02285	74 07		 je	 SHORT $LN268@AddRenderI
  02287	8b 01		 mov	 eax, DWORD PTR [ecx]
  02289	6a 01		 push	 1
  0228b	ff 50 40	 call	 DWORD PTR [eax+64]
$LN268@AddRenderI:
  0228e	89 9f 30 02 00
	00		 mov	 DWORD PTR [edi+560], ebx
$LN14@AddRenderI:

; 442  : 		m_pRaidCoin = pImage;

  02294	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  0229a	89 87 30 02 00
	00		 mov	 DWORD PTR [edi+560], eax
  022a0	e9 bc 02 00 00	 jmp	 $LN1@AddRenderI
$LN6378@AddRenderI:

; 443  : 	}	
; 444  : 	else if( szType == "CoinNumber" )

  022a5	6a 02		 push	 2
  022a7	c7 85 b8 fd ff
	ff ae 83 82 84	 mov	 DWORD PTR __t$565285[ebp], -2071821394 ; 848283aeH
  022b1	c7 85 bc fd ff
	ff a3 99 86 88	 mov	 DWORD PTR __t$565285[ebp+4], -2004444765 ; 888699a3H
  022bb	66 c7 85 c0 fd
	ff ff 88 9e	 mov	 WORD PTR __t$565285[ebp+8], 40584 ; 00009e88H
  022c4	8d 85 b8 fd ff
	ff		 lea	 eax, DWORD PTR __t$565285[ebp]
  022ca	88 9d c2 fd ff
	ff		 mov	 BYTE PTR __t$565285[ebp+10], bl
  022d0	59		 pop	 ecx
$LL5787@AddRenderI:
  022d1	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  022d7	83 c0 04	 add	 eax, 4
  022da	49		 dec	 ecx
  022db	75 f4		 jne	 SHORT $LL5787@AddRenderI
  022dd	6a 08		 push	 8
  022df	58		 pop	 eax
$LL5784@AddRenderI:
  022e0	8b c8		 mov	 ecx, eax
  022e2	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  022e8	79 05		 jns	 SHORT $LN6642@AddRenderI
  022ea	49		 dec	 ecx
  022eb	83 c9 fc	 or	 ecx, -4			; fffffffcH
  022ee	41		 inc	 ecx
$LN6642@AddRenderI:
  022ef	b2 ed		 mov	 dl, -19			; ffffffedH
  022f1	2a d1		 sub	 dl, cl
  022f3	30 94 05 b8 fd
	ff ff		 xor	 BYTE PTR __t$565285[ebp+eax], dl
  022fa	40		 inc	 eax
  022fb	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  022fe	7c e0		 jl	 SHORT $LL5784@AddRenderI
  02300	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  02306	8d b5 b8 fd ff
	ff		 lea	 esi, DWORD PTR __t$565285[ebp]
  0230c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6586@AddRenderI:
  02312	8a 08		 mov	 cl, BYTE PTR [eax]
  02314	3a 0e		 cmp	 cl, BYTE PTR [esi]
  02316	75 1a		 jne	 SHORT $LN6587@AddRenderI
  02318	3a cb		 cmp	 cl, bl
  0231a	74 12		 je	 SHORT $LN6588@AddRenderI
  0231c	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  0231f	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  02322	75 0e		 jne	 SHORT $LN6587@AddRenderI
  02324	83 c0 02	 add	 eax, 2
  02327	83 c6 02	 add	 esi, 2
  0232a	3a cb		 cmp	 cl, bl
  0232c	75 e4		 jne	 SHORT $LL6586@AddRenderI
$LN6588@AddRenderI:
  0232e	33 c0		 xor	 eax, eax
  02330	eb 05		 jmp	 SHORT $LN6589@AddRenderI
$LN6587@AddRenderI:
  02332	1b c0		 sbb	 eax, eax
  02334	83 d8 ff	 sbb	 eax, -1
$LN6589@AddRenderI:
  02337	3b c3		 cmp	 eax, ebx
  02339	75 30		 jne	 SHORT $LN6379@AddRenderI

; 445  : 	{
; 446  : 		SAFEDELETE( m_pCoinNumber );

  0233b	39 9f 34 02 00
	00		 cmp	 DWORD PTR [edi+564], ebx
  02341	74 17		 je	 SHORT $LN11@AddRenderI
  02343	8b 8f 34 02 00
	00		 mov	 ecx, DWORD PTR [edi+564]
  02349	3b cb		 cmp	 ecx, ebx
  0234b	74 07		 je	 SHORT $LN270@AddRenderI
  0234d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0234f	6a 01		 push	 1
  02351	ff 50 40	 call	 DWORD PTR [eax+64]
$LN270@AddRenderI:
  02354	89 9f 34 02 00
	00		 mov	 DWORD PTR [edi+564], ebx
$LN11@AddRenderI:

; 447  : 		m_pCoinNumber = pImage;

  0235a	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  02360	89 87 34 02 00
	00		 mov	 DWORD PTR [edi+564], eax
  02366	e9 f6 01 00 00	 jmp	 $LN1@AddRenderI
$LN6379@AddRenderI:

; 448  : 	}	
; 449  : 	else if( szType == "CoinUnlimited" )

  0236b	6a 03		 push	 3
  0236d	c7 85 00 ff ff
	ff ae 83 82 84	 mov	 DWORD PTR __t$565410[ebp], -2071821394 ; 848283aeH
  02377	c7 85 04 ff ff
	ff b8 82 87 83	 mov	 DWORD PTR __t$565410[ebp+4], -2088271176 ; 838782b8H
  02381	c7 85 08 ff ff
	ff 80 85 9f 8f	 mov	 DWORD PTR __t$565410[ebp+8], -1885371008 ; 8f9f8580H
  0238b	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR __t$565410[ebp]
  02391	66 c7 85 0c ff
	ff ff 89 00	 mov	 WORD PTR __t$565410[ebp+12], 137 ; 00000089H
  0239a	59		 pop	 ecx
$LL5893@AddRenderI:
  0239b	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  023a1	83 c0 04	 add	 eax, 4
  023a4	49		 dec	 ecx
  023a5	75 f4		 jne	 SHORT $LL5893@AddRenderI
  023a7	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  023ad	80 b5 0c ff ff
	ff ed		 xor	 BYTE PTR __t$565410[ebp+12], -19 ; ffffffedH
  023b4	8d b5 00 ff ff
	ff		 lea	 esi, DWORD PTR __t$565410[ebp]
  023ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6590@AddRenderI:
  023c0	8a 08		 mov	 cl, BYTE PTR [eax]
  023c2	3a 0e		 cmp	 cl, BYTE PTR [esi]
  023c4	75 1a		 jne	 SHORT $LN6591@AddRenderI
  023c6	3a cb		 cmp	 cl, bl
  023c8	74 12		 je	 SHORT $LN6622@AddRenderI
  023ca	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  023cd	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  023d0	75 0e		 jne	 SHORT $LN6591@AddRenderI
  023d2	83 c0 02	 add	 eax, 2
  023d5	83 c6 02	 add	 esi, 2
  023d8	3a cb		 cmp	 cl, bl
  023da	75 e4		 jne	 SHORT $LL6590@AddRenderI
$LN6622@AddRenderI:
  023dc	33 c0		 xor	 eax, eax
  023de	eb 05		 jmp	 SHORT $LN6593@AddRenderI
$LN6591@AddRenderI:
  023e0	1b c0		 sbb	 eax, eax
  023e2	83 d8 ff	 sbb	 eax, -1
$LN6593@AddRenderI:
  023e5	3b c3		 cmp	 eax, ebx
  023e7	75 30		 jne	 SHORT $LN6380@AddRenderI

; 450  : 	{
; 451  : 		SAFEDELETE( m_pCoinUnlimited );

  023e9	39 9f 38 02 00
	00		 cmp	 DWORD PTR [edi+568], ebx
  023ef	74 17		 je	 SHORT $LN8@AddRenderI
  023f1	8b 8f 38 02 00
	00		 mov	 ecx, DWORD PTR [edi+568]
  023f7	3b cb		 cmp	 ecx, ebx
  023f9	74 07		 je	 SHORT $LN272@AddRenderI
  023fb	8b 01		 mov	 eax, DWORD PTR [ecx]
  023fd	6a 01		 push	 1
  023ff	ff 50 40	 call	 DWORD PTR [eax+64]
$LN272@AddRenderI:
  02402	89 9f 38 02 00
	00		 mov	 DWORD PTR [edi+568], ebx
$LN8@AddRenderI:

; 452  : 		m_pCoinUnlimited = pImage;

  02408	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  0240e	89 87 38 02 00
	00		 mov	 DWORD PTR [edi+568], eax
  02414	e9 48 01 00 00	 jmp	 $LN1@AddRenderI
$LN6380@AddRenderI:

; 453  : 	}
; 454  : 	else if( szType == "BlueTeam" )

  02419	6a 02		 push	 2
  0241b	c7 85 3c fc ff
	ff af 80 9e 8f	 mov	 DWORD PTR __t$565548[ebp], -1885437777 ; 8f9e80afH
  02425	c7 85 40 fc ff
	ff b9 89 8a 87	 mov	 DWORD PTR __t$565548[ebp+4], -2020963911 ; 878a89b9H
  0242f	8d 85 3c fc ff
	ff		 lea	 eax, DWORD PTR __t$565548[ebp]
  02435	88 9d 44 fc ff
	ff		 mov	 BYTE PTR __t$565548[ebp+8], bl
  0243b	59		 pop	 ecx
$LL5999@AddRenderI:
  0243c	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  02442	83 c0 04	 add	 eax, 4
  02445	49		 dec	 ecx
  02446	75 f4		 jne	 SHORT $LL5999@AddRenderI
  02448	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  0244e	8d b5 3c fc ff
	ff		 lea	 esi, DWORD PTR __t$565548[ebp]
  02454	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6594@AddRenderI:
  0245a	8a 08		 mov	 cl, BYTE PTR [eax]
  0245c	3a 0e		 cmp	 cl, BYTE PTR [esi]
  0245e	75 1a		 jne	 SHORT $LN6595@AddRenderI
  02460	3a cb		 cmp	 cl, bl
  02462	74 12		 je	 SHORT $LN6596@AddRenderI
  02464	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  02467	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  0246a	75 0e		 jne	 SHORT $LN6595@AddRenderI
  0246c	83 c0 02	 add	 eax, 2
  0246f	83 c6 02	 add	 esi, 2
  02472	3a cb		 cmp	 cl, bl
  02474	75 e4		 jne	 SHORT $LL6594@AddRenderI
$LN6596@AddRenderI:
  02476	33 c0		 xor	 eax, eax
  02478	eb 05		 jmp	 SHORT $LN6597@AddRenderI
$LN6595@AddRenderI:
  0247a	1b c0		 sbb	 eax, eax
  0247c	83 d8 ff	 sbb	 eax, -1
$LN6597@AddRenderI:
  0247f	3b c3		 cmp	 eax, ebx
  02481	75 30		 jne	 SHORT $LN6381@AddRenderI

; 455  : 	{
; 456  : 		SAFEDELETE( m_pBlueTeam );

  02483	39 9f 50 02 00
	00		 cmp	 DWORD PTR [edi+592], ebx
  02489	74 17		 je	 SHORT $LN5@AddRenderI
  0248b	8b 8f 50 02 00
	00		 mov	 ecx, DWORD PTR [edi+592]
  02491	3b cb		 cmp	 ecx, ebx
  02493	74 07		 je	 SHORT $LN274@AddRenderI
  02495	8b 01		 mov	 eax, DWORD PTR [ecx]
  02497	6a 01		 push	 1
  02499	ff 50 40	 call	 DWORD PTR [eax+64]
$LN274@AddRenderI:
  0249c	89 9f 50 02 00
	00		 mov	 DWORD PTR [edi+592], ebx
$LN5@AddRenderI:

; 457  : 		m_pBlueTeam = pImage;

  024a2	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  024a8	89 87 50 02 00
	00		 mov	 DWORD PTR [edi+592], eax
  024ae	e9 ae 00 00 00	 jmp	 $LN1@AddRenderI
$LN6381@AddRenderI:

; 458  : 	}
; 459  : 	else if( szType == "RedTeam" )

  024b3	6a 04		 push	 4
  024b5	c7 45 c0 bf 89
	8f be		 mov	 DWORD PTR __t$565647[ebp], -1097889345 ; be8f89bfH
  024bc	81 75 c0 ed ec
	eb ea		 xor	 DWORD PTR __t$565647[ebp], -353637139 ; eaebecedH
  024c3	c7 45 c4 88 8d
	86 00		 mov	 DWORD PTR __t$565647[ebp+4], 8818056 ; 00868d88H
  024ca	58		 pop	 eax
$LL6102@AddRenderI:
  024cb	8b c8		 mov	 ecx, eax
  024cd	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  024d3	79 05		 jns	 SHORT $LN6643@AddRenderI
  024d5	49		 dec	 ecx
  024d6	83 c9 fc	 or	 ecx, -4			; fffffffcH
  024d9	41		 inc	 ecx
$LN6643@AddRenderI:
  024da	b2 ed		 mov	 dl, -19			; ffffffedH
  024dc	2a d1		 sub	 dl, cl
  024de	30 54 05 c0	 xor	 BYTE PTR __t$565647[ebp+eax], dl
  024e2	40		 inc	 eax
  024e3	83 f8 07	 cmp	 eax, 7
  024e6	7c e3		 jl	 SHORT $LL6102@AddRenderI
  024e8	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR _szType$GSCopy$[ebp]
  024ee	8d 75 c0	 lea	 esi, DWORD PTR __t$565647[ebp]
  024f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
$LL6598@AddRenderI:
  024f7	8a 08		 mov	 cl, BYTE PTR [eax]
  024f9	3a 0e		 cmp	 cl, BYTE PTR [esi]
  024fb	75 1a		 jne	 SHORT $LN6599@AddRenderI
  024fd	3a cb		 cmp	 cl, bl
  024ff	74 12		 je	 SHORT $LN6600@AddRenderI
  02501	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  02504	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  02507	75 0e		 jne	 SHORT $LN6599@AddRenderI
  02509	83 c0 02	 add	 eax, 2
  0250c	83 c6 02	 add	 esi, 2
  0250f	3a cb		 cmp	 cl, bl
  02511	75 e4		 jne	 SHORT $LL6598@AddRenderI
$LN6600@AddRenderI:
  02513	33 c0		 xor	 eax, eax
  02515	eb 05		 jmp	 SHORT $LN6601@AddRenderI
$LN6599@AddRenderI:
  02517	1b c0		 sbb	 eax, eax
  02519	83 d8 ff	 sbb	 eax, -1
$LN6601@AddRenderI:
  0251c	3b c3		 cmp	 eax, ebx
  0251e	75 2d		 jne	 SHORT $LN3@AddRenderI

; 460  : 	{
; 461  : 		SAFEDELETE( m_pRedTeam );

  02520	39 9f 54 02 00
	00		 cmp	 DWORD PTR [edi+596], ebx
  02526	74 17		 je	 SHORT $LN2@AddRenderI
  02528	8b 8f 54 02 00
	00		 mov	 ecx, DWORD PTR [edi+596]
  0252e	3b cb		 cmp	 ecx, ebx
  02530	74 07		 je	 SHORT $LN276@AddRenderI
  02532	8b 01		 mov	 eax, DWORD PTR [ecx]
  02534	6a 01		 push	 1
  02536	ff 50 40	 call	 DWORD PTR [eax+64]
$LN276@AddRenderI:
  02539	89 9f 54 02 00
	00		 mov	 DWORD PTR [edi+596], ebx
$LN2@AddRenderI:

; 462  : 		m_pRedTeam = pImage;

  0253f	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _pImage$GSCopy$[ebp]
  02545	89 87 54 02 00
	00		 mov	 DWORD PTR [edi+596], eax

; 463  : 	}
; 464  : 	else 

  0254b	eb 14		 jmp	 SHORT $LN1@AddRenderI
$LN3@AddRenderI:

; 465  : 	{
; 466  : 		ioWnd::AddRenderImage( szType, pImage );

  0254d	ff b5 24 fc ff
	ff		 push	 DWORD PTR _pImage$GSCopy$[ebp]
  02553	8b cf		 mov	 ecx, edi
  02555	ff b5 28 fc ff
	ff		 push	 DWORD PTR _szType$GSCopy$[ebp]
  0255b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?AddRenderImage@ioWnd@@UAEXABVioHashString@@PAVioUIRenderImage@@@Z
$LN1@AddRenderI:

; 467  : 	}
; 468  : }

  02561	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02564	5f		 pop	 edi
  02565	5e		 pop	 esi
  02566	33 cd		 xor	 ecx, ebp
  02568	5b		 pop	 ebx
  02569	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0256e	c9		 leave
  0256f	c2 08 00	 ret	 8
?AddRenderImage@RoundStateUserWnd@@MAEXABVioHashString@@PAVioUIRenderImage@@@Z ENDP ; RoundStateUserWnd::AddRenderImage
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?ParseExtraInfo@RoundStateUserWnd@@UAEXAAVioXMLElement@@@Z ; RoundStateUserWnd::ParseExtraInfo
; Function compile flags: /Ogsp
;	COMDAT ?ParseExtraInfo@RoundStateUserWnd@@UAEXAAVioXMLElement@@@Z
_TEXT	SEGMENT
__k$567063 = -24					; size = 11
__k$566826 = -24					; size = 11
__k$566701 = -24					; size = 11
__k$566576 = -24					; size = 14
__k$566451 = -24					; size = 11
__k$567235 = -20					; size = 10
__k$566985 = -20					; size = 10
__k$566326 = -20					; size = 8
__$ArrayPad$ = -4					; size = 4
_xElement$ = 8						; size = 4
?ParseExtraInfo@RoundStateUserWnd@@UAEXAAVioXMLElement@@@Z PROC ; RoundStateUserWnd::ParseExtraInfo, COMDAT
; _this$ = ecx

; 471  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _xElement$[ebp]
  00014	56		 push	 esi
  00015	57		 push	 edi

; 472  : 	m_iMaxLine		= xElement.GetIntAttribute_e( "MaxLine" );

  00016	6a 04		 push	 4
  00018	c7 45 ec a0 8d
	93 a6		 mov	 DWORD PTR __k$566326[ebp], -1500279392 ; a6938da0H
  0001f	81 75 ec ed ec
	eb ea		 xor	 DWORD PTR __k$566326[ebp], -353637139 ; eaebecedH
  00026	8b f9		 mov	 edi, ecx
  00028	c7 45 f0 84 82
	8e 00		 mov	 DWORD PTR __k$566326[ebp+4], 9339524 ; 008e8284H
  0002f	5e		 pop	 esi
$LL103@ParseExtra:
  00030	8b c6		 mov	 eax, esi
  00032	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00037	79 05		 jns	 SHORT $LN883@ParseExtra
  00039	48		 dec	 eax
  0003a	83 c8 fc	 or	 eax, -4			; fffffffcH
  0003d	40		 inc	 eax
$LN883@ParseExtra:
  0003e	b1 ed		 mov	 cl, -19			; ffffffedH
  00040	2a c8		 sub	 cl, al
  00042	30 4c 35 ec	 xor	 BYTE PTR __k$566326[ebp+esi], cl
  00046	46		 inc	 esi
  00047	83 fe 07	 cmp	 esi, 7
  0004a	7c e4		 jl	 SHORT $LL103@ParseExtra
  0004c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?GetIntAttribute@ioXMLElement@@QBEHPBD@Z
  00052	8d 45 ec	 lea	 eax, DWORD PTR __k$566326[ebp]
  00055	50		 push	 eax
  00056	8b cb		 mov	 ecx, ebx
  00058	ff d6		 call	 esi
  0005a	6a 02		 push	 2
  0005c	89 87 74 02 00
	00		 mov	 DWORD PTR [edi+628], eax

; 473  : 	m_iLinePlayer	= xElement.GetIntAttribute_e( "LinePlayer" );

  00062	c7 45 e8 a1 85
	85 8f		 mov	 DWORD PTR __k$566451[ebp], -1887074911 ; 8f8585a1H
  00069	c7 45 ec bd 80
	8a 93		 mov	 DWORD PTR __k$566451[ebp+4], -1819639619 ; 938a80bdH
  00070	66 c7 45 f0 88
	9e		 mov	 WORD PTR __k$566451[ebp+8], 40584 ; 00009e88H
  00076	8d 45 e8	 lea	 eax, DWORD PTR __k$566451[ebp]
  00079	c6 45 f2 00	 mov	 BYTE PTR __k$566451[ebp+10], 0
  0007d	59		 pop	 ecx
$LL212@ParseExtra:
  0007e	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00084	83 c0 04	 add	 eax, 4
  00087	49		 dec	 ecx
  00088	75 f4		 jne	 SHORT $LL212@ParseExtra
  0008a	6a 08		 push	 8
  0008c	58		 pop	 eax
$LL209@ParseExtra:
  0008d	8b c8		 mov	 ecx, eax
  0008f	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00095	79 05		 jns	 SHORT $LN884@ParseExtra
  00097	49		 dec	 ecx
  00098	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0009b	41		 inc	 ecx
$LN884@ParseExtra:
  0009c	b2 ed		 mov	 dl, -19			; ffffffedH
  0009e	2a d1		 sub	 dl, cl
  000a0	30 54 05 e8	 xor	 BYTE PTR __k$566451[ebp+eax], dl
  000a4	40		 inc	 eax
  000a5	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  000a8	7c e3		 jl	 SHORT $LL209@ParseExtra
  000aa	8d 45 e8	 lea	 eax, DWORD PTR __k$566451[ebp]
  000ad	50		 push	 eax
  000ae	8b cb		 mov	 ecx, ebx
  000b0	ff d6		 call	 esi
  000b2	6a 03		 push	 3
  000b4	89 87 78 02 00
	00		 mov	 DWORD PTR [edi+632], eax

; 474  : 	m_iLinePlayerGap= xElement.GetIntAttribute_e( "LinePlayerGap" );

  000ba	c7 45 e8 a1 85
	85 8f		 mov	 DWORD PTR __k$566576[ebp], -1887074911 ; 8f8585a1H
  000c1	c7 45 ec bd 80
	8a 93		 mov	 DWORD PTR __k$566576[ebp+4], -1819639619 ; 938a80bdH
  000c8	c7 45 f0 88 9e
	ac 8b		 mov	 DWORD PTR __k$566576[ebp+8], -1951621496 ; 8bac9e88H
  000cf	8d 45 e8	 lea	 eax, DWORD PTR __k$566576[ebp]
  000d2	66 c7 45 f4 9d
	00		 mov	 WORD PTR __k$566576[ebp+12], 157 ; 0000009dH
  000d8	59		 pop	 ecx
$LL318@ParseExtra:
  000d9	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  000df	83 c0 04	 add	 eax, 4
  000e2	49		 dec	 ecx
  000e3	75 f4		 jne	 SHORT $LL318@ParseExtra
  000e5	80 75 f4 ed	 xor	 BYTE PTR __k$566576[ebp+12], -19 ; ffffffedH
  000e9	8d 45 e8	 lea	 eax, DWORD PTR __k$566576[ebp]
  000ec	50		 push	 eax
  000ed	8b cb		 mov	 ecx, ebx
  000ef	ff d6		 call	 esi
  000f1	6a 02		 push	 2
  000f3	89 87 7c 02 00
	00		 mov	 DWORD PTR [edi+636], eax

; 475  : 	m_iLineStartX	= xElement.GetIntAttribute_e( "LineStartX" );

  000f9	c7 45 e8 a1 85
	85 8f		 mov	 DWORD PTR __k$566701[ebp], -1887074911 ; 8f8585a1H
  00100	c7 45 ec be 98
	8a 98		 mov	 DWORD PTR __k$566701[ebp+4], -1735747394 ; 988a98beH
  00107	66 c7 45 f0 99
	b4		 mov	 WORD PTR __k$566701[ebp+8], 46233 ; 0000b499H
  0010d	8d 45 e8	 lea	 eax, DWORD PTR __k$566701[ebp]
  00110	c6 45 f2 00	 mov	 BYTE PTR __k$566701[ebp+10], 0
  00114	59		 pop	 ecx
$LL424@ParseExtra:
  00115	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0011b	83 c0 04	 add	 eax, 4
  0011e	49		 dec	 ecx
  0011f	75 f4		 jne	 SHORT $LL424@ParseExtra
  00121	6a 08		 push	 8
  00123	58		 pop	 eax
$LL421@ParseExtra:
  00124	8b c8		 mov	 ecx, eax
  00126	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0012c	79 05		 jns	 SHORT $LN885@ParseExtra
  0012e	49		 dec	 ecx
  0012f	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00132	41		 inc	 ecx
$LN885@ParseExtra:
  00133	b2 ed		 mov	 dl, -19			; ffffffedH
  00135	2a d1		 sub	 dl, cl
  00137	30 54 05 e8	 xor	 BYTE PTR __k$566701[ebp+eax], dl
  0013b	40		 inc	 eax
  0013c	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0013f	7c e3		 jl	 SHORT $LL421@ParseExtra
  00141	8d 45 e8	 lea	 eax, DWORD PTR __k$566701[ebp]
  00144	50		 push	 eax
  00145	8b cb		 mov	 ecx, ebx
  00147	ff d6		 call	 esi
  00149	6a 02		 push	 2
  0014b	89 87 80 02 00
	00		 mov	 DWORD PTR [edi+640], eax

; 476  : 	m_iLineStartY	= xElement.GetIntAttribute_e( "LineStartY" );

  00151	c7 45 e8 a1 85
	85 8f		 mov	 DWORD PTR __k$566826[ebp], -1887074911 ; 8f8585a1H
  00158	c7 45 ec be 98
	8a 98		 mov	 DWORD PTR __k$566826[ebp+4], -1735747394 ; 988a98beH
  0015f	66 c7 45 f0 99
	b5		 mov	 WORD PTR __k$566826[ebp+8], 46489 ; 0000b599H
  00165	8d 45 e8	 lea	 eax, DWORD PTR __k$566826[ebp]
  00168	c6 45 f2 00	 mov	 BYTE PTR __k$566826[ebp+10], 0
  0016c	59		 pop	 ecx
$LL530@ParseExtra:
  0016d	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00173	83 c0 04	 add	 eax, 4
  00176	49		 dec	 ecx
  00177	75 f4		 jne	 SHORT $LL530@ParseExtra
  00179	6a 08		 push	 8
  0017b	58		 pop	 eax
$LL527@ParseExtra:
  0017c	8b c8		 mov	 ecx, eax
  0017e	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00184	79 05		 jns	 SHORT $LN886@ParseExtra
  00186	49		 dec	 ecx
  00187	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0018a	41		 inc	 ecx
$LN886@ParseExtra:
  0018b	b2 ed		 mov	 dl, -19			; ffffffedH
  0018d	2a d1		 sub	 dl, cl
  0018f	30 54 05 e8	 xor	 BYTE PTR __k$566826[ebp+eax], dl
  00193	40		 inc	 eax
  00194	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00197	7c e3		 jl	 SHORT $LL527@ParseExtra
  00199	8d 45 e8	 lea	 eax, DWORD PTR __k$566826[ebp]
  0019c	50		 push	 eax
  0019d	8b cb		 mov	 ecx, ebx
  0019f	ff d6		 call	 esi
  001a1	6a 02		 push	 2
  001a3	89 87 84 02 00
	00		 mov	 DWORD PTR [edi+644], eax

; 477  : 	m_iLineWidth	= xElement.GetIntAttribute_e( "LineWidth" );

  001a9	c7 45 ec a1 85
	85 8f		 mov	 DWORD PTR __k$566985[ebp], -1887074911 ; 8f8585a1H
  001b0	c7 45 f0 ba 85
	8f 9e		 mov	 DWORD PTR __k$566985[ebp+4], -1634761286 ; 9e8f85baH
  001b7	8d 45 ec	 lea	 eax, DWORD PTR __k$566985[ebp]
  001ba	66 c7 45 f4 85
	00		 mov	 WORD PTR __k$566985[ebp+8], 133 ; 00000085H
  001c0	59		 pop	 ecx
$LL636@ParseExtra:
  001c1	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  001c7	83 c0 04	 add	 eax, 4
  001ca	49		 dec	 ecx
  001cb	75 f4		 jne	 SHORT $LL636@ParseExtra
  001cd	80 75 f4 ed	 xor	 BYTE PTR __k$566985[ebp+8], -19 ; ffffffedH
  001d1	8d 45 ec	 lea	 eax, DWORD PTR __k$566985[ebp]
  001d4	50		 push	 eax
  001d5	8b cb		 mov	 ecx, ebx
  001d7	ff d6		 call	 esi
  001d9	6a 02		 push	 2
  001db	89 87 88 02 00
	00		 mov	 DWORD PTR [edi+648], eax

; 478  : 	m_iLineHeight	= xElement.GetIntAttribute_e( "LineHeight" );

  001e1	c7 45 e8 a1 85
	85 8f		 mov	 DWORD PTR __k$567063[ebp], -1887074911 ; 8f8585a1H
  001e8	c7 45 ec a5 89
	82 8d		 mov	 DWORD PTR __k$567063[ebp+4], -1920824923 ; 8d8289a5H
  001ef	66 c7 45 f0 85
	98		 mov	 WORD PTR __k$567063[ebp+8], 39045 ; 00009885H
  001f5	8d 45 e8	 lea	 eax, DWORD PTR __k$567063[ebp]
  001f8	c6 45 f2 00	 mov	 BYTE PTR __k$567063[ebp+10], 0
  001fc	59		 pop	 ecx
$LL742@ParseExtra:
  001fd	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00203	83 c0 04	 add	 eax, 4
  00206	49		 dec	 ecx
  00207	75 f4		 jne	 SHORT $LL742@ParseExtra
  00209	6a 08		 push	 8
  0020b	58		 pop	 eax
$LL739@ParseExtra:
  0020c	8b c8		 mov	 ecx, eax
  0020e	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00214	79 05		 jns	 SHORT $LN887@ParseExtra
  00216	49		 dec	 ecx
  00217	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0021a	41		 inc	 ecx
$LN887@ParseExtra:
  0021b	b2 ed		 mov	 dl, -19			; ffffffedH
  0021d	2a d1		 sub	 dl, cl
  0021f	30 54 05 e8	 xor	 BYTE PTR __k$567063[ebp+eax], dl
  00223	40		 inc	 eax
  00224	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00227	7c e3		 jl	 SHORT $LL739@ParseExtra
  00229	8d 45 e8	 lea	 eax, DWORD PTR __k$567063[ebp]
  0022c	50		 push	 eax
  0022d	8b cb		 mov	 ecx, ebx
  0022f	ff d6		 call	 esi
  00231	6a 02		 push	 2
  00233	89 87 8c 02 00
	00		 mov	 DWORD PTR [edi+652], eax

; 479  : 	m_iNameLimit	= xElement.GetIntAttribute_e( "NameLimit" );

  00239	c7 45 ec a3 8d
	86 8f		 mov	 DWORD PTR __k$567235[ebp], -1887007325 ; 8f868da3H
  00240	c7 45 f0 a1 85
	86 83		 mov	 DWORD PTR __k$567235[ebp+4], -2088335967 ; 838685a1H
  00247	8d 45 ec	 lea	 eax, DWORD PTR __k$567235[ebp]
  0024a	66 c7 45 f4 99
	00		 mov	 WORD PTR __k$567235[ebp+8], 153 ; 00000099H
  00250	59		 pop	 ecx
$LL848@ParseExtra:
  00251	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00257	83 c0 04	 add	 eax, 4
  0025a	49		 dec	 ecx
  0025b	75 f4		 jne	 SHORT $LL848@ParseExtra
  0025d	80 75 f4 ed	 xor	 BYTE PTR __k$567235[ebp+8], -19 ; ffffffedH
  00261	8d 45 ec	 lea	 eax, DWORD PTR __k$567235[ebp]
  00264	50		 push	 eax
  00265	8b cb		 mov	 ecx, ebx
  00267	ff d6		 call	 esi

; 480  : }

  00269	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0026c	89 87 90 02 00
	00		 mov	 DWORD PTR [edi+656], eax
  00272	5f		 pop	 edi
  00273	5e		 pop	 esi
  00274	33 cd		 xor	 ecx, ebp
  00276	5b		 pop	 ebx
  00277	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0027c	c9		 leave
  0027d	c2 04 00	 ret	 4
?ParseExtraInfo@RoundStateUserWnd@@UAEXAAVioXMLElement@@@Z ENDP ; RoundStateUserWnd::ParseExtraInfo
_TEXT	ENDS
PUBLIC	?IsDieUser@RoundStateUserWnd@@IAE_NABVioHashString@@@Z ; RoundStateUserWnd::IsDieUser
EXTRN	?GetBaseChar@ioPlayStage@@QAEPAVioBaseChar@@ABVioHashString@@@Z:PROC ; ioPlayStage::GetBaseChar
; Function compile flags: /Ogsp
;	COMDAT ?IsDieUser@RoundStateUserWnd@@IAE_NABVioHashString@@@Z
_TEXT	SEGMENT
_szName$ = 8						; size = 4
_value$567360 = 11					; size = 1
?IsDieUser@RoundStateUserWnd@@IAE_NABVioHashString@@@Z PROC ; RoundStateUserWnd::IsDieUser, COMDAT
; _this$ = ecx

; 494  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 495  : 	if( !m_pPlayStage ) return true;

  00003	8b 89 94 02 00
	00		 mov	 ecx, DWORD PTR [ecx+660]
  00009	85 c9		 test	 ecx, ecx
  0000b	74 3a		 je	 SHORT $LN1@IsDieUser

; 496  : 
; 497  : 	ioBaseChar *pUser = m_pPlayStage->GetBaseChar( szName );

  0000d	ff 75 08	 push	 DWORD PTR _szName$[ebp]
  00010	e8 00 00 00 00	 call	 ?GetBaseChar@ioPlayStage@@QAEPAVioBaseChar@@ABVioHashString@@@Z ; ioPlayStage::GetBaseChar

; 498  : 	if( !pUser ) return true;

  00015	85 c0		 test	 eax, eax
  00017	74 2e		 je	 SHORT $LN1@IsDieUser

; 499  : 
; 500  : 	if( pUser->GetState() == CS_DIE || 
; 501  : 		pUser->GetState() == CS_VIEW || 
; 502  : 		pUser->GetState() == CS_LOADING || 
; 503  : 		pUser->IsPrisonerMode() )

  00019	8a 88 10 03 00
	00		 mov	 cl, BYTE PTR [eax+784]
  0001f	80 f9 0e	 cmp	 cl, 14			; 0000000eH
  00022	74 23		 je	 SHORT $LN1@IsDieUser
  00024	80 f9 1a	 cmp	 cl, 26			; 0000001aH
  00027	74 1e		 je	 SHORT $LN1@IsDieUser
  00029	80 f9 24	 cmp	 cl, 36			; 00000024H
  0002c	74 19		 je	 SHORT $LN1@IsDieUser
  0002e	8d 4d 0b	 lea	 ecx, DWORD PTR _value$567360[ebp]
  00031	51		 push	 ecx
  00032	8d 88 cc 14 00
	00		 lea	 ecx, DWORD PTR [eax+5324]
  00038	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  0003d	80 7d 0b 00	 cmp	 BYTE PTR _value$567360[ebp], 0
  00041	75 04		 jne	 SHORT $LN1@IsDieUser

; 505  : 
; 506  : 	return false;

  00043	32 c0		 xor	 al, al
  00045	eb 02		 jmp	 SHORT $LN5@IsDieUser
$LN1@IsDieUser:

; 504  : 		return true;

  00047	b0 01		 mov	 al, 1
$LN5@IsDieUser:

; 507  : }

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
?IsDieUser@RoundStateUserWnd@@IAE_NABVioHashString@@@Z ENDP ; RoundStateUserWnd::IsDieUser
_TEXT	ENDS
PUBLIC	__real@4032000000000000
PUBLIC	?OnRenderGradeAndNick@RoundStateUserWnd@@IAEHABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderGradeAndNick
EXTRN	__imp_?GetTextWidthCutSize@ioFontManager@@QAEMPBDW4TextStyle@@MM@Z:PROC
EXTRN	__imp_?PrintTextWidthCut@ioFontManager@@QAAXMMMMPBDZZ:PROC
EXTRN	?RenderGrade@ioMyLevelMgr@@QAEXABVioHashString@@HHKW4TeamType@@W4UIRenderType@@K@Z:PROC ; ioMyLevelMgr::RenderGrade
EXTRN	?GetSingleton@ioMyLevelMgr@@SAAAV1@XZ:PROC	; ioMyLevelMgr::GetSingleton
EXTRN	__ftol2_sse:PROC
;	COMDAT __real@4032000000000000
CONST	SEGMENT
__real@4032000000000000 DQ 04032000000000000r	; 18
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?OnRenderGradeAndNick@RoundStateUserWnd@@IAEHABURoundInfo@@HH_N@Z
_TEXT	SEGMENT
_rkInfo$ = 8						; size = 4
_iXPos$ = 12						; size = 4
_iYPos$ = 16						; size = 4
_bOver$ = 20						; size = 1
?OnRenderGradeAndNick@RoundStateUserWnd@@IAEHABURoundInfo@@HH_N@Z PROC ; RoundStateUserWnd::OnRenderGradeAndNick, COMDAT
; _this$ = ecx

; 926  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 927  : 	// 계급
; 928  : 	if( IsDieUser( rkInfo.m_szName ) )    // 죽으면 오버해도 무조건 회색

  00006	8b 7d 08	 mov	 edi, DWORD PTR _rkInfo$[ebp]
  00009	57		 push	 edi
  0000a	8b d9		 mov	 ebx, ecx
  0000c	e8 00 00 00 00	 call	 ?IsDieUser@RoundStateUserWnd@@IAE_NABVioHashString@@@Z ; RoundStateUserWnd::IsDieUser

; 929  : 		g_LevelMgr.RenderGrade( rkInfo.m_szName, iXPos, iYPos, rkInfo.m_iLevel, TEAM_PRIVATE_3 );

  00011	6a ff		 push	 -1
  00013	84 c0		 test	 al, al
  00015	74 06		 je	 SHORT $LN10@OnRenderGr
  00017	6a 00		 push	 0
  00019	6a 05		 push	 5
  0001b	eb 0e		 jmp	 SHORT $LN13@OnRenderGr
$LN10@OnRenderGr:

; 930  : 	else if( bOver )  

  0001d	80 7d 14 00	 cmp	 BYTE PTR _bOver$[ebp], 0
  00021	74 04		 je	 SHORT $LN8@OnRenderGr

; 931  : 		g_LevelMgr.RenderGrade( rkInfo.m_szName, iXPos, iYPos, rkInfo.m_iLevel, TEAM_PRIVATE_1, UI_RENDER_NORMAL_ADD_COLOR, TCT_DEFAULT_WHITE );

  00023	6a 04		 push	 4

; 932  : 	else

  00025	eb 02		 jmp	 SHORT $LN14@OnRenderGr
$LN8@OnRenderGr:

; 933  : 		g_LevelMgr.RenderGrade( rkInfo.m_szName, iXPos, iYPos, rkInfo.m_iLevel, TEAM_PRIVATE_1 );

  00027	6a 00		 push	 0
$LN14@OnRenderGr:
  00029	6a 03		 push	 3
$LN13@OnRenderGr:
  0002b	ff 77 44	 push	 DWORD PTR [edi+68]
  0002e	ff 75 10	 push	 DWORD PTR _iYPos$[ebp]
  00031	ff 75 0c	 push	 DWORD PTR _iXPos$[ebp]
  00034	57		 push	 edi
  00035	e8 00 00 00 00	 call	 ?GetSingleton@ioMyLevelMgr@@SAAAV1@XZ ; ioMyLevelMgr::GetSingleton
  0003a	8b c8		 mov	 ecx, eax
  0003c	e8 00 00 00 00	 call	 ?RenderGrade@ioMyLevelMgr@@QAEXABVioHashString@@HHKW4TeamType@@W4UIRenderType@@K@Z ; ioMyLevelMgr::RenderGrade

; 934  : 
; 935  : 	// 아이디
; 936  : 	g_FontMgr.SetBkColor( 0, 0, 0 );

  00041	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  00047	33 c0		 xor	 eax, eax
  00049	50		 push	 eax
  0004a	50		 push	 eax
  0004b	50		 push	 eax
  0004c	ff d6		 call	 esi
  0004e	8b c8		 mov	 ecx, eax
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetBkColor@ioFontManager@@QAEXHHH@Z

; 937  : 	g_FontMgr.SetAlignType( TAT_LEFT );

  00056	6a 00		 push	 0
  00058	ff d6		 call	 esi
  0005a	8b c8		 mov	 ecx, eax
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 938  : 	g_FontMgr.SetTextStyle( TS_NORMAL );

  00062	6a 00		 push	 0
  00064	ff d6		 call	 esi
  00066	8b c8		 mov	 ecx, eax
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextStyle@ioFontManager@@QAEXW4TextStyle@@@Z

; 939  : 
; 940  : 	if( IsDieUser( rkInfo.m_szName ) )    // 죽으면 오버해도 무조건 회색

  0006e	57		 push	 edi
  0006f	8b cb		 mov	 ecx, ebx
  00071	e8 00 00 00 00	 call	 ?IsDieUser@RoundStateUserWnd@@IAE_NABVioHashString@@@Z ; RoundStateUserWnd::IsDieUser
  00076	84 c0		 test	 al, al
  00078	74 07		 je	 SHORT $LN6@OnRenderGr

; 941  : 		g_FontMgr.SetTextColor( TCT_DEFAULT_LIGHTGRAY );

  0007a	68 a7 a7 a7 ff	 push	 -5789785		; ffa7a7a7H
  0007f	eb 1c		 jmp	 SHORT $LN15@OnRenderGr
$LN6@OnRenderGr:

; 942  : 	else if( bOver )

  00081	80 7d 14 00	 cmp	 BYTE PTR _bOver$[ebp], 0
  00085	74 04		 je	 SHORT $LN4@OnRenderGr

; 943  : 		g_FontMgr.SetTextColor( TCT_DEFAULT_WHITE );

  00087	6a ff		 push	 -1
  00089	eb 12		 jmp	 SHORT $LN15@OnRenderGr
$LN4@OnRenderGr:

; 944  : 	else if( rkInfo.m_Team == TEAM_BLUE )

  0008b	83 7f 10 02	 cmp	 DWORD PTR [edi+16], 2
  0008f	75 07		 jne	 SHORT $LN2@OnRenderGr

; 945  : 		g_FontMgr.SetTextColor( TCT_DEFAULT_BLUE );

  00091	68 b2 46 16 ff	 push	 -15317326		; ff1646b2H

; 946  : 	else

  00096	eb 05		 jmp	 SHORT $LN15@OnRenderGr
$LN2@OnRenderGr:

; 947  : 		g_FontMgr.SetTextColor( TCT_DEFAULT_RED );

  00098	68 00 16 b9 ff	 push	 -4647424		; ffb91600H
$LN15@OnRenderGr:
  0009d	ff d6		 call	 esi
  0009f	8b c8		 mov	 ecx, eax
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextColor@ioFontManager@@QAEXK@Z

; 948  : 	g_FontMgr.PrintTextWidthCut( iXPos + 18, iYPos + 2, FONT_SIZE_12, m_iNameLimit, rkInfo.m_szName.c_str() );

  000a7	8b cf		 mov	 ecx, edi
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  000af	66 0f 6e 83 90
	02 00 00	 movd	 xmm0, DWORD PTR [ebx+656]
  000b7	50		 push	 eax
  000b8	8b 45 10	 mov	 eax, DWORD PTR _iYPos$[ebp]
  000bb	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000be	83 ec 10	 sub	 esp, 16			; 00000010H
  000c1	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  000c7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  000cf	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  000d5	83 c0 02	 add	 eax, 2
  000d8	0f 57 c0	 xorps	 xmm0, xmm0
  000db	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000df	8b 45 0c	 mov	 eax, DWORD PTR _iXPos$[ebp]
  000e2	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000e8	83 c0 12	 add	 eax, 18			; 00000012H
  000eb	0f 57 c0	 xorps	 xmm0, xmm0
  000ee	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000f2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f7	ff d6		 call	 esi
  000f9	50		 push	 eax
  000fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintTextWidthCut@ioFontManager@@QAAXMMMMPBDZZ

; 949  : 	return 18 + g_FontMgr.GetTextWidthCutSize( rkInfo.m_szName.c_str(), TS_NORMAL, FONT_SIZE_12, m_iNameLimit );

  00100	66 0f 6e 83 90
	02 00 00	 movd	 xmm0, DWORD PTR [ebx+656]
  00108	83 c4 10	 add	 esp, 16			; 00000010H
  0010b	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0010e	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00114	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  0011c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00121	6a 00		 push	 0
  00123	8b cf		 mov	 ecx, edi
  00125	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  0012b	50		 push	 eax
  0012c	ff d6		 call	 esi
  0012e	8b c8		 mov	 ecx, eax
  00130	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetTextWidthCutSize@ioFontManager@@QAEMPBDW4TextStyle@@MM@Z
  00136	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@4032000000000000
  0013c	e8 00 00 00 00	 call	 __ftol2_sse
  00141	5f		 pop	 edi
  00142	5e		 pop	 esi
  00143	5b		 pop	 ebx

; 950  : }

  00144	5d		 pop	 ebp
  00145	c2 10 00	 ret	 16			; 00000010H
?OnRenderGradeAndNick@RoundStateUserWnd@@IAEHABURoundInfo@@HH_N@Z ENDP ; RoundStateUserWnd::OnRenderGradeAndNick
_TEXT	ENDS
PUBLIC	??1tagLadderHeroUserInfo@@QAE@XZ		; tagLadderHeroUserInfo::~tagLadderHeroUserInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1tagLadderHeroUserInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1tagLadderHeroUserInfo@@QAE@XZ$0
__ehfuncinfo$??1tagLadderHeroUserInfo@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1tagLadderHeroUserInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??1tagLadderHeroUserInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1tagLadderHeroUserInfo@@QAE@XZ PROC			; tagLadderHeroUserInfo::~tagLadderHeroUserInfo, COMDAT
; _this$ = ecx
  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??1tagLadderHeroUserInfo@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00015	8d 4e 24	 lea	 ecx, DWORD PTR [esi+36]
  00018	e8 00 00 00 00	 call	 ??1CHARACTER@@QAE@XZ
  0001d	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00021	8b ce		 mov	 ecx, esi
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00029	e8 00 00 00 00	 call	 __EH_epilog3
  0002e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1tagLadderHeroUserInfo@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$??1tagLadderHeroUserInfo@@QAE@XZ:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1tagLadderHeroUserInfo@@QAE@XZ
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1tagLadderHeroUserInfo@@QAE@XZ ENDP			; tagLadderHeroUserInfo::~tagLadderHeroUserInfo
PUBLIC	??_C@_0CF@HPPJIDJH@RoundStateUserWnd?3?3OnRenderPlaza@ ; `string'
PUBLIC	?OnRenderPlazaUser@RoundStateUserWnd@@IAEXHH@Z	; RoundStateUserWnd::OnRenderPlazaUser
;	COMDAT ??_C@_0CF@HPPJIDJH@RoundStateUserWnd?3?3OnRenderPlaza@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
CONST	SEGMENT
??_C@_0CF@HPPJIDJH@RoundStateUserWnd?3?3OnRenderPlaza@ DB 'RoundStateUser'
	DB	'Wnd::OnRenderPlazaUser', 00H		; `string'
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
CONST	ENDS
;	COMDAT ?OnRenderPlazaUser@RoundStateUserWnd@@IAEXHH@Z
_TEXT	SEGMENT
_iSize$ = -16						; size = 4
tv520 = -12						; size = 4
tv377 = -12						; size = 4
_rkInfo$550251 = -8					; size = 4
_iMaxUserLineTitle$ = -8				; size = 4
_i$ = -4						; size = 4
_iRealYPos$ = 8						; size = 4
_iXPos$ = 8						; size = 4
_iYPos$ = 12						; size = 4
?OnRenderPlazaUser@RoundStateUserWnd@@IAEXHH@Z PROC	; RoundStateUserWnd::OnRenderPlazaUser, COMDAT
; _this$ = ecx

; 1698 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 1699 : 	if( !m_pCurrentOver || !m_pBlueOver || !m_pRedOver || !m_pRedVert ) return;

  0000a	33 db		 xor	 ebx, ebx
  0000c	39 9e 44 02 00
	00		 cmp	 DWORD PTR [esi+580], ebx
  00012	0f 84 08 03 00
	00		 je	 $LN16@OnRenderPl
  00018	39 9e 70 01 00
	00		 cmp	 DWORD PTR [esi+368], ebx
  0001e	0f 84 fc 02 00
	00		 je	 $LN16@OnRenderPl
  00024	39 9e 7c 01 00
	00		 cmp	 DWORD PTR [esi+380], ebx
  0002a	0f 84 f0 02 00
	00		 je	 $LN16@OnRenderPl
  00030	39 9e c0 01 00
	00		 cmp	 DWORD PTR [esi+448], ebx
  00036	0f 84 e4 02 00
	00		 je	 $LN16@OnRenderPl

; 1700 : 	
; 1701 : 	int i = 0;
; 1702 : 	// 
; 1703 : 	int iMaxUserLineTitle = m_iMaxLine / m_iLinePlayer;

  0003c	8b 86 74 02 00
	00		 mov	 eax, DWORD PTR [esi+628]
  00042	99		 cdq
  00043	f7 be 78 02 00
	00		 idiv	 DWORD PTR [esi+632]
  00049	57		 push	 edi

; 1704 : 	for(i = 0;i < iMaxUserLineTitle;i++)

  0004a	89 5d fc	 mov	 DWORD PTR _i$[ebp], ebx
  0004d	89 45 f8	 mov	 DWORD PTR _iMaxUserLineTitle$[ebp], eax
  00050	3b c3		 cmp	 eax, ebx
  00052	0f 8e 79 01 00
	00		 jle	 $LN13@OnRenderPl
  00058	8b 45 0c	 mov	 eax, DWORD PTR _iYPos$[ebp]
  0005b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  00061	83 c0 0b	 add	 eax, 11			; 0000000bH
  00064	0f 57 c0	 xorps	 xmm0, xmm0
  00067	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0006b	f3 0f 11 45 f4	 movss	 DWORD PTR tv377[ebp], xmm0
$LL15@OnRenderPl:

; 1705 : 	{
; 1706 : 		g_FontMgr.SetBkColor( 0, 0, 0 );

  00070	53		 push	 ebx
  00071	53		 push	 ebx
  00072	53		 push	 ebx
  00073	ff d7		 call	 edi
  00075	8b c8		 mov	 ecx, eax
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetBkColor@ioFontManager@@QAEXHHH@Z

; 1707 : 		g_FontMgr.SetTextStyle( TS_NORMAL );

  0007d	53		 push	 ebx
  0007e	ff d7		 call	 edi
  00080	8b c8		 mov	 ecx, eax
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextStyle@ioFontManager@@QAEXW4TextStyle@@@Z

; 1708 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_RED );

  00088	68 00 16 b9 ff	 push	 -4647424		; ffb91600H
  0008d	ff d7		 call	 edi
  0008f	8b c8		 mov	 ecx, eax
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextColor@ioFontManager@@QAEXK@Z

; 1709 : 
; 1710 : 		g_FontMgr.SetAlignType( TAT_LEFT );

  00097	53		 push	 ebx
  00098	ff d7		 call	 edi
  0009a	8b c8		 mov	 ecx, eax
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 1711 : 		g_FontMgr.PrintText( iXPos + 12 + i * m_iLinePlayerGap, iYPos + 11, FONT_SIZE_12, STR(1) );

  000a2	53		 push	 ebx
  000a3	6a 01		 push	 1
  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  000aa	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@HPPJIDJH@RoundStateUserWnd?3?3OnRenderPlaza@
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  000b5	8b c8		 mov	 ecx, eax
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  000bd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  000c5	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  000c8	50		 push	 eax
  000c9	8b 86 7c 02 00
	00		 mov	 eax, DWORD PTR [esi+636]
  000cf	0f af 45 fc	 imul	 eax, DWORD PTR _i$[ebp]
  000d3	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000d6	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  000dc	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR tv377[ebp]
  000e1	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000e7	8d 44 08 0c	 lea	 eax, DWORD PTR [eax+ecx+12]
  000eb	0f 57 c0	 xorps	 xmm0, xmm0
  000ee	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000f2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f7	ff d7		 call	 edi
  000f9	50		 push	 eax
  000fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAAXMMMPBDZZ
  00100	83 c4 14	 add	 esp, 20			; 00000014H

; 1712 : 
; 1713 : 		g_FontMgr.SetAlignType( TAT_CENTER );

  00103	6a 01		 push	 1
  00105	ff d7		 call	 edi
  00107	8b c8		 mov	 ecx, eax
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 1714 : 		g_FontMgr.PrintText( iXPos + 135 + i * m_iLinePlayerGap, iYPos + 11, FONT_SIZE_12, STR(2) );

  0010f	53		 push	 ebx
  00110	6a 02		 push	 2
  00112	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00117	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@HPPJIDJH@RoundStateUserWnd?3?3OnRenderPlaza@
  0011c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00122	8b c8		 mov	 ecx, eax
  00124	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0012a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00132	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  00135	50		 push	 eax
  00136	8b 86 7c 02 00
	00		 mov	 eax, DWORD PTR [esi+636]
  0013c	0f af 45 fc	 imul	 eax, DWORD PTR _i$[ebp]
  00140	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00143	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00149	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR tv377[ebp]
  0014e	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00154	8d 84 08 87 00
	00 00		 lea	 eax, DWORD PTR [eax+ecx+135]
  0015b	0f 57 c0	 xorps	 xmm0, xmm0
  0015e	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00162	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00167	ff d7		 call	 edi
  00169	50		 push	 eax
  0016a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAAXMMMPBDZZ
  00170	83 c4 14	 add	 esp, 20			; 00000014H

; 1715 : 
; 1716 : 		if( m_pRedVert && i < iMaxUserLineTitle - 1 )

  00173	39 9e c0 01 00
	00		 cmp	 DWORD PTR [esi+448], ebx
  00179	74 47		 je	 SHORT $LN14@OnRenderPl
  0017b	8b 45 f8	 mov	 eax, DWORD PTR _iMaxUserLineTitle$[ebp]
  0017e	48		 dec	 eax
  0017f	39 45 fc	 cmp	 DWORD PTR _i$[ebp], eax
  00182	7d 3e		 jge	 SHORT $LN14@OnRenderPl

; 1717 : 			m_pRedVert->Render( iXPos + i * m_iLinePlayerGap, iYPos, UI_RENDER_MULTIPLY );

  00184	66 0f 6e 45 0c	 movd	 xmm0, DWORD PTR _iYPos$[ebp]
  00189	8b 86 c0 01 00
	00		 mov	 eax, DWORD PTR [esi+448]
  0018f	53		 push	 ebx
  00190	8b 00		 mov	 eax, DWORD PTR [eax]
  00192	53		 push	 ebx
  00193	53		 push	 ebx
  00194	6a 08		 push	 8
  00196	51		 push	 ecx
  00197	51		 push	 ecx
  00198	8b 8e 7c 02 00
	00		 mov	 ecx, DWORD PTR [esi+636]
  0019e	0f af 4d fc	 imul	 ecx, DWORD PTR _i$[ebp]
  001a2	03 4d 08	 add	 ecx, DWORD PTR _iXPos$[ebp]
  001a5	0f 5b c0	 cvtdq2ps xmm0, xmm0
  001a8	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  001ae	0f 57 c0	 xorps	 xmm0, xmm0
  001b1	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  001b5	8b 8e c0 01 00
	00		 mov	 ecx, DWORD PTR [esi+448]
  001bb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001c0	ff 10		 call	 DWORD PTR [eax]
$LN14@OnRenderPl:

; 1704 : 	for(i = 0;i < iMaxUserLineTitle;i++)

  001c2	ff 45 fc	 inc	 DWORD PTR _i$[ebp]
  001c5	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  001c8	3b 45 f8	 cmp	 eax, DWORD PTR _iMaxUserLineTitle$[ebp]
  001cb	0f 8c 9f fe ff
	ff		 jl	 $LL15@OnRenderPl
$LN13@OnRenderPl:

; 1721 : 	int iRealYPos = iYPos + m_iLineStartY;
; 1722 : 	int iSize = m_RoundInfoList.size();

  001d1	8b 86 9c 02 00
	00		 mov	 eax, DWORD PTR [esi+668]
  001d7	2b 86 98 02 00
	00		 sub	 eax, DWORD PTR [esi+664]
  001dd	8b 96 84 02 00
	00		 mov	 edx, DWORD PTR [esi+644]
  001e3	8b be 80 02 00
	00		 mov	 edi, DWORD PTR [esi+640]
  001e9	03 55 0c	 add	 edx, DWORD PTR _iYPos$[ebp]
  001ec	03 7d 08	 add	 edi, DWORD PTR _iXPos$[ebp]
  001ef	c1 f8 07	 sar	 eax, 7
  001f2	89 55 08	 mov	 DWORD PTR _iRealYPos$[ebp], edx
  001f5	89 45 f0	 mov	 DWORD PTR _iSize$[ebp], eax

; 1723 : 	for(i = 0;i < iSize;i++)

  001f8	89 5d fc	 mov	 DWORD PTR _i$[ebp], ebx
  001fb	3b c3		 cmp	 eax, ebx
  001fd	0f 8e 1c 01 00
	00		 jle	 $LN36@OnRenderPl

; 1718 : 	}
; 1719 : 
; 1720 : 	int iRealXPos = iXPos + m_iLineStartX;

  00203	89 5d f4	 mov	 DWORD PTR tv520[ebp], ebx
  00206	eb 03		 jmp	 SHORT $LN11@OnRenderPl
$LL34@OnRenderPl:
  00208	8b 55 08	 mov	 edx, DWORD PTR _iRealYPos$[ebp]
$LN11@OnRenderPl:

; 1723 : 	for(i = 0;i < iSize;i++)

  0020b	8b 86 98 02 00
	00		 mov	 eax, DWORD PTR [esi+664]
  00211	03 45 f4	 add	 eax, DWORD PTR tv520[ebp]
  00214	89 45 f8	 mov	 DWORD PTR _rkInfo$550251[ebp], eax

; 1724 : 	{
; 1725 : 		RoundInfo &rkInfo = m_RoundInfoList[i];
; 1726 : 
; 1727 : 		if( rkInfo.m_bOwner )

  00217	38 58 54	 cmp	 BYTE PTR [eax+84], bl
  0021a	74 1d		 je	 SHORT $LN8@OnRenderPl

; 1728 : 		{
; 1729 : 			if( rkInfo.m_Team == TEAM_BLUE )

  0021c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0021f	83 f9 02	 cmp	 ecx, 2
  00222	75 08		 jne	 SHORT $LN7@OnRenderPl

; 1730 : 				m_pBlueOver->Render( iRealXPos, iRealYPos );

  00224	8b 8e 70 01 00
	00		 mov	 ecx, DWORD PTR [esi+368]
  0022a	eb 1e		 jmp	 SHORT $LN37@OnRenderPl
$LN7@OnRenderPl:

; 1731 : 			else if( rkInfo.m_Team == TEAM_RED )

  0022c	83 f9 01	 cmp	 ecx, 1
  0022f	75 3f		 jne	 SHORT $LN3@OnRenderPl

; 1732 : 				m_pRedOver->Render( iRealXPos, iRealYPos );

  00231	8b 8e 7c 01 00
	00		 mov	 ecx, DWORD PTR [esi+380]

; 1733 : 		}

  00237	eb 11		 jmp	 SHORT $LN37@OnRenderPl
$LN8@OnRenderPl:

; 1734 : 		else if( m_MouseOverIndex == i )

  00239	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0023c	39 8e 5c 02 00
	00		 cmp	 DWORD PTR [esi+604], ecx
  00242	75 37		 jne	 SHORT $LN32@OnRenderPl

; 1735 : 			m_pCurrentOver->Render( iRealXPos, iRealYPos );

  00244	8b 8e 44 02 00
	00		 mov	 ecx, DWORD PTR [esi+580]
$LN37@OnRenderPl:
  0024a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0024c	53		 push	 ebx
  0024d	53		 push	 ebx
  0024e	53		 push	 ebx
  0024f	53		 push	 ebx
  00250	51		 push	 ecx
  00251	0f 57 c0	 xorps	 xmm0, xmm0
  00254	51		 push	 ecx
  00255	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  00259	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0025f	0f 57 c0	 xorps	 xmm0, xmm0
  00262	f3 0f 2a c7	 cvtsi2ss xmm0, edi
  00266	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0026b	ff 10		 call	 DWORD PTR [eax]
  0026d	8b 45 f8	 mov	 eax, DWORD PTR _rkInfo$550251[ebp]
$LN3@OnRenderPl:

; 1736 : 
; 1737 : 		// 계급 & 아이디
; 1738 : 		int iWidth = OnRenderGradeAndNick( rkInfo, iRealXPos + 4, iRealYPos + 2, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  00270	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00273	39 8e 5c 02 00
	00		 cmp	 DWORD PTR [esi+604], ecx
  00279	74 09		 je	 SHORT $LN20@OnRenderPl
$LN32@OnRenderPl:
  0027b	38 58 54	 cmp	 BYTE PTR [eax+84], bl
  0027e	75 04		 jne	 SHORT $LN20@OnRenderPl
  00280	32 d2		 xor	 dl, dl
  00282	eb 03		 jmp	 SHORT $LN21@OnRenderPl
$LN20@OnRenderPl:
  00284	33 d2		 xor	 edx, edx
  00286	42		 inc	 edx
$LN21@OnRenderPl:
  00287	8b 4d 08	 mov	 ecx, DWORD PTR _iRealYPos$[ebp]
  0028a	83 c1 02	 add	 ecx, 2
  0028d	52		 push	 edx
  0028e	51		 push	 ecx
  0028f	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00292	51		 push	 ecx
  00293	50		 push	 eax
  00294	8b ce		 mov	 ecx, esi
  00296	e8 00 00 00 00	 call	 ?OnRenderGradeAndNick@RoundStateUserWnd@@IAEHABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderGradeAndNick

; 1739 : 
; 1740 : 		// 길드 마크
; 1741 : 		OnRenderGuildMark( rkInfo, iRealXPos + 4 + iWidth, iRealYPos + 4 );

  0029b	8b 4d 08	 mov	 ecx, DWORD PTR _iRealYPos$[ebp]
  0029e	83 c1 04	 add	 ecx, 4
  002a1	51		 push	 ecx
  002a2	8d 44 38 04	 lea	 eax, DWORD PTR [eax+edi+4]
  002a6	50		 push	 eax
  002a7	ff 75 f8	 push	 DWORD PTR _rkInfo$550251[ebp]
  002aa	8b ce		 mov	 ecx, esi
  002ac	e8 00 00 00 00	 call	 ?OnRenderGuildMark@RoundStateUserWnd@@IAEHABURoundInfo@@HH@Z ; RoundStateUserWnd::OnRenderGuildMark

; 1742 : 
; 1743 : 		// 핑
; 1744 : 		OnRenderPing( rkInfo, iRealXPos + 116, iRealYPos + 2, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  002b1	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  002b4	39 86 5c 02 00
	00		 cmp	 DWORD PTR [esi+604], eax
  002ba	74 0c		 je	 SHORT $LN35@OnRenderPl
  002bc	8b 45 f8	 mov	 eax, DWORD PTR _rkInfo$550251[ebp]
  002bf	38 58 54	 cmp	 BYTE PTR [eax+84], bl
  002c2	75 04		 jne	 SHORT $LN35@OnRenderPl
  002c4	32 c0		 xor	 al, al
  002c6	eb 03		 jmp	 SHORT $LN23@OnRenderPl
$LN35@OnRenderPl:
  002c8	33 c0		 xor	 eax, eax
  002ca	40		 inc	 eax
$LN23@OnRenderPl:
  002cb	50		 push	 eax
  002cc	8b 45 08	 mov	 eax, DWORD PTR _iRealYPos$[ebp]
  002cf	83 c0 02	 add	 eax, 2
  002d2	50		 push	 eax
  002d3	8d 47 74	 lea	 eax, DWORD PTR [edi+116]
  002d6	50		 push	 eax
  002d7	ff 75 f8	 push	 DWORD PTR _rkInfo$550251[ebp]
  002da	8b ce		 mov	 ecx, esi
  002dc	e8 00 00 00 00	 call	 ?OnRenderPing@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderPing

; 1745 : 
; 1746 : 		//
; 1747 : 		if( 0 == ( i + 1 ) % m_iLinePlayer )

  002e1	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  002e4	41		 inc	 ecx
  002e5	8b c1		 mov	 eax, ecx
  002e7	99		 cdq
  002e8	f7 be 78 02 00
	00		 idiv	 DWORD PTR [esi+632]
  002ee	85 d2		 test	 edx, edx
  002f0	75 14		 jne	 SHORT $LN2@OnRenderPl

; 1748 : 		{
; 1749 : 			iRealXPos += m_iLinePlayerGap;
; 1750 : 			iRealYPos = iYPos + m_iLineStartY;

  002f2	8b 86 84 02 00
	00		 mov	 eax, DWORD PTR [esi+644]
  002f8	03 be 7c 02 00
	00		 add	 edi, DWORD PTR [esi+636]
  002fe	03 45 0c	 add	 eax, DWORD PTR _iYPos$[ebp]
  00301	89 45 08	 mov	 DWORD PTR _iRealYPos$[ebp], eax

; 1751 : 		}
; 1752 : 		else

  00304	eb 09		 jmp	 SHORT $LN10@OnRenderPl
$LN2@OnRenderPl:

; 1753 : 		{
; 1754 : 			iRealYPos += m_iLineHeight;

  00306	8b 86 8c 02 00
	00		 mov	 eax, DWORD PTR [esi+652]
  0030c	01 45 08	 add	 DWORD PTR _iRealYPos$[ebp], eax
$LN10@OnRenderPl:

; 1723 : 	for(i = 0;i < iSize;i++)

  0030f	83 6d f4 80	 sub	 DWORD PTR tv520[ebp], -128 ; ffffff80H
  00313	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  00316	3b 4d f0	 cmp	 ecx, DWORD PTR _iSize$[ebp]
  00319	0f 8c e9 fe ff
	ff		 jl	 $LL34@OnRenderPl
$LN36@OnRenderPl:
  0031f	5f		 pop	 edi
$LN16@OnRenderPl:
  00320	5e		 pop	 esi
  00321	5b		 pop	 ebx

; 1755 : 		}
; 1756 : 	}
; 1757 : }

  00322	c9		 leave
  00323	c2 08 00	 ret	 8
?OnRenderPlazaUser@RoundStateUserWnd@@IAEXHH@Z ENDP	; RoundStateUserWnd::OnRenderPlazaUser
_TEXT	ENDS
PUBLIC	??_C@_0CE@LNCFPBKI@RoundStateUserWnd?3?3OnRenderTeamU@ ; `string'
PUBLIC	?OnRenderTeamUser@RoundStateUserWnd@@IAEXHH@Z	; RoundStateUserWnd::OnRenderTeamUser
;	COMDAT ??_C@_0CE@LNCFPBKI@RoundStateUserWnd?3?3OnRenderTeamU@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
CONST	SEGMENT
??_C@_0CE@LNCFPBKI@RoundStateUserWnd?3?3OnRenderTeamU@ DB 'RoundStateUser'
	DB	'Wnd::OnRenderTeamUser', 00H			; `string'
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
CONST	ENDS
;	COMDAT ?OnRenderTeamUser@RoundStateUserWnd@@IAEXHH@Z
_TEXT	SEGMENT
_iSize$ = -16						; size = 4
_iWidth$550287 = -12					; size = 4
_iMaxUserLineTitle$ = -12				; size = 4
tv526 = -8						; size = 4
tv401 = -8						; size = 4
_i$ = -4						; size = 4
_rkInfo$550284 = 8					; size = 4
_iXPos$ = 8						; size = 4
_iYPos$ = 12						; size = 4
?OnRenderTeamUser@RoundStateUserWnd@@IAEXHH@Z PROC	; RoundStateUserWnd::OnRenderTeamUser, COMDAT
; _this$ = ecx

; 1760 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 1761 : 	if( !m_pCurrentOver ) return;

  00009	33 c9		 xor	 ecx, ecx
  0000b	39 8e 44 02 00
	00		 cmp	 DWORD PTR [esi+580], ecx
  00011	0f 84 d2 03 00
	00		 je	 $LN5@OnRenderTe

; 1762 : 
; 1763 : 	// 
; 1764 : 	int i = 0;
; 1765 : 	int iMaxUserLineTitle = m_iMaxLine / m_iLinePlayer;

  00017	8b 86 74 02 00
	00		 mov	 eax, DWORD PTR [esi+628]
  0001d	99		 cdq
  0001e	f7 be 78 02 00
	00		 idiv	 DWORD PTR [esi+632]
  00024	53		 push	 ebx
  00025	57		 push	 edi

; 1766 : 	for(i = 0;i < iMaxUserLineTitle;i++)

  00026	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  00029	89 45 f4	 mov	 DWORD PTR _iMaxUserLineTitle$[ebp], eax
  0002c	3b c1		 cmp	 eax, ecx
  0002e	0f 8e 10 02 00
	00		 jle	 $LN11@OnRenderTe
  00034	8b 45 0c	 mov	 eax, DWORD PTR _iYPos$[ebp]
  00037	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  0003d	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?PrintText@ioFontManager@@QAAXMMMPBDZZ
  00043	83 c0 3e	 add	 eax, 62			; 0000003eH
  00046	0f 57 c0	 xorps	 xmm0, xmm0
  00049	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0004d	f3 0f 11 45 f8	 movss	 DWORD PTR tv401[ebp], xmm0
$LL13@OnRenderTe:

; 1767 : 	{
; 1768 : 		g_FontMgr.SetBkColor( 0, 0, 0 );

  00052	51		 push	 ecx
  00053	51		 push	 ecx
  00054	51		 push	 ecx
  00055	ff d7		 call	 edi
  00057	8b c8		 mov	 ecx, eax
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetBkColor@ioFontManager@@QAEXHHH@Z

; 1769 : 		g_FontMgr.SetTextStyle( TS_NORMAL );

  0005f	6a 00		 push	 0
  00061	ff d7		 call	 edi
  00063	8b c8		 mov	 ecx, eax
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextStyle@ioFontManager@@QAEXW4TextStyle@@@Z

; 1770 : 
; 1771 : 		if( m_eWindowTeam == TEAM_BLUE )

  0006b	83 be 58 02 00
	00 02		 cmp	 DWORD PTR [esi+600], 2
  00072	75 07		 jne	 SHORT $LN10@OnRenderTe

; 1772 : 			g_FontMgr.SetTextColor( TCT_DEFAULT_BLUE );

  00074	68 b2 46 16 ff	 push	 -15317326		; ff1646b2H

; 1773 : 		else

  00079	eb 05		 jmp	 SHORT $LN40@OnRenderTe
$LN10@OnRenderTe:

; 1774 : 			g_FontMgr.SetTextColor( TCT_DEFAULT_RED );

  0007b	68 00 16 b9 ff	 push	 -4647424		; ffb91600H
$LN40@OnRenderTe:
  00080	ff d7		 call	 edi
  00082	8b c8		 mov	 ecx, eax
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextColor@ioFontManager@@QAEXK@Z

; 1775 : 
; 1776 : 		g_FontMgr.SetAlignType( TAT_LEFT );

  0008a	6a 00		 push	 0
  0008c	ff d7		 call	 edi
  0008e	8b c8		 mov	 ecx, eax
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 1777 : 		g_FontMgr.PrintText( iXPos + 12 + i * m_iLinePlayerGap, iYPos + 62, FONT_SIZE_12, STR(1) );

  00096	6a 00		 push	 0
  00098	6a 01		 push	 1
  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@LNCFPBKI@RoundStateUserWnd?3?3OnRenderTeamU@
  000a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  000aa	8b c8		 mov	 ecx, eax
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  000b2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  000ba	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  000bd	50		 push	 eax
  000be	8b 86 7c 02 00
	00		 mov	 eax, DWORD PTR [esi+636]
  000c4	0f af 45 fc	 imul	 eax, DWORD PTR _i$[ebp]
  000c8	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000cb	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  000d1	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv401[ebp]
  000d6	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000dc	8d 44 08 0c	 lea	 eax, DWORD PTR [eax+ecx+12]
  000e0	0f 57 c0	 xorps	 xmm0, xmm0
  000e3	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000e7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ec	ff d7		 call	 edi
  000ee	50		 push	 eax
  000ef	ff d3		 call	 ebx
  000f1	83 c4 14	 add	 esp, 20			; 00000014H

; 1778 : 
; 1779 : 		g_FontMgr.SetAlignType( TAT_CENTER );

  000f4	6a 01		 push	 1
  000f6	ff d7		 call	 edi
  000f8	8b c8		 mov	 ecx, eax
  000fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 1780 : 		if( !g_BattleRoomMgr.IsTournamentModeType() )

  00100	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  00105	8b c8		 mov	 ecx, eax
  00107	e8 00 00 00 00	 call	 ?IsTournamentModeType@ioBattleRoomMgr@@QAE_NXZ ; ioBattleRoomMgr::IsTournamentModeType
  0010c	84 c0		 test	 al, al
  0010e	75 61		 jne	 SHORT $LN8@OnRenderTe

; 1781 : 		{
; 1782 : 			g_FontMgr.PrintText( iXPos + 219 + i * m_iLinePlayerGap, iYPos + 62, FONT_SIZE_12, STR(2) );

  00110	6a 00		 push	 0
  00112	6a 02		 push	 2
  00114	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00119	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@LNCFPBKI@RoundStateUserWnd?3?3OnRenderTeamU@
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00124	8b c8		 mov	 ecx, eax
  00126	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0012c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00134	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  00137	50		 push	 eax
  00138	8b 86 7c 02 00
	00		 mov	 eax, DWORD PTR [esi+636]
  0013e	0f af 45 fc	 imul	 eax, DWORD PTR _i$[ebp]
  00142	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00145	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  0014b	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv401[ebp]
  00150	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00156	8d 84 08 db 00
	00 00		 lea	 eax, DWORD PTR [eax+ecx+219]
  0015d	0f 57 c0	 xorps	 xmm0, xmm0
  00160	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00164	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00169	ff d7		 call	 edi
  0016b	50		 push	 eax
  0016c	ff d3		 call	 ebx
  0016e	83 c4 14	 add	 esp, 20			; 00000014H
$LN8@OnRenderTe:

; 1783 : 		}
; 1784 : 		g_FontMgr.PrintText( iXPos + 261 + i * m_iLinePlayerGap, iYPos + 62, FONT_SIZE_12, STR(3) );

  00171	6a 00		 push	 0
  00173	6a 03		 push	 3
  00175	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0017a	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@LNCFPBKI@RoundStateUserWnd?3?3OnRenderTeamU@
  0017f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00185	8b c8		 mov	 ecx, eax
  00187	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0018d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00195	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  00198	50		 push	 eax
  00199	8b 86 7c 02 00
	00		 mov	 eax, DWORD PTR [esi+636]
  0019f	0f af 45 fc	 imul	 eax, DWORD PTR _i$[ebp]
  001a3	83 ec 0c	 sub	 esp, 12			; 0000000cH
  001a6	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  001ac	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv401[ebp]
  001b1	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  001b7	8d 84 08 05 01
	00 00		 lea	 eax, DWORD PTR [eax+ecx+261]
  001be	0f 57 c0	 xorps	 xmm0, xmm0
  001c1	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001c5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ca	ff d7		 call	 edi
  001cc	50		 push	 eax
  001cd	ff d3		 call	 ebx
  001cf	83 c4 14	 add	 esp, 20			; 00000014H

; 1785 : 		g_FontMgr.PrintText( iXPos + 294 + i * m_iLinePlayerGap, iYPos + 62, FONT_SIZE_12, STR(4) );

  001d2	6a 00		 push	 0
  001d4	6a 04		 push	 4
  001d6	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  001db	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@LNCFPBKI@RoundStateUserWnd?3?3OnRenderTeamU@
  001e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  001e6	8b c8		 mov	 ecx, eax
  001e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  001ee	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  001f6	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  001f9	50		 push	 eax
  001fa	8b 86 7c 02 00
	00		 mov	 eax, DWORD PTR [esi+636]
  00200	0f af 45 fc	 imul	 eax, DWORD PTR _i$[ebp]
  00204	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00207	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  0020d	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv401[ebp]
  00212	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00218	8d 84 08 26 01
	00 00		 lea	 eax, DWORD PTR [eax+ecx+294]
  0021f	0f 57 c0	 xorps	 xmm0, xmm0
  00222	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00226	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0022b	ff d7		 call	 edi
  0022d	50		 push	 eax
  0022e	ff d3		 call	 ebx
  00230	83 c4 14	 add	 esp, 20			; 00000014H
  00233	ff 45 fc	 inc	 DWORD PTR _i$[ebp]
  00236	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00239	33 c9		 xor	 ecx, ecx
  0023b	3b 45 f4	 cmp	 eax, DWORD PTR _iMaxUserLineTitle$[ebp]
  0023e	0f 8c 0e fe ff
	ff		 jl	 $LL13@OnRenderTe
$LN11@OnRenderTe:

; 1789 : 	int iRealYPos = iYPos + m_iLineStartY;
; 1790 : 	int iSize = m_RoundInfoList.size();

  00244	8b 86 9c 02 00
	00		 mov	 eax, DWORD PTR [esi+668]
  0024a	2b 86 98 02 00
	00		 sub	 eax, DWORD PTR [esi+664]
  00250	8b be 80 02 00
	00		 mov	 edi, DWORD PTR [esi+640]
  00256	8b 9e 84 02 00
	00		 mov	 ebx, DWORD PTR [esi+644]
  0025c	03 7d 08	 add	 edi, DWORD PTR _iXPos$[ebp]
  0025f	03 5d 0c	 add	 ebx, DWORD PTR _iYPos$[ebp]
  00262	c1 f8 07	 sar	 eax, 7
  00265	89 45 f0	 mov	 DWORD PTR _iSize$[ebp], eax

; 1791 : 	for(i = 0;i < iSize;i++)

  00268	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  0026b	3b c1		 cmp	 eax, ecx
  0026d	0f 8e 74 01 00
	00		 jle	 $LN38@OnRenderTe

; 1786 : 	}
; 1787 : 
; 1788 : 	int iRealXPos = iXPos + m_iLineStartX;

  00273	89 4d f8	 mov	 DWORD PTR tv526[ebp], ecx
  00276	eb 02		 jmp	 SHORT $LN7@OnRenderTe
$LL34@OnRenderTe:
  00278	33 c9		 xor	 ecx, ecx
$LN7@OnRenderTe:

; 1791 : 	for(i = 0;i < iSize;i++)

  0027a	8b 86 98 02 00
	00		 mov	 eax, DWORD PTR [esi+664]
  00280	03 45 f8	 add	 eax, DWORD PTR tv526[ebp]

; 1792 : 	{
; 1793 : 		RoundInfo &rkInfo = m_RoundInfoList[i];
; 1794 : 
; 1795 : 		if( m_MouseOverIndex == i || rkInfo.m_bOwner )

  00283	8b 96 5c 02 00
	00		 mov	 edx, DWORD PTR [esi+604]
  00289	89 45 08	 mov	 DWORD PTR _rkInfo$550284[ebp], eax
  0028c	3b 55 fc	 cmp	 edx, DWORD PTR _i$[ebp]
  0028f	74 06		 je	 SHORT $LN3@OnRenderTe
  00291	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  00295	74 2e		 je	 SHORT $LN4@OnRenderTe
$LN3@OnRenderTe:

; 1796 : 			m_pCurrentOver->Render( iRealXPos, iRealYPos );

  00297	8b 86 44 02 00
	00		 mov	 eax, DWORD PTR [esi+580]
  0029d	8b 10		 mov	 edx, DWORD PTR [eax]
  0029f	51		 push	 ecx
  002a0	51		 push	 ecx
  002a1	51		 push	 ecx
  002a2	51		 push	 ecx
  002a3	51		 push	 ecx
  002a4	0f 57 c0	 xorps	 xmm0, xmm0
  002a7	51		 push	 ecx
  002a8	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  002ac	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  002b2	0f 57 c0	 xorps	 xmm0, xmm0
  002b5	f3 0f 2a c7	 cvtsi2ss xmm0, edi
  002b9	8b c8		 mov	 ecx, eax
  002bb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002c0	ff 12		 call	 DWORD PTR [edx]
  002c2	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550284[ebp]
$LN4@OnRenderTe:

; 1797 : 
; 1798 : 		// 계급 & 아이디
; 1799 : 		int iWidth = OnRenderGradeAndNick( rkInfo, iRealXPos + 4, iRealYPos + 2, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  002c5	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  002c8	39 8e 5c 02 00
	00		 cmp	 DWORD PTR [esi+604], ecx
  002ce	74 0a		 je	 SHORT $LN17@OnRenderTe
  002d0	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  002d4	75 04		 jne	 SHORT $LN17@OnRenderTe
  002d6	32 d2		 xor	 dl, dl
  002d8	eb 03		 jmp	 SHORT $LN18@OnRenderTe
$LN17@OnRenderTe:
  002da	33 d2		 xor	 edx, edx
  002dc	42		 inc	 edx
$LN18@OnRenderTe:
  002dd	52		 push	 edx
  002de	8d 4b 02	 lea	 ecx, DWORD PTR [ebx+2]
  002e1	51		 push	 ecx
  002e2	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  002e5	51		 push	 ecx
  002e6	50		 push	 eax
  002e7	8b ce		 mov	 ecx, esi
  002e9	e8 00 00 00 00	 call	 ?OnRenderGradeAndNick@RoundStateUserWnd@@IAEHABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderGradeAndNick

; 1800 : 
; 1801 : 		// 길드 마크
; 1802 : 		iWidth += OnRenderGuildMark( rkInfo, iRealXPos + 4 + iWidth, iRealYPos + 4 );

  002ee	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  002f1	51		 push	 ecx
  002f2	89 45 f4	 mov	 DWORD PTR _iWidth$550287[ebp], eax
  002f5	8d 44 38 04	 lea	 eax, DWORD PTR [eax+edi+4]
  002f9	50		 push	 eax
  002fa	ff 75 08	 push	 DWORD PTR _rkInfo$550284[ebp]
  002fd	8b ce		 mov	 ecx, esi
  002ff	e8 00 00 00 00	 call	 ?OnRenderGuildMark@RoundStateUserWnd@@IAEHABURoundInfo@@HH@Z ; RoundStateUserWnd::OnRenderGuildMark
  00304	8b 4d f4	 mov	 ecx, DWORD PTR _iWidth$550287[ebp]
  00307	03 c8		 add	 ecx, eax

; 1803 : 
; 1804 : 		// 보너스
; 1805 : 		OnRenderBonus( rkInfo, iRealXPos + iWidth + 7, iRealYPos + 3 );

  00309	8d 43 03	 lea	 eax, DWORD PTR [ebx+3]
  0030c	50		 push	 eax
  0030d	8d 44 39 07	 lea	 eax, DWORD PTR [ecx+edi+7]
  00311	50		 push	 eax
  00312	ff 75 08	 push	 DWORD PTR _rkInfo$550284[ebp]
  00315	8b ce		 mov	 ecx, esi
  00317	e8 00 00 00 00	 call	 ?OnRenderBonus@RoundStateUserWnd@@IAEXABURoundInfo@@HH@Z ; RoundStateUserWnd::OnRenderBonus

; 1806 : 
; 1807 : 		// 기여도
; 1808 : 		OnRenderContribute( rkInfo, iRealXPos + 212, iRealYPos + 3, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  0031c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0031f	39 86 5c 02 00
	00		 cmp	 DWORD PTR [esi+604], eax
  00325	74 0d		 je	 SHORT $LN35@OnRenderTe
  00327	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550284[ebp]
  0032a	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  0032e	75 04		 jne	 SHORT $LN35@OnRenderTe
  00330	32 c0		 xor	 al, al
  00332	eb 03		 jmp	 SHORT $LN20@OnRenderTe
$LN35@OnRenderTe:
  00334	33 c0		 xor	 eax, eax
  00336	40		 inc	 eax
$LN20@OnRenderTe:
  00337	50		 push	 eax
  00338	8d 43 03	 lea	 eax, DWORD PTR [ebx+3]
  0033b	50		 push	 eax
  0033c	8d 87 d4 00 00
	00		 lea	 eax, DWORD PTR [edi+212]
  00342	50		 push	 eax
  00343	ff 75 08	 push	 DWORD PTR _rkInfo$550284[ebp]
  00346	8b ce		 mov	 ecx, esi
  00348	e8 00 00 00 00	 call	 ?OnRenderContribute@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderContribute

; 1809 : 
; 1810 : 		// KO & Death
; 1811 : 		OnRenderKillDeath( rkInfo, iRealXPos + 254, iRealYPos + 3, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  0034d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00350	39 86 5c 02 00
	00		 cmp	 DWORD PTR [esi+604], eax
  00356	74 0d		 je	 SHORT $LN36@OnRenderTe
  00358	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550284[ebp]
  0035b	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  0035f	75 04		 jne	 SHORT $LN36@OnRenderTe
  00361	32 c0		 xor	 al, al
  00363	eb 03		 jmp	 SHORT $LN22@OnRenderTe
$LN36@OnRenderTe:
  00365	33 c0		 xor	 eax, eax
  00367	40		 inc	 eax
$LN22@OnRenderTe:
  00368	50		 push	 eax
  00369	8d 43 03	 lea	 eax, DWORD PTR [ebx+3]
  0036c	50		 push	 eax
  0036d	8d 87 fe 00 00
	00		 lea	 eax, DWORD PTR [edi+254]
  00373	50		 push	 eax
  00374	ff 75 08	 push	 DWORD PTR _rkInfo$550284[ebp]
  00377	8b ce		 mov	 ecx, esi
  00379	e8 00 00 00 00	 call	 ?OnRenderKillDeath@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderKillDeath

; 1812 : 
; 1813 : 		// 핑
; 1814 : 		OnRenderPing( rkInfo, iRealXPos + 275, iRealYPos + 2, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  0037e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00381	39 86 5c 02 00
	00		 cmp	 DWORD PTR [esi+604], eax
  00387	74 0d		 je	 SHORT $LN37@OnRenderTe
  00389	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550284[ebp]
  0038c	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  00390	75 04		 jne	 SHORT $LN37@OnRenderTe
  00392	32 c0		 xor	 al, al
  00394	eb 03		 jmp	 SHORT $LN24@OnRenderTe
$LN37@OnRenderTe:
  00396	33 c0		 xor	 eax, eax
  00398	40		 inc	 eax
$LN24@OnRenderTe:
  00399	50		 push	 eax
  0039a	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
  0039d	50		 push	 eax
  0039e	8d 87 13 01 00
	00		 lea	 eax, DWORD PTR [edi+275]
  003a4	50		 push	 eax
  003a5	ff 75 08	 push	 DWORD PTR _rkInfo$550284[ebp]
  003a8	8b ce		 mov	 ecx, esi
  003aa	e8 00 00 00 00	 call	 ?OnRenderPing@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderPing

; 1815 : 
; 1816 : 		//
; 1817 : 		if( 0 == ( i + 1 ) % m_iLinePlayer )

  003af	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  003b2	41		 inc	 ecx
  003b3	8b c1		 mov	 eax, ecx
  003b5	99		 cdq
  003b6	f7 be 78 02 00
	00		 idiv	 DWORD PTR [esi+632]
  003bc	85 d2		 test	 edx, edx
  003be	75 11		 jne	 SHORT $LN2@OnRenderTe

; 1818 : 		{
; 1819 : 			iRealXPos += m_iLinePlayerGap;
; 1820 : 			iRealYPos = iYPos + m_iLineStartY;

  003c0	8b 9e 84 02 00
	00		 mov	 ebx, DWORD PTR [esi+644]
  003c6	03 be 7c 02 00
	00		 add	 edi, DWORD PTR [esi+636]
  003cc	03 5d 0c	 add	 ebx, DWORD PTR _iYPos$[ebp]

; 1821 : 		}
; 1822 : 		else

  003cf	eb 06		 jmp	 SHORT $LN6@OnRenderTe
$LN2@OnRenderTe:

; 1823 : 		{
; 1824 : 			iRealYPos += m_iLineHeight;

  003d1	03 9e 8c 02 00
	00		 add	 ebx, DWORD PTR [esi+652]
$LN6@OnRenderTe:

; 1791 : 	for(i = 0;i < iSize;i++)

  003d7	83 6d f8 80	 sub	 DWORD PTR tv526[ebp], -128 ; ffffff80H
  003db	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  003de	3b 4d f0	 cmp	 ecx, DWORD PTR _iSize$[ebp]
  003e1	0f 8c 91 fe ff
	ff		 jl	 $LL34@OnRenderTe
$LN38@OnRenderTe:
  003e7	5f		 pop	 edi
  003e8	5b		 pop	 ebx
$LN5@OnRenderTe:
  003e9	5e		 pop	 esi

; 1825 : 		}
; 1826 : 	}
; 1827 : }

  003ea	c9		 leave
  003eb	c2 08 00	 ret	 8
?OnRenderTeamUser@RoundStateUserWnd@@IAEXHH@Z ENDP	; RoundStateUserWnd::OnRenderTeamUser
_TEXT	ENDS
PUBLIC	??_C@_0CG@HDOGKDAB@RoundStateUserWnd?3?3OnRenderSingl@ ; `string'
PUBLIC	?OnRenderSingleUser@RoundStateUserWnd@@IAEXHH@Z	; RoundStateUserWnd::OnRenderSingleUser
;	COMDAT ??_C@_0CG@HDOGKDAB@RoundStateUserWnd?3?3OnRenderSingl@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
CONST	SEGMENT
??_C@_0CG@HDOGKDAB@RoundStateUserWnd?3?3OnRenderSingl@ DB 'RoundStateUser'
	DB	'Wnd::OnRenderSingleUser', 00H		; `string'
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
CONST	ENDS
;	COMDAT ?OnRenderSingleUser@RoundStateUserWnd@@IAEXHH@Z
_TEXT	SEGMENT
_iSize$ = -16						; size = 4
_iWidth$550317 = -12					; size = 4
_iMaxUserLineTitle$ = -12				; size = 4
tv627 = -8						; size = 4
tv481 = -8						; size = 4
_i$ = -4						; size = 4
_rkInfo$550310 = 8					; size = 4
_iXPos$ = 8						; size = 4
_iYPos$ = 12						; size = 4
?OnRenderSingleUser@RoundStateUserWnd@@IAEXHH@Z PROC	; RoundStateUserWnd::OnRenderSingleUser, COMDAT
; _this$ = ecx

; 1830 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx

; 1831 : 	if( !m_pCurrentOver || !m_pBlueOver || !m_pRedOver || !m_pRedVert ) return;

  0000a	33 f6		 xor	 esi, esi
  0000c	39 b7 44 02 00
	00		 cmp	 DWORD PTR [edi+580], esi
  00012	0f 84 1b 04 00
	00		 je	 $LN15@OnRenderSi
  00018	39 b7 70 01 00
	00		 cmp	 DWORD PTR [edi+368], esi
  0001e	0f 84 0f 04 00
	00		 je	 $LN15@OnRenderSi
  00024	39 b7 7c 01 00
	00		 cmp	 DWORD PTR [edi+380], esi
  0002a	0f 84 03 04 00
	00		 je	 $LN15@OnRenderSi
  00030	39 b7 c0 01 00
	00		 cmp	 DWORD PTR [edi+448], esi
  00036	0f 84 f7 03 00
	00		 je	 $LN15@OnRenderSi

; 1832 : 
; 1833 : 	m_pRedVert->Render( iXPos, iYPos );//중앙선

  0003c	8b 8f c0 01 00
	00		 mov	 ecx, DWORD PTR [edi+448]
  00042	8b 01		 mov	 eax, DWORD PTR [ecx]
  00044	53		 push	 ebx
  00045	8b 5d 0c	 mov	 ebx, DWORD PTR _iYPos$[ebp]
  00048	56		 push	 esi
  00049	56		 push	 esi
  0004a	56		 push	 esi
  0004b	56		 push	 esi
  0004c	0f 57 c0	 xorps	 xmm0, xmm0
  0004f	51		 push	 ecx
  00050	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  00054	51		 push	 ecx
  00055	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0005b	66 0f 6e 45 08	 movd	 xmm0, DWORD PTR _iXPos$[ebp]
  00060	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00063	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00068	ff 10		 call	 DWORD PTR [eax]

; 1834 : 
; 1835 : 	// 
; 1836 : 	int i = 0;
; 1837 : 	int iMaxUserLineTitle = m_iMaxLine / m_iLinePlayer;

  0006a	8b 87 74 02 00
	00		 mov	 eax, DWORD PTR [edi+628]
  00070	99		 cdq
  00071	f7 bf 78 02 00
	00		 idiv	 DWORD PTR [edi+632]

; 1838 : 	for(i = 0;i < iMaxUserLineTitle;i++)

  00077	89 75 fc	 mov	 DWORD PTR _i$[ebp], esi
  0007a	89 45 f4	 mov	 DWORD PTR _iMaxUserLineTitle$[ebp], eax
  0007d	3b c6		 cmp	 eax, esi
  0007f	0f 8e ed 01 00
	00		 jle	 $LN12@OnRenderSi
  00085	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  0008b	83 c3 3e	 add	 ebx, 62			; 0000003eH
  0008e	0f 57 c0	 xorps	 xmm0, xmm0
  00091	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  00095	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?PrintText@ioFontManager@@QAAXMMMPBDZZ
  0009b	f3 0f 11 45 f8	 movss	 DWORD PTR tv481[ebp], xmm0
$LL14@OnRenderSi:

; 1839 : 	{
; 1840 : 		g_FontMgr.SetBkColor( 0, 0, 0 );

  000a0	33 c0		 xor	 eax, eax
  000a2	50		 push	 eax
  000a3	50		 push	 eax
  000a4	50		 push	 eax
  000a5	ff d6		 call	 esi
  000a7	8b c8		 mov	 ecx, eax
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetBkColor@ioFontManager@@QAEXHHH@Z

; 1841 : 		g_FontMgr.SetTextStyle( TS_NORMAL );

  000af	6a 00		 push	 0
  000b1	ff d6		 call	 esi
  000b3	8b c8		 mov	 ecx, eax
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextStyle@ioFontManager@@QAEXW4TextStyle@@@Z

; 1842 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_RED );

  000bb	68 00 16 b9 ff	 push	 -4647424		; ffb91600H
  000c0	ff d6		 call	 esi
  000c2	8b c8		 mov	 ecx, eax
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextColor@ioFontManager@@QAEXK@Z

; 1843 : 
; 1844 : 		g_FontMgr.SetAlignType( TAT_LEFT );

  000ca	6a 00		 push	 0
  000cc	ff d6		 call	 esi
  000ce	8b c8		 mov	 ecx, eax
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 1845 : 		g_FontMgr.PrintText( iXPos + 12 + i * m_iLinePlayerGap, iYPos + 62, FONT_SIZE_12, STR(1) );

  000d6	6a 00		 push	 0
  000d8	6a 01		 push	 1
  000da	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  000df	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@HDOGKDAB@RoundStateUserWnd?3?3OnRenderSingl@
  000e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  000ea	8b c8		 mov	 ecx, eax
  000ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  000f2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  000fd	50		 push	 eax
  000fe	8b 87 7c 02 00
	00		 mov	 eax, DWORD PTR [edi+636]
  00104	0f af 45 fc	 imul	 eax, DWORD PTR _i$[ebp]
  00108	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0010b	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00111	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv481[ebp]
  00116	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0011c	8d 44 08 0c	 lea	 eax, DWORD PTR [eax+ecx+12]
  00120	0f 57 c0	 xorps	 xmm0, xmm0
  00123	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00127	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0012c	ff d6		 call	 esi
  0012e	50		 push	 eax
  0012f	ff d3		 call	 ebx
  00131	83 c4 14	 add	 esp, 20			; 00000014H

; 1846 : 
; 1847 : 		g_FontMgr.SetAlignType( TAT_CENTER );

  00134	6a 01		 push	 1
  00136	ff d6		 call	 esi
  00138	8b c8		 mov	 ecx, eax
  0013a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 1848 : 		g_FontMgr.PrintText( iXPos + 219 + i * m_iLinePlayerGap, iYPos + 62, FONT_SIZE_12, STR(2) );

  00140	6a 00		 push	 0
  00142	6a 02		 push	 2
  00144	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00149	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@HDOGKDAB@RoundStateUserWnd?3?3OnRenderSingl@
  0014e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00154	8b c8		 mov	 ecx, eax
  00156	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0015c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00164	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  00167	50		 push	 eax
  00168	8b 87 7c 02 00
	00		 mov	 eax, DWORD PTR [edi+636]
  0016e	0f af 45 fc	 imul	 eax, DWORD PTR _i$[ebp]
  00172	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00175	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  0017b	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv481[ebp]
  00180	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00186	8d 84 08 db 00
	00 00		 lea	 eax, DWORD PTR [eax+ecx+219]
  0018d	0f 57 c0	 xorps	 xmm0, xmm0
  00190	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00194	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00199	ff d6		 call	 esi
  0019b	50		 push	 eax
  0019c	ff d3		 call	 ebx
  0019e	83 c4 14	 add	 esp, 20			; 00000014H

; 1849 : 		g_FontMgr.PrintText( iXPos + 261 + i * m_iLinePlayerGap, iYPos + 62, FONT_SIZE_12, STR(3) );

  001a1	6a 00		 push	 0
  001a3	6a 03		 push	 3
  001a5	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  001aa	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@HDOGKDAB@RoundStateUserWnd?3?3OnRenderSingl@
  001af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  001b5	8b c8		 mov	 ecx, eax
  001b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  001bd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  001c5	50		 push	 eax
  001c6	83 ec 0c	 sub	 esp, 12			; 0000000cH
  001c9	8b 87 7c 02 00
	00		 mov	 eax, DWORD PTR [edi+636]
  001cf	0f af 45 fc	 imul	 eax, DWORD PTR _i$[ebp]
  001d3	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  001d6	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  001dc	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv481[ebp]
  001e1	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  001e7	8d 84 08 05 01
	00 00		 lea	 eax, DWORD PTR [eax+ecx+261]
  001ee	0f 57 c0	 xorps	 xmm0, xmm0
  001f1	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001f5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001fa	ff d6		 call	 esi
  001fc	50		 push	 eax
  001fd	ff d3		 call	 ebx
  001ff	83 c4 14	 add	 esp, 20			; 00000014H

; 1850 : 		g_FontMgr.PrintText( iXPos + 294 + i * m_iLinePlayerGap, iYPos + 62, FONT_SIZE_12, STR(4) );

  00202	6a 00		 push	 0
  00204	6a 04		 push	 4
  00206	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0020b	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@HDOGKDAB@RoundStateUserWnd?3?3OnRenderSingl@
  00210	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00216	8b c8		 mov	 ecx, eax
  00218	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0021e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00226	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  00229	50		 push	 eax
  0022a	8b 87 7c 02 00
	00		 mov	 eax, DWORD PTR [edi+636]
  00230	0f af 45 fc	 imul	 eax, DWORD PTR _i$[ebp]
  00234	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00237	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  0023d	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv481[ebp]
  00242	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00248	8d 84 08 26 01
	00 00		 lea	 eax, DWORD PTR [eax+ecx+294]
  0024f	0f 57 c0	 xorps	 xmm0, xmm0
  00252	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00256	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0025b	ff d6		 call	 esi
  0025d	50		 push	 eax
  0025e	ff d3		 call	 ebx
  00260	83 c4 14	 add	 esp, 20			; 00000014H
  00263	ff 45 fc	 inc	 DWORD PTR _i$[ebp]
  00266	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00269	3b 45 f4	 cmp	 eax, DWORD PTR _iMaxUserLineTitle$[ebp]
  0026c	0f 8c 2e fe ff
	ff		 jl	 $LL14@OnRenderSi
$LN12@OnRenderSi:

; 1854 : 	int iRealYPos = iYPos + m_iLineStartY;
; 1855 : 	int iSize = m_RoundInfoList.size();

  00272	8b 87 9c 02 00
	00		 mov	 eax, DWORD PTR [edi+668]
  00278	2b 87 98 02 00
	00		 sub	 eax, DWORD PTR [edi+664]
  0027e	8b b7 80 02 00
	00		 mov	 esi, DWORD PTR [edi+640]
  00284	8b 9f 84 02 00
	00		 mov	 ebx, DWORD PTR [edi+644]
  0028a	03 75 08	 add	 esi, DWORD PTR _iXPos$[ebp]
  0028d	03 5d 0c	 add	 ebx, DWORD PTR _iYPos$[ebp]
  00290	c1 f8 07	 sar	 eax, 7

; 1856 : 	for(i = 0;i < iSize;i++)

  00293	33 d2		 xor	 edx, edx
  00295	89 45 f0	 mov	 DWORD PTR _iSize$[ebp], eax
  00298	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
  0029b	3b c2		 cmp	 eax, edx
  0029d	0f 8e 8f 01 00
	00		 jle	 $LN41@OnRenderSi

; 1851 : 	}
; 1852 : 
; 1853 : 	int iRealXPos = iXPos + m_iLineStartX;

  002a3	89 55 f8	 mov	 DWORD PTR tv627[ebp], edx
  002a6	eb 02		 jmp	 SHORT $LN11@OnRenderSi
$LL36@OnRenderSi:
  002a8	33 d2		 xor	 edx, edx
$LN11@OnRenderSi:

; 1856 : 	for(i = 0;i < iSize;i++)

  002aa	8b 87 98 02 00
	00		 mov	 eax, DWORD PTR [edi+664]
  002b0	03 45 f8	 add	 eax, DWORD PTR tv627[ebp]

; 1857 : 	{
; 1858 : 		RoundInfo &rkInfo = m_RoundInfoList[i];
; 1859 : 
; 1860 : 		if( rkInfo.m_bOwner )

  002b3	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  002b7	89 45 08	 mov	 DWORD PTR _rkInfo$550310[ebp], eax
  002ba	74 1d		 je	 SHORT $LN8@OnRenderSi

; 1861 : 		{
; 1862 : 			if( rkInfo.m_Team == TEAM_BLUE )

  002bc	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  002bf	83 f9 02	 cmp	 ecx, 2
  002c2	75 08		 jne	 SHORT $LN7@OnRenderSi

; 1863 : 				m_pBlueOver->Render( iRealXPos, iRealYPos );

  002c4	8b 8f 70 01 00
	00		 mov	 ecx, DWORD PTR [edi+368]
  002ca	eb 1e		 jmp	 SHORT $LN42@OnRenderSi
$LN7@OnRenderSi:

; 1864 : 			else if( rkInfo.m_Team == TEAM_RED )

  002cc	83 f9 01	 cmp	 ecx, 1
  002cf	75 3f		 jne	 SHORT $LN40@OnRenderSi

; 1865 : 				m_pRedOver->Render( iRealXPos, iRealYPos );

  002d1	8b 8f 7c 01 00
	00		 mov	 ecx, DWORD PTR [edi+380]

; 1866 : 		}

  002d7	eb 11		 jmp	 SHORT $LN42@OnRenderSi
$LN8@OnRenderSi:

; 1867 : 		else if( m_MouseOverIndex == i )

  002d9	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  002dc	39 8f 5c 02 00
	00		 cmp	 DWORD PTR [edi+604], ecx
  002e2	75 37		 jne	 SHORT $LN35@OnRenderSi

; 1868 : 			m_pCurrentOver->Render( iRealXPos, iRealYPos );

  002e4	8b 8f 44 02 00
	00		 mov	 ecx, DWORD PTR [edi+580]
$LN42@OnRenderSi:
  002ea	8b 01		 mov	 eax, DWORD PTR [ecx]
  002ec	52		 push	 edx
  002ed	52		 push	 edx
  002ee	52		 push	 edx
  002ef	52		 push	 edx
  002f0	51		 push	 ecx
  002f1	0f 57 c0	 xorps	 xmm0, xmm0
  002f4	51		 push	 ecx
  002f5	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  002f9	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  002ff	0f 57 c0	 xorps	 xmm0, xmm0
  00302	f3 0f 2a c6	 cvtsi2ss xmm0, esi
  00306	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0030b	ff 10		 call	 DWORD PTR [eax]
  0030d	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550310[ebp]
$LN40@OnRenderSi:

; 1869 : 
; 1870 : 		// 계급 & 아이디
; 1871 : 		int iWidth = OnRenderGradeAndNick( rkInfo, iRealXPos + 4, iRealYPos + 2, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  00310	8b 8f 5c 02 00
	00		 mov	 ecx, DWORD PTR [edi+604]
  00316	3b 4d fc	 cmp	 ecx, DWORD PTR _i$[ebp]
  00319	74 0a		 je	 SHORT $LN19@OnRenderSi
$LN35@OnRenderSi:
  0031b	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  0031f	75 04		 jne	 SHORT $LN19@OnRenderSi
  00321	32 d2		 xor	 dl, dl
  00323	eb 03		 jmp	 SHORT $LN20@OnRenderSi
$LN19@OnRenderSi:
  00325	33 d2		 xor	 edx, edx
  00327	42		 inc	 edx
$LN20@OnRenderSi:
  00328	52		 push	 edx
  00329	8d 4b 02	 lea	 ecx, DWORD PTR [ebx+2]
  0032c	51		 push	 ecx
  0032d	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00330	51		 push	 ecx
  00331	50		 push	 eax
  00332	8b cf		 mov	 ecx, edi
  00334	e8 00 00 00 00	 call	 ?OnRenderGradeAndNick@RoundStateUserWnd@@IAEHABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderGradeAndNick

; 1872 : 
; 1873 : 		// 길드 마크
; 1874 : 		iWidth += OnRenderGuildMark( rkInfo, iRealXPos + 4 + iWidth, iRealYPos + 4 );

  00339	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  0033c	51		 push	 ecx
  0033d	89 45 f4	 mov	 DWORD PTR _iWidth$550317[ebp], eax
  00340	8d 44 30 04	 lea	 eax, DWORD PTR [eax+esi+4]
  00344	50		 push	 eax
  00345	ff 75 08	 push	 DWORD PTR _rkInfo$550310[ebp]
  00348	8b cf		 mov	 ecx, edi
  0034a	e8 00 00 00 00	 call	 ?OnRenderGuildMark@RoundStateUserWnd@@IAEHABURoundInfo@@HH@Z ; RoundStateUserWnd::OnRenderGuildMark
  0034f	8b 4d f4	 mov	 ecx, DWORD PTR _iWidth$550317[ebp]
  00352	03 c8		 add	 ecx, eax

; 1875 : 
; 1876 : 		// 보너스
; 1877 : 		OnRenderBonus( rkInfo, iRealXPos + iWidth + 7, iRealYPos + 3 );

  00354	8d 43 03	 lea	 eax, DWORD PTR [ebx+3]
  00357	50		 push	 eax
  00358	8d 44 31 07	 lea	 eax, DWORD PTR [ecx+esi+7]
  0035c	50		 push	 eax
  0035d	ff 75 08	 push	 DWORD PTR _rkInfo$550310[ebp]
  00360	8b cf		 mov	 ecx, edi
  00362	e8 00 00 00 00	 call	 ?OnRenderBonus@RoundStateUserWnd@@IAEXABURoundInfo@@HH@Z ; RoundStateUserWnd::OnRenderBonus

; 1878 : 
; 1879 : 		// 기여도
; 1880 : 		OnRenderContribute( rkInfo, iRealXPos + 212, iRealYPos + 3, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  00367	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0036a	39 87 5c 02 00
	00		 cmp	 DWORD PTR [edi+604], eax
  00370	74 0d		 je	 SHORT $LN37@OnRenderSi
  00372	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550310[ebp]
  00375	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  00379	75 04		 jne	 SHORT $LN37@OnRenderSi
  0037b	32 c0		 xor	 al, al
  0037d	eb 03		 jmp	 SHORT $LN22@OnRenderSi
$LN37@OnRenderSi:
  0037f	33 c0		 xor	 eax, eax
  00381	40		 inc	 eax
$LN22@OnRenderSi:
  00382	50		 push	 eax
  00383	8d 43 03	 lea	 eax, DWORD PTR [ebx+3]
  00386	50		 push	 eax
  00387	8d 86 d4 00 00
	00		 lea	 eax, DWORD PTR [esi+212]
  0038d	50		 push	 eax
  0038e	ff 75 08	 push	 DWORD PTR _rkInfo$550310[ebp]
  00391	8b cf		 mov	 ecx, edi
  00393	e8 00 00 00 00	 call	 ?OnRenderContribute@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderContribute

; 1881 : 
; 1882 : 		// KO & Death
; 1883 : 		OnRenderKillDeath( rkInfo, iRealXPos + 254, iRealYPos + 3, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  00398	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0039b	39 87 5c 02 00
	00		 cmp	 DWORD PTR [edi+604], eax
  003a1	74 0d		 je	 SHORT $LN38@OnRenderSi
  003a3	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550310[ebp]
  003a6	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  003aa	75 04		 jne	 SHORT $LN38@OnRenderSi
  003ac	32 c0		 xor	 al, al
  003ae	eb 03		 jmp	 SHORT $LN24@OnRenderSi
$LN38@OnRenderSi:
  003b0	33 c0		 xor	 eax, eax
  003b2	40		 inc	 eax
$LN24@OnRenderSi:
  003b3	50		 push	 eax
  003b4	8d 43 03	 lea	 eax, DWORD PTR [ebx+3]
  003b7	50		 push	 eax
  003b8	8d 86 fe 00 00
	00		 lea	 eax, DWORD PTR [esi+254]
  003be	50		 push	 eax
  003bf	ff 75 08	 push	 DWORD PTR _rkInfo$550310[ebp]
  003c2	8b cf		 mov	 ecx, edi
  003c4	e8 00 00 00 00	 call	 ?OnRenderKillDeath@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderKillDeath

; 1884 : 
; 1885 : 		// 핑
; 1886 : 		OnRenderPing( rkInfo, iRealXPos + 275, iRealYPos + 2, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  003c9	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  003cc	39 87 5c 02 00
	00		 cmp	 DWORD PTR [edi+604], eax
  003d2	74 0d		 je	 SHORT $LN39@OnRenderSi
  003d4	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550310[ebp]
  003d7	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  003db	75 04		 jne	 SHORT $LN39@OnRenderSi
  003dd	32 c0		 xor	 al, al
  003df	eb 03		 jmp	 SHORT $LN26@OnRenderSi
$LN39@OnRenderSi:
  003e1	33 c0		 xor	 eax, eax
  003e3	40		 inc	 eax
$LN26@OnRenderSi:
  003e4	50		 push	 eax
  003e5	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
  003e8	50		 push	 eax
  003e9	8d 86 13 01 00
	00		 lea	 eax, DWORD PTR [esi+275]
  003ef	50		 push	 eax
  003f0	ff 75 08	 push	 DWORD PTR _rkInfo$550310[ebp]
  003f3	8b cf		 mov	 ecx, edi
  003f5	e8 00 00 00 00	 call	 ?OnRenderPing@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderPing

; 1887 : 
; 1888 : 		//
; 1889 : 		if( 0 == ( i + 1 ) % m_iLinePlayer )

  003fa	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  003fd	41		 inc	 ecx
  003fe	8b c1		 mov	 eax, ecx
  00400	99		 cdq
  00401	f7 bf 78 02 00
	00		 idiv	 DWORD PTR [edi+632]
  00407	85 d2		 test	 edx, edx
  00409	75 11		 jne	 SHORT $LN2@OnRenderSi

; 1890 : 		{
; 1891 : 			iRealXPos += m_iLinePlayerGap;
; 1892 : 			iRealYPos = iYPos + m_iLineStartY;

  0040b	8b 9f 84 02 00
	00		 mov	 ebx, DWORD PTR [edi+644]
  00411	03 b7 7c 02 00
	00		 add	 esi, DWORD PTR [edi+636]
  00417	03 5d 0c	 add	 ebx, DWORD PTR _iYPos$[ebp]

; 1893 : 		}
; 1894 : 		else

  0041a	eb 06		 jmp	 SHORT $LN10@OnRenderSi
$LN2@OnRenderSi:

; 1895 : 		{
; 1896 : 			iRealYPos += m_iLineHeight;

  0041c	03 9f 8c 02 00
	00		 add	 ebx, DWORD PTR [edi+652]
$LN10@OnRenderSi:

; 1856 : 	for(i = 0;i < iSize;i++)

  00422	83 6d f8 80	 sub	 DWORD PTR tv627[ebp], -128 ; ffffff80H
  00426	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  00429	3b 4d f0	 cmp	 ecx, DWORD PTR _iSize$[ebp]
  0042c	0f 8c 76 fe ff
	ff		 jl	 $LL36@OnRenderSi
$LN41@OnRenderSi:
  00432	5b		 pop	 ebx
$LN15@OnRenderSi:
  00433	5f		 pop	 edi
  00434	5e		 pop	 esi

; 1897 : 		}
; 1898 : 	}
; 1899 : }

  00435	c9		 leave
  00436	c2 08 00	 ret	 8
?OnRenderSingleUser@RoundStateUserWnd@@IAEXHH@Z ENDP	; RoundStateUserWnd::OnRenderSingleUser
_TEXT	ENDS
PUBLIC	??_C@_0CG@IALGENBL@RoundStateUserWnd?3?3OnRenderSocce@ ; `string'
PUBLIC	?OnRenderSoccerUser@RoundStateUserWnd@@IAEXHH@Z	; RoundStateUserWnd::OnRenderSoccerUser
;	COMDAT ??_C@_0CG@IALGENBL@RoundStateUserWnd?3?3OnRenderSocce@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
CONST	SEGMENT
??_C@_0CG@IALGENBL@RoundStateUserWnd?3?3OnRenderSocce@ DB 'RoundStateUser'
	DB	'Wnd::OnRenderSoccerUser', 00H		; `string'
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
CONST	ENDS
;	COMDAT ?OnRenderSoccerUser@RoundStateUserWnd@@IAEXHH@Z
_TEXT	SEGMENT
_iSize$ = -16						; size = 4
_iWidth$550345 = -12					; size = 4
_iMaxUserLineTitle$ = -12				; size = 4
tv525 = -8						; size = 4
tv401 = -8						; size = 4
_i$ = -4						; size = 4
_rkInfo$550342 = 8					; size = 4
_iXPos$ = 8						; size = 4
_iYPos$ = 12						; size = 4
?OnRenderSoccerUser@RoundStateUserWnd@@IAEXHH@Z PROC	; RoundStateUserWnd::OnRenderSoccerUser, COMDAT
; _this$ = ecx

; 1902 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 1903 : 	if( !m_pCurrentOver ) return;

  00009	33 c9		 xor	 ecx, ecx
  0000b	39 8e 44 02 00
	00		 cmp	 DWORD PTR [esi+580], ecx
  00011	0f 84 c2 03 00
	00		 je	 $LN5@OnRenderSo

; 1904 : 
; 1905 : 	// 
; 1906 : 	int i = 0;
; 1907 : 	int iMaxUserLineTitle = m_iMaxLine / m_iLinePlayer;

  00017	8b 86 74 02 00
	00		 mov	 eax, DWORD PTR [esi+628]
  0001d	99		 cdq
  0001e	f7 be 78 02 00
	00		 idiv	 DWORD PTR [esi+632]
  00024	53		 push	 ebx
  00025	57		 push	 edi

; 1908 : 	for(i = 0;i < iMaxUserLineTitle;i++)

  00026	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  00029	89 45 f4	 mov	 DWORD PTR _iMaxUserLineTitle$[ebp], eax
  0002c	3b c1		 cmp	 eax, ecx
  0002e	0f 8e 00 02 00
	00		 jle	 $LN10@OnRenderSo
  00034	8b 45 0c	 mov	 eax, DWORD PTR _iYPos$[ebp]
  00037	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  0003d	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?PrintText@ioFontManager@@QAAXMMMPBDZZ
  00043	83 c0 3e	 add	 eax, 62			; 0000003eH
  00046	0f 57 c0	 xorps	 xmm0, xmm0
  00049	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0004d	f3 0f 11 45 f8	 movss	 DWORD PTR tv401[ebp], xmm0
$LL12@OnRenderSo:

; 1909 : 	{
; 1910 : 		g_FontMgr.SetBkColor( 0, 0, 0 );

  00052	51		 push	 ecx
  00053	51		 push	 ecx
  00054	51		 push	 ecx
  00055	ff d7		 call	 edi
  00057	8b c8		 mov	 ecx, eax
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetBkColor@ioFontManager@@QAEXHHH@Z

; 1911 : 		g_FontMgr.SetTextStyle( TS_NORMAL );

  0005f	6a 00		 push	 0
  00061	ff d7		 call	 edi
  00063	8b c8		 mov	 ecx, eax
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextStyle@ioFontManager@@QAEXW4TextStyle@@@Z

; 1912 : 		if( m_eWindowTeam == TEAM_BLUE )

  0006b	83 be 58 02 00
	00 02		 cmp	 DWORD PTR [esi+600], 2
  00072	75 07		 jne	 SHORT $LN9@OnRenderSo

; 1913 : 			g_FontMgr.SetTextColor( TCT_DEFAULT_BLUE );

  00074	68 b2 46 16 ff	 push	 -15317326		; ff1646b2H

; 1914 : 		else

  00079	eb 05		 jmp	 SHORT $LN39@OnRenderSo
$LN9@OnRenderSo:

; 1915 : 			g_FontMgr.SetTextColor( TCT_DEFAULT_RED );

  0007b	68 00 16 b9 ff	 push	 -4647424		; ffb91600H
$LN39@OnRenderSo:
  00080	ff d7		 call	 edi
  00082	8b c8		 mov	 ecx, eax
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextColor@ioFontManager@@QAEXK@Z

; 1916 : 
; 1917 : 		g_FontMgr.SetAlignType( TAT_LEFT );

  0008a	6a 00		 push	 0
  0008c	ff d7		 call	 edi
  0008e	8b c8		 mov	 ecx, eax
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 1918 : 		g_FontMgr.PrintText( iXPos + 12 + i * m_iLinePlayerGap, iYPos + 62, FONT_SIZE_12, STR(1) );

  00096	6a 00		 push	 0
  00098	6a 01		 push	 1
  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@IALGENBL@RoundStateUserWnd?3?3OnRenderSocce@
  000a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  000aa	8b c8		 mov	 ecx, eax
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  000b2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  000ba	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  000bd	50		 push	 eax
  000be	8b 86 7c 02 00
	00		 mov	 eax, DWORD PTR [esi+636]
  000c4	0f af 45 fc	 imul	 eax, DWORD PTR _i$[ebp]
  000c8	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000cb	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  000d1	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv401[ebp]
  000d6	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000dc	8d 44 08 0c	 lea	 eax, DWORD PTR [eax+ecx+12]
  000e0	0f 57 c0	 xorps	 xmm0, xmm0
  000e3	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000e7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ec	ff d7		 call	 edi
  000ee	50		 push	 eax
  000ef	ff d3		 call	 ebx
  000f1	83 c4 14	 add	 esp, 20			; 00000014H

; 1919 : 
; 1920 : 		g_FontMgr.SetAlignType( TAT_CENTER );

  000f4	6a 01		 push	 1
  000f6	ff d7		 call	 edi
  000f8	8b c8		 mov	 ecx, eax
  000fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 1921 : 		g_FontMgr.PrintText( iXPos + 219 + i * m_iLinePlayerGap, iYPos + 62, FONT_SIZE_12, STR(2) );

  00100	6a 00		 push	 0
  00102	6a 02		 push	 2
  00104	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00109	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@IALGENBL@RoundStateUserWnd?3?3OnRenderSocce@
  0010e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00114	8b c8		 mov	 ecx, eax
  00116	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0011c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00124	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  00127	50		 push	 eax
  00128	8b 86 7c 02 00
	00		 mov	 eax, DWORD PTR [esi+636]
  0012e	0f af 45 fc	 imul	 eax, DWORD PTR _i$[ebp]
  00132	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00135	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  0013b	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv401[ebp]
  00140	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00146	8d 84 08 db 00
	00 00		 lea	 eax, DWORD PTR [eax+ecx+219]
  0014d	0f 57 c0	 xorps	 xmm0, xmm0
  00150	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00154	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00159	ff d7		 call	 edi
  0015b	50		 push	 eax
  0015c	ff d3		 call	 ebx
  0015e	83 c4 14	 add	 esp, 20			; 00000014H

; 1922 : 		g_FontMgr.PrintText( iXPos + 261 + i * m_iLinePlayerGap, iYPos + 62, FONT_SIZE_12, STR(3) );

  00161	6a 00		 push	 0
  00163	6a 03		 push	 3
  00165	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0016a	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@IALGENBL@RoundStateUserWnd?3?3OnRenderSocce@
  0016f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00175	8b c8		 mov	 ecx, eax
  00177	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0017d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00185	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  00188	50		 push	 eax
  00189	8b 86 7c 02 00
	00		 mov	 eax, DWORD PTR [esi+636]
  0018f	0f af 45 fc	 imul	 eax, DWORD PTR _i$[ebp]
  00193	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00196	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  0019c	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv401[ebp]
  001a1	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  001a7	8d 84 08 05 01
	00 00		 lea	 eax, DWORD PTR [eax+ecx+261]
  001ae	0f 57 c0	 xorps	 xmm0, xmm0
  001b1	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001b5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ba	ff d7		 call	 edi
  001bc	50		 push	 eax
  001bd	ff d3		 call	 ebx
  001bf	83 c4 14	 add	 esp, 20			; 00000014H

; 1923 : 		g_FontMgr.PrintText( iXPos + 294 + i * m_iLinePlayerGap, iYPos + 62, FONT_SIZE_12, STR(4) );

  001c2	6a 00		 push	 0
  001c4	6a 04		 push	 4
  001c6	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  001cb	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@IALGENBL@RoundStateUserWnd?3?3OnRenderSocce@
  001d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  001d6	8b c8		 mov	 ecx, eax
  001d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  001de	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  001e6	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  001e9	50		 push	 eax
  001ea	8b 86 7c 02 00
	00		 mov	 eax, DWORD PTR [esi+636]
  001f0	0f af 45 fc	 imul	 eax, DWORD PTR _i$[ebp]
  001f4	83 ec 0c	 sub	 esp, 12			; 0000000cH
  001f7	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  001fd	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv401[ebp]
  00202	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00208	8d 84 08 26 01
	00 00		 lea	 eax, DWORD PTR [eax+ecx+294]
  0020f	0f 57 c0	 xorps	 xmm0, xmm0
  00212	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00216	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0021b	ff d7		 call	 edi
  0021d	50		 push	 eax
  0021e	ff d3		 call	 ebx
  00220	83 c4 14	 add	 esp, 20			; 00000014H
  00223	ff 45 fc	 inc	 DWORD PTR _i$[ebp]
  00226	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00229	33 c9		 xor	 ecx, ecx
  0022b	3b 45 f4	 cmp	 eax, DWORD PTR _iMaxUserLineTitle$[ebp]
  0022e	0f 8c 1e fe ff
	ff		 jl	 $LL12@OnRenderSo
$LN10@OnRenderSo:

; 1927 : 	int iRealYPos = iYPos + m_iLineStartY;
; 1928 : 	int iSize = m_RoundInfoList.size();

  00234	8b 86 9c 02 00
	00		 mov	 eax, DWORD PTR [esi+668]
  0023a	2b 86 98 02 00
	00		 sub	 eax, DWORD PTR [esi+664]
  00240	8b be 80 02 00
	00		 mov	 edi, DWORD PTR [esi+640]
  00246	8b 9e 84 02 00
	00		 mov	 ebx, DWORD PTR [esi+644]
  0024c	03 7d 08	 add	 edi, DWORD PTR _iXPos$[ebp]
  0024f	03 5d 0c	 add	 ebx, DWORD PTR _iYPos$[ebp]
  00252	c1 f8 07	 sar	 eax, 7
  00255	89 45 f0	 mov	 DWORD PTR _iSize$[ebp], eax

; 1929 : 	for(i = 0;i < iSize;i++)

  00258	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  0025b	3b c1		 cmp	 eax, ecx
  0025d	0f 8e 74 01 00
	00		 jle	 $LN37@OnRenderSo

; 1924 : 	}
; 1925 : 
; 1926 : 	int iRealXPos = iXPos + m_iLineStartX;

  00263	89 4d f8	 mov	 DWORD PTR tv525[ebp], ecx
  00266	eb 02		 jmp	 SHORT $LN7@OnRenderSo
$LL33@OnRenderSo:
  00268	33 c9		 xor	 ecx, ecx
$LN7@OnRenderSo:

; 1929 : 	for(i = 0;i < iSize;i++)

  0026a	8b 86 98 02 00
	00		 mov	 eax, DWORD PTR [esi+664]
  00270	03 45 f8	 add	 eax, DWORD PTR tv525[ebp]

; 1930 : 	{
; 1931 : 		RoundInfo &rkInfo = m_RoundInfoList[i];
; 1932 : 
; 1933 : 		if( m_MouseOverIndex == i || rkInfo.m_bOwner )

  00273	8b 96 5c 02 00
	00		 mov	 edx, DWORD PTR [esi+604]
  00279	89 45 08	 mov	 DWORD PTR _rkInfo$550342[ebp], eax
  0027c	3b 55 fc	 cmp	 edx, DWORD PTR _i$[ebp]
  0027f	74 06		 je	 SHORT $LN3@OnRenderSo
  00281	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  00285	74 2e		 je	 SHORT $LN4@OnRenderSo
$LN3@OnRenderSo:

; 1934 : 			m_pCurrentOver->Render( iRealXPos, iRealYPos );

  00287	8b 86 44 02 00
	00		 mov	 eax, DWORD PTR [esi+580]
  0028d	8b 10		 mov	 edx, DWORD PTR [eax]
  0028f	51		 push	 ecx
  00290	51		 push	 ecx
  00291	51		 push	 ecx
  00292	51		 push	 ecx
  00293	51		 push	 ecx
  00294	0f 57 c0	 xorps	 xmm0, xmm0
  00297	51		 push	 ecx
  00298	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  0029c	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  002a2	0f 57 c0	 xorps	 xmm0, xmm0
  002a5	f3 0f 2a c7	 cvtsi2ss xmm0, edi
  002a9	8b c8		 mov	 ecx, eax
  002ab	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002b0	ff 12		 call	 DWORD PTR [edx]
  002b2	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550342[ebp]
$LN4@OnRenderSo:

; 1935 : 
; 1936 : 		// 계급 & 아이디
; 1937 : 		int iWidth = OnRenderGradeAndNick( rkInfo, iRealXPos + 4, iRealYPos + 2, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  002b5	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  002b8	39 8e 5c 02 00
	00		 cmp	 DWORD PTR [esi+604], ecx
  002be	74 0a		 je	 SHORT $LN16@OnRenderSo
  002c0	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  002c4	75 04		 jne	 SHORT $LN16@OnRenderSo
  002c6	32 d2		 xor	 dl, dl
  002c8	eb 03		 jmp	 SHORT $LN17@OnRenderSo
$LN16@OnRenderSo:
  002ca	33 d2		 xor	 edx, edx
  002cc	42		 inc	 edx
$LN17@OnRenderSo:
  002cd	52		 push	 edx
  002ce	8d 4b 02	 lea	 ecx, DWORD PTR [ebx+2]
  002d1	51		 push	 ecx
  002d2	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  002d5	51		 push	 ecx
  002d6	50		 push	 eax
  002d7	8b ce		 mov	 ecx, esi
  002d9	e8 00 00 00 00	 call	 ?OnRenderGradeAndNick@RoundStateUserWnd@@IAEHABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderGradeAndNick

; 1938 : 
; 1939 : 		// 길드 마크
; 1940 : 		iWidth += OnRenderGuildMark( rkInfo, iRealXPos + 4 + iWidth, iRealYPos + 4 );

  002de	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  002e1	51		 push	 ecx
  002e2	89 45 f4	 mov	 DWORD PTR _iWidth$550345[ebp], eax
  002e5	8d 44 38 04	 lea	 eax, DWORD PTR [eax+edi+4]
  002e9	50		 push	 eax
  002ea	ff 75 08	 push	 DWORD PTR _rkInfo$550342[ebp]
  002ed	8b ce		 mov	 ecx, esi
  002ef	e8 00 00 00 00	 call	 ?OnRenderGuildMark@RoundStateUserWnd@@IAEHABURoundInfo@@HH@Z ; RoundStateUserWnd::OnRenderGuildMark
  002f4	8b 4d f4	 mov	 ecx, DWORD PTR _iWidth$550345[ebp]
  002f7	03 c8		 add	 ecx, eax

; 1941 : 
; 1942 : 		// 보너스
; 1943 : 		OnRenderBonus( rkInfo, iRealXPos + iWidth + 7, iRealYPos + 3 );

  002f9	8d 43 03	 lea	 eax, DWORD PTR [ebx+3]
  002fc	50		 push	 eax
  002fd	8d 44 39 07	 lea	 eax, DWORD PTR [ecx+edi+7]
  00301	50		 push	 eax
  00302	ff 75 08	 push	 DWORD PTR _rkInfo$550342[ebp]
  00305	8b ce		 mov	 ecx, esi
  00307	e8 00 00 00 00	 call	 ?OnRenderBonus@RoundStateUserWnd@@IAEXABURoundInfo@@HH@Z ; RoundStateUserWnd::OnRenderBonus

; 1944 : 
; 1945 : 		// 기여도
; 1946 : 		OnRenderContribute( rkInfo, iRealXPos + 212, iRealYPos + 3, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  0030c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0030f	39 86 5c 02 00
	00		 cmp	 DWORD PTR [esi+604], eax
  00315	74 0d		 je	 SHORT $LN34@OnRenderSo
  00317	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550342[ebp]
  0031a	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  0031e	75 04		 jne	 SHORT $LN34@OnRenderSo
  00320	32 c0		 xor	 al, al
  00322	eb 03		 jmp	 SHORT $LN19@OnRenderSo
$LN34@OnRenderSo:
  00324	33 c0		 xor	 eax, eax
  00326	40		 inc	 eax
$LN19@OnRenderSo:
  00327	50		 push	 eax
  00328	8d 43 03	 lea	 eax, DWORD PTR [ebx+3]
  0032b	50		 push	 eax
  0032c	8d 87 d4 00 00
	00		 lea	 eax, DWORD PTR [edi+212]
  00332	50		 push	 eax
  00333	ff 75 08	 push	 DWORD PTR _rkInfo$550342[ebp]
  00336	8b ce		 mov	 ecx, esi
  00338	e8 00 00 00 00	 call	 ?OnRenderContribute@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderContribute

; 1947 : 
; 1948 : 		// 골
; 1949 : 		OnRenderGoal( rkInfo, iRealXPos + 254, iRealYPos + 3, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  0033d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00340	39 86 5c 02 00
	00		 cmp	 DWORD PTR [esi+604], eax
  00346	74 0d		 je	 SHORT $LN35@OnRenderSo
  00348	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550342[ebp]
  0034b	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  0034f	75 04		 jne	 SHORT $LN35@OnRenderSo
  00351	32 c0		 xor	 al, al
  00353	eb 03		 jmp	 SHORT $LN21@OnRenderSo
$LN35@OnRenderSo:
  00355	33 c0		 xor	 eax, eax
  00357	40		 inc	 eax
$LN21@OnRenderSo:
  00358	50		 push	 eax
  00359	8d 43 03	 lea	 eax, DWORD PTR [ebx+3]
  0035c	50		 push	 eax
  0035d	8d 87 fe 00 00
	00		 lea	 eax, DWORD PTR [edi+254]
  00363	50		 push	 eax
  00364	ff 75 08	 push	 DWORD PTR _rkInfo$550342[ebp]
  00367	8b ce		 mov	 ecx, esi
  00369	e8 00 00 00 00	 call	 ?OnRenderGoal@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderGoal

; 1950 : 
; 1951 : 		// 핑
; 1952 : 		OnRenderPing( rkInfo, iRealXPos + 275, iRealYPos + 2, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  0036e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00371	39 86 5c 02 00
	00		 cmp	 DWORD PTR [esi+604], eax
  00377	74 0d		 je	 SHORT $LN36@OnRenderSo
  00379	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550342[ebp]
  0037c	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  00380	75 04		 jne	 SHORT $LN36@OnRenderSo
  00382	32 c0		 xor	 al, al
  00384	eb 03		 jmp	 SHORT $LN23@OnRenderSo
$LN36@OnRenderSo:
  00386	33 c0		 xor	 eax, eax
  00388	40		 inc	 eax
$LN23@OnRenderSo:
  00389	50		 push	 eax
  0038a	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
  0038d	50		 push	 eax
  0038e	8d 87 13 01 00
	00		 lea	 eax, DWORD PTR [edi+275]
  00394	50		 push	 eax
  00395	ff 75 08	 push	 DWORD PTR _rkInfo$550342[ebp]
  00398	8b ce		 mov	 ecx, esi
  0039a	e8 00 00 00 00	 call	 ?OnRenderPing@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderPing

; 1953 : 
; 1954 : 		//
; 1955 : 		if( 0 == ( i + 1 ) % m_iLinePlayer )

  0039f	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  003a2	41		 inc	 ecx
  003a3	8b c1		 mov	 eax, ecx
  003a5	99		 cdq
  003a6	f7 be 78 02 00
	00		 idiv	 DWORD PTR [esi+632]
  003ac	85 d2		 test	 edx, edx
  003ae	75 11		 jne	 SHORT $LN2@OnRenderSo

; 1956 : 		{
; 1957 : 			iRealXPos += m_iLinePlayerGap;
; 1958 : 			iRealYPos = iYPos + m_iLineStartY;

  003b0	8b 9e 84 02 00
	00		 mov	 ebx, DWORD PTR [esi+644]
  003b6	03 be 7c 02 00
	00		 add	 edi, DWORD PTR [esi+636]
  003bc	03 5d 0c	 add	 ebx, DWORD PTR _iYPos$[ebp]

; 1959 : 		}
; 1960 : 		else

  003bf	eb 06		 jmp	 SHORT $LN6@OnRenderSo
$LN2@OnRenderSo:

; 1961 : 		{
; 1962 : 			iRealYPos += m_iLineHeight;

  003c1	03 9e 8c 02 00
	00		 add	 ebx, DWORD PTR [esi+652]
$LN6@OnRenderSo:

; 1929 : 	for(i = 0;i < iSize;i++)

  003c7	83 6d f8 80	 sub	 DWORD PTR tv525[ebp], -128 ; ffffff80H
  003cb	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  003ce	3b 4d f0	 cmp	 ecx, DWORD PTR _iSize$[ebp]
  003d1	0f 8c 91 fe ff
	ff		 jl	 $LL33@OnRenderSo
$LN37@OnRenderSo:
  003d7	5f		 pop	 edi
  003d8	5b		 pop	 ebx
$LN5@OnRenderSo:
  003d9	5e		 pop	 esi

; 1963 : 		}
; 1964 : 	}
; 1965 : }

  003da	c9		 leave
  003db	c2 08 00	 ret	 8
?OnRenderSoccerUser@RoundStateUserWnd@@IAEXHH@Z ENDP	; RoundStateUserWnd::OnRenderSoccerUser
_TEXT	ENDS
PUBLIC	??_C@_0CI@PFOKDJDD@RoundStateUserWnd?3?3OnRenderTower@ ; `string'
PUBLIC	?OnRenderTowerDefUser@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderTowerDefUser
;	COMDAT ??_C@_0CI@PFOKDJDD@RoundStateUserWnd?3?3OnRenderTower@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
CONST	SEGMENT
??_C@_0CI@PFOKDJDD@RoundStateUserWnd?3?3OnRenderTower@ DB 'RoundStateUser'
	DB	'Wnd::OnRenderTowerDefUser', 00H		; `string'
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
CONST	ENDS
;	COMDAT ?OnRenderTowerDefUser@RoundStateUserWnd@@IAEXHH@Z
_TEXT	SEGMENT
_iWidth$550368 = -12					; size = 4
tv517 = -8						; size = 4
tv393 = -4						; size = 4
_iRealXPos$ = -4					; size = 4
_rkInfo$550364 = 8					; size = 4
_iXPos$ = 8						; size = 4
_i$550360 = 12						; size = 4
_iYPos$ = 12						; size = 4
?OnRenderTowerDefUser@RoundStateUserWnd@@IAEXHH@Z PROC	; RoundStateUserWnd::OnRenderTowerDefUser, COMDAT
; _this$ = ecx

; 1968 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx

; 1969 : 	if( !m_pCurrentOver || !m_pBlueOver ) return;

  0000a	33 db		 xor	 ebx, ebx
  0000c	39 9f 44 02 00
	00		 cmp	 DWORD PTR [edi+580], ebx
  00012	0f 84 9b 03 00
	00		 je	 $LN7@OnRenderTo@3
  00018	39 9f 70 01 00
	00		 cmp	 DWORD PTR [edi+368], ebx
  0001e	0f 84 8f 03 00
	00		 je	 $LN7@OnRenderTo@3

; 1970 : 
; 1971 : 	g_FontMgr.SetBkColor( 0, 0, 0 );

  00024	56		 push	 esi
  00025	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  0002b	53		 push	 ebx
  0002c	53		 push	 ebx
  0002d	53		 push	 ebx
  0002e	ff d6		 call	 esi
  00030	8b c8		 mov	 ecx, eax
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetBkColor@ioFontManager@@QAEXHHH@Z

; 1972 : 	g_FontMgr.SetTextStyle( TS_NORMAL );

  00038	53		 push	 ebx
  00039	ff d6		 call	 esi
  0003b	8b c8		 mov	 ecx, eax
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextStyle@ioFontManager@@QAEXW4TextStyle@@@Z

; 1973 : 	g_FontMgr.SetTextColor( TCT_DEFAULT_BLUE );

  00043	68 b2 46 16 ff	 push	 -15317326		; ff1646b2H
  00048	ff d6		 call	 esi
  0004a	8b c8		 mov	 ecx, eax
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextColor@ioFontManager@@QAEXK@Z

; 1974 : 
; 1975 : 	g_FontMgr.SetAlignType( TAT_LEFT );

  00052	53		 push	 ebx
  00053	ff d6		 call	 esi
  00055	8b c8		 mov	 ecx, eax
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 1976 : 	g_FontMgr.PrintText( iXPos + 12, iYPos + 62, FONT_SIZE_12, STR(6) );

  0005d	8b 45 0c	 mov	 eax, DWORD PTR _iYPos$[ebp]
  00060	53		 push	 ebx
  00061	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00067	6a 06		 push	 6
  00069	83 c0 3e	 add	 eax, 62			; 0000003eH
  0006c	0f 57 c0	 xorps	 xmm0, xmm0
  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00074	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@PFOKDJDD@RoundStateUserWnd?3?3OnRenderTower@
  0007d	f3 0f 11 45 fc	 movss	 DWORD PTR tv393[ebp], xmm0
  00082	ff d3		 call	 ebx
  00084	8b c8		 mov	 ecx, eax
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0008c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00094	50		 push	 eax
  00095	8b 45 08	 mov	 eax, DWORD PTR _iXPos$[ebp]
  00098	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0009b	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  000a1	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR tv393[ebp]
  000a6	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000ac	83 c0 0c	 add	 eax, 12			; 0000000cH
  000af	0f 57 c0	 xorps	 xmm0, xmm0
  000b2	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000b6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000bb	ff d6		 call	 esi
  000bd	50		 push	 eax
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAAXMMMPBDZZ
  000c4	83 c4 14	 add	 esp, 20			; 00000014H

; 1977 : 
; 1978 : 	g_FontMgr.SetAlignType( TAT_CENTER );

  000c7	6a 01		 push	 1
  000c9	ff d6		 call	 esi
  000cb	8b c8		 mov	 ecx, eax
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 1979 : 	g_FontMgr.PrintText( iXPos + 352, iYPos + 62, FONT_SIZE_12, STR(7) );

  000d3	6a 00		 push	 0
  000d5	6a 07		 push	 7
  000d7	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  000dc	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@PFOKDJDD@RoundStateUserWnd?3?3OnRenderTower@
  000e1	ff d3		 call	 ebx
  000e3	8b c8		 mov	 ecx, eax
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  000eb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  000f3	50		 push	 eax
  000f4	8b 45 08	 mov	 eax, DWORD PTR _iXPos$[ebp]
  000f7	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000fa	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00100	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR tv393[ebp]
  00105	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0010b	05 60 01 00 00	 add	 eax, 352		; 00000160H
  00110	0f 57 c0	 xorps	 xmm0, xmm0
  00113	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00117	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0011c	ff d6		 call	 esi
  0011e	50		 push	 eax
  0011f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAAXMMMPBDZZ
  00125	83 c4 14	 add	 esp, 20			; 00000014H

; 1980 : 	g_FontMgr.PrintText( iXPos + 403, iYPos + 62, FONT_SIZE_12, STR(8) );

  00128	6a 00		 push	 0
  0012a	6a 08		 push	 8
  0012c	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00131	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@PFOKDJDD@RoundStateUserWnd?3?3OnRenderTower@
  00136	ff d3		 call	 ebx
  00138	8b c8		 mov	 ecx, eax
  0013a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  00140	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00148	50		 push	 eax
  00149	8b 45 08	 mov	 eax, DWORD PTR _iXPos$[ebp]
  0014c	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0014f	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00155	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR tv393[ebp]
  0015a	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00160	05 93 01 00 00	 add	 eax, 403		; 00000193H
  00165	0f 57 c0	 xorps	 xmm0, xmm0
  00168	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0016c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00171	ff d6		 call	 esi
  00173	50		 push	 eax
  00174	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAAXMMMPBDZZ
  0017a	83 c4 14	 add	 esp, 20			; 00000014H

; 1981 : 	g_FontMgr.PrintText( iXPos + 454, iYPos + 62, FONT_SIZE_12, STR(9) );

  0017d	6a 00		 push	 0
  0017f	6a 09		 push	 9
  00181	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00186	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@PFOKDJDD@RoundStateUserWnd?3?3OnRenderTower@
  0018b	ff d3		 call	 ebx
  0018d	8b c8		 mov	 ecx, eax
  0018f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  00195	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  0019d	50		 push	 eax
  0019e	8b 45 08	 mov	 eax, DWORD PTR _iXPos$[ebp]
  001a1	83 ec 0c	 sub	 esp, 12			; 0000000cH
  001a4	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  001aa	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR tv393[ebp]
  001af	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  001b5	05 c6 01 00 00	 add	 eax, 454		; 000001c6H
  001ba	0f 57 c0	 xorps	 xmm0, xmm0
  001bd	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001c1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001c6	ff d6		 call	 esi
  001c8	50		 push	 eax
  001c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAAXMMMPBDZZ
  001cf	83 c4 14	 add	 esp, 20			; 00000014H

; 1982 : 	g_FontMgr.PrintText( iXPos + 505, iYPos + 62, FONT_SIZE_12, STR(10) );

  001d2	6a 00		 push	 0
  001d4	6a 0a		 push	 10			; 0000000aH
  001d6	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  001db	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@PFOKDJDD@RoundStateUserWnd?3?3OnRenderTower@
  001e0	ff d3		 call	 ebx
  001e2	8b c8		 mov	 ecx, eax
  001e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  001ea	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  001f2	8b 5d 08	 mov	 ebx, DWORD PTR _iXPos$[ebp]
  001f5	50		 push	 eax
  001f6	83 ec 0c	 sub	 esp, 12			; 0000000cH
  001f9	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  001ff	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR tv393[ebp]
  00204	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0020a	8d 83 f9 01 00
	00		 lea	 eax, DWORD PTR [ebx+505]
  00210	0f 57 c0	 xorps	 xmm0, xmm0
  00213	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00217	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0021c	ff d6		 call	 esi
  0021e	50		 push	 eax
  0021f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAAXMMMPBDZZ

; 1983 : 
; 1984 : 	int iRealXPos = iXPos + m_iLineStartX;

  00225	8b 87 80 02 00
	00		 mov	 eax, DWORD PTR [edi+640]

; 1985 : 	int iRealYPos = iYPos + m_iLineStartY;
; 1986 : 	int iSize = m_RoundInfoList.size();
; 1987 : 
; 1988 : 	m_pBlueOver->SetSize(514,21);

  0022b	8b 8f 70 01 00
	00		 mov	 ecx, DWORD PTR [edi+368]
  00231	8b b7 84 02 00
	00		 mov	 esi, DWORD PTR [edi+644]
  00237	03 75 0c	 add	 esi, DWORD PTR _iYPos$[ebp]
  0023a	03 c3		 add	 eax, ebx
  0023c	8b 9f 9c 02 00
	00		 mov	 ebx, DWORD PTR [edi+668]
  00242	2b 9f 98 02 00
	00		 sub	 ebx, DWORD PTR [edi+664]
  00248	83 c4 14	 add	 esp, 20			; 00000014H
  0024b	6a 15		 push	 21			; 00000015H
  0024d	89 45 fc	 mov	 DWORD PTR _iRealXPos$[ebp], eax
  00250	8b 01		 mov	 eax, DWORD PTR [ecx]
  00252	68 02 02 00 00	 push	 514			; 00000202H
  00257	c1 fb 07	 sar	 ebx, 7
  0025a	ff 50 10	 call	 DWORD PTR [eax+16]

; 1989 : 	m_pCurrentOver->SetSize(514,21);

  0025d	8b 8f 44 02 00
	00		 mov	 ecx, DWORD PTR [edi+580]
  00263	8b 01		 mov	 eax, DWORD PTR [ecx]
  00265	6a 15		 push	 21			; 00000015H
  00267	68 02 02 00 00	 push	 514			; 00000202H
  0026c	ff 50 10	 call	 DWORD PTR [eax+16]

; 1990 : 
; 1991 : 	for(int i = 0;i < iSize;i++)

  0026f	33 d2		 xor	 edx, edx
  00271	89 55 0c	 mov	 DWORD PTR _i$550360[ebp], edx
  00274	3b da		 cmp	 ebx, edx
  00276	0f 8e 36 01 00
	00		 jle	 $LN28@OnRenderTo@3

; 1970 : 
; 1971 : 	g_FontMgr.SetBkColor( 0, 0, 0 );

  0027c	89 55 f8	 mov	 DWORD PTR tv517[ebp], edx
  0027f	eb 02		 jmp	 SHORT $LN6@OnRenderTo@3
$LL24@OnRenderTo@3:
  00281	33 d2		 xor	 edx, edx
$LN6@OnRenderTo@3:

; 1990 : 
; 1991 : 	for(int i = 0;i < iSize;i++)

  00283	8b 87 98 02 00
	00		 mov	 eax, DWORD PTR [edi+664]
  00289	03 45 f8	 add	 eax, DWORD PTR tv517[ebp]

; 1992 : 	{
; 1993 : 		RoundInfo &rkInfo = m_RoundInfoList[i];
; 1994 : 
; 1995 : 		if( rkInfo.m_bOwner )

  0028c	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  00290	89 45 08	 mov	 DWORD PTR _rkInfo$550364[ebp], eax
  00293	74 08		 je	 SHORT $LN3@OnRenderTo@3

; 1996 : 			m_pBlueOver->Render( iRealXPos, iRealYPos );

  00295	8b 8f 70 01 00
	00		 mov	 ecx, DWORD PTR [edi+368]
  0029b	eb 11		 jmp	 SHORT $LN29@OnRenderTo@3
$LN3@OnRenderTo@3:

; 1997 : 		else if( m_MouseOverIndex == i )

  0029d	8b 4d 0c	 mov	 ecx, DWORD PTR _i$550360[ebp]
  002a0	39 8f 5c 02 00
	00		 cmp	 DWORD PTR [edi+604], ecx
  002a6	75 38		 jne	 SHORT $LN23@OnRenderTo@3

; 1998 : 			m_pCurrentOver->Render( iRealXPos, iRealYPos );

  002a8	8b 8f 44 02 00
	00		 mov	 ecx, DWORD PTR [edi+580]
$LN29@OnRenderTo@3:
  002ae	8b 01		 mov	 eax, DWORD PTR [ecx]
  002b0	52		 push	 edx
  002b1	52		 push	 edx
  002b2	52		 push	 edx
  002b3	52		 push	 edx
  002b4	51		 push	 ecx
  002b5	0f 57 c0	 xorps	 xmm0, xmm0
  002b8	51		 push	 ecx
  002b9	f3 0f 2a c6	 cvtsi2ss xmm0, esi
  002bd	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  002c3	66 0f 6e 45 fc	 movd	 xmm0, DWORD PTR _iRealXPos$[ebp]
  002c8	0f 5b c0	 cvtdq2ps xmm0, xmm0
  002cb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002d0	ff 10		 call	 DWORD PTR [eax]

; 1999 : 
; 2000 : 		int iWidth = OnRenderGradeAndNick( rkInfo, iRealXPos + 4, iRealYPos + 2, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  002d2	8b 45 0c	 mov	 eax, DWORD PTR _i$550360[ebp]
  002d5	39 87 5c 02 00
	00		 cmp	 DWORD PTR [edi+604], eax
  002db	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550364[ebp]
  002de	74 0a		 je	 SHORT $LN11@OnRenderTo@3
$LN23@OnRenderTo@3:
  002e0	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  002e4	75 04		 jne	 SHORT $LN11@OnRenderTo@3
  002e6	32 d2		 xor	 dl, dl
  002e8	eb 03		 jmp	 SHORT $LN12@OnRenderTo@3
$LN11@OnRenderTo@3:
  002ea	33 d2		 xor	 edx, edx
  002ec	42		 inc	 edx
$LN12@OnRenderTo@3:
  002ed	52		 push	 edx
  002ee	8d 4e 02	 lea	 ecx, DWORD PTR [esi+2]
  002f1	51		 push	 ecx
  002f2	8b 4d fc	 mov	 ecx, DWORD PTR _iRealXPos$[ebp]
  002f5	83 c1 04	 add	 ecx, 4
  002f8	51		 push	 ecx
  002f9	50		 push	 eax
  002fa	8b cf		 mov	 ecx, edi
  002fc	e8 00 00 00 00	 call	 ?OnRenderGradeAndNick@RoundStateUserWnd@@IAEHABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderGradeAndNick

; 2001 : 		iWidth += OnRenderGuildMark( rkInfo, iRealXPos + 4 + iWidth, iRealYPos + 4 );

  00301	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00304	51		 push	 ecx
  00305	8b 4d fc	 mov	 ecx, DWORD PTR _iRealXPos$[ebp]
  00308	83 c1 04	 add	 ecx, 4
  0030b	03 c8		 add	 ecx, eax
  0030d	51		 push	 ecx
  0030e	ff 75 08	 push	 DWORD PTR _rkInfo$550364[ebp]
  00311	8b cf		 mov	 ecx, edi
  00313	89 45 f4	 mov	 DWORD PTR _iWidth$550368[ebp], eax
  00316	e8 00 00 00 00	 call	 ?OnRenderGuildMark@RoundStateUserWnd@@IAEHABURoundInfo@@HH@Z ; RoundStateUserWnd::OnRenderGuildMark
  0031b	8b 4d f4	 mov	 ecx, DWORD PTR _iWidth$550368[ebp]
  0031e	03 c8		 add	 ecx, eax

; 2002 : 		OnRenderBonus( rkInfo, iRealXPos + iWidth + 7, iRealYPos + 3 );

  00320	8d 46 03	 lea	 eax, DWORD PTR [esi+3]
  00323	50		 push	 eax
  00324	8b 45 fc	 mov	 eax, DWORD PTR _iRealXPos$[ebp]
  00327	8d 44 08 07	 lea	 eax, DWORD PTR [eax+ecx+7]
  0032b	50		 push	 eax
  0032c	ff 75 08	 push	 DWORD PTR _rkInfo$550364[ebp]
  0032f	8b cf		 mov	 ecx, edi
  00331	e8 00 00 00 00	 call	 ?OnRenderBonus@RoundStateUserWnd@@IAEXABURoundInfo@@HH@Z ; RoundStateUserWnd::OnRenderBonus

; 2003 : 		OnRenderTowerDefRank( rkInfo, iRealXPos + 352, iRealYPos + 3, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  00336	8b 45 0c	 mov	 eax, DWORD PTR _i$550360[ebp]
  00339	39 87 5c 02 00
	00		 cmp	 DWORD PTR [edi+604], eax
  0033f	74 0d		 je	 SHORT $LN26@OnRenderTo@3
  00341	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550364[ebp]
  00344	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  00348	75 04		 jne	 SHORT $LN26@OnRenderTo@3
  0034a	32 c0		 xor	 al, al
  0034c	eb 03		 jmp	 SHORT $LN14@OnRenderTo@3
$LN26@OnRenderTo@3:
  0034e	33 c0		 xor	 eax, eax
  00350	40		 inc	 eax
$LN14@OnRenderTo@3:
  00351	50		 push	 eax
  00352	8d 46 03	 lea	 eax, DWORD PTR [esi+3]
  00355	50		 push	 eax
  00356	8b 45 fc	 mov	 eax, DWORD PTR _iRealXPos$[ebp]
  00359	05 60 01 00 00	 add	 eax, 352		; 00000160H
  0035e	50		 push	 eax
  0035f	ff 75 08	 push	 DWORD PTR _rkInfo$550364[ebp]
  00362	8b cf		 mov	 ecx, edi
  00364	e8 00 00 00 00	 call	 ?OnRenderTowerDefRank@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderTowerDefRank

; 2004 : 		OnRenderPing( rkInfo, iRealXPos + 486, iRealYPos + 2, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  00369	8b 45 0c	 mov	 eax, DWORD PTR _i$550360[ebp]
  0036c	39 87 5c 02 00
	00		 cmp	 DWORD PTR [edi+604], eax
  00372	74 0d		 je	 SHORT $LN27@OnRenderTo@3
  00374	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550364[ebp]
  00377	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  0037b	75 04		 jne	 SHORT $LN27@OnRenderTo@3
  0037d	32 c0		 xor	 al, al
  0037f	eb 03		 jmp	 SHORT $LN16@OnRenderTo@3
$LN27@OnRenderTo@3:
  00381	33 c0		 xor	 eax, eax
  00383	40		 inc	 eax
$LN16@OnRenderTo@3:
  00384	50		 push	 eax
  00385	8d 46 02	 lea	 eax, DWORD PTR [esi+2]
  00388	50		 push	 eax
  00389	8b 45 fc	 mov	 eax, DWORD PTR _iRealXPos$[ebp]
  0038c	05 e6 01 00 00	 add	 eax, 486		; 000001e6H
  00391	50		 push	 eax
  00392	ff 75 08	 push	 DWORD PTR _rkInfo$550364[ebp]
  00395	8b cf		 mov	 ecx, edi
  00397	e8 00 00 00 00	 call	 ?OnRenderPing@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderPing

; 2005 : 		iRealYPos += m_iLineHeight;

  0039c	03 b7 8c 02 00
	00		 add	 esi, DWORD PTR [edi+652]
  003a2	ff 45 0c	 inc	 DWORD PTR _i$550360[ebp]
  003a5	83 6d f8 80	 sub	 DWORD PTR tv517[ebp], -128 ; ffffff80H
  003a9	39 5d 0c	 cmp	 DWORD PTR _i$550360[ebp], ebx
  003ac	0f 8c cf fe ff
	ff		 jl	 $LL24@OnRenderTo@3
$LN28@OnRenderTo@3:
  003b2	5e		 pop	 esi
$LN7@OnRenderTo@3:
  003b3	5f		 pop	 edi
  003b4	5b		 pop	 ebx

; 2006 : 	}
; 2007 : }

  003b5	c9		 leave
  003b6	c2 08 00	 ret	 8
?OnRenderTowerDefUser@RoundStateUserWnd@@IAEXHH@Z ENDP	; RoundStateUserWnd::OnRenderTowerDefUser
_TEXT	ENDS
PUBLIC	??_C@_0CH@BKAFCJP@RoundStateUserWnd?3?3OnRenderMonst@ ; `string'
PUBLIC	?OnRenderMonsterUser@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderMonsterUser
;	COMDAT ??_C@_0CH@BKAFCJP@RoundStateUserWnd?3?3OnRenderMonst@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
CONST	SEGMENT
??_C@_0CH@BKAFCJP@RoundStateUserWnd?3?3OnRenderMonst@ DB 'RoundStateUserW'
	DB	'nd::OnRenderMonsterUser', 00H		; `string'
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
CONST	ENDS
;	COMDAT ?OnRenderMonsterUser@RoundStateUserWnd@@IAEXHH@Z
_TEXT	SEGMENT
_iSize$ = -16						; size = 4
_iWidth$550396 = -12					; size = 4
_iMaxUserLineTitle$ = -12				; size = 4
tv662 = -8						; size = 4
tv513 = -8						; size = 4
_i$ = -4						; size = 4
_rkInfo$550389 = 8					; size = 4
_iXPos$ = 8						; size = 4
_iYPos$ = 12						; size = 4
?OnRenderMonsterUser@RoundStateUserWnd@@IAEXHH@Z PROC	; RoundStateUserWnd::OnRenderMonsterUser, COMDAT
; _this$ = ecx

; 2011 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx

; 2012 : 	if( !m_pCurrentOver || !m_pBlueOver || !m_pRedOver || !m_pBlueVert ) return;

  0000a	33 f6		 xor	 esi, esi
  0000c	39 b7 44 02 00
	00		 cmp	 DWORD PTR [edi+580], esi
  00012	0f 84 91 04 00
	00		 je	 $LN15@OnRenderMo@2
  00018	39 b7 70 01 00
	00		 cmp	 DWORD PTR [edi+368], esi
  0001e	0f 84 85 04 00
	00		 je	 $LN15@OnRenderMo@2
  00024	39 b7 7c 01 00
	00		 cmp	 DWORD PTR [edi+380], esi
  0002a	0f 84 79 04 00
	00		 je	 $LN15@OnRenderMo@2
  00030	39 b7 bc 01 00
	00		 cmp	 DWORD PTR [edi+444], esi
  00036	0f 84 6d 04 00
	00		 je	 $LN15@OnRenderMo@2

; 2013 : 
; 2014 : 	m_pBlueVert->Render( iXPos, iYPos );//중앙선

  0003c	8b 8f bc 01 00
	00		 mov	 ecx, DWORD PTR [edi+444]
  00042	8b 01		 mov	 eax, DWORD PTR [ecx]
  00044	53		 push	 ebx
  00045	8b 5d 0c	 mov	 ebx, DWORD PTR _iYPos$[ebp]
  00048	56		 push	 esi
  00049	56		 push	 esi
  0004a	56		 push	 esi
  0004b	56		 push	 esi
  0004c	0f 57 c0	 xorps	 xmm0, xmm0
  0004f	51		 push	 ecx
  00050	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  00054	51		 push	 ecx
  00055	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0005b	66 0f 6e 45 08	 movd	 xmm0, DWORD PTR _iXPos$[ebp]
  00060	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00063	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00068	ff 10		 call	 DWORD PTR [eax]

; 2015 : 
; 2016 : 	// 
; 2017 : 	int i = 0;
; 2018 : 	int iMaxUserLineTitle = m_iMaxLine / m_iLinePlayer;

  0006a	8b 87 74 02 00
	00		 mov	 eax, DWORD PTR [edi+628]
  00070	99		 cdq
  00071	f7 bf 78 02 00
	00		 idiv	 DWORD PTR [edi+632]

; 2019 : 	for(i = 0;i < iMaxUserLineTitle;i++)

  00077	89 75 fc	 mov	 DWORD PTR _i$[ebp], esi
  0007a	89 45 f4	 mov	 DWORD PTR _iMaxUserLineTitle$[ebp], eax
  0007d	3b c6		 cmp	 eax, esi
  0007f	0f 8e 4e 02 00
	00		 jle	 $LN12@OnRenderMo@2
  00085	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  0008b	83 c3 3e	 add	 ebx, 62			; 0000003eH
  0008e	0f 57 c0	 xorps	 xmm0, xmm0
  00091	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  00095	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?PrintText@ioFontManager@@QAAXMMMPBDZZ
  0009b	f3 0f 11 45 f8	 movss	 DWORD PTR tv513[ebp], xmm0
$LL14@OnRenderMo@2:

; 2020 : 	{
; 2021 : 		g_FontMgr.SetBkColor( 0, 0, 0 );

  000a0	33 c0		 xor	 eax, eax
  000a2	50		 push	 eax
  000a3	50		 push	 eax
  000a4	50		 push	 eax
  000a5	ff d6		 call	 esi
  000a7	8b c8		 mov	 ecx, eax
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetBkColor@ioFontManager@@QAEXHHH@Z

; 2022 : 		g_FontMgr.SetTextStyle( TS_NORMAL );

  000af	6a 00		 push	 0
  000b1	ff d6		 call	 esi
  000b3	8b c8		 mov	 ecx, eax
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextStyle@ioFontManager@@QAEXW4TextStyle@@@Z

; 2023 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_BLUE );

  000bb	68 b2 46 16 ff	 push	 -15317326		; ff1646b2H
  000c0	ff d6		 call	 esi
  000c2	8b c8		 mov	 ecx, eax
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextColor@ioFontManager@@QAEXK@Z

; 2024 : 
; 2025 : 		g_FontMgr.SetAlignType( TAT_LEFT );

  000ca	6a 00		 push	 0
  000cc	ff d6		 call	 esi
  000ce	8b c8		 mov	 ecx, eax
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 2026 : 		g_FontMgr.PrintText( iXPos + 12 + i * m_iLinePlayerGap, iYPos + 62, FONT_SIZE_12, STR(1) );

  000d6	6a 00		 push	 0
  000d8	6a 01		 push	 1
  000da	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  000df	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@BKAFCJP@RoundStateUserWnd?3?3OnRenderMonst@
  000e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  000ea	8b c8		 mov	 ecx, eax
  000ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  000f2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  000fd	50		 push	 eax
  000fe	8b 87 7c 02 00
	00		 mov	 eax, DWORD PTR [edi+636]
  00104	0f af 45 fc	 imul	 eax, DWORD PTR _i$[ebp]
  00108	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0010b	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00111	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv513[ebp]
  00116	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0011c	8d 44 08 0c	 lea	 eax, DWORD PTR [eax+ecx+12]
  00120	0f 57 c0	 xorps	 xmm0, xmm0
  00123	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00127	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0012c	ff d6		 call	 esi
  0012e	50		 push	 eax
  0012f	ff d3		 call	 ebx
  00131	83 c4 14	 add	 esp, 20			; 00000014H

; 2027 : 
; 2028 : 		g_FontMgr.SetAlignType( TAT_CENTER );

  00134	6a 01		 push	 1
  00136	ff d6		 call	 esi
  00138	8b c8		 mov	 ecx, eax
  0013a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 2029 : 		g_FontMgr.PrintText( iXPos + 178 + i * m_iLinePlayerGap, iYPos + 62, FONT_SIZE_12, STR(2) );

  00140	6a 00		 push	 0
  00142	6a 02		 push	 2
  00144	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00149	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@BKAFCJP@RoundStateUserWnd?3?3OnRenderMonst@
  0014e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00154	8b c8		 mov	 ecx, eax
  00156	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0015c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00164	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  00167	50		 push	 eax
  00168	8b 87 7c 02 00
	00		 mov	 eax, DWORD PTR [edi+636]
  0016e	0f af 45 fc	 imul	 eax, DWORD PTR _i$[ebp]
  00172	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00175	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  0017b	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv513[ebp]
  00180	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00186	8d 84 08 b2 00
	00 00		 lea	 eax, DWORD PTR [eax+ecx+178]
  0018d	0f 57 c0	 xorps	 xmm0, xmm0
  00190	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00194	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00199	ff d6		 call	 esi
  0019b	50		 push	 eax
  0019c	ff d3		 call	 ebx
  0019e	83 c4 14	 add	 esp, 20			; 00000014H

; 2030 : 		g_FontMgr.PrintText( iXPos + 219 + i * m_iLinePlayerGap, iYPos + 62, FONT_SIZE_12, STR(3) );

  001a1	6a 00		 push	 0
  001a3	6a 03		 push	 3
  001a5	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  001aa	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@BKAFCJP@RoundStateUserWnd?3?3OnRenderMonst@
  001af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  001b5	8b c8		 mov	 ecx, eax
  001b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  001bd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  001c5	50		 push	 eax
  001c6	83 ec 0c	 sub	 esp, 12			; 0000000cH
  001c9	8b 87 7c 02 00
	00		 mov	 eax, DWORD PTR [edi+636]
  001cf	0f af 45 fc	 imul	 eax, DWORD PTR _i$[ebp]
  001d3	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  001d6	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  001dc	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv513[ebp]
  001e1	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  001e7	8d 84 08 db 00
	00 00		 lea	 eax, DWORD PTR [eax+ecx+219]
  001ee	0f 57 c0	 xorps	 xmm0, xmm0
  001f1	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001f5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001fa	ff d6		 call	 esi
  001fc	50		 push	 eax
  001fd	ff d3		 call	 ebx
  001ff	83 c4 14	 add	 esp, 20			; 00000014H

; 2031 : 		g_FontMgr.PrintText( iXPos + 261 + i * m_iLinePlayerGap, iYPos + 62, FONT_SIZE_12, STR(4) );

  00202	6a 00		 push	 0
  00204	6a 04		 push	 4
  00206	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0020b	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@BKAFCJP@RoundStateUserWnd?3?3OnRenderMonst@
  00210	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00216	8b c8		 mov	 ecx, eax
  00218	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0021e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00226	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  00229	50		 push	 eax
  0022a	8b 87 7c 02 00
	00		 mov	 eax, DWORD PTR [edi+636]
  00230	0f af 45 fc	 imul	 eax, DWORD PTR _i$[ebp]
  00234	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00237	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  0023d	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv513[ebp]
  00242	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00248	8d 84 08 05 01
	00 00		 lea	 eax, DWORD PTR [eax+ecx+261]
  0024f	0f 57 c0	 xorps	 xmm0, xmm0
  00252	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00256	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0025b	ff d6		 call	 esi
  0025d	50		 push	 eax
  0025e	ff d3		 call	 ebx
  00260	83 c4 14	 add	 esp, 20			; 00000014H

; 2032 : 		g_FontMgr.PrintText( iXPos + 294 + i * m_iLinePlayerGap, iYPos + 62, FONT_SIZE_12, STR(5) );

  00263	6a 00		 push	 0
  00265	6a 05		 push	 5
  00267	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0026c	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@BKAFCJP@RoundStateUserWnd?3?3OnRenderMonst@
  00271	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00277	8b c8		 mov	 ecx, eax
  00279	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0027f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00287	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  0028a	50		 push	 eax
  0028b	8b 87 7c 02 00
	00		 mov	 eax, DWORD PTR [edi+636]
  00291	0f af 45 fc	 imul	 eax, DWORD PTR _i$[ebp]
  00295	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00298	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  0029e	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv513[ebp]
  002a3	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  002a9	8d 84 08 26 01
	00 00		 lea	 eax, DWORD PTR [eax+ecx+294]
  002b0	0f 57 c0	 xorps	 xmm0, xmm0
  002b3	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  002b7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002bc	ff d6		 call	 esi
  002be	50		 push	 eax
  002bf	ff d3		 call	 ebx
  002c1	83 c4 14	 add	 esp, 20			; 00000014H
  002c4	ff 45 fc	 inc	 DWORD PTR _i$[ebp]
  002c7	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  002ca	3b 45 f4	 cmp	 eax, DWORD PTR _iMaxUserLineTitle$[ebp]
  002cd	0f 8c cd fd ff
	ff		 jl	 $LL14@OnRenderMo@2
$LN12@OnRenderMo@2:

; 2036 : 	int iRealYPos = iYPos + m_iLineStartY;
; 2037 : 	int iSize = m_RoundInfoList.size();

  002d3	8b 87 9c 02 00
	00		 mov	 eax, DWORD PTR [edi+668]
  002d9	2b 87 98 02 00
	00		 sub	 eax, DWORD PTR [edi+664]
  002df	8b b7 80 02 00
	00		 mov	 esi, DWORD PTR [edi+640]
  002e5	8b 9f 84 02 00
	00		 mov	 ebx, DWORD PTR [edi+644]
  002eb	03 75 08	 add	 esi, DWORD PTR _iXPos$[ebp]
  002ee	03 5d 0c	 add	 ebx, DWORD PTR _iYPos$[ebp]
  002f1	c1 f8 07	 sar	 eax, 7

; 2038 : 	for(i = 0;i < iSize;i++)

  002f4	33 d2		 xor	 edx, edx
  002f6	89 45 f0	 mov	 DWORD PTR _iSize$[ebp], eax
  002f9	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
  002fc	3b c2		 cmp	 eax, edx
  002fe	0f 8e a4 01 00
	00		 jle	 $LN41@OnRenderMo@2

; 2033 : 	}
; 2034 : 
; 2035 : 	int iRealXPos = iXPos + m_iLineStartX;

  00304	89 55 f8	 mov	 DWORD PTR tv662[ebp], edx
  00307	eb 02		 jmp	 SHORT $LN11@OnRenderMo@2
$LL36@OnRenderMo@2:
  00309	33 d2		 xor	 edx, edx
$LN11@OnRenderMo@2:

; 2038 : 	for(i = 0;i < iSize;i++)

  0030b	8b 87 98 02 00
	00		 mov	 eax, DWORD PTR [edi+664]
  00311	03 45 f8	 add	 eax, DWORD PTR tv662[ebp]

; 2039 : 	{
; 2040 : 		RoundInfo &rkInfo = m_RoundInfoList[i];
; 2041 : 
; 2042 : 		if( rkInfo.m_bOwner )

  00314	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  00318	89 45 08	 mov	 DWORD PTR _rkInfo$550389[ebp], eax
  0031b	74 1d		 je	 SHORT $LN8@OnRenderMo@2

; 2043 : 		{
; 2044 : 			if( rkInfo.m_Team == TEAM_BLUE )

  0031d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00320	83 f9 02	 cmp	 ecx, 2
  00323	75 08		 jne	 SHORT $LN7@OnRenderMo@2

; 2045 : 				m_pBlueOver->Render( iRealXPos, iRealYPos );

  00325	8b 8f 70 01 00
	00		 mov	 ecx, DWORD PTR [edi+368]
  0032b	eb 1e		 jmp	 SHORT $LN42@OnRenderMo@2
$LN7@OnRenderMo@2:

; 2046 : 			else if( rkInfo.m_Team == TEAM_RED )

  0032d	83 f9 01	 cmp	 ecx, 1
  00330	75 3f		 jne	 SHORT $LN40@OnRenderMo@2

; 2047 : 				m_pRedOver->Render( iRealXPos, iRealYPos );

  00332	8b 8f 7c 01 00
	00		 mov	 ecx, DWORD PTR [edi+380]

; 2048 : 		}

  00338	eb 11		 jmp	 SHORT $LN42@OnRenderMo@2
$LN8@OnRenderMo@2:

; 2049 : 		else if( m_MouseOverIndex == i )

  0033a	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0033d	39 8f 5c 02 00
	00		 cmp	 DWORD PTR [edi+604], ecx
  00343	75 37		 jne	 SHORT $LN35@OnRenderMo@2

; 2050 : 			m_pCurrentOver->Render( iRealXPos, iRealYPos );

  00345	8b 8f 44 02 00
	00		 mov	 ecx, DWORD PTR [edi+580]
$LN42@OnRenderMo@2:
  0034b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0034d	52		 push	 edx
  0034e	52		 push	 edx
  0034f	52		 push	 edx
  00350	52		 push	 edx
  00351	51		 push	 ecx
  00352	0f 57 c0	 xorps	 xmm0, xmm0
  00355	51		 push	 ecx
  00356	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  0035a	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00360	0f 57 c0	 xorps	 xmm0, xmm0
  00363	f3 0f 2a c6	 cvtsi2ss xmm0, esi
  00367	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0036c	ff 10		 call	 DWORD PTR [eax]
  0036e	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550389[ebp]
$LN40@OnRenderMo@2:

; 2051 : 
; 2052 : 		// 계급 & 아이디
; 2053 : 		int iWidth = OnRenderGradeAndNick( rkInfo, iRealXPos + 4, iRealYPos + 2, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  00371	8b 8f 5c 02 00
	00		 mov	 ecx, DWORD PTR [edi+604]
  00377	3b 4d fc	 cmp	 ecx, DWORD PTR _i$[ebp]
  0037a	74 0a		 je	 SHORT $LN19@OnRenderMo@2
$LN35@OnRenderMo@2:
  0037c	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  00380	75 04		 jne	 SHORT $LN19@OnRenderMo@2
  00382	32 d2		 xor	 dl, dl
  00384	eb 03		 jmp	 SHORT $LN20@OnRenderMo@2
$LN19@OnRenderMo@2:
  00386	33 d2		 xor	 edx, edx
  00388	42		 inc	 edx
$LN20@OnRenderMo@2:
  00389	52		 push	 edx
  0038a	8d 4b 02	 lea	 ecx, DWORD PTR [ebx+2]
  0038d	51		 push	 ecx
  0038e	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00391	51		 push	 ecx
  00392	50		 push	 eax
  00393	8b cf		 mov	 ecx, edi
  00395	e8 00 00 00 00	 call	 ?OnRenderGradeAndNick@RoundStateUserWnd@@IAEHABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderGradeAndNick

; 2054 : 
; 2055 : 		// 길드 마크
; 2056 : 		iWidth += OnRenderGuildMark( rkInfo, iRealXPos + 4 + iWidth, iRealYPos + 4 );

  0039a	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  0039d	51		 push	 ecx
  0039e	89 45 f4	 mov	 DWORD PTR _iWidth$550396[ebp], eax
  003a1	8d 44 30 04	 lea	 eax, DWORD PTR [eax+esi+4]
  003a5	50		 push	 eax
  003a6	ff 75 08	 push	 DWORD PTR _rkInfo$550389[ebp]
  003a9	8b cf		 mov	 ecx, edi
  003ab	e8 00 00 00 00	 call	 ?OnRenderGuildMark@RoundStateUserWnd@@IAEHABURoundInfo@@HH@Z ; RoundStateUserWnd::OnRenderGuildMark
  003b0	8b 4d f4	 mov	 ecx, DWORD PTR _iWidth$550396[ebp]
  003b3	03 c8		 add	 ecx, eax

; 2057 : 
; 2058 : 		// 보너스
; 2059 : 		OnRenderBonus( rkInfo, iRealXPos + iWidth + 7, iRealYPos + 3 );

  003b5	8d 43 03	 lea	 eax, DWORD PTR [ebx+3]
  003b8	50		 push	 eax
  003b9	8d 44 31 07	 lea	 eax, DWORD PTR [ecx+esi+7]
  003bd	50		 push	 eax
  003be	ff 75 08	 push	 DWORD PTR _rkInfo$550389[ebp]
  003c1	8b cf		 mov	 ecx, edi
  003c3	e8 00 00 00 00	 call	 ?OnRenderBonus@RoundStateUserWnd@@IAEXABURoundInfo@@HH@Z ; RoundStateUserWnd::OnRenderBonus

; 2060 : 
; 2061 : 		// 몬스터 코인
; 2062 : 		OnRenderMonsterCoin( rkInfo, iRealXPos + 153, iRealYPos + 2 );

  003c8	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
  003cb	50		 push	 eax
  003cc	8d 86 99 00 00
	00		 lea	 eax, DWORD PTR [esi+153]
  003d2	50		 push	 eax
  003d3	ff 75 08	 push	 DWORD PTR _rkInfo$550389[ebp]
  003d6	8b cf		 mov	 ecx, edi
  003d8	e8 00 00 00 00	 call	 ?OnRenderMonsterCoin@RoundStateUserWnd@@IAEXABURoundInfo@@HH@Z ; RoundStateUserWnd::OnRenderMonsterCoin

; 2063 : 
; 2064 : 		// 기여도
; 2065 : 		OnRenderContribute( rkInfo, iRealXPos + 212, iRealYPos + 3, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  003dd	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  003e0	39 87 5c 02 00
	00		 cmp	 DWORD PTR [edi+604], eax
  003e6	74 0d		 je	 SHORT $LN37@OnRenderMo@2
  003e8	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550389[ebp]
  003eb	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  003ef	75 04		 jne	 SHORT $LN37@OnRenderMo@2
  003f1	32 c0		 xor	 al, al
  003f3	eb 03		 jmp	 SHORT $LN22@OnRenderMo@2
$LN37@OnRenderMo@2:
  003f5	33 c0		 xor	 eax, eax
  003f7	40		 inc	 eax
$LN22@OnRenderMo@2:
  003f8	50		 push	 eax
  003f9	8d 43 03	 lea	 eax, DWORD PTR [ebx+3]
  003fc	50		 push	 eax
  003fd	8d 86 d4 00 00
	00		 lea	 eax, DWORD PTR [esi+212]
  00403	50		 push	 eax
  00404	ff 75 08	 push	 DWORD PTR _rkInfo$550389[ebp]
  00407	8b cf		 mov	 ecx, edi
  00409	e8 00 00 00 00	 call	 ?OnRenderContribute@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderContribute

; 2066 : 
; 2067 : 		// KO & Death
; 2068 : 		OnRenderKillDeath( rkInfo, iRealXPos + 254, iRealYPos + 3, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  0040e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00411	39 87 5c 02 00
	00		 cmp	 DWORD PTR [edi+604], eax
  00417	74 0d		 je	 SHORT $LN38@OnRenderMo@2
  00419	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550389[ebp]
  0041c	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  00420	75 04		 jne	 SHORT $LN38@OnRenderMo@2
  00422	32 c0		 xor	 al, al
  00424	eb 03		 jmp	 SHORT $LN24@OnRenderMo@2
$LN38@OnRenderMo@2:
  00426	33 c0		 xor	 eax, eax
  00428	40		 inc	 eax
$LN24@OnRenderMo@2:
  00429	50		 push	 eax
  0042a	8d 43 03	 lea	 eax, DWORD PTR [ebx+3]
  0042d	50		 push	 eax
  0042e	8d 86 fe 00 00
	00		 lea	 eax, DWORD PTR [esi+254]
  00434	50		 push	 eax
  00435	ff 75 08	 push	 DWORD PTR _rkInfo$550389[ebp]
  00438	8b cf		 mov	 ecx, edi
  0043a	e8 00 00 00 00	 call	 ?OnRenderKillDeath@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderKillDeath

; 2069 : 
; 2070 : 		// 핑
; 2071 : 		OnRenderPing( rkInfo, iRealXPos + 275, iRealYPos + 2, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  0043f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00442	39 87 5c 02 00
	00		 cmp	 DWORD PTR [edi+604], eax
  00448	74 0d		 je	 SHORT $LN39@OnRenderMo@2
  0044a	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550389[ebp]
  0044d	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  00451	75 04		 jne	 SHORT $LN39@OnRenderMo@2
  00453	32 c0		 xor	 al, al
  00455	eb 03		 jmp	 SHORT $LN26@OnRenderMo@2
$LN39@OnRenderMo@2:
  00457	33 c0		 xor	 eax, eax
  00459	40		 inc	 eax
$LN26@OnRenderMo@2:
  0045a	50		 push	 eax
  0045b	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
  0045e	50		 push	 eax
  0045f	8d 86 13 01 00
	00		 lea	 eax, DWORD PTR [esi+275]
  00465	50		 push	 eax
  00466	ff 75 08	 push	 DWORD PTR _rkInfo$550389[ebp]
  00469	8b cf		 mov	 ecx, edi
  0046b	e8 00 00 00 00	 call	 ?OnRenderPing@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderPing

; 2072 : 
; 2073 : 		//
; 2074 : 		if( 0 == ( i + 1 ) % m_iLinePlayer )

  00470	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00473	41		 inc	 ecx
  00474	8b c1		 mov	 eax, ecx
  00476	99		 cdq
  00477	f7 bf 78 02 00
	00		 idiv	 DWORD PTR [edi+632]
  0047d	85 d2		 test	 edx, edx
  0047f	75 11		 jne	 SHORT $LN2@OnRenderMo@2

; 2075 : 		{
; 2076 : 			iRealXPos += m_iLinePlayerGap;
; 2077 : 			iRealYPos = iYPos + m_iLineStartY;

  00481	8b 9f 84 02 00
	00		 mov	 ebx, DWORD PTR [edi+644]
  00487	03 b7 7c 02 00
	00		 add	 esi, DWORD PTR [edi+636]
  0048d	03 5d 0c	 add	 ebx, DWORD PTR _iYPos$[ebp]

; 2078 : 		}
; 2079 : 		else

  00490	eb 06		 jmp	 SHORT $LN10@OnRenderMo@2
$LN2@OnRenderMo@2:

; 2080 : 		{
; 2081 : 			iRealYPos += m_iLineHeight;

  00492	03 9f 8c 02 00
	00		 add	 ebx, DWORD PTR [edi+652]
$LN10@OnRenderMo@2:

; 2038 : 	for(i = 0;i < iSize;i++)

  00498	83 6d f8 80	 sub	 DWORD PTR tv662[ebp], -128 ; ffffff80H
  0049c	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  0049f	3b 4d f0	 cmp	 ecx, DWORD PTR _iSize$[ebp]
  004a2	0f 8c 61 fe ff
	ff		 jl	 $LL36@OnRenderMo@2
$LN41@OnRenderMo@2:
  004a8	5b		 pop	 ebx
$LN15@OnRenderMo@2:
  004a9	5f		 pop	 edi
  004aa	5e		 pop	 esi

; 2082 : 		}
; 2083 : 	}
; 2084 : }

  004ab	c9		 leave
  004ac	c2 08 00	 ret	 8
?OnRenderMonsterUser@RoundStateUserWnd@@IAEXHH@Z ENDP	; RoundStateUserWnd::OnRenderMonsterUser
_TEXT	ENDS
PUBLIC	??_C@_0CJ@FJHKMHEN@RoundStateUserWnd?3?3OnRenderFight@ ; `string'
PUBLIC	?OnRenderFightClubUser@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderFightClubUser
;	COMDAT ??_C@_0CJ@FJHKMHEN@RoundStateUserWnd?3?3OnRenderFight@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
CONST	SEGMENT
??_C@_0CJ@FJHKMHEN@RoundStateUserWnd?3?3OnRenderFight@ DB 'RoundStateUser'
	DB	'Wnd::OnRenderFightClubUser', 00H		; `string'
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
CONST	ENDS
;	COMDAT ?OnRenderFightClubUser@RoundStateUserWnd@@IAEXHH@Z
_TEXT	SEGMENT
_iSize$ = -16						; size = 4
_iWidth$550426 = -12					; size = 4
_iMaxUserLineTitle$ = -12				; size = 4
tv627 = -8						; size = 4
tv481 = -8						; size = 4
_i$ = -4						; size = 4
_rkInfo$550419 = 8					; size = 4
_iXPos$ = 8						; size = 4
_iYPos$ = 12						; size = 4
?OnRenderFightClubUser@RoundStateUserWnd@@IAEXHH@Z PROC	; RoundStateUserWnd::OnRenderFightClubUser, COMDAT
; _this$ = ecx

; 2087 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx

; 2088 : 	if( !m_pCurrentOver || !m_pBlueOver || !m_pRedOver || !m_pRedVert ) return;

  0000a	33 f6		 xor	 esi, esi
  0000c	39 b7 44 02 00
	00		 cmp	 DWORD PTR [edi+580], esi
  00012	0f 84 1b 04 00
	00		 je	 $LN15@OnRenderFi@3
  00018	39 b7 70 01 00
	00		 cmp	 DWORD PTR [edi+368], esi
  0001e	0f 84 0f 04 00
	00		 je	 $LN15@OnRenderFi@3
  00024	39 b7 7c 01 00
	00		 cmp	 DWORD PTR [edi+380], esi
  0002a	0f 84 03 04 00
	00		 je	 $LN15@OnRenderFi@3
  00030	39 b7 c0 01 00
	00		 cmp	 DWORD PTR [edi+448], esi
  00036	0f 84 f7 03 00
	00		 je	 $LN15@OnRenderFi@3

; 2089 : 
; 2090 : 	m_pRedVert->Render( iXPos, iYPos );//중앙선

  0003c	8b 8f c0 01 00
	00		 mov	 ecx, DWORD PTR [edi+448]
  00042	8b 01		 mov	 eax, DWORD PTR [ecx]
  00044	53		 push	 ebx
  00045	8b 5d 0c	 mov	 ebx, DWORD PTR _iYPos$[ebp]
  00048	56		 push	 esi
  00049	56		 push	 esi
  0004a	56		 push	 esi
  0004b	56		 push	 esi
  0004c	0f 57 c0	 xorps	 xmm0, xmm0
  0004f	51		 push	 ecx
  00050	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  00054	51		 push	 ecx
  00055	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0005b	66 0f 6e 45 08	 movd	 xmm0, DWORD PTR _iXPos$[ebp]
  00060	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00063	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00068	ff 10		 call	 DWORD PTR [eax]

; 2091 : 
; 2092 : 	// 
; 2093 : 	int i = 0;
; 2094 : 	int iMaxUserLineTitle = m_iMaxLine / m_iLinePlayer;

  0006a	8b 87 74 02 00
	00		 mov	 eax, DWORD PTR [edi+628]
  00070	99		 cdq
  00071	f7 bf 78 02 00
	00		 idiv	 DWORD PTR [edi+632]

; 2095 : 	for(i = 0;i < iMaxUserLineTitle;i++)

  00077	89 75 fc	 mov	 DWORD PTR _i$[ebp], esi
  0007a	89 45 f4	 mov	 DWORD PTR _iMaxUserLineTitle$[ebp], eax
  0007d	3b c6		 cmp	 eax, esi
  0007f	0f 8e ed 01 00
	00		 jle	 $LN12@OnRenderFi@3
  00085	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  0008b	83 c3 3e	 add	 ebx, 62			; 0000003eH
  0008e	0f 57 c0	 xorps	 xmm0, xmm0
  00091	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  00095	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?PrintText@ioFontManager@@QAAXMMMPBDZZ
  0009b	f3 0f 11 45 f8	 movss	 DWORD PTR tv481[ebp], xmm0
$LL14@OnRenderFi@3:

; 2096 : 	{
; 2097 : 		g_FontMgr.SetBkColor( 0, 0, 0 );

  000a0	33 c0		 xor	 eax, eax
  000a2	50		 push	 eax
  000a3	50		 push	 eax
  000a4	50		 push	 eax
  000a5	ff d6		 call	 esi
  000a7	8b c8		 mov	 ecx, eax
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetBkColor@ioFontManager@@QAEXHHH@Z

; 2098 : 		g_FontMgr.SetTextStyle( TS_NORMAL );

  000af	6a 00		 push	 0
  000b1	ff d6		 call	 esi
  000b3	8b c8		 mov	 ecx, eax
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextStyle@ioFontManager@@QAEXW4TextStyle@@@Z

; 2099 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_RED );

  000bb	68 00 16 b9 ff	 push	 -4647424		; ffb91600H
  000c0	ff d6		 call	 esi
  000c2	8b c8		 mov	 ecx, eax
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextColor@ioFontManager@@QAEXK@Z

; 2100 : 
; 2101 : 		g_FontMgr.SetAlignType( TAT_LEFT );

  000ca	6a 00		 push	 0
  000cc	ff d6		 call	 esi
  000ce	8b c8		 mov	 ecx, eax
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 2102 : 		g_FontMgr.PrintText( iXPos + 12 + i * m_iLinePlayerGap, iYPos + 62, FONT_SIZE_12, STR(1) );

  000d6	6a 00		 push	 0
  000d8	6a 01		 push	 1
  000da	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  000df	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@FJHKMHEN@RoundStateUserWnd?3?3OnRenderFight@
  000e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  000ea	8b c8		 mov	 ecx, eax
  000ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  000f2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  000fd	50		 push	 eax
  000fe	8b 87 7c 02 00
	00		 mov	 eax, DWORD PTR [edi+636]
  00104	0f af 45 fc	 imul	 eax, DWORD PTR _i$[ebp]
  00108	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0010b	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00111	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv481[ebp]
  00116	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0011c	8d 44 08 0c	 lea	 eax, DWORD PTR [eax+ecx+12]
  00120	0f 57 c0	 xorps	 xmm0, xmm0
  00123	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00127	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0012c	ff d6		 call	 esi
  0012e	50		 push	 eax
  0012f	ff d3		 call	 ebx
  00131	83 c4 14	 add	 esp, 20			; 00000014H

; 2103 : 
; 2104 : 		g_FontMgr.SetAlignType( TAT_CENTER );

  00134	6a 01		 push	 1
  00136	ff d6		 call	 esi
  00138	8b c8		 mov	 ecx, eax
  0013a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 2105 : 		g_FontMgr.PrintText( iXPos + 219 + i * m_iLinePlayerGap, iYPos + 62, FONT_SIZE_12, STR(2) );

  00140	6a 00		 push	 0
  00142	6a 02		 push	 2
  00144	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00149	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@FJHKMHEN@RoundStateUserWnd?3?3OnRenderFight@
  0014e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00154	8b c8		 mov	 ecx, eax
  00156	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0015c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00164	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  00167	50		 push	 eax
  00168	8b 87 7c 02 00
	00		 mov	 eax, DWORD PTR [edi+636]
  0016e	0f af 45 fc	 imul	 eax, DWORD PTR _i$[ebp]
  00172	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00175	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  0017b	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv481[ebp]
  00180	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00186	8d 84 08 db 00
	00 00		 lea	 eax, DWORD PTR [eax+ecx+219]
  0018d	0f 57 c0	 xorps	 xmm0, xmm0
  00190	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00194	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00199	ff d6		 call	 esi
  0019b	50		 push	 eax
  0019c	ff d3		 call	 ebx
  0019e	83 c4 14	 add	 esp, 20			; 00000014H

; 2106 : 		g_FontMgr.PrintText( iXPos + 261 + i * m_iLinePlayerGap, iYPos + 62, FONT_SIZE_12, STR(3) );

  001a1	6a 00		 push	 0
  001a3	6a 03		 push	 3
  001a5	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  001aa	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@FJHKMHEN@RoundStateUserWnd?3?3OnRenderFight@
  001af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  001b5	8b c8		 mov	 ecx, eax
  001b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  001bd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  001c5	50		 push	 eax
  001c6	83 ec 0c	 sub	 esp, 12			; 0000000cH
  001c9	8b 87 7c 02 00
	00		 mov	 eax, DWORD PTR [edi+636]
  001cf	0f af 45 fc	 imul	 eax, DWORD PTR _i$[ebp]
  001d3	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  001d6	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  001dc	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv481[ebp]
  001e1	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  001e7	8d 84 08 05 01
	00 00		 lea	 eax, DWORD PTR [eax+ecx+261]
  001ee	0f 57 c0	 xorps	 xmm0, xmm0
  001f1	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001f5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001fa	ff d6		 call	 esi
  001fc	50		 push	 eax
  001fd	ff d3		 call	 ebx
  001ff	83 c4 14	 add	 esp, 20			; 00000014H

; 2107 : 		g_FontMgr.PrintText( iXPos + 294 + i * m_iLinePlayerGap, iYPos + 62, FONT_SIZE_12, STR(4) );

  00202	6a 00		 push	 0
  00204	6a 04		 push	 4
  00206	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0020b	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@FJHKMHEN@RoundStateUserWnd?3?3OnRenderFight@
  00210	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00216	8b c8		 mov	 ecx, eax
  00218	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0021e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00226	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  00229	50		 push	 eax
  0022a	8b 87 7c 02 00
	00		 mov	 eax, DWORD PTR [edi+636]
  00230	0f af 45 fc	 imul	 eax, DWORD PTR _i$[ebp]
  00234	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00237	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  0023d	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv481[ebp]
  00242	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00248	8d 84 08 26 01
	00 00		 lea	 eax, DWORD PTR [eax+ecx+294]
  0024f	0f 57 c0	 xorps	 xmm0, xmm0
  00252	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00256	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0025b	ff d6		 call	 esi
  0025d	50		 push	 eax
  0025e	ff d3		 call	 ebx
  00260	83 c4 14	 add	 esp, 20			; 00000014H
  00263	ff 45 fc	 inc	 DWORD PTR _i$[ebp]
  00266	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00269	3b 45 f4	 cmp	 eax, DWORD PTR _iMaxUserLineTitle$[ebp]
  0026c	0f 8c 2e fe ff
	ff		 jl	 $LL14@OnRenderFi@3
$LN12@OnRenderFi@3:

; 2111 : 	int iRealYPos = iYPos + m_iLineStartY;
; 2112 : 	int iSize = m_RoundInfoList.size();

  00272	8b 87 9c 02 00
	00		 mov	 eax, DWORD PTR [edi+668]
  00278	2b 87 98 02 00
	00		 sub	 eax, DWORD PTR [edi+664]
  0027e	8b b7 80 02 00
	00		 mov	 esi, DWORD PTR [edi+640]
  00284	8b 9f 84 02 00
	00		 mov	 ebx, DWORD PTR [edi+644]
  0028a	03 75 08	 add	 esi, DWORD PTR _iXPos$[ebp]
  0028d	03 5d 0c	 add	 ebx, DWORD PTR _iYPos$[ebp]
  00290	c1 f8 07	 sar	 eax, 7

; 2113 : 	for(i = 0;i < iSize;i++)

  00293	33 d2		 xor	 edx, edx
  00295	89 45 f0	 mov	 DWORD PTR _iSize$[ebp], eax
  00298	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
  0029b	3b c2		 cmp	 eax, edx
  0029d	0f 8e 8f 01 00
	00		 jle	 $LN41@OnRenderFi@3

; 2108 : 	}
; 2109 : 
; 2110 : 	int iRealXPos = iXPos + m_iLineStartX;

  002a3	89 55 f8	 mov	 DWORD PTR tv627[ebp], edx
  002a6	eb 02		 jmp	 SHORT $LN11@OnRenderFi@3
$LL36@OnRenderFi@3:
  002a8	33 d2		 xor	 edx, edx
$LN11@OnRenderFi@3:

; 2113 : 	for(i = 0;i < iSize;i++)

  002aa	8b 87 98 02 00
	00		 mov	 eax, DWORD PTR [edi+664]
  002b0	03 45 f8	 add	 eax, DWORD PTR tv627[ebp]

; 2114 : 	{
; 2115 : 		RoundInfo &rkInfo = m_RoundInfoList[i];
; 2116 : 
; 2117 : 		if( rkInfo.m_bOwner )

  002b3	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  002b7	89 45 08	 mov	 DWORD PTR _rkInfo$550419[ebp], eax
  002ba	74 1d		 je	 SHORT $LN8@OnRenderFi@3

; 2118 : 		{
; 2119 : 			if( rkInfo.m_Team == TEAM_BLUE )

  002bc	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  002bf	83 f9 02	 cmp	 ecx, 2
  002c2	75 08		 jne	 SHORT $LN7@OnRenderFi@3

; 2120 : 				m_pBlueOver->Render( iRealXPos, iRealYPos );

  002c4	8b 8f 70 01 00
	00		 mov	 ecx, DWORD PTR [edi+368]
  002ca	eb 1e		 jmp	 SHORT $LN42@OnRenderFi@3
$LN7@OnRenderFi@3:

; 2121 : 			else if( rkInfo.m_Team == TEAM_RED )

  002cc	83 f9 01	 cmp	 ecx, 1
  002cf	75 3f		 jne	 SHORT $LN40@OnRenderFi@3

; 2122 : 				m_pRedOver->Render( iRealXPos, iRealYPos );

  002d1	8b 8f 7c 01 00
	00		 mov	 ecx, DWORD PTR [edi+380]

; 2123 : 		}

  002d7	eb 11		 jmp	 SHORT $LN42@OnRenderFi@3
$LN8@OnRenderFi@3:

; 2124 : 		else if( m_MouseOverIndex == i )

  002d9	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  002dc	39 8f 5c 02 00
	00		 cmp	 DWORD PTR [edi+604], ecx
  002e2	75 37		 jne	 SHORT $LN35@OnRenderFi@3

; 2125 : 			m_pCurrentOver->Render( iRealXPos, iRealYPos );

  002e4	8b 8f 44 02 00
	00		 mov	 ecx, DWORD PTR [edi+580]
$LN42@OnRenderFi@3:
  002ea	8b 01		 mov	 eax, DWORD PTR [ecx]
  002ec	52		 push	 edx
  002ed	52		 push	 edx
  002ee	52		 push	 edx
  002ef	52		 push	 edx
  002f0	51		 push	 ecx
  002f1	0f 57 c0	 xorps	 xmm0, xmm0
  002f4	51		 push	 ecx
  002f5	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  002f9	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  002ff	0f 57 c0	 xorps	 xmm0, xmm0
  00302	f3 0f 2a c6	 cvtsi2ss xmm0, esi
  00306	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0030b	ff 10		 call	 DWORD PTR [eax]
  0030d	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550419[ebp]
$LN40@OnRenderFi@3:

; 2126 : 
; 2127 : 		// 계급 & 아이디
; 2128 : 		int iWidth = OnRenderGradeAndNick( rkInfo, iRealXPos + 4, iRealYPos + 2, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  00310	8b 8f 5c 02 00
	00		 mov	 ecx, DWORD PTR [edi+604]
  00316	3b 4d fc	 cmp	 ecx, DWORD PTR _i$[ebp]
  00319	74 0a		 je	 SHORT $LN19@OnRenderFi@3
$LN35@OnRenderFi@3:
  0031b	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  0031f	75 04		 jne	 SHORT $LN19@OnRenderFi@3
  00321	32 d2		 xor	 dl, dl
  00323	eb 03		 jmp	 SHORT $LN20@OnRenderFi@3
$LN19@OnRenderFi@3:
  00325	33 d2		 xor	 edx, edx
  00327	42		 inc	 edx
$LN20@OnRenderFi@3:
  00328	52		 push	 edx
  00329	8d 4b 02	 lea	 ecx, DWORD PTR [ebx+2]
  0032c	51		 push	 ecx
  0032d	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00330	51		 push	 ecx
  00331	50		 push	 eax
  00332	8b cf		 mov	 ecx, edi
  00334	e8 00 00 00 00	 call	 ?OnRenderGradeAndNick@RoundStateUserWnd@@IAEHABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderGradeAndNick

; 2129 : 
; 2130 : 		// 길드 마크
; 2131 : 		iWidth += OnRenderGuildMark( rkInfo, iRealXPos + 4 + iWidth, iRealYPos + 4 );

  00339	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  0033c	51		 push	 ecx
  0033d	89 45 f4	 mov	 DWORD PTR _iWidth$550426[ebp], eax
  00340	8d 44 30 04	 lea	 eax, DWORD PTR [eax+esi+4]
  00344	50		 push	 eax
  00345	ff 75 08	 push	 DWORD PTR _rkInfo$550419[ebp]
  00348	8b cf		 mov	 ecx, edi
  0034a	e8 00 00 00 00	 call	 ?OnRenderGuildMark@RoundStateUserWnd@@IAEHABURoundInfo@@HH@Z ; RoundStateUserWnd::OnRenderGuildMark
  0034f	8b 4d f4	 mov	 ecx, DWORD PTR _iWidth$550426[ebp]
  00352	03 c8		 add	 ecx, eax

; 2132 : 
; 2133 : 		// 보너스
; 2134 : 		OnRenderBonus( rkInfo, iRealXPos + iWidth + 7, iRealYPos + 3 );

  00354	8d 43 03	 lea	 eax, DWORD PTR [ebx+3]
  00357	50		 push	 eax
  00358	8d 44 31 07	 lea	 eax, DWORD PTR [ecx+esi+7]
  0035c	50		 push	 eax
  0035d	ff 75 08	 push	 DWORD PTR _rkInfo$550419[ebp]
  00360	8b cf		 mov	 ecx, edi
  00362	e8 00 00 00 00	 call	 ?OnRenderBonus@RoundStateUserWnd@@IAEXABURoundInfo@@HH@Z ; RoundStateUserWnd::OnRenderBonus

; 2135 : 
; 2136 : 		// 승
; 2137 : 		OnRenderFightWin( rkInfo, iRealXPos + 212, iRealYPos + 3, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  00367	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0036a	39 87 5c 02 00
	00		 cmp	 DWORD PTR [edi+604], eax
  00370	74 0d		 je	 SHORT $LN37@OnRenderFi@3
  00372	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550419[ebp]
  00375	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  00379	75 04		 jne	 SHORT $LN37@OnRenderFi@3
  0037b	32 c0		 xor	 al, al
  0037d	eb 03		 jmp	 SHORT $LN22@OnRenderFi@3
$LN37@OnRenderFi@3:
  0037f	33 c0		 xor	 eax, eax
  00381	40		 inc	 eax
$LN22@OnRenderFi@3:
  00382	50		 push	 eax
  00383	8d 43 03	 lea	 eax, DWORD PTR [ebx+3]
  00386	50		 push	 eax
  00387	8d 86 d4 00 00
	00		 lea	 eax, DWORD PTR [esi+212]
  0038d	50		 push	 eax
  0038e	ff 75 08	 push	 DWORD PTR _rkInfo$550419[ebp]
  00391	8b cf		 mov	 ecx, edi
  00393	e8 00 00 00 00	 call	 ?OnRenderFightWin@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderFightWin

; 2138 : 
; 2139 : 		// 패
; 2140 : 		OnRenderFightLose( rkInfo, iRealXPos + 254, iRealYPos + 3, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  00398	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0039b	39 87 5c 02 00
	00		 cmp	 DWORD PTR [edi+604], eax
  003a1	74 0d		 je	 SHORT $LN38@OnRenderFi@3
  003a3	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550419[ebp]
  003a6	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  003aa	75 04		 jne	 SHORT $LN38@OnRenderFi@3
  003ac	32 c0		 xor	 al, al
  003ae	eb 03		 jmp	 SHORT $LN24@OnRenderFi@3
$LN38@OnRenderFi@3:
  003b0	33 c0		 xor	 eax, eax
  003b2	40		 inc	 eax
$LN24@OnRenderFi@3:
  003b3	50		 push	 eax
  003b4	8d 43 03	 lea	 eax, DWORD PTR [ebx+3]
  003b7	50		 push	 eax
  003b8	8d 86 fe 00 00
	00		 lea	 eax, DWORD PTR [esi+254]
  003be	50		 push	 eax
  003bf	ff 75 08	 push	 DWORD PTR _rkInfo$550419[ebp]
  003c2	8b cf		 mov	 ecx, edi
  003c4	e8 00 00 00 00	 call	 ?OnRenderFightLose@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderFightLose

; 2141 : 
; 2142 : 		// 핑
; 2143 : 		OnRenderPing( rkInfo, iRealXPos + 275, iRealYPos + 2, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  003c9	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  003cc	39 87 5c 02 00
	00		 cmp	 DWORD PTR [edi+604], eax
  003d2	74 0d		 je	 SHORT $LN39@OnRenderFi@3
  003d4	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550419[ebp]
  003d7	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  003db	75 04		 jne	 SHORT $LN39@OnRenderFi@3
  003dd	32 c0		 xor	 al, al
  003df	eb 03		 jmp	 SHORT $LN26@OnRenderFi@3
$LN39@OnRenderFi@3:
  003e1	33 c0		 xor	 eax, eax
  003e3	40		 inc	 eax
$LN26@OnRenderFi@3:
  003e4	50		 push	 eax
  003e5	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
  003e8	50		 push	 eax
  003e9	8d 86 13 01 00
	00		 lea	 eax, DWORD PTR [esi+275]
  003ef	50		 push	 eax
  003f0	ff 75 08	 push	 DWORD PTR _rkInfo$550419[ebp]
  003f3	8b cf		 mov	 ecx, edi
  003f5	e8 00 00 00 00	 call	 ?OnRenderPing@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderPing

; 2144 : 
; 2145 : 		//
; 2146 : 		if( 0 == ( i + 1 ) % m_iLinePlayer )

  003fa	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  003fd	41		 inc	 ecx
  003fe	8b c1		 mov	 eax, ecx
  00400	99		 cdq
  00401	f7 bf 78 02 00
	00		 idiv	 DWORD PTR [edi+632]
  00407	85 d2		 test	 edx, edx
  00409	75 11		 jne	 SHORT $LN2@OnRenderFi@3

; 2147 : 		{
; 2148 : 			iRealXPos += m_iLinePlayerGap;
; 2149 : 			iRealYPos = iYPos + m_iLineStartY;

  0040b	8b 9f 84 02 00
	00		 mov	 ebx, DWORD PTR [edi+644]
  00411	03 b7 7c 02 00
	00		 add	 esi, DWORD PTR [edi+636]
  00417	03 5d 0c	 add	 ebx, DWORD PTR _iYPos$[ebp]

; 2150 : 		}
; 2151 : 		else

  0041a	eb 06		 jmp	 SHORT $LN10@OnRenderFi@3
$LN2@OnRenderFi@3:

; 2152 : 		{
; 2153 : 			iRealYPos += m_iLineHeight;

  0041c	03 9f 8c 02 00
	00		 add	 ebx, DWORD PTR [edi+652]
$LN10@OnRenderFi@3:

; 2113 : 	for(i = 0;i < iSize;i++)

  00422	83 6d f8 80	 sub	 DWORD PTR tv627[ebp], -128 ; ffffff80H
  00426	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  00429	3b 4d f0	 cmp	 ecx, DWORD PTR _iSize$[ebp]
  0042c	0f 8c 76 fe ff
	ff		 jl	 $LL36@OnRenderFi@3
$LN41@OnRenderFi@3:
  00432	5b		 pop	 ebx
$LN15@OnRenderFi@3:
  00433	5f		 pop	 edi
  00434	5e		 pop	 esi

; 2154 : 		}
; 2155 : 	}
; 2156 : }

  00435	c9		 leave
  00436	c2 08 00	 ret	 8
?OnRenderFightClubUser@RoundStateUserWnd@@IAEXHH@Z ENDP	; RoundStateUserWnd::OnRenderFightClubUser
_TEXT	ENDS
PUBLIC	??_C@_0CM@KPJEDKJK@RoundStateUserWnd?3?3OnRenderShuff@ ; `string'
PUBLIC	?OnRenderShuffleBonusUser@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderShuffleBonusUser
;	COMDAT ??_C@_0CM@KPJEDKJK@RoundStateUserWnd?3?3OnRenderShuff@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
CONST	SEGMENT
??_C@_0CM@KPJEDKJK@RoundStateUserWnd?3?3OnRenderShuff@ DB 'RoundStateUser'
	DB	'Wnd::OnRenderShuffleBonusUser', 00H		; `string'
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
CONST	ENDS
;	COMDAT ?OnRenderShuffleBonusUser@RoundStateUserWnd@@IAEXHH@Z
_TEXT	SEGMENT
_iSize$ = -16						; size = 4
_iWidth$550457 = -12					; size = 4
_iMaxUserLineTitle$ = -12				; size = 4
tv593 = -8						; size = 4
tv449 = -8						; size = 4
_i$550446 = -4						; size = 4
_i$550437 = -4						; size = 4
_rkInfo$550450 = 8					; size = 4
_iXPos$ = 8						; size = 4
_iYPos$ = 12						; size = 4
?OnRenderShuffleBonusUser@RoundStateUserWnd@@IAEXHH@Z PROC ; RoundStateUserWnd::OnRenderShuffleBonusUser, COMDAT
; _this$ = ecx

; 2159 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx

; 2160 : 	if( !m_pCurrentOver || !m_pBlueOver || !m_pRedOver || !m_pRedVert ) return;

  0000a	33 f6		 xor	 esi, esi
  0000c	39 b7 44 02 00
	00		 cmp	 DWORD PTR [edi+580], esi
  00012	0f 84 89 03 00
	00		 je	 $LN15@OnRenderSh
  00018	39 b7 70 01 00
	00		 cmp	 DWORD PTR [edi+368], esi
  0001e	0f 84 7d 03 00
	00		 je	 $LN15@OnRenderSh
  00024	39 b7 7c 01 00
	00		 cmp	 DWORD PTR [edi+380], esi
  0002a	0f 84 71 03 00
	00		 je	 $LN15@OnRenderSh
  00030	39 b7 c0 01 00
	00		 cmp	 DWORD PTR [edi+448], esi
  00036	0f 84 65 03 00
	00		 je	 $LN15@OnRenderSh

; 2161 : 
; 2162 : 	m_pRedVert->Render( iXPos, iYPos );//중앙선

  0003c	8b 8f c0 01 00
	00		 mov	 ecx, DWORD PTR [edi+448]
  00042	8b 01		 mov	 eax, DWORD PTR [ecx]
  00044	53		 push	 ebx
  00045	8b 5d 0c	 mov	 ebx, DWORD PTR _iYPos$[ebp]
  00048	56		 push	 esi
  00049	56		 push	 esi
  0004a	56		 push	 esi
  0004b	56		 push	 esi
  0004c	0f 57 c0	 xorps	 xmm0, xmm0
  0004f	51		 push	 ecx
  00050	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  00054	51		 push	 ecx
  00055	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0005b	66 0f 6e 45 08	 movd	 xmm0, DWORD PTR _iXPos$[ebp]
  00060	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00063	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00068	ff 10		 call	 DWORD PTR [eax]

; 2163 : 
; 2164 : 	// 
; 2165 : 	int iMaxUserLineTitle = m_iMaxLine / m_iLinePlayer;

  0006a	8b 87 74 02 00
	00		 mov	 eax, DWORD PTR [edi+628]
  00070	99		 cdq
  00071	f7 bf 78 02 00
	00		 idiv	 DWORD PTR [edi+632]

; 2166 : 	for( int i=0 ; i<iMaxUserLineTitle ; ++i )

  00077	89 75 fc	 mov	 DWORD PTR _i$550437[ebp], esi
  0007a	89 45 f4	 mov	 DWORD PTR _iMaxUserLineTitle$[ebp], eax
  0007d	3b c6		 cmp	 eax, esi
  0007f	0f 8e 8c 01 00
	00		 jle	 $LN12@OnRenderSh
  00085	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  0008b	83 c3 3e	 add	 ebx, 62			; 0000003eH
  0008e	0f 57 c0	 xorps	 xmm0, xmm0
  00091	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  00095	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?PrintText@ioFontManager@@QAAXMMMPBDZZ
  0009b	f3 0f 11 45 f8	 movss	 DWORD PTR tv449[ebp], xmm0
$LL14@OnRenderSh:

; 2167 : 	{
; 2168 : 		g_FontMgr.SetBkColor( 0, 0, 0 );

  000a0	33 c0		 xor	 eax, eax
  000a2	50		 push	 eax
  000a3	50		 push	 eax
  000a4	50		 push	 eax
  000a5	ff d6		 call	 esi
  000a7	8b c8		 mov	 ecx, eax
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetBkColor@ioFontManager@@QAEXHHH@Z

; 2169 : 		g_FontMgr.SetTextStyle( TS_NORMAL );

  000af	6a 00		 push	 0
  000b1	ff d6		 call	 esi
  000b3	8b c8		 mov	 ecx, eax
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextStyle@ioFontManager@@QAEXW4TextStyle@@@Z

; 2170 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_RED );

  000bb	68 00 16 b9 ff	 push	 -4647424		; ffb91600H
  000c0	ff d6		 call	 esi
  000c2	8b c8		 mov	 ecx, eax
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextColor@ioFontManager@@QAEXK@Z

; 2171 : 
; 2172 : 		g_FontMgr.SetAlignType( TAT_LEFT );

  000ca	6a 00		 push	 0
  000cc	ff d6		 call	 esi
  000ce	8b c8		 mov	 ecx, eax
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 2173 : 		g_FontMgr.PrintText( iXPos + 12 + i * m_iLinePlayerGap, iYPos + 62, FONT_SIZE_12, STR(1) );

  000d6	6a 00		 push	 0
  000d8	6a 01		 push	 1
  000da	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  000df	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@KPJEDKJK@RoundStateUserWnd?3?3OnRenderShuff@
  000e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  000ea	8b c8		 mov	 ecx, eax
  000ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  000f2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  000fd	50		 push	 eax
  000fe	8b 87 7c 02 00
	00		 mov	 eax, DWORD PTR [edi+636]
  00104	0f af 45 fc	 imul	 eax, DWORD PTR _i$550437[ebp]
  00108	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0010b	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00111	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv449[ebp]
  00116	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0011c	8d 44 08 0c	 lea	 eax, DWORD PTR [eax+ecx+12]
  00120	0f 57 c0	 xorps	 xmm0, xmm0
  00123	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00127	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0012c	ff d6		 call	 esi
  0012e	50		 push	 eax
  0012f	ff d3		 call	 ebx
  00131	83 c4 14	 add	 esp, 20			; 00000014H

; 2174 : 
; 2175 : 		g_FontMgr.SetAlignType( TAT_CENTER );

  00134	6a 01		 push	 1
  00136	ff d6		 call	 esi
  00138	8b c8		 mov	 ecx, eax
  0013a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 2176 : 		g_FontMgr.PrintText( iXPos + 261 + i * m_iLinePlayerGap, iYPos + 62, FONT_SIZE_12, STR(2) );

  00140	6a 00		 push	 0
  00142	6a 02		 push	 2
  00144	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00149	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@KPJEDKJK@RoundStateUserWnd?3?3OnRenderShuff@
  0014e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00154	8b c8		 mov	 ecx, eax
  00156	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0015c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00164	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  00167	50		 push	 eax
  00168	8b 87 7c 02 00
	00		 mov	 eax, DWORD PTR [edi+636]
  0016e	0f af 45 fc	 imul	 eax, DWORD PTR _i$550437[ebp]
  00172	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00175	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  0017b	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv449[ebp]
  00180	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00186	8d 84 08 05 01
	00 00		 lea	 eax, DWORD PTR [eax+ecx+261]
  0018d	0f 57 c0	 xorps	 xmm0, xmm0
  00190	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00194	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00199	ff d6		 call	 esi
  0019b	50		 push	 eax
  0019c	ff d3		 call	 ebx
  0019e	83 c4 14	 add	 esp, 20			; 00000014H

; 2177 : 		g_FontMgr.PrintText( iXPos + 294 + i * m_iLinePlayerGap, iYPos + 62, FONT_SIZE_12, STR(3) );

  001a1	6a 00		 push	 0
  001a3	6a 03		 push	 3
  001a5	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  001aa	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@KPJEDKJK@RoundStateUserWnd?3?3OnRenderShuff@
  001af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  001b5	8b c8		 mov	 ecx, eax
  001b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  001bd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  001c5	50		 push	 eax
  001c6	83 ec 0c	 sub	 esp, 12			; 0000000cH
  001c9	8b 87 7c 02 00
	00		 mov	 eax, DWORD PTR [edi+636]
  001cf	0f af 45 fc	 imul	 eax, DWORD PTR _i$550437[ebp]
  001d3	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  001d6	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  001dc	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv449[ebp]
  001e1	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  001e7	8d 84 08 26 01
	00 00		 lea	 eax, DWORD PTR [eax+ecx+294]
  001ee	0f 57 c0	 xorps	 xmm0, xmm0
  001f1	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001f5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001fa	ff d6		 call	 esi
  001fc	50		 push	 eax
  001fd	ff d3		 call	 ebx
  001ff	83 c4 14	 add	 esp, 20			; 00000014H
  00202	ff 45 fc	 inc	 DWORD PTR _i$550437[ebp]
  00205	8b 45 fc	 mov	 eax, DWORD PTR _i$550437[ebp]
  00208	3b 45 f4	 cmp	 eax, DWORD PTR _iMaxUserLineTitle$[ebp]
  0020b	0f 8c 8f fe ff
	ff		 jl	 $LL14@OnRenderSh
$LN12@OnRenderSh:

; 2181 : 	int iRealYPos = iYPos + m_iLineStartY;
; 2182 : 	int iSize = m_RoundInfoList.size();

  00211	8b 87 9c 02 00
	00		 mov	 eax, DWORD PTR [edi+668]
  00217	2b 87 98 02 00
	00		 sub	 eax, DWORD PTR [edi+664]
  0021d	8b b7 80 02 00
	00		 mov	 esi, DWORD PTR [edi+640]
  00223	8b 9f 84 02 00
	00		 mov	 ebx, DWORD PTR [edi+644]
  00229	03 75 08	 add	 esi, DWORD PTR _iXPos$[ebp]
  0022c	03 5d 0c	 add	 ebx, DWORD PTR _iYPos$[ebp]
  0022f	c1 f8 07	 sar	 eax, 7

; 2183 : 	for( int i=0 ; i<iSize ; ++i )

  00232	33 d2		 xor	 edx, edx
  00234	89 45 f0	 mov	 DWORD PTR _iSize$[ebp], eax
  00237	89 55 fc	 mov	 DWORD PTR _i$550446[ebp], edx
  0023a	3b c2		 cmp	 eax, edx
  0023c	0f 8e 5e 01 00
	00		 jle	 $LN38@OnRenderSh

; 2178 : 	}
; 2179 : 
; 2180 : 	int iRealXPos = iXPos + m_iLineStartX;

  00242	89 55 f8	 mov	 DWORD PTR tv593[ebp], edx
  00245	eb 02		 jmp	 SHORT $LN11@OnRenderSh
$LL34@OnRenderSh:
  00247	33 d2		 xor	 edx, edx
$LN11@OnRenderSh:

; 2183 : 	for( int i=0 ; i<iSize ; ++i )

  00249	8b 87 98 02 00
	00		 mov	 eax, DWORD PTR [edi+664]
  0024f	03 45 f8	 add	 eax, DWORD PTR tv593[ebp]

; 2184 : 	{
; 2185 : 		RoundInfo &rkInfo = m_RoundInfoList[i];
; 2186 : 
; 2187 : 		if( rkInfo.m_bOwner )

  00252	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  00256	89 45 08	 mov	 DWORD PTR _rkInfo$550450[ebp], eax
  00259	74 1d		 je	 SHORT $LN8@OnRenderSh

; 2188 : 		{
; 2189 : 			if( rkInfo.m_Team == TEAM_BLUE )

  0025b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0025e	83 f9 02	 cmp	 ecx, 2
  00261	75 08		 jne	 SHORT $LN7@OnRenderSh

; 2190 : 				m_pBlueOver->Render( iRealXPos, iRealYPos );

  00263	8b 8f 70 01 00
	00		 mov	 ecx, DWORD PTR [edi+368]
  00269	eb 1e		 jmp	 SHORT $LN39@OnRenderSh
$LN7@OnRenderSh:

; 2191 : 			else if( rkInfo.m_Team == TEAM_RED )

  0026b	83 f9 01	 cmp	 ecx, 1
  0026e	75 3f		 jne	 SHORT $LN37@OnRenderSh

; 2192 : 				m_pRedOver->Render( iRealXPos, iRealYPos );

  00270	8b 8f 7c 01 00
	00		 mov	 ecx, DWORD PTR [edi+380]

; 2193 : 		}

  00276	eb 11		 jmp	 SHORT $LN39@OnRenderSh
$LN8@OnRenderSh:

; 2194 : 		else if( m_MouseOverIndex == i )

  00278	8b 4d fc	 mov	 ecx, DWORD PTR _i$550446[ebp]
  0027b	39 8f 5c 02 00
	00		 cmp	 DWORD PTR [edi+604], ecx
  00281	75 37		 jne	 SHORT $LN33@OnRenderSh

; 2195 : 			m_pCurrentOver->Render( iRealXPos, iRealYPos );

  00283	8b 8f 44 02 00
	00		 mov	 ecx, DWORD PTR [edi+580]
$LN39@OnRenderSh:
  00289	8b 01		 mov	 eax, DWORD PTR [ecx]
  0028b	52		 push	 edx
  0028c	52		 push	 edx
  0028d	52		 push	 edx
  0028e	52		 push	 edx
  0028f	51		 push	 ecx
  00290	0f 57 c0	 xorps	 xmm0, xmm0
  00293	51		 push	 ecx
  00294	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  00298	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0029e	0f 57 c0	 xorps	 xmm0, xmm0
  002a1	f3 0f 2a c6	 cvtsi2ss xmm0, esi
  002a5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002aa	ff 10		 call	 DWORD PTR [eax]
  002ac	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550450[ebp]
$LN37@OnRenderSh:

; 2196 : 
; 2197 : 		// 계급 & 아이디
; 2198 : 		int iWidth = OnRenderGradeAndNick( rkInfo, iRealXPos + 4, iRealYPos + 2, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  002af	8b 8f 5c 02 00
	00		 mov	 ecx, DWORD PTR [edi+604]
  002b5	3b 4d fc	 cmp	 ecx, DWORD PTR _i$550446[ebp]
  002b8	74 0a		 je	 SHORT $LN19@OnRenderSh
$LN33@OnRenderSh:
  002ba	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  002be	75 04		 jne	 SHORT $LN19@OnRenderSh
  002c0	32 d2		 xor	 dl, dl
  002c2	eb 03		 jmp	 SHORT $LN20@OnRenderSh
$LN19@OnRenderSh:
  002c4	33 d2		 xor	 edx, edx
  002c6	42		 inc	 edx
$LN20@OnRenderSh:
  002c7	52		 push	 edx
  002c8	8d 4b 02	 lea	 ecx, DWORD PTR [ebx+2]
  002cb	51		 push	 ecx
  002cc	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  002cf	51		 push	 ecx
  002d0	50		 push	 eax
  002d1	8b cf		 mov	 ecx, edi
  002d3	e8 00 00 00 00	 call	 ?OnRenderGradeAndNick@RoundStateUserWnd@@IAEHABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderGradeAndNick

; 2199 : 
; 2200 : 		// 길드 마크
; 2201 : 		iWidth += OnRenderGuildMark( rkInfo, iRealXPos + 4 + iWidth, iRealYPos + 4 );

  002d8	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  002db	51		 push	 ecx
  002dc	89 45 f4	 mov	 DWORD PTR _iWidth$550457[ebp], eax
  002df	8d 44 30 04	 lea	 eax, DWORD PTR [eax+esi+4]
  002e3	50		 push	 eax
  002e4	ff 75 08	 push	 DWORD PTR _rkInfo$550450[ebp]
  002e7	8b cf		 mov	 ecx, edi
  002e9	e8 00 00 00 00	 call	 ?OnRenderGuildMark@RoundStateUserWnd@@IAEHABURoundInfo@@HH@Z ; RoundStateUserWnd::OnRenderGuildMark
  002ee	8b 4d f4	 mov	 ecx, DWORD PTR _iWidth$550457[ebp]
  002f1	03 c8		 add	 ecx, eax

; 2202 : 
; 2203 : 		// 보너스
; 2204 : 		OnRenderBonus( rkInfo, iRealXPos + iWidth + 7, iRealYPos + 3 );

  002f3	8d 43 03	 lea	 eax, DWORD PTR [ebx+3]
  002f6	50		 push	 eax
  002f7	8d 44 31 07	 lea	 eax, DWORD PTR [ecx+esi+7]
  002fb	50		 push	 eax
  002fc	ff 75 08	 push	 DWORD PTR _rkInfo$550450[ebp]
  002ff	8b cf		 mov	 ecx, edi
  00301	e8 00 00 00 00	 call	 ?OnRenderBonus@RoundStateUserWnd@@IAEXABURoundInfo@@HH@Z ; RoundStateUserWnd::OnRenderBonus

; 2205 : 
; 2206 : 		// 별 갯수
; 2207 : 		OnRenderStarCount( rkInfo, iRealXPos + 254, iRealYPos + 3, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  00306	8b 45 fc	 mov	 eax, DWORD PTR _i$550446[ebp]
  00309	39 87 5c 02 00
	00		 cmp	 DWORD PTR [edi+604], eax
  0030f	74 0d		 je	 SHORT $LN35@OnRenderSh
  00311	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550450[ebp]
  00314	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  00318	75 04		 jne	 SHORT $LN35@OnRenderSh
  0031a	32 c0		 xor	 al, al
  0031c	eb 03		 jmp	 SHORT $LN22@OnRenderSh
$LN35@OnRenderSh:
  0031e	33 c0		 xor	 eax, eax
  00320	40		 inc	 eax
$LN22@OnRenderSh:
  00321	50		 push	 eax
  00322	8d 43 03	 lea	 eax, DWORD PTR [ebx+3]
  00325	50		 push	 eax
  00326	8d 86 fe 00 00
	00		 lea	 eax, DWORD PTR [esi+254]
  0032c	50		 push	 eax
  0032d	ff 75 08	 push	 DWORD PTR _rkInfo$550450[ebp]
  00330	8b cf		 mov	 ecx, edi
  00332	e8 00 00 00 00	 call	 ?OnRenderStarCount@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderStarCount

; 2208 : 
; 2209 : 		// 핑
; 2210 : 		OnRenderPing( rkInfo, iRealXPos + 275, iRealYPos + 2, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  00337	8b 45 fc	 mov	 eax, DWORD PTR _i$550446[ebp]
  0033a	39 87 5c 02 00
	00		 cmp	 DWORD PTR [edi+604], eax
  00340	74 0d		 je	 SHORT $LN36@OnRenderSh
  00342	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550450[ebp]
  00345	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  00349	75 04		 jne	 SHORT $LN36@OnRenderSh
  0034b	32 c0		 xor	 al, al
  0034d	eb 03		 jmp	 SHORT $LN24@OnRenderSh
$LN36@OnRenderSh:
  0034f	33 c0		 xor	 eax, eax
  00351	40		 inc	 eax
$LN24@OnRenderSh:
  00352	50		 push	 eax
  00353	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
  00356	50		 push	 eax
  00357	8d 86 13 01 00
	00		 lea	 eax, DWORD PTR [esi+275]
  0035d	50		 push	 eax
  0035e	ff 75 08	 push	 DWORD PTR _rkInfo$550450[ebp]
  00361	8b cf		 mov	 ecx, edi
  00363	e8 00 00 00 00	 call	 ?OnRenderPing@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderPing

; 2211 : 
; 2212 : 		//
; 2213 : 		if( 0 == ( i + 1 ) % m_iLinePlayer )

  00368	8b 4d fc	 mov	 ecx, DWORD PTR _i$550446[ebp]
  0036b	41		 inc	 ecx
  0036c	8b c1		 mov	 eax, ecx
  0036e	99		 cdq
  0036f	f7 bf 78 02 00
	00		 idiv	 DWORD PTR [edi+632]
  00375	85 d2		 test	 edx, edx
  00377	75 11		 jne	 SHORT $LN2@OnRenderSh

; 2214 : 		{
; 2215 : 			iRealXPos += m_iLinePlayerGap;
; 2216 : 			iRealYPos = iYPos + m_iLineStartY;

  00379	8b 9f 84 02 00
	00		 mov	 ebx, DWORD PTR [edi+644]
  0037f	03 b7 7c 02 00
	00		 add	 esi, DWORD PTR [edi+636]
  00385	03 5d 0c	 add	 ebx, DWORD PTR _iYPos$[ebp]

; 2217 : 		}
; 2218 : 		else

  00388	eb 06		 jmp	 SHORT $LN10@OnRenderSh
$LN2@OnRenderSh:

; 2219 : 		{
; 2220 : 			iRealYPos += m_iLineHeight;

  0038a	03 9f 8c 02 00
	00		 add	 ebx, DWORD PTR [edi+652]
$LN10@OnRenderSh:

; 2183 : 	for( int i=0 ; i<iSize ; ++i )

  00390	83 6d f8 80	 sub	 DWORD PTR tv593[ebp], -128 ; ffffff80H
  00394	89 4d fc	 mov	 DWORD PTR _i$550446[ebp], ecx
  00397	3b 4d f0	 cmp	 ecx, DWORD PTR _iSize$[ebp]
  0039a	0f 8c a7 fe ff
	ff		 jl	 $LL34@OnRenderSh
$LN38@OnRenderSh:
  003a0	5b		 pop	 ebx
$LN15@OnRenderSh:
  003a1	5f		 pop	 edi
  003a2	5e		 pop	 esi

; 2221 : 		}
; 2222 : 	}
; 2223 : }

  003a3	c9		 leave
  003a4	c2 08 00	 ret	 8
?OnRenderShuffleBonusUser@RoundStateUserWnd@@IAEXHH@Z ENDP ; RoundStateUserWnd::OnRenderShuffleBonusUser
_TEXT	ENDS
PUBLIC	??_C@_0CE@FOJFJJHH@RoundStateUserWnd?3?3OnRenderRaidU@ ; `string'
PUBLIC	?OnRenderRaidUser@RoundStateUserWnd@@IAEXHH@Z	; RoundStateUserWnd::OnRenderRaidUser
;	COMDAT ??_C@_0CE@FOJFJJHH@RoundStateUserWnd?3?3OnRenderRaidU@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
CONST	SEGMENT
??_C@_0CE@FOJFJJHH@RoundStateUserWnd?3?3OnRenderRaidU@ DB 'RoundStateUser'
	DB	'Wnd::OnRenderRaidUser', 00H			; `string'
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
CONST	ENDS
;	COMDAT ?OnRenderRaidUser@RoundStateUserWnd@@IAEXHH@Z
_TEXT	SEGMENT
_iSize$ = -16						; size = 4
_iWidth$550487 = -12					; size = 4
_iMaxUserLineTitle$ = -12				; size = 4
tv662 = -8						; size = 4
tv513 = -8						; size = 4
_i$ = -4						; size = 4
_rkInfo$550480 = 8					; size = 4
_iXPos$ = 8						; size = 4
_iYPos$ = 12						; size = 4
?OnRenderRaidUser@RoundStateUserWnd@@IAEXHH@Z PROC	; RoundStateUserWnd::OnRenderRaidUser, COMDAT
; _this$ = ecx

; 2226 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx

; 2227 : 	if( !m_pCurrentOver || !m_pBlueOver || !m_pRedOver || !m_pBlueVert ) return;

  0000a	33 f6		 xor	 esi, esi
  0000c	39 b7 44 02 00
	00		 cmp	 DWORD PTR [edi+580], esi
  00012	0f 84 91 04 00
	00		 je	 $LN15@OnRenderRa@2
  00018	39 b7 70 01 00
	00		 cmp	 DWORD PTR [edi+368], esi
  0001e	0f 84 85 04 00
	00		 je	 $LN15@OnRenderRa@2
  00024	39 b7 7c 01 00
	00		 cmp	 DWORD PTR [edi+380], esi
  0002a	0f 84 79 04 00
	00		 je	 $LN15@OnRenderRa@2
  00030	39 b7 bc 01 00
	00		 cmp	 DWORD PTR [edi+444], esi
  00036	0f 84 6d 04 00
	00		 je	 $LN15@OnRenderRa@2

; 2228 : 
; 2229 : 	m_pBlueVert->Render( iXPos, iYPos );//중앙선

  0003c	8b 8f bc 01 00
	00		 mov	 ecx, DWORD PTR [edi+444]
  00042	8b 01		 mov	 eax, DWORD PTR [ecx]
  00044	53		 push	 ebx
  00045	8b 5d 0c	 mov	 ebx, DWORD PTR _iYPos$[ebp]
  00048	56		 push	 esi
  00049	56		 push	 esi
  0004a	56		 push	 esi
  0004b	56		 push	 esi
  0004c	0f 57 c0	 xorps	 xmm0, xmm0
  0004f	51		 push	 ecx
  00050	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  00054	51		 push	 ecx
  00055	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0005b	66 0f 6e 45 08	 movd	 xmm0, DWORD PTR _iXPos$[ebp]
  00060	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00063	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00068	ff 10		 call	 DWORD PTR [eax]

; 2230 : 
; 2231 : 	// 
; 2232 : 	int i = 0;
; 2233 : 	int iMaxUserLineTitle = m_iMaxLine / m_iLinePlayer;

  0006a	8b 87 74 02 00
	00		 mov	 eax, DWORD PTR [edi+628]
  00070	99		 cdq
  00071	f7 bf 78 02 00
	00		 idiv	 DWORD PTR [edi+632]

; 2234 : 	for(i = 0;i < iMaxUserLineTitle;i++)

  00077	89 75 fc	 mov	 DWORD PTR _i$[ebp], esi
  0007a	89 45 f4	 mov	 DWORD PTR _iMaxUserLineTitle$[ebp], eax
  0007d	3b c6		 cmp	 eax, esi
  0007f	0f 8e 4e 02 00
	00		 jle	 $LN12@OnRenderRa@2
  00085	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  0008b	83 c3 3e	 add	 ebx, 62			; 0000003eH
  0008e	0f 57 c0	 xorps	 xmm0, xmm0
  00091	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  00095	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?PrintText@ioFontManager@@QAAXMMMPBDZZ
  0009b	f3 0f 11 45 f8	 movss	 DWORD PTR tv513[ebp], xmm0
$LL14@OnRenderRa@2:

; 2235 : 	{
; 2236 : 		g_FontMgr.SetBkColor( 0, 0, 0 );

  000a0	33 c0		 xor	 eax, eax
  000a2	50		 push	 eax
  000a3	50		 push	 eax
  000a4	50		 push	 eax
  000a5	ff d6		 call	 esi
  000a7	8b c8		 mov	 ecx, eax
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetBkColor@ioFontManager@@QAEXHHH@Z

; 2237 : 		g_FontMgr.SetTextStyle( TS_NORMAL );

  000af	6a 00		 push	 0
  000b1	ff d6		 call	 esi
  000b3	8b c8		 mov	 ecx, eax
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextStyle@ioFontManager@@QAEXW4TextStyle@@@Z

; 2238 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_BLUE );

  000bb	68 b2 46 16 ff	 push	 -15317326		; ff1646b2H
  000c0	ff d6		 call	 esi
  000c2	8b c8		 mov	 ecx, eax
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextColor@ioFontManager@@QAEXK@Z

; 2239 : 
; 2240 : 		g_FontMgr.SetAlignType( TAT_LEFT );

  000ca	6a 00		 push	 0
  000cc	ff d6		 call	 esi
  000ce	8b c8		 mov	 ecx, eax
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 2241 : 		g_FontMgr.PrintText( iXPos + 12 + i * m_iLinePlayerGap, iYPos + 62, FONT_SIZE_12, STR(1) );

  000d6	6a 00		 push	 0
  000d8	6a 01		 push	 1
  000da	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  000df	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@FOJFJJHH@RoundStateUserWnd?3?3OnRenderRaidU@
  000e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  000ea	8b c8		 mov	 ecx, eax
  000ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  000f2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  000fd	50		 push	 eax
  000fe	8b 87 7c 02 00
	00		 mov	 eax, DWORD PTR [edi+636]
  00104	0f af 45 fc	 imul	 eax, DWORD PTR _i$[ebp]
  00108	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0010b	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00111	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv513[ebp]
  00116	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0011c	8d 44 08 0c	 lea	 eax, DWORD PTR [eax+ecx+12]
  00120	0f 57 c0	 xorps	 xmm0, xmm0
  00123	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00127	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0012c	ff d6		 call	 esi
  0012e	50		 push	 eax
  0012f	ff d3		 call	 ebx
  00131	83 c4 14	 add	 esp, 20			; 00000014H

; 2242 : 
; 2243 : 		g_FontMgr.SetAlignType( TAT_CENTER );

  00134	6a 01		 push	 1
  00136	ff d6		 call	 esi
  00138	8b c8		 mov	 ecx, eax
  0013a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 2244 : 		g_FontMgr.PrintText( iXPos + 178 + i * m_iLinePlayerGap, iYPos + 62, FONT_SIZE_12, STR(2) );

  00140	6a 00		 push	 0
  00142	6a 02		 push	 2
  00144	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00149	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@FOJFJJHH@RoundStateUserWnd?3?3OnRenderRaidU@
  0014e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00154	8b c8		 mov	 ecx, eax
  00156	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0015c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00164	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  00167	50		 push	 eax
  00168	8b 87 7c 02 00
	00		 mov	 eax, DWORD PTR [edi+636]
  0016e	0f af 45 fc	 imul	 eax, DWORD PTR _i$[ebp]
  00172	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00175	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  0017b	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv513[ebp]
  00180	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00186	8d 84 08 b2 00
	00 00		 lea	 eax, DWORD PTR [eax+ecx+178]
  0018d	0f 57 c0	 xorps	 xmm0, xmm0
  00190	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00194	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00199	ff d6		 call	 esi
  0019b	50		 push	 eax
  0019c	ff d3		 call	 ebx
  0019e	83 c4 14	 add	 esp, 20			; 00000014H

; 2245 : 		g_FontMgr.PrintText( iXPos + 219 + i * m_iLinePlayerGap, iYPos + 62, FONT_SIZE_12, STR(3) );

  001a1	6a 00		 push	 0
  001a3	6a 03		 push	 3
  001a5	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  001aa	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@FOJFJJHH@RoundStateUserWnd?3?3OnRenderRaidU@
  001af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  001b5	8b c8		 mov	 ecx, eax
  001b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  001bd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  001c5	50		 push	 eax
  001c6	83 ec 0c	 sub	 esp, 12			; 0000000cH
  001c9	8b 87 7c 02 00
	00		 mov	 eax, DWORD PTR [edi+636]
  001cf	0f af 45 fc	 imul	 eax, DWORD PTR _i$[ebp]
  001d3	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  001d6	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  001dc	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv513[ebp]
  001e1	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  001e7	8d 84 08 db 00
	00 00		 lea	 eax, DWORD PTR [eax+ecx+219]
  001ee	0f 57 c0	 xorps	 xmm0, xmm0
  001f1	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001f5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001fa	ff d6		 call	 esi
  001fc	50		 push	 eax
  001fd	ff d3		 call	 ebx
  001ff	83 c4 14	 add	 esp, 20			; 00000014H

; 2246 : 		g_FontMgr.PrintText( iXPos + 261 + i * m_iLinePlayerGap, iYPos + 62, FONT_SIZE_12, STR(4) );

  00202	6a 00		 push	 0
  00204	6a 04		 push	 4
  00206	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0020b	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@FOJFJJHH@RoundStateUserWnd?3?3OnRenderRaidU@
  00210	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00216	8b c8		 mov	 ecx, eax
  00218	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0021e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00226	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  00229	50		 push	 eax
  0022a	8b 87 7c 02 00
	00		 mov	 eax, DWORD PTR [edi+636]
  00230	0f af 45 fc	 imul	 eax, DWORD PTR _i$[ebp]
  00234	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00237	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  0023d	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv513[ebp]
  00242	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00248	8d 84 08 05 01
	00 00		 lea	 eax, DWORD PTR [eax+ecx+261]
  0024f	0f 57 c0	 xorps	 xmm0, xmm0
  00252	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00256	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0025b	ff d6		 call	 esi
  0025d	50		 push	 eax
  0025e	ff d3		 call	 ebx
  00260	83 c4 14	 add	 esp, 20			; 00000014H

; 2247 : 		g_FontMgr.PrintText( iXPos + 294 + i * m_iLinePlayerGap, iYPos + 62, FONT_SIZE_12, STR(5) );

  00263	6a 00		 push	 0
  00265	6a 05		 push	 5
  00267	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0026c	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@FOJFJJHH@RoundStateUserWnd?3?3OnRenderRaidU@
  00271	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00277	8b c8		 mov	 ecx, eax
  00279	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0027f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00287	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  0028a	50		 push	 eax
  0028b	8b 87 7c 02 00
	00		 mov	 eax, DWORD PTR [edi+636]
  00291	0f af 45 fc	 imul	 eax, DWORD PTR _i$[ebp]
  00295	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00298	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  0029e	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv513[ebp]
  002a3	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  002a9	8d 84 08 26 01
	00 00		 lea	 eax, DWORD PTR [eax+ecx+294]
  002b0	0f 57 c0	 xorps	 xmm0, xmm0
  002b3	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  002b7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002bc	ff d6		 call	 esi
  002be	50		 push	 eax
  002bf	ff d3		 call	 ebx
  002c1	83 c4 14	 add	 esp, 20			; 00000014H
  002c4	ff 45 fc	 inc	 DWORD PTR _i$[ebp]
  002c7	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  002ca	3b 45 f4	 cmp	 eax, DWORD PTR _iMaxUserLineTitle$[ebp]
  002cd	0f 8c cd fd ff
	ff		 jl	 $LL14@OnRenderRa@2
$LN12@OnRenderRa@2:

; 2251 : 	int iRealYPos = iYPos + m_iLineStartY;
; 2252 : 	int iSize = m_RoundInfoList.size();

  002d3	8b 87 9c 02 00
	00		 mov	 eax, DWORD PTR [edi+668]
  002d9	2b 87 98 02 00
	00		 sub	 eax, DWORD PTR [edi+664]
  002df	8b b7 80 02 00
	00		 mov	 esi, DWORD PTR [edi+640]
  002e5	8b 9f 84 02 00
	00		 mov	 ebx, DWORD PTR [edi+644]
  002eb	03 75 08	 add	 esi, DWORD PTR _iXPos$[ebp]
  002ee	03 5d 0c	 add	 ebx, DWORD PTR _iYPos$[ebp]
  002f1	c1 f8 07	 sar	 eax, 7

; 2253 : 	for(i = 0;i < iSize;i++)

  002f4	33 d2		 xor	 edx, edx
  002f6	89 45 f0	 mov	 DWORD PTR _iSize$[ebp], eax
  002f9	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
  002fc	3b c2		 cmp	 eax, edx
  002fe	0f 8e a4 01 00
	00		 jle	 $LN41@OnRenderRa@2

; 2248 : 	}
; 2249 : 
; 2250 : 	int iRealXPos = iXPos + m_iLineStartX;

  00304	89 55 f8	 mov	 DWORD PTR tv662[ebp], edx
  00307	eb 02		 jmp	 SHORT $LN11@OnRenderRa@2
$LL36@OnRenderRa@2:
  00309	33 d2		 xor	 edx, edx
$LN11@OnRenderRa@2:

; 2253 : 	for(i = 0;i < iSize;i++)

  0030b	8b 87 98 02 00
	00		 mov	 eax, DWORD PTR [edi+664]
  00311	03 45 f8	 add	 eax, DWORD PTR tv662[ebp]

; 2254 : 	{
; 2255 : 		RoundInfo &rkInfo = m_RoundInfoList[i];
; 2256 : 
; 2257 : 		if( rkInfo.m_bOwner )

  00314	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  00318	89 45 08	 mov	 DWORD PTR _rkInfo$550480[ebp], eax
  0031b	74 1d		 je	 SHORT $LN8@OnRenderRa@2

; 2258 : 		{
; 2259 : 			if( rkInfo.m_Team == TEAM_BLUE )

  0031d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00320	83 f9 02	 cmp	 ecx, 2
  00323	75 08		 jne	 SHORT $LN7@OnRenderRa@2

; 2260 : 				m_pBlueOver->Render( iRealXPos, iRealYPos );

  00325	8b 8f 70 01 00
	00		 mov	 ecx, DWORD PTR [edi+368]
  0032b	eb 1e		 jmp	 SHORT $LN42@OnRenderRa@2
$LN7@OnRenderRa@2:

; 2261 : 			else if( rkInfo.m_Team == TEAM_RED )

  0032d	83 f9 01	 cmp	 ecx, 1
  00330	75 3f		 jne	 SHORT $LN40@OnRenderRa@2

; 2262 : 				m_pRedOver->Render( iRealXPos, iRealYPos );

  00332	8b 8f 7c 01 00
	00		 mov	 ecx, DWORD PTR [edi+380]

; 2263 : 		}

  00338	eb 11		 jmp	 SHORT $LN42@OnRenderRa@2
$LN8@OnRenderRa@2:

; 2264 : 		else if( m_MouseOverIndex == i )

  0033a	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0033d	39 8f 5c 02 00
	00		 cmp	 DWORD PTR [edi+604], ecx
  00343	75 37		 jne	 SHORT $LN35@OnRenderRa@2

; 2265 : 			m_pCurrentOver->Render( iRealXPos, iRealYPos );

  00345	8b 8f 44 02 00
	00		 mov	 ecx, DWORD PTR [edi+580]
$LN42@OnRenderRa@2:
  0034b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0034d	52		 push	 edx
  0034e	52		 push	 edx
  0034f	52		 push	 edx
  00350	52		 push	 edx
  00351	51		 push	 ecx
  00352	0f 57 c0	 xorps	 xmm0, xmm0
  00355	51		 push	 ecx
  00356	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  0035a	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00360	0f 57 c0	 xorps	 xmm0, xmm0
  00363	f3 0f 2a c6	 cvtsi2ss xmm0, esi
  00367	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0036c	ff 10		 call	 DWORD PTR [eax]
  0036e	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550480[ebp]
$LN40@OnRenderRa@2:

; 2266 : 
; 2267 : 		// 계급 & 아이디
; 2268 : 		int iWidth = OnRenderGradeAndNick( rkInfo, iRealXPos + 4, iRealYPos + 2, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  00371	8b 8f 5c 02 00
	00		 mov	 ecx, DWORD PTR [edi+604]
  00377	3b 4d fc	 cmp	 ecx, DWORD PTR _i$[ebp]
  0037a	74 0a		 je	 SHORT $LN19@OnRenderRa@2
$LN35@OnRenderRa@2:
  0037c	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  00380	75 04		 jne	 SHORT $LN19@OnRenderRa@2
  00382	32 d2		 xor	 dl, dl
  00384	eb 03		 jmp	 SHORT $LN20@OnRenderRa@2
$LN19@OnRenderRa@2:
  00386	33 d2		 xor	 edx, edx
  00388	42		 inc	 edx
$LN20@OnRenderRa@2:
  00389	52		 push	 edx
  0038a	8d 4b 02	 lea	 ecx, DWORD PTR [ebx+2]
  0038d	51		 push	 ecx
  0038e	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00391	51		 push	 ecx
  00392	50		 push	 eax
  00393	8b cf		 mov	 ecx, edi
  00395	e8 00 00 00 00	 call	 ?OnRenderGradeAndNick@RoundStateUserWnd@@IAEHABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderGradeAndNick

; 2269 : 
; 2270 : 		// 길드 마크
; 2271 : 		iWidth += OnRenderGuildMark( rkInfo, iRealXPos + 4 + iWidth, iRealYPos + 4 );

  0039a	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  0039d	51		 push	 ecx
  0039e	89 45 f4	 mov	 DWORD PTR _iWidth$550487[ebp], eax
  003a1	8d 44 30 04	 lea	 eax, DWORD PTR [eax+esi+4]
  003a5	50		 push	 eax
  003a6	ff 75 08	 push	 DWORD PTR _rkInfo$550480[ebp]
  003a9	8b cf		 mov	 ecx, edi
  003ab	e8 00 00 00 00	 call	 ?OnRenderGuildMark@RoundStateUserWnd@@IAEHABURoundInfo@@HH@Z ; RoundStateUserWnd::OnRenderGuildMark
  003b0	8b 4d f4	 mov	 ecx, DWORD PTR _iWidth$550487[ebp]
  003b3	03 c8		 add	 ecx, eax

; 2272 : 
; 2273 : 		// 보너스
; 2274 : 		OnRenderBonus( rkInfo, iRealXPos + iWidth + 7, iRealYPos + 3 );

  003b5	8d 43 03	 lea	 eax, DWORD PTR [ebx+3]
  003b8	50		 push	 eax
  003b9	8d 44 31 07	 lea	 eax, DWORD PTR [ecx+esi+7]
  003bd	50		 push	 eax
  003be	ff 75 08	 push	 DWORD PTR _rkInfo$550480[ebp]
  003c1	8b cf		 mov	 ecx, edi
  003c3	e8 00 00 00 00	 call	 ?OnRenderBonus@RoundStateUserWnd@@IAEXABURoundInfo@@HH@Z ; RoundStateUserWnd::OnRenderBonus

; 2275 : 
; 2276 : 		OnRenderRaidCoinCount( rkInfo, iRealXPos + 156, iRealYPos + 3 );

  003c8	8d 43 03	 lea	 eax, DWORD PTR [ebx+3]
  003cb	50		 push	 eax
  003cc	8d 86 9c 00 00
	00		 lea	 eax, DWORD PTR [esi+156]
  003d2	50		 push	 eax
  003d3	ff 75 08	 push	 DWORD PTR _rkInfo$550480[ebp]
  003d6	8b cf		 mov	 ecx, edi
  003d8	e8 00 00 00 00	 call	 ?OnRenderRaidCoinCount@RoundStateUserWnd@@IAEXABURoundInfo@@HH@Z ; RoundStateUserWnd::OnRenderRaidCoinCount

; 2277 : 
; 2278 : 		// 기여도
; 2279 : 		OnRenderContribute( rkInfo, iRealXPos + 212, iRealYPos + 3, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  003dd	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  003e0	39 87 5c 02 00
	00		 cmp	 DWORD PTR [edi+604], eax
  003e6	74 0d		 je	 SHORT $LN37@OnRenderRa@2
  003e8	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550480[ebp]
  003eb	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  003ef	75 04		 jne	 SHORT $LN37@OnRenderRa@2
  003f1	32 c0		 xor	 al, al
  003f3	eb 03		 jmp	 SHORT $LN22@OnRenderRa@2
$LN37@OnRenderRa@2:
  003f5	33 c0		 xor	 eax, eax
  003f7	40		 inc	 eax
$LN22@OnRenderRa@2:
  003f8	50		 push	 eax
  003f9	8d 43 03	 lea	 eax, DWORD PTR [ebx+3]
  003fc	50		 push	 eax
  003fd	8d 86 d4 00 00
	00		 lea	 eax, DWORD PTR [esi+212]
  00403	50		 push	 eax
  00404	ff 75 08	 push	 DWORD PTR _rkInfo$550480[ebp]
  00407	8b cf		 mov	 ecx, edi
  00409	e8 00 00 00 00	 call	 ?OnRenderContribute@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderContribute

; 2280 : 
; 2281 : 		// KO & Death
; 2282 : 		OnRenderKillDeath( rkInfo, iRealXPos + 254, iRealYPos + 3, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  0040e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00411	39 87 5c 02 00
	00		 cmp	 DWORD PTR [edi+604], eax
  00417	74 0d		 je	 SHORT $LN38@OnRenderRa@2
  00419	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550480[ebp]
  0041c	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  00420	75 04		 jne	 SHORT $LN38@OnRenderRa@2
  00422	32 c0		 xor	 al, al
  00424	eb 03		 jmp	 SHORT $LN24@OnRenderRa@2
$LN38@OnRenderRa@2:
  00426	33 c0		 xor	 eax, eax
  00428	40		 inc	 eax
$LN24@OnRenderRa@2:
  00429	50		 push	 eax
  0042a	8d 43 03	 lea	 eax, DWORD PTR [ebx+3]
  0042d	50		 push	 eax
  0042e	8d 86 fe 00 00
	00		 lea	 eax, DWORD PTR [esi+254]
  00434	50		 push	 eax
  00435	ff 75 08	 push	 DWORD PTR _rkInfo$550480[ebp]
  00438	8b cf		 mov	 ecx, edi
  0043a	e8 00 00 00 00	 call	 ?OnRenderKillDeath@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderKillDeath

; 2283 : 
; 2284 : 		// 핑
; 2285 : 		OnRenderPing( rkInfo, iRealXPos + 275, iRealYPos + 2, ( m_MouseOverIndex == i || rkInfo.m_bOwner ) );

  0043f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00442	39 87 5c 02 00
	00		 cmp	 DWORD PTR [edi+604], eax
  00448	74 0d		 je	 SHORT $LN39@OnRenderRa@2
  0044a	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$550480[ebp]
  0044d	80 78 54 00	 cmp	 BYTE PTR [eax+84], 0
  00451	75 04		 jne	 SHORT $LN39@OnRenderRa@2
  00453	32 c0		 xor	 al, al
  00455	eb 03		 jmp	 SHORT $LN26@OnRenderRa@2
$LN39@OnRenderRa@2:
  00457	33 c0		 xor	 eax, eax
  00459	40		 inc	 eax
$LN26@OnRenderRa@2:
  0045a	50		 push	 eax
  0045b	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
  0045e	50		 push	 eax
  0045f	8d 86 13 01 00
	00		 lea	 eax, DWORD PTR [esi+275]
  00465	50		 push	 eax
  00466	ff 75 08	 push	 DWORD PTR _rkInfo$550480[ebp]
  00469	8b cf		 mov	 ecx, edi
  0046b	e8 00 00 00 00	 call	 ?OnRenderPing@RoundStateUserWnd@@IAEXABURoundInfo@@HH_N@Z ; RoundStateUserWnd::OnRenderPing

; 2286 : 
; 2287 : 		//
; 2288 : 		if( 0 == ( i + 1 ) % m_iLinePlayer )

  00470	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00473	41		 inc	 ecx
  00474	8b c1		 mov	 eax, ecx
  00476	99		 cdq
  00477	f7 bf 78 02 00
	00		 idiv	 DWORD PTR [edi+632]
  0047d	85 d2		 test	 edx, edx
  0047f	75 11		 jne	 SHORT $LN2@OnRenderRa@2

; 2289 : 		{
; 2290 : 			iRealXPos += m_iLinePlayerGap;
; 2291 : 			iRealYPos = iYPos + m_iLineStartY;

  00481	8b 9f 84 02 00
	00		 mov	 ebx, DWORD PTR [edi+644]
  00487	03 b7 7c 02 00
	00		 add	 esi, DWORD PTR [edi+636]
  0048d	03 5d 0c	 add	 ebx, DWORD PTR _iYPos$[ebp]

; 2292 : 		}
; 2293 : 		else

  00490	eb 06		 jmp	 SHORT $LN10@OnRenderRa@2
$LN2@OnRenderRa@2:

; 2294 : 		{
; 2295 : 			iRealYPos += m_iLineHeight;

  00492	03 9f 8c 02 00
	00		 add	 ebx, DWORD PTR [edi+652]
$LN10@OnRenderRa@2:

; 2253 : 	for(i = 0;i < iSize;i++)

  00498	83 6d f8 80	 sub	 DWORD PTR tv662[ebp], -128 ; ffffff80H
  0049c	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  0049f	3b 4d f0	 cmp	 ecx, DWORD PTR _iSize$[ebp]
  004a2	0f 8c 61 fe ff
	ff		 jl	 $LL36@OnRenderRa@2
$LN41@OnRenderRa@2:
  004a8	5b		 pop	 ebx
$LN15@OnRenderRa@2:
  004a9	5f		 pop	 edi
  004aa	5e		 pop	 esi

; 2296 : 		}
; 2297 : 	}
; 2298 : }

  004ab	c9		 leave
  004ac	c2 08 00	 ret	 8
?OnRenderRaidUser@RoundStateUserWnd@@IAEXHH@Z ENDP	; RoundStateUserWnd::OnRenderRaidUser
_TEXT	ENDS
PUBLIC	??0?$CEncrypt@H@@QAE@ABV0@@Z			; CEncrypt<int>::CEncrypt<int>
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
xdata$x	SEGMENT
__unwindtable$??0?$CEncrypt@H@@QAE@ABV0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CEncrypt@H@@QAE@ABV0@@Z$0
__ehfuncinfo$??0?$CEncrypt@H@@QAE@ABV0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CEncrypt@H@@QAE@ABV0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??0?$CEncrypt@H@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_value$567639 = 8					; size = 4
_value$567634 = 8					; size = 4
_inValue$ = 8						; size = 4
??0?$CEncrypt@H@@QAE@ABV0@@Z PROC			; CEncrypt<int>::CEncrypt<int>, COMDAT
; _this$ = ecx

; 120  : 	CEncrypt( const CEncrypt<type> &inValue )   // 선언과 동시에 값을 대입하기 위해서

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0?$CEncrypt@H@@QAE@ABV0@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00014	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CEncrypt@H@@6B@
  0001a	e8 00 00 00 00	 call	 ??0ccddaabb@@QAE@XZ	; ccddaabb::ccddaabb
  0001f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 121  : 	{
; 122  : 		Init();

  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?Init@?$CEncrypt@H@@AAEXXZ ; CEncrypt<int>::Init

; 123  : 		*this = inValue;

  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _inValue$[ebp]
  0002d	8d 45 08	 lea	 eax, DWORD PTR _value$567634[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@H@@QAEXPAH@Z ; CEncrypt<int>::DecryptValueToPool
  00036	8b 45 08	 mov	 eax, DWORD PTR _value$567634[ebp]
  00039	89 45 08	 mov	 DWORD PTR _value$567639[ebp], eax
  0003c	8d 45 08	 lea	 eax, DWORD PTR _value$567639[ebp]
  0003f	50		 push	 eax
  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@H@@AAEXPBD@Z ; CEncrypt<int>::EncryptValueToPool

; 124  : 	}

  00047	8b c6		 mov	 eax, esi
  00049	e8 00 00 00 00	 call	 __EH_epilog3
  0004e	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CEncrypt@H@@QAE@ABV0@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	e9 00 00 00 00	 jmp	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
__ehhandler$??0?$CEncrypt@H@@QAE@ABV0@@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$CEncrypt@H@@QAE@ABV0@@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$CEncrypt@H@@QAE@ABV0@@Z ENDP			; CEncrypt<int>::CEncrypt<int>
PUBLIC	??0?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE@XZ ; std::vector<RoundInfo,std::allocator<RoundInfo> >::vector<RoundInfo,std::allocator<RoundInfo> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<RoundInfo,std::allocator<RoundInfo> >::vector<RoundInfo,std::allocator<RoundInfo> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<RoundInfo,std::allocator<RoundInfo> >::vector<RoundInfo,std::allocator<RoundInfo> >
_TEXT	ENDS
PUBLIC	?begin@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@XZ ; std::vector<RoundInfo,std::allocator<RoundInfo> >::begin
; Function compile flags: /Ogsp
;	COMDAT ?begin@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@XZ PROC ; std::vector<RoundInfo,std::allocator<RoundInfo> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 782  : 		return (iterator(this->_Myfirst, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 783  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@XZ ENDP ; std::vector<RoundInfo,std::allocator<RoundInfo> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@XZ ; std::vector<RoundInfo,std::allocator<RoundInfo> >::end
; Function compile flags: /Ogsp
;	COMDAT ?end@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@XZ PROC ; std::vector<RoundInfo,std::allocator<RoundInfo> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 792  : 		return (iterator(this->_Mylast, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 793  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@XZ ENDP ; std::vector<RoundInfo,std::allocator<RoundInfo> >::end
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >::operator!=
; Function compile flags: /Ogsp
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 209  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >::operator!=
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@AAU3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@AAU2@@Z ; std::_Cons_val<std::allocator<RoundInfo>,RoundInfo,RoundInfo &>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@AAU3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@AAU3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@AAU2@@Z$0
__ehfuncinfo$??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@AAU3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@AAU3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@AAU3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@AAU2@@Z
_TEXT	SEGMENT
$T567730 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@AAU3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<RoundInfo>,RoundInfo,RoundInfo &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@AAU3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@AAU2@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  0000f	89 4d f0	 mov	 DWORD PTR $T567730[ebp], ecx
  00012	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00016	85 c9		 test	 ecx, ecx
  00018	74 08		 je	 SHORT $LN7@Cons_val
  0001a	ff 75 10	 push	 DWORD PTR __Src$[ebp]
  0001d	e8 00 00 00 00	 call	 ??0RoundInfo@@QAE@ABU0@@Z
$LN7@Cons_val:

; 281  : 	}

  00022	e8 00 00 00 00	 call	 __EH_epilog3
  00027	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@AAU3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@AAU2@@Z$0:
  00000	ff 75 0c	 push	 DWORD PTR __Pdest$[ebp]
  00003	ff 75 f0	 push	 DWORD PTR $T567730[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000b	59		 pop	 ecx
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
__ehhandler$??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@AAU3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@AAU2@@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@AAU3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@AAU2@@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@AAU3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<RoundInfo>,RoundInfo,RoundInfo &>
PUBLIC	??$_Move@PAURoundInfo@@PAU1@@std@@YAPAURoundInfo@@PAU1@00@Z ; std::_Move<RoundInfo *,RoundInfo *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAURoundInfo@@PAU1@@std@@YAPAURoundInfo@@PAU1@00@Z
_TEXT	SEGMENT
__Cat$567748 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAURoundInfo@@PAU1@@std@@YAPAURoundInfo@@PAU1@00@Z PROC ; std::_Move<RoundInfo *,RoundInfo *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$567748[ebp]
  00007	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Move@PAURoundInfo@@PAU1@@std@@YAPAURoundInfo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<RoundInfo *,RoundInfo *>
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00018	c9		 leave
  00019	c3		 ret	 0
??$_Move@PAURoundInfo@@PAU1@@std@@YAPAURoundInfo@@PAU1@00@Z ENDP ; std::_Move<RoundInfo *,RoundInfo *>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@ABU3@@Z ; std::allocator<RoundInfo>::construct
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@ABU3@@Z PROC ; std::allocator<RoundInfo>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 		_Construct(_Ptr, _Val);

  00003	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  00006	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00009	e8 00 00 00 00	 call	 ??$_Construct@URoundInfo@@ABU1@@std@@YAXPAURoundInfo@@ABU1@@Z ; std::_Construct<RoundInfo,RoundInfo const &>
  0000e	59		 pop	 ecx
  0000f	59		 pop	 ecx

; 198  : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?construct@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@ABU3@@Z ENDP ; std::allocator<RoundInfo>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@@Z ; std::allocator<RoundInfo>::destroy
; Function compile flags: /Ogsp
;	COMDAT ?destroy@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@@Z PROC ; std::allocator<RoundInfo>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 213  : 		_Destroy(_Ptr);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??1RoundInfo@@QAE@XZ

; 214  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?destroy@?$allocator@URoundInfo@@@std@@QAEXPAURoundInfo@@@Z ENDP ; std::allocator<RoundInfo>::destroy
_TEXT	ENDS
PUBLIC	??$iter_swap@PAURoundInfo@@PAU1@@std@@YAXPAURoundInfo@@0@Z ; std::iter_swap<RoundInfo *,RoundInfo *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$iter_swap@PAURoundInfo@@PAU1@@std@@YAXPAURoundInfo@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAURoundInfo@@PAU1@@std@@YAXPAURoundInfo@@0@Z PROC ; std::iter_swap<RoundInfo *,RoundInfo *>, COMDAT

; 2133 : 	{	// swap *_Left and *_Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2135 : 	}

  00003	5d		 pop	 ebp

; 2134 : 	swap(*_Left, *_Right);

  00004	e9 00 00 00 00	 jmp	 ??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z ; std::swap<RoundInfo>
??$iter_swap@PAURoundInfo@@PAU1@@std@@YAXPAURoundInfo@@0@Z ENDP ; std::iter_swap<RoundInfo *,RoundInfo *>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAURoundInfo@@VRoundInfoKoSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@0@Z ; std::_Insertion_sort1<RoundInfo *,RoundInfoKoSort,RoundInfo>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??$_Insertion_sort1@PAURoundInfo@@VRoundInfoKoSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Insertion_sort1@PAURoundInfo@@VRoundInfoKoSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@0@Z$0
__ehfuncinfo$??$_Insertion_sort1@PAURoundInfo@@VRoundInfoKoSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Insertion_sort1@PAURoundInfo@@VRoundInfoKoSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Insertion_sort1@PAURoundInfo@@VRoundInfoKoSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@0@Z
_TEXT	SEGMENT
__Val$555639 = -148					; size = 128
__Next1$555638 = -20					; size = 4
__First1$555649 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Cat$567783 = 8					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
___formal$ = 20						; size = 4
??$_Insertion_sort1@PAURoundInfo@@VRoundInfoKoSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@0@Z PROC ; std::_Insertion_sort1<RoundInfo *,RoundInfoKoSort,RoundInfo>, COMDAT

; 3650 : 	{	// insertion sort [_First, _Last), using _Pred

  00000	68 88 00 00 00	 push	 136			; 00000088H
  00005	b8 00 00 00 00	 mov	 eax, __ehhandler$??$_Insertion_sort1@PAURoundInfo@@VRoundInfoKoSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@0@Z
  0000a	e8 00 00 00 00	 call	 __EH_prolog3

; 3651 : 	if (_First != _Last)

  0000f	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  00012	3b 7d 0c	 cmp	 edi, DWORD PTR __Last$[ebp]
  00015	0f 84 b0 00 00
	00		 je	 $LN6@Insertion_

; 3652 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

  0001b	83 ef 80	 sub	 edi, -128		; ffffff80H
  0001e	3b 7d 0c	 cmp	 edi, DWORD PTR __Last$[ebp]
  00021	0f 84 a4 00 00
	00		 je	 $LN6@Insertion_
  00027	8d 5f 80	 lea	 ebx, DWORD PTR [edi-128]
  0002a	be 80 00 00 00	 mov	 esi, 128		; 00000080H
$LL7@Insertion_:

; 3653 : 			{	// order next element
; 3654 : 			_BidIt _Next1 = _Next;
; 3655 : 			_Ty _Val = _Move(*_Next);

  0002f	57		 push	 edi
  00030	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR __Val$555639[ebp]
  00036	89 7d ec	 mov	 DWORD PTR __Next1$555638[ebp], edi
  00039	e8 00 00 00 00	 call	 ??0RoundInfo@@QAE@ABU0@@Z

; 3656 : 
; 3657 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

  0003e	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00041	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00045	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR __Val$555639[ebp]
  0004b	50		 push	 eax
  0004c	8d 4d 10	 lea	 ecx, DWORD PTR __Pred$[ebp]
  0004f	e8 00 00 00 00	 call	 ??RRoundInfoKoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoKoSort::operator()
  00054	84 c0		 test	 al, al
  00056	74 1b		 je	 SHORT $LN5@Insertion_

; 3658 : 				{	// found new earliest element, move to front
; 3659 : 				_Move_backward(_First, _Next, ++_Next1);

  00058	ff 75 08	 push	 DWORD PTR __Cat$567783[ebp]
  0005b	8d 83 00 01 00
	00		 lea	 eax, DWORD PTR [ebx+256]
  00061	50		 push	 eax
  00062	57		 push	 edi
  00063	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00066	e8 00 00 00 00	 call	 ??$_Move_backward@PAURoundInfo@@PAU1@@std@@YAPAURoundInfo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move_backward<RoundInfo *,RoundInfo *>

; 3660 : 				*_First = _Move(_Val);

  0006b	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0006e	83 c4 10	 add	 esp, 16			; 00000010H

; 3661 : 				}
; 3662 : 			else

  00071	eb 30		 jmp	 SHORT $LN29@Insertion_
$LN5@Insertion_:

; 3663 : 				{	// look for insertion point after first
; 3664 : 				for (_BidIt _First1 = _Next1;
; 3665 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3666 : 					_Next1 = _First1)

  00073	89 5d f0	 mov	 DWORD PTR __First1$555649[ebp], ebx
  00076	53		 push	 ebx
  00077	eb 14		 jmp	 SHORT $LN31@Insertion_
$LL3@Insertion_:

; 3667 : 					*_Next1 = _Move(*_First1);	// move hole down

  00079	ff 75 f0	 push	 DWORD PTR __First1$555649[ebp]
  0007c	e8 00 00 00 00	 call	 ??4RoundInfo@@QAEAAU0@ABU0@@Z
  00081	8b 45 f0	 mov	 eax, DWORD PTR __First1$555649[ebp]
  00084	29 75 f0	 sub	 DWORD PTR __First1$555649[ebp], esi
  00087	ff 75 f0	 push	 DWORD PTR __First1$555649[ebp]
  0008a	89 45 ec	 mov	 DWORD PTR __Next1$555638[ebp], eax
$LN31@Insertion_:

; 3663 : 				{	// look for insertion point after first
; 3664 : 				for (_BidIt _First1 = _Next1;
; 3665 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3666 : 					_Next1 = _First1)

  0008d	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR __Val$555639[ebp]
  00093	50		 push	 eax
  00094	8d 4d 10	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00097	e8 00 00 00 00	 call	 ??RRoundInfoKoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoKoSort::operator()

; 3668 : 				*_Next1 = _Move(_Val);	// insert element in hole

  0009c	8b 4d ec	 mov	 ecx, DWORD PTR __Next1$555638[ebp]
  0009f	84 c0		 test	 al, al
  000a1	75 d6		 jne	 SHORT $LL3@Insertion_
$LN29@Insertion_:
  000a3	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR __Val$555639[ebp]
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 ??4RoundInfo@@QAEAAU0@ABU0@@Z

; 3669 : 				}
; 3670 : 			}

  000af	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000b3	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR __Val$555639[ebp]
  000b9	e8 00 00 00 00	 call	 ??1RoundInfo@@QAE@XZ
  000be	03 fe		 add	 edi, esi
  000c0	03 de		 add	 ebx, esi
  000c2	3b 7d 0c	 cmp	 edi, DWORD PTR __Last$[ebp]
  000c5	0f 85 64 ff ff
	ff		 jne	 $LL7@Insertion_
$LN6@Insertion_:

; 3671 : 	}

  000cb	e8 00 00 00 00	 call	 __EH_epilog3
  000d0	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Insertion_sort1@PAURoundInfo@@VRoundInfoKoSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@0@Z$0:
  00000	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR __Val$555639[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1RoundInfo@@QAE@XZ
__ehhandler$??$_Insertion_sort1@PAURoundInfo@@VRoundInfoKoSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@0@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Insertion_sort1@PAURoundInfo@@VRoundInfoKoSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@0@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Insertion_sort1@PAURoundInfo@@VRoundInfoKoSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@0@Z ENDP ; std::_Insertion_sort1<RoundInfo *,RoundInfoKoSort,RoundInfo>
PUBLIC	??$_Insertion_sort1@PAURoundInfo@@VRoundInfoSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@0@Z ; std::_Insertion_sort1<RoundInfo *,RoundInfoSort,RoundInfo>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??$_Insertion_sort1@PAURoundInfo@@VRoundInfoSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Insertion_sort1@PAURoundInfo@@VRoundInfoSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@0@Z$0
__ehfuncinfo$??$_Insertion_sort1@PAURoundInfo@@VRoundInfoSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Insertion_sort1@PAURoundInfo@@VRoundInfoSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Insertion_sort1@PAURoundInfo@@VRoundInfoSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@0@Z
_TEXT	SEGMENT
__Val$555701 = -148					; size = 128
__Next1$555700 = -20					; size = 4
__First1$555704 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Cat$567823 = 8					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
___formal$ = 20						; size = 4
??$_Insertion_sort1@PAURoundInfo@@VRoundInfoSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@0@Z PROC ; std::_Insertion_sort1<RoundInfo *,RoundInfoSort,RoundInfo>, COMDAT

; 3650 : 	{	// insertion sort [_First, _Last), using _Pred

  00000	68 88 00 00 00	 push	 136			; 00000088H
  00005	b8 00 00 00 00	 mov	 eax, __ehhandler$??$_Insertion_sort1@PAURoundInfo@@VRoundInfoSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@0@Z
  0000a	e8 00 00 00 00	 call	 __EH_prolog3

; 3651 : 	if (_First != _Last)

  0000f	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  00012	3b 7d 0c	 cmp	 edi, DWORD PTR __Last$[ebp]
  00015	0f 84 b0 00 00
	00		 je	 $LN6@Insertion_@2

; 3652 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

  0001b	83 ef 80	 sub	 edi, -128		; ffffff80H
  0001e	3b 7d 0c	 cmp	 edi, DWORD PTR __Last$[ebp]
  00021	0f 84 a4 00 00
	00		 je	 $LN6@Insertion_@2
  00027	8d 5f 80	 lea	 ebx, DWORD PTR [edi-128]
  0002a	be 80 00 00 00	 mov	 esi, 128		; 00000080H
$LL7@Insertion_@2:

; 3653 : 			{	// order next element
; 3654 : 			_BidIt _Next1 = _Next;
; 3655 : 			_Ty _Val = _Move(*_Next);

  0002f	57		 push	 edi
  00030	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR __Val$555701[ebp]
  00036	89 7d ec	 mov	 DWORD PTR __Next1$555700[ebp], edi
  00039	e8 00 00 00 00	 call	 ??0RoundInfo@@QAE@ABU0@@Z

; 3656 : 
; 3657 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

  0003e	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00041	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00045	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR __Val$555701[ebp]
  0004b	50		 push	 eax
  0004c	8d 4d 10	 lea	 ecx, DWORD PTR __Pred$[ebp]
  0004f	e8 00 00 00 00	 call	 ??RRoundInfoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoSort::operator()
  00054	84 c0		 test	 al, al
  00056	74 1b		 je	 SHORT $LN5@Insertion_@2

; 3658 : 				{	// found new earliest element, move to front
; 3659 : 				_Move_backward(_First, _Next, ++_Next1);

  00058	ff 75 08	 push	 DWORD PTR __Cat$567823[ebp]
  0005b	8d 83 00 01 00
	00		 lea	 eax, DWORD PTR [ebx+256]
  00061	50		 push	 eax
  00062	57		 push	 edi
  00063	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00066	e8 00 00 00 00	 call	 ??$_Move_backward@PAURoundInfo@@PAU1@@std@@YAPAURoundInfo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move_backward<RoundInfo *,RoundInfo *>

; 3660 : 				*_First = _Move(_Val);

  0006b	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0006e	83 c4 10	 add	 esp, 16			; 00000010H

; 3661 : 				}
; 3662 : 			else

  00071	eb 30		 jmp	 SHORT $LN29@Insertion_@2
$LN5@Insertion_@2:

; 3663 : 				{	// look for insertion point after first
; 3664 : 				for (_BidIt _First1 = _Next1;
; 3665 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3666 : 					_Next1 = _First1)

  00073	89 5d f0	 mov	 DWORD PTR __First1$555704[ebp], ebx
  00076	53		 push	 ebx
  00077	eb 14		 jmp	 SHORT $LN31@Insertion_@2
$LL3@Insertion_@2:

; 3667 : 					*_Next1 = _Move(*_First1);	// move hole down

  00079	ff 75 f0	 push	 DWORD PTR __First1$555704[ebp]
  0007c	e8 00 00 00 00	 call	 ??4RoundInfo@@QAEAAU0@ABU0@@Z
  00081	8b 45 f0	 mov	 eax, DWORD PTR __First1$555704[ebp]
  00084	29 75 f0	 sub	 DWORD PTR __First1$555704[ebp], esi
  00087	ff 75 f0	 push	 DWORD PTR __First1$555704[ebp]
  0008a	89 45 ec	 mov	 DWORD PTR __Next1$555700[ebp], eax
$LN31@Insertion_@2:

; 3663 : 				{	// look for insertion point after first
; 3664 : 				for (_BidIt _First1 = _Next1;
; 3665 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3666 : 					_Next1 = _First1)

  0008d	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR __Val$555701[ebp]
  00093	50		 push	 eax
  00094	8d 4d 10	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00097	e8 00 00 00 00	 call	 ??RRoundInfoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoSort::operator()

; 3668 : 				*_Next1 = _Move(_Val);	// insert element in hole

  0009c	8b 4d ec	 mov	 ecx, DWORD PTR __Next1$555700[ebp]
  0009f	84 c0		 test	 al, al
  000a1	75 d6		 jne	 SHORT $LL3@Insertion_@2
$LN29@Insertion_@2:
  000a3	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR __Val$555701[ebp]
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 ??4RoundInfo@@QAEAAU0@ABU0@@Z

; 3669 : 				}
; 3670 : 			}

  000af	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000b3	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR __Val$555701[ebp]
  000b9	e8 00 00 00 00	 call	 ??1RoundInfo@@QAE@XZ
  000be	03 fe		 add	 edi, esi
  000c0	03 de		 add	 ebx, esi
  000c2	3b 7d 0c	 cmp	 edi, DWORD PTR __Last$[ebp]
  000c5	0f 85 64 ff ff
	ff		 jne	 $LL7@Insertion_@2
$LN6@Insertion_@2:

; 3671 : 	}

  000cb	e8 00 00 00 00	 call	 __EH_epilog3
  000d0	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Insertion_sort1@PAURoundInfo@@VRoundInfoSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@0@Z$0:
  00000	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR __Val$555701[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1RoundInfo@@QAE@XZ
__ehhandler$??$_Insertion_sort1@PAURoundInfo@@VRoundInfoSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@0@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Insertion_sort1@PAURoundInfo@@VRoundInfoSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@0@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Insertion_sort1@PAURoundInfo@@VRoundInfoSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@0@Z ENDP ; std::_Insertion_sort1<RoundInfo *,RoundInfoSort,RoundInfo>
PUBLIC	??$_Insertion_sort1@PAURoundInfo@@VRoundInfoStarSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@0@Z ; std::_Insertion_sort1<RoundInfo *,RoundInfoStarSort,RoundInfo>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??$_Insertion_sort1@PAURoundInfo@@VRoundInfoStarSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Insertion_sort1@PAURoundInfo@@VRoundInfoStarSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@0@Z$0
__ehfuncinfo$??$_Insertion_sort1@PAURoundInfo@@VRoundInfoStarSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Insertion_sort1@PAURoundInfo@@VRoundInfoStarSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Insertion_sort1@PAURoundInfo@@VRoundInfoStarSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@0@Z
_TEXT	SEGMENT
__Val$555756 = -148					; size = 128
__Next1$555755 = -20					; size = 4
__First1$555759 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Cat$567863 = 8					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
___formal$ = 20						; size = 4
??$_Insertion_sort1@PAURoundInfo@@VRoundInfoStarSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@0@Z PROC ; std::_Insertion_sort1<RoundInfo *,RoundInfoStarSort,RoundInfo>, COMDAT

; 3650 : 	{	// insertion sort [_First, _Last), using _Pred

  00000	68 88 00 00 00	 push	 136			; 00000088H
  00005	b8 00 00 00 00	 mov	 eax, __ehhandler$??$_Insertion_sort1@PAURoundInfo@@VRoundInfoStarSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@0@Z
  0000a	e8 00 00 00 00	 call	 __EH_prolog3

; 3651 : 	if (_First != _Last)

  0000f	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  00012	3b 7d 0c	 cmp	 edi, DWORD PTR __Last$[ebp]
  00015	0f 84 b0 00 00
	00		 je	 $LN6@Insertion_@3

; 3652 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

  0001b	83 ef 80	 sub	 edi, -128		; ffffff80H
  0001e	3b 7d 0c	 cmp	 edi, DWORD PTR __Last$[ebp]
  00021	0f 84 a4 00 00
	00		 je	 $LN6@Insertion_@3
  00027	8d 5f 80	 lea	 ebx, DWORD PTR [edi-128]
  0002a	be 80 00 00 00	 mov	 esi, 128		; 00000080H
$LL7@Insertion_@3:

; 3653 : 			{	// order next element
; 3654 : 			_BidIt _Next1 = _Next;
; 3655 : 			_Ty _Val = _Move(*_Next);

  0002f	57		 push	 edi
  00030	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR __Val$555756[ebp]
  00036	89 7d ec	 mov	 DWORD PTR __Next1$555755[ebp], edi
  00039	e8 00 00 00 00	 call	 ??0RoundInfo@@QAE@ABU0@@Z

; 3656 : 
; 3657 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

  0003e	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00041	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00045	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR __Val$555756[ebp]
  0004b	50		 push	 eax
  0004c	8d 4d 10	 lea	 ecx, DWORD PTR __Pred$[ebp]
  0004f	e8 00 00 00 00	 call	 ??RRoundInfoStarSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoStarSort::operator()
  00054	84 c0		 test	 al, al
  00056	74 1b		 je	 SHORT $LN5@Insertion_@3

; 3658 : 				{	// found new earliest element, move to front
; 3659 : 				_Move_backward(_First, _Next, ++_Next1);

  00058	ff 75 08	 push	 DWORD PTR __Cat$567863[ebp]
  0005b	8d 83 00 01 00
	00		 lea	 eax, DWORD PTR [ebx+256]
  00061	50		 push	 eax
  00062	57		 push	 edi
  00063	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00066	e8 00 00 00 00	 call	 ??$_Move_backward@PAURoundInfo@@PAU1@@std@@YAPAURoundInfo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move_backward<RoundInfo *,RoundInfo *>

; 3660 : 				*_First = _Move(_Val);

  0006b	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0006e	83 c4 10	 add	 esp, 16			; 00000010H

; 3661 : 				}
; 3662 : 			else

  00071	eb 30		 jmp	 SHORT $LN29@Insertion_@3
$LN5@Insertion_@3:

; 3663 : 				{	// look for insertion point after first
; 3664 : 				for (_BidIt _First1 = _Next1;
; 3665 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3666 : 					_Next1 = _First1)

  00073	89 5d f0	 mov	 DWORD PTR __First1$555759[ebp], ebx
  00076	53		 push	 ebx
  00077	eb 14		 jmp	 SHORT $LN31@Insertion_@3
$LL3@Insertion_@3:

; 3667 : 					*_Next1 = _Move(*_First1);	// move hole down

  00079	ff 75 f0	 push	 DWORD PTR __First1$555759[ebp]
  0007c	e8 00 00 00 00	 call	 ??4RoundInfo@@QAEAAU0@ABU0@@Z
  00081	8b 45 f0	 mov	 eax, DWORD PTR __First1$555759[ebp]
  00084	29 75 f0	 sub	 DWORD PTR __First1$555759[ebp], esi
  00087	ff 75 f0	 push	 DWORD PTR __First1$555759[ebp]
  0008a	89 45 ec	 mov	 DWORD PTR __Next1$555755[ebp], eax
$LN31@Insertion_@3:

; 3663 : 				{	// look for insertion point after first
; 3664 : 				for (_BidIt _First1 = _Next1;
; 3665 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3666 : 					_Next1 = _First1)

  0008d	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR __Val$555756[ebp]
  00093	50		 push	 eax
  00094	8d 4d 10	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00097	e8 00 00 00 00	 call	 ??RRoundInfoStarSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoStarSort::operator()

; 3668 : 				*_Next1 = _Move(_Val);	// insert element in hole

  0009c	8b 4d ec	 mov	 ecx, DWORD PTR __Next1$555755[ebp]
  0009f	84 c0		 test	 al, al
  000a1	75 d6		 jne	 SHORT $LL3@Insertion_@3
$LN29@Insertion_@3:
  000a3	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR __Val$555756[ebp]
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 ??4RoundInfo@@QAEAAU0@ABU0@@Z

; 3669 : 				}
; 3670 : 			}

  000af	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000b3	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR __Val$555756[ebp]
  000b9	e8 00 00 00 00	 call	 ??1RoundInfo@@QAE@XZ
  000be	03 fe		 add	 edi, esi
  000c0	03 de		 add	 ebx, esi
  000c2	3b 7d 0c	 cmp	 edi, DWORD PTR __Last$[ebp]
  000c5	0f 85 64 ff ff
	ff		 jne	 $LL7@Insertion_@3
$LN6@Insertion_@3:

; 3671 : 	}

  000cb	e8 00 00 00 00	 call	 __EH_epilog3
  000d0	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Insertion_sort1@PAURoundInfo@@VRoundInfoStarSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@0@Z$0:
  00000	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR __Val$555756[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1RoundInfo@@QAE@XZ
__ehhandler$??$_Insertion_sort1@PAURoundInfo@@VRoundInfoStarSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@0@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Insertion_sort1@PAURoundInfo@@VRoundInfoStarSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@0@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Insertion_sort1@PAURoundInfo@@VRoundInfoStarSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@0@Z ENDP ; std::_Insertion_sort1<RoundInfo *,RoundInfoStarSort,RoundInfo>
PUBLIC	??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@U3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@$$QAU2@@Z ; std::_Cons_val<std::allocator<RoundInfo>,RoundInfo,RoundInfo>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@U3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@$$QAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@U3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@$$QAU2@@Z$0
__ehfuncinfo$??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@U3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@$$QAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@U3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@$$QAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@U3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@$$QAU2@@Z
_TEXT	SEGMENT
$T567907 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@U3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<RoundInfo>,RoundInfo,RoundInfo>, COMDAT

; 279  : 	{	// construct using allocator

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@U3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@$$QAU2@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  0000f	89 4d f0	 mov	 DWORD PTR $T567907[ebp], ecx
  00012	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00016	85 c9		 test	 ecx, ecx
  00018	74 08		 je	 SHORT $LN7@Cons_val@2
  0001a	ff 75 10	 push	 DWORD PTR __Src$[ebp]
  0001d	e8 00 00 00 00	 call	 ??0RoundInfo@@QAE@ABU0@@Z
$LN7@Cons_val@2:

; 281  : 	}

  00022	e8 00 00 00 00	 call	 __EH_epilog3
  00027	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@U3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@$$QAU2@@Z$0:
  00000	ff 75 0c	 push	 DWORD PTR __Pdest$[ebp]
  00003	ff 75 f0	 push	 DWORD PTR $T567907[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000b	59		 pop	 ecx
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
__ehhandler$??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@U3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@$$QAU2@@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@U3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@$$QAU2@@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@U3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<RoundInfo>,RoundInfo,RoundInfo>
PUBLIC	??$_Med3@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@00VRoundInfoKoSort@@@Z ; std::_Med3<RoundInfo *,RoundInfoKoSort>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\algorithm
;	COMDAT ??$_Med3@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@00VRoundInfoKoSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Med3@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@00VRoundInfoKoSort@@@Z PROC ; std::_Med3<RoundInfo *,RoundInfoKoSort>, COMDAT

; 3683 : 	{	// sort median of three elements to middle

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3684 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Mid$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  0000b	57		 push	 edi
  0000c	56		 push	 esi
  0000d	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00010	e8 00 00 00 00	 call	 ??RRoundInfoKoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoKoSort::operator()
  00015	84 c0		 test	 al, al
  00017	74 09		 je	 SHORT $LN6@Med3

; 3685 : 		_STD iter_swap(_Mid, _First);

  00019	57		 push	 edi
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z ; std::swap<RoundInfo>
  00020	59		 pop	 ecx
  00021	59		 pop	 ecx
$LN6@Med3:

; 3686 : 	if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid))

  00022	56		 push	 esi
  00023	ff 75 10	 push	 DWORD PTR __Last$[ebp]
  00026	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00029	e8 00 00 00 00	 call	 ??RRoundInfoKoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoKoSort::operator()
  0002e	84 c0		 test	 al, al
  00030	74 0b		 je	 SHORT $LN8@Med3

; 3687 : 		_STD iter_swap(_Last, _Mid);

  00032	56		 push	 esi
  00033	ff 75 10	 push	 DWORD PTR __Last$[ebp]
  00036	e8 00 00 00 00	 call	 ??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z ; std::swap<RoundInfo>
  0003b	59		 pop	 ecx
  0003c	59		 pop	 ecx
$LN8@Med3:

; 3688 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

  0003d	57		 push	 edi
  0003e	56		 push	 esi
  0003f	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00042	e8 00 00 00 00	 call	 ??RRoundInfoKoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoKoSort::operator()
  00047	84 c0		 test	 al, al
  00049	74 09		 je	 SHORT $LN10@Med3

; 3689 : 		_STD iter_swap(_Mid, _First);

  0004b	57		 push	 edi
  0004c	56		 push	 esi
  0004d	e8 00 00 00 00	 call	 ??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z ; std::swap<RoundInfo>
  00052	59		 pop	 ecx
  00053	59		 pop	 ecx
$LN10@Med3:
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi

; 3690 : 	}

  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
??$_Med3@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@00VRoundInfoKoSort@@@Z ENDP ; std::_Med3<RoundInfo *,RoundInfoKoSort>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAURoundInfo@@HU1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoKoSort@@@Z ; std::_Adjust_heap<RoundInfo *,int,RoundInfo,RoundInfoKoSort>
; Function compile flags: /Ogsp
;	COMDAT ??$_Adjust_heap@PAURoundInfo@@HU1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoKoSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Top$ = 12						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Adjust_heap@PAURoundInfo@@HU1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoKoSort@@@Z PROC ; std::_Adjust_heap<RoundInfo *,int,RoundInfo,RoundInfoKoSort>, COMDAT

; 2565 : 	{	// percolate _Hole to _Bottom, then push _Val, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 2566 : 	_Diff _Top = _Hole;
; 2567 : 	_Diff _Idx = 2 * _Hole + 2;
; 2568 : 
; 2569 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Hole$[ebp]
  0000c	89 7d 0c	 mov	 DWORD PTR __Top$[ebp], edi
  0000f	8d 74 3f 02	 lea	 esi, DWORD PTR [edi+edi+2]
  00013	eb 33		 jmp	 SHORT $LN16@Adjust_hea
$LL5@Adjust_hea:

; 2570 : 		{	// move _Hole down to larger child
; 2571 : 		if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1))))

  00015	8b c6		 mov	 eax, esi
  00017	c1 e0 07	 shl	 eax, 7
  0001a	03 c3		 add	 eax, ebx
  0001c	8d 48 80	 lea	 ecx, DWORD PTR [eax-128]
  0001f	51		 push	 ecx
  00020	50		 push	 eax
  00021	8d 4d 18	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00024	e8 00 00 00 00	 call	 ??RRoundInfoKoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoKoSort::operator()
  00029	84 c0		 test	 al, al
  0002b	74 01		 je	 SHORT $LN2@Adjust_hea

; 2572 : 			--_Idx;

  0002d	4e		 dec	 esi
$LN2@Adjust_hea:

; 2573 : 		*(_First + _Hole) = _Move(*(_First + _Idx));

  0002e	8b c6		 mov	 eax, esi
  00030	c1 e0 07	 shl	 eax, 7
  00033	8b cf		 mov	 ecx, edi
  00035	03 c3		 add	 eax, ebx
  00037	c1 e1 07	 shl	 ecx, 7
  0003a	50		 push	 eax
  0003b	03 cb		 add	 ecx, ebx
  0003d	e8 00 00 00 00	 call	 ??4RoundInfo@@QAEAAU0@ABU0@@Z

; 2574 : 		_Hole = _Idx;

  00042	8b fe		 mov	 edi, esi
  00044	8d 74 36 02	 lea	 esi, DWORD PTR [esi+esi+2]
$LN16@Adjust_hea:

; 2566 : 	_Diff _Top = _Hole;
; 2567 : 	_Diff _Idx = 2 * _Hole + 2;
; 2568 : 
; 2569 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

  00048	3b 75 10	 cmp	 esi, DWORD PTR __Bottom$[ebp]
  0004b	7c c8		 jl	 SHORT $LL5@Adjust_hea

; 2575 : 		}
; 2576 : 
; 2577 : 	if (_Idx == _Bottom)

  0004d	75 1b		 jne	 SHORT $LN1@Adjust_hea

; 2578 : 		{	// only child at bottom, move _Hole down to it
; 2579 : 		*(_First + _Hole) = _Move(*(_First + (_Bottom - 1)));

  0004f	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  00052	c1 e0 07	 shl	 eax, 7
  00055	8b cf		 mov	 ecx, edi
  00057	8d 44 18 80	 lea	 eax, DWORD PTR [eax+ebx-128]
  0005b	c1 e1 07	 shl	 ecx, 7
  0005e	50		 push	 eax
  0005f	03 cb		 add	 ecx, ebx
  00061	e8 00 00 00 00	 call	 ??4RoundInfo@@QAEAAU0@ABU0@@Z

; 2580 : 		_Hole = _Bottom - 1;

  00066	8b 7d 10	 mov	 edi, DWORD PTR __Bottom$[ebp]
  00069	4f		 dec	 edi
$LN1@Adjust_hea:

; 2581 : 		}
; 2582 : 	_Push_heap(_First, _Hole, _Top, _Move(_Val), _Pred);

  0006a	ff 75 18	 push	 DWORD PTR __Pred$[ebp]
  0006d	ff 75 14	 push	 DWORD PTR __Val$[ebp]
  00070	ff 75 0c	 push	 DWORD PTR __Top$[ebp]
  00073	57		 push	 edi
  00074	53		 push	 ebx
  00075	e8 00 00 00 00	 call	 ??$_Push_heap@PAURoundInfo@@HU1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoKoSort@@@Z ; std::_Push_heap<RoundInfo *,int,RoundInfo,RoundInfoKoSort>
  0007a	83 c4 14	 add	 esp, 20			; 00000014H
  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx

; 2583 : 	}

  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
??$_Adjust_heap@PAURoundInfo@@HU1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoKoSort@@@Z ENDP ; std::_Adjust_heap<RoundInfo *,int,RoundInfo,RoundInfoKoSort>
_TEXT	ENDS
PUBLIC	??$_Med3@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@00VRoundInfoSort@@@Z ; std::_Med3<RoundInfo *,RoundInfoSort>
; Function compile flags: /Ogsp
;	COMDAT ??$_Med3@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@00VRoundInfoSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Med3@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@00VRoundInfoSort@@@Z PROC ; std::_Med3<RoundInfo *,RoundInfoSort>, COMDAT

; 3683 : 	{	// sort median of three elements to middle

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3684 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Mid$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  0000b	57		 push	 edi
  0000c	56		 push	 esi
  0000d	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00010	e8 00 00 00 00	 call	 ??RRoundInfoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoSort::operator()
  00015	84 c0		 test	 al, al
  00017	74 09		 je	 SHORT $LN6@Med3@2

; 3685 : 		_STD iter_swap(_Mid, _First);

  00019	57		 push	 edi
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z ; std::swap<RoundInfo>
  00020	59		 pop	 ecx
  00021	59		 pop	 ecx
$LN6@Med3@2:

; 3686 : 	if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid))

  00022	56		 push	 esi
  00023	ff 75 10	 push	 DWORD PTR __Last$[ebp]
  00026	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00029	e8 00 00 00 00	 call	 ??RRoundInfoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoSort::operator()
  0002e	84 c0		 test	 al, al
  00030	74 0b		 je	 SHORT $LN8@Med3@2

; 3687 : 		_STD iter_swap(_Last, _Mid);

  00032	56		 push	 esi
  00033	ff 75 10	 push	 DWORD PTR __Last$[ebp]
  00036	e8 00 00 00 00	 call	 ??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z ; std::swap<RoundInfo>
  0003b	59		 pop	 ecx
  0003c	59		 pop	 ecx
$LN8@Med3@2:

; 3688 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

  0003d	57		 push	 edi
  0003e	56		 push	 esi
  0003f	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00042	e8 00 00 00 00	 call	 ??RRoundInfoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoSort::operator()
  00047	84 c0		 test	 al, al
  00049	74 09		 je	 SHORT $LN10@Med3@2

; 3689 : 		_STD iter_swap(_Mid, _First);

  0004b	57		 push	 edi
  0004c	56		 push	 esi
  0004d	e8 00 00 00 00	 call	 ??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z ; std::swap<RoundInfo>
  00052	59		 pop	 ecx
  00053	59		 pop	 ecx
$LN10@Med3@2:
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi

; 3690 : 	}

  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
??$_Med3@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@00VRoundInfoSort@@@Z ENDP ; std::_Med3<RoundInfo *,RoundInfoSort>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAURoundInfo@@HU1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoSort@@@Z ; std::_Adjust_heap<RoundInfo *,int,RoundInfo,RoundInfoSort>
; Function compile flags: /Ogsp
;	COMDAT ??$_Adjust_heap@PAURoundInfo@@HU1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Top$ = 12						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Adjust_heap@PAURoundInfo@@HU1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoSort@@@Z PROC ; std::_Adjust_heap<RoundInfo *,int,RoundInfo,RoundInfoSort>, COMDAT

; 2565 : 	{	// percolate _Hole to _Bottom, then push _Val, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 2566 : 	_Diff _Top = _Hole;
; 2567 : 	_Diff _Idx = 2 * _Hole + 2;
; 2568 : 
; 2569 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Hole$[ebp]
  0000c	89 7d 0c	 mov	 DWORD PTR __Top$[ebp], edi
  0000f	8d 74 3f 02	 lea	 esi, DWORD PTR [edi+edi+2]
  00013	eb 33		 jmp	 SHORT $LN16@Adjust_hea@2
$LL5@Adjust_hea@2:

; 2570 : 		{	// move _Hole down to larger child
; 2571 : 		if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1))))

  00015	8b c6		 mov	 eax, esi
  00017	c1 e0 07	 shl	 eax, 7
  0001a	03 c3		 add	 eax, ebx
  0001c	8d 48 80	 lea	 ecx, DWORD PTR [eax-128]
  0001f	51		 push	 ecx
  00020	50		 push	 eax
  00021	8d 4d 18	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00024	e8 00 00 00 00	 call	 ??RRoundInfoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoSort::operator()
  00029	84 c0		 test	 al, al
  0002b	74 01		 je	 SHORT $LN2@Adjust_hea@2

; 2572 : 			--_Idx;

  0002d	4e		 dec	 esi
$LN2@Adjust_hea@2:

; 2573 : 		*(_First + _Hole) = _Move(*(_First + _Idx));

  0002e	8b c6		 mov	 eax, esi
  00030	c1 e0 07	 shl	 eax, 7
  00033	8b cf		 mov	 ecx, edi
  00035	03 c3		 add	 eax, ebx
  00037	c1 e1 07	 shl	 ecx, 7
  0003a	50		 push	 eax
  0003b	03 cb		 add	 ecx, ebx
  0003d	e8 00 00 00 00	 call	 ??4RoundInfo@@QAEAAU0@ABU0@@Z

; 2574 : 		_Hole = _Idx;

  00042	8b fe		 mov	 edi, esi
  00044	8d 74 36 02	 lea	 esi, DWORD PTR [esi+esi+2]
$LN16@Adjust_hea@2:

; 2566 : 	_Diff _Top = _Hole;
; 2567 : 	_Diff _Idx = 2 * _Hole + 2;
; 2568 : 
; 2569 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

  00048	3b 75 10	 cmp	 esi, DWORD PTR __Bottom$[ebp]
  0004b	7c c8		 jl	 SHORT $LL5@Adjust_hea@2

; 2575 : 		}
; 2576 : 
; 2577 : 	if (_Idx == _Bottom)

  0004d	75 1b		 jne	 SHORT $LN1@Adjust_hea@2

; 2578 : 		{	// only child at bottom, move _Hole down to it
; 2579 : 		*(_First + _Hole) = _Move(*(_First + (_Bottom - 1)));

  0004f	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  00052	c1 e0 07	 shl	 eax, 7
  00055	8b cf		 mov	 ecx, edi
  00057	8d 44 18 80	 lea	 eax, DWORD PTR [eax+ebx-128]
  0005b	c1 e1 07	 shl	 ecx, 7
  0005e	50		 push	 eax
  0005f	03 cb		 add	 ecx, ebx
  00061	e8 00 00 00 00	 call	 ??4RoundInfo@@QAEAAU0@ABU0@@Z

; 2580 : 		_Hole = _Bottom - 1;

  00066	8b 7d 10	 mov	 edi, DWORD PTR __Bottom$[ebp]
  00069	4f		 dec	 edi
$LN1@Adjust_hea@2:

; 2581 : 		}
; 2582 : 	_Push_heap(_First, _Hole, _Top, _Move(_Val), _Pred);

  0006a	ff 75 18	 push	 DWORD PTR __Pred$[ebp]
  0006d	ff 75 14	 push	 DWORD PTR __Val$[ebp]
  00070	ff 75 0c	 push	 DWORD PTR __Top$[ebp]
  00073	57		 push	 edi
  00074	53		 push	 ebx
  00075	e8 00 00 00 00	 call	 ??$_Push_heap@PAURoundInfo@@HU1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoSort@@@Z ; std::_Push_heap<RoundInfo *,int,RoundInfo,RoundInfoSort>
  0007a	83 c4 14	 add	 esp, 20			; 00000014H
  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx

; 2583 : 	}

  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
??$_Adjust_heap@PAURoundInfo@@HU1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoSort@@@Z ENDP ; std::_Adjust_heap<RoundInfo *,int,RoundInfo,RoundInfoSort>
_TEXT	ENDS
PUBLIC	??$_Med3@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@00VRoundInfoStarSort@@@Z ; std::_Med3<RoundInfo *,RoundInfoStarSort>
; Function compile flags: /Ogsp
;	COMDAT ??$_Med3@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@00VRoundInfoStarSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Med3@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@00VRoundInfoStarSort@@@Z PROC ; std::_Med3<RoundInfo *,RoundInfoStarSort>, COMDAT

; 3683 : 	{	// sort median of three elements to middle

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3684 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Mid$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  0000b	57		 push	 edi
  0000c	56		 push	 esi
  0000d	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00010	e8 00 00 00 00	 call	 ??RRoundInfoStarSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoStarSort::operator()
  00015	84 c0		 test	 al, al
  00017	74 09		 je	 SHORT $LN6@Med3@3

; 3685 : 		_STD iter_swap(_Mid, _First);

  00019	57		 push	 edi
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z ; std::swap<RoundInfo>
  00020	59		 pop	 ecx
  00021	59		 pop	 ecx
$LN6@Med3@3:

; 3686 : 	if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid))

  00022	56		 push	 esi
  00023	ff 75 10	 push	 DWORD PTR __Last$[ebp]
  00026	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00029	e8 00 00 00 00	 call	 ??RRoundInfoStarSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoStarSort::operator()
  0002e	84 c0		 test	 al, al
  00030	74 0b		 je	 SHORT $LN8@Med3@3

; 3687 : 		_STD iter_swap(_Last, _Mid);

  00032	56		 push	 esi
  00033	ff 75 10	 push	 DWORD PTR __Last$[ebp]
  00036	e8 00 00 00 00	 call	 ??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z ; std::swap<RoundInfo>
  0003b	59		 pop	 ecx
  0003c	59		 pop	 ecx
$LN8@Med3@3:

; 3688 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

  0003d	57		 push	 edi
  0003e	56		 push	 esi
  0003f	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00042	e8 00 00 00 00	 call	 ??RRoundInfoStarSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoStarSort::operator()
  00047	84 c0		 test	 al, al
  00049	74 09		 je	 SHORT $LN10@Med3@3

; 3689 : 		_STD iter_swap(_Mid, _First);

  0004b	57		 push	 edi
  0004c	56		 push	 esi
  0004d	e8 00 00 00 00	 call	 ??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z ; std::swap<RoundInfo>
  00052	59		 pop	 ecx
  00053	59		 pop	 ecx
$LN10@Med3@3:
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi

; 3690 : 	}

  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
??$_Med3@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@00VRoundInfoStarSort@@@Z ENDP ; std::_Med3<RoundInfo *,RoundInfoStarSort>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAURoundInfo@@HU1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoStarSort@@@Z ; std::_Adjust_heap<RoundInfo *,int,RoundInfo,RoundInfoStarSort>
; Function compile flags: /Ogsp
;	COMDAT ??$_Adjust_heap@PAURoundInfo@@HU1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoStarSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Top$ = 12						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Adjust_heap@PAURoundInfo@@HU1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoStarSort@@@Z PROC ; std::_Adjust_heap<RoundInfo *,int,RoundInfo,RoundInfoStarSort>, COMDAT

; 2565 : 	{	// percolate _Hole to _Bottom, then push _Val, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 2566 : 	_Diff _Top = _Hole;
; 2567 : 	_Diff _Idx = 2 * _Hole + 2;
; 2568 : 
; 2569 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Hole$[ebp]
  0000c	89 7d 0c	 mov	 DWORD PTR __Top$[ebp], edi
  0000f	8d 74 3f 02	 lea	 esi, DWORD PTR [edi+edi+2]
  00013	eb 33		 jmp	 SHORT $LN16@Adjust_hea@3
$LL5@Adjust_hea@3:

; 2570 : 		{	// move _Hole down to larger child
; 2571 : 		if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1))))

  00015	8b c6		 mov	 eax, esi
  00017	c1 e0 07	 shl	 eax, 7
  0001a	03 c3		 add	 eax, ebx
  0001c	8d 48 80	 lea	 ecx, DWORD PTR [eax-128]
  0001f	51		 push	 ecx
  00020	50		 push	 eax
  00021	8d 4d 18	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00024	e8 00 00 00 00	 call	 ??RRoundInfoStarSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoStarSort::operator()
  00029	84 c0		 test	 al, al
  0002b	74 01		 je	 SHORT $LN2@Adjust_hea@3

; 2572 : 			--_Idx;

  0002d	4e		 dec	 esi
$LN2@Adjust_hea@3:

; 2573 : 		*(_First + _Hole) = _Move(*(_First + _Idx));

  0002e	8b c6		 mov	 eax, esi
  00030	c1 e0 07	 shl	 eax, 7
  00033	8b cf		 mov	 ecx, edi
  00035	03 c3		 add	 eax, ebx
  00037	c1 e1 07	 shl	 ecx, 7
  0003a	50		 push	 eax
  0003b	03 cb		 add	 ecx, ebx
  0003d	e8 00 00 00 00	 call	 ??4RoundInfo@@QAEAAU0@ABU0@@Z

; 2574 : 		_Hole = _Idx;

  00042	8b fe		 mov	 edi, esi
  00044	8d 74 36 02	 lea	 esi, DWORD PTR [esi+esi+2]
$LN16@Adjust_hea@3:

; 2566 : 	_Diff _Top = _Hole;
; 2567 : 	_Diff _Idx = 2 * _Hole + 2;
; 2568 : 
; 2569 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

  00048	3b 75 10	 cmp	 esi, DWORD PTR __Bottom$[ebp]
  0004b	7c c8		 jl	 SHORT $LL5@Adjust_hea@3

; 2575 : 		}
; 2576 : 
; 2577 : 	if (_Idx == _Bottom)

  0004d	75 1b		 jne	 SHORT $LN1@Adjust_hea@3

; 2578 : 		{	// only child at bottom, move _Hole down to it
; 2579 : 		*(_First + _Hole) = _Move(*(_First + (_Bottom - 1)));

  0004f	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  00052	c1 e0 07	 shl	 eax, 7
  00055	8b cf		 mov	 ecx, edi
  00057	8d 44 18 80	 lea	 eax, DWORD PTR [eax+ebx-128]
  0005b	c1 e1 07	 shl	 ecx, 7
  0005e	50		 push	 eax
  0005f	03 cb		 add	 ecx, ebx
  00061	e8 00 00 00 00	 call	 ??4RoundInfo@@QAEAAU0@ABU0@@Z

; 2580 : 		_Hole = _Bottom - 1;

  00066	8b 7d 10	 mov	 edi, DWORD PTR __Bottom$[ebp]
  00069	4f		 dec	 edi
$LN1@Adjust_hea@3:

; 2581 : 		}
; 2582 : 	_Push_heap(_First, _Hole, _Top, _Move(_Val), _Pred);

  0006a	ff 75 18	 push	 DWORD PTR __Pred$[ebp]
  0006d	ff 75 14	 push	 DWORD PTR __Val$[ebp]
  00070	ff 75 0c	 push	 DWORD PTR __Top$[ebp]
  00073	57		 push	 edi
  00074	53		 push	 ebx
  00075	e8 00 00 00 00	 call	 ??$_Push_heap@PAURoundInfo@@HU1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoStarSort@@@Z ; std::_Push_heap<RoundInfo *,int,RoundInfo,RoundInfoStarSort>
  0007a	83 c4 14	 add	 esp, 20			; 00000014H
  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx

; 2583 : 	}

  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
??$_Adjust_heap@PAURoundInfo@@HU1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoStarSort@@@Z ENDP ; std::_Adjust_heap<RoundInfo *,int,RoundInfo,RoundInfoStarSort>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@PAURoundInfo@@HU1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@00$$QAU1@VRoundInfoKoSort@@PAH@Z ; std::_Pop_heap<RoundInfo *,int,RoundInfo,RoundInfoKoSort>
; Function compile flags: /Ogsp
;	COMDAT ??$_Pop_heap@PAURoundInfo@@HU1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@00$$QAU1@VRoundInfoKoSort@@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
___formal$ = 28						; size = 4
??$_Pop_heap@PAURoundInfo@@HU1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@00$$QAU1@VRoundInfoKoSort@@PAH@Z PROC ; std::_Pop_heap<RoundInfo *,int,RoundInfo,RoundInfoKoSort>, COMDAT

; 2591 : 	{	// pop *_First to *_Dest and reheap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2592 : 	*_Dest = _Move(*_First);

  00003	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00006	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00009	e8 00 00 00 00	 call	 ??4RoundInfo@@QAEAAU0@ABU0@@Z

; 2593 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2594 : 		_Move(_Val), _Pred);

  0000e	ff 75 18	 push	 DWORD PTR __Pred$[ebp]
  00011	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00014	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00017	ff 75 14	 push	 DWORD PTR __Val$[ebp]
  0001a	c1 f8 07	 sar	 eax, 7
  0001d	50		 push	 eax
  0001e	6a 00		 push	 0
  00020	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Adjust_heap@PAURoundInfo@@HU1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoKoSort@@@Z ; std::_Adjust_heap<RoundInfo *,int,RoundInfo,RoundInfoKoSort>
  00028	83 c4 14	 add	 esp, 20			; 00000014H

; 2595 : 	}

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??$_Pop_heap@PAURoundInfo@@HU1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@00$$QAU1@VRoundInfoKoSort@@PAH@Z ENDP ; std::_Pop_heap<RoundInfo *,int,RoundInfo,RoundInfoKoSort>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@PAURoundInfo@@HU1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@00$$QAU1@VRoundInfoSort@@PAH@Z ; std::_Pop_heap<RoundInfo *,int,RoundInfo,RoundInfoSort>
; Function compile flags: /Ogsp
;	COMDAT ??$_Pop_heap@PAURoundInfo@@HU1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@00$$QAU1@VRoundInfoSort@@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
___formal$ = 28						; size = 4
??$_Pop_heap@PAURoundInfo@@HU1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@00$$QAU1@VRoundInfoSort@@PAH@Z PROC ; std::_Pop_heap<RoundInfo *,int,RoundInfo,RoundInfoSort>, COMDAT

; 2591 : 	{	// pop *_First to *_Dest and reheap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2592 : 	*_Dest = _Move(*_First);

  00003	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00006	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00009	e8 00 00 00 00	 call	 ??4RoundInfo@@QAEAAU0@ABU0@@Z

; 2593 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2594 : 		_Move(_Val), _Pred);

  0000e	ff 75 18	 push	 DWORD PTR __Pred$[ebp]
  00011	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00014	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00017	ff 75 14	 push	 DWORD PTR __Val$[ebp]
  0001a	c1 f8 07	 sar	 eax, 7
  0001d	50		 push	 eax
  0001e	6a 00		 push	 0
  00020	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Adjust_heap@PAURoundInfo@@HU1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoSort@@@Z ; std::_Adjust_heap<RoundInfo *,int,RoundInfo,RoundInfoSort>
  00028	83 c4 14	 add	 esp, 20			; 00000014H

; 2595 : 	}

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??$_Pop_heap@PAURoundInfo@@HU1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@00$$QAU1@VRoundInfoSort@@PAH@Z ENDP ; std::_Pop_heap<RoundInfo *,int,RoundInfo,RoundInfoSort>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@PAURoundInfo@@HU1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@00$$QAU1@VRoundInfoStarSort@@PAH@Z ; std::_Pop_heap<RoundInfo *,int,RoundInfo,RoundInfoStarSort>
; Function compile flags: /Ogsp
;	COMDAT ??$_Pop_heap@PAURoundInfo@@HU1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@00$$QAU1@VRoundInfoStarSort@@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
___formal$ = 28						; size = 4
??$_Pop_heap@PAURoundInfo@@HU1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@00$$QAU1@VRoundInfoStarSort@@PAH@Z PROC ; std::_Pop_heap<RoundInfo *,int,RoundInfo,RoundInfoStarSort>, COMDAT

; 2591 : 	{	// pop *_First to *_Dest and reheap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2592 : 	*_Dest = _Move(*_First);

  00003	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00006	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00009	e8 00 00 00 00	 call	 ??4RoundInfo@@QAEAAU0@ABU0@@Z

; 2593 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2594 : 		_Move(_Val), _Pred);

  0000e	ff 75 18	 push	 DWORD PTR __Pred$[ebp]
  00011	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00014	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00017	ff 75 14	 push	 DWORD PTR __Val$[ebp]
  0001a	c1 f8 07	 sar	 eax, 7
  0001d	50		 push	 eax
  0001e	6a 00		 push	 0
  00020	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Adjust_heap@PAURoundInfo@@HU1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoStarSort@@@Z ; std::_Adjust_heap<RoundInfo *,int,RoundInfo,RoundInfoStarSort>
  00028	83 c4 14	 add	 esp, 20			; 00000014H

; 2595 : 	}

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??$_Pop_heap@PAURoundInfo@@HU1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@00$$QAU1@VRoundInfoStarSort@@PAH@Z ENDP ; std::_Pop_heap<RoundInfo *,int,RoundInfo,RoundInfoStarSort>
_TEXT	ENDS
PUBLIC	??0tagBattleRoomInfo@@QAE@XZ			; tagBattleRoomInfo::tagBattleRoomInfo
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
xdata$x	SEGMENT
__ehfuncinfo$??0tagBattleRoomInfo@@QAE@XZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0tagBattleRoomInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0tagBattleRoomInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0tagBattleRoomInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0tagBattleRoomInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0tagBattleRoomInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0tagBattleRoomInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0tagBattleRoomInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0tagBattleRoomInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0tagBattleRoomInfo@@QAE@XZ$6
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobattleroommgr.h
xdata$x	ENDS
;	COMDAT ??0tagBattleRoomInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
_value$568044 = -20					; size = 4
_value$568040 = -20					; size = 4
_value$568036 = -20					; size = 4
_value$568032 = -13					; size = 1
__$EHRec$ = -12						; size = 12
??0tagBattleRoomInfo@@QAE@XZ PROC			; tagBattleRoomInfo::tagBattleRoomInfo, COMDAT
; _this$ = ecx

; 158  : 	tagBattleRoomInfo()

  00000	6a 0c		 push	 12			; 0000000cH
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0tagBattleRoomInfo@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi
  00011	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_??0ioHashString@@QAE@XZ
  00017	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0001a	ff d7		 call	 edi
  0001c	33 db		 xor	 ebx, ebx
  0001e	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  00021	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00024	ff d7		 call	 edi
  00026	8d 4e 24	 lea	 ecx, DWORD PTR [esi+36]
  00029	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0002d	ff d7		 call	 edi
  0002f	8d 4e 6c	 lea	 ecx, DWORD PTR [esi+108]
  00032	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00036	e8 00 00 00 00	 call	 ??0?$CEncrypt@_N@@QAE@XZ ; CEncrypt<bool>::CEncrypt<bool>
  0003b	8d 8e 9c 00 00
	00		 lea	 ecx, DWORD PTR [esi+156]
  00041	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00045	e8 00 00 00 00	 call	 ??0?$CEncrypt@H@@QAE@XZ	; CEncrypt<int>::CEncrypt<int>
  0004a	8d 8e d8 00 00
	00		 lea	 ecx, DWORD PTR [esi+216]
  00050	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00054	e8 00 00 00 00	 call	 ??0?$CEncrypt@H@@QAE@XZ	; CEncrypt<int>::CEncrypt<int>
  00059	8d 8e 08 01 00
	00		 lea	 ecx, DWORD PTR [esi+264]
  0005f	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00063	e8 00 00 00 00	 call	 ??0?$CEncrypt@H@@QAE@XZ	; CEncrypt<int>::CEncrypt<int>

; 159  : 	{
; 160  : 		m_dwIndex				= 0;
; 161  : 		m_iCurJoiner			= 0;
; 162  : 		m_iCurPlayer			= 0;
; 163  : 		m_iMaxPlayerBlue		= 0;
; 164  : 		m_iMaxPlayerRed			= 0;
; 165  : 		m_iMaxObserver			= 0;
; 166  : 		m_iAverageLevel			= 0;
; 167  : 
; 168  : 		m_bRandomTeamMode = true;
; 169  : 		m_bStartRoomEnterX= false;
; 170  : 		m_bAutoModeStart  = false;
; 171  : 		m_bBadPingKick	  = true;		
; 172  : 		m_bUseExtraOption = false;

  00068	8d 45 f3	 lea	 eax, DWORD PTR _value$568032[ebp]
  0006b	50		 push	 eax
  0006c	8d 4e 6c	 lea	 ecx, DWORD PTR [esi+108]
  0006f	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00073	89 1e		 mov	 DWORD PTR [esi], ebx
  00075	89 5e 34	 mov	 DWORD PTR [esi+52], ebx
  00078	89 5e 38	 mov	 DWORD PTR [esi+56], ebx
  0007b	89 5e 3c	 mov	 DWORD PTR [esi+60], ebx
  0007e	89 5e 40	 mov	 DWORD PTR [esi+64], ebx
  00081	89 5e 44	 mov	 DWORD PTR [esi+68], ebx
  00084	89 5e 48	 mov	 DWORD PTR [esi+72], ebx
  00087	c7 46 64 01 00
	00 01		 mov	 DWORD PTR [esi+100], 16777217 ; 01000001H
  0008e	88 5d f3	 mov	 BYTE PTR _value$568032[ebp], bl
  00091	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@_N@@AAEXPBD@Z ; CEncrypt<bool>::EncryptValueToPool

; 173  : 		m_bNoChallenger = true;
; 174  : 
; 175  : 		m_iPreSetMode = 0;

  00096	8d 45 ec	 lea	 eax, DWORD PTR _value$568036[ebp]
  00099	50		 push	 eax
  0009a	8d 8e 9c 00 00
	00		 lea	 ecx, DWORD PTR [esi+156]
  000a0	c6 46 68 01	 mov	 BYTE PTR [esi+104], 1
  000a4	89 5d ec	 mov	 DWORD PTR _value$568036[ebp], ebx
  000a7	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@H@@AAEXPBD@Z ; CEncrypt<int>::EncryptValueToPool

; 176  : 
; 177  : 		m_iTeamAttackType = 0;
; 178  : 		m_iChangeCharType = 0;
; 179  : 		m_iCoolTimeType = 0;
; 180  : 		m_iRedHPType = 0;

  000ac	8d 45 ec	 lea	 eax, DWORD PTR _value$568040[ebp]
  000af	50		 push	 eax
  000b0	8d 8e d8 00 00
	00		 lea	 ecx, DWORD PTR [esi+216]
  000b6	89 9e cc 00 00
	00		 mov	 DWORD PTR [esi+204], ebx
  000bc	89 9e d0 00 00
	00		 mov	 DWORD PTR [esi+208], ebx
  000c2	89 9e d4 00 00
	00		 mov	 DWORD PTR [esi+212], ebx
  000c8	89 5d ec	 mov	 DWORD PTR _value$568040[ebp], ebx
  000cb	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@H@@AAEXPBD@Z ; CEncrypt<int>::EncryptValueToPool

; 181  : 		m_iBlueHPType = 0;

  000d0	8d 45 ec	 lea	 eax, DWORD PTR _value$568044[ebp]
  000d3	50		 push	 eax
  000d4	8d 8e 08 01 00
	00		 lea	 ecx, DWORD PTR [esi+264]
  000da	89 5d ec	 mov	 DWORD PTR _value$568044[ebp], ebx
  000dd	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@H@@AAEXPBD@Z ; CEncrypt<int>::EncryptValueToPool

; 182  : 		m_iDropDamageType = 0;

  000e2	89 9e 38 01 00
	00		 mov	 DWORD PTR [esi+312], ebx

; 183  : 		m_iGravityType = 0;

  000e8	89 9e 3c 01 00
	00		 mov	 DWORD PTR [esi+316], ebx

; 184  : 		m_iGetUpType = 0;

  000ee	89 9e 40 01 00
	00		 mov	 DWORD PTR [esi+320], ebx

; 185  : 		m_iKOType = 0;

  000f4	89 9e 44 01 00
	00		 mov	 DWORD PTR [esi+324], ebx

; 186  : 		m_iKOEffectType = 0;

  000fa	89 9e 48 01 00
	00		 mov	 DWORD PTR [esi+328], ebx

; 187  : 		m_iRedBlowType = 0;

  00100	89 9e 4c 01 00
	00		 mov	 DWORD PTR [esi+332], ebx

; 188  : 		m_iBlueBlowType = 0;

  00106	89 9e 50 01 00
	00		 mov	 DWORD PTR [esi+336], ebx

; 189  : 		m_iRedMoveSpeedType = 0;

  0010c	89 9e 54 01 00
	00		 mov	 DWORD PTR [esi+340], ebx

; 190  : 		m_iBlueMoveSpeedType = 0;

  00112	89 9e 58 01 00
	00		 mov	 DWORD PTR [esi+344], ebx

; 191  : 		m_iRedEquipType = 0;

  00118	89 9e 5c 01 00
	00		 mov	 DWORD PTR [esi+348], ebx

; 192  : 		m_iBlueEquipType = 0;

  0011e	89 9e 60 01 00
	00		 mov	 DWORD PTR [esi+352], ebx

; 193  : 
; 194  : 		m_dwTourIndex	 = 0;

  00124	89 9e 7c 01 00
	00		 mov	 DWORD PTR [esi+380], ebx

; 195  : 		m_dwBlueTeamIndex= 0;

  0012a	89 9e 80 01 00
	00		 mov	 DWORD PTR [esi+384], ebx

; 196  : 		m_dwRedTeamIndex = 0;

  00130	89 9e 84 01 00
	00		 mov	 DWORD PTR [esi+388], ebx

; 197  : 		m_dwTourStartTimer = 0;

  00136	89 9e 88 01 00
	00		 mov	 DWORD PTR [esi+392], ebx

; 198  : 		m_bTourStartSender = false;

  0013c	88 9e 8c 01 00
	00		 mov	 BYTE PTR [esi+396], bl

; 199  : 
; 200  : 		m_iCatchModeRoundType = 0;

  00142	89 9e 64 01 00
	00		 mov	 DWORD PTR [esi+356], ebx

; 201  : 		m_iCatchModeRoundTimeType = 0;

  00148	89 9e 68 01 00
	00		 mov	 DWORD PTR [esi+360], ebx

; 202  : 
; 203  : 		m_iGrowthUseType = 0;

  0014e	89 9e 6c 01 00
	00		 mov	 DWORD PTR [esi+364], ebx

; 204  : 		m_iExtraItemUseType = 0;
; 205  : 
; 206  : 		m_iBattleEventType      = BET_NORMAL;
; 207  : 
; 208  : 		m_iBlueWin				= 0;
; 209  : 		m_iBlueLose				= 0;
; 210  : 		m_iBlueVictories		= 0;
; 211  : 		m_iRedWin				= 0;
; 212  : 		m_iRedLose				= 0;
; 213  : 		m_iRedVictories			= 0;
; 214  : 
; 215  : 		m_iNumber               = 0;
; 216  : 		m_iState                = BRS_ACTIVE;

  00154	33 c0		 xor	 eax, eax
  00156	40		 inc	 eax
  00157	89 86 94 01 00
	00		 mov	 DWORD PTR [esi+404], eax

; 217  : 		m_bPassword				= false;
; 218  : 		m_iModeType				= MT_NONE;
; 219  : 		m_iModeSelectIndex      = BMT_RANDOM;

  0015d	89 86 a0 01 00
	00		 mov	 DWORD PTR [esi+416], eax
  00163	89 9e 70 01 00
	00		 mov	 DWORD PTR [esi+368], ebx
  00169	89 9e 74 01 00
	00		 mov	 DWORD PTR [esi+372], ebx
  0016f	89 5e 4c	 mov	 DWORD PTR [esi+76], ebx
  00172	89 5e 50	 mov	 DWORD PTR [esi+80], ebx
  00175	89 5e 54	 mov	 DWORD PTR [esi+84], ebx
  00178	89 5e 58	 mov	 DWORD PTR [esi+88], ebx
  0017b	89 5e 5c	 mov	 DWORD PTR [esi+92], ebx
  0017e	89 5e 60	 mov	 DWORD PTR [esi+96], ebx
  00181	89 9e 90 01 00
	00		 mov	 DWORD PTR [esi+400], ebx
  00187	88 9e 98 01 00
	00		 mov	 BYTE PTR [esi+408], bl
  0018d	89 9e 9c 01 00
	00		 mov	 DWORD PTR [esi+412], ebx

; 220  : 		m_iMaxPlayer			= 0;

  00193	89 9e a4 01 00
	00		 mov	 DWORD PTR [esi+420], ebx

; 221  : 
; 222  : 		m_iPlayState			= 0;

  00199	89 9e a8 01 00
	00		 mov	 DWORD PTR [esi+424], ebx

; 223  : 		m_iBlueTeamWinCount		= 0;

  0019f	89 9e ac 01 00
	00		 mov	 DWORD PTR [esi+428], ebx

; 224  : 		m_iRedTeamWinCount		= 0;

  001a5	89 9e b0 01 00
	00		 mov	 DWORD PTR [esi+432], ebx

; 225  : 		m_dwRemainPlayTime		= 0;

  001ab	89 9e b4 01 00
	00		 mov	 DWORD PTR [esi+436], ebx

; 226  : 		m_iAiLevel				= 0;

  001b1	89 9e 78 01 00
	00		 mov	 DWORD PTR [esi+376], ebx

; 227  : 	}

  001b7	8b c6		 mov	 eax, esi
  001b9	e8 00 00 00 00	 call	 __EH_epilog3
  001be	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0tagBattleRoomInfo@@QAE@XZ$0:
  00000	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??0tagBattleRoomInfo@@QAE@XZ$1:
  0000c	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 14	 add	 ecx, 20			; 00000014H
  00012	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??0tagBattleRoomInfo@@QAE@XZ$2:
  00018	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 c1 24	 add	 ecx, 36			; 00000024H
  0001e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??0tagBattleRoomInfo@@QAE@XZ$3:
  00024	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	83 c1 6c	 add	 ecx, 108		; 0000006cH
  0002a	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@_N@@UAE@XZ ; CEncrypt<bool>::~CEncrypt<bool>
__unwindfunclet$??0tagBattleRoomInfo@@QAE@XZ$4:
  0002f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
  00038	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@H@@UAE@XZ	; CEncrypt<int>::~CEncrypt<int>
__unwindfunclet$??0tagBattleRoomInfo@@QAE@XZ$5:
  0003d	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	81 c1 d8 00 00
	00		 add	 ecx, 216		; 000000d8H
  00046	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@H@@UAE@XZ	; CEncrypt<int>::~CEncrypt<int>
__unwindfunclet$??0tagBattleRoomInfo@@QAE@XZ$6:
  0004b	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	81 c1 08 01 00
	00		 add	 ecx, 264		; 00000108H
  00054	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@H@@UAE@XZ	; CEncrypt<int>::~CEncrypt<int>
__ehhandler$??0tagBattleRoomInfo@@QAE@XZ:
  00059	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0005d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00060	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00063	33 c8		 xor	 ecx, eax
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0tagBattleRoomInfo@@QAE@XZ
  0006f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0tagBattleRoomInfo@@QAE@XZ ENDP			; tagBattleRoomInfo::tagBattleRoomInfo
PUBLIC	?IsUseExtraOption@ioBattleRoomMgr@@QAE_NXZ	; ioBattleRoomMgr::IsUseExtraOption
; Function compile flags: /Ogsp
;	COMDAT ?IsUseExtraOption@ioBattleRoomMgr@@QAE_NXZ
_TEXT	SEGMENT
_value$568056 = -1					; size = 1
?IsUseExtraOption@ioBattleRoomMgr@@QAE_NXZ PROC		; ioBattleRoomMgr::IsUseExtraOption, COMDAT
; _this$ = ecx

; 471  : 	bool IsUseExtraOption() { return m_BattleRoom.m_bUseExtraOption; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 ff	 lea	 eax, DWORD PTR _value$568056[ebp]
  00007	50		 push	 eax
  00008	83 c1 70	 add	 ecx, 112		; 00000070H
  0000b	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  00010	8a 45 ff	 mov	 al, BYTE PTR _value$568056[ebp]
  00013	c9		 leave
  00014	c3		 ret	 0
?IsUseExtraOption@ioBattleRoomMgr@@QAE_NXZ ENDP		; ioBattleRoomMgr::IsUseExtraOption
_TEXT	ENDS
PUBLIC	?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ	; ioPlayMode::GetModeType
EXTRN	?m_ModeType@ioPlayMode@@1V?$CEncrypt@W4ModeType@@@@A:BYTE ; ioPlayMode::m_ModeType
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioplaymode.h
;	COMDAT ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ
_TEXT	SEGMENT
?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ PROC	; ioPlayMode::GetModeType, COMDAT

; 782  : 	static ModeType GetModeType() { return m_ModeType; }

  00000	6a 04		 push	 4
  00002	68 28 00 00 00	 push	 OFFSET ?m_ModeType@ioPlayMode@@1V?$CEncrypt@W4ModeType@@@@A+40
  00007	68 1c 00 00 00	 push	 OFFSET ?m_ModeType@ioPlayMode@@1V?$CEncrypt@W4ModeType@@@@A+28
  0000c	b9 0c 00 00 00	 mov	 ecx, OFFSET ?m_ModeType@ioPlayMode@@1V?$CEncrypt@W4ModeType@@@@A+12
  00011	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte
  00016	a1 28 00 00 00	 mov	 eax, DWORD PTR ?m_ModeType@ioPlayMode@@1V?$CEncrypt@W4ModeType@@@@A+40
  0001b	c3		 ret	 0
?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ENDP	; ioPlayMode::GetModeType
_TEXT	ENDS
PUBLIC	??_R0?AVioPlayMode@@@8				; ioPlayMode `RTTI Type Descriptor'
PUBLIC	??_R0?AVioHeadquartersMode@@@8			; ioHeadquartersMode `RTTI Type Descriptor'
PUBLIC	?ToHeadquartersMode@@YAPAVioHeadquartersMode@@PAVioPlayMode@@@Z ; ToHeadquartersMode
;	COMDAT ??_R0?AVioPlayMode@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioheadquartersmode.h
_DATA	SEGMENT
??_R0?AVioPlayMode@@@8 DD FLAT:??_7type_info@@6B@	; ioPlayMode `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioPlayMode@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVioHeadquartersMode@@@8
_DATA	SEGMENT
??_R0?AVioHeadquartersMode@@@8 DD FLAT:??_7type_info@@6B@ ; ioHeadquartersMode `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioHeadquartersMode@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToHeadquartersMode@@YAPAVioHeadquartersMode@@PAVioPlayMode@@@Z
_TEXT	SEGMENT
_pMode$ = 8						; size = 4
?ToHeadquartersMode@@YAPAVioHeadquartersMode@@PAVioPlayMode@@@Z PROC ; ToHeadquartersMode, COMDAT

; 234  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 235  : 	if( !pMode || pMode->GetModeType() != MT_HEADQUARTERS )

  00003	83 7d 08 00	 cmp	 DWORD PTR _pMode$[ebp], 0
  00007	74 25		 je	 SHORT $LN1@ToHeadquar
  00009	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  0000e	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  00011	75 1b		 jne	 SHORT $LN1@ToHeadquar

; 237  : 
; 238  : 	return dynamic_cast< ioHeadquartersMode* >( pMode );

  00013	6a 00		 push	 0
  00015	68 00 00 00 00	 push	 OFFSET ??_R0?AVioHeadquartersMode@@@8
  0001a	68 00 00 00 00	 push	 OFFSET ??_R0?AVioPlayMode@@@8
  0001f	6a 00		 push	 0
  00021	ff 75 08	 push	 DWORD PTR _pMode$[ebp]
  00024	e8 00 00 00 00	 call	 ___RTDynamicCast
  00029	83 c4 14	 add	 esp, 20			; 00000014H

; 239  : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
$LN1@ToHeadquar:

; 236  : 		return NULL;

  0002e	33 c0		 xor	 eax, eax

; 239  : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?ToHeadquartersMode@@YAPAVioHeadquartersMode@@PAVioPlayMode@@@Z ENDP ; ToHeadquartersMode
_TEXT	ENDS
PUBLIC	??_R0?AVioHouseMode@@@8				; ioHouseMode `RTTI Type Descriptor'
PUBLIC	?ToHouseMode@@YAPAVioHouseMode@@PAVioPlayMode@@@Z ; ToHouseMode
;	COMDAT ??_R0?AVioHouseMode@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iohousemode.h
_DATA	SEGMENT
??_R0?AVioHouseMode@@@8 DD FLAT:??_7type_info@@6B@	; ioHouseMode `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioHouseMode@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToHouseMode@@YAPAVioHouseMode@@PAVioPlayMode@@@Z
_TEXT	SEGMENT
_pMode$ = 8						; size = 4
?ToHouseMode@@YAPAVioHouseMode@@PAVioPlayMode@@@Z PROC	; ToHouseMode, COMDAT

; 165  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 166  : 	if( !pMode || pMode->GetModeType() != MT_HOUSE )

  00003	83 7d 08 00	 cmp	 DWORD PTR _pMode$[ebp], 0
  00007	74 25		 je	 SHORT $LN1@ToHouseMod
  00009	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  0000e	83 f8 17	 cmp	 eax, 23			; 00000017H
  00011	75 1b		 jne	 SHORT $LN1@ToHouseMod

; 168  : 
; 169  : 	return dynamic_cast< ioHouseMode* >( pMode );

  00013	6a 00		 push	 0
  00015	68 00 00 00 00	 push	 OFFSET ??_R0?AVioHouseMode@@@8
  0001a	68 00 00 00 00	 push	 OFFSET ??_R0?AVioPlayMode@@@8
  0001f	6a 00		 push	 0
  00021	ff 75 08	 push	 DWORD PTR _pMode$[ebp]
  00024	e8 00 00 00 00	 call	 ___RTDynamicCast
  00029	83 c4 14	 add	 esp, 20			; 00000014H

; 170  : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
$LN1@ToHouseMod:

; 167  : 		return NULL;

  0002e	33 c0		 xor	 eax, eax

; 170  : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?ToHouseMode@@YAPAVioHouseMode@@PAVioPlayMode@@@Z ENDP	; ToHouseMode
_TEXT	ENDS
PUBLIC	?iwm_show@RoundStateUserWnd@@UAEXXZ		; RoundStateUserWnd::iwm_show
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
;	COMDAT ?iwm_show@RoundStateUserWnd@@UAEXXZ
_TEXT	SEGMENT
?iwm_show@RoundStateUserWnd@@UAEXXZ PROC		; RoundStateUserWnd::iwm_show, COMDAT
; _this$ = ecx

; 606  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 607  : 	if( m_eWindowTeam == TEAM_BLUE )

  00003	83 be 58 02 00
	00 02		 cmp	 DWORD PTR [esi+600], 2
  0000a	75 5e		 jne	 SHORT $LN8@iwm_show@3

; 608  : 	{
; 609  : 		m_pCurrentDark = m_pBlueDark;

  0000c	8b 86 68 01 00
	00		 mov	 eax, DWORD PTR [esi+360]
  00012	89 86 3c 02 00
	00		 mov	 DWORD PTR [esi+572], eax

; 610  : 		m_pCurrentLight= m_pBlueLight;

  00018	8b 86 6c 01 00
	00		 mov	 eax, DWORD PTR [esi+364]
  0001e	89 86 40 02 00
	00		 mov	 DWORD PTR [esi+576], eax

; 611  : 		m_pCurrentOver = m_pBlueOver;

  00024	8b 86 70 01 00
	00		 mov	 eax, DWORD PTR [esi+368]
  0002a	89 86 44 02 00
	00		 mov	 DWORD PTR [esi+580], eax

; 612  : 		m_pCurrentNumber = m_pBlueNumber;

  00030	8b 86 e4 01 00
	00		 mov	 eax, DWORD PTR [esi+484]
  00036	89 86 48 02 00
	00		 mov	 DWORD PTR [esi+584], eax

; 613  : 		if( ioPlayMode::GetModeType() == MT_TEAM_SURVIVAL || ioPlayMode::GetModeType() == MT_DOUBLE_CROWN || ioPlayMode::GetModeType() == MT_TEAM_SURVIVAL_AI )

  0003c	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  00041	83 f8 06	 cmp	 eax, 6
  00044	74 1c		 je	 SHORT $LN6@iwm_show@3
  00046	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  0004b	83 f8 13	 cmp	 eax, 19			; 00000013H
  0004e	74 12		 je	 SHORT $LN6@iwm_show@3
  00050	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  00055	83 f8 16	 cmp	 eax, 22			; 00000016H
  00058	74 08		 je	 SHORT $LN6@iwm_show@3

; 616  : 		}
; 617  : 		else
; 618  : 			m_pCurrentNumberText = m_pBluePoint;

  0005a	8b 86 00 02 00
	00		 mov	 eax, DWORD PTR [esi+512]
  00060	eb 64		 jmp	 SHORT $LN11@iwm_show@3
$LN6@iwm_show@3:

; 614  : 		{
; 615  : 			m_pCurrentNumberText = m_pBluePer;

  00062	8b 86 f8 01 00
	00		 mov	 eax, DWORD PTR [esi+504]

; 619  : 	}
; 620  : 	else

  00068	eb 5c		 jmp	 SHORT $LN11@iwm_show@3
$LN8@iwm_show@3:

; 621  : 	{
; 622  : 		m_pCurrentDark = m_pRedDark;

  0006a	8b 86 74 01 00
	00		 mov	 eax, DWORD PTR [esi+372]
  00070	89 86 3c 02 00
	00		 mov	 DWORD PTR [esi+572], eax

; 623  : 		m_pCurrentLight= m_pRedLight;

  00076	8b 86 78 01 00
	00		 mov	 eax, DWORD PTR [esi+376]
  0007c	89 86 40 02 00
	00		 mov	 DWORD PTR [esi+576], eax

; 624  : 		m_pCurrentOver = m_pRedOver;

  00082	8b 86 7c 01 00
	00		 mov	 eax, DWORD PTR [esi+380]
  00088	89 86 44 02 00
	00		 mov	 DWORD PTR [esi+580], eax

; 625  : 		m_pCurrentNumber = m_pRedNumber;

  0008e	8b 86 e8 01 00
	00		 mov	 eax, DWORD PTR [esi+488]
  00094	89 86 48 02 00
	00		 mov	 DWORD PTR [esi+584], eax

; 626  : 
; 627  : 		if( ioPlayMode::GetModeType() == MT_TEAM_SURVIVAL || ioPlayMode::GetModeType() == MT_DOUBLE_CROWN || ioPlayMode::GetModeType() == MT_TEAM_SURVIVAL_AI )

  0009a	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  0009f	83 f8 06	 cmp	 eax, 6
  000a2	74 1c		 je	 SHORT $LN2@iwm_show@3
  000a4	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  000a9	83 f8 13	 cmp	 eax, 19			; 00000013H
  000ac	74 12		 je	 SHORT $LN2@iwm_show@3
  000ae	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  000b3	83 f8 16	 cmp	 eax, 22			; 00000016H
  000b6	74 08		 je	 SHORT $LN2@iwm_show@3

; 629  : 		else
; 630  : 			m_pCurrentNumberText = m_pRedPoint;

  000b8	8b 86 04 02 00
	00		 mov	 eax, DWORD PTR [esi+516]
  000be	eb 06		 jmp	 SHORT $LN11@iwm_show@3
$LN2@iwm_show@3:

; 628  : 			m_pCurrentNumberText = m_pRedPer;

  000c0	8b 86 fc 01 00
	00		 mov	 eax, DWORD PTR [esi+508]
$LN11@iwm_show@3:
  000c6	89 86 4c 02 00
	00		 mov	 DWORD PTR [esi+588], eax
  000cc	5e		 pop	 esi

; 631  : 	}
; 632  : }

  000cd	c3		 ret	 0
?iwm_show@RoundStateUserWnd@@UAEXXZ ENDP		; RoundStateUserWnd::iwm_show
_TEXT	ENDS
PUBLIC	__real@3f0a3d71
PUBLIC	?OnRenderMonsterTitle@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderMonsterTitle
EXTRN	?GetModeIcon@ioModeSelectInfo@@QAEPAVioUIRenderImage@@W4ModeType@@W4TeamType@@_N@Z:PROC ; ioModeSelectInfo::GetModeIcon
EXTRN	?GetSingleton@ioModeSelectInfo@@SAAAV1@XZ:PROC	; ioModeSelectInfo::GetSingleton
;	COMDAT __real@3f0a3d71
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
CONST	SEGMENT
__real@3f0a3d71 DD 03f0a3d71r			; 0.54
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
CONST	ENDS
;	COMDAT ?OnRenderMonsterTitle@RoundStateUserWnd@@IAEXHH@Z
_TEXT	SEGMENT
tv323 = -12						; size = 4
tv320 = -8						; size = 4
_value$568088 = -4					; size = 1
_pModeIcon$ = -4					; size = 4
_iFloorCountGap$ = -4					; size = 4
_iXPos$ = 8						; size = 4
tv343 = 12						; size = 4
_iYPos$ = 12						; size = 4
?OnRenderMonsterTitle@RoundStateUserWnd@@IAEXHH@Z PROC	; RoundStateUserWnd::OnRenderMonsterTitle, COMDAT
; _this$ = ecx

; 1233 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx

; 1234 : 	if( !m_pMonsterModeTitle || !m_pBlueNumber || !m_pModeIconBack || !m_pBlueFloor ) return;

  0000a	33 ff		 xor	 edi, edi
  0000c	39 be c4 01 00
	00		 cmp	 DWORD PTR [esi+452], edi
  00012	0f 84 ce 01 00
	00		 je	 $LN5@OnRenderMo@3
  00018	39 be e4 01 00
	00		 cmp	 DWORD PTR [esi+484], edi
  0001e	0f 84 c2 01 00
	00		 je	 $LN5@OnRenderMo@3
  00024	39 be b0 01 00
	00		 cmp	 DWORD PTR [esi+432], edi
  0002a	0f 84 b6 01 00
	00		 je	 $LN5@OnRenderMo@3
  00030	39 be ec 01 00
	00		 cmp	 DWORD PTR [esi+492], edi
  00036	0f 84 aa 01 00
	00		 je	 $LN5@OnRenderMo@3

; 1235 : 
; 1236 : 	int iFloorCountGap = 0;
; 1237 : 	if( m_iCurrentFloor >= 10 )

  0003c	83 be 64 02 00
	00 0a		 cmp	 DWORD PTR [esi+612], 10	; 0000000aH
  00043	89 7d fc	 mov	 DWORD PTR _iFloorCountGap$[ebp], edi
  00046	7c 07		 jl	 SHORT $LN4@OnRenderMo@3

; 1238 : 		iFloorCountGap = 11;

  00048	c7 45 fc 0b 00
	00 00		 mov	 DWORD PTR _iFloorCountGap$[ebp], 11 ; 0000000bH
$LN4@OnRenderMo@3:

; 1239 : 
; 1240 : 	m_pModeIconBack->SetScale( 0.54f );

  0004f	8b 8e b0 01 00
	00		 mov	 ecx, DWORD PTR [esi+432]
  00055	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0a3d71
  0005d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005f	53		 push	 ebx
  00060	51		 push	 ecx
  00061	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00066	ff 50 1c	 call	 DWORD PTR [eax+28]

; 1241 : 	m_pModeIconBack->Render( iXPos + 232 - iFloorCountGap, iYPos + 30, UI_RENDER_MULTIPLY, TFO_BILINEAR );

  00069	8b 8e b0 01 00
	00		 mov	 ecx, DWORD PTR [esi+432]
  0006f	8b 45 0c	 mov	 eax, DWORD PTR _iYPos$[ebp]
  00072	8b 5d 08	 mov	 ebx, DWORD PTR _iXPos$[ebp]
  00075	2b 5d fc	 sub	 ebx, DWORD PTR _iFloorCountGap$[ebp]
  00078	57		 push	 edi
  00079	57		 push	 edi
  0007a	6a 01		 push	 1
  0007c	83 c0 1e	 add	 eax, 30			; 0000001eH
  0007f	6a 08		 push	 8
  00081	0f 57 c0	 xorps	 xmm0, xmm0
  00084	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00088	51		 push	 ecx
  00089	8d 83 e8 00 00
	00		 lea	 eax, DWORD PTR [ebx+232]
  0008f	51		 push	 ecx
  00090	0f 57 c9	 xorps	 xmm1, xmm1
  00093	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00097	8b 01		 mov	 eax, DWORD PTR [ecx]
  00099	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0009f	f3 0f 11 45 f8	 movss	 DWORD PTR tv320[ebp], xmm0
  000a4	f3 0f 11 4d f4	 movss	 DWORD PTR tv323[ebp], xmm1
  000a9	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  000ae	ff 10		 call	 DWORD PTR [eax]

; 1242 : 
; 1243 : 	// 모드 아이콘
; 1244 : 	ioUIRenderImage *pModeIcon = g_ModeSelectInfo.GetModeIcon( ioPlayMode::GetModeType(), m_eWindowTeam, g_BattleRoomMgr.IsUseExtraOption() );

  000b0	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  000b5	8d 4d fc	 lea	 ecx, DWORD PTR _value$568088[ebp]
  000b8	51		 push	 ecx
  000b9	8d 48 70	 lea	 ecx, DWORD PTR [eax+112]
  000bc	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  000c1	ff 75 fc	 push	 DWORD PTR _value$568088[ebp]
  000c4	ff b6 58 02 00
	00		 push	 DWORD PTR [esi+600]
  000ca	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 ?GetSingleton@ioModeSelectInfo@@SAAAV1@XZ ; ioModeSelectInfo::GetSingleton
  000d5	8b c8		 mov	 ecx, eax
  000d7	e8 00 00 00 00	 call	 ?GetModeIcon@ioModeSelectInfo@@QAEPAVioUIRenderImage@@W4ModeType@@W4TeamType@@_N@Z ; ioModeSelectInfo::GetModeIcon
  000dc	89 45 fc	 mov	 DWORD PTR _pModeIcon$[ebp], eax

; 1245 : 	if( pModeIcon )

  000df	3b c7		 cmp	 eax, edi
  000e1	74 38		 je	 SHORT $LN3@OnRenderMo@3

; 1246 : 	{
; 1247 : 		pModeIcon->SetScale( 0.54f );

  000e3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0a3d71
  000eb	8b 10		 mov	 edx, DWORD PTR [eax]
  000ed	51		 push	 ecx
  000ee	8b c8		 mov	 ecx, eax
  000f0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f5	ff 52 1c	 call	 DWORD PTR [edx+28]

; 1248 : 		pModeIcon->Render( iXPos + 232 - iFloorCountGap, iYPos + 30, UI_RENDER_NORMAL, TFO_BILINEAR );

  000f8	8b 4d fc	 mov	 ecx, DWORD PTR _pModeIcon$[ebp]
  000fb	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv320[ebp]
  00100	8b 01		 mov	 eax, DWORD PTR [ecx]
  00102	57		 push	 edi
  00103	57		 push	 edi
  00104	6a 01		 push	 1
  00106	57		 push	 edi
  00107	51		 push	 ecx
  00108	51		 push	 ecx
  00109	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0010f	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR tv323[ebp]
  00114	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00119	ff 10		 call	 DWORD PTR [eax]
$LN3@OnRenderMo@3:

; 1249 : 	}
; 1250 : 
; 1251 : 	// 모드 타이틀
; 1252 : 	m_pMonsterModeTitle->Render( iXPos + 258 - iFloorCountGap, iYPos + 16 );  //TODO : 모드 타이틀 이미지임..

  0011b	8b 8e c4 01 00
	00		 mov	 ecx, DWORD PTR [esi+452]
  00121	8b 45 0c	 mov	 eax, DWORD PTR _iYPos$[ebp]
  00124	57		 push	 edi
  00125	57		 push	 edi
  00126	57		 push	 edi
  00127	57		 push	 edi
  00128	83 c0 10	 add	 eax, 16			; 00000010H
  0012b	0f 57 c0	 xorps	 xmm0, xmm0
  0012e	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00132	8b 01		 mov	 eax, DWORD PTR [ecx]
  00134	51		 push	 ecx
  00135	51		 push	 ecx
  00136	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0013c	f3 0f 11 45 0c	 movss	 DWORD PTR tv343[ebp], xmm0
  00141	81 c3 02 01 00
	00		 add	 ebx, 258		; 00000102H
  00147	0f 57 c0	 xorps	 xmm0, xmm0
  0014a	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  0014e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00153	ff 10		 call	 DWORD PTR [eax]

; 1253 : 
; 1254 : 	// 
; 1255 : 	m_pBlueNumber->RenderNum( iXPos + 368, iYPos + 16, m_iCurrentFloor );

  00155	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0015d	8b 5d 08	 mov	 ebx, DWORD PTR _iXPos$[ebp]
  00160	57		 push	 edi
  00161	57		 push	 edi
  00162	57		 push	 edi
  00163	57		 push	 edi
  00164	51		 push	 ecx
  00165	51		 push	 ecx
  00166	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0016c	0f 57 c0	 xorps	 xmm0, xmm0
  0016f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00174	ff b6 64 02 00
	00		 push	 DWORD PTR [esi+612]
  0017a	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR tv343[ebp]
  0017f	51		 push	 ecx
  00180	51		 push	 ecx
  00181	8b 8e e4 01 00
	00		 mov	 ecx, DWORD PTR [esi+484]
  00187	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0018d	8d 83 70 01 00
	00		 lea	 eax, DWORD PTR [ebx+368]
  00193	0f 57 c0	 xorps	 xmm0, xmm0
  00196	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0019a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0019f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?RenderNum@ioUIRenderImage@@QAEXMMHMMW4UIRenderType@@W4TextureFilterOption@@0W4RenerNumerFormatting@1@@Z

; 1256 : 	if( m_iCurrentFloor >= 10 )
; 1257 : 		iFloorCountGap = 46;
; 1258 : 	else
; 1259 : 		iFloorCountGap = 23;
; 1260 : 	m_pBlueFloor->Render( iXPos + 368 + iFloorCountGap, iYPos + 16 );

  001a5	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR tv343[ebp]
  001aa	33 c0		 xor	 eax, eax
  001ac	83 be 64 02 00
	00 0a		 cmp	 DWORD PTR [esi+612], 10	; 0000000aH
  001b3	8b b6 ec 01 00
	00		 mov	 esi, DWORD PTR [esi+492]
  001b9	8b 16		 mov	 edx, DWORD PTR [esi]
  001bb	57		 push	 edi
  001bc	0f 9c c0	 setl	 al
  001bf	57		 push	 edi
  001c0	57		 push	 edi
  001c1	57		 push	 edi
  001c2	51		 push	 ecx
  001c3	51		 push	 ecx
  001c4	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  001ca	48		 dec	 eax
  001cb	83 e0 17	 and	 eax, 23			; 00000017H
  001ce	8d 84 18 87 01
	00 00		 lea	 eax, DWORD PTR [eax+ebx+391]
  001d5	0f 57 c0	 xorps	 xmm0, xmm0
  001d8	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001dc	8b ce		 mov	 ecx, esi
  001de	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e3	ff 12		 call	 DWORD PTR [edx]
  001e5	5b		 pop	 ebx
$LN5@OnRenderMo@3:
  001e6	5f		 pop	 edi
  001e7	5e		 pop	 esi

; 1261 : }

  001e8	c9		 leave
  001e9	c2 08 00	 ret	 8
?OnRenderMonsterTitle@RoundStateUserWnd@@IAEXHH@Z ENDP	; RoundStateUserWnd::OnRenderMonsterTitle
_TEXT	ENDS
PUBLIC	?OnRenderTowerDefTitle@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderTowerDefTitle
; Function compile flags: /Ogsp
;	COMDAT ?OnRenderTowerDefTitle@RoundStateUserWnd@@IAEXHH@Z
_TEXT	SEGMENT
tv294 = -8						; size = 4
tv292 = -4						; size = 4
_value$568103 = 8					; size = 1
_pModeIcon$ = 8						; size = 4
_iXPos$ = 8						; size = 4
tv314 = 12						; size = 4
_iYPos$ = 12						; size = 4
?OnRenderTowerDefTitle@RoundStateUserWnd@@IAEXHH@Z PROC	; RoundStateUserWnd::OnRenderTowerDefTitle, COMDAT
; _this$ = ecx

; 1264 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f1		 mov	 esi, ecx

; 1265 : 	if( !m_pTowerDefTitle || !m_pTowerDefDiff[TOWERDEF_EASY] || !m_pTowerDefDiff[TOWERDEF_NORMAL] || 
; 1266 : 		!m_pTowerDefDiff[TOWERDEF_HARD] || !m_pTowerDefDiff[TOWERDEF_MASTER] || !m_pModeIconBack  ) return;

  00009	33 ff		 xor	 edi, edi
  0000b	39 be 08 02 00
	00		 cmp	 DWORD PTR [esi+520], edi
  00011	0f 84 7a 01 00
	00		 je	 $LN2@OnRenderTo@4
  00017	39 be 18 02 00
	00		 cmp	 DWORD PTR [esi+536], edi
  0001d	0f 84 6e 01 00
	00		 je	 $LN2@OnRenderTo@4
  00023	39 be 1c 02 00
	00		 cmp	 DWORD PTR [esi+540], edi
  00029	0f 84 62 01 00
	00		 je	 $LN2@OnRenderTo@4
  0002f	39 be 20 02 00
	00		 cmp	 DWORD PTR [esi+544], edi
  00035	0f 84 56 01 00
	00		 je	 $LN2@OnRenderTo@4
  0003b	39 be 24 02 00
	00		 cmp	 DWORD PTR [esi+548], edi
  00041	0f 84 4a 01 00
	00		 je	 $LN2@OnRenderTo@4
  00047	39 be b0 01 00
	00		 cmp	 DWORD PTR [esi+432], edi
  0004d	0f 84 3e 01 00
	00		 je	 $LN2@OnRenderTo@4

; 1267 : 
; 1268 : 	m_pModeIconBack->SetScale( 0.54f );

  00053	8b 8e b0 01 00
	00		 mov	 ecx, DWORD PTR [esi+432]
  00059	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0a3d71
  00061	8b 01		 mov	 eax, DWORD PTR [ecx]
  00063	53		 push	 ebx
  00064	51		 push	 ecx
  00065	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006a	ff 50 1c	 call	 DWORD PTR [eax+28]

; 1269 : 	m_pModeIconBack->Render( iXPos + 177, iYPos + 30, UI_RENDER_MULTIPLY, TFO_BILINEAR );

  0006d	8b 8e b0 01 00
	00		 mov	 ecx, DWORD PTR [esi+432]
  00073	8b 45 0c	 mov	 eax, DWORD PTR _iYPos$[ebp]
  00076	8b 5d 08	 mov	 ebx, DWORD PTR _iXPos$[ebp]
  00079	57		 push	 edi
  0007a	57		 push	 edi
  0007b	6a 01		 push	 1
  0007d	83 c0 1e	 add	 eax, 30			; 0000001eH
  00080	6a 08		 push	 8
  00082	0f 57 c0	 xorps	 xmm0, xmm0
  00085	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00089	51		 push	 ecx
  0008a	8d 83 b1 00 00
	00		 lea	 eax, DWORD PTR [ebx+177]
  00090	51		 push	 ecx
  00091	0f 57 c9	 xorps	 xmm1, xmm1
  00094	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00098	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009a	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000a0	f3 0f 11 45 fc	 movss	 DWORD PTR tv292[ebp], xmm0
  000a5	f3 0f 11 4d f8	 movss	 DWORD PTR tv294[ebp], xmm1
  000aa	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  000af	ff 10		 call	 DWORD PTR [eax]

; 1270 : 	//TODO 스노우타운 고칠 곳
; 1271 : 	// 모드 아이콘
; 1272 : 	ioUIRenderImage *pModeIcon = g_ModeSelectInfo.GetModeIcon( ioPlayMode::GetModeType(), m_eWindowTeam, g_BattleRoomMgr.IsUseExtraOption() );

  000b1	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  000b6	8d 4d 08	 lea	 ecx, DWORD PTR _value$568103[ebp]
  000b9	51		 push	 ecx
  000ba	8d 48 70	 lea	 ecx, DWORD PTR [eax+112]
  000bd	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  000c2	ff 75 08	 push	 DWORD PTR _value$568103[ebp]
  000c5	ff b6 58 02 00
	00		 push	 DWORD PTR [esi+600]
  000cb	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 ?GetSingleton@ioModeSelectInfo@@SAAAV1@XZ ; ioModeSelectInfo::GetSingleton
  000d6	8b c8		 mov	 ecx, eax
  000d8	e8 00 00 00 00	 call	 ?GetModeIcon@ioModeSelectInfo@@QAEPAVioUIRenderImage@@W4ModeType@@W4TeamType@@_N@Z ; ioModeSelectInfo::GetModeIcon
  000dd	89 45 08	 mov	 DWORD PTR _pModeIcon$[ebp], eax

; 1273 : 	if( pModeIcon )

  000e0	3b c7		 cmp	 eax, edi
  000e2	74 38		 je	 SHORT $LN1@OnRenderTo@4

; 1274 : 	{
; 1275 : 		pModeIcon->SetScale( 0.54f );

  000e4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0a3d71
  000ec	8b 10		 mov	 edx, DWORD PTR [eax]
  000ee	51		 push	 ecx
  000ef	8b c8		 mov	 ecx, eax
  000f1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f6	ff 52 1c	 call	 DWORD PTR [edx+28]

; 1276 : 		pModeIcon->Render( iXPos + 177, iYPos + 30, UI_RENDER_NORMAL, TFO_BILINEAR );

  000f9	8b 4d 08	 mov	 ecx, DWORD PTR _pModeIcon$[ebp]
  000fc	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR tv292[ebp]
  00101	8b 01		 mov	 eax, DWORD PTR [ecx]
  00103	57		 push	 edi
  00104	57		 push	 edi
  00105	6a 01		 push	 1
  00107	57		 push	 edi
  00108	51		 push	 ecx
  00109	51		 push	 ecx
  0010a	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00110	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv294[ebp]
  00115	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0011a	ff 10		 call	 DWORD PTR [eax]
$LN1@OnRenderTo@4:

; 1277 : 	}
; 1278 : 
; 1279 : 	// 모드 타이틀
; 1280 : 	m_pTowerDefTitle->Render( iXPos + 203, iYPos + 16 );  //TODO : 모드 타이틀 이미지임..

  0011c	8b 8e 08 02 00
	00		 mov	 ecx, DWORD PTR [esi+520]
  00122	8b 45 0c	 mov	 eax, DWORD PTR _iYPos$[ebp]
  00125	57		 push	 edi
  00126	57		 push	 edi
  00127	57		 push	 edi
  00128	57		 push	 edi
  00129	83 c0 10	 add	 eax, 16			; 00000010H
  0012c	0f 57 c0	 xorps	 xmm0, xmm0
  0012f	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00133	8b 01		 mov	 eax, DWORD PTR [ecx]
  00135	51		 push	 ecx
  00136	51		 push	 ecx
  00137	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0013d	f3 0f 11 45 0c	 movss	 DWORD PTR tv314[ebp], xmm0
  00142	8d 93 cb 00 00
	00		 lea	 edx, DWORD PTR [ebx+203]
  00148	0f 57 c0	 xorps	 xmm0, xmm0
  0014b	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  0014f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00154	ff 10		 call	 DWORD PTR [eax]

; 1281 : 	m_pTowerDefDiff[m_pPlayStage->GetModeSubNum() - 1]->Render( iXPos + 293, iYPos + 16 );  //TODO : 모드 타이틀 이미지임..

  00156	8b 86 94 02 00
	00		 mov	 eax, DWORD PTR [esi+660]
  0015c	8b 80 24 01 00
	00		 mov	 eax, DWORD PTR [eax+292]
  00162	8b 8c 86 14 02
	00 00		 mov	 ecx, DWORD PTR [esi+eax*4+532]
  00169	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR tv314[ebp]
  0016e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00170	57		 push	 edi
  00171	57		 push	 edi
  00172	57		 push	 edi
  00173	57		 push	 edi
  00174	51		 push	 ecx
  00175	51		 push	 ecx
  00176	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0017c	81 c3 25 01 00
	00		 add	 ebx, 293		; 00000125H
  00182	0f 57 c0	 xorps	 xmm0, xmm0
  00185	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  00189	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0018e	ff 10		 call	 DWORD PTR [eax]
  00190	5b		 pop	 ebx
$LN2@OnRenderTo@4:
  00191	5f		 pop	 edi
  00192	5e		 pop	 esi

; 1282 : }

  00193	c9		 leave
  00194	c2 08 00	 ret	 8
?OnRenderTowerDefTitle@RoundStateUserWnd@@IAEXHH@Z ENDP	; RoundStateUserWnd::OnRenderTowerDefTitle
_TEXT	ENDS
PUBLIC	?OnRenderFireTempleTitle@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderFireTempleTitle
; Function compile flags: /Ogsp
;	COMDAT ?OnRenderFireTempleTitle@RoundStateUserWnd@@IAEXHH@Z
_TEXT	SEGMENT
tv294 = -8						; size = 4
tv292 = -4						; size = 4
_value$568121 = 8					; size = 1
_pModeIcon$ = 8						; size = 4
_iXPos$ = 8						; size = 4
tv314 = 12						; size = 4
_iYPos$ = 12						; size = 4
?OnRenderFireTempleTitle@RoundStateUserWnd@@IAEXHH@Z PROC ; RoundStateUserWnd::OnRenderFireTempleTitle, COMDAT
; _this$ = ecx

; 1285 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f1		 mov	 esi, ecx

; 1286 : 	if( !m_pFireTempleTitle || !m_pTowerDefDiff[TOWERDEF_EASY] || !m_pTowerDefDiff[TOWERDEF_NORMAL] || 
; 1287 : 		!m_pTowerDefDiff[TOWERDEF_HARD] || !m_pTowerDefDiff[TOWERDEF_MASTER] || !m_pModeIconBack  ) return;

  00009	33 ff		 xor	 edi, edi
  0000b	39 be 10 02 00
	00		 cmp	 DWORD PTR [esi+528], edi
  00011	0f 84 7a 01 00
	00		 je	 $LN2@OnRenderFi@4
  00017	39 be 18 02 00
	00		 cmp	 DWORD PTR [esi+536], edi
  0001d	0f 84 6e 01 00
	00		 je	 $LN2@OnRenderFi@4
  00023	39 be 1c 02 00
	00		 cmp	 DWORD PTR [esi+540], edi
  00029	0f 84 62 01 00
	00		 je	 $LN2@OnRenderFi@4
  0002f	39 be 20 02 00
	00		 cmp	 DWORD PTR [esi+544], edi
  00035	0f 84 56 01 00
	00		 je	 $LN2@OnRenderFi@4
  0003b	39 be 24 02 00
	00		 cmp	 DWORD PTR [esi+548], edi
  00041	0f 84 4a 01 00
	00		 je	 $LN2@OnRenderFi@4
  00047	39 be b0 01 00
	00		 cmp	 DWORD PTR [esi+432], edi
  0004d	0f 84 3e 01 00
	00		 je	 $LN2@OnRenderFi@4

; 1288 : 
; 1289 : 	m_pModeIconBack->SetScale( 0.54f );

  00053	8b 8e b0 01 00
	00		 mov	 ecx, DWORD PTR [esi+432]
  00059	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0a3d71
  00061	8b 01		 mov	 eax, DWORD PTR [ecx]
  00063	53		 push	 ebx
  00064	51		 push	 ecx
  00065	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006a	ff 50 1c	 call	 DWORD PTR [eax+28]

; 1290 : 	m_pModeIconBack->Render( iXPos + 163, iYPos + 30, UI_RENDER_MULTIPLY, TFO_BILINEAR );

  0006d	8b 8e b0 01 00
	00		 mov	 ecx, DWORD PTR [esi+432]
  00073	8b 45 0c	 mov	 eax, DWORD PTR _iYPos$[ebp]
  00076	8b 5d 08	 mov	 ebx, DWORD PTR _iXPos$[ebp]
  00079	57		 push	 edi
  0007a	57		 push	 edi
  0007b	6a 01		 push	 1
  0007d	83 c0 1e	 add	 eax, 30			; 0000001eH
  00080	6a 08		 push	 8
  00082	0f 57 c0	 xorps	 xmm0, xmm0
  00085	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00089	51		 push	 ecx
  0008a	8d 83 a3 00 00
	00		 lea	 eax, DWORD PTR [ebx+163]
  00090	51		 push	 ecx
  00091	0f 57 c9	 xorps	 xmm1, xmm1
  00094	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00098	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009a	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000a0	f3 0f 11 45 fc	 movss	 DWORD PTR tv292[ebp], xmm0
  000a5	f3 0f 11 4d f8	 movss	 DWORD PTR tv294[ebp], xmm1
  000aa	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  000af	ff 10		 call	 DWORD PTR [eax]

; 1291 : 	//TODO 스노우타운 고칠 곳
; 1292 : 	// 모드 아이콘
; 1293 : 	ioUIRenderImage *pModeIcon = g_ModeSelectInfo.GetModeIcon( ioPlayMode::GetModeType(), m_eWindowTeam, g_BattleRoomMgr.IsUseExtraOption() );

  000b1	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  000b6	8d 4d 08	 lea	 ecx, DWORD PTR _value$568121[ebp]
  000b9	51		 push	 ecx
  000ba	8d 48 70	 lea	 ecx, DWORD PTR [eax+112]
  000bd	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  000c2	ff 75 08	 push	 DWORD PTR _value$568121[ebp]
  000c5	ff b6 58 02 00
	00		 push	 DWORD PTR [esi+600]
  000cb	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 ?GetSingleton@ioModeSelectInfo@@SAAAV1@XZ ; ioModeSelectInfo::GetSingleton
  000d6	8b c8		 mov	 ecx, eax
  000d8	e8 00 00 00 00	 call	 ?GetModeIcon@ioModeSelectInfo@@QAEPAVioUIRenderImage@@W4ModeType@@W4TeamType@@_N@Z ; ioModeSelectInfo::GetModeIcon
  000dd	89 45 08	 mov	 DWORD PTR _pModeIcon$[ebp], eax

; 1294 : 	if( pModeIcon )

  000e0	3b c7		 cmp	 eax, edi
  000e2	74 38		 je	 SHORT $LN1@OnRenderFi@4

; 1295 : 	{
; 1296 : 		pModeIcon->SetScale( 0.54f );

  000e4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0a3d71
  000ec	8b 10		 mov	 edx, DWORD PTR [eax]
  000ee	51		 push	 ecx
  000ef	8b c8		 mov	 ecx, eax
  000f1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f6	ff 52 1c	 call	 DWORD PTR [edx+28]

; 1297 : 		pModeIcon->Render( iXPos + 163, iYPos + 30, UI_RENDER_NORMAL, TFO_BILINEAR );

  000f9	8b 4d 08	 mov	 ecx, DWORD PTR _pModeIcon$[ebp]
  000fc	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR tv292[ebp]
  00101	8b 01		 mov	 eax, DWORD PTR [ecx]
  00103	57		 push	 edi
  00104	57		 push	 edi
  00105	6a 01		 push	 1
  00107	57		 push	 edi
  00108	51		 push	 ecx
  00109	51		 push	 ecx
  0010a	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00110	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv294[ebp]
  00115	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0011a	ff 10		 call	 DWORD PTR [eax]
$LN1@OnRenderFi@4:

; 1298 : 	}
; 1299 : 
; 1300 : 	// 모드 타이틀
; 1301 : 	m_pFireTempleTitle->Render( iXPos + 189, iYPos + 16 );  //TODO : 모드 타이틀 이미지임..

  0011c	8b 8e 10 02 00
	00		 mov	 ecx, DWORD PTR [esi+528]
  00122	8b 45 0c	 mov	 eax, DWORD PTR _iYPos$[ebp]
  00125	57		 push	 edi
  00126	57		 push	 edi
  00127	57		 push	 edi
  00128	57		 push	 edi
  00129	83 c0 10	 add	 eax, 16			; 00000010H
  0012c	0f 57 c0	 xorps	 xmm0, xmm0
  0012f	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00133	8b 01		 mov	 eax, DWORD PTR [ecx]
  00135	51		 push	 ecx
  00136	51		 push	 ecx
  00137	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0013d	f3 0f 11 45 0c	 movss	 DWORD PTR tv314[ebp], xmm0
  00142	8d 93 bd 00 00
	00		 lea	 edx, DWORD PTR [ebx+189]
  00148	0f 57 c0	 xorps	 xmm0, xmm0
  0014b	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  0014f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00154	ff 10		 call	 DWORD PTR [eax]

; 1302 : 	m_pTowerDefDiff[m_pPlayStage->GetModeSubNum() - 1]->Render( iXPos + 303, iYPos + 16 );  //TODO : 모드 타이틀 이미지임..

  00156	8b 86 94 02 00
	00		 mov	 eax, DWORD PTR [esi+660]
  0015c	8b 80 24 01 00
	00		 mov	 eax, DWORD PTR [eax+292]
  00162	8b 8c 86 14 02
	00 00		 mov	 ecx, DWORD PTR [esi+eax*4+532]
  00169	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR tv314[ebp]
  0016e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00170	57		 push	 edi
  00171	57		 push	 edi
  00172	57		 push	 edi
  00173	57		 push	 edi
  00174	51		 push	 ecx
  00175	51		 push	 ecx
  00176	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0017c	81 c3 2f 01 00
	00		 add	 ebx, 303		; 0000012fH
  00182	0f 57 c0	 xorps	 xmm0, xmm0
  00185	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  00189	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0018e	ff 10		 call	 DWORD PTR [eax]
  00190	5b		 pop	 ebx
$LN2@OnRenderFi@4:
  00191	5f		 pop	 edi
  00192	5e		 pop	 esi

; 1303 : }

  00193	c9		 leave
  00194	c2 08 00	 ret	 8
?OnRenderFireTempleTitle@RoundStateUserWnd@@IAEXHH@Z ENDP ; RoundStateUserWnd::OnRenderFireTempleTitle
_TEXT	ENDS
PUBLIC	?OnRenderSnowTownTitle@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderSnowTownTitle
; Function compile flags: /Ogsp
;	COMDAT ?OnRenderSnowTownTitle@RoundStateUserWnd@@IAEXHH@Z
_TEXT	SEGMENT
tv294 = -8						; size = 4
tv292 = -4						; size = 4
_value$568139 = 8					; size = 1
_pModeIcon$ = 8						; size = 4
_iXPos$ = 8						; size = 4
tv314 = 12						; size = 4
_iYPos$ = 12						; size = 4
?OnRenderSnowTownTitle@RoundStateUserWnd@@IAEXHH@Z PROC	; RoundStateUserWnd::OnRenderSnowTownTitle, COMDAT
; _this$ = ecx

; 1306 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f1		 mov	 esi, ecx

; 1307 : 	if( !m_pSnowTownTitle || !m_pTowerDefDiff[TOWERDEF_EASY] || !m_pTowerDefDiff[TOWERDEF_NORMAL] || 
; 1308 : 		!m_pTowerDefDiff[TOWERDEF_HARD] || !m_pTowerDefDiff[TOWERDEF_MASTER] || !m_pModeIconBack  ) return;

  00009	33 ff		 xor	 edi, edi
  0000b	39 be 0c 02 00
	00		 cmp	 DWORD PTR [esi+524], edi
  00011	0f 84 7a 01 00
	00		 je	 $LN2@OnRenderSn
  00017	39 be 18 02 00
	00		 cmp	 DWORD PTR [esi+536], edi
  0001d	0f 84 6e 01 00
	00		 je	 $LN2@OnRenderSn
  00023	39 be 1c 02 00
	00		 cmp	 DWORD PTR [esi+540], edi
  00029	0f 84 62 01 00
	00		 je	 $LN2@OnRenderSn
  0002f	39 be 20 02 00
	00		 cmp	 DWORD PTR [esi+544], edi
  00035	0f 84 56 01 00
	00		 je	 $LN2@OnRenderSn
  0003b	39 be 24 02 00
	00		 cmp	 DWORD PTR [esi+548], edi
  00041	0f 84 4a 01 00
	00		 je	 $LN2@OnRenderSn
  00047	39 be b0 01 00
	00		 cmp	 DWORD PTR [esi+432], edi
  0004d	0f 84 3e 01 00
	00		 je	 $LN2@OnRenderSn

; 1309 : 
; 1310 : 	m_pModeIconBack->SetScale( 0.54f );

  00053	8b 8e b0 01 00
	00		 mov	 ecx, DWORD PTR [esi+432]
  00059	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0a3d71
  00061	8b 01		 mov	 eax, DWORD PTR [ecx]
  00063	53		 push	 ebx
  00064	51		 push	 ecx
  00065	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006a	ff 50 1c	 call	 DWORD PTR [eax+28]

; 1311 : 	m_pModeIconBack->Render( iXPos + 154, iYPos + 30, UI_RENDER_MULTIPLY, TFO_BILINEAR );

  0006d	8b 8e b0 01 00
	00		 mov	 ecx, DWORD PTR [esi+432]
  00073	8b 45 0c	 mov	 eax, DWORD PTR _iYPos$[ebp]
  00076	8b 5d 08	 mov	 ebx, DWORD PTR _iXPos$[ebp]
  00079	57		 push	 edi
  0007a	57		 push	 edi
  0007b	6a 01		 push	 1
  0007d	83 c0 1e	 add	 eax, 30			; 0000001eH
  00080	6a 08		 push	 8
  00082	0f 57 c0	 xorps	 xmm0, xmm0
  00085	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00089	51		 push	 ecx
  0008a	8d 83 9a 00 00
	00		 lea	 eax, DWORD PTR [ebx+154]
  00090	51		 push	 ecx
  00091	0f 57 c9	 xorps	 xmm1, xmm1
  00094	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00098	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009a	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000a0	f3 0f 11 45 fc	 movss	 DWORD PTR tv292[ebp], xmm0
  000a5	f3 0f 11 4d f8	 movss	 DWORD PTR tv294[ebp], xmm1
  000aa	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  000af	ff 10		 call	 DWORD PTR [eax]

; 1312 : 	//TODO 스노우타운 고칠 곳
; 1313 : 	// 모드 아이콘
; 1314 : 	ioUIRenderImage *pModeIcon = g_ModeSelectInfo.GetModeIcon( ioPlayMode::GetModeType(), m_eWindowTeam, g_BattleRoomMgr.IsUseExtraOption() );

  000b1	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  000b6	8d 4d 08	 lea	 ecx, DWORD PTR _value$568139[ebp]
  000b9	51		 push	 ecx
  000ba	8d 48 70	 lea	 ecx, DWORD PTR [eax+112]
  000bd	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  000c2	ff 75 08	 push	 DWORD PTR _value$568139[ebp]
  000c5	ff b6 58 02 00
	00		 push	 DWORD PTR [esi+600]
  000cb	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 ?GetSingleton@ioModeSelectInfo@@SAAAV1@XZ ; ioModeSelectInfo::GetSingleton
  000d6	8b c8		 mov	 ecx, eax
  000d8	e8 00 00 00 00	 call	 ?GetModeIcon@ioModeSelectInfo@@QAEPAVioUIRenderImage@@W4ModeType@@W4TeamType@@_N@Z ; ioModeSelectInfo::GetModeIcon
  000dd	89 45 08	 mov	 DWORD PTR _pModeIcon$[ebp], eax

; 1315 : 	if( pModeIcon )

  000e0	3b c7		 cmp	 eax, edi
  000e2	74 38		 je	 SHORT $LN1@OnRenderSn

; 1316 : 	{
; 1317 : 		pModeIcon->SetScale( 0.54f );

  000e4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0a3d71
  000ec	8b 10		 mov	 edx, DWORD PTR [eax]
  000ee	51		 push	 ecx
  000ef	8b c8		 mov	 ecx, eax
  000f1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f6	ff 52 1c	 call	 DWORD PTR [edx+28]

; 1318 : 		pModeIcon->Render( iXPos + 154, iYPos + 30, UI_RENDER_NORMAL, TFO_BILINEAR );

  000f9	8b 4d 08	 mov	 ecx, DWORD PTR _pModeIcon$[ebp]
  000fc	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR tv292[ebp]
  00101	8b 01		 mov	 eax, DWORD PTR [ecx]
  00103	57		 push	 edi
  00104	57		 push	 edi
  00105	6a 01		 push	 1
  00107	57		 push	 edi
  00108	51		 push	 ecx
  00109	51		 push	 ecx
  0010a	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00110	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv294[ebp]
  00115	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0011a	ff 10		 call	 DWORD PTR [eax]
$LN1@OnRenderSn:

; 1319 : 	}
; 1320 : 
; 1321 : 	// 모드 타이틀
; 1322 : 	m_pSnowTownTitle->Render( iXPos + 180, iYPos + 16 );  //TODO : 모드 타이틀 이미지임..

  0011c	8b 8e 0c 02 00
	00		 mov	 ecx, DWORD PTR [esi+524]
  00122	8b 45 0c	 mov	 eax, DWORD PTR _iYPos$[ebp]
  00125	57		 push	 edi
  00126	57		 push	 edi
  00127	57		 push	 edi
  00128	57		 push	 edi
  00129	83 c0 10	 add	 eax, 16			; 00000010H
  0012c	0f 57 c0	 xorps	 xmm0, xmm0
  0012f	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00133	8b 01		 mov	 eax, DWORD PTR [ecx]
  00135	51		 push	 ecx
  00136	51		 push	 ecx
  00137	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0013d	f3 0f 11 45 0c	 movss	 DWORD PTR tv314[ebp], xmm0
  00142	8d 93 b4 00 00
	00		 lea	 edx, DWORD PTR [ebx+180]
  00148	0f 57 c0	 xorps	 xmm0, xmm0
  0014b	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  0014f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00154	ff 10		 call	 DWORD PTR [eax]

; 1323 : 	m_pTowerDefDiff[m_pPlayStage->GetModeSubNum() - 1]->Render( iXPos + 316, iYPos + 16 );  //TODO : 모드 타이틀 이미지임..

  00156	8b 86 94 02 00
	00		 mov	 eax, DWORD PTR [esi+660]
  0015c	8b 80 24 01 00
	00		 mov	 eax, DWORD PTR [eax+292]
  00162	8b 8c 86 14 02
	00 00		 mov	 ecx, DWORD PTR [esi+eax*4+532]
  00169	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR tv314[ebp]
  0016e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00170	57		 push	 edi
  00171	57		 push	 edi
  00172	57		 push	 edi
  00173	57		 push	 edi
  00174	51		 push	 ecx
  00175	51		 push	 ecx
  00176	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0017c	81 c3 3c 01 00
	00		 add	 ebx, 316		; 0000013cH
  00182	0f 57 c0	 xorps	 xmm0, xmm0
  00185	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  00189	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0018e	ff 10		 call	 DWORD PTR [eax]
  00190	5b		 pop	 ebx
$LN2@OnRenderSn:
  00191	5f		 pop	 edi
  00192	5e		 pop	 esi

; 1324 : }

  00193	c9		 leave
  00194	c2 08 00	 ret	 8
?OnRenderSnowTownTitle@RoundStateUserWnd@@IAEXHH@Z ENDP	; RoundStateUserWnd::OnRenderSnowTownTitle
_TEXT	ENDS
PUBLIC	?OnRenderFactoryTitle@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderFactoryTitle
; Function compile flags: /Ogsp
;	COMDAT ?OnRenderFactoryTitle@RoundStateUserWnd@@IAEXHH@Z
_TEXT	SEGMENT
tv294 = -8						; size = 4
tv292 = -4						; size = 4
_value$568157 = 8					; size = 1
_pModeIcon$ = 8						; size = 4
_iXPos$ = 8						; size = 4
tv314 = 12						; size = 4
_iYPos$ = 12						; size = 4
?OnRenderFactoryTitle@RoundStateUserWnd@@IAEXHH@Z PROC	; RoundStateUserWnd::OnRenderFactoryTitle, COMDAT
; _this$ = ecx

; 1327 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f1		 mov	 esi, ecx

; 1328 : 	if( !m_pFactoryTitle || !m_pTowerDefDiff[TOWERDEF_EASY] || !m_pTowerDefDiff[TOWERDEF_NORMAL] || 
; 1329 : 		!m_pTowerDefDiff[TOWERDEF_HARD] || !m_pTowerDefDiff[TOWERDEF_MASTER] || !m_pModeIconBack  ) return;

  00009	33 ff		 xor	 edi, edi
  0000b	39 be 14 02 00
	00		 cmp	 DWORD PTR [esi+532], edi
  00011	0f 84 7a 01 00
	00		 je	 $LN2@OnRenderFa
  00017	39 be 18 02 00
	00		 cmp	 DWORD PTR [esi+536], edi
  0001d	0f 84 6e 01 00
	00		 je	 $LN2@OnRenderFa
  00023	39 be 1c 02 00
	00		 cmp	 DWORD PTR [esi+540], edi
  00029	0f 84 62 01 00
	00		 je	 $LN2@OnRenderFa
  0002f	39 be 20 02 00
	00		 cmp	 DWORD PTR [esi+544], edi
  00035	0f 84 56 01 00
	00		 je	 $LN2@OnRenderFa
  0003b	39 be 24 02 00
	00		 cmp	 DWORD PTR [esi+548], edi
  00041	0f 84 4a 01 00
	00		 je	 $LN2@OnRenderFa
  00047	39 be b0 01 00
	00		 cmp	 DWORD PTR [esi+432], edi
  0004d	0f 84 3e 01 00
	00		 je	 $LN2@OnRenderFa

; 1330 : 
; 1331 : 	m_pModeIconBack->SetScale( 0.54f );

  00053	8b 8e b0 01 00
	00		 mov	 ecx, DWORD PTR [esi+432]
  00059	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0a3d71
  00061	8b 01		 mov	 eax, DWORD PTR [ecx]
  00063	53		 push	 ebx
  00064	51		 push	 ecx
  00065	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006a	ff 50 1c	 call	 DWORD PTR [eax+28]

; 1332 : 	m_pModeIconBack->Render( iXPos + 156, iYPos + 30, UI_RENDER_MULTIPLY, TFO_BILINEAR );

  0006d	8b 8e b0 01 00
	00		 mov	 ecx, DWORD PTR [esi+432]
  00073	8b 45 0c	 mov	 eax, DWORD PTR _iYPos$[ebp]
  00076	8b 5d 08	 mov	 ebx, DWORD PTR _iXPos$[ebp]
  00079	57		 push	 edi
  0007a	57		 push	 edi
  0007b	6a 01		 push	 1
  0007d	83 c0 1e	 add	 eax, 30			; 0000001eH
  00080	6a 08		 push	 8
  00082	0f 57 c0	 xorps	 xmm0, xmm0
  00085	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00089	51		 push	 ecx
  0008a	8d 83 9c 00 00
	00		 lea	 eax, DWORD PTR [ebx+156]
  00090	51		 push	 ecx
  00091	0f 57 c9	 xorps	 xmm1, xmm1
  00094	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00098	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009a	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000a0	f3 0f 11 45 fc	 movss	 DWORD PTR tv292[ebp], xmm0
  000a5	f3 0f 11 4d f8	 movss	 DWORD PTR tv294[ebp], xmm1
  000aa	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  000af	ff 10		 call	 DWORD PTR [eax]

; 1333 : 	//TODO 스노우타운 고칠 곳
; 1334 : 	// 모드 아이콘
; 1335 : 	ioUIRenderImage *pModeIcon = g_ModeSelectInfo.GetModeIcon( ioPlayMode::GetModeType(), m_eWindowTeam, g_BattleRoomMgr.IsUseExtraOption() );

  000b1	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  000b6	8d 4d 08	 lea	 ecx, DWORD PTR _value$568157[ebp]
  000b9	51		 push	 ecx
  000ba	8d 48 70	 lea	 ecx, DWORD PTR [eax+112]
  000bd	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  000c2	ff 75 08	 push	 DWORD PTR _value$568157[ebp]
  000c5	ff b6 58 02 00
	00		 push	 DWORD PTR [esi+600]
  000cb	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 ?GetSingleton@ioModeSelectInfo@@SAAAV1@XZ ; ioModeSelectInfo::GetSingleton
  000d6	8b c8		 mov	 ecx, eax
  000d8	e8 00 00 00 00	 call	 ?GetModeIcon@ioModeSelectInfo@@QAEPAVioUIRenderImage@@W4ModeType@@W4TeamType@@_N@Z ; ioModeSelectInfo::GetModeIcon
  000dd	89 45 08	 mov	 DWORD PTR _pModeIcon$[ebp], eax

; 1336 : 	if( pModeIcon )

  000e0	3b c7		 cmp	 eax, edi
  000e2	74 38		 je	 SHORT $LN1@OnRenderFa

; 1337 : 	{
; 1338 : 		pModeIcon->SetScale( 0.54f );

  000e4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0a3d71
  000ec	8b 10		 mov	 edx, DWORD PTR [eax]
  000ee	51		 push	 ecx
  000ef	8b c8		 mov	 ecx, eax
  000f1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f6	ff 52 1c	 call	 DWORD PTR [edx+28]

; 1339 : 		pModeIcon->Render( iXPos + 156, iYPos + 30, UI_RENDER_NORMAL, TFO_BILINEAR );

  000f9	8b 4d 08	 mov	 ecx, DWORD PTR _pModeIcon$[ebp]
  000fc	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR tv292[ebp]
  00101	8b 01		 mov	 eax, DWORD PTR [ecx]
  00103	57		 push	 edi
  00104	57		 push	 edi
  00105	6a 01		 push	 1
  00107	57		 push	 edi
  00108	51		 push	 ecx
  00109	51		 push	 ecx
  0010a	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00110	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv294[ebp]
  00115	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0011a	ff 10		 call	 DWORD PTR [eax]
$LN1@OnRenderFa:

; 1340 : 	}
; 1341 : 
; 1342 : 	// 모드 타이틀
; 1343 : 	m_pFactoryTitle->Render( iXPos + 182, iYPos + 16 );  //TODO : 모드 타이틀 이미지임..

  0011c	8b 8e 14 02 00
	00		 mov	 ecx, DWORD PTR [esi+532]
  00122	8b 45 0c	 mov	 eax, DWORD PTR _iYPos$[ebp]
  00125	57		 push	 edi
  00126	57		 push	 edi
  00127	57		 push	 edi
  00128	57		 push	 edi
  00129	83 c0 10	 add	 eax, 16			; 00000010H
  0012c	0f 57 c0	 xorps	 xmm0, xmm0
  0012f	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00133	8b 01		 mov	 eax, DWORD PTR [ecx]
  00135	51		 push	 ecx
  00136	51		 push	 ecx
  00137	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0013d	f3 0f 11 45 0c	 movss	 DWORD PTR tv314[ebp], xmm0
  00142	8d 93 b6 00 00
	00		 lea	 edx, DWORD PTR [ebx+182]
  00148	0f 57 c0	 xorps	 xmm0, xmm0
  0014b	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  0014f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00154	ff 10		 call	 DWORD PTR [eax]

; 1344 : 	m_pTowerDefDiff[m_pPlayStage->GetModeSubNum() - 1]->Render( iXPos + 292, iYPos + 16 );  //TODO : 모드 타이틀 이미지임..

  00156	8b 86 94 02 00
	00		 mov	 eax, DWORD PTR [esi+660]
  0015c	8b 80 24 01 00
	00		 mov	 eax, DWORD PTR [eax+292]
  00162	8b 8c 86 14 02
	00 00		 mov	 ecx, DWORD PTR [esi+eax*4+532]
  00169	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR tv314[ebp]
  0016e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00170	57		 push	 edi
  00171	57		 push	 edi
  00172	57		 push	 edi
  00173	57		 push	 edi
  00174	51		 push	 ecx
  00175	51		 push	 ecx
  00176	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0017c	81 c3 24 01 00
	00		 add	 ebx, 292		; 00000124H
  00182	0f 57 c0	 xorps	 xmm0, xmm0
  00185	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  00189	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0018e	ff 10		 call	 DWORD PTR [eax]
  00190	5b		 pop	 ebx
$LN2@OnRenderFa:
  00191	5f		 pop	 edi
  00192	5e		 pop	 esi

; 1345 : }

  00193	c9		 leave
  00194	c2 08 00	 ret	 8
?OnRenderFactoryTitle@RoundStateUserWnd@@IAEXHH@Z ENDP	; RoundStateUserWnd::OnRenderFactoryTitle
_TEXT	ENDS
PUBLIC	?OnRenderSurvivalTitle@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderSurvivalTitle
; Function compile flags: /Ogsp
;	COMDAT ?OnRenderSurvivalTitle@RoundStateUserWnd@@IAEXHH@Z
_TEXT	SEGMENT
tv323 = -12						; size = 4
tv320 = -8						; size = 4
_value$568175 = -4					; size = 1
_pModeIcon$ = -4					; size = 4
_iRankCountGap$ = -4					; size = 4
_iXPos$ = 8						; size = 4
tv343 = 12						; size = 4
_iYPos$ = 12						; size = 4
?OnRenderSurvivalTitle@RoundStateUserWnd@@IAEXHH@Z PROC	; RoundStateUserWnd::OnRenderSurvivalTitle, COMDAT
; _this$ = ecx

; 1348 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx

; 1349 : 	if( !m_pSurvivalModeTitle || !m_pRedNumber || !m_pModeIconBack || !m_pRedRank ) return;

  0000a	33 ff		 xor	 edi, edi
  0000c	39 be c8 01 00
	00		 cmp	 DWORD PTR [esi+456], edi
  00012	0f 84 ce 01 00
	00		 je	 $LN5@OnRenderSu
  00018	39 be e8 01 00
	00		 cmp	 DWORD PTR [esi+488], edi
  0001e	0f 84 c2 01 00
	00		 je	 $LN5@OnRenderSu
  00024	39 be b0 01 00
	00		 cmp	 DWORD PTR [esi+432], edi
  0002a	0f 84 b6 01 00
	00		 je	 $LN5@OnRenderSu
  00030	39 be f0 01 00
	00		 cmp	 DWORD PTR [esi+496], edi
  00036	0f 84 aa 01 00
	00		 je	 $LN5@OnRenderSu

; 1350 : 
; 1351 : 	int iRankCountGap = 0;
; 1352 : 	if( m_iCurrentRank >= 10 )

  0003c	83 be 68 02 00
	00 0a		 cmp	 DWORD PTR [esi+616], 10	; 0000000aH
  00043	89 7d fc	 mov	 DWORD PTR _iRankCountGap$[ebp], edi
  00046	7c 07		 jl	 SHORT $LN4@OnRenderSu

; 1353 : 		iRankCountGap = 11;

  00048	c7 45 fc 0b 00
	00 00		 mov	 DWORD PTR _iRankCountGap$[ebp], 11 ; 0000000bH
$LN4@OnRenderSu:

; 1354 : 
; 1355 : 	m_pModeIconBack->SetScale( 0.54f );

  0004f	8b 8e b0 01 00
	00		 mov	 ecx, DWORD PTR [esi+432]
  00055	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0a3d71
  0005d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005f	53		 push	 ebx
  00060	51		 push	 ecx
  00061	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00066	ff 50 1c	 call	 DWORD PTR [eax+28]

; 1356 : 	m_pModeIconBack->Render( iXPos + 232 - iRankCountGap, iYPos + 30, UI_RENDER_MULTIPLY, TFO_BILINEAR );

  00069	8b 8e b0 01 00
	00		 mov	 ecx, DWORD PTR [esi+432]
  0006f	8b 45 0c	 mov	 eax, DWORD PTR _iYPos$[ebp]
  00072	8b 5d 08	 mov	 ebx, DWORD PTR _iXPos$[ebp]
  00075	2b 5d fc	 sub	 ebx, DWORD PTR _iRankCountGap$[ebp]
  00078	57		 push	 edi
  00079	57		 push	 edi
  0007a	6a 01		 push	 1
  0007c	83 c0 1e	 add	 eax, 30			; 0000001eH
  0007f	6a 08		 push	 8
  00081	0f 57 c0	 xorps	 xmm0, xmm0
  00084	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00088	51		 push	 ecx
  00089	8d 83 e8 00 00
	00		 lea	 eax, DWORD PTR [ebx+232]
  0008f	51		 push	 ecx
  00090	0f 57 c9	 xorps	 xmm1, xmm1
  00093	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00097	8b 01		 mov	 eax, DWORD PTR [ecx]
  00099	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0009f	f3 0f 11 45 f8	 movss	 DWORD PTR tv320[ebp], xmm0
  000a4	f3 0f 11 4d f4	 movss	 DWORD PTR tv323[ebp], xmm1
  000a9	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  000ae	ff 10		 call	 DWORD PTR [eax]

; 1357 : 
; 1358 : 	// 모드 아이콘
; 1359 : 	ioUIRenderImage *pModeIcon = g_ModeSelectInfo.GetModeIcon( ioPlayMode::GetModeType(), m_eWindowTeam, g_BattleRoomMgr.IsUseExtraOption() );

  000b0	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  000b5	8d 4d fc	 lea	 ecx, DWORD PTR _value$568175[ebp]
  000b8	51		 push	 ecx
  000b9	8d 48 70	 lea	 ecx, DWORD PTR [eax+112]
  000bc	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  000c1	ff 75 fc	 push	 DWORD PTR _value$568175[ebp]
  000c4	ff b6 58 02 00
	00		 push	 DWORD PTR [esi+600]
  000ca	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 ?GetSingleton@ioModeSelectInfo@@SAAAV1@XZ ; ioModeSelectInfo::GetSingleton
  000d5	8b c8		 mov	 ecx, eax
  000d7	e8 00 00 00 00	 call	 ?GetModeIcon@ioModeSelectInfo@@QAEPAVioUIRenderImage@@W4ModeType@@W4TeamType@@_N@Z ; ioModeSelectInfo::GetModeIcon
  000dc	89 45 fc	 mov	 DWORD PTR _pModeIcon$[ebp], eax

; 1360 : 	if( pModeIcon )

  000df	3b c7		 cmp	 eax, edi
  000e1	74 38		 je	 SHORT $LN3@OnRenderSu

; 1361 : 	{
; 1362 : 		pModeIcon->SetScale( 0.54f );

  000e3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0a3d71
  000eb	8b 10		 mov	 edx, DWORD PTR [eax]
  000ed	51		 push	 ecx
  000ee	8b c8		 mov	 ecx, eax
  000f0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f5	ff 52 1c	 call	 DWORD PTR [edx+28]

; 1363 : 		pModeIcon->Render( iXPos + 232 - iRankCountGap, iYPos + 30, UI_RENDER_NORMAL, TFO_BILINEAR );

  000f8	8b 4d fc	 mov	 ecx, DWORD PTR _pModeIcon$[ebp]
  000fb	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv320[ebp]
  00100	8b 01		 mov	 eax, DWORD PTR [ecx]
  00102	57		 push	 edi
  00103	57		 push	 edi
  00104	6a 01		 push	 1
  00106	57		 push	 edi
  00107	51		 push	 ecx
  00108	51		 push	 ecx
  00109	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0010f	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR tv323[ebp]
  00114	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00119	ff 10		 call	 DWORD PTR [eax]
$LN3@OnRenderSu:

; 1364 : 	}
; 1365 : 
; 1366 : 	// 모드 타이틀
; 1367 : 	m_pSurvivalModeTitle->Render( iXPos + 258 - iRankCountGap, iYPos + 16 );

  0011b	8b 8e c8 01 00
	00		 mov	 ecx, DWORD PTR [esi+456]
  00121	8b 45 0c	 mov	 eax, DWORD PTR _iYPos$[ebp]
  00124	57		 push	 edi
  00125	57		 push	 edi
  00126	57		 push	 edi
  00127	57		 push	 edi
  00128	83 c0 10	 add	 eax, 16			; 00000010H
  0012b	0f 57 c0	 xorps	 xmm0, xmm0
  0012e	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00132	8b 01		 mov	 eax, DWORD PTR [ecx]
  00134	51		 push	 ecx
  00135	51		 push	 ecx
  00136	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0013c	f3 0f 11 45 0c	 movss	 DWORD PTR tv343[ebp], xmm0
  00141	81 c3 02 01 00
	00		 add	 ebx, 258		; 00000102H
  00147	0f 57 c0	 xorps	 xmm0, xmm0
  0014a	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  0014e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00153	ff 10		 call	 DWORD PTR [eax]

; 1368 : 
; 1369 : 	// 
; 1370 : 	m_pRedNumber->RenderNum( iXPos + 368, iYPos + 16, m_iCurrentRank );

  00155	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0015d	8b 5d 08	 mov	 ebx, DWORD PTR _iXPos$[ebp]
  00160	57		 push	 edi
  00161	57		 push	 edi
  00162	57		 push	 edi
  00163	57		 push	 edi
  00164	51		 push	 ecx
  00165	51		 push	 ecx
  00166	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0016c	0f 57 c0	 xorps	 xmm0, xmm0
  0016f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00174	ff b6 68 02 00
	00		 push	 DWORD PTR [esi+616]
  0017a	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR tv343[ebp]
  0017f	51		 push	 ecx
  00180	51		 push	 ecx
  00181	8b 8e e8 01 00
	00		 mov	 ecx, DWORD PTR [esi+488]
  00187	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0018d	8d 83 70 01 00
	00		 lea	 eax, DWORD PTR [ebx+368]
  00193	0f 57 c0	 xorps	 xmm0, xmm0
  00196	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0019a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0019f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?RenderNum@ioUIRenderImage@@QAEXMMHMMW4UIRenderType@@W4TextureFilterOption@@0W4RenerNumerFormatting@1@@Z

; 1371 : 	if( m_iCurrentRank >= 10 )
; 1372 : 		iRankCountGap = 46;
; 1373 : 	else
; 1374 : 		iRankCountGap = 23;
; 1375 : 	m_pRedRank->Render( iXPos + 368 + iRankCountGap, iYPos + 16 );

  001a5	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR tv343[ebp]
  001aa	33 c0		 xor	 eax, eax
  001ac	83 be 68 02 00
	00 0a		 cmp	 DWORD PTR [esi+616], 10	; 0000000aH
  001b3	8b b6 f0 01 00
	00		 mov	 esi, DWORD PTR [esi+496]
  001b9	8b 16		 mov	 edx, DWORD PTR [esi]
  001bb	57		 push	 edi
  001bc	0f 9c c0	 setl	 al
  001bf	57		 push	 edi
  001c0	57		 push	 edi
  001c1	57		 push	 edi
  001c2	51		 push	 ecx
  001c3	51		 push	 ecx
  001c4	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  001ca	48		 dec	 eax
  001cb	83 e0 17	 and	 eax, 23			; 00000017H
  001ce	8d 84 18 87 01
	00 00		 lea	 eax, DWORD PTR [eax+ebx+391]
  001d5	0f 57 c0	 xorps	 xmm0, xmm0
  001d8	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001dc	8b ce		 mov	 ecx, esi
  001de	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e3	ff 12		 call	 DWORD PTR [edx]
  001e5	5b		 pop	 ebx
$LN5@OnRenderSu:
  001e6	5f		 pop	 edi
  001e7	5e		 pop	 esi

; 1376 : }

  001e8	c9		 leave
  001e9	c2 08 00	 ret	 8
?OnRenderSurvivalTitle@RoundStateUserWnd@@IAEXHH@Z ENDP	; RoundStateUserWnd::OnRenderSurvivalTitle
_TEXT	ENDS
PUBLIC	?OnRenderFightClubTitle@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderFightClubTitle
; Function compile flags: /Ogsp
;	COMDAT ?OnRenderFightClubTitle@RoundStateUserWnd@@IAEXHH@Z
_TEXT	SEGMENT
tv246 = -12						; size = 4
tv244 = -8						; size = 4
_value$568189 = -4					; size = 1
_iXPos$ = 8						; size = 4
_iYPos$ = 12						; size = 4
?OnRenderFightClubTitle@RoundStateUserWnd@@IAEXHH@Z PROC ; RoundStateUserWnd::OnRenderFightClubTitle, COMDAT
; _this$ = ecx

; 1379 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx

; 1380 : 	if( !m_pFightModeTitle || !m_pModeIconBack ) return;

  0000a	33 ff		 xor	 edi, edi
  0000c	39 be d8 01 00
	00		 cmp	 DWORD PTR [esi+472], edi
  00012	0f 84 0b 01 00
	00		 je	 $LN2@OnRenderFi@5
  00018	39 be b0 01 00
	00		 cmp	 DWORD PTR [esi+432], edi
  0001e	0f 84 ff 00 00
	00		 je	 $LN2@OnRenderFi@5

; 1381 : 	
; 1382 : 	m_pModeIconBack->SetScale( 0.54f );

  00024	8b 8e b0 01 00
	00		 mov	 ecx, DWORD PTR [esi+432]
  0002a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0a3d71
  00032	8b 01		 mov	 eax, DWORD PTR [ecx]
  00034	53		 push	 ebx
  00035	51		 push	 ecx
  00036	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003b	ff 50 1c	 call	 DWORD PTR [eax+28]

; 1383 : 	m_pModeIconBack->Render( iXPos + 276, iYPos + 30, UI_RENDER_MULTIPLY, TFO_BILINEAR );

  0003e	8b 45 0c	 mov	 eax, DWORD PTR _iYPos$[ebp]
  00041	8b 8e b0 01 00
	00		 mov	 ecx, DWORD PTR [esi+432]
  00047	57		 push	 edi
  00048	57		 push	 edi
  00049	83 c0 1e	 add	 eax, 30			; 0000001eH
  0004c	6a 01		 push	 1
  0004e	0f 57 c0	 xorps	 xmm0, xmm0
  00051	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00055	8b 45 08	 mov	 eax, DWORD PTR _iXPos$[ebp]
  00058	6a 08		 push	 8
  0005a	05 14 01 00 00	 add	 eax, 276		; 00000114H
  0005f	51		 push	 ecx
  00060	51		 push	 ecx
  00061	0f 57 c9	 xorps	 xmm1, xmm1
  00064	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00068	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006a	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00070	f3 0f 11 45 f8	 movss	 DWORD PTR tv244[ebp], xmm0
  00075	f3 0f 11 4d f4	 movss	 DWORD PTR tv246[ebp], xmm1
  0007a	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  0007f	ff 10		 call	 DWORD PTR [eax]

; 1384 : 
; 1385 : 	// 모드 아이콘
; 1386 : 	ioUIRenderImage *pModeIcon = g_ModeSelectInfo.GetModeIcon( ioPlayMode::GetModeType(), m_eWindowTeam, g_BattleRoomMgr.IsUseExtraOption() );

  00081	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  00086	8d 4d fc	 lea	 ecx, DWORD PTR _value$568189[ebp]
  00089	51		 push	 ecx
  0008a	8d 48 70	 lea	 ecx, DWORD PTR [eax+112]
  0008d	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  00092	ff 75 fc	 push	 DWORD PTR _value$568189[ebp]
  00095	ff b6 58 02 00
	00		 push	 DWORD PTR [esi+600]
  0009b	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ?GetSingleton@ioModeSelectInfo@@SAAAV1@XZ ; ioModeSelectInfo::GetSingleton
  000a6	8b c8		 mov	 ecx, eax
  000a8	e8 00 00 00 00	 call	 ?GetModeIcon@ioModeSelectInfo@@QAEPAVioUIRenderImage@@W4ModeType@@W4TeamType@@_N@Z ; ioModeSelectInfo::GetModeIcon
  000ad	8b d8		 mov	 ebx, eax

; 1387 : 	if( pModeIcon )

  000af	3b df		 cmp	 ebx, edi
  000b1	74 37		 je	 SHORT $LN1@OnRenderFi@5

; 1388 : 	{
; 1389 : 		pModeIcon->SetScale( 0.54f );

  000b3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0a3d71
  000bb	8b 03		 mov	 eax, DWORD PTR [ebx]
  000bd	51		 push	 ecx
  000be	8b cb		 mov	 ecx, ebx
  000c0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c5	ff 50 1c	 call	 DWORD PTR [eax+28]

; 1390 : 		pModeIcon->Render( iXPos + 276, iYPos + 30, UI_RENDER_NORMAL, TFO_BILINEAR );

  000c8	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv244[ebp]
  000cd	8b 03		 mov	 eax, DWORD PTR [ebx]
  000cf	57		 push	 edi
  000d0	57		 push	 edi
  000d1	6a 01		 push	 1
  000d3	57		 push	 edi
  000d4	51		 push	 ecx
  000d5	51		 push	 ecx
  000d6	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000dc	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR tv246[ebp]
  000e1	8b cb		 mov	 ecx, ebx
  000e3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e8	ff 10		 call	 DWORD PTR [eax]
$LN1@OnRenderFi@5:

; 1391 : 	}
; 1392 : 
; 1393 : 	// 모드 타이틀
; 1394 : 	m_pFightModeTitle->Render( iXPos + 304, iYPos + 17 );

  000ea	8b 8e d8 01 00
	00		 mov	 ecx, DWORD PTR [esi+472]
  000f0	8b 55 0c	 mov	 edx, DWORD PTR _iYPos$[ebp]
  000f3	8b 01		 mov	 eax, DWORD PTR [ecx]
  000f5	57		 push	 edi
  000f6	57		 push	 edi
  000f7	57		 push	 edi
  000f8	57		 push	 edi
  000f9	83 c2 11	 add	 edx, 17			; 00000011H
  000fc	0f 57 c0	 xorps	 xmm0, xmm0
  000ff	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  00103	8b 55 08	 mov	 edx, DWORD PTR _iXPos$[ebp]
  00106	51		 push	 ecx
  00107	51		 push	 ecx
  00108	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0010e	81 c2 30 01 00
	00		 add	 edx, 304		; 00000130H
  00114	0f 57 c0	 xorps	 xmm0, xmm0
  00117	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  0011b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00120	ff 10		 call	 DWORD PTR [eax]
  00122	5b		 pop	 ebx
$LN2@OnRenderFi@5:
  00123	5f		 pop	 edi
  00124	5e		 pop	 esi

; 1395 : }

  00125	c9		 leave
  00126	c2 08 00	 ret	 8
?OnRenderFightClubTitle@RoundStateUserWnd@@IAEXHH@Z ENDP ; RoundStateUserWnd::OnRenderFightClubTitle
_TEXT	ENDS
PUBLIC	?OnRenderShuffleBonusTitle@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderShuffleBonusTitle
; Function compile flags: /Ogsp
;	COMDAT ?OnRenderShuffleBonusTitle@RoundStateUserWnd@@IAEXHH@Z
_TEXT	SEGMENT
tv323 = -12						; size = 4
tv320 = -8						; size = 4
_value$568203 = -4					; size = 1
_pModeIcon$ = -4					; size = 4
_iRankCountGap$ = -4					; size = 4
_iXPos$ = 8						; size = 4
tv343 = 12						; size = 4
_iYPos$ = 12						; size = 4
?OnRenderShuffleBonusTitle@RoundStateUserWnd@@IAEXHH@Z PROC ; RoundStateUserWnd::OnRenderShuffleBonusTitle, COMDAT
; _this$ = ecx

; 1398 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx

; 1399 : 	if( !m_pShuffleBonusModeTitle || !m_pRedNumber || !m_pModeIconBack || !m_pRedRank ) return;

  0000a	33 ff		 xor	 edi, edi
  0000c	39 be dc 01 00
	00		 cmp	 DWORD PTR [esi+476], edi
  00012	0f 84 ce 01 00
	00		 je	 $LN5@OnRenderSh@2
  00018	39 be e8 01 00
	00		 cmp	 DWORD PTR [esi+488], edi
  0001e	0f 84 c2 01 00
	00		 je	 $LN5@OnRenderSh@2
  00024	39 be b0 01 00
	00		 cmp	 DWORD PTR [esi+432], edi
  0002a	0f 84 b6 01 00
	00		 je	 $LN5@OnRenderSh@2
  00030	39 be f0 01 00
	00		 cmp	 DWORD PTR [esi+496], edi
  00036	0f 84 aa 01 00
	00		 je	 $LN5@OnRenderSh@2

; 1400 : 
; 1401 : 	int iRankCountGap = 0;
; 1402 : 	if( m_iCurrentRank >= 10 )

  0003c	83 be 68 02 00
	00 0a		 cmp	 DWORD PTR [esi+616], 10	; 0000000aH
  00043	89 7d fc	 mov	 DWORD PTR _iRankCountGap$[ebp], edi
  00046	7c 07		 jl	 SHORT $LN4@OnRenderSh@2

; 1403 : 		iRankCountGap = 11;

  00048	c7 45 fc 0b 00
	00 00		 mov	 DWORD PTR _iRankCountGap$[ebp], 11 ; 0000000bH
$LN4@OnRenderSh@2:

; 1404 : 
; 1405 : 	m_pModeIconBack->SetScale( 0.54f );

  0004f	8b 8e b0 01 00
	00		 mov	 ecx, DWORD PTR [esi+432]
  00055	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0a3d71
  0005d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005f	53		 push	 ebx
  00060	51		 push	 ecx
  00061	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00066	ff 50 1c	 call	 DWORD PTR [eax+28]

; 1406 : 	m_pModeIconBack->Render( iXPos + 218 - iRankCountGap, iYPos + 30, UI_RENDER_MULTIPLY, TFO_BILINEAR );

  00069	8b 8e b0 01 00
	00		 mov	 ecx, DWORD PTR [esi+432]
  0006f	8b 45 0c	 mov	 eax, DWORD PTR _iYPos$[ebp]
  00072	8b 5d 08	 mov	 ebx, DWORD PTR _iXPos$[ebp]
  00075	2b 5d fc	 sub	 ebx, DWORD PTR _iRankCountGap$[ebp]
  00078	57		 push	 edi
  00079	57		 push	 edi
  0007a	6a 01		 push	 1
  0007c	83 c0 1e	 add	 eax, 30			; 0000001eH
  0007f	6a 08		 push	 8
  00081	0f 57 c0	 xorps	 xmm0, xmm0
  00084	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00088	51		 push	 ecx
  00089	8d 83 da 00 00
	00		 lea	 eax, DWORD PTR [ebx+218]
  0008f	51		 push	 ecx
  00090	0f 57 c9	 xorps	 xmm1, xmm1
  00093	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00097	8b 01		 mov	 eax, DWORD PTR [ecx]
  00099	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0009f	f3 0f 11 45 f8	 movss	 DWORD PTR tv320[ebp], xmm0
  000a4	f3 0f 11 4d f4	 movss	 DWORD PTR tv323[ebp], xmm1
  000a9	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  000ae	ff 10		 call	 DWORD PTR [eax]

; 1407 : 
; 1408 : 	// 모드 아이콘
; 1409 : 	ioUIRenderImage *pModeIcon = g_ModeSelectInfo.GetModeIcon( ioPlayMode::GetModeType(), m_eWindowTeam, g_BattleRoomMgr.IsUseExtraOption() );

  000b0	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  000b5	8d 4d fc	 lea	 ecx, DWORD PTR _value$568203[ebp]
  000b8	51		 push	 ecx
  000b9	8d 48 70	 lea	 ecx, DWORD PTR [eax+112]
  000bc	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  000c1	ff 75 fc	 push	 DWORD PTR _value$568203[ebp]
  000c4	ff b6 58 02 00
	00		 push	 DWORD PTR [esi+600]
  000ca	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 ?GetSingleton@ioModeSelectInfo@@SAAAV1@XZ ; ioModeSelectInfo::GetSingleton
  000d5	8b c8		 mov	 ecx, eax
  000d7	e8 00 00 00 00	 call	 ?GetModeIcon@ioModeSelectInfo@@QAEPAVioUIRenderImage@@W4ModeType@@W4TeamType@@_N@Z ; ioModeSelectInfo::GetModeIcon
  000dc	89 45 fc	 mov	 DWORD PTR _pModeIcon$[ebp], eax

; 1410 : 	if( pModeIcon )

  000df	3b c7		 cmp	 eax, edi
  000e1	74 38		 je	 SHORT $LN3@OnRenderSh@2

; 1411 : 	{
; 1412 : 		pModeIcon->SetScale( 0.54f );

  000e3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0a3d71
  000eb	8b 10		 mov	 edx, DWORD PTR [eax]
  000ed	51		 push	 ecx
  000ee	8b c8		 mov	 ecx, eax
  000f0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f5	ff 52 1c	 call	 DWORD PTR [edx+28]

; 1413 : 		pModeIcon->Render( iXPos + 218 - iRankCountGap, iYPos + 30, UI_RENDER_NORMAL, TFO_BILINEAR );

  000f8	8b 4d fc	 mov	 ecx, DWORD PTR _pModeIcon$[ebp]
  000fb	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv320[ebp]
  00100	8b 01		 mov	 eax, DWORD PTR [ecx]
  00102	57		 push	 edi
  00103	57		 push	 edi
  00104	6a 01		 push	 1
  00106	57		 push	 edi
  00107	51		 push	 ecx
  00108	51		 push	 ecx
  00109	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0010f	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR tv323[ebp]
  00114	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00119	ff 10		 call	 DWORD PTR [eax]
$LN3@OnRenderSh@2:

; 1414 : 	}
; 1415 : 
; 1416 : 	// 모드 타이틀
; 1417 : 	m_pShuffleBonusModeTitle->Render( iXPos + 247 - iRankCountGap, iYPos + 16 );

  0011b	8b 8e dc 01 00
	00		 mov	 ecx, DWORD PTR [esi+476]
  00121	8b 45 0c	 mov	 eax, DWORD PTR _iYPos$[ebp]
  00124	57		 push	 edi
  00125	57		 push	 edi
  00126	57		 push	 edi
  00127	57		 push	 edi
  00128	83 c0 10	 add	 eax, 16			; 00000010H
  0012b	0f 57 c0	 xorps	 xmm0, xmm0
  0012e	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00132	8b 01		 mov	 eax, DWORD PTR [ecx]
  00134	51		 push	 ecx
  00135	51		 push	 ecx
  00136	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0013c	f3 0f 11 45 0c	 movss	 DWORD PTR tv343[ebp], xmm0
  00141	81 c3 f7 00 00
	00		 add	 ebx, 247		; 000000f7H
  00147	0f 57 c0	 xorps	 xmm0, xmm0
  0014a	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  0014e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00153	ff 10		 call	 DWORD PTR [eax]

; 1418 : 
; 1419 : 	// 
; 1420 : 	m_pRedNumber->RenderNum( iXPos + 388, iYPos + 16, m_iCurrentRank );

  00155	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0015d	8b 5d 08	 mov	 ebx, DWORD PTR _iXPos$[ebp]
  00160	57		 push	 edi
  00161	57		 push	 edi
  00162	57		 push	 edi
  00163	57		 push	 edi
  00164	51		 push	 ecx
  00165	51		 push	 ecx
  00166	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0016c	0f 57 c0	 xorps	 xmm0, xmm0
  0016f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00174	ff b6 68 02 00
	00		 push	 DWORD PTR [esi+616]
  0017a	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR tv343[ebp]
  0017f	51		 push	 ecx
  00180	51		 push	 ecx
  00181	8b 8e e8 01 00
	00		 mov	 ecx, DWORD PTR [esi+488]
  00187	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0018d	8d 83 84 01 00
	00		 lea	 eax, DWORD PTR [ebx+388]
  00193	0f 57 c0	 xorps	 xmm0, xmm0
  00196	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0019a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0019f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?RenderNum@ioUIRenderImage@@QAEXMMHMMW4UIRenderType@@W4TextureFilterOption@@0W4RenerNumerFormatting@1@@Z

; 1421 : 	if( m_iCurrentRank >= 10 )
; 1422 : 		iRankCountGap = 46;
; 1423 : 	else
; 1424 : 		iRankCountGap = 23;
; 1425 : 	m_pRedRank->Render( iXPos + 388 + iRankCountGap, iYPos + 16 );

  001a5	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR tv343[ebp]
  001aa	33 c0		 xor	 eax, eax
  001ac	83 be 68 02 00
	00 0a		 cmp	 DWORD PTR [esi+616], 10	; 0000000aH
  001b3	8b b6 f0 01 00
	00		 mov	 esi, DWORD PTR [esi+496]
  001b9	8b 16		 mov	 edx, DWORD PTR [esi]
  001bb	57		 push	 edi
  001bc	0f 9c c0	 setl	 al
  001bf	57		 push	 edi
  001c0	57		 push	 edi
  001c1	57		 push	 edi
  001c2	51		 push	 ecx
  001c3	51		 push	 ecx
  001c4	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  001ca	48		 dec	 eax
  001cb	83 e0 17	 and	 eax, 23			; 00000017H
  001ce	8d 84 18 9b 01
	00 00		 lea	 eax, DWORD PTR [eax+ebx+411]
  001d5	0f 57 c0	 xorps	 xmm0, xmm0
  001d8	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001dc	8b ce		 mov	 ecx, esi
  001de	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e3	ff 12		 call	 DWORD PTR [edx]
  001e5	5b		 pop	 ebx
$LN5@OnRenderSh@2:
  001e6	5f		 pop	 edi
  001e7	5e		 pop	 esi

; 1426 : }

  001e8	c9		 leave
  001e9	c2 08 00	 ret	 8
?OnRenderShuffleBonusTitle@RoundStateUserWnd@@IAEXHH@Z ENDP ; RoundStateUserWnd::OnRenderShuffleBonusTitle
_TEXT	ENDS
PUBLIC	?OnRenderRaidTitle@RoundStateUserWnd@@IAEXHH@Z	; RoundStateUserWnd::OnRenderRaidTitle
; Function compile flags: /Ogsp
;	COMDAT ?OnRenderRaidTitle@RoundStateUserWnd@@IAEXHH@Z
_TEXT	SEGMENT
tv323 = -12						; size = 4
tv320 = -8						; size = 4
_value$568217 = -4					; size = 1
_pModeIcon$ = -4					; size = 4
_iRankCountGap$ = -4					; size = 4
_iXPos$ = 8						; size = 4
tv343 = 12						; size = 4
_iYPos$ = 12						; size = 4
?OnRenderRaidTitle@RoundStateUserWnd@@IAEXHH@Z PROC	; RoundStateUserWnd::OnRenderRaidTitle, COMDAT
; _this$ = ecx

; 1429 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx

; 1430 : 	if( !m_pRaidModeTitle || !m_pBlueNumber || !m_pModeIconBack || !m_pBlueRank ) return;

  0000a	33 ff		 xor	 edi, edi
  0000c	39 be e0 01 00
	00		 cmp	 DWORD PTR [esi+480], edi
  00012	0f 84 ce 01 00
	00		 je	 $LN5@OnRenderRa@3
  00018	39 be e4 01 00
	00		 cmp	 DWORD PTR [esi+484], edi
  0001e	0f 84 c2 01 00
	00		 je	 $LN5@OnRenderRa@3
  00024	39 be b0 01 00
	00		 cmp	 DWORD PTR [esi+432], edi
  0002a	0f 84 b6 01 00
	00		 je	 $LN5@OnRenderRa@3
  00030	39 be f4 01 00
	00		 cmp	 DWORD PTR [esi+500], edi
  00036	0f 84 aa 01 00
	00		 je	 $LN5@OnRenderRa@3

; 1431 : 
; 1432 : 	int iRankCountGap = 0;
; 1433 : 	if( m_iCurrentRank >= 10 )

  0003c	83 be 68 02 00
	00 0a		 cmp	 DWORD PTR [esi+616], 10	; 0000000aH
  00043	89 7d fc	 mov	 DWORD PTR _iRankCountGap$[ebp], edi
  00046	7c 07		 jl	 SHORT $LN4@OnRenderRa@3

; 1434 : 		iRankCountGap = 11;

  00048	c7 45 fc 0b 00
	00 00		 mov	 DWORD PTR _iRankCountGap$[ebp], 11 ; 0000000bH
$LN4@OnRenderRa@3:

; 1435 : 
; 1436 : 	m_pModeIconBack->SetScale( 0.54f );

  0004f	8b 8e b0 01 00
	00		 mov	 ecx, DWORD PTR [esi+432]
  00055	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0a3d71
  0005d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005f	53		 push	 ebx
  00060	51		 push	 ecx
  00061	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00066	ff 50 1c	 call	 DWORD PTR [eax+28]

; 1437 : 	m_pModeIconBack->Render( iXPos + 232 - iRankCountGap, iYPos + 30, UI_RENDER_MULTIPLY, TFO_BILINEAR );

  00069	8b 8e b0 01 00
	00		 mov	 ecx, DWORD PTR [esi+432]
  0006f	8b 45 0c	 mov	 eax, DWORD PTR _iYPos$[ebp]
  00072	8b 5d 08	 mov	 ebx, DWORD PTR _iXPos$[ebp]
  00075	2b 5d fc	 sub	 ebx, DWORD PTR _iRankCountGap$[ebp]
  00078	57		 push	 edi
  00079	57		 push	 edi
  0007a	6a 01		 push	 1
  0007c	83 c0 1e	 add	 eax, 30			; 0000001eH
  0007f	6a 08		 push	 8
  00081	0f 57 c0	 xorps	 xmm0, xmm0
  00084	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00088	51		 push	 ecx
  00089	8d 83 e8 00 00
	00		 lea	 eax, DWORD PTR [ebx+232]
  0008f	51		 push	 ecx
  00090	0f 57 c9	 xorps	 xmm1, xmm1
  00093	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00097	8b 01		 mov	 eax, DWORD PTR [ecx]
  00099	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0009f	f3 0f 11 45 f8	 movss	 DWORD PTR tv320[ebp], xmm0
  000a4	f3 0f 11 4d f4	 movss	 DWORD PTR tv323[ebp], xmm1
  000a9	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  000ae	ff 10		 call	 DWORD PTR [eax]

; 1438 : 
; 1439 : 	// 모드 아이콘
; 1440 : 	ioUIRenderImage *pModeIcon = g_ModeSelectInfo.GetModeIcon( ioPlayMode::GetModeType(), m_eWindowTeam, g_BattleRoomMgr.IsUseExtraOption() );

  000b0	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  000b5	8d 4d fc	 lea	 ecx, DWORD PTR _value$568217[ebp]
  000b8	51		 push	 ecx
  000b9	8d 48 70	 lea	 ecx, DWORD PTR [eax+112]
  000bc	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  000c1	ff 75 fc	 push	 DWORD PTR _value$568217[ebp]
  000c4	ff b6 58 02 00
	00		 push	 DWORD PTR [esi+600]
  000ca	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 ?GetSingleton@ioModeSelectInfo@@SAAAV1@XZ ; ioModeSelectInfo::GetSingleton
  000d5	8b c8		 mov	 ecx, eax
  000d7	e8 00 00 00 00	 call	 ?GetModeIcon@ioModeSelectInfo@@QAEPAVioUIRenderImage@@W4ModeType@@W4TeamType@@_N@Z ; ioModeSelectInfo::GetModeIcon
  000dc	89 45 fc	 mov	 DWORD PTR _pModeIcon$[ebp], eax

; 1441 : 	if( pModeIcon )

  000df	3b c7		 cmp	 eax, edi
  000e1	74 38		 je	 SHORT $LN3@OnRenderRa@3

; 1442 : 	{
; 1443 : 		pModeIcon->SetScale( 0.54f );

  000e3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0a3d71
  000eb	8b 10		 mov	 edx, DWORD PTR [eax]
  000ed	51		 push	 ecx
  000ee	8b c8		 mov	 ecx, eax
  000f0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f5	ff 52 1c	 call	 DWORD PTR [edx+28]

; 1444 : 		pModeIcon->Render( iXPos + 232 - iRankCountGap, iYPos + 30, UI_RENDER_NORMAL, TFO_BILINEAR );

  000f8	8b 4d fc	 mov	 ecx, DWORD PTR _pModeIcon$[ebp]
  000fb	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv320[ebp]
  00100	8b 01		 mov	 eax, DWORD PTR [ecx]
  00102	57		 push	 edi
  00103	57		 push	 edi
  00104	6a 01		 push	 1
  00106	57		 push	 edi
  00107	51		 push	 ecx
  00108	51		 push	 ecx
  00109	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0010f	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR tv323[ebp]
  00114	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00119	ff 10		 call	 DWORD PTR [eax]
$LN3@OnRenderRa@3:

; 1445 : 	}
; 1446 : 
; 1447 : 	// 모드 타이틀
; 1448 : 	m_pRaidModeTitle->Render( iXPos + 258 - iRankCountGap, iYPos + 16 );

  0011b	8b 8e e0 01 00
	00		 mov	 ecx, DWORD PTR [esi+480]
  00121	8b 45 0c	 mov	 eax, DWORD PTR _iYPos$[ebp]
  00124	57		 push	 edi
  00125	57		 push	 edi
  00126	57		 push	 edi
  00127	57		 push	 edi
  00128	83 c0 10	 add	 eax, 16			; 00000010H
  0012b	0f 57 c0	 xorps	 xmm0, xmm0
  0012e	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00132	8b 01		 mov	 eax, DWORD PTR [ecx]
  00134	51		 push	 ecx
  00135	51		 push	 ecx
  00136	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0013c	f3 0f 11 45 0c	 movss	 DWORD PTR tv343[ebp], xmm0
  00141	81 c3 02 01 00
	00		 add	 ebx, 258		; 00000102H
  00147	0f 57 c0	 xorps	 xmm0, xmm0
  0014a	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  0014e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00153	ff 10		 call	 DWORD PTR [eax]

; 1449 : 
; 1450 : 	// 
; 1451 : 	m_pBlueNumber->RenderNum( iXPos + 342, iYPos + 16, m_iCurrentRank );

  00155	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0015d	8b 5d 08	 mov	 ebx, DWORD PTR _iXPos$[ebp]
  00160	57		 push	 edi
  00161	57		 push	 edi
  00162	57		 push	 edi
  00163	57		 push	 edi
  00164	51		 push	 ecx
  00165	51		 push	 ecx
  00166	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0016c	0f 57 c0	 xorps	 xmm0, xmm0
  0016f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00174	ff b6 68 02 00
	00		 push	 DWORD PTR [esi+616]
  0017a	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR tv343[ebp]
  0017f	51		 push	 ecx
  00180	51		 push	 ecx
  00181	8b 8e e4 01 00
	00		 mov	 ecx, DWORD PTR [esi+484]
  00187	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0018d	8d 83 56 01 00
	00		 lea	 eax, DWORD PTR [ebx+342]
  00193	0f 57 c0	 xorps	 xmm0, xmm0
  00196	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0019a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0019f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?RenderNum@ioUIRenderImage@@QAEXMMHMMW4UIRenderType@@W4TextureFilterOption@@0W4RenerNumerFormatting@1@@Z

; 1452 : 	if( m_iCurrentRank >= 10 )
; 1453 : 		iRankCountGap = 46;
; 1454 : 	else
; 1455 : 		iRankCountGap = 23;
; 1456 : 	m_pBlueRank->Render( iXPos + 342 + iRankCountGap, iYPos + 16 );

  001a5	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR tv343[ebp]
  001aa	33 c0		 xor	 eax, eax
  001ac	83 be 68 02 00
	00 0a		 cmp	 DWORD PTR [esi+616], 10	; 0000000aH
  001b3	8b b6 f4 01 00
	00		 mov	 esi, DWORD PTR [esi+500]
  001b9	8b 16		 mov	 edx, DWORD PTR [esi]
  001bb	57		 push	 edi
  001bc	0f 9c c0	 setl	 al
  001bf	57		 push	 edi
  001c0	57		 push	 edi
  001c1	57		 push	 edi
  001c2	51		 push	 ecx
  001c3	51		 push	 ecx
  001c4	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  001ca	48		 dec	 eax
  001cb	83 e0 17	 and	 eax, 23			; 00000017H
  001ce	8d 84 18 6d 01
	00 00		 lea	 eax, DWORD PTR [eax+ebx+365]
  001d5	0f 57 c0	 xorps	 xmm0, xmm0
  001d8	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001dc	8b ce		 mov	 ecx, esi
  001de	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e3	ff 12		 call	 DWORD PTR [edx]
  001e5	5b		 pop	 ebx
$LN5@OnRenderRa@3:
  001e6	5f		 pop	 edi
  001e7	5e		 pop	 esi

; 1457 : }

  001e8	c9		 leave
  001e9	c2 08 00	 ret	 8
?OnRenderRaidTitle@RoundStateUserWnd@@IAEXHH@Z ENDP	; RoundStateUserWnd::OnRenderRaidTitle
_TEXT	ENDS
PUBLIC	?OnRenderBossTitle@RoundStateUserWnd@@IAEXHH@Z	; RoundStateUserWnd::OnRenderBossTitle
; Function compile flags: /Ogsp
;	COMDAT ?OnRenderBossTitle@RoundStateUserWnd@@IAEXHH@Z
_TEXT	SEGMENT
tv323 = -12						; size = 4
tv320 = -8						; size = 4
_value$568231 = -4					; size = 1
_pModeIcon$ = -4					; size = 4
_iRankCountGap$ = -4					; size = 4
_iXPos$ = 8						; size = 4
tv343 = 12						; size = 4
_iYPos$ = 12						; size = 4
?OnRenderBossTitle@RoundStateUserWnd@@IAEXHH@Z PROC	; RoundStateUserWnd::OnRenderBossTitle, COMDAT
; _this$ = ecx

; 1460 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx

; 1461 : 	if( !m_pBossModeTitle || !m_pRedNumber || !m_pModeIconBack || !m_pRedRank ) return;

  0000a	33 ff		 xor	 edi, edi
  0000c	39 be cc 01 00
	00		 cmp	 DWORD PTR [esi+460], edi
  00012	0f 84 ce 01 00
	00		 je	 $LN5@OnRenderBo@2
  00018	39 be e8 01 00
	00		 cmp	 DWORD PTR [esi+488], edi
  0001e	0f 84 c2 01 00
	00		 je	 $LN5@OnRenderBo@2
  00024	39 be b0 01 00
	00		 cmp	 DWORD PTR [esi+432], edi
  0002a	0f 84 b6 01 00
	00		 je	 $LN5@OnRenderBo@2
  00030	39 be f0 01 00
	00		 cmp	 DWORD PTR [esi+496], edi
  00036	0f 84 aa 01 00
	00		 je	 $LN5@OnRenderBo@2

; 1462 : 
; 1463 : 	int iRankCountGap = 0;
; 1464 : 	if( m_iCurrentRank >= 10 )

  0003c	83 be 68 02 00
	00 0a		 cmp	 DWORD PTR [esi+616], 10	; 0000000aH
  00043	89 7d fc	 mov	 DWORD PTR _iRankCountGap$[ebp], edi
  00046	7c 07		 jl	 SHORT $LN4@OnRenderBo@2

; 1465 : 		iRankCountGap = 11;

  00048	c7 45 fc 0b 00
	00 00		 mov	 DWORD PTR _iRankCountGap$[ebp], 11 ; 0000000bH
$LN4@OnRenderBo@2:

; 1466 : 
; 1467 : 	m_pModeIconBack->SetScale( 0.54f );

  0004f	8b 8e b0 01 00
	00		 mov	 ecx, DWORD PTR [esi+432]
  00055	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0a3d71
  0005d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005f	53		 push	 ebx
  00060	51		 push	 ecx
  00061	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00066	ff 50 1c	 call	 DWORD PTR [eax+28]

; 1468 : 	m_pModeIconBack->Render( iXPos + 219 - iRankCountGap, iYPos + 30, UI_RENDER_MULTIPLY, TFO_BILINEAR );

  00069	8b 8e b0 01 00
	00		 mov	 ecx, DWORD PTR [esi+432]
  0006f	8b 45 0c	 mov	 eax, DWORD PTR _iYPos$[ebp]
  00072	8b 5d 08	 mov	 ebx, DWORD PTR _iXPos$[ebp]
  00075	2b 5d fc	 sub	 ebx, DWORD PTR _iRankCountGap$[ebp]
  00078	57		 push	 edi
  00079	57		 push	 edi
  0007a	6a 01		 push	 1
  0007c	83 c0 1e	 add	 eax, 30			; 0000001eH
  0007f	6a 08		 push	 8
  00081	0f 57 c0	 xorps	 xmm0, xmm0
  00084	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00088	51		 push	 ecx
  00089	8d 83 db 00 00
	00		 lea	 eax, DWORD PTR [ebx+219]
  0008f	51		 push	 ecx
  00090	0f 57 c9	 xorps	 xmm1, xmm1
  00093	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00097	8b 01		 mov	 eax, DWORD PTR [ecx]
  00099	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0009f	f3 0f 11 45 f8	 movss	 DWORD PTR tv320[ebp], xmm0
  000a4	f3 0f 11 4d f4	 movss	 DWORD PTR tv323[ebp], xmm1
  000a9	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  000ae	ff 10		 call	 DWORD PTR [eax]

; 1469 : 
; 1470 : 	// 모드 아이콘
; 1471 : 	ioUIRenderImage *pModeIcon = g_ModeSelectInfo.GetModeIcon( ioPlayMode::GetModeType(), m_eWindowTeam, g_BattleRoomMgr.IsUseExtraOption() );

  000b0	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  000b5	8d 4d fc	 lea	 ecx, DWORD PTR _value$568231[ebp]
  000b8	51		 push	 ecx
  000b9	8d 48 70	 lea	 ecx, DWORD PTR [eax+112]
  000bc	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  000c1	ff 75 fc	 push	 DWORD PTR _value$568231[ebp]
  000c4	ff b6 58 02 00
	00		 push	 DWORD PTR [esi+600]
  000ca	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 ?GetSingleton@ioModeSelectInfo@@SAAAV1@XZ ; ioModeSelectInfo::GetSingleton
  000d5	8b c8		 mov	 ecx, eax
  000d7	e8 00 00 00 00	 call	 ?GetModeIcon@ioModeSelectInfo@@QAEPAVioUIRenderImage@@W4ModeType@@W4TeamType@@_N@Z ; ioModeSelectInfo::GetModeIcon
  000dc	89 45 fc	 mov	 DWORD PTR _pModeIcon$[ebp], eax

; 1472 : 	if( pModeIcon )

  000df	3b c7		 cmp	 eax, edi
  000e1	74 38		 je	 SHORT $LN3@OnRenderBo@2

; 1473 : 	{
; 1474 : 		pModeIcon->SetScale( 0.54f );

  000e3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0a3d71
  000eb	8b 10		 mov	 edx, DWORD PTR [eax]
  000ed	51		 push	 ecx
  000ee	8b c8		 mov	 ecx, eax
  000f0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f5	ff 52 1c	 call	 DWORD PTR [edx+28]

; 1475 : 		pModeIcon->Render( iXPos + 219 - iRankCountGap, iYPos + 30, UI_RENDER_NORMAL, TFO_BILINEAR );

  000f8	8b 4d fc	 mov	 ecx, DWORD PTR _pModeIcon$[ebp]
  000fb	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv320[ebp]
  00100	8b 01		 mov	 eax, DWORD PTR [ecx]
  00102	57		 push	 edi
  00103	57		 push	 edi
  00104	6a 01		 push	 1
  00106	57		 push	 edi
  00107	51		 push	 ecx
  00108	51		 push	 ecx
  00109	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0010f	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR tv323[ebp]
  00114	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00119	ff 10		 call	 DWORD PTR [eax]
$LN3@OnRenderBo@2:

; 1476 : 	}
; 1477 : 
; 1478 : 	// 모드 타이틀
; 1479 : 	m_pBossModeTitle->Render( iXPos + 245 - iRankCountGap, iYPos + 16 );

  0011b	8b 8e cc 01 00
	00		 mov	 ecx, DWORD PTR [esi+460]
  00121	8b 45 0c	 mov	 eax, DWORD PTR _iYPos$[ebp]
  00124	57		 push	 edi
  00125	57		 push	 edi
  00126	57		 push	 edi
  00127	57		 push	 edi
  00128	83 c0 10	 add	 eax, 16			; 00000010H
  0012b	0f 57 c0	 xorps	 xmm0, xmm0
  0012e	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00132	8b 01		 mov	 eax, DWORD PTR [ecx]
  00134	51		 push	 ecx
  00135	51		 push	 ecx
  00136	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0013c	f3 0f 11 45 0c	 movss	 DWORD PTR tv343[ebp], xmm0
  00141	81 c3 f5 00 00
	00		 add	 ebx, 245		; 000000f5H
  00147	0f 57 c0	 xorps	 xmm0, xmm0
  0014a	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  0014e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00153	ff 10		 call	 DWORD PTR [eax]

; 1480 : 
; 1481 : 	// 
; 1482 : 	m_pRedNumber->RenderNum( iXPos + 381, iYPos + 16, m_iCurrentRank );

  00155	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0015d	8b 5d 08	 mov	 ebx, DWORD PTR _iXPos$[ebp]
  00160	57		 push	 edi
  00161	57		 push	 edi
  00162	57		 push	 edi
  00163	57		 push	 edi
  00164	51		 push	 ecx
  00165	51		 push	 ecx
  00166	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0016c	0f 57 c0	 xorps	 xmm0, xmm0
  0016f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00174	ff b6 68 02 00
	00		 push	 DWORD PTR [esi+616]
  0017a	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR tv343[ebp]
  0017f	51		 push	 ecx
  00180	51		 push	 ecx
  00181	8b 8e e8 01 00
	00		 mov	 ecx, DWORD PTR [esi+488]
  00187	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0018d	8d 83 7d 01 00
	00		 lea	 eax, DWORD PTR [ebx+381]
  00193	0f 57 c0	 xorps	 xmm0, xmm0
  00196	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0019a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0019f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?RenderNum@ioUIRenderImage@@QAEXMMHMMW4UIRenderType@@W4TextureFilterOption@@0W4RenerNumerFormatting@1@@Z

; 1483 : 	if( m_iCurrentRank >= 10 )
; 1484 : 		iRankCountGap = 46;
; 1485 : 	else
; 1486 : 		iRankCountGap = 23;
; 1487 : 	m_pRedRank->Render( iXPos + 381 + iRankCountGap, iYPos + 16 );

  001a5	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR tv343[ebp]
  001aa	33 c0		 xor	 eax, eax
  001ac	83 be 68 02 00
	00 0a		 cmp	 DWORD PTR [esi+616], 10	; 0000000aH
  001b3	8b b6 f0 01 00
	00		 mov	 esi, DWORD PTR [esi+496]
  001b9	8b 16		 mov	 edx, DWORD PTR [esi]
  001bb	57		 push	 edi
  001bc	0f 9c c0	 setl	 al
  001bf	57		 push	 edi
  001c0	57		 push	 edi
  001c1	57		 push	 edi
  001c2	51		 push	 ecx
  001c3	51		 push	 ecx
  001c4	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  001ca	48		 dec	 eax
  001cb	83 e0 17	 and	 eax, 23			; 00000017H
  001ce	8d 84 18 94 01
	00 00		 lea	 eax, DWORD PTR [eax+ebx+404]
  001d5	0f 57 c0	 xorps	 xmm0, xmm0
  001d8	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001dc	8b ce		 mov	 ecx, esi
  001de	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e3	ff 12		 call	 DWORD PTR [edx]
  001e5	5b		 pop	 ebx
$LN5@OnRenderBo@2:
  001e6	5f		 pop	 edi
  001e7	5e		 pop	 esi

; 1488 : }

  001e8	c9		 leave
  001e9	c2 08 00	 ret	 8
?OnRenderBossTitle@RoundStateUserWnd@@IAEXHH@Z ENDP	; RoundStateUserWnd::OnRenderBossTitle
_TEXT	ENDS
PUBLIC	?OnRenderGangsiTitle@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderGangsiTitle
; Function compile flags: /Ogsp
;	COMDAT ?OnRenderGangsiTitle@RoundStateUserWnd@@IAEXHH@Z
_TEXT	SEGMENT
tv323 = -12						; size = 4
tv320 = -8						; size = 4
_value$568245 = -4					; size = 1
_pModeIcon$ = -4					; size = 4
_iRankCountGap$ = -4					; size = 4
_iXPos$ = 8						; size = 4
tv343 = 12						; size = 4
_iYPos$ = 12						; size = 4
?OnRenderGangsiTitle@RoundStateUserWnd@@IAEXHH@Z PROC	; RoundStateUserWnd::OnRenderGangsiTitle, COMDAT
; _this$ = ecx

; 1491 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx

; 1492 : 	if( !m_pGangsiModeTitle1 || !m_pGangsiModeTitle2 || !m_pRedNumber || !m_pModeIconBack ) return;

  0000a	33 ff		 xor	 edi, edi
  0000c	39 be d0 01 00
	00		 cmp	 DWORD PTR [esi+464], edi
  00012	0f 84 ca 01 00
	00		 je	 $LN4@OnRenderGa@2
  00018	39 be d4 01 00
	00		 cmp	 DWORD PTR [esi+468], edi
  0001e	0f 84 be 01 00
	00		 je	 $LN4@OnRenderGa@2
  00024	39 be e8 01 00
	00		 cmp	 DWORD PTR [esi+488], edi
  0002a	0f 84 b2 01 00
	00		 je	 $LN4@OnRenderGa@2
  00030	39 be b0 01 00
	00		 cmp	 DWORD PTR [esi+432], edi
  00036	0f 84 a6 01 00
	00		 je	 $LN4@OnRenderGa@2

; 1493 : 
; 1494 : 	int iRankCountGap = 0;
; 1495 : 	if( m_iCurrentLiveUser >= 10 )

  0003c	83 be 70 02 00
	00 0a		 cmp	 DWORD PTR [esi+624], 10	; 0000000aH
  00043	89 7d fc	 mov	 DWORD PTR _iRankCountGap$[ebp], edi
  00046	7c 07		 jl	 SHORT $LN3@OnRenderGa@2

; 1496 : 		iRankCountGap = 11;

  00048	c7 45 fc 0b 00
	00 00		 mov	 DWORD PTR _iRankCountGap$[ebp], 11 ; 0000000bH
$LN3@OnRenderGa@2:

; 1497 : 
; 1498 : 	m_pModeIconBack->SetScale( 0.54f );

  0004f	8b 8e b0 01 00
	00		 mov	 ecx, DWORD PTR [esi+432]
  00055	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0a3d71
  0005d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005f	53		 push	 ebx
  00060	51		 push	 ecx
  00061	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00066	ff 50 1c	 call	 DWORD PTR [eax+28]

; 1499 : 	m_pModeIconBack->Render( iXPos + 177 - iRankCountGap, iYPos + 30, UI_RENDER_MULTIPLY, TFO_BILINEAR );

  00069	8b 8e b0 01 00
	00		 mov	 ecx, DWORD PTR [esi+432]
  0006f	8b 45 0c	 mov	 eax, DWORD PTR _iYPos$[ebp]
  00072	8b 5d 08	 mov	 ebx, DWORD PTR _iXPos$[ebp]
  00075	2b 5d fc	 sub	 ebx, DWORD PTR _iRankCountGap$[ebp]
  00078	57		 push	 edi
  00079	57		 push	 edi
  0007a	6a 01		 push	 1
  0007c	83 c0 1e	 add	 eax, 30			; 0000001eH
  0007f	6a 08		 push	 8
  00081	0f 57 c0	 xorps	 xmm0, xmm0
  00084	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00088	51		 push	 ecx
  00089	8d 83 b1 00 00
	00		 lea	 eax, DWORD PTR [ebx+177]
  0008f	51		 push	 ecx
  00090	0f 57 c9	 xorps	 xmm1, xmm1
  00093	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00097	8b 01		 mov	 eax, DWORD PTR [ecx]
  00099	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0009f	f3 0f 11 45 f8	 movss	 DWORD PTR tv320[ebp], xmm0
  000a4	f3 0f 11 4d f4	 movss	 DWORD PTR tv323[ebp], xmm1
  000a9	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  000ae	ff 10		 call	 DWORD PTR [eax]

; 1500 : 
; 1501 : 	// 모드 아이콘
; 1502 : 	ioUIRenderImage *pModeIcon = g_ModeSelectInfo.GetModeIcon( ioPlayMode::GetModeType(), m_eWindowTeam, g_BattleRoomMgr.IsUseExtraOption() );

  000b0	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  000b5	8d 4d fc	 lea	 ecx, DWORD PTR _value$568245[ebp]
  000b8	51		 push	 ecx
  000b9	8d 48 70	 lea	 ecx, DWORD PTR [eax+112]
  000bc	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  000c1	ff 75 fc	 push	 DWORD PTR _value$568245[ebp]
  000c4	ff b6 58 02 00
	00		 push	 DWORD PTR [esi+600]
  000ca	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 ?GetSingleton@ioModeSelectInfo@@SAAAV1@XZ ; ioModeSelectInfo::GetSingleton
  000d5	8b c8		 mov	 ecx, eax
  000d7	e8 00 00 00 00	 call	 ?GetModeIcon@ioModeSelectInfo@@QAEPAVioUIRenderImage@@W4ModeType@@W4TeamType@@_N@Z ; ioModeSelectInfo::GetModeIcon
  000dc	89 45 fc	 mov	 DWORD PTR _pModeIcon$[ebp], eax

; 1503 : 	if( pModeIcon )

  000df	3b c7		 cmp	 eax, edi
  000e1	74 38		 je	 SHORT $LN2@OnRenderGa@2

; 1504 : 	{
; 1505 : 		pModeIcon->SetScale( 0.54f );

  000e3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0a3d71
  000eb	8b 10		 mov	 edx, DWORD PTR [eax]
  000ed	51		 push	 ecx
  000ee	8b c8		 mov	 ecx, eax
  000f0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f5	ff 52 1c	 call	 DWORD PTR [edx+28]

; 1506 : 		pModeIcon->Render( iXPos + 177 - iRankCountGap, iYPos + 30, UI_RENDER_NORMAL, TFO_BILINEAR );

  000f8	8b 4d fc	 mov	 ecx, DWORD PTR _pModeIcon$[ebp]
  000fb	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv320[ebp]
  00100	8b 01		 mov	 eax, DWORD PTR [ecx]
  00102	57		 push	 edi
  00103	57		 push	 edi
  00104	6a 01		 push	 1
  00106	57		 push	 edi
  00107	51		 push	 ecx
  00108	51		 push	 ecx
  00109	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0010f	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR tv323[ebp]
  00114	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00119	ff 10		 call	 DWORD PTR [eax]
$LN2@OnRenderGa@2:

; 1507 : 	}
; 1508 : 
; 1509 : 	// 모드 타이틀
; 1510 : 	m_pGangsiModeTitle1->Render( iXPos + 203 - iRankCountGap, iYPos + 16 );

  0011b	8b 8e d0 01 00
	00		 mov	 ecx, DWORD PTR [esi+464]
  00121	8b 45 0c	 mov	 eax, DWORD PTR _iYPos$[ebp]
  00124	57		 push	 edi
  00125	57		 push	 edi
  00126	57		 push	 edi
  00127	57		 push	 edi
  00128	83 c0 10	 add	 eax, 16			; 00000010H
  0012b	0f 57 c0	 xorps	 xmm0, xmm0
  0012e	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00132	8b 01		 mov	 eax, DWORD PTR [ecx]
  00134	51		 push	 ecx
  00135	51		 push	 ecx
  00136	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0013c	f3 0f 11 45 0c	 movss	 DWORD PTR tv343[ebp], xmm0
  00141	8d 93 cb 00 00
	00		 lea	 edx, DWORD PTR [ebx+203]
  00147	0f 57 c0	 xorps	 xmm0, xmm0
  0014a	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  0014e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00153	ff 10		 call	 DWORD PTR [eax]

; 1511 : 
; 1512 : 	// 
; 1513 : 	m_pRedNumber->RenderNum( iXPos + 365 - iRankCountGap, iYPos + 16, m_iCurrentLiveUser );

  00155	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0015d	57		 push	 edi
  0015e	57		 push	 edi
  0015f	57		 push	 edi
  00160	57		 push	 edi
  00161	51		 push	 ecx
  00162	51		 push	 ecx
  00163	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00169	0f 57 c0	 xorps	 xmm0, xmm0
  0016c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00171	ff b6 70 02 00
	00		 push	 DWORD PTR [esi+624]
  00177	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR tv343[ebp]
  0017c	51		 push	 ecx
  0017d	51		 push	 ecx
  0017e	8b 8e e8 01 00
	00		 mov	 ecx, DWORD PTR [esi+488]
  00184	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0018a	81 c3 6d 01 00
	00		 add	 ebx, 365		; 0000016dH
  00190	0f 57 c0	 xorps	 xmm0, xmm0
  00193	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  00197	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0019c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?RenderNum@ioUIRenderImage@@QAEXMMHMMW4UIRenderType@@W4TextureFilterOption@@0W4RenerNumerFormatting@1@@Z

; 1514 : 
; 1515 : 	//
; 1516 : 	iRankCountGap = 0;

  001a2	33 c0		 xor	 eax, eax

; 1517 : 	if( m_iCurrentLiveUser >= 10 )

  001a4	83 be 70 02 00
	00 0a		 cmp	 DWORD PTR [esi+624], 10	; 0000000aH
  001ab	5b		 pop	 ebx
  001ac	7c 03		 jl	 SHORT $LN1@OnRenderGa@2

; 1518 : 		iRankCountGap = 12;

  001ae	6a 0c		 push	 12			; 0000000cH
  001b0	58		 pop	 eax
$LN1@OnRenderGa@2:

; 1519 : 	m_pGangsiModeTitle2->Render( iXPos + 388 + iRankCountGap, iYPos + 16 );

  001b1	8b 8e d4 01 00
	00		 mov	 ecx, DWORD PTR [esi+468]
  001b7	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR tv343[ebp]
  001bc	8b 75 08	 mov	 esi, DWORD PTR _iXPos$[ebp]
  001bf	8b 11		 mov	 edx, DWORD PTR [ecx]
  001c1	57		 push	 edi
  001c2	57		 push	 edi
  001c3	57		 push	 edi
  001c4	57		 push	 edi
  001c5	51		 push	 ecx
  001c6	51		 push	 ecx
  001c7	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  001cd	8d 84 30 84 01
	00 00		 lea	 eax, DWORD PTR [eax+esi+388]
  001d4	0f 57 c0	 xorps	 xmm0, xmm0
  001d7	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001db	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e0	ff 12		 call	 DWORD PTR [edx]
$LN4@OnRenderGa@2:
  001e2	5f		 pop	 edi
  001e3	5e		 pop	 esi

; 1520 : }

  001e4	c9		 leave
  001e5	c2 08 00	 ret	 8
?OnRenderGangsiTitle@RoundStateUserWnd@@IAEXHH@Z ENDP	; RoundStateUserWnd::OnRenderGangsiTitle
_TEXT	ENDS
PUBLIC	??0CHARACTER@@QAE@ABU0@@Z			; CHARACTER::CHARACTER
EXTRN	??__C@YGXPAX0IHP6EX00@ZP6EX0@Z@Z:PROC		; `eh vector copy constructor iterator'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CHARACTER@@QAE@ABU0@@Z DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$??0CHARACTER@@QAE@ABU0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CHARACTER@@QAE@ABU0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CHARACTER@@QAE@ABU0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CHARACTER@@QAE@ABU0@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CHARACTER@@QAE@ABU0@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CHARACTER@@QAE@ABU0@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CHARACTER@@QAE@ABU0@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CHARACTER@@QAE@ABU0@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CHARACTER@@QAE@ABU0@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0CHARACTER@@QAE@ABU0@@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$??0CHARACTER@@QAE@ABU0@@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$??0CHARACTER@@QAE@ABU0@@Z$9
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??0CHARACTER@@QAE@ABU0@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T568273 = 8						; size = 4
___that$ = 8						; size = 4
??0CHARACTER@@QAE@ABU0@@Z PROC				; CHARACTER::CHARACTER, COMDAT
; _this$ = ecx
  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0CHARACTER@@QAE@ABU0@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f9		 mov	 edi, ecx
  0000e	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  00011	8b 75 08	 mov	 esi, DWORD PTR ___that$[ebp]
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??0?$CEncrypt@H@@QAE@ABV0@@Z ; CEncrypt<int>::CEncrypt<int>
  0001a	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0001e	8d 46 30	 lea	 eax, DWORD PTR [esi+48]
  00021	50		 push	 eax
  00022	8d 4f 30	 lea	 ecx, DWORD PTR [edi+48]
  00025	e8 00 00 00 00	 call	 ??0?$CEncrypt@H@@QAE@ABV0@@Z ; CEncrypt<int>::CEncrypt<int>
  0002a	8d 46 60	 lea	 eax, DWORD PTR [esi+96]
  0002d	50		 push	 eax
  0002e	8d 4f 60	 lea	 ecx, DWORD PTR [edi+96]
  00031	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00035	e8 00 00 00 00	 call	 ??0?$CEncrypt@H@@QAE@ABV0@@Z ; CEncrypt<int>::CEncrypt<int>
  0003a	8d 86 90 00 00
	00		 lea	 eax, DWORD PTR [esi+144]
  00040	50		 push	 eax
  00041	8d 8f 90 00 00
	00		 lea	 ecx, DWORD PTR [edi+144]
  00047	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0004b	e8 00 00 00 00	 call	 ??0?$CEncrypt@H@@QAE@ABV0@@Z ; CEncrypt<int>::CEncrypt<int>
  00050	8d 86 c0 00 00
	00		 lea	 eax, DWORD PTR [esi+192]
  00056	50		 push	 eax
  00057	8d 8f c0 00 00
	00		 lea	 ecx, DWORD PTR [edi+192]
  0005d	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00061	e8 00 00 00 00	 call	 ??0?$CEncrypt@H@@QAE@ABV0@@Z ; CEncrypt<int>::CEncrypt<int>
  00066	8d 86 f0 00 00
	00		 lea	 eax, DWORD PTR [esi+240]
  0006c	50		 push	 eax
  0006d	8d 8f f0 00 00
	00		 lea	 ecx, DWORD PTR [edi+240]
  00073	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00077	e8 00 00 00 00	 call	 ??0?$CEncrypt@H@@QAE@ABV0@@Z ; CEncrypt<int>::CEncrypt<int>
  0007c	8d 86 20 01 00
	00		 lea	 eax, DWORD PTR [esi+288]
  00082	50		 push	 eax
  00083	8d 8f 20 01 00
	00		 lea	 ecx, DWORD PTR [edi+288]
  00089	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0008d	e8 00 00 00 00	 call	 ??0?$CEncrypt@H@@QAE@ABV0@@Z ; CEncrypt<int>::CEncrypt<int>
  00092	8d 86 50 01 00
	00		 lea	 eax, DWORD PTR [esi+336]
  00098	50		 push	 eax
  00099	8d 8f 50 01 00
	00		 lea	 ecx, DWORD PTR [edi+336]
  0009f	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  000a3	e8 00 00 00 00	 call	 ??0?$CEncrypt@H@@QAE@ABV0@@Z ; CEncrypt<int>::CEncrypt<int>
  000a8	8d 86 80 01 00
	00		 lea	 eax, DWORD PTR [esi+384]
  000ae	50		 push	 eax
  000af	8d 8f 80 01 00
	00		 lea	 ecx, DWORD PTR [edi+384]
  000b5	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  000b9	e8 00 00 00 00	 call	 ??0?$CEncrypt@H@@QAE@ABV0@@Z ; CEncrypt<int>::CEncrypt<int>
  000be	8d 86 b0 01 00
	00		 lea	 eax, DWORD PTR [esi+432]
  000c4	50		 push	 eax
  000c5	8d 8f b0 01 00
	00		 lea	 ecx, DWORD PTR [edi+432]
  000cb	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  000cf	e8 00 00 00 00	 call	 ??0?$CEncrypt@H@@QAE@ABV0@@Z ; CEncrypt<int>::CEncrypt<int>
  000d4	68 00 00 00 00	 push	 OFFSET ??1?$CEncrypt@H@@UAE@XZ ; CEncrypt<int>::~CEncrypt<int>
  000d9	68 00 00 00 00	 push	 OFFSET ??0?$CEncrypt@H@@QAE@ABV0@@Z ; CEncrypt<int>::CEncrypt<int>
  000de	6a 04		 push	 4
  000e0	6a 30		 push	 48			; 00000030H
  000e2	8d 86 e0 01 00
	00		 lea	 eax, DWORD PTR [esi+480]
  000e8	50		 push	 eax
  000e9	8d 87 e0 01 00
	00		 lea	 eax, DWORD PTR [edi+480]
  000ef	50		 push	 eax
  000f0	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  000f4	e8 00 00 00 00	 call	 ??__C@YGXPAX0IHP6EX00@ZP6EX0@Z@Z
  000f9	8b 86 a0 02 00
	00		 mov	 eax, DWORD PTR [esi+672]
  000ff	89 87 a0 02 00
	00		 mov	 DWORD PTR [edi+672], eax
  00105	8b 86 a4 02 00
	00		 mov	 eax, DWORD PTR [esi+676]
  0010b	89 87 a4 02 00
	00		 mov	 DWORD PTR [edi+676], eax
  00111	66 8b 86 a8 02
	00 00		 mov	 ax, WORD PTR [esi+680]
  00118	66 89 87 a8 02
	00 00		 mov	 WORD PTR [edi+680], ax
  0011f	66 8b 86 aa 02
	00 00		 mov	 ax, WORD PTR [esi+682]
  00126	66 89 87 aa 02
	00 00		 mov	 WORD PTR [edi+682], ax
  0012d	8b 86 ac 02 00
	00		 mov	 eax, DWORD PTR [esi+684]
  00133	89 87 ac 02 00
	00		 mov	 DWORD PTR [edi+684], eax
  00139	8b 86 b0 02 00
	00		 mov	 eax, DWORD PTR [esi+688]
  0013f	89 87 b0 02 00
	00		 mov	 DWORD PTR [edi+688], eax
  00145	8a 86 b4 02 00
	00		 mov	 al, BYTE PTR [esi+692]
  0014b	88 87 b4 02 00
	00		 mov	 BYTE PTR [edi+692], al
  00151	8a 86 b5 02 00
	00		 mov	 al, BYTE PTR [esi+693]
  00157	88 87 b5 02 00
	00		 mov	 BYTE PTR [edi+693], al
  0015d	8a 86 b6 02 00
	00		 mov	 al, BYTE PTR [esi+694]
  00163	88 87 b6 02 00
	00		 mov	 BYTE PTR [edi+694], al
  00169	8b 86 b8 02 00
	00		 mov	 eax, DWORD PTR [esi+696]
  0016f	89 87 b8 02 00
	00		 mov	 DWORD PTR [edi+696], eax
  00175	8a 86 bc 02 00
	00		 mov	 al, BYTE PTR [esi+700]
  0017b	88 87 bc 02 00
	00		 mov	 BYTE PTR [edi+700], al
  00181	8d 8e c0 02 00
	00		 lea	 ecx, DWORD PTR [esi+704]
  00187	8b c1		 mov	 eax, ecx
  00189	2b c6		 sub	 eax, esi
  0018b	8b d6		 mov	 edx, esi
  0018d	c7 45 08 03 00
	00 00		 mov	 DWORD PTR $T568273[ebp], 3
  00194	8d 44 38 08	 lea	 eax, DWORD PTR [eax+edi+8]
  00198	2b d7		 sub	 edx, edi
$LL14@CHARACTER:
  0019a	8b 19		 mov	 ebx, DWORD PTR [ecx]
  0019c	89 58 f8	 mov	 DWORD PTR [eax-8], ebx
  0019f	8b 59 04	 mov	 ebx, DWORD PTR [ecx+4]
  001a2	89 58 fc	 mov	 DWORD PTR [eax-4], ebx
  001a5	8b 1c 02	 mov	 ebx, DWORD PTR [edx+eax]
  001a8	89 18		 mov	 DWORD PTR [eax], ebx
  001aa	8b 59 0c	 mov	 ebx, DWORD PTR [ecx+12]
  001ad	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  001b0	83 c1 10	 add	 ecx, 16			; 00000010H
  001b3	83 c0 10	 add	 eax, 16			; 00000010H
  001b6	ff 4d 08	 dec	 DWORD PTR $T568273[ebp]
  001b9	79 df		 jns	 SHORT $LL14@CHARACTER
  001bb	8d 8e 00 03 00
	00		 lea	 ecx, DWORD PTR [esi+768]
  001c1	8b c1		 mov	 eax, ecx
  001c3	6a 02		 push	 2
  001c5	2b c6		 sub	 eax, esi
  001c7	5b		 pop	 ebx
  001c8	8d 44 38 08	 lea	 eax, DWORD PTR [eax+edi+8]
$LL20@CHARACTER:
  001cc	8b 31		 mov	 esi, DWORD PTR [ecx]
  001ce	89 70 f8	 mov	 DWORD PTR [eax-8], esi
  001d1	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  001d4	89 70 fc	 mov	 DWORD PTR [eax-4], esi
  001d7	8b 34 10	 mov	 esi, DWORD PTR [eax+edx]
  001da	89 30		 mov	 DWORD PTR [eax], esi
  001dc	83 c1 0c	 add	 ecx, 12			; 0000000cH
  001df	83 c0 0c	 add	 eax, 12			; 0000000cH
  001e2	4b		 dec	 ebx
  001e3	79 e7		 jns	 SHORT $LL20@CHARACTER
  001e5	8b c7		 mov	 eax, edi
  001e7	e8 00 00 00 00	 call	 __EH_epilog3
  001ec	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CHARACTER@@QAE@ABU0@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@H@@UAE@XZ	; CEncrypt<int>::~CEncrypt<int>
__unwindfunclet$??0CHARACTER@@QAE@ABU0@@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 30	 add	 ecx, 48			; 00000030H
  0000e	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@H@@UAE@XZ	; CEncrypt<int>::~CEncrypt<int>
__unwindfunclet$??0CHARACTER@@QAE@ABU0@@Z$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 60	 add	 ecx, 96			; 00000060H
  00019	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@H@@UAE@XZ	; CEncrypt<int>::~CEncrypt<int>
__unwindfunclet$??0CHARACTER@@QAE@ABU0@@Z$3:
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  00027	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@H@@UAE@XZ	; CEncrypt<int>::~CEncrypt<int>
__unwindfunclet$??0CHARACTER@@QAE@ABU0@@Z$4:
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	81 c1 c0 00 00
	00		 add	 ecx, 192		; 000000c0H
  00035	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@H@@UAE@XZ	; CEncrypt<int>::~CEncrypt<int>
__unwindfunclet$??0CHARACTER@@QAE@ABU0@@Z$5:
  0003a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	81 c1 f0 00 00
	00		 add	 ecx, 240		; 000000f0H
  00043	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@H@@UAE@XZ	; CEncrypt<int>::~CEncrypt<int>
__unwindfunclet$??0CHARACTER@@QAE@ABU0@@Z$6:
  00048	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	81 c1 20 01 00
	00		 add	 ecx, 288		; 00000120H
  00051	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@H@@UAE@XZ	; CEncrypt<int>::~CEncrypt<int>
__unwindfunclet$??0CHARACTER@@QAE@ABU0@@Z$7:
  00056	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	81 c1 50 01 00
	00		 add	 ecx, 336		; 00000150H
  0005f	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@H@@UAE@XZ	; CEncrypt<int>::~CEncrypt<int>
__unwindfunclet$??0CHARACTER@@QAE@ABU0@@Z$8:
  00064	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	81 c1 80 01 00
	00		 add	 ecx, 384		; 00000180H
  0006d	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@H@@UAE@XZ	; CEncrypt<int>::~CEncrypt<int>
__unwindfunclet$??0CHARACTER@@QAE@ABU0@@Z$9:
  00072	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	81 c1 b0 01 00
	00		 add	 ecx, 432		; 000001b0H
  0007b	e9 00 00 00 00	 jmp	 ??1?$CEncrypt@H@@UAE@XZ	; CEncrypt<int>::~CEncrypt<int>
__ehhandler$??0CHARACTER@@QAE@ABU0@@Z:
  00080	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00084	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00087	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0008a	33 c8		 xor	 ecx, eax
  0008c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00091	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CHARACTER@@QAE@ABU0@@Z
  00096	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CHARACTER@@QAE@ABU0@@Z ENDP				; CHARACTER::CHARACTER
PUBLIC	??_C@_0BP@DNIDBFBH@RoundStateMainWnd?3?3iwm_command?$AA@ ; `string'
PUBLIC	?iwm_command@RoundStateMainWnd@@UAEXPAVioWnd@@HK@Z ; RoundStateMainWnd::iwm_command
EXTRN	__imp_?IsShow@ioGUIManager@@QAE_NK@Z:PROC
EXTRN	?SetMsgBox@ioSP2GUIManager@@QAAXHPAVioWnd@@PBDZZ:PROC ; ioSP2GUIManager::SetMsgBox
EXTRN	?IsTutorialUser@ioMyInfo@@QAE_NXZ:PROC		; ioMyInfo::IsTutorialUser
EXTRN	?GetSingleton@ioMyInfo@@SAAAV1@XZ:PROC		; ioMyInfo::GetSingleton
EXTRN	__imp_?GetID@ioWnd@@QBEKXZ:PROC
;	COMDAT ??_C@_0BP@DNIDBFBH@RoundStateMainWnd?3?3iwm_command?$AA@
CONST	SEGMENT
??_C@_0BP@DNIDBFBH@RoundStateMainWnd?3?3iwm_command?$AA@ DB 'RoundStateMa'
	DB	'inWnd::iwm_command', 00H			; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?iwm_command@RoundStateMainWnd@@UAEXPAVioWnd@@HK@Z
_TEXT	SEGMENT
_pWnd$ = 8						; size = 4
_cmd$ = 12						; size = 4
_param$ = 16						; size = 4
?iwm_command@RoundStateMainWnd@@UAEXPAVioWnd@@HK@Z PROC	; RoundStateMainWnd::iwm_command, COMDAT
; _this$ = ecx

; 2986 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2987 : 	DWORD dwID = pWnd->GetID();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pWnd$[ebp]
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetID@ioWnd@@QBEKXZ

; 2988 : 	switch( dwID )

  0000c	48		 dec	 eax
  0000d	0f 85 ea 00 00
	00		 jne	 $LN19@iwm_comman

; 2989 : 	{
; 2990 : 	case ID_ROOM_INFO:
; 2991 : 		if( cmd == IOBN_BTNUP )

  00013	83 7d 0c 11	 cmp	 DWORD PTR _cmd$[ebp], 17 ; 00000011H
  00017	0f 85 e0 00 00
	00		 jne	 $LN19@iwm_comman

; 2992 : 		{
; 2993 : 			switch( ioPlayMode::GetModeType() )

  0001d	56		 push	 esi
  0001e	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  00023	83 f8 04	 cmp	 eax, 4
  00026	0f 84 9a 00 00
	00		 je	 $LN21@iwm_comman
  0002c	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  0002f	74 4e		 je	 SHORT $LN18@iwm_comman
  00031	83 f8 17	 cmp	 eax, 23			; 00000017H
  00034	74 32		 je	 SHORT $LN13@iwm_comman

; 3031 : 							g_GUIMgr.ShowWnd( HOUSE_MAIN_WND );
; 3032 : 					}
; 3033 : 				}
; 3034 : 				break;
; 3035 : 			default:
; 3036 : 				{
; 3037 : 					if( g_BattleRoomMgr.IsBattleRoom() )

  00036	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  0003b	8b c8		 mov	 ecx, eax
  0003d	e8 00 00 00 00	 call	 ?IsBattleRoom@ioBattleRoomMgr@@QAE_NXZ ; ioBattleRoomMgr::IsBattleRoom
  00042	84 c0		 test	 al, al
  00044	74 07		 je	 SHORT $LN7@iwm_comman

; 3038 : 					{
; 3039 : 						if( g_GUIMgr.IsShow( PARTY_BATTLE_SIMPLE_WND ) )

  00046	be ce 13 00 00	 mov	 esi, 5070		; 000013ceH

; 3040 : 							g_GUIMgr.HideWnd( PARTY_BATTLE_SIMPLE_WND );
; 3041 : 						else

  0004b	eb 7e		 jmp	 SHORT $LN31@iwm_comman
$LN7@iwm_comman:

; 3042 : 							g_GUIMgr.ShowWnd( PARTY_BATTLE_SIMPLE_WND );
; 3043 : 					}
; 3044 : 					else if( g_LadderTeamMgr.IsLadderTeam() )

  0004d	e8 00 00 00 00	 call	 ?GetSingleton@ioLadderTeamMgr@@SAAAV1@XZ ; ioLadderTeamMgr::GetSingleton
  00052	8b c8		 mov	 ecx, eax
  00054	e8 00 00 00 00	 call	 ?IsLadderTeam@ioLadderTeamMgr@@QAE_NXZ ; ioLadderTeamMgr::IsLadderTeam
  00059	84 c0		 test	 al, al
  0005b	0f 84 9b 00 00
	00		 je	 $LN30@iwm_comman

; 3045 : 					{
; 3046 : 						if( g_GUIMgr.IsShow( MY_LADDER_TEAM_INFO_WND ) )

  00061	be cd 13 00 00	 mov	 esi, 5069		; 000013cdH

; 3047 : 							g_GUIMgr.HideWnd( MY_LADDER_TEAM_INFO_WND );
; 3048 : 						else

  00066	eb 63		 jmp	 SHORT $LN31@iwm_comman
$LN13@iwm_comman:

; 3015 : 							g_GUIMgr.ShowWnd( HEADQUARTERS_MAIN_WND );
; 3016 : 					}
; 3017 : 				}
; 3018 : 				break;
; 3019 : 			case MT_HOUSE:
; 3020 : 				{
; 3021 : 					// 방정보
; 3022 : 					if( g_MyInfo.IsTutorialUser() )

  00068	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  0006d	8b c8		 mov	 ecx, eax
  0006f	e8 00 00 00 00	 call	 ?IsTutorialUser@ioMyInfo@@QAE_NXZ ; ioMyInfo::IsTutorialUser
  00074	84 c0		 test	 al, al

; 3023 : 					{
; 3024 : 						g_GUIMgr.SetMsgBox( MB_OK, NULL, STR(1) );
; 3025 : 					}
; 3026 : 					else

  00076	75 17		 jne	 SHORT $LN32@iwm_comman

; 3027 : 					{
; 3028 : 						if( g_GUIMgr.IsShow( HOUSE_MAIN_WND ) )

  00078	be 8f 18 00 00	 mov	 esi, 6287		; 0000188fH

; 3029 : 							g_GUIMgr.HideWnd( HOUSE_MAIN_WND );
; 3030 : 						else

  0007d	eb 4c		 jmp	 SHORT $LN31@iwm_comman
$LN18@iwm_comman:

; 3001 : 				}
; 3002 : 				break;
; 3003 : 			case MT_HEADQUARTERS:
; 3004 : 				{
; 3005 : 					// 방정보
; 3006 : 					if( g_MyInfo.IsTutorialUser() )

  0007f	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  00084	8b c8		 mov	 ecx, eax
  00086	e8 00 00 00 00	 call	 ?IsTutorialUser@ioMyInfo@@QAE_NXZ ; ioMyInfo::IsTutorialUser
  0008b	84 c0		 test	 al, al
  0008d	74 30		 je	 SHORT $LN17@iwm_comman
$LN32@iwm_comman:

; 3007 : 					{
; 3008 : 						g_GUIMgr.SetMsgBox( MB_OK, NULL, STR(1) );

  0008f	33 f6		 xor	 esi, esi
  00091	56		 push	 esi
  00092	6a 01		 push	 1
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00099	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@DNIDBFBH@RoundStateMainWnd?3?3iwm_command?$AA@
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  000a4	8b c8		 mov	 ecx, eax
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  000ac	50		 push	 eax
  000ad	56		 push	 esi
  000ae	56		 push	 esi
  000af	e8 00 00 00 00	 call	 ?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ ; ioSP2GUIManager::GetSingleton
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ?SetMsgBox@ioSP2GUIManager@@QAAXHPAVioWnd@@PBDZZ ; ioSP2GUIManager::SetMsgBox
  000ba	83 c4 10	 add	 esp, 16			; 00000010H

; 3009 : 					}
; 3010 : 					else

  000bd	eb 3d		 jmp	 SHORT $LN30@iwm_comman
$LN17@iwm_comman:

; 3011 : 					{
; 3012 : 						if( g_GUIMgr.IsShow( HEADQUARTERS_MAIN_WND ) )

  000bf	be db 17 00 00	 mov	 esi, 6107		; 000017dbH

; 3013 : 							g_GUIMgr.HideWnd( HEADQUARTERS_MAIN_WND );
; 3014 : 						else

  000c4	eb 05		 jmp	 SHORT $LN31@iwm_comman
$LN21@iwm_comman:

; 2994 : 			{
; 2995 : 			case MT_TRAINING:
; 2996 : 				{
; 2997 : 					if( g_GUIMgr.IsShow( PLAZA_MAIN_WND ) )

  000c6	be 91 17 00 00	 mov	 esi, 6033		; 00001791H
$LN31@iwm_comman:
  000cb	56		 push	 esi
  000cc	e8 00 00 00 00	 call	 ?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ ; ioSP2GUIManager::GetSingleton
  000d1	8b c8		 mov	 ecx, eax
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsShow@ioGUIManager@@QAE_NK@Z

; 2998 : 						g_GUIMgr.HideWnd( PLAZA_MAIN_WND );

  000d9	6a 00		 push	 0
  000db	56		 push	 esi
  000dc	84 c0		 test	 al, al
  000de	74 0f		 je	 SHORT $LN6@iwm_comman
  000e0	e8 00 00 00 00	 call	 ?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ ; ioSP2GUIManager::GetSingleton
  000e5	8b c8		 mov	 ecx, eax
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?HideWnd@ioGUIManager@@QAEXK_N@Z

; 2999 : 					else

  000ed	eb 0d		 jmp	 SHORT $LN30@iwm_comman
$LN6@iwm_comman:

; 3000 : 						g_GUIMgr.ShowWnd( PLAZA_MAIN_WND );

  000ef	e8 00 00 00 00	 call	 ?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ ; ioSP2GUIManager::GetSingleton
  000f4	8b c8		 mov	 ecx, eax
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ShowWnd@ioGUIManager@@QAEXK_N@Z
$LN30@iwm_comman:
  000fc	5e		 pop	 esi
$LN19@iwm_comman:

; 3049 : 							g_GUIMgr.ShowWnd( MY_LADDER_TEAM_INFO_WND );
; 3050 : 					}
; 3051 : 				}
; 3052 : 				break;
; 3053 : 			}
; 3054 : 		}
; 3055 : 		break;
; 3056 : 	}
; 3057 : }

  000fd	5d		 pop	 ebp
  000fe	c2 0c 00	 ret	 12			; 0000000cH
?iwm_command@RoundStateMainWnd@@UAEXPAVioWnd@@HK@Z ENDP	; RoundStateMainWnd::iwm_command
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@ABU3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@ABU2@@Z ; std::_Cons_val<std::allocator<RoundInfo>,RoundInfo,RoundInfo const &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@ABU3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@ABU3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<RoundInfo>,RoundInfo,RoundInfo const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	ff 75 10	 push	 DWORD PTR __Src$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR __Pdest$[ebp]
  00009	e8 00 00 00 00	 call	 ??$_Construct@URoundInfo@@ABU1@@std@@YAXPAURoundInfo@@ABU1@@Z ; std::_Construct<RoundInfo,RoundInfo const &>
  0000e	59		 pop	 ecx
  0000f	59		 pop	 ecx

; 281  : 	}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@ABU3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<RoundInfo>,RoundInfo,RoundInfo const &>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@@Z ; std::_Insertion_sort<RoundInfo *,RoundInfoKoSort>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\algorithm
;	COMDAT ??$_Insertion_sort@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Insertion_sort@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@@Z PROC ; std::_Insertion_sort<RoundInfo *,RoundInfoKoSort>, COMDAT

; 3676 : 	{	// insertion sort [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3677 : 	_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

  00003	6a 00		 push	 0
  00005	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00008	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000e	e8 00 00 00 00	 call	 ??$_Insertion_sort1@PAURoundInfo@@VRoundInfoKoSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@0@Z ; std::_Insertion_sort1<RoundInfo *,RoundInfoKoSort,RoundInfo>
  00013	83 c4 10	 add	 esp, 16			; 00000010H

; 3678 : 	}

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$_Insertion_sort@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@@Z ENDP ; std::_Insertion_sort<RoundInfo *,RoundInfoKoSort>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@@Z ; std::_Insertion_sort<RoundInfo *,RoundInfoSort>
; Function compile flags: /Ogsp
;	COMDAT ??$_Insertion_sort@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Insertion_sort@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@@Z PROC ; std::_Insertion_sort<RoundInfo *,RoundInfoSort>, COMDAT

; 3676 : 	{	// insertion sort [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3677 : 	_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

  00003	6a 00		 push	 0
  00005	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00008	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000e	e8 00 00 00 00	 call	 ??$_Insertion_sort1@PAURoundInfo@@VRoundInfoSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@0@Z ; std::_Insertion_sort1<RoundInfo *,RoundInfoSort,RoundInfo>
  00013	83 c4 10	 add	 esp, 16			; 00000010H

; 3678 : 	}

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$_Insertion_sort@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@@Z ENDP ; std::_Insertion_sort<RoundInfo *,RoundInfoSort>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@@Z ; std::_Insertion_sort<RoundInfo *,RoundInfoStarSort>
; Function compile flags: /Ogsp
;	COMDAT ??$_Insertion_sort@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Insertion_sort@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@@Z PROC ; std::_Insertion_sort<RoundInfo *,RoundInfoStarSort>, COMDAT

; 3676 : 	{	// insertion sort [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3677 : 	_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

  00003	6a 00		 push	 0
  00005	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00008	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000e	e8 00 00 00 00	 call	 ??$_Insertion_sort1@PAURoundInfo@@VRoundInfoStarSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@0@Z ; std::_Insertion_sort1<RoundInfo *,RoundInfoStarSort,RoundInfo>
  00013	83 c4 10	 add	 esp, 16			; 00000010H

; 3678 : 	}

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$_Insertion_sort@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@@Z ENDP ; std::_Insertion_sort<RoundInfo *,RoundInfoStarSort>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@@Z ; std::_Dest_val<std::allocator<RoundInfo>,RoundInfo>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@@Z PROC ; std::_Dest_val<std::allocator<RoundInfo>,RoundInfo>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 287  : 	_Alval.destroy(_Pdest);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]

; 288  : 	}

  00006	5d		 pop	 ebp

; 287  : 	_Alval.destroy(_Pdest);

  00007	e9 00 00 00 00	 jmp	 ??1RoundInfo@@QAE@XZ
??$_Dest_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@@Z ENDP ; std::_Dest_val<std::allocator<RoundInfo>,RoundInfo>
_TEXT	ENDS
PUBLIC	??$_Median@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@00VRoundInfoKoSort@@@Z ; std::_Median<RoundInfo *,RoundInfoKoSort>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\algorithm
;	COMDAT ??$_Median@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@00VRoundInfoKoSort@@@Z
_TEXT	SEGMENT
tv200 = 8						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
tv203 = 16						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Median@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@00VRoundInfoKoSort@@@Z PROC ; std::_Median<RoundInfo *,RoundInfoKoSort>, COMDAT

; 3695 : 	{	// sort median element to middle

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3696 : 	if (40 < _Last - _First)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	57		 push	 edi
  00007	8b 7d 10	 mov	 edi, DWORD PTR __Last$[ebp]
  0000a	8b c7		 mov	 eax, edi
  0000c	2b c1		 sub	 eax, ecx
  0000e	c1 f8 07	 sar	 eax, 7
  00011	83 f8 28	 cmp	 eax, 40			; 00000028H
  00014	7e 6a		 jle	 SHORT $LN2@Median

; 3697 : 		{	// median of nine
; 3698 : 		size_t _Step = (_Last - _First + 1) / 8;

  00016	40		 inc	 eax
  00017	99		 cdq
  00018	83 e2 07	 and	 edx, 7
  0001b	53		 push	 ebx
  0001c	03 c2		 add	 eax, edx
  0001e	c1 f8 03	 sar	 eax, 3
  00021	56		 push	 esi

; 3699 : 		_Med3(_First, _First + _Step, _First + 2 * _Step, _Pred);

  00022	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00025	8b d8		 mov	 ebx, eax
  00027	8b f0		 mov	 esi, eax
  00029	c1 e3 08	 shl	 ebx, 8
  0002c	8d 14 0b	 lea	 edx, DWORD PTR [ebx+ecx]
  0002f	c1 e6 07	 shl	 esi, 7
  00032	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  00035	52		 push	 edx
  00036	50		 push	 eax
  00037	51		 push	 ecx
  00038	89 45 08	 mov	 DWORD PTR tv200[ebp], eax
  0003b	e8 00 00 00 00	 call	 ??$_Med3@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@00VRoundInfoKoSort@@@Z ; std::_Med3<RoundInfo *,RoundInfoKoSort>

; 3700 : 		_Med3(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

  00040	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00043	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00046	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00049	51		 push	 ecx
  0004a	50		 push	 eax
  0004b	2b c6		 sub	 eax, esi
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$_Med3@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@00VRoundInfoKoSort@@@Z ; std::_Med3<RoundInfo *,RoundInfoKoSort>

; 3701 : 		_Med3(_Last - 2 * _Step, _Last - _Step, _Last, _Pred);

  00053	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00056	89 7d 10	 mov	 DWORD PTR tv203[ebp], edi
  00059	29 75 10	 sub	 DWORD PTR tv203[ebp], esi
  0005c	57		 push	 edi
  0005d	ff 75 10	 push	 DWORD PTR tv203[ebp]
  00060	2b fb		 sub	 edi, ebx
  00062	57		 push	 edi
  00063	e8 00 00 00 00	 call	 ??$_Med3@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@00VRoundInfoKoSort@@@Z ; std::_Med3<RoundInfo *,RoundInfoKoSort>

; 3702 : 		_Med3(_First + _Step, _Mid, _Last - _Step, _Pred);

  00068	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  0006b	ff 75 10	 push	 DWORD PTR tv203[ebp]
  0006e	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  00071	ff 75 08	 push	 DWORD PTR tv200[ebp]
  00074	e8 00 00 00 00	 call	 ??$_Med3@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@00VRoundInfoKoSort@@@Z ; std::_Med3<RoundInfo *,RoundInfoKoSort>
  00079	83 c4 40	 add	 esp, 64			; 00000040H
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx

; 3703 : 		}
; 3704 : 	else

  0007e	eb 10		 jmp	 SHORT $LN1@Median
$LN2@Median:

; 3705 : 		_Med3(_First, _Mid, _Last, _Pred);

  00080	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00083	57		 push	 edi
  00084	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??$_Med3@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@00VRoundInfoKoSort@@@Z ; std::_Med3<RoundInfo *,RoundInfoKoSort>
  0008d	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@Median:
  00090	5f		 pop	 edi

; 3706 : 	}

  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
??$_Median@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@00VRoundInfoKoSort@@@Z ENDP ; std::_Median<RoundInfo *,RoundInfoKoSort>
_TEXT	ENDS
PUBLIC	??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@PAH0@Z ; std::_Make_heap<RoundInfo *,int,RoundInfo,RoundInfoKoSort>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@PAH0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@PAH0@Z$0
__ehfuncinfo$??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@PAH0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@PAH0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@PAH0@Z
_TEXT	SEGMENT
__Val$555604 = -140					; size = 128
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@PAH0@Z PROC ; std::_Make_heap<RoundInfo *,int,RoundInfo,RoundInfoKoSort>, COMDAT

; 2658 : 	{	// make nontrivial [_First, _Last) into a heap, using _Pred

  00000	68 80 00 00 00	 push	 128			; 00000080H
  00005	b8 00 00 00 00	 mov	 eax, __ehhandler$??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@PAH0@Z
  0000a	e8 00 00 00 00	 call	 __EH_prolog3

; 2659 : 	_Diff _Bottom = _Last - _First;

  0000f	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  00012	2b 7d 08	 sub	 edi, DWORD PTR __First$[ebp]
  00015	c1 ff 07	 sar	 edi, 7

; 2660 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

  00018	8b c7		 mov	 eax, edi
  0001a	99		 cdq
  0001b	2b c2		 sub	 eax, edx
  0001d	8b f0		 mov	 esi, eax
  0001f	d1 fe		 sar	 esi, 1
  00021	85 f6		 test	 esi, esi
  00023	7e 46		 jle	 SHORT $LN1@Make_heap

; 2659 : 	_Diff _Bottom = _Last - _First;

  00025	8b de		 mov	 ebx, esi
  00027	c1 e3 07	 shl	 ebx, 7
  0002a	03 5d 08	 add	 ebx, DWORD PTR __First$[ebp]
$LL2@Make_heap:

; 2661 : 		{	// reheap top half, bottom to top
; 2662 : 		--_Hole;

  0002d	83 c3 80	 add	 ebx, -128		; ffffff80H

; 2663 : 		_Ty _Val = _Move(*(_First + _Hole));

  00030	53		 push	 ebx
  00031	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR __Val$555604[ebp]
  00037	4e		 dec	 esi
  00038	e8 00 00 00 00	 call	 ??0RoundInfo@@QAE@ABU0@@Z

; 2664 : 		_Adjust_heap(_First, _Hole, _Bottom,
; 2665 : 			_Move(_Val), _Pred);

  0003d	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00040	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00044	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR __Val$555604[ebp]
  0004a	50		 push	 eax
  0004b	57		 push	 edi
  0004c	56		 push	 esi
  0004d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00050	e8 00 00 00 00	 call	 ??$_Adjust_heap@PAURoundInfo@@HU1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoKoSort@@@Z ; std::_Adjust_heap<RoundInfo *,int,RoundInfo,RoundInfoKoSort>

; 2666 : 		}

  00055	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00059	83 c4 14	 add	 esp, 20			; 00000014H
  0005c	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR __Val$555604[ebp]
  00062	e8 00 00 00 00	 call	 ??1RoundInfo@@QAE@XZ
  00067	85 f6		 test	 esi, esi
  00069	7f c2		 jg	 SHORT $LL2@Make_heap
$LN1@Make_heap:

; 2667 : 	}

  0006b	e8 00 00 00 00	 call	 __EH_epilog3
  00070	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@PAH0@Z$0:
  00000	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR __Val$555604[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1RoundInfo@@QAE@XZ
__ehhandler$??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@PAH0@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 70 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-144]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@PAH0@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@PAH0@Z ENDP ; std::_Make_heap<RoundInfo *,int,RoundInfo,RoundInfoKoSort>
PUBLIC	??$_Median@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@00VRoundInfoSort@@@Z ; std::_Median<RoundInfo *,RoundInfoSort>
; Function compile flags: /Ogsp
;	COMDAT ??$_Median@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@00VRoundInfoSort@@@Z
_TEXT	SEGMENT
tv200 = 8						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
tv203 = 16						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Median@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@00VRoundInfoSort@@@Z PROC ; std::_Median<RoundInfo *,RoundInfoSort>, COMDAT

; 3695 : 	{	// sort median element to middle

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3696 : 	if (40 < _Last - _First)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	57		 push	 edi
  00007	8b 7d 10	 mov	 edi, DWORD PTR __Last$[ebp]
  0000a	8b c7		 mov	 eax, edi
  0000c	2b c1		 sub	 eax, ecx
  0000e	c1 f8 07	 sar	 eax, 7
  00011	83 f8 28	 cmp	 eax, 40			; 00000028H
  00014	7e 6a		 jle	 SHORT $LN2@Median@2

; 3697 : 		{	// median of nine
; 3698 : 		size_t _Step = (_Last - _First + 1) / 8;

  00016	40		 inc	 eax
  00017	99		 cdq
  00018	83 e2 07	 and	 edx, 7
  0001b	53		 push	 ebx
  0001c	03 c2		 add	 eax, edx
  0001e	c1 f8 03	 sar	 eax, 3
  00021	56		 push	 esi

; 3699 : 		_Med3(_First, _First + _Step, _First + 2 * _Step, _Pred);

  00022	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00025	8b d8		 mov	 ebx, eax
  00027	8b f0		 mov	 esi, eax
  00029	c1 e3 08	 shl	 ebx, 8
  0002c	8d 14 0b	 lea	 edx, DWORD PTR [ebx+ecx]
  0002f	c1 e6 07	 shl	 esi, 7
  00032	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  00035	52		 push	 edx
  00036	50		 push	 eax
  00037	51		 push	 ecx
  00038	89 45 08	 mov	 DWORD PTR tv200[ebp], eax
  0003b	e8 00 00 00 00	 call	 ??$_Med3@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@00VRoundInfoSort@@@Z ; std::_Med3<RoundInfo *,RoundInfoSort>

; 3700 : 		_Med3(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

  00040	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00043	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00046	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00049	51		 push	 ecx
  0004a	50		 push	 eax
  0004b	2b c6		 sub	 eax, esi
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$_Med3@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@00VRoundInfoSort@@@Z ; std::_Med3<RoundInfo *,RoundInfoSort>

; 3701 : 		_Med3(_Last - 2 * _Step, _Last - _Step, _Last, _Pred);

  00053	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00056	89 7d 10	 mov	 DWORD PTR tv203[ebp], edi
  00059	29 75 10	 sub	 DWORD PTR tv203[ebp], esi
  0005c	57		 push	 edi
  0005d	ff 75 10	 push	 DWORD PTR tv203[ebp]
  00060	2b fb		 sub	 edi, ebx
  00062	57		 push	 edi
  00063	e8 00 00 00 00	 call	 ??$_Med3@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@00VRoundInfoSort@@@Z ; std::_Med3<RoundInfo *,RoundInfoSort>

; 3702 : 		_Med3(_First + _Step, _Mid, _Last - _Step, _Pred);

  00068	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  0006b	ff 75 10	 push	 DWORD PTR tv203[ebp]
  0006e	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  00071	ff 75 08	 push	 DWORD PTR tv200[ebp]
  00074	e8 00 00 00 00	 call	 ??$_Med3@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@00VRoundInfoSort@@@Z ; std::_Med3<RoundInfo *,RoundInfoSort>
  00079	83 c4 40	 add	 esp, 64			; 00000040H
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx

; 3703 : 		}
; 3704 : 	else

  0007e	eb 10		 jmp	 SHORT $LN1@Median@2
$LN2@Median@2:

; 3705 : 		_Med3(_First, _Mid, _Last, _Pred);

  00080	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00083	57		 push	 edi
  00084	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??$_Med3@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@00VRoundInfoSort@@@Z ; std::_Med3<RoundInfo *,RoundInfoSort>
  0008d	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@Median@2:
  00090	5f		 pop	 edi

; 3706 : 	}

  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
??$_Median@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@00VRoundInfoSort@@@Z ENDP ; std::_Median<RoundInfo *,RoundInfoSort>
_TEXT	ENDS
PUBLIC	??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@PAH0@Z ; std::_Make_heap<RoundInfo *,int,RoundInfo,RoundInfoSort>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@PAH0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@PAH0@Z$0
__ehfuncinfo$??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@PAH0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@PAH0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@PAH0@Z
_TEXT	SEGMENT
__Val$555671 = -140					; size = 128
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@PAH0@Z PROC ; std::_Make_heap<RoundInfo *,int,RoundInfo,RoundInfoSort>, COMDAT

; 2658 : 	{	// make nontrivial [_First, _Last) into a heap, using _Pred

  00000	68 80 00 00 00	 push	 128			; 00000080H
  00005	b8 00 00 00 00	 mov	 eax, __ehhandler$??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@PAH0@Z
  0000a	e8 00 00 00 00	 call	 __EH_prolog3

; 2659 : 	_Diff _Bottom = _Last - _First;

  0000f	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  00012	2b 7d 08	 sub	 edi, DWORD PTR __First$[ebp]
  00015	c1 ff 07	 sar	 edi, 7

; 2660 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

  00018	8b c7		 mov	 eax, edi
  0001a	99		 cdq
  0001b	2b c2		 sub	 eax, edx
  0001d	8b f0		 mov	 esi, eax
  0001f	d1 fe		 sar	 esi, 1
  00021	85 f6		 test	 esi, esi
  00023	7e 46		 jle	 SHORT $LN1@Make_heap@2

; 2659 : 	_Diff _Bottom = _Last - _First;

  00025	8b de		 mov	 ebx, esi
  00027	c1 e3 07	 shl	 ebx, 7
  0002a	03 5d 08	 add	 ebx, DWORD PTR __First$[ebp]
$LL2@Make_heap@2:

; 2661 : 		{	// reheap top half, bottom to top
; 2662 : 		--_Hole;

  0002d	83 c3 80	 add	 ebx, -128		; ffffff80H

; 2663 : 		_Ty _Val = _Move(*(_First + _Hole));

  00030	53		 push	 ebx
  00031	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR __Val$555671[ebp]
  00037	4e		 dec	 esi
  00038	e8 00 00 00 00	 call	 ??0RoundInfo@@QAE@ABU0@@Z

; 2664 : 		_Adjust_heap(_First, _Hole, _Bottom,
; 2665 : 			_Move(_Val), _Pred);

  0003d	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00040	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00044	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR __Val$555671[ebp]
  0004a	50		 push	 eax
  0004b	57		 push	 edi
  0004c	56		 push	 esi
  0004d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00050	e8 00 00 00 00	 call	 ??$_Adjust_heap@PAURoundInfo@@HU1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoSort@@@Z ; std::_Adjust_heap<RoundInfo *,int,RoundInfo,RoundInfoSort>

; 2666 : 		}

  00055	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00059	83 c4 14	 add	 esp, 20			; 00000014H
  0005c	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR __Val$555671[ebp]
  00062	e8 00 00 00 00	 call	 ??1RoundInfo@@QAE@XZ
  00067	85 f6		 test	 esi, esi
  00069	7f c2		 jg	 SHORT $LL2@Make_heap@2
$LN1@Make_heap@2:

; 2667 : 	}

  0006b	e8 00 00 00 00	 call	 __EH_epilog3
  00070	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@PAH0@Z$0:
  00000	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR __Val$555671[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1RoundInfo@@QAE@XZ
__ehhandler$??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@PAH0@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 70 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-144]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@PAH0@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@PAH0@Z ENDP ; std::_Make_heap<RoundInfo *,int,RoundInfo,RoundInfoSort>
PUBLIC	??$_Median@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@00VRoundInfoStarSort@@@Z ; std::_Median<RoundInfo *,RoundInfoStarSort>
; Function compile flags: /Ogsp
;	COMDAT ??$_Median@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@00VRoundInfoStarSort@@@Z
_TEXT	SEGMENT
tv200 = 8						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
tv203 = 16						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Median@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@00VRoundInfoStarSort@@@Z PROC ; std::_Median<RoundInfo *,RoundInfoStarSort>, COMDAT

; 3695 : 	{	// sort median element to middle

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3696 : 	if (40 < _Last - _First)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	57		 push	 edi
  00007	8b 7d 10	 mov	 edi, DWORD PTR __Last$[ebp]
  0000a	8b c7		 mov	 eax, edi
  0000c	2b c1		 sub	 eax, ecx
  0000e	c1 f8 07	 sar	 eax, 7
  00011	83 f8 28	 cmp	 eax, 40			; 00000028H
  00014	7e 6a		 jle	 SHORT $LN2@Median@3

; 3697 : 		{	// median of nine
; 3698 : 		size_t _Step = (_Last - _First + 1) / 8;

  00016	40		 inc	 eax
  00017	99		 cdq
  00018	83 e2 07	 and	 edx, 7
  0001b	53		 push	 ebx
  0001c	03 c2		 add	 eax, edx
  0001e	c1 f8 03	 sar	 eax, 3
  00021	56		 push	 esi

; 3699 : 		_Med3(_First, _First + _Step, _First + 2 * _Step, _Pred);

  00022	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00025	8b d8		 mov	 ebx, eax
  00027	8b f0		 mov	 esi, eax
  00029	c1 e3 08	 shl	 ebx, 8
  0002c	8d 14 0b	 lea	 edx, DWORD PTR [ebx+ecx]
  0002f	c1 e6 07	 shl	 esi, 7
  00032	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  00035	52		 push	 edx
  00036	50		 push	 eax
  00037	51		 push	 ecx
  00038	89 45 08	 mov	 DWORD PTR tv200[ebp], eax
  0003b	e8 00 00 00 00	 call	 ??$_Med3@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@00VRoundInfoStarSort@@@Z ; std::_Med3<RoundInfo *,RoundInfoStarSort>

; 3700 : 		_Med3(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

  00040	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00043	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00046	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00049	51		 push	 ecx
  0004a	50		 push	 eax
  0004b	2b c6		 sub	 eax, esi
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$_Med3@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@00VRoundInfoStarSort@@@Z ; std::_Med3<RoundInfo *,RoundInfoStarSort>

; 3701 : 		_Med3(_Last - 2 * _Step, _Last - _Step, _Last, _Pred);

  00053	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00056	89 7d 10	 mov	 DWORD PTR tv203[ebp], edi
  00059	29 75 10	 sub	 DWORD PTR tv203[ebp], esi
  0005c	57		 push	 edi
  0005d	ff 75 10	 push	 DWORD PTR tv203[ebp]
  00060	2b fb		 sub	 edi, ebx
  00062	57		 push	 edi
  00063	e8 00 00 00 00	 call	 ??$_Med3@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@00VRoundInfoStarSort@@@Z ; std::_Med3<RoundInfo *,RoundInfoStarSort>

; 3702 : 		_Med3(_First + _Step, _Mid, _Last - _Step, _Pred);

  00068	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  0006b	ff 75 10	 push	 DWORD PTR tv203[ebp]
  0006e	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  00071	ff 75 08	 push	 DWORD PTR tv200[ebp]
  00074	e8 00 00 00 00	 call	 ??$_Med3@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@00VRoundInfoStarSort@@@Z ; std::_Med3<RoundInfo *,RoundInfoStarSort>
  00079	83 c4 40	 add	 esp, 64			; 00000040H
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx

; 3703 : 		}
; 3704 : 	else

  0007e	eb 10		 jmp	 SHORT $LN1@Median@3
$LN2@Median@3:

; 3705 : 		_Med3(_First, _Mid, _Last, _Pred);

  00080	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00083	57		 push	 edi
  00084	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??$_Med3@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@00VRoundInfoStarSort@@@Z ; std::_Med3<RoundInfo *,RoundInfoStarSort>
  0008d	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@Median@3:
  00090	5f		 pop	 edi

; 3706 : 	}

  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
??$_Median@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@00VRoundInfoStarSort@@@Z ENDP ; std::_Median<RoundInfo *,RoundInfoStarSort>
_TEXT	ENDS
PUBLIC	??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@PAH0@Z ; std::_Make_heap<RoundInfo *,int,RoundInfo,RoundInfoStarSort>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@PAH0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@PAH0@Z$0
__ehfuncinfo$??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@PAH0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@PAH0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@PAH0@Z
_TEXT	SEGMENT
__Val$555726 = -140					; size = 128
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@PAH0@Z PROC ; std::_Make_heap<RoundInfo *,int,RoundInfo,RoundInfoStarSort>, COMDAT

; 2658 : 	{	// make nontrivial [_First, _Last) into a heap, using _Pred

  00000	68 80 00 00 00	 push	 128			; 00000080H
  00005	b8 00 00 00 00	 mov	 eax, __ehhandler$??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@PAH0@Z
  0000a	e8 00 00 00 00	 call	 __EH_prolog3

; 2659 : 	_Diff _Bottom = _Last - _First;

  0000f	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  00012	2b 7d 08	 sub	 edi, DWORD PTR __First$[ebp]
  00015	c1 ff 07	 sar	 edi, 7

; 2660 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

  00018	8b c7		 mov	 eax, edi
  0001a	99		 cdq
  0001b	2b c2		 sub	 eax, edx
  0001d	8b f0		 mov	 esi, eax
  0001f	d1 fe		 sar	 esi, 1
  00021	85 f6		 test	 esi, esi
  00023	7e 46		 jle	 SHORT $LN1@Make_heap@3

; 2659 : 	_Diff _Bottom = _Last - _First;

  00025	8b de		 mov	 ebx, esi
  00027	c1 e3 07	 shl	 ebx, 7
  0002a	03 5d 08	 add	 ebx, DWORD PTR __First$[ebp]
$LL2@Make_heap@3:

; 2661 : 		{	// reheap top half, bottom to top
; 2662 : 		--_Hole;

  0002d	83 c3 80	 add	 ebx, -128		; ffffff80H

; 2663 : 		_Ty _Val = _Move(*(_First + _Hole));

  00030	53		 push	 ebx
  00031	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR __Val$555726[ebp]
  00037	4e		 dec	 esi
  00038	e8 00 00 00 00	 call	 ??0RoundInfo@@QAE@ABU0@@Z

; 2664 : 		_Adjust_heap(_First, _Hole, _Bottom,
; 2665 : 			_Move(_Val), _Pred);

  0003d	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00040	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00044	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR __Val$555726[ebp]
  0004a	50		 push	 eax
  0004b	57		 push	 edi
  0004c	56		 push	 esi
  0004d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00050	e8 00 00 00 00	 call	 ??$_Adjust_heap@PAURoundInfo@@HU1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@HH$$QAU1@VRoundInfoStarSort@@@Z ; std::_Adjust_heap<RoundInfo *,int,RoundInfo,RoundInfoStarSort>

; 2666 : 		}

  00055	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00059	83 c4 14	 add	 esp, 20			; 00000014H
  0005c	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR __Val$555726[ebp]
  00062	e8 00 00 00 00	 call	 ??1RoundInfo@@QAE@XZ
  00067	85 f6		 test	 esi, esi
  00069	7f c2		 jg	 SHORT $LL2@Make_heap@3
$LN1@Make_heap@3:

; 2667 : 	}

  0006b	e8 00 00 00 00	 call	 __EH_epilog3
  00070	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@PAH0@Z$0:
  00000	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR __Val$555726[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1RoundInfo@@QAE@XZ
__ehhandler$??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@PAH0@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 70 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-144]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@PAH0@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@PAH0@Z ENDP ; std::_Make_heap<RoundInfo *,int,RoundInfo,RoundInfoStarSort>
PUBLIC	??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@0@Z ; std::_Pop_heap_0<RoundInfo *,RoundInfo,RoundInfoKoSort>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@0@Z$0
__ehfuncinfo$??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@0@Z
_TEXT	SEGMENT
__Val$ = -140						; size = 128
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
___formal$ = 20						; size = 4
??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@0@Z PROC ; std::_Pop_heap_0<RoundInfo *,RoundInfo,RoundInfoKoSort>, COMDAT

; 2601 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred

  00000	68 80 00 00 00	 push	 128			; 00000080H
  00005	b8 00 00 00 00	 mov	 eax, __ehhandler$??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@0@Z
  0000a	e8 00 00 00 00	 call	 __EH_prolog3

; 2602 : 	_Ty _Val = _Move(*(_Last - 1));

  0000f	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  00012	83 c6 80	 add	 esi, -128		; ffffff80H
  00015	56		 push	 esi
  00016	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR __Val$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0RoundInfo@@QAE@ABU0@@Z
  00021	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2603 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2604 : 		_Move(_Val), _Pred, _Dist_type(_First));

  00025	6a 00		 push	 0
  00027	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  0002a	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR __Val$[ebp]
  00030	50		 push	 eax
  00031	56		 push	 esi
  00032	56		 push	 esi
  00033	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00036	e8 00 00 00 00	 call	 ??$_Pop_heap@PAURoundInfo@@HU1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@00$$QAU1@VRoundInfoKoSort@@PAH@Z ; std::_Pop_heap<RoundInfo *,int,RoundInfo,RoundInfoKoSort>

; 2605 : 	}

  0003b	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0003f	83 c4 18	 add	 esp, 24			; 00000018H
  00042	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR __Val$[ebp]
  00048	e8 00 00 00 00	 call	 ??1RoundInfo@@QAE@XZ
  0004d	e8 00 00 00 00	 call	 __EH_epilog3
  00052	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@0@Z$0:
  00000	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR __Val$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1RoundInfo@@QAE@XZ
__ehhandler$??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@0@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 70 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-144]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@0@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@0@Z ENDP ; std::_Pop_heap_0<RoundInfo *,RoundInfo,RoundInfoKoSort>
PUBLIC	??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@0@Z ; std::_Pop_heap_0<RoundInfo *,RoundInfo,RoundInfoSort>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@0@Z$0
__ehfuncinfo$??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@0@Z
_TEXT	SEGMENT
__Val$ = -140						; size = 128
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
___formal$ = 20						; size = 4
??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@0@Z PROC ; std::_Pop_heap_0<RoundInfo *,RoundInfo,RoundInfoSort>, COMDAT

; 2601 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred

  00000	68 80 00 00 00	 push	 128			; 00000080H
  00005	b8 00 00 00 00	 mov	 eax, __ehhandler$??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@0@Z
  0000a	e8 00 00 00 00	 call	 __EH_prolog3

; 2602 : 	_Ty _Val = _Move(*(_Last - 1));

  0000f	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  00012	83 c6 80	 add	 esi, -128		; ffffff80H
  00015	56		 push	 esi
  00016	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR __Val$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0RoundInfo@@QAE@ABU0@@Z
  00021	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2603 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2604 : 		_Move(_Val), _Pred, _Dist_type(_First));

  00025	6a 00		 push	 0
  00027	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  0002a	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR __Val$[ebp]
  00030	50		 push	 eax
  00031	56		 push	 esi
  00032	56		 push	 esi
  00033	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00036	e8 00 00 00 00	 call	 ??$_Pop_heap@PAURoundInfo@@HU1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@00$$QAU1@VRoundInfoSort@@PAH@Z ; std::_Pop_heap<RoundInfo *,int,RoundInfo,RoundInfoSort>

; 2605 : 	}

  0003b	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0003f	83 c4 18	 add	 esp, 24			; 00000018H
  00042	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR __Val$[ebp]
  00048	e8 00 00 00 00	 call	 ??1RoundInfo@@QAE@XZ
  0004d	e8 00 00 00 00	 call	 __EH_epilog3
  00052	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@0@Z$0:
  00000	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR __Val$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1RoundInfo@@QAE@XZ
__ehhandler$??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@0@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 70 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-144]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@0@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@0@Z ENDP ; std::_Pop_heap_0<RoundInfo *,RoundInfo,RoundInfoSort>
PUBLIC	??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@0@Z ; std::_Pop_heap_0<RoundInfo *,RoundInfo,RoundInfoStarSort>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@0@Z$0
__ehfuncinfo$??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@0@Z
_TEXT	SEGMENT
__Val$ = -140						; size = 128
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
___formal$ = 20						; size = 4
??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@0@Z PROC ; std::_Pop_heap_0<RoundInfo *,RoundInfo,RoundInfoStarSort>, COMDAT

; 2601 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred

  00000	68 80 00 00 00	 push	 128			; 00000080H
  00005	b8 00 00 00 00	 mov	 eax, __ehhandler$??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@0@Z
  0000a	e8 00 00 00 00	 call	 __EH_prolog3

; 2602 : 	_Ty _Val = _Move(*(_Last - 1));

  0000f	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  00012	83 c6 80	 add	 esi, -128		; ffffff80H
  00015	56		 push	 esi
  00016	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR __Val$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0RoundInfo@@QAE@ABU0@@Z
  00021	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2603 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2604 : 		_Move(_Val), _Pred, _Dist_type(_First));

  00025	6a 00		 push	 0
  00027	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  0002a	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR __Val$[ebp]
  00030	50		 push	 eax
  00031	56		 push	 esi
  00032	56		 push	 esi
  00033	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00036	e8 00 00 00 00	 call	 ??$_Pop_heap@PAURoundInfo@@HU1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@00$$QAU1@VRoundInfoStarSort@@PAH@Z ; std::_Pop_heap<RoundInfo *,int,RoundInfo,RoundInfoStarSort>

; 2605 : 	}

  0003b	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0003f	83 c4 18	 add	 esp, 24			; 00000018H
  00042	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR __Val$[ebp]
  00048	e8 00 00 00 00	 call	 ??1RoundInfo@@QAE@XZ
  0004d	e8 00 00 00 00	 call	 __EH_epilog3
  00052	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@0@Z$0:
  00000	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR __Val$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1RoundInfo@@QAE@XZ
__ehhandler$??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@0@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 70 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-144]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@0@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@0@Z ENDP ; std::_Pop_heap_0<RoundInfo *,RoundInfo,RoundInfoStarSort>
PUBLIC	??0tagLadderHeroUserInfo@@QAE@ABU0@@Z		; tagLadderHeroUserInfo::tagLadderHeroUserInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0tagLadderHeroUserInfo@@QAE@ABU0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0tagLadderHeroUserInfo@@QAE@ABU0@@Z$0
__ehfuncinfo$??0tagLadderHeroUserInfo@@QAE@ABU0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0tagLadderHeroUserInfo@@QAE@ABU0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??0tagLadderHeroUserInfo@@QAE@ABU0@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0tagLadderHeroUserInfo@@QAE@ABU0@@Z PROC		; tagLadderHeroUserInfo::tagLadderHeroUserInfo, COMDAT
; _this$ = ecx
  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0tagLadderHeroUserInfo@@QAE@ABU0@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b d9		 mov	 ebx, ecx
  0000e	89 5d f0	 mov	 DWORD PTR _this$[ebp], ebx
  00011	8b 75 08	 mov	 esi, DWORD PTR ___that$[ebp]
  00014	56		 push	 esi
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  0001b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0001e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00022	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  00025	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00028	89 43 14	 mov	 DWORD PTR [ebx+20], eax
  0002b	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0002e	89 43 18	 mov	 DWORD PTR [ebx+24], eax
  00031	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00034	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
  00037	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0003a	89 43 20	 mov	 DWORD PTR [ebx+32], eax
  0003d	8d 46 24	 lea	 eax, DWORD PTR [esi+36]
  00040	50		 push	 eax
  00041	8d 4b 24	 lea	 ecx, DWORD PTR [ebx+36]
  00044	e8 00 00 00 00	 call	 ??0CHARACTER@@QAE@ABU0@@Z
  00049	8b 86 48 03 00
	00		 mov	 eax, DWORD PTR [esi+840]
  0004f	6a 14		 push	 20			; 00000014H
  00051	89 83 48 03 00
	00		 mov	 DWORD PTR [ebx+840], eax
  00057	81 c6 4c 03 00
	00		 add	 esi, 844		; 0000034cH
  0005d	8d bb 4c 03 00
	00		 lea	 edi, DWORD PTR [ebx+844]
  00063	59		 pop	 ecx
  00064	f3 a5		 rep movsd
  00066	8b c3		 mov	 eax, ebx
  00068	e8 00 00 00 00	 call	 __EH_epilog3
  0006d	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0tagLadderHeroUserInfo@@QAE@ABU0@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$??0tagLadderHeroUserInfo@@QAE@ABU0@@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0tagLadderHeroUserInfo@@QAE@ABU0@@Z
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0tagLadderHeroUserInfo@@QAE@ABU0@@Z ENDP		; tagLadderHeroUserInfo::tagLadderHeroUserInfo
PUBLIC	??$_Destroy_range@V?$allocator@URoundInfo@@@std@@@std@@YAXPAURoundInfo@@0AAV?$allocator@URoundInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<RoundInfo> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@URoundInfo@@@std@@@std@@YAXPAURoundInfo@@0AAV?$allocator@URoundInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@URoundInfo@@@std@@@std@@YAXPAURoundInfo@@0AAV?$allocator@URoundInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<RoundInfo> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 96   : 	for (; _First != _Last; ++_First)

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	eb 0a		 jmp	 SHORT $LN17@Destroy_ra
$LL3@Destroy_ra:

; 97   : 		_Dest_val(_Al, _First);

  00009	8b ce		 mov	 ecx, esi
  0000b	e8 00 00 00 00	 call	 ??1RoundInfo@@QAE@XZ
  00010	83 ee 80	 sub	 esi, -128		; ffffff80H
$LN17@Destroy_ra:

; 96   : 	for (; _First != _Last; ++_First)

  00013	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00016	75 f1		 jne	 SHORT $LL3@Destroy_ra
  00018	5e		 pop	 esi

; 98   : 	}

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$_Destroy_range@V?$allocator@URoundInfo@@@std@@@std@@YAXPAURoundInfo@@0AAV?$allocator@URoundInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<RoundInfo> >
_TEXT	ENDS
PUBLIC	??$_Unguarded_partition@PAURoundInfo@@VRoundInfoKoSort@@@std@@YA?AU?$pair@PAURoundInfo@@PAU1@@0@PAURoundInfo@@0VRoundInfoKoSort@@@Z ; std::_Unguarded_partition<RoundInfo *,RoundInfoKoSort>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\algorithm
;	COMDAT ??$_Unguarded_partition@PAURoundInfo@@VRoundInfoKoSort@@@std@@YA?AU?$pair@PAURoundInfo@@PAU1@@0@PAURoundInfo@@0VRoundInfoKoSort@@@Z
_TEXT	SEGMENT
tv320 = -12						; size = 4
__Glast$ = -8						; size = 4
__Gfirst$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Unguarded_partition@PAURoundInfo@@VRoundInfoKoSort@@@std@@YA?AU?$pair@PAURoundInfo@@PAU1@@0@PAURoundInfo@@0VRoundInfoKoSort@@@Z PROC ; std::_Unguarded_partition<RoundInfo *,RoundInfoKoSort>, COMDAT

; 3712 : 	{	// partition [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3713 : 	_RanIt _Mid = _First + (_Last - _First) / 2;

  00003	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	8b c1		 mov	 eax, ecx
  00008	2b 45 0c	 sub	 eax, DWORD PTR __First$[ebp]
  0000b	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000e	c1 f8 07	 sar	 eax, 7
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	99		 cdq
  00014	2b c2		 sub	 eax, edx
  00016	57		 push	 edi

; 3714 : 	_Median(_First, _Mid, _Last - 1, _Pred);

  00017	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  0001a	8b f0		 mov	 esi, eax
  0001c	d1 fe		 sar	 esi, 1
  0001e	c1 e6 07	 shl	 esi, 7
  00021	03 75 0c	 add	 esi, DWORD PTR __First$[ebp]
  00024	83 c1 80	 add	 ecx, -128		; ffffff80H
  00027	51		 push	 ecx
  00028	56		 push	 esi
  00029	ff 75 0c	 push	 DWORD PTR __First$[ebp]
  0002c	e8 00 00 00 00	 call	 ??$_Median@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@00VRoundInfoKoSort@@@Z ; std::_Median<RoundInfo *,RoundInfoKoSort>
  00031	83 c4 10	 add	 esp, 16			; 00000010H

; 3715 : 	_RanIt _Pfirst = _Mid;

  00034	8b fe		 mov	 edi, esi

; 3716 : 	_RanIt _Plast = _Pfirst + 1;

  00036	8d 9e 80 00 00
	00		 lea	 ebx, DWORD PTR [esi+128]

; 3717 : 
; 3718 : 	while (_First < _Pfirst
; 3719 : 		&& !_DEBUG_LT_PRED(_Pred, *(_Pfirst - 1), *_Pfirst)
; 3720 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

  0003c	39 75 0c	 cmp	 DWORD PTR __First$[ebp], esi
  0003f	73 26		 jae	 SHORT $LN69@Unguarded_
$LL27@Unguarded_:
  00041	57		 push	 edi
  00042	8d 77 80	 lea	 esi, DWORD PTR [edi-128]
  00045	56		 push	 esi
  00046	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00049	e8 00 00 00 00	 call	 ??RRoundInfoKoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoKoSort::operator()
  0004e	84 c0		 test	 al, al
  00050	75 15		 jne	 SHORT $LN69@Unguarded_
  00052	56		 push	 esi
  00053	57		 push	 edi
  00054	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00057	e8 00 00 00 00	 call	 ??RRoundInfoKoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoKoSort::operator()
  0005c	84 c0		 test	 al, al
  0005e	75 07		 jne	 SHORT $LN69@Unguarded_

; 3721 : 		--_Pfirst;

  00060	8b fe		 mov	 edi, esi
  00062	39 7d 0c	 cmp	 DWORD PTR __First$[ebp], edi
  00065	72 da		 jb	 SHORT $LL27@Unguarded_
$LN69@Unguarded_:

; 3722 : 	while (_Plast < _Last
; 3723 : 		&& !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst)
; 3724 : 		&& !_Pred(*_Pfirst, *_Plast))

  00067	be 80 00 00 00	 mov	 esi, 128		; 00000080H
  0006c	eb 1e		 jmp	 SHORT $LN75@Unguarded_
$LL25@Unguarded_:
  0006e	57		 push	 edi
  0006f	53		 push	 ebx
  00070	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00073	e8 00 00 00 00	 call	 ??RRoundInfoKoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoKoSort::operator()
  00078	84 c0		 test	 al, al
  0007a	75 15		 jne	 SHORT $LN70@Unguarded_
  0007c	53		 push	 ebx
  0007d	57		 push	 edi
  0007e	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00081	e8 00 00 00 00	 call	 ??RRoundInfoKoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoKoSort::operator()
  00086	84 c0		 test	 al, al
  00088	75 07		 jne	 SHORT $LN70@Unguarded_

; 3725 : 		++_Plast;

  0008a	03 de		 add	 ebx, esi
$LN75@Unguarded_:

; 3722 : 	while (_Plast < _Last
; 3723 : 		&& !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst)
; 3724 : 		&& !_Pred(*_Pfirst, *_Plast))

  0008c	3b 5d 10	 cmp	 ebx, DWORD PTR __Last$[ebp]
  0008f	72 dd		 jb	 SHORT $LL25@Unguarded_
$LN70@Unguarded_:

; 3726 : 
; 3727 : 	_RanIt _Gfirst = _Plast;

  00091	89 5d fc	 mov	 DWORD PTR __Gfirst$[ebp], ebx

; 3728 : 	_RanIt _Glast = _Pfirst;

  00094	89 7d f8	 mov	 DWORD PTR __Glast$[ebp], edi
$LL23@Unguarded_:

; 3729 : 
; 3730 : 	for (; ; )
; 3731 : 		{	// partition
; 3732 : 		for (; _Gfirst < _Last; ++_Gfirst)

  00097	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  0009a	39 45 fc	 cmp	 DWORD PTR __Gfirst$[ebp], eax
  0009d	73 3a		 jae	 SHORT $LN72@Unguarded_
$LL71@Unguarded_:

; 3733 : 			if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst))

  0009f	ff 75 fc	 push	 DWORD PTR __Gfirst$[ebp]
  000a2	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  000a5	57		 push	 edi
  000a6	e8 00 00 00 00	 call	 ??RRoundInfoKoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoKoSort::operator()
  000ab	84 c0		 test	 al, al
  000ad	75 1f		 jne	 SHORT $LN20@Unguarded_

; 3734 : 				;
; 3735 : 			else if (_Pred(*_Gfirst, *_Pfirst))

  000af	57		 push	 edi
  000b0	ff 75 fc	 push	 DWORD PTR __Gfirst$[ebp]
  000b3	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  000b6	e8 00 00 00 00	 call	 ??RRoundInfoKoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoKoSort::operator()
  000bb	84 c0		 test	 al, al
  000bd	75 1a		 jne	 SHORT $LN72@Unguarded_

; 3736 : 				break;
; 3737 : 			else
; 3738 : 				_STD iter_swap(_Plast++, _Gfirst);

  000bf	ff 75 fc	 push	 DWORD PTR __Gfirst$[ebp]
  000c2	8b c3		 mov	 eax, ebx
  000c4	50		 push	 eax
  000c5	03 de		 add	 ebx, esi
  000c7	e8 00 00 00 00	 call	 ??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z ; std::swap<RoundInfo>
  000cc	59		 pop	 ecx
  000cd	59		 pop	 ecx
$LN20@Unguarded_:

; 3729 : 
; 3730 : 	for (; ; )
; 3731 : 		{	// partition
; 3732 : 		for (; _Gfirst < _Last; ++_Gfirst)

  000ce	01 75 fc	 add	 DWORD PTR __Gfirst$[ebp], esi
  000d1	8b 45 fc	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  000d4	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]
  000d7	72 c6		 jb	 SHORT $LL71@Unguarded_
$LN72@Unguarded_:

; 3739 : 		for (; _First < _Glast; --_Glast)

  000d9	8b 45 f8	 mov	 eax, DWORD PTR __Glast$[ebp]
  000dc	39 45 0c	 cmp	 DWORD PTR __First$[ebp], eax
  000df	73 41		 jae	 SHORT $LN74@Unguarded_
  000e1	83 c0 80	 add	 eax, -128		; ffffff80H
  000e4	89 45 f4	 mov	 DWORD PTR tv320[ebp], eax
$LL73@Unguarded_:

; 3740 : 			if (_DEBUG_LT_PRED(_Pred, *(_Glast - 1), *_Pfirst))

  000e7	57		 push	 edi
  000e8	ff 75 f4	 push	 DWORD PTR tv320[ebp]
  000eb	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  000ee	e8 00 00 00 00	 call	 ??RRoundInfoKoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoKoSort::operator()
  000f3	84 c0		 test	 al, al
  000f5	75 1d		 jne	 SHORT $LN13@Unguarded_

; 3741 : 				;
; 3742 : 			else if (_Pred(*_Pfirst, *(_Glast - 1)))

  000f7	ff 75 f4	 push	 DWORD PTR tv320[ebp]
  000fa	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  000fd	57		 push	 edi
  000fe	e8 00 00 00 00	 call	 ??RRoundInfoKoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoKoSort::operator()
  00103	84 c0		 test	 al, al
  00105	75 1b		 jne	 SHORT $LN74@Unguarded_

; 3743 : 				break;
; 3744 : 			else
; 3745 : 				_STD iter_swap(--_Pfirst, _Glast - 1);

  00107	ff 75 f4	 push	 DWORD PTR tv320[ebp]
  0010a	2b fe		 sub	 edi, esi
  0010c	57		 push	 edi
  0010d	e8 00 00 00 00	 call	 ??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z ; std::swap<RoundInfo>
  00112	59		 pop	 ecx
  00113	59		 pop	 ecx
$LN13@Unguarded_:

; 3739 : 		for (; _First < _Glast; --_Glast)

  00114	29 75 f8	 sub	 DWORD PTR __Glast$[ebp], esi
  00117	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  0011a	29 75 f4	 sub	 DWORD PTR tv320[ebp], esi
  0011d	3b 45 f8	 cmp	 eax, DWORD PTR __Glast$[ebp]
  00120	72 c5		 jb	 SHORT $LL73@Unguarded_
$LN74@Unguarded_:

; 3746 : 		if (_Glast == _First && _Gfirst == _Last)

  00122	8b 45 f8	 mov	 eax, DWORD PTR __Glast$[ebp]
  00125	3b 45 0c	 cmp	 eax, DWORD PTR __First$[ebp]
  00128	75 25		 jne	 SHORT $LN6@Unguarded_
  0012a	8b 45 fc	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  0012d	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]
  00130	74 5a		 je	 SHORT $LN64@Unguarded_

; 3748 : 
; 3749 : 		if (_Glast == _First)
; 3750 : 			{	// no room at bottom, rotate pivot upward
; 3751 : 			if (_Plast != _Gfirst)

  00132	3b d8		 cmp	 ebx, eax
  00134	74 09		 je	 SHORT $LN46@Unguarded_

; 3752 : 				_STD iter_swap(_Pfirst, _Plast);

  00136	53		 push	 ebx
  00137	57		 push	 edi
  00138	e8 00 00 00 00	 call	 ??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z ; std::swap<RoundInfo>
  0013d	59		 pop	 ecx
  0013e	59		 pop	 ecx
$LN46@Unguarded_:

; 3753 : 			++_Plast;
; 3754 : 			_STD iter_swap(_Pfirst++, _Gfirst++);

  0013f	8b 45 fc	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00142	8b cf		 mov	 ecx, edi
  00144	50		 push	 eax
  00145	03 de		 add	 ebx, esi
  00147	03 fe		 add	 edi, esi
  00149	01 75 fc	 add	 DWORD PTR __Gfirst$[ebp], esi
  0014c	51		 push	 ecx
  0014d	eb 20		 jmp	 SHORT $LN76@Unguarded_
$LN6@Unguarded_:

; 3755 : 			}
; 3756 : 		else if (_Gfirst == _Last)

  0014f	8b 4d fc	 mov	 ecx, DWORD PTR __Gfirst$[ebp]

; 3757 : 			{	// no room at top, rotate pivot downward
; 3758 : 			if (--_Glast != --_Pfirst)

  00152	2b c6		 sub	 eax, esi
  00154	89 45 f8	 mov	 DWORD PTR __Glast$[ebp], eax
  00157	3b 4d 10	 cmp	 ecx, DWORD PTR __Last$[ebp]
  0015a	75 1f		 jne	 SHORT $LN3@Unguarded_
  0015c	2b fe		 sub	 edi, esi
  0015e	3b c7		 cmp	 eax, edi
  00160	74 09		 je	 SHORT $LN50@Unguarded_

; 3759 : 				_STD iter_swap(_Glast, _Pfirst);

  00162	57		 push	 edi
  00163	50		 push	 eax
  00164	e8 00 00 00 00	 call	 ??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z ; std::swap<RoundInfo>
  00169	59		 pop	 ecx
  0016a	59		 pop	 ecx
$LN50@Unguarded_:

; 3760 : 			_STD iter_swap(_Pfirst, --_Plast);

  0016b	2b de		 sub	 ebx, esi
  0016d	53		 push	 ebx
  0016e	57		 push	 edi
$LN76@Unguarded_:
  0016f	e8 00 00 00 00	 call	 ??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z ; std::swap<RoundInfo>
  00174	59		 pop	 ecx
  00175	59		 pop	 ecx

; 3761 : 			}
; 3762 : 		else

  00176	e9 1c ff ff ff	 jmp	 $LL23@Unguarded_
$LN3@Unguarded_:

; 3763 : 			_STD iter_swap(_Gfirst++, --_Glast);

  0017b	50		 push	 eax
  0017c	51		 push	 ecx
  0017d	e8 00 00 00 00	 call	 ??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z ; std::swap<RoundInfo>
  00182	01 75 fc	 add	 DWORD PTR __Gfirst$[ebp], esi
  00185	59		 pop	 ecx
  00186	59		 pop	 ecx

; 3764 : 		}

  00187	e9 0b ff ff ff	 jmp	 $LL23@Unguarded_
$LN64@Unguarded_:

; 3747 : 			return (_STD pair<_RanIt, _RanIt>(_Pfirst, _Plast));

  0018c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0018f	89 38		 mov	 DWORD PTR [eax], edi
  00191	5f		 pop	 edi
  00192	5e		 pop	 esi
  00193	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00196	5b		 pop	 ebx

; 3765 : 	}

  00197	c9		 leave
  00198	c3		 ret	 0
??$_Unguarded_partition@PAURoundInfo@@VRoundInfoKoSort@@@std@@YA?AU?$pair@PAURoundInfo@@PAU1@@0@PAURoundInfo@@0VRoundInfoKoSort@@@Z ENDP ; std::_Unguarded_partition<RoundInfo *,RoundInfoKoSort>
_TEXT	ENDS
PUBLIC	??$make_heap@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@@Z ; std::make_heap<RoundInfo *,RoundInfoKoSort>
; Function compile flags: /Ogsp
;	COMDAT ??$make_heap@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$make_heap@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@@Z PROC ; std::make_heap<RoundInfo *,RoundInfoKoSort>, COMDAT

; 2672 : 	{	// make [_First, _Last) into a heap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2673 : 	_DEBUG_RANGE(_First, _Last);
; 2674 : 	_DEBUG_POINTER(_Pred);
; 2675 : 	if (1 < _Last - _First)

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00009	83 e0 80	 and	 eax, -128		; ffffff80H
  0000c	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00011	7e 15		 jle	 SHORT $LN1@make_heap

; 2676 : 		_Make_heap(_Unchecked(_First), _Unchecked(_Last), _Pred,
; 2677 : 			_Dist_type(_First), _Val_type(_First));

  00013	6a 00		 push	 0
  00015	6a 00		 push	 0
  00017	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  0001a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00020	e8 00 00 00 00	 call	 ??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@PAH0@Z ; std::_Make_heap<RoundInfo *,int,RoundInfo,RoundInfoKoSort>
  00025	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@make_heap:

; 2678 : 	}

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??$make_heap@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@@Z ENDP ; std::make_heap<RoundInfo *,RoundInfoKoSort>
_TEXT	ENDS
PUBLIC	??$_Unguarded_partition@PAURoundInfo@@VRoundInfoSort@@@std@@YA?AU?$pair@PAURoundInfo@@PAU1@@0@PAURoundInfo@@0VRoundInfoSort@@@Z ; std::_Unguarded_partition<RoundInfo *,RoundInfoSort>
; Function compile flags: /Ogsp
;	COMDAT ??$_Unguarded_partition@PAURoundInfo@@VRoundInfoSort@@@std@@YA?AU?$pair@PAURoundInfo@@PAU1@@0@PAURoundInfo@@0VRoundInfoSort@@@Z
_TEXT	SEGMENT
tv320 = -12						; size = 4
__Glast$ = -8						; size = 4
__Gfirst$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Unguarded_partition@PAURoundInfo@@VRoundInfoSort@@@std@@YA?AU?$pair@PAURoundInfo@@PAU1@@0@PAURoundInfo@@0VRoundInfoSort@@@Z PROC ; std::_Unguarded_partition<RoundInfo *,RoundInfoSort>, COMDAT

; 3712 : 	{	// partition [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3713 : 	_RanIt _Mid = _First + (_Last - _First) / 2;

  00003	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	8b c1		 mov	 eax, ecx
  00008	2b 45 0c	 sub	 eax, DWORD PTR __First$[ebp]
  0000b	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000e	c1 f8 07	 sar	 eax, 7
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	99		 cdq
  00014	2b c2		 sub	 eax, edx
  00016	57		 push	 edi

; 3714 : 	_Median(_First, _Mid, _Last - 1, _Pred);

  00017	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  0001a	8b f0		 mov	 esi, eax
  0001c	d1 fe		 sar	 esi, 1
  0001e	c1 e6 07	 shl	 esi, 7
  00021	03 75 0c	 add	 esi, DWORD PTR __First$[ebp]
  00024	83 c1 80	 add	 ecx, -128		; ffffff80H
  00027	51		 push	 ecx
  00028	56		 push	 esi
  00029	ff 75 0c	 push	 DWORD PTR __First$[ebp]
  0002c	e8 00 00 00 00	 call	 ??$_Median@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@00VRoundInfoSort@@@Z ; std::_Median<RoundInfo *,RoundInfoSort>
  00031	83 c4 10	 add	 esp, 16			; 00000010H

; 3715 : 	_RanIt _Pfirst = _Mid;

  00034	8b fe		 mov	 edi, esi

; 3716 : 	_RanIt _Plast = _Pfirst + 1;

  00036	8d 9e 80 00 00
	00		 lea	 ebx, DWORD PTR [esi+128]

; 3717 : 
; 3718 : 	while (_First < _Pfirst
; 3719 : 		&& !_DEBUG_LT_PRED(_Pred, *(_Pfirst - 1), *_Pfirst)
; 3720 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

  0003c	39 75 0c	 cmp	 DWORD PTR __First$[ebp], esi
  0003f	73 26		 jae	 SHORT $LN69@Unguarded_@2
$LL27@Unguarded_@2:
  00041	57		 push	 edi
  00042	8d 77 80	 lea	 esi, DWORD PTR [edi-128]
  00045	56		 push	 esi
  00046	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00049	e8 00 00 00 00	 call	 ??RRoundInfoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoSort::operator()
  0004e	84 c0		 test	 al, al
  00050	75 15		 jne	 SHORT $LN69@Unguarded_@2
  00052	56		 push	 esi
  00053	57		 push	 edi
  00054	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00057	e8 00 00 00 00	 call	 ??RRoundInfoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoSort::operator()
  0005c	84 c0		 test	 al, al
  0005e	75 07		 jne	 SHORT $LN69@Unguarded_@2

; 3721 : 		--_Pfirst;

  00060	8b fe		 mov	 edi, esi
  00062	39 7d 0c	 cmp	 DWORD PTR __First$[ebp], edi
  00065	72 da		 jb	 SHORT $LL27@Unguarded_@2
$LN69@Unguarded_@2:

; 3722 : 	while (_Plast < _Last
; 3723 : 		&& !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst)
; 3724 : 		&& !_Pred(*_Pfirst, *_Plast))

  00067	be 80 00 00 00	 mov	 esi, 128		; 00000080H
  0006c	eb 1e		 jmp	 SHORT $LN75@Unguarded_@2
$LL25@Unguarded_@2:
  0006e	57		 push	 edi
  0006f	53		 push	 ebx
  00070	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00073	e8 00 00 00 00	 call	 ??RRoundInfoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoSort::operator()
  00078	84 c0		 test	 al, al
  0007a	75 15		 jne	 SHORT $LN70@Unguarded_@2
  0007c	53		 push	 ebx
  0007d	57		 push	 edi
  0007e	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00081	e8 00 00 00 00	 call	 ??RRoundInfoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoSort::operator()
  00086	84 c0		 test	 al, al
  00088	75 07		 jne	 SHORT $LN70@Unguarded_@2

; 3725 : 		++_Plast;

  0008a	03 de		 add	 ebx, esi
$LN75@Unguarded_@2:

; 3722 : 	while (_Plast < _Last
; 3723 : 		&& !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst)
; 3724 : 		&& !_Pred(*_Pfirst, *_Plast))

  0008c	3b 5d 10	 cmp	 ebx, DWORD PTR __Last$[ebp]
  0008f	72 dd		 jb	 SHORT $LL25@Unguarded_@2
$LN70@Unguarded_@2:

; 3726 : 
; 3727 : 	_RanIt _Gfirst = _Plast;

  00091	89 5d fc	 mov	 DWORD PTR __Gfirst$[ebp], ebx

; 3728 : 	_RanIt _Glast = _Pfirst;

  00094	89 7d f8	 mov	 DWORD PTR __Glast$[ebp], edi
$LL23@Unguarded_@2:

; 3729 : 
; 3730 : 	for (; ; )
; 3731 : 		{	// partition
; 3732 : 		for (; _Gfirst < _Last; ++_Gfirst)

  00097	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  0009a	39 45 fc	 cmp	 DWORD PTR __Gfirst$[ebp], eax
  0009d	73 3a		 jae	 SHORT $LN72@Unguarded_@2
$LL71@Unguarded_@2:

; 3733 : 			if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst))

  0009f	ff 75 fc	 push	 DWORD PTR __Gfirst$[ebp]
  000a2	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  000a5	57		 push	 edi
  000a6	e8 00 00 00 00	 call	 ??RRoundInfoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoSort::operator()
  000ab	84 c0		 test	 al, al
  000ad	75 1f		 jne	 SHORT $LN20@Unguarded_@2

; 3734 : 				;
; 3735 : 			else if (_Pred(*_Gfirst, *_Pfirst))

  000af	57		 push	 edi
  000b0	ff 75 fc	 push	 DWORD PTR __Gfirst$[ebp]
  000b3	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  000b6	e8 00 00 00 00	 call	 ??RRoundInfoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoSort::operator()
  000bb	84 c0		 test	 al, al
  000bd	75 1a		 jne	 SHORT $LN72@Unguarded_@2

; 3736 : 				break;
; 3737 : 			else
; 3738 : 				_STD iter_swap(_Plast++, _Gfirst);

  000bf	ff 75 fc	 push	 DWORD PTR __Gfirst$[ebp]
  000c2	8b c3		 mov	 eax, ebx
  000c4	50		 push	 eax
  000c5	03 de		 add	 ebx, esi
  000c7	e8 00 00 00 00	 call	 ??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z ; std::swap<RoundInfo>
  000cc	59		 pop	 ecx
  000cd	59		 pop	 ecx
$LN20@Unguarded_@2:

; 3729 : 
; 3730 : 	for (; ; )
; 3731 : 		{	// partition
; 3732 : 		for (; _Gfirst < _Last; ++_Gfirst)

  000ce	01 75 fc	 add	 DWORD PTR __Gfirst$[ebp], esi
  000d1	8b 45 fc	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  000d4	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]
  000d7	72 c6		 jb	 SHORT $LL71@Unguarded_@2
$LN72@Unguarded_@2:

; 3739 : 		for (; _First < _Glast; --_Glast)

  000d9	8b 45 f8	 mov	 eax, DWORD PTR __Glast$[ebp]
  000dc	39 45 0c	 cmp	 DWORD PTR __First$[ebp], eax
  000df	73 41		 jae	 SHORT $LN74@Unguarded_@2
  000e1	83 c0 80	 add	 eax, -128		; ffffff80H
  000e4	89 45 f4	 mov	 DWORD PTR tv320[ebp], eax
$LL73@Unguarded_@2:

; 3740 : 			if (_DEBUG_LT_PRED(_Pred, *(_Glast - 1), *_Pfirst))

  000e7	57		 push	 edi
  000e8	ff 75 f4	 push	 DWORD PTR tv320[ebp]
  000eb	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  000ee	e8 00 00 00 00	 call	 ??RRoundInfoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoSort::operator()
  000f3	84 c0		 test	 al, al
  000f5	75 1d		 jne	 SHORT $LN13@Unguarded_@2

; 3741 : 				;
; 3742 : 			else if (_Pred(*_Pfirst, *(_Glast - 1)))

  000f7	ff 75 f4	 push	 DWORD PTR tv320[ebp]
  000fa	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  000fd	57		 push	 edi
  000fe	e8 00 00 00 00	 call	 ??RRoundInfoSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoSort::operator()
  00103	84 c0		 test	 al, al
  00105	75 1b		 jne	 SHORT $LN74@Unguarded_@2

; 3743 : 				break;
; 3744 : 			else
; 3745 : 				_STD iter_swap(--_Pfirst, _Glast - 1);

  00107	ff 75 f4	 push	 DWORD PTR tv320[ebp]
  0010a	2b fe		 sub	 edi, esi
  0010c	57		 push	 edi
  0010d	e8 00 00 00 00	 call	 ??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z ; std::swap<RoundInfo>
  00112	59		 pop	 ecx
  00113	59		 pop	 ecx
$LN13@Unguarded_@2:

; 3739 : 		for (; _First < _Glast; --_Glast)

  00114	29 75 f8	 sub	 DWORD PTR __Glast$[ebp], esi
  00117	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  0011a	29 75 f4	 sub	 DWORD PTR tv320[ebp], esi
  0011d	3b 45 f8	 cmp	 eax, DWORD PTR __Glast$[ebp]
  00120	72 c5		 jb	 SHORT $LL73@Unguarded_@2
$LN74@Unguarded_@2:

; 3746 : 		if (_Glast == _First && _Gfirst == _Last)

  00122	8b 45 f8	 mov	 eax, DWORD PTR __Glast$[ebp]
  00125	3b 45 0c	 cmp	 eax, DWORD PTR __First$[ebp]
  00128	75 25		 jne	 SHORT $LN6@Unguarded_@2
  0012a	8b 45 fc	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  0012d	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]
  00130	74 5a		 je	 SHORT $LN64@Unguarded_@2

; 3748 : 
; 3749 : 		if (_Glast == _First)
; 3750 : 			{	// no room at bottom, rotate pivot upward
; 3751 : 			if (_Plast != _Gfirst)

  00132	3b d8		 cmp	 ebx, eax
  00134	74 09		 je	 SHORT $LN46@Unguarded_@2

; 3752 : 				_STD iter_swap(_Pfirst, _Plast);

  00136	53		 push	 ebx
  00137	57		 push	 edi
  00138	e8 00 00 00 00	 call	 ??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z ; std::swap<RoundInfo>
  0013d	59		 pop	 ecx
  0013e	59		 pop	 ecx
$LN46@Unguarded_@2:

; 3753 : 			++_Plast;
; 3754 : 			_STD iter_swap(_Pfirst++, _Gfirst++);

  0013f	8b 45 fc	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00142	8b cf		 mov	 ecx, edi
  00144	50		 push	 eax
  00145	03 de		 add	 ebx, esi
  00147	03 fe		 add	 edi, esi
  00149	01 75 fc	 add	 DWORD PTR __Gfirst$[ebp], esi
  0014c	51		 push	 ecx
  0014d	eb 20		 jmp	 SHORT $LN76@Unguarded_@2
$LN6@Unguarded_@2:

; 3755 : 			}
; 3756 : 		else if (_Gfirst == _Last)

  0014f	8b 4d fc	 mov	 ecx, DWORD PTR __Gfirst$[ebp]

; 3757 : 			{	// no room at top, rotate pivot downward
; 3758 : 			if (--_Glast != --_Pfirst)

  00152	2b c6		 sub	 eax, esi
  00154	89 45 f8	 mov	 DWORD PTR __Glast$[ebp], eax
  00157	3b 4d 10	 cmp	 ecx, DWORD PTR __Last$[ebp]
  0015a	75 1f		 jne	 SHORT $LN3@Unguarded_@2
  0015c	2b fe		 sub	 edi, esi
  0015e	3b c7		 cmp	 eax, edi
  00160	74 09		 je	 SHORT $LN50@Unguarded_@2

; 3759 : 				_STD iter_swap(_Glast, _Pfirst);

  00162	57		 push	 edi
  00163	50		 push	 eax
  00164	e8 00 00 00 00	 call	 ??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z ; std::swap<RoundInfo>
  00169	59		 pop	 ecx
  0016a	59		 pop	 ecx
$LN50@Unguarded_@2:

; 3760 : 			_STD iter_swap(_Pfirst, --_Plast);

  0016b	2b de		 sub	 ebx, esi
  0016d	53		 push	 ebx
  0016e	57		 push	 edi
$LN76@Unguarded_@2:
  0016f	e8 00 00 00 00	 call	 ??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z ; std::swap<RoundInfo>
  00174	59		 pop	 ecx
  00175	59		 pop	 ecx

; 3761 : 			}
; 3762 : 		else

  00176	e9 1c ff ff ff	 jmp	 $LL23@Unguarded_@2
$LN3@Unguarded_@2:

; 3763 : 			_STD iter_swap(_Gfirst++, --_Glast);

  0017b	50		 push	 eax
  0017c	51		 push	 ecx
  0017d	e8 00 00 00 00	 call	 ??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z ; std::swap<RoundInfo>
  00182	01 75 fc	 add	 DWORD PTR __Gfirst$[ebp], esi
  00185	59		 pop	 ecx
  00186	59		 pop	 ecx

; 3764 : 		}

  00187	e9 0b ff ff ff	 jmp	 $LL23@Unguarded_@2
$LN64@Unguarded_@2:

; 3747 : 			return (_STD pair<_RanIt, _RanIt>(_Pfirst, _Plast));

  0018c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0018f	89 38		 mov	 DWORD PTR [eax], edi
  00191	5f		 pop	 edi
  00192	5e		 pop	 esi
  00193	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00196	5b		 pop	 ebx

; 3765 : 	}

  00197	c9		 leave
  00198	c3		 ret	 0
??$_Unguarded_partition@PAURoundInfo@@VRoundInfoSort@@@std@@YA?AU?$pair@PAURoundInfo@@PAU1@@0@PAURoundInfo@@0VRoundInfoSort@@@Z ENDP ; std::_Unguarded_partition<RoundInfo *,RoundInfoSort>
_TEXT	ENDS
PUBLIC	??$make_heap@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@@Z ; std::make_heap<RoundInfo *,RoundInfoSort>
; Function compile flags: /Ogsp
;	COMDAT ??$make_heap@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$make_heap@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@@Z PROC ; std::make_heap<RoundInfo *,RoundInfoSort>, COMDAT

; 2672 : 	{	// make [_First, _Last) into a heap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2673 : 	_DEBUG_RANGE(_First, _Last);
; 2674 : 	_DEBUG_POINTER(_Pred);
; 2675 : 	if (1 < _Last - _First)

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00009	83 e0 80	 and	 eax, -128		; ffffff80H
  0000c	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00011	7e 15		 jle	 SHORT $LN1@make_heap@2

; 2676 : 		_Make_heap(_Unchecked(_First), _Unchecked(_Last), _Pred,
; 2677 : 			_Dist_type(_First), _Val_type(_First));

  00013	6a 00		 push	 0
  00015	6a 00		 push	 0
  00017	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  0001a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00020	e8 00 00 00 00	 call	 ??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@PAH0@Z ; std::_Make_heap<RoundInfo *,int,RoundInfo,RoundInfoSort>
  00025	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@make_heap@2:

; 2678 : 	}

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??$make_heap@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@@Z ENDP ; std::make_heap<RoundInfo *,RoundInfoSort>
_TEXT	ENDS
PUBLIC	??$_Unguarded_partition@PAURoundInfo@@VRoundInfoStarSort@@@std@@YA?AU?$pair@PAURoundInfo@@PAU1@@0@PAURoundInfo@@0VRoundInfoStarSort@@@Z ; std::_Unguarded_partition<RoundInfo *,RoundInfoStarSort>
; Function compile flags: /Ogsp
;	COMDAT ??$_Unguarded_partition@PAURoundInfo@@VRoundInfoStarSort@@@std@@YA?AU?$pair@PAURoundInfo@@PAU1@@0@PAURoundInfo@@0VRoundInfoStarSort@@@Z
_TEXT	SEGMENT
tv320 = -12						; size = 4
__Glast$ = -8						; size = 4
__Gfirst$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Unguarded_partition@PAURoundInfo@@VRoundInfoStarSort@@@std@@YA?AU?$pair@PAURoundInfo@@PAU1@@0@PAURoundInfo@@0VRoundInfoStarSort@@@Z PROC ; std::_Unguarded_partition<RoundInfo *,RoundInfoStarSort>, COMDAT

; 3712 : 	{	// partition [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3713 : 	_RanIt _Mid = _First + (_Last - _First) / 2;

  00003	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	8b c1		 mov	 eax, ecx
  00008	2b 45 0c	 sub	 eax, DWORD PTR __First$[ebp]
  0000b	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000e	c1 f8 07	 sar	 eax, 7
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	99		 cdq
  00014	2b c2		 sub	 eax, edx
  00016	57		 push	 edi

; 3714 : 	_Median(_First, _Mid, _Last - 1, _Pred);

  00017	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  0001a	8b f0		 mov	 esi, eax
  0001c	d1 fe		 sar	 esi, 1
  0001e	c1 e6 07	 shl	 esi, 7
  00021	03 75 0c	 add	 esi, DWORD PTR __First$[ebp]
  00024	83 c1 80	 add	 ecx, -128		; ffffff80H
  00027	51		 push	 ecx
  00028	56		 push	 esi
  00029	ff 75 0c	 push	 DWORD PTR __First$[ebp]
  0002c	e8 00 00 00 00	 call	 ??$_Median@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@00VRoundInfoStarSort@@@Z ; std::_Median<RoundInfo *,RoundInfoStarSort>
  00031	83 c4 10	 add	 esp, 16			; 00000010H

; 3715 : 	_RanIt _Pfirst = _Mid;

  00034	8b fe		 mov	 edi, esi

; 3716 : 	_RanIt _Plast = _Pfirst + 1;

  00036	8d 9e 80 00 00
	00		 lea	 ebx, DWORD PTR [esi+128]

; 3717 : 
; 3718 : 	while (_First < _Pfirst
; 3719 : 		&& !_DEBUG_LT_PRED(_Pred, *(_Pfirst - 1), *_Pfirst)
; 3720 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

  0003c	39 75 0c	 cmp	 DWORD PTR __First$[ebp], esi
  0003f	73 26		 jae	 SHORT $LN69@Unguarded_@3
$LL27@Unguarded_@3:
  00041	57		 push	 edi
  00042	8d 77 80	 lea	 esi, DWORD PTR [edi-128]
  00045	56		 push	 esi
  00046	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00049	e8 00 00 00 00	 call	 ??RRoundInfoStarSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoStarSort::operator()
  0004e	84 c0		 test	 al, al
  00050	75 15		 jne	 SHORT $LN69@Unguarded_@3
  00052	56		 push	 esi
  00053	57		 push	 edi
  00054	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00057	e8 00 00 00 00	 call	 ??RRoundInfoStarSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoStarSort::operator()
  0005c	84 c0		 test	 al, al
  0005e	75 07		 jne	 SHORT $LN69@Unguarded_@3

; 3721 : 		--_Pfirst;

  00060	8b fe		 mov	 edi, esi
  00062	39 7d 0c	 cmp	 DWORD PTR __First$[ebp], edi
  00065	72 da		 jb	 SHORT $LL27@Unguarded_@3
$LN69@Unguarded_@3:

; 3722 : 	while (_Plast < _Last
; 3723 : 		&& !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst)
; 3724 : 		&& !_Pred(*_Pfirst, *_Plast))

  00067	be 80 00 00 00	 mov	 esi, 128		; 00000080H
  0006c	eb 1e		 jmp	 SHORT $LN75@Unguarded_@3
$LL25@Unguarded_@3:
  0006e	57		 push	 edi
  0006f	53		 push	 ebx
  00070	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00073	e8 00 00 00 00	 call	 ??RRoundInfoStarSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoStarSort::operator()
  00078	84 c0		 test	 al, al
  0007a	75 15		 jne	 SHORT $LN70@Unguarded_@3
  0007c	53		 push	 ebx
  0007d	57		 push	 edi
  0007e	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00081	e8 00 00 00 00	 call	 ??RRoundInfoStarSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoStarSort::operator()
  00086	84 c0		 test	 al, al
  00088	75 07		 jne	 SHORT $LN70@Unguarded_@3

; 3725 : 		++_Plast;

  0008a	03 de		 add	 ebx, esi
$LN75@Unguarded_@3:

; 3722 : 	while (_Plast < _Last
; 3723 : 		&& !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst)
; 3724 : 		&& !_Pred(*_Pfirst, *_Plast))

  0008c	3b 5d 10	 cmp	 ebx, DWORD PTR __Last$[ebp]
  0008f	72 dd		 jb	 SHORT $LL25@Unguarded_@3
$LN70@Unguarded_@3:

; 3726 : 
; 3727 : 	_RanIt _Gfirst = _Plast;

  00091	89 5d fc	 mov	 DWORD PTR __Gfirst$[ebp], ebx

; 3728 : 	_RanIt _Glast = _Pfirst;

  00094	89 7d f8	 mov	 DWORD PTR __Glast$[ebp], edi
$LL23@Unguarded_@3:

; 3729 : 
; 3730 : 	for (; ; )
; 3731 : 		{	// partition
; 3732 : 		for (; _Gfirst < _Last; ++_Gfirst)

  00097	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  0009a	39 45 fc	 cmp	 DWORD PTR __Gfirst$[ebp], eax
  0009d	73 3a		 jae	 SHORT $LN72@Unguarded_@3
$LL71@Unguarded_@3:

; 3733 : 			if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst))

  0009f	ff 75 fc	 push	 DWORD PTR __Gfirst$[ebp]
  000a2	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  000a5	57		 push	 edi
  000a6	e8 00 00 00 00	 call	 ??RRoundInfoStarSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoStarSort::operator()
  000ab	84 c0		 test	 al, al
  000ad	75 1f		 jne	 SHORT $LN20@Unguarded_@3

; 3734 : 				;
; 3735 : 			else if (_Pred(*_Gfirst, *_Pfirst))

  000af	57		 push	 edi
  000b0	ff 75 fc	 push	 DWORD PTR __Gfirst$[ebp]
  000b3	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  000b6	e8 00 00 00 00	 call	 ??RRoundInfoStarSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoStarSort::operator()
  000bb	84 c0		 test	 al, al
  000bd	75 1a		 jne	 SHORT $LN72@Unguarded_@3

; 3736 : 				break;
; 3737 : 			else
; 3738 : 				_STD iter_swap(_Plast++, _Gfirst);

  000bf	ff 75 fc	 push	 DWORD PTR __Gfirst$[ebp]
  000c2	8b c3		 mov	 eax, ebx
  000c4	50		 push	 eax
  000c5	03 de		 add	 ebx, esi
  000c7	e8 00 00 00 00	 call	 ??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z ; std::swap<RoundInfo>
  000cc	59		 pop	 ecx
  000cd	59		 pop	 ecx
$LN20@Unguarded_@3:

; 3729 : 
; 3730 : 	for (; ; )
; 3731 : 		{	// partition
; 3732 : 		for (; _Gfirst < _Last; ++_Gfirst)

  000ce	01 75 fc	 add	 DWORD PTR __Gfirst$[ebp], esi
  000d1	8b 45 fc	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  000d4	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]
  000d7	72 c6		 jb	 SHORT $LL71@Unguarded_@3
$LN72@Unguarded_@3:

; 3739 : 		for (; _First < _Glast; --_Glast)

  000d9	8b 45 f8	 mov	 eax, DWORD PTR __Glast$[ebp]
  000dc	39 45 0c	 cmp	 DWORD PTR __First$[ebp], eax
  000df	73 41		 jae	 SHORT $LN74@Unguarded_@3
  000e1	83 c0 80	 add	 eax, -128		; ffffff80H
  000e4	89 45 f4	 mov	 DWORD PTR tv320[ebp], eax
$LL73@Unguarded_@3:

; 3740 : 			if (_DEBUG_LT_PRED(_Pred, *(_Glast - 1), *_Pfirst))

  000e7	57		 push	 edi
  000e8	ff 75 f4	 push	 DWORD PTR tv320[ebp]
  000eb	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  000ee	e8 00 00 00 00	 call	 ??RRoundInfoStarSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoStarSort::operator()
  000f3	84 c0		 test	 al, al
  000f5	75 1d		 jne	 SHORT $LN13@Unguarded_@3

; 3741 : 				;
; 3742 : 			else if (_Pred(*_Pfirst, *(_Glast - 1)))

  000f7	ff 75 f4	 push	 DWORD PTR tv320[ebp]
  000fa	8d 4d 14	 lea	 ecx, DWORD PTR __Pred$[ebp]
  000fd	57		 push	 edi
  000fe	e8 00 00 00 00	 call	 ??RRoundInfoStarSort@@QBE_NABURoundInfo@@0@Z ; RoundInfoStarSort::operator()
  00103	84 c0		 test	 al, al
  00105	75 1b		 jne	 SHORT $LN74@Unguarded_@3

; 3743 : 				break;
; 3744 : 			else
; 3745 : 				_STD iter_swap(--_Pfirst, _Glast - 1);

  00107	ff 75 f4	 push	 DWORD PTR tv320[ebp]
  0010a	2b fe		 sub	 edi, esi
  0010c	57		 push	 edi
  0010d	e8 00 00 00 00	 call	 ??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z ; std::swap<RoundInfo>
  00112	59		 pop	 ecx
  00113	59		 pop	 ecx
$LN13@Unguarded_@3:

; 3739 : 		for (; _First < _Glast; --_Glast)

  00114	29 75 f8	 sub	 DWORD PTR __Glast$[ebp], esi
  00117	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  0011a	29 75 f4	 sub	 DWORD PTR tv320[ebp], esi
  0011d	3b 45 f8	 cmp	 eax, DWORD PTR __Glast$[ebp]
  00120	72 c5		 jb	 SHORT $LL73@Unguarded_@3
$LN74@Unguarded_@3:

; 3746 : 		if (_Glast == _First && _Gfirst == _Last)

  00122	8b 45 f8	 mov	 eax, DWORD PTR __Glast$[ebp]
  00125	3b 45 0c	 cmp	 eax, DWORD PTR __First$[ebp]
  00128	75 25		 jne	 SHORT $LN6@Unguarded_@3
  0012a	8b 45 fc	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  0012d	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]
  00130	74 5a		 je	 SHORT $LN64@Unguarded_@3

; 3748 : 
; 3749 : 		if (_Glast == _First)
; 3750 : 			{	// no room at bottom, rotate pivot upward
; 3751 : 			if (_Plast != _Gfirst)

  00132	3b d8		 cmp	 ebx, eax
  00134	74 09		 je	 SHORT $LN46@Unguarded_@3

; 3752 : 				_STD iter_swap(_Pfirst, _Plast);

  00136	53		 push	 ebx
  00137	57		 push	 edi
  00138	e8 00 00 00 00	 call	 ??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z ; std::swap<RoundInfo>
  0013d	59		 pop	 ecx
  0013e	59		 pop	 ecx
$LN46@Unguarded_@3:

; 3753 : 			++_Plast;
; 3754 : 			_STD iter_swap(_Pfirst++, _Gfirst++);

  0013f	8b 45 fc	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00142	8b cf		 mov	 ecx, edi
  00144	50		 push	 eax
  00145	03 de		 add	 ebx, esi
  00147	03 fe		 add	 edi, esi
  00149	01 75 fc	 add	 DWORD PTR __Gfirst$[ebp], esi
  0014c	51		 push	 ecx
  0014d	eb 20		 jmp	 SHORT $LN76@Unguarded_@3
$LN6@Unguarded_@3:

; 3755 : 			}
; 3756 : 		else if (_Gfirst == _Last)

  0014f	8b 4d fc	 mov	 ecx, DWORD PTR __Gfirst$[ebp]

; 3757 : 			{	// no room at top, rotate pivot downward
; 3758 : 			if (--_Glast != --_Pfirst)

  00152	2b c6		 sub	 eax, esi
  00154	89 45 f8	 mov	 DWORD PTR __Glast$[ebp], eax
  00157	3b 4d 10	 cmp	 ecx, DWORD PTR __Last$[ebp]
  0015a	75 1f		 jne	 SHORT $LN3@Unguarded_@3
  0015c	2b fe		 sub	 edi, esi
  0015e	3b c7		 cmp	 eax, edi
  00160	74 09		 je	 SHORT $LN50@Unguarded_@3

; 3759 : 				_STD iter_swap(_Glast, _Pfirst);

  00162	57		 push	 edi
  00163	50		 push	 eax
  00164	e8 00 00 00 00	 call	 ??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z ; std::swap<RoundInfo>
  00169	59		 pop	 ecx
  0016a	59		 pop	 ecx
$LN50@Unguarded_@3:

; 3760 : 			_STD iter_swap(_Pfirst, --_Plast);

  0016b	2b de		 sub	 ebx, esi
  0016d	53		 push	 ebx
  0016e	57		 push	 edi
$LN76@Unguarded_@3:
  0016f	e8 00 00 00 00	 call	 ??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z ; std::swap<RoundInfo>
  00174	59		 pop	 ecx
  00175	59		 pop	 ecx

; 3761 : 			}
; 3762 : 		else

  00176	e9 1c ff ff ff	 jmp	 $LL23@Unguarded_@3
$LN3@Unguarded_@3:

; 3763 : 			_STD iter_swap(_Gfirst++, --_Glast);

  0017b	50		 push	 eax
  0017c	51		 push	 ecx
  0017d	e8 00 00 00 00	 call	 ??$swap@URoundInfo@@@std@@YAXAAURoundInfo@@0@Z ; std::swap<RoundInfo>
  00182	01 75 fc	 add	 DWORD PTR __Gfirst$[ebp], esi
  00185	59		 pop	 ecx
  00186	59		 pop	 ecx

; 3764 : 		}

  00187	e9 0b ff ff ff	 jmp	 $LL23@Unguarded_@3
$LN64@Unguarded_@3:

; 3747 : 			return (_STD pair<_RanIt, _RanIt>(_Pfirst, _Plast));

  0018c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0018f	89 38		 mov	 DWORD PTR [eax], edi
  00191	5f		 pop	 edi
  00192	5e		 pop	 esi
  00193	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00196	5b		 pop	 ebx

; 3765 : 	}

  00197	c9		 leave
  00198	c3		 ret	 0
??$_Unguarded_partition@PAURoundInfo@@VRoundInfoStarSort@@@std@@YA?AU?$pair@PAURoundInfo@@PAU1@@0@PAURoundInfo@@0VRoundInfoStarSort@@@Z ENDP ; std::_Unguarded_partition<RoundInfo *,RoundInfoStarSort>
_TEXT	ENDS
PUBLIC	??$make_heap@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@@Z ; std::make_heap<RoundInfo *,RoundInfoStarSort>
; Function compile flags: /Ogsp
;	COMDAT ??$make_heap@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$make_heap@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@@Z PROC ; std::make_heap<RoundInfo *,RoundInfoStarSort>, COMDAT

; 2672 : 	{	// make [_First, _Last) into a heap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2673 : 	_DEBUG_RANGE(_First, _Last);
; 2674 : 	_DEBUG_POINTER(_Pred);
; 2675 : 	if (1 < _Last - _First)

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00009	83 e0 80	 and	 eax, -128		; ffffff80H
  0000c	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00011	7e 15		 jle	 SHORT $LN1@make_heap@3

; 2676 : 		_Make_heap(_Unchecked(_First), _Unchecked(_Last), _Pred,
; 2677 : 			_Dist_type(_First), _Val_type(_First));

  00013	6a 00		 push	 0
  00015	6a 00		 push	 0
  00017	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  0001a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00020	e8 00 00 00 00	 call	 ??$_Make_heap@PAURoundInfo@@HU1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@PAH0@Z ; std::_Make_heap<RoundInfo *,int,RoundInfo,RoundInfoStarSort>
  00025	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@make_heap@3:

; 2678 : 	}

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??$make_heap@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@@Z ENDP ; std::make_heap<RoundInfo *,RoundInfoStarSort>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAURoundInfo@@PAU1@V?$allocator@URoundInfo@@@std@@U1@@std@@YAPAURoundInfo@@PAU1@00AAV?$allocator@URoundInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<RoundInfo *,RoundInfo *,std::allocator<RoundInfo>,RoundInfo>
EXTRN	__EH_prolog3_catch:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAURoundInfo@@PAU1@V?$allocator@URoundInfo@@@std@@U1@@std@@YAPAURoundInfo@@PAU1@00AAV?$allocator@URoundInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAURoundInfo@@PAU1@V?$allocator@URoundInfo@@@std@@U1@@std@@YAPAURoundInfo@@PAU1@00AAV?$allocator@URoundInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAURoundInfo@@PAU1@V?$allocator@URoundInfo@@@std@@U1@@std@@YAPAURoundInfo@@PAU1@00AAV?$allocator@URoundInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAURoundInfo@@PAU1@V?$allocator@URoundInfo@@@std@@U1@@std@@YAPAURoundInfo@@PAU1@00AAV?$allocator@URoundInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAURoundInfo@@PAU1@V?$allocator@URoundInfo@@@std@@U1@@std@@YAPAURoundInfo@@PAU1@00AAV?$allocator@URoundInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAURoundInfo@@PAU1@V?$allocator@URoundInfo@@@std@@U1@@std@@YAPAURoundInfo@@PAU1@00AAV?$allocator@URoundInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAURoundInfo@@PAU1@V?$allocator@URoundInfo@@@std@@U1@@std@@YAPAURoundInfo@@PAU1@00AAV?$allocator@URoundInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAURoundInfo@@PAU1@V?$allocator@URoundInfo@@@std@@U1@@std@@YAPAURoundInfo@@PAU1@00AAV?$allocator@URoundInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAURoundInfo@@PAU1@V?$allocator@URoundInfo@@@std@@U1@@std@@YAPAURoundInfo@@PAU1@00AAV?$allocator@URoundInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAURoundInfo@@PAU1@V?$allocator@URoundInfo@@@std@@U1@@std@@YAPAURoundInfo@@PAU1@00AAV?$allocator@URoundInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<RoundInfo *,RoundInfo *,std::allocator<RoundInfo>,RoundInfo>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	6a 08		 push	 8
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??$_Uninit_move@PAURoundInfo@@PAU1@V?$allocator@URoundInfo@@@std@@U1@@std@@YAPAURoundInfo@@PAU1@00AAV?$allocator@URoundInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_catch

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0000c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 428  : 
; 429  : 	_TRY_BEGIN

  0000f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
  00013	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  00016	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
  00019	be 80 00 00 00	 mov	 esi, 128		; 00000080H
$LL6@Uninit_mov:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  0001e	3b 7d 0c	 cmp	 edi, DWORD PTR __Last$[ebp]
  00021	74 3a		 je	 SHORT $LN4@Uninit_mov

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00023	57		 push	 edi
  00024	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00027	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0002a	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@U3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@$$QAU2@@Z ; std::_Cons_val<std::allocator<RoundInfo>,RoundInfo,RoundInfo>
  0002f	01 75 10	 add	 DWORD PTR __Dest$[ebp], esi
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
  00035	03 fe		 add	 edi, esi
  00037	eb e5		 jmp	 SHORT $LL6@Uninit_mov
__catch$??$_Uninit_move@PAURoundInfo@@PAU1@V?$allocator@URoundInfo@@@std@@U1@@std@@YAPAURoundInfo@@PAU1@00AAV?$allocator@URoundInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)

  00039	8b 7d ec	 mov	 edi, DWORD PTR __Next$[ebp]
  0003c	3b 7d 10	 cmp	 edi, DWORD PTR __Dest$[ebp]
  0003f	74 13		 je	 SHORT $LN1@Uninit_mov
  00041	be 80 00 00 00	 mov	 esi, 128		; 00000080H
$LL3@Uninit_mov:

; 434  : 		_Dest_val(_Al, _Next);

  00046	8b cf		 mov	 ecx, edi
  00048	e8 00 00 00 00	 call	 ??1RoundInfo@@QAE@XZ
  0004d	03 fe		 add	 edi, esi
  0004f	3b 7d 10	 cmp	 edi, DWORD PTR __Dest$[ebp]
  00052	75 f2		 jne	 SHORT $LL3@Uninit_mov
$LN1@Uninit_mov:

; 435  : 	_RERAISE;

  00054	6a 00		 push	 0
  00056	6a 00		 push	 0
  00058	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN29@Uninit_mov:
$LN4@Uninit_mov:

; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  0005d	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 438  : 	}

  00060	e8 00 00 00 00	 call	 __EH_epilog3
  00065	c3		 ret	 0
$LN28@Uninit_mov:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAURoundInfo@@PAU1@V?$allocator@URoundInfo@@@std@@U1@@std@@YAPAURoundInfo@@PAU1@00AAV?$allocator@URoundInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAURoundInfo@@PAU1@V?$allocator@URoundInfo@@@std@@U1@@std@@YAPAURoundInfo@@PAU1@00AAV?$allocator@URoundInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAURoundInfo@@PAU1@V?$allocator@URoundInfo@@@std@@U1@@std@@YAPAURoundInfo@@PAU1@00AAV?$allocator@URoundInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<RoundInfo *,RoundInfo *,std::allocator<RoundInfo>,RoundInfo>
PUBLIC	??$_Pop_heap@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@@Z ; std::_Pop_heap<RoundInfo *,RoundInfoKoSort>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\algorithm
;	COMDAT ??$_Pop_heap@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Pop_heap@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@@Z PROC ; std::_Pop_heap<RoundInfo *,RoundInfoKoSort>, COMDAT

; 2610 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2611 : 	_Pop_heap_0(_Unchecked(_First), _Unchecked(_Last), _Pred,
; 2612 : 		_Val_type(_First));

  00003	6a 00		 push	 0
  00005	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00008	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000e	e8 00 00 00 00	 call	 ??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@0@Z ; std::_Pop_heap_0<RoundInfo *,RoundInfo,RoundInfoKoSort>
  00013	83 c4 10	 add	 esp, 16			; 00000010H

; 2613 : 	}

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$_Pop_heap@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@@Z ENDP ; std::_Pop_heap<RoundInfo *,RoundInfoKoSort>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@@Z ; std::_Pop_heap<RoundInfo *,RoundInfoSort>
; Function compile flags: /Ogsp
;	COMDAT ??$_Pop_heap@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Pop_heap@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@@Z PROC ; std::_Pop_heap<RoundInfo *,RoundInfoSort>, COMDAT

; 2610 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2611 : 	_Pop_heap_0(_Unchecked(_First), _Unchecked(_Last), _Pred,
; 2612 : 		_Val_type(_First));

  00003	6a 00		 push	 0
  00005	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00008	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000e	e8 00 00 00 00	 call	 ??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@0@Z ; std::_Pop_heap_0<RoundInfo *,RoundInfo,RoundInfoSort>
  00013	83 c4 10	 add	 esp, 16			; 00000010H

; 2613 : 	}

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$_Pop_heap@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@@Z ENDP ; std::_Pop_heap<RoundInfo *,RoundInfoSort>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@@Z ; std::_Pop_heap<RoundInfo *,RoundInfoStarSort>
; Function compile flags: /Ogsp
;	COMDAT ??$_Pop_heap@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Pop_heap@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@@Z PROC ; std::_Pop_heap<RoundInfo *,RoundInfoStarSort>, COMDAT

; 2610 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2611 : 	_Pop_heap_0(_Unchecked(_First), _Unchecked(_Last), _Pred,
; 2612 : 		_Val_type(_First));

  00003	6a 00		 push	 0
  00005	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00008	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000e	e8 00 00 00 00	 call	 ??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@0@Z ; std::_Pop_heap_0<RoundInfo *,RoundInfo,RoundInfoStarSort>
  00013	83 c4 10	 add	 esp, 16			; 00000010H

; 2613 : 	}

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$_Pop_heap@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@@Z ENDP ; std::_Pop_heap<RoundInfo *,RoundInfoStarSort>
_TEXT	ENDS
PUBLIC	??_C@_0CF@NPCLHDMP@RoundStateUserWnd?3?3OnRenderTeamT@ ; `string'
PUBLIC	__real@3f266666
PUBLIC	_this$GSCopy$
PUBLIC	?OnRenderTeamTitle@RoundStateUserWnd@@IAEXHH_N0@Z ; RoundStateUserWnd::OnRenderTeamTitle
EXTRN	?GetLadderRedTeamInfo@ioLadderTeamMgr@@QAEABUtagLadderTeamInfo@@XZ:PROC ; ioLadderTeamMgr::GetLadderRedTeamInfo
EXTRN	?RenderMarkSize@ioGuildMarkMgr@@QAEXHHKKMMW4UIRenderType@@@Z:PROC ; ioGuildMarkMgr::RenderMarkSize
EXTRN	?GetGuildData@ioGuildInfo@@QAEPAVioGuildData@@K_N@Z:PROC ; ioGuildInfo::GetGuildData
EXTRN	?GetSingleton@ioGuildInfo@@SAAAV1@XZ:PROC	; ioGuildInfo::GetSingleton
EXTRN	__imp_?PrintText@ioFontManager@@QAEXMMMPBDH0@Z:PROC
EXTRN	__imp_??8ioHashString@@QBE_NABV0@@Z:PROC
EXTRN	?GetLadderBlueTeamInfo@ioLadderTeamMgr@@QAEABUtagLadderTeamInfo@@XZ:PROC ; ioLadderTeamMgr::GetLadderBlueTeamInfo
EXTRN	__imp_?PrintText@ioFontManager@@QAEXMMMPBDHHH@Z:PROC
EXTRN	?GetBattleRoomInfo@ioBattleRoomMgr@@QAEXPAUtagBattleRoomInfo@@@Z:PROC ; ioBattleRoomMgr::GetBattleRoomInfo
EXTRN	__imp_?GetNumberCount@@YAHH@Z:PROC
;	COMDAT ??_C@_0CF@NPCLHDMP@RoundStateUserWnd?3?3OnRenderTeamT@
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioguildinfo.h
CONST	SEGMENT
??_C@_0CF@NPCLHDMP@RoundStateUserWnd?3?3OnRenderTeamT@ DB 'RoundStateUser'
	DB	'Wnd::OnRenderTeamTitle', 00H		; `string'
CONST	ENDS
;	COMDAT __real@3f266666
CONST	SEGMENT
__real@3f266666 DD 03f266666r			; 0.65
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?OnRenderTeamTitle@RoundStateUserWnd@@IAEXHH_N0@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?OnRenderTeamTitle@RoundStateUserWnd@@IAEXHH_N0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?OnRenderTeamTitle@RoundStateUserWnd@@IAEXHH_N0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnRenderTeamTitle@RoundStateUserWnd@@IAEXHH_N0@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?OnRenderTeamTitle@RoundStateUserWnd@@IAEXHH_N0@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?OnRenderTeamTitle@RoundStateUserWnd@@IAEXHH_N0@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?OnRenderTeamTitle@RoundStateUserWnd@@IAEXHH_N0@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?OnRenderTeamTitle@RoundStateUserWnd@@IAEXHH_N0@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?OnRenderTeamTitle@RoundStateUserWnd@@IAEXHH_N0@Z$5
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
xdata$x	ENDS
;	COMDAT ?OnRenderTeamTitle@RoundStateUserWnd@@IAEXHH_N0@Z
_TEXT	SEGMENT
_LadderInfo$550178 = -1608				; size = 108
_LadderInfo$550160 = -1500				; size = 108
tv1076 = -1392						; size = 4
_this$GSCopy$ = -1392					; size = 4
tv1037 = -1388						; size = 4
_value$568901 = -1388					; size = 1
$T568953 = -1388					; size = 4
$T568922 = -1388					; size = 4
tv1100 = -1384						; size = 4
tv1078 = -1384						; size = 4
_iScoreXGap$ = -1384					; size = 4
_kHeroInfo$550184 = -1380				; size = 924
_kHeroInfo$550166 = -1380				; size = 924
_BattleInfo$550142 = -456				; size = 440
_BattleInfo$550138 = -456				; size = 440
__$EHRec$ = -12						; size = 12
_iXPos$ = 8						; size = 4
_iYPos$ = 12						; size = 4
_bPointRender$ = 16					; size = 1
_bScroreRender$ = 20					; size = 1
?OnRenderTeamTitle@RoundStateUserWnd@@IAEXHH_N0@Z PROC	; RoundStateUserWnd::OnRenderTeamTitle, COMDAT
; _this$ = ecx

; 1523 : {

  00000	68 3c 06 00 00	 push	 1596			; 0000063cH
  00005	b8 00 00 00 00	 mov	 eax, __ehhandler$?OnRenderTeamTitle@RoundStateUserWnd@@IAEXHH_N0@Z
  0000a	e8 00 00 00 00	 call	 __EH_prolog3_GS

; 1524 : 	int iScoreXGap = 12;
; 1525 : 
; 1526 : 	if( m_pCurrentNumber  && m_pCurrentNumberText && bPointRender )

  0000f	8b 75 0c	 mov	 esi, DWORD PTR _iYPos$[ebp]
  00012	8b f9		 mov	 edi, ecx
  00014	8b 8f 48 02 00
	00		 mov	 ecx, DWORD PTR [edi+584]
  0001a	33 db		 xor	 ebx, ebx
  0001c	89 bd 90 fa ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], edi
  00022	c7 85 98 fa ff
	ff 0c 00 00 00	 mov	 DWORD PTR _iScoreXGap$[ebp], 12 ; 0000000cH
  0002c	3b cb		 cmp	 ecx, ebx
  0002e	0f 84 b8 00 00
	00		 je	 $LN51@OnRenderTe@2
  00034	39 9f 4c 02 00
	00		 cmp	 DWORD PTR [edi+588], ebx
  0003a	0f 84 ac 00 00
	00		 je	 $LN51@OnRenderTe@2
  00040	38 5d 10	 cmp	 BYTE PTR _bPointRender$[ebp], bl
  00043	0f 84 a3 00 00
	00		 je	 $LN51@OnRenderTe@2

; 1527 : 	{	
; 1528 : 		m_pCurrentNumber->RenderNum( iXPos + iScoreXGap, iYPos + 16, m_iCurrentScore );

  00049	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00051	53		 push	 ebx
  00052	53		 push	 ebx
  00053	53		 push	 ebx
  00054	53		 push	 ebx
  00055	51		 push	 ecx
  00056	51		 push	 ecx
  00057	f3 0f 11 4c 24
	04		 movss	 DWORD PTR [esp+4], xmm1
  0005d	0f 57 c9	 xorps	 xmm1, xmm1
  00060	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00065	ff b7 6c 02 00
	00		 push	 DWORD PTR [edi+620]
  0006b	0f 57 c0	 xorps	 xmm0, xmm0
  0006e	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  00071	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00075	8b 45 08	 mov	 eax, DWORD PTR _iXPos$[ebp]
  00078	51		 push	 ecx
  00079	51		 push	 ecx
  0007a	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00080	f3 0f 11 85 94
	fa ff ff	 movss	 DWORD PTR tv1037[ebp], xmm0
  00088	83 c0 0c	 add	 eax, 12			; 0000000cH
  0008b	0f 57 c0	 xorps	 xmm0, xmm0
  0008e	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00092	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?RenderNum@ioUIRenderImage@@QAEXMMHMMW4UIRenderType@@W4TextureFilterOption@@0W4RenerNumerFormatting@1@@Z

; 1529 : 		iScoreXGap += GetNumberCount( m_iCurrentScore ) * 23;

  0009d	ff b7 6c 02 00
	00		 push	 DWORD PTR [edi+620]
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetNumberCount@@YAHH@Z
  000a9	6b c0 17	 imul	 eax, 23			; 00000017H

; 1530 : 
; 1531 : 		m_pCurrentNumberText->Render( iXPos + iScoreXGap, iYPos + 16 );

  000ac	f3 0f 10 85 94
	fa ff ff	 movss	 xmm0, DWORD PTR tv1037[ebp]
  000b4	59		 pop	 ecx
  000b5	8b 8f 4c 02 00
	00		 mov	 ecx, DWORD PTR [edi+588]
  000bb	8b 11		 mov	 edx, DWORD PTR [ecx]
  000bd	53		 push	 ebx
  000be	53		 push	 ebx
  000bf	53		 push	 ebx
  000c0	53		 push	 ebx
  000c1	83 c0 0c	 add	 eax, 12			; 0000000cH
  000c4	51		 push	 ecx
  000c5	51		 push	 ecx
  000c6	89 85 98 fa ff
	ff		 mov	 DWORD PTR _iScoreXGap$[ebp], eax
  000cc	03 45 08	 add	 eax, DWORD PTR _iXPos$[ebp]
  000cf	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000d5	0f 57 c0	 xorps	 xmm0, xmm0
  000d8	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000dc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e1	ff 12		 call	 DWORD PTR [edx]

; 1532 : 		iScoreXGap += 32;

  000e3	83 85 98 fa ff
	ff 20		 add	 DWORD PTR _iScoreXGap$[ebp], 32 ; 00000020H

; 1533 : 	}
; 1534 : 	else

  000ea	eb 54		 jmp	 SHORT $LN46@OnRenderTe@2
$LN51@OnRenderTe@2:

; 1535 : 	{
; 1536 : 		if( m_eWindowTeam == TEAM_BLUE )

  000ec	83 bf 58 02 00
	00 02		 cmp	 DWORD PTR [edi+600], 2
  000f3	75 10		 jne	 SHORT $LN49@OnRenderTe@2

; 1537 : 		{
; 1538 : 			if( m_pBlueTeam )

  000f5	39 9f 50 02 00
	00		 cmp	 DWORD PTR [edi+592], ebx
  000fb	74 43		 je	 SHORT $LN46@OnRenderTe@2

; 1539 : 				m_pBlueTeam->Render( iXPos + iScoreXGap, iYPos + 16, UI_RENDER_NORMAL, TFO_BILINEAR );

  000fd	8b 8f 50 02 00
	00		 mov	 ecx, DWORD PTR [edi+592]

; 1540 : 		}
; 1541 : 		else

  00103	eb 0e		 jmp	 SHORT $LN94@OnRenderTe@2
$LN49@OnRenderTe@2:

; 1542 : 		{
; 1543 : 			if( m_pRedTeam )

  00105	39 9f 54 02 00
	00		 cmp	 DWORD PTR [edi+596], ebx
  0010b	74 33		 je	 SHORT $LN46@OnRenderTe@2

; 1544 : 				m_pRedTeam->Render( iXPos + iScoreXGap, iYPos  + 16, UI_RENDER_NORMAL, TFO_BILINEAR );

  0010d	8b 8f 54 02 00
	00		 mov	 ecx, DWORD PTR [edi+596]
$LN94@OnRenderTe@2:
  00113	8b 01		 mov	 eax, DWORD PTR [ecx]
  00115	53		 push	 ebx
  00116	53		 push	 ebx
  00117	6a 01		 push	 1
  00119	53		 push	 ebx
  0011a	0f 57 c0	 xorps	 xmm0, xmm0
  0011d	8d 56 10	 lea	 edx, DWORD PTR [esi+16]
  00120	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  00124	8b 55 08	 mov	 edx, DWORD PTR _iXPos$[ebp]
  00127	51		 push	 ecx
  00128	51		 push	 ecx
  00129	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0012f	83 c2 0c	 add	 edx, 12			; 0000000cH
  00132	0f 57 c0	 xorps	 xmm0, xmm0
  00135	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  00139	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0013e	ff 10		 call	 DWORD PTR [eax]
$LN46@OnRenderTe@2:

; 1545 : 		}
; 1546 : 	}
; 1547 : 
; 1548 : 	if( g_BattleRoomMgr.IsTournamentModeType() )

  00140	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  00145	8b c8		 mov	 ecx, eax
  00147	e8 00 00 00 00	 call	 ?IsTournamentModeType@ioBattleRoomMgr@@QAE_NXZ ; ioBattleRoomMgr::IsTournamentModeType
  0014c	84 c0		 test	 al, al
  0014e	0f 84 bf 00 00
	00		 je	 $LN45@OnRenderTe@2

; 1549 : 	{
; 1550 : 		g_FontMgr.SetBkColor( 0, 0, 0 );

  00154	53		 push	 ebx
  00155	53		 push	 ebx
  00156	53		 push	 ebx
  00157	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  0015d	8b c8		 mov	 ecx, eax
  0015f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetBkColor@ioFontManager@@QAEXHHH@Z

; 1551 : 		g_FontMgr.SetAlignType( TAT_LEFT );

  00165	53		 push	 ebx
  00166	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  0016c	8b c8		 mov	 ecx, eax
  0016e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 1552 : 		g_FontMgr.SetTextStyle( TS_NORMAL );

  00174	53		 push	 ebx
  00175	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  0017b	8b c8		 mov	 ecx, eax
  0017d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextStyle@ioFontManager@@QAEXW4TextStyle@@@Z

; 1553 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_DARKGRAY );

  00183	68 3a 3a 3a ff	 push	 -12961222		; ff3a3a3aH
  00188	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  0018e	8b c8		 mov	 ecx, eax
  00190	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextColor@ioFontManager@@QAEXK@Z

; 1554 : 
; 1555 : 		BattleRoomInfo BattleInfo;

  00196	8d 8d 38 fe ff
	ff		 lea	 ecx, DWORD PTR _BattleInfo$550138[ebp]
  0019c	e8 00 00 00 00	 call	 ??0tagBattleRoomInfo@@QAE@XZ ; tagBattleRoomInfo::tagBattleRoomInfo

; 1556 : 		g_BattleRoomMgr.GetBattleRoomInfo( &BattleInfo );

  001a1	8d 85 38 fe ff
	ff		 lea	 eax, DWORD PTR _BattleInfo$550138[ebp]
  001a7	50		 push	 eax
  001a8	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  001ab	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  001b0	8b c8		 mov	 ecx, eax
  001b2	e8 00 00 00 00	 call	 ?GetBattleRoomInfo@ioBattleRoomMgr@@QAEXPAUtagBattleRoomInfo@@@Z ; ioBattleRoomMgr::GetBattleRoomInfo

; 1557 : 		g_FontMgr.PrintText( iXPos + iScoreXGap + 4, iYPos + 30, FONT_SIZE_13, m_szTournamentTeamName.c_str() );

  001b7	8d 8f d4 02 00
	00		 lea	 ecx, DWORD PTR [edi+724]
  001bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  001c3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f266666
  001cb	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  001ce	50		 push	 eax
  001cf	8b 85 98 fa ff
	ff		 mov	 eax, DWORD PTR _iScoreXGap$[ebp]
  001d5	83 ec 0c	 sub	 esp, 12			; 0000000cH
  001d8	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  001de	0f 57 c0	 xorps	 xmm0, xmm0
  001e1	83 c6 1e	 add	 esi, 30			; 0000001eH
  001e4	f3 0f 2a c6	 cvtsi2ss xmm0, esi
  001e8	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  001ee	8d 44 08 04	 lea	 eax, DWORD PTR [eax+ecx+4]
  001f2	0f 57 c0	 xorps	 xmm0, xmm0
  001f5	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001f9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  00204	50		 push	 eax
  00205	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAAXMMMPBDZZ
  0020b	83 c4 14	 add	 esp, 20			; 00000014H

; 1558 : 
; 1559 : 
; 1560 : 	}

  0020e	e9 a5 02 00 00	 jmp	 $LN32@OnRenderTe@2
$LN45@OnRenderTe@2:

; 1561 : 	else if( g_BattleRoomMgr.IsBattleRoom() )

  00213	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  00218	8b c8		 mov	 ecx, eax
  0021a	e8 00 00 00 00	 call	 ?IsBattleRoom@ioBattleRoomMgr@@QAE_NXZ ; ioBattleRoomMgr::IsBattleRoom
  0021f	84 c0		 test	 al, al
  00221	0f 84 a5 02 00
	00		 je	 $LN43@OnRenderTe@2

; 1562 : 	{
; 1563 : 		// 싱글 모드가 아닐 때만 승무패표시
; 1564 : 		g_FontMgr.SetBkColor( 0, 0, 0 );

  00227	53		 push	 ebx
  00228	53		 push	 ebx
  00229	53		 push	 ebx
  0022a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  00230	8b c8		 mov	 ecx, eax
  00232	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetBkColor@ioFontManager@@QAEXHHH@Z

; 1565 : 		g_FontMgr.SetAlignType( TAT_LEFT );

  00238	53		 push	 ebx
  00239	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  0023f	8b c8		 mov	 ecx, eax
  00241	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 1566 : 		g_FontMgr.SetTextStyle( TS_NORMAL );

  00247	53		 push	 ebx
  00248	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  0024e	8b c8		 mov	 ecx, eax
  00250	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextStyle@ioFontManager@@QAEXW4TextStyle@@@Z

; 1567 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_DARKGRAY );

  00256	68 3a 3a 3a ff	 push	 -12961222		; ff3a3a3aH
  0025b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  00261	8b c8		 mov	 ecx, eax
  00263	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextColor@ioFontManager@@QAEXK@Z

; 1568 : 
; 1569 : 		BattleRoomInfo BattleInfo;

  00269	8d 8d 38 fe ff
	ff		 lea	 ecx, DWORD PTR _BattleInfo$550142[ebp]
  0026f	e8 00 00 00 00	 call	 ??0tagBattleRoomInfo@@QAE@XZ ; tagBattleRoomInfo::tagBattleRoomInfo

; 1570 : 		g_BattleRoomMgr.GetBattleRoomInfo( &BattleInfo );

  00274	8d 85 38 fe ff
	ff		 lea	 eax, DWORD PTR _BattleInfo$550142[ebp]
  0027a	50		 push	 eax
  0027b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00282	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  00287	8b c8		 mov	 ecx, eax
  00289	e8 00 00 00 00	 call	 ?GetBattleRoomInfo@ioBattleRoomMgr@@QAEXPAUtagBattleRoomInfo@@@Z ; ioBattleRoomMgr::GetBattleRoomInfo

; 1571 : 		if( m_eWindowTeam == TEAM_BLUE )

  0028e	8b 87 58 02 00
	00		 mov	 eax, DWORD PTR [edi+600]
  00294	83 f8 02	 cmp	 eax, 2
  00297	75 3d		 jne	 SHORT $LN42@OnRenderTe@2

; 1572 : 		{
; 1573 : 			if( bScroreRender )

  00299	38 5d 14	 cmp	 BYTE PTR _bScroreRender$[ebp], bl
  0029c	0f 84 36 01 00
	00		 je	 $LN34@OnRenderTe@2

; 1574 : 			{
; 1575 : 				if( BattleInfo.m_iBlueVictories > 1 )

  002a2	83 bd 8c fe ff
	ff 01		 cmp	 DWORD PTR _BattleInfo$550142[ebp+84], 1
  002a9	7e 17		 jle	 SHORT $LN40@OnRenderTe@2

; 1576 : 					g_FontMgr.PrintText( iXPos + iScoreXGap + 4, iYPos + 30, FONT_SIZE_13, STR(1), BattleInfo.m_iBlueWin, BattleInfo.m_iBlueLose, BattleInfo.m_iBlueVictories );

  002ab	ff b5 8c fe ff
	ff		 push	 DWORD PTR _BattleInfo$550142[ebp+84]
  002b1	ff b5 88 fe ff
	ff		 push	 DWORD PTR _BattleInfo$550142[ebp+80]
  002b7	ff b5 84 fe ff
	ff		 push	 DWORD PTR _BattleInfo$550142[ebp+76]
  002bd	53		 push	 ebx
  002be	6a 01		 push	 1

; 1577 : 				else

  002c0	eb 43		 jmp	 SHORT $LN96@OnRenderTe@2
$LN40@OnRenderTe@2:

; 1578 : 					g_FontMgr.PrintText( iXPos + iScoreXGap + 4, iYPos + 30, FONT_SIZE_13, STR(2), BattleInfo.m_iBlueWin, BattleInfo.m_iBlueLose );

  002c2	ff b5 88 fe ff
	ff		 push	 DWORD PTR _BattleInfo$550142[ebp+80]
  002c8	ff b5 84 fe ff
	ff		 push	 DWORD PTR _BattleInfo$550142[ebp+76]
  002ce	53		 push	 ebx
  002cf	6a 02		 push	 2

; 1579 : 			}
; 1580 : 		}

  002d1	e9 a1 00 00 00	 jmp	 $LN95@OnRenderTe@2
$LN42@OnRenderTe@2:

; 1581 : 		else if( m_eWindowTeam == TEAM_RED )

  002d6	83 f8 01	 cmp	 eax, 1
  002d9	0f 85 f9 00 00
	00		 jne	 $LN34@OnRenderTe@2

; 1582 : 		{
; 1583 : 			if( bScroreRender )

  002df	38 5d 14	 cmp	 BYTE PTR _bScroreRender$[ebp], bl
  002e2	0f 84 f0 00 00
	00		 je	 $LN34@OnRenderTe@2

; 1584 : 			{
; 1585 : 				if( BattleInfo.m_iRedVictories > 1 )

  002e8	39 85 98 fe ff
	ff		 cmp	 DWORD PTR _BattleInfo$550142[ebp+96], eax
  002ee	7e 78		 jle	 SHORT $LN35@OnRenderTe@2

; 1586 : 					g_FontMgr.PrintText( iXPos + iScoreXGap + 4, iYPos + 30, FONT_SIZE_13, STR(3), BattleInfo.m_iRedWin, BattleInfo.m_iRedLose, BattleInfo.m_iRedVictories );

  002f0	ff b5 98 fe ff
	ff		 push	 DWORD PTR _BattleInfo$550142[ebp+96]
  002f6	ff b5 94 fe ff
	ff		 push	 DWORD PTR _BattleInfo$550142[ebp+92]
  002fc	ff b5 90 fe ff
	ff		 push	 DWORD PTR _BattleInfo$550142[ebp+88]
  00302	53		 push	 ebx
  00303	6a 03		 push	 3
$LN96@OnRenderTe@2:
  00305	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0030a	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NPCLHDMP@RoundStateUserWnd?3?3OnRenderTeamT@
  0030f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00315	8b c8		 mov	 ecx, eax
  00317	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0031d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f266666
  00325	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  00328	50		 push	 eax
  00329	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0032c	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00332	0f 57 c0	 xorps	 xmm0, xmm0
  00335	8d 46 1e	 lea	 eax, DWORD PTR [esi+30]
  00338	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0033c	8b 85 98 fa ff
	ff		 mov	 eax, DWORD PTR _iScoreXGap$[ebp]
  00342	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00348	8d 44 08 04	 lea	 eax, DWORD PTR [eax+ecx+4]
  0034c	0f 57 c0	 xorps	 xmm0, xmm0
  0034f	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00353	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00358	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  0035e	8b c8		 mov	 ecx, eax
  00360	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAEXMMMPBDHHH@Z

; 1587 : 				else

  00366	eb 70		 jmp	 SHORT $LN34@OnRenderTe@2
$LN35@OnRenderTe@2:

; 1588 : 					g_FontMgr.PrintText( iXPos + iScoreXGap + 4, iYPos + 30, FONT_SIZE_13, STR(4), BattleInfo.m_iRedWin, BattleInfo.m_iRedLose );

  00368	ff b5 94 fe ff
	ff		 push	 DWORD PTR _BattleInfo$550142[ebp+92]
  0036e	ff b5 90 fe ff
	ff		 push	 DWORD PTR _BattleInfo$550142[ebp+88]
  00374	53		 push	 ebx
  00375	6a 04		 push	 4
$LN95@OnRenderTe@2:
  00377	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0037c	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NPCLHDMP@RoundStateUserWnd?3?3OnRenderTeamT@
  00381	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00387	8b c8		 mov	 ecx, eax
  00389	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0038f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f266666
  00397	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  0039a	50		 push	 eax
  0039b	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0039e	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  003a4	0f 57 c0	 xorps	 xmm0, xmm0
  003a7	8d 46 1e	 lea	 eax, DWORD PTR [esi+30]
  003aa	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  003ae	8b 85 98 fa ff
	ff		 mov	 eax, DWORD PTR _iScoreXGap$[ebp]
  003b4	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  003ba	8d 44 08 04	 lea	 eax, DWORD PTR [eax+ecx+4]
  003be	0f 57 c0	 xorps	 xmm0, xmm0
  003c1	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  003c5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  003d0	8b c8		 mov	 ecx, eax
  003d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAEXMMMPBDHH@Z
$LN34@OnRenderTe@2:

; 1589 : 			}
; 1590 : 		}
; 1591 : 
; 1592 : 		if( m_pModeIconBack )

  003d8	39 9f b0 01 00
	00		 cmp	 DWORD PTR [edi+432], ebx
  003de	0f 84 d4 00 00
	00		 je	 $LN32@OnRenderTe@2

; 1593 : 		{
; 1594 : 			m_pModeIconBack->SetScale( 0.54f );

  003e4	8b 8f b0 01 00
	00		 mov	 ecx, DWORD PTR [edi+432]
  003ea	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0a3d71
  003f2	8b 01		 mov	 eax, DWORD PTR [ecx]
  003f4	51		 push	 ecx
  003f5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003fa	ff 50 1c	 call	 DWORD PTR [eax+28]

; 1595 : 			m_pModeIconBack->Render( iXPos + 285, iYPos + 30, UI_RENDER_MULTIPLY, TFO_BILINEAR );

  003fd	8b 8f b0 01 00
	00		 mov	 ecx, DWORD PTR [edi+432]
  00403	8b 45 08	 mov	 eax, DWORD PTR _iXPos$[ebp]
  00406	53		 push	 ebx
  00407	53		 push	 ebx
  00408	6a 01		 push	 1
  0040a	6a 08		 push	 8
  0040c	05 1d 01 00 00	 add	 eax, 285		; 0000011dH
  00411	51		 push	 ecx
  00412	51		 push	 ecx
  00413	83 c6 1e	 add	 esi, 30			; 0000001eH
  00416	0f 57 c0	 xorps	 xmm0, xmm0
  00419	f3 0f 2a c6	 cvtsi2ss xmm0, esi
  0041d	0f 57 c9	 xorps	 xmm1, xmm1
  00420	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00424	8b 01		 mov	 eax, DWORD PTR [ecx]
  00426	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0042c	f3 0f 11 85 90
	fa ff ff	 movss	 DWORD PTR tv1076[ebp], xmm0
  00434	f3 0f 11 8d 98
	fa ff ff	 movss	 DWORD PTR tv1100[ebp], xmm1
  0043c	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00441	ff 10		 call	 DWORD PTR [eax]

; 1596 : 
; 1597 : 			// 모드 아이콘
; 1598 : 			ioUIRenderImage *pModeIcon = g_ModeSelectInfo.GetModeIcon( ioPlayMode::GetModeType(), m_eWindowTeam, g_BattleRoomMgr.IsUseExtraOption() );

  00443	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  00448	8d 8d 94 fa ff
	ff		 lea	 ecx, DWORD PTR _value$568901[ebp]
  0044e	51		 push	 ecx
  0044f	8d 48 70	 lea	 ecx, DWORD PTR [eax+112]
  00452	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  00457	ff b5 94 fa ff
	ff		 push	 DWORD PTR _value$568901[ebp]
  0045d	ff b7 58 02 00
	00		 push	 DWORD PTR [edi+600]
  00463	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  00468	50		 push	 eax
  00469	e8 00 00 00 00	 call	 ?GetSingleton@ioModeSelectInfo@@SAAAV1@XZ ; ioModeSelectInfo::GetSingleton
  0046e	8b c8		 mov	 ecx, eax
  00470	e8 00 00 00 00	 call	 ?GetModeIcon@ioModeSelectInfo@@QAEPAVioUIRenderImage@@W4ModeType@@W4TeamType@@_N@Z ; ioModeSelectInfo::GetModeIcon
  00475	8b f0		 mov	 esi, eax

; 1599 : 			if( pModeIcon )

  00477	3b f3		 cmp	 esi, ebx
  00479	74 3d		 je	 SHORT $LN32@OnRenderTe@2

; 1600 : 			{
; 1601 : 				pModeIcon->SetScale( 0.54f );

  0047b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0a3d71
  00483	8b 06		 mov	 eax, DWORD PTR [esi]
  00485	51		 push	 ecx
  00486	8b ce		 mov	 ecx, esi
  00488	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0048d	ff 50 1c	 call	 DWORD PTR [eax+28]

; 1602 : 				pModeIcon->Render( iXPos + 285, iYPos + 30, UI_RENDER_NORMAL, TFO_BILINEAR );

  00490	f3 0f 10 85 90
	fa ff ff	 movss	 xmm0, DWORD PTR tv1076[ebp]
  00498	8b 06		 mov	 eax, DWORD PTR [esi]
  0049a	53		 push	 ebx
  0049b	53		 push	 ebx
  0049c	6a 01		 push	 1
  0049e	53		 push	 ebx
  0049f	51		 push	 ecx
  004a0	51		 push	 ecx
  004a1	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  004a7	f3 0f 10 85 98
	fa ff ff	 movss	 xmm0, DWORD PTR tv1100[ebp]
  004af	8b ce		 mov	 ecx, esi
  004b1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004b6	ff 10		 call	 DWORD PTR [eax]
$LN32@OnRenderTe@2:

; 1603 : 			}
; 1604 : 		}
; 1605 : 	}

  004b8	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  004bc	8d 8d 38 fe ff
	ff		 lea	 ecx, DWORD PTR _BattleInfo$550142[ebp]
  004c2	e8 00 00 00 00	 call	 ??1tagBattleRoomInfo@@QAE@XZ
  004c7	e9 08 08 00 00	 jmp	 $LN14@OnRenderTe@2
$LN43@OnRenderTe@2:

; 1606 : 	else if( g_LadderTeamMgr.IsLadderTeam() )

  004cc	e8 00 00 00 00	 call	 ?GetSingleton@ioLadderTeamMgr@@SAAAV1@XZ ; ioLadderTeamMgr::GetSingleton
  004d1	8b c8		 mov	 ecx, eax
  004d3	e8 00 00 00 00	 call	 ?IsLadderTeam@ioLadderTeamMgr@@QAE_NXZ ; ioLadderTeamMgr::IsLadderTeam
  004d8	84 c0		 test	 al, al
  004da	0f 84 f4 07 00
	00		 je	 $LN14@OnRenderTe@2

; 1607 : 	{
; 1608 : 		g_FontMgr.SetBkColor( 0, 0, 0 );

  004e0	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?GetSingleton@ioFontManager@@SAAAV1@XZ
  004e6	53		 push	 ebx
  004e7	53		 push	 ebx
  004e8	53		 push	 ebx
  004e9	ff d7		 call	 edi
  004eb	8b c8		 mov	 ecx, eax
  004ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetBkColor@ioFontManager@@QAEXHHH@Z

; 1609 : 		g_FontMgr.SetAlignType( TAT_LEFT );

  004f3	53		 push	 ebx
  004f4	ff d7		 call	 edi
  004f6	8b c8		 mov	 ecx, eax
  004f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetAlignType@ioFontManager@@QAEXW4TextAlignType@@@Z

; 1610 : 		g_FontMgr.SetTextStyle( TS_NORMAL );

  004fe	53		 push	 ebx
  004ff	ff d7		 call	 edi
  00501	8b c8		 mov	 ecx, eax
  00503	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextStyle@ioFontManager@@QAEXW4TextStyle@@@Z

; 1611 : 		g_FontMgr.SetTextColor( TCT_DEFAULT_DARKGRAY );

  00509	68 3a 3a 3a ff	 push	 -12961222		; ff3a3a3aH
  0050e	ff d7		 call	 edi
  00510	8b c8		 mov	 ecx, eax
  00512	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTextColor@ioFontManager@@QAEXK@Z

; 1612 : 		if( m_eWindowTeam == TEAM_BLUE )

  00518	8b 85 90 fa ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$[ebp]
  0051e	8b 80 58 02 00
	00		 mov	 eax, DWORD PTR [eax+600]
  00524	83 f8 02	 cmp	 eax, 2
  00527	0f 85 cd 03 00
	00		 jne	 $LN29@OnRenderTe@2

; 1613 : 		{
; 1614 : 			LadderTeamInfo LadderInfo = g_LadderTeamMgr.GetLadderBlueTeamInfo();

  0052d	e8 00 00 00 00	 call	 ?GetSingleton@ioLadderTeamMgr@@SAAAV1@XZ ; ioLadderTeamMgr::GetSingleton
  00532	8b c8		 mov	 ecx, eax
  00534	e8 00 00 00 00	 call	 ?GetLadderBlueTeamInfo@ioLadderTeamMgr@@QAEABUtagLadderTeamInfo@@XZ ; ioLadderTeamMgr::GetLadderBlueTeamInfo
  00539	50		 push	 eax
  0053a	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _LadderInfo$550160[ebp]
  00540	e8 00 00 00 00	 call	 ??0tagLadderTeamInfo@@QAE@ABU0@@Z
  00545	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2

; 1615 : 			if( g_LadderTeamMgr.IsHeroMatchMode() )

  0054c	e8 00 00 00 00	 call	 ?GetSingleton@ioLadderTeamMgr@@SAAAV1@XZ ; ioLadderTeamMgr::GetSingleton
  00551	8a 80 be 04 00
	00		 mov	 al, BYTE PTR [eax+1214]
  00557	3a c3		 cmp	 al, bl
  00559	0f 84 c0 01 00
	00		 je	 $LN28@OnRenderTe@2

; 1616 : 			{
; 1617 : 				if( LadderInfo.m_szOwnerName == g_MyInfo.GetPublicID() )

  0055f	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  00564	83 c0 1c	 add	 eax, 28			; 0000001cH
  00567	50		 push	 eax
  00568	8d 8d 50 fa ff
	ff		 lea	 ecx, DWORD PTR _LadderInfo$550160[ebp+44]
  0056e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??8ioHashString@@QBE_NABV0@@Z
  00574	84 c0		 test	 al, al
  00576	0f 84 aa 00 00
	00		 je	 $LN27@OnRenderTe@2

; 1618 : 				{
; 1619 : 					if( g_MyInfo.GetHeroTodayRank() == 0 )

  0057c	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  00581	39 98 d8 01 00
	00		 cmp	 DWORD PTR [eax+472], ebx

; 1620 : 						g_FontMgr.PrintText( iXPos + iScoreXGap + 4, iYPos + 16, FONT_SIZE_13, LadderInfo.m_szTeamName.c_str() );	
; 1621 : 					else

  00587	0f 84 92 01 00
	00		 je	 $LN28@OnRenderTe@2

; 1622 : 						g_FontMgr.PrintText( iXPos + iScoreXGap + 4, iYPos + 16, FONT_SIZE_13, STR(5), g_MyInfo.GetHeroTodayRank(), LadderInfo.m_szTeamName.c_str() );	

  0058d	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  00592	8b 80 d8 01 00
	00		 mov	 eax, DWORD PTR [eax+472]
  00598	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  0059b	89 85 94 fa ff
	ff		 mov	 DWORD PTR $T568922[ebp], eax
  005a1	8b 85 98 fa ff
	ff		 mov	 eax, DWORD PTR _iScoreXGap$[ebp]
  005a7	8d 44 08 04	 lea	 eax, DWORD PTR [eax+ecx+4]
  005ab	0f 57 c0	 xorps	 xmm0, xmm0
  005ae	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  005b2	8d 8d 30 fa ff
	ff		 lea	 ecx, DWORD PTR _LadderInfo$550160[ebp+12]
  005b8	f3 0f 11 85 98
	fa ff ff	 movss	 DWORD PTR tv1078[ebp], xmm0
  005c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  005c6	50		 push	 eax
  005c7	ff b5 94 fa ff
	ff		 push	 DWORD PTR $T568922[ebp]
  005cd	53		 push	 ebx
  005ce	6a 05		 push	 5
  005d0	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  005d5	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NPCLHDMP@RoundStateUserWnd?3?3OnRenderTeamT@
  005da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  005e0	8b c8		 mov	 ecx, eax
  005e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  005e8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f266666
  005f0	50		 push	 eax
  005f1	83 ec 0c	 sub	 esp, 12			; 0000000cH
  005f4	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  005fa	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  005fd	0f 57 c0	 xorps	 xmm0, xmm0
  00600	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00604	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0060a	f3 0f 10 85 98
	fa ff ff	 movss	 xmm0, DWORD PTR tv1078[ebp]
  00612	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00617	ff d7		 call	 edi
  00619	8b c8		 mov	 ecx, eax
  0061b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAEXMMMPBDH0@Z

; 1623 : 				}
; 1624 : 				else

  00621	e9 5c 01 00 00	 jmp	 $LN21@OnRenderTe@2
$LN27@OnRenderTe@2:

; 1625 : 				{
; 1626 : 					LadderHeroUserInfo kHeroInfo = g_LadderTeamMgr.GetHeroMatchOtherInfo();

  00626	e8 00 00 00 00	 call	 ?GetSingleton@ioLadderTeamMgr@@SAAAV1@XZ ; ioLadderTeamMgr::GetSingleton
  0062b	05 ec 00 00 00	 add	 eax, 236		; 000000ecH
  00630	50		 push	 eax
  00631	8d 8d 9c fa ff
	ff		 lea	 ecx, DWORD PTR _kHeroInfo$550166[ebp]
  00637	e8 00 00 00 00	 call	 ??0tagLadderHeroUserInfo@@QAE@ABU0@@Z

; 1627 : 					if( kHeroInfo.m_iHeroTodayRank == 0 )
; 1628 : 						g_FontMgr.PrintText( iXPos + iScoreXGap + 4, iYPos + 16, FONT_SIZE_13, LadderInfo.m_szTeamName.c_str() );	

  0063c	8b 85 98 fa ff
	ff		 mov	 eax, DWORD PTR _iScoreXGap$[ebp]
  00642	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  00645	8d 44 08 04	 lea	 eax, DWORD PTR [eax+ecx+4]
  00649	0f 57 c0	 xorps	 xmm0, xmm0
  0064c	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00650	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00654	8d 8d 30 fa ff
	ff		 lea	 ecx, DWORD PTR _LadderInfo$550160[ebp+12]
  0065a	f3 0f 11 85 98
	fa ff ff	 movss	 DWORD PTR tv1078[ebp], xmm0
  00662	39 9d b0 fa ff
	ff		 cmp	 DWORD PTR _kHeroInfo$550166[ebp+20], ebx
  00668	75 43		 jne	 SHORT $LN23@OnRenderTe@2
  0066a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00670	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f266666
  00678	50		 push	 eax
  00679	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0067c	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00682	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  00685	0f 57 c0	 xorps	 xmm0, xmm0
  00688	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0068c	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00692	f3 0f 10 85 98
	fa ff ff	 movss	 xmm0, DWORD PTR tv1078[ebp]
  0069a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0069f	ff d7		 call	 edi
  006a1	50		 push	 eax
  006a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAAXMMMPBDZZ
  006a8	83 c4 14	 add	 esp, 20			; 00000014H

; 1629 : 					else

  006ab	eb 61		 jmp	 SHORT $LN22@OnRenderTe@2
$LN23@OnRenderTe@2:

; 1630 : 						g_FontMgr.PrintText( iXPos + iScoreXGap + 4, iYPos + 16, FONT_SIZE_13, STR(6), kHeroInfo.m_iHeroTodayRank, LadderInfo.m_szTeamName.c_str() );	

  006ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  006b3	50		 push	 eax
  006b4	ff b5 b0 fa ff
	ff		 push	 DWORD PTR _kHeroInfo$550166[ebp+20]
  006ba	53		 push	 ebx
  006bb	6a 06		 push	 6
  006bd	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  006c2	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NPCLHDMP@RoundStateUserWnd?3?3OnRenderTeamT@
  006c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  006cd	8b c8		 mov	 ecx, eax
  006cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  006d5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f266666
  006dd	50		 push	 eax
  006de	83 ec 0c	 sub	 esp, 12			; 0000000cH
  006e1	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  006e7	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  006ea	0f 57 c0	 xorps	 xmm0, xmm0
  006ed	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  006f1	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  006f7	f3 0f 10 85 98
	fa ff ff	 movss	 xmm0, DWORD PTR tv1078[ebp]
  006ff	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00704	ff d7		 call	 edi
  00706	8b c8		 mov	 ecx, eax
  00708	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAEXMMMPBDH0@Z
$LN22@OnRenderTe@2:

; 1631 : 				}

  0070e	8d 8d 9c fa ff
	ff		 lea	 ecx, DWORD PTR _kHeroInfo$550166[ebp]
  00714	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00718	e8 00 00 00 00	 call	 ??1tagLadderHeroUserInfo@@QAE@XZ

; 1632 : 			}
; 1633 : 			else

  0071d	eb 63		 jmp	 SHORT $LN21@OnRenderTe@2
$LN28@OnRenderTe@2:

; 1634 : 			{
; 1635 : 				g_FontMgr.PrintText( iXPos + iScoreXGap + 4, iYPos + 16, FONT_SIZE_13, LadderInfo.m_szTeamName.c_str() );		

  0071f	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  00722	8b 85 98 fa ff
	ff		 mov	 eax, DWORD PTR _iScoreXGap$[ebp]
  00728	8d 44 08 04	 lea	 eax, DWORD PTR [eax+ecx+4]
  0072c	0f 57 c0	 xorps	 xmm0, xmm0
  0072f	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00733	8d 8d 30 fa ff
	ff		 lea	 ecx, DWORD PTR _LadderInfo$550160[ebp+12]
  00739	f3 0f 11 85 98
	fa ff ff	 movss	 DWORD PTR tv1078[ebp], xmm0
  00741	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00747	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f266666
  0074f	50		 push	 eax
  00750	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00753	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00759	0f 57 c0	 xorps	 xmm0, xmm0
  0075c	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  0075f	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00763	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00769	f3 0f 10 85 98
	fa ff ff	 movss	 xmm0, DWORD PTR tv1078[ebp]
  00771	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00776	ff d7		 call	 edi
  00778	50		 push	 eax
  00779	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAAXMMMPBDZZ
  0077f	83 c4 14	 add	 esp, 20			; 00000014H
$LN21@OnRenderTe@2:

; 1636 : 			}
; 1637 : 			if( LadderInfo.m_iVictoriesRecord > 1 )

  00782	83 bd 74 fa ff
	ff 01		 cmp	 DWORD PTR _LadderInfo$550160[ebp+80], 1
  00789	7e 68		 jle	 SHORT $LN20@OnRenderTe@2

; 1638 : 				g_FontMgr.PrintText( iXPos + iScoreXGap + 4, iYPos + 30, FONT_SIZE_13, STR(7), LadderInfo.m_iWinRecord, LadderInfo.m_iLoseRecord, LadderInfo.m_iVictoriesRecord );

  0078b	ff b5 74 fa ff
	ff		 push	 DWORD PTR _LadderInfo$550160[ebp+80]
  00791	ff b5 70 fa ff
	ff		 push	 DWORD PTR _LadderInfo$550160[ebp+76]
  00797	ff b5 6c fa ff
	ff		 push	 DWORD PTR _LadderInfo$550160[ebp+72]
  0079d	53		 push	 ebx
  0079e	6a 07		 push	 7
  007a0	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  007a5	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NPCLHDMP@RoundStateUserWnd?3?3OnRenderTeamT@
  007aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  007b0	8b c8		 mov	 ecx, eax
  007b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  007b8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f266666
  007c0	50		 push	 eax
  007c1	83 ec 0c	 sub	 esp, 12			; 0000000cH
  007c4	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  007ca	8d 46 1e	 lea	 eax, DWORD PTR [esi+30]
  007cd	0f 57 c0	 xorps	 xmm0, xmm0
  007d0	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  007d4	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  007da	f3 0f 10 85 98
	fa ff ff	 movss	 xmm0, DWORD PTR tv1078[ebp]
  007e2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007e7	ff d7		 call	 edi
  007e9	8b c8		 mov	 ecx, eax
  007eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAEXMMMPBDHHH@Z

; 1639 : 			else

  007f1	eb 60		 jmp	 SHORT $LN19@OnRenderTe@2
$LN20@OnRenderTe@2:

; 1640 : 				g_FontMgr.PrintText( iXPos + iScoreXGap + 4, iYPos + 30, FONT_SIZE_13, STR(8), LadderInfo.m_iWinRecord, LadderInfo.m_iLoseRecord );

  007f3	ff b5 70 fa ff
	ff		 push	 DWORD PTR _LadderInfo$550160[ebp+76]
  007f9	ff b5 6c fa ff
	ff		 push	 DWORD PTR _LadderInfo$550160[ebp+72]
  007ff	53		 push	 ebx
  00800	6a 08		 push	 8
  00802	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00807	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NPCLHDMP@RoundStateUserWnd?3?3OnRenderTeamT@
  0080c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00812	8b c8		 mov	 ecx, eax
  00814	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0081a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f266666
  00822	50		 push	 eax
  00823	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00826	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  0082c	8d 46 1e	 lea	 eax, DWORD PTR [esi+30]
  0082f	0f 57 c0	 xorps	 xmm0, xmm0
  00832	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00836	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0083c	f3 0f 10 85 98
	fa ff ff	 movss	 xmm0, DWORD PTR tv1078[ebp]
  00844	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00849	ff d7		 call	 edi
  0084b	8b c8		 mov	 ecx, eax
  0084d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAEXMMMPBDHH@Z
$LN19@OnRenderTe@2:

; 1641 : 
; 1642 : 			if( LadderInfo.m_dwGuildIndex != 0 )

  00853	39 9d 2c fa ff
	ff		 cmp	 DWORD PTR _LadderInfo$550160[ebp+8], ebx
  00859	0f 84 90 00 00
	00		 je	 $LN16@OnRenderTe@2

; 1643 : 			{
; 1644 : 				ioGuildData *pGuildData = g_GuildInfo.GetGuildData( LadderInfo.m_dwGuildIndex );

  0085f	53		 push	 ebx
  00860	ff b5 2c fa ff
	ff		 push	 DWORD PTR _LadderInfo$550160[ebp+8]
  00866	e8 00 00 00 00	 call	 ?GetSingleton@ioGuildInfo@@SAAAV1@XZ ; ioGuildInfo::GetSingleton
  0086b	8b c8		 mov	 ecx, eax
  0086d	e8 00 00 00 00	 call	 ?GetGuildData@ioGuildInfo@@QAEPAVioGuildData@@K_N@Z ; ioGuildInfo::GetGuildData

; 1645 : 				if( pGuildData )

  00872	3b c3		 cmp	 eax, ebx
  00874	74 79		 je	 SHORT $LN16@OnRenderTe@2

; 1646 : 				{
; 1647 : 					g_GuildMarkMgr.RenderMarkSize( 35, 35, pGuildData->GetGuildIndex(), pGuildData->GetGuildMark(), iXPos + 268, iYPos + 13 );

  00876	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00879	8b 7d 08	 mov	 edi, DWORD PTR _iXPos$[ebp]
  0087c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0087f	53		 push	 ebx
  00880	51		 push	 ecx
  00881	51		 push	 ecx
  00882	0f 57 c0	 xorps	 xmm0, xmm0
  00885	8d 56 0d	 lea	 edx, DWORD PTR [esi+13]
  00888	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  0088c	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00892	8d 97 0c 01 00
	00		 lea	 edx, DWORD PTR [edi+268]
  00898	0f 57 c0	 xorps	 xmm0, xmm0
  0089b	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  0089f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008a4	51		 push	 ecx
  008a5	50		 push	 eax
  008a6	6a 23		 push	 35			; 00000023H
  008a8	6a 23		 push	 35			; 00000023H
  008aa	e8 00 00 00 00	 call	 ?GetSingleton@ioGuildMarkMgr@@SAAAV1@XZ ; ioGuildMarkMgr::GetSingleton
  008af	8b c8		 mov	 ecx, eax
  008b1	e8 00 00 00 00	 call	 ?RenderMarkSize@ioGuildMarkMgr@@QAEXHHKKMMW4UIRenderType@@@Z ; ioGuildMarkMgr::RenderMarkSize

; 1648 : 					if( m_pGuildMarkFrm )

  008b6	8b 85 90 fa ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$[ebp]
  008bc	39 98 64 01 00
	00		 cmp	 DWORD PTR [eax+356], ebx
  008c2	74 2b		 je	 SHORT $LN16@OnRenderTe@2

; 1649 : 						m_pGuildMarkFrm->Render( iXPos, iYPos );

  008c4	8b 80 64 01 00
	00		 mov	 eax, DWORD PTR [eax+356]
  008ca	8b 10		 mov	 edx, DWORD PTR [eax]
  008cc	53		 push	 ebx
  008cd	53		 push	 ebx
  008ce	53		 push	 ebx
  008cf	53		 push	 ebx
  008d0	51		 push	 ecx
  008d1	0f 57 c0	 xorps	 xmm0, xmm0
  008d4	51		 push	 ecx
  008d5	f3 0f 2a c6	 cvtsi2ss xmm0, esi
  008d9	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  008df	0f 57 c0	 xorps	 xmm0, xmm0
  008e2	f3 0f 2a c7	 cvtsi2ss xmm0, edi
  008e6	8b c8		 mov	 ecx, eax
  008e8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008ed	ff 12		 call	 DWORD PTR [edx]
$LN16@OnRenderTe@2:

; 1650 : 				}
; 1651 : 			}
; 1652 : 		}

  008ef	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _LadderInfo$550160[ebp]
  008f5	e9 d1 03 00 00	 jmp	 $LN97@OnRenderTe@2
$LN29@OnRenderTe@2:

; 1653 : 		else if( m_eWindowTeam == TEAM_RED )

  008fa	83 f8 01	 cmp	 eax, 1
  008fd	0f 85 d1 03 00
	00		 jne	 $LN14@OnRenderTe@2

; 1654 : 		{
; 1655 : 			LadderTeamInfo LadderInfo = g_LadderTeamMgr.GetLadderRedTeamInfo();			

  00903	e8 00 00 00 00	 call	 ?GetSingleton@ioLadderTeamMgr@@SAAAV1@XZ ; ioLadderTeamMgr::GetSingleton
  00908	8b c8		 mov	 ecx, eax
  0090a	e8 00 00 00 00	 call	 ?GetLadderRedTeamInfo@ioLadderTeamMgr@@QAEABUtagLadderTeamInfo@@XZ ; ioLadderTeamMgr::GetLadderRedTeamInfo
  0090f	50		 push	 eax
  00910	8d 8d b8 f9 ff
	ff		 lea	 ecx, DWORD PTR _LadderInfo$550178[ebp]
  00916	e8 00 00 00 00	 call	 ??0tagLadderTeamInfo@@QAE@ABU0@@Z
  0091b	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4

; 1656 : 			if( g_LadderTeamMgr.IsHeroMatchMode() )

  00922	e8 00 00 00 00	 call	 ?GetSingleton@ioLadderTeamMgr@@SAAAV1@XZ ; ioLadderTeamMgr::GetSingleton
  00927	8a 80 be 04 00
	00		 mov	 al, BYTE PTR [eax+1214]
  0092d	3a c3		 cmp	 al, bl
  0092f	0f 84 c0 01 00
	00		 je	 $LN13@OnRenderTe@2

; 1657 : 			{
; 1658 : 				if( LadderInfo.m_szOwnerName == g_MyInfo.GetPublicID() )

  00935	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  0093a	83 c0 1c	 add	 eax, 28			; 0000001cH
  0093d	50		 push	 eax
  0093e	8d 8d e4 f9 ff
	ff		 lea	 ecx, DWORD PTR _LadderInfo$550178[ebp+44]
  00944	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??8ioHashString@@QBE_NABV0@@Z
  0094a	84 c0		 test	 al, al
  0094c	0f 84 aa 00 00
	00		 je	 $LN12@OnRenderTe@2

; 1659 : 				{
; 1660 : 					if( g_MyInfo.GetHeroTodayRank() == 0 )

  00952	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  00957	39 98 d8 01 00
	00		 cmp	 DWORD PTR [eax+472], ebx

; 1661 : 						g_FontMgr.PrintText( iXPos + iScoreXGap + 4, iYPos + 16, FONT_SIZE_13, LadderInfo.m_szTeamName.c_str() );
; 1662 : 					else

  0095d	0f 84 92 01 00
	00		 je	 $LN13@OnRenderTe@2

; 1663 : 						g_FontMgr.PrintText( iXPos + iScoreXGap + 4, iYPos + 16, FONT_SIZE_13, STR(9), g_MyInfo.GetHeroTodayRank(), LadderInfo.m_szTeamName.c_str() );	

  00963	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  00968	8b 80 d8 01 00
	00		 mov	 eax, DWORD PTR [eax+472]
  0096e	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  00971	89 85 94 fa ff
	ff		 mov	 DWORD PTR $T568953[ebp], eax
  00977	8b 85 98 fa ff
	ff		 mov	 eax, DWORD PTR _iScoreXGap$[ebp]
  0097d	8d 44 08 04	 lea	 eax, DWORD PTR [eax+ecx+4]
  00981	0f 57 c0	 xorps	 xmm0, xmm0
  00984	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00988	8d 8d c4 f9 ff
	ff		 lea	 ecx, DWORD PTR _LadderInfo$550178[ebp+12]
  0098e	f3 0f 11 85 98
	fa ff ff	 movss	 DWORD PTR tv1078[ebp], xmm0
  00996	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  0099c	50		 push	 eax
  0099d	ff b5 94 fa ff
	ff		 push	 DWORD PTR $T568953[ebp]
  009a3	53		 push	 ebx
  009a4	6a 09		 push	 9
  009a6	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  009ab	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NPCLHDMP@RoundStateUserWnd?3?3OnRenderTeamT@
  009b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  009b6	8b c8		 mov	 ecx, eax
  009b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  009be	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f266666
  009c6	50		 push	 eax
  009c7	83 ec 0c	 sub	 esp, 12			; 0000000cH
  009ca	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  009d0	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  009d3	0f 57 c0	 xorps	 xmm0, xmm0
  009d6	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  009da	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  009e0	f3 0f 10 85 98
	fa ff ff	 movss	 xmm0, DWORD PTR tv1078[ebp]
  009e8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009ed	ff d7		 call	 edi
  009ef	8b c8		 mov	 ecx, eax
  009f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAEXMMMPBDH0@Z

; 1664 : 				}
; 1665 : 				else

  009f7	e9 5c 01 00 00	 jmp	 $LN6@OnRenderTe@2
$LN12@OnRenderTe@2:

; 1666 : 				{
; 1667 : 					LadderHeroUserInfo kHeroInfo = g_LadderTeamMgr.GetHeroMatchOtherInfo();

  009fc	e8 00 00 00 00	 call	 ?GetSingleton@ioLadderTeamMgr@@SAAAV1@XZ ; ioLadderTeamMgr::GetSingleton
  00a01	05 ec 00 00 00	 add	 eax, 236		; 000000ecH
  00a06	50		 push	 eax
  00a07	8d 8d 9c fa ff
	ff		 lea	 ecx, DWORD PTR _kHeroInfo$550184[ebp]
  00a0d	e8 00 00 00 00	 call	 ??0tagLadderHeroUserInfo@@QAE@ABU0@@Z

; 1668 : 					if( kHeroInfo.m_iHeroTodayRank == 0 )
; 1669 : 						g_FontMgr.PrintText( iXPos + iScoreXGap + 4, iYPos + 16, FONT_SIZE_13, LadderInfo.m_szTeamName.c_str() );	

  00a12	8b 85 98 fa ff
	ff		 mov	 eax, DWORD PTR _iScoreXGap$[ebp]
  00a18	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  00a1b	8d 44 08 04	 lea	 eax, DWORD PTR [eax+ecx+4]
  00a1f	0f 57 c0	 xorps	 xmm0, xmm0
  00a22	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00a26	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00a2a	8d 8d c4 f9 ff
	ff		 lea	 ecx, DWORD PTR _LadderInfo$550178[ebp+12]
  00a30	f3 0f 11 85 98
	fa ff ff	 movss	 DWORD PTR tv1078[ebp], xmm0
  00a38	39 9d b0 fa ff
	ff		 cmp	 DWORD PTR _kHeroInfo$550184[ebp+20], ebx
  00a3e	75 43		 jne	 SHORT $LN8@OnRenderTe@2
  00a40	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00a46	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f266666
  00a4e	50		 push	 eax
  00a4f	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00a52	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00a58	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  00a5b	0f 57 c0	 xorps	 xmm0, xmm0
  00a5e	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00a62	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00a68	f3 0f 10 85 98
	fa ff ff	 movss	 xmm0, DWORD PTR tv1078[ebp]
  00a70	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a75	ff d7		 call	 edi
  00a77	50		 push	 eax
  00a78	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAAXMMMPBDZZ
  00a7e	83 c4 14	 add	 esp, 20			; 00000014H

; 1670 : 					else

  00a81	eb 61		 jmp	 SHORT $LN7@OnRenderTe@2
$LN8@OnRenderTe@2:

; 1671 : 						g_FontMgr.PrintText( iXPos + iScoreXGap + 4, iYPos + 16, FONT_SIZE_13, STR(10), kHeroInfo.m_iHeroTodayRank, LadderInfo.m_szTeamName.c_str() );	

  00a83	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00a89	50		 push	 eax
  00a8a	ff b5 b0 fa ff
	ff		 push	 DWORD PTR _kHeroInfo$550184[ebp+20]
  00a90	53		 push	 ebx
  00a91	6a 0a		 push	 10			; 0000000aH
  00a93	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00a98	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NPCLHDMP@RoundStateUserWnd?3?3OnRenderTeamT@
  00a9d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00aa3	8b c8		 mov	 ecx, eax
  00aa5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  00aab	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f266666
  00ab3	50		 push	 eax
  00ab4	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00ab7	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00abd	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  00ac0	0f 57 c0	 xorps	 xmm0, xmm0
  00ac3	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00ac7	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00acd	f3 0f 10 85 98
	fa ff ff	 movss	 xmm0, DWORD PTR tv1078[ebp]
  00ad5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ada	ff d7		 call	 edi
  00adc	8b c8		 mov	 ecx, eax
  00ade	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAEXMMMPBDH0@Z
$LN7@OnRenderTe@2:

; 1672 : 				}

  00ae4	8d 8d 9c fa ff
	ff		 lea	 ecx, DWORD PTR _kHeroInfo$550184[ebp]
  00aea	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00aee	e8 00 00 00 00	 call	 ??1tagLadderHeroUserInfo@@QAE@XZ

; 1673 : 			}
; 1674 : 			else

  00af3	eb 63		 jmp	 SHORT $LN6@OnRenderTe@2
$LN13@OnRenderTe@2:

; 1675 : 			{
; 1676 : 				g_FontMgr.PrintText( iXPos + iScoreXGap + 4, iYPos + 16, FONT_SIZE_13, LadderInfo.m_szTeamName.c_str() );

  00af5	8b 4d 08	 mov	 ecx, DWORD PTR _iXPos$[ebp]
  00af8	8b 85 98 fa ff
	ff		 mov	 eax, DWORD PTR _iScoreXGap$[ebp]
  00afe	8d 44 08 04	 lea	 eax, DWORD PTR [eax+ecx+4]
  00b02	0f 57 c0	 xorps	 xmm0, xmm0
  00b05	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00b09	8d 8d c4 f9 ff
	ff		 lea	 ecx, DWORD PTR _LadderInfo$550178[ebp+12]
  00b0f	f3 0f 11 85 98
	fa ff ff	 movss	 DWORD PTR tv1078[ebp], xmm0
  00b17	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00b1d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f266666
  00b25	50		 push	 eax
  00b26	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00b29	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00b2f	0f 57 c0	 xorps	 xmm0, xmm0
  00b32	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  00b35	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00b39	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00b3f	f3 0f 10 85 98
	fa ff ff	 movss	 xmm0, DWORD PTR tv1078[ebp]
  00b47	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b4c	ff d7		 call	 edi
  00b4e	50		 push	 eax
  00b4f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAAXMMMPBDZZ
  00b55	83 c4 14	 add	 esp, 20			; 00000014H
$LN6@OnRenderTe@2:

; 1677 : 			}
; 1678 : 			if( LadderInfo.m_iVictoriesRecord > 1 )

  00b58	83 bd 08 fa ff
	ff 01		 cmp	 DWORD PTR _LadderInfo$550178[ebp+80], 1
  00b5f	7e 68		 jle	 SHORT $LN5@OnRenderTe@2

; 1679 : 				g_FontMgr.PrintText( iXPos + iScoreXGap + 4, iYPos + 30, FONT_SIZE_13, STR(11), LadderInfo.m_iWinRecord, LadderInfo.m_iLoseRecord, LadderInfo.m_iVictoriesRecord );

  00b61	ff b5 08 fa ff
	ff		 push	 DWORD PTR _LadderInfo$550178[ebp+80]
  00b67	ff b5 04 fa ff
	ff		 push	 DWORD PTR _LadderInfo$550178[ebp+76]
  00b6d	ff b5 00 fa ff
	ff		 push	 DWORD PTR _LadderInfo$550178[ebp+72]
  00b73	53		 push	 ebx
  00b74	6a 0b		 push	 11			; 0000000bH
  00b76	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00b7b	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NPCLHDMP@RoundStateUserWnd?3?3OnRenderTeamT@
  00b80	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00b86	8b c8		 mov	 ecx, eax
  00b88	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  00b8e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f266666
  00b96	50		 push	 eax
  00b97	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00b9a	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00ba0	8d 46 1e	 lea	 eax, DWORD PTR [esi+30]
  00ba3	0f 57 c0	 xorps	 xmm0, xmm0
  00ba6	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00baa	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00bb0	f3 0f 10 85 98
	fa ff ff	 movss	 xmm0, DWORD PTR tv1078[ebp]
  00bb8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bbd	ff d7		 call	 edi
  00bbf	8b c8		 mov	 ecx, eax
  00bc1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAEXMMMPBDHHH@Z

; 1680 : 			else

  00bc7	eb 60		 jmp	 SHORT $LN4@OnRenderTe@2
$LN5@OnRenderTe@2:

; 1681 : 				g_FontMgr.PrintText( iXPos + iScoreXGap + 4, iYPos + 30, FONT_SIZE_13, STR(12), LadderInfo.m_iWinRecord, LadderInfo.m_iLoseRecord );

  00bc9	ff b5 04 fa ff
	ff		 push	 DWORD PTR _LadderInfo$550178[ebp+76]
  00bcf	ff b5 00 fa ff
	ff		 push	 DWORD PTR _LadderInfo$550178[ebp+72]
  00bd5	53		 push	 ebx
  00bd6	6a 0c		 push	 12			; 0000000cH
  00bd8	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00bdd	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NPCLHDMP@RoundStateUserWnd?3?3OnRenderTeamT@
  00be2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00be8	8b c8		 mov	 ecx, eax
  00bea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  00bf0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f266666
  00bf8	50		 push	 eax
  00bf9	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00bfc	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00c02	8d 46 1e	 lea	 eax, DWORD PTR [esi+30]
  00c05	0f 57 c0	 xorps	 xmm0, xmm0
  00c08	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00c0c	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00c12	f3 0f 10 85 98
	fa ff ff	 movss	 xmm0, DWORD PTR tv1078[ebp]
  00c1a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c1f	ff d7		 call	 edi
  00c21	8b c8		 mov	 ecx, eax
  00c23	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintText@ioFontManager@@QAEXMMMPBDHH@Z
$LN4@OnRenderTe@2:

; 1682 : 
; 1683 : 			if( LadderInfo.m_dwGuildIndex != 0 )

  00c29	39 9d c0 f9 ff
	ff		 cmp	 DWORD PTR _LadderInfo$550178[ebp+8], ebx
  00c2f	0f 84 90 00 00
	00		 je	 $LN1@OnRenderTe@2

; 1684 : 			{
; 1685 : 				ioGuildData *pGuildData = g_GuildInfo.GetGuildData( LadderInfo.m_dwGuildIndex );

  00c35	53		 push	 ebx
  00c36	ff b5 c0 f9 ff
	ff		 push	 DWORD PTR _LadderInfo$550178[ebp+8]
  00c3c	e8 00 00 00 00	 call	 ?GetSingleton@ioGuildInfo@@SAAAV1@XZ ; ioGuildInfo::GetSingleton
  00c41	8b c8		 mov	 ecx, eax
  00c43	e8 00 00 00 00	 call	 ?GetGuildData@ioGuildInfo@@QAEPAVioGuildData@@K_N@Z ; ioGuildInfo::GetGuildData

; 1686 : 				if( pGuildData )

  00c48	3b c3		 cmp	 eax, ebx
  00c4a	74 79		 je	 SHORT $LN1@OnRenderTe@2

; 1687 : 				{
; 1688 : 					g_GuildMarkMgr.RenderMarkSize( 35, 35, pGuildData->GetGuildIndex(), pGuildData->GetGuildMark(), iXPos + 268, iYPos + 13 );

  00c4c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00c4f	8b 7d 08	 mov	 edi, DWORD PTR _iXPos$[ebp]
  00c52	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00c55	53		 push	 ebx
  00c56	51		 push	 ecx
  00c57	51		 push	 ecx
  00c58	0f 57 c0	 xorps	 xmm0, xmm0
  00c5b	8d 56 0d	 lea	 edx, DWORD PTR [esi+13]
  00c5e	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  00c62	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00c68	8d 97 0c 01 00
	00		 lea	 edx, DWORD PTR [edi+268]
  00c6e	0f 57 c0	 xorps	 xmm0, xmm0
  00c71	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  00c75	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c7a	51		 push	 ecx
  00c7b	50		 push	 eax
  00c7c	6a 23		 push	 35			; 00000023H
  00c7e	6a 23		 push	 35			; 00000023H
  00c80	e8 00 00 00 00	 call	 ?GetSingleton@ioGuildMarkMgr@@SAAAV1@XZ ; ioGuildMarkMgr::GetSingleton
  00c85	8b c8		 mov	 ecx, eax
  00c87	e8 00 00 00 00	 call	 ?RenderMarkSize@ioGuildMarkMgr@@QAEXHHKKMMW4UIRenderType@@@Z ; ioGuildMarkMgr::RenderMarkSize

; 1689 : 					if( m_pGuildMarkFrm )

  00c8c	8b 85 90 fa ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$[ebp]
  00c92	39 98 64 01 00
	00		 cmp	 DWORD PTR [eax+356], ebx
  00c98	74 2b		 je	 SHORT $LN1@OnRenderTe@2

; 1690 : 						m_pGuildMarkFrm->Render( iXPos, iYPos );

  00c9a	8b 80 64 01 00
	00		 mov	 eax, DWORD PTR [eax+356]
  00ca0	8b 10		 mov	 edx, DWORD PTR [eax]
  00ca2	53		 push	 ebx
  00ca3	53		 push	 ebx
  00ca4	53		 push	 ebx
  00ca5	53		 push	 ebx
  00ca6	51		 push	 ecx
  00ca7	0f 57 c0	 xorps	 xmm0, xmm0
  00caa	51		 push	 ecx
  00cab	f3 0f 2a c6	 cvtsi2ss xmm0, esi
  00caf	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00cb5	0f 57 c0	 xorps	 xmm0, xmm0
  00cb8	f3 0f 2a c7	 cvtsi2ss xmm0, edi
  00cbc	8b c8		 mov	 ecx, eax
  00cbe	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00cc3	ff 12		 call	 DWORD PTR [edx]
$LN1@OnRenderTe@2:

; 1691 : 				}
; 1692 : 			}
; 1693 : 		}

  00cc5	8d 8d b8 f9 ff
	ff		 lea	 ecx, DWORD PTR _LadderInfo$550178[ebp]
$LN97@OnRenderTe@2:
  00ccb	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00ccf	e8 00 00 00 00	 call	 ??1tagLadderTeamInfo@@QAE@XZ
$LN14@OnRenderTe@2:

; 1694 : 	}
; 1695 : }

  00cd4	e8 00 00 00 00	 call	 __EH_epilog3_GS
  00cd9	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnRenderTeamTitle@RoundStateUserWnd@@IAEXHH_N0@Z$0:
  00000	8d 8d 38 fe ff
	ff		 lea	 ecx, DWORD PTR _BattleInfo$550138[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1tagBattleRoomInfo@@QAE@XZ
__unwindfunclet$?OnRenderTeamTitle@RoundStateUserWnd@@IAEXHH_N0@Z$1:
  0000b	8d 8d 38 fe ff
	ff		 lea	 ecx, DWORD PTR _BattleInfo$550142[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1tagBattleRoomInfo@@QAE@XZ
__unwindfunclet$?OnRenderTeamTitle@RoundStateUserWnd@@IAEXHH_N0@Z$2:
  00016	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _LadderInfo$550160[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1tagLadderTeamInfo@@QAE@XZ
__unwindfunclet$?OnRenderTeamTitle@RoundStateUserWnd@@IAEXHH_N0@Z$3:
  00021	8d 8d 9c fa ff
	ff		 lea	 ecx, DWORD PTR _kHeroInfo$550166[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1tagLadderHeroUserInfo@@QAE@XZ
__unwindfunclet$?OnRenderTeamTitle@RoundStateUserWnd@@IAEXHH_N0@Z$4:
  0002c	8d 8d b8 f9 ff
	ff		 lea	 ecx, DWORD PTR _LadderInfo$550178[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1tagLadderTeamInfo@@QAE@XZ
__unwindfunclet$?OnRenderTeamTitle@RoundStateUserWnd@@IAEXHH_N0@Z$5:
  00037	8d 8d 9c fa ff
	ff		 lea	 ecx, DWORD PTR _kHeroInfo$550184[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??1tagLadderHeroUserInfo@@QAE@XZ
__ehhandler$?OnRenderTeamTitle@RoundStateUserWnd@@IAEXHH_N0@Z:
  00042	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00046	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00049	8b 8a b4 f9 ff
	ff		 mov	 ecx, DWORD PTR [edx-1612]
  0004f	33 c8		 xor	 ecx, eax
  00051	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00056	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00059	33 c8		 xor	 ecx, eax
  0005b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00060	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnRenderTeamTitle@RoundStateUserWnd@@IAEXHH_N0@Z
  00065	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnRenderTeamTitle@RoundStateUserWnd@@IAEXHH_N0@Z ENDP	; RoundStateUserWnd::OnRenderTeamTitle
PUBLIC	??$_Destroy_range@V?$allocator@URoundInfo@@@std@@@std@@YAXPAURoundInfo@@0AAV?$allocator@URoundInfo@@@0@@Z ; std::_Destroy_range<std::allocator<RoundInfo> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@URoundInfo@@@std@@@std@@YAXPAURoundInfo@@0AAV?$allocator@URoundInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@URoundInfo@@@std@@@std@@YAXPAURoundInfo@@0AAV?$allocator@URoundInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<RoundInfo> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	eb 0a		 jmp	 SHORT $LN21@Destroy_ra@2
$LL7@Destroy_ra@2:
  00009	8b ce		 mov	 ecx, esi
  0000b	e8 00 00 00 00	 call	 ??1RoundInfo@@QAE@XZ
  00010	83 ee 80	 sub	 esi, -128		; ffffff80H
$LN21@Destroy_ra@2:
  00013	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00016	75 f1		 jne	 SHORT $LL7@Destroy_ra@2
  00018	5e		 pop	 esi

; 89   : 	}

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$_Destroy_range@V?$allocator@URoundInfo@@@std@@@std@@YAXPAURoundInfo@@0AAV?$allocator@URoundInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<RoundInfo> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAURoundInfo@@PAU1@V?$allocator@URoundInfo@@@std@@@std@@YAPAURoundInfo@@PAU1@00AAV?$allocator@URoundInfo@@@0@@Z ; std::_Uninitialized_move<RoundInfo *,RoundInfo *,std::allocator<RoundInfo> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAURoundInfo@@PAU1@V?$allocator@URoundInfo@@@std@@@std@@YAPAURoundInfo@@PAU1@00AAV?$allocator@URoundInfo@@@0@@Z
_TEXT	SEGMENT
__Cat$569039 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAURoundInfo@@PAU1@V?$allocator@URoundInfo@@@std@@@std@@YAPAURoundInfo@@PAU1@00AAV?$allocator@URoundInfo@@@0@@Z PROC ; std::_Uninitialized_move<RoundInfo *,RoundInfo *,std::allocator<RoundInfo> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$569039[ebp]
  00007	6a 00		 push	 0
  00009	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000c	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000f	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00012	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00015	e8 00 00 00 00	 call	 ??$_Uninit_move@PAURoundInfo@@PAU1@V?$allocator@URoundInfo@@@std@@U1@@std@@YAPAURoundInfo@@PAU1@00AAV?$allocator@URoundInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<RoundInfo *,RoundInfo *,std::allocator<RoundInfo>,RoundInfo>
  0001a	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  0001d	c9		 leave
  0001e	c3		 ret	 0
??$_Uninitialized_move@PAURoundInfo@@PAU1@V?$allocator@URoundInfo@@@std@@@std@@YAPAURoundInfo@@PAU1@00AAV?$allocator@URoundInfo@@@0@@Z ENDP ; std::_Uninitialized_move<RoundInfo *,RoundInfo *,std::allocator<RoundInfo> >
_TEXT	ENDS
PUBLIC	??$_Sort_heap@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@@Z ; std::_Sort_heap<RoundInfo *,RoundInfoKoSort>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\algorithm
;	COMDAT ??$_Sort_heap@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Sort_heap@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@@Z PROC ; std::_Sort_heap<RoundInfo *,RoundInfoKoSort>, COMDAT

; 2700 : 	{	// order heap by repeatedly popping, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2701 : 	for (; 1 < _Last - _First; --_Last)

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00009	56		 push	 esi
  0000a	8b c8		 mov	 ecx, eax
  0000c	83 e1 80	 and	 ecx, -128		; ffffff80H
  0000f	be 80 00 00 00	 mov	 esi, 128		; 00000080H
  00014	3b ce		 cmp	 ecx, esi
  00016	7e 25		 jle	 SHORT $LN1@Sort_heap
  00018	57		 push	 edi
  00019	8b f8		 mov	 edi, eax
$LL3@Sort_heap:

; 2702 : 		_Pop_heap(_First, _Last, _Pred);

  0001b	6a 00		 push	 0
  0001d	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00020	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00023	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00026	e8 00 00 00 00	 call	 ??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@0@Z ; std::_Pop_heap_0<RoundInfo *,RoundInfo,RoundInfoKoSort>
  0002b	29 75 0c	 sub	 DWORD PTR __Last$[ebp], esi
  0002e	2b fe		 sub	 edi, esi
  00030	8b c7		 mov	 eax, edi
  00032	83 e0 80	 and	 eax, -128		; ffffff80H
  00035	83 c4 10	 add	 esp, 16			; 00000010H
  00038	3b c6		 cmp	 eax, esi
  0003a	7f df		 jg	 SHORT $LL3@Sort_heap
  0003c	5f		 pop	 edi
$LN1@Sort_heap:
  0003d	5e		 pop	 esi

; 2703 : 	}

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??$_Sort_heap@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@@Z ENDP ; std::_Sort_heap<RoundInfo *,RoundInfoKoSort>
_TEXT	ENDS
PUBLIC	??$_Sort_heap@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@@Z ; std::_Sort_heap<RoundInfo *,RoundInfoSort>
; Function compile flags: /Ogsp
;	COMDAT ??$_Sort_heap@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Sort_heap@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@@Z PROC ; std::_Sort_heap<RoundInfo *,RoundInfoSort>, COMDAT

; 2700 : 	{	// order heap by repeatedly popping, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2701 : 	for (; 1 < _Last - _First; --_Last)

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00009	56		 push	 esi
  0000a	8b c8		 mov	 ecx, eax
  0000c	83 e1 80	 and	 ecx, -128		; ffffff80H
  0000f	be 80 00 00 00	 mov	 esi, 128		; 00000080H
  00014	3b ce		 cmp	 ecx, esi
  00016	7e 25		 jle	 SHORT $LN1@Sort_heap@2
  00018	57		 push	 edi
  00019	8b f8		 mov	 edi, eax
$LL3@Sort_heap@2:

; 2702 : 		_Pop_heap(_First, _Last, _Pred);

  0001b	6a 00		 push	 0
  0001d	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00020	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00023	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00026	e8 00 00 00 00	 call	 ??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@0@Z ; std::_Pop_heap_0<RoundInfo *,RoundInfo,RoundInfoSort>
  0002b	29 75 0c	 sub	 DWORD PTR __Last$[ebp], esi
  0002e	2b fe		 sub	 edi, esi
  00030	8b c7		 mov	 eax, edi
  00032	83 e0 80	 and	 eax, -128		; ffffff80H
  00035	83 c4 10	 add	 esp, 16			; 00000010H
  00038	3b c6		 cmp	 eax, esi
  0003a	7f df		 jg	 SHORT $LL3@Sort_heap@2
  0003c	5f		 pop	 edi
$LN1@Sort_heap@2:
  0003d	5e		 pop	 esi

; 2703 : 	}

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??$_Sort_heap@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@@Z ENDP ; std::_Sort_heap<RoundInfo *,RoundInfoSort>
_TEXT	ENDS
PUBLIC	??$_Sort_heap@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@@Z ; std::_Sort_heap<RoundInfo *,RoundInfoStarSort>
; Function compile flags: /Ogsp
;	COMDAT ??$_Sort_heap@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Sort_heap@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@@Z PROC ; std::_Sort_heap<RoundInfo *,RoundInfoStarSort>, COMDAT

; 2700 : 	{	// order heap by repeatedly popping, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2701 : 	for (; 1 < _Last - _First; --_Last)

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00009	56		 push	 esi
  0000a	8b c8		 mov	 ecx, eax
  0000c	83 e1 80	 and	 ecx, -128		; ffffff80H
  0000f	be 80 00 00 00	 mov	 esi, 128		; 00000080H
  00014	3b ce		 cmp	 ecx, esi
  00016	7e 25		 jle	 SHORT $LN1@Sort_heap@3
  00018	57		 push	 edi
  00019	8b f8		 mov	 edi, eax
$LL3@Sort_heap@3:

; 2702 : 		_Pop_heap(_First, _Last, _Pred);

  0001b	6a 00		 push	 0
  0001d	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00020	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00023	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00026	e8 00 00 00 00	 call	 ??$_Pop_heap_0@PAURoundInfo@@U1@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@0@Z ; std::_Pop_heap_0<RoundInfo *,RoundInfo,RoundInfoStarSort>
  0002b	29 75 0c	 sub	 DWORD PTR __Last$[ebp], esi
  0002e	2b fe		 sub	 edi, esi
  00030	8b c7		 mov	 eax, edi
  00032	83 e0 80	 and	 eax, -128		; ffffff80H
  00035	83 c4 10	 add	 esp, 16			; 00000010H
  00038	3b c6		 cmp	 eax, esi
  0003a	7f df		 jg	 SHORT $LL3@Sort_heap@3
  0003c	5f		 pop	 edi
$LN1@Sort_heap@3:
  0003d	5e		 pop	 esi

; 2703 : 	}

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??$_Sort_heap@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@@Z ENDP ; std::_Sort_heap<RoundInfo *,RoundInfoStarSort>
_TEXT	ENDS
PUBLIC	?OnRender@RoundStateUserWnd@@MAEXXZ		; RoundStateUserWnd::OnRender
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
;	COMDAT ?OnRender@RoundStateUserWnd@@MAEXXZ
_TEXT	SEGMENT
?OnRender@RoundStateUserWnd@@MAEXXZ PROC		; RoundStateUserWnd::OnRender, COMDAT
; _this$ = ecx

; 705  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f1		 mov	 esi, ecx

; 706  : 	ioWnd::OnRender();

  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?OnRender@ioWnd@@MAEXXZ

; 707  : 
; 708  : 	int iXPos = GetDerivedPosX();

  0000b	8b ce		 mov	 ecx, esi
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetDerivedPosX@ioWnd@@QBEHXZ

; 709  : 	int iYPos = GetDerivedPosY();

  00013	8b ce		 mov	 ecx, esi
  00015	8b f8		 mov	 edi, eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetDerivedPosY@ioWnd@@QBEHXZ
  0001d	8b d8		 mov	 ebx, eax

; 710  : 
; 711  : 	// 바닥 라인
; 712  : 	switch( ioPlayMode::GetModeType() )

  0001f	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  00024	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00027	0f 84 db 00 00
	00		 je	 $LN23@OnRender
  0002d	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00030	7e 7c		 jle	 SHORT $LN19@OnRender
  00032	83 f8 12	 cmp	 eax, 18			; 00000012H
  00035	7e 05		 jle	 SHORT $LN21@OnRender
  00037	83 f8 15	 cmp	 eax, 21			; 00000015H
  0003a	75 72		 jne	 SHORT $LN19@OnRender
$LN21@OnRender:

; 718  : 		break;
; 719  : 	case MT_TOWER_DEFENSE:
; 720  : 	case MT_DARK_XMAS:
; 721  : 	case MT_FIRE_TEMPLE:
; 722  : 	case MT_FACTORY:
; 723  : 		if( m_pMyTeamFrm && IsMyTeam() )

  0003c	83 be 60 01 00
	00 00		 cmp	 DWORD PTR [esi+352], 0
  00043	74 4b		 je	 SHORT $LN20@OnRender
  00045	8b ce		 mov	 ecx, esi
  00047	e8 00 00 00 00	 call	 ?IsMyTeam@RoundStateUserWnd@@IAE_NXZ ; RoundStateUserWnd::IsMyTeam
  0004c	84 c0		 test	 al, al
  0004e	74 40		 je	 SHORT $LN20@OnRender

; 724  : 		{
; 725  : 			m_pMyTeamFrm->SetSize(528, 255);

  00050	8b 8e 60 01 00
	00		 mov	 ecx, DWORD PTR [esi+352]
  00056	8b 01		 mov	 eax, DWORD PTR [ecx]
  00058	68 ff 00 00 00	 push	 255			; 000000ffH
  0005d	68 10 02 00 00	 push	 528			; 00000210H
  00062	ff 50 10	 call	 DWORD PTR [eax+16]

; 726  : 			m_pMyTeamFrm->Render( iXPos, iYPos );

  00065	8b 8e 60 01 00
	00		 mov	 ecx, DWORD PTR [esi+352]
  0006b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006d	33 c0		 xor	 eax, eax
  0006f	50		 push	 eax
  00070	50		 push	 eax
  00071	50		 push	 eax
  00072	50		 push	 eax
  00073	0f 57 c0	 xorps	 xmm0, xmm0
  00076	51		 push	 ecx
  00077	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  0007b	51		 push	 ecx
  0007c	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00082	0f 57 c0	 xorps	 xmm0, xmm0
  00085	f3 0f 2a c7	 cvtsi2ss xmm0, edi
  00089	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0008e	ff 12		 call	 DWORD PTR [edx]
$LN20@OnRender:

; 727  : 		}
; 728  : 
; 729  : 		OnRenderTowerDefLine(iXPos + m_iLineStartX, iYPos + m_iLineStartY );

  00090	8b 86 84 02 00
	00		 mov	 eax, DWORD PTR [esi+644]
  00096	03 c3		 add	 eax, ebx
  00098	50		 push	 eax
  00099	8b 86 80 02 00
	00		 mov	 eax, DWORD PTR [esi+640]
  0009f	03 c7		 add	 eax, edi
  000a1	50		 push	 eax
  000a2	8b ce		 mov	 ecx, esi
  000a4	e8 00 00 00 00	 call	 ?OnRenderTowerDefLine@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderTowerDefLine

; 730  : 		break;

  000a9	e9 b2 00 00 00	 jmp	 $LN24@OnRender
$LN19@OnRender:

; 731  : 	default:
; 732  : 		if( m_pMyTeamFrm && IsMyTeam() )

  000ae	83 be 60 01 00
	00 00		 cmp	 DWORD PTR [esi+352], 0
  000b5	74 36		 je	 SHORT $LN18@OnRender
  000b7	8b ce		 mov	 ecx, esi
  000b9	e8 00 00 00 00	 call	 ?IsMyTeam@RoundStateUserWnd@@IAE_NXZ ; RoundStateUserWnd::IsMyTeam
  000be	84 c0		 test	 al, al
  000c0	74 2b		 je	 SHORT $LN18@OnRender

; 733  : 			m_pMyTeamFrm->Render( iXPos, iYPos );

  000c2	8b 8e 60 01 00
	00		 mov	 ecx, DWORD PTR [esi+352]
  000c8	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ca	33 c0		 xor	 eax, eax
  000cc	50		 push	 eax
  000cd	50		 push	 eax
  000ce	50		 push	 eax
  000cf	50		 push	 eax
  000d0	0f 57 c0	 xorps	 xmm0, xmm0
  000d3	51		 push	 ecx
  000d4	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  000d8	51		 push	 ecx
  000d9	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000df	0f 57 c0	 xorps	 xmm0, xmm0
  000e2	f3 0f 2a c7	 cvtsi2ss xmm0, edi
  000e6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000eb	ff 12		 call	 DWORD PTR [edx]
$LN18@OnRender:

; 734  : 		OnRenderBack( iXPos + m_iLineStartX, iYPos + m_iLineStartY );

  000ed	8b 86 84 02 00
	00		 mov	 eax, DWORD PTR [esi+644]
  000f3	03 c3		 add	 eax, ebx
  000f5	50		 push	 eax
  000f6	8b 86 80 02 00
	00		 mov	 eax, DWORD PTR [esi+640]
  000fc	03 c7		 add	 eax, edi
  000fe	50		 push	 eax
  000ff	8b ce		 mov	 ecx, esi
  00101	e8 00 00 00 00	 call	 ?OnRenderBack@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderBack

; 735  : 		break;

  00106	eb 58		 jmp	 SHORT $LN24@OnRender
$LN23@OnRender:

; 713  : 	{
; 714  : 	case MT_GANGSI:
; 715  : 		if( m_pMyTeamFrm && IsMyTeam() )

  00108	83 be 60 01 00
	00 00		 cmp	 DWORD PTR [esi+352], 0
  0010f	74 36		 je	 SHORT $LN22@OnRender
  00111	8b ce		 mov	 ecx, esi
  00113	e8 00 00 00 00	 call	 ?IsMyTeam@RoundStateUserWnd@@IAE_NXZ ; RoundStateUserWnd::IsMyTeam
  00118	84 c0		 test	 al, al
  0011a	74 2b		 je	 SHORT $LN22@OnRender

; 716  : 			m_pMyTeamFrm->Render( iXPos, iYPos );

  0011c	8b 8e 60 01 00
	00		 mov	 ecx, DWORD PTR [esi+352]
  00122	8b 11		 mov	 edx, DWORD PTR [ecx]
  00124	33 c0		 xor	 eax, eax
  00126	50		 push	 eax
  00127	50		 push	 eax
  00128	50		 push	 eax
  00129	50		 push	 eax
  0012a	0f 57 c0	 xorps	 xmm0, xmm0
  0012d	51		 push	 ecx
  0012e	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  00132	51		 push	 ecx
  00133	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00139	0f 57 c0	 xorps	 xmm0, xmm0
  0013c	f3 0f 2a c7	 cvtsi2ss xmm0, edi
  00140	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00145	ff 12		 call	 DWORD PTR [edx]
$LN22@OnRender:

; 717  : 		OnRenderGangsiBack( iXPos + m_iLineStartX, iYPos + m_iLineStartY );

  00147	8b 86 84 02 00
	00		 mov	 eax, DWORD PTR [esi+644]
  0014d	03 c3		 add	 eax, ebx
  0014f	50		 push	 eax
  00150	8b 86 80 02 00
	00		 mov	 eax, DWORD PTR [esi+640]
  00156	03 c7		 add	 eax, edi
  00158	50		 push	 eax
  00159	8b ce		 mov	 ecx, esi
  0015b	e8 00 00 00 00	 call	 ?OnRenderGangsiBack@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderGangsiBack
$LN24@OnRender:

; 736  : 	}
; 737  : 
; 738  : 	// 타이틀 & 유저 정보
; 739  : 	switch( ioPlayMode::GetModeType() )

  00160	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  00165	48		 dec	 eax
  00166	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  00169	0f 87 0e 01 00
	00		 ja	 $LN16@OnRender
  0016f	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN28@OnRender[eax]
  00176	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN32@OnRender[eax*4]
$LN15@OnRender:

; 740  : 	{
; 741  : 	case MT_TRAINING:
; 742  : 	case MT_HEADQUARTERS:
; 743  : 	case MT_HOUSE:
; 744  : 		OnRenderPlazaUser( iXPos, iYPos );

  0017d	53		 push	 ebx
  0017e	57		 push	 edi
  0017f	8b ce		 mov	 ecx, esi
  00181	e8 00 00 00 00	 call	 ?OnRenderPlazaUser@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderPlazaUser

; 745  : 		break;

  00186	e9 f2 00 00 00	 jmp	 $LN16@OnRender
$LN14@OnRender:

; 746  : 	case MT_MONSTER_SURVIVAL:
; 747  : 	case MT_DUNGEON_A:
; 748  : 		OnRenderMonsterTitle( iXPos, iYPos );

  0018b	53		 push	 ebx
  0018c	57		 push	 edi
  0018d	8b ce		 mov	 ecx, esi
  0018f	e8 00 00 00 00	 call	 ?OnRenderMonsterTitle@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderMonsterTitle

; 749  : 		OnRenderMonsterUser( iXPos, iYPos );				

  00194	53		 push	 ebx
  00195	57		 push	 edi
  00196	8b ce		 mov	 ecx, esi
  00198	e8 00 00 00 00	 call	 ?OnRenderMonsterUser@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderMonsterUser

; 750  : 		break;

  0019d	e9 db 00 00 00	 jmp	 $LN16@OnRender
$LN13@OnRender:

; 751  : 	case MT_SURVIVAL:
; 752  : 		OnRenderSurvivalTitle( iXPos, iYPos );

  001a2	53		 push	 ebx
  001a3	57		 push	 edi
  001a4	8b ce		 mov	 ecx, esi
  001a6	e8 00 00 00 00	 call	 ?OnRenderSurvivalTitle@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderSurvivalTitle
$LN29@OnRender:

; 753  : 		OnRenderSingleUser( iXPos, iYPos );

  001ab	53		 push	 ebx
  001ac	57		 push	 edi
  001ad	8b ce		 mov	 ecx, esi
  001af	e8 00 00 00 00	 call	 ?OnRenderSingleUser@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderSingleUser

; 754  : 		break;

  001b4	e9 c4 00 00 00	 jmp	 $LN16@OnRender
$LN12@OnRender:

; 755  : 	case MT_SHUFFLE_BONUS:
; 756  : 		OnRenderShuffleBonusTitle( iXPos, iYPos );

  001b9	53		 push	 ebx
  001ba	57		 push	 edi
  001bb	8b ce		 mov	 ecx, esi
  001bd	e8 00 00 00 00	 call	 ?OnRenderShuffleBonusTitle@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderShuffleBonusTitle

; 757  : 		OnRenderShuffleBonusUser( iXPos, iYPos );

  001c2	53		 push	 ebx
  001c3	57		 push	 edi
  001c4	8b ce		 mov	 ecx, esi
  001c6	e8 00 00 00 00	 call	 ?OnRenderShuffleBonusUser@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderShuffleBonusUser

; 758  : 		break;

  001cb	e9 ad 00 00 00	 jmp	 $LN16@OnRender
$LN11@OnRender:

; 759  : 	case MT_FIGHT_CLUB:
; 760  : 		OnRenderFightClubTitle( iXPos, iYPos );

  001d0	53		 push	 ebx
  001d1	57		 push	 edi
  001d2	8b ce		 mov	 ecx, esi
  001d4	e8 00 00 00 00	 call	 ?OnRenderFightClubTitle@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderFightClubTitle

; 761  : 		OnRenderFightClubUser( iXPos, iYPos );

  001d9	53		 push	 ebx
  001da	57		 push	 edi
  001db	8b ce		 mov	 ecx, esi
  001dd	e8 00 00 00 00	 call	 ?OnRenderFightClubUser@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderFightClubUser

; 762  : 		break;

  001e2	e9 96 00 00 00	 jmp	 $LN16@OnRender
$LN10@OnRender:

; 763  : 	case MT_BOSS:
; 764  : 		OnRenderBossTitle( iXPos, iYPos );

  001e7	53		 push	 ebx
  001e8	57		 push	 edi
  001e9	8b ce		 mov	 ecx, esi
  001eb	e8 00 00 00 00	 call	 ?OnRenderBossTitle@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderBossTitle

; 765  : 		OnRenderSingleUser( iXPos, iYPos );
; 766  : 		break;

  001f0	eb b9		 jmp	 SHORT $LN29@OnRender
$LN9@OnRender:

; 767  : 	case MT_TOWER_DEFENSE:  //TODO tf TAB GUI IN PLAYSTAGE
; 768  : 		OnRenderTowerDefTitle(iXPos, iYPos);

  001f2	53		 push	 ebx
  001f3	57		 push	 edi
  001f4	8b ce		 mov	 ecx, esi
  001f6	e8 00 00 00 00	 call	 ?OnRenderTowerDefTitle@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderTowerDefTitle
$LN30@OnRender:

; 769  : 		OnRenderTowerDefUser(iXPos, iYPos);

  001fb	53		 push	 ebx
  001fc	57		 push	 edi
  001fd	8b ce		 mov	 ecx, esi
  001ff	e8 00 00 00 00	 call	 ?OnRenderTowerDefUser@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderTowerDefUser

; 770  : 		break;

  00204	eb 77		 jmp	 SHORT $LN16@OnRender
$LN8@OnRender:

; 771  : 	case MT_FIRE_TEMPLE:
; 772  : 		OnRenderFireTempleTitle(iXPos, iYPos);

  00206	53		 push	 ebx
  00207	57		 push	 edi
  00208	8b ce		 mov	 ecx, esi
  0020a	e8 00 00 00 00	 call	 ?OnRenderFireTempleTitle@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderFireTempleTitle

; 773  : 		OnRenderTowerDefUser(iXPos, iYPos);
; 774  : 		break;

  0020f	eb ea		 jmp	 SHORT $LN30@OnRender
$LN7@OnRender:

; 775  : 	case MT_DARK_XMAS:
; 776  : 		OnRenderSnowTownTitle(iXPos, iYPos);

  00211	53		 push	 ebx
  00212	57		 push	 edi
  00213	8b ce		 mov	 ecx, esi
  00215	e8 00 00 00 00	 call	 ?OnRenderSnowTownTitle@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderSnowTownTitle

; 777  : 		OnRenderTowerDefUser(iXPos, iYPos);
; 778  : 		break;

  0021a	eb df		 jmp	 SHORT $LN30@OnRender
$LN6@OnRender:

; 779  : 	case MT_SYMBOL:
; 780  : 	case MT_UNDERWEAR:
; 781  : 	case MT_CBT:
; 782  : 	case MT_CATCH:
; 783  : 	case MT_KING:
; 784  : 	case MT_TEAM_SURVIVAL:
; 785  : 	case MT_TEAM_SURVIVAL_AI:
; 786  : 	case MT_HEROMATCH:
; 787  : 	case MT_CATCH_RUNNINGMAN:
; 788  : 		OnRenderTeamTitle( iXPos, iYPos );

  0021c	6a 01		 push	 1
  0021e	6a 01		 push	 1
$LN31@OnRender:
  00220	53		 push	 ebx
  00221	57		 push	 edi
  00222	8b ce		 mov	 ecx, esi
  00224	e8 00 00 00 00	 call	 ?OnRenderTeamTitle@RoundStateUserWnd@@IAEXHH_N0@Z ; RoundStateUserWnd::OnRenderTeamTitle

; 789  : 		OnRenderTeamUser( iXPos, iYPos );

  00229	53		 push	 ebx
  0022a	57		 push	 edi
  0022b	8b ce		 mov	 ecx, esi
  0022d	e8 00 00 00 00	 call	 ?OnRenderTeamUser@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderTeamUser

; 790  : 		break;	

  00232	eb 49		 jmp	 SHORT $LN16@OnRender
$LN5@OnRender:

; 791  : 	case MT_FOOTBALL:
; 792  : 		OnRenderTeamTitle( iXPos, iYPos );

  00234	6a 01		 push	 1
  00236	6a 01		 push	 1
  00238	53		 push	 ebx
  00239	57		 push	 edi
  0023a	8b ce		 mov	 ecx, esi
  0023c	e8 00 00 00 00	 call	 ?OnRenderTeamTitle@RoundStateUserWnd@@IAEXHH_N0@Z ; RoundStateUserWnd::OnRenderTeamTitle

; 793  : 		OnRenderSoccerUser( iXPos, iYPos );

  00241	53		 push	 ebx
  00242	57		 push	 edi
  00243	8b ce		 mov	 ecx, esi
  00245	e8 00 00 00 00	 call	 ?OnRenderSoccerUser@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderSoccerUser

; 794  : 		break;	

  0024a	eb 31		 jmp	 SHORT $LN16@OnRender
$LN4@OnRender:

; 795  : 	case MT_GANGSI:
; 796  : 		OnRenderGangsiTitle( iXPos, iYPos );

  0024c	53		 push	 ebx
  0024d	57		 push	 edi
  0024e	8b ce		 mov	 ecx, esi
  00250	e8 00 00 00 00	 call	 ?OnRenderGangsiTitle@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderGangsiTitle

; 797  : 		OnRenderSingleUser( iXPos, iYPos );
; 798  : 		break;

  00255	e9 51 ff ff ff	 jmp	 $LN29@OnRender
$LN3@OnRender:

; 799  : 	case MT_DOUBLE_CROWN:
; 800  : 		OnRenderTeamTitle( iXPos, iYPos, false, false );

  0025a	6a 00		 push	 0
  0025c	6a 00		 push	 0

; 801  : 		OnRenderTeamUser( iXPos, iYPos );
; 802  : 		break;

  0025e	eb c0		 jmp	 SHORT $LN31@OnRender
$LN2@OnRender:

; 803  : 	case MT_FACTORY:
; 804  : 		OnRenderFactoryTitle(iXPos, iYPos);

  00260	53		 push	 ebx
  00261	57		 push	 edi
  00262	8b ce		 mov	 ecx, esi
  00264	e8 00 00 00 00	 call	 ?OnRenderFactoryTitle@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderFactoryTitle

; 805  : 		OnRenderTowerDefUser(iXPos, iYPos);
; 806  : 		break;

  00269	eb 90		 jmp	 SHORT $LN30@OnRender
$LN1@OnRender:

; 807  : 	case MT_RAID:
; 808  : 		OnRenderRaidTitle( iXPos, iYPos );

  0026b	53		 push	 ebx
  0026c	57		 push	 edi
  0026d	8b ce		 mov	 ecx, esi
  0026f	e8 00 00 00 00	 call	 ?OnRenderRaidTitle@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderRaidTitle

; 809  : 		OnRenderRaidUser( iXPos, iYPos );

  00274	53		 push	 ebx
  00275	57		 push	 edi
  00276	8b ce		 mov	 ecx, esi
  00278	e8 00 00 00 00	 call	 ?OnRenderRaidUser@RoundStateUserWnd@@IAEXHH@Z ; RoundStateUserWnd::OnRenderRaidUser
$LN16@OnRender:

; 810  : 		break;
; 811  : 	}
; 812  : }

  0027d	5f		 pop	 edi
  0027e	5e		 pop	 esi
  0027f	5b		 pop	 ebx
  00280	c3		 ret	 0
  00281	8d 49 00	 npad	 3
$LN32@OnRender:
  00284	00 00 00 00	 DD	 $LN6@OnRender
  00288	00 00 00 00	 DD	 $LN15@OnRender
  0028c	00 00 00 00	 DD	 $LN13@OnRender
  00290	00 00 00 00	 DD	 $LN10@OnRender
  00294	00 00 00 00	 DD	 $LN14@OnRender
  00298	00 00 00 00	 DD	 $LN5@OnRender
  0029c	00 00 00 00	 DD	 $LN4@OnRender
  002a0	00 00 00 00	 DD	 $LN11@OnRender
  002a4	00 00 00 00	 DD	 $LN9@OnRender
  002a8	00 00 00 00	 DD	 $LN7@OnRender
  002ac	00 00 00 00	 DD	 $LN8@OnRender
  002b0	00 00 00 00	 DD	 $LN3@OnRender
  002b4	00 00 00 00	 DD	 $LN12@OnRender
  002b8	00 00 00 00	 DD	 $LN2@OnRender
  002bc	00 00 00 00	 DD	 $LN1@OnRender
  002c0	00 00 00 00	 DD	 $LN16@OnRender
$LN28@OnRender:
  002c4	00		 DB	 0
  002c5	00		 DB	 0
  002c6	00		 DB	 0
  002c7	01		 DB	 1
  002c8	02		 DB	 2
  002c9	00		 DB	 0
  002ca	03		 DB	 3
  002cb	04		 DB	 4
  002cc	05		 DB	 5
  002cd	00		 DB	 0
  002ce	06		 DB	 6
  002cf	04		 DB	 4
  002d0	01		 DB	 1
  002d1	00		 DB	 0
  002d2	07		 DB	 7
  002d3	08		 DB	 8
  002d4	09		 DB	 9
  002d5	0a		 DB	 10			; 0000000aH
  002d6	0b		 DB	 11			; 0000000bH
  002d7	0c		 DB	 12			; 0000000cH
  002d8	0d		 DB	 13			; 0000000dH
  002d9	00		 DB	 0
  002da	01		 DB	 1
  002db	0f		 DB	 15			; 0000000fH
  002dc	00		 DB	 0
  002dd	00		 DB	 0
  002de	0e		 DB	 14			; 0000000eH
?OnRender@RoundStateUserWnd@@MAEXXZ ENDP		; RoundStateUserWnd::OnRender
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IAEXPAURoundInfo@@0@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Destroy
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IAEXPAURoundInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IAEXPAURoundInfo@@0@Z PROC ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	eb 0a		 jmp	 SHORT $LN23@Destroy
$LL9@Destroy:
  00009	8b ce		 mov	 ecx, esi
  0000b	e8 00 00 00 00	 call	 ??1RoundInfo@@QAE@XZ
  00010	83 ee 80	 sub	 esi, -128		; ffffff80H
$LN23@Destroy:
  00013	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00016	75 f1		 jne	 SHORT $LL9@Destroy
  00018	5e		 pop	 esi

; 1271 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?_Destroy@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IAEXPAURoundInfo@@0@Z ENDP ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Umove@PAURoundInfo@@@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IAEPAURoundInfo@@PAU2@00@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Umove<RoundInfo *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Umove@PAURoundInfo@@@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IAEPAURoundInfo@@PAU2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAURoundInfo@@@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IAEPAURoundInfo@@PAU2@00@Z PROC ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Umove<RoundInfo *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	51		 push	 ecx
  00007	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAURoundInfo@@PAU1@V?$allocator@URoundInfo@@@std@@@std@@YAPAURoundInfo@@PAU1@00AAV?$allocator@URoundInfo@@@0@@Z ; std::_Uninitialized_move<RoundInfo *,RoundInfo *,std::allocator<RoundInfo> >
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00018	5d		 pop	 ebp
  00019	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAURoundInfo@@@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IAEPAURoundInfo@@PAU2@00@Z ENDP ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Umove<RoundInfo *>
_TEXT	ENDS
PUBLIC	??$sort_heap@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@@Z ; std::sort_heap<RoundInfo *,RoundInfoKoSort>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\algorithm
;	COMDAT ??$sort_heap@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$sort_heap@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@@Z PROC ; std::sort_heap<RoundInfo *,RoundInfoKoSort>, COMDAT

; 2708 : 	{	// order heap by repeatedly popping, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2709 : 	_DEBUG_RANGE(_First, _Last);
; 2710 : 	_DEBUG_POINTER(_Pred);
; 2711 : 	_DEBUG_HEAP_PRED(_First, _Last, _Pred);
; 2712 : 	_Sort_heap(_Unchecked(_First), _Unchecked(_Last), _Pred);

  00003	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00009	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000c	e8 00 00 00 00	 call	 ??$_Sort_heap@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@@Z ; std::_Sort_heap<RoundInfo *,RoundInfoKoSort>
  00011	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2713 : 	}

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??$sort_heap@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@@Z ENDP ; std::sort_heap<RoundInfo *,RoundInfoKoSort>
_TEXT	ENDS
PUBLIC	??$sort_heap@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@@Z ; std::sort_heap<RoundInfo *,RoundInfoSort>
; Function compile flags: /Ogsp
;	COMDAT ??$sort_heap@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$sort_heap@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@@Z PROC ; std::sort_heap<RoundInfo *,RoundInfoSort>, COMDAT

; 2708 : 	{	// order heap by repeatedly popping, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2709 : 	_DEBUG_RANGE(_First, _Last);
; 2710 : 	_DEBUG_POINTER(_Pred);
; 2711 : 	_DEBUG_HEAP_PRED(_First, _Last, _Pred);
; 2712 : 	_Sort_heap(_Unchecked(_First), _Unchecked(_Last), _Pred);

  00003	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00009	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000c	e8 00 00 00 00	 call	 ??$_Sort_heap@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@@Z ; std::_Sort_heap<RoundInfo *,RoundInfoSort>
  00011	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2713 : 	}

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??$sort_heap@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@@Z ENDP ; std::sort_heap<RoundInfo *,RoundInfoSort>
_TEXT	ENDS
PUBLIC	??$sort_heap@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@@Z ; std::sort_heap<RoundInfo *,RoundInfoStarSort>
; Function compile flags: /Ogsp
;	COMDAT ??$sort_heap@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$sort_heap@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@@Z PROC ; std::sort_heap<RoundInfo *,RoundInfoStarSort>, COMDAT

; 2708 : 	{	// order heap by repeatedly popping, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2709 : 	_DEBUG_RANGE(_First, _Last);
; 2710 : 	_DEBUG_POINTER(_Pred);
; 2711 : 	_DEBUG_HEAP_PRED(_First, _Last, _Pred);
; 2712 : 	_Sort_heap(_Unchecked(_First), _Unchecked(_Last), _Pred);

  00003	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00009	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000c	e8 00 00 00 00	 call	 ??$_Sort_heap@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@@Z ; std::_Sort_heap<RoundInfo *,RoundInfoStarSort>
  00011	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2713 : 	}

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??$sort_heap@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@@Z ENDP ; std::sort_heap<RoundInfo *,RoundInfoStarSort>
_TEXT	ENDS
PUBLIC	?erase@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@0@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::erase
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?erase@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T569349 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Cat$569294 = 16					; size = 1
__Last_arg$ = 16					; size = 4
?erase@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@0@Z PROC ; std::vector<RoundInfo,std::allocator<RoundInfo> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  00004	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __First_arg$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);
; 1193 : 
; 1194 : 		if (_First != _Last)

  0000f	3b 4d 10	 cmp	 ecx, DWORD PTR __Last_arg$[ebp]
  00012	74 37		 je	 SHORT $LN1@erase

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  00014	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00017	53		 push	 ebx
  00018	57		 push	 edi
  00019	ff 75 10	 push	 DWORD PTR __Cat$569294[ebp]
  0001c	51		 push	 ecx
  0001d	50		 push	 eax
  0001e	ff 75 10	 push	 DWORD PTR __Last_arg$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Move@PAURoundInfo@@PAU1@@std@@YAPAURoundInfo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<RoundInfo *,RoundInfo *>

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);

  00026	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00029	8b d8		 mov	 ebx, eax
  0002b	83 c4 10	 add	 esp, 16			; 00000010H
  0002e	89 5d fc	 mov	 DWORD PTR $T569349[ebp], ebx
  00031	3b df		 cmp	 ebx, edi
  00033	74 11		 je	 SHORT $LN36@erase
$LL52@erase:
  00035	8b 4d fc	 mov	 ecx, DWORD PTR $T569349[ebp]
  00038	e8 00 00 00 00	 call	 ??1RoundInfo@@QAE@XZ
  0003d	83 6d fc 80	 sub	 DWORD PTR $T569349[ebp], -128 ; ffffff80H
  00041	39 7d fc	 cmp	 DWORD PTR $T569349[ebp], edi
  00044	75 ef		 jne	 SHORT $LL52@erase
$LN36@erase:

; 1211 : 			this->_Mylast = _Ptr;

  00046	5f		 pop	 edi
  00047	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0004a	5b		 pop	 ebx
$LN1@erase:

; 1212 : 			}
; 1213 : 		return (_First);

  0004b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0004e	5e		 pop	 esi

; 1214 : 		}

  0004f	c9		 leave
  00050	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@0@Z ENDP ; std::vector<RoundInfo,std::allocator<RoundInfo> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IAEXXZ ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Tidy
EXTRN	__imp_?_Orphan_all@_Container_base0@std@@QAEXXZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ?_Tidy@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00006	74 27		 je	 SHORT $LN24@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00008	53		 push	 ebx
  00009	57		 push	 edi
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  00010	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00013	8b 3e		 mov	 edi, DWORD PTR [esi]
  00015	eb 0a		 jmp	 SHORT $LN28@Tidy
$LL12@Tidy:
  00017	8b cf		 mov	 ecx, edi
  00019	e8 00 00 00 00	 call	 ??1RoundInfo@@QAE@XZ
  0001e	83 ef 80	 sub	 edi, -128		; ffffff80H
$LN28@Tidy:
  00021	3b fb		 cmp	 edi, ebx
  00023	75 f2		 jne	 SHORT $LL12@Tidy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00025	ff 36		 push	 DWORD PTR [esi]
  00027	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002c	59		 pop	 ecx
  0002d	5f		 pop	 edi
  0002e	5b		 pop	 ebx
$LN24@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  0002f	33 c0		 xor	 eax, eax
  00031	89 06		 mov	 DWORD PTR [esi], eax

; 1310 : 		this->_Mylast = 0;

  00033	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1311 : 		this->_Myend = 0;

  00036	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00039	5e		 pop	 esi

; 1312 : 		}

  0003a	c3		 ret	 0
?_Tidy@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Tidy
_TEXT	ENDS
PUBLIC	?reserve@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXI@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::reserve
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
tv300 = -24						; size = 4
__Ptr$551419 = -20					; size = 4
__$EHRec$ = -16						; size = 16
$T569595 = 8						; size = 4
__Count$ = 8						; size = 4
?reserve@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXI@Z PROC ; std::vector<RoundInfo,std::allocator<RoundInfo> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	6a 0c		 push	 12			; 0000000cH
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?reserve@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXI@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_catch
  0000c	8b f1		 mov	 esi, ecx

; 747  : 		if (max_size() < _Count)

  0000e	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00011	81 fb ff ff ff
	01		 cmp	 ebx, 33554431		; 01ffffffH
  00017	76 0b		 jbe	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN59@reserve:
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	2b 06		 sub	 eax, DWORD PTR [esi]
  00029	c1 f8 07	 sar	 eax, 7
  0002c	3b c3		 cmp	 eax, ebx
  0002e	73 79		 jae	 SHORT $LN3@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  00030	6a 00		 push	 0
  00032	53		 push	 ebx
  00033	e8 00 00 00 00	 call	 ??$_Allocate@URoundInfo@@@std@@YAPAURoundInfo@@IPAU1@@Z ; std::_Allocate<RoundInfo>

; 752  : 
; 753  : 			_TRY_BEGIN
; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00038	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0003a	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
  0003e	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  00041	52		 push	 edx
  00042	89 45 ec	 mov	 DWORD PTR __Ptr$551419[ebp], eax
  00045	ff 75 ec	 push	 DWORD PTR __Ptr$551419[ebp]
  00048	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0004b	50		 push	 eax
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAURoundInfo@@PAU1@V?$allocator@URoundInfo@@@std@@@std@@YAPAURoundInfo@@PAU1@00AAV?$allocator@URoundInfo@@@0@@Z ; std::_Uninitialized_move<RoundInfo *,RoundInfo *,std::allocator<RoundInfo> >

; 758  : 			_CATCH_END
; 759  : 
; 760  : 			size_type _Size = size();

  00052	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00055	8b 06		 mov	 eax, DWORD PTR [esi]
  00057	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0005b	8b f9		 mov	 edi, ecx
  0005d	83 c4 18	 add	 esp, 24			; 00000018H
  00060	2b f8		 sub	 edi, eax
  00062	89 4d e8	 mov	 DWORD PTR tv300[ebp], ecx
  00065	85 c0		 test	 eax, eax
  00067	74 23		 je	 SHORT $LN51@reserve

; 761  : 			if (this->_Myfirst != 0)
; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  00069	89 45 08	 mov	 DWORD PTR $T569595[ebp], eax
  0006c	3b c1		 cmp	 eax, ecx
  0006e	74 14		 je	 SHORT $LN37@reserve
$LN39@reserve:
  00070	8b 4d 08	 mov	 ecx, DWORD PTR $T569595[ebp]
  00073	e8 00 00 00 00	 call	 ??1RoundInfo@@QAE@XZ
  00078	83 6d 08 80	 sub	 DWORD PTR $T569595[ebp], -128 ; ffffff80H
  0007c	8b 45 08	 mov	 eax, DWORD PTR $T569595[ebp]
  0007f	3b 45 e8	 cmp	 eax, DWORD PTR tv300[ebp]
  00082	75 ec		 jne	 SHORT $LN39@reserve
$LN37@reserve:

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  00084	ff 36		 push	 DWORD PTR [esi]
  00086	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008b	59		 pop	 ecx
$LN51@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  0008c	8b ce		 mov	 ecx, esi
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 769  : 			this->_Myend = _Ptr + _Count;

  00094	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$551419[ebp]
  00097	c1 e3 07	 shl	 ebx, 7
  0009a	03 d8		 add	 ebx, eax

; 770  : 			this->_Mylast = _Ptr + _Size;

  0009c	83 e7 80	 and	 edi, -128		; ffffff80H
  0009f	03 f8		 add	 edi, eax
  000a1	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  000a4	89 7e 04	 mov	 DWORD PTR [esi+4], edi

; 771  : 			this->_Myfirst = _Ptr;

  000a7	89 06		 mov	 DWORD PTR [esi], eax
$LN3@reserve:

; 772  : 			}
; 773  : 		}

  000a9	e8 00 00 00 00	 call	 __EH_epilog3
  000ae	c2 04 00	 ret	 4
__catch$?reserve@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  000b1	ff 75 ec	 push	 DWORD PTR __Ptr$551419[ebp]
  000b4	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000b9	59		 pop	 ecx

; 757  : 			_RERAISE;

  000ba	6a 00		 push	 0
  000bc	6a 00		 push	 0
  000be	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN60@reserve:
$LN58@reserve:
  000c3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXI@Z ENDP ; std::vector<RoundInfo,std::allocator<RoundInfo> >::reserve
PUBLIC	??$_Sort@PAURoundInfo@@HVRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0HVRoundInfoKoSort@@@Z ; std::_Sort<RoundInfo *,int,RoundInfoKoSort>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\algorithm
;	COMDAT ??$_Sort@PAURoundInfo@@HVRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0HVRoundInfoKoSort@@@Z
_TEXT	SEGMENT
__Mid$554958 = -8					; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Sort@PAURoundInfo@@HVRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0HVRoundInfoKoSort@@@Z PROC ; std::_Sort<RoundInfo *,int,RoundInfoKoSort>, COMDAT

; 3771 : 	{	// order [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx

; 3772 : 	_Diff _Count;
; 3773 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

  00006	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
  00009	57		 push	 edi
  0000a	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000d	8b c7		 mov	 eax, edi
  0000f	2b c3		 sub	 eax, ebx
  00011	c1 f8 07	 sar	 eax, 7
  00014	83 f8 20	 cmp	 eax, 32			; 00000020H
  00017	0f 8e 89 00 00
	00		 jle	 $LN22@Sort
  0001d	56		 push	 esi
  0001e	8b 75 10	 mov	 esi, DWORD PTR __Ideal$[ebp]
$LL7@Sort:
  00021	85 f6		 test	 esi, esi
  00023	7e 62		 jle	 SHORT $LN6@Sort

; 3774 : 		{	// divide and conquer by quicksort
; 3775 : 		_STD pair<_RanIt, _RanIt> _Mid =
; 3776 : 			_Unguarded_partition(_First, _Last, _Pred);

  00025	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00028	8d 45 f8	 lea	 eax, DWORD PTR __Mid$554958[ebp]
  0002b	57		 push	 edi
  0002c	53		 push	 ebx
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ??$_Unguarded_partition@PAURoundInfo@@VRoundInfoKoSort@@@std@@YA?AU?$pair@PAURoundInfo@@PAU1@@0@PAURoundInfo@@0VRoundInfoKoSort@@@Z ; std::_Unguarded_partition<RoundInfo *,RoundInfoKoSort>

; 3777 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions
; 3778 : 
; 3779 : 		if (_Mid.first - _First < _Last - _Mid.second)

  00033	8b 4d f8	 mov	 ecx, DWORD PTR __Mid$554958[ebp]
  00036	8b c6		 mov	 eax, esi
  00038	99		 cdq
  00039	2b c2		 sub	 eax, edx
  0003b	d1 f8		 sar	 eax, 1
  0003d	8b f0		 mov	 esi, eax
  0003f	99		 cdq
  00040	2b c2		 sub	 eax, edx
  00042	d1 f8		 sar	 eax, 1
  00044	03 f0		 add	 esi, eax
  00046	8b c7		 mov	 eax, edi
  00048	2b 45 fc	 sub	 eax, DWORD PTR __Mid$554958[ebp+4]
  0004b	83 c4 10	 add	 esp, 16			; 00000010H

; 3780 : 			{	// loop on second half
; 3781 : 			_Sort(_First, _Mid.first, _Ideal, _Pred);

  0004e	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00051	2b cb		 sub	 ecx, ebx
  00053	83 e0 80	 and	 eax, -128		; ffffff80H
  00056	83 e1 80	 and	 ecx, -128		; ffffff80H
  00059	56		 push	 esi
  0005a	3b c8		 cmp	 ecx, eax
  0005c	7d 0e		 jge	 SHORT $LN5@Sort
  0005e	ff 75 f8	 push	 DWORD PTR __Mid$554958[ebp]
  00061	53		 push	 ebx
  00062	e8 00 00 00 00	 call	 ??$_Sort@PAURoundInfo@@HVRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0HVRoundInfoKoSort@@@Z ; std::_Sort<RoundInfo *,int,RoundInfoKoSort>

; 3782 : 			_First = _Mid.second;

  00067	8b 5d fc	 mov	 ebx, DWORD PTR __Mid$554958[ebp+4]

; 3783 : 			}
; 3784 : 		else

  0006a	eb 0c		 jmp	 SHORT $LN23@Sort
$LN5@Sort:

; 3785 : 			{	// loop on first half
; 3786 : 			_Sort(_Mid.second, _Last, _Ideal, _Pred);

  0006c	57		 push	 edi
  0006d	ff 75 fc	 push	 DWORD PTR __Mid$554958[ebp+4]
  00070	e8 00 00 00 00	 call	 ??$_Sort@PAURoundInfo@@HVRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0HVRoundInfoKoSort@@@Z ; std::_Sort<RoundInfo *,int,RoundInfoKoSort>

; 3787 : 			_Last = _Mid.first;

  00075	8b 7d f8	 mov	 edi, DWORD PTR __Mid$554958[ebp]
$LN23@Sort:

; 3772 : 	_Diff _Count;
; 3773 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

  00078	8b c7		 mov	 eax, edi
  0007a	2b c3		 sub	 eax, ebx
  0007c	c1 f8 07	 sar	 eax, 7

; 3785 : 			{	// loop on first half
; 3786 : 			_Sort(_Mid.second, _Last, _Ideal, _Pred);

  0007f	83 c4 10	 add	 esp, 16			; 00000010H
  00082	83 f8 20	 cmp	 eax, 32			; 00000020H
  00085	7f 9a		 jg	 SHORT $LL7@Sort
$LN6@Sort:
  00087	5e		 pop	 esi

; 3788 : 			}
; 3789 : 		}
; 3790 : 
; 3791 : 	if (_ISORT_MAX < _Count)

  00088	83 f8 20	 cmp	 eax, 32			; 00000020H
  0008b	7e 19		 jle	 SHORT $LN22@Sort

; 3792 : 		{	// heap sort if too many divisions
; 3793 : 		_STD make_heap(_First, _Last, _Pred);

  0008d	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00090	57		 push	 edi
  00091	53		 push	 ebx
  00092	e8 00 00 00 00	 call	 ??$make_heap@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@@Z ; std::make_heap<RoundInfo *,RoundInfoKoSort>

; 3794 : 		_STD sort_heap(_First, _Last, _Pred);

  00097	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  0009a	57		 push	 edi
  0009b	53		 push	 ebx
  0009c	e8 00 00 00 00	 call	 ??$_Sort_heap@PAURoundInfo@@VRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@@Z ; std::_Sort_heap<RoundInfo *,RoundInfoKoSort>
  000a1	83 c4 18	 add	 esp, 24			; 00000018H
  000a4	eb 14		 jmp	 SHORT $LN16@Sort
$LN22@Sort:

; 3795 : 		}
; 3796 : 	else if (1 < _Count)

  000a6	83 f8 01	 cmp	 eax, 1
  000a9	7e 0f		 jle	 SHORT $LN16@Sort

; 3797 : 		_Insertion_sort(_First, _Last, _Pred);	// small

  000ab	6a 00		 push	 0
  000ad	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  000b0	57		 push	 edi
  000b1	53		 push	 ebx
  000b2	e8 00 00 00 00	 call	 ??$_Insertion_sort1@PAURoundInfo@@VRoundInfoKoSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoKoSort@@0@Z ; std::_Insertion_sort1<RoundInfo *,RoundInfoKoSort,RoundInfo>
  000b7	83 c4 10	 add	 esp, 16			; 00000010H
$LN16@Sort:
  000ba	5f		 pop	 edi
  000bb	5b		 pop	 ebx

; 3798 : 	}

  000bc	c9		 leave
  000bd	c3		 ret	 0
??$_Sort@PAURoundInfo@@HVRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0HVRoundInfoKoSort@@@Z ENDP ; std::_Sort<RoundInfo *,int,RoundInfoKoSort>
_TEXT	ENDS
PUBLIC	??$_Sort@PAURoundInfo@@HVRoundInfoSort@@@std@@YAXPAURoundInfo@@0HVRoundInfoSort@@@Z ; std::_Sort<RoundInfo *,int,RoundInfoSort>
; Function compile flags: /Ogsp
;	COMDAT ??$_Sort@PAURoundInfo@@HVRoundInfoSort@@@std@@YAXPAURoundInfo@@0HVRoundInfoSort@@@Z
_TEXT	SEGMENT
__Mid$555026 = -8					; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Sort@PAURoundInfo@@HVRoundInfoSort@@@std@@YAXPAURoundInfo@@0HVRoundInfoSort@@@Z PROC ; std::_Sort<RoundInfo *,int,RoundInfoSort>, COMDAT

; 3771 : 	{	// order [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx

; 3772 : 	_Diff _Count;
; 3773 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

  00006	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
  00009	57		 push	 edi
  0000a	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000d	8b c7		 mov	 eax, edi
  0000f	2b c3		 sub	 eax, ebx
  00011	c1 f8 07	 sar	 eax, 7
  00014	83 f8 20	 cmp	 eax, 32			; 00000020H
  00017	0f 8e 89 00 00
	00		 jle	 $LN22@Sort@2
  0001d	56		 push	 esi
  0001e	8b 75 10	 mov	 esi, DWORD PTR __Ideal$[ebp]
$LL7@Sort@2:
  00021	85 f6		 test	 esi, esi
  00023	7e 62		 jle	 SHORT $LN6@Sort@2

; 3774 : 		{	// divide and conquer by quicksort
; 3775 : 		_STD pair<_RanIt, _RanIt> _Mid =
; 3776 : 			_Unguarded_partition(_First, _Last, _Pred);

  00025	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00028	8d 45 f8	 lea	 eax, DWORD PTR __Mid$555026[ebp]
  0002b	57		 push	 edi
  0002c	53		 push	 ebx
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ??$_Unguarded_partition@PAURoundInfo@@VRoundInfoSort@@@std@@YA?AU?$pair@PAURoundInfo@@PAU1@@0@PAURoundInfo@@0VRoundInfoSort@@@Z ; std::_Unguarded_partition<RoundInfo *,RoundInfoSort>

; 3777 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions
; 3778 : 
; 3779 : 		if (_Mid.first - _First < _Last - _Mid.second)

  00033	8b 4d f8	 mov	 ecx, DWORD PTR __Mid$555026[ebp]
  00036	8b c6		 mov	 eax, esi
  00038	99		 cdq
  00039	2b c2		 sub	 eax, edx
  0003b	d1 f8		 sar	 eax, 1
  0003d	8b f0		 mov	 esi, eax
  0003f	99		 cdq
  00040	2b c2		 sub	 eax, edx
  00042	d1 f8		 sar	 eax, 1
  00044	03 f0		 add	 esi, eax
  00046	8b c7		 mov	 eax, edi
  00048	2b 45 fc	 sub	 eax, DWORD PTR __Mid$555026[ebp+4]
  0004b	83 c4 10	 add	 esp, 16			; 00000010H

; 3780 : 			{	// loop on second half
; 3781 : 			_Sort(_First, _Mid.first, _Ideal, _Pred);

  0004e	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00051	2b cb		 sub	 ecx, ebx
  00053	83 e0 80	 and	 eax, -128		; ffffff80H
  00056	83 e1 80	 and	 ecx, -128		; ffffff80H
  00059	56		 push	 esi
  0005a	3b c8		 cmp	 ecx, eax
  0005c	7d 0e		 jge	 SHORT $LN5@Sort@2
  0005e	ff 75 f8	 push	 DWORD PTR __Mid$555026[ebp]
  00061	53		 push	 ebx
  00062	e8 00 00 00 00	 call	 ??$_Sort@PAURoundInfo@@HVRoundInfoSort@@@std@@YAXPAURoundInfo@@0HVRoundInfoSort@@@Z ; std::_Sort<RoundInfo *,int,RoundInfoSort>

; 3782 : 			_First = _Mid.second;

  00067	8b 5d fc	 mov	 ebx, DWORD PTR __Mid$555026[ebp+4]

; 3783 : 			}
; 3784 : 		else

  0006a	eb 0c		 jmp	 SHORT $LN23@Sort@2
$LN5@Sort@2:

; 3785 : 			{	// loop on first half
; 3786 : 			_Sort(_Mid.second, _Last, _Ideal, _Pred);

  0006c	57		 push	 edi
  0006d	ff 75 fc	 push	 DWORD PTR __Mid$555026[ebp+4]
  00070	e8 00 00 00 00	 call	 ??$_Sort@PAURoundInfo@@HVRoundInfoSort@@@std@@YAXPAURoundInfo@@0HVRoundInfoSort@@@Z ; std::_Sort<RoundInfo *,int,RoundInfoSort>

; 3787 : 			_Last = _Mid.first;

  00075	8b 7d f8	 mov	 edi, DWORD PTR __Mid$555026[ebp]
$LN23@Sort@2:

; 3772 : 	_Diff _Count;
; 3773 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

  00078	8b c7		 mov	 eax, edi
  0007a	2b c3		 sub	 eax, ebx
  0007c	c1 f8 07	 sar	 eax, 7

; 3785 : 			{	// loop on first half
; 3786 : 			_Sort(_Mid.second, _Last, _Ideal, _Pred);

  0007f	83 c4 10	 add	 esp, 16			; 00000010H
  00082	83 f8 20	 cmp	 eax, 32			; 00000020H
  00085	7f 9a		 jg	 SHORT $LL7@Sort@2
$LN6@Sort@2:
  00087	5e		 pop	 esi

; 3788 : 			}
; 3789 : 		}
; 3790 : 
; 3791 : 	if (_ISORT_MAX < _Count)

  00088	83 f8 20	 cmp	 eax, 32			; 00000020H
  0008b	7e 19		 jle	 SHORT $LN22@Sort@2

; 3792 : 		{	// heap sort if too many divisions
; 3793 : 		_STD make_heap(_First, _Last, _Pred);

  0008d	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00090	57		 push	 edi
  00091	53		 push	 ebx
  00092	e8 00 00 00 00	 call	 ??$make_heap@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@@Z ; std::make_heap<RoundInfo *,RoundInfoSort>

; 3794 : 		_STD sort_heap(_First, _Last, _Pred);

  00097	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  0009a	57		 push	 edi
  0009b	53		 push	 ebx
  0009c	e8 00 00 00 00	 call	 ??$_Sort_heap@PAURoundInfo@@VRoundInfoSort@@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@@Z ; std::_Sort_heap<RoundInfo *,RoundInfoSort>
  000a1	83 c4 18	 add	 esp, 24			; 00000018H
  000a4	eb 14		 jmp	 SHORT $LN16@Sort@2
$LN22@Sort@2:

; 3795 : 		}
; 3796 : 	else if (1 < _Count)

  000a6	83 f8 01	 cmp	 eax, 1
  000a9	7e 0f		 jle	 SHORT $LN16@Sort@2

; 3797 : 		_Insertion_sort(_First, _Last, _Pred);	// small

  000ab	6a 00		 push	 0
  000ad	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  000b0	57		 push	 edi
  000b1	53		 push	 ebx
  000b2	e8 00 00 00 00	 call	 ??$_Insertion_sort1@PAURoundInfo@@VRoundInfoSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoSort@@0@Z ; std::_Insertion_sort1<RoundInfo *,RoundInfoSort,RoundInfo>
  000b7	83 c4 10	 add	 esp, 16			; 00000010H
$LN16@Sort@2:
  000ba	5f		 pop	 edi
  000bb	5b		 pop	 ebx

; 3798 : 	}

  000bc	c9		 leave
  000bd	c3		 ret	 0
??$_Sort@PAURoundInfo@@HVRoundInfoSort@@@std@@YAXPAURoundInfo@@0HVRoundInfoSort@@@Z ENDP ; std::_Sort<RoundInfo *,int,RoundInfoSort>
_TEXT	ENDS
PUBLIC	??$_Sort@PAURoundInfo@@HVRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0HVRoundInfoStarSort@@@Z ; std::_Sort<RoundInfo *,int,RoundInfoStarSort>
; Function compile flags: /Ogsp
;	COMDAT ??$_Sort@PAURoundInfo@@HVRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0HVRoundInfoStarSort@@@Z
_TEXT	SEGMENT
__Mid$555070 = -8					; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Sort@PAURoundInfo@@HVRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0HVRoundInfoStarSort@@@Z PROC ; std::_Sort<RoundInfo *,int,RoundInfoStarSort>, COMDAT

; 3771 : 	{	// order [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx

; 3772 : 	_Diff _Count;
; 3773 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

  00006	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
  00009	57		 push	 edi
  0000a	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000d	8b c7		 mov	 eax, edi
  0000f	2b c3		 sub	 eax, ebx
  00011	c1 f8 07	 sar	 eax, 7
  00014	83 f8 20	 cmp	 eax, 32			; 00000020H
  00017	0f 8e 89 00 00
	00		 jle	 $LN22@Sort@3
  0001d	56		 push	 esi
  0001e	8b 75 10	 mov	 esi, DWORD PTR __Ideal$[ebp]
$LL7@Sort@3:
  00021	85 f6		 test	 esi, esi
  00023	7e 62		 jle	 SHORT $LN6@Sort@3

; 3774 : 		{	// divide and conquer by quicksort
; 3775 : 		_STD pair<_RanIt, _RanIt> _Mid =
; 3776 : 			_Unguarded_partition(_First, _Last, _Pred);

  00025	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00028	8d 45 f8	 lea	 eax, DWORD PTR __Mid$555070[ebp]
  0002b	57		 push	 edi
  0002c	53		 push	 ebx
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ??$_Unguarded_partition@PAURoundInfo@@VRoundInfoStarSort@@@std@@YA?AU?$pair@PAURoundInfo@@PAU1@@0@PAURoundInfo@@0VRoundInfoStarSort@@@Z ; std::_Unguarded_partition<RoundInfo *,RoundInfoStarSort>

; 3777 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions
; 3778 : 
; 3779 : 		if (_Mid.first - _First < _Last - _Mid.second)

  00033	8b 4d f8	 mov	 ecx, DWORD PTR __Mid$555070[ebp]
  00036	8b c6		 mov	 eax, esi
  00038	99		 cdq
  00039	2b c2		 sub	 eax, edx
  0003b	d1 f8		 sar	 eax, 1
  0003d	8b f0		 mov	 esi, eax
  0003f	99		 cdq
  00040	2b c2		 sub	 eax, edx
  00042	d1 f8		 sar	 eax, 1
  00044	03 f0		 add	 esi, eax
  00046	8b c7		 mov	 eax, edi
  00048	2b 45 fc	 sub	 eax, DWORD PTR __Mid$555070[ebp+4]
  0004b	83 c4 10	 add	 esp, 16			; 00000010H

; 3780 : 			{	// loop on second half
; 3781 : 			_Sort(_First, _Mid.first, _Ideal, _Pred);

  0004e	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00051	2b cb		 sub	 ecx, ebx
  00053	83 e0 80	 and	 eax, -128		; ffffff80H
  00056	83 e1 80	 and	 ecx, -128		; ffffff80H
  00059	56		 push	 esi
  0005a	3b c8		 cmp	 ecx, eax
  0005c	7d 0e		 jge	 SHORT $LN5@Sort@3
  0005e	ff 75 f8	 push	 DWORD PTR __Mid$555070[ebp]
  00061	53		 push	 ebx
  00062	e8 00 00 00 00	 call	 ??$_Sort@PAURoundInfo@@HVRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0HVRoundInfoStarSort@@@Z ; std::_Sort<RoundInfo *,int,RoundInfoStarSort>

; 3782 : 			_First = _Mid.second;

  00067	8b 5d fc	 mov	 ebx, DWORD PTR __Mid$555070[ebp+4]

; 3783 : 			}
; 3784 : 		else

  0006a	eb 0c		 jmp	 SHORT $LN23@Sort@3
$LN5@Sort@3:

; 3785 : 			{	// loop on first half
; 3786 : 			_Sort(_Mid.second, _Last, _Ideal, _Pred);

  0006c	57		 push	 edi
  0006d	ff 75 fc	 push	 DWORD PTR __Mid$555070[ebp+4]
  00070	e8 00 00 00 00	 call	 ??$_Sort@PAURoundInfo@@HVRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0HVRoundInfoStarSort@@@Z ; std::_Sort<RoundInfo *,int,RoundInfoStarSort>

; 3787 : 			_Last = _Mid.first;

  00075	8b 7d f8	 mov	 edi, DWORD PTR __Mid$555070[ebp]
$LN23@Sort@3:

; 3772 : 	_Diff _Count;
; 3773 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

  00078	8b c7		 mov	 eax, edi
  0007a	2b c3		 sub	 eax, ebx
  0007c	c1 f8 07	 sar	 eax, 7

; 3785 : 			{	// loop on first half
; 3786 : 			_Sort(_Mid.second, _Last, _Ideal, _Pred);

  0007f	83 c4 10	 add	 esp, 16			; 00000010H
  00082	83 f8 20	 cmp	 eax, 32			; 00000020H
  00085	7f 9a		 jg	 SHORT $LL7@Sort@3
$LN6@Sort@3:
  00087	5e		 pop	 esi

; 3788 : 			}
; 3789 : 		}
; 3790 : 
; 3791 : 	if (_ISORT_MAX < _Count)

  00088	83 f8 20	 cmp	 eax, 32			; 00000020H
  0008b	7e 19		 jle	 SHORT $LN22@Sort@3

; 3792 : 		{	// heap sort if too many divisions
; 3793 : 		_STD make_heap(_First, _Last, _Pred);

  0008d	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00090	57		 push	 edi
  00091	53		 push	 ebx
  00092	e8 00 00 00 00	 call	 ??$make_heap@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@@Z ; std::make_heap<RoundInfo *,RoundInfoStarSort>

; 3794 : 		_STD sort_heap(_First, _Last, _Pred);

  00097	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  0009a	57		 push	 edi
  0009b	53		 push	 ebx
  0009c	e8 00 00 00 00	 call	 ??$_Sort_heap@PAURoundInfo@@VRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@@Z ; std::_Sort_heap<RoundInfo *,RoundInfoStarSort>
  000a1	83 c4 18	 add	 esp, 24			; 00000018H
  000a4	eb 14		 jmp	 SHORT $LN16@Sort@3
$LN22@Sort@3:

; 3795 : 		}
; 3796 : 	else if (1 < _Count)

  000a6	83 f8 01	 cmp	 eax, 1
  000a9	7e 0f		 jle	 SHORT $LN16@Sort@3

; 3797 : 		_Insertion_sort(_First, _Last, _Pred);	// small

  000ab	6a 00		 push	 0
  000ad	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  000b0	57		 push	 edi
  000b1	53		 push	 ebx
  000b2	e8 00 00 00 00	 call	 ??$_Insertion_sort1@PAURoundInfo@@VRoundInfoStarSort@@U1@@std@@YAXPAURoundInfo@@0VRoundInfoStarSort@@0@Z ; std::_Insertion_sort1<RoundInfo *,RoundInfoStarSort,RoundInfo>
  000b7	83 c4 10	 add	 esp, 16			; 00000010H
$LN16@Sort@3:
  000ba	5f		 pop	 edi
  000bb	5b		 pop	 ebx

; 3798 : 	}

  000bc	c9		 leave
  000bd	c3		 ret	 0
??$_Sort@PAURoundInfo@@HVRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0HVRoundInfoStarSort@@@Z ENDP ; std::_Sort<RoundInfo *,int,RoundInfoStarSort>
_TEXT	ENDS
PUBLIC	??1?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE@XZ ; std::vector<RoundInfo,std::allocator<RoundInfo> >::~vector<RoundInfo,std::allocator<RoundInfo> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??1?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<RoundInfo,std::allocator<RoundInfo> >::~vector<RoundInfo,std::allocator<RoundInfo> >, COMDAT
; _this$ = ecx

; 705  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IAEXXZ ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Tidy
??1?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<RoundInfo,std::allocator<RoundInfo> >::~vector<RoundInfo,std::allocator<RoundInfo> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXXZ ; std::vector<RoundInfo,std::allocator<RoundInfo> >::clear
; Function compile flags: /Ogsp
;	COMDAT ?clear@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T569754 = -4						; size = 4
?clear@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<RoundInfo,std::allocator<RoundInfo> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1218 : 		erase(begin(), end());

  00004	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00007	8b 11		 mov	 edx, DWORD PTR [ecx]
  00009	50		 push	 eax
  0000a	52		 push	 edx
  0000b	8d 45 fc	 lea	 eax, DWORD PTR $T569754[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?erase@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@0@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::erase

; 1219 : 		}

  00014	c9		 leave
  00015	c3		 ret	 0
?clear@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<RoundInfo,std::allocator<RoundInfo> >::clear
_TEXT	ENDS
PUBLIC	?_Reserve@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IAEXI@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Reserve
; Function compile flags: /Ogsp
;	COMDAT ?_Reserve@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IAEXI@Z PROC ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1291 : 		size_type _Size = size();

  00006	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00008	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000b	2b c1		 sub	 eax, ecx

; 1292 : 		if (max_size() - _Count < _Size)

  0000d	ba ff ff ff 01	 mov	 edx, 33554431		; 01ffffffH
  00012	2b 55 08	 sub	 edx, DWORD PTR __Count$[ebp]
  00015	c1 f8 07	 sar	 eax, 7
  00018	3b d0		 cmp	 edx, eax
  0001a	73 0b		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN21@Reserve:
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00027	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002a	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  0002d	2b d1		 sub	 edx, ecx
  0002f	c1 fa 07	 sar	 edx, 7
  00032	3b c2		 cmp	 eax, edx
  00034	76 10		 jbe	 SHORT $LN1@Reserve

; 1295 : 			;
; 1296 : 		else
; 1297 : 			reserve(_Grow_to(_Size));

  00036	50		 push	 eax
  00037	8b ce		 mov	 ecx, esi
  00039	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IBEII@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Grow_to
  0003e	50		 push	 eax
  0003f	8b ce		 mov	 ecx, esi
  00041	e8 00 00 00 00	 call	 ?reserve@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXI@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::reserve
$LN1@Reserve:
  00046	5e		 pop	 esi

; 1298 : 		}

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN20@Reserve:
?_Reserve@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IAEXI@Z ENDP ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Reserve
_TEXT	ENDS
PUBLIC	??$sort@V?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@VRoundInfoKoSort@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@0@0VRoundInfoKoSort@@@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >,RoundInfoKoSort>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\algorithm
;	COMDAT ??$sort@V?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@VRoundInfoKoSort@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@0@0VRoundInfoKoSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$sort@V?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@VRoundInfoKoSort@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@0@0VRoundInfoKoSort@@@Z PROC ; std::sort<std::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >,RoundInfoKoSort>, COMDAT

; 3803 : 	{	// order [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3804 : 	_DEBUG_RANGE(_First, _Last);
; 3805 : 	_DEBUG_POINTER(_Pred);
; 3806 : 	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00009	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000c	c1 f8 07	 sar	 eax, 7
  0000f	50		 push	 eax
  00010	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00013	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00016	e8 00 00 00 00	 call	 ??$_Sort@PAURoundInfo@@HVRoundInfoKoSort@@@std@@YAXPAURoundInfo@@0HVRoundInfoKoSort@@@Z ; std::_Sort<RoundInfo *,int,RoundInfoKoSort>
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 3807 : 	}

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$sort@V?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@VRoundInfoKoSort@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@0@0VRoundInfoKoSort@@@Z ENDP ; std::sort<std::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >,RoundInfoKoSort>
_TEXT	ENDS
PUBLIC	??$sort@V?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@VRoundInfoSort@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@0@0VRoundInfoSort@@@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >,RoundInfoSort>
; Function compile flags: /Ogsp
;	COMDAT ??$sort@V?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@VRoundInfoSort@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@0@0VRoundInfoSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$sort@V?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@VRoundInfoSort@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@0@0VRoundInfoSort@@@Z PROC ; std::sort<std::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >,RoundInfoSort>, COMDAT

; 3803 : 	{	// order [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3804 : 	_DEBUG_RANGE(_First, _Last);
; 3805 : 	_DEBUG_POINTER(_Pred);
; 3806 : 	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00009	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000c	c1 f8 07	 sar	 eax, 7
  0000f	50		 push	 eax
  00010	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00013	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00016	e8 00 00 00 00	 call	 ??$_Sort@PAURoundInfo@@HVRoundInfoSort@@@std@@YAXPAURoundInfo@@0HVRoundInfoSort@@@Z ; std::_Sort<RoundInfo *,int,RoundInfoSort>
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 3807 : 	}

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$sort@V?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@VRoundInfoSort@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@0@0VRoundInfoSort@@@Z ENDP ; std::sort<std::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >,RoundInfoSort>
_TEXT	ENDS
PUBLIC	??$sort@V?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@VRoundInfoStarSort@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@0@0VRoundInfoStarSort@@@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >,RoundInfoStarSort>
; Function compile flags: /Ogsp
;	COMDAT ??$sort@V?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@VRoundInfoStarSort@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@0@0VRoundInfoStarSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$sort@V?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@VRoundInfoStarSort@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@0@0VRoundInfoStarSort@@@Z PROC ; std::sort<std::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >,RoundInfoStarSort>, COMDAT

; 3803 : 	{	// order [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3804 : 	_DEBUG_RANGE(_First, _Last);
; 3805 : 	_DEBUG_POINTER(_Pred);
; 3806 : 	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00009	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000c	c1 f8 07	 sar	 eax, 7
  0000f	50		 push	 eax
  00010	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00013	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00016	e8 00 00 00 00	 call	 ??$_Sort@PAURoundInfo@@HVRoundInfoStarSort@@@std@@YAXPAURoundInfo@@0HVRoundInfoStarSort@@@Z ; std::_Sort<RoundInfo *,int,RoundInfoStarSort>
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 3807 : 	}

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$sort@V?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@VRoundInfoStarSort@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@0@0VRoundInfoStarSort@@@Z ENDP ; std::sort<std::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >,RoundInfoStarSort>
_TEXT	ENDS
PUBLIC	??_7RoundStateUserWnd@@6B@			; RoundStateUserWnd::`vftable'
PUBLIC	??0RoundStateUserWnd@@QAE@XZ			; RoundStateUserWnd::RoundStateUserWnd
PUBLIC	??_R4RoundStateUserWnd@@6B@			; RoundStateUserWnd::`RTTI Complete Object Locator'
PUBLIC	??_R3RoundStateUserWnd@@8			; RoundStateUserWnd::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2RoundStateUserWnd@@8			; RoundStateUserWnd::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@RoundStateUserWnd@@8		; RoundStateUserWnd::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ioWnd@@8				; ioWnd::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3ioWnd@@8					; ioWnd::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioWnd@@8					; ioWnd::`RTTI Base Class Array'
EXTRN	??1PingStepWnd@@UAE@XZ:PROC			; PingStepWnd::~PingStepWnd
EXTRN	__imp_??1ioWnd@@UAE@XZ:PROC
EXTRN	??0PingStepWnd@@QAE@XZ:PROC			; PingStepWnd::PingStepWnd
EXTRN	__imp_??0ioWnd@@QAE@XZ:PROC
EXTRN	?AddTooltipHelp@ioWnd@@UAEXABVioHashString@@00@Z:PROC ; ioWnd::AddTooltipHelp
EXTRN	?AddNamedRenderImage@ioWnd@@UAEXABVioHashString@@PAVioUIRenderImage@@@Z:PROC ; ioWnd::AddNamedRenderImage
EXTRN	?RemoveNamedRenderImage@ioWnd@@UAEXABVioHashString@@@Z:PROC ; ioWnd::RemoveNamedRenderImage
EXTRN	?GetNamedRenderImage@ioWnd@@UBEPAVioUIRenderImage@@ABVioHashString@@@Z:PROC ; ioWnd::GetNamedRenderImage
EXTRN	?SetWindowAlpha@ioWnd@@UAEXH@Z:PROC		; ioWnd::SetWindowAlpha
EXTRN	?SetActive@ioWnd@@UAEXXZ:PROC			; ioWnd::SetActive
EXTRN	?SetInActive@ioWnd@@UAEXXZ:PROC			; ioWnd::SetInActive
EXTRN	?ClearElementImageList@ioWnd@@UAEXXZ:PROC	; ioWnd::ClearElementImageList
EXTRN	?SetSize@ioWnd@@UAEXHH@Z:PROC			; ioWnd::SetSize
EXTRN	?SetPositionToDefault@ioWnd@@UAEXHH_N0@Z:PROC	; ioWnd::SetPositionToDefault
EXTRN	?IsNeedProcess@ioWnd@@UBE_NXZ:PROC		; ioWnd::IsNeedProcess
EXTRN	?IsCanMouseReaction@ioWnd@@UBE_NXZ:PROC		; ioWnd::IsCanMouseReaction
EXTRN	?AddChild@ioWnd@@UAEXPAV1@@Z:PROC		; ioWnd::AddChild
EXTRN	?DeleteChild@ioWnd@@UAEXK@Z:PROC		; ioWnd::DeleteChild
EXTRN	?DeleteAllChild@ioWnd@@UAEXXZ:PROC		; ioWnd::DeleteAllChild
EXTRN	?OnRenderShowAndHide@ioWnd@@MAE_NXZ:PROC	; ioWnd::OnRenderShowAndHide
EXTRN	?OnRenderShowAndHideByDefault@ioWnd@@MAE_NK@Z:PROC ; ioWnd::OnRenderShowAndHideByDefault
EXTRN	?OnRenderShowAndHideByTop@ioWnd@@MAE_NK@Z:PROC	; ioWnd::OnRenderShowAndHideByTop
EXTRN	?OnRenderShowAndHideByDown@ioWnd@@MAE_NK@Z:PROC	; ioWnd::OnRenderShowAndHideByDown
EXTRN	?OnRenderAfterChild@ioWnd@@MAEXXZ:PROC		; ioWnd::OnRenderAfterChild
EXTRN	?OnMouseProcess@ioWnd@@MAEXABVioMouse@@@Z:PROC	; ioWnd::OnMouseProcess
EXTRN	?CheckFrameReSize@ioWnd@@MAEXHHHH@Z:PROC	; ioWnd::CheckFrameReSize
EXTRN	?RenderImageList@ioWnd@@MAEXHHW4UIRenderType@@@Z:PROC ; ioWnd::RenderImageList
EXTRN	?iwm_destroy@ioWnd@@UAEXXZ:PROC			; ioWnd::iwm_destroy
EXTRN	?iwm_lbuttondown@ioWnd@@UAEXABVioMouse@@@Z:PROC	; ioWnd::iwm_lbuttondown
EXTRN	?iwm_lbuttonup@ioWnd@@UAEXABVioMouse@@@Z:PROC	; ioWnd::iwm_lbuttonup
EXTRN	?iwm_lbuttonDBLCLK@ioWnd@@UAEXABVioMouse@@@Z:PROC ; ioWnd::iwm_lbuttonDBLCLK
EXTRN	?iwm_rbuttondown@ioWnd@@UAEXABVioMouse@@@Z:PROC	; ioWnd::iwm_rbuttondown
EXTRN	?iwm_rbuttonup@ioWnd@@UAEXABVioMouse@@@Z:PROC	; ioWnd::iwm_rbuttonup
EXTRN	?iwm_command@ioWnd@@UAEXPAV1@HK@Z:PROC		; ioWnd::iwm_command
EXTRN	?iwm_mouseover@ioWnd@@UAEXABVioMouse@@@Z:PROC	; ioWnd::iwm_mouseover
EXTRN	?iwm_mousemove@ioWnd@@UAEXABVioMouse@@@Z:PROC	; ioWnd::iwm_mousemove
EXTRN	?iwm_mouseleave@ioWnd@@UAEXABVioMouse@@@Z:PROC	; ioWnd::iwm_mouseleave
EXTRN	?iwm_vscroll@ioWnd@@UAEXKH@Z:PROC		; ioWnd::iwm_vscroll
EXTRN	?iwm_wheel@ioWnd@@UAEXH@Z:PROC			; ioWnd::iwm_wheel
EXTRN	?iwm_esc@ioWnd@@UAE_NXZ:PROC			; ioWnd::iwm_esc
EXTRN	?iwm_spacebar@ioWnd@@UAE_NXZ:PROC		; ioWnd::iwm_spacebar
EXTRN	?iwm_gototop@ioWnd@@UAEXXZ:PROC			; ioWnd::iwm_gototop
EXTRN	?iwm_dragenter@ioWnd@@UAE?AW4IWDropEffect@@PAVioDragItem@@ABVioMouse@@@Z:PROC ; ioWnd::iwm_dragenter
EXTRN	?iwm_dragover@ioWnd@@UAE?AW4IWDropEffect@@PAVioDragItem@@ABVioMouse@@@Z:PROC ; ioWnd::iwm_dragover
EXTRN	?iwm_dragleave@ioWnd@@UAEXXZ:PROC		; ioWnd::iwm_dragleave
EXTRN	?iwm_dropitem@ioWnd@@UAE_NPAVioDragItem@@ABVioMouse@@PAV1@@Z:PROC ; ioWnd::iwm_dropitem
EXTRN	?iwm_dropdone@ioWnd@@UAEXPAVioDragItem@@PAV1@_N@Z:PROC ; ioWnd::iwm_dropdone
EXTRN	?IsEXType@ioWnd@@UBE_NXZ:PROC			; ioWnd::IsEXType
EXTRN	?GetWndType@ioWnd@@UBEKXZ:PROC			; ioWnd::GetWndType
EXTRN	?RenderWnd@ioWnd@@UAEXXZ:PROC			; ioWnd::RenderWnd
EXTRN	?SetIDEX@ioWnd@@UAEXAAK_N@Z:PROC		; ioWnd::SetIDEX
EXTRN	?ParseXML@ioWnd@@UAEXAAVioXMLElement@@@Z:PROC	; ioWnd::ParseXML
EXTRN	?GetHeaderFileName@ioWnd@@UAEPBDXZ:PROC		; ioWnd::GetHeaderFileName
EXTRN	?GetTemplateName@ioWnd@@UAEPBDXZ:PROC		; ioWnd::GetTemplateName
EXTRN	?GetDefClassName@ioWnd@@UBEPBDXZ:PROC		; ioWnd::GetDefClassName
EXTRN	?_Clone@ioWnd@@UAEPAV1@XZ:PROC			; ioWnd::_Clone
EXTRN	?Copy@ioWnd@@UAEXPAV1@@Z:PROC			; ioWnd::Copy
EXTRN	?Save@ioWnd@@UAE_NAAVioXMLElement@@@Z:PROC	; ioWnd::Save
EXTRN	?SetSaveData@ioWnd@@UAEXAAVioXMLElement@@@Z:PROC ; ioWnd::SetSaveData
EXTRN	?SetPosX@ioWnd@@UAEXH@Z:PROC			; ioWnd::SetPosX
EXTRN	?SetPosY@ioWnd@@UAEXH@Z:PROC			; ioWnd::SetPosY
EXTRN	?SetWidth@ioWnd@@UAEXH@Z:PROC			; ioWnd::SetWidth
EXTRN	?SetHeight@ioWnd@@UAEXH@Z:PROC			; ioWnd::SetHeight
EXTRN	?GetNumFixedRenderFrame@ioWnd@@UBEHXZ:PROC	; ioWnd::GetNumFixedRenderFrame
EXTRN	?GetFixedRenderFrameType@ioWnd@@UAEPBDH@Z:PROC	; ioWnd::GetFixedRenderFrameType
EXTRN	?GetRenderFrame@ioWnd@@UAEPAPAVioUIRenderElement@@PBD@Z:PROC ; ioWnd::GetRenderFrame
EXTRN	?GetNumFixedRenderImage@ioWnd@@UBEHXZ:PROC	; ioWnd::GetNumFixedRenderImage
EXTRN	?GetFixedRenderImageType@ioWnd@@UAEPBDH@Z:PROC	; ioWnd::GetFixedRenderImageType
EXTRN	?GetRenderImage@ioWnd@@UAEPAPAVioUIRenderElement@@PBD@Z:PROC ; ioWnd::GetRenderImage
EXTRN	?AddEffect@ioWnd@@UAEXABVioHashString@@PAVioUI3DEffectRender@@@Z:PROC ; ioWnd::AddEffect
EXTRN	?GetEffect@ioWnd@@UAEPAVioUI3DEffectRender@@VioHashString@@@Z:PROC ; ioWnd::GetEffect
EXTRN	??_ERoundStateUserWnd@@UAEPAXI@Z:PROC		; RoundStateUserWnd::`vector deleting destructor'
;	COMDAT ??_R2ioWnd@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
rdata$r	SEGMENT
??_R2ioWnd@@8 DD FLAT:??_R1A@?0A@EA@ioWnd@@8		; ioWnd::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ioWnd@@8
rdata$r	SEGMENT
??_R3ioWnd@@8 DD 00H					; ioWnd::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ioWnd@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ioWnd@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioWnd@@8 DD FLAT:??_R0?AVioWnd@@@8	; ioWnd::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioWnd@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@RoundStateUserWnd@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@RoundStateUserWnd@@8 DD FLAT:??_R0?AVRoundStateUserWnd@@@8 ; RoundStateUserWnd::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3RoundStateUserWnd@@8
rdata$r	ENDS
;	COMDAT ??_R2RoundStateUserWnd@@8
rdata$r	SEGMENT
??_R2RoundStateUserWnd@@8 DD FLAT:??_R1A@?0A@EA@RoundStateUserWnd@@8 ; RoundStateUserWnd::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ioWnd@@8
rdata$r	ENDS
;	COMDAT ??_R3RoundStateUserWnd@@8
rdata$r	SEGMENT
??_R3RoundStateUserWnd@@8 DD 00H			; RoundStateUserWnd::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2RoundStateUserWnd@@8
rdata$r	ENDS
;	COMDAT ??_R4RoundStateUserWnd@@6B@
rdata$r	SEGMENT
??_R4RoundStateUserWnd@@6B@ DD 00H			; RoundStateUserWnd::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRoundStateUserWnd@@@8
	DD	FLAT:??_R3RoundStateUserWnd@@8
rdata$r	ENDS
;	COMDAT ??_7RoundStateUserWnd@@6B@
CONST	SEGMENT
??_7RoundStateUserWnd@@6B@ DD FLAT:??_R4RoundStateUserWnd@@6B@ ; RoundStateUserWnd::`vftable'
	DD	FLAT:?AddRenderFrame@RoundStateUserWnd@@MAEXABVioHashString@@PAVioUIRenderFrame@@@Z
	DD	FLAT:?AddRenderImage@RoundStateUserWnd@@MAEXABVioHashString@@PAVioUIRenderImage@@@Z
	DD	FLAT:?AddTooltipHelp@ioWnd@@UAEXABVioHashString@@00@Z
	DD	FLAT:?ParseExtraInfo@RoundStateUserWnd@@UAEXAAVioXMLElement@@@Z
	DD	FLAT:?AddNamedRenderImage@ioWnd@@UAEXABVioHashString@@PAVioUIRenderImage@@@Z
	DD	FLAT:?RemoveNamedRenderImage@ioWnd@@UAEXABVioHashString@@@Z
	DD	FLAT:?GetNamedRenderImage@ioWnd@@UBEPAVioUIRenderImage@@ABVioHashString@@@Z
	DD	FLAT:?SetWindowAlpha@ioWnd@@UAEXH@Z
	DD	FLAT:?SetActive@ioWnd@@UAEXXZ
	DD	FLAT:?SetInActive@ioWnd@@UAEXXZ
	DD	FLAT:?ClearElementImageList@ioWnd@@UAEXXZ
	DD	FLAT:?SetSize@ioWnd@@UAEXHH@Z
	DD	FLAT:?SetPositionToDefault@ioWnd@@UAEXHH_N0@Z
	DD	FLAT:?IsNeedProcess@ioWnd@@UBE_NXZ
	DD	FLAT:?IsCanMouseReaction@ioWnd@@UBE_NXZ
	DD	FLAT:?AddChild@ioWnd@@UAEXPAV1@@Z
	DD	FLAT:?DeleteChild@ioWnd@@UAEXK@Z
	DD	FLAT:?DeleteAllChild@ioWnd@@UAEXXZ
	DD	FLAT:?OnRenderShowAndHide@ioWnd@@MAE_NXZ
	DD	FLAT:?OnRenderShowAndHideByDefault@ioWnd@@MAE_NK@Z
	DD	FLAT:?OnRenderShowAndHideByTop@ioWnd@@MAE_NK@Z
	DD	FLAT:?OnRenderShowAndHideByDown@ioWnd@@MAE_NK@Z
	DD	FLAT:?OnRender@RoundStateUserWnd@@MAEXXZ
	DD	FLAT:?OnRenderAfterChild@ioWnd@@MAEXXZ
	DD	FLAT:?OnProcess@RoundStateUserWnd@@MAEXM@Z
	DD	FLAT:?OnMouseProcess@ioWnd@@MAEXABVioMouse@@@Z
	DD	FLAT:?CheckFrameReSize@ioWnd@@MAEXHHHH@Z
	DD	FLAT:?RenderImageList@ioWnd@@MAEXHHW4UIRenderType@@@Z
	DD	FLAT:?iwm_create@RoundStateUserWnd@@UAEXXZ
	DD	FLAT:?iwm_destroy@ioWnd@@UAEXXZ
	DD	FLAT:?iwm_lbuttondown@ioWnd@@UAEXABVioMouse@@@Z
	DD	FLAT:?iwm_lbuttonup@ioWnd@@UAEXABVioMouse@@@Z
	DD	FLAT:?iwm_lbuttonDBLCLK@ioWnd@@UAEXABVioMouse@@@Z
	DD	FLAT:?iwm_rbuttondown@ioWnd@@UAEXABVioMouse@@@Z
	DD	FLAT:?iwm_rbuttonup@ioWnd@@UAEXABVioMouse@@@Z
	DD	FLAT:?iwm_command@ioWnd@@UAEXPAV1@HK@Z
	DD	FLAT:?iwm_mouseover@ioWnd@@UAEXABVioMouse@@@Z
	DD	FLAT:?iwm_mousemove@ioWnd@@UAEXABVioMouse@@@Z
	DD	FLAT:?iwm_mouseleave@ioWnd@@UAEXABVioMouse@@@Z
	DD	FLAT:?iwm_vscroll@ioWnd@@UAEXKH@Z
	DD	FLAT:?iwm_wheel@ioWnd@@UAEXH@Z
	DD	FLAT:?iwm_show@RoundStateUserWnd@@UAEXXZ
	DD	FLAT:?iwm_hide@RoundStateUserWnd@@UAEXXZ
	DD	FLAT:?iwm_esc@ioWnd@@UAE_NXZ
	DD	FLAT:?iwm_spacebar@ioWnd@@UAE_NXZ
	DD	FLAT:?iwm_gototop@ioWnd@@UAEXXZ
	DD	FLAT:?iwm_dragenter@ioWnd@@UAE?AW4IWDropEffect@@PAVioDragItem@@ABVioMouse@@@Z
	DD	FLAT:?iwm_dragover@ioWnd@@UAE?AW4IWDropEffect@@PAVioDragItem@@ABVioMouse@@@Z
	DD	FLAT:?iwm_dragleave@ioWnd@@UAEXXZ
	DD	FLAT:?iwm_dropitem@ioWnd@@UAE_NPAVioDragItem@@ABVioMouse@@PAV1@@Z
	DD	FLAT:?iwm_dropdone@ioWnd@@UAEXPAVioDragItem@@PAV1@_N@Z
	DD	FLAT:?IsEXType@ioWnd@@UBE_NXZ
	DD	FLAT:?GetWndType@ioWnd@@UBEKXZ
	DD	FLAT:?RenderWnd@ioWnd@@UAEXXZ
	DD	FLAT:?SetIDEX@ioWnd@@UAEXAAK_N@Z
	DD	FLAT:?ParseXML@ioWnd@@UAEXAAVioXMLElement@@@Z
	DD	FLAT:?GetHeaderFileName@ioWnd@@UAEPBDXZ
	DD	FLAT:?GetTemplateName@ioWnd@@UAEPBDXZ
	DD	FLAT:?GetDefClassName@ioWnd@@UBEPBDXZ
	DD	FLAT:?_Clone@ioWnd@@UAEPAV1@XZ
	DD	FLAT:?Copy@ioWnd@@UAEXPAV1@@Z
	DD	FLAT:?Save@ioWnd@@UAE_NAAVioXMLElement@@@Z
	DD	FLAT:?SetSaveData@ioWnd@@UAEXAAVioXMLElement@@@Z
	DD	FLAT:?SetPosX@ioWnd@@UAEXH@Z
	DD	FLAT:?SetPosY@ioWnd@@UAEXH@Z
	DD	FLAT:?SetWidth@ioWnd@@UAEXH@Z
	DD	FLAT:?SetHeight@ioWnd@@UAEXH@Z
	DD	FLAT:?GetNumFixedRenderFrame@ioWnd@@UBEHXZ
	DD	FLAT:?GetFixedRenderFrameType@ioWnd@@UAEPBDH@Z
	DD	FLAT:?GetRenderFrame@ioWnd@@UAEPAPAVioUIRenderElement@@PBD@Z
	DD	FLAT:?GetNumFixedRenderImage@ioWnd@@UBEHXZ
	DD	FLAT:?GetFixedRenderImageType@ioWnd@@UAEPBDH@Z
	DD	FLAT:?GetRenderImage@ioWnd@@UAEPAPAVioUIRenderElement@@PBD@Z
	DD	FLAT:?AddEffect@ioWnd@@UAEXABVioHashString@@PAVioUI3DEffectRender@@@Z
	DD	FLAT:?GetEffect@ioWnd@@UAEPAVioUI3DEffectRender@@VioHashString@@@Z
	DD	FLAT:??_ERoundStateUserWnd@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0RoundStateUserWnd@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0RoundStateUserWnd@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0RoundStateUserWnd@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0RoundStateUserWnd@@QAE@XZ$2
__ehfuncinfo$??0RoundStateUserWnd@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0RoundStateUserWnd@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
xdata$x	ENDS
;	COMDAT ??0RoundStateUserWnd@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0RoundStateUserWnd@@QAE@XZ PROC			; RoundStateUserWnd::RoundStateUserWnd, COMDAT
; _this$ = ecx

; 21   : {

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0RoundStateUserWnd@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioWnd@@QAE@XZ
  00017	33 ff		 xor	 edi, edi
  00019	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7RoundStateUserWnd@@6B@
  0001f	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  00022	89 be 98 02 00
	00		 mov	 DWORD PTR [esi+664], edi
  00028	89 be 9c 02 00
	00		 mov	 DWORD PTR [esi+668], edi
  0002e	89 be a0 02 00
	00		 mov	 DWORD PTR [esi+672], edi
  00034	8d 8e a8 02 00
	00		 lea	 ecx, DWORD PTR [esi+680]
  0003a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0003e	e8 00 00 00 00	 call	 ??0PingStepWnd@@QAE@XZ	; PingStepWnd::PingStepWnd
  00043	8d 8e d4 02 00
	00		 lea	 ecx, DWORD PTR [esi+724]
  00049	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ

; 22   : 	m_pMyTeamFrm= NULL;

  00053	89 be 60 01 00
	00		 mov	 DWORD PTR [esi+352], edi

; 23   : 	m_pGuildMarkFrm = NULL;

  00059	89 be 64 01 00
	00		 mov	 DWORD PTR [esi+356], edi

; 24   : 
; 25   : 	m_pBlueDark = NULL;

  0005f	89 be 68 01 00
	00		 mov	 DWORD PTR [esi+360], edi

; 26   : 	m_pBlueLight= NULL;

  00065	89 be 6c 01 00
	00		 mov	 DWORD PTR [esi+364], edi

; 27   : 	m_pBlueOver = NULL;

  0006b	89 be 70 01 00
	00		 mov	 DWORD PTR [esi+368], edi

; 28   : 	m_pRedDark  = NULL;

  00071	89 be 74 01 00
	00		 mov	 DWORD PTR [esi+372], edi

; 29   : 	m_pRedLight = NULL;

  00077	89 be 78 01 00
	00		 mov	 DWORD PTR [esi+376], edi

; 30   : 	m_pRedOver  = NULL;

  0007d	89 be 7c 01 00
	00		 mov	 DWORD PTR [esi+380], edi

; 31   : 
; 32   : 	m_pPCRoomBlue = NULL;

  00083	89 be 80 01 00
	00		 mov	 DWORD PTR [esi+384], edi

; 33   : 	m_pPCRoomRed  = NULL;

  00089	89 be 84 01 00
	00		 mov	 DWORD PTR [esi+388], edi

; 34   : 	m_pGuildBlue  = NULL;

  0008f	89 be 88 01 00
	00		 mov	 DWORD PTR [esi+392], edi

; 35   : 	m_pGuildRed   = NULL;

  00095	89 be 8c 01 00
	00		 mov	 DWORD PTR [esi+396], edi

; 36   : 	m_pFriendBlue = NULL;

  0009b	89 be 90 01 00
	00		 mov	 DWORD PTR [esi+400], edi

; 37   : 	m_pFriendRed  = NULL;

  000a1	89 be 94 01 00
	00		 mov	 DWORD PTR [esi+404], edi

; 38   : 	m_pVictoriesBlue1 = NULL;

  000a7	89 be 98 01 00
	00		 mov	 DWORD PTR [esi+408], edi

; 39   : 	m_pVictoriesRed1  = NULL;

  000ad	89 be 9c 01 00
	00		 mov	 DWORD PTR [esi+412], edi

; 40   : 	m_pVictoriesBlue2 = NULL;

  000b3	89 be a0 01 00
	00		 mov	 DWORD PTR [esi+416], edi

; 41   : 	m_pVictoriesRed2  = NULL;

  000b9	89 be a4 01 00
	00		 mov	 DWORD PTR [esi+420], edi

; 42   : 	m_pVictoriesNumBlue = NULL;

  000bf	89 be a8 01 00
	00		 mov	 DWORD PTR [esi+424], edi

; 43   : 	m_pVictoriesNumRed  = NULL;

  000c5	89 be ac 01 00
	00		 mov	 DWORD PTR [esi+428], edi

; 44   : 	m_pModeIconBack = NULL;

  000cb	89 be b0 01 00
	00		 mov	 DWORD PTR [esi+432], edi

; 45   : 	m_pOrangeMan = NULL;

  000d1	89 be b4 01 00
	00		 mov	 DWORD PTR [esi+436], edi

; 46   : 	m_pGrayMan = NULL;

  000d7	89 be b8 01 00
	00		 mov	 DWORD PTR [esi+440], edi

; 47   : 
; 48   : 	m_pBlueVert	= NULL;

  000dd	89 be bc 01 00
	00		 mov	 DWORD PTR [esi+444], edi

; 49   : 	m_pRedVert	= NULL;

  000e3	89 be c0 01 00
	00		 mov	 DWORD PTR [esi+448], edi

; 50   : 	m_pMonsterModeTitle = NULL;

  000e9	89 be c4 01 00
	00		 mov	 DWORD PTR [esi+452], edi

; 51   : 	m_pSurvivalModeTitle= NULL;

  000ef	89 be c8 01 00
	00		 mov	 DWORD PTR [esi+456], edi

; 52   : 	m_pBossModeTitle = NULL;

  000f5	89 be cc 01 00
	00		 mov	 DWORD PTR [esi+460], edi

; 53   : 	m_pGangsiModeTitle1 = NULL;

  000fb	89 be d0 01 00
	00		 mov	 DWORD PTR [esi+464], edi

; 54   : 	m_pGangsiModeTitle2 = NULL;

  00101	89 be d4 01 00
	00		 mov	 DWORD PTR [esi+468], edi

; 55   : 	m_pFightModeTitle   = NULL;

  00107	89 be d8 01 00
	00		 mov	 DWORD PTR [esi+472], edi

; 56   : 	m_pShuffleBonusModeTitle = NULL;

  0010d	89 be dc 01 00
	00		 mov	 DWORD PTR [esi+476], edi

; 57   : 	m_pRaidModeTitle = NULL;

  00113	89 be e0 01 00
	00		 mov	 DWORD PTR [esi+480], edi

; 58   : 	m_pBlueNumber = NULL;

  00119	89 be e4 01 00
	00		 mov	 DWORD PTR [esi+484], edi

; 59   : 	m_pRedNumber = NULL;

  0011f	89 be e8 01 00
	00		 mov	 DWORD PTR [esi+488], edi

; 60   : 	m_pBlueFloor = NULL;

  00125	89 be ec 01 00
	00		 mov	 DWORD PTR [esi+492], edi

; 61   : 	m_pRedRank = NULL;

  0012b	89 be f0 01 00
	00		 mov	 DWORD PTR [esi+496], edi

; 62   : 	m_pBlueRank = NULL;

  00131	89 be f4 01 00
	00		 mov	 DWORD PTR [esi+500], edi

; 63   : 	m_pBluePer = NULL;

  00137	89 be f8 01 00
	00		 mov	 DWORD PTR [esi+504], edi

; 64   : 	m_pRedPer  = NULL;

  0013d	89 be fc 01 00
	00		 mov	 DWORD PTR [esi+508], edi

; 65   : 	m_pBluePoint = NULL;

  00143	89 be 00 02 00
	00		 mov	 DWORD PTR [esi+512], edi

; 66   : 	m_pRedPoint= NULL;

  00149	89 be 04 02 00
	00		 mov	 DWORD PTR [esi+516], edi

; 67   : 
; 68   : 	m_pTowerDefTitle = NULL;

  0014f	89 be 08 02 00
	00		 mov	 DWORD PTR [esi+520], edi

; 69   : 	m_pSnowTownTitle = NULL;

  00155	89 be 0c 02 00
	00		 mov	 DWORD PTR [esi+524], edi

; 70   : 	m_pFireTempleTitle = NULL;

  0015b	89 be 10 02 00
	00		 mov	 DWORD PTR [esi+528], edi

; 71   : 	m_pFactoryTitle = NULL;

  00161	89 be 14 02 00
	00		 mov	 DWORD PTR [esi+532], edi

; 72   : 
; 73   : 	m_pTowerDefDiff[TOWERDEF_EASY] = NULL;

  00167	89 be 18 02 00
	00		 mov	 DWORD PTR [esi+536], edi

; 74   : 	m_pTowerDefDiff[TOWERDEF_NORMAL] = NULL;

  0016d	89 be 1c 02 00
	00		 mov	 DWORD PTR [esi+540], edi

; 75   : 	m_pTowerDefDiff[TOWERDEF_HARD] = NULL;

  00173	89 be 20 02 00
	00		 mov	 DWORD PTR [esi+544], edi

; 76   : 	m_pTowerDefDiff[TOWERDEF_MASTER] = NULL;

  00179	89 be 24 02 00
	00		 mov	 DWORD PTR [esi+548], edi

; 77   : 
; 78   : 	m_pGoldMonsterCoin  = NULL;

  0017f	89 be 28 02 00
	00		 mov	 DWORD PTR [esi+552], edi

; 79   : 	m_pMonsterCoin		= NULL;

  00185	89 be 2c 02 00
	00		 mov	 DWORD PTR [esi+556], edi

; 80   : 	m_pRaidCoin			= NULL;

  0018b	89 be 30 02 00
	00		 mov	 DWORD PTR [esi+560], edi

; 81   : 	m_pCoinNumber		= NULL;

  00191	89 be 34 02 00
	00		 mov	 DWORD PTR [esi+564], edi

; 82   : 	m_pCoinUnlimited	= NULL;

  00197	89 be 38 02 00
	00		 mov	 DWORD PTR [esi+568], edi

; 83   : 
; 84   : 	m_pCurrentDark = NULL;

  0019d	89 be 3c 02 00
	00		 mov	 DWORD PTR [esi+572], edi

; 85   : 	m_pCurrentLight= NULL;

  001a3	89 be 40 02 00
	00		 mov	 DWORD PTR [esi+576], edi

; 86   : 	m_pCurrentOver = NULL;

  001a9	89 be 44 02 00
	00		 mov	 DWORD PTR [esi+580], edi

; 87   : 	m_pCurrentNumber = NULL;

  001af	89 be 48 02 00
	00		 mov	 DWORD PTR [esi+584], edi

; 88   : 	m_pCurrentNumberText  = NULL;

  001b5	89 be 4c 02 00
	00		 mov	 DWORD PTR [esi+588], edi

; 89   : 
; 90   : 	m_pBlueTeam = NULL;

  001bb	89 be 50 02 00
	00		 mov	 DWORD PTR [esi+592], edi

; 91   : 	m_pRedTeam  = NULL;

  001c1	89 be 54 02 00
	00		 mov	 DWORD PTR [esi+596], edi

; 92   : 	
; 93   : 	m_pPlayStage= NULL;

  001c7	89 be 94 02 00
	00		 mov	 DWORD PTR [esi+660], edi

; 94   : 	m_eWindowTeam = TEAM_NONE;

  001cd	89 be 58 02 00
	00		 mov	 DWORD PTR [esi+600], edi

; 95   : 	m_iMaxSlot = m_iCurrentFloor = m_iCurrentRank = m_iCurrentScore = m_iCurrentLiveUser = 0;

  001d3	89 be 70 02 00
	00		 mov	 DWORD PTR [esi+624], edi

; 96   : 
; 97   : 	m_iMaxLine = m_iLinePlayer = m_iLinePlayerGap = m_iLineStartX = 0;
; 98   : 	m_iLineStartY = m_iLineWidth = m_iLineHeight = m_iNameLimit = 0;
; 99   : 	m_MouseOverIndex = -1;

  001d9	83 8e 5c 02 00
	00 ff		 or	 DWORD PTR [esi+604], -1
  001e0	89 be 6c 02 00
	00		 mov	 DWORD PTR [esi+620], edi
  001e6	89 be 68 02 00
	00		 mov	 DWORD PTR [esi+616], edi
  001ec	89 be 64 02 00
	00		 mov	 DWORD PTR [esi+612], edi
  001f2	89 be 60 02 00
	00		 mov	 DWORD PTR [esi+608], edi
  001f8	89 be 80 02 00
	00		 mov	 DWORD PTR [esi+640], edi
  001fe	89 be 7c 02 00
	00		 mov	 DWORD PTR [esi+636], edi
  00204	89 be 78 02 00
	00		 mov	 DWORD PTR [esi+632], edi
  0020a	89 be 74 02 00
	00		 mov	 DWORD PTR [esi+628], edi
  00210	89 be 90 02 00
	00		 mov	 DWORD PTR [esi+656], edi
  00216	89 be 8c 02 00
	00		 mov	 DWORD PTR [esi+652], edi
  0021c	89 be 88 02 00
	00		 mov	 DWORD PTR [esi+648], edi
  00222	89 be 84 02 00
	00		 mov	 DWORD PTR [esi+644], edi

; 100  : }

  00228	8b c6		 mov	 eax, esi
  0022a	e8 00 00 00 00	 call	 __EH_epilog3
  0022f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0RoundStateUserWnd@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioWnd@@UAE@XZ
__unwindfunclet$??0RoundStateUserWnd@@QAE@XZ$1:
  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	81 c1 98 02 00
	00		 add	 ecx, 664		; 00000298H
  00012	e9 00 00 00 00	 jmp	 ??1?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE@XZ ; std::vector<RoundInfo,std::allocator<RoundInfo> >::~vector<RoundInfo,std::allocator<RoundInfo> >
__unwindfunclet$??0RoundStateUserWnd@@QAE@XZ$2:
  00017	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	81 c1 a8 02 00
	00		 add	 ecx, 680		; 000002a8H
  00020	e9 00 00 00 00	 jmp	 ??1PingStepWnd@@UAE@XZ	; PingStepWnd::~PingStepWnd
__ehhandler$??0RoundStateUserWnd@@QAE@XZ:
  00025	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00029	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002c	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0002f	33 c8		 xor	 ecx, eax
  00031	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00036	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0RoundStateUserWnd@@QAE@XZ
  0003b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0RoundStateUserWnd@@QAE@XZ ENDP			; RoundStateUserWnd::RoundStateUserWnd
PUBLIC	??1RoundStateUserWnd@@UAE@XZ			; RoundStateUserWnd::~RoundStateUserWnd
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??1RoundStateUserWnd@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1RoundStateUserWnd@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1RoundStateUserWnd@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1RoundStateUserWnd@@UAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1RoundStateUserWnd@@UAE@XZ$3
__ehfuncinfo$??1RoundStateUserWnd@@UAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??1RoundStateUserWnd@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
xdata$x	ENDS
;	COMDAT ??1RoundStateUserWnd@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1RoundStateUserWnd@@UAE@XZ PROC			; RoundStateUserWnd::~RoundStateUserWnd, COMDAT
; _this$ = ecx

; 103  : {

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??1RoundStateUserWnd@@UAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7RoundStateUserWnd@@6B@

; 104  : 	SAFEDELETE( m_pMyTeamFrm );

  00017	8b 8e 60 01 00
	00		 mov	 ecx, DWORD PTR [esi+352]
  0001d	33 db		 xor	 ebx, ebx
  0001f	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  00026	3b cb		 cmp	 ecx, ebx
  00028	74 0d		 je	 SHORT $LN57@RoundState
  0002a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002c	6a 01		 push	 1
  0002e	ff 50 40	 call	 DWORD PTR [eax+64]
  00031	89 9e 60 01 00
	00		 mov	 DWORD PTR [esi+352], ebx
$LN57@RoundState:

; 105  : 	SAFEDELETE( m_pGuildMarkFrm );

  00037	8b 8e 64 01 00
	00		 mov	 ecx, DWORD PTR [esi+356]
  0003d	3b cb		 cmp	 ecx, ebx
  0003f	74 0d		 je	 SHORT $LN56@RoundState
  00041	8b 01		 mov	 eax, DWORD PTR [ecx]
  00043	6a 01		 push	 1
  00045	ff 50 40	 call	 DWORD PTR [eax+64]
  00048	89 9e 64 01 00
	00		 mov	 DWORD PTR [esi+356], ebx
$LN56@RoundState:

; 106  : 
; 107  :     SAFEDELETE( m_pBlueDark );

  0004e	8b 8e 68 01 00
	00		 mov	 ecx, DWORD PTR [esi+360]
  00054	3b cb		 cmp	 ecx, ebx
  00056	74 0d		 je	 SHORT $LN55@RoundState
  00058	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005a	6a 01		 push	 1
  0005c	ff 50 40	 call	 DWORD PTR [eax+64]
  0005f	89 9e 68 01 00
	00		 mov	 DWORD PTR [esi+360], ebx
$LN55@RoundState:

; 108  : 	SAFEDELETE( m_pBlueLight );

  00065	8b 8e 6c 01 00
	00		 mov	 ecx, DWORD PTR [esi+364]
  0006b	3b cb		 cmp	 ecx, ebx
  0006d	74 0d		 je	 SHORT $LN54@RoundState
  0006f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00071	6a 01		 push	 1
  00073	ff 50 40	 call	 DWORD PTR [eax+64]
  00076	89 9e 6c 01 00
	00		 mov	 DWORD PTR [esi+364], ebx
$LN54@RoundState:

; 109  : 	SAFEDELETE( m_pBlueOver );

  0007c	8b 8e 70 01 00
	00		 mov	 ecx, DWORD PTR [esi+368]
  00082	3b cb		 cmp	 ecx, ebx
  00084	74 0d		 je	 SHORT $LN53@RoundState
  00086	8b 01		 mov	 eax, DWORD PTR [ecx]
  00088	6a 01		 push	 1
  0008a	ff 50 40	 call	 DWORD PTR [eax+64]
  0008d	89 9e 70 01 00
	00		 mov	 DWORD PTR [esi+368], ebx
$LN53@RoundState:

; 110  : 	SAFEDELETE( m_pRedDark );

  00093	8b 8e 74 01 00
	00		 mov	 ecx, DWORD PTR [esi+372]
  00099	3b cb		 cmp	 ecx, ebx
  0009b	74 0d		 je	 SHORT $LN52@RoundState
  0009d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009f	6a 01		 push	 1
  000a1	ff 50 40	 call	 DWORD PTR [eax+64]
  000a4	89 9e 74 01 00
	00		 mov	 DWORD PTR [esi+372], ebx
$LN52@RoundState:

; 111  : 	SAFEDELETE( m_pRedLight );

  000aa	8b 8e 78 01 00
	00		 mov	 ecx, DWORD PTR [esi+376]
  000b0	3b cb		 cmp	 ecx, ebx
  000b2	74 0d		 je	 SHORT $LN51@RoundState
  000b4	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b6	6a 01		 push	 1
  000b8	ff 50 40	 call	 DWORD PTR [eax+64]
  000bb	89 9e 78 01 00
	00		 mov	 DWORD PTR [esi+376], ebx
$LN51@RoundState:

; 112  : 	SAFEDELETE( m_pRedOver );

  000c1	8b 8e 7c 01 00
	00		 mov	 ecx, DWORD PTR [esi+380]
  000c7	3b cb		 cmp	 ecx, ebx
  000c9	74 0d		 je	 SHORT $LN50@RoundState
  000cb	8b 01		 mov	 eax, DWORD PTR [ecx]
  000cd	6a 01		 push	 1
  000cf	ff 50 40	 call	 DWORD PTR [eax+64]
  000d2	89 9e 7c 01 00
	00		 mov	 DWORD PTR [esi+380], ebx
$LN50@RoundState:

; 113  : 
; 114  : 	SAFEDELETE( m_pPCRoomBlue );

  000d8	8b 8e 80 01 00
	00		 mov	 ecx, DWORD PTR [esi+384]
  000de	3b cb		 cmp	 ecx, ebx
  000e0	74 0d		 je	 SHORT $LN49@RoundState
  000e2	8b 01		 mov	 eax, DWORD PTR [ecx]
  000e4	6a 01		 push	 1
  000e6	ff 50 40	 call	 DWORD PTR [eax+64]
  000e9	89 9e 80 01 00
	00		 mov	 DWORD PTR [esi+384], ebx
$LN49@RoundState:

; 115  : 	SAFEDELETE( m_pPCRoomRed );

  000ef	8b 8e 84 01 00
	00		 mov	 ecx, DWORD PTR [esi+388]
  000f5	3b cb		 cmp	 ecx, ebx
  000f7	74 0d		 je	 SHORT $LN48@RoundState
  000f9	8b 01		 mov	 eax, DWORD PTR [ecx]
  000fb	6a 01		 push	 1
  000fd	ff 50 40	 call	 DWORD PTR [eax+64]
  00100	89 9e 84 01 00
	00		 mov	 DWORD PTR [esi+388], ebx
$LN48@RoundState:

; 116  : 	SAFEDELETE( m_pGuildBlue );

  00106	8b 8e 88 01 00
	00		 mov	 ecx, DWORD PTR [esi+392]
  0010c	3b cb		 cmp	 ecx, ebx
  0010e	74 0d		 je	 SHORT $LN47@RoundState
  00110	8b 01		 mov	 eax, DWORD PTR [ecx]
  00112	6a 01		 push	 1
  00114	ff 50 40	 call	 DWORD PTR [eax+64]
  00117	89 9e 88 01 00
	00		 mov	 DWORD PTR [esi+392], ebx
$LN47@RoundState:

; 117  : 	SAFEDELETE( m_pGuildRed );

  0011d	8b 8e 8c 01 00
	00		 mov	 ecx, DWORD PTR [esi+396]
  00123	3b cb		 cmp	 ecx, ebx
  00125	74 0d		 je	 SHORT $LN46@RoundState
  00127	8b 01		 mov	 eax, DWORD PTR [ecx]
  00129	6a 01		 push	 1
  0012b	ff 50 40	 call	 DWORD PTR [eax+64]
  0012e	89 9e 8c 01 00
	00		 mov	 DWORD PTR [esi+396], ebx
$LN46@RoundState:

; 118  : 	SAFEDELETE( m_pFriendBlue );

  00134	8b 8e 90 01 00
	00		 mov	 ecx, DWORD PTR [esi+400]
  0013a	3b cb		 cmp	 ecx, ebx
  0013c	74 0d		 je	 SHORT $LN45@RoundState
  0013e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00140	6a 01		 push	 1
  00142	ff 50 40	 call	 DWORD PTR [eax+64]
  00145	89 9e 90 01 00
	00		 mov	 DWORD PTR [esi+400], ebx
$LN45@RoundState:

; 119  : 	SAFEDELETE( m_pFriendRed );

  0014b	8b 8e 94 01 00
	00		 mov	 ecx, DWORD PTR [esi+404]
  00151	3b cb		 cmp	 ecx, ebx
  00153	74 0d		 je	 SHORT $LN44@RoundState
  00155	8b 01		 mov	 eax, DWORD PTR [ecx]
  00157	6a 01		 push	 1
  00159	ff 50 40	 call	 DWORD PTR [eax+64]
  0015c	89 9e 94 01 00
	00		 mov	 DWORD PTR [esi+404], ebx
$LN44@RoundState:

; 120  : 	SAFEDELETE( m_pVictoriesBlue1 );

  00162	8b 8e 98 01 00
	00		 mov	 ecx, DWORD PTR [esi+408]
  00168	3b cb		 cmp	 ecx, ebx
  0016a	74 0d		 je	 SHORT $LN43@RoundState
  0016c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0016e	6a 01		 push	 1
  00170	ff 50 40	 call	 DWORD PTR [eax+64]
  00173	89 9e 98 01 00
	00		 mov	 DWORD PTR [esi+408], ebx
$LN43@RoundState:

; 121  : 	SAFEDELETE( m_pVictoriesRed1 );

  00179	8b 8e 9c 01 00
	00		 mov	 ecx, DWORD PTR [esi+412]
  0017f	3b cb		 cmp	 ecx, ebx
  00181	74 0d		 je	 SHORT $LN42@RoundState
  00183	8b 01		 mov	 eax, DWORD PTR [ecx]
  00185	6a 01		 push	 1
  00187	ff 50 40	 call	 DWORD PTR [eax+64]
  0018a	89 9e 9c 01 00
	00		 mov	 DWORD PTR [esi+412], ebx
$LN42@RoundState:

; 122  : 	SAFEDELETE( m_pVictoriesBlue2 );

  00190	8b 8e a0 01 00
	00		 mov	 ecx, DWORD PTR [esi+416]
  00196	3b cb		 cmp	 ecx, ebx
  00198	74 0d		 je	 SHORT $LN41@RoundState
  0019a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0019c	6a 01		 push	 1
  0019e	ff 50 40	 call	 DWORD PTR [eax+64]
  001a1	89 9e a0 01 00
	00		 mov	 DWORD PTR [esi+416], ebx
$LN41@RoundState:

; 123  : 	SAFEDELETE( m_pVictoriesRed2 );

  001a7	8b 8e a4 01 00
	00		 mov	 ecx, DWORD PTR [esi+420]
  001ad	3b cb		 cmp	 ecx, ebx
  001af	74 0d		 je	 SHORT $LN40@RoundState
  001b1	8b 01		 mov	 eax, DWORD PTR [ecx]
  001b3	6a 01		 push	 1
  001b5	ff 50 40	 call	 DWORD PTR [eax+64]
  001b8	89 9e a4 01 00
	00		 mov	 DWORD PTR [esi+420], ebx
$LN40@RoundState:

; 124  : 	SAFEDELETE( m_pVictoriesNumBlue );

  001be	8b 8e a8 01 00
	00		 mov	 ecx, DWORD PTR [esi+424]
  001c4	3b cb		 cmp	 ecx, ebx
  001c6	74 0d		 je	 SHORT $LN39@RoundState
  001c8	8b 01		 mov	 eax, DWORD PTR [ecx]
  001ca	6a 01		 push	 1
  001cc	ff 50 40	 call	 DWORD PTR [eax+64]
  001cf	89 9e a8 01 00
	00		 mov	 DWORD PTR [esi+424], ebx
$LN39@RoundState:

; 125  : 	SAFEDELETE( m_pVictoriesNumRed );

  001d5	8b 8e ac 01 00
	00		 mov	 ecx, DWORD PTR [esi+428]
  001db	3b cb		 cmp	 ecx, ebx
  001dd	74 0d		 je	 SHORT $LN38@RoundState
  001df	8b 01		 mov	 eax, DWORD PTR [ecx]
  001e1	6a 01		 push	 1
  001e3	ff 50 40	 call	 DWORD PTR [eax+64]
  001e6	89 9e ac 01 00
	00		 mov	 DWORD PTR [esi+428], ebx
$LN38@RoundState:

; 126  : 	SAFEDELETE( m_pModeIconBack );

  001ec	8b 8e b0 01 00
	00		 mov	 ecx, DWORD PTR [esi+432]
  001f2	3b cb		 cmp	 ecx, ebx
  001f4	74 0d		 je	 SHORT $LN37@RoundState
  001f6	8b 01		 mov	 eax, DWORD PTR [ecx]
  001f8	6a 01		 push	 1
  001fa	ff 50 40	 call	 DWORD PTR [eax+64]
  001fd	89 9e b0 01 00
	00		 mov	 DWORD PTR [esi+432], ebx
$LN37@RoundState:

; 127  : 	SAFEDELETE( m_pOrangeMan );

  00203	8b 8e b4 01 00
	00		 mov	 ecx, DWORD PTR [esi+436]
  00209	3b cb		 cmp	 ecx, ebx
  0020b	74 0d		 je	 SHORT $LN36@RoundState
  0020d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0020f	6a 01		 push	 1
  00211	ff 50 40	 call	 DWORD PTR [eax+64]
  00214	89 9e b4 01 00
	00		 mov	 DWORD PTR [esi+436], ebx
$LN36@RoundState:

; 128  : 	SAFEDELETE( m_pGrayMan );

  0021a	8b 8e b8 01 00
	00		 mov	 ecx, DWORD PTR [esi+440]
  00220	3b cb		 cmp	 ecx, ebx
  00222	74 0d		 je	 SHORT $LN35@RoundState
  00224	8b 01		 mov	 eax, DWORD PTR [ecx]
  00226	6a 01		 push	 1
  00228	ff 50 40	 call	 DWORD PTR [eax+64]
  0022b	89 9e b8 01 00
	00		 mov	 DWORD PTR [esi+440], ebx
$LN35@RoundState:

; 129  : 
; 130  : 	SAFEDELETE( m_pBlueVert );

  00231	8b 8e bc 01 00
	00		 mov	 ecx, DWORD PTR [esi+444]
  00237	3b cb		 cmp	 ecx, ebx
  00239	74 0d		 je	 SHORT $LN34@RoundState
  0023b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0023d	6a 01		 push	 1
  0023f	ff 50 40	 call	 DWORD PTR [eax+64]
  00242	89 9e bc 01 00
	00		 mov	 DWORD PTR [esi+444], ebx
$LN34@RoundState:

; 131  : 	SAFEDELETE( m_pRedVert );

  00248	8b 8e c0 01 00
	00		 mov	 ecx, DWORD PTR [esi+448]
  0024e	3b cb		 cmp	 ecx, ebx
  00250	74 0d		 je	 SHORT $LN33@RoundState
  00252	8b 01		 mov	 eax, DWORD PTR [ecx]
  00254	6a 01		 push	 1
  00256	ff 50 40	 call	 DWORD PTR [eax+64]
  00259	89 9e c0 01 00
	00		 mov	 DWORD PTR [esi+448], ebx
$LN33@RoundState:

; 132  : 	SAFEDELETE( m_pMonsterModeTitle );

  0025f	8b 8e c4 01 00
	00		 mov	 ecx, DWORD PTR [esi+452]
  00265	3b cb		 cmp	 ecx, ebx
  00267	74 0d		 je	 SHORT $LN32@RoundState
  00269	8b 01		 mov	 eax, DWORD PTR [ecx]
  0026b	6a 01		 push	 1
  0026d	ff 50 40	 call	 DWORD PTR [eax+64]
  00270	89 9e c4 01 00
	00		 mov	 DWORD PTR [esi+452], ebx
$LN32@RoundState:

; 133  : 	SAFEDELETE( m_pSurvivalModeTitle );

  00276	8b 8e c8 01 00
	00		 mov	 ecx, DWORD PTR [esi+456]
  0027c	3b cb		 cmp	 ecx, ebx
  0027e	74 0d		 je	 SHORT $LN31@RoundState
  00280	8b 01		 mov	 eax, DWORD PTR [ecx]
  00282	6a 01		 push	 1
  00284	ff 50 40	 call	 DWORD PTR [eax+64]
  00287	89 9e c8 01 00
	00		 mov	 DWORD PTR [esi+456], ebx
$LN31@RoundState:

; 134  : 	SAFEDELETE( m_pBossModeTitle );

  0028d	8b 8e cc 01 00
	00		 mov	 ecx, DWORD PTR [esi+460]
  00293	3b cb		 cmp	 ecx, ebx
  00295	74 0d		 je	 SHORT $LN30@RoundState
  00297	8b 01		 mov	 eax, DWORD PTR [ecx]
  00299	6a 01		 push	 1
  0029b	ff 50 40	 call	 DWORD PTR [eax+64]
  0029e	89 9e cc 01 00
	00		 mov	 DWORD PTR [esi+460], ebx
$LN30@RoundState:

; 135  : 	SAFEDELETE( m_pGangsiModeTitle1 );

  002a4	8b 8e d0 01 00
	00		 mov	 ecx, DWORD PTR [esi+464]
  002aa	3b cb		 cmp	 ecx, ebx
  002ac	74 0d		 je	 SHORT $LN29@RoundState
  002ae	8b 01		 mov	 eax, DWORD PTR [ecx]
  002b0	6a 01		 push	 1
  002b2	ff 50 40	 call	 DWORD PTR [eax+64]
  002b5	89 9e d0 01 00
	00		 mov	 DWORD PTR [esi+464], ebx
$LN29@RoundState:

; 136  : 	SAFEDELETE( m_pGangsiModeTitle2 );

  002bb	8b 8e d4 01 00
	00		 mov	 ecx, DWORD PTR [esi+468]
  002c1	3b cb		 cmp	 ecx, ebx
  002c3	74 0d		 je	 SHORT $LN28@RoundState
  002c5	8b 01		 mov	 eax, DWORD PTR [ecx]
  002c7	6a 01		 push	 1
  002c9	ff 50 40	 call	 DWORD PTR [eax+64]
  002cc	89 9e d4 01 00
	00		 mov	 DWORD PTR [esi+468], ebx
$LN28@RoundState:

; 137  : 	SAFEDELETE( m_pFightModeTitle );

  002d2	8b 8e d8 01 00
	00		 mov	 ecx, DWORD PTR [esi+472]
  002d8	3b cb		 cmp	 ecx, ebx
  002da	74 0d		 je	 SHORT $LN27@RoundState
  002dc	8b 01		 mov	 eax, DWORD PTR [ecx]
  002de	6a 01		 push	 1
  002e0	ff 50 40	 call	 DWORD PTR [eax+64]
  002e3	89 9e d8 01 00
	00		 mov	 DWORD PTR [esi+472], ebx
$LN27@RoundState:

; 138  : 	SAFEDELETE( m_pShuffleBonusModeTitle );

  002e9	8b 8e dc 01 00
	00		 mov	 ecx, DWORD PTR [esi+476]
  002ef	3b cb		 cmp	 ecx, ebx
  002f1	74 0d		 je	 SHORT $LN26@RoundState
  002f3	8b 01		 mov	 eax, DWORD PTR [ecx]
  002f5	6a 01		 push	 1
  002f7	ff 50 40	 call	 DWORD PTR [eax+64]
  002fa	89 9e dc 01 00
	00		 mov	 DWORD PTR [esi+476], ebx
$LN26@RoundState:

; 139  : 	SAFEDELETE( m_pRaidModeTitle );

  00300	8b 8e e0 01 00
	00		 mov	 ecx, DWORD PTR [esi+480]
  00306	3b cb		 cmp	 ecx, ebx
  00308	74 0d		 je	 SHORT $LN25@RoundState
  0030a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0030c	6a 01		 push	 1
  0030e	ff 50 40	 call	 DWORD PTR [eax+64]
  00311	89 9e e0 01 00
	00		 mov	 DWORD PTR [esi+480], ebx
$LN25@RoundState:

; 140  : 	SAFEDELETE( m_pBlueNumber );

  00317	8b 8e e4 01 00
	00		 mov	 ecx, DWORD PTR [esi+484]
  0031d	3b cb		 cmp	 ecx, ebx
  0031f	74 0d		 je	 SHORT $LN24@RoundState
  00321	8b 01		 mov	 eax, DWORD PTR [ecx]
  00323	6a 01		 push	 1
  00325	ff 50 40	 call	 DWORD PTR [eax+64]
  00328	89 9e e4 01 00
	00		 mov	 DWORD PTR [esi+484], ebx
$LN24@RoundState:

; 141  : 	SAFEDELETE( m_pRedNumber );

  0032e	8b 8e e8 01 00
	00		 mov	 ecx, DWORD PTR [esi+488]
  00334	3b cb		 cmp	 ecx, ebx
  00336	74 0d		 je	 SHORT $LN23@RoundState
  00338	8b 01		 mov	 eax, DWORD PTR [ecx]
  0033a	6a 01		 push	 1
  0033c	ff 50 40	 call	 DWORD PTR [eax+64]
  0033f	89 9e e8 01 00
	00		 mov	 DWORD PTR [esi+488], ebx
$LN23@RoundState:

; 142  : 	SAFEDELETE( m_pBlueFloor );

  00345	8b 8e ec 01 00
	00		 mov	 ecx, DWORD PTR [esi+492]
  0034b	3b cb		 cmp	 ecx, ebx
  0034d	74 0d		 je	 SHORT $LN22@RoundState
  0034f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00351	6a 01		 push	 1
  00353	ff 50 40	 call	 DWORD PTR [eax+64]
  00356	89 9e ec 01 00
	00		 mov	 DWORD PTR [esi+492], ebx
$LN22@RoundState:

; 143  : 	SAFEDELETE( m_pRedRank );

  0035c	8b 8e f0 01 00
	00		 mov	 ecx, DWORD PTR [esi+496]
  00362	3b cb		 cmp	 ecx, ebx
  00364	74 0d		 je	 SHORT $LN21@RoundState
  00366	8b 01		 mov	 eax, DWORD PTR [ecx]
  00368	6a 01		 push	 1
  0036a	ff 50 40	 call	 DWORD PTR [eax+64]
  0036d	89 9e f0 01 00
	00		 mov	 DWORD PTR [esi+496], ebx
$LN21@RoundState:

; 144  : 	SAFEDELETE( m_pBlueRank );

  00373	8b 8e f4 01 00
	00		 mov	 ecx, DWORD PTR [esi+500]
  00379	3b cb		 cmp	 ecx, ebx
  0037b	74 0d		 je	 SHORT $LN20@RoundState
  0037d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0037f	6a 01		 push	 1
  00381	ff 50 40	 call	 DWORD PTR [eax+64]
  00384	89 9e f4 01 00
	00		 mov	 DWORD PTR [esi+500], ebx
$LN20@RoundState:

; 145  : 	SAFEDELETE( m_pBluePer );

  0038a	8b 8e f8 01 00
	00		 mov	 ecx, DWORD PTR [esi+504]
  00390	3b cb		 cmp	 ecx, ebx
  00392	74 0d		 je	 SHORT $LN19@RoundState
  00394	8b 01		 mov	 eax, DWORD PTR [ecx]
  00396	6a 01		 push	 1
  00398	ff 50 40	 call	 DWORD PTR [eax+64]
  0039b	89 9e f8 01 00
	00		 mov	 DWORD PTR [esi+504], ebx
$LN19@RoundState:

; 146  : 	SAFEDELETE( m_pRedPer );

  003a1	8b 8e fc 01 00
	00		 mov	 ecx, DWORD PTR [esi+508]
  003a7	3b cb		 cmp	 ecx, ebx
  003a9	74 0d		 je	 SHORT $LN18@RoundState
  003ab	8b 01		 mov	 eax, DWORD PTR [ecx]
  003ad	6a 01		 push	 1
  003af	ff 50 40	 call	 DWORD PTR [eax+64]
  003b2	89 9e fc 01 00
	00		 mov	 DWORD PTR [esi+508], ebx
$LN18@RoundState:

; 147  : 	SAFEDELETE( m_pBluePoint );

  003b8	8b 8e 00 02 00
	00		 mov	 ecx, DWORD PTR [esi+512]
  003be	3b cb		 cmp	 ecx, ebx
  003c0	74 0d		 je	 SHORT $LN17@RoundState
  003c2	8b 01		 mov	 eax, DWORD PTR [ecx]
  003c4	6a 01		 push	 1
  003c6	ff 50 40	 call	 DWORD PTR [eax+64]
  003c9	89 9e 00 02 00
	00		 mov	 DWORD PTR [esi+512], ebx
$LN17@RoundState:

; 148  : 	SAFEDELETE( m_pRedPoint );

  003cf	8b 8e 04 02 00
	00		 mov	 ecx, DWORD PTR [esi+516]
  003d5	3b cb		 cmp	 ecx, ebx
  003d7	74 0d		 je	 SHORT $LN16@RoundState
  003d9	8b 01		 mov	 eax, DWORD PTR [ecx]
  003db	6a 01		 push	 1
  003dd	ff 50 40	 call	 DWORD PTR [eax+64]
  003e0	89 9e 04 02 00
	00		 mov	 DWORD PTR [esi+516], ebx
$LN16@RoundState:

; 149  : 
; 150  : 	SAFEDELETE(m_pTowerDefTitle);

  003e6	8b 8e 08 02 00
	00		 mov	 ecx, DWORD PTR [esi+520]
  003ec	3b cb		 cmp	 ecx, ebx
  003ee	74 0d		 je	 SHORT $LN15@RoundState
  003f0	8b 01		 mov	 eax, DWORD PTR [ecx]
  003f2	6a 01		 push	 1
  003f4	ff 50 40	 call	 DWORD PTR [eax+64]
  003f7	89 9e 08 02 00
	00		 mov	 DWORD PTR [esi+520], ebx
$LN15@RoundState:

; 151  : 	SAFEDELETE(m_pSnowTownTitle);

  003fd	8b 8e 0c 02 00
	00		 mov	 ecx, DWORD PTR [esi+524]
  00403	3b cb		 cmp	 ecx, ebx
  00405	74 0d		 je	 SHORT $LN14@RoundState
  00407	8b 01		 mov	 eax, DWORD PTR [ecx]
  00409	6a 01		 push	 1
  0040b	ff 50 40	 call	 DWORD PTR [eax+64]
  0040e	89 9e 0c 02 00
	00		 mov	 DWORD PTR [esi+524], ebx
$LN14@RoundState:

; 152  : 	SAFEDELETE(m_pFireTempleTitle);

  00414	8b 8e 10 02 00
	00		 mov	 ecx, DWORD PTR [esi+528]
  0041a	3b cb		 cmp	 ecx, ebx
  0041c	74 0d		 je	 SHORT $LN13@RoundState
  0041e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00420	6a 01		 push	 1
  00422	ff 50 40	 call	 DWORD PTR [eax+64]
  00425	89 9e 10 02 00
	00		 mov	 DWORD PTR [esi+528], ebx
$LN13@RoundState:

; 153  : 	SAFEDELETE(m_pFactoryTitle);

  0042b	8b 8e 14 02 00
	00		 mov	 ecx, DWORD PTR [esi+532]
  00431	3b cb		 cmp	 ecx, ebx
  00433	74 0d		 je	 SHORT $LN12@RoundState
  00435	8b 01		 mov	 eax, DWORD PTR [ecx]
  00437	6a 01		 push	 1
  00439	ff 50 40	 call	 DWORD PTR [eax+64]
  0043c	89 9e 14 02 00
	00		 mov	 DWORD PTR [esi+532], ebx
$LN12@RoundState:

; 154  : 	SAFEDELETE(m_pTowerDefDiff[TOWERDEF_EASY]);

  00442	8b 8e 18 02 00
	00		 mov	 ecx, DWORD PTR [esi+536]
  00448	3b cb		 cmp	 ecx, ebx
  0044a	74 0d		 je	 SHORT $LN11@RoundState
  0044c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0044e	6a 01		 push	 1
  00450	ff 50 40	 call	 DWORD PTR [eax+64]
  00453	89 9e 18 02 00
	00		 mov	 DWORD PTR [esi+536], ebx
$LN11@RoundState:

; 155  : 	SAFEDELETE(m_pTowerDefDiff[TOWERDEF_NORMAL]);

  00459	8b 8e 1c 02 00
	00		 mov	 ecx, DWORD PTR [esi+540]
  0045f	3b cb		 cmp	 ecx, ebx
  00461	74 0d		 je	 SHORT $LN10@RoundState
  00463	8b 01		 mov	 eax, DWORD PTR [ecx]
  00465	6a 01		 push	 1
  00467	ff 50 40	 call	 DWORD PTR [eax+64]
  0046a	89 9e 1c 02 00
	00		 mov	 DWORD PTR [esi+540], ebx
$LN10@RoundState:

; 156  : 	SAFEDELETE(m_pTowerDefDiff[TOWERDEF_HARD]);

  00470	8b 8e 20 02 00
	00		 mov	 ecx, DWORD PTR [esi+544]
  00476	3b cb		 cmp	 ecx, ebx
  00478	74 0d		 je	 SHORT $LN9@RoundState
  0047a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0047c	6a 01		 push	 1
  0047e	ff 50 40	 call	 DWORD PTR [eax+64]
  00481	89 9e 20 02 00
	00		 mov	 DWORD PTR [esi+544], ebx
$LN9@RoundState:

; 157  : 	SAFEDELETE(m_pTowerDefDiff[TOWERDEF_MASTER]);

  00487	8b 8e 24 02 00
	00		 mov	 ecx, DWORD PTR [esi+548]
  0048d	3b cb		 cmp	 ecx, ebx
  0048f	74 0d		 je	 SHORT $LN8@RoundState
  00491	8b 01		 mov	 eax, DWORD PTR [ecx]
  00493	6a 01		 push	 1
  00495	ff 50 40	 call	 DWORD PTR [eax+64]
  00498	89 9e 24 02 00
	00		 mov	 DWORD PTR [esi+548], ebx
$LN8@RoundState:

; 158  : 
; 159  : 	SAFEDELETE( m_pGoldMonsterCoin );

  0049e	8b 8e 28 02 00
	00		 mov	 ecx, DWORD PTR [esi+552]
  004a4	3b cb		 cmp	 ecx, ebx
  004a6	74 0d		 je	 SHORT $LN7@RoundState
  004a8	8b 01		 mov	 eax, DWORD PTR [ecx]
  004aa	6a 01		 push	 1
  004ac	ff 50 40	 call	 DWORD PTR [eax+64]
  004af	89 9e 28 02 00
	00		 mov	 DWORD PTR [esi+552], ebx
$LN7@RoundState:

; 160  : 	SAFEDELETE( m_pMonsterCoin );

  004b5	8b 8e 2c 02 00
	00		 mov	 ecx, DWORD PTR [esi+556]
  004bb	3b cb		 cmp	 ecx, ebx
  004bd	74 0d		 je	 SHORT $LN6@RoundState
  004bf	8b 01		 mov	 eax, DWORD PTR [ecx]
  004c1	6a 01		 push	 1
  004c3	ff 50 40	 call	 DWORD PTR [eax+64]
  004c6	89 9e 2c 02 00
	00		 mov	 DWORD PTR [esi+556], ebx
$LN6@RoundState:

; 161  : 	SAFEDELETE( m_pRaidCoin );

  004cc	8b 8e 30 02 00
	00		 mov	 ecx, DWORD PTR [esi+560]
  004d2	3b cb		 cmp	 ecx, ebx
  004d4	74 0d		 je	 SHORT $LN5@RoundState
  004d6	8b 01		 mov	 eax, DWORD PTR [ecx]
  004d8	6a 01		 push	 1
  004da	ff 50 40	 call	 DWORD PTR [eax+64]
  004dd	89 9e 30 02 00
	00		 mov	 DWORD PTR [esi+560], ebx
$LN5@RoundState:

; 162  : 	SAFEDELETE( m_pCoinNumber );

  004e3	8b 8e 34 02 00
	00		 mov	 ecx, DWORD PTR [esi+564]
  004e9	3b cb		 cmp	 ecx, ebx
  004eb	74 0d		 je	 SHORT $LN4@RoundState
  004ed	8b 01		 mov	 eax, DWORD PTR [ecx]
  004ef	6a 01		 push	 1
  004f1	ff 50 40	 call	 DWORD PTR [eax+64]
  004f4	89 9e 34 02 00
	00		 mov	 DWORD PTR [esi+564], ebx
$LN4@RoundState:

; 163  : 	SAFEDELETE( m_pCoinUnlimited );

  004fa	8b 8e 38 02 00
	00		 mov	 ecx, DWORD PTR [esi+568]
  00500	3b cb		 cmp	 ecx, ebx
  00502	74 0d		 je	 SHORT $LN3@RoundState
  00504	8b 01		 mov	 eax, DWORD PTR [ecx]
  00506	6a 01		 push	 1
  00508	ff 50 40	 call	 DWORD PTR [eax+64]
  0050b	89 9e 38 02 00
	00		 mov	 DWORD PTR [esi+568], ebx
$LN3@RoundState:

; 164  : 
; 165  : 	SAFEDELETE( m_pBlueTeam );

  00511	8b 8e 50 02 00
	00		 mov	 ecx, DWORD PTR [esi+592]
  00517	3b cb		 cmp	 ecx, ebx
  00519	74 0d		 je	 SHORT $LN2@RoundState
  0051b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0051d	6a 01		 push	 1
  0051f	ff 50 40	 call	 DWORD PTR [eax+64]
  00522	89 9e 50 02 00
	00		 mov	 DWORD PTR [esi+592], ebx
$LN2@RoundState:

; 166  : 	SAFEDELETE( m_pRedTeam );

  00528	8b 8e 54 02 00
	00		 mov	 ecx, DWORD PTR [esi+596]
  0052e	3b cb		 cmp	 ecx, ebx
  00530	74 0d		 je	 SHORT $LN1@RoundState
  00532	8b 01		 mov	 eax, DWORD PTR [ecx]
  00534	6a 01		 push	 1
  00536	ff 50 40	 call	 DWORD PTR [eax+64]
  00539	89 9e 54 02 00
	00		 mov	 DWORD PTR [esi+596], ebx
$LN1@RoundState:

; 167  : }

  0053f	8d 8e d4 02 00
	00		 lea	 ecx, DWORD PTR [esi+724]
  00545	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00549	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  0054f	8d 8e a8 02 00
	00		 lea	 ecx, DWORD PTR [esi+680]
  00555	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00559	e8 00 00 00 00	 call	 ??1PingStepWnd@@UAE@XZ	; PingStepWnd::~PingStepWnd
  0055e	8d 8e 98 02 00
	00		 lea	 ecx, DWORD PTR [esi+664]
  00564	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  00567	e8 00 00 00 00	 call	 ?_Tidy@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IAEXXZ ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Tidy
  0056c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00570	8b ce		 mov	 ecx, esi
  00572	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioWnd@@UAE@XZ
  00578	e8 00 00 00 00	 call	 __EH_epilog3
  0057d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1RoundStateUserWnd@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioWnd@@UAE@XZ
__unwindfunclet$??1RoundStateUserWnd@@UAE@XZ$1:
  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	81 c1 98 02 00
	00		 add	 ecx, 664		; 00000298H
  00012	e9 00 00 00 00	 jmp	 ??1?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE@XZ ; std::vector<RoundInfo,std::allocator<RoundInfo> >::~vector<RoundInfo,std::allocator<RoundInfo> >
__unwindfunclet$??1RoundStateUserWnd@@UAE@XZ$2:
  00017	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	81 c1 a8 02 00
	00		 add	 ecx, 680		; 000002a8H
  00020	e9 00 00 00 00	 jmp	 ??1PingStepWnd@@UAE@XZ	; PingStepWnd::~PingStepWnd
__unwindfunclet$??1RoundStateUserWnd@@UAE@XZ$3:
  00025	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	81 c1 d4 02 00
	00		 add	 ecx, 724		; 000002d4H
  0002e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$??1RoundStateUserWnd@@UAE@XZ:
  00034	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00038	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003b	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0003e	33 c8		 xor	 ecx, eax
  00040	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00045	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1RoundStateUserWnd@@UAE@XZ
  0004a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1RoundStateUserWnd@@UAE@XZ ENDP			; RoundStateUserWnd::~RoundStateUserWnd
PUBLIC	?ClearRoundInfo@RoundStateUserWnd@@QAEXXZ	; RoundStateUserWnd::ClearRoundInfo
; Function compile flags: /Ogsp
;	COMDAT ?ClearRoundInfo@RoundStateUserWnd@@QAEXXZ
_TEXT	SEGMENT
$T570291 = -4						; size = 4
?ClearRoundInfo@RoundStateUserWnd@@QAEXXZ PROC		; RoundStateUserWnd::ClearRoundInfo, COMDAT
; _this$ = ecx

; 532  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 533  : 	m_RoundInfoList.clear();

  00004	8b 81 9c 02 00
	00		 mov	 eax, DWORD PTR [ecx+668]
  0000a	81 c1 98 02 00
	00		 add	 ecx, 664		; 00000298H
  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	50		 push	 eax
  00013	52		 push	 edx
  00014	8d 45 fc	 lea	 eax, DWORD PTR $T570291[ebp]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ?erase@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@0@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::erase

; 534  : }

  0001d	c9		 leave
  0001e	c3		 ret	 0
?ClearRoundInfo@RoundStateUserWnd@@QAEXXZ ENDP		; RoundStateUserWnd::ClearRoundInfo
_TEXT	ENDS
PUBLIC	??_7RoundStateMainWnd@@6B@			; RoundStateMainWnd::`vftable'
PUBLIC	??0RoundStateMainWnd@@QAE@XZ			; RoundStateMainWnd::RoundStateMainWnd
PUBLIC	??_R4RoundStateMainWnd@@6B@			; RoundStateMainWnd::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVRoundStateMainWnd@@@8			; RoundStateMainWnd `RTTI Type Descriptor'
PUBLIC	??_R3RoundStateMainWnd@@8			; RoundStateMainWnd::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2RoundStateMainWnd@@8			; RoundStateMainWnd::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@RoundStateMainWnd@@8		; RoundStateMainWnd::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ClearRoundInfo@RoundStateMainWnd@@UAEXXZ	; RoundStateMainWnd::ClearRoundInfo
PUBLIC	?AddRoundInfo@RoundStateMainWnd@@UAEXABURoundInfo@@@Z ; RoundStateMainWnd::AddRoundInfo
PUBLIC	?SetPlazaScore@RoundStateMainWnd@@UAEXXZ	; RoundStateMainWnd::SetPlazaScore
PUBLIC	?SetHeadequartersScore@RoundStateMainWnd@@UAEXXZ ; RoundStateMainWnd::SetHeadequartersScore
PUBLIC	?SetSingleScore@RoundStateMainWnd@@UAEXXZ	; RoundStateMainWnd::SetSingleScore
PUBLIC	?SetGangsiScore@RoundStateMainWnd@@UAEXXZ	; RoundStateMainWnd::SetGangsiScore
PUBLIC	?SetTowerDefScore@RoundStateMainWnd@@UAEXXZ	; RoundStateMainWnd::SetTowerDefScore
PUBLIC	?SetDungeonsScore@RoundStateMainWnd@@UAEXH@Z	; RoundStateMainWnd::SetDungeonsScore
PUBLIC	?SetTeamScore@RoundStateMainWnd@@UAEXHH@Z	; RoundStateMainWnd::SetTeamScore
PUBLIC	?SetStarCountScore@RoundStateMainWnd@@UAEXXZ	; RoundStateMainWnd::SetStarCountScore
PUBLIC	?SetRaidCoinCountScore@RoundStateMainWnd@@UAEXXZ ; RoundStateMainWnd::SetRaidCoinCountScore
EXTRN	??0ioComplexStringPrinter@@QAE@XZ:PROC		; ioComplexStringPrinter::ioComplexStringPrinter
EXTRN	?AddRenderFrame@ioWnd@@UAEXABVioHashString@@PAVioUIRenderFrame@@@Z:PROC ; ioWnd::AddRenderFrame
EXTRN	?AddRenderImage@ioWnd@@UAEXABVioHashString@@PAVioUIRenderImage@@@Z:PROC ; ioWnd::AddRenderImage
EXTRN	?ParseExtraInfo@ioWnd@@UAEXAAVioXMLElement@@@Z:PROC ; ioWnd::ParseExtraInfo
EXTRN	?OnProcess@ioWnd@@MAEXM@Z:PROC			; ioWnd::OnProcess
EXTRN	?iwm_create@ioWnd@@UAEXXZ:PROC			; ioWnd::iwm_create
EXTRN	??_ERoundStateMainWnd@@UAEPAXI@Z:PROC		; RoundStateMainWnd::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@RoundStateMainWnd@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
rdata$r	SEGMENT
??_R1A@?0A@EA@RoundStateMainWnd@@8 DD FLAT:??_R0?AVRoundStateMainWnd@@@8 ; RoundStateMainWnd::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3RoundStateMainWnd@@8
rdata$r	ENDS
;	COMDAT ??_R2RoundStateMainWnd@@8
rdata$r	SEGMENT
??_R2RoundStateMainWnd@@8 DD FLAT:??_R1A@?0A@EA@RoundStateMainWnd@@8 ; RoundStateMainWnd::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ioWnd@@8
rdata$r	ENDS
;	COMDAT ??_R3RoundStateMainWnd@@8
rdata$r	SEGMENT
??_R3RoundStateMainWnd@@8 DD 00H			; RoundStateMainWnd::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2RoundStateMainWnd@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRoundStateMainWnd@@@8
_DATA	SEGMENT
??_R0?AVRoundStateMainWnd@@@8 DD FLAT:??_7type_info@@6B@ ; RoundStateMainWnd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRoundStateMainWnd@@', 00H
_DATA	ENDS
;	COMDAT ??_R4RoundStateMainWnd@@6B@
rdata$r	SEGMENT
??_R4RoundStateMainWnd@@6B@ DD 00H			; RoundStateMainWnd::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRoundStateMainWnd@@@8
	DD	FLAT:??_R3RoundStateMainWnd@@8
rdata$r	ENDS
;	COMDAT ??_7RoundStateMainWnd@@6B@
CONST	SEGMENT
??_7RoundStateMainWnd@@6B@ DD FLAT:??_R4RoundStateMainWnd@@6B@ ; RoundStateMainWnd::`vftable'
	DD	FLAT:?AddRenderFrame@ioWnd@@UAEXABVioHashString@@PAVioUIRenderFrame@@@Z
	DD	FLAT:?AddRenderImage@ioWnd@@UAEXABVioHashString@@PAVioUIRenderImage@@@Z
	DD	FLAT:?AddTooltipHelp@ioWnd@@UAEXABVioHashString@@00@Z
	DD	FLAT:?ParseExtraInfo@ioWnd@@UAEXAAVioXMLElement@@@Z
	DD	FLAT:?AddNamedRenderImage@ioWnd@@UAEXABVioHashString@@PAVioUIRenderImage@@@Z
	DD	FLAT:?RemoveNamedRenderImage@ioWnd@@UAEXABVioHashString@@@Z
	DD	FLAT:?GetNamedRenderImage@ioWnd@@UBEPAVioUIRenderImage@@ABVioHashString@@@Z
	DD	FLAT:?SetWindowAlpha@ioWnd@@UAEXH@Z
	DD	FLAT:?SetActive@ioWnd@@UAEXXZ
	DD	FLAT:?SetInActive@ioWnd@@UAEXXZ
	DD	FLAT:?ClearElementImageList@ioWnd@@UAEXXZ
	DD	FLAT:?SetSize@ioWnd@@UAEXHH@Z
	DD	FLAT:?SetPositionToDefault@ioWnd@@UAEXHH_N0@Z
	DD	FLAT:?IsNeedProcess@ioWnd@@UBE_NXZ
	DD	FLAT:?IsCanMouseReaction@ioWnd@@UBE_NXZ
	DD	FLAT:?AddChild@ioWnd@@UAEXPAV1@@Z
	DD	FLAT:?DeleteChild@ioWnd@@UAEXK@Z
	DD	FLAT:?DeleteAllChild@ioWnd@@UAEXXZ
	DD	FLAT:?OnRenderShowAndHide@ioWnd@@MAE_NXZ
	DD	FLAT:?OnRenderShowAndHideByDefault@ioWnd@@MAE_NK@Z
	DD	FLAT:?OnRenderShowAndHideByTop@ioWnd@@MAE_NK@Z
	DD	FLAT:?OnRenderShowAndHideByDown@ioWnd@@MAE_NK@Z
	DD	FLAT:?OnRender@RoundStateMainWnd@@MAEXXZ
	DD	FLAT:?OnRenderAfterChild@ioWnd@@MAEXXZ
	DD	FLAT:?OnProcess@ioWnd@@MAEXM@Z
	DD	FLAT:?OnMouseProcess@ioWnd@@MAEXABVioMouse@@@Z
	DD	FLAT:?CheckFrameReSize@ioWnd@@MAEXHHHH@Z
	DD	FLAT:?RenderImageList@ioWnd@@MAEXHHW4UIRenderType@@@Z
	DD	FLAT:?iwm_create@ioWnd@@UAEXXZ
	DD	FLAT:?iwm_destroy@ioWnd@@UAEXXZ
	DD	FLAT:?iwm_lbuttondown@ioWnd@@UAEXABVioMouse@@@Z
	DD	FLAT:?iwm_lbuttonup@ioWnd@@UAEXABVioMouse@@@Z
	DD	FLAT:?iwm_lbuttonDBLCLK@ioWnd@@UAEXABVioMouse@@@Z
	DD	FLAT:?iwm_rbuttondown@ioWnd@@UAEXABVioMouse@@@Z
	DD	FLAT:?iwm_rbuttonup@ioWnd@@UAEXABVioMouse@@@Z
	DD	FLAT:?iwm_command@RoundStateMainWnd@@UAEXPAVioWnd@@HK@Z
	DD	FLAT:?iwm_mouseover@ioWnd@@UAEXABVioMouse@@@Z
	DD	FLAT:?iwm_mousemove@ioWnd@@UAEXABVioMouse@@@Z
	DD	FLAT:?iwm_mouseleave@ioWnd@@UAEXABVioMouse@@@Z
	DD	FLAT:?iwm_vscroll@ioWnd@@UAEXKH@Z
	DD	FLAT:?iwm_wheel@ioWnd@@UAEXH@Z
	DD	FLAT:?iwm_show@RoundStateMainWnd@@UAEXXZ
	DD	FLAT:?iwm_hide@RoundStateMainWnd@@UAEXXZ
	DD	FLAT:?iwm_esc@ioWnd@@UAE_NXZ
	DD	FLAT:?iwm_spacebar@ioWnd@@UAE_NXZ
	DD	FLAT:?iwm_gototop@ioWnd@@UAEXXZ
	DD	FLAT:?iwm_dragenter@ioWnd@@UAE?AW4IWDropEffect@@PAVioDragItem@@ABVioMouse@@@Z
	DD	FLAT:?iwm_dragover@ioWnd@@UAE?AW4IWDropEffect@@PAVioDragItem@@ABVioMouse@@@Z
	DD	FLAT:?iwm_dragleave@ioWnd@@UAEXXZ
	DD	FLAT:?iwm_dropitem@ioWnd@@UAE_NPAVioDragItem@@ABVioMouse@@PAV1@@Z
	DD	FLAT:?iwm_dropdone@ioWnd@@UAEXPAVioDragItem@@PAV1@_N@Z
	DD	FLAT:?IsEXType@ioWnd@@UBE_NXZ
	DD	FLAT:?GetWndType@ioWnd@@UBEKXZ
	DD	FLAT:?RenderWnd@ioWnd@@UAEXXZ
	DD	FLAT:?SetIDEX@ioWnd@@UAEXAAK_N@Z
	DD	FLAT:?ParseXML@ioWnd@@UAEXAAVioXMLElement@@@Z
	DD	FLAT:?GetHeaderFileName@ioWnd@@UAEPBDXZ
	DD	FLAT:?GetTemplateName@ioWnd@@UAEPBDXZ
	DD	FLAT:?GetDefClassName@ioWnd@@UBEPBDXZ
	DD	FLAT:?_Clone@ioWnd@@UAEPAV1@XZ
	DD	FLAT:?Copy@ioWnd@@UAEXPAV1@@Z
	DD	FLAT:?Save@ioWnd@@UAE_NAAVioXMLElement@@@Z
	DD	FLAT:?SetSaveData@ioWnd@@UAEXAAVioXMLElement@@@Z
	DD	FLAT:?SetPosX@ioWnd@@UAEXH@Z
	DD	FLAT:?SetPosY@ioWnd@@UAEXH@Z
	DD	FLAT:?SetWidth@ioWnd@@UAEXH@Z
	DD	FLAT:?SetHeight@ioWnd@@UAEXH@Z
	DD	FLAT:?GetNumFixedRenderFrame@ioWnd@@UBEHXZ
	DD	FLAT:?GetFixedRenderFrameType@ioWnd@@UAEPBDH@Z
	DD	FLAT:?GetRenderFrame@ioWnd@@UAEPAPAVioUIRenderElement@@PBD@Z
	DD	FLAT:?GetNumFixedRenderImage@ioWnd@@UBEHXZ
	DD	FLAT:?GetFixedRenderImageType@ioWnd@@UAEPBDH@Z
	DD	FLAT:?GetRenderImage@ioWnd@@UAEPAPAVioUIRenderElement@@PBD@Z
	DD	FLAT:?AddEffect@ioWnd@@UAEXABVioHashString@@PAVioUI3DEffectRender@@@Z
	DD	FLAT:?GetEffect@ioWnd@@UAEPAVioUI3DEffectRender@@VioHashString@@@Z
	DD	FLAT:??_ERoundStateMainWnd@@UAEPAXI@Z
	DD	FLAT:?ClearRoundInfo@RoundStateMainWnd@@UAEXXZ
	DD	FLAT:?AddRoundInfo@RoundStateMainWnd@@UAEXABURoundInfo@@@Z
	DD	FLAT:?SetPlazaScore@RoundStateMainWnd@@UAEXXZ
	DD	FLAT:?SetHeadequartersScore@RoundStateMainWnd@@UAEXXZ
	DD	FLAT:?SetSingleScore@RoundStateMainWnd@@UAEXXZ
	DD	FLAT:?SetGangsiScore@RoundStateMainWnd@@UAEXXZ
	DD	FLAT:?SetTowerDefScore@RoundStateMainWnd@@UAEXXZ
	DD	FLAT:?SetDungeonsScore@RoundStateMainWnd@@UAEXH@Z
	DD	FLAT:?SetTeamScore@RoundStateMainWnd@@UAEXHH@Z
	DD	FLAT:?SetStarCountScore@RoundStateMainWnd@@UAEXXZ
	DD	FLAT:?SetRaidCoinCountScore@RoundStateMainWnd@@UAEXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0RoundStateMainWnd@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0RoundStateMainWnd@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0RoundStateMainWnd@@QAE@XZ$1
__ehfuncinfo$??0RoundStateMainWnd@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0RoundStateMainWnd@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
xdata$x	ENDS
;	COMDAT ??0RoundStateMainWnd@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0RoundStateMainWnd@@QAE@XZ PROC			; RoundStateMainWnd::RoundStateMainWnd, COMDAT
; _this$ = ecx

; 2301 : {

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0RoundStateMainWnd@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioWnd@@QAE@XZ
  00017	33 ff		 xor	 edi, edi
  00019	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7RoundStateMainWnd@@6B@
  0001f	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  00022	89 be 64 01 00
	00		 mov	 DWORD PTR [esi+356], edi
  00028	89 be 68 01 00
	00		 mov	 DWORD PTR [esi+360], edi
  0002e	89 be 6c 01 00
	00		 mov	 DWORD PTR [esi+364], edi
  00034	8d 8e 74 01 00
	00		 lea	 ecx, DWORD PTR [esi+372]
  0003a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0003e	e8 00 00 00 00	 call	 ??0ioComplexStringPrinter@@QAE@XZ ; ioComplexStringPrinter::ioComplexStringPrinter

; 2302 : 	m_pPlayStage = NULL;

  00043	89 be 60 01 00
	00		 mov	 DWORD PTR [esi+352], edi

; 2303 : }

  00049	8b c6		 mov	 eax, esi
  0004b	e8 00 00 00 00	 call	 __EH_epilog3
  00050	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0RoundStateMainWnd@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioWnd@@UAE@XZ
__unwindfunclet$??0RoundStateMainWnd@@QAE@XZ$1:
  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	81 c1 64 01 00
	00		 add	 ecx, 356		; 00000164H
  00012	e9 00 00 00 00	 jmp	 ??1?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE@XZ ; std::vector<RoundInfo,std::allocator<RoundInfo> >::~vector<RoundInfo,std::allocator<RoundInfo> >
__ehhandler$??0RoundStateMainWnd@@QAE@XZ:
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0RoundStateMainWnd@@QAE@XZ
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0RoundStateMainWnd@@QAE@XZ ENDP			; RoundStateMainWnd::RoundStateMainWnd
PUBLIC	??1RoundStateMainWnd@@UAE@XZ			; RoundStateMainWnd::~RoundStateMainWnd
EXTRN	??1ioComplexStringPrinter@@QAE@XZ:PROC		; ioComplexStringPrinter::~ioComplexStringPrinter
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??1RoundStateMainWnd@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1RoundStateMainWnd@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1RoundStateMainWnd@@UAE@XZ$1
__ehfuncinfo$??1RoundStateMainWnd@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1RoundStateMainWnd@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
xdata$x	ENDS
;	COMDAT ??1RoundStateMainWnd@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1RoundStateMainWnd@@UAE@XZ PROC			; RoundStateMainWnd::~RoundStateMainWnd, COMDAT
; _this$ = ecx

; 2306 : {

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??1RoundStateMainWnd@@UAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7RoundStateMainWnd@@6B@

; 2307 : }

  00017	8d 8e 74 01 00
	00		 lea	 ecx, DWORD PTR [esi+372]
  0001d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00024	e8 00 00 00 00	 call	 ??1ioComplexStringPrinter@@QAE@XZ ; ioComplexStringPrinter::~ioComplexStringPrinter
  00029	8d 8e 64 01 00
	00		 lea	 ecx, DWORD PTR [esi+356]
  0002f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00033	e8 00 00 00 00	 call	 ?_Tidy@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IAEXXZ ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Tidy
  00038	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0003c	8b ce		 mov	 ecx, esi
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioWnd@@UAE@XZ
  00044	e8 00 00 00 00	 call	 __EH_epilog3
  00049	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1RoundStateMainWnd@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioWnd@@UAE@XZ
__unwindfunclet$??1RoundStateMainWnd@@UAE@XZ$1:
  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	81 c1 64 01 00
	00		 add	 ecx, 356		; 00000164H
  00012	e9 00 00 00 00	 jmp	 ??1?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE@XZ ; std::vector<RoundInfo,std::allocator<RoundInfo> >::~vector<RoundInfo,std::allocator<RoundInfo> >
__ehhandler$??1RoundStateMainWnd@@UAE@XZ:
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1RoundStateMainWnd@@UAE@XZ
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1RoundStateMainWnd@@UAE@XZ ENDP			; RoundStateMainWnd::~RoundStateMainWnd
; Function compile flags: /Ogsp
;	COMDAT ?ClearRoundInfo@RoundStateMainWnd@@UAEXXZ
_TEXT	SEGMENT
$T570425 = -8						; size = 4
_this$ = -4						; size = 4
?ClearRoundInfo@RoundStateMainWnd@@UAEXXZ PROC		; RoundStateMainWnd::ClearRoundInfo, COMDAT
; _this$ = ecx

; 2315 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 2316 : 	m_RoundInfoList.clear();

  00009	8d 8e 64 01 00
	00		 lea	 ecx, DWORD PTR [esi+356]
  0000f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00012	8b 11		 mov	 edx, DWORD PTR [ecx]
  00014	57		 push	 edi
  00015	50		 push	 eax
  00016	52		 push	 edx
  00017	8d 45 f8	 lea	 eax, DWORD PTR $T570425[ebp]
  0001a	50		 push	 eax
  0001b	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0001e	e8 00 00 00 00	 call	 ?erase@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@2@0@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::erase

; 2317 : 
; 2318 : 	RoundStateUserWnd *pPlazaWnd = dynamic_cast<RoundStateUserWnd *>(FindChildWnd( ID_PLAZA_WND ));

  00023	6a 00		 push	 0
  00025	bb 00 00 00 00	 mov	 ebx, OFFSET ??_R0?AVRoundStateUserWnd@@@8
  0002a	53		 push	 ebx
  0002b	bf 00 00 00 00	 mov	 edi, OFFSET ??_R0?AVioWnd@@@8
  00030	57		 push	 edi
  00031	6a 00		 push	 0
  00033	8b ce		 mov	 ecx, esi
  00035	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?FindChildWnd@ioWnd@@QAEPAV1@K@Z
  0003b	6a 02		 push	 2
  0003d	ff d6		 call	 esi
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ___RTDynamicCast
  00045	83 c4 14	 add	 esp, 20			; 00000014H

; 2319 : 	if( pPlazaWnd )

  00048	85 c0		 test	 eax, eax
  0004a	74 07		 je	 SHORT $LN4@ClearRound

; 2320 : 		pPlazaWnd->ClearRoundInfo();

  0004c	8b c8		 mov	 ecx, eax
  0004e	e8 00 00 00 00	 call	 ?ClearRoundInfo@RoundStateUserWnd@@QAEXXZ ; RoundStateUserWnd::ClearRoundInfo
$LN4@ClearRound:

; 2321 : 
; 2322 : 	RoundStateUserWnd *pUserWnd = dynamic_cast<RoundStateUserWnd *>(FindChildWnd( ID_SINGLE_WND ));

  00053	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	6a 00		 push	 0
  00058	53		 push	 ebx
  00059	57		 push	 edi
  0005a	6a 00		 push	 0
  0005c	6a 03		 push	 3
  0005e	ff d6		 call	 esi
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 ___RTDynamicCast
  00066	83 c4 14	 add	 esp, 20			; 00000014H

; 2323 : 	if( pUserWnd )

  00069	85 c0		 test	 eax, eax
  0006b	74 07		 je	 SHORT $LN3@ClearRound

; 2324 : 		pUserWnd->ClearRoundInfo();

  0006d	8b c8		 mov	 ecx, eax
  0006f	e8 00 00 00 00	 call	 ?ClearRoundInfo@RoundStateUserWnd@@QAEXXZ ; RoundStateUserWnd::ClearRoundInfo
$LN3@ClearRound:

; 2325 : 
; 2326 : 	RoundStateUserWnd *pBlueWnd = dynamic_cast<RoundStateUserWnd *>(FindChildWnd( ID_BLUE_WND ));

  00074	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	6a 00		 push	 0
  00079	53		 push	 ebx
  0007a	57		 push	 edi
  0007b	6a 00		 push	 0
  0007d	6a 04		 push	 4
  0007f	ff d6		 call	 esi
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ___RTDynamicCast
  00087	83 c4 14	 add	 esp, 20			; 00000014H

; 2327 : 	if( pBlueWnd )

  0008a	85 c0		 test	 eax, eax
  0008c	74 07		 je	 SHORT $LN2@ClearRound

; 2328 : 		pBlueWnd->ClearRoundInfo();

  0008e	8b c8		 mov	 ecx, eax
  00090	e8 00 00 00 00	 call	 ?ClearRoundInfo@RoundStateUserWnd@@QAEXXZ ; RoundStateUserWnd::ClearRoundInfo
$LN2@ClearRound:

; 2329 : 
; 2330 : 	RoundStateUserWnd *pRedWnd = dynamic_cast<RoundStateUserWnd *>(FindChildWnd( ID_RED_WND ));

  00095	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00098	6a 00		 push	 0
  0009a	53		 push	 ebx
  0009b	57		 push	 edi
  0009c	6a 00		 push	 0
  0009e	6a 05		 push	 5
  000a0	ff d6		 call	 esi
  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ___RTDynamicCast
  000a8	83 c4 14	 add	 esp, 20			; 00000014H
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	5b		 pop	 ebx

; 2331 : 	if( pRedWnd )

  000ae	85 c0		 test	 eax, eax
  000b0	74 07		 je	 SHORT $LN1@ClearRound

; 2332 : 		pRedWnd->ClearRoundInfo();

  000b2	8b c8		 mov	 ecx, eax
  000b4	e8 00 00 00 00	 call	 ?ClearRoundInfo@RoundStateUserWnd@@QAEXXZ ; RoundStateUserWnd::ClearRoundInfo
$LN1@ClearRound:

; 2333 : }

  000b9	c9		 leave
  000ba	c3		 ret	 0
?ClearRoundInfo@RoundStateMainWnd@@UAEXXZ ENDP		; RoundStateMainWnd::ClearRoundInfo
_TEXT	ENDS
PUBLIC	??_7RoundResultMainWnd@@6B@			; RoundResultMainWnd::`vftable'
PUBLIC	??0RoundResultMainWnd@@QAE@XZ			; RoundResultMainWnd::RoundResultMainWnd
PUBLIC	??_R4RoundResultMainWnd@@6B@			; RoundResultMainWnd::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVRoundResultMainWnd@@@8			; RoundResultMainWnd `RTTI Type Descriptor'
PUBLIC	??_R3RoundResultMainWnd@@8			; RoundResultMainWnd::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2RoundResultMainWnd@@8			; RoundResultMainWnd::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@RoundResultMainWnd@@8		; RoundResultMainWnd::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?SetTeamScore@RoundResultMainWnd@@UAEXHH@Z	; RoundResultMainWnd::SetTeamScore
EXTRN	??_ERoundResultMainWnd@@UAEPAXI@Z:PROC		; RoundResultMainWnd::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@RoundResultMainWnd@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@RoundResultMainWnd@@8 DD FLAT:??_R0?AVRoundResultMainWnd@@@8 ; RoundResultMainWnd::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3RoundResultMainWnd@@8
rdata$r	ENDS
;	COMDAT ??_R2RoundResultMainWnd@@8
rdata$r	SEGMENT
??_R2RoundResultMainWnd@@8 DD FLAT:??_R1A@?0A@EA@RoundResultMainWnd@@8 ; RoundResultMainWnd::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@RoundStateMainWnd@@8
	DD	FLAT:??_R1A@?0A@EA@ioWnd@@8
rdata$r	ENDS
;	COMDAT ??_R3RoundResultMainWnd@@8
rdata$r	SEGMENT
??_R3RoundResultMainWnd@@8 DD 00H			; RoundResultMainWnd::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2RoundResultMainWnd@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRoundResultMainWnd@@@8
_DATA	SEGMENT
??_R0?AVRoundResultMainWnd@@@8 DD FLAT:??_7type_info@@6B@ ; RoundResultMainWnd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRoundResultMainWnd@@', 00H
_DATA	ENDS
;	COMDAT ??_R4RoundResultMainWnd@@6B@
rdata$r	SEGMENT
??_R4RoundResultMainWnd@@6B@ DD 00H			; RoundResultMainWnd::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRoundResultMainWnd@@@8
	DD	FLAT:??_R3RoundResultMainWnd@@8
rdata$r	ENDS
;	COMDAT ??_7RoundResultMainWnd@@6B@
CONST	SEGMENT
??_7RoundResultMainWnd@@6B@ DD FLAT:??_R4RoundResultMainWnd@@6B@ ; RoundResultMainWnd::`vftable'
	DD	FLAT:?AddRenderFrame@ioWnd@@UAEXABVioHashString@@PAVioUIRenderFrame@@@Z
	DD	FLAT:?AddRenderImage@ioWnd@@UAEXABVioHashString@@PAVioUIRenderImage@@@Z
	DD	FLAT:?AddTooltipHelp@ioWnd@@UAEXABVioHashString@@00@Z
	DD	FLAT:?ParseExtraInfo@ioWnd@@UAEXAAVioXMLElement@@@Z
	DD	FLAT:?AddNamedRenderImage@ioWnd@@UAEXABVioHashString@@PAVioUIRenderImage@@@Z
	DD	FLAT:?RemoveNamedRenderImage@ioWnd@@UAEXABVioHashString@@@Z
	DD	FLAT:?GetNamedRenderImage@ioWnd@@UBEPAVioUIRenderImage@@ABVioHashString@@@Z
	DD	FLAT:?SetWindowAlpha@ioWnd@@UAEXH@Z
	DD	FLAT:?SetActive@ioWnd@@UAEXXZ
	DD	FLAT:?SetInActive@ioWnd@@UAEXXZ
	DD	FLAT:?ClearElementImageList@ioWnd@@UAEXXZ
	DD	FLAT:?SetSize@ioWnd@@UAEXHH@Z
	DD	FLAT:?SetPositionToDefault@ioWnd@@UAEXHH_N0@Z
	DD	FLAT:?IsNeedProcess@ioWnd@@UBE_NXZ
	DD	FLAT:?IsCanMouseReaction@ioWnd@@UBE_NXZ
	DD	FLAT:?AddChild@ioWnd@@UAEXPAV1@@Z
	DD	FLAT:?DeleteChild@ioWnd@@UAEXK@Z
	DD	FLAT:?DeleteAllChild@ioWnd@@UAEXXZ
	DD	FLAT:?OnRenderShowAndHide@ioWnd@@MAE_NXZ
	DD	FLAT:?OnRenderShowAndHideByDefault@ioWnd@@MAE_NK@Z
	DD	FLAT:?OnRenderShowAndHideByTop@ioWnd@@MAE_NK@Z
	DD	FLAT:?OnRenderShowAndHideByDown@ioWnd@@MAE_NK@Z
	DD	FLAT:?OnRender@RoundStateMainWnd@@MAEXXZ
	DD	FLAT:?OnRenderAfterChild@ioWnd@@MAEXXZ
	DD	FLAT:?OnProcess@RoundResultMainWnd@@MAEXM@Z
	DD	FLAT:?OnMouseProcess@ioWnd@@MAEXABVioMouse@@@Z
	DD	FLAT:?CheckFrameReSize@ioWnd@@MAEXHHHH@Z
	DD	FLAT:?RenderImageList@ioWnd@@MAEXHHW4UIRenderType@@@Z
	DD	FLAT:?iwm_create@ioWnd@@UAEXXZ
	DD	FLAT:?iwm_destroy@ioWnd@@UAEXXZ
	DD	FLAT:?iwm_lbuttondown@ioWnd@@UAEXABVioMouse@@@Z
	DD	FLAT:?iwm_lbuttonup@ioWnd@@UAEXABVioMouse@@@Z
	DD	FLAT:?iwm_lbuttonDBLCLK@ioWnd@@UAEXABVioMouse@@@Z
	DD	FLAT:?iwm_rbuttondown@ioWnd@@UAEXABVioMouse@@@Z
	DD	FLAT:?iwm_rbuttonup@ioWnd@@UAEXABVioMouse@@@Z
	DD	FLAT:?iwm_command@RoundStateMainWnd@@UAEXPAVioWnd@@HK@Z
	DD	FLAT:?iwm_mouseover@ioWnd@@UAEXABVioMouse@@@Z
	DD	FLAT:?iwm_mousemove@ioWnd@@UAEXABVioMouse@@@Z
	DD	FLAT:?iwm_mouseleave@ioWnd@@UAEXABVioMouse@@@Z
	DD	FLAT:?iwm_vscroll@ioWnd@@UAEXKH@Z
	DD	FLAT:?iwm_wheel@ioWnd@@UAEXH@Z
	DD	FLAT:?iwm_show@RoundResultMainWnd@@UAEXXZ
	DD	FLAT:?iwm_hide@RoundResultMainWnd@@UAEXXZ
	DD	FLAT:?iwm_esc@ioWnd@@UAE_NXZ
	DD	FLAT:?iwm_spacebar@ioWnd@@UAE_NXZ
	DD	FLAT:?iwm_gototop@ioWnd@@UAEXXZ
	DD	FLAT:?iwm_dragenter@ioWnd@@UAE?AW4IWDropEffect@@PAVioDragItem@@ABVioMouse@@@Z
	DD	FLAT:?iwm_dragover@ioWnd@@UAE?AW4IWDropEffect@@PAVioDragItem@@ABVioMouse@@@Z
	DD	FLAT:?iwm_dragleave@ioWnd@@UAEXXZ
	DD	FLAT:?iwm_dropitem@ioWnd@@UAE_NPAVioDragItem@@ABVioMouse@@PAV1@@Z
	DD	FLAT:?iwm_dropdone@ioWnd@@UAEXPAVioDragItem@@PAV1@_N@Z
	DD	FLAT:?IsEXType@ioWnd@@UBE_NXZ
	DD	FLAT:?GetWndType@ioWnd@@UBEKXZ
	DD	FLAT:?RenderWnd@ioWnd@@UAEXXZ
	DD	FLAT:?SetIDEX@ioWnd@@UAEXAAK_N@Z
	DD	FLAT:?ParseXML@ioWnd@@UAEXAAVioXMLElement@@@Z
	DD	FLAT:?GetHeaderFileName@ioWnd@@UAEPBDXZ
	DD	FLAT:?GetTemplateName@ioWnd@@UAEPBDXZ
	DD	FLAT:?GetDefClassName@ioWnd@@UBEPBDXZ
	DD	FLAT:?_Clone@ioWnd@@UAEPAV1@XZ
	DD	FLAT:?Copy@ioWnd@@UAEXPAV1@@Z
	DD	FLAT:?Save@ioWnd@@UAE_NAAVioXMLElement@@@Z
	DD	FLAT:?SetSaveData@ioWnd@@UAEXAAVioXMLElement@@@Z
	DD	FLAT:?SetPosX@ioWnd@@UAEXH@Z
	DD	FLAT:?SetPosY@ioWnd@@UAEXH@Z
	DD	FLAT:?SetWidth@ioWnd@@UAEXH@Z
	DD	FLAT:?SetHeight@ioWnd@@UAEXH@Z
	DD	FLAT:?GetNumFixedRenderFrame@ioWnd@@UBEHXZ
	DD	FLAT:?GetFixedRenderFrameType@ioWnd@@UAEPBDH@Z
	DD	FLAT:?GetRenderFrame@ioWnd@@UAEPAPAVioUIRenderElement@@PBD@Z
	DD	FLAT:?GetNumFixedRenderImage@ioWnd@@UBEHXZ
	DD	FLAT:?GetFixedRenderImageType@ioWnd@@UAEPBDH@Z
	DD	FLAT:?GetRenderImage@ioWnd@@UAEPAPAVioUIRenderElement@@PBD@Z
	DD	FLAT:?AddEffect@ioWnd@@UAEXABVioHashString@@PAVioUI3DEffectRender@@@Z
	DD	FLAT:?GetEffect@ioWnd@@UAEPAVioUI3DEffectRender@@VioHashString@@@Z
	DD	FLAT:??_ERoundResultMainWnd@@UAEPAXI@Z
	DD	FLAT:?ClearRoundInfo@RoundStateMainWnd@@UAEXXZ
	DD	FLAT:?AddRoundInfo@RoundStateMainWnd@@UAEXABURoundInfo@@@Z
	DD	FLAT:?SetPlazaScore@RoundStateMainWnd@@UAEXXZ
	DD	FLAT:?SetHeadequartersScore@RoundStateMainWnd@@UAEXXZ
	DD	FLAT:?SetSingleScore@RoundStateMainWnd@@UAEXXZ
	DD	FLAT:?SetGangsiScore@RoundStateMainWnd@@UAEXXZ
	DD	FLAT:?SetTowerDefScore@RoundStateMainWnd@@UAEXXZ
	DD	FLAT:?SetDungeonsScore@RoundStateMainWnd@@UAEXH@Z
	DD	FLAT:?SetTeamScore@RoundResultMainWnd@@UAEXHH@Z
	DD	FLAT:?SetStarCountScore@RoundStateMainWnd@@UAEXXZ
	DD	FLAT:?SetRaidCoinCountScore@RoundStateMainWnd@@UAEXXZ
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??0RoundResultMainWnd@@QAE@XZ
_TEXT	SEGMENT
??0RoundResultMainWnd@@QAE@XZ PROC			; RoundResultMainWnd::RoundResultMainWnd, COMDAT
; _this$ = ecx

; 3067 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??0RoundStateMainWnd@@QAE@XZ ; RoundStateMainWnd::RoundStateMainWnd

; 3068 : 	m_pPlayStage = NULL;

  00008	83 a6 60 01 00
	00 00		 and	 DWORD PTR [esi+352], 0
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7RoundResultMainWnd@@6B@

; 3069 : }

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	c3		 ret	 0
??0RoundResultMainWnd@@QAE@XZ ENDP			; RoundResultMainWnd::RoundResultMainWnd
_TEXT	ENDS
PUBLIC	??1RoundResultMainWnd@@UAE@XZ			; RoundResultMainWnd::~RoundResultMainWnd
; Function compile flags: /Ogsp
;	COMDAT ??1RoundResultMainWnd@@UAE@XZ
_TEXT	SEGMENT
??1RoundResultMainWnd@@UAE@XZ PROC			; RoundResultMainWnd::~RoundResultMainWnd, COMDAT
; _this$ = ecx

; 3072 : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7RoundResultMainWnd@@6B@

; 3073 : }

  00006	e9 00 00 00 00	 jmp	 ??1RoundStateMainWnd@@UAE@XZ ; RoundStateMainWnd::~RoundStateMainWnd
??1RoundResultMainWnd@@UAE@XZ ENDP			; RoundResultMainWnd::~RoundResultMainWnd
_TEXT	ENDS
PUBLIC	?push_back@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXABURoundInfo@@@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::push_back
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?push_back@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXABURoundInfo@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXABURoundInfo@@@Z PROC ; std::vector<RoundInfo,std::allocator<RoundInfo> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  00006	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 2d		 jae	 SHORT $LN4@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 27		 ja	 SHORT $LN4@push_back

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx

; 980  : 			if (this->_Mylast == this->_Myend)

  00019	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001c	75 09		 jne	 SHORT $LN3@push_back

; 981  : 				_Reserve(1);

  0001e	6a 01		 push	 1
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?_Reserve@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IAEXI@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Reserve
$LN3@push_back:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  00027	83 e7 80	 and	 edi, -128		; ffffff80H
  0002a	03 3e		 add	 edi, DWORD PTR [esi]
  0002c	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  0002f	57		 push	 edi
  00030	ff 76 04	 push	 DWORD PTR [esi+4]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@URoundInfo@@@std@@URoundInfo@@AAU3@@std@@YAXAAV?$allocator@URoundInfo@@@0@PAURoundInfo@@AAU2@@Z ; std::_Cons_val<std::allocator<RoundInfo>,RoundInfo,RoundInfo &>
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 986  : 			++this->_Mylast;
; 987  : 			}
; 988  : 		else

  0003c	eb 19		 jmp	 SHORT $LN26@push_back
$LN4@push_back:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  0003e	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00041	75 09		 jne	 SHORT $LN1@push_back

; 991  : 				_Reserve(1);

  00043	6a 01		 push	 1
  00045	8b ce		 mov	 ecx, esi
  00047	e8 00 00 00 00	 call	 ?_Reserve@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@IAEXI@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::_Reserve
$LN1@push_back:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  0004c	57		 push	 edi
  0004d	ff 76 04	 push	 DWORD PTR [esi+4]
  00050	e8 00 00 00 00	 call	 ??$_Construct@URoundInfo@@ABU1@@std@@YAXPAURoundInfo@@ABU1@@Z ; std::_Construct<RoundInfo,RoundInfo const &>
  00055	59		 pop	 ecx
  00056	59		 pop	 ecx
$LN26@push_back:

; 996  : 			++this->_Mylast;

  00057	83 6e 04 80	 sub	 DWORD PTR [esi+4], -128	; ffffff80H
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  0005d	5d		 pop	 ebp
  0005e	c2 04 00	 ret	 4
?push_back@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXABURoundInfo@@@Z ENDP ; std::vector<RoundInfo,std::allocator<RoundInfo> >::push_back
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??_GRoundStateUserWnd@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GRoundStateUserWnd@@UAEPAXI@Z PROC			; RoundStateUserWnd::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1RoundStateUserWnd@@UAE@XZ ; RoundStateUserWnd::~RoundStateUserWnd
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 07		 je	 SHORT $LN1@scalar@5
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	59		 pop	 ecx
$LN1@scalar@5:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??_GRoundStateUserWnd@@UAEPAXI@Z ENDP			; RoundStateUserWnd::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?AddRoundInfo@RoundStateUserWnd@@QAEXABURoundInfo@@@Z ; RoundStateUserWnd::AddRoundInfo
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
;	COMDAT ?AddRoundInfo@RoundStateUserWnd@@QAEXABURoundInfo@@@Z
_TEXT	SEGMENT
_rkInfo$ = 8						; size = 4
?AddRoundInfo@RoundStateUserWnd@@QAEXABURoundInfo@@@Z PROC ; RoundStateUserWnd::AddRoundInfo, COMDAT
; _this$ = ecx

; 527  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 528  : 	m_RoundInfoList.push_back( rkInfo );

  00003	81 c1 98 02 00
	00		 add	 ecx, 664		; 00000298H

; 529  : }

  00009	5d		 pop	 ebp

; 528  : 	m_RoundInfoList.push_back( rkInfo );

  0000a	e9 00 00 00 00	 jmp	 ?push_back@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXABURoundInfo@@@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::push_back
?AddRoundInfo@RoundStateUserWnd@@QAEXABURoundInfo@@@Z ENDP ; RoundStateUserWnd::AddRoundInfo
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??_GRoundStateMainWnd@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GRoundStateMainWnd@@UAEPAXI@Z PROC			; RoundStateMainWnd::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1RoundStateMainWnd@@UAE@XZ ; RoundStateMainWnd::~RoundStateMainWnd
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 07		 je	 SHORT $LN1@scalar@6
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	59		 pop	 ecx
$LN1@scalar@6:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??_GRoundStateMainWnd@@UAEPAXI@Z ENDP			; RoundStateMainWnd::`scalar deleting destructor'
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?AddRoundInfo@RoundStateMainWnd@@UAEXABURoundInfo@@@Z
_TEXT	SEGMENT
_rkInfo$ = 8						; size = 4
?AddRoundInfo@RoundStateMainWnd@@UAEXABURoundInfo@@@Z PROC ; RoundStateMainWnd::AddRoundInfo, COMDAT
; _this$ = ecx

; 2336 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2337 : 	if( rkInfo.m_Team == TEAM_NONE ) 

  00003	8b 45 08	 mov	 eax, DWORD PTR _rkInfo$[ebp]
  00006	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0000a	74 0c		 je	 SHORT $LN2@AddRoundIn

; 2338 : 		return;
; 2339 : 
; 2340 : 	m_RoundInfoList.push_back( rkInfo );

  0000c	50		 push	 eax
  0000d	81 c1 64 01 00
	00		 add	 ecx, 356		; 00000164H
  00013	e8 00 00 00 00	 call	 ?push_back@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXABURoundInfo@@@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::push_back
$LN2@AddRoundIn:

; 2341 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?AddRoundInfo@RoundStateMainWnd@@UAEXABURoundInfo@@@Z ENDP ; RoundStateMainWnd::AddRoundInfo
_TEXT	ENDS
PUBLIC	??_R0?AVPlazaMainWnd@@@8			; PlazaMainWnd `RTTI Type Descriptor'
PUBLIC	??_C@_03LGOGDKEL@?5?$HM?5?$AA@			; `string'
PUBLIC	__real@3f59999a
PUBLIC	??_C@_0CB@GGGGOHHI@RoundStateMainWnd?3?3SetPlazaScore@ ; `string'
EXTRN	__imp_?ShowWnd@ioWnd@@QAEXXZ:PROC
EXTRN	?AddTextPiece@ioComplexStringPrinter@@QAEXMPBD0@Z:PROC ; ioComplexStringPrinter::AddTextPiece
EXTRN	__imp_?FindWnd@ioGUIManager@@QAEPAVioWnd@@K@Z:PROC
EXTRN	?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ:PROC ; ioComplexStringPrinter::AddTextPiece
EXTRN	?GetPlazaModeType@ioPlayStage@@QAE?AW4PlazaType@@XZ:PROC ; ioPlayStage::GetPlazaModeType
EXTRN	?SetTextColor@ioComplexStringPrinter@@QAEXK@Z:PROC ; ioComplexStringPrinter::SetTextColor
EXTRN	?SetBkColor@ioComplexStringPrinter@@QAEXHHH@Z:PROC ; ioComplexStringPrinter::SetBkColor
EXTRN	?SetTextStyle@ioComplexStringPrinter@@QAEXW4TextStyle@@@Z:PROC ; ioComplexStringPrinter::SetTextStyle
EXTRN	?ClearList@ioComplexStringPrinter@@QAEXXZ:PROC	; ioComplexStringPrinter::ClearList
;	COMDAT ??_R0?AVPlazaMainWnd@@@8
_DATA	SEGMENT
??_R0?AVPlazaMainWnd@@@8 DD FLAT:??_7type_info@@6B@	; PlazaMainWnd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVPlazaMainWnd@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_03LGOGDKEL@?5?$HM?5?$AA@
CONST	SEGMENT
??_C@_03LGOGDKEL@?5?$HM?5?$AA@ DB ' | ', 00H		; `string'
CONST	ENDS
;	COMDAT __real@3f59999a
CONST	SEGMENT
__real@3f59999a DD 03f59999ar			; 0.85
CONST	ENDS
;	COMDAT ??_C@_0CB@GGGGOHHI@RoundStateMainWnd?3?3SetPlazaScore@
CONST	SEGMENT
??_C@_0CB@GGGGOHHI@RoundStateMainWnd?3?3SetPlazaScore@ DB 'RoundStateMain'
	DB	'Wnd::SetPlazaScore', 00H			; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?SetPlazaScore@RoundStateMainWnd@@UAEXXZ
_TEXT	SEGMENT
$T570504 = -12						; size = 1
_pMainWnd$ = -12					; size = 4
tv340 = -8						; size = 4
tv473 = -4						; size = 4
?SetPlazaScore@RoundStateMainWnd@@UAEXXZ PROC		; RoundStateMainWnd::SetPlazaScore, COMDAT
; _this$ = ecx

; 2344 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 2345 : 	if( !m_pPlayStage ) return;

  0000a	33 db		 xor	 ebx, ebx
  0000c	39 9e 60 01 00
	00		 cmp	 DWORD PTR [esi+352], ebx
  00012	0f 84 25 02 00
	00		 je	 $LN6@SetPlazaSc

; 2346 : 	
; 2347 : 	HideChildWnd( ID_PLAZA_WND );

  00018	57		 push	 edi
  00019	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?HideChildWnd@ioWnd@@QAEXK_N@Z
  0001f	53		 push	 ebx
  00020	6a 02		 push	 2
  00022	ff d7		 call	 edi

; 2348 : 	HideChildWnd( ID_SINGLE_WND );

  00024	53		 push	 ebx
  00025	6a 03		 push	 3
  00027	8b ce		 mov	 ecx, esi
  00029	ff d7		 call	 edi

; 2349 : 	HideChildWnd( ID_BLUE_WND );

  0002b	53		 push	 ebx
  0002c	6a 04		 push	 4
  0002e	8b ce		 mov	 ecx, esi
  00030	ff d7		 call	 edi

; 2350 : 	HideChildWnd( ID_RED_WND );

  00032	53		 push	 ebx
  00033	6a 05		 push	 5
  00035	8b ce		 mov	 ecx, esi
  00037	ff d7		 call	 edi

; 2351 : 
; 2352 : 	std::sort( m_RoundInfoList.begin(), m_RoundInfoList.end(), RoundInfoKoSort() );

  00039	ff 75 f4	 push	 DWORD PTR $T570504[ebp]
  0003c	8b 86 68 01 00
	00		 mov	 eax, DWORD PTR [esi+360]
  00042	8b 8e 64 01 00
	00		 mov	 ecx, DWORD PTR [esi+356]
  00048	50		 push	 eax
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ??$sort@V?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@VRoundInfoKoSort@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@0@0VRoundInfoKoSort@@@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >,RoundInfoKoSort>

; 2353 : 	
; 2354 : 	// 타이틀
; 2355 : 	m_Title.ClearList();

  0004f	8d be 74 01 00
	00		 lea	 edi, DWORD PTR [esi+372]
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH
  00058	8b cf		 mov	 ecx, edi
  0005a	e8 00 00 00 00	 call	 ?ClearList@ioComplexStringPrinter@@QAEXXZ ; ioComplexStringPrinter::ClearList

; 2356 : 	m_Title.SetTextStyle( TS_OUTLINE_FULL_2X );

  0005f	6a 05		 push	 5
  00061	8b cf		 mov	 ecx, edi
  00063	e8 00 00 00 00	 call	 ?SetTextStyle@ioComplexStringPrinter@@QAEXW4TextStyle@@@Z ; ioComplexStringPrinter::SetTextStyle

; 2357 : 	m_Title.SetBkColor( 12, 66, 111 );

  00068	6a 6f		 push	 111			; 0000006fH
  0006a	6a 42		 push	 66			; 00000042H
  0006c	6a 0c		 push	 12			; 0000000cH
  0006e	8b cf		 mov	 ecx, edi
  00070	e8 00 00 00 00	 call	 ?SetBkColor@ioComplexStringPrinter@@QAEXHHH@Z ; ioComplexStringPrinter::SetBkColor

; 2358 : 	m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  00075	6a ff		 push	 -1
  00077	8b cf		 mov	 ecx, edi
  00079	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2359 : 	if( m_pPlayStage->GetPlazaModeType() == PT_BATTLE )

  0007e	8b 8e 60 01 00
	00		 mov	 ecx, DWORD PTR [esi+352]
  00084	e8 00 00 00 00	 call	 ?GetPlazaModeType@ioPlayStage@@QAE?AW4PlazaType@@XZ ; ioPlayStage::GetPlazaModeType
  00089	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0008f	83 f8 01	 cmp	 eax, 1
  00092	75 06		 jne	 SHORT $LN14@SetPlazaSc

; 2360 : 		m_Title.AddTextPiece( FONT_SIZE_17, STR(1) );

  00094	6a 00		 push	 0
  00096	6a 01		 push	 1
  00098	eb 28		 jmp	 SHORT $LN58@SetPlazaSc
$LN14@SetPlazaSc:

; 2361 : 	else if( m_pPlayStage->GetPlazaModeType() == PT_COMMUNITY )

  0009a	8b 8e 60 01 00
	00		 mov	 ecx, DWORD PTR [esi+352]
  000a0	e8 00 00 00 00	 call	 ?GetPlazaModeType@ioPlayStage@@QAE?AW4PlazaType@@XZ ; ioPlayStage::GetPlazaModeType
  000a5	83 f8 02	 cmp	 eax, 2
  000a8	75 05		 jne	 SHORT $LN12@SetPlazaSc

; 2362 : 		m_Title.AddTextPiece( FONT_SIZE_17, STR(2) );

  000aa	6a 00		 push	 0
  000ac	50		 push	 eax
  000ad	eb 13		 jmp	 SHORT $LN58@SetPlazaSc
$LN12@SetPlazaSc:

; 2363 : 	else if( m_pPlayStage->GetPlazaModeType() == PT_GUILD )

  000af	8b 8e 60 01 00
	00		 mov	 ecx, DWORD PTR [esi+352]
  000b5	e8 00 00 00 00	 call	 ?GetPlazaModeType@ioPlayStage@@QAE?AW4PlazaType@@XZ ; ioPlayStage::GetPlazaModeType
  000ba	83 f8 03	 cmp	 eax, 3
  000bd	75 2f		 jne	 SHORT $LN10@SetPlazaSc

; 2364 : 		m_Title.AddTextPiece( FONT_SIZE_17, STR(3) );

  000bf	6a 00		 push	 0
  000c1	50		 push	 eax
$LN58@SetPlazaSc:
  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  000c7	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@GGGGOHHI@RoundStateMainWnd?3?3SetPlazaScore@
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  000d2	8b c8		 mov	 ecx, eax
  000d4	ff d3		 call	 ebx
  000d6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  000de	50		 push	 eax
  000df	51		 push	 ecx
  000e0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e5	57		 push	 edi
  000e6	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  000eb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@SetPlazaSc:

; 2365 : 	m_Title.SetTextColor( TCT_DEFAULT_LIGHTGRAY );

  000ee	68 a7 a7 a7 ff	 push	 -5789785		; ffa7a7a7H
  000f3	8b cf		 mov	 ecx, edi
  000f5	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2366 : 	m_Title.AddTextPiece( FONT_SIZE_17, " | " );

  000fa	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  00102	68 00 00 00 00	 push	 OFFSET ??_C@_03LGOGDKEL@?5?$HM?5?$AA@
  00107	51		 push	 ecx
  00108	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0010d	57		 push	 edi
  0010e	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  00113	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2367 : 
; 2368 : 	m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  00116	6a ff		 push	 -1
  00118	8b cf		 mov	 ecx, edi
  0011a	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2369 : 	PlazaMainWnd *pMainWnd = dynamic_cast<PlazaMainWnd*>(g_GUIMgr.FindWnd( PLAZA_MAIN_WND ));

  0011f	6a 00		 push	 0
  00121	68 00 00 00 00	 push	 OFFSET ??_R0?AVPlazaMainWnd@@@8
  00126	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWnd@@@8
  0012b	6a 00		 push	 0
  0012d	68 91 17 00 00	 push	 6033			; 00001791H
  00132	e8 00 00 00 00	 call	 ?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ ; ioSP2GUIManager::GetSingleton
  00137	8b c8		 mov	 ecx, eax
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?FindWnd@ioGUIManager@@QAEPAVioWnd@@K@Z
  0013f	50		 push	 eax
  00140	e8 00 00 00 00	 call	 ___RTDynamicCast
  00145	83 c4 14	 add	 esp, 20			; 00000014H
  00148	89 45 f4	 mov	 DWORD PTR _pMainWnd$[ebp], eax

; 2370 : 	if( !pMainWnd ) return;

  0014b	85 c0		 test	 eax, eax
  0014d	0f 84 e9 00 00
	00		 je	 $LN57@SetPlazaSc

; 2371 :     
; 2372 : 	if( pMainWnd->IsRoomPW() )

  00153	80 b8 08 02 00
	00 00		 cmp	 BYTE PTR [eax+520], 0

; 2373 : 		m_Title.AddTextPiece( FONT_SIZE_17, STR(4), pMainWnd->GetPlazaName().c_str() );

  0015a	8d 88 ac 01 00
	00		 lea	 ecx, DWORD PTR [eax+428]
  00160	74 0d		 je	 SHORT $LN8@SetPlazaSc
  00162	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00168	50		 push	 eax
  00169	6a 00		 push	 0
  0016b	6a 04		 push	 4

; 2374 : 	else

  0016d	eb 0b		 jmp	 SHORT $LN59@SetPlazaSc
$LN8@SetPlazaSc:

; 2375 : 		m_Title.AddTextPiece( FONT_SIZE_17, STR(5), pMainWnd->GetPlazaName().c_str() );		

  0016f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00175	50		 push	 eax
  00176	6a 00		 push	 0
  00178	6a 05		 push	 5
$LN59@SetPlazaSc:
  0017a	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0017f	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@GGGGOHHI@RoundStateMainWnd?3?3SetPlazaScore@
  00184	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  0018a	8b c8		 mov	 ecx, eax
  0018c	ff d3		 call	 ebx
  0018e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  00196	50		 push	 eax
  00197	51		 push	 ecx
  00198	8b cf		 mov	 ecx, edi
  0019a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0019f	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAEXMPBD0@Z ; ioComplexStringPrinter::AddTextPiece

; 2376 : 
; 2377 : 	// 윈도우 세팅
; 2378 : 	RoundStateUserWnd *pPlazaWnd = dynamic_cast<RoundStateUserWnd *>(FindChildWnd( ID_PLAZA_WND ));

  001a4	6a 00		 push	 0
  001a6	68 00 00 00 00	 push	 OFFSET ??_R0?AVRoundStateUserWnd@@@8
  001ab	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWnd@@@8
  001b0	6a 00		 push	 0
  001b2	6a 02		 push	 2
  001b4	8b ce		 mov	 ecx, esi
  001b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?FindChildWnd@ioWnd@@QAEPAV1@K@Z
  001bc	50		 push	 eax
  001bd	e8 00 00 00 00	 call	 ___RTDynamicCast
  001c2	8b f8		 mov	 edi, eax
  001c4	83 c4 14	 add	 esp, 20			; 00000014H

; 2379 : 	if( pPlazaWnd )

  001c7	85 ff		 test	 edi, edi
  001c9	74 71		 je	 SHORT $LN57@SetPlazaSc

; 2380 : 	{
; 2381 : 		int iUserSize = m_RoundInfoList.size();

  001cb	8b 86 68 01 00
	00		 mov	 eax, DWORD PTR [esi+360]
  001d1	2b 86 64 01 00
	00		 sub	 eax, DWORD PTR [esi+356]
  001d7	c1 f8 07	 sar	 eax, 7

; 2382 : 		for(int i = 0;i < iUserSize;i++)

  001da	85 c0		 test	 eax, eax
  001dc	7e 31		 jle	 SHORT $LN3@SetPlazaSc

; 2380 : 	{
; 2381 : 		int iUserSize = m_RoundInfoList.size();

  001de	83 65 fc 00	 and	 DWORD PTR tv473[ebp], 0
  001e2	89 45 f8	 mov	 DWORD PTR tv340[ebp], eax
$LL56@SetPlazaSc:

; 2382 : 		for(int i = 0;i < iUserSize;i++)

  001e5	8b 86 64 01 00
	00		 mov	 eax, DWORD PTR [esi+356]
  001eb	03 45 fc	 add	 eax, DWORD PTR tv473[ebp]

; 2383 : 		{
; 2384 : 			RoundInfo &rkInfo = m_RoundInfoList[i];
; 2385 : 
; 2386 : 			// 자신은 블루 
; 2387 : 			if( rkInfo.m_bOwner )

  001ee	33 c9		 xor	 ecx, ecx
  001f0	38 48 54	 cmp	 BYTE PTR [eax+84], cl

; 2388 : 				rkInfo.m_Team = TEAM_BLUE;
; 2389 : 			else
; 2390 : 				rkInfo.m_Team = TEAM_RED;
; 2391 : 			pPlazaWnd->AddRoundInfo( rkInfo );

  001f3	50		 push	 eax
  001f4	0f 95 c1	 setne	 cl
  001f7	41		 inc	 ecx
  001f8	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  001fb	8d 8f 98 02 00
	00		 lea	 ecx, DWORD PTR [edi+664]
  00201	e8 00 00 00 00	 call	 ?push_back@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXABURoundInfo@@@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::push_back
  00206	83 6d fc 80	 sub	 DWORD PTR tv473[ebp], -128 ; ffffff80H
  0020a	ff 4d f8	 dec	 DWORD PTR tv340[ebp]
  0020d	75 d6		 jne	 SHORT $LL56@SetPlazaSc
$LN3@SetPlazaSc:

; 2392 : 		}
; 2393 : 		pPlazaWnd->SetPlayStage( m_pPlayStage );

  0020f	8b 86 60 01 00
	00		 mov	 eax, DWORD PTR [esi+352]
  00215	89 87 94 02 00
	00		 mov	 DWORD PTR [edi+660], eax

; 2394 : 		pPlazaWnd->SetWindowTeam( TEAM_RED );
; 2395 : 		pPlazaWnd->SetPlazaScore( pMainWnd->GetMaxUserCount() );

  0021b	8b 45 f4	 mov	 eax, DWORD PTR _pMainWnd$[ebp]
  0021e	c7 87 58 02 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+600], 1
  00228	8b 80 00 02 00
	00		 mov	 eax, DWORD PTR [eax+512]

; 2396 : 		pPlazaWnd->ShowWnd();

  0022e	8b cf		 mov	 ecx, edi
  00230	89 87 60 02 00
	00		 mov	 DWORD PTR [edi+608], eax
  00236	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ShowWnd@ioWnd@@QAEXXZ
$LN57@SetPlazaSc:
  0023c	5f		 pop	 edi
$LN6@SetPlazaSc:
  0023d	5e		 pop	 esi
  0023e	5b		 pop	 ebx

; 2397 : 	}
; 2398 : }

  0023f	c9		 leave
  00240	c3		 ret	 0
?SetPlazaScore@RoundStateMainWnd@@UAEXXZ ENDP		; RoundStateMainWnd::SetPlazaScore
_TEXT	ENDS
PUBLIC	??_C@_0CJ@JLNCDIGF@RoundStateMainWnd?3?3SetHeadequart@ ; `string'
;	COMDAT ??_C@_0CJ@JLNCDIGF@RoundStateMainWnd?3?3SetHeadequart@
CONST	SEGMENT
??_C@_0CJ@JLNCDIGF@RoundStateMainWnd?3?3SetHeadequart@ DB 'RoundStateMain'
	DB	'Wnd::SetHeadequartersScore', 00H		; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?SetHeadequartersScore@RoundStateMainWnd@@UAEXXZ
_TEXT	SEGMENT
tv232 = -8						; size = 4
$T570601 = -8						; size = 1
tv442 = -4						; size = 4
?SetHeadequartersScore@RoundStateMainWnd@@UAEXXZ PROC	; RoundStateMainWnd::SetHeadequartersScore, COMDAT
; _this$ = ecx

; 2401 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx

; 2402 : 	if( !m_pPlayStage ) return;

  00009	33 db		 xor	 ebx, ebx
  0000b	39 9f 60 01 00
	00		 cmp	 DWORD PTR [edi+352], ebx
  00011	0f 84 2c 02 00
	00		 je	 $LN6@SetHeadequ

; 2403 : 
; 2404 : 	HideChildWnd( ID_PLAZA_WND );

  00017	56		 push	 esi
  00018	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?HideChildWnd@ioWnd@@QAEXK_N@Z
  0001e	53		 push	 ebx
  0001f	6a 02		 push	 2
  00021	ff d6		 call	 esi

; 2405 : 	HideChildWnd( ID_SINGLE_WND );

  00023	53		 push	 ebx
  00024	6a 03		 push	 3
  00026	8b cf		 mov	 ecx, edi
  00028	ff d6		 call	 esi

; 2406 : 	HideChildWnd( ID_BLUE_WND );

  0002a	53		 push	 ebx
  0002b	6a 04		 push	 4
  0002d	8b cf		 mov	 ecx, edi
  0002f	ff d6		 call	 esi

; 2407 : 	HideChildWnd( ID_RED_WND );

  00031	53		 push	 ebx
  00032	6a 05		 push	 5
  00034	8b cf		 mov	 ecx, edi
  00036	ff d6		 call	 esi

; 2408 : 
; 2409 : 	std::sort( m_RoundInfoList.begin(), m_RoundInfoList.end(), RoundInfoKoSort() );

  00038	ff 75 f8	 push	 DWORD PTR $T570601[ebp]
  0003b	8b 87 68 01 00
	00		 mov	 eax, DWORD PTR [edi+360]
  00041	8b 8f 64 01 00
	00		 mov	 ecx, DWORD PTR [edi+356]
  00047	50		 push	 eax
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??$sort@V?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@VRoundInfoKoSort@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@0@0VRoundInfoKoSort@@@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >,RoundInfoKoSort>

; 2410 : 
; 2411 : 	// 타이틀
; 2412 : 	m_Title.ClearList();

  0004e	8d b7 74 01 00
	00		 lea	 esi, DWORD PTR [edi+372]
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
  00057	8b ce		 mov	 ecx, esi
  00059	e8 00 00 00 00	 call	 ?ClearList@ioComplexStringPrinter@@QAEXXZ ; ioComplexStringPrinter::ClearList

; 2413 : 	m_Title.SetTextStyle( TS_OUTLINE_FULL_2X );

  0005e	6a 05		 push	 5
  00060	8b ce		 mov	 ecx, esi
  00062	e8 00 00 00 00	 call	 ?SetTextStyle@ioComplexStringPrinter@@QAEXW4TextStyle@@@Z ; ioComplexStringPrinter::SetTextStyle

; 2414 : 	m_Title.SetBkColor( 12, 66, 111 );

  00067	6a 6f		 push	 111			; 0000006fH
  00069	6a 42		 push	 66			; 00000042H
  0006b	6a 0c		 push	 12			; 0000000cH
  0006d	8b ce		 mov	 ecx, esi
  0006f	e8 00 00 00 00	 call	 ?SetBkColor@ioComplexStringPrinter@@QAEXHHH@Z ; ioComplexStringPrinter::SetBkColor

; 2415 : 	m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  00074	6a ff		 push	 -1
  00076	8b ce		 mov	 ecx, esi
  00078	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2416 : 
; 2417 : 	if( m_pPlayStage->GetPlayMode()->GetModeType() == MT_HEADQUARTERS )

  0007d	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  00082	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  00085	75 1f		 jne	 SHORT $LN16@SetHeadequ

; 2418 : 		m_Title.AddTextPiece( FONT_SIZE_17, STR(1) );

  00087	53		 push	 ebx
  00088	6a 01		 push	 1
$LN70@SetHeadequ:
  0008a	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0008f	53		 push	 ebx
  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@JLNCDIGF@RoundStateMainWnd?3?3SetHeadequart@
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  0009b	8b c8		 mov	 ecx, eax
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  000a3	50		 push	 eax

; 2419 : 	else if( m_pPlayStage->GetPlayMode()->GetModeType() == MT_HOUSE )

  000a4	eb 15		 jmp	 SHORT $LN69@SetHeadequ
$LN16@SetHeadequ:
  000a6	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  000ab	83 f8 17	 cmp	 eax, 23			; 00000017H
  000ae	75 05		 jne	 SHORT $LN14@SetHeadequ

; 2420 : 		m_Title.AddTextPiece( FONT_SIZE_17, STR(2) );

  000b0	53		 push	 ebx
  000b1	6a 02		 push	 2

; 2421 : 	else

  000b3	eb d5		 jmp	 SHORT $LN70@SetHeadequ
$LN14@SetHeadequ:

; 2422 : 		m_Title.AddTextPiece( FONT_SIZE_17, "" );

  000b5	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  000ba	53		 push	 ebx
$LN69@SetHeadequ:
  000bb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  000c3	51		 push	 ecx
  000c4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c9	56		 push	 esi
  000ca	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  000cf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2423 : 
; 2424 : 	m_Title.SetTextColor( TCT_DEFAULT_LIGHTGRAY );

  000d2	68 a7 a7 a7 ff	 push	 -5789785		; ffa7a7a7H
  000d7	8b ce		 mov	 ecx, esi
  000d9	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2425 : 	m_Title.AddTextPiece( FONT_SIZE_17, " | " );

  000de	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  000e6	68 00 00 00 00	 push	 OFFSET ??_C@_03LGOGDKEL@?5?$HM?5?$AA@
  000eb	51		 push	 ecx
  000ec	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f1	56		 push	 esi
  000f2	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  000f7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2426 : 	m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  000fa	6a ff		 push	 -1
  000fc	8b ce		 mov	 ecx, esi
  000fe	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2427 : 
; 2428 : 	if( m_pPlayStage->GetPlayMode()->GetModeType() == MT_HEADQUARTERS )

  00103	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  00108	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  0010b	75 2d		 jne	 SHORT $LN12@SetHeadequ

; 2429 : 	{
; 2430 : 		ioHeadquartersMode *pHeadquartersMode = ToHeadquartersMode( m_pPlayStage->GetPlayMode() );

  0010d	8b 87 60 01 00
	00		 mov	 eax, DWORD PTR [edi+352]
  00113	ff b0 10 01 00
	00		 push	 DWORD PTR [eax+272]
  00119	e8 00 00 00 00	 call	 ?ToHeadquartersMode@@YAPAVioHeadquartersMode@@PAVioPlayMode@@@Z ; ToHeadquartersMode
  0011e	59		 pop	 ecx

; 2431 : 		if( pHeadquartersMode )

  0011f	85 c0		 test	 eax, eax
  00121	0f 84 88 00 00
	00		 je	 $LN66@SetHeadequ

; 2432 : 		{
; 2433 : 			m_Title.AddTextPiece( FONT_SIZE_17, STR(3), pHeadquartersMode->GetMasterName().c_str() );

  00127	8d 88 f4 04 00
	00		 lea	 ecx, DWORD PTR [eax+1268]
  0012d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00133	50		 push	 eax
  00134	6a 00		 push	 0
  00136	6a 03		 push	 3

; 2434 : 		}
; 2435 : 	}
; 2436 : 	else if( m_pPlayStage->GetPlayMode()->GetModeType() == MT_HOUSE )

  00138	eb 31		 jmp	 SHORT $LN71@SetHeadequ
$LN12@SetHeadequ:
  0013a	e8 00 00 00 00	 call	 ?GetModeType@ioPlayMode@@SA?AW4ModeType@@XZ ; ioPlayMode::GetModeType
  0013f	83 f8 17	 cmp	 eax, 23			; 00000017H
  00142	75 53		 jne	 SHORT $LN9@SetHeadequ

; 2437 : 	{
; 2438 : 		ioHouseMode *pHouse = ToHouseMode( m_pPlayStage->GetPlayMode() );

  00144	8b 87 60 01 00
	00		 mov	 eax, DWORD PTR [edi+352]
  0014a	ff b0 10 01 00
	00		 push	 DWORD PTR [eax+272]
  00150	e8 00 00 00 00	 call	 ?ToHouseMode@@YAPAVioHouseMode@@PAVioPlayMode@@@Z ; ToHouseMode
  00155	59		 pop	 ecx

; 2439 : 		if( pHouse )

  00156	85 c0		 test	 eax, eax
  00158	74 55		 je	 SHORT $LN66@SetHeadequ

; 2440 : 		{
; 2441 : 			m_Title.AddTextPiece( FONT_SIZE_17, STR(4), pHouse->GetMasterName().c_str() );

  0015a	8d 88 f4 04 00
	00		 lea	 ecx, DWORD PTR [eax+1268]
  00160	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00166	50		 push	 eax
  00167	6a 00		 push	 0
  00169	6a 04		 push	 4
$LN71@SetHeadequ:
  0016b	53		 push	 ebx
  0016c	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@JLNCDIGF@RoundStateMainWnd?3?3SetHeadequart@
  00171	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00177	8b c8		 mov	 ecx, eax
  00179	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0017f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  00187	50		 push	 eax
  00188	51		 push	 ecx
  00189	8b ce		 mov	 ecx, esi
  0018b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00190	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAEXMPBD0@Z ; ioComplexStringPrinter::AddTextPiece

; 2442 : 		}
; 2443 : 	}
; 2444 : 	else

  00195	eb 18		 jmp	 SHORT $LN66@SetHeadequ
$LN9@SetHeadequ:

; 2445 : 	{
; 2446 : 		m_Title.AddTextPiece( FONT_SIZE_17, "" );

  00197	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  0019f	53		 push	 ebx
  001a0	51		 push	 ecx
  001a1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001a6	56		 push	 esi
  001a7	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  001ac	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN66@SetHeadequ:

; 2447 : 	}	
; 2448 : 
; 2449 : 	// 윈도우 세팅
; 2450 : 	RoundStateUserWnd *pPlazaWnd = dynamic_cast<RoundStateUserWnd *>(FindChildWnd( ID_PLAZA_WND ));

  001af	6a 00		 push	 0
  001b1	68 00 00 00 00	 push	 OFFSET ??_R0?AVRoundStateUserWnd@@@8
  001b6	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWnd@@@8
  001bb	6a 00		 push	 0
  001bd	6a 02		 push	 2
  001bf	8b cf		 mov	 ecx, edi
  001c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?FindChildWnd@ioWnd@@QAEPAV1@K@Z
  001c7	50		 push	 eax
  001c8	e8 00 00 00 00	 call	 ___RTDynamicCast
  001cd	8b f0		 mov	 esi, eax
  001cf	83 c4 14	 add	 esp, 20			; 00000014H

; 2451 : 	if( pPlazaWnd )

  001d2	85 f6		 test	 esi, esi
  001d4	74 6c		 je	 SHORT $LN68@SetHeadequ

; 2452 : 	{
; 2453 : 		int iUserSize = m_RoundInfoList.size();

  001d6	8b 87 68 01 00
	00		 mov	 eax, DWORD PTR [edi+360]
  001dc	2b 87 64 01 00
	00		 sub	 eax, DWORD PTR [edi+356]
  001e2	c1 f8 07	 sar	 eax, 7

; 2454 : 		for(int i = 0;i < iUserSize;i++)

  001e5	85 c0		 test	 eax, eax
  001e7	7e 31		 jle	 SHORT $LN3@SetHeadequ

; 2452 : 	{
; 2453 : 		int iUserSize = m_RoundInfoList.size();

  001e9	83 65 fc 00	 and	 DWORD PTR tv442[ebp], 0
  001ed	89 45 f8	 mov	 DWORD PTR tv232[ebp], eax
$LL67@SetHeadequ:

; 2454 : 		for(int i = 0;i < iUserSize;i++)

  001f0	8b 87 64 01 00
	00		 mov	 eax, DWORD PTR [edi+356]
  001f6	03 45 fc	 add	 eax, DWORD PTR tv442[ebp]

; 2455 : 		{
; 2456 : 			RoundInfo &rkInfo = m_RoundInfoList[i];
; 2457 : 
; 2458 : 			// 자신은 블루 
; 2459 : 			if( rkInfo.m_bOwner )

  001f9	33 c9		 xor	 ecx, ecx
  001fb	38 48 54	 cmp	 BYTE PTR [eax+84], cl

; 2460 : 				rkInfo.m_Team = TEAM_BLUE;
; 2461 : 			else
; 2462 : 				rkInfo.m_Team = TEAM_RED;
; 2463 : 			pPlazaWnd->AddRoundInfo( rkInfo );

  001fe	50		 push	 eax
  001ff	0f 95 c1	 setne	 cl
  00202	41		 inc	 ecx
  00203	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00206	8d 8e 98 02 00
	00		 lea	 ecx, DWORD PTR [esi+664]
  0020c	e8 00 00 00 00	 call	 ?push_back@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXABURoundInfo@@@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::push_back
  00211	83 6d fc 80	 sub	 DWORD PTR tv442[ebp], -128 ; ffffff80H
  00215	ff 4d f8	 dec	 DWORD PTR tv232[ebp]
  00218	75 d6		 jne	 SHORT $LL67@SetHeadequ
$LN3@SetHeadequ:

; 2464 : 		}
; 2465 : 		pPlazaWnd->SetPlayStage( m_pPlayStage );

  0021a	8b 87 60 01 00
	00		 mov	 eax, DWORD PTR [edi+352]

; 2466 : 		pPlazaWnd->SetWindowTeam( TEAM_RED );
; 2467 : 		pPlazaWnd->SetHeadequartersScore( MAX_PLAYER / 2 );
; 2468 : 		pPlazaWnd->ShowWnd();

  00220	8b ce		 mov	 ecx, esi
  00222	89 86 94 02 00
	00		 mov	 DWORD PTR [esi+660], eax
  00228	c7 86 58 02 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+600], 1
  00232	c7 86 60 02 00
	00 08 00 00 00	 mov	 DWORD PTR [esi+608], 8
  0023c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ShowWnd@ioWnd@@QAEXXZ
$LN68@SetHeadequ:
  00242	5e		 pop	 esi
$LN6@SetHeadequ:
  00243	5f		 pop	 edi
  00244	5b		 pop	 ebx

; 2469 : 	}
; 2470 : }

  00245	c9		 leave
  00246	c3		 ret	 0
?SetHeadequartersScore@RoundStateMainWnd@@UAEXXZ ENDP	; RoundStateMainWnd::SetHeadequartersScore
_TEXT	ENDS
PUBLIC	??_C@_0CC@MGFJNFLA@RoundStateMainWnd?3?3SetSingleScor@ ; `string'
EXTRN	?AddTextPiece@ioComplexStringPrinter@@QAEXMPBDH@Z:PROC ; ioComplexStringPrinter::AddTextPiece
;	COMDAT ??_C@_0CC@MGFJNFLA@RoundStateMainWnd?3?3SetSingleScor@
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobattleroommgr.h
CONST	SEGMENT
??_C@_0CC@MGFJNFLA@RoundStateMainWnd?3?3SetSingleScor@ DB 'RoundStateMain'
	DB	'Wnd::SetSingleScore', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetSingleScore@RoundStateMainWnd@@UAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetSingleScore@RoundStateMainWnd@@UAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SetSingleScore@RoundStateMainWnd@@UAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SetSingleScore@RoundStateMainWnd@@UAEXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SetSingleScore@RoundStateMainWnd@@UAEXXZ$3
__ehfuncinfo$?SetSingleScore@RoundStateMainWnd@@UAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetSingleScore@RoundStateMainWnd@@UAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
xdata$x	ENDS
;	COMDAT ?SetSingleScore@RoundStateMainWnd@@UAEXXZ
_TEXT	SEGMENT
$T570717 = -56						; size = 16
$T570716 = -40						; size = 16
$T570715 = -40						; size = 16
$T570713 = -40						; size = 16
tv437 = -24						; size = 4
$T570710 = -24						; size = 1
tv574 = -20						; size = 4
$T570714 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?SetSingleScore@RoundStateMainWnd@@UAEXXZ PROC		; RoundStateMainWnd::SetSingleScore, COMDAT
; _this$ = ecx

; 2473 : {

  00000	6a 2c		 push	 44			; 0000002cH
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetSingleScore@RoundStateMainWnd@@UAEXXZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b d9		 mov	 ebx, ecx

; 2474 : 	if( !m_pPlayStage ) return;

  0000e	33 ff		 xor	 edi, edi
  00010	39 bb 60 01 00
	00		 cmp	 DWORD PTR [ebx+352], edi
  00016	0f 84 7e 04 00
	00		 je	 $LN6@SetSingleS@2

; 2475 : 
; 2476 : 	HideChildWnd( ID_PLAZA_WND );

  0001c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?HideChildWnd@ioWnd@@QAEXK_N@Z
  00022	57		 push	 edi
  00023	6a 02		 push	 2
  00025	ff d6		 call	 esi

; 2477 : 	HideChildWnd( ID_SINGLE_WND );

  00027	57		 push	 edi
  00028	6a 03		 push	 3
  0002a	8b cb		 mov	 ecx, ebx
  0002c	ff d6		 call	 esi

; 2478 : 	HideChildWnd( ID_BLUE_WND );

  0002e	57		 push	 edi
  0002f	6a 04		 push	 4
  00031	8b cb		 mov	 ecx, ebx
  00033	ff d6		 call	 esi

; 2479 : 	HideChildWnd( ID_RED_WND );

  00035	57		 push	 edi
  00036	6a 05		 push	 5
  00038	8b cb		 mov	 ecx, ebx
  0003a	ff d6		 call	 esi

; 2480 : 
; 2481 : 	std::sort( m_RoundInfoList.begin(), m_RoundInfoList.end(), RoundInfoSort() );

  0003c	ff 75 e8	 push	 DWORD PTR $T570710[ebp]
  0003f	8b 83 68 01 00
	00		 mov	 eax, DWORD PTR [ebx+360]
  00045	8b 8b 64 01 00
	00		 mov	 ecx, DWORD PTR [ebx+356]
  0004b	50		 push	 eax
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$sort@V?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@VRoundInfoSort@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@0@0VRoundInfoSort@@@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >,RoundInfoSort>
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2482 : 
; 2483 : 	if( g_BattleRoomMgr.IsTournamentModeType() )

  00055	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  0005a	8b c8		 mov	 ecx, eax
  0005c	e8 00 00 00 00	 call	 ?IsTournamentModeType@ioBattleRoomMgr@@QAE_NXZ ; ioBattleRoomMgr::IsTournamentModeType
  00061	84 c0		 test	 al, al
  00063	0f 84 1d 01 00
	00		 je	 $LN14@SetSingleS@2

; 2484 : 	{
; 2485 : 		SetTournamentData();

  00069	8b cb		 mov	 ecx, ebx
  0006b	e8 00 00 00 00	 call	 ?SetTournamentData@RoundStateMainWnd@@QAEXXZ ; RoundStateMainWnd::SetTournamentData

; 2486 : 
; 2487 : 		// 타이틀
; 2488 : 		m_Title.ClearList();

  00070	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00076	e8 00 00 00 00	 call	 ?ClearList@ioComplexStringPrinter@@QAEXXZ ; ioComplexStringPrinter::ClearList

; 2489 : 		m_Title.SetTextStyle( TS_OUTLINE_FULL_2X );

  0007b	6a 05		 push	 5
  0007d	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00083	e8 00 00 00 00	 call	 ?SetTextStyle@ioComplexStringPrinter@@QAEXW4TextStyle@@@Z ; ioComplexStringPrinter::SetTextStyle

; 2490 : 		m_Title.SetBkColor( 12, 66, 111 );

  00088	6a 6f		 push	 111			; 0000006fH
  0008a	6a 42		 push	 66			; 00000042H
  0008c	6a 0c		 push	 12			; 0000000cH
  0008e	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00094	e8 00 00 00 00	 call	 ?SetBkColor@ioComplexStringPrinter@@QAEXHHH@Z ; ioComplexStringPrinter::SetBkColor

; 2491 : 		m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  00099	6a ff		 push	 -1
  0009b	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  000a1	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2492 : 		m_Title.AddTextPiece( FONT_SIZE_17, STR(1) );

  000a6	57		 push	 edi
  000a7	6a 01		 push	 1
  000a9	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
  000ae	57		 push	 edi
  000af	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0CC@MGFJNFLA@RoundStateMainWnd?3?3SetSingleScor@
  000b4	56		 push	 esi
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  000bb	8b c8		 mov	 ecx, eax
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  000c3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  000cb	50		 push	 eax
  000cc	51		 push	 ecx
  000cd	8d 83 74 01 00
	00		 lea	 eax, DWORD PTR [ebx+372]
  000d3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece

; 2493 : 		m_Title.AddTextPiece( FONT_SIZE_17, " | " );

  000de	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  000e6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_03LGOGDKEL@?5?$HM?5?$AA@
  000ee	51		 push	 ecx
  000ef	8d 83 74 01 00
	00		 lea	 eax, DWORD PTR [ebx+372]
  000f5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  00100	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2494 : 		m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  00103	6a ff		 push	 -1
  00105	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  0010b	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2495 : 
; 2496 : 		if( m_iTournamentCurrentRound  <= 2 )

  00110	8b 83 94 01 00
	00		 mov	 eax, DWORD PTR [ebx+404]
  00116	83 f8 02	 cmp	 eax, 2
  00119	7f 37		 jg	 SHORT $LN13@SetSingleS@2

; 2497 : 		{
; 2498 : 			m_Title.AddTextPiece( FONT_SIZE_17, STR(4) );

  0011b	6a 00		 push	 0
  0011d	6a 04		 push	 4
  0011f	57		 push	 edi
  00120	56		 push	 esi
  00121	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00127	8b c8		 mov	 ecx, eax
  00129	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0012f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  00137	50		 push	 eax
  00138	51		 push	 ecx
  00139	8d 83 74 01 00
	00		 lea	 eax, DWORD PTR [ebx+372]
  0013f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00144	50		 push	 eax
  00145	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  0014a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2499 : 		}
; 2500 : 		else

  0014d	e9 ae 02 00 00	 jmp	 $LN7@SetSingleS@2
$LN13@SetSingleS@2:

; 2501 : 		{
; 2502 : 			m_Title.AddTextPiece( FONT_SIZE_17, STR(5), m_iTournamentCurrentRound );

  00152	50		 push	 eax
  00153	6a 00		 push	 0
  00155	6a 05		 push	 5
  00157	57		 push	 edi
  00158	56		 push	 esi
  00159	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  0015f	8b c8		 mov	 ecx, eax
  00161	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  00167	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  0016f	50		 push	 eax
  00170	51		 push	 ecx
  00171	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00177	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0017c	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAEXMPBDH@Z ; ioComplexStringPrinter::AddTextPiece

; 2503 : 		}

  00181	e9 7a 02 00 00	 jmp	 $LN7@SetSingleS@2
$LN14@SetSingleS@2:

; 2504 : 	}
; 2505 : 	else if( g_ShuffleRoomMgr.IsShuffleRoom() )

  00186	e8 00 00 00 00	 call	 ?GetSingleton@ioShuffleRoomMgr@@SAAAV1@XZ ; ioShuffleRoomMgr::GetSingleton
  0018b	8b c8		 mov	 ecx, eax
  0018d	e8 00 00 00 00	 call	 ?IsShuffleRoom@ioShuffleRoomMgr@@QAE_NXZ ; ioShuffleRoomMgr::IsShuffleRoom

; 2506 : 	{
; 2507 : 		// 타이틀
; 2508 : 		m_Title.ClearList();

  00192	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00198	84 c0		 test	 al, al
  0019a	0f 84 fd 00 00
	00		 je	 $LN10@SetSingleS@2
  001a0	e8 00 00 00 00	 call	 ?ClearList@ioComplexStringPrinter@@QAEXXZ ; ioComplexStringPrinter::ClearList

; 2509 : 		m_Title.SetTextStyle( TS_OUTLINE_FULL_2X );

  001a5	6a 05		 push	 5
  001a7	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  001ad	e8 00 00 00 00	 call	 ?SetTextStyle@ioComplexStringPrinter@@QAEXW4TextStyle@@@Z ; ioComplexStringPrinter::SetTextStyle

; 2510 : 		m_Title.SetBkColor( 12, 66, 111 );

  001b2	6a 6f		 push	 111			; 0000006fH
  001b4	6a 42		 push	 66			; 00000042H
  001b6	6a 0c		 push	 12			; 0000000cH
  001b8	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  001be	e8 00 00 00 00	 call	 ?SetBkColor@ioComplexStringPrinter@@QAEXHHH@Z ; ioComplexStringPrinter::SetBkColor

; 2511 : 		m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  001c3	6a ff		 push	 -1
  001c5	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  001cb	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2512 : 		m_Title.AddTextPiece( FONT_SIZE_17, STR(6) );

  001d0	57		 push	 edi
  001d1	6a 06		 push	 6
  001d3	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
  001d8	57		 push	 edi
  001d9	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0CC@MGFJNFLA@RoundStateMainWnd?3?3SetSingleScor@
  001de	56		 push	 esi
  001df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  001e5	8b c8		 mov	 ecx, eax
  001e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  001ed	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  001f5	50		 push	 eax
  001f6	51		 push	 ecx
  001f7	8d 83 74 01 00
	00		 lea	 eax, DWORD PTR [ebx+372]
  001fd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00202	50		 push	 eax
  00203	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  00208	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2513 : 		m_Title.SetTextColor( TCT_DEFAULT_LIGHTGRAY );

  0020b	68 a7 a7 a7 ff	 push	 -5789785		; ffa7a7a7H
  00210	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00216	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2514 : 		m_Title.AddTextPiece( FONT_SIZE_17, " | " );

  0021b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  00223	68 00 00 00 00	 push	 OFFSET ??_C@_03LGOGDKEL@?5?$HM?5?$AA@
  00228	51		 push	 ecx
  00229	8d 83 74 01 00
	00		 lea	 eax, DWORD PTR [ebx+372]
  0022f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00234	50		 push	 eax
  00235	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  0023a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2515 : 		m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  0023d	6a ff		 push	 -1
  0023f	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00245	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2516 : 		m_Title.AddTextPiece( FONT_SIZE_17, STR(7), g_ShuffleRoomMgr.GetName().c_str() );

  0024a	8d 45 d8	 lea	 eax, DWORD PTR $T570713[ebp]
  0024d	50		 push	 eax
  0024e	e8 00 00 00 00	 call	 ?GetSingleton@ioShuffleRoomMgr@@SAAAV1@XZ ; ioShuffleRoomMgr::GetSingleton
  00253	8b c8		 mov	 ecx, eax
  00255	e8 00 00 00 00	 call	 ?GetName@ioShuffleRoomMgr@@QAE?AVioHashString@@XZ ; ioShuffleRoomMgr::GetName
  0025a	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0025e	8b c8		 mov	 ecx, eax
  00260	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00266	50		 push	 eax
  00267	6a 00		 push	 0
  00269	6a 07		 push	 7
$LN55@SetSingleS@2:
  0026b	57		 push	 edi
  0026c	56		 push	 esi
  0026d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00273	8b c8		 mov	 ecx, eax
  00275	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0027b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  00283	50		 push	 eax
  00284	51		 push	 ecx
  00285	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  0028b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00290	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAEXMPBD0@Z ; ioComplexStringPrinter::AddTextPiece
  00295	8d 4d d8	 lea	 ecx, DWORD PTR $T570713[ebp]

; 2517 : 	}
; 2518 : 	else

  00298	e9 59 01 00 00	 jmp	 $LN54@SetSingleS@2
$LN10@SetSingleS@2:

; 2519 : 	{
; 2520 : 		// 타이틀
; 2521 : 		m_Title.ClearList();

  0029d	e8 00 00 00 00	 call	 ?ClearList@ioComplexStringPrinter@@QAEXXZ ; ioComplexStringPrinter::ClearList

; 2522 : 		m_Title.SetTextStyle( TS_OUTLINE_FULL_2X );

  002a2	6a 05		 push	 5
  002a4	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  002aa	e8 00 00 00 00	 call	 ?SetTextStyle@ioComplexStringPrinter@@QAEXW4TextStyle@@@Z ; ioComplexStringPrinter::SetTextStyle

; 2523 : 		m_Title.SetBkColor( 12, 66, 111 );

  002af	6a 6f		 push	 111			; 0000006fH
  002b1	6a 42		 push	 66			; 00000042H
  002b3	6a 0c		 push	 12			; 0000000cH
  002b5	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  002bb	e8 00 00 00 00	 call	 ?SetBkColor@ioComplexStringPrinter@@QAEXHHH@Z ; ioComplexStringPrinter::SetBkColor

; 2524 : 		m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  002c0	6a ff		 push	 -1
  002c2	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  002c8	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2525 : 		m_Title.AddTextPiece( FONT_SIZE_17, STR(1) );

  002cd	57		 push	 edi
  002ce	6a 01		 push	 1
  002d0	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
  002d5	57		 push	 edi
  002d6	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0CC@MGFJNFLA@RoundStateMainWnd?3?3SetSingleScor@
  002db	56		 push	 esi
  002dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  002e2	8b c8		 mov	 ecx, eax
  002e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  002ea	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  002f2	50		 push	 eax
  002f3	51		 push	 ecx
  002f4	8d 83 74 01 00
	00		 lea	 eax, DWORD PTR [ebx+372]
  002fa	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002ff	50		 push	 eax
  00300	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  00305	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2526 : 		m_Title.SetTextColor( TCT_DEFAULT_LIGHTGRAY );

  00308	68 a7 a7 a7 ff	 push	 -5789785		; ffa7a7a7H
  0030d	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00313	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2527 : 		m_Title.AddTextPiece( FONT_SIZE_17, " | " );

  00318	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  00320	68 00 00 00 00	 push	 OFFSET ??_C@_03LGOGDKEL@?5?$HM?5?$AA@
  00325	51		 push	 ecx
  00326	8d 83 74 01 00
	00		 lea	 eax, DWORD PTR [ebx+372]
  0032c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00331	50		 push	 eax
  00332	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  00337	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2528 : 		m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  0033a	6a ff		 push	 -1
  0033c	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00342	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2529 : 		if( g_BattleRoomMgr.GetPW().IsEmpty() )

  00347	8d 45 d8	 lea	 eax, DWORD PTR $T570715[ebp]
  0034a	50		 push	 eax
  0034b	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  00350	8b c8		 mov	 ecx, eax
  00352	e8 00 00 00 00	 call	 ?GetPW@ioBattleRoomMgr@@QAE?AVioHashString@@XZ ; ioBattleRoomMgr::GetPW
  00357	8b c8		 mov	 ecx, eax
  00359	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00360	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00366	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0036a	8d 4d d8	 lea	 ecx, DWORD PTR $T570715[ebp]
  0036d	88 45 f3	 mov	 BYTE PTR $T570714[ebp], al
  00370	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00376	80 7d f3 00	 cmp	 BYTE PTR $T570714[ebp], 0
  0037a	74 29		 je	 SHORT $LN8@SetSingleS@2

; 2530 : 			m_Title.AddTextPiece( FONT_SIZE_17, STR(2), g_BattleRoomMgr.GetName().c_str() );

  0037c	8d 45 d8	 lea	 eax, DWORD PTR $T570716[ebp]
  0037f	50		 push	 eax
  00380	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  00385	8b c8		 mov	 ecx, eax
  00387	e8 00 00 00 00	 call	 ?GetName@ioBattleRoomMgr@@QAE?AVioHashString@@XZ ; ioBattleRoomMgr::GetName
  0038c	8b c8		 mov	 ecx, eax
  0038e	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00395	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  0039b	50		 push	 eax
  0039c	6a 00		 push	 0
  0039e	6a 02		 push	 2

; 2531 : 		else

  003a0	e9 c6 fe ff ff	 jmp	 $LN55@SetSingleS@2
$LN8@SetSingleS@2:

; 2532 : 			m_Title.AddTextPiece( FONT_SIZE_17, STR(3), g_BattleRoomMgr.GetName().c_str() );		

  003a5	8d 45 c8	 lea	 eax, DWORD PTR $T570717[ebp]
  003a8	50		 push	 eax
  003a9	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  003ae	8b c8		 mov	 ecx, eax
  003b0	e8 00 00 00 00	 call	 ?GetName@ioBattleRoomMgr@@QAE?AVioHashString@@XZ ; ioBattleRoomMgr::GetName
  003b5	8b c8		 mov	 ecx, eax
  003b7	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  003be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  003c4	50		 push	 eax
  003c5	6a 00		 push	 0
  003c7	6a 03		 push	 3
  003c9	57		 push	 edi
  003ca	56		 push	 esi
  003cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  003d1	8b c8		 mov	 ecx, eax
  003d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  003d9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  003e1	50		 push	 eax
  003e2	51		 push	 ecx
  003e3	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  003e9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003ee	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAEXMPBD0@Z ; ioComplexStringPrinter::AddTextPiece
  003f3	8d 4d c8	 lea	 ecx, DWORD PTR $T570717[ebp]
$LN54@SetSingleS@2:
  003f6	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  003fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
$LN7@SetSingleS@2:

; 2533 : 	}
; 2534 : 
; 2535 : 	// 윈도우 세팅
; 2536 : 	RoundStateUserWnd *pUserWnd = dynamic_cast<RoundStateUserWnd *>(FindChildWnd( ID_SINGLE_WND ));

  00400	6a 00		 push	 0
  00402	68 00 00 00 00	 push	 OFFSET ??_R0?AVRoundStateUserWnd@@@8
  00407	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWnd@@@8
  0040c	6a 00		 push	 0
  0040e	6a 03		 push	 3
  00410	8b cb		 mov	 ecx, ebx
  00412	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?FindChildWnd@ioWnd@@QAEPAV1@K@Z
  00418	50		 push	 eax
  00419	e8 00 00 00 00	 call	 ___RTDynamicCast
  0041e	8b f0		 mov	 esi, eax
  00420	83 c4 14	 add	 esp, 20			; 00000014H

; 2537 : 	if( pUserWnd )

  00423	85 f6		 test	 esi, esi
  00425	74 73		 je	 SHORT $LN6@SetSingleS@2

; 2538 : 	{
; 2539 : 		int iUserSize = m_RoundInfoList.size();

  00427	8b 83 68 01 00
	00		 mov	 eax, DWORD PTR [ebx+360]
  0042d	2b 83 64 01 00
	00		 sub	 eax, DWORD PTR [ebx+356]
  00433	c1 f8 07	 sar	 eax, 7

; 2540 : 		for(int i = 0;i < iUserSize;i++)

  00436	85 c0		 test	 eax, eax
  00438	7e 31		 jle	 SHORT $LN3@SetSingleS@2

; 2538 : 	{
; 2539 : 		int iUserSize = m_RoundInfoList.size();

  0043a	83 65 ec 00	 and	 DWORD PTR tv574[ebp], 0
  0043e	89 45 e8	 mov	 DWORD PTR tv437[ebp], eax
$LN5@SetSingleS@2:

; 2540 : 		for(int i = 0;i < iUserSize;i++)

  00441	8b 83 64 01 00
	00		 mov	 eax, DWORD PTR [ebx+356]
  00447	03 45 ec	 add	 eax, DWORD PTR tv574[ebp]

; 2541 : 		{
; 2542 : 			RoundInfo &rkInfo = m_RoundInfoList[i];
; 2543 : 			
; 2544 : 			// 자신은 블루 
; 2545 : 			if( rkInfo.m_bOwner )

  0044a	33 c9		 xor	 ecx, ecx
  0044c	38 48 54	 cmp	 BYTE PTR [eax+84], cl

; 2546 : 				rkInfo.m_Team = TEAM_BLUE;
; 2547 : 			else
; 2548 : 				rkInfo.m_Team = TEAM_RED;
; 2549 : 			pUserWnd->AddRoundInfo( rkInfo );

  0044f	50		 push	 eax
  00450	0f 95 c1	 setne	 cl
  00453	41		 inc	 ecx
  00454	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00457	8d 8e 98 02 00
	00		 lea	 ecx, DWORD PTR [esi+664]
  0045d	e8 00 00 00 00	 call	 ?push_back@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXABURoundInfo@@@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::push_back
  00462	83 6d ec 80	 sub	 DWORD PTR tv574[ebp], -128 ; ffffff80H
  00466	ff 4d e8	 dec	 DWORD PTR tv437[ebp]
  00469	75 d6		 jne	 SHORT $LN5@SetSingleS@2
$LN3@SetSingleS@2:

; 2550 : 		}
; 2551 : 		pUserWnd->SetPlayStage( m_pPlayStage );

  0046b	8b 83 60 01 00
	00		 mov	 eax, DWORD PTR [ebx+352]
  00471	89 86 94 02 00
	00		 mov	 DWORD PTR [esi+660], eax

; 2552 : 		pUserWnd->SetWindowTeam( TEAM_RED );

  00477	c7 86 58 02 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+600], 1

; 2553 : 		pUserWnd->SetSingleScore( g_BattleRoomMgr.GetMaxPlayer() );

  00481	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  00486	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00489	03 48 40	 add	 ecx, DWORD PTR [eax+64]
  0048c	51		 push	 ecx
  0048d	8b ce		 mov	 ecx, esi
  0048f	e8 00 00 00 00	 call	 ?SetSingleScore@RoundStateUserWnd@@QAEXH@Z ; RoundStateUserWnd::SetSingleScore

; 2554 : 		pUserWnd->ShowWnd();

  00494	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ShowWnd@ioWnd@@QAEXXZ
$LN6@SetSingleS@2:

; 2555 : 	}
; 2556 : }

  0049a	e8 00 00 00 00	 call	 __EH_epilog3
  0049f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetSingleScore@RoundStateMainWnd@@UAEXXZ$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T570713[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?SetSingleScore@RoundStateMainWnd@@UAEXXZ$1:
  00009	8d 4d d8	 lea	 ecx, DWORD PTR $T570715[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?SetSingleScore@RoundStateMainWnd@@UAEXXZ$2:
  00012	8d 4d d8	 lea	 ecx, DWORD PTR $T570716[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?SetSingleScore@RoundStateMainWnd@@UAEXXZ$3:
  0001b	8d 4d c8	 lea	 ecx, DWORD PTR $T570717[ebp]
  0001e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$?SetSingleScore@RoundStateMainWnd@@UAEXXZ:
  00024	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00028	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002b	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetSingleScore@RoundStateMainWnd@@UAEXXZ
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetSingleScore@RoundStateMainWnd@@UAEXXZ ENDP		; RoundStateMainWnd::SetSingleScore
PUBLIC	??_C@_0CE@KNIELNLB@RoundStateMainWnd?3?3SetTowerDefSc@ ; `string'
;	COMDAT ??_C@_0CE@KNIELNLB@RoundStateMainWnd?3?3SetTowerDefSc@
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobattleroommgr.h
CONST	SEGMENT
??_C@_0CE@KNIELNLB@RoundStateMainWnd?3?3SetTowerDefSc@ DB 'RoundStateMain'
	DB	'Wnd::SetTowerDefScore', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetTowerDefScore@RoundStateMainWnd@@UAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetTowerDefScore@RoundStateMainWnd@@UAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SetTowerDefScore@RoundStateMainWnd@@UAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SetTowerDefScore@RoundStateMainWnd@@UAEXXZ$2
__ehfuncinfo$?SetTowerDefScore@RoundStateMainWnd@@UAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?SetTowerDefScore@RoundStateMainWnd@@UAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
xdata$x	ENDS
;	COMDAT ?SetTowerDefScore@RoundStateMainWnd@@UAEXXZ
_TEXT	SEGMENT
$T570812 = -56						; size = 16
$T570811 = -40						; size = 16
$T570810 = -40						; size = 16
tv306 = -24						; size = 4
$T570806 = -24						; size = 1
tv431 = -20						; size = 4
$T570809 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?SetTowerDefScore@RoundStateMainWnd@@UAEXXZ PROC	; RoundStateMainWnd::SetTowerDefScore, COMDAT
; _this$ = ecx

; 2559 : {

  00000	6a 2c		 push	 44			; 0000002cH
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetTowerDefScore@RoundStateMainWnd@@UAEXXZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f9		 mov	 edi, ecx

; 2560 : 	if( !m_pPlayStage ) return;

  0000e	33 db		 xor	 ebx, ebx
  00010	39 9f 60 01 00
	00		 cmp	 DWORD PTR [edi+352], ebx
  00016	0f 84 40 02 00
	00		 je	 $LN4@SetTowerDe

; 2561 : 
; 2562 : 	HideChildWnd( ID_PLAZA_WND );

  0001c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?HideChildWnd@ioWnd@@QAEXK_N@Z
  00022	53		 push	 ebx
  00023	6a 02		 push	 2
  00025	ff d6		 call	 esi

; 2563 : 	HideChildWnd( ID_SINGLE_WND );

  00027	53		 push	 ebx
  00028	6a 03		 push	 3
  0002a	8b cf		 mov	 ecx, edi
  0002c	ff d6		 call	 esi

; 2564 : 	HideChildWnd( ID_BLUE_WND );

  0002e	53		 push	 ebx
  0002f	6a 04		 push	 4
  00031	8b cf		 mov	 ecx, edi
  00033	ff d6		 call	 esi

; 2565 : 	HideChildWnd( ID_RED_WND );

  00035	53		 push	 ebx
  00036	6a 05		 push	 5
  00038	8b cf		 mov	 ecx, edi
  0003a	ff d6		 call	 esi

; 2566 : 
; 2567 : 	std::sort( m_RoundInfoList.begin(), m_RoundInfoList.end(), RoundInfoKoSort() );

  0003c	ff 75 e8	 push	 DWORD PTR $T570806[ebp]
  0003f	8b 87 68 01 00
	00		 mov	 eax, DWORD PTR [edi+360]
  00045	8b 8f 64 01 00
	00		 mov	 ecx, DWORD PTR [edi+356]
  0004b	50		 push	 eax
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$sort@V?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@VRoundInfoKoSort@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@0@0VRoundInfoKoSort@@@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >,RoundInfoKoSort>

; 2568 : 
; 2569 : 	// 타이틀
; 2570 : 	m_Title.ClearList();

  00052	8d b7 74 01 00
	00		 lea	 esi, DWORD PTR [edi+372]
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005b	8b ce		 mov	 ecx, esi
  0005d	e8 00 00 00 00	 call	 ?ClearList@ioComplexStringPrinter@@QAEXXZ ; ioComplexStringPrinter::ClearList

; 2571 : 	m_Title.SetTextStyle( TS_OUTLINE_FULL_2X );

  00062	6a 05		 push	 5
  00064	8b ce		 mov	 ecx, esi
  00066	e8 00 00 00 00	 call	 ?SetTextStyle@ioComplexStringPrinter@@QAEXW4TextStyle@@@Z ; ioComplexStringPrinter::SetTextStyle

; 2572 : 	m_Title.SetBkColor( 12, 66, 111 );

  0006b	6a 6f		 push	 111			; 0000006fH
  0006d	6a 42		 push	 66			; 00000042H
  0006f	6a 0c		 push	 12			; 0000000cH
  00071	8b ce		 mov	 ecx, esi
  00073	e8 00 00 00 00	 call	 ?SetBkColor@ioComplexStringPrinter@@QAEXHHH@Z ; ioComplexStringPrinter::SetBkColor

; 2573 : 	m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  00078	6a ff		 push	 -1
  0007a	8b ce		 mov	 ecx, esi
  0007c	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2574 : 	m_Title.AddTextPiece( FONT_SIZE_17, STR(4) );

  00081	53		 push	 ebx
  00082	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00088	6a 04		 push	 4
  0008a	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@KNIELNLB@RoundStateMainWnd?3?3SetTowerDefSc@
  00094	ff d3		 call	 ebx
  00096	8b c8		 mov	 ecx, eax
  00098	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0009e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  000a6	50		 push	 eax
  000a7	51		 push	 ecx
  000a8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ad	56		 push	 esi
  000ae	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  000b3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2575 : 	m_Title.SetTextColor( TCT_DEFAULT_LIGHTGRAY );

  000b6	68 a7 a7 a7 ff	 push	 -5789785		; ffa7a7a7H
  000bb	8b ce		 mov	 ecx, esi
  000bd	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2576 : 	m_Title.AddTextPiece( FONT_SIZE_17, " | " );

  000c2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_03LGOGDKEL@?5?$HM?5?$AA@
  000cf	51		 push	 ecx
  000d0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d5	56		 push	 esi
  000d6	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  000db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2577 : 	m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  000de	6a ff		 push	 -1
  000e0	8b ce		 mov	 ecx, esi
  000e2	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2578 : 	if( g_BattleRoomMgr.GetPW().IsEmpty() )

  000e7	8d 45 d8	 lea	 eax, DWORD PTR $T570810[ebp]
  000ea	50		 push	 eax
  000eb	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  000f0	8b c8		 mov	 ecx, eax
  000f2	e8 00 00 00 00	 call	 ?GetPW@ioBattleRoomMgr@@QAE?AVioHashString@@XZ ; ioBattleRoomMgr::GetPW
  000f7	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  000fb	8b c8		 mov	 ecx, eax
  000fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00103	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00107	8d 4d d8	 lea	 ecx, DWORD PTR $T570810[ebp]
  0010a	88 45 f3	 mov	 BYTE PTR $T570809[ebp], al
  0010d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00113	80 7d f3 00	 cmp	 BYTE PTR $T570809[ebp], 0
  00117	74 53		 je	 SHORT $LN6@SetTowerDe

; 2579 : 		m_Title.AddTextPiece( FONT_SIZE_17, STR(5), g_BattleRoomMgr.GetName().c_str() );

  00119	8d 45 d8	 lea	 eax, DWORD PTR $T570811[ebp]
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  00122	8b c8		 mov	 ecx, eax
  00124	e8 00 00 00 00	 call	 ?GetName@ioBattleRoomMgr@@QAE?AVioHashString@@XZ ; ioBattleRoomMgr::GetName
  00129	8b c8		 mov	 ecx, eax
  0012b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00138	50		 push	 eax
  00139	6a 00		 push	 0
  0013b	6a 05		 push	 5
  0013d	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00142	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@KNIELNLB@RoundStateMainWnd?3?3SetTowerDefSc@
  00147	ff d3		 call	 ebx
  00149	8b c8		 mov	 ecx, eax
  0014b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  00151	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  00159	50		 push	 eax
  0015a	51		 push	 ecx
  0015b	8b ce		 mov	 ecx, esi
  0015d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00162	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAEXMPBD0@Z ; ioComplexStringPrinter::AddTextPiece
  00167	8d 4d d8	 lea	 ecx, DWORD PTR $T570811[ebp]

; 2580 : 	else

  0016a	eb 51		 jmp	 SHORT $LN45@SetTowerDe
$LN6@SetTowerDe:

; 2581 : 		m_Title.AddTextPiece( FONT_SIZE_17, STR(6), g_BattleRoomMgr.GetName().c_str() );		

  0016c	8d 45 c8	 lea	 eax, DWORD PTR $T570812[ebp]
  0016f	50		 push	 eax
  00170	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  00175	8b c8		 mov	 ecx, eax
  00177	e8 00 00 00 00	 call	 ?GetName@ioBattleRoomMgr@@QAE?AVioHashString@@XZ ; ioBattleRoomMgr::GetName
  0017c	8b c8		 mov	 ecx, eax
  0017e	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00185	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  0018b	50		 push	 eax
  0018c	6a 00		 push	 0
  0018e	6a 06		 push	 6
  00190	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00195	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@KNIELNLB@RoundStateMainWnd?3?3SetTowerDefSc@
  0019a	ff d3		 call	 ebx
  0019c	8b c8		 mov	 ecx, eax
  0019e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  001a4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  001ac	50		 push	 eax
  001ad	51		 push	 ecx
  001ae	8b ce		 mov	 ecx, esi
  001b0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001b5	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAEXMPBD0@Z ; ioComplexStringPrinter::AddTextPiece
  001ba	8d 4d c8	 lea	 ecx, DWORD PTR $T570812[ebp]
$LN45@SetTowerDe:
  001bd	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  001c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ

; 2582 : 
; 2583 : 	// 윈도우 세팅
; 2584 : 	RoundStateUserWnd *pUserWnd = dynamic_cast<RoundStateUserWnd *>(FindChildWnd( ID_SINGLE_WND ));

  001c7	6a 00		 push	 0
  001c9	68 00 00 00 00	 push	 OFFSET ??_R0?AVRoundStateUserWnd@@@8
  001ce	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWnd@@@8
  001d3	6a 00		 push	 0
  001d5	6a 03		 push	 3
  001d7	8b cf		 mov	 ecx, edi
  001d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?FindChildWnd@ioWnd@@QAEPAV1@K@Z
  001df	50		 push	 eax
  001e0	e8 00 00 00 00	 call	 ___RTDynamicCast
  001e5	8b f0		 mov	 esi, eax
  001e7	83 c4 14	 add	 esp, 20			; 00000014H

; 2585 : 	if( pUserWnd )

  001ea	85 f6		 test	 esi, esi
  001ec	74 6e		 je	 SHORT $LN4@SetTowerDe

; 2586 : 	{
; 2587 : 		int iUserSize = m_RoundInfoList.size();

  001ee	8b 87 68 01 00
	00		 mov	 eax, DWORD PTR [edi+360]
  001f4	2b 87 64 01 00
	00		 sub	 eax, DWORD PTR [edi+356]
  001fa	c1 f8 07	 sar	 eax, 7

; 2588 : 		for(int i = 0;i < iUserSize;i++)

  001fd	85 c0		 test	 eax, eax
  001ff	7e 2c		 jle	 SHORT $LN1@SetTowerDe

; 2586 : 	{
; 2587 : 		int iUserSize = m_RoundInfoList.size();

  00201	83 65 ec 00	 and	 DWORD PTR tv431[ebp], 0
  00205	89 45 e8	 mov	 DWORD PTR tv306[ebp], eax
$LN3@SetTowerDe:

; 2588 : 		for(int i = 0;i < iUserSize;i++)

  00208	8b 87 64 01 00
	00		 mov	 eax, DWORD PTR [edi+356]
  0020e	03 45 ec	 add	 eax, DWORD PTR tv431[ebp]

; 2589 : 		{
; 2590 : 			RoundInfo &rkInfo = m_RoundInfoList[i];
; 2591 : 			rkInfo.m_Team = TEAM_BLUE;
; 2592 : 			pUserWnd->AddRoundInfo( rkInfo );

  00211	8d 8e 98 02 00
	00		 lea	 ecx, DWORD PTR [esi+664]
  00217	50		 push	 eax
  00218	c7 40 10 02 00
	00 00		 mov	 DWORD PTR [eax+16], 2
  0021f	e8 00 00 00 00	 call	 ?push_back@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXABURoundInfo@@@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::push_back
  00224	83 6d ec 80	 sub	 DWORD PTR tv431[ebp], -128 ; ffffff80H
  00228	ff 4d e8	 dec	 DWORD PTR tv306[ebp]
  0022b	75 db		 jne	 SHORT $LN3@SetTowerDe
$LN1@SetTowerDe:

; 2593 : 		}
; 2594 : 		pUserWnd->SetPlayStage( m_pPlayStage );

  0022d	8b 87 60 01 00
	00		 mov	 eax, DWORD PTR [edi+352]
  00233	89 86 94 02 00
	00		 mov	 DWORD PTR [esi+660], eax

; 2595 : 		pUserWnd->SetWindowTeam( TEAM_BLUE );

  00239	c7 86 58 02 00
	00 02 00 00 00	 mov	 DWORD PTR [esi+600], 2

; 2596 : 		pUserWnd->SetSingleScore( g_BattleRoomMgr.GetMaxPlayer() );

  00243	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  00248	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  0024b	03 48 40	 add	 ecx, DWORD PTR [eax+64]
  0024e	51		 push	 ecx
  0024f	8b ce		 mov	 ecx, esi
  00251	e8 00 00 00 00	 call	 ?SetSingleScore@RoundStateUserWnd@@QAEXH@Z ; RoundStateUserWnd::SetSingleScore

; 2597 : 		pUserWnd->ShowWnd();

  00256	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ShowWnd@ioWnd@@QAEXXZ
$LN4@SetTowerDe:

; 2598 : 	}
; 2599 : }

  0025c	e8 00 00 00 00	 call	 __EH_epilog3
  00261	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetTowerDefScore@RoundStateMainWnd@@UAEXXZ$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T570810[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?SetTowerDefScore@RoundStateMainWnd@@UAEXXZ$1:
  00009	8d 4d d8	 lea	 ecx, DWORD PTR $T570811[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?SetTowerDefScore@RoundStateMainWnd@@UAEXXZ$2:
  00012	8d 4d c8	 lea	 ecx, DWORD PTR $T570812[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$?SetTowerDefScore@RoundStateMainWnd@@UAEXXZ:
  0001b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00022	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00025	33 c8		 xor	 ecx, eax
  00027	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetTowerDefScore@RoundStateMainWnd@@UAEXXZ
  00031	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetTowerDefScore@RoundStateMainWnd@@UAEXXZ ENDP	; RoundStateMainWnd::SetTowerDefScore
PUBLIC	??_C@_0CC@BBLPKLIF@RoundStateMainWnd?3?3SetGangsiScor@ ; `string'
;	COMDAT ??_C@_0CC@BBLPKLIF@RoundStateMainWnd?3?3SetGangsiScor@
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobattleroommgr.h
CONST	SEGMENT
??_C@_0CC@BBLPKLIF@RoundStateMainWnd?3?3SetGangsiScor@ DB 'RoundStateMain'
	DB	'Wnd::SetGangsiScore', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetGangsiScore@RoundStateMainWnd@@UAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetGangsiScore@RoundStateMainWnd@@UAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SetGangsiScore@RoundStateMainWnd@@UAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SetGangsiScore@RoundStateMainWnd@@UAEXXZ$2
__ehfuncinfo$?SetGangsiScore@RoundStateMainWnd@@UAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?SetGangsiScore@RoundStateMainWnd@@UAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
xdata$x	ENDS
;	COMDAT ?SetGangsiScore@RoundStateMainWnd@@UAEXXZ
_TEXT	SEGMENT
$T570905 = -56						; size = 16
$T570904 = -40						; size = 16
$T570903 = -40						; size = 16
tv135 = -24						; size = 4
$T570899 = -24						; size = 1
tv426 = -20						; size = 4
$T570902 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?SetGangsiScore@RoundStateMainWnd@@UAEXXZ PROC		; RoundStateMainWnd::SetGangsiScore, COMDAT
; _this$ = ecx

; 2602 : {

  00000	6a 2c		 push	 44			; 0000002cH
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetGangsiScore@RoundStateMainWnd@@UAEXXZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f9		 mov	 edi, ecx

; 2603 : 	if( !m_pPlayStage ) return;

  0000e	33 db		 xor	 ebx, ebx
  00010	39 9f 60 01 00
	00		 cmp	 DWORD PTR [edi+352], ebx
  00016	0f 84 39 02 00
	00		 je	 $LN4@SetGangsiS@2

; 2604 : 
; 2605 : 	HideChildWnd( ID_PLAZA_WND );

  0001c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?HideChildWnd@ioWnd@@QAEXK_N@Z
  00022	53		 push	 ebx
  00023	6a 02		 push	 2
  00025	ff d6		 call	 esi

; 2606 : 	HideChildWnd( ID_SINGLE_WND );

  00027	53		 push	 ebx
  00028	6a 03		 push	 3
  0002a	8b cf		 mov	 ecx, edi
  0002c	ff d6		 call	 esi

; 2607 : 	HideChildWnd( ID_BLUE_WND );

  0002e	53		 push	 ebx
  0002f	6a 04		 push	 4
  00031	8b cf		 mov	 ecx, edi
  00033	ff d6		 call	 esi

; 2608 : 	HideChildWnd( ID_RED_WND );

  00035	53		 push	 ebx
  00036	6a 05		 push	 5
  00038	8b cf		 mov	 ecx, edi
  0003a	ff d6		 call	 esi

; 2609 : 
; 2610 : 	std::sort( m_RoundInfoList.begin(), m_RoundInfoList.end(), RoundInfoSort() );

  0003c	ff 75 e8	 push	 DWORD PTR $T570899[ebp]
  0003f	8b 87 68 01 00
	00		 mov	 eax, DWORD PTR [edi+360]
  00045	8b 8f 64 01 00
	00		 mov	 ecx, DWORD PTR [edi+356]
  0004b	50		 push	 eax
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$sort@V?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@VRoundInfoSort@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@0@0VRoundInfoSort@@@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >,RoundInfoSort>

; 2611 : 
; 2612 : 	// 타이틀
; 2613 : 	m_Title.ClearList();

  00052	8d b7 74 01 00
	00		 lea	 esi, DWORD PTR [edi+372]
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005b	8b ce		 mov	 ecx, esi
  0005d	e8 00 00 00 00	 call	 ?ClearList@ioComplexStringPrinter@@QAEXXZ ; ioComplexStringPrinter::ClearList

; 2614 : 	m_Title.SetTextStyle( TS_OUTLINE_FULL_2X );

  00062	6a 05		 push	 5
  00064	8b ce		 mov	 ecx, esi
  00066	e8 00 00 00 00	 call	 ?SetTextStyle@ioComplexStringPrinter@@QAEXW4TextStyle@@@Z ; ioComplexStringPrinter::SetTextStyle

; 2615 : 	m_Title.SetBkColor( 12, 66, 111 );

  0006b	6a 6f		 push	 111			; 0000006fH
  0006d	6a 42		 push	 66			; 00000042H
  0006f	6a 0c		 push	 12			; 0000000cH
  00071	8b ce		 mov	 ecx, esi
  00073	e8 00 00 00 00	 call	 ?SetBkColor@ioComplexStringPrinter@@QAEXHHH@Z ; ioComplexStringPrinter::SetBkColor

; 2616 : 	m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  00078	6a ff		 push	 -1
  0007a	8b ce		 mov	 ecx, esi
  0007c	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2617 : 	m_Title.AddTextPiece( FONT_SIZE_17, STR(1) );

  00081	53		 push	 ebx
  00082	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00088	6a 01		 push	 1
  0008a	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@BBLPKLIF@RoundStateMainWnd?3?3SetGangsiScor@
  00094	ff d3		 call	 ebx
  00096	8b c8		 mov	 ecx, eax
  00098	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0009e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  000a6	50		 push	 eax
  000a7	51		 push	 ecx
  000a8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ad	56		 push	 esi
  000ae	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  000b3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2618 : 	m_Title.SetTextColor( TCT_DEFAULT_LIGHTGRAY );

  000b6	68 a7 a7 a7 ff	 push	 -5789785		; ffa7a7a7H
  000bb	8b ce		 mov	 ecx, esi
  000bd	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2619 : 	m_Title.AddTextPiece( FONT_SIZE_17, " | " );

  000c2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_03LGOGDKEL@?5?$HM?5?$AA@
  000cf	51		 push	 ecx
  000d0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d5	56		 push	 esi
  000d6	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  000db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2620 : 	m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  000de	6a ff		 push	 -1
  000e0	8b ce		 mov	 ecx, esi
  000e2	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2621 : 	if( g_BattleRoomMgr.GetPW().IsEmpty() )

  000e7	8d 45 d8	 lea	 eax, DWORD PTR $T570903[ebp]
  000ea	50		 push	 eax
  000eb	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  000f0	8b c8		 mov	 ecx, eax
  000f2	e8 00 00 00 00	 call	 ?GetPW@ioBattleRoomMgr@@QAE?AVioHashString@@XZ ; ioBattleRoomMgr::GetPW
  000f7	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  000fb	8b c8		 mov	 ecx, eax
  000fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00103	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00107	8d 4d d8	 lea	 ecx, DWORD PTR $T570903[ebp]
  0010a	88 45 f3	 mov	 BYTE PTR $T570902[ebp], al
  0010d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00113	80 7d f3 00	 cmp	 BYTE PTR $T570902[ebp], 0
  00117	74 53		 je	 SHORT $LN6@SetGangsiS@2

; 2622 : 		m_Title.AddTextPiece( FONT_SIZE_17, STR(2), g_BattleRoomMgr.GetName().c_str() );

  00119	8d 45 d8	 lea	 eax, DWORD PTR $T570904[ebp]
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  00122	8b c8		 mov	 ecx, eax
  00124	e8 00 00 00 00	 call	 ?GetName@ioBattleRoomMgr@@QAE?AVioHashString@@XZ ; ioBattleRoomMgr::GetName
  00129	8b c8		 mov	 ecx, eax
  0012b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00138	50		 push	 eax
  00139	6a 00		 push	 0
  0013b	6a 02		 push	 2
  0013d	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00142	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@BBLPKLIF@RoundStateMainWnd?3?3SetGangsiScor@
  00147	ff d3		 call	 ebx
  00149	8b c8		 mov	 ecx, eax
  0014b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  00151	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  00159	50		 push	 eax
  0015a	51		 push	 ecx
  0015b	8b ce		 mov	 ecx, esi
  0015d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00162	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAEXMPBD0@Z ; ioComplexStringPrinter::AddTextPiece
  00167	8d 4d d8	 lea	 ecx, DWORD PTR $T570904[ebp]

; 2623 : 	else

  0016a	eb 51		 jmp	 SHORT $LN45@SetGangsiS@2
$LN6@SetGangsiS@2:

; 2624 : 		m_Title.AddTextPiece( FONT_SIZE_17, STR(3), g_BattleRoomMgr.GetName().c_str() );		

  0016c	8d 45 c8	 lea	 eax, DWORD PTR $T570905[ebp]
  0016f	50		 push	 eax
  00170	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  00175	8b c8		 mov	 ecx, eax
  00177	e8 00 00 00 00	 call	 ?GetName@ioBattleRoomMgr@@QAE?AVioHashString@@XZ ; ioBattleRoomMgr::GetName
  0017c	8b c8		 mov	 ecx, eax
  0017e	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00185	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  0018b	50		 push	 eax
  0018c	6a 00		 push	 0
  0018e	6a 03		 push	 3
  00190	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00195	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@BBLPKLIF@RoundStateMainWnd?3?3SetGangsiScor@
  0019a	ff d3		 call	 ebx
  0019c	8b c8		 mov	 ecx, eax
  0019e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  001a4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  001ac	50		 push	 eax
  001ad	51		 push	 ecx
  001ae	8b ce		 mov	 ecx, esi
  001b0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001b5	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAEXMPBD0@Z ; ioComplexStringPrinter::AddTextPiece
  001ba	8d 4d c8	 lea	 ecx, DWORD PTR $T570905[ebp]
$LN45@SetGangsiS@2:
  001bd	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  001c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ

; 2625 : 
; 2626 : 	// 윈도우 세팅
; 2627 : 	RoundStateUserWnd *pUserWnd = dynamic_cast<RoundStateUserWnd *>(FindChildWnd( ID_SINGLE_WND ));

  001c7	6a 00		 push	 0
  001c9	68 00 00 00 00	 push	 OFFSET ??_R0?AVRoundStateUserWnd@@@8
  001ce	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWnd@@@8
  001d3	6a 00		 push	 0
  001d5	6a 03		 push	 3
  001d7	8b cf		 mov	 ecx, edi
  001d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?FindChildWnd@ioWnd@@QAEPAV1@K@Z
  001df	50		 push	 eax
  001e0	e8 00 00 00 00	 call	 ___RTDynamicCast
  001e5	8b f0		 mov	 esi, eax
  001e7	83 c4 14	 add	 esp, 20			; 00000014H

; 2628 : 	if( pUserWnd )

  001ea	85 f6		 test	 esi, esi
  001ec	74 67		 je	 SHORT $LN4@SetGangsiS@2

; 2629 : 	{
; 2630 : 		int iUserSize = m_RoundInfoList.size();

  001ee	8b 87 68 01 00
	00		 mov	 eax, DWORD PTR [edi+360]
  001f4	2b 87 64 01 00
	00		 sub	 eax, DWORD PTR [edi+356]
  001fa	c1 f8 07	 sar	 eax, 7

; 2631 : 		for(int i = 0;i < iUserSize;i++)

  001fd	85 c0		 test	 eax, eax
  001ff	7e 25		 jle	 SHORT $LN1@SetGangsiS@2

; 2629 : 	{
; 2630 : 		int iUserSize = m_RoundInfoList.size();

  00201	83 65 ec 00	 and	 DWORD PTR tv426[ebp], 0
  00205	89 45 e8	 mov	 DWORD PTR tv135[ebp], eax
$LN3@SetGangsiS@2:

; 2631 : 		for(int i = 0;i < iUserSize;i++)

  00208	8b 87 64 01 00
	00		 mov	 eax, DWORD PTR [edi+356]
  0020e	03 45 ec	 add	 eax, DWORD PTR tv426[ebp]

; 2632 : 		{
; 2633 : 			RoundInfo &rkInfo = m_RoundInfoList[i];
; 2634 : 			pUserWnd->AddRoundInfo( rkInfo );

  00211	8d 8e 98 02 00
	00		 lea	 ecx, DWORD PTR [esi+664]
  00217	50		 push	 eax
  00218	e8 00 00 00 00	 call	 ?push_back@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXABURoundInfo@@@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::push_back
  0021d	83 6d ec 80	 sub	 DWORD PTR tv426[ebp], -128 ; ffffff80H
  00221	ff 4d e8	 dec	 DWORD PTR tv135[ebp]
  00224	75 e2		 jne	 SHORT $LN3@SetGangsiS@2
$LN1@SetGangsiS@2:

; 2635 : 		}
; 2636 : 		pUserWnd->SetPlayStage( m_pPlayStage );

  00226	8b 87 60 01 00
	00		 mov	 eax, DWORD PTR [edi+352]
  0022c	89 86 94 02 00
	00		 mov	 DWORD PTR [esi+660], eax

; 2637 : 		pUserWnd->SetWindowTeam( TEAM_RED );

  00232	c7 86 58 02 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+600], 1

; 2638 : 		pUserWnd->SetGangsiScore( g_BattleRoomMgr.GetMaxPlayer() );

  0023c	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  00241	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00244	03 48 40	 add	 ecx, DWORD PTR [eax+64]
  00247	51		 push	 ecx
  00248	8b ce		 mov	 ecx, esi
  0024a	e8 00 00 00 00	 call	 ?SetGangsiScore@RoundStateUserWnd@@QAEXH@Z ; RoundStateUserWnd::SetGangsiScore

; 2639 : 		pUserWnd->ShowWnd();

  0024f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ShowWnd@ioWnd@@QAEXXZ
$LN4@SetGangsiS@2:

; 2640 : 	}
; 2641 : }

  00255	e8 00 00 00 00	 call	 __EH_epilog3
  0025a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetGangsiScore@RoundStateMainWnd@@UAEXXZ$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T570903[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?SetGangsiScore@RoundStateMainWnd@@UAEXXZ$1:
  00009	8d 4d d8	 lea	 ecx, DWORD PTR $T570904[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?SetGangsiScore@RoundStateMainWnd@@UAEXXZ$2:
  00012	8d 4d c8	 lea	 ecx, DWORD PTR $T570905[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$?SetGangsiScore@RoundStateMainWnd@@UAEXXZ:
  0001b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00022	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00025	33 c8		 xor	 ecx, eax
  00027	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetGangsiScore@RoundStateMainWnd@@UAEXXZ
  00031	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetGangsiScore@RoundStateMainWnd@@UAEXXZ ENDP		; RoundStateMainWnd::SetGangsiScore
PUBLIC	??_C@_0CE@CBOJAGFN@RoundStateMainWnd?3?3SetDungeonsSc@ ; `string'
;	COMDAT ??_C@_0CE@CBOJAGFN@RoundStateMainWnd?3?3SetDungeonsSc@
CONST	SEGMENT
??_C@_0CE@CBOJAGFN@RoundStateMainWnd?3?3SetDungeonsSc@ DB 'RoundStateMain'
	DB	'Wnd::SetDungeonsScore', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetDungeonsScore@RoundStateMainWnd@@UAEXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetDungeonsScore@RoundStateMainWnd@@UAEXH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SetDungeonsScore@RoundStateMainWnd@@UAEXH@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SetDungeonsScore@RoundStateMainWnd@@UAEXH@Z$2
__ehfuncinfo$?SetDungeonsScore@RoundStateMainWnd@@UAEXH@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?SetDungeonsScore@RoundStateMainWnd@@UAEXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ?SetDungeonsScore@RoundStateMainWnd@@UAEXH@Z
_TEXT	SEGMENT
$T570998 = -56						; size = 16
$T570997 = -40						; size = 16
$T570996 = -40						; size = 16
tv309 = -24						; size = 4
tv437 = -20						; size = 4
$T570995 = -13						; size = 1
__$EHRec$ = -12						; size = 12
$T570992 = 8						; size = 1
_iCurrentFloor$ = 8					; size = 4
?SetDungeonsScore@RoundStateMainWnd@@UAEXH@Z PROC	; RoundStateMainWnd::SetDungeonsScore, COMDAT
; _this$ = ecx

; 2644 : {

  00000	6a 2c		 push	 44			; 0000002cH
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetDungeonsScore@RoundStateMainWnd@@UAEXH@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f9		 mov	 edi, ecx

; 2645 : 	if( !m_pPlayStage ) return;

  0000e	33 db		 xor	 ebx, ebx
  00010	39 9f 60 01 00
	00		 cmp	 DWORD PTR [edi+352], ebx
  00016	0f 84 49 02 00
	00		 je	 $LN4@SetDungeon

; 2646 : 
; 2647 : 	HideChildWnd( ID_PLAZA_WND );

  0001c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?HideChildWnd@ioWnd@@QAEXK_N@Z
  00022	53		 push	 ebx
  00023	6a 02		 push	 2
  00025	ff d6		 call	 esi

; 2648 : 	HideChildWnd( ID_SINGLE_WND );

  00027	53		 push	 ebx
  00028	6a 03		 push	 3
  0002a	8b cf		 mov	 ecx, edi
  0002c	ff d6		 call	 esi

; 2649 : 	HideChildWnd( ID_BLUE_WND );

  0002e	53		 push	 ebx
  0002f	6a 04		 push	 4
  00031	8b cf		 mov	 ecx, edi
  00033	ff d6		 call	 esi

; 2650 : 	HideChildWnd( ID_RED_WND );

  00035	53		 push	 ebx
  00036	6a 05		 push	 5
  00038	8b cf		 mov	 ecx, edi
  0003a	ff d6		 call	 esi

; 2651 : 
; 2652 : 	std::sort( m_RoundInfoList.begin(), m_RoundInfoList.end(), RoundInfoSort() );

  0003c	ff 75 08	 push	 DWORD PTR $T570992[ebp]
  0003f	8b 87 68 01 00
	00		 mov	 eax, DWORD PTR [edi+360]
  00045	8b 8f 64 01 00
	00		 mov	 ecx, DWORD PTR [edi+356]
  0004b	50		 push	 eax
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$sort@V?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@VRoundInfoSort@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@0@0VRoundInfoSort@@@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >,RoundInfoSort>

; 2653 : 
; 2654 : 	// 타이틀
; 2655 : 	m_Title.ClearList();

  00052	8d b7 74 01 00
	00		 lea	 esi, DWORD PTR [edi+372]
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005b	8b ce		 mov	 ecx, esi
  0005d	e8 00 00 00 00	 call	 ?ClearList@ioComplexStringPrinter@@QAEXXZ ; ioComplexStringPrinter::ClearList

; 2656 : 	m_Title.SetTextStyle( TS_OUTLINE_FULL_2X );

  00062	6a 05		 push	 5
  00064	8b ce		 mov	 ecx, esi
  00066	e8 00 00 00 00	 call	 ?SetTextStyle@ioComplexStringPrinter@@QAEXW4TextStyle@@@Z ; ioComplexStringPrinter::SetTextStyle

; 2657 : 	m_Title.SetBkColor( 12, 66, 111 );

  0006b	6a 6f		 push	 111			; 0000006fH
  0006d	6a 42		 push	 66			; 00000042H
  0006f	6a 0c		 push	 12			; 0000000cH
  00071	8b ce		 mov	 ecx, esi
  00073	e8 00 00 00 00	 call	 ?SetBkColor@ioComplexStringPrinter@@QAEXHHH@Z ; ioComplexStringPrinter::SetBkColor

; 2658 : 	m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  00078	6a ff		 push	 -1
  0007a	8b ce		 mov	 ecx, esi
  0007c	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2659 : 	m_Title.AddTextPiece( FONT_SIZE_17, STR(1) );

  00081	53		 push	 ebx
  00082	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00088	6a 01		 push	 1
  0008a	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@CBOJAGFN@RoundStateMainWnd?3?3SetDungeonsSc@
  00094	ff d3		 call	 ebx
  00096	8b c8		 mov	 ecx, eax
  00098	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0009e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  000a6	50		 push	 eax
  000a7	51		 push	 ecx
  000a8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ad	56		 push	 esi
  000ae	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  000b3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2660 : 	m_Title.SetTextColor( TCT_DEFAULT_LIGHTGRAY );

  000b6	68 a7 a7 a7 ff	 push	 -5789785		; ffa7a7a7H
  000bb	8b ce		 mov	 ecx, esi
  000bd	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2661 : 	m_Title.AddTextPiece( FONT_SIZE_17, " | " );

  000c2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_03LGOGDKEL@?5?$HM?5?$AA@
  000cf	51		 push	 ecx
  000d0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d5	56		 push	 esi
  000d6	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  000db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2662 : 	m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  000de	6a ff		 push	 -1
  000e0	8b ce		 mov	 ecx, esi
  000e2	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2663 : 	if( g_BattleRoomMgr.GetPW().IsEmpty() )

  000e7	8d 45 d8	 lea	 eax, DWORD PTR $T570996[ebp]
  000ea	50		 push	 eax
  000eb	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  000f0	8b c8		 mov	 ecx, eax
  000f2	e8 00 00 00 00	 call	 ?GetPW@ioBattleRoomMgr@@QAE?AVioHashString@@XZ ; ioBattleRoomMgr::GetPW
  000f7	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  000fb	8b c8		 mov	 ecx, eax
  000fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00103	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00107	8d 4d d8	 lea	 ecx, DWORD PTR $T570996[ebp]
  0010a	88 45 f3	 mov	 BYTE PTR $T570995[ebp], al
  0010d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00113	80 7d f3 00	 cmp	 BYTE PTR $T570995[ebp], 0
  00117	74 53		 je	 SHORT $LN6@SetDungeon

; 2664 : 		m_Title.AddTextPiece( FONT_SIZE_17, STR(2), g_BattleRoomMgr.GetName().c_str() );

  00119	8d 45 d8	 lea	 eax, DWORD PTR $T570997[ebp]
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  00122	8b c8		 mov	 ecx, eax
  00124	e8 00 00 00 00	 call	 ?GetName@ioBattleRoomMgr@@QAE?AVioHashString@@XZ ; ioBattleRoomMgr::GetName
  00129	8b c8		 mov	 ecx, eax
  0012b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00138	50		 push	 eax
  00139	6a 00		 push	 0
  0013b	6a 02		 push	 2
  0013d	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00142	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@CBOJAGFN@RoundStateMainWnd?3?3SetDungeonsSc@
  00147	ff d3		 call	 ebx
  00149	8b c8		 mov	 ecx, eax
  0014b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  00151	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  00159	50		 push	 eax
  0015a	51		 push	 ecx
  0015b	8b ce		 mov	 ecx, esi
  0015d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00162	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAEXMPBD0@Z ; ioComplexStringPrinter::AddTextPiece
  00167	8d 4d d8	 lea	 ecx, DWORD PTR $T570997[ebp]

; 2665 : 	else

  0016a	eb 51		 jmp	 SHORT $LN47@SetDungeon
$LN6@SetDungeon:

; 2666 : 		m_Title.AddTextPiece( FONT_SIZE_17, STR(3), g_BattleRoomMgr.GetName().c_str() );		

  0016c	8d 45 c8	 lea	 eax, DWORD PTR $T570998[ebp]
  0016f	50		 push	 eax
  00170	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  00175	8b c8		 mov	 ecx, eax
  00177	e8 00 00 00 00	 call	 ?GetName@ioBattleRoomMgr@@QAE?AVioHashString@@XZ ; ioBattleRoomMgr::GetName
  0017c	8b c8		 mov	 ecx, eax
  0017e	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00185	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  0018b	50		 push	 eax
  0018c	6a 00		 push	 0
  0018e	6a 03		 push	 3
  00190	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00195	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@CBOJAGFN@RoundStateMainWnd?3?3SetDungeonsSc@
  0019a	ff d3		 call	 ebx
  0019c	8b c8		 mov	 ecx, eax
  0019e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  001a4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  001ac	50		 push	 eax
  001ad	51		 push	 ecx
  001ae	8b ce		 mov	 ecx, esi
  001b0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001b5	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAEXMPBD0@Z ; ioComplexStringPrinter::AddTextPiece
  001ba	8d 4d c8	 lea	 ecx, DWORD PTR $T570998[ebp]
$LN47@SetDungeon:
  001bd	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  001c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ

; 2667 : 
; 2668 :     // 윈도우 세팅
; 2669 : 	RoundStateUserWnd *pUserWnd = dynamic_cast<RoundStateUserWnd *>(FindChildWnd( ID_SINGLE_WND ));

  001c7	6a 00		 push	 0
  001c9	68 00 00 00 00	 push	 OFFSET ??_R0?AVRoundStateUserWnd@@@8
  001ce	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWnd@@@8
  001d3	6a 00		 push	 0
  001d5	6a 03		 push	 3
  001d7	8b cf		 mov	 ecx, edi
  001d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?FindChildWnd@ioWnd@@QAEPAV1@K@Z
  001df	50		 push	 eax
  001e0	e8 00 00 00 00	 call	 ___RTDynamicCast
  001e5	8b f0		 mov	 esi, eax
  001e7	83 c4 14	 add	 esp, 20			; 00000014H

; 2670 : 	if( pUserWnd )

  001ea	85 f6		 test	 esi, esi
  001ec	74 77		 je	 SHORT $LN4@SetDungeon

; 2671 : 	{
; 2672 : 		int iUserSize = m_RoundInfoList.size();

  001ee	8b 87 68 01 00
	00		 mov	 eax, DWORD PTR [edi+360]
  001f4	2b 87 64 01 00
	00		 sub	 eax, DWORD PTR [edi+356]
  001fa	c1 f8 07	 sar	 eax, 7

; 2673 : 		for(int i = 0;i < iUserSize;i++)

  001fd	85 c0		 test	 eax, eax
  001ff	7e 2c		 jle	 SHORT $LN1@SetDungeon

; 2671 : 	{
; 2672 : 		int iUserSize = m_RoundInfoList.size();

  00201	83 65 ec 00	 and	 DWORD PTR tv437[ebp], 0
  00205	89 45 e8	 mov	 DWORD PTR tv309[ebp], eax
$LN3@SetDungeon:

; 2673 : 		for(int i = 0;i < iUserSize;i++)

  00208	8b 87 64 01 00
	00		 mov	 eax, DWORD PTR [edi+356]
  0020e	03 45 ec	 add	 eax, DWORD PTR tv437[ebp]

; 2674 : 		{
; 2675 : 			RoundInfo &rkInfo = m_RoundInfoList[i];
; 2676 : 
; 2677 : 			// 모두 블루 
; 2678 : 			rkInfo.m_Team = TEAM_BLUE;
; 2679 : 			pUserWnd->AddRoundInfo( rkInfo );

  00211	8d 8e 98 02 00
	00		 lea	 ecx, DWORD PTR [esi+664]
  00217	50		 push	 eax
  00218	c7 40 10 02 00
	00 00		 mov	 DWORD PTR [eax+16], 2
  0021f	e8 00 00 00 00	 call	 ?push_back@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXABURoundInfo@@@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::push_back
  00224	83 6d ec 80	 sub	 DWORD PTR tv437[ebp], -128 ; ffffff80H
  00228	ff 4d e8	 dec	 DWORD PTR tv309[ebp]
  0022b	75 db		 jne	 SHORT $LN3@SetDungeon
$LN1@SetDungeon:

; 2680 : 		}
; 2681 : 		pUserWnd->SetPlayStage( m_pPlayStage );

  0022d	8b 87 60 01 00
	00		 mov	 eax, DWORD PTR [edi+352]
  00233	89 86 94 02 00
	00		 mov	 DWORD PTR [esi+660], eax

; 2682 : 		pUserWnd->SetWindowTeam( TEAM_BLUE );

  00239	c7 86 58 02 00
	00 02 00 00 00	 mov	 DWORD PTR [esi+600], 2

; 2683 : 		pUserWnd->SetDungeonsScore( g_BattleRoomMgr.GetMaxPlayer(), iCurrentFloor );

  00243	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  00248	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  0024b	03 48 40	 add	 ecx, DWORD PTR [eax+64]
  0024e	8b 45 08	 mov	 eax, DWORD PTR _iCurrentFloor$[ebp]
  00251	89 8e 60 02 00
	00		 mov	 DWORD PTR [esi+608], ecx

; 2684 : 		pUserWnd->ShowWnd();

  00257	8b ce		 mov	 ecx, esi
  00259	89 86 64 02 00
	00		 mov	 DWORD PTR [esi+612], eax
  0025f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ShowWnd@ioWnd@@QAEXXZ
$LN4@SetDungeon:

; 2685 : 	}
; 2686 : }

  00265	e8 00 00 00 00	 call	 __EH_epilog3
  0026a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetDungeonsScore@RoundStateMainWnd@@UAEXH@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T570996[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?SetDungeonsScore@RoundStateMainWnd@@UAEXH@Z$1:
  00009	8d 4d d8	 lea	 ecx, DWORD PTR $T570997[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?SetDungeonsScore@RoundStateMainWnd@@UAEXH@Z$2:
  00012	8d 4d c8	 lea	 ecx, DWORD PTR $T570998[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$?SetDungeonsScore@RoundStateMainWnd@@UAEXH@Z:
  0001b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00022	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00025	33 c8		 xor	 ecx, eax
  00027	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetDungeonsScore@RoundStateMainWnd@@UAEXH@Z
  00031	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetDungeonsScore@RoundStateMainWnd@@UAEXH@Z ENDP	; RoundStateMainWnd::SetDungeonsScore
PUBLIC	??_C@_0CA@OJANIGEB@RoundStateMainWnd?3?3SetTeamScore?$AA@ ; `string'
;	COMDAT ??_C@_0CA@OJANIGEB@RoundStateMainWnd?3?3SetTeamScore?$AA@
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobattleroommgr.h
CONST	SEGMENT
??_C@_0CA@OJANIGEB@RoundStateMainWnd?3?3SetTeamScore?$AA@ DB 'RoundStateM'
	DB	'ainWnd::SetTeamScore', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetTeamScore@RoundStateMainWnd@@UAEXHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetTeamScore@RoundStateMainWnd@@UAEXHH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SetTeamScore@RoundStateMainWnd@@UAEXHH@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SetTeamScore@RoundStateMainWnd@@UAEXHH@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SetTeamScore@RoundStateMainWnd@@UAEXHH@Z$3
__ehfuncinfo$?SetTeamScore@RoundStateMainWnd@@UAEXHH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetTeamScore@RoundStateMainWnd@@UAEXHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
xdata$x	ENDS
;	COMDAT ?SetTeamScore@RoundStateMainWnd@@UAEXHH@Z
_TEXT	SEGMENT
$T571096 = -60						; size = 16
$T571095 = -44						; size = 16
$T571094 = -44						; size = 16
$T571092 = -44						; size = 16
tv588 = -28						; size = 4
tv828 = -24						; size = 4
_pBlueWnd$ = -20					; size = 4
$T571093 = -13						; size = 1
__$EHRec$ = -12						; size = 12
$T571089 = 8						; size = 1
tv590 = 8						; size = 4
_iBlueWin$ = 8						; size = 4
_iRedWin$ = 12						; size = 4
?SetTeamScore@RoundStateMainWnd@@UAEXHH@Z PROC		; RoundStateMainWnd::SetTeamScore, COMDAT
; _this$ = ecx

; 2689 : {

  00000	6a 30		 push	 48			; 00000030H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetTeamScore@RoundStateMainWnd@@UAEXHH@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b d9		 mov	 ebx, ecx

; 2690 : 	if( !m_pPlayStage  ) return;

  0000e	33 ff		 xor	 edi, edi
  00010	39 bb 60 01 00
	00		 cmp	 DWORD PTR [ebx+352], edi
  00016	0f 84 84 06 00
	00		 je	 $LN7@SetTeamSco@2

; 2691 : 
; 2692 : 	HideChildWnd( ID_PLAZA_WND );

  0001c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?HideChildWnd@ioWnd@@QAEXK_N@Z
  00022	57		 push	 edi
  00023	6a 02		 push	 2
  00025	ff d6		 call	 esi

; 2693 : 	HideChildWnd( ID_SINGLE_WND );

  00027	57		 push	 edi
  00028	6a 03		 push	 3
  0002a	8b cb		 mov	 ecx, ebx
  0002c	ff d6		 call	 esi

; 2694 : 	HideChildWnd( ID_BLUE_WND );

  0002e	57		 push	 edi
  0002f	6a 04		 push	 4
  00031	8b cb		 mov	 ecx, ebx
  00033	ff d6		 call	 esi

; 2695 : 	HideChildWnd( ID_RED_WND );

  00035	57		 push	 edi
  00036	6a 05		 push	 5
  00038	8b cb		 mov	 ecx, ebx
  0003a	ff d6		 call	 esi

; 2696 : 
; 2697 : 	std::sort( m_RoundInfoList.begin(), m_RoundInfoList.end(), RoundInfoSort() );

  0003c	ff 75 08	 push	 DWORD PTR $T571089[ebp]
  0003f	8b 83 68 01 00
	00		 mov	 eax, DWORD PTR [ebx+360]
  00045	8b 8b 64 01 00
	00		 mov	 ecx, DWORD PTR [ebx+356]
  0004b	50		 push	 eax
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$sort@V?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@VRoundInfoSort@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@0@0VRoundInfoSort@@@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >,RoundInfoSort>
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2698 : 
; 2699 : 	if( g_BattleRoomMgr.IsTournamentModeType() )

  00055	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  0005a	8b c8		 mov	 ecx, eax
  0005c	e8 00 00 00 00	 call	 ?IsTournamentModeType@ioBattleRoomMgr@@QAE_NXZ ; ioBattleRoomMgr::IsTournamentModeType
  00061	84 c0		 test	 al, al
  00063	0f 84 1d 01 00
	00		 je	 $LN26@SetTeamSco@2

; 2700 : 	{
; 2701 : 		SetTournamentData();

  00069	8b cb		 mov	 ecx, ebx
  0006b	e8 00 00 00 00	 call	 ?SetTournamentData@RoundStateMainWnd@@QAEXXZ ; RoundStateMainWnd::SetTournamentData

; 2702 : 
; 2703 : 		// 타이틀
; 2704 : 		m_Title.ClearList();

  00070	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00076	e8 00 00 00 00	 call	 ?ClearList@ioComplexStringPrinter@@QAEXXZ ; ioComplexStringPrinter::ClearList

; 2705 : 		m_Title.SetTextStyle( TS_OUTLINE_FULL_2X );

  0007b	6a 05		 push	 5
  0007d	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00083	e8 00 00 00 00	 call	 ?SetTextStyle@ioComplexStringPrinter@@QAEXW4TextStyle@@@Z ; ioComplexStringPrinter::SetTextStyle

; 2706 : 		m_Title.SetBkColor( 12, 66, 111 );

  00088	6a 6f		 push	 111			; 0000006fH
  0008a	6a 42		 push	 66			; 00000042H
  0008c	6a 0c		 push	 12			; 0000000cH
  0008e	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00094	e8 00 00 00 00	 call	 ?SetBkColor@ioComplexStringPrinter@@QAEXHHH@Z ; ioComplexStringPrinter::SetBkColor

; 2707 : 		m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  00099	6a ff		 push	 -1
  0009b	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  000a1	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2708 : 		m_Title.AddTextPiece( FONT_SIZE_17, STR(1) );

  000a6	57		 push	 edi
  000a7	6a 01		 push	 1
  000a9	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
  000ae	57		 push	 edi
  000af	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0CA@OJANIGEB@RoundStateMainWnd?3?3SetTeamScore?$AA@
  000b4	56		 push	 esi
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  000bb	8b c8		 mov	 ecx, eax
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  000c3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  000cb	50		 push	 eax
  000cc	51		 push	 ecx
  000cd	8d 83 74 01 00
	00		 lea	 eax, DWORD PTR [ebx+372]
  000d3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece

; 2709 : 		m_Title.AddTextPiece( FONT_SIZE_17, " | " );

  000de	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  000e6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_03LGOGDKEL@?5?$HM?5?$AA@
  000ee	51		 push	 ecx
  000ef	8d 83 74 01 00
	00		 lea	 eax, DWORD PTR [ebx+372]
  000f5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  00100	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2710 : 		m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  00103	6a ff		 push	 -1
  00105	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  0010b	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2711 : 		
; 2712 : 		if( m_iTournamentCurrentRound  <= 2 )

  00110	8b 83 94 01 00
	00		 mov	 eax, DWORD PTR [ebx+404]
  00116	83 f8 02	 cmp	 eax, 2
  00119	7f 37		 jg	 SHORT $LN25@SetTeamSco@2

; 2713 : 		{
; 2714 : 			m_Title.AddTextPiece( FONT_SIZE_17, STR(9) );

  0011b	6a 00		 push	 0
  0011d	6a 09		 push	 9
  0011f	57		 push	 edi
  00120	56		 push	 esi
  00121	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00127	8b c8		 mov	 ecx, eax
  00129	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0012f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  00137	50		 push	 eax
  00138	51		 push	 ecx
  00139	8d 83 74 01 00
	00		 lea	 eax, DWORD PTR [ebx+372]
  0013f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00144	50		 push	 eax
  00145	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  0014a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2715 : 		}
; 2716 : 		else

  0014d	e9 db 03 00 00	 jmp	 $LN15@SetTeamSco@2
$LN25@SetTeamSco@2:

; 2717 : 		{
; 2718 : 			m_Title.AddTextPiece( FONT_SIZE_17, STR(10), m_iTournamentCurrentRound );

  00152	50		 push	 eax
  00153	6a 00		 push	 0
  00155	6a 0a		 push	 10			; 0000000aH
  00157	57		 push	 edi
  00158	56		 push	 esi
  00159	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  0015f	8b c8		 mov	 ecx, eax
  00161	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  00167	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  0016f	50		 push	 eax
  00170	51		 push	 ecx
  00171	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00177	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0017c	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAEXMPBDH@Z ; ioComplexStringPrinter::AddTextPiece

; 2719 : 		}

  00181	e9 a7 03 00 00	 jmp	 $LN15@SetTeamSco@2
$LN26@SetTeamSco@2:

; 2720 : 		
; 2721 : 	}
; 2722 : 	else if( g_LadderTeamMgr.IsLadderTeam() )

  00186	e8 00 00 00 00	 call	 ?GetSingleton@ioLadderTeamMgr@@SAAAV1@XZ ; ioLadderTeamMgr::GetSingleton
  0018b	8b c8		 mov	 ecx, eax
  0018d	e8 00 00 00 00	 call	 ?IsLadderTeam@ioLadderTeamMgr@@QAE_NXZ ; ioLadderTeamMgr::IsLadderTeam
  00192	84 c0		 test	 al, al
  00194	0f 84 19 01 00
	00		 je	 $LN22@SetTeamSco@2

; 2723 : 	{
; 2724 : 		// 타이틀
; 2725 : 		m_Title.ClearList();

  0019a	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  001a0	e8 00 00 00 00	 call	 ?ClearList@ioComplexStringPrinter@@QAEXXZ ; ioComplexStringPrinter::ClearList

; 2726 : 		m_Title.SetTextStyle( TS_OUTLINE_FULL_2X );

  001a5	6a 05		 push	 5
  001a7	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  001ad	e8 00 00 00 00	 call	 ?SetTextStyle@ioComplexStringPrinter@@QAEXW4TextStyle@@@Z ; ioComplexStringPrinter::SetTextStyle

; 2727 : 		m_Title.SetBkColor( 12, 66, 111 );

  001b2	6a 6f		 push	 111			; 0000006fH
  001b4	6a 42		 push	 66			; 00000042H
  001b6	6a 0c		 push	 12			; 0000000cH
  001b8	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  001be	e8 00 00 00 00	 call	 ?SetBkColor@ioComplexStringPrinter@@QAEXHHH@Z ; ioComplexStringPrinter::SetBkColor

; 2728 : 		m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  001c3	6a ff		 push	 -1
  001c5	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  001cb	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2729 : 		m_Title.AddTextPiece( FONT_SIZE_17, STR(1) );

  001d0	57		 push	 edi
  001d1	6a 01		 push	 1
  001d3	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
  001d8	57		 push	 edi
  001d9	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0CA@OJANIGEB@RoundStateMainWnd?3?3SetTeamScore?$AA@
  001de	56		 push	 esi
  001df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  001e5	8b c8		 mov	 ecx, eax
  001e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  001ed	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  001f5	50		 push	 eax
  001f6	51		 push	 ecx
  001f7	8d 83 74 01 00
	00		 lea	 eax, DWORD PTR [ebx+372]
  001fd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00202	50		 push	 eax
  00203	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  00208	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2730 : 		m_Title.SetTextColor( TCT_DEFAULT_LIGHTGRAY );

  0020b	68 a7 a7 a7 ff	 push	 -5789785		; ffa7a7a7H
  00210	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00216	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2731 : 		m_Title.AddTextPiece( FONT_SIZE_17, " | " );

  0021b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  00223	68 00 00 00 00	 push	 OFFSET ??_C@_03LGOGDKEL@?5?$HM?5?$AA@
  00228	51		 push	 ecx
  00229	8d 83 74 01 00
	00		 lea	 eax, DWORD PTR [ebx+372]
  0022f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00234	50		 push	 eax
  00235	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  0023a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2732 : 		m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  0023d	6a ff		 push	 -1
  0023f	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00245	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2733 : 		if( g_LadderTeamMgr.GetLadderTeamPW().IsEmpty() )

  0024a	e8 00 00 00 00	 call	 ?GetSingleton@ioLadderTeamMgr@@SAAAV1@XZ ; ioLadderTeamMgr::GetSingleton
  0024f	8d 48 20	 lea	 ecx, DWORD PTR [eax+32]
  00252	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00258	84 c0		 test	 al, al
  0025a	74 15		 je	 SHORT $LN21@SetTeamSco@2

; 2734 : 			m_Title.AddTextPiece( FONT_SIZE_17, STR(2), g_LadderTeamMgr.GetLadderTeamName().c_str() );

  0025c	e8 00 00 00 00	 call	 ?GetSingleton@ioLadderTeamMgr@@SAAAV1@XZ ; ioLadderTeamMgr::GetSingleton
  00261	8d 48 10	 lea	 ecx, DWORD PTR [eax+16]
  00264	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  0026a	50		 push	 eax
  0026b	6a 00		 push	 0
  0026d	6a 02		 push	 2

; 2735 : 		else

  0026f	eb 13		 jmp	 SHORT $LN90@SetTeamSco@2
$LN21@SetTeamSco@2:

; 2736 : 			m_Title.AddTextPiece( FONT_SIZE_17, STR(3), g_LadderTeamMgr.GetLadderTeamName().c_str() );		

  00271	e8 00 00 00 00	 call	 ?GetSingleton@ioLadderTeamMgr@@SAAAV1@XZ ; ioLadderTeamMgr::GetSingleton
  00276	8d 48 10	 lea	 ecx, DWORD PTR [eax+16]
  00279	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  0027f	50		 push	 eax
  00280	6a 00		 push	 0
  00282	6a 03		 push	 3
$LN90@SetTeamSco@2:
  00284	57		 push	 edi
  00285	56		 push	 esi
  00286	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  0028c	8b c8		 mov	 ecx, eax
  0028e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  00294	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  0029c	50		 push	 eax
  0029d	51		 push	 ecx
  0029e	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  002a4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002a9	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAEXMPBD0@Z ; ioComplexStringPrinter::AddTextPiece
  002ae	e9 7a 02 00 00	 jmp	 $LN15@SetTeamSco@2
$LN22@SetTeamSco@2:

; 2737 : 	}
; 2738 : 	else if( g_ShuffleRoomMgr.IsShuffleRoom() )

  002b3	e8 00 00 00 00	 call	 ?GetSingleton@ioShuffleRoomMgr@@SAAAV1@XZ ; ioShuffleRoomMgr::GetSingleton
  002b8	8b c8		 mov	 ecx, eax
  002ba	e8 00 00 00 00	 call	 ?IsShuffleRoom@ioShuffleRoomMgr@@QAE_NXZ ; ioShuffleRoomMgr::IsShuffleRoom

; 2739 : 	{
; 2740 : 		// 타이틀
; 2741 : 		m_Title.ClearList();

  002bf	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  002c5	84 c0		 test	 al, al
  002c7	0f 84 fd 00 00
	00		 je	 $LN18@SetTeamSco@2
  002cd	e8 00 00 00 00	 call	 ?ClearList@ioComplexStringPrinter@@QAEXXZ ; ioComplexStringPrinter::ClearList

; 2742 : 		m_Title.SetTextStyle( TS_OUTLINE_FULL_2X );

  002d2	6a 05		 push	 5
  002d4	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  002da	e8 00 00 00 00	 call	 ?SetTextStyle@ioComplexStringPrinter@@QAEXW4TextStyle@@@Z ; ioComplexStringPrinter::SetTextStyle

; 2743 : 		m_Title.SetBkColor( 12, 66, 111 );

  002df	6a 6f		 push	 111			; 0000006fH
  002e1	6a 42		 push	 66			; 00000042H
  002e3	6a 0c		 push	 12			; 0000000cH
  002e5	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  002eb	e8 00 00 00 00	 call	 ?SetBkColor@ioComplexStringPrinter@@QAEXHHH@Z ; ioComplexStringPrinter::SetBkColor

; 2744 : 		m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  002f0	6a ff		 push	 -1
  002f2	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  002f8	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2745 : 		m_Title.AddTextPiece( FONT_SIZE_17, STR(11) );

  002fd	57		 push	 edi
  002fe	6a 0b		 push	 11			; 0000000bH
  00300	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00305	57		 push	 edi
  00306	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0CA@OJANIGEB@RoundStateMainWnd?3?3SetTeamScore?$AA@
  0030b	56		 push	 esi
  0030c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00312	8b c8		 mov	 ecx, eax
  00314	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0031a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  00322	50		 push	 eax
  00323	51		 push	 ecx
  00324	8d 83 74 01 00
	00		 lea	 eax, DWORD PTR [ebx+372]
  0032a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0032f	50		 push	 eax
  00330	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  00335	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2746 : 		m_Title.SetTextColor( TCT_DEFAULT_LIGHTGRAY );

  00338	68 a7 a7 a7 ff	 push	 -5789785		; ffa7a7a7H
  0033d	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00343	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2747 : 		m_Title.AddTextPiece( FONT_SIZE_17, " | " );

  00348	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  00350	68 00 00 00 00	 push	 OFFSET ??_C@_03LGOGDKEL@?5?$HM?5?$AA@
  00355	51		 push	 ecx
  00356	8d 83 74 01 00
	00		 lea	 eax, DWORD PTR [ebx+372]
  0035c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00361	50		 push	 eax
  00362	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  00367	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2748 : 		m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  0036a	6a ff		 push	 -1
  0036c	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00372	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2749 : 		m_Title.AddTextPiece( FONT_SIZE_17, STR(12), g_ShuffleRoomMgr.GetName().c_str() );

  00377	8d 45 d4	 lea	 eax, DWORD PTR $T571092[ebp]
  0037a	50		 push	 eax
  0037b	e8 00 00 00 00	 call	 ?GetSingleton@ioShuffleRoomMgr@@SAAAV1@XZ ; ioShuffleRoomMgr::GetSingleton
  00380	8b c8		 mov	 ecx, eax
  00382	e8 00 00 00 00	 call	 ?GetName@ioShuffleRoomMgr@@QAE?AVioHashString@@XZ ; ioShuffleRoomMgr::GetName
  00387	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0038b	8b c8		 mov	 ecx, eax
  0038d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00393	50		 push	 eax
  00394	6a 00		 push	 0
  00396	6a 0c		 push	 12			; 0000000cH
$LN89@SetTeamSco@2:
  00398	57		 push	 edi
  00399	56		 push	 esi
  0039a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  003a0	8b c8		 mov	 ecx, eax
  003a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  003a8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  003b0	50		 push	 eax
  003b1	51		 push	 ecx
  003b2	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  003b8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003bd	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAEXMPBD0@Z ; ioComplexStringPrinter::AddTextPiece
  003c2	8d 4d d4	 lea	 ecx, DWORD PTR $T571092[ebp]

; 2750 : 	}
; 2751 : 	else

  003c5	e9 59 01 00 00	 jmp	 $LN88@SetTeamSco@2
$LN18@SetTeamSco@2:

; 2752 : 	{
; 2753 : 		// 타이틀
; 2754 : 		m_Title.ClearList();

  003ca	e8 00 00 00 00	 call	 ?ClearList@ioComplexStringPrinter@@QAEXXZ ; ioComplexStringPrinter::ClearList

; 2755 : 		m_Title.SetTextStyle( TS_OUTLINE_FULL_2X );

  003cf	6a 05		 push	 5
  003d1	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  003d7	e8 00 00 00 00	 call	 ?SetTextStyle@ioComplexStringPrinter@@QAEXW4TextStyle@@@Z ; ioComplexStringPrinter::SetTextStyle

; 2756 : 		m_Title.SetBkColor( 12, 66, 111 );

  003dc	6a 6f		 push	 111			; 0000006fH
  003de	6a 42		 push	 66			; 00000042H
  003e0	6a 0c		 push	 12			; 0000000cH
  003e2	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  003e8	e8 00 00 00 00	 call	 ?SetBkColor@ioComplexStringPrinter@@QAEXHHH@Z ; ioComplexStringPrinter::SetBkColor

; 2757 : 		m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  003ed	6a ff		 push	 -1
  003ef	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  003f5	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2758 : 		m_Title.AddTextPiece( FONT_SIZE_17, STR(4) );

  003fa	57		 push	 edi
  003fb	6a 04		 push	 4
  003fd	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00402	57		 push	 edi
  00403	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0CA@OJANIGEB@RoundStateMainWnd?3?3SetTeamScore?$AA@
  00408	56		 push	 esi
  00409	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  0040f	8b c8		 mov	 ecx, eax
  00411	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  00417	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  0041f	50		 push	 eax
  00420	51		 push	 ecx
  00421	8d 83 74 01 00
	00		 lea	 eax, DWORD PTR [ebx+372]
  00427	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0042c	50		 push	 eax
  0042d	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  00432	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2759 : 		m_Title.SetTextColor( TCT_DEFAULT_LIGHTGRAY );

  00435	68 a7 a7 a7 ff	 push	 -5789785		; ffa7a7a7H
  0043a	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00440	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2760 : 		m_Title.AddTextPiece( FONT_SIZE_17, " | " );

  00445	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  0044d	68 00 00 00 00	 push	 OFFSET ??_C@_03LGOGDKEL@?5?$HM?5?$AA@
  00452	51		 push	 ecx
  00453	8d 83 74 01 00
	00		 lea	 eax, DWORD PTR [ebx+372]
  00459	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0045e	50		 push	 eax
  0045f	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  00464	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2761 : 		m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  00467	6a ff		 push	 -1
  00469	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  0046f	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2762 : 		if( g_BattleRoomMgr.GetPW().IsEmpty() )

  00474	8d 45 d4	 lea	 eax, DWORD PTR $T571094[ebp]
  00477	50		 push	 eax
  00478	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  0047d	8b c8		 mov	 ecx, eax
  0047f	e8 00 00 00 00	 call	 ?GetPW@ioBattleRoomMgr@@QAE?AVioHashString@@XZ ; ioBattleRoomMgr::GetPW
  00484	8b c8		 mov	 ecx, eax
  00486	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0048d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00493	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00497	8d 4d d4	 lea	 ecx, DWORD PTR $T571094[ebp]
  0049a	88 45 f3	 mov	 BYTE PTR $T571093[ebp], al
  0049d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  004a3	80 7d f3 00	 cmp	 BYTE PTR $T571093[ebp], 0
  004a7	74 29		 je	 SHORT $LN16@SetTeamSco@2

; 2763 : 			m_Title.AddTextPiece( FONT_SIZE_17, STR(5), g_BattleRoomMgr.GetName().c_str() );

  004a9	8d 45 d4	 lea	 eax, DWORD PTR $T571095[ebp]
  004ac	50		 push	 eax
  004ad	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  004b2	8b c8		 mov	 ecx, eax
  004b4	e8 00 00 00 00	 call	 ?GetName@ioBattleRoomMgr@@QAE?AVioHashString@@XZ ; ioBattleRoomMgr::GetName
  004b9	8b c8		 mov	 ecx, eax
  004bb	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  004c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  004c8	50		 push	 eax
  004c9	6a 00		 push	 0
  004cb	6a 05		 push	 5

; 2764 : 		else

  004cd	e9 c6 fe ff ff	 jmp	 $LN89@SetTeamSco@2
$LN16@SetTeamSco@2:

; 2765 : 			m_Title.AddTextPiece( FONT_SIZE_17, STR(6), g_BattleRoomMgr.GetName().c_str() );		

  004d2	8d 45 c4	 lea	 eax, DWORD PTR $T571096[ebp]
  004d5	50		 push	 eax
  004d6	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  004db	8b c8		 mov	 ecx, eax
  004dd	e8 00 00 00 00	 call	 ?GetName@ioBattleRoomMgr@@QAE?AVioHashString@@XZ ; ioBattleRoomMgr::GetName
  004e2	8b c8		 mov	 ecx, eax
  004e4	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  004eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  004f1	50		 push	 eax
  004f2	6a 00		 push	 0
  004f4	6a 06		 push	 6
  004f6	57		 push	 edi
  004f7	56		 push	 esi
  004f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  004fe	8b c8		 mov	 ecx, eax
  00500	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  00506	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  0050e	50		 push	 eax
  0050f	51		 push	 ecx
  00510	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00516	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0051b	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAEXMPBD0@Z ; ioComplexStringPrinter::AddTextPiece
  00520	8d 4d c4	 lea	 ecx, DWORD PTR $T571096[ebp]
$LN88@SetTeamSco@2:
  00523	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00527	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
$LN15@SetTeamSco@2:

; 2766 : 	}
; 2767 : 
; 2768 : 	RoundStateUserWnd *pBlueWnd = dynamic_cast<RoundStateUserWnd *>(FindChildWnd( ID_BLUE_WND ));

  0052d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?FindChildWnd@ioWnd@@QAEPAV1@K@Z
  00533	6a 00		 push	 0
  00535	68 00 00 00 00	 push	 OFFSET ??_R0?AVRoundStateUserWnd@@@8
  0053a	bf 00 00 00 00	 mov	 edi, OFFSET ??_R0?AVioWnd@@@8
  0053f	57		 push	 edi
  00540	6a 00		 push	 0
  00542	6a 04		 push	 4
  00544	8b cb		 mov	 ecx, ebx
  00546	ff d6		 call	 esi
  00548	50		 push	 eax
  00549	e8 00 00 00 00	 call	 ___RTDynamicCast
  0054e	8b c8		 mov	 ecx, eax
  00550	83 c4 14	 add	 esp, 20			; 00000014H
  00553	89 4d ec	 mov	 DWORD PTR _pBlueWnd$[ebp], ecx

; 2769 : 	if( pBlueWnd )

  00556	85 c9		 test	 ecx, ecx
  00558	0f 84 91 00 00
	00		 je	 $LN14@SetTeamSco@2

; 2770 : 	{
; 2771 : 		int iUserSize = m_RoundInfoList.size();

  0055e	8b 83 68 01 00
	00		 mov	 eax, DWORD PTR [ebx+360]
  00564	2b 83 64 01 00
	00		 sub	 eax, DWORD PTR [ebx+356]
  0056a	c1 f8 07	 sar	 eax, 7

; 2772 : 		for(int i = 0;i < iUserSize;i++)

  0056d	85 c0		 test	 eax, eax
  0056f	7e 2e		 jle	 SHORT $LN11@SetTeamSco@2

; 2770 : 	{
; 2771 : 		int iUserSize = m_RoundInfoList.size();

  00571	83 65 e8 00	 and	 DWORD PTR tv828[ebp], 0
  00575	89 45 e4	 mov	 DWORD PTR tv588[ebp], eax
$LL13@SetTeamSco@2:

; 2772 : 		for(int i = 0;i < iUserSize;i++)

  00578	8b 83 64 01 00
	00		 mov	 eax, DWORD PTR [ebx+356]
  0057e	03 45 e8	 add	 eax, DWORD PTR tv828[ebp]

; 2773 : 		{
; 2774 : 			RoundInfo &rkInfo = m_RoundInfoList[i];
; 2775 : 			if( rkInfo.m_Team == TEAM_BLUE )

  00581	83 78 10 02	 cmp	 DWORD PTR [eax+16], 2
  00585	75 0f		 jne	 SHORT $LN12@SetTeamSco@2

; 2776 : 				pBlueWnd->AddRoundInfo( rkInfo );

  00587	50		 push	 eax
  00588	81 c1 98 02 00
	00		 add	 ecx, 664		; 00000298H
  0058e	e8 00 00 00 00	 call	 ?push_back@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXABURoundInfo@@@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::push_back
  00593	8b 4d ec	 mov	 ecx, DWORD PTR _pBlueWnd$[ebp]
$LN12@SetTeamSco@2:

; 2772 : 		for(int i = 0;i < iUserSize;i++)

  00596	83 6d e8 80	 sub	 DWORD PTR tv828[ebp], -128 ; ffffff80H
  0059a	ff 4d e4	 dec	 DWORD PTR tv588[ebp]
  0059d	75 d9		 jne	 SHORT $LL13@SetTeamSco@2
$LN11@SetTeamSco@2:

; 2777 : 		}
; 2778 : 
; 2779 : 		pBlueWnd->SetWindowTeam( TEAM_BLUE );

  0059f	c7 81 58 02 00
	00 02 00 00 00	 mov	 DWORD PTR [ecx+600], 2

; 2780 : 		pBlueWnd->SetPlayStage( m_pPlayStage );

  005a9	8b 83 60 01 00
	00		 mov	 eax, DWORD PTR [ebx+352]
  005af	89 81 94 02 00
	00		 mov	 DWORD PTR [ecx+660], eax

; 2781 : 		if( g_LadderTeamMgr.IsLadderTeam() )

  005b5	e8 00 00 00 00	 call	 ?GetSingleton@ioLadderTeamMgr@@SAAAV1@XZ ; ioLadderTeamMgr::GetSingleton
  005ba	8b c8		 mov	 ecx, eax
  005bc	e8 00 00 00 00	 call	 ?IsLadderTeam@ioLadderTeamMgr@@QAE_NXZ ; ioLadderTeamMgr::IsLadderTeam
  005c1	84 c0		 test	 al, al
  005c3	74 0e		 je	 SHORT $LN9@SetTeamSco@2

; 2782 : 		{
; 2783 : 			const LadderTeamInfo &rkTeamInfo = g_LadderTeamMgr.GetLadderBlueTeamInfo();

  005c5	e8 00 00 00 00	 call	 ?GetSingleton@ioLadderTeamMgr@@SAAAV1@XZ ; ioLadderTeamMgr::GetSingleton
  005ca	8b c8		 mov	 ecx, eax
  005cc	e8 00 00 00 00	 call	 ?GetLadderBlueTeamInfo@ioLadderTeamMgr@@QAEABUtagLadderTeamInfo@@XZ ; ioLadderTeamMgr::GetLadderBlueTeamInfo

; 2784 : 			pBlueWnd->SetTeamScore( rkTeamInfo.m_iMaxPlayer, iBlueWin );
; 2785 : 		}
; 2786 : 		else

  005d1	eb 05		 jmp	 SHORT $LN91@SetTeamSco@2
$LN9@SetTeamSco@2:

; 2787 : 			pBlueWnd->SetTeamScore( g_BattleRoomMgr.GetMaxPlayerBlue(), iBlueWin );

  005d3	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
$LN91@SetTeamSco@2:
  005d8	ff 75 08	 push	 DWORD PTR _iBlueWin$[ebp]
  005db	8b 4d ec	 mov	 ecx, DWORD PTR _pBlueWnd$[ebp]
  005de	ff 70 40	 push	 DWORD PTR [eax+64]
  005e1	e8 00 00 00 00	 call	 ?SetTeamScore@RoundStateUserWnd@@QAEXHH@Z ; RoundStateUserWnd::SetTeamScore

; 2788 : 		pBlueWnd->ShowWnd();

  005e6	8b 4d ec	 mov	 ecx, DWORD PTR _pBlueWnd$[ebp]
  005e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ShowWnd@ioWnd@@QAEXXZ
$LN14@SetTeamSco@2:

; 2789 : 	}
; 2790 : 
; 2791 : 	RoundStateUserWnd *pRedWnd = dynamic_cast<RoundStateUserWnd *>(FindChildWnd( ID_RED_WND ));

  005ef	6a 00		 push	 0
  005f1	68 00 00 00 00	 push	 OFFSET ??_R0?AVRoundStateUserWnd@@@8
  005f6	57		 push	 edi
  005f7	6a 00		 push	 0
  005f9	6a 05		 push	 5
  005fb	8b cb		 mov	 ecx, ebx
  005fd	ff d6		 call	 esi
  005ff	50		 push	 eax
  00600	e8 00 00 00 00	 call	 ___RTDynamicCast
  00605	8b f0		 mov	 esi, eax
  00607	83 c4 14	 add	 esp, 20			; 00000014H

; 2792 : 	if( pRedWnd )

  0060a	85 f6		 test	 esi, esi
  0060c	0f 84 8e 00 00
	00		 je	 $LN7@SetTeamSco@2

; 2793 : 	{
; 2794 : 		int iUserSize = m_RoundInfoList.size();

  00612	8b 83 68 01 00
	00		 mov	 eax, DWORD PTR [ebx+360]
  00618	2b 83 64 01 00
	00		 sub	 eax, DWORD PTR [ebx+356]
  0061e	c1 f8 07	 sar	 eax, 7

; 2795 : 		for(int i = 0;i < iUserSize;i++)

  00621	85 c0		 test	 eax, eax
  00623	7e 27		 jle	 SHORT $LN4@SetTeamSco@2

; 2793 : 	{
; 2794 : 		int iUserSize = m_RoundInfoList.size();

  00625	33 ff		 xor	 edi, edi
  00627	89 45 08	 mov	 DWORD PTR tv590[ebp], eax
$LL6@SetTeamSco@2:

; 2795 : 		for(int i = 0;i < iUserSize;i++)

  0062a	8b 83 64 01 00
	00		 mov	 eax, DWORD PTR [ebx+356]
  00630	03 c7		 add	 eax, edi

; 2796 : 		{
; 2797 : 			RoundInfo &rkInfo = m_RoundInfoList[i];
; 2798 : 			if( rkInfo.m_Team == TEAM_RED )

  00632	83 78 10 01	 cmp	 DWORD PTR [eax+16], 1
  00636	75 0c		 jne	 SHORT $LN5@SetTeamSco@2

; 2799 : 				pRedWnd->AddRoundInfo( rkInfo );

  00638	50		 push	 eax
  00639	8d 8e 98 02 00
	00		 lea	 ecx, DWORD PTR [esi+664]
  0063f	e8 00 00 00 00	 call	 ?push_back@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXABURoundInfo@@@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::push_back
$LN5@SetTeamSco@2:

; 2795 : 		for(int i = 0;i < iUserSize;i++)

  00644	83 ef 80	 sub	 edi, -128		; ffffff80H
  00647	ff 4d 08	 dec	 DWORD PTR tv590[ebp]
  0064a	75 de		 jne	 SHORT $LL6@SetTeamSco@2
$LN4@SetTeamSco@2:

; 2800 : 		}
; 2801 : 
; 2802 : 		pRedWnd->SetWindowTeam( TEAM_RED );

  0064c	c7 86 58 02 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+600], 1

; 2803 : 		pRedWnd->SetPlayStage( m_pPlayStage );

  00656	8b 83 60 01 00
	00		 mov	 eax, DWORD PTR [ebx+352]
  0065c	89 86 94 02 00
	00		 mov	 DWORD PTR [esi+660], eax

; 2804 : 		if( g_LadderTeamMgr.IsLadderTeam() )

  00662	e8 00 00 00 00	 call	 ?GetSingleton@ioLadderTeamMgr@@SAAAV1@XZ ; ioLadderTeamMgr::GetSingleton
  00667	8b c8		 mov	 ecx, eax
  00669	e8 00 00 00 00	 call	 ?IsLadderTeam@ioLadderTeamMgr@@QAE_NXZ ; ioLadderTeamMgr::IsLadderTeam
  0066e	84 c0		 test	 al, al
  00670	74 14		 je	 SHORT $LN2@SetTeamSco@2

; 2805 : 		{
; 2806 : 			const LadderTeamInfo &rkTeamInfo = g_LadderTeamMgr.GetLadderRedTeamInfo();

  00672	e8 00 00 00 00	 call	 ?GetSingleton@ioLadderTeamMgr@@SAAAV1@XZ ; ioLadderTeamMgr::GetSingleton
  00677	8b c8		 mov	 ecx, eax
  00679	e8 00 00 00 00	 call	 ?GetLadderRedTeamInfo@ioLadderTeamMgr@@QAEABUtagLadderTeamInfo@@XZ ; ioLadderTeamMgr::GetLadderRedTeamInfo

; 2807 : 			pRedWnd->SetTeamScore( rkTeamInfo.m_iMaxPlayer, iRedWin );

  0067e	ff 75 0c	 push	 DWORD PTR _iRedWin$[ebp]
  00681	ff 70 40	 push	 DWORD PTR [eax+64]

; 2808 : 		}
; 2809 : 		else

  00684	eb 0b		 jmp	 SHORT $LN92@SetTeamSco@2
$LN2@SetTeamSco@2:

; 2810 : 			pRedWnd->SetTeamScore( g_BattleRoomMgr.GetMaxPlayerRed(), iRedWin );

  00686	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  0068b	ff 75 0c	 push	 DWORD PTR _iRedWin$[ebp]
  0068e	ff 70 44	 push	 DWORD PTR [eax+68]
$LN92@SetTeamSco@2:
  00691	8b ce		 mov	 ecx, esi
  00693	e8 00 00 00 00	 call	 ?SetTeamScore@RoundStateUserWnd@@QAEXHH@Z ; RoundStateUserWnd::SetTeamScore

; 2811 : 		pRedWnd->ShowWnd();

  00698	8b ce		 mov	 ecx, esi
  0069a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ShowWnd@ioWnd@@QAEXXZ
$LN7@SetTeamSco@2:

; 2812 : 	}			
; 2813 : }

  006a0	e8 00 00 00 00	 call	 __EH_epilog3
  006a5	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetTeamScore@RoundStateMainWnd@@UAEXHH@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR $T571092[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?SetTeamScore@RoundStateMainWnd@@UAEXHH@Z$1:
  00009	8d 4d d4	 lea	 ecx, DWORD PTR $T571094[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?SetTeamScore@RoundStateMainWnd@@UAEXHH@Z$2:
  00012	8d 4d d4	 lea	 ecx, DWORD PTR $T571095[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?SetTeamScore@RoundStateMainWnd@@UAEXHH@Z$3:
  0001b	8d 4d c4	 lea	 ecx, DWORD PTR $T571096[ebp]
  0001e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$?SetTeamScore@RoundStateMainWnd@@UAEXHH@Z:
  00024	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00028	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002b	8b 4a c0	 mov	 ecx, DWORD PTR [edx-64]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetTeamScore@RoundStateMainWnd@@UAEXHH@Z
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetTeamScore@RoundStateMainWnd@@UAEXHH@Z ENDP		; RoundStateMainWnd::SetTeamScore
PUBLIC	??_C@_0CF@CLFOAPJM@RoundStateMainWnd?3?3SetStarCountS@ ; `string'
;	COMDAT ??_C@_0CF@CLFOAPJM@RoundStateMainWnd?3?3SetStarCountS@
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobattleroommgr.h
CONST	SEGMENT
??_C@_0CF@CLFOAPJM@RoundStateMainWnd?3?3SetStarCountS@ DB 'RoundStateMain'
	DB	'Wnd::SetStarCountScore', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetStarCountScore@RoundStateMainWnd@@UAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetStarCountScore@RoundStateMainWnd@@UAEXXZ$0
__ehfuncinfo$?SetStarCountScore@RoundStateMainWnd@@UAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetStarCountScore@RoundStateMainWnd@@UAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
xdata$x	ENDS
;	COMDAT ?SetStarCountScore@RoundStateMainWnd@@UAEXXZ
_TEXT	SEGMENT
$T571230 = -36						; size = 16
tv279 = -20						; size = 4
$T571227 = -20						; size = 1
tv400 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SetStarCountScore@RoundStateMainWnd@@UAEXXZ PROC	; RoundStateMainWnd::SetStarCountScore, COMDAT
; _this$ = ecx

; 2816 : {

  00000	6a 18		 push	 24			; 00000018H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetStarCountScore@RoundStateMainWnd@@UAEXXZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx

; 2817 : 	if( !m_pPlayStage ) return;

  0000e	33 db		 xor	 ebx, ebx
  00010	39 9e 60 01 00
	00		 cmp	 DWORD PTR [esi+352], ebx
  00016	0f 84 ba 01 00
	00		 je	 $LN6@SetStarCou

; 2818 : 
; 2819 : 	HideChildWnd( ID_PLAZA_WND );

  0001c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?HideChildWnd@ioWnd@@QAEXK_N@Z
  00022	53		 push	 ebx
  00023	6a 02		 push	 2
  00025	ff d7		 call	 edi

; 2820 : 	HideChildWnd( ID_SINGLE_WND );

  00027	53		 push	 ebx
  00028	6a 03		 push	 3
  0002a	8b ce		 mov	 ecx, esi
  0002c	ff d7		 call	 edi

; 2821 : 	HideChildWnd( ID_BLUE_WND );

  0002e	53		 push	 ebx
  0002f	6a 04		 push	 4
  00031	8b ce		 mov	 ecx, esi
  00033	ff d7		 call	 edi

; 2822 : 	HideChildWnd( ID_RED_WND );

  00035	53		 push	 ebx
  00036	6a 05		 push	 5
  00038	8b ce		 mov	 ecx, esi
  0003a	ff d7		 call	 edi

; 2823 : 
; 2824 : 	std::sort( m_RoundInfoList.begin(), m_RoundInfoList.end(), RoundInfoStarSort() );

  0003c	ff 75 ec	 push	 DWORD PTR $T571227[ebp]
  0003f	8b 86 68 01 00
	00		 mov	 eax, DWORD PTR [esi+360]
  00045	8b 8e 64 01 00
	00		 mov	 ecx, DWORD PTR [esi+356]
  0004b	50		 push	 eax
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$sort@V?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@VRoundInfoStarSort@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@0@0VRoundInfoStarSort@@@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >,RoundInfoStarSort>

; 2825 : 
; 2826 : 	// 타이틀
; 2827 : 	m_Title.ClearList();

  00052	8d be 74 01 00
	00		 lea	 edi, DWORD PTR [esi+372]
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005b	8b cf		 mov	 ecx, edi
  0005d	e8 00 00 00 00	 call	 ?ClearList@ioComplexStringPrinter@@QAEXXZ ; ioComplexStringPrinter::ClearList

; 2828 : 	m_Title.SetTextStyle( TS_OUTLINE_FULL_2X );

  00062	6a 05		 push	 5
  00064	8b cf		 mov	 ecx, edi
  00066	e8 00 00 00 00	 call	 ?SetTextStyle@ioComplexStringPrinter@@QAEXW4TextStyle@@@Z ; ioComplexStringPrinter::SetTextStyle

; 2829 : 	m_Title.SetBkColor( 12, 66, 111 );

  0006b	6a 6f		 push	 111			; 0000006fH
  0006d	6a 42		 push	 66			; 00000042H
  0006f	6a 0c		 push	 12			; 0000000cH
  00071	8b cf		 mov	 ecx, edi
  00073	e8 00 00 00 00	 call	 ?SetBkColor@ioComplexStringPrinter@@QAEXHHH@Z ; ioComplexStringPrinter::SetBkColor

; 2830 : 	m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  00078	6a ff		 push	 -1
  0007a	8b cf		 mov	 ecx, edi
  0007c	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2831 : 	m_Title.AddTextPiece( FONT_SIZE_17, STR(1) );

  00081	53		 push	 ebx
  00082	6a 01		 push	 1
  00084	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00089	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@CLFOAPJM@RoundStateMainWnd?3?3SetStarCountS@
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00094	8b c8		 mov	 ecx, eax
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0009c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  000a4	50		 push	 eax
  000a5	51		 push	 ecx
  000a6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ab	57		 push	 edi
  000ac	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2832 : 	m_Title.SetTextColor( TCT_DEFAULT_LIGHTGRAY );

  000b4	68 a7 a7 a7 ff	 push	 -5789785		; ffa7a7a7H
  000b9	8b cf		 mov	 ecx, edi
  000bb	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2833 : 	m_Title.AddTextPiece( FONT_SIZE_17, " | " );

  000c0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  000c8	68 00 00 00 00	 push	 OFFSET ??_C@_03LGOGDKEL@?5?$HM?5?$AA@
  000cd	51		 push	 ecx
  000ce	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d3	57		 push	 edi
  000d4	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  000d9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2834 : 	m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  000dc	6a ff		 push	 -1
  000de	8b cf		 mov	 ecx, edi
  000e0	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2835 : 	m_Title.AddTextPiece( FONT_SIZE_17, STR(2), g_ShuffleRoomMgr.GetName().c_str() );

  000e5	8d 45 dc	 lea	 eax, DWORD PTR $T571230[ebp]
  000e8	50		 push	 eax
  000e9	e8 00 00 00 00	 call	 ?GetSingleton@ioShuffleRoomMgr@@SAAAV1@XZ ; ioShuffleRoomMgr::GetSingleton
  000ee	8b c8		 mov	 ecx, eax
  000f0	e8 00 00 00 00	 call	 ?GetName@ioShuffleRoomMgr@@QAE?AVioHashString@@XZ ; ioShuffleRoomMgr::GetName
  000f5	8b c8		 mov	 ecx, eax
  000f7	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  000fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00100	50		 push	 eax
  00101	53		 push	 ebx
  00102	6a 02		 push	 2
  00104	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00109	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@CLFOAPJM@RoundStateMainWnd?3?3SetStarCountS@
  0010e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00114	8b c8		 mov	 ecx, eax
  00116	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0011c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  00124	50		 push	 eax
  00125	51		 push	 ecx
  00126	8b cf		 mov	 ecx, edi
  00128	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0012d	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAEXMPBD0@Z ; ioComplexStringPrinter::AddTextPiece
  00132	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00136	8d 4d dc	 lea	 ecx, DWORD PTR $T571230[ebp]
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ

; 2836 : 
; 2837 : 	// 윈도우 세팅
; 2838 : 	RoundStateUserWnd *pUserWnd = dynamic_cast<RoundStateUserWnd *>(FindChildWnd( ID_SINGLE_WND ));

  0013f	53		 push	 ebx
  00140	68 00 00 00 00	 push	 OFFSET ??_R0?AVRoundStateUserWnd@@@8
  00145	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWnd@@@8
  0014a	53		 push	 ebx
  0014b	6a 03		 push	 3
  0014d	8b ce		 mov	 ecx, esi
  0014f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?FindChildWnd@ioWnd@@QAEPAV1@K@Z
  00155	50		 push	 eax
  00156	e8 00 00 00 00	 call	 ___RTDynamicCast
  0015b	8b f8		 mov	 edi, eax
  0015d	83 c4 14	 add	 esp, 20			; 00000014H

; 2839 : 	if( pUserWnd )

  00160	3b fb		 cmp	 edi, ebx
  00162	74 72		 je	 SHORT $LN6@SetStarCou

; 2840 : 	{
; 2841 : 		int iUserSize = m_RoundInfoList.size();

  00164	8b 86 68 01 00
	00		 mov	 eax, DWORD PTR [esi+360]
  0016a	2b 86 64 01 00
	00		 sub	 eax, DWORD PTR [esi+356]
  00170	c1 f8 07	 sar	 eax, 7

; 2842 : 		for(int i = 0;i < iUserSize;i++)

  00173	3b c3		 cmp	 eax, ebx
  00175	7e 30		 jle	 SHORT $LN3@SetStarCou

; 2840 : 	{
; 2841 : 		int iUserSize = m_RoundInfoList.size();

  00177	89 5d f0	 mov	 DWORD PTR tv400[ebp], ebx
  0017a	89 45 ec	 mov	 DWORD PTR tv279[ebp], eax
$LN5@SetStarCou:

; 2842 : 		for(int i = 0;i < iUserSize;i++)

  0017d	8b 86 64 01 00
	00		 mov	 eax, DWORD PTR [esi+356]
  00183	03 45 f0	 add	 eax, DWORD PTR tv400[ebp]

; 2843 : 		{
; 2844 : 			RoundInfo &rkInfo = m_RoundInfoList[i];
; 2845 : 
; 2846 : 			// 자신은 블루 
; 2847 : 			if( rkInfo.m_bOwner )

  00186	33 c9		 xor	 ecx, ecx
  00188	38 58 54	 cmp	 BYTE PTR [eax+84], bl

; 2848 : 				rkInfo.m_Team = TEAM_BLUE;
; 2849 : 			else
; 2850 : 				rkInfo.m_Team = TEAM_RED;
; 2851 : 			pUserWnd->AddRoundInfo( rkInfo );

  0018b	50		 push	 eax
  0018c	0f 95 c1	 setne	 cl
  0018f	41		 inc	 ecx
  00190	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00193	8d 8f 98 02 00
	00		 lea	 ecx, DWORD PTR [edi+664]
  00199	e8 00 00 00 00	 call	 ?push_back@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXABURoundInfo@@@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::push_back
  0019e	83 6d f0 80	 sub	 DWORD PTR tv400[ebp], -128 ; ffffff80H
  001a2	ff 4d ec	 dec	 DWORD PTR tv279[ebp]
  001a5	75 d6		 jne	 SHORT $LN5@SetStarCou
$LN3@SetStarCou:

; 2852 : 		}
; 2853 : 		pUserWnd->SetPlayStage( m_pPlayStage );

  001a7	8b 86 60 01 00
	00		 mov	 eax, DWORD PTR [esi+352]
  001ad	89 87 94 02 00
	00		 mov	 DWORD PTR [edi+660], eax

; 2854 : 		pUserWnd->SetWindowTeam( TEAM_RED );

  001b3	c7 87 58 02 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+600], 1

; 2855 : 		pUserWnd->SetSingleScore( g_BattleRoomMgr.GetMaxPlayer() );

  001bd	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  001c2	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  001c5	03 48 40	 add	 ecx, DWORD PTR [eax+64]
  001c8	51		 push	 ecx
  001c9	8b cf		 mov	 ecx, edi
  001cb	e8 00 00 00 00	 call	 ?SetSingleScore@RoundStateUserWnd@@QAEXH@Z ; RoundStateUserWnd::SetSingleScore

; 2856 : 		pUserWnd->ShowWnd();

  001d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ShowWnd@ioWnd@@QAEXXZ
$LN6@SetStarCou:

; 2857 : 	}
; 2858 : }

  001d6	e8 00 00 00 00	 call	 __EH_epilog3
  001db	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetStarCountScore@RoundStateMainWnd@@UAEXXZ$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR $T571230[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$?SetStarCountScore@RoundStateMainWnd@@UAEXXZ:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetStarCountScore@RoundStateMainWnd@@UAEXXZ
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetStarCountScore@RoundStateMainWnd@@UAEXXZ ENDP	; RoundStateMainWnd::SetStarCountScore
PUBLIC	??_C@_0CJ@DHNLDFAL@RoundStateMainWnd?3?3SetRaidCoinCo@ ; `string'
;	COMDAT ??_C@_0CJ@DHNLDFAL@RoundStateMainWnd?3?3SetRaidCoinCo@
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobattleroommgr.h
CONST	SEGMENT
??_C@_0CJ@DHNLDFAL@RoundStateMainWnd?3?3SetRaidCoinCo@ DB 'RoundStateMain'
	DB	'Wnd::SetRaidCoinCountScore', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetRaidCoinCountScore@RoundStateMainWnd@@UAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetRaidCoinCountScore@RoundStateMainWnd@@UAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SetRaidCoinCountScore@RoundStateMainWnd@@UAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SetRaidCoinCountScore@RoundStateMainWnd@@UAEXXZ$2
__ehfuncinfo$?SetRaidCoinCountScore@RoundStateMainWnd@@UAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?SetRaidCoinCountScore@RoundStateMainWnd@@UAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
xdata$x	ENDS
;	COMDAT ?SetRaidCoinCountScore@RoundStateMainWnd@@UAEXXZ
_TEXT	SEGMENT
$T571320 = -56						; size = 16
$T571319 = -40						; size = 16
$T571318 = -40						; size = 16
tv306 = -24						; size = 4
$T571314 = -24						; size = 1
tv431 = -20						; size = 4
$T571317 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?SetRaidCoinCountScore@RoundStateMainWnd@@UAEXXZ PROC	; RoundStateMainWnd::SetRaidCoinCountScore, COMDAT
; _this$ = ecx

; 2861 : {

  00000	6a 2c		 push	 44			; 0000002cH
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetRaidCoinCountScore@RoundStateMainWnd@@UAEXXZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f9		 mov	 edi, ecx

; 2862 : 	if( !m_pPlayStage ) return;

  0000e	33 db		 xor	 ebx, ebx
  00010	39 9f 60 01 00
	00		 cmp	 DWORD PTR [edi+352], ebx
  00016	0f 84 40 02 00
	00		 je	 $LN4@SetRaidCoi

; 2863 : 
; 2864 : 	HideChildWnd( ID_PLAZA_WND );

  0001c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?HideChildWnd@ioWnd@@QAEXK_N@Z
  00022	53		 push	 ebx
  00023	6a 02		 push	 2
  00025	ff d6		 call	 esi

; 2865 : 	HideChildWnd( ID_SINGLE_WND );

  00027	53		 push	 ebx
  00028	6a 03		 push	 3
  0002a	8b cf		 mov	 ecx, edi
  0002c	ff d6		 call	 esi

; 2866 : 	HideChildWnd( ID_BLUE_WND );

  0002e	53		 push	 ebx
  0002f	6a 04		 push	 4
  00031	8b cf		 mov	 ecx, edi
  00033	ff d6		 call	 esi

; 2867 : 	HideChildWnd( ID_RED_WND );

  00035	53		 push	 ebx
  00036	6a 05		 push	 5
  00038	8b cf		 mov	 ecx, edi
  0003a	ff d6		 call	 esi

; 2868 : 
; 2869 : 	std::sort( m_RoundInfoList.begin(), m_RoundInfoList.end(), RoundInfoSort() );

  0003c	ff 75 e8	 push	 DWORD PTR $T571314[ebp]
  0003f	8b 87 68 01 00
	00		 mov	 eax, DWORD PTR [edi+360]
  00045	8b 8f 64 01 00
	00		 mov	 ecx, DWORD PTR [edi+356]
  0004b	50		 push	 eax
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$sort@V?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@VRoundInfoSort@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@0@0VRoundInfoSort@@@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >,RoundInfoSort>

; 2870 : 
; 2871 : 	// 타이틀
; 2872 : 	m_Title.ClearList();

  00052	8d b7 74 01 00
	00		 lea	 esi, DWORD PTR [edi+372]
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005b	8b ce		 mov	 ecx, esi
  0005d	e8 00 00 00 00	 call	 ?ClearList@ioComplexStringPrinter@@QAEXXZ ; ioComplexStringPrinter::ClearList

; 2873 : 	m_Title.SetTextStyle( TS_OUTLINE_FULL_2X );

  00062	6a 05		 push	 5
  00064	8b ce		 mov	 ecx, esi
  00066	e8 00 00 00 00	 call	 ?SetTextStyle@ioComplexStringPrinter@@QAEXW4TextStyle@@@Z ; ioComplexStringPrinter::SetTextStyle

; 2874 : 	m_Title.SetBkColor( 12, 66, 111 );

  0006b	6a 6f		 push	 111			; 0000006fH
  0006d	6a 42		 push	 66			; 00000042H
  0006f	6a 0c		 push	 12			; 0000000cH
  00071	8b ce		 mov	 ecx, esi
  00073	e8 00 00 00 00	 call	 ?SetBkColor@ioComplexStringPrinter@@QAEXHHH@Z ; ioComplexStringPrinter::SetBkColor

; 2875 : 	m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  00078	6a ff		 push	 -1
  0007a	8b ce		 mov	 ecx, esi
  0007c	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2876 : 	m_Title.AddTextPiece( FONT_SIZE_17, STR(1) );

  00081	53		 push	 ebx
  00082	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00088	6a 01		 push	 1
  0008a	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@DHNLDFAL@RoundStateMainWnd?3?3SetRaidCoinCo@
  00094	ff d3		 call	 ebx
  00096	8b c8		 mov	 ecx, eax
  00098	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0009e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  000a6	50		 push	 eax
  000a7	51		 push	 ecx
  000a8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ad	56		 push	 esi
  000ae	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  000b3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2877 : 	m_Title.SetTextColor( TCT_DEFAULT_LIGHTGRAY );

  000b6	68 a7 a7 a7 ff	 push	 -5789785		; ffa7a7a7H
  000bb	8b ce		 mov	 ecx, esi
  000bd	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2878 : 	m_Title.AddTextPiece( FONT_SIZE_17, " | " );

  000c2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_03LGOGDKEL@?5?$HM?5?$AA@
  000cf	51		 push	 ecx
  000d0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d5	56		 push	 esi
  000d6	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  000db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2879 : 	m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  000de	6a ff		 push	 -1
  000e0	8b ce		 mov	 ecx, esi
  000e2	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 2880 : 	if( g_BattleRoomMgr.GetPW().IsEmpty() )

  000e7	8d 45 d8	 lea	 eax, DWORD PTR $T571318[ebp]
  000ea	50		 push	 eax
  000eb	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  000f0	8b c8		 mov	 ecx, eax
  000f2	e8 00 00 00 00	 call	 ?GetPW@ioBattleRoomMgr@@QAE?AVioHashString@@XZ ; ioBattleRoomMgr::GetPW
  000f7	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  000fb	8b c8		 mov	 ecx, eax
  000fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00103	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00107	8d 4d d8	 lea	 ecx, DWORD PTR $T571318[ebp]
  0010a	88 45 f3	 mov	 BYTE PTR $T571317[ebp], al
  0010d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00113	80 7d f3 00	 cmp	 BYTE PTR $T571317[ebp], 0
  00117	74 53		 je	 SHORT $LN6@SetRaidCoi

; 2881 : 		m_Title.AddTextPiece( FONT_SIZE_17, STR(2), g_BattleRoomMgr.GetName().c_str() );

  00119	8d 45 d8	 lea	 eax, DWORD PTR $T571319[ebp]
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  00122	8b c8		 mov	 ecx, eax
  00124	e8 00 00 00 00	 call	 ?GetName@ioBattleRoomMgr@@QAE?AVioHashString@@XZ ; ioBattleRoomMgr::GetName
  00129	8b c8		 mov	 ecx, eax
  0012b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00138	50		 push	 eax
  00139	6a 00		 push	 0
  0013b	6a 02		 push	 2
  0013d	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00142	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@DHNLDFAL@RoundStateMainWnd?3?3SetRaidCoinCo@
  00147	ff d3		 call	 ebx
  00149	8b c8		 mov	 ecx, eax
  0014b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  00151	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  00159	50		 push	 eax
  0015a	51		 push	 ecx
  0015b	8b ce		 mov	 ecx, esi
  0015d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00162	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAEXMPBD0@Z ; ioComplexStringPrinter::AddTextPiece
  00167	8d 4d d8	 lea	 ecx, DWORD PTR $T571319[ebp]

; 2882 : 	else

  0016a	eb 51		 jmp	 SHORT $LN45@SetRaidCoi
$LN6@SetRaidCoi:

; 2883 : 		m_Title.AddTextPiece( FONT_SIZE_17, STR(3), g_BattleRoomMgr.GetName().c_str() );		

  0016c	8d 45 c8	 lea	 eax, DWORD PTR $T571320[ebp]
  0016f	50		 push	 eax
  00170	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  00175	8b c8		 mov	 ecx, eax
  00177	e8 00 00 00 00	 call	 ?GetName@ioBattleRoomMgr@@QAE?AVioHashString@@XZ ; ioBattleRoomMgr::GetName
  0017c	8b c8		 mov	 ecx, eax
  0017e	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00185	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  0018b	50		 push	 eax
  0018c	6a 00		 push	 0
  0018e	6a 03		 push	 3
  00190	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00195	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@DHNLDFAL@RoundStateMainWnd?3?3SetRaidCoinCo@
  0019a	ff d3		 call	 ebx
  0019c	8b c8		 mov	 ecx, eax
  0019e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  001a4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  001ac	50		 push	 eax
  001ad	51		 push	 ecx
  001ae	8b ce		 mov	 ecx, esi
  001b0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001b5	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAEXMPBD0@Z ; ioComplexStringPrinter::AddTextPiece
  001ba	8d 4d c8	 lea	 ecx, DWORD PTR $T571320[ebp]
$LN45@SetRaidCoi:
  001bd	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  001c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ

; 2884 : 
; 2885 : 	// 윈도우 세팅
; 2886 : 	RoundStateUserWnd *pUserWnd = dynamic_cast<RoundStateUserWnd *>(FindChildWnd( ID_SINGLE_WND ));

  001c7	6a 00		 push	 0
  001c9	68 00 00 00 00	 push	 OFFSET ??_R0?AVRoundStateUserWnd@@@8
  001ce	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWnd@@@8
  001d3	6a 00		 push	 0
  001d5	6a 03		 push	 3
  001d7	8b cf		 mov	 ecx, edi
  001d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?FindChildWnd@ioWnd@@QAEPAV1@K@Z
  001df	50		 push	 eax
  001e0	e8 00 00 00 00	 call	 ___RTDynamicCast
  001e5	8b f0		 mov	 esi, eax
  001e7	83 c4 14	 add	 esp, 20			; 00000014H

; 2887 : 	if( pUserWnd )

  001ea	85 f6		 test	 esi, esi
  001ec	74 6e		 je	 SHORT $LN4@SetRaidCoi

; 2888 : 	{
; 2889 : 		int iUserSize = m_RoundInfoList.size();

  001ee	8b 87 68 01 00
	00		 mov	 eax, DWORD PTR [edi+360]
  001f4	2b 87 64 01 00
	00		 sub	 eax, DWORD PTR [edi+356]
  001fa	c1 f8 07	 sar	 eax, 7

; 2890 : 		for(int i = 0;i < iUserSize;i++)

  001fd	85 c0		 test	 eax, eax
  001ff	7e 2c		 jle	 SHORT $LN1@SetRaidCoi

; 2888 : 	{
; 2889 : 		int iUserSize = m_RoundInfoList.size();

  00201	83 65 ec 00	 and	 DWORD PTR tv431[ebp], 0
  00205	89 45 e8	 mov	 DWORD PTR tv306[ebp], eax
$LN3@SetRaidCoi:

; 2890 : 		for(int i = 0;i < iUserSize;i++)

  00208	8b 87 64 01 00
	00		 mov	 eax, DWORD PTR [edi+356]
  0020e	03 45 ec	 add	 eax, DWORD PTR tv431[ebp]

; 2891 : 		{
; 2892 : 			RoundInfo &rkInfo = m_RoundInfoList[i];
; 2893 : 			rkInfo.m_Team = TEAM_BLUE;
; 2894 : 			pUserWnd->AddRoundInfo( rkInfo );

  00211	8d 8e 98 02 00
	00		 lea	 ecx, DWORD PTR [esi+664]
  00217	50		 push	 eax
  00218	c7 40 10 02 00
	00 00		 mov	 DWORD PTR [eax+16], 2
  0021f	e8 00 00 00 00	 call	 ?push_back@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXABURoundInfo@@@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::push_back
  00224	83 6d ec 80	 sub	 DWORD PTR tv431[ebp], -128 ; ffffff80H
  00228	ff 4d e8	 dec	 DWORD PTR tv306[ebp]
  0022b	75 db		 jne	 SHORT $LN3@SetRaidCoi
$LN1@SetRaidCoi:

; 2895 : 		}
; 2896 : 		pUserWnd->SetPlayStage( m_pPlayStage );

  0022d	8b 87 60 01 00
	00		 mov	 eax, DWORD PTR [edi+352]
  00233	89 86 94 02 00
	00		 mov	 DWORD PTR [esi+660], eax

; 2897 : 		pUserWnd->SetWindowTeam( TEAM_BLUE );

  00239	c7 86 58 02 00
	00 02 00 00 00	 mov	 DWORD PTR [esi+600], 2

; 2898 : 		pUserWnd->SetSingleScore( g_BattleRoomMgr.GetMaxPlayer() );

  00243	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  00248	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  0024b	03 48 40	 add	 ecx, DWORD PTR [eax+64]
  0024e	51		 push	 ecx
  0024f	8b ce		 mov	 ecx, esi
  00251	e8 00 00 00 00	 call	 ?SetSingleScore@RoundStateUserWnd@@QAEXH@Z ; RoundStateUserWnd::SetSingleScore

; 2899 : 		pUserWnd->ShowWnd();

  00256	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ShowWnd@ioWnd@@QAEXXZ
$LN4@SetRaidCoi:

; 2900 : 	}
; 2901 : }

  0025c	e8 00 00 00 00	 call	 __EH_epilog3
  00261	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetRaidCoinCountScore@RoundStateMainWnd@@UAEXXZ$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T571318[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?SetRaidCoinCountScore@RoundStateMainWnd@@UAEXXZ$1:
  00009	8d 4d d8	 lea	 ecx, DWORD PTR $T571319[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?SetRaidCoinCountScore@RoundStateMainWnd@@UAEXXZ$2:
  00012	8d 4d c8	 lea	 ecx, DWORD PTR $T571320[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$?SetRaidCoinCountScore@RoundStateMainWnd@@UAEXXZ:
  0001b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00022	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00025	33 c8		 xor	 ecx, eax
  00027	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetRaidCoinCountScore@RoundStateMainWnd@@UAEXXZ
  00031	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetRaidCoinCountScore@RoundStateMainWnd@@UAEXXZ ENDP	; RoundStateMainWnd::SetRaidCoinCountScore
; Function compile flags: /Ogsp
;	COMDAT ??_GRoundResultMainWnd@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GRoundResultMainWnd@@UAEPAXI@Z PROC			; RoundResultMainWnd::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7RoundResultMainWnd@@6B@
  0000c	e8 00 00 00 00	 call	 ??1RoundStateMainWnd@@UAE@XZ ; RoundStateMainWnd::~RoundStateMainWnd
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 07		 je	 SHORT $LN1@scalar@7
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	59		 pop	 ecx
$LN1@scalar@7:
  0001e	8b c6		 mov	 eax, esi
  00020	5e		 pop	 esi
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??_GRoundResultMainWnd@@UAEPAXI@Z ENDP			; RoundResultMainWnd::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_C@_0CB@HBMENOPF@RoundResultMainWnd?3?3SetTeamScore@ ; `string'
;	COMDAT ??_C@_0CB@HBMENOPF@RoundResultMainWnd?3?3SetTeamScore@
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobattleroommgr.h
CONST	SEGMENT
??_C@_0CB@HBMENOPF@RoundResultMainWnd?3?3SetTeamScore@ DB 'RoundResultMai'
	DB	'nWnd::SetTeamScore', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetTeamScore@RoundResultMainWnd@@UAEXHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetTeamScore@RoundResultMainWnd@@UAEXHH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SetTeamScore@RoundResultMainWnd@@UAEXHH@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SetTeamScore@RoundResultMainWnd@@UAEXHH@Z$2
__ehfuncinfo$?SetTeamScore@RoundResultMainWnd@@UAEXHH@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?SetTeamScore@RoundResultMainWnd@@UAEXHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\gui\roundstatemainwnd.cpp
xdata$x	ENDS
;	COMDAT ?SetTeamScore@RoundResultMainWnd@@UAEXHH@Z
_TEXT	SEGMENT
$T571419 = -60						; size = 16
$T571418 = -44						; size = 16
$T571417 = -44						; size = 16
tv668 = -28						; size = 4
tv890 = -24						; size = 4
_pBlueWnd$ = -20					; size = 4
$T571416 = -13						; size = 1
__$EHRec$ = -12						; size = 12
$T571413 = 8						; size = 1
tv665 = 8						; size = 4
_iBlueWin$ = 8						; size = 4
_iRedWin$ = 12						; size = 4
?SetTeamScore@RoundResultMainWnd@@UAEXHH@Z PROC		; RoundResultMainWnd::SetTeamScore, COMDAT
; _this$ = ecx

; 3141 : {

  00000	6a 30		 push	 48			; 00000030H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetTeamScore@RoundResultMainWnd@@UAEXHH@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b d9		 mov	 ebx, ecx

; 3142 : 	if( !m_pPlayStage  ) return;

  0000e	33 ff		 xor	 edi, edi
  00010	39 bb 60 01 00
	00		 cmp	 DWORD PTR [ebx+352], edi
  00016	0f 84 74 05 00
	00		 je	 $LN7@SetTeamSco@3

; 3143 : 
; 3144 : 	std::sort( m_RoundInfoList.begin(), m_RoundInfoList.end(), RoundInfoSort() );

  0001c	ff 75 08	 push	 DWORD PTR $T571413[ebp]
  0001f	8b 83 68 01 00
	00		 mov	 eax, DWORD PTR [ebx+360]
  00025	8b 8b 64 01 00
	00		 mov	 ecx, DWORD PTR [ebx+356]
  0002b	50		 push	 eax
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 ??$sort@V?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@std@@VRoundInfoSort@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@@0@0VRoundInfoSort@@@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<RoundInfo,std::allocator<RoundInfo> > >,RoundInfoSort>
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3145 : 
; 3146 : 	if( g_BattleRoomMgr.IsTournamentModeType() )

  00035	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  0003a	8b c8		 mov	 ecx, eax
  0003c	e8 00 00 00 00	 call	 ?IsTournamentModeType@ioBattleRoomMgr@@QAE_NXZ ; ioBattleRoomMgr::IsTournamentModeType
  00041	84 c0		 test	 al, al
  00043	0f 84 1d 01 00
	00		 je	 $LN24@SetTeamSco@3

; 3147 : 	{
; 3148 : 		SetTournamentData();

  00049	8b cb		 mov	 ecx, ebx
  0004b	e8 00 00 00 00	 call	 ?SetTournamentData@RoundStateMainWnd@@QAEXXZ ; RoundStateMainWnd::SetTournamentData

; 3149 : 
; 3150 : 		// 타이틀
; 3151 : 		m_Title.ClearList();

  00050	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00056	e8 00 00 00 00	 call	 ?ClearList@ioComplexStringPrinter@@QAEXXZ ; ioComplexStringPrinter::ClearList

; 3152 : 		m_Title.SetTextStyle( TS_OUTLINE_FULL_2X );

  0005b	6a 05		 push	 5
  0005d	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00063	e8 00 00 00 00	 call	 ?SetTextStyle@ioComplexStringPrinter@@QAEXW4TextStyle@@@Z ; ioComplexStringPrinter::SetTextStyle

; 3153 : 		m_Title.SetBkColor( 12, 66, 111 );

  00068	6a 6f		 push	 111			; 0000006fH
  0006a	6a 42		 push	 66			; 00000042H
  0006c	6a 0c		 push	 12			; 0000000cH
  0006e	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00074	e8 00 00 00 00	 call	 ?SetBkColor@ioComplexStringPrinter@@QAEXHHH@Z ; ioComplexStringPrinter::SetBkColor

; 3154 : 		m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  00079	6a ff		 push	 -1
  0007b	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00081	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 3155 : 		m_Title.AddTextPiece( FONT_SIZE_17, STR(1) );

  00086	57		 push	 edi
  00087	6a 01		 push	 1
  00089	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0008e	57		 push	 edi
  0008f	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0CB@HBMENOPF@RoundResultMainWnd?3?3SetTeamScore@
  00094	56		 push	 esi
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  0009b	8b c8		 mov	 ecx, eax
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  000a3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  000ab	50		 push	 eax
  000ac	51		 push	 ecx
  000ad	8d 83 74 01 00
	00		 lea	 eax, DWORD PTR [ebx+372]
  000b3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece

; 3156 : 		m_Title.AddTextPiece( FONT_SIZE_17, " | " );

  000be	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c9	68 00 00 00 00	 push	 OFFSET ??_C@_03LGOGDKEL@?5?$HM?5?$AA@
  000ce	51		 push	 ecx
  000cf	8d 83 74 01 00
	00		 lea	 eax, DWORD PTR [ebx+372]
  000d5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000da	50		 push	 eax
  000db	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  000e0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3157 : 		m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  000e3	6a ff		 push	 -1
  000e5	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  000eb	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 3158 : 
; 3159 : 		if( m_iTournamentCurrentRound  <= 2 )

  000f0	8b 83 94 01 00
	00		 mov	 eax, DWORD PTR [ebx+404]
  000f6	83 f8 02	 cmp	 eax, 2
  000f9	7f 37		 jg	 SHORT $LN23@SetTeamSco@3

; 3160 : 		{
; 3161 : 			m_Title.AddTextPiece( FONT_SIZE_17, STR(9) );

  000fb	6a 00		 push	 0
  000fd	6a 09		 push	 9
  000ff	57		 push	 edi
  00100	56		 push	 esi
  00101	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00107	8b c8		 mov	 ecx, eax
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  0010f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  00117	50		 push	 eax
  00118	51		 push	 ecx
  00119	8d 83 74 01 00
	00		 lea	 eax, DWORD PTR [ebx+372]
  0011f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00124	50		 push	 eax
  00125	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  0012a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3162 : 		}
; 3163 : 		else

  0012d	e9 eb 02 00 00	 jmp	 $LN15@SetTeamSco@3
$LN23@SetTeamSco@3:

; 3164 : 		{
; 3165 : 			m_Title.AddTextPiece( FONT_SIZE_17, STR(10), m_iTournamentCurrentRound );

  00132	50		 push	 eax
  00133	6a 00		 push	 0
  00135	6a 0a		 push	 10			; 0000000aH
  00137	57		 push	 edi
  00138	56		 push	 esi
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  0013f	8b c8		 mov	 ecx, eax
  00141	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  00147	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  0014f	50		 push	 eax
  00150	51		 push	 ecx
  00151	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00157	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0015c	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAEXMPBDH@Z ; ioComplexStringPrinter::AddTextPiece

; 3166 : 		}

  00161	e9 b7 02 00 00	 jmp	 $LN15@SetTeamSco@3
$LN24@SetTeamSco@3:

; 3167 : 
; 3168 : 	}else if( g_LadderTeamMgr.IsLadderTeam() )

  00166	e8 00 00 00 00	 call	 ?GetSingleton@ioLadderTeamMgr@@SAAAV1@XZ ; ioLadderTeamMgr::GetSingleton
  0016b	8b c8		 mov	 ecx, eax
  0016d	e8 00 00 00 00	 call	 ?IsLadderTeam@ioLadderTeamMgr@@QAE_NXZ ; ioLadderTeamMgr::IsLadderTeam

; 3169 : 	{
; 3170 : 		// 타이틀
; 3171 : 		m_Title.ClearList();

  00172	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00178	84 c0		 test	 al, al
  0017a	0f 84 13 01 00
	00		 je	 $LN20@SetTeamSco@3
  00180	e8 00 00 00 00	 call	 ?ClearList@ioComplexStringPrinter@@QAEXXZ ; ioComplexStringPrinter::ClearList

; 3172 : 		m_Title.SetTextStyle( TS_OUTLINE_FULL_2X );

  00185	6a 05		 push	 5
  00187	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  0018d	e8 00 00 00 00	 call	 ?SetTextStyle@ioComplexStringPrinter@@QAEXW4TextStyle@@@Z ; ioComplexStringPrinter::SetTextStyle

; 3173 : 		m_Title.SetBkColor( 12, 66, 111 );

  00192	6a 6f		 push	 111			; 0000006fH
  00194	6a 42		 push	 66			; 00000042H
  00196	6a 0c		 push	 12			; 0000000cH
  00198	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  0019e	e8 00 00 00 00	 call	 ?SetBkColor@ioComplexStringPrinter@@QAEXHHH@Z ; ioComplexStringPrinter::SetBkColor

; 3174 : 		m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  001a3	6a ff		 push	 -1
  001a5	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  001ab	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 3175 : 		m_Title.AddTextPiece( FONT_SIZE_17, STR(1) );

  001b0	57		 push	 edi
  001b1	6a 01		 push	 1
  001b3	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
  001b8	57		 push	 edi
  001b9	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0CB@HBMENOPF@RoundResultMainWnd?3?3SetTeamScore@
  001be	56		 push	 esi
  001bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  001c5	8b c8		 mov	 ecx, eax
  001c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  001cd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  001d5	50		 push	 eax
  001d6	51		 push	 ecx
  001d7	8d 83 74 01 00
	00		 lea	 eax, DWORD PTR [ebx+372]
  001dd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e2	50		 push	 eax
  001e3	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  001e8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3176 : 		m_Title.SetTextColor( TCT_DEFAULT_LIGHTGRAY );

  001eb	68 a7 a7 a7 ff	 push	 -5789785		; ffa7a7a7H
  001f0	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  001f6	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 3177 : 		m_Title.AddTextPiece( FONT_SIZE_17, " | " );

  001fb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  00203	68 00 00 00 00	 push	 OFFSET ??_C@_03LGOGDKEL@?5?$HM?5?$AA@
  00208	51		 push	 ecx
  00209	8d 83 74 01 00
	00		 lea	 eax, DWORD PTR [ebx+372]
  0020f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00214	50		 push	 eax
  00215	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  0021a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3178 : 		m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  0021d	6a ff		 push	 -1
  0021f	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00225	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 3179 : 		if( g_LadderTeamMgr.GetLadderTeamPW().IsEmpty() )

  0022a	e8 00 00 00 00	 call	 ?GetSingleton@ioLadderTeamMgr@@SAAAV1@XZ ; ioLadderTeamMgr::GetSingleton
  0022f	8d 48 20	 lea	 ecx, DWORD PTR [eax+32]
  00232	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00238	84 c0		 test	 al, al
  0023a	74 15		 je	 SHORT $LN19@SetTeamSco@3

; 3180 : 			m_Title.AddTextPiece( FONT_SIZE_17, STR(2), g_LadderTeamMgr.GetLadderTeamName().c_str() );

  0023c	e8 00 00 00 00	 call	 ?GetSingleton@ioLadderTeamMgr@@SAAAV1@XZ ; ioLadderTeamMgr::GetSingleton
  00241	8d 48 10	 lea	 ecx, DWORD PTR [eax+16]
  00244	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  0024a	50		 push	 eax
  0024b	6a 00		 push	 0
  0024d	6a 02		 push	 2

; 3181 : 		else

  0024f	eb 13		 jmp	 SHORT $LN86@SetTeamSco@3
$LN19@SetTeamSco@3:

; 3182 : 			m_Title.AddTextPiece( FONT_SIZE_17, STR(3), g_LadderTeamMgr.GetLadderTeamName().c_str() );		

  00251	e8 00 00 00 00	 call	 ?GetSingleton@ioLadderTeamMgr@@SAAAV1@XZ ; ioLadderTeamMgr::GetSingleton
  00256	8d 48 10	 lea	 ecx, DWORD PTR [eax+16]
  00259	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  0025f	50		 push	 eax
  00260	6a 00		 push	 0
  00262	6a 03		 push	 3
$LN86@SetTeamSco@3:
  00264	57		 push	 edi
  00265	56		 push	 esi
  00266	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  0026c	8b c8		 mov	 ecx, eax
  0026e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  00274	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  0027c	50		 push	 eax
  0027d	51		 push	 ecx
  0027e	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00284	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00289	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAEXMPBD0@Z ; ioComplexStringPrinter::AddTextPiece

; 3183 : 	}
; 3184 : 	else

  0028e	e9 8a 01 00 00	 jmp	 $LN15@SetTeamSco@3
$LN20@SetTeamSco@3:

; 3185 : 	{
; 3186 : 		// 타이틀
; 3187 : 		m_Title.ClearList();

  00293	e8 00 00 00 00	 call	 ?ClearList@ioComplexStringPrinter@@QAEXXZ ; ioComplexStringPrinter::ClearList

; 3188 : 		m_Title.SetTextStyle( TS_OUTLINE_FULL_2X );

  00298	6a 05		 push	 5
  0029a	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  002a0	e8 00 00 00 00	 call	 ?SetTextStyle@ioComplexStringPrinter@@QAEXW4TextStyle@@@Z ; ioComplexStringPrinter::SetTextStyle

; 3189 : 		m_Title.SetBkColor( 12, 66, 111 );

  002a5	6a 6f		 push	 111			; 0000006fH
  002a7	6a 42		 push	 66			; 00000042H
  002a9	6a 0c		 push	 12			; 0000000cH
  002ab	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  002b1	e8 00 00 00 00	 call	 ?SetBkColor@ioComplexStringPrinter@@QAEXHHH@Z ; ioComplexStringPrinter::SetBkColor

; 3190 : 		m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  002b6	6a ff		 push	 -1
  002b8	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  002be	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 3191 : 		m_Title.AddTextPiece( FONT_SIZE_17, STR(4) );

  002c3	57		 push	 edi
  002c4	6a 04		 push	 4
  002c6	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
  002cb	57		 push	 edi
  002cc	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0CB@HBMENOPF@RoundResultMainWnd?3?3SetTeamScore@
  002d1	56		 push	 esi
  002d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  002d8	8b c8		 mov	 ecx, eax
  002da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  002e0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  002e8	50		 push	 eax
  002e9	51		 push	 ecx
  002ea	8d 83 74 01 00
	00		 lea	 eax, DWORD PTR [ebx+372]
  002f0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002f5	50		 push	 eax
  002f6	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  002fb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3192 : 		m_Title.SetTextColor( TCT_DEFAULT_LIGHTGRAY );

  002fe	68 a7 a7 a7 ff	 push	 -5789785		; ffa7a7a7H
  00303	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00309	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 3193 : 		m_Title.AddTextPiece( FONT_SIZE_17, " | " );

  0030e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  00316	68 00 00 00 00	 push	 OFFSET ??_C@_03LGOGDKEL@?5?$HM?5?$AA@
  0031b	51		 push	 ecx
  0031c	8d 83 74 01 00
	00		 lea	 eax, DWORD PTR [ebx+372]
  00322	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00327	50		 push	 eax
  00328	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAAXMPBDZZ ; ioComplexStringPrinter::AddTextPiece
  0032d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3194 : 		m_Title.SetTextColor( TCT_DEFAULT_WHITE );

  00330	6a ff		 push	 -1
  00332	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00338	e8 00 00 00 00	 call	 ?SetTextColor@ioComplexStringPrinter@@QAEXK@Z ; ioComplexStringPrinter::SetTextColor

; 3195 : 		if( g_BattleRoomMgr.GetPW().IsEmpty() )

  0033d	8d 45 d4	 lea	 eax, DWORD PTR $T571417[ebp]
  00340	50		 push	 eax
  00341	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  00346	8b c8		 mov	 ecx, eax
  00348	e8 00 00 00 00	 call	 ?GetPW@ioBattleRoomMgr@@QAE?AVioHashString@@XZ ; ioBattleRoomMgr::GetPW
  0034d	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00351	8b c8		 mov	 ecx, eax
  00353	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00359	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0035d	8d 4d d4	 lea	 ecx, DWORD PTR $T571417[ebp]
  00360	88 45 f3	 mov	 BYTE PTR $T571416[ebp], al
  00363	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00369	80 7d f3 00	 cmp	 BYTE PTR $T571416[ebp], 0
  0036d	74 53		 je	 SHORT $LN16@SetTeamSco@3

; 3196 : 			m_Title.AddTextPiece( FONT_SIZE_17, STR(5), g_BattleRoomMgr.GetName().c_str() );

  0036f	8d 45 d4	 lea	 eax, DWORD PTR $T571418[ebp]
  00372	50		 push	 eax
  00373	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  00378	8b c8		 mov	 ecx, eax
  0037a	e8 00 00 00 00	 call	 ?GetName@ioBattleRoomMgr@@QAE?AVioHashString@@XZ ; ioBattleRoomMgr::GetName
  0037f	8b c8		 mov	 ecx, eax
  00381	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00388	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  0038e	50		 push	 eax
  0038f	6a 00		 push	 0
  00391	6a 05		 push	 5
  00393	57		 push	 edi
  00394	56		 push	 esi
  00395	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  0039b	8b c8		 mov	 ecx, eax
  0039d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  003a3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  003ab	50		 push	 eax
  003ac	51		 push	 ecx
  003ad	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  003b3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003b8	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAEXMPBD0@Z ; ioComplexStringPrinter::AddTextPiece
  003bd	8d 4d d4	 lea	 ecx, DWORD PTR $T571418[ebp]

; 3197 : 		else

  003c0	eb 51		 jmp	 SHORT $LN85@SetTeamSco@3
$LN16@SetTeamSco@3:

; 3198 : 			m_Title.AddTextPiece( FONT_SIZE_17, STR(6), g_BattleRoomMgr.GetName().c_str() );		

  003c2	8d 45 c4	 lea	 eax, DWORD PTR $T571419[ebp]
  003c5	50		 push	 eax
  003c6	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  003cb	8b c8		 mov	 ecx, eax
  003cd	e8 00 00 00 00	 call	 ?GetName@ioBattleRoomMgr@@QAE?AVioHashString@@XZ ; ioBattleRoomMgr::GetName
  003d2	8b c8		 mov	 ecx, eax
  003d4	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  003db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  003e1	50		 push	 eax
  003e2	6a 00		 push	 0
  003e4	6a 06		 push	 6
  003e6	57		 push	 edi
  003e7	56		 push	 esi
  003e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  003ee	8b c8		 mov	 ecx, eax
  003f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
  003f6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f59999a
  003fe	50		 push	 eax
  003ff	51		 push	 ecx
  00400	8d 8b 74 01 00
	00		 lea	 ecx, DWORD PTR [ebx+372]
  00406	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0040b	e8 00 00 00 00	 call	 ?AddTextPiece@ioComplexStringPrinter@@QAEXMPBD0@Z ; ioComplexStringPrinter::AddTextPiece
  00410	8d 4d c4	 lea	 ecx, DWORD PTR $T571419[ebp]
$LN85@SetTeamSco@3:
  00413	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00417	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
$LN15@SetTeamSco@3:

; 3199 : 	}
; 3200 : 
; 3201 : 	RoundStateUserWnd *pBlueWnd = dynamic_cast<RoundStateUserWnd *>(FindChildWnd( ID_BLUE_WND ));

  0041d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?FindChildWnd@ioWnd@@QAEPAV1@K@Z
  00423	6a 00		 push	 0
  00425	68 00 00 00 00	 push	 OFFSET ??_R0?AVRoundStateUserWnd@@@8
  0042a	bf 00 00 00 00	 mov	 edi, OFFSET ??_R0?AVioWnd@@@8
  0042f	57		 push	 edi
  00430	6a 00		 push	 0
  00432	6a 04		 push	 4
  00434	8b cb		 mov	 ecx, ebx
  00436	ff d6		 call	 esi
  00438	50		 push	 eax
  00439	e8 00 00 00 00	 call	 ___RTDynamicCast
  0043e	8b c8		 mov	 ecx, eax
  00440	83 c4 14	 add	 esp, 20			; 00000014H
  00443	89 4d ec	 mov	 DWORD PTR _pBlueWnd$[ebp], ecx

; 3202 : 	if( pBlueWnd )

  00446	85 c9		 test	 ecx, ecx
  00448	0f 84 91 00 00
	00		 je	 $LN14@SetTeamSco@3

; 3203 : 	{
; 3204 : 		int iUserSize = m_RoundInfoList.size();

  0044e	8b 83 68 01 00
	00		 mov	 eax, DWORD PTR [ebx+360]
  00454	2b 83 64 01 00
	00		 sub	 eax, DWORD PTR [ebx+356]
  0045a	c1 f8 07	 sar	 eax, 7

; 3205 : 		for(int i = 0;i < iUserSize;i++)

  0045d	85 c0		 test	 eax, eax
  0045f	7e 2e		 jle	 SHORT $LN11@SetTeamSco@3

; 3203 : 	{
; 3204 : 		int iUserSize = m_RoundInfoList.size();

  00461	83 65 e8 00	 and	 DWORD PTR tv890[ebp], 0
  00465	89 45 e4	 mov	 DWORD PTR tv668[ebp], eax
$LL13@SetTeamSco@3:

; 3205 : 		for(int i = 0;i < iUserSize;i++)

  00468	8b 83 64 01 00
	00		 mov	 eax, DWORD PTR [ebx+356]
  0046e	03 45 e8	 add	 eax, DWORD PTR tv890[ebp]

; 3206 : 		{
; 3207 : 			RoundInfo &rkInfo = m_RoundInfoList[i];
; 3208 : 			if( rkInfo.m_Team == TEAM_BLUE )

  00471	83 78 10 02	 cmp	 DWORD PTR [eax+16], 2
  00475	75 0f		 jne	 SHORT $LN12@SetTeamSco@3

; 3209 : 				pBlueWnd->AddRoundInfo( rkInfo );

  00477	50		 push	 eax
  00478	81 c1 98 02 00
	00		 add	 ecx, 664		; 00000298H
  0047e	e8 00 00 00 00	 call	 ?push_back@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXABURoundInfo@@@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::push_back
  00483	8b 4d ec	 mov	 ecx, DWORD PTR _pBlueWnd$[ebp]
$LN12@SetTeamSco@3:

; 3205 : 		for(int i = 0;i < iUserSize;i++)

  00486	83 6d e8 80	 sub	 DWORD PTR tv890[ebp], -128 ; ffffff80H
  0048a	ff 4d e4	 dec	 DWORD PTR tv668[ebp]
  0048d	75 d9		 jne	 SHORT $LL13@SetTeamSco@3
$LN11@SetTeamSco@3:

; 3210 : 		}
; 3211 : 
; 3212 : 		pBlueWnd->SetWindowTeam( TEAM_BLUE );

  0048f	c7 81 58 02 00
	00 02 00 00 00	 mov	 DWORD PTR [ecx+600], 2

; 3213 : 		pBlueWnd->SetPlayStage( m_pPlayStage );

  00499	8b 83 60 01 00
	00		 mov	 eax, DWORD PTR [ebx+352]
  0049f	89 81 94 02 00
	00		 mov	 DWORD PTR [ecx+660], eax

; 3214 : 		if( g_LadderTeamMgr.IsLadderTeam() )

  004a5	e8 00 00 00 00	 call	 ?GetSingleton@ioLadderTeamMgr@@SAAAV1@XZ ; ioLadderTeamMgr::GetSingleton
  004aa	8b c8		 mov	 ecx, eax
  004ac	e8 00 00 00 00	 call	 ?IsLadderTeam@ioLadderTeamMgr@@QAE_NXZ ; ioLadderTeamMgr::IsLadderTeam
  004b1	84 c0		 test	 al, al
  004b3	74 0e		 je	 SHORT $LN9@SetTeamSco@3

; 3215 : 		{
; 3216 : 			const LadderTeamInfo &rkTeamInfo = g_LadderTeamMgr.GetLadderBlueTeamInfo();

  004b5	e8 00 00 00 00	 call	 ?GetSingleton@ioLadderTeamMgr@@SAAAV1@XZ ; ioLadderTeamMgr::GetSingleton
  004ba	8b c8		 mov	 ecx, eax
  004bc	e8 00 00 00 00	 call	 ?GetLadderBlueTeamInfo@ioLadderTeamMgr@@QAEABUtagLadderTeamInfo@@XZ ; ioLadderTeamMgr::GetLadderBlueTeamInfo

; 3217 : 			pBlueWnd->SetTeamScore( rkTeamInfo.m_iMaxPlayer, iBlueWin );
; 3218 : 		}
; 3219 : 		else

  004c1	eb 05		 jmp	 SHORT $LN87@SetTeamSco@3
$LN9@SetTeamSco@3:

; 3220 : 			pBlueWnd->SetTeamScore( g_BattleRoomMgr.GetMaxPlayerBlue(), iBlueWin );

  004c3	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
$LN87@SetTeamSco@3:
  004c8	ff 75 08	 push	 DWORD PTR _iBlueWin$[ebp]
  004cb	8b 4d ec	 mov	 ecx, DWORD PTR _pBlueWnd$[ebp]
  004ce	ff 70 40	 push	 DWORD PTR [eax+64]
  004d1	e8 00 00 00 00	 call	 ?SetTeamScore@RoundStateUserWnd@@QAEXHH@Z ; RoundStateUserWnd::SetTeamScore

; 3221 : 		pBlueWnd->ShowWnd();

  004d6	8b 4d ec	 mov	 ecx, DWORD PTR _pBlueWnd$[ebp]
  004d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ShowWnd@ioWnd@@QAEXXZ
$LN14@SetTeamSco@3:

; 3222 : 	}
; 3223 : 
; 3224 : 	RoundStateUserWnd *pRedWnd = dynamic_cast<RoundStateUserWnd *>(FindChildWnd( ID_RED_WND ));

  004df	6a 00		 push	 0
  004e1	68 00 00 00 00	 push	 OFFSET ??_R0?AVRoundStateUserWnd@@@8
  004e6	57		 push	 edi
  004e7	6a 00		 push	 0
  004e9	6a 05		 push	 5
  004eb	8b cb		 mov	 ecx, ebx
  004ed	ff d6		 call	 esi
  004ef	50		 push	 eax
  004f0	e8 00 00 00 00	 call	 ___RTDynamicCast
  004f5	8b f0		 mov	 esi, eax
  004f7	83 c4 14	 add	 esp, 20			; 00000014H

; 3225 : 	if( pRedWnd )

  004fa	85 f6		 test	 esi, esi
  004fc	0f 84 8e 00 00
	00		 je	 $LN7@SetTeamSco@3

; 3226 : 	{
; 3227 : 		int iUserSize = m_RoundInfoList.size();

  00502	8b 83 68 01 00
	00		 mov	 eax, DWORD PTR [ebx+360]
  00508	2b 83 64 01 00
	00		 sub	 eax, DWORD PTR [ebx+356]
  0050e	c1 f8 07	 sar	 eax, 7

; 3228 : 		for(int i = 0;i < iUserSize;i++)

  00511	85 c0		 test	 eax, eax
  00513	7e 27		 jle	 SHORT $LN4@SetTeamSco@3

; 3226 : 	{
; 3227 : 		int iUserSize = m_RoundInfoList.size();

  00515	33 ff		 xor	 edi, edi
  00517	89 45 08	 mov	 DWORD PTR tv665[ebp], eax
$LL6@SetTeamSco@3:

; 3228 : 		for(int i = 0;i < iUserSize;i++)

  0051a	8b 83 64 01 00
	00		 mov	 eax, DWORD PTR [ebx+356]
  00520	03 c7		 add	 eax, edi

; 3229 : 		{
; 3230 : 			RoundInfo &rkInfo = m_RoundInfoList[i];
; 3231 : 			if( rkInfo.m_Team == TEAM_RED )

  00522	83 78 10 01	 cmp	 DWORD PTR [eax+16], 1
  00526	75 0c		 jne	 SHORT $LN5@SetTeamSco@3

; 3232 : 				pRedWnd->AddRoundInfo( rkInfo );

  00528	50		 push	 eax
  00529	8d 8e 98 02 00
	00		 lea	 ecx, DWORD PTR [esi+664]
  0052f	e8 00 00 00 00	 call	 ?push_back@?$vector@URoundInfo@@V?$allocator@URoundInfo@@@std@@@std@@QAEXABURoundInfo@@@Z ; std::vector<RoundInfo,std::allocator<RoundInfo> >::push_back
$LN5@SetTeamSco@3:

; 3228 : 		for(int i = 0;i < iUserSize;i++)

  00534	83 ef 80	 sub	 edi, -128		; ffffff80H
  00537	ff 4d 08	 dec	 DWORD PTR tv665[ebp]
  0053a	75 de		 jne	 SHORT $LL6@SetTeamSco@3
$LN4@SetTeamSco@3:

; 3233 : 		}
; 3234 : 
; 3235 : 		pRedWnd->SetWindowTeam( TEAM_RED );

  0053c	c7 86 58 02 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+600], 1

; 3236 : 		pRedWnd->SetPlayStage( m_pPlayStage );

  00546	8b 83 60 01 00
	00		 mov	 eax, DWORD PTR [ebx+352]
  0054c	89 86 94 02 00
	00		 mov	 DWORD PTR [esi+660], eax

; 3237 : 		if( g_LadderTeamMgr.IsLadderTeam() )

  00552	e8 00 00 00 00	 call	 ?GetSingleton@ioLadderTeamMgr@@SAAAV1@XZ ; ioLadderTeamMgr::GetSingleton
  00557	8b c8		 mov	 ecx, eax
  00559	e8 00 00 00 00	 call	 ?IsLadderTeam@ioLadderTeamMgr@@QAE_NXZ ; ioLadderTeamMgr::IsLadderTeam
  0055e	84 c0		 test	 al, al
  00560	74 14		 je	 SHORT $LN2@SetTeamSco@3

; 3238 : 		{
; 3239 : 			const LadderTeamInfo &rkTeamInfo = g_LadderTeamMgr.GetLadderRedTeamInfo();

  00562	e8 00 00 00 00	 call	 ?GetSingleton@ioLadderTeamMgr@@SAAAV1@XZ ; ioLadderTeamMgr::GetSingleton
  00567	8b c8		 mov	 ecx, eax
  00569	e8 00 00 00 00	 call	 ?GetLadderRedTeamInfo@ioLadderTeamMgr@@QAEABUtagLadderTeamInfo@@XZ ; ioLadderTeamMgr::GetLadderRedTeamInfo

; 3240 : 			pRedWnd->SetTeamScore( rkTeamInfo.m_iMaxPlayer, iRedWin );

  0056e	ff 75 0c	 push	 DWORD PTR _iRedWin$[ebp]
  00571	ff 70 40	 push	 DWORD PTR [eax+64]

; 3241 : 		}
; 3242 : 		else

  00574	eb 0b		 jmp	 SHORT $LN88@SetTeamSco@3
$LN2@SetTeamSco@3:

; 3243 : 			pRedWnd->SetTeamScore( g_BattleRoomMgr.GetMaxPlayerRed(), iRedWin );

  00576	e8 00 00 00 00	 call	 ?GetSingleton@ioBattleRoomMgr@@SAAAV1@XZ ; ioBattleRoomMgr::GetSingleton
  0057b	ff 75 0c	 push	 DWORD PTR _iRedWin$[ebp]
  0057e	ff 70 44	 push	 DWORD PTR [eax+68]
$LN88@SetTeamSco@3:
  00581	8b ce		 mov	 ecx, esi
  00583	e8 00 00 00 00	 call	 ?SetTeamScore@RoundStateUserWnd@@QAEXHH@Z ; RoundStateUserWnd::SetTeamScore

; 3244 : 		pRedWnd->ShowWnd();

  00588	8b ce		 mov	 ecx, esi
  0058a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ShowWnd@ioWnd@@QAEXXZ
$LN7@SetTeamSco@3:

; 3245 : 	}			
; 3246 : }

  00590	e8 00 00 00 00	 call	 __EH_epilog3
  00595	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetTeamScore@RoundResultMainWnd@@UAEXHH@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR $T571417[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?SetTeamScore@RoundResultMainWnd@@UAEXHH@Z$1:
  00009	8d 4d d4	 lea	 ecx, DWORD PTR $T571418[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?SetTeamScore@RoundResultMainWnd@@UAEXHH@Z$2:
  00012	8d 4d c4	 lea	 ecx, DWORD PTR $T571419[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$?SetTeamScore@RoundResultMainWnd@@UAEXHH@Z:
  0001b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00022	8b 4a c0	 mov	 ecx, DWORD PTR [edx-64]
  00025	33 c8		 xor	 ecx, eax
  00027	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetTeamScore@RoundResultMainWnd@@UAEXHH@Z
  00031	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetTeamScore@RoundResultMainWnd@@UAEXHH@Z ENDP		; RoundResultMainWnd::SetTeamScore
END
