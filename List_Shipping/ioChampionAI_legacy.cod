; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\Lost Saga For Developer\Youtube\Tutorial\Source\src\LSClient\ioChampionAI_legacy.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_EEM_DS@?$deque@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@2HB ; std::deque<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_EEM_DS
;	COMDAT ?_EEM_DS@?$deque@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@2HB
CONST	SEGMENT
?_EEM_DS@?$deque@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@2HB DD 01H ; std::deque<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_EEM_DS
CONST	ENDS
PUBLIC	?GetBaseCharList@ioPlayStage@@QBEABV?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@XZ ; ioPlayStage::GetBaseCharList
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioplaystage.h
;	COMDAT ?GetBaseCharList@ioPlayStage@@QBEABV?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@XZ
_TEXT	SEGMENT
?GetBaseCharList@ioPlayStage@@QBEABV?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@XZ PROC ; ioPlayStage::GetBaseCharList, COMDAT
; _this$ = ecx

; 755  : 	const BaseCharList& GetBaseCharList() const { return m_BaseCharList; }

  00000	8d 41 2c	 lea	 eax, DWORD PTR [ecx+44]
  00003	c3		 ret	 0
?GetBaseCharList@ioPlayStage@@QBEABV?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@XZ ENDP ; ioPlayStage::GetBaseCharList
_TEXT	ENDS
PUBLIC	?GetGameEntityList@ioPlayStage@@QBEABV?$list@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@XZ ; ioPlayStage::GetGameEntityList
; Function compile flags: /Ogsp
;	COMDAT ?GetGameEntityList@ioPlayStage@@QBEABV?$list@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@XZ
_TEXT	SEGMENT
?GetGameEntityList@ioPlayStage@@QBEABV?$list@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@XZ PROC ; ioPlayStage::GetGameEntityList, COMDAT
; _this$ = ecx

; 759  : 	const GameEntityList& GetGameEntityList() const { return m_GameEntityList; }

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00003	c3		 ret	 0
?GetGameEntityList@ioPlayStage@@QBEABV?$list@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@XZ ENDP ; ioPlayStage::GetGameEntityList
_TEXT	ENDS
PUBLIC	?return1@@YAIXZ					; return1
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stdafx.h
;	COMDAT ?return1@@YAIXZ
_TEXT	SEGMENT
?return1@@YAIXZ PROC					; return1, COMDAT

; 17   : 	__forceinline unsigned int return1() { __asm mov eax, 1 };

  00000	b8 01 00 00 00	 mov	 eax, 1
  00005	c3		 ret	 0
?return1@@YAIXZ ENDP					; return1
_TEXT	ENDS
PUBLIC	?return100@@YAIXZ				; return100
; Function compile flags: /Ogsp
;	COMDAT ?return100@@YAIXZ
_TEXT	SEGMENT
?return100@@YAIXZ PROC					; return100, COMDAT

; 25   : 	__forceinline unsigned int return100() { __asm mov eax, 100 };

  00000	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  00005	c3		 ret	 0
?return100@@YAIXZ ENDP					; return100
_TEXT	ENDS
PUBLIC	?GetState@ioBaseChar@@QBE?AW4CharState@@XZ	; ioBaseChar::GetState
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasechar.h
;	COMDAT ?GetState@ioBaseChar@@QBE?AW4CharState@@XZ
_TEXT	SEGMENT
?GetState@ioBaseChar@@QBE?AW4CharState@@XZ PROC		; ioBaseChar::GetState, COMDAT
; _this$ = ecx

; 2156 : 	inline CharState GetState() const { return m_CharState; }	

  00000	8a 81 10 03 00
	00		 mov	 al, BYTE PTR [ecx+784]
  00006	c3		 ret	 0
?GetState@ioBaseChar@@QBE?AW4CharState@@XZ ENDP		; ioBaseChar::GetState
_TEXT	ENDS
PUBLIC	_fabsf
EXTRN	__fltused:DWORD
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv129 = 8						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 395  :         {return ((float)fabs((double)_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	d9 e1		 fabs
  00008	d9 5d 08	 fstp	 DWORD PTR tv129[ebp]
  0000b	d9 45 08	 fld	 DWORD PTR tv129[ebp]
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
_fabsf	ENDP
_TEXT	ENDS
PUBLIC	?GetLevel@ioBaseChar@@QBEHXZ			; ioBaseChar::GetLevel
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasechar.h
;	COMDAT ?GetLevel@ioBaseChar@@QBEHXZ
_TEXT	SEGMENT
?GetLevel@ioBaseChar@@QBEHXZ PROC			; ioBaseChar::GetLevel, COMDAT
; _this$ = ecx

; 2592 : 	inline int GetLevel() const { return m_iLevel; }

  00000	8b 81 cc 02 00
	00		 mov	 eax, DWORD PTR [ecx+716]
  00006	c3		 ret	 0
?GetLevel@ioBaseChar@@QBEHXZ ENDP			; ioBaseChar::GetLevel
_TEXT	ENDS
PUBLIC	?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ	; ioBaseChar::GetCharName
; Function compile flags: /Ogsp
;	COMDAT ?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ
_TEXT	SEGMENT
?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ PROC	; ioBaseChar::GetCharName, COMDAT
; _this$ = ecx

; 2594 : 	inline const ioHashString& GetCharName() const { return m_Name; }

  00000	8d 81 d4 02 00
	00		 lea	 eax, DWORD PTR [ecx+724]
  00006	c3		 ret	 0
?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ ENDP	; ioBaseChar::GetCharName
_TEXT	ENDS
PUBLIC	?fabs@@YAMM@Z					; fabs
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
tv131 = 8						; size = 4
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 518  :         {return (fabsf(_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	d9 e1		 fabs
  00008	d9 5d 08	 fstp	 DWORD PTR tv131[ebp]
  0000b	d9 45 08	 fld	 DWORD PTR tv131[ebp]
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
PUBLIC	?GetTargetType@TargetData@ioAI@@QBE?AW4TargetType@2@XZ ; ioAI::TargetData::GetTargetType
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioai.h
;	COMDAT ?GetTargetType@TargetData@ioAI@@QBE?AW4TargetType@2@XZ
_TEXT	SEGMENT
?GetTargetType@TargetData@ioAI@@QBE?AW4TargetType@2@XZ PROC ; ioAI::TargetData::GetTargetType, COMDAT
; _this$ = ecx

; 120  : 		ioAI::TargetType GetTargetType() const { return m_TargetType; }

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	c3		 ret	 0
?GetTargetType@TargetData@ioAI@@QBE?AW4TargetType@2@XZ ENDP ; ioAI::TargetData::GetTargetType
_TEXT	ENDS
PUBLIC	?GetTargetName@TargetData@ioAI@@QAEAAVioHashString@@XZ ; ioAI::TargetData::GetTargetName
; Function compile flags: /Ogsp
;	COMDAT ?GetTargetName@TargetData@ioAI@@QAEAAVioHashString@@XZ
_TEXT	SEGMENT
?GetTargetName@TargetData@ioAI@@QAEAAVioHashString@@XZ PROC ; ioAI::TargetData::GetTargetName, COMDAT
; _this$ = ecx

; 121  : 		ioHashString &GetTargetName() { return m_szTargetName; }

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetTargetName@TargetData@ioAI@@QAEAAVioHashString@@XZ ENDP ; ioAI::TargetData::GetTargetName
_TEXT	ENDS
PUBLIC	?GetTargetPos@TargetData@ioAI@@QAEAAUD3DXVECTOR3@@XZ ; ioAI::TargetData::GetTargetPos
; Function compile flags: /Ogsp
;	COMDAT ?GetTargetPos@TargetData@ioAI@@QAEAAUD3DXVECTOR3@@XZ
_TEXT	SEGMENT
?GetTargetPos@TargetData@ioAI@@QAEAAUD3DXVECTOR3@@XZ PROC ; ioAI::TargetData::GetTargetPos, COMDAT
; _this$ = ecx

; 122  : 		D3DXVECTOR3 &GetTargetPos() { return m_vTargetPos; }

  00000	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]
  00003	c3		 ret	 0
?GetTargetPos@TargetData@ioAI@@QAEAAUD3DXVECTOR3@@XZ ENDP ; ioAI::TargetData::GetTargetPos
_TEXT	ENDS
PUBLIC	?GetTargetLevel@TargetData@ioAI@@QBEHXZ		; ioAI::TargetData::GetTargetLevel
; Function compile flags: /Ogsp
;	COMDAT ?GetTargetLevel@TargetData@ioAI@@QBEHXZ
_TEXT	SEGMENT
?GetTargetLevel@TargetData@ioAI@@QBEHXZ PROC		; ioAI::TargetData::GetTargetLevel, COMDAT
; _this$ = ecx

; 123  : 		int GetTargetLevel() const { return m_iTargetLevel; }

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	c3		 ret	 0
?GetTargetLevel@TargetData@ioAI@@QBEHXZ ENDP		; ioAI::TargetData::GetTargetLevel
_TEXT	ENDS
PUBLIC	?SetTargetPos@TargetData@ioAI@@QAEXABUD3DXVECTOR3@@@Z ; ioAI::TargetData::SetTargetPos
; Function compile flags: /Ogsp
;	COMDAT ?SetTargetPos@TargetData@ioAI@@QAEXABUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_vPos$ = 8						; size = 4
?SetTargetPos@TargetData@ioAI@@QAEXABUD3DXVECTOR3@@@Z PROC ; ioAI::TargetData::SetTargetPos, COMDAT
; _this$ = ecx

; 128  : 		void SetTargetPos( const D3DXVECTOR3 &vPos ){ m_vTargetPos = vPos;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR _vPos$[ebp]
  00007	57		 push	 edi
  00008	8d 79 14	 lea	 edi, DWORD PTR [ecx+20]
  0000b	a5		 movsd
  0000c	a5		 movsd
  0000d	a5		 movsd
  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?SetTargetPos@TargetData@ioAI@@QAEXABUD3DXVECTOR3@@@Z ENDP ; ioAI::TargetData::SetTargetPos
_TEXT	ENDS
PUBLIC	?SetTargetLevel@TargetData@ioAI@@QAEXH@Z	; ioAI::TargetData::SetTargetLevel
; Function compile flags: /Ogsp
;	COMDAT ?SetTargetLevel@TargetData@ioAI@@QAEXH@Z
_TEXT	SEGMENT
_iTargetLevel$ = 8					; size = 4
?SetTargetLevel@TargetData@ioAI@@QAEXH@Z PROC		; ioAI::TargetData::SetTargetLevel, COMDAT
; _this$ = ecx

; 129  : 		void SetTargetLevel( int iTargetLevel )	{m_iTargetLevel = iTargetLevel;	}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _iTargetLevel$[ebp]
  00006	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetTargetLevel@TargetData@ioAI@@QAEXH@Z ENDP		; ioAI::TargetData::SetTargetLevel
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 49   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
PUBLIC	?SearchFixedTarget@ioChampionAI@@IAE_NAAVioHashString@@@Z ; ioChampionAI::SearchFixedTarget
EXTRN	__imp_?IsEmpty@ioHashString@@QBE_NXZ:PROC
EXTRN	__imp_??4ioHashString@@QAEAAV0@ABV0@@Z:PROC
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iochampionai_legacy.cpp
;	COMDAT ?SearchFixedTarget@ioChampionAI@@IAE_NAAVioHashString@@@Z
_TEXT	SEGMENT
_szFirstTarget$ = 8					; size = 4
?SearchFixedTarget@ioChampionAI@@IAE_NAAVioHashString@@@Z PROC ; ioChampionAI::SearchFixedTarget, COMDAT
; _this$ = ecx

; 11   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 12   : 	szFirstTarget = m_szFixingName;

  00003	83 c1 50	 add	 ecx, 80			; 00000050H
  00006	51		 push	 ecx
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _szFirstTarget$[ebp]
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@ABV0@@Z

; 13   : 
; 14   : 	return ( !szFirstTarget.IsEmpty() );

  00010	8b 4d 08	 mov	 ecx, DWORD PTR _szFirstTarget$[ebp]
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00019	33 c9		 xor	 ecx, ecx
  0001b	84 c0		 test	 al, al
  0001d	0f 94 c0	 sete	 al

; 15   : }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
?SearchFixedTarget@ioChampionAI@@IAE_NAAVioHashString@@@Z ENDP ; ioChampionAI::SearchFixedTarget
_TEXT	ENDS
PUBLIC	?SearchTargetByDamage@ioChampionAI@@IAE_NAAVioHashString@@@Z ; ioChampionAI::SearchTargetByDamage
EXTRN	?GetDamagedTopChar@ioBaseChar@@QAEXAAVioHashString@@@Z:PROC ; ioBaseChar::GetDamagedTopChar
EXTRN	?GetDamagedLowestChar@ioBaseChar@@QAEXAAVioHashString@@@Z:PROC ; ioBaseChar::GetDamagedLowestChar
; Function compile flags: /Ogsp
;	COMDAT ?SearchTargetByDamage@ioChampionAI@@IAE_NAAVioHashString@@@Z
_TEXT	SEGMENT
_szFirstTarget$ = 8					; size = 4
?SearchTargetByDamage@ioChampionAI@@IAE_NAAVioHashString@@@Z PROC ; ioChampionAI::SearchTargetByDamage, COMDAT
; _this$ = ecx

; 18   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19   : 	// 데미지에 따른 우선 순위
; 20   : 	switch( m_dwSearchType )

  00003	8b 81 6c 01 00
	00		 mov	 eax, DWORD PTR [ecx+364]
  00009	83 e8 00	 sub	 eax, 0
  0000c	74 14		 je	 SHORT $LN3@SearchTarg
  0000e	48		 dec	 eax
  0000f	74 04		 je	 SHORT $LN2@SearchTarg

; 30   : 	default:
; 31   : 		return false;

  00011	32 c0		 xor	 al, al
  00013	eb 1a		 jmp	 SHORT $LN4@SearchTarg
$LN2@SearchTarg:

; 27   : 	case SEARCH_LOWEST_DAMAGE:
; 28   : 		m_pCreator->GetDamagedLowestChar( szFirstTarget );

  00015	ff 75 08	 push	 DWORD PTR _szFirstTarget$[ebp]
  00018	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0001b	e8 00 00 00 00	 call	 ?GetDamagedLowestChar@ioBaseChar@@QAEXAAVioHashString@@@Z ; ioBaseChar::GetDamagedLowestChar

; 29   : 		return true;

  00020	eb 0b		 jmp	 SHORT $LN8@SearchTarg
$LN3@SearchTarg:

; 21   : 	{
; 22   : 	// actual default value since m_dwSearchType will be set to 0 as default when loaded
; 23   : 	// and SEARCH_TOP_DAMAGE has value 0
; 24   : 	case SEARCH_TOP_DAMAGE:		
; 25   : 		m_pCreator->GetDamagedTopChar( szFirstTarget );

  00022	ff 75 08	 push	 DWORD PTR _szFirstTarget$[ebp]
  00025	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00028	e8 00 00 00 00	 call	 ?GetDamagedTopChar@ioBaseChar@@QAEXAAVioHashString@@@Z ; ioBaseChar::GetDamagedTopChar
$LN8@SearchTarg:

; 26   : 		return true;

  0002d	b0 01		 mov	 al, 1
$LN4@SearchTarg:

; 32   : 	}
; 33   : }

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?SearchTargetByDamage@ioChampionAI@@IAE_NAAVioHashString@@@Z ENDP ; ioChampionAI::SearchTargetByDamage
_TEXT	ENDS
PUBLIC	?SetAsTarget@ioChampionAI@@AAE_NPAVioBaseChar@@@Z ; ioChampionAI::SetAsTarget
EXTRN	?SetTargetType@TargetData@ioAI@@QAEXW4TargetType@2@@Z:PROC ; ioAI::TargetData::SetTargetType
EXTRN	?SetTargetName@TargetData@ioAI@@QAEXABVioHashString@@@Z:PROC ; ioAI::TargetData::SetTargetName
; Function compile flags: /Ogsp
;	COMDAT ?SetAsTarget@ioChampionAI@@AAE_NPAVioBaseChar@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
tv162 = 8						; size = 4
_pChar$ = 8						; size = 4
?SetAsTarget@ioChampionAI@@AAE_NPAVioBaseChar@@@Z PROC	; ioChampionAI::SetAsTarget, COMDAT
; _this$ = ecx

; 36   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 37   : 	if( pChar != (ioBaseChar*)0 )

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _pChar$[ebp]
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	89 7d fc	 mov	 DWORD PTR _this$[ebp], edi
  0000e	85 db		 test	 ebx, ebx
  00010	74 46		 je	 SHORT $LN1@SetAsTarge

; 38   : 	{
; 39   : 		m_TargetData.SetTargetName( pChar->GetCharName() );

  00012	56		 push	 esi
  00013	8d 83 d4 02 00
	00		 lea	 eax, DWORD PTR [ebx+724]
  00019	8d 8f b4 00 00
	00		 lea	 ecx, DWORD PTR [edi+180]
  0001f	50		 push	 eax
  00020	89 4d 08	 mov	 DWORD PTR tv162[ebp], ecx
  00023	e8 00 00 00 00	 call	 ?SetTargetName@TargetData@ioAI@@QAEXABVioHashString@@@Z ; ioAI::TargetData::SetTargetName

; 40   : 		m_TargetData.SetTargetPos( pChar->GetWorldPosition() );

  00028	8b 03		 mov	 eax, DWORD PTR [ebx]
  0002a	8b cb		 mov	 ecx, ebx
  0002c	ff 50 70	 call	 DWORD PTR [eax+112]

; 41   : 		m_TargetData.SetTargetLevel( pChar->GetLevel() );

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	81 c7 c8 00 00
	00		 add	 edi, 200		; 000000c8H
  00038	8b f0		 mov	 esi, eax
  0003a	a5		 movsd
  0003b	a5		 movsd
  0003c	a5		 movsd
  0003d	8b 83 cc 02 00
	00		 mov	 eax, DWORD PTR [ebx+716]
  00043	89 81 d4 00 00
	00		 mov	 DWORD PTR [ecx+212], eax

; 42   : 		
; 43   : 		m_TargetData.SetTargetType( TARGET_BASECHAR );

  00049	8b 4d 08	 mov	 ecx, DWORD PTR tv162[ebp]
  0004c	6a 01		 push	 1
  0004e	e8 00 00 00 00	 call	 ?SetTargetType@TargetData@ioAI@@QAEXW4TargetType@2@@Z ; ioAI::TargetData::SetTargetType

; 44   : 
; 45   : 		return true;

  00053	b0 01		 mov	 al, 1
  00055	5e		 pop	 esi
  00056	eb 02		 jmp	 SHORT $LN2@SetAsTarge
$LN1@SetAsTarge:

; 46   : 	}
; 47   : 	return false;

  00058	32 c0		 xor	 al, al
$LN2@SetAsTarge:
  0005a	5f		 pop	 edi
  0005b	5b		 pop	 ebx

; 48   : }

  0005c	c9		 leave
  0005d	c2 04 00	 ret	 4
?SetAsTarget@ioChampionAI@@AAE_NPAVioBaseChar@@@Z ENDP	; ioChampionAI::SetAsTarget
_TEXT	ENDS
PUBLIC	__real@4f800000
PUBLIC	_pNPC$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?IsNPCBlocking@ioChampionAI@@IAE_NPAVioBaseChar@@AAM@Z ; ioChampionAI::IsNPCBlocking
EXTRN	?CheckLeftRightPos@ioAI@@IAE_NABUD3DXQUATERNION@@ABUD3DXVECTOR3@@MAAU3@2@Z:PROC ; ioAI::CheckLeftRightPos
EXTRN	__imp_?VEC3_ZERO@ioMath@@2UD3DXVECTOR3@@A:BYTE
EXTRN	__imp_?AngleGap@ioMath@@SAMMM@Z:PROC
EXTRN	?GetAngle@ioAI@@QAEMUD3DXVECTOR3@@0@Z:PROC	; ioAI::GetAngle
EXTRN	?GetTargetRange@ioAI@@IAEMUD3DXVECTOR3@@@Z:PROC	; ioAI::GetTargetRange
EXTRN	__imp_??8ioHashString@@QBE_NABV0@@Z:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT __real@4f800000
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioai.h
CONST	SEGMENT
__real@4f800000 DD 04f800000r			; 4.29497e+009
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iochampionai_legacy.cpp
CONST	ENDS
;	COMDAT ?IsNPCBlocking@ioChampionAI@@IAE_NPAVioBaseChar@@AAM@Z
_TEXT	SEGMENT
_fAngle2$546532 = -32					; size = 4
_fDistSq$ = -28						; size = 4
_pNPC$GSCopy$ = -24					; size = 4
tv359 = -20						; size = 4
tv299 = -20						; size = 4
tv278 = -20						; size = 4
tv269 = -20						; size = 4
$T549274 = -20						; size = 4
_fAngle1$546531 = -20					; size = 4
_vTargetPos$546537 = -16				; size = 12
__$ArrayPad$ = -4					; size = 4
_pNPC$ = 8						; size = 4
_fSearchRange$ = 12					; size = 4
?IsNPCBlocking@ioChampionAI@@IAE_NPAVioBaseChar@@AAM@Z PROC ; ioChampionAI::IsNPCBlocking, COMDAT
; _this$ = ecx

; 115  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _pNPC$[ebp]
  00015	8b d9		 mov	 ebx, ecx

; 116  : 	if( m_pCreator->GetCharName() == pNPC->GetCharName() ) 

  00017	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0001a	57		 push	 edi
  0001b	8d 86 d4 02 00
	00		 lea	 eax, DWORD PTR [esi+724]
  00021	81 c1 d4 02 00
	00		 add	 ecx, 724		; 000002d4H
  00027	50		 push	 eax

; 145  : 
; 146  : 			m_TargetData.SetTargetPos( vTargetPos );

  00028	89 75 e8	 mov	 DWORD PTR _pNPC$GSCopy$[ebp], esi
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??8ioHashString@@QBE_NABV0@@Z
  00031	84 c0		 test	 al, al
  00033	0f 85 9b 01 00
	00		 jne	 $LN4@IsNPCBlock

; 117  : 		return false;
; 118  : 
; 119  : 	if( pNPC->GetState() == CS_READY ||
; 120  : 		pNPC->GetState() == CS_VIEW  ||
; 121  : 		pNPC->GetState() == CS_DIE   ||
; 122  : 		pNPC->GetState() == CS_OBSERVER ||
; 123  : 		pNPC->GetState() == CS_LOADING ||
; 124  : 		pNPC->GetState() == CS_DROP_ZONE_DOWN ||
; 125  : 		pNPC->GetState() == CS_FALL || 
; 126  : 		pNPC->GetState() == CS_BLOW_WOUNDED ||
; 127  : 		pNPC->GetState() == CS_BOUND_BLOW_WOUNDED ||
; 128  : 		pNPC->GetState() == CS_BLOW_EXTEND_WOUND )

  00039	8a 86 10 03 00
	00		 mov	 al, BYTE PTR [esi+784]
  0003f	3c 18		 cmp	 al, 24			; 00000018H
  00041	0f 84 8d 01 00
	00		 je	 $LN4@IsNPCBlock
  00047	3c 1a		 cmp	 al, 26			; 0000001aH
  00049	0f 84 85 01 00
	00		 je	 $LN4@IsNPCBlock
  0004f	3c 0e		 cmp	 al, 14			; 0000000eH
  00051	0f 84 7d 01 00
	00		 je	 $LN4@IsNPCBlock
  00057	3c 2a		 cmp	 al, 42			; 0000002aH
  00059	0f 84 75 01 00
	00		 je	 $LN4@IsNPCBlock
  0005f	3c 24		 cmp	 al, 36			; 00000024H
  00061	0f 84 6d 01 00
	00		 je	 $LN4@IsNPCBlock
  00067	3c 10		 cmp	 al, 16			; 00000010H
  00069	0f 84 65 01 00
	00		 je	 $LN4@IsNPCBlock
  0006f	3c 12		 cmp	 al, 18			; 00000012H
  00071	0f 84 5d 01 00
	00		 je	 $LN4@IsNPCBlock
  00077	3c 0c		 cmp	 al, 12			; 0000000cH
  00079	0f 84 55 01 00
	00		 je	 $LN4@IsNPCBlock
  0007f	3c 31		 cmp	 al, 49			; 00000031H
  00081	0f 84 4d 01 00
	00		 je	 $LN4@IsNPCBlock
  00087	3c 46		 cmp	 al, 70			; 00000046H
  00089	0f 84 45 01 00
	00		 je	 $LN4@IsNPCBlock

; 131  : 	}
; 132  : 
; 133  : 	float fDistSq = GetTargetRange( pNPC->GetWorldPosition() );

  0008f	8b 06		 mov	 eax, DWORD PTR [esi]
  00091	8b ce		 mov	 ecx, esi
  00093	ff 50 70	 call	 DWORD PTR [eax+112]
  00096	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00099	8b f0		 mov	 esi, eax
  0009b	8b fc		 mov	 edi, esp
  0009d	a5		 movsd
  0009e	a5		 movsd
  0009f	8b cb		 mov	 ecx, ebx
  000a1	a5		 movsd
  000a2	e8 00 00 00 00	 call	 ?GetTargetRange@ioAI@@IAEMUD3DXVECTOR3@@@Z ; ioAI::GetTargetRange

; 134  : 	if( fDistSq < fSearchRange )	

  000a7	8b 45 0c	 mov	 eax, DWORD PTR _fSearchRange$[ebp]
  000aa	d9 5d e4	 fstp	 DWORD PTR _fDistSq$[ebp]
  000ad	d9 45 e4	 fld	 DWORD PTR _fDistSq$[ebp]
  000b0	d9 00		 fld	 DWORD PTR [eax]
  000b2	df f1		 fcomip	 ST(1)
  000b4	dd d8		 fstp	 ST(0)
  000b6	0f 86 18 01 00
	00		 jbe	 $LN4@IsNPCBlock

; 135  : 	{
; 136  : 		float fAngle1   = GetAngle( m_TargetData.GetTargetPos(), m_pCreator->GetWorldPosition() );

  000bc	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  000bf	8b 01		 mov	 eax, DWORD PTR [ecx]
  000c1	ff 50 70	 call	 DWORD PTR [eax+112]
  000c4	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000c7	8b fc		 mov	 edi, esp
  000c9	8b f0		 mov	 esi, eax
  000cb	a5		 movsd
  000cc	a5		 movsd
  000cd	a5		 movsd
  000ce	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000d1	8b fc		 mov	 edi, esp
  000d3	8d b3 c8 00 00
	00		 lea	 esi, DWORD PTR [ebx+200]
  000d9	a5		 movsd
  000da	a5		 movsd
  000db	8b cb		 mov	 ecx, ebx
  000dd	a5		 movsd
  000de	e8 00 00 00 00	 call	 ?GetAngle@ioAI@@QAEMUD3DXVECTOR3@@0@Z ; ioAI::GetAngle

; 137  : 		float fAngle2   = GetAngle( pNPC->GetWorldPosition(), m_pCreator->GetWorldPosition() );

  000e3	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  000e6	8b 01		 mov	 eax, DWORD PTR [ecx]
  000e8	d9 5d ec	 fstp	 DWORD PTR _fAngle1$546531[ebp]
  000eb	ff 50 70	 call	 DWORD PTR [eax+112]
  000ee	8b 4d e8	 mov	 ecx, DWORD PTR _pNPC$GSCopy$[ebp]
  000f1	8b f0		 mov	 esi, eax
  000f3	8b 01		 mov	 eax, DWORD PTR [ecx]
  000f5	ff 50 70	 call	 DWORD PTR [eax+112]
  000f8	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000fb	8b fc		 mov	 edi, esp
  000fd	a5		 movsd
  000fe	a5		 movsd
  000ff	a5		 movsd
  00100	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00103	8b f0		 mov	 esi, eax
  00105	8b fc		 mov	 edi, esp
  00107	a5		 movsd
  00108	a5		 movsd
  00109	8b cb		 mov	 ecx, ebx
  0010b	a5		 movsd
  0010c	e8 00 00 00 00	 call	 ?GetAngle@ioAI@@QAEMUD3DXVECTOR3@@0@Z ; ioAI::GetAngle

; 138  : 		float fGapAngle = fabs( ioMath::AngleGap( fAngle1, fAngle2 ) );

  00111	51		 push	 ecx
  00112	d9 5d e0	 fstp	 DWORD PTR _fAngle2$546532[ebp]
  00115	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _fAngle2$546532[ebp]
  0011a	51		 push	 ecx
  0011b	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00121	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _fAngle1$546531[ebp]
  00126	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0012b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?AngleGap@ioMath@@SAMMM@Z
  00131	d9 5d ec	 fstp	 DWORD PTR $T549274[ebp]
  00134	59		 pop	 ecx
  00135	59		 pop	 ecx

; 139  : 		float fCheckAngle = m_fObjectSearchAngle * ( FLOAT1 - ( fDistSq / fSearchRange ) );

  00136	b8 01 00 00 00	 mov	 eax, 1

; 140  : 		if( fGapAngle <= fCheckAngle )

  0013b	d9 45 ec	 fld	 DWORD PTR $T549274[ebp]
  0013e	d9 e1		 fabs
  00140	d9 5d ec	 fstp	 DWORD PTR tv359[ebp]
  00143	d9 45 ec	 fld	 DWORD PTR tv359[ebp]
  00146	89 45 ec	 mov	 DWORD PTR tv278[ebp], eax
  00149	db 45 ec	 fild	 DWORD PTR tv278[ebp]
  0014c	85 c0		 test	 eax, eax
  0014e	79 06		 jns	 SHORT $LN47@IsNPCBlock
  00150	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN47@IsNPCBlock:
  00156	d9 45 e4	 fld	 DWORD PTR _fDistSq$[ebp]
  00159	8b 45 0c	 mov	 eax, DWORD PTR _fSearchRange$[ebp]
  0015c	d8 30		 fdiv	 DWORD PTR [eax]
  0015e	de e9		 fsubp	 ST(1), ST(0)
  00160	d8 4b 30	 fmul	 DWORD PTR [ebx+48]
  00163	d9 5d ec	 fstp	 DWORD PTR tv269[ebp]
  00166	d9 45 ec	 fld	 DWORD PTR tv269[ebp]
  00169	df f1		 fcomip	 ST(1)
  0016b	dd d8		 fstp	 ST(0)
  0016d	72 65		 jb	 SHORT $LN4@IsNPCBlock

; 141  : 		{
; 142  : 			D3DXVECTOR3 vTargetPos = ioMath::VEC3_ZERO;

  0016f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?VEC3_ZERO@ioMath@@2UD3DXVECTOR3@@A
  00175	8d 7d f0	 lea	 edi, DWORD PTR _vTargetPos$546537[ebp]
  00178	a5		 movsd
  00179	a5		 movsd
  0017a	a5		 movsd

; 143  : 			if( !CheckLeftRightPos( pNPC->GetWorldOrientation(), pNPC->GetWorldPosition(), FLOAT100, m_TargetData.GetTargetPos(), vTargetPos ) )

  0017b	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  00180	8d 4d f0	 lea	 ecx, DWORD PTR _vTargetPos$546537[ebp]
  00183	51		 push	 ecx
  00184	8d bb c8 00 00
	00		 lea	 edi, DWORD PTR [ebx+200]
  0018a	89 45 ec	 mov	 DWORD PTR tv299[ebp], eax
  0018d	57		 push	 edi
  0018e	db 45 ec	 fild	 DWORD PTR tv299[ebp]
  00191	85 c0		 test	 eax, eax
  00193	79 06		 jns	 SHORT $LN48@IsNPCBlock
  00195	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN48@IsNPCBlock:
  0019b	8b 75 e8	 mov	 esi, DWORD PTR _pNPC$GSCopy$[ebp]
  0019e	8b 06		 mov	 eax, DWORD PTR [esi]
  001a0	51		 push	 ecx
  001a1	8b ce		 mov	 ecx, esi
  001a3	d9 1c 24	 fstp	 DWORD PTR [esp]
  001a6	ff 50 70	 call	 DWORD PTR [eax+112]
  001a9	50		 push	 eax
  001aa	8b 06		 mov	 eax, DWORD PTR [esi]
  001ac	8b ce		 mov	 ecx, esi
  001ae	ff 50 74	 call	 DWORD PTR [eax+116]
  001b1	50		 push	 eax
  001b2	8b cb		 mov	 ecx, ebx
  001b4	e8 00 00 00 00	 call	 ?CheckLeftRightPos@ioAI@@IAE_NABUD3DXQUATERNION@@ABUD3DXVECTOR3@@MAAU3@2@Z ; ioAI::CheckLeftRightPos
  001b9	84 c0		 test	 al, al

; 144  : 				return false;

  001bb	74 17		 je	 SHORT $LN4@IsNPCBlock

; 145  : 
; 146  : 			m_TargetData.SetTargetPos( vTargetPos );

  001bd	8d 75 f0	 lea	 esi, DWORD PTR _vTargetPos$546537[ebp]
  001c0	a5		 movsd
  001c1	a5		 movsd

; 147  : 			m_TargetData.SetTargetType( TARGET_POSITION );

  001c2	6a 03		 push	 3
  001c4	8d 8b b4 00 00
	00		 lea	 ecx, DWORD PTR [ebx+180]
  001ca	a5		 movsd
  001cb	e8 00 00 00 00	 call	 ?SetTargetType@TargetData@ioAI@@QAEXW4TargetType@2@@Z ; ioAI::TargetData::SetTargetType

; 148  : 			
; 149  : 			return true;

  001d0	b0 01		 mov	 al, 1
  001d2	eb 02		 jmp	 SHORT $LN7@IsNPCBlock
$LN4@IsNPCBlock:

; 129  : 	{
; 130  : 		return false;

  001d4	32 c0		 xor	 al, al
$LN7@IsNPCBlock:

; 150  : 		}
; 151  : 	}
; 152  : 	return false;
; 153  : }

  001d6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d9	5f		 pop	 edi
  001da	5e		 pop	 esi
  001db	33 cd		 xor	 ecx, ebp
  001dd	5b		 pop	 ebx
  001de	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e3	c9		 leave
  001e4	c2 08 00	 ret	 8
?IsNPCBlocking@ioChampionAI@@IAE_NPAVioBaseChar@@AAM@Z ENDP ; ioChampionAI::IsNPCBlocking
_TEXT	ENDS
PUBLIC	?CanSearchTimeBeUpdated@ioChampionAI@@IAE_NXZ	; ioChampionAI::CanSearchTimeBeUpdated
EXTRN	__imp_?GetLoopSec@ioFrameTimer@@QBEKXZ:PROC
EXTRN	__imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ?CanSearchTimeBeUpdated@ioChampionAI@@IAE_NXZ
_TEXT	SEGMENT
tv136 = -4						; size = 4
_fSearchTime$ = -4					; size = 4
?CanSearchTimeBeUpdated@ioChampionAI@@IAE_NXZ PROC	; ioChampionAI::CanSearchTimeBeUpdated, COMDAT
; _this$ = ecx

; 233  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 234  : 	float fSearchTime = FRAMEGETTIME() - m_fSearchTargetTime;

  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  0000d	8b c8		 mov	 ecx, eax
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ
  00015	89 45 fc	 mov	 DWORD PTR tv136[ebp], eax
  00018	db 45 fc	 fild	 DWORD PTR tv136[ebp]
  0001b	85 c0		 test	 eax, eax
  0001d	79 06		 jns	 SHORT $LN4@CanSearchT
  0001f	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN4@CanSearchT:
  00025	d8 66 10	 fsub	 DWORD PTR [esi+16]
  00028	d9 5d fc	 fstp	 DWORD PTR _fSearchTime$[ebp]

; 235  : 	if( fSearchTime < m_fCurSearchTime )

  0002b	d9 45 fc	 fld	 DWORD PTR _fSearchTime$[ebp]
  0002e	d9 86 a0 00 00
	00		 fld	 DWORD PTR [esi+160]
  00034	5e		 pop	 esi
  00035	df f1		 fcomip	 ST(1)
  00037	dd d8		 fstp	 ST(0)
  00039	76 04		 jbe	 SHORT $LN1@CanSearchT

; 236  : 	{
; 237  : 		return false;

  0003b	32 c0		 xor	 al, al

; 241  : }

  0003d	c9		 leave
  0003e	c3		 ret	 0
$LN1@CanSearchT:

; 238  : 	}
; 239  : 
; 240  : 	return true;

  0003f	b0 01		 mov	 al, 1

; 241  : }

  00041	c9		 leave
  00042	c3		 ret	 0
?CanSearchTimeBeUpdated@ioChampionAI@@IAE_NXZ ENDP	; ioChampionAI::CanSearchTimeBeUpdated
_TEXT	ENDS
PUBLIC	__real@471c4000
PUBLIC	__$ArrayPad$
PUBLIC	?SetToRoamingMonster@ioChampionAI@@IAE_NAAM@Z	; ioChampionAI::SetToRoamingMonster
EXTRN	?GetRoamingPoint@ioAI@@IAE?AUD3DXVECTOR3@@XZ:PROC ; ioAI::GetRoamingPoint
;	COMDAT __real@471c4000
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasechar.h
CONST	SEGMENT
__real@471c4000 DD 0471c4000r			; 40000
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iochampionai_legacy.cpp
CONST	ENDS
;	COMDAT ?SetToRoamingMonster@ioChampionAI@@IAE_NAAM@Z
_TEXT	SEGMENT
$T546610 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_fSearchRange$ = 8					; size = 4
?SetToRoamingMonster@ioChampionAI@@IAE_NAAM@Z PROC	; ioChampionAI::SetToRoamingMonster, COMDAT
; _this$ = ecx

; 294  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _fSearchRange$[ebp]
  00013	53		 push	 ebx
  00014	8b d9		 mov	 ebx, ecx

; 295  : 	// 타겟이 없으면 로밍
; 296  : 	if( m_TargetData.GetTargetType() == TARGET_NONE )

  00016	83 bb b4 00 00
	00 00		 cmp	 DWORD PTR [ebx+180], 0
  0001d	75 4f		 jne	 SHORT $LN1@SetToRoami

; 297  : 	{
; 298  : 		// processed check death monster romaing
; 299  : 		if( m_bRoaming )

  0001f	80 7b 40 00	 cmp	 BYTE PTR [ebx+64], 0
  00023	74 49		 je	 SHORT $LN1@SetToRoami

; 300  : 		{
; 301  : 			fSearchRange = 200.0f * 200.0f;

  00025	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@471c4000
  0002d	56		 push	 esi
  0002e	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00032	57		 push	 edi

; 302  : 			m_TargetData.SetTargetPos( GetRoamingPoint() );

  00033	8d 45 f0	 lea	 eax, DWORD PTR $T546610[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ?GetRoamingPoint@ioAI@@IAE?AUD3DXVECTOR3@@XZ ; ioAI::GetRoamingPoint
  0003c	8b f0		 mov	 esi, eax
  0003e	8d bb c8 00 00
	00		 lea	 edi, DWORD PTR [ebx+200]
  00044	a5		 movsd
  00045	a5		 movsd

; 303  : 			m_TargetData.SetTargetType( TARGET_ROAMING );

  00046	6a 04		 push	 4
  00048	8d 8b b4 00 00
	00		 lea	 ecx, DWORD PTR [ebx+180]
  0004e	a5		 movsd
  0004f	e8 00 00 00 00	 call	 ?SetTargetType@TargetData@ioAI@@QAEXW4TargetType@2@@Z ; ioAI::TargetData::SetTargetType

; 304  : 			m_TargetData.SetTargetName( m_pCreator->GetCharName() );

  00054	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00057	05 d4 02 00 00	 add	 eax, 724		; 000002d4H
  0005c	50		 push	 eax
  0005d	8d 8b b4 00 00
	00		 lea	 ecx, DWORD PTR [ebx+180]
  00063	e8 00 00 00 00	 call	 ?SetTargetName@TargetData@ioAI@@QAEXABVioHashString@@@Z ; ioAI::TargetData::SetTargetName
  00068	5f		 pop	 edi

; 305  : 
; 306  : 			return true;

  00069	b0 01		 mov	 al, 1
  0006b	5e		 pop	 esi
  0006c	eb 02		 jmp	 SHORT $LN3@SetToRoami
$LN1@SetToRoami:

; 307  : 		}
; 308  : 	}
; 309  : 
; 310  : 	return false;

  0006e	32 c0		 xor	 al, al
$LN3@SetToRoami:

; 311  : }

  00070	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00073	33 cd		 xor	 ecx, ebp
  00075	5b		 pop	 ebx
  00076	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007b	c9		 leave
  0007c	c2 04 00	 ret	 4
?SetToRoamingMonster@ioChampionAI@@IAE_NAAM@Z ENDP	; ioChampionAI::SetToRoamingMonster
_TEXT	ENDS
PUBLIC	?HasValidTarget@ioChampionAI@@IAE_NXZ		; ioChampionAI::HasValidTarget
; Function compile flags: /Ogsp
;	COMDAT ?HasValidTarget@ioChampionAI@@IAE_NXZ
_TEXT	SEGMENT
?HasValidTarget@ioChampionAI@@IAE_NXZ PROC		; ioChampionAI::HasValidTarget, COMDAT
; _this$ = ecx

; 315  : 	return !m_TargetData.GetTargetName().IsEmpty();

  00000	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  0000c	33 c9		 xor	 ecx, ecx
  0000e	84 c0		 test	 al, al
  00010	0f 94 c0	 sete	 al

; 316  : }

  00013	c3		 ret	 0
?HasValidTarget@ioChampionAI@@IAE_NXZ ENDP		; ioChampionAI::HasValidTarget
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with null pointer

  00000	8b c1		 mov	 eax, ecx
  00002	83 20 00	 and	 DWORD PTR [eax], 0

; 41   : 		}

  00005	c3		 ret	 0
??0?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBEABQAVioBaseChar@@XZ ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator*
; Function compile flags: /Ogsp
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBEABQAVioBaseChar@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBEABQAVioBaseChar@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator*, COMDAT
; _this$ = ecx

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);
; 83   : 
; 84   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 85   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBEABQAVioBaseChar@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator++
; Function compile flags: /Ogsp
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator++, COMDAT
; _this$ = ecx

; 93   : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

  00002	83 00 04	 add	 DWORD PTR [eax], 4

; 111  : 		return (*this);
; 112  : 		}

  00005	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator++
_TEXT	ENDS
PUBLIC	?_Nextnode@?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@SAAAPAU_Node@?$_List_nod@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@2@PAU342@@Z ; std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> >::_Nextnode
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ?_Nextnode@?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@SAAAPAU_Node@?$_List_nod@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@SAAAPAU_Node@?$_List_nod@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@2@PAU342@@Z PROC ; std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> >::_Nextnode, COMDAT

; 560  : 		{	// return reference to successor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 561  : 		return ((_Nodepref)(*_Pnode)._Next);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 562  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Nextnode@?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@SAAAPAU_Node@?$_List_nod@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@2@PAU342@@Z ENDP ; std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> >::_Nextnode
_TEXT	ENDS
PUBLIC	?_Myval@?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@SAAAPAVioGameEntity@@PAU_Node@?$_List_nod@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@2@@Z ; std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> >::_Myval
; Function compile flags: /Ogsp
;	COMDAT ?_Myval@?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@SAAAPAVioGameEntity@@PAU_Node@?$_List_nod@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@SAAAPAVioGameEntity@@PAU_Node@?$_List_nod@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@2@@Z PROC ; std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> >::_Myval, COMDAT

; 570  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 571  : 		return ((reference)(*_Pnode)._Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 572  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@SAAAPAVioGameEntity@@PAU_Node@?$_List_nod@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@2@@Z ENDP ; std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> >::_Myval
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@PAPAVioBaseChar@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@PAPAVioBaseChar@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@PAPAVioBaseChar@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@PAPAVioBaseChar@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >
_TEXT	ENDS
PUBLIC	??8?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> > >::operator==
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> > >::operator==, COMDAT
; _this$ = ecx

; 281  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 282  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 283  : 		if (this->_Getcont() == 0
; 284  : 			|| this->_Getcont() != _Right._Getcont())
; 285  : 			{	// report error
; 286  : 			_DEBUG_ERROR("list iterators incompatible");
; 287  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 288  : 			}
; 289  : 
; 290  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 291  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 292  : 			&& this->_Getcont() == _Right._Getcont());
; 293  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 294  : 
; 295  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	f7 d8		 neg	 eax
  0000c	1b c0		 sbb	 eax, eax
  0000e	40		 inc	 eax

; 296  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> > >::operator==
_TEXT	ENDS
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_List_unchecked_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> >,std::_Iterator_base0>
; Function compile flags: /Ogsp
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_unchecked_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 36   : 		{	// construct with null node pointer

  00000	8b c1		 mov	 eax, ecx
  00002	83 20 00	 and	 DWORD PTR [eax], 0

; 37   : 		}

  00005	c3		 ret	 0
??0?$_List_unchecked_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Compat
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Compat, COMDAT
; _this$ = ecx

; 253  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Compat
_TEXT	ENDS
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@1@PBV?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> >,std::_Iterator_base0>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@1@PBV?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@1@PBV?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 41   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 42   : 		this->_Adopt(_Plist);
; 43   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_unchecked_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@1@PBV?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	__real@3f91df46a2526c7a
PUBLIC	??$DEGtoRAD@M@@YAMM@Z				; DEGtoRAD<float>
;	COMDAT __real@3f91df46a2526c7a
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\veryoftenusedefine.h
CONST	SEGMENT
__real@3f91df46a2526c7a DQ 03f91df46a2526c7ar	; 0.0174533
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??$DEGtoRAD@M@@YAMM@Z
_TEXT	SEGMENT
tv129 = 8						; size = 4
_val$ = 8						; size = 4
??$DEGtoRAD@M@@YAMM@Z PROC				; DEGtoRAD<float>, COMDAT

; 20   : type  DEGtoRAD (type val) {return (type) (val * 0.0174532925199);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR _val$[ebp]
  00006	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3f91df46a2526c7a
  0000c	d9 5d 08	 fstp	 DWORD PTR tv129[ebp]
  0000f	d9 45 08	 fld	 DWORD PTR tv129[ebp]
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$DEGtoRAD@M@@YAMM@Z ENDP				; DEGtoRAD<float>
_TEXT	ENDS
PUBLIC	??0D3DXQUATERNION@@QAE@XZ			; D3DXQUATERNION::D3DXQUATERNION
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx9math.h
;	COMDAT ??0D3DXQUATERNION@@QAE@XZ
_TEXT	SEGMENT
??0D3DXQUATERNION@@QAE@XZ PROC				; D3DXQUATERNION::D3DXQUATERNION, COMDAT
; _this$ = ecx

; 429  :     D3DXQUATERNION() {}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXQUATERNION@@QAE@XZ ENDP				; D3DXQUATERNION::D3DXQUATERNION
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx9math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 303  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 304  :     x = fx;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00008	8b c1		 mov	 eax, ecx
  0000a	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 305  :     y = fy;

  0000e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00013	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 306  :     z = fz;

  00018	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0001d	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 307  : }

  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
PUBLIC	??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z			; D3DXVECTOR3::operator+
; Function compile flags: /Ogsp
;	COMDAT ??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z PROC			; D3DXVECTOR3::operator+, COMDAT
; _this$ = ecx

; 380  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 381  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00006	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  0000a	f3 0f 10 09	 movss	 xmm1, DWORD PTR [ecx]
  0000e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00011	0f 5a c0	 cvtps2pd xmm0, xmm0
  00014	0f 5a c9	 cvtps2pd xmm1, xmm1
  00017	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0001b	f3 0f 10 49 04	 movss	 xmm1, DWORD PTR [ecx+4]
  00020	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00024	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00028	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [edx+4]
  0002d	0f 5a c0	 cvtps2pd xmm0, xmm0
  00030	0f 5a c9	 cvtps2pd xmm1, xmm1
  00033	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00037	f3 0f 10 49 08	 movss	 xmm1, DWORD PTR [ecx+8]
  0003c	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00040	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  00045	f3 0f 10 42 08	 movss	 xmm0, DWORD PTR [edx+8]
  0004a	0f 5a c0	 cvtps2pd xmm0, xmm0
  0004d	0f 5a c9	 cvtps2pd xmm1, xmm1
  00050	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00054	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00058	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 382  : }

  0005d	5d		 pop	 ebp
  0005e	c2 08 00	 ret	 8
??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator+
_TEXT	ENDS
PUBLIC	??D@YA?AUD3DXVECTOR3@@MABU0@@Z			; operator*
; Function compile flags: /Ogsp
;	COMDAT ??D@YA?AUD3DXVECTOR3@@MABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_f$ = 12						; size = 4
_v$ = 16						; size = 4
??D@YA?AUD3DXVECTOR3@@MABU0@@Z PROC			; operator*, COMDAT

; 406  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 407  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00003	8b 4d 10	 mov	 ecx, DWORD PTR _v$[ebp]
  00006	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _f$[ebp]
  0000b	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00012	0f 5a c0	 cvtps2pd xmm0, xmm0
  00015	0f 5a c9	 cvtps2pd xmm1, xmm1
  00018	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  0001c	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _f$[ebp]
  00021	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00025	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00029	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0002e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00031	0f 5a c9	 cvtps2pd xmm1, xmm1
  00034	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00038	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _f$[ebp]
  0003d	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00041	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  00046	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  0004b	0f 5a c0	 cvtps2pd xmm0, xmm0
  0004e	0f 5a c9	 cvtps2pd xmm1, xmm1
  00051	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00055	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00059	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 408  : }

  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
??D@YA?AUD3DXVECTOR3@@MABU0@@Z ENDP			; operator*
_TEXT	ENDS
PUBLIC	?GetGroup@ioGameEntity@@QBEPAVioEntityGroup@@XZ	; ioGameEntity::GetGroup
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iogameentity.h
;	COMDAT ?GetGroup@ioGameEntity@@QBEPAVioEntityGroup@@XZ
_TEXT	SEGMENT
?GetGroup@ioGameEntity@@QBEPAVioEntityGroup@@XZ PROC	; ioGameEntity::GetGroup, COMDAT
; _this$ = ecx

; 166  : 	inline ioEntityGroup* GetGroup() const { return m_pGroup; }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetGroup@ioGameEntity@@QBEPAVioEntityGroup@@XZ ENDP	; ioGameEntity::GetGroup
_TEXT	ENDS
PUBLIC	??_R0?AVioGameEntity@@@8			; ioGameEntity `RTTI Type Descriptor'
PUBLIC	??_R0?AVioPlayEntity@@@8			; ioPlayEntity `RTTI Type Descriptor'
PUBLIC	?ToPlayEntity@@YAPAVioPlayEntity@@PAVioGameEntity@@@Z ; ToPlayEntity
EXTRN	___RTDynamicCast:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT ??_R0?AVioGameEntity@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioplayentity.h
_DATA	SEGMENT
??_R0?AVioGameEntity@@@8 DD FLAT:??_7type_info@@6B@	; ioGameEntity `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioGameEntity@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVioPlayEntity@@@8
_DATA	SEGMENT
??_R0?AVioPlayEntity@@@8 DD FLAT:??_7type_info@@6B@	; ioPlayEntity `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioPlayEntity@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToPlayEntity@@YAPAVioPlayEntity@@PAVioGameEntity@@@Z
_TEXT	SEGMENT
_pObj$ = 8						; size = 4
?ToPlayEntity@@YAPAVioPlayEntity@@PAVioGameEntity@@@Z PROC ; ToPlayEntity, COMDAT

; 121  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 122  : 	if( !pObj || pObj->GetTypeID() != ioGameEntity::GET_PLAY_ENTITY )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pObj$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 25		 je	 SHORT $LN1@ToPlayEnti
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 50 10	 call	 DWORD PTR [eax+16]
  00012	83 f8 01	 cmp	 eax, 1
  00015	75 19		 jne	 SHORT $LN1@ToPlayEnti

; 124  : 
; 125  : 	return dynamic_cast< ioPlayEntity* >( pObj );

  00017	6a 00		 push	 0
  00019	68 00 00 00 00	 push	 OFFSET ??_R0?AVioPlayEntity@@@8
  0001e	68 00 00 00 00	 push	 OFFSET ??_R0?AVioGameEntity@@@8
  00023	6a 00		 push	 0
  00025	56		 push	 esi
  00026	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002b	83 c4 14	 add	 esp, 20			; 00000014H
  0002e	eb 02		 jmp	 SHORT $LN3@ToPlayEnti
$LN1@ToPlayEnti:

; 123  : 		return NULL;

  00030	33 c0		 xor	 eax, eax
$LN3@ToPlayEnti:
  00032	5e		 pop	 esi

; 126  : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?ToPlayEntity@@YAPAVioPlayEntity@@PAVioGameEntity@@@Z ENDP ; ToPlayEntity
_TEXT	ENDS
PUBLIC	?IsEnableClick@ioPushStruct@@QBE_NXZ		; ioPushStruct::IsEnableClick
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iopushstruct.h
;	COMDAT ?IsEnableClick@ioPushStruct@@QBE_NXZ
_TEXT	SEGMENT
?IsEnableClick@ioPushStruct@@QBE_NXZ PROC		; ioPushStruct::IsEnableClick, COMDAT
; _this$ = ecx

; 355  : 	inline bool IsEnableClick() const { return m_bEnableClick; }

  00000	8a 81 c8 03 00
	00		 mov	 al, BYTE PTR [ecx+968]
  00006	c3		 ret	 0
?IsEnableClick@ioPushStruct@@QBE_NXZ ENDP		; ioPushStruct::IsEnableClick
_TEXT	ENDS
PUBLIC	??_R0?AVioPushStruct@@@8			; ioPushStruct `RTTI Type Descriptor'
PUBLIC	?ToPushStruct@@YAPAVioPushStruct@@PAVioGameEntity@@@Z ; ToPushStruct
;	COMDAT ??_R0?AVioPushStruct@@@8
_DATA	SEGMENT
??_R0?AVioPushStruct@@@8 DD FLAT:??_7type_info@@6B@	; ioPushStruct `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioPushStruct@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToPushStruct@@YAPAVioPushStruct@@PAVioGameEntity@@@Z
_TEXT	SEGMENT
_pObj$ = 8						; size = 4
?ToPushStruct@@YAPAVioPushStruct@@PAVioGameEntity@@@Z PROC ; ToPushStruct, COMDAT

; 440  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 441  : 	ioPlayEntity *pPlay = ToPlayEntity( pObj );

  00004	ff 75 08	 push	 DWORD PTR _pObj$[ebp]
  00007	e8 00 00 00 00	 call	 ?ToPlayEntity@@YAPAVioPlayEntity@@PAVioGameEntity@@@Z ; ToPlayEntity
  0000c	8b f0		 mov	 esi, eax
  0000e	59		 pop	 ecx

; 442  : 	if( !pPlay || pPlay->GetSubType() != ioPlayEntity::PST_PUSHSTRUCT )

  0000f	85 f6		 test	 esi, esi
  00011	74 28		 je	 SHORT $LN1@ToPushStru
  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	8b ce		 mov	 ecx, esi
  00017	ff 90 a4 00 00
	00		 call	 DWORD PTR [eax+164]
  0001d	83 f8 02	 cmp	 eax, 2
  00020	75 19		 jne	 SHORT $LN1@ToPushStru

; 444  : 
; 445  : 	return dynamic_cast< ioPushStruct* >( pPlay );

  00022	6a 00		 push	 0
  00024	68 00 00 00 00	 push	 OFFSET ??_R0?AVioPushStruct@@@8
  00029	68 00 00 00 00	 push	 OFFSET ??_R0?AVioPlayEntity@@@8
  0002e	6a 00		 push	 0
  00030	56		 push	 esi
  00031	e8 00 00 00 00	 call	 ___RTDynamicCast
  00036	83 c4 14	 add	 esp, 20			; 00000014H
  00039	eb 02		 jmp	 SHORT $LN3@ToPushStru
$LN1@ToPushStru:

; 443  : 		return NULL;

  0003b	33 c0		 xor	 eax, eax
$LN3@ToPushStru:
  0003d	5e		 pop	 esi

; 446  : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?ToPushStruct@@YAPAVioPushStruct@@PAVioGameEntity@@@Z ENDP ; ToPushStruct
_TEXT	ENDS
PUBLIC	??_R0?AVioBaseChar@@@8				; ioBaseChar `RTTI Type Descriptor'
PUBLIC	?ToBaseChar@@YAPAVioBaseChar@@PAVioGameEntity@@@Z ; ToBaseChar
;	COMDAT ??_R0?AVioBaseChar@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasechar.h
_DATA	SEGMENT
??_R0?AVioBaseChar@@@8 DD FLAT:??_7type_info@@6B@	; ioBaseChar `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioBaseChar@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToBaseChar@@YAPAVioBaseChar@@PAVioGameEntity@@@Z
_TEXT	SEGMENT
_pObj$ = 8						; size = 4
?ToBaseChar@@YAPAVioBaseChar@@PAVioGameEntity@@@Z PROC	; ToBaseChar, COMDAT

; 4326 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4327 : 	ioPlayEntity *pPlay = ToPlayEntity( pObj );

  00004	ff 75 08	 push	 DWORD PTR _pObj$[ebp]
  00007	e8 00 00 00 00	 call	 ?ToPlayEntity@@YAPAVioPlayEntity@@PAVioGameEntity@@@Z ; ToPlayEntity
  0000c	8b f0		 mov	 esi, eax
  0000e	59		 pop	 ecx

; 4328 : 	if( !pPlay || pPlay->GetSubType() != ioPlayEntity::PST_CHAR )

  0000f	85 f6		 test	 esi, esi
  00011	74 25		 je	 SHORT $LN1@ToBaseChar
  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	8b ce		 mov	 ecx, esi
  00017	ff 90 a4 00 00
	00		 call	 DWORD PTR [eax+164]
  0001d	85 c0		 test	 eax, eax
  0001f	75 17		 jne	 SHORT $LN1@ToBaseChar

; 4330 : 
; 4331 : 	return dynamic_cast< ioBaseChar* >( pPlay );

  00021	50		 push	 eax
  00022	68 00 00 00 00	 push	 OFFSET ??_R0?AVioBaseChar@@@8
  00027	68 00 00 00 00	 push	 OFFSET ??_R0?AVioPlayEntity@@@8
  0002c	50		 push	 eax
  0002d	56		 push	 esi
  0002e	e8 00 00 00 00	 call	 ___RTDynamicCast
  00033	83 c4 14	 add	 esp, 20			; 00000014H
  00036	eb 02		 jmp	 SHORT $LN3@ToBaseChar
$LN1@ToBaseChar:

; 4329 : 		return NULL;

  00038	33 c0		 xor	 eax, eax
$LN3@ToBaseChar:
  0003a	5e		 pop	 esi

; 4332 : }

  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?ToBaseChar@@YAPAVioBaseChar@@PAVioGameEntity@@@Z ENDP	; ToBaseChar
_TEXT	ENDS
PUBLIC	??_R0?AVioNpcChar@@@8				; ioNpcChar `RTTI Type Descriptor'
PUBLIC	?ToNpcChar@@YAPAVioNpcChar@@PAVioGameEntity@@@Z	; ToNpcChar
;	COMDAT ??_R0?AVioNpcChar@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ionpcchar.h
_DATA	SEGMENT
??_R0?AVioNpcChar@@@8 DD FLAT:??_7type_info@@6B@	; ioNpcChar `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioNpcChar@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToNpcChar@@YAPAVioNpcChar@@PAVioGameEntity@@@Z
_TEXT	SEGMENT
_pObj$ = 8						; size = 4
?ToNpcChar@@YAPAVioNpcChar@@PAVioGameEntity@@@Z PROC	; ToNpcChar, COMDAT

; 361  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 362  : 	ioBaseChar *pChar = ToBaseChar( pObj );

  00004	ff 75 08	 push	 DWORD PTR _pObj$[ebp]
  00007	e8 00 00 00 00	 call	 ?ToBaseChar@@YAPAVioBaseChar@@PAVioGameEntity@@@Z ; ToBaseChar
  0000c	8b f0		 mov	 esi, eax
  0000e	59		 pop	 ecx

; 363  : 	if( !pChar || pChar->GetControlType() != CONTROL_AI )

  0000f	85 f6		 test	 esi, esi
  00011	74 28		 je	 SHORT $LN1@ToNpcChar
  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	8b ce		 mov	 ecx, esi
  00017	ff 90 ec 00 00
	00		 call	 DWORD PTR [eax+236]
  0001d	83 f8 02	 cmp	 eax, 2
  00020	75 19		 jne	 SHORT $LN1@ToNpcChar

; 365  : 
; 366  : 	return dynamic_cast< ioNpcChar* >(pChar);

  00022	6a 00		 push	 0
  00024	68 00 00 00 00	 push	 OFFSET ??_R0?AVioNpcChar@@@8
  00029	68 00 00 00 00	 push	 OFFSET ??_R0?AVioBaseChar@@@8
  0002e	6a 00		 push	 0
  00030	56		 push	 esi
  00031	e8 00 00 00 00	 call	 ___RTDynamicCast
  00036	83 c4 14	 add	 esp, 20			; 00000014H
  00039	eb 02		 jmp	 SHORT $LN3@ToNpcChar
$LN1@ToNpcChar:

; 364  : 		return NULL;

  0003b	33 c0		 xor	 eax, eax
$LN3@ToNpcChar:
  0003d	5e		 pop	 esi

; 367  : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?ToNpcChar@@YAPAVioNpcChar@@PAVioGameEntity@@@Z ENDP	; ToNpcChar
_TEXT	ENDS
PUBLIC	__real@00000000
PUBLIC	__real@4069000000000000
PUBLIC	__real@4066800000000000
PUBLIC	_fSearchRange$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CheckFlee@ioChampionAI@@IAE_NAAM@Z		; ioChampionAI::CheckFlee
EXTRN	?Init@TargetData@ioAI@@QAEXXZ:PROC		; ioAI::TargetData::Init
EXTRN	__imp_??D@YA?AUD3DXVECTOR3@@ABUD3DXQUATERNION@@ABU0@@Z:PROC
EXTRN	_D3DXQuaternionRotationYawPitchRoll@16:PROC
EXTRN	__imp_?ArrangeHead@ioMath@@SAMM@Z:PROC
;	COMDAT __real@00000000
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasechar.h
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@4069000000000000
CONST	SEGMENT
__real@4069000000000000 DQ 04069000000000000r	; 200
CONST	ENDS
;	COMDAT __real@4066800000000000
CONST	SEGMENT
__real@4066800000000000 DQ 04066800000000000r	; 180
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iochampionai_legacy.cpp
CONST	ENDS
;	COMDAT ?CheckFlee@ioChampionAI@@IAE_NAAM@Z
_TEXT	SEGMENT
_qtAngle$546572 = -68					; size = 16
$T546583 = -52						; size = 12
_fSearchRange$GSCopy$ = -40				; size = 4
tv482 = -36						; size = 4
tv508 = -32						; size = 4
tv493 = -32						; size = 4
_fAngle$546571 = -32					; size = 4
_fDistSq$546569 = -32					; size = 4
_vCurDir$546578 = -28					; size = 12
$T546582 = -16						; size = 12
$T546580 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_fSearchRange$ = 8					; size = 4
?CheckFlee@ioChampionAI@@IAE_NAAM@Z PROC		; ioChampionAI::CheckFlee, COMDAT
; _this$ = ecx

; 195  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _fSearchRange$[ebp]
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b d9		 mov	 ebx, ecx
  00017	57		 push	 edi

; 196  : 	if( !m_TargetData.GetTargetName().IsEmpty() )

  00018	8d 8b b8 00 00
	00		 lea	 ecx, DWORD PTR [ebx+184]

; 205  : 				{
; 206  : 					float fAngle   = GetAngle( m_TargetData.GetTargetPos(), m_pCreator->GetWorldPosition() ) + 180.0f;

  0001e	89 45 d8	 mov	 DWORD PTR _fSearchRange$GSCopy$[ebp], eax
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00027	84 c0		 test	 al, al
  00029	0f 85 f8 01 00
	00		 jne	 $LN1@CheckFlee

; 197  : 	{
; 198  : 		// 대상이 계급 높을 때 도망 
; 199  : 		if( m_TargetData.GetTargetType() == TARGET_BASECHAR )

  0002f	8d 83 b4 00 00
	00		 lea	 eax, DWORD PTR [ebx+180]
  00035	83 38 01	 cmp	 DWORD PTR [eax], 1
  00038	89 45 dc	 mov	 DWORD PTR tv482[ebp], eax
  0003b	0f 85 e6 01 00
	00		 jne	 $LN1@CheckFlee

; 200  : 		{
; 201  : 			if( m_TargetData.GetTargetLevel() >= m_pCreator->GetLevel() )

  00041	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00044	8b 8b d4 00 00
	00		 mov	 ecx, DWORD PTR [ebx+212]
  0004a	3b 88 cc 02 00
	00		 cmp	 ecx, DWORD PTR [eax+716]
  00050	0f 8c d1 01 00
	00		 jl	 $LN1@CheckFlee

; 202  : 			{
; 203  : 				float fDistSq = GetTargetRange( m_TargetData.GetTargetPos() );

  00056	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00059	8b fc		 mov	 edi, esp
  0005b	8d b3 c8 00 00
	00		 lea	 esi, DWORD PTR [ebx+200]
  00061	a5		 movsd
  00062	a5		 movsd
  00063	8b cb		 mov	 ecx, ebx
  00065	a5		 movsd
  00066	e8 00 00 00 00	 call	 ?GetTargetRange@ioAI@@IAEMUD3DXVECTOR3@@@Z ; ioAI::GetTargetRange

; 204  : 				if( fDistSq < m_fEscapeRange * m_fEscapeRange )

  0006b	f3 0f 10 43 34	 movss	 xmm0, DWORD PTR [ebx+52]
  00070	d9 5d e0	 fstp	 DWORD PTR _fDistSq$546569[ebp]
  00073	0f 5a c8	 cvtps2pd xmm1, xmm0
  00076	f3 0f 10 55 e0	 movss	 xmm2, DWORD PTR _fDistSq$546569[ebp]
  0007b	0f 5a d2	 cvtps2pd xmm2, xmm2
  0007e	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  00082	66 0f 2f ca	 comisd	 xmm1, xmm2
  00086	0f 86 8a 01 00
	00		 jbe	 $LN3@CheckFlee

; 205  : 				{
; 206  : 					float fAngle   = GetAngle( m_TargetData.GetTargetPos(), m_pCreator->GetWorldPosition() ) + 180.0f;

  0008c	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0008f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00091	ff 50 70	 call	 DWORD PTR [eax+112]
  00094	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00097	8b fc		 mov	 edi, esp
  00099	8b f0		 mov	 esi, eax
  0009b	a5		 movsd
  0009c	a5		 movsd
  0009d	a5		 movsd
  0009e	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000a1	8b fc		 mov	 edi, esp
  000a3	8d b3 c8 00 00
	00		 lea	 esi, DWORD PTR [ebx+200]
  000a9	a5		 movsd
  000aa	a5		 movsd
  000ab	8b cb		 mov	 ecx, ebx
  000ad	a5		 movsd
  000ae	e8 00 00 00 00	 call	 ?GetAngle@ioAI@@QAEMUD3DXVECTOR3@@0@Z ; ioAI::GetAngle

; 207  : 					fAngle = ioMath::ArrangeHead( fAngle );

  000b3	51		 push	 ecx
  000b4	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@4066800000000000
  000ba	d9 5d e0	 fstp	 DWORD PTR _fAngle$546571[ebp]
  000bd	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _fAngle$546571[ebp]
  000c2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ArrangeHead@ioMath@@SAMM@Z
  000cd	d9 5d e0	 fstp	 DWORD PTR _fAngle$546571[ebp]

; 208  : 					D3DXQUATERNION qtAngle;
; 209  : 					D3DXQuaternionRotationYawPitchRoll( &qtAngle, DEGtoRAD(fAngle), 0.0f, 0.0f );

  000d0	d9 45 e0	 fld	 DWORD PTR _fAngle$546571[ebp]
  000d3	0f 57 c0	 xorps	 xmm0, xmm0
  000d6	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3f91df46a2526c7a
  000dc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e1	51		 push	 ecx
  000e2	51		 push	 ecx
  000e3	d9 5d e0	 fstp	 DWORD PTR tv508[ebp]
  000e6	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000ec	d9 45 e0	 fld	 DWORD PTR tv508[ebp]
  000ef	8d 45 bc	 lea	 eax, DWORD PTR _qtAngle$546572[ebp]
  000f2	d9 1c 24	 fstp	 DWORD PTR [esp]
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 _D3DXQuaternionRotationYawPitchRoll@16

; 210  : 
; 211  : 					D3DXVECTOR3 kBackPos = m_TargetData.GetTargetPos();
; 212  : 					D3DXVECTOR3 vCurDir  = qtAngle * D3DXVECTOR3( 0.0f, 0.0f, -FLOAT1 );

  000fb	b8 01 00 00 00	 mov	 eax, 1
  00100	0f 57 c0	 xorps	 xmm0, xmm0
  00103	89 45 e0	 mov	 DWORD PTR tv493[ebp], eax
  00106	db 45 e0	 fild	 DWORD PTR tv493[ebp]
  00109	f3 0f 11 45 f0	 movss	 DWORD PTR $T546580[ebp], xmm0
  0010e	f3 0f 11 45 f4	 movss	 DWORD PTR $T546580[ebp+4], xmm0
  00113	85 c0		 test	 eax, eax
  00115	79 06		 jns	 SHORT $LN43@CheckFlee
  00117	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN43@CheckFlee:
  0011d	8d 45 f0	 lea	 eax, DWORD PTR $T546580[ebp]
  00120	d9 e0		 fchs
  00122	50		 push	 eax
  00123	d9 5d f8	 fstp	 DWORD PTR $T546580[ebp+8]
  00126	8d 45 bc	 lea	 eax, DWORD PTR _qtAngle$546572[ebp]
  00129	50		 push	 eax
  0012a	8d 45 e4	 lea	 eax, DWORD PTR _vCurDir$546578[ebp]
  0012d	50		 push	 eax
  0012e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??D@YA?AUD3DXVECTOR3@@ABUD3DXQUATERNION@@ABU0@@Z

; 213  : 					m_TargetData.SetTargetPos( m_pCreator->GetWorldPosition() + 200.0f * vCurDir );

  00134	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _vCurDir$546578[ebp]
  00139	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0013c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0013e	0f 5a c8	 cvtps2pd xmm1, xmm0
  00141	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4069000000000000
  00149	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  0014d	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  00151	f3 0f 11 4d f0	 movss	 DWORD PTR $T546582[ebp], xmm1
  00156	f3 0f 10 4d e8	 movss	 xmm1, DWORD PTR _vCurDir$546578[ebp+4]
  0015b	0f 5a c9	 cvtps2pd xmm1, xmm1
  0015e	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  00162	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  00166	f3 0f 11 4d f4	 movss	 DWORD PTR $T546582[ebp+4], xmm1
  0016b	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR _vCurDir$546578[ebp+8]
  00170	0f 5a c9	 cvtps2pd xmm1, xmm1
  00173	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  00177	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  0017b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0017e	f3 0f 11 45 f8	 movss	 DWORD PTR $T546582[ebp+8], xmm0
  00183	ff 50 70	 call	 DWORD PTR [eax+112]
  00186	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  0018a	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR $T546582[ebp]
  0018f	0f 5a c0	 cvtps2pd xmm0, xmm0

; 214  : 					m_TargetData.SetTargetType( TARGET_ESCAPE );

  00192	8b 4d dc	 mov	 ecx, DWORD PTR tv482[ebp]
  00195	0f 5a c9	 cvtps2pd xmm1, xmm1
  00198	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0019c	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR $T546582[ebp+4]
  001a1	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  001a5	f3 0f 11 45 cc	 movss	 DWORD PTR $T546583[ebp], xmm0
  001aa	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  001af	0f 5a c0	 cvtps2pd xmm0, xmm0
  001b2	0f 5a c9	 cvtps2pd xmm1, xmm1
  001b5	f2 0f 58 c1	 addsd	 xmm0, xmm1
  001b9	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR $T546582[ebp+8]
  001be	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  001c2	f3 0f 11 45 d0	 movss	 DWORD PTR $T546583[ebp+4], xmm0
  001c7	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001cc	0f 5a c0	 cvtps2pd xmm0, xmm0
  001cf	0f 5a c9	 cvtps2pd xmm1, xmm1
  001d2	f2 0f 58 c1	 addsd	 xmm0, xmm1
  001d6	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  001da	f3 0f 11 45 d4	 movss	 DWORD PTR $T546583[ebp+8], xmm0
  001df	8d 75 cc	 lea	 esi, DWORD PTR $T546583[ebp]
  001e2	8d bb c8 00 00
	00		 lea	 edi, DWORD PTR [ebx+200]
  001e8	a5		 movsd
  001e9	a5		 movsd
  001ea	6a 06		 push	 6
  001ec	a5		 movsd
  001ed	e8 00 00 00 00	 call	 ?SetTargetType@TargetData@ioAI@@QAEXW4TargetType@2@@Z ; ioAI::TargetData::SetTargetType

; 215  : 					m_TargetData.SetTargetName( m_pCreator->GetCharName() );

  001f2	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  001f5	8b 4d dc	 mov	 ecx, DWORD PTR tv482[ebp]
  001f8	05 d4 02 00 00	 add	 eax, 724		; 000002d4H
  001fd	50		 push	 eax
  001fe	e8 00 00 00 00	 call	 ?SetTargetName@TargetData@ioAI@@QAEXABVioHashString@@@Z ; ioAI::TargetData::SetTargetName

; 216  : 					fSearchRange = 200.0f * 200.0f;

  00203	8b 45 d8	 mov	 eax, DWORD PTR _fSearchRange$GSCopy$[ebp]
  00206	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@471c4000
  0020e	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 217  : 
; 218  : 					return true;

  00212	b0 01		 mov	 al, 1
  00214	eb 13		 jmp	 SHORT $LN7@CheckFlee
$LN3@CheckFlee:

; 219  : 				}
; 220  : 				else if( m_fEscapeRange > 0.0f )

  00216	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0021d	76 08		 jbe	 SHORT $LN1@CheckFlee

; 221  : 				{
; 222  : 					// 거리가 멀면 그냥 중지
; 223  : 					m_TargetData.Init();

  0021f	8b 4d dc	 mov	 ecx, DWORD PTR tv482[ebp]
  00222	e8 00 00 00 00	 call	 ?Init@TargetData@ioAI@@QAEXXZ ; ioAI::TargetData::Init
$LN1@CheckFlee:

; 224  : 				}
; 225  : 			}
; 226  : 		}
; 227  : 	}
; 228  : 
; 229  : 	return false;

  00227	32 c0		 xor	 al, al
$LN7@CheckFlee:

; 230  : }

  00229	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0022c	5f		 pop	 edi
  0022d	5e		 pop	 esi
  0022e	33 cd		 xor	 ecx, ebp
  00230	5b		 pop	 ebx
  00231	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00236	c9		 leave
  00237	c2 04 00	 ret	 4
?CheckFlee@ioChampionAI@@IAE_NAAM@Z ENDP		; ioChampionAI::CheckFlee
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@XZ ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::begin
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@XZ PROC ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::begin, COMDAT
; _this$ = ecx

; 786  : 		{	// return iterator for beginning of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 787  : 		return (const_iterator(this->_Myfirst, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 788  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@XZ ENDP ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@XZ ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::end
; Function compile flags: /Ogsp
;	COMDAT ?end@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@XZ PROC ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::end, COMDAT
; _this$ = ecx

; 796  : 		{	// return iterator for end of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 797  : 		return (const_iterator(this->_Mylast, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 798  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@XZ ENDP ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::end
_TEXT	ENDS
PUBLIC	??0?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@std@@QAE@XZ ; std::_List_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> > >::_List_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> > >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@std@@QAE@XZ PROC ; std::_List_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> > >::_List_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> > >, COMDAT
; _this$ = ecx

; 179  : 		{	// construct with null node pointer

  00000	8b c1		 mov	 eax, ecx
  00002	83 20 00	 and	 DWORD PTR [eax], 0

; 180  : 		}

  00005	c3		 ret	 0
??0?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> > >::_List_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> > >
_TEXT	ENDS
PUBLIC	??D?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@std@@QBEABQAVioGameEntity@@XZ ; std::_List_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> > >::operator*
; Function compile flags: /Ogsp
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@std@@QBEABQAVioGameEntity@@XZ
_TEXT	SEGMENT
??D?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@std@@QBEABQAVioGameEntity@@XZ PROC ; std::_List_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> > >::operator*, COMDAT
; _this$ = ecx

; 202  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 203  : 		if (this->_Getcont() == 0
; 204  : 			|| this->_Ptr == 0
; 205  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 206  : 			{	// report error
; 207  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 208  : 			_SCL_SECURE_OUT_OF_RANGE;
; 209  : 			}
; 210  : 
; 211  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 212  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 213  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 214  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 215  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 216  : 
; 217  : 		return (_Mylist::_Myval(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 218  : 		}

  00005	c3		 ret	 0
??D?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@std@@QBEABQAVioGameEntity@@XZ ENDP ; std::_List_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> > >::operator++
; Function compile flags: /Ogsp
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> > >::operator++, COMDAT
; _this$ = ecx

; 221  : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 222  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 223  : 		if (this->_Getcont() == 0
; 224  : 			|| this->_Ptr == 0
; 225  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 226  : 			{	// report error
; 227  : 			_DEBUG_ERROR("list iterator not incrementable");
; 228  : 			_SCL_SECURE_OUT_OF_RANGE;
; 229  : 			}
; 230  : 
; 231  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 232  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 233  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 234  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 235  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 236  : 
; 237  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 238  : 		return (*this);
; 239  : 		}

  00008	c3		 ret	 0
??E?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> > >::operator++
_TEXT	ENDS
PUBLIC	??9?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> > >::operator!=
; Function compile flags: /Ogsp
;	COMDAT ??9?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> > >::operator!=, COMDAT
; _this$ = ecx

; 299  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 300  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 301  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> > >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator==
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	f7 d8		 neg	 eax
  0000c	1b c0		 sbb	 eax, eax
  0000e	40		 inc	 eax

; 204  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator==
_TEXT	ENDS
PUBLIC	??0?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@1@PBV?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> > >::_List_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> > >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@1@PBV?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@1@PBV?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> > >::_List_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> > >, COMDAT
; _this$ = ecx

; 184  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 185  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@1@PBV?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> > >::_List_const_iterator<std::_List_val<ioGameEntity *,std::allocator<ioGameEntity *> > >
_TEXT	ENDS
PUBLIC	?begin@?$list@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@2@XZ ; std::list<ioGameEntity *,std::allocator<ioGameEntity *> >::begin
; Function compile flags: /Ogsp
;	COMDAT ?begin@?$list@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@2@XZ PROC ; std::list<ioGameEntity *,std::allocator<ioGameEntity *> >::begin, COMDAT
; _this$ = ecx

; 786  : 		{	// return iterator for beginning of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 787  : 		return (const_iterator(this->_Nextnode(this->_Myhead), this));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 788  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?begin@?$list@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@2@XZ ENDP ; std::list<ioGameEntity *,std::allocator<ioGameEntity *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$list@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@2@XZ ; std::list<ioGameEntity *,std::allocator<ioGameEntity *> >::end
; Function compile flags: /Ogsp
;	COMDAT ?end@?$list@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@2@XZ PROC ; std::list<ioGameEntity *,std::allocator<ioGameEntity *> >::end, COMDAT
; _this$ = ecx

; 796  : 		{	// return iterator for end of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 797  : 		return (const_iterator(this->_Myhead, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 798  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?end@?$list@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@PAVioGameEntity@@V?$allocator@PAVioGameEntity@@@std@@@std@@@2@XZ ENDP ; std::list<ioGameEntity *,std::allocator<ioGameEntity *> >::end
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator!=
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 209  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator!=
_TEXT	ENDS
PUBLIC	?CheckWaypointObstacles@ioChampionAI@@IAE_NAAM@Z ; ioChampionAI::CheckWaypointObstacles
EXTRN	?IsTargetIgnoreState@ioAI@@QAE_NPAVioBaseChar@@_N@Z:PROC ; ioAI::IsTargetIgnoreState
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iochampionai_legacy.cpp
;	COMDAT ?CheckWaypointObstacles@ioChampionAI@@IAE_NAAM@Z
_TEXT	SEGMENT
tv353 = -28						; size = 4
$T549658 = -28						; size = 4
_fAngle1$546379 = -28					; size = 4
_fAngle2$546380 = -24					; size = 4
_rkTargetList$546270 = -20				; size = 4
_fDistSq$546377 = -16					; size = 4
_iter$546353 = -12					; size = 4
_pChar$546375 = -8					; size = 4
_bRet$ = -1						; size = 1
_fSearchRange$ = 8					; size = 4
?CheckWaypointObstacles@ioChampionAI@@IAE_NAAM@Z PROC	; ioChampionAI::CheckWaypointObstacles, COMDAT
; _this$ = ecx

; 51   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx

; 52   : 	bool	bRet = false;
; 53   : 
; 54   : 	if( m_TargetData.GetTargetType() == TARGET_WAYPOINT )

  00009	83 bb b4 00 00
	00 05		 cmp	 DWORD PTR [ebx+180], 5
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	c6 45 ff 00	 mov	 BYTE PTR _bRet$[ebp], 0
  00016	0f 85 3c 01 00
	00		 jne	 $LN4@CheckWaypo

; 55   : 	{
; 56   : 		const BaseCharList &rkTargetList = m_pPlayStage->GetBaseCharList();

  0001c	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]
  0001f	83 c6 2c	 add	 esi, 44			; 0000002cH

; 57   : 		for( BaseCharList::const_iterator iter = rkTargetList.begin(); iter != rkTargetList.end(); ++iter )

  00022	8b 3e		 mov	 edi, DWORD PTR [esi]
  00024	89 75 ec	 mov	 DWORD PTR _rkTargetList$546270[ebp], esi
  00027	e9 20 01 00 00	 jmp	 $LN49@CheckWaypo
$LL20@CheckWaypo:

; 58   : 		{				
; 59   : 			ioBaseChar *pChar = (*iter);

  0002c	8b 07		 mov	 eax, DWORD PTR [edi]

; 60   : 			if( IsTargetIgnoreState( pChar ) ) continue;

  0002e	6a 01		 push	 1
  00030	50		 push	 eax
  00031	8b cb		 mov	 ecx, ebx
  00033	89 45 f8	 mov	 DWORD PTR _pChar$546375[ebp], eax
  00036	e8 00 00 00 00	 call	 ?IsTargetIgnoreState@ioAI@@QAE_NPAVioBaseChar@@_N@Z ; ioAI::IsTargetIgnoreState
  0003b	84 c0		 test	 al, al
  0003d	0f 85 06 01 00
	00		 jne	 $LN5@CheckWaypo

; 61   : 
; 62   : 			float fDistSq = GetTargetRange( pChar->GetWorldPosition() );

  00043	8b 4d f8	 mov	 ecx, DWORD PTR _pChar$546375[ebp]
  00046	8b 01		 mov	 eax, DWORD PTR [ecx]
  00048	ff 50 70	 call	 DWORD PTR [eax+112]
  0004b	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0004e	8b f0		 mov	 esi, eax
  00050	8b fc		 mov	 edi, esp
  00052	a5		 movsd
  00053	a5		 movsd
  00054	8b cb		 mov	 ecx, ebx
  00056	a5		 movsd
  00057	e8 00 00 00 00	 call	 ?GetTargetRange@ioAI@@IAEMUD3DXVECTOR3@@@Z ; ioAI::GetTargetRange

; 63   : 			if( fDistSq < fSearchRange )	// Enemy

  0005c	8b 45 08	 mov	 eax, DWORD PTR _fSearchRange$[ebp]
  0005f	d9 5d f0	 fstp	 DWORD PTR _fDistSq$546377[ebp]
  00062	d9 45 f0	 fld	 DWORD PTR _fDistSq$546377[ebp]
  00065	d9 00		 fld	 DWORD PTR [eax]
  00067	df f1		 fcomip	 ST(1)
  00069	dd d8		 fstp	 ST(0)
  0006b	0f 86 d2 00 00
	00		 jbe	 $LN48@CheckWaypo

; 64   : 			{
; 65   : 				float fAngle1   = GetAngle( m_TargetData.GetTargetPos(), m_pCreator->GetWorldPosition() );

  00071	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00074	8b 01		 mov	 eax, DWORD PTR [ecx]
  00076	ff 50 70	 call	 DWORD PTR [eax+112]
  00079	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0007c	8b fc		 mov	 edi, esp
  0007e	8b f0		 mov	 esi, eax
  00080	a5		 movsd
  00081	a5		 movsd
  00082	a5		 movsd
  00083	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00086	8b fc		 mov	 edi, esp
  00088	8d b3 c8 00 00
	00		 lea	 esi, DWORD PTR [ebx+200]
  0008e	a5		 movsd
  0008f	a5		 movsd
  00090	8b cb		 mov	 ecx, ebx
  00092	a5		 movsd
  00093	e8 00 00 00 00	 call	 ?GetAngle@ioAI@@QAEMUD3DXVECTOR3@@0@Z ; ioAI::GetAngle

; 66   : 				float fAngle2   = GetAngle( pChar->GetWorldPosition(), m_pCreator->GetWorldPosition() );

  00098	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0009b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009d	d9 5d e4	 fstp	 DWORD PTR _fAngle1$546379[ebp]
  000a0	ff 50 70	 call	 DWORD PTR [eax+112]
  000a3	8b 4d f8	 mov	 ecx, DWORD PTR _pChar$546375[ebp]
  000a6	8b f0		 mov	 esi, eax
  000a8	8b 01		 mov	 eax, DWORD PTR [ecx]
  000aa	ff 50 70	 call	 DWORD PTR [eax+112]
  000ad	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000b0	8b fc		 mov	 edi, esp
  000b2	a5		 movsd
  000b3	a5		 movsd
  000b4	a5		 movsd
  000b5	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000b8	8b f0		 mov	 esi, eax
  000ba	8b fc		 mov	 edi, esp
  000bc	a5		 movsd
  000bd	a5		 movsd
  000be	8b cb		 mov	 ecx, ebx
  000c0	a5		 movsd
  000c1	e8 00 00 00 00	 call	 ?GetAngle@ioAI@@QAEMUD3DXVECTOR3@@0@Z ; ioAI::GetAngle

; 67   : 				float fGapAngle = fabs( ioMath::AngleGap( fAngle1, fAngle2 ) );

  000c6	51		 push	 ecx
  000c7	d9 5d e8	 fstp	 DWORD PTR _fAngle2$546380[ebp]
  000ca	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _fAngle2$546380[ebp]
  000cf	51		 push	 ecx
  000d0	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000d6	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _fAngle1$546379[ebp]
  000db	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?AngleGap@ioMath@@SAMMM@Z
  000e6	d9 5d e4	 fstp	 DWORD PTR $T549658[ebp]

; 68   : 				if( fGapAngle <= m_fObjectSearchAngle )

  000e9	d9 45 e4	 fld	 DWORD PTR $T549658[ebp]
  000ec	59		 pop	 ecx
  000ed	d9 e1		 fabs
  000ef	59		 pop	 ecx
  000f0	d9 5d e4	 fstp	 DWORD PTR tv353[ebp]
  000f3	d9 45 e4	 fld	 DWORD PTR tv353[ebp]
  000f6	d9 43 30	 fld	 DWORD PTR [ebx+48]
  000f9	df f1		 fcomip	 ST(1)
  000fb	dd d8		 fstp	 ST(0)
  000fd	72 44		 jb	 SHORT $LN48@CheckWaypo

; 69   : 				{
; 70   : 					fSearchRange = fDistSq;

  000ff	8b 45 08	 mov	 eax, DWORD PTR _fSearchRange$[ebp]
  00102	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _fDistSq$546377[ebp]

; 71   : 					m_TargetData.SetTargetName( pChar->GetCharName() );

  00107	8b 75 f8	 mov	 esi, DWORD PTR _pChar$546375[ebp]
  0010a	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  0010e	8d 86 d4 02 00
	00		 lea	 eax, DWORD PTR [esi+724]
  00114	50		 push	 eax
  00115	8d 8b b4 00 00
	00		 lea	 ecx, DWORD PTR [ebx+180]
  0011b	e8 00 00 00 00	 call	 ?SetTargetName@TargetData@ioAI@@QAEXABVioHashString@@@Z ; ioAI::TargetData::SetTargetName

; 72   : 					m_TargetData.SetTargetPos( pChar->GetWorldPosition() );

  00120	8b 06		 mov	 eax, DWORD PTR [esi]
  00122	8b ce		 mov	 ecx, esi
  00124	ff 50 70	 call	 DWORD PTR [eax+112]
  00127	8b f0		 mov	 esi, eax
  00129	8d bb c8 00 00
	00		 lea	 edi, DWORD PTR [ebx+200]
  0012f	a5		 movsd
  00130	a5		 movsd

; 73   : 					m_TargetData.SetTargetType( TARGET_BASECHAR );

  00131	6a 01		 push	 1
  00133	8d 8b b4 00 00
	00		 lea	 ecx, DWORD PTR [ebx+180]
  00139	a5		 movsd
  0013a	e8 00 00 00 00	 call	 ?SetTargetType@TargetData@ioAI@@QAEXW4TargetType@2@@Z ; ioAI::TargetData::SetTargetType

; 74   : 
; 75   : 					bRet = true;

  0013f	c6 45 ff 01	 mov	 BYTE PTR _bRet$[ebp], 1
$LN48@CheckWaypo:
  00143	8b 7d f4	 mov	 edi, DWORD PTR _iter$546353[ebp]
  00146	8b 75 ec	 mov	 esi, DWORD PTR _rkTargetList$546270[ebp]
$LN5@CheckWaypo:

; 57   : 		for( BaseCharList::const_iterator iter = rkTargetList.begin(); iter != rkTargetList.end(); ++iter )

  00149	83 c7 04	 add	 edi, 4
$LN49@CheckWaypo:
  0014c	89 7d f4	 mov	 DWORD PTR _iter$546353[ebp], edi
  0014f	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00152	0f 85 d4 fe ff
	ff		 jne	 $LL20@CheckWaypo
$LN4@CheckWaypo:

; 76   : 				}					
; 77   : 			}
; 78   : 		}
; 79   : 	}
; 80   : 
; 81   : 	return bRet;

  00158	8a 45 ff	 mov	 al, BYTE PTR _bRet$[ebp]

; 82   : }

  0015b	5f		 pop	 edi
  0015c	5e		 pop	 esi
  0015d	5b		 pop	 ebx
  0015e	c9		 leave
  0015f	c2 04 00	 ret	 4
?CheckWaypointObstacles@ioChampionAI@@IAE_NAAM@Z ENDP	; ioChampionAI::CheckWaypointObstacles
_TEXT	ENDS
PUBLIC	?CheckTargetObstacles@ioChampionAI@@IAE_NAAM@Z	; ioChampionAI::CheckTargetObstacles
; Function compile flags: /Ogsp
;	COMDAT ?CheckTargetObstacles@ioChampionAI@@IAE_NAAM@Z
_TEXT	SEGMENT
_rkObjectList$ = -20					; size = 4
tv400 = -16						; size = 4
$T549785 = -16						; size = 4
_fAngle1$546517 = -16					; size = 4
_fAngle2$546518 = -12					; size = 4
_fDistSq$546515 = -12					; size = 4
_pPush$546511 = -8					; size = 4
_iter$ = -4						; size = 4
_fSearchRange$ = 8					; size = 4
?CheckTargetObstacles@ioChampionAI@@IAE_NAAM@Z PROC	; ioChampionAI::CheckTargetObstacles, COMDAT
; _this$ = ecx

; 85   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b d9		 mov	 ebx, ecx

; 86   : 	const GameEntityList &rkObjectList = m_pPlayStage->GetGameEntityList();

  0000a	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]
  0000d	83 c6 08	 add	 esi, 8

; 87   : 	GameEntityList::const_iterator iter;
; 88   : 	for( iter = rkObjectList.begin() ; iter!=rkObjectList.end() ; ++iter )

  00010	8b 06		 mov	 eax, DWORD PTR [esi]
  00012	57		 push	 edi
  00013	8b 38		 mov	 edi, DWORD PTR [eax]
  00015	89 75 ec	 mov	 DWORD PTR _rkObjectList$[ebp], esi
  00018	89 7d fc	 mov	 DWORD PTR _iter$[ebp], edi
  0001b	3b f8		 cmp	 edi, eax
  0001d	75 0c		 jne	 SHORT $LN27@CheckTarge
$LN6@CheckTarge:

; 107  : 			}
; 108  : 		}
; 109  : 	}
; 110  : 
; 111  : 	return false;

  0001f	32 c0		 xor	 al, al
$LN9@CheckTarge:

; 112  : }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	c9		 leave
  00025	c2 04 00	 ret	 4
$LL62@CheckTarge:

; 87   : 	GameEntityList::const_iterator iter;
; 88   : 	for( iter = rkObjectList.begin() ; iter!=rkObjectList.end() ; ++iter )

  00028	8b 7d fc	 mov	 edi, DWORD PTR _iter$[ebp]
$LN27@CheckTarge:

; 89   : 	{
; 90   : 		ioPushStruct *pPush = ToPushStruct( *iter );

  0002b	ff 77 08	 push	 DWORD PTR [edi+8]
  0002e	e8 00 00 00 00	 call	 ?ToPushStruct@@YAPAVioPushStruct@@PAVioGameEntity@@@Z ; ToPushStruct
  00033	59		 pop	 ecx
  00034	89 45 f8	 mov	 DWORD PTR _pPush$546511[ebp], eax

; 91   : 		if( !pPush ) continue;

  00037	85 c0		 test	 eax, eax
  00039	0f 84 df 00 00
	00		 je	 $LN7@CheckTarge

; 92   : 		if( !pPush->GetGroup()->IsVisible() ) continue;		

  0003f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00042	8b 01		 mov	 eax, DWORD PTR [ecx]
  00044	ff 50 0c	 call	 DWORD PTR [eax+12]
  00047	84 c0		 test	 al, al
  00049	0f 84 cf 00 00
	00		 je	 $LN7@CheckTarge

; 93   : 		if( pPush->IsEnableClick() ) continue;

  0004f	8b 4d f8	 mov	 ecx, DWORD PTR _pPush$546511[ebp]
  00052	80 b9 c8 03 00
	00 00		 cmp	 BYTE PTR [ecx+968], 0
  00059	0f 85 bf 00 00
	00		 jne	 $LN7@CheckTarge

; 94   : 
; 95   : 		float fDistSq = GetTargetRange( pPush->GetWorldPosition() );

  0005f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00061	ff 50 70	 call	 DWORD PTR [eax+112]
  00064	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00067	8b f0		 mov	 esi, eax
  00069	8b fc		 mov	 edi, esp
  0006b	a5		 movsd
  0006c	a5		 movsd
  0006d	8b cb		 mov	 ecx, ebx
  0006f	a5		 movsd
  00070	e8 00 00 00 00	 call	 ?GetTargetRange@ioAI@@IAEMUD3DXVECTOR3@@@Z ; ioAI::GetTargetRange

; 96   : 		if( fDistSq < fSearchRange )	

  00075	8b 45 08	 mov	 eax, DWORD PTR _fSearchRange$[ebp]
  00078	d9 5d f4	 fstp	 DWORD PTR _fDistSq$546515[ebp]
  0007b	d9 45 f4	 fld	 DWORD PTR _fDistSq$546515[ebp]
  0007e	d9 00		 fld	 DWORD PTR [eax]
  00080	df f1		 fcomip	 ST(1)
  00082	dd d8		 fstp	 ST(0)
  00084	0f 86 8e 00 00
	00		 jbe	 $LN63@CheckTarge

; 97   : 		{
; 98   : 			float fAngle1   = GetAngle( m_TargetData.GetTargetPos(), m_pCreator->GetWorldPosition() );

  0008a	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0008d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0008f	ff 50 70	 call	 DWORD PTR [eax+112]
  00092	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00095	8b fc		 mov	 edi, esp
  00097	8b f0		 mov	 esi, eax
  00099	a5		 movsd
  0009a	a5		 movsd
  0009b	a5		 movsd
  0009c	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0009f	8b fc		 mov	 edi, esp
  000a1	8d b3 c8 00 00
	00		 lea	 esi, DWORD PTR [ebx+200]
  000a7	a5		 movsd
  000a8	a5		 movsd
  000a9	8b cb		 mov	 ecx, ebx
  000ab	a5		 movsd
  000ac	e8 00 00 00 00	 call	 ?GetAngle@ioAI@@QAEMUD3DXVECTOR3@@0@Z ; ioAI::GetAngle

; 99   : 			float fAngle2   = GetAngle( pPush->GetWorldPosition(), m_pCreator->GetWorldPosition() );

  000b1	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  000b4	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b6	d9 5d f0	 fstp	 DWORD PTR _fAngle1$546517[ebp]
  000b9	ff 50 70	 call	 DWORD PTR [eax+112]
  000bc	8b 4d f8	 mov	 ecx, DWORD PTR _pPush$546511[ebp]
  000bf	8b f0		 mov	 esi, eax
  000c1	8b 01		 mov	 eax, DWORD PTR [ecx]
  000c3	ff 50 70	 call	 DWORD PTR [eax+112]
  000c6	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000c9	8b fc		 mov	 edi, esp
  000cb	a5		 movsd
  000cc	a5		 movsd
  000cd	a5		 movsd
  000ce	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000d1	8b f0		 mov	 esi, eax
  000d3	8b fc		 mov	 edi, esp
  000d5	a5		 movsd
  000d6	a5		 movsd
  000d7	8b cb		 mov	 ecx, ebx
  000d9	a5		 movsd
  000da	e8 00 00 00 00	 call	 ?GetAngle@ioAI@@QAEMUD3DXVECTOR3@@0@Z ; ioAI::GetAngle

; 100  : 			float fGapAngle = fabs( ioMath::AngleGap( fAngle1, fAngle2 ) );

  000df	51		 push	 ecx
  000e0	d9 5d f4	 fstp	 DWORD PTR _fAngle2$546518[ebp]
  000e3	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _fAngle2$546518[ebp]
  000e8	51		 push	 ecx
  000e9	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000ef	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _fAngle1$546517[ebp]
  000f4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?AngleGap@ioMath@@SAMMM@Z
  000ff	d9 5d f0	 fstp	 DWORD PTR $T549785[ebp]

; 101  : 			if( fGapAngle <= m_fObjectSearchAngle )

  00102	d9 45 f0	 fld	 DWORD PTR $T549785[ebp]
  00105	59		 pop	 ecx
  00106	d9 e1		 fabs
  00108	59		 pop	 ecx
  00109	d9 5d f0	 fstp	 DWORD PTR tv400[ebp]
  0010c	d9 45 f0	 fld	 DWORD PTR tv400[ebp]
  0010f	d9 43 30	 fld	 DWORD PTR [ebx+48]
  00112	df f1		 fcomip	 ST(1)
  00114	dd d8		 fstp	 ST(0)
  00116	73 18		 jae	 SHORT $LN60@CheckTarge
$LN63@CheckTarge:
  00118	8b 75 ec	 mov	 esi, DWORD PTR _rkObjectList$[ebp]
  0011b	8b 7d fc	 mov	 edi, DWORD PTR _iter$[ebp]
$LN7@CheckTarge:

; 87   : 	GameEntityList::const_iterator iter;
; 88   : 	for( iter = rkObjectList.begin() ; iter!=rkObjectList.end() ; ++iter )

  0011e	8b 3f		 mov	 edi, DWORD PTR [edi]
  00120	89 7d fc	 mov	 DWORD PTR _iter$[ebp], edi
  00123	3b 3e		 cmp	 edi, DWORD PTR [esi]
  00125	0f 85 fd fe ff
	ff		 jne	 $LL62@CheckTarge

; 101  : 			if( fGapAngle <= m_fObjectSearchAngle )

  0012b	e9 ef fe ff ff	 jmp	 $LN6@CheckTarge
$LN60@CheckTarge:

; 102  : 			{
; 103  : 				m_TargetData.SetTargetPos( pPush->GetWorldPosition() );

  00130	8b 4d f8	 mov	 ecx, DWORD PTR _pPush$546511[ebp]
  00133	8b 01		 mov	 eax, DWORD PTR [ecx]
  00135	ff 50 70	 call	 DWORD PTR [eax+112]
  00138	8b f0		 mov	 esi, eax
  0013a	8d bb c8 00 00
	00		 lea	 edi, DWORD PTR [ebx+200]
  00140	a5		 movsd
  00141	a5		 movsd

; 104  : 				m_TargetData.SetTargetType( TARGET_OBJECT );

  00142	6a 02		 push	 2
  00144	8d 8b b4 00 00
	00		 lea	 ecx, DWORD PTR [ebx+180]
  0014a	a5		 movsd
  0014b	e8 00 00 00 00	 call	 ?SetTargetType@TargetData@ioAI@@QAEXW4TargetType@2@@Z ; ioAI::TargetData::SetTargetType

; 105  : 
; 106  : 				return true;

  00150	b0 01		 mov	 al, 1
  00152	e9 ca fe ff ff	 jmp	 $LN9@CheckTarge
?CheckTargetObstacles@ioChampionAI@@IAE_NAAM@Z ENDP	; ioChampionAI::CheckTargetObstacles
_TEXT	ENDS
PUBLIC	?CheckTargetMonsterBlocking@ioChampionAI@@IAE_NAAM@Z ; ioChampionAI::CheckTargetMonsterBlocking
; Function compile flags: /Ogsp
;	COMDAT ?CheckTargetMonsterBlocking@ioChampionAI@@IAE_NAAM@Z
_TEXT	SEGMENT
tv251 = -8						; size = 4
_this$ = -4						; size = 4
_fSearchRange$ = 8					; size = 4
?CheckTargetMonsterBlocking@ioChampionAI@@IAE_NAAM@Z PROC ; ioChampionAI::CheckTargetMonsterBlocking, COMDAT
; _this$ = ecx

; 156  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 157  : 	if( fSearchRange > FLOAT1 ) 

  0000b	b8 01 00 00 00	 mov	 eax, 1
  00010	8b 55 08	 mov	 edx, DWORD PTR _fSearchRange$[ebp]
  00013	d9 02		 fld	 DWORD PTR [edx]
  00015	89 45 f8	 mov	 DWORD PTR tv251[ebp], eax
  00018	db 45 f8	 fild	 DWORD PTR tv251[ebp]
  0001b	85 c0		 test	 eax, eax
  0001d	79 06		 jns	 SHORT $LN41@CheckTarge@2
  0001f	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN41@CheckTarge@2:
  00025	d9 c9		 fxch	 ST(1)
  00027	df f1		 fcomip	 ST(1)
  00029	dd d8		 fstp	 ST(0)
  0002b	76 31		 jbe	 SHORT $LN4@CheckTarge@2

; 158  : 	{
; 159  : 		const BaseCharList &rkTargetList = m_pPlayStage->GetBaseCharList();

  0002d	8b 71 0c	 mov	 esi, DWORD PTR [ecx+12]

; 160  : 		BaseCharList::const_iterator iter;
; 161  : 		for( iter = rkTargetList.begin(); iter != rkTargetList.end(); ++iter )

  00030	8b 7e 2c	 mov	 edi, DWORD PTR [esi+44]
  00033	eb 24		 jmp	 SHORT $LN42@CheckTarge@2
$LL22@CheckTarge@2:

; 162  : 		{
; 163  : 			ioBaseChar *pChar = (*iter);

  00035	8b 1f		 mov	 ebx, DWORD PTR [edi]

; 164  : 			
; 165  : 			if( !pChar ) continue;

  00037	85 db		 test	 ebx, ebx
  00039	74 1b		 je	 SHORT $LN5@CheckTarge@2

; 166  : 			if( !ToNpcChar( pChar ) ) continue;

  0003b	53		 push	 ebx
  0003c	e8 00 00 00 00	 call	 ?ToNpcChar@@YAPAVioNpcChar@@PAVioGameEntity@@@Z ; ToNpcChar
  00041	59		 pop	 ecx
  00042	85 c0		 test	 eax, eax
  00044	74 10		 je	 SHORT $LN5@CheckTarge@2

; 167  : 
; 168  : 			if( IsNPCBlocking( pChar, fSearchRange ) )

  00046	ff 75 08	 push	 DWORD PTR _fSearchRange$[ebp]
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	53		 push	 ebx
  0004d	e8 00 00 00 00	 call	 ?IsNPCBlocking@ioChampionAI@@IAE_NPAVioBaseChar@@AAM@Z ; ioChampionAI::IsNPCBlocking
  00052	84 c0		 test	 al, al
  00054	75 11		 jne	 SHORT $LN39@CheckTarge@2
$LN5@CheckTarge@2:

; 160  : 		BaseCharList::const_iterator iter;
; 161  : 		for( iter = rkTargetList.begin(); iter != rkTargetList.end(); ++iter )

  00056	83 c7 04	 add	 edi, 4
$LN42@CheckTarge@2:
  00059	3b 7e 30	 cmp	 edi, DWORD PTR [esi+48]
  0005c	75 d7		 jne	 SHORT $LL22@CheckTarge@2
$LN4@CheckTarge@2:

; 170  : 		}
; 171  : 	}
; 172  : 
; 173  : 	return false;

  0005e	32 c0		 xor	 al, al
$LN8@CheckTarge@2:
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx

; 174  : }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
$LN39@CheckTarge@2:

; 169  : 				return true;

  00067	b0 01		 mov	 al, 1
  00069	eb f5		 jmp	 SHORT $LN8@CheckTarge@2
?CheckTargetMonsterBlocking@ioChampionAI@@IAE_NAAM@Z ENDP ; ioChampionAI::CheckTargetMonsterBlocking
_TEXT	ENDS
PUBLIC	?CheckTargetBlocking@ioChampionAI@@IAE_NAAM@Z	; ioChampionAI::CheckTargetBlocking
; Function compile flags: /Ogsp
;	COMDAT ?CheckTargetBlocking@ioChampionAI@@IAE_NAAM@Z
_TEXT	SEGMENT
_rkObjectList$550034 = -20				; size = 4
tv400 = -16						; size = 4
$T549986 = -16						; size = 4
_fAngle1$550045 = -16					; size = 4
_fAngle2$550046 = -12					; size = 4
_fDistSq$550043 = -12					; size = 4
_pPush$550039 = -8					; size = 4
_iter$550035 = -4					; size = 4
_fSearchRange$ = 8					; size = 4
?CheckTargetBlocking@ioChampionAI@@IAE_NAAM@Z PROC	; ioChampionAI::CheckTargetBlocking, COMDAT
; _this$ = ecx

; 177  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b d9		 mov	 ebx, ecx
  0000a	57		 push	 edi

; 178  : 	// 타겟 선택 후 처리
; 179  : 	if( !m_TargetData.GetTargetName().IsEmpty() )

  0000b	8d 8b b8 00 00
	00		 lea	 ecx, DWORD PTR [ebx+184]
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00017	84 c0		 test	 al, al
  00019	0f 85 53 01 00
	00		 jne	 $LN1@CheckTarge@3

; 180  : 	{
; 181  : 		// 웨이 포인트 사이에 오브젝트가 있는지 검색
; 182  : 		CheckWaypointObstacles( fSearchRange );

  0001f	ff 75 08	 push	 DWORD PTR _fSearchRange$[ebp]
  00022	8b cb		 mov	 ecx, ebx
  00024	e8 00 00 00 00	 call	 ?CheckWaypointObstacles@ioChampionAI@@IAE_NAAM@Z ; ioChampionAI::CheckWaypointObstacles

; 183  : 
; 184  : 		// 타겟 사이에 오브젝트가 있는지 검색
; 185  : 		CheckTargetObstacles( fSearchRange );

  00029	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]
  0002c	83 c6 08	 add	 esi, 8
  0002f	8b 06		 mov	 eax, DWORD PTR [esi]
  00031	8b 38		 mov	 edi, DWORD PTR [eax]
  00033	89 75 ec	 mov	 DWORD PTR _rkObjectList$550034[ebp], esi
  00036	89 7d fc	 mov	 DWORD PTR _iter$550035[ebp], edi
  00039	3b f8		 cmp	 edi, eax
  0003b	0f 84 27 01 00
	00		 je	 $LN11@CheckTarge@3
  00041	eb 03		 jmp	 SHORT $LN32@CheckTarge@3
$LL67@CheckTarge@3:
  00043	8b 7d fc	 mov	 edi, DWORD PTR _iter$550035[ebp]
$LN32@CheckTarge@3:
  00046	ff 77 08	 push	 DWORD PTR [edi+8]
  00049	e8 00 00 00 00	 call	 ?ToPushStruct@@YAPAVioPushStruct@@PAVioGameEntity@@@Z ; ToPushStruct
  0004e	59		 pop	 ecx
  0004f	89 45 f8	 mov	 DWORD PTR _pPush$550039[ebp], eax
  00052	85 c0		 test	 eax, eax
  00054	0f 84 df 00 00
	00		 je	 $LN12@CheckTarge@3
  0005a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005f	ff 50 0c	 call	 DWORD PTR [eax+12]
  00062	84 c0		 test	 al, al
  00064	0f 84 cf 00 00
	00		 je	 $LN12@CheckTarge@3
  0006a	8b 4d f8	 mov	 ecx, DWORD PTR _pPush$550039[ebp]
  0006d	80 b9 c8 03 00
	00 00		 cmp	 BYTE PTR [ecx+968], 0
  00074	0f 85 bf 00 00
	00		 jne	 $LN12@CheckTarge@3
  0007a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0007c	ff 50 70	 call	 DWORD PTR [eax+112]
  0007f	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00082	8b f0		 mov	 esi, eax
  00084	8b fc		 mov	 edi, esp
  00086	a5		 movsd
  00087	a5		 movsd
  00088	8b cb		 mov	 ecx, ebx
  0008a	a5		 movsd
  0008b	e8 00 00 00 00	 call	 ?GetTargetRange@ioAI@@IAEMUD3DXVECTOR3@@@Z ; ioAI::GetTargetRange
  00090	8b 45 08	 mov	 eax, DWORD PTR _fSearchRange$[ebp]
  00093	d9 5d f4	 fstp	 DWORD PTR _fDistSq$550043[ebp]
  00096	d9 45 f4	 fld	 DWORD PTR _fDistSq$550043[ebp]
  00099	d9 00		 fld	 DWORD PTR [eax]
  0009b	df f1		 fcomip	 ST(1)
  0009d	dd d8		 fstp	 ST(0)
  0009f	0f 86 8e 00 00
	00		 jbe	 $LN68@CheckTarge@3
  000a5	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  000a8	8b 01		 mov	 eax, DWORD PTR [ecx]
  000aa	ff 50 70	 call	 DWORD PTR [eax+112]
  000ad	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000b0	8b fc		 mov	 edi, esp
  000b2	8b f0		 mov	 esi, eax
  000b4	a5		 movsd
  000b5	a5		 movsd
  000b6	a5		 movsd
  000b7	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000ba	8b fc		 mov	 edi, esp
  000bc	8d b3 c8 00 00
	00		 lea	 esi, DWORD PTR [ebx+200]
  000c2	a5		 movsd
  000c3	a5		 movsd
  000c4	8b cb		 mov	 ecx, ebx
  000c6	a5		 movsd
  000c7	e8 00 00 00 00	 call	 ?GetAngle@ioAI@@QAEMUD3DXVECTOR3@@0@Z ; ioAI::GetAngle
  000cc	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  000cf	8b 01		 mov	 eax, DWORD PTR [ecx]
  000d1	d9 5d f0	 fstp	 DWORD PTR _fAngle1$550045[ebp]
  000d4	ff 50 70	 call	 DWORD PTR [eax+112]
  000d7	8b 4d f8	 mov	 ecx, DWORD PTR _pPush$550039[ebp]
  000da	8b f0		 mov	 esi, eax
  000dc	8b 01		 mov	 eax, DWORD PTR [ecx]
  000de	ff 50 70	 call	 DWORD PTR [eax+112]
  000e1	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000e4	8b fc		 mov	 edi, esp
  000e6	a5		 movsd
  000e7	a5		 movsd
  000e8	a5		 movsd
  000e9	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000ec	8b f0		 mov	 esi, eax
  000ee	8b fc		 mov	 edi, esp
  000f0	a5		 movsd
  000f1	a5		 movsd
  000f2	8b cb		 mov	 ecx, ebx
  000f4	a5		 movsd
  000f5	e8 00 00 00 00	 call	 ?GetAngle@ioAI@@QAEMUD3DXVECTOR3@@0@Z ; ioAI::GetAngle
  000fa	51		 push	 ecx
  000fb	d9 5d f4	 fstp	 DWORD PTR _fAngle2$550046[ebp]
  000fe	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _fAngle2$550046[ebp]
  00103	51		 push	 ecx
  00104	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0010a	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _fAngle1$550045[ebp]
  0010f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00114	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?AngleGap@ioMath@@SAMMM@Z
  0011a	d9 5d f0	 fstp	 DWORD PTR $T549986[ebp]
  0011d	d9 45 f0	 fld	 DWORD PTR $T549986[ebp]
  00120	59		 pop	 ecx
  00121	d9 e1		 fabs
  00123	59		 pop	 ecx
  00124	d9 5d f0	 fstp	 DWORD PTR tv400[ebp]
  00127	d9 45 f0	 fld	 DWORD PTR tv400[ebp]
  0012a	d9 43 30	 fld	 DWORD PTR [ebx+48]
  0012d	df f1		 fcomip	 ST(1)
  0012f	dd d8		 fstp	 ST(0)
  00131	73 15		 jae	 SHORT $LN65@CheckTarge@3
$LN68@CheckTarge@3:
  00133	8b 75 ec	 mov	 esi, DWORD PTR _rkObjectList$550034[ebp]
  00136	8b 7d fc	 mov	 edi, DWORD PTR _iter$550035[ebp]
$LN12@CheckTarge@3:
  00139	8b 3f		 mov	 edi, DWORD PTR [edi]
  0013b	89 7d fc	 mov	 DWORD PTR _iter$550035[ebp], edi
  0013e	3b 3e		 cmp	 edi, DWORD PTR [esi]
  00140	0f 85 fd fe ff
	ff		 jne	 $LL67@CheckTarge@3
  00146	eb 20		 jmp	 SHORT $LN11@CheckTarge@3
$LN65@CheckTarge@3:
  00148	8b 4d f8	 mov	 ecx, DWORD PTR _pPush$550039[ebp]
  0014b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0014d	ff 50 70	 call	 DWORD PTR [eax+112]
  00150	8b f0		 mov	 esi, eax
  00152	8d bb c8 00 00
	00		 lea	 edi, DWORD PTR [ebx+200]
  00158	a5		 movsd
  00159	a5		 movsd
  0015a	6a 02		 push	 2
  0015c	8d 8b b4 00 00
	00		 lea	 ecx, DWORD PTR [ebx+180]
  00162	a5		 movsd
  00163	e8 00 00 00 00	 call	 ?SetTargetType@TargetData@ioAI@@QAEXW4TargetType@2@@Z ; ioAI::TargetData::SetTargetType
$LN11@CheckTarge@3:

; 186  : 
; 187  : 		// 타겟 사이에 몬스터가 있는지 검색
; 188  : 		CheckTargetMonsterBlocking( fSearchRange );

  00168	ff 75 08	 push	 DWORD PTR _fSearchRange$[ebp]
  0016b	8b cb		 mov	 ecx, ebx
  0016d	e8 00 00 00 00	 call	 ?CheckTargetMonsterBlocking@ioChampionAI@@IAE_NAAM@Z ; ioChampionAI::CheckTargetMonsterBlocking
$LN1@CheckTarge@3:

; 189  : 	}
; 190  : 
; 191  : 	return false;
; 192  : }

  00172	5f		 pop	 edi
  00173	5e		 pop	 esi
  00174	32 c0		 xor	 al, al
  00176	5b		 pop	 ebx
  00177	c9		 leave
  00178	c2 04 00	 ret	 4
?CheckTargetBlocking@ioChampionAI@@IAE_NAAM@Z ENDP	; ioChampionAI::CheckTargetBlocking
_TEXT	ENDS
PUBLIC	?FindTargetChar@ioChampionAI@@QAE_NXZ		; ioChampionAI::FindTargetChar
EXTRN	__imp_??1ioHashString@@QAE@XZ:PROC
EXTRN	?FindClosestTarget@ioChampionAI@@QAEPAVioBaseChar@@ABM@Z:PROC ; ioChampionAI::FindClosestTarget
EXTRN	?GetBaseChar@ioBaseChar@@QAEPAV1@ABVioHashString@@@Z:PROC ; ioBaseChar::GetBaseChar
EXTRN	__imp_??0ioHashString@@QAE@XZ:PROC
EXTRN	?CheckWayPoint@ioAI@@IAEXXZ:PROC		; ioAI::CheckWayPoint
EXTRN	?CheckRandomAggroTarget@ioAI@@IAEXXZ:PROC	; ioAI::CheckRandomAggroTarget
EXTRN	?CheckFixingTarget@ioAI@@IAEXXZ:PROC		; ioAI::CheckFixingTarget
EXTRN	?CheckGlobalTarget@ioAI@@IAEXXZ:PROC		; ioAI::CheckGlobalTarget
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__EH_epilog3:PROC
EXTRN	__EH_prolog3:PROC
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioai.h
xdata$x	SEGMENT
__unwindtable$?FindTargetChar@ioChampionAI@@QAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindTargetChar@ioChampionAI@@QAE_NXZ$0
__ehfuncinfo$?FindTargetChar@ioChampionAI@@QAE_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindTargetChar@ioChampionAI@@QAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iochampionai_legacy.cpp
xdata$x	ENDS
;	COMDAT ?FindTargetChar@ioChampionAI@@QAE_NXZ
_TEXT	SEGMENT
_szFirstTarget$546597 = -36				; size = 16
tv292 = -20						; size = 4
_fSearchRange$546595 = -16				; size = 4
__$EHRec$ = -12						; size = 12
?FindTargetChar@ioChampionAI@@QAE_NXZ PROC		; ioChampionAI::FindTargetChar, COMDAT
; _this$ = ecx

; 244  : {

  00000	6a 18		 push	 24			; 00000018H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?FindTargetChar@ioChampionAI@@QAE_NXZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b d9		 mov	 ebx, ecx

; 245  : 	if( CanSearchTimeBeUpdated() )

  0000e	e8 00 00 00 00	 call	 ?CanSearchTimeBeUpdated@ioChampionAI@@IAE_NXZ ; ioChampionAI::CanSearchTimeBeUpdated
  00013	84 c0		 test	 al, al
  00015	0f 84 32 01 00
	00		 je	 $LN7@FindTarget

; 246  : 	{
; 247  : 	    m_fCurSearchTime = FRAMEGETTIME();	

  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  00021	8b c8		 mov	 ecx, eax
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ
  00029	89 45 ec	 mov	 DWORD PTR tv292[ebp], eax
  0002c	db 45 ec	 fild	 DWORD PTR tv292[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	79 06		 jns	 SHORT $LN17@FindTarget
  00033	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN17@FindTarget:

; 248  : 		m_TargetData.Init();

  00039	8d 8b b4 00 00
	00		 lea	 ecx, DWORD PTR [ebx+180]
  0003f	d9 9b a0 00 00
	00		 fstp	 DWORD PTR [ebx+160]
  00045	e8 00 00 00 00	 call	 ?Init@TargetData@ioAI@@QAEXXZ ; ioAI::TargetData::Init

; 249  : 
; 250  : 		CheckGlobalTarget();

  0004a	8b cb		 mov	 ecx, ebx
  0004c	e8 00 00 00 00	 call	 ?CheckGlobalTarget@ioAI@@IAEXXZ ; ioAI::CheckGlobalTarget

; 251  : 		CheckFixingTarget();

  00051	8b cb		 mov	 ecx, ebx
  00053	e8 00 00 00 00	 call	 ?CheckFixingTarget@ioAI@@IAEXXZ ; ioAI::CheckFixingTarget

; 252  : 		CheckRandomAggroTarget();

  00058	8b cb		 mov	 ecx, ebx
  0005a	e8 00 00 00 00	 call	 ?CheckRandomAggroTarget@ioAI@@IAEXXZ ; ioAI::CheckRandomAggroTarget

; 253  : 		CheckWayPoint(); 

  0005f	8b cb		 mov	 ecx, ebx
  00061	e8 00 00 00 00	 call	 ?CheckWayPoint@ioAI@@IAEXXZ ; ioAI::CheckWayPoint

; 254  : 
; 255  : 		float fSearchRange = m_fSearchRangeCurrent * m_fSearchRangeCurrent;	
; 256  : 		if( m_TargetData.GetTargetType() != TARGET_WAYPOINT )

  00066	83 bb b4 00 00
	00 05		 cmp	 DWORD PTR [ebx+180], 5
  0006d	f3 0f 10 43 24	 movss	 xmm0, DWORD PTR [ebx+36]
  00072	0f 5a c0	 cvtps2pd xmm0, xmm0
  00075	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  00079	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0007d	f3 0f 11 45 f0	 movss	 DWORD PTR _fSearchRange$546595[ebp], xmm0
  00082	0f 84 9c 00 00
	00		 je	 $LN6@FindTarget

; 257  : 		{
; 258  : 			ioHashString szFirstTarget;

  00088	8d 4d dc	 lea	 ecx, DWORD PTR _szFirstTarget$546597[ebp]
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ
  00091	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 259  : 		
; 260  : 			if( !SearchFixedTarget( szFirstTarget ) )

  00095	8d 45 dc	 lea	 eax, DWORD PTR _szFirstTarget$546597[ebp]
  00098	50		 push	 eax
  00099	8b cb		 mov	 ecx, ebx
  0009b	e8 00 00 00 00	 call	 ?SearchFixedTarget@ioChampionAI@@IAE_NAAVioHashString@@@Z ; ioChampionAI::SearchFixedTarget
  000a0	84 c0		 test	 al, al
  000a2	75 0b		 jne	 SHORT $LN5@FindTarget

; 261  : 			{
; 262  : 				SearchTargetByDamage( szFirstTarget );

  000a4	8d 45 dc	 lea	 eax, DWORD PTR _szFirstTarget$546597[ebp]
  000a7	50		 push	 eax
  000a8	8b cb		 mov	 ecx, ebx
  000aa	e8 00 00 00 00	 call	 ?SearchTargetByDamage@ioChampionAI@@IAE_NAAVioHashString@@@Z ; ioChampionAI::SearchTargetByDamage
$LN5@FindTarget:

; 263  : 			}
; 264  : 
; 265  : 			ioBaseChar *pFirstTarget = m_pCreator->GetBaseChar( szFirstTarget );

  000af	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  000b2	8d 45 dc	 lea	 eax, DWORD PTR _szFirstTarget$546597[ebp]
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 ?GetBaseChar@ioBaseChar@@QAEPAV1@ABVioHashString@@@Z ; ioBaseChar::GetBaseChar
  000bb	8b f0		 mov	 esi, eax

; 266  : 			if( !IsTargetIgnoreState( pFirstTarget ) )

  000bd	6a 01		 push	 1
  000bf	56		 push	 esi
  000c0	8b cb		 mov	 ecx, ebx
  000c2	e8 00 00 00 00	 call	 ?IsTargetIgnoreState@ioAI@@QAE_NPAVioBaseChar@@_N@Z ; ioAI::IsTargetIgnoreState

; 267  : 			{
; 268  : 				SetAsTarget( pFirstTarget );

  000c7	8b cb		 mov	 ecx, ebx
  000c9	84 c0		 test	 al, al
  000cb	75 23		 jne	 SHORT $LN4@FindTarget
  000cd	56		 push	 esi
  000ce	e8 00 00 00 00	 call	 ?SetAsTarget@ioChampionAI@@AAE_NPAVioBaseChar@@@Z ; ioChampionAI::SetAsTarget

; 269  : 				fSearchRange = GetTargetRange( pFirstTarget->GetWorldPosition() );

  000d3	8b 06		 mov	 eax, DWORD PTR [esi]
  000d5	8b ce		 mov	 ecx, esi
  000d7	ff 50 70	 call	 DWORD PTR [eax+112]
  000da	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000dd	8b f0		 mov	 esi, eax
  000df	8b fc		 mov	 edi, esp
  000e1	a5		 movsd
  000e2	a5		 movsd
  000e3	8b cb		 mov	 ecx, ebx
  000e5	a5		 movsd
  000e6	e8 00 00 00 00	 call	 ?GetTargetRange@ioAI@@IAEMUD3DXVECTOR3@@@Z ; ioAI::GetTargetRange
  000eb	d9 5d f0	 fstp	 DWORD PTR _fSearchRange$546595[ebp]

; 270  : 			}
; 271  : 			else

  000ee	eb 27		 jmp	 SHORT $LN3@FindTarget
$LN4@FindTarget:

; 272  : 			{
; 273  : 				if( IsOffensive() )

  000f0	8b 03		 mov	 eax, DWORD PTR [ebx]
  000f2	ff 50 24	 call	 DWORD PTR [eax+36]
  000f5	84 c0		 test	 al, al
  000f7	74 13		 je	 SHORT $LN2@FindTarget

; 274  : 				{
; 275  : 					SetAsTarget( FindClosestTarget( fSearchRange ) );

  000f9	8d 45 f0	 lea	 eax, DWORD PTR _fSearchRange$546595[ebp]
  000fc	50		 push	 eax
  000fd	8b cb		 mov	 ecx, ebx
  000ff	e8 00 00 00 00	 call	 ?FindClosestTarget@ioChampionAI@@QAEPAVioBaseChar@@ABM@Z ; ioChampionAI::FindClosestTarget
  00104	50		 push	 eax
  00105	8b cb		 mov	 ecx, ebx
  00107	e8 00 00 00 00	 call	 ?SetAsTarget@ioChampionAI@@AAE_NPAVioBaseChar@@@Z ; ioChampionAI::SetAsTarget
$LN2@FindTarget:

; 276  : 				}
; 277  : 				SetToRoamingMonster( fSearchRange );

  0010c	8d 45 f0	 lea	 eax, DWORD PTR _fSearchRange$546595[ebp]
  0010f	50		 push	 eax
  00110	8b cb		 mov	 ecx, ebx
  00112	e8 00 00 00 00	 call	 ?SetToRoamingMonster@ioChampionAI@@IAE_NAAM@Z ; ioChampionAI::SetToRoamingMonster
$LN3@FindTarget:

; 278  : 			}		
; 279  : 		}

  00117	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0011b	8d 4d dc	 lea	 ecx, DWORD PTR _szFirstTarget$546597[ebp]
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
$LN6@FindTarget:

; 280  : 
; 281  : 		CheckFlee( fSearchRange );

  00124	8d 45 f0	 lea	 eax, DWORD PTR _fSearchRange$546595[ebp]
  00127	50		 push	 eax
  00128	8b cb		 mov	 ecx, ebx
  0012a	e8 00 00 00 00	 call	 ?CheckFlee@ioChampionAI@@IAE_NAAM@Z ; ioChampionAI::CheckFlee

; 282  : 		CheckTargetBlocking( fSearchRange );

  0012f	8d 45 f0	 lea	 eax, DWORD PTR _fSearchRange$546595[ebp]
  00132	50		 push	 eax
  00133	8b cb		 mov	 ecx, ebx
  00135	e8 00 00 00 00	 call	 ?CheckTargetBlocking@ioChampionAI@@IAE_NAAM@Z ; ioChampionAI::CheckTargetBlocking

; 283  : 
; 284  : 		if( m_TargetData.GetTargetType() == TARGET_BASECHAR )

  0013a	83 bb b4 00 00
	00 01		 cmp	 DWORD PTR [ebx+180], 1
  00141	75 06		 jne	 SHORT $LN1@FindTarget

; 285  : 			m_fSearchRangeCurrent = m_fSearchRangeMax;

  00143	d9 43 18	 fld	 DWORD PTR [ebx+24]
  00146	d9 5b 24	 fstp	 DWORD PTR [ebx+36]
$LN1@FindTarget:

; 286  : 
; 287  : 		return true;

  00149	b0 01		 mov	 al, 1
  0014b	eb 02		 jmp	 SHORT $LN8@FindTarget
$LN7@FindTarget:

; 288  : 	}
; 289  : 
; 290  : 	return false;

  0014d	32 c0		 xor	 al, al
$LN8@FindTarget:

; 291  : }

  0014f	e8 00 00 00 00	 call	 __EH_epilog3
  00154	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindTargetChar@ioChampionAI@@QAE_NXZ$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR _szFirstTarget$546597[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$?FindTargetChar@ioChampionAI@@QAE_NXZ:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?FindTargetChar@ioChampionAI@@QAE_NXZ
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?FindTargetChar@ioChampionAI@@QAE_NXZ ENDP		; ioChampionAI::FindTargetChar
PUBLIC	?OldProcessAI@ioChampionAI@@QAEXXZ		; ioChampionAI::OldProcessAI
EXTRN	?OnJumpAction@ioJumpController@@QAE_NPAVioNpcChar@@PAVioBaseChar@@@Z:PROC ; ioJumpController::OnJumpAction
EXTRN	?OnMoveAction@ioMoveController@@QAE_NPAVioNpcChar@@PAVioBaseChar@@AAUD3DXVECTOR3@@MM@Z:PROC ; ioMoveController::OnMoveAction
EXTRN	?GetTargetAngle@ioAI@@IAEMUD3DXVECTOR3@@@Z:PROC	; ioAI::GetTargetAngle
EXTRN	?IsAction@ioActionController@@QAE_NXZ:PROC	; ioActionController::IsAction
EXTRN	?OnAttackAction@ioActionController@@QAE_NPAVioNpcChar@@PAVioBaseChar@@@Z:PROC ; ioActionController::OnAttackAction
EXTRN	?OnDefenseAction@ioDefenseController@@QAE_NPAVioNpcChar@@PAVioBaseChar@@@Z:PROC ; ioDefenseController::OnDefenseAction
EXTRN	?IsDefense@ioDefenseController@@QAE_NXZ:PROC	; ioDefenseController::IsDefense
EXTRN	?GetBaseChar@ioPlayStage@@QAEPAVioBaseChar@@ABVioHashString@@@Z:PROC ; ioPlayStage::GetBaseChar
; Function compile flags: /Ogsp
;	COMDAT ?OldProcessAI@ioChampionAI@@QAEXXZ
_TEXT	SEGMENT
_pTargetChar$546620 = -4				; size = 4
?OldProcessAI@ioChampionAI@@QAEXXZ PROC			; ioChampionAI::OldProcessAI, COMDAT
; _this$ = ecx

; 319  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b d9		 mov	 ebx, ecx

; 320  : 	// 타겟 검색
; 321  : 	if( !IsRoaming() )

  00008	8b 03		 mov	 eax, DWORD PTR [ebx]
  0000a	57		 push	 edi
  0000b	ff 50 20	 call	 DWORD PTR [eax+32]
  0000e	84 c0		 test	 al, al
  00010	75 07		 jne	 SHORT $LN12@OldProcess

; 322  : 	{
; 323  : 		FindTargetChar();		// m_TargetData will be updated

  00012	8b cb		 mov	 ecx, ebx
  00014	e8 00 00 00 00	 call	 ?FindTargetChar@ioChampionAI@@QAE_NXZ ; ioChampionAI::FindTargetChar
$LN12@OldProcess:

; 324  : 	}
; 325  : 
; 326  : 	// 타겟이 없으면 모든 키입력 중단.
; 327  : 	if( !HasValidTarget() )

  00019	8b cb		 mov	 ecx, ebx
  0001b	e8 00 00 00 00	 call	 ?HasValidTarget@ioChampionAI@@IAE_NXZ ; ioChampionAI::HasValidTarget
  00020	84 c0		 test	 al, al
  00022	75 0b		 jne	 SHORT $LN11@OldProcess

; 328  : 	{
; 329  : 		OnClearAction();

  00024	8b 03		 mov	 eax, DWORD PTR [ebx]
  00026	8b cb		 mov	 ecx, ebx
  00028	ff 10		 call	 DWORD PTR [eax]

; 330  : 	}
; 331  : 	else

  0002a	e9 60 01 00 00	 jmp	 $LN2@OldProcess
$LN11@OldProcess:

; 332  : 	{
; 333  : 		// 실시간 타겟 위치 변경
; 334  : 		ioBaseChar *pTargetChar = NULL;

  0002f	83 65 fc 00	 and	 DWORD PTR _pTargetChar$546620[ebp], 0

; 335  : 		if( m_TargetData.GetTargetType() == TARGET_BASECHAR )

  00033	83 bb b4 00 00
	00 01		 cmp	 DWORD PTR [ebx+180], 1
  0003a	75 28		 jne	 SHORT $LN33@OldProcess

; 336  : 		{
; 337  : 			pTargetChar = m_pPlayStage->GetBaseChar( m_TargetData.GetTargetName() );

  0003c	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  0003f	8d 83 b8 00 00
	00		 lea	 eax, DWORD PTR [ebx+184]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ?GetBaseChar@ioPlayStage@@QAEPAVioBaseChar@@ABVioHashString@@@Z ; ioPlayStage::GetBaseChar
  0004b	89 45 fc	 mov	 DWORD PTR _pTargetChar$546620[ebp], eax

; 338  : 			if( pTargetChar )

  0004e	85 c0		 test	 eax, eax
  00050	74 12		 je	 SHORT $LN33@OldProcess

; 339  : 			{
; 340  : 				m_TargetData.SetTargetPos( pTargetChar->GetWorldPosition() );

  00052	8b c8		 mov	 ecx, eax
  00054	8b 01		 mov	 eax, DWORD PTR [ecx]
  00056	ff 50 70	 call	 DWORD PTR [eax+112]
  00059	8d bb c8 00 00
	00		 lea	 edi, DWORD PTR [ebx+200]
  0005f	8b f0		 mov	 esi, eax
  00061	a5		 movsd
  00062	a5		 movsd
  00063	a5		 movsd
$LN33@OldProcess:

; 341  : 			}
; 342  : 		}
; 343  : 
; 344  : 		{
; 345  : 			// 타겟에 대한 행동
; 346  : 			OnDefense();

  00064	8b 03		 mov	 eax, DWORD PTR [ebx]
  00066	8b cb		 mov	 ecx, ebx
  00068	ff 50 10	 call	 DWORD PTR [eax+16]

; 347  : 			if( m_DefenseController.IsDefense() )

  0006b	8d 8b 90 02 00
	00		 lea	 ecx, DWORD PTR [ebx+656]
  00071	e8 00 00 00 00	 call	 ?IsDefense@ioDefenseController@@QAE_NXZ ; ioDefenseController::IsDefense

; 348  : 			{
; 349  : 				m_DefenseController.OnDefenseAction( m_pCreator, pTargetChar );

  00076	ff 75 fc	 push	 DWORD PTR _pTargetChar$546620[ebp]
  00079	84 c0		 test	 al, al
  0007b	74 13		 je	 SHORT $LN7@OldProcess
  0007d	ff 73 08	 push	 DWORD PTR [ebx+8]
  00080	8d 8b 90 02 00
	00		 lea	 ecx, DWORD PTR [ebx+656]
  00086	e8 00 00 00 00	 call	 ?OnDefenseAction@ioDefenseController@@QAE_NPAVioNpcChar@@PAVioBaseChar@@@Z ; ioDefenseController::OnDefenseAction

; 350  : 			}
; 351  : 			else

  0008b	e9 cd 00 00 00	 jmp	 $LN3@OldProcess
$LN7@OldProcess:

; 352  : 			{
; 353  : 				m_ActionController.OnAttackAction( m_pCreator, pTargetChar );			

  00090	ff 73 08	 push	 DWORD PTR [ebx+8]
  00093	8d 8b 70 01 00
	00		 lea	 ecx, DWORD PTR [ebx+368]
  00099	e8 00 00 00 00	 call	 ?OnAttackAction@ioActionController@@QAE_NPAVioNpcChar@@PAVioBaseChar@@@Z ; ioActionController::OnAttackAction

; 354  : 				if( !m_ActionController.IsAction() )

  0009e	8d 8b 70 01 00
	00		 lea	 ecx, DWORD PTR [ebx+368]
  000a4	e8 00 00 00 00	 call	 ?IsAction@ioActionController@@QAE_NXZ ; ioActionController::IsAction

; 355  : 				{
; 356  : 					m_MoveController.OnMoveAction( m_pCreator, pTargetChar, m_TargetData.GetTargetPos(), 
; 357  : 												   ioAI::GetTargetAngle( m_TargetData.GetTargetPos() ), GetTargetRange( m_TargetData.GetTargetPos() ) );

  000a9	8b cb		 mov	 ecx, ebx
  000ab	84 c0		 test	 al, al
  000ad	75 5b		 jne	 SHORT $LN5@OldProcess
  000af	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000b2	8b fc		 mov	 edi, esp
  000b4	8d b3 c8 00 00
	00		 lea	 esi, DWORD PTR [ebx+200]
  000ba	a5		 movsd
  000bb	a5		 movsd
  000bc	a5		 movsd
  000bd	e8 00 00 00 00	 call	 ?GetTargetRange@ioAI@@IAEMUD3DXVECTOR3@@@Z ; ioAI::GetTargetRange
  000c2	83 ec 10	 sub	 esp, 16			; 00000010H
  000c5	8b fc		 mov	 edi, esp
  000c7	d9 5c 24 0c	 fstp	 DWORD PTR [esp+12]
  000cb	8d b3 c8 00 00
	00		 lea	 esi, DWORD PTR [ebx+200]
  000d1	a5		 movsd
  000d2	a5		 movsd
  000d3	8b cb		 mov	 ecx, ebx
  000d5	a5		 movsd
  000d6	e8 00 00 00 00	 call	 ?GetTargetAngle@ioAI@@IAEMUD3DXVECTOR3@@@Z ; ioAI::GetTargetAngle
  000db	51		 push	 ecx
  000dc	8d 83 c8 00 00
	00		 lea	 eax, DWORD PTR [ebx+200]
  000e2	d9 1c 24	 fstp	 DWORD PTR [esp]
  000e5	50		 push	 eax
  000e6	ff 75 fc	 push	 DWORD PTR _pTargetChar$546620[ebp]
  000e9	8d 8b 2c 02 00
	00		 lea	 ecx, DWORD PTR [ebx+556]
  000ef	ff 73 08	 push	 DWORD PTR [ebx+8]
  000f2	e8 00 00 00 00	 call	 ?OnMoveAction@ioMoveController@@QAE_NPAVioNpcChar@@PAVioBaseChar@@AAUD3DXVECTOR3@@MM@Z ; ioMoveController::OnMoveAction

; 358  : 					m_JumpController.OnJumpAction( m_pCreator, pTargetChar );				

  000f7	ff 75 fc	 push	 DWORD PTR _pTargetChar$546620[ebp]
  000fa	8d 8b 64 02 00
	00		 lea	 ecx, DWORD PTR [ebx+612]
  00100	ff 73 08	 push	 DWORD PTR [ebx+8]
  00103	e8 00 00 00 00	 call	 ?OnJumpAction@ioJumpController@@QAE_NPAVioNpcChar@@PAVioBaseChar@@@Z ; ioJumpController::OnJumpAction
  00108	eb 53		 jmp	 SHORT $LN3@OldProcess
$LN5@OldProcess:

; 359  : 				}
; 360  : 				else if( IsActionToMove() )

  0010a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0010c	ff 50 04	 call	 DWORD PTR [eax+4]
  0010f	84 c0		 test	 al, al
  00111	74 4a		 je	 SHORT $LN3@OldProcess

; 361  : 				{
; 362  : 					m_MoveController.OnMoveAction( m_pCreator, pTargetChar, m_TargetData.GetTargetPos(), 
; 363  : 												   ioAI::GetTargetAngle( m_TargetData.GetTargetPos() ), GetTargetRange( m_TargetData.GetTargetPos() ) );

  00113	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00116	8b fc		 mov	 edi, esp
  00118	8d b3 c8 00 00
	00		 lea	 esi, DWORD PTR [ebx+200]
  0011e	a5		 movsd
  0011f	a5		 movsd
  00120	8b cb		 mov	 ecx, ebx
  00122	a5		 movsd
  00123	e8 00 00 00 00	 call	 ?GetTargetRange@ioAI@@IAEMUD3DXVECTOR3@@@Z ; ioAI::GetTargetRange
  00128	83 ec 10	 sub	 esp, 16			; 00000010H
  0012b	8b fc		 mov	 edi, esp
  0012d	d9 5c 24 0c	 fstp	 DWORD PTR [esp+12]
  00131	8d b3 c8 00 00
	00		 lea	 esi, DWORD PTR [ebx+200]
  00137	a5		 movsd
  00138	a5		 movsd
  00139	8b cb		 mov	 ecx, ebx
  0013b	a5		 movsd
  0013c	e8 00 00 00 00	 call	 ?GetTargetAngle@ioAI@@IAEMUD3DXVECTOR3@@@Z ; ioAI::GetTargetAngle
  00141	51		 push	 ecx
  00142	8d 83 c8 00 00
	00		 lea	 eax, DWORD PTR [ebx+200]
  00148	d9 1c 24	 fstp	 DWORD PTR [esp]
  0014b	50		 push	 eax
  0014c	ff 75 fc	 push	 DWORD PTR _pTargetChar$546620[ebp]
  0014f	8d 8b 2c 02 00
	00		 lea	 ecx, DWORD PTR [ebx+556]
  00155	ff 73 08	 push	 DWORD PTR [ebx+8]
  00158	e8 00 00 00 00	 call	 ?OnMoveAction@ioMoveController@@QAE_NPAVioNpcChar@@PAVioBaseChar@@AAUD3DXVECTOR3@@MM@Z ; ioMoveController::OnMoveAction
$LN3@OldProcess:

; 364  : 				}
; 365  : 			}
; 366  : 		}
; 367  : 
; 368  : 		{   // 타겟에 대한 행동 결정
; 369  : 			if( !OnAction() )

  0015d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0015f	8b cb		 mov	 ecx, ebx
  00161	ff 50 14	 call	 DWORD PTR [eax+20]
  00164	84 c0		 test	 al, al
  00166	75 27		 jne	 SHORT $LN2@OldProcess

; 370  : 			{				
; 371  : 				if( !OnMove() && !m_DefenseController.IsDefense() )

  00168	8b 03		 mov	 eax, DWORD PTR [ebx]
  0016a	8b cb		 mov	 ecx, ebx
  0016c	ff 50 08	 call	 DWORD PTR [eax+8]
  0016f	84 c0		 test	 al, al
  00171	75 15		 jne	 SHORT $LN1@OldProcess
  00173	8d 8b 90 02 00
	00		 lea	 ecx, DWORD PTR [ebx+656]
  00179	e8 00 00 00 00	 call	 ?IsDefense@ioDefenseController@@QAE_NXZ ; ioDefenseController::IsDefense
  0017e	84 c0		 test	 al, al
  00180	75 06		 jne	 SHORT $LN1@OldProcess

; 372  : 				{
; 373  : 					OnClearAction();

  00182	8b 03		 mov	 eax, DWORD PTR [ebx]
  00184	8b cb		 mov	 ecx, ebx
  00186	ff 10		 call	 DWORD PTR [eax]
$LN1@OldProcess:

; 374  : 				}
; 375  : 				OnJump();				

  00188	8b 03		 mov	 eax, DWORD PTR [ebx]
  0018a	8b cb		 mov	 ecx, ebx
  0018c	ff 50 0c	 call	 DWORD PTR [eax+12]
$LN2@OldProcess:

; 376  : 			}
; 377  : 		}
; 378  : 	}
; 379  : }

  0018f	5f		 pop	 edi
  00190	5e		 pop	 esi
  00191	5b		 pop	 ebx
  00192	c9		 leave
  00193	c3		 ret	 0
?OldProcessAI@ioChampionAI@@QAEXXZ ENDP			; ioChampionAI::OldProcessAI
_TEXT	ENDS
END
