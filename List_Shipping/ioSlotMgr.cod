; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\Lost Saga For Developer\Youtube\Tutorial\Source\src\LSClient\ioSlotMgr.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?ms_Singleton@?$Singleton@VioSlotMgr@@@@1PAVioSlotMgr@@A ; Singleton<ioSlotMgr>::ms_Singleton
;	COMDAT ?ms_Singleton@?$Singleton@VioSlotMgr@@@@1PAVioSlotMgr@@A
_BSS	SEGMENT
?ms_Singleton@?$Singleton@VioSlotMgr@@@@1PAVioSlotMgr@@A DD 01H DUP (?) ; Singleton<ioSlotMgr>::ms_Singleton
_BSS	ENDS
PUBLIC	?SetType@ioSlotItem@@QAEXK@Z			; ioSlotItem::SetType
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioslotmgr.h
;	COMDAT ?SetType@ioSlotItem@@QAEXK@Z
_TEXT	SEGMENT
_dwType$ = 8						; size = 4
?SetType@ioSlotItem@@QAEXK@Z PROC			; ioSlotItem::SetType, COMDAT
; _this$ = ecx

; 85   : 	void SetType(DWORD dwType){m_dwType = dwType;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _dwType$[ebp]
  00006	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetType@ioSlotItem@@QAEXK@Z ENDP			; ioSlotItem::SetType
_TEXT	ENDS
PUBLIC	?SetCoolTime@ioSlotItem@@QAEXK@Z		; ioSlotItem::SetCoolTime
; Function compile flags: /Ogsp
;	COMDAT ?SetCoolTime@ioSlotItem@@QAEXK@Z
_TEXT	SEGMENT
_dwCoolTime$ = 8					; size = 4
?SetCoolTime@ioSlotItem@@QAEXK@Z PROC			; ioSlotItem::SetCoolTime, COMDAT
; _this$ = ecx

; 87   : 	void SetCoolTime(const DWORD dwCoolTime) {m_dwCoolTime = dwCoolTime;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _dwCoolTime$[ebp]
  00006	89 41 44	 mov	 DWORD PTR [ecx+68], eax
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetCoolTime@ioSlotItem@@QAEXK@Z ENDP			; ioSlotItem::SetCoolTime
_TEXT	ENDS
PUBLIC	?SetItemNum@ioSlotItem@@QAEXH@Z			; ioSlotItem::SetItemNum
; Function compile flags: /Ogsp
;	COMDAT ?SetItemNum@ioSlotItem@@QAEXH@Z
_TEXT	SEGMENT
_nItem$ = 8						; size = 4
?SetItemNum@ioSlotItem@@QAEXH@Z PROC			; ioSlotItem::SetItemNum, COMDAT
; _this$ = ecx

; 88   : 	void SetItemNum(const int nItem) {m_nCount = nItem;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _nItem$[ebp]
  00006	89 41 3c	 mov	 DWORD PTR [ecx+60], eax
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetItemNum@ioSlotItem@@QAEXH@Z ENDP			; ioSlotItem::SetItemNum
_TEXT	ENDS
PUBLIC	?SetKeyName@ioSlotItem@@QAEXG@Z			; ioSlotItem::SetKeyName
; Function compile flags: /Ogsp
;	COMDAT ?SetKeyName@ioSlotItem@@QAEXG@Z
_TEXT	SEGMENT
_wKey$ = 8						; size = 2
?SetKeyName@ioSlotItem@@QAEXG@Z PROC			; ioSlotItem::SetKeyName, COMDAT
; _this$ = ecx

; 89   : 	void SetKeyName(const WORD wKey) {m_wKey = wKey;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	66 8b 45 08	 mov	 ax, WORD PTR _wKey$[ebp]
  00007	66 89 41 40	 mov	 WORD PTR [ecx+64], ax
  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?SetKeyName@ioSlotItem@@QAEXG@Z ENDP			; ioSlotItem::SetKeyName
_TEXT	ENDS
PUBLIC	?SetImg@ioSlotItem@@QAEXABVioHashString@@@Z	; ioSlotItem::SetImg
EXTRN	__imp_??4ioHashString@@QAEAAV0@ABV0@@Z:PROC
; Function compile flags: /Ogsp
;	COMDAT ?SetImg@ioSlotItem@@QAEXABVioHashString@@@Z
_TEXT	SEGMENT
_strImg$ = 8						; size = 4
?SetImg@ioSlotItem@@QAEXABVioHashString@@@Z PROC	; ioSlotItem::SetImg, COMDAT
; _this$ = ecx

; 90   : 	void SetImg(const ioHashString& strImg) {m_strItemImg = strImg;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 c1 04	 add	 ecx, 4
  00006	5d		 pop	 ebp
  00007	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@ABV0@@Z
?SetImg@ioSlotItem@@QAEXABVioHashString@@@Z ENDP	; ioSlotItem::SetImg
_TEXT	ENDS
PUBLIC	?SetBackImg@ioSlotItem@@QAEXABVioHashString@@@Z	; ioSlotItem::SetBackImg
; Function compile flags: /Ogsp
;	COMDAT ?SetBackImg@ioSlotItem@@QAEXABVioHashString@@@Z
_TEXT	SEGMENT
_strBackImg$ = 8					; size = 4
?SetBackImg@ioSlotItem@@QAEXABVioHashString@@@Z PROC	; ioSlotItem::SetBackImg, COMDAT
; _this$ = ecx

; 91   : 	void SetBackImg(const ioHashString& strBackImg) {m_strItemBackImg = strBackImg;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 c1 14	 add	 ecx, 20			; 00000014H
  00006	5d		 pop	 ebp
  00007	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@ABV0@@Z
?SetBackImg@ioSlotItem@@QAEXABVioHashString@@@Z ENDP	; ioSlotItem::SetBackImg
_TEXT	ENDS
PUBLIC	?SetBuffName@ioSlotItem@@QAEXABVioHashString@@@Z ; ioSlotItem::SetBuffName
; Function compile flags: /Ogsp
;	COMDAT ?SetBuffName@ioSlotItem@@QAEXABVioHashString@@@Z
_TEXT	SEGMENT
_strBuff$ = 8						; size = 4
?SetBuffName@ioSlotItem@@QAEXABVioHashString@@@Z PROC	; ioSlotItem::SetBuffName, COMDAT
; _this$ = ecx

; 92   : 	void SetBuffName(const ioHashString& strBuff) {m_strBuff = strBuff;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 c1 24	 add	 ecx, 36			; 00000024H
  00006	5d		 pop	 ebp
  00007	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@ABV0@@Z
?SetBuffName@ioSlotItem@@QAEXABVioHashString@@@Z ENDP	; ioSlotItem::SetBuffName
_TEXT	ENDS
PUBLIC	?GetMySlot@ioSlotItem@@QAE?BHXZ			; ioSlotItem::GetMySlot
; Function compile flags: /Ogsp
;	COMDAT ?GetMySlot@ioSlotItem@@QAE?BHXZ
_TEXT	SEGMENT
?GetMySlot@ioSlotItem@@QAE?BHXZ PROC			; ioSlotItem::GetMySlot, COMDAT
; _this$ = ecx

; 95   : 	const int GetMySlot(){return m_nMySlot;}

  00000	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  00003	c3		 ret	 0
?GetMySlot@ioSlotItem@@QAE?BHXZ ENDP			; ioSlotItem::GetMySlot
_TEXT	ENDS
PUBLIC	?GetType@ioSlotItem@@QAE?BKXZ			; ioSlotItem::GetType
; Function compile flags: /Ogsp
;	COMDAT ?GetType@ioSlotItem@@QAE?BKXZ
_TEXT	SEGMENT
?GetType@ioSlotItem@@QAE?BKXZ PROC			; ioSlotItem::GetType, COMDAT
; _this$ = ecx

; 96   : 	const DWORD GetType(){return m_dwType;}

  00000	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00003	c3		 ret	 0
?GetType@ioSlotItem@@QAE?BKXZ ENDP			; ioSlotItem::GetType
_TEXT	ENDS
PUBLIC	?GetCountItem@ioSlotItem@@QAE?BHXZ		; ioSlotItem::GetCountItem
; Function compile flags: /Ogsp
;	COMDAT ?GetCountItem@ioSlotItem@@QAE?BHXZ
_TEXT	SEGMENT
?GetCountItem@ioSlotItem@@QAE?BHXZ PROC			; ioSlotItem::GetCountItem, COMDAT
; _this$ = ecx

; 98   : 	const int GetCountItem() {return m_nCount;}

  00000	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]
  00003	c3		 ret	 0
?GetCountItem@ioSlotItem@@QAE?BHXZ ENDP			; ioSlotItem::GetCountItem
_TEXT	ENDS
PUBLIC	?GetKeyName@ioSlotItem@@QAE?BGXZ		; ioSlotItem::GetKeyName
; Function compile flags: /Ogsp
;	COMDAT ?GetKeyName@ioSlotItem@@QAE?BGXZ
_TEXT	SEGMENT
?GetKeyName@ioSlotItem@@QAE?BGXZ PROC			; ioSlotItem::GetKeyName, COMDAT
; _this$ = ecx

; 99   : 	const WORD GetKeyName() {return m_wKey;}

  00000	66 8b 41 40	 mov	 ax, WORD PTR [ecx+64]
  00004	c3		 ret	 0
?GetKeyName@ioSlotItem@@QAE?BGXZ ENDP			; ioSlotItem::GetKeyName
_TEXT	ENDS
PUBLIC	?SetSlotToSlot@ioSlotMgr@@QAEXHH@Z		; ioSlotMgr::SetSlotToSlot
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioslotmgr.cpp
;	COMDAT ?SetSlotToSlot@ioSlotMgr@@QAEXHH@Z
_TEXT	SEGMENT
_nSrcSlot$ = 8						; size = 4
_nDstSlot$ = 12						; size = 4
?SetSlotToSlot@ioSlotMgr@@QAEXHH@Z PROC			; ioSlotMgr::SetSlotToSlot, COMDAT
; _this$ = ecx

; 82   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 83   : 	ioSlotItem* pSrcSlot = m_pSlotItem[nSrcSlot];

  00003	8b 45 08	 mov	 eax, DWORD PTR _nSrcSlot$[ebp]
  00006	8b 44 81 04	 mov	 eax, DWORD PTR [ecx+eax*4+4]

; 84   : 	ioSlotItem* pDstSlot = m_pSlotItem[nDstSlot];

  0000a	8b 55 0c	 mov	 edx, DWORD PTR _nDstSlot$[ebp]
  0000d	8b 4c 91 04	 mov	 ecx, DWORD PTR [ecx+edx*4+4]

; 85   : 
; 86   : 	DWORD dwTmp = pDstSlot->GetType();

  00011	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00014	56		 push	 esi

; 87   : 
; 88   : 	pDstSlot->SetType(pSrcSlot->GetType());

  00015	8b 70 38	 mov	 esi, DWORD PTR [eax+56]
  00018	89 71 38	 mov	 DWORD PTR [ecx+56], esi

; 89   : 	pSrcSlot->SetType(dwTmp);

  0001b	89 50 38	 mov	 DWORD PTR [eax+56], edx
  0001e	5e		 pop	 esi

; 90   : }

  0001f	5d		 pop	 ebp
  00020	c2 08 00	 ret	 8
?SetSlotToSlot@ioSlotMgr@@QAEXHH@Z ENDP			; ioSlotMgr::SetSlotToSlot
_TEXT	ENDS
PUBLIC	?SetInvetToSlot@ioSlotMgr@@QAEXHK@Z		; ioSlotMgr::SetInvetToSlot
; Function compile flags: /Ogsp
;	COMDAT ?SetInvetToSlot@ioSlotMgr@@QAEXHK@Z
_TEXT	SEGMENT
_nDstSlot$ = 8						; size = 4
_dwType$ = 12						; size = 4
?SetInvetToSlot@ioSlotMgr@@QAEXHK@Z PROC		; ioSlotMgr::SetInvetToSlot, COMDAT
; _this$ = ecx

; 93   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 94   : 	m_pSlotItem[nDstSlot]->SetType(dwType);

  00003	8b 45 08	 mov	 eax, DWORD PTR _nDstSlot$[ebp]
  00006	8b 44 81 04	 mov	 eax, DWORD PTR [ecx+eax*4+4]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _dwType$[ebp]
  0000d	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 95   : }

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?SetInvetToSlot@ioSlotMgr@@QAEXHK@Z ENDP		; ioSlotMgr::SetInvetToSlot
_TEXT	ENDS
PUBLIC	??_R0?AVioWnd@@@8				; ioWnd `RTTI Type Descriptor'
PUBLIC	??_R0?AVTowerDefWnd@@@8				; TowerDefWnd `RTTI Type Descriptor'
PUBLIC	?InitAllItem@ioSlotMgr@@QAEXXZ			; ioSlotMgr::InitAllItem
EXTRN	?InitSlotItem@TowerDefWnd@@QAEXXZ:PROC		; TowerDefWnd::InitSlotItem
EXTRN	__imp_?FindWnd@ioGUIManager@@QAEPAVioWnd@@K@Z:PROC
EXTRN	?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ:PROC	; ioSP2GUIManager::GetSingleton
EXTRN	___RTDynamicCast:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT ??_R0?AVioWnd@@@8
_DATA	SEGMENT
??_R0?AVioWnd@@@8 DD FLAT:??_7type_info@@6B@		; ioWnd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioWnd@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVTowerDefWnd@@@8
_DATA	SEGMENT
??_R0?AVTowerDefWnd@@@8 DD FLAT:??_7type_info@@6B@	; TowerDefWnd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTowerDefWnd@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?InitAllItem@ioSlotMgr@@QAEXXZ
_TEXT	SEGMENT
?InitAllItem@ioSlotMgr@@QAEXXZ PROC			; ioSlotMgr::InitAllItem, COMDAT
; _this$ = ecx

; 218  : 	TowerDefWnd *pTowerWnd = dynamic_cast< TowerDefWnd * >( g_GUIMgr.FindWnd(TOWERDEF_USER_GAUGE_WND));

  00000	6a 00		 push	 0
  00002	68 00 00 00 00	 push	 OFFSET ??_R0?AVTowerDefWnd@@@8
  00007	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWnd@@@8
  0000c	6a 00		 push	 0
  0000e	68 d4 13 00 00	 push	 5076			; 000013d4H
  00013	e8 00 00 00 00	 call	 ?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ ; ioSP2GUIManager::GetSingleton
  00018	8b c8		 mov	 ecx, eax
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?FindWnd@ioGUIManager@@QAEPAVioWnd@@K@Z
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ___RTDynamicCast
  00026	83 c4 14	 add	 esp, 20			; 00000014H

; 219  : 	if(pTowerWnd)

  00029	85 c0		 test	 eax, eax
  0002b	74 07		 je	 SHORT $LN1@InitAllIte

; 220  : 		pTowerWnd->InitSlotItem();

  0002d	8b c8		 mov	 ecx, eax
  0002f	e9 00 00 00 00	 jmp	 ?InitSlotItem@TowerDefWnd@@QAEXXZ ; TowerDefWnd::InitSlotItem
$LN1@InitAllIte:

; 221  : }

  00034	c3		 ret	 0
?InitAllItem@ioSlotMgr@@QAEXXZ ENDP			; ioSlotMgr::InitAllItem
_TEXT	ENDS
PUBLIC	?GetSlot@ioSlotMgr@@QAEPAVioSlotItem@@K@Z	; ioSlotMgr::GetSlot
; Function compile flags: /Ogsp
;	COMDAT ?GetSlot@ioSlotMgr@@QAEPAVioSlotItem@@K@Z
_TEXT	SEGMENT
_dwType$ = 8						; size = 4
?GetSlot@ioSlotMgr@@QAEPAVioSlotItem@@K@Z PROC		; ioSlotMgr::GetSlot, COMDAT
; _this$ = ecx

; 229  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 230  : 	for(int i = 0; i < MAX_SLOT; i++)

  00003	33 d2		 xor	 edx, edx
  00005	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00008	56		 push	 esi
$LL4@GetSlot:

; 231  : 	{
; 232  : 		if(m_pSlotItem[i]->GetType() == dwType)

  00009	8b 30		 mov	 esi, DWORD PTR [eax]
  0000b	8b 76 38	 mov	 esi, DWORD PTR [esi+56]
  0000e	3b 75 08	 cmp	 esi, DWORD PTR _dwType$[ebp]
  00011	74 10		 je	 SHORT $LN10@GetSlot

; 230  : 	for(int i = 0; i < MAX_SLOT; i++)

  00013	42		 inc	 edx
  00014	83 c0 04	 add	 eax, 4
  00017	83 fa 04	 cmp	 edx, 4
  0001a	7c ed		 jl	 SHORT $LL4@GetSlot

; 234  : 	}
; 235  : 
; 236  : 	return NULL;

  0001c	33 c0		 xor	 eax, eax
$LN5@GetSlot:
  0001e	5e		 pop	 esi

; 237  : }

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
$LN10@GetSlot:

; 233  : 			return m_pSlotItem[i];

  00023	8b 44 91 04	 mov	 eax, DWORD PTR [ecx+edx*4+4]
  00027	eb f5		 jmp	 SHORT $LN5@GetSlot
?GetSlot@ioSlotMgr@@QAEPAVioSlotItem@@K@Z ENDP		; ioSlotMgr::GetSlot
_TEXT	ENDS
PUBLIC	?GetSlotItemType@ioSlotMgr@@QAE?BKH@Z		; ioSlotMgr::GetSlotItemType
; Function compile flags: /Ogsp
;	COMDAT ?GetSlotItemType@ioSlotMgr@@QAE?BKH@Z
_TEXT	SEGMENT
_nSlot$ = 8						; size = 4
?GetSlotItemType@ioSlotMgr@@QAE?BKH@Z PROC		; ioSlotMgr::GetSlotItemType, COMDAT
; _this$ = ecx

; 246  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 247  : 	return m_pSlotItem[nSlot]->GetType();

  00003	8b 45 08	 mov	 eax, DWORD PTR _nSlot$[ebp]
  00006	8b 44 81 04	 mov	 eax, DWORD PTR [ecx+eax*4+4]
  0000a	8b 40 38	 mov	 eax, DWORD PTR [eax+56]

; 248  : }

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
?GetSlotItemType@ioSlotMgr@@QAE?BKH@Z ENDP		; ioSlotMgr::GetSlotItemType
_TEXT	ENDS
PUBLIC	?GetReviveKey@ioSlotMgr@@QAE?BGXZ		; ioSlotMgr::GetReviveKey
; Function compile flags: /Ogsp
;	COMDAT ?GetReviveKey@ioSlotMgr@@QAE?BGXZ
_TEXT	SEGMENT
?GetReviveKey@ioSlotMgr@@QAE?BGXZ PROC			; ioSlotMgr::GetReviveKey, COMDAT
; _this$ = ecx

; 251  : {

  00000	56		 push	 esi

; 252  : 	for(int i = 0; i < MAX_SLOT; i++)

  00001	33 f6		 xor	 esi, esi
  00003	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
$LL5@GetReviveK:

; 253  : 	{
; 254  : 		if(m_pSlotItem[i]->GetType() == ioEtcItem::EIT_ETC_CONSUMPTION_REVIVE)

  00006	8b 10		 mov	 edx, DWORD PTR [eax]
  00008	81 7a 38 ff 47
	0f 00		 cmp	 DWORD PTR [edx+56], 1001471 ; 000f47ffH
  0000f	75 06		 jne	 SHORT $LN4@GetReviveK

; 255  : 		{
; 256  : 			if(m_pSlotItem[i]->GetCountItem() > 0)

  00011	83 7a 3c 00	 cmp	 DWORD PTR [edx+60], 0
  00015	7f 10		 jg	 SHORT $LN15@GetReviveK
$LN4@GetReviveK:

; 252  : 	for(int i = 0; i < MAX_SLOT; i++)

  00017	46		 inc	 esi
  00018	83 c0 04	 add	 eax, 4
  0001b	83 fe 04	 cmp	 esi, 4
  0001e	7c e6		 jl	 SHORT $LL5@GetReviveK

; 258  : 		}
; 259  : 	}
; 260  : 
; 261  : 	return 0xff; 

  00020	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00025	5e		 pop	 esi

; 262  : }

  00026	c3		 ret	 0
$LN15@GetReviveK:

; 257  : 				return m_pSlotItem[i]->GetKeyName();

  00027	8b 44 b1 04	 mov	 eax, DWORD PTR [ecx+esi*4+4]
  0002b	66 8b 40 40	 mov	 ax, WORD PTR [eax+64]
  0002f	5e		 pop	 esi

; 262  : }

  00030	c3		 ret	 0
?GetReviveKey@ioSlotMgr@@QAE?BGXZ ENDP			; ioSlotMgr::GetReviveKey
_TEXT	ENDS
PUBLIC	?GetEmptySlot@ioSlotMgr@@QAE?BHXZ		; ioSlotMgr::GetEmptySlot
; Function compile flags: /Ogsp
;	COMDAT ?GetEmptySlot@ioSlotMgr@@QAE?BHXZ
_TEXT	SEGMENT
?GetEmptySlot@ioSlotMgr@@QAE?BHXZ PROC			; ioSlotMgr::GetEmptySlot, COMDAT
; _this$ = ecx

; 266  : 	for(int i = 0; i < MAX_SLOT; i++)

  00000	33 c0		 xor	 eax, eax
  00002	83 c1 04	 add	 ecx, 4
$LL4@GetEmptySl:

; 267  : 	{
; 268  : 		if(m_pSlotItem[i]->GetType() == ioEtcItem::EIT_NONE)

  00005	8b 11		 mov	 edx, DWORD PTR [ecx]
  00007	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  0000b	74 0c		 je	 SHORT $LN5@GetEmptySl

; 266  : 	for(int i = 0; i < MAX_SLOT; i++)

  0000d	40		 inc	 eax
  0000e	83 c1 04	 add	 ecx, 4
  00011	83 f8 04	 cmp	 eax, 4
  00014	7c ef		 jl	 SHORT $LL4@GetEmptySl

; 269  : 			return i;
; 270  : 	}
; 271  : 
; 272  : 	return -1;

  00016	83 c8 ff	 or	 eax, -1
$LN5@GetEmptySl:

; 273  : }

  00019	c3		 ret	 0
?GetEmptySlot@ioSlotMgr@@QAE?BHXZ ENDP			; ioSlotMgr::GetEmptySlot
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_7ioSlotItem@@6B@				; ioSlotItem::`vftable'
PUBLIC	??0ioSlotItem@@QAE@H@Z				; ioSlotItem::ioSlotItem
PUBLIC	??_R4ioSlotItem@@6B@				; ioSlotItem::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVioSlotItem@@@8				; ioSlotItem `RTTI Type Descriptor'
PUBLIC	??_R3ioSlotItem@@8				; ioSlotItem::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioSlotItem@@8				; ioSlotItem::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ioSlotItem@@8			; ioSlotItem::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__imp_??1ioHashString@@QAE@XZ:PROC
EXTRN	__imp_??4ioHashString@@QAEAAV0@PBD@Z:PROC
EXTRN	__imp_??0ioHashString@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__EH_epilog3:PROC
EXTRN	__EH_prolog3:PROC
EXTRN	??_EioSlotItem@@UAEPAXI@Z:PROC			; ioSlotItem::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@ioSlotItem@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioSlotItem@@8 DD FLAT:??_R0?AVioSlotItem@@@8 ; ioSlotItem::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioSlotItem@@8
rdata$r	ENDS
;	COMDAT ??_R2ioSlotItem@@8
rdata$r	SEGMENT
??_R2ioSlotItem@@8 DD FLAT:??_R1A@?0A@EA@ioSlotItem@@8	; ioSlotItem::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ioSlotItem@@8
rdata$r	SEGMENT
??_R3ioSlotItem@@8 DD 00H				; ioSlotItem::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ioSlotItem@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioSlotItem@@@8
_DATA	SEGMENT
??_R0?AVioSlotItem@@@8 DD FLAT:??_7type_info@@6B@	; ioSlotItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioSlotItem@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ioSlotItem@@6B@
rdata$r	SEGMENT
??_R4ioSlotItem@@6B@ DD 00H				; ioSlotItem::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVioSlotItem@@@8
	DD	FLAT:??_R3ioSlotItem@@8
rdata$r	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_7ioSlotItem@@6B@
CONST	SEGMENT
??_7ioSlotItem@@6B@ DD FLAT:??_R4ioSlotItem@@6B@	; ioSlotItem::`vftable'
	DD	FLAT:??_EioSlotItem@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ioSlotItem@@QAE@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ioSlotItem@@QAE@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0ioSlotItem@@QAE@H@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0ioSlotItem@@QAE@H@Z$2
__ehfuncinfo$??0ioSlotItem@@QAE@H@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0ioSlotItem@@QAE@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??0ioSlotItem@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_nNum$ = 8						; size = 4
??0ioSlotItem@@QAE@H@Z PROC				; ioSlotItem::ioSlotItem, COMDAT
; _this$ = ecx

; 282  : {

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0ioSlotItem@@QAE@H@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_??0ioHashString@@QAE@XZ
  00017	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0001a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioSlotItem@@6B@
  00020	ff d7		 call	 edi
  00022	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00026	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  00029	ff d7		 call	 edi
  0002b	8d 4e 24	 lea	 ecx, DWORD PTR [esi+36]
  0002e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00032	ff d7		 call	 edi

; 283  : 	m_nMySlot = nNum;

  00034	8b 45 08	 mov	 eax, DWORD PTR _nNum$[ebp]

; 284  : 
; 285  : 	m_strItemImg = "";

  00037	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z
  0003d	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00042	53		 push	 ebx
  00043	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00046	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0004a	89 46 34	 mov	 DWORD PTR [esi+52], eax
  0004d	ff d7		 call	 edi

; 286  : 	m_strItemBackImg = "";

  0004f	53		 push	 ebx
  00050	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  00053	ff d7		 call	 edi

; 287  : 	m_strBuff = "";

  00055	53		 push	 ebx
  00056	8d 4e 24	 lea	 ecx, DWORD PTR [esi+36]
  00059	ff d7		 call	 edi

; 288  : 	m_dwType = ioEtcItem::EIT_NONE;

  0005b	33 c0		 xor	 eax, eax

; 289  : 	m_nCount = 0;
; 290  : 	m_wKey = 0;

  0005d	33 c9		 xor	 ecx, ecx
  0005f	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00062	89 46 3c	 mov	 DWORD PTR [esi+60], eax

; 291  : 	m_dwCoolTime = 0;

  00065	89 46 44	 mov	 DWORD PTR [esi+68], eax

; 292  : 	m_dwSetCT = 0;

  00068	89 46 48	 mov	 DWORD PTR [esi+72], eax
  0006b	66 89 4e 40	 mov	 WORD PTR [esi+64], cx

; 293  : }

  0006f	8b c6		 mov	 eax, esi
  00071	e8 00 00 00 00	 call	 __EH_epilog3
  00076	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ioSlotItem@@QAE@H@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??0ioSlotItem@@QAE@H@Z$1:
  0000c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 14	 add	 ecx, 20			; 00000014H
  00012	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??0ioSlotItem@@QAE@H@Z$2:
  00018	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 c1 24	 add	 ecx, 36			; 00000024H
  0001e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$??0ioSlotItem@@QAE@H@Z:
  00024	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00028	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002b	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ioSlotItem@@QAE@H@Z
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ioSlotItem@@QAE@H@Z ENDP				; ioSlotItem::ioSlotItem
PUBLIC	??1ioSlotItem@@UAE@XZ				; ioSlotItem::~ioSlotItem
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1ioSlotItem@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1ioSlotItem@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1ioSlotItem@@UAE@XZ$1
__ehfuncinfo$??1ioSlotItem@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1ioSlotItem@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??1ioSlotItem@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1ioSlotItem@@UAE@XZ PROC				; ioSlotItem::~ioSlotItem, COMDAT
; _this$ = ecx

; 296  : {

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??1ioSlotItem@@UAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioSlotItem@@6B@

; 297  : 
; 298  : }

  00017	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_??1ioHashString@@QAE@XZ
  0001d	8d 4e 24	 lea	 ecx, DWORD PTR [esi+36]
  00020	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00027	ff d7		 call	 edi
  00029	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  0002c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00030	ff d7		 call	 edi
  00032	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00036	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00039	ff d7		 call	 edi
  0003b	e8 00 00 00 00	 call	 __EH_epilog3
  00040	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1ioSlotItem@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??1ioSlotItem@@UAE@XZ$1:
  0000c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 14	 add	 ecx, 20			; 00000014H
  00012	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$??1ioSlotItem@@UAE@XZ:
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1ioSlotItem@@UAE@XZ
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1ioSlotItem@@UAE@XZ ENDP				; ioSlotItem::~ioSlotItem
PUBLIC	?ResetItem@ioSlotItem@@QAEXXZ			; ioSlotItem::ResetItem
; Function compile flags: /Ogsp
;	COMDAT ?ResetItem@ioSlotItem@@QAEXXZ
_TEXT	SEGMENT
?ResetItem@ioSlotItem@@QAEXXZ PROC			; ioSlotItem::ResetItem, COMDAT
; _this$ = ecx

; 301  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx
  00004	57		 push	 edi

; 302  : 	m_nCount = 0;
; 303  : 	m_dwCoolTime = 0;
; 304  : 	m_dwSetCT = 0;
; 305  : 	m_strItemImg = "";

  00005	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z
  0000b	33 c0		 xor	 eax, eax
  0000d	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00012	53		 push	 ebx
  00013	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00016	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  00019	89 46 44	 mov	 DWORD PTR [esi+68], eax
  0001c	89 46 48	 mov	 DWORD PTR [esi+72], eax
  0001f	ff d7		 call	 edi

; 306  : 	m_strItemBackImg = "";

  00021	53		 push	 ebx
  00022	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  00025	ff d7		 call	 edi

; 307  : 	m_strBuff = "";

  00027	53		 push	 ebx
  00028	8d 4e 24	 lea	 ecx, DWORD PTR [esi+36]
  0002b	ff d7		 call	 edi
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx

; 308  : }

  00030	c3		 ret	 0
?ResetItem@ioSlotItem@@QAEXXZ ENDP			; ioSlotItem::ResetItem
_TEXT	ENDS
PUBLIC	?SetCoolTime@ioSlotItem@@QAEXXZ			; ioSlotItem::SetCoolTime
EXTRN	__imp_?GetLoopSec@ioFrameTimer@@QBEKXZ:PROC
EXTRN	__imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ?SetCoolTime@ioSlotItem@@QAEXXZ
_TEXT	SEGMENT
?SetCoolTime@ioSlotItem@@QAEXXZ PROC			; ioSlotItem::SetCoolTime, COMDAT
; _this$ = ecx

; 311  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 312  : 	m_dwSetCT = FRAMEGETTIME() + m_dwCoolTime;

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  00009	8b c8		 mov	 ecx, eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ
  00011	03 46 44	 add	 eax, DWORD PTR [esi+68]
  00014	89 46 48	 mov	 DWORD PTR [esi+72], eax
  00017	5e		 pop	 esi

; 313  : }

  00018	c3		 ret	 0
?SetCoolTime@ioSlotItem@@QAEXXZ ENDP			; ioSlotItem::SetCoolTime
_TEXT	ENDS
PUBLIC	?IsCoolTime@ioSlotItem@@QAE_NXZ			; ioSlotItem::IsCoolTime
; Function compile flags: /Ogsp
;	COMDAT ?IsCoolTime@ioSlotItem@@QAE_NXZ
_TEXT	SEGMENT
?IsCoolTime@ioSlotItem@@QAE_NXZ PROC			; ioSlotItem::IsCoolTime, COMDAT
; _this$ = ecx

; 316  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 317  : 	DWORD dwFrame = FRAMEGETTIME();

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  00009	8b c8		 mov	 ecx, eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ

; 318  : 
; 319  : 	if( dwFrame > m_dwSetCT)

  00011	39 46 48	 cmp	 DWORD PTR [esi+72], eax
  00014	5e		 pop	 esi
  00015	1a c0		 sbb	 al, al
  00017	fe c0		 inc	 al

; 320  : 		return false;
; 321  : 
; 322  : 	return true;
; 323  : }

  00019	c3		 ret	 0
?IsCoolTime@ioSlotItem@@QAE_NXZ ENDP			; ioSlotItem::IsCoolTime
_TEXT	ENDS
PUBLIC	?GetSingleton@?$Singleton@VioEtcItemManager@@@@SAAAVioEtcItemManager@@XZ ; Singleton<ioEtcItemManager>::GetSingleton
EXTRN	?ms_Singleton@?$Singleton@VioEtcItemManager@@@@1PAVioEtcItemManager@@A:DWORD ; Singleton<ioEtcItemManager>::ms_Singleton
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\io3dengine\iosingleton.h
;	COMDAT ?GetSingleton@?$Singleton@VioEtcItemManager@@@@SAAAVioEtcItemManager@@XZ
_TEXT	SEGMENT
?GetSingleton@?$Singleton@VioEtcItemManager@@@@SAAAVioEtcItemManager@@XZ PROC ; Singleton<ioEtcItemManager>::GetSingleton, COMDAT

; 42   : 		assert( ms_Singleton );
; 43   : 		return (*ms_Singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_Singleton@?$Singleton@VioEtcItemManager@@@@1PAVioEtcItemManager@@A ; Singleton<ioEtcItemManager>::ms_Singleton

; 44   : 	}

  00005	c3		 ret	 0
?GetSingleton@?$Singleton@VioEtcItemManager@@@@SAAAVioEtcItemManager@@XZ ENDP ; Singleton<ioEtcItemManager>::GetSingleton
_TEXT	ENDS
PUBLIC	??0?$Singleton@VioSlotMgr@@@@QAE@XZ		; Singleton<ioSlotMgr>::Singleton<ioSlotMgr>
; Function compile flags: /Ogsp
;	COMDAT ??0?$Singleton@VioSlotMgr@@@@QAE@XZ
_TEXT	SEGMENT
??0?$Singleton@VioSlotMgr@@@@QAE@XZ PROC		; Singleton<ioSlotMgr>::Singleton<ioSlotMgr>, COMDAT
; _this$ = ecx

; 27   : 	Singleton()

  00000	8b c1		 mov	 eax, ecx

; 28   : 	{
; 29   : 		assert( !ms_Singleton );
; 30   : 		int offset = (int)(T*)1 - (int)(Singleton <T>*)(T*)1;
; 31   : 		ms_Singleton = (T*)((int)this + offset);

  00002	8d 48 fc	 lea	 ecx, DWORD PTR [eax-4]
  00005	89 0d 00 00 00
	00		 mov	 DWORD PTR ?ms_Singleton@?$Singleton@VioSlotMgr@@@@1PAVioSlotMgr@@A, ecx ; Singleton<ioSlotMgr>::ms_Singleton

; 32   : 	}

  0000b	c3		 ret	 0
??0?$Singleton@VioSlotMgr@@@@QAE@XZ ENDP		; Singleton<ioSlotMgr>::Singleton<ioSlotMgr>
_TEXT	ENDS
PUBLIC	??1?$Singleton@VioSlotMgr@@@@QAE@XZ		; Singleton<ioSlotMgr>::~Singleton<ioSlotMgr>
; Function compile flags: /Ogsp
;	COMDAT ??1?$Singleton@VioSlotMgr@@@@QAE@XZ
_TEXT	SEGMENT
??1?$Singleton@VioSlotMgr@@@@QAE@XZ PROC		; Singleton<ioSlotMgr>::~Singleton<ioSlotMgr>, COMDAT
; _this$ = ecx

; 36   : 		assert( ms_Singleton );
; 37   : 		ms_Singleton = 0;

  00000	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_Singleton@?$Singleton@VioSlotMgr@@@@1PAVioSlotMgr@@A, 0 ; Singleton<ioSlotMgr>::ms_Singleton

; 38   : 	}

  00007	c3		 ret	 0
??1?$Singleton@VioSlotMgr@@@@QAE@XZ ENDP		; Singleton<ioSlotMgr>::~Singleton<ioSlotMgr>
_TEXT	ENDS
PUBLIC	?GetSingleton@?$Singleton@VioSlotMgr@@@@SAAAVioSlotMgr@@XZ ; Singleton<ioSlotMgr>::GetSingleton
; Function compile flags: /Ogsp
;	COMDAT ?GetSingleton@?$Singleton@VioSlotMgr@@@@SAAAVioSlotMgr@@XZ
_TEXT	SEGMENT
?GetSingleton@?$Singleton@VioSlotMgr@@@@SAAAVioSlotMgr@@XZ PROC ; Singleton<ioSlotMgr>::GetSingleton, COMDAT

; 42   : 		assert( ms_Singleton );
; 43   : 		return (*ms_Singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_Singleton@?$Singleton@VioSlotMgr@@@@1PAVioSlotMgr@@A ; Singleton<ioSlotMgr>::ms_Singleton

; 44   : 	}

  00005	c3		 ret	 0
?GetSingleton@?$Singleton@VioSlotMgr@@@@SAAAVioSlotMgr@@XZ ENDP ; Singleton<ioSlotMgr>::GetSingleton
_TEXT	ENDS
PUBLIC	?GetSlotItem@Setting@@SAKXZ			; Setting::GetSlotItem
EXTRN	?m_Option@Setting@@1USettingOption@@A:BYTE	; Setting::m_Option
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\setting.h
;	COMDAT ?GetSlotItem@Setting@@SAKXZ
_TEXT	SEGMENT
?GetSlotItem@Setting@@SAKXZ PROC			; Setting::GetSlotItem, COMDAT

; 387  : 	static DWORD GetSlotItem() { return m_Option.m_dwSlot; }

  00000	a1 9c 00 00 00	 mov	 eax, DWORD PTR ?m_Option@Setting@@1USettingOption@@A+156
  00005	c3		 ret	 0
?GetSlotItem@Setting@@SAKXZ ENDP			; Setting::GetSlotItem
_TEXT	ENDS
PUBLIC	?SetSlotItem@Setting@@SAXK@Z			; Setting::SetSlotItem
; Function compile flags: /Ogsp
;	COMDAT ?SetSlotItem@Setting@@SAXK@Z
_TEXT	SEGMENT
_dwSlot$ = 8						; size = 4
?SetSlotItem@Setting@@SAXK@Z PROC			; Setting::SetSlotItem, COMDAT

; 388  : 	static void SetSlotItem(DWORD dwSlot) { m_Option.m_dwSlot = dwSlot;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _dwSlot$[ebp]
  00006	a3 9c 00 00 00	 mov	 DWORD PTR ?m_Option@Setting@@1USettingOption@@A+156, eax
  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?SetSlotItem@Setting@@SAXK@Z ENDP			; Setting::SetSlotItem
_TEXT	ENDS
PUBLIC	??0ETCITEMSLOT@ioUserEtcItem@@QAE@XZ		; ioUserEtcItem::ETCITEMSLOT::ETCITEMSLOT
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iouseretcitem.h
;	COMDAT ??0ETCITEMSLOT@ioUserEtcItem@@QAE@XZ
_TEXT	SEGMENT
??0ETCITEMSLOT@ioUserEtcItem@@QAE@XZ PROC		; ioUserEtcItem::ETCITEMSLOT::ETCITEMSLOT, COMDAT
; _this$ = ecx

; 22   : 		ETCITEMSLOT()

  00000	8b c1		 mov	 eax, ecx

; 23   : 		{
; 24   : 			m_iType   = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 25   : 			m_iValue1 = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 26   : 			m_iValue2 = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 27   : 		}

  0000c	c3		 ret	 0
??0ETCITEMSLOT@ioUserEtcItem@@QAE@XZ ENDP		; ioUserEtcItem::ETCITEMSLOT::ETCITEMSLOT
_TEXT	ENDS
PUBLIC	?GetIconImg@ioEtcItemConsumption@@QAEABVioHashString@@XZ ; ioEtcItemConsumption::GetIconImg
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioetcitem.h
;	COMDAT ?GetIconImg@ioEtcItemConsumption@@QAEABVioHashString@@XZ
_TEXT	SEGMENT
?GetIconImg@ioEtcItemConsumption@@QAEABVioHashString@@XZ PROC ; ioEtcItemConsumption::GetIconImg, COMDAT
; _this$ = ecx

; 1671 : 	const ioHashString& GetIconImg() {return m_strIcon;}

  00000	8d 81 88 01 00
	00		 lea	 eax, DWORD PTR [ecx+392]
  00006	c3		 ret	 0
?GetIconImg@ioEtcItemConsumption@@QAEABVioHashString@@XZ ENDP ; ioEtcItemConsumption::GetIconImg
_TEXT	ENDS
PUBLIC	?GetIconBackImg@ioEtcItemConsumption@@QAEABVioHashString@@XZ ; ioEtcItemConsumption::GetIconBackImg
; Function compile flags: /Ogsp
;	COMDAT ?GetIconBackImg@ioEtcItemConsumption@@QAEABVioHashString@@XZ
_TEXT	SEGMENT
?GetIconBackImg@ioEtcItemConsumption@@QAEABVioHashString@@XZ PROC ; ioEtcItemConsumption::GetIconBackImg, COMDAT
; _this$ = ecx

; 1672 : 	const ioHashString& GetIconBackImg() {return m_strBackImg;}

  00000	8d 81 98 01 00
	00		 lea	 eax, DWORD PTR [ecx+408]
  00006	c3		 ret	 0
?GetIconBackImg@ioEtcItemConsumption@@QAEABVioHashString@@XZ ENDP ; ioEtcItemConsumption::GetIconBackImg
_TEXT	ENDS
PUBLIC	?GetSlotBuff@ioEtcItemConsumption@@QAEABVioHashString@@XZ ; ioEtcItemConsumption::GetSlotBuff
; Function compile flags: /Ogsp
;	COMDAT ?GetSlotBuff@ioEtcItemConsumption@@QAEABVioHashString@@XZ
_TEXT	SEGMENT
?GetSlotBuff@ioEtcItemConsumption@@QAEABVioHashString@@XZ PROC ; ioEtcItemConsumption::GetSlotBuff, COMDAT
; _this$ = ecx

; 1673 : 	const ioHashString& GetSlotBuff() {return m_strSlotBuff;}

  00000	8d 81 a8 01 00
	00		 lea	 eax, DWORD PTR [ecx+424]
  00006	c3		 ret	 0
?GetSlotBuff@ioEtcItemConsumption@@QAEABVioHashString@@XZ ENDP ; ioEtcItemConsumption::GetSlotBuff
_TEXT	ENDS
PUBLIC	?GetCoolTime@ioEtcItemConsumption@@QAE?BKXZ	; ioEtcItemConsumption::GetCoolTime
; Function compile flags: /Ogsp
;	COMDAT ?GetCoolTime@ioEtcItemConsumption@@QAE?BKXZ
_TEXT	SEGMENT
?GetCoolTime@ioEtcItemConsumption@@QAE?BKXZ PROC	; ioEtcItemConsumption::GetCoolTime, COMDAT
; _this$ = ecx

; 1676 : 	const DWORD	GetCoolTime() {return m_dwCoolTime;}

  00000	8b 81 b8 01 00
	00		 mov	 eax, DWORD PTR [ecx+440]
  00006	c3		 ret	 0
?GetCoolTime@ioEtcItemConsumption@@QAE?BKXZ ENDP	; ioEtcItemConsumption::GetCoolTime
_TEXT	ENDS
PUBLIC	?GetPublicID@ioMyInfo@@QBEABVioHashString@@XZ	; ioMyInfo::GetPublicID
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iomyinfo.h
;	COMDAT ?GetPublicID@ioMyInfo@@QBEABVioHashString@@XZ
_TEXT	SEGMENT
?GetPublicID@ioMyInfo@@QBEABVioHashString@@XZ PROC	; ioMyInfo::GetPublicID, COMDAT
; _this$ = ecx

; 517  : 	const ioHashString& GetPublicID() const { return m_user_data.m_public_id; }    

  00000	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  00003	c3		 ret	 0
?GetPublicID@ioMyInfo@@QBEABVioHashString@@XZ ENDP	; ioMyInfo::GetPublicID
_TEXT	ENDS
PUBLIC	?GetUserEtcItem@ioMyInfo@@QAEPAVioUserEtcItem@@XZ ; ioMyInfo::GetUserEtcItem
; Function compile flags: /Ogsp
;	COMDAT ?GetUserEtcItem@ioMyInfo@@QAEPAVioUserEtcItem@@XZ
_TEXT	SEGMENT
?GetUserEtcItem@ioMyInfo@@QAEPAVioUserEtcItem@@XZ PROC	; ioMyInfo::GetUserEtcItem, COMDAT
; _this$ = ecx

; 635  : 	ioUserEtcItem* GetUserEtcItem() { return &m_UserEtcItem; }

  00000	8d 81 44 01 00
	00		 lea	 eax, DWORD PTR [ecx+324]
  00006	c3		 ret	 0
?GetUserEtcItem@ioMyInfo@@QAEPAVioUserEtcItem@@XZ ENDP	; ioMyInfo::GetUserEtcItem
_TEXT	ENDS
PUBLIC	??_7ioSlotMgr@@6B@				; ioSlotMgr::`vftable'
PUBLIC	??0ioSlotMgr@@QAE@XZ				; ioSlotMgr::ioSlotMgr
PUBLIC	??_R4ioSlotMgr@@6B@				; ioSlotMgr::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVioSlotMgr@@@8				; ioSlotMgr `RTTI Type Descriptor'
PUBLIC	??_R3ioSlotMgr@@8				; ioSlotMgr::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioSlotMgr@@8				; ioSlotMgr::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ioSlotMgr@@8			; ioSlotMgr::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R13?0A@EA@?$Singleton@VioSlotMgr@@@@8	; Singleton<ioSlotMgr>::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AV?$Singleton@VioSlotMgr@@@@@8		; Singleton<ioSlotMgr> `RTTI Type Descriptor'
PUBLIC	??_R3?$Singleton@VioSlotMgr@@@@8		; Singleton<ioSlotMgr>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$Singleton@VioSlotMgr@@@@8		; Singleton<ioSlotMgr>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$Singleton@VioSlotMgr@@@@8	; Singleton<ioSlotMgr>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??_EioSlotMgr@@UAEPAXI@Z:PROC			; ioSlotMgr::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$Singleton@VioSlotMgr@@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioslotmgr.h
rdata$r	SEGMENT
??_R1A@?0A@EA@?$Singleton@VioSlotMgr@@@@8 DD FLAT:??_R0?AV?$Singleton@VioSlotMgr@@@@@8 ; Singleton<ioSlotMgr>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$Singleton@VioSlotMgr@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$Singleton@VioSlotMgr@@@@8
rdata$r	SEGMENT
??_R2?$Singleton@VioSlotMgr@@@@8 DD FLAT:??_R1A@?0A@EA@?$Singleton@VioSlotMgr@@@@8 ; Singleton<ioSlotMgr>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$Singleton@VioSlotMgr@@@@8
rdata$r	SEGMENT
??_R3?$Singleton@VioSlotMgr@@@@8 DD 00H			; Singleton<ioSlotMgr>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$Singleton@VioSlotMgr@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$Singleton@VioSlotMgr@@@@@8
_DATA	SEGMENT
??_R0?AV?$Singleton@VioSlotMgr@@@@@8 DD FLAT:??_7type_info@@6B@ ; Singleton<ioSlotMgr> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$Singleton@VioSlotMgr@@@@', 00H
_DATA	ENDS
;	COMDAT ??_R13?0A@EA@?$Singleton@VioSlotMgr@@@@8
rdata$r	SEGMENT
??_R13?0A@EA@?$Singleton@VioSlotMgr@@@@8 DD FLAT:??_R0?AV?$Singleton@VioSlotMgr@@@@@8 ; Singleton<ioSlotMgr>::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$Singleton@VioSlotMgr@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ioSlotMgr@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioSlotMgr@@8 DD FLAT:??_R0?AVioSlotMgr@@@8 ; ioSlotMgr::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioSlotMgr@@8
rdata$r	ENDS
;	COMDAT ??_R2ioSlotMgr@@8
rdata$r	SEGMENT
??_R2ioSlotMgr@@8 DD FLAT:??_R1A@?0A@EA@ioSlotMgr@@8	; ioSlotMgr::`RTTI Base Class Array'
	DD	FLAT:??_R13?0A@EA@?$Singleton@VioSlotMgr@@@@8
rdata$r	ENDS
;	COMDAT ??_R3ioSlotMgr@@8
rdata$r	SEGMENT
??_R3ioSlotMgr@@8 DD 00H				; ioSlotMgr::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ioSlotMgr@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioSlotMgr@@@8
_DATA	SEGMENT
??_R0?AVioSlotMgr@@@8 DD FLAT:??_7type_info@@6B@	; ioSlotMgr `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioSlotMgr@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ioSlotMgr@@6B@
rdata$r	SEGMENT
??_R4ioSlotMgr@@6B@ DD 00H				; ioSlotMgr::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVioSlotMgr@@@8
	DD	FLAT:??_R3ioSlotMgr@@8
rdata$r	ENDS
;	COMDAT ??_7ioSlotMgr@@6B@
CONST	SEGMENT
??_7ioSlotMgr@@6B@ DD FLAT:??_R4ioSlotMgr@@6B@		; ioSlotMgr::`vftable'
	DD	FLAT:??_EioSlotMgr@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ioSlotMgr@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ioSlotMgr@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0ioSlotMgr@@QAE@XZ$1
__ehfuncinfo$??0ioSlotMgr@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0ioSlotMgr@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioslotmgr.cpp
xdata$x	ENDS
;	COMDAT ??0ioSlotMgr@@QAE@XZ
_TEXT	SEGMENT
$T506078 = -24						; size = 4
_this$ = -20						; size = 4
_i$505596 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0ioSlotMgr@@QAE@XZ PROC				; ioSlotMgr::ioSlotMgr, COMDAT
; _this$ = ecx

; 10   : {

  00000	6a 0c		 push	 12			; 0000000cH
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0ioSlotMgr@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  00011	8b c6		 mov	 eax, esi
  00013	a3 00 00 00 00	 mov	 DWORD PTR ?ms_Singleton@?$Singleton@VioSlotMgr@@@@1PAVioSlotMgr@@A, eax ; Singleton<ioSlotMgr>::ms_Singleton
  00018	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 11   : 	for(int i = 0; i < MAX_SLOT; i++)

  0001c	83 65 f0 00	 and	 DWORD PTR _i$505596[ebp], 0
  00020	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioSlotMgr@@6B@
  00026	8d 5e 04	 lea	 ebx, DWORD PTR [esi+4]
$LL11@ioSlotMgr:

; 12   : 		m_pSlotItem[i] = new ioSlotItem(i);

  00029	6a 4c		 push	 76			; 0000004cH
  0002b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00030	59		 pop	 ecx
  00031	89 45 e8	 mov	 DWORD PTR $T506078[ebp], eax
  00034	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00038	85 c0		 test	 eax, eax
  0003a	74 0c		 je	 SHORT $LN14@ioSlotMgr
  0003c	ff 75 f0	 push	 DWORD PTR _i$505596[ebp]
  0003f	8b c8		 mov	 ecx, eax
  00041	e8 00 00 00 00	 call	 ??0ioSlotItem@@QAE@H@Z	; ioSlotItem::ioSlotItem
  00046	eb 02		 jmp	 SHORT $LN15@ioSlotMgr
$LN14@ioSlotMgr:
  00048	33 c0		 xor	 eax, eax
$LN15@ioSlotMgr:

; 11   : 	for(int i = 0; i < MAX_SLOT; i++)

  0004a	ff 45 f0	 inc	 DWORD PTR _i$505596[ebp]

; 12   : 		m_pSlotItem[i] = new ioSlotItem(i);

  0004d	89 03		 mov	 DWORD PTR [ebx], eax
  0004f	83 c3 04	 add	 ebx, 4
  00052	83 7d f0 04	 cmp	 DWORD PTR _i$505596[ebp], 4
  00056	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0005a	7c cd		 jl	 SHORT $LL11@ioSlotMgr

; 13   : 
; 14   : 	m_dwSlot = Setting::GetSlotItem();

  0005c	a1 9c 00 00 00	 mov	 eax, DWORD PTR ?m_Option@Setting@@1USettingOption@@A+156
  00061	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 15   : 
; 16   : 	DWORD dwSlot = m_dwSlot >>  24;

  00064	0f b6 46 17	 movzx	 eax, BYTE PTR [esi+23]

; 17   : 	DWORD dwEtcItem = ioEtcItem::EIT_NONE;
; 18   : 
; 19   : 	if(dwSlot == 0)

  00068	85 c0		 test	 eax, eax
  0006a	74 05		 je	 SHORT $LN7@ioSlotMgr
$LN8@ioSlotMgr:

; 20   : 		dwEtcItem = ioEtcItem::EIT_NONE;
; 21   : 	else
; 22   : 		dwEtcItem = dwSlot - 1 + ioEtcItem::EIT_ETC_CONSUMPTION_BUFF01;

  0006c	05 be 47 0f 00	 add	 eax, 1001406		; 000f47beH
$LN7@ioSlotMgr:

; 23   : 
; 24   : 	m_pSlotItem[SLOT_1]->SetType(dwEtcItem);

  00071	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00074	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 25   : 
; 26   : 
; 27   : 	dwSlot =  (m_dwSlot >>  16) & 0x000000ff;

  00077	0f b6 46 16	 movzx	 eax, BYTE PTR [esi+22]

; 28   : 
; 29   : 	if(dwSlot == 0)

  0007b	85 c0		 test	 eax, eax
  0007d	74 05		 je	 SHORT $LN5@ioSlotMgr
$LN6@ioSlotMgr:

; 30   : 		dwEtcItem = ioEtcItem::EIT_NONE;
; 31   : 	else
; 32   : 		dwEtcItem = dwSlot - 1 + ioEtcItem::EIT_ETC_CONSUMPTION_BUFF01;

  0007f	05 be 47 0f 00	 add	 eax, 1001406		; 000f47beH
$LN5@ioSlotMgr:

; 33   : 
; 34   : 	m_pSlotItem[SLOT_2]->SetType(dwEtcItem);

  00084	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00087	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 35   : 
; 36   : 
; 37   : 	dwSlot =  (m_dwSlot >>  8) & 0x000000ff;

  0008a	0f b6 46 15	 movzx	 eax, BYTE PTR [esi+21]

; 38   : 
; 39   : 	if(dwSlot == 0)

  0008e	85 c0		 test	 eax, eax
  00090	74 05		 je	 SHORT $LN3@ioSlotMgr
$LN4@ioSlotMgr:

; 40   : 		dwEtcItem = ioEtcItem::EIT_NONE;
; 41   : 	else
; 42   : 		dwEtcItem = dwSlot - 1 + ioEtcItem::EIT_ETC_CONSUMPTION_BUFF01;

  00092	05 be 47 0f 00	 add	 eax, 1001406		; 000f47beH
$LN3@ioSlotMgr:

; 43   : 
; 44   : 	m_pSlotItem[SLOT_3]->SetType(dwEtcItem);

  00097	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0009a	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 45   : 
; 46   : 
; 47   : 	dwSlot =  m_dwSlot & 0x000000ff;

  0009d	0f b6 46 14	 movzx	 eax, BYTE PTR [esi+20]

; 48   : 
; 49   : 	if(dwSlot == 0)

  000a1	85 c0		 test	 eax, eax
  000a3	74 05		 je	 SHORT $LN1@ioSlotMgr
$LN2@ioSlotMgr:

; 50   : 		dwEtcItem = ioEtcItem::EIT_NONE;
; 51   : 	else
; 52   : 		dwEtcItem = dwSlot - 1 + ioEtcItem::EIT_ETC_CONSUMPTION_BUFF01;

  000a5	05 be 47 0f 00	 add	 eax, 1001406		; 000f47beH
$LN1@ioSlotMgr:

; 53   : 
; 54   : 	m_pSlotItem[SLOT_4]->SetType(dwEtcItem);

  000aa	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000ad	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 55   : }

  000b0	8b c6		 mov	 eax, esi
  000b2	e8 00 00 00 00	 call	 __EH_epilog3
  000b7	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ioSlotMgr@@QAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$Singleton@VioSlotMgr@@@@QAE@XZ ; Singleton<ioSlotMgr>::~Singleton<ioSlotMgr>
__unwindfunclet$??0ioSlotMgr@@QAE@XZ$1:
  0000b	ff 75 e8	 push	 DWORD PTR $T506078[ebp]
  0000e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00013	59		 pop	 ecx
  00014	c3		 ret	 0
__ehhandler$??0ioSlotMgr@@QAE@XZ:
  00015	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00019	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001c	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ioSlotMgr@@QAE@XZ
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ioSlotMgr@@QAE@XZ ENDP				; ioSlotMgr::ioSlotMgr
PUBLIC	??1ioSlotMgr@@UAE@XZ				; ioSlotMgr::~ioSlotMgr
EXTRN	?SaveSetting@Setting@@SAXABVioHashString@@_N@Z:PROC ; Setting::SaveSetting
EXTRN	?GetSingleton@ioMyInfo@@SAAAV1@XZ:PROC		; ioMyInfo::GetSingleton
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\io3dengine\iosingleton.h
xdata$x	SEGMENT
__unwindtable$??1ioSlotMgr@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1ioSlotMgr@@UAE@XZ$0
__ehfuncinfo$??1ioSlotMgr@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1ioSlotMgr@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioslotmgr.cpp
xdata$x	ENDS
;	COMDAT ??1ioSlotMgr@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1ioSlotMgr@@UAE@XZ PROC				; ioSlotMgr::~ioSlotMgr, COMDAT
; _this$ = ecx

; 59   : {

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??1ioSlotMgr@@UAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0000f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ioSlotMgr@@6B@
  00015	33 db		 xor	 ebx, ebx
  00017	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx

; 60   : 	DWORD dwSlot = 0;

  0001a	33 ff		 xor	 edi, edi
  0001c	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
$LN7@ioSlotMgr@2:

; 63   : 	{
; 64   : 		if(m_pSlotItem[i])

  0001f	8b 06		 mov	 eax, DWORD PTR [esi]
  00021	85 c0		 test	 eax, eax
  00023	74 24		 je	 SHORT $LN6@ioSlotMgr@2

; 65   : 		{
; 66   : 			if(m_pSlotItem[i]->GetType() != ioEtcItem::EIT_NONE )

  00025	8b 50 38	 mov	 edx, DWORD PTR [eax+56]
  00028	85 d2		 test	 edx, edx
  0002a	74 12		 je	 SHORT $LN3@ioSlotMgr@2

; 67   : 				dwSlot = dwSlot | ( (m_pSlotItem[i]->GetType() - ioEtcItem::EIT_ETC_CONSUMPTION_BUFF01 + 1) << (24 - (i * 8)));

  0002c	6a 03		 push	 3
  0002e	59		 pop	 ecx
  0002f	2b cb		 sub	 ecx, ebx
  00031	c1 e1 03	 shl	 ecx, 3
  00034	81 c2 42 b8 f0
	ff		 add	 edx, -1001406		; fff0b842H
  0003a	d3 e2		 shl	 edx, cl
  0003c	0b fa		 or	 edi, edx
$LN3@ioSlotMgr@2:

; 68   : 		}
; 69   : 
; 70   : 		SAFEDELETE(m_pSlotItem[i]);

  0003e	8b 10		 mov	 edx, DWORD PTR [eax]
  00040	6a 01		 push	 1
  00042	8b c8		 mov	 ecx, eax
  00044	ff 12		 call	 DWORD PTR [edx]
  00046	83 26 00	 and	 DWORD PTR [esi], 0
$LN6@ioSlotMgr@2:

; 61   : 
; 62   : 	for(int i = 0; i < MAX_SLOT; i++)

  00049	43		 inc	 ebx
  0004a	83 c6 04	 add	 esi, 4
  0004d	83 fb 04	 cmp	 ebx, 4
  00050	7c cd		 jl	 SHORT $LN7@ioSlotMgr@2

; 71   : 	}
; 72   : 
; 73   : 	if( dwSlot != Setting::GetSlotItem())

  00052	3b 3d 9c 00 00
	00		 cmp	 edi, DWORD PTR ?m_Option@Setting@@1USettingOption@@A+156
  00058	74 18		 je	 SHORT $LN1@ioSlotMgr@2

; 74   : 	{
; 75   : 		Setting::SetSlotItem(dwSlot);

  0005a	89 3d 9c 00 00
	00		 mov	 DWORD PTR ?m_Option@Setting@@1USettingOption@@A+156, edi

; 76   : 		Setting::SaveSetting(g_MyInfo.GetPublicID());

  00060	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  00065	83 c0 1c	 add	 eax, 28			; 0000001cH
  00068	6a 00		 push	 0
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 ?SaveSetting@Setting@@SAXABVioHashString@@_N@Z ; Setting::SaveSetting
  00070	59		 pop	 ecx
  00071	59		 pop	 ecx
$LN1@ioSlotMgr@2:

; 77   : 	}
; 78   : }

  00072	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_Singleton@?$Singleton@VioSlotMgr@@@@1PAVioSlotMgr@@A, 0 ; Singleton<ioSlotMgr>::ms_Singleton
  00079	e8 00 00 00 00	 call	 __EH_epilog3
  0007e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1ioSlotMgr@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$Singleton@VioSlotMgr@@@@QAE@XZ ; Singleton<ioSlotMgr>::~Singleton<ioSlotMgr>
__ehhandler$??1ioSlotMgr@@UAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1ioSlotMgr@@UAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1ioSlotMgr@@UAE@XZ ENDP				; ioSlotMgr::~ioSlotMgr
PUBLIC	??_R0?AVioEtcItemRevive@@@8			; ioEtcItemRevive `RTTI Type Descriptor'
PUBLIC	??_R0?AVioEtcItem@@@8				; ioEtcItem `RTTI Type Descriptor'
PUBLIC	??_R0?AVioEtcItemConsumption@@@8		; ioEtcItemConsumption `RTTI Type Descriptor'
PUBLIC	?InitSlot@ioSlotMgr@@QAEXXZ			; ioSlotMgr::InitSlot
EXTRN	?GetEtcItem@ioUserEtcItem@@QAE_NHAAUETCITEMSLOT@1@@Z:PROC ; ioUserEtcItem::GetEtcItem
EXTRN	?GetCurrentConsumptionKey@ioKeyManager@@QAEGH@Z:PROC ; ioKeyManager::GetCurrentConsumptionKey
EXTRN	?GetSingleton@ioKeyManager@@SAAAV1@XZ:PROC	; ioKeyManager::GetSingleton
EXTRN	?FindEtcItem@ioEtcItemManager@@QAEPAVioEtcItem@@K@Z:PROC ; ioEtcItemManager::FindEtcItem
;	COMDAT ??_R0?AVioEtcItemRevive@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioslotmgr.h
_DATA	SEGMENT
??_R0?AVioEtcItemRevive@@@8 DD FLAT:??_7type_info@@6B@	; ioEtcItemRevive `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioEtcItemRevive@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVioEtcItem@@@8
_DATA	SEGMENT
??_R0?AVioEtcItem@@@8 DD FLAT:??_7type_info@@6B@	; ioEtcItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioEtcItem@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVioEtcItemConsumption@@@8
_DATA	SEGMENT
??_R0?AVioEtcItemConsumption@@@8 DD FLAT:??_7type_info@@6B@ ; ioEtcItemConsumption `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioEtcItemConsumption@@', 00H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioslotmgr.cpp
_DATA	ENDS
;	COMDAT ?InitSlot@ioSlotMgr@@QAEXXZ
_TEXT	SEGMENT
_kSlot$505668 = -32					; size = 12
_kSlot$505659 = -20					; size = 12
_dwType$505652 = -8					; size = 4
_i$505648 = -4						; size = 4
?InitSlot@ioSlotMgr@@QAEXXZ PROC			; ioSlotMgr::InitSlot, COMDAT
; _this$ = ecx

; 100  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 101  : 	for(int i = 0; i < MAX_SLOT; i++)

  00008	33 db		 xor	 ebx, ebx
  0000a	57		 push	 edi
  0000b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_??4ioHashString@@QAEAAV0@ABV0@@Z
  00011	89 5d fc	 mov	 DWORD PTR _i$505648[ebp], ebx
  00014	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  00017	eb 02		 jmp	 SHORT $LN12@InitSlot
$LL75@InitSlot:
  00019	33 db		 xor	 ebx, ebx
$LN12@InitSlot:

; 102  : 	{
; 103  : 		DWORD dwType = m_pSlotItem[i]->GetType();

  0001b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0001d	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]

; 104  : 
; 105  : 		if(COMPARE(dwType, ioEtcItem::EIT_ETC_CONSUMPTION_BUFF01, ioEtcItem::EIT_ETC_CONSUMPTION_BUFF64+1))

  00020	8d 90 41 b8 f0
	ff		 lea	 edx, DWORD PTR [eax-1001407]
  00026	89 45 f8	 mov	 DWORD PTR _dwType$505652[ebp], eax
  00029	83 fa 3f	 cmp	 edx, 63			; 0000003fH
  0002c	0f 87 ac 00 00
	00		 ja	 $LN9@InitSlot

; 106  : 		{
; 107  : 			ioEtcItemConsumption *pItem = dynamic_cast< ioEtcItemConsumption * >( g_EtcItemMgr.FindEtcItem(dwType) );

  00032	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_Singleton@?$Singleton@VioEtcItemManager@@@@1PAVioEtcItemManager@@A ; Singleton<ioEtcItemManager>::ms_Singleton
  00038	53		 push	 ebx
  00039	68 00 00 00 00	 push	 OFFSET ??_R0?AVioEtcItemConsumption@@@8
  0003e	68 00 00 00 00	 push	 OFFSET ??_R0?AVioEtcItem@@@8
  00043	53		 push	 ebx
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ?FindEtcItem@ioEtcItemManager@@QAEPAVioEtcItem@@K@Z ; ioEtcItemManager::FindEtcItem
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ___RTDynamicCast
  00050	8b d8		 mov	 ebx, eax
  00052	83 c4 14	 add	 esp, 20			; 00000014H

; 108  : 			if(pItem)

  00055	85 db		 test	 ebx, ebx
  00057	74 53		 je	 SHORT $LN37@InitSlot

; 109  : 			{
; 110  : 				m_pSlotItem[i]->SetCoolTime(pItem->GetCoolTime());

  00059	8b 06		 mov	 eax, DWORD PTR [esi]
  0005b	8b 8b b8 01 00
	00		 mov	 ecx, DWORD PTR [ebx+440]
  00061	89 48 44	 mov	 DWORD PTR [eax+68], ecx

; 111  : 				m_pSlotItem[i]->SetImg(pItem->GetIconImg());

  00064	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00066	8d 83 88 01 00
	00		 lea	 eax, DWORD PTR [ebx+392]
  0006c	50		 push	 eax
  0006d	83 c1 04	 add	 ecx, 4
  00070	ff d7		 call	 edi

; 112  : 				m_pSlotItem[i]->SetBackImg(pItem->GetIconBackImg());

  00072	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00074	8d 83 98 01 00
	00		 lea	 eax, DWORD PTR [ebx+408]
  0007a	50		 push	 eax
  0007b	83 c1 14	 add	 ecx, 20			; 00000014H
  0007e	ff d7		 call	 edi

; 113  : 				m_pSlotItem[i]->SetBuffName(pItem->GetSlotBuff());

  00080	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00082	81 c3 a8 01 00
	00		 add	 ebx, 424		; 000001a8H
  00088	53		 push	 ebx
  00089	83 c1 24	 add	 ecx, 36			; 00000024H
  0008c	ff d7		 call	 edi

; 114  : 				m_pSlotItem[i]->SetKeyName(g_KeyManager.GetCurrentConsumptionKey(i));

  0008e	ff 75 fc	 push	 DWORD PTR _i$505648[ebp]
  00091	e8 00 00 00 00	 call	 ?GetSingleton@ioKeyManager@@SAAAV1@XZ ; ioKeyManager::GetSingleton
  00096	8b c8		 mov	 ecx, eax
  00098	e8 00 00 00 00	 call	 ?GetCurrentConsumptionKey@ioKeyManager@@QAEGH@Z ; ioKeyManager::GetCurrentConsumptionKey
  0009d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0009f	0f b7 c0	 movzx	 eax, ax
  000a2	66 89 41 40	 mov	 WORD PTR [ecx+64], ax

; 115  : 				m_pSlotItem[i]->SetItemNum(0);

  000a6	8b 06		 mov	 eax, DWORD PTR [esi]
  000a8	83 60 3c 00	 and	 DWORD PTR [eax+60], 0
$LN37@InitSlot:

; 116  : 			}
; 117  : 
; 118  : 			ioUserEtcItem *pUserEtcItem = g_MyInfo.GetUserEtcItem();

  000ac	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton

; 119  : 			ioUserEtcItem::ETCITEMSLOT kSlot;

  000b1	33 c9		 xor	 ecx, ecx
  000b3	89 4d ec	 mov	 DWORD PTR _kSlot$505659[ebp], ecx
  000b6	89 4d f0	 mov	 DWORD PTR _kSlot$505659[ebp+4], ecx
  000b9	89 4d f4	 mov	 DWORD PTR _kSlot$505659[ebp+8], ecx

; 120  : 
; 121  : 			if(pUserEtcItem->GetEtcItem( dwType, kSlot ) )

  000bc	8d 4d ec	 lea	 ecx, DWORD PTR _kSlot$505659[ebp]
  000bf	51		 push	 ecx
  000c0	ff 75 f8	 push	 DWORD PTR _dwType$505652[ebp]
  000c3	8d 88 44 01 00
	00		 lea	 ecx, DWORD PTR [eax+324]
  000c9	e8 00 00 00 00	 call	 ?GetEtcItem@ioUserEtcItem@@QAE_NHAAUETCITEMSLOT@1@@Z ; ioUserEtcItem::GetEtcItem
  000ce	84 c0		 test	 al, al
  000d0	0f 84 bc 00 00
	00		 je	 $LN11@InitSlot

; 122  : 				m_pSlotItem[i]->SetItemNum(kSlot.m_iValue1);

  000d6	8b 4d f0	 mov	 ecx, DWORD PTR _kSlot$505659[ebp+4]

; 123  : 		}
; 124  : 		else

  000d9	e9 a4 00 00 00	 jmp	 $LN77@InitSlot
$LN9@InitSlot:

; 125  : 		{
; 126  : 			if(dwType == ioEtcItem::EIT_ETC_CONSUMPTION_REVIVE)

  000de	ba ff 47 0f 00	 mov	 edx, 1001471		; 000f47ffH
  000e3	3b c2		 cmp	 eax, edx
  000e5	0f 85 9e 00 00
	00		 jne	 $LN5@InitSlot

; 127  : 			{
; 128  : 				ioEtcItemRevive *pItem = dynamic_cast< ioEtcItemRevive * >( g_EtcItemMgr.FindEtcItem(dwType) );

  000eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_Singleton@?$Singleton@VioEtcItemManager@@@@1PAVioEtcItemManager@@A ; Singleton<ioEtcItemManager>::ms_Singleton
  000f1	53		 push	 ebx
  000f2	68 00 00 00 00	 push	 OFFSET ??_R0?AVioEtcItemRevive@@@8
  000f7	68 00 00 00 00	 push	 OFFSET ??_R0?AVioEtcItem@@@8
  000fc	53		 push	 ebx
  000fd	52		 push	 edx
  000fe	e8 00 00 00 00	 call	 ?FindEtcItem@ioEtcItemManager@@QAEPAVioEtcItem@@K@Z ; ioEtcItemManager::FindEtcItem
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 ___RTDynamicCast
  00109	8b d8		 mov	 ebx, eax
  0010b	83 c4 14	 add	 esp, 20			; 00000014H

; 129  : 				if(pItem)

  0010e	85 db		 test	 ebx, ebx
  00110	74 45		 je	 SHORT $LN71@InitSlot

; 130  : 				{
; 131  : 					m_pSlotItem[i]->SetCoolTime(pItem->GetCoolTime());

  00112	8b 06		 mov	 eax, DWORD PTR [esi]
  00114	8b 8b b8 01 00
	00		 mov	 ecx, DWORD PTR [ebx+440]
  0011a	89 48 44	 mov	 DWORD PTR [eax+68], ecx

; 132  : 					m_pSlotItem[i]->SetImg(pItem->GetIconImg());

  0011d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0011f	8d 83 88 01 00
	00		 lea	 eax, DWORD PTR [ebx+392]
  00125	50		 push	 eax
  00126	83 c1 04	 add	 ecx, 4
  00129	ff d7		 call	 edi

; 133  : 					m_pSlotItem[i]->SetBackImg(pItem->GetIconBackImg());

  0012b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0012d	81 c3 98 01 00
	00		 add	 ebx, 408		; 00000198H
  00133	53		 push	 ebx
  00134	83 c1 14	 add	 ecx, 20			; 00000014H
  00137	ff d7		 call	 edi

; 134  : 					m_pSlotItem[i]->SetKeyName(g_KeyManager.GetCurrentConsumptionKey(i));

  00139	ff 75 fc	 push	 DWORD PTR _i$505648[ebp]
  0013c	e8 00 00 00 00	 call	 ?GetSingleton@ioKeyManager@@SAAAV1@XZ ; ioKeyManager::GetSingleton
  00141	8b c8		 mov	 ecx, eax
  00143	e8 00 00 00 00	 call	 ?GetCurrentConsumptionKey@ioKeyManager@@QAEGH@Z ; ioKeyManager::GetCurrentConsumptionKey
  00148	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0014a	0f b7 c0	 movzx	 eax, ax
  0014d	66 89 41 40	 mov	 WORD PTR [ecx+64], ax

; 135  : 					m_pSlotItem[i]->SetItemNum(0);

  00151	8b 06		 mov	 eax, DWORD PTR [esi]
  00153	83 60 3c 00	 and	 DWORD PTR [eax+60], 0
$LN71@InitSlot:

; 136  : 				}
; 137  : 
; 138  : 				ioUserEtcItem *pUserEtcItem = g_MyInfo.GetUserEtcItem();

  00157	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton

; 139  : 				ioUserEtcItem::ETCITEMSLOT kSlot;

  0015c	33 c9		 xor	 ecx, ecx
  0015e	89 4d e0	 mov	 DWORD PTR _kSlot$505668[ebp], ecx
  00161	89 4d e4	 mov	 DWORD PTR _kSlot$505668[ebp+4], ecx
  00164	89 4d e8	 mov	 DWORD PTR _kSlot$505668[ebp+8], ecx

; 140  : 
; 141  : 				if(pUserEtcItem->GetEtcItem( dwType, kSlot ) )

  00167	8d 4d e0	 lea	 ecx, DWORD PTR _kSlot$505668[ebp]
  0016a	51		 push	 ecx
  0016b	68 ff 47 0f 00	 push	 1001471			; 000f47ffH
  00170	8d 88 44 01 00
	00		 lea	 ecx, DWORD PTR [eax+324]
  00176	e8 00 00 00 00	 call	 ?GetEtcItem@ioUserEtcItem@@QAE_NHAAUETCITEMSLOT@1@@Z ; ioUserEtcItem::GetEtcItem
  0017b	84 c0		 test	 al, al
  0017d	74 13		 je	 SHORT $LN11@InitSlot

; 142  : 					m_pSlotItem[i]->SetItemNum(kSlot.m_iValue1);

  0017f	8b 4d e4	 mov	 ecx, DWORD PTR _kSlot$505668[ebp+4]
$LN77@InitSlot:
  00182	8b 06		 mov	 eax, DWORD PTR [esi]
  00184	89 48 3c	 mov	 DWORD PTR [eax+60], ecx

; 143  : 			}

  00187	eb 09		 jmp	 SHORT $LN11@InitSlot
$LN5@InitSlot:

; 144  : 			else if( dwType == ioEtcItem::EIT_NONE)

  00189	3b c3		 cmp	 eax, ebx
  0018b	75 05		 jne	 SHORT $LN11@InitSlot

; 145  : 			{
; 146  : 				m_pSlotItem[i]->ResetItem();

  0018d	e8 00 00 00 00	 call	 ?ResetItem@ioSlotItem@@QAEXXZ ; ioSlotItem::ResetItem
$LN11@InitSlot:

; 101  : 	for(int i = 0; i < MAX_SLOT; i++)

  00192	ff 45 fc	 inc	 DWORD PTR _i$505648[ebp]
  00195	83 c6 04	 add	 esi, 4
  00198	83 7d fc 04	 cmp	 DWORD PTR _i$505648[ebp], 4
  0019c	0f 8c 77 fe ff
	ff		 jl	 $LL75@InitSlot
  001a2	5f		 pop	 edi
  001a3	5e		 pop	 esi
  001a4	5b		 pop	 ebx

; 147  : 			}
; 148  : 		}
; 149  : 	}
; 150  : }

  001a5	c9		 leave
  001a6	c3		 ret	 0
?InitSlot@ioSlotMgr@@QAEXXZ ENDP			; ioSlotMgr::InitSlot
_TEXT	ENDS
PUBLIC	?UseItem@ioSlotMgr@@QAEHK@Z			; ioSlotMgr::UseItem
EXTRN	?SendUse@ioUserEtcItem@@QAEXH@Z:PROC		; ioUserEtcItem::SendUse
EXTRN	?IsCanUse@ioUserEtcItem@@QAE_NH@Z:PROC		; ioUserEtcItem::IsCanUse
; Function compile flags: /Ogsp
;	COMDAT ?UseItem@ioSlotMgr@@QAEHK@Z
_TEXT	SEGMENT
_kSlot$ = -12						; size = 12
_dwType$ = 8						; size = 4
?UseItem@ioSlotMgr@@QAEHK@Z PROC			; ioSlotMgr::UseItem, COMDAT
; _this$ = ecx

; 158  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	57		 push	 edi

; 159  : 	ioSlotItem* pItem = GetSlot(dwType);

  00008	ff 75 08	 push	 DWORD PTR _dwType$[ebp]
  0000b	e8 00 00 00 00	 call	 ?GetSlot@ioSlotMgr@@QAEPAVioSlotItem@@K@Z ; ioSlotMgr::GetSlot
  00010	8b f8		 mov	 edi, eax

; 160  : 
; 161  : 	if(!pItem) return 1;

  00012	33 db		 xor	 ebx, ebx
  00014	3b fb		 cmp	 edi, ebx
  00016	75 05		 jne	 SHORT $LN6@UseItem
  00018	33 c0		 xor	 eax, eax
  0001a	40		 inc	 eax
  0001b	eb 60		 jmp	 SHORT $LN7@UseItem
$LN6@UseItem:

; 162  : 
; 163  : 	if(pItem->GetCountItem() < 1)

  0001d	83 7f 3c 01	 cmp	 DWORD PTR [edi+60], 1
  00021	7d 05		 jge	 SHORT $LN5@UseItem

; 164  : 		return 2;

  00023	6a 02		 push	 2
$LN18@UseItem:
  00025	58		 pop	 eax
  00026	eb 55		 jmp	 SHORT $LN7@UseItem
$LN5@UseItem:

; 165  : 
; 166  : 	if(pItem->IsCoolTime())

  00028	8b cf		 mov	 ecx, edi
  0002a	e8 00 00 00 00	 call	 ?IsCoolTime@ioSlotItem@@QAE_NXZ ; ioSlotItem::IsCoolTime
  0002f	84 c0		 test	 al, al
  00031	74 04		 je	 SHORT $LN4@UseItem

; 167  : 		return 3;

  00033	6a 03		 push	 3
  00035	eb ee		 jmp	 SHORT $LN18@UseItem
$LN4@UseItem:
  00037	56		 push	 esi

; 168  : 
; 169  : 	ioUserEtcItem *pUserEtcItem = g_MyInfo.GetUserEtcItem();

  00038	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  0003d	8d b0 44 01 00
	00		 lea	 esi, DWORD PTR [eax+324]

; 170  : 	ioUserEtcItem::ETCITEMSLOT kSlot;
; 171  : 
; 172  : 	int nType = pItem->GetType();
; 173  : 	if( pUserEtcItem->GetEtcItem(nType, kSlot ) )   

  00043	8d 45 f4	 lea	 eax, DWORD PTR _kSlot$[ebp]
  00046	89 5d f4	 mov	 DWORD PTR _kSlot$[ebp], ebx
  00049	89 5d f8	 mov	 DWORD PTR _kSlot$[ebp+4], ebx
  0004c	89 5d fc	 mov	 DWORD PTR _kSlot$[ebp+8], ebx
  0004f	8b 5f 38	 mov	 ebx, DWORD PTR [edi+56]
  00052	50		 push	 eax
  00053	53		 push	 ebx
  00054	8b ce		 mov	 ecx, esi
  00056	e8 00 00 00 00	 call	 ?GetEtcItem@ioUserEtcItem@@QAE_NHAAUETCITEMSLOT@1@@Z ; ioUserEtcItem::GetEtcItem
  0005b	84 c0		 test	 al, al
  0005d	74 1b		 je	 SHORT $LN1@UseItem

; 174  : 	{
; 175  : 		if(pUserEtcItem->IsCanUse(nType) )

  0005f	53		 push	 ebx
  00060	8b ce		 mov	 ecx, esi
  00062	e8 00 00 00 00	 call	 ?IsCanUse@ioUserEtcItem@@QAE_NH@Z ; ioUserEtcItem::IsCanUse
  00067	84 c0		 test	 al, al
  00069	74 18		 je	 SHORT $LN2@UseItem

; 176  : 		{
; 177  : 			pUserEtcItem->SendUse(nType);

  0006b	53		 push	 ebx
  0006c	8b ce		 mov	 ecx, esi
  0006e	e8 00 00 00 00	 call	 ?SendUse@ioUserEtcItem@@QAEXH@Z ; ioUserEtcItem::SendUse

; 178  : 			pItem->SetCoolTime();

  00073	8b cf		 mov	 ecx, edi
  00075	e8 00 00 00 00	 call	 ?SetCoolTime@ioSlotItem@@QAEXXZ ; ioSlotItem::SetCoolTime
$LN1@UseItem:

; 184  : 		}
; 185  : 	}
; 186  : 
; 187  : 	return 0;

  0007a	33 c0		 xor	 eax, eax
$LN17@UseItem:
  0007c	5e		 pop	 esi
$LN7@UseItem:
  0007d	5f		 pop	 edi
  0007e	5b		 pop	 ebx

; 188  : }

  0007f	c9		 leave
  00080	c2 04 00	 ret	 4
$LN2@UseItem:

; 179  : 			return 0;
; 180  : 		}
; 181  : 		else
; 182  : 		{
; 183  : 			return 2;

  00083	6a 02		 push	 2
  00085	58		 pop	 eax
  00086	eb f4		 jmp	 SHORT $LN17@UseItem
?UseItem@ioSlotMgr@@QAEHK@Z ENDP			; ioSlotMgr::UseItem
_TEXT	ENDS
PUBLIC	?UpdateItem@ioSlotMgr@@QAEXK@Z			; ioSlotMgr::UpdateItem
EXTRN	?UpdateSlotItem@TowerDefWnd@@QAEXH@Z:PROC	; TowerDefWnd::UpdateSlotItem
; Function compile flags: /Ogsp
;	COMDAT ?UpdateItem@ioSlotMgr@@QAEXK@Z
_TEXT	SEGMENT
_kSlot$ = -12						; size = 12
_dwType$ = 8						; size = 4
?UpdateItem@ioSlotMgr@@QAEXK@Z PROC			; ioSlotMgr::UpdateItem, COMDAT
; _this$ = ecx

; 191  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi

; 192  : 	ioSlotItem* pItem = GetSlot(dwType);

  00008	ff 75 08	 push	 DWORD PTR _dwType$[ebp]
  0000b	e8 00 00 00 00	 call	 ?GetSlot@ioSlotMgr@@QAEPAVioSlotItem@@K@Z ; ioSlotMgr::GetSlot
  00010	8b f0		 mov	 esi, eax

; 193  : 
; 194  : 	if(!pItem) return;

  00012	33 ff		 xor	 edi, edi
  00014	3b f7		 cmp	 esi, edi
  00016	74 72		 je	 SHORT $LN1@UpdateItem

; 195  : 
; 196  : 	ioUserEtcItem *pUserEtcItem = g_MyInfo.GetUserEtcItem();

  00018	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton

; 197  : 	ioUserEtcItem::ETCITEMSLOT kSlot;
; 198  : 
; 199  : 	if(pUserEtcItem->GetEtcItem(dwType, kSlot ))

  0001d	8d 4d f4	 lea	 ecx, DWORD PTR _kSlot$[ebp]
  00020	51		 push	 ecx
  00021	ff 75 08	 push	 DWORD PTR _dwType$[ebp]
  00024	8d 88 44 01 00
	00		 lea	 ecx, DWORD PTR [eax+324]
  0002a	89 7d f4	 mov	 DWORD PTR _kSlot$[ebp], edi
  0002d	89 7d f8	 mov	 DWORD PTR _kSlot$[ebp+4], edi
  00030	89 7d fc	 mov	 DWORD PTR _kSlot$[ebp+8], edi
  00033	e8 00 00 00 00	 call	 ?GetEtcItem@ioUserEtcItem@@QAE_NHAAUETCITEMSLOT@1@@Z ; ioUserEtcItem::GetEtcItem
  00038	84 c0		 test	 al, al
  0003a	74 19		 je	 SHORT $LN14@UpdateItem

; 200  : 	{
; 201  : 		pItem->SetItemNum(kSlot.m_iValue1);

  0003c	8b 45 f8	 mov	 eax, DWORD PTR _kSlot$[ebp+4]

; 202  : 		pItem->SetKeyName(g_KeyManager.GetCurrentConsumptionKey(pItem->GetMySlot()));

  0003f	ff 76 34	 push	 DWORD PTR [esi+52]
  00042	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  00045	e8 00 00 00 00	 call	 ?GetSingleton@ioKeyManager@@SAAAV1@XZ ; ioKeyManager::GetSingleton
  0004a	8b c8		 mov	 ecx, eax
  0004c	e8 00 00 00 00	 call	 ?GetCurrentConsumptionKey@ioKeyManager@@QAEGH@Z ; ioKeyManager::GetCurrentConsumptionKey
  00051	66 89 46 40	 mov	 WORD PTR [esi+64], ax
$LN14@UpdateItem:

; 203  : 	}
; 204  : 
; 205  : 	TowerDefWnd *pTowerWnd = dynamic_cast< TowerDefWnd * >( g_GUIMgr.FindWnd(TOWERDEF_USER_GAUGE_WND));

  00055	57		 push	 edi
  00056	68 00 00 00 00	 push	 OFFSET ??_R0?AVTowerDefWnd@@@8
  0005b	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWnd@@@8
  00060	57		 push	 edi
  00061	68 d4 13 00 00	 push	 5076			; 000013d4H
  00066	e8 00 00 00 00	 call	 ?GetSingleton@ioSP2GUIManager@@SAAAV1@XZ ; ioSP2GUIManager::GetSingleton
  0006b	8b c8		 mov	 ecx, eax
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?FindWnd@ioGUIManager@@QAEPAVioWnd@@K@Z
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ___RTDynamicCast
  00079	83 c4 14	 add	 esp, 20			; 00000014H

; 206  : 	if(pTowerWnd)

  0007c	3b c7		 cmp	 eax, edi
  0007e	74 0a		 je	 SHORT $LN1@UpdateItem

; 207  : 		pTowerWnd->UpdateSlotItem(pItem->GetMySlot());

  00080	ff 76 34	 push	 DWORD PTR [esi+52]
  00083	8b c8		 mov	 ecx, eax
  00085	e8 00 00 00 00	 call	 ?UpdateSlotItem@TowerDefWnd@@QAEXH@Z ; TowerDefWnd::UpdateSlotItem
$LN1@UpdateItem:
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi

; 208  : }

  0008c	c9		 leave
  0008d	c2 04 00	 ret	 4
?UpdateItem@ioSlotMgr@@QAEXK@Z ENDP			; ioSlotMgr::UpdateItem
_TEXT	ENDS
PUBLIC	?UpdateAllItem@ioSlotMgr@@QAEXXZ		; ioSlotMgr::UpdateAllItem
; Function compile flags: /Ogsp
;	COMDAT ?UpdateAllItem@ioSlotMgr@@QAEXXZ
_TEXT	SEGMENT
?UpdateAllItem@ioSlotMgr@@QAEXXZ PROC			; ioSlotMgr::UpdateAllItem, COMDAT
; _this$ = ecx

; 211  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx

; 212  : 	for(int i = 0; i < MAX_SLOT; i++)

  00005	6a 04		 push	 4
  00007	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  0000a	5b		 pop	 ebx
$LL3@UpdateAllI:

; 213  : 		UpdateItem(m_pSlotItem[i]->GetType());

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	ff 70 38	 push	 DWORD PTR [eax+56]
  00010	8b cf		 mov	 ecx, edi
  00012	e8 00 00 00 00	 call	 ?UpdateItem@ioSlotMgr@@QAEXK@Z ; ioSlotMgr::UpdateItem
  00017	83 c6 04	 add	 esi, 4
  0001a	4b		 dec	 ebx
  0001b	75 ee		 jne	 SHORT $LL3@UpdateAllI

; 214  : }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	c3		 ret	 0
?UpdateAllItem@ioSlotMgr@@QAEXXZ ENDP			; ioSlotMgr::UpdateAllItem
_TEXT	ENDS
PUBLIC	?GetSlot@ioSlotMgr@@QAEPAVioSlotItem@@H@Z	; ioSlotMgr::GetSlot
; Function compile flags: /Ogsp
;	COMDAT ?GetSlot@ioSlotMgr@@QAEPAVioSlotItem@@H@Z
_TEXT	SEGMENT
_nSlot$ = 8						; size = 4
?GetSlot@ioSlotMgr@@QAEPAVioSlotItem@@H@Z PROC		; ioSlotMgr::GetSlot, COMDAT
; _this$ = ecx

; 224  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 225  : 	return GetSlot(m_pSlotItem[nSlot]->GetType());

  00003	8b 45 08	 mov	 eax, DWORD PTR _nSlot$[ebp]
  00006	8b 44 81 04	 mov	 eax, DWORD PTR [ecx+eax*4+4]
  0000a	ff 70 38	 push	 DWORD PTR [eax+56]
  0000d	e8 00 00 00 00	 call	 ?GetSlot@ioSlotMgr@@QAEPAVioSlotItem@@K@Z ; ioSlotMgr::GetSlot

; 226  : }

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?GetSlot@ioSlotMgr@@QAEPAVioSlotItem@@H@Z ENDP		; ioSlotMgr::GetSlot
_TEXT	ENDS
PUBLIC	?IsCoolTime@ioSlotMgr@@QAE_NH@Z			; ioSlotMgr::IsCoolTime
; Function compile flags: /Ogsp
;	COMDAT ?IsCoolTime@ioSlotMgr@@QAE_NH@Z
_TEXT	SEGMENT
_nSlot$ = 8						; size = 4
?IsCoolTime@ioSlotMgr@@QAE_NH@Z PROC			; ioSlotMgr::IsCoolTime, COMDAT
; _this$ = ecx

; 240  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 241  : 	return m_pSlotItem[nSlot]->IsCoolTime();

  00003	8b 45 08	 mov	 eax, DWORD PTR _nSlot$[ebp]
  00006	8b 4c 81 04	 mov	 ecx, DWORD PTR [ecx+eax*4+4]
  0000a	e8 00 00 00 00	 call	 ?IsCoolTime@ioSlotItem@@QAE_NXZ ; ioSlotItem::IsCoolTime

; 242  : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?IsCoolTime@ioSlotMgr@@QAE_NH@Z ENDP			; ioSlotMgr::IsCoolTime
_TEXT	ENDS
PUBLIC	?GetSingleton@ioSlotMgr@@SAAAV1@XZ		; ioSlotMgr::GetSingleton
; Function compile flags: /Ogsp
;	COMDAT ?GetSingleton@ioSlotMgr@@SAAAV1@XZ
_TEXT	SEGMENT
?GetSingleton@ioSlotMgr@@SAAAV1@XZ PROC			; ioSlotMgr::GetSingleton, COMDAT

; 277  : 	return Singleton<ioSlotMgr>::GetSingleton();

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_Singleton@?$Singleton@VioSlotMgr@@@@1PAVioSlotMgr@@A ; Singleton<ioSlotMgr>::ms_Singleton

; 278  : }

  00005	c3		 ret	 0
?GetSingleton@ioSlotMgr@@SAAAV1@XZ ENDP			; ioSlotMgr::GetSingleton
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??_GioSlotItem@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GioSlotItem@@UAEPAXI@Z PROC				; ioSlotItem::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1ioSlotItem@@UAE@XZ	; ioSlotItem::~ioSlotItem
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 07		 je	 SHORT $LN1@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	59		 pop	 ecx
$LN1@scalar:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??_GioSlotItem@@UAEPAXI@Z ENDP				; ioSlotItem::`scalar deleting destructor'
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??_GioSlotMgr@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GioSlotMgr@@UAEPAXI@Z PROC				; ioSlotMgr::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1ioSlotMgr@@UAE@XZ	; ioSlotMgr::~ioSlotMgr
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 07		 je	 SHORT $LN1@scalar@2
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	59		 pop	 ecx
$LN1@scalar@2:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??_GioSlotMgr@@UAEPAXI@Z ENDP				; ioSlotMgr::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?UseItem@ioSlotMgr@@QAEHH@Z			; ioSlotMgr::UseItem
; Function compile flags: /Ogsp
;	COMDAT ?UseItem@ioSlotMgr@@QAEHH@Z
_TEXT	SEGMENT
_nSlot$ = 8						; size = 4
?UseItem@ioSlotMgr@@QAEHH@Z PROC			; ioSlotMgr::UseItem, COMDAT
; _this$ = ecx

; 153  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 154  : 	return UseItem(m_pSlotItem[nSlot]->GetType());

  00003	8b 45 08	 mov	 eax, DWORD PTR _nSlot$[ebp]
  00006	8b 44 81 04	 mov	 eax, DWORD PTR [ecx+eax*4+4]
  0000a	ff 70 38	 push	 DWORD PTR [eax+56]
  0000d	e8 00 00 00 00	 call	 ?UseItem@ioSlotMgr@@QAEHK@Z ; ioSlotMgr::UseItem

; 155  : }

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?UseItem@ioSlotMgr@@QAEHH@Z ENDP			; ioSlotMgr::UseItem
_TEXT	ENDS
END
