; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\Lost Saga For Developer\Youtube\Tutorial\Source\src\LSClient\ioCreateDummyByAttackedBuff2.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_EEM_DS@?$deque@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@2HB ; std::deque<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_EEM_DS
;	COMDAT ?_EEM_DS@?$deque@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@2HB
CONST	SEGMENT
?_EEM_DS@?$deque@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@2HB DD 01H ; std::deque<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_EEM_DS
CONST	ENDS
PUBLIC	?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ	; ioBaseChar::GetCharName
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasechar.h
;	COMDAT ?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ
_TEXT	SEGMENT
?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ PROC	; ioBaseChar::GetCharName, COMDAT
; _this$ = ecx

; 2594 : 	inline const ioHashString& GetCharName() const { return m_Name; }

  00000	8d 81 d4 02 00
	00		 lea	 eax, DWORD PTR [ecx+724]
  00006	c3		 ret	 0
?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ ENDP	; ioBaseChar::GetCharName
_TEXT	ENDS
PUBLIC	?GetTargetRot@ioBaseChar@@QBEABUD3DXQUATERNION@@XZ ; ioBaseChar::GetTargetRot
; Function compile flags: /Ogsp
;	COMDAT ?GetTargetRot@ioBaseChar@@QBEABUD3DXQUATERNION@@XZ
_TEXT	SEGMENT
?GetTargetRot@ioBaseChar@@QBEABUD3DXQUATERNION@@XZ PROC	; ioBaseChar::GetTargetRot, COMDAT
; _this$ = ecx

; 2599 : 	inline const D3DXQUATERNION& GetTargetRot() const { return m_qtTargetRot; }

  00000	8d 81 a4 06 00
	00		 lea	 eax, DWORD PTR [ecx+1700]
  00006	c3		 ret	 0
?GetTargetRot@ioBaseChar@@QBEABUD3DXQUATERNION@@XZ ENDP	; ioBaseChar::GetTargetRot
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
  00010	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00016	8b c6		 mov	 eax, esi
  00018	5e		 pop	 esi
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogsp
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1exception@std@@UAE@XZ
  00012	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00016	74 07		 je	 SHORT $LN1@scalar
  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001e	59		 pop	 ecx
$LN1@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 56   : 	{	// construct array with placement at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : 	return (_Where);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 58   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogsp
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 62   : 	}

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?GetCreator@ioBaseChar@@QAEPAVioPlayStage@@XZ	; ioBaseChar::GetCreator
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasechar.h
;	COMDAT ?GetCreator@ioBaseChar@@QAEPAVioPlayStage@@XZ
_TEXT	SEGMENT
?GetCreator@ioBaseChar@@QAEPAVioPlayStage@@XZ PROC	; ioBaseChar::GetCreator, COMDAT
; _this$ = ecx

; 4013 : 	inline ioPlayStage* GetCreator() { return m_pCreator; }

  00000	8b 81 44 03 00
	00		 mov	 eax, DWORD PTR [ecx+836]
  00006	c3		 ret	 0
?GetCreator@ioBaseChar@@QAEPAVioPlayStage@@XZ ENDP	; ioBaseChar::GetCreator
_TEXT	ENDS
PUBLIC	?StartBuff@ioCreateDummyByAttackedBuff2@@UAEXPAVioBaseChar@@@Z ; ioCreateDummyByAttackedBuff2::StartBuff
EXTRN	?StartBuff@ioBuff@@UAEXPAVioBaseChar@@@Z:PROC	; ioBuff::StartBuff
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iocreatedummybyattackedbuff2.cpp
;	COMDAT ?StartBuff@ioCreateDummyByAttackedBuff2@@UAEXPAVioBaseChar@@@Z
_TEXT	SEGMENT
_pOwner$ = 8						; size = 4
?StartBuff@ioCreateDummyByAttackedBuff2@@UAEXPAVioBaseChar@@@Z PROC ; ioCreateDummyByAttackedBuff2::StartBuff, COMDAT
; _this$ = ecx

; 38   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 40   : }

  00003	5d		 pop	 ebp

; 39   : 	ioBuff::StartBuff( pOwner );

  00004	e9 00 00 00 00	 jmp	 ?StartBuff@ioBuff@@UAEXPAVioBaseChar@@@Z ; ioBuff::StartBuff
?StartBuff@ioCreateDummyByAttackedBuff2@@UAEXPAVioBaseChar@@@Z ENDP ; ioCreateDummyByAttackedBuff2::StartBuff
_TEXT	ENDS
PUBLIC	?ProcessBuff@ioCreateDummyByAttackedBuff2@@UAEXM@Z ; ioCreateDummyByAttackedBuff2::ProcessBuff
EXTRN	?ProcessBuff@ioBuff@@UAEXM@Z:PROC		; ioBuff::ProcessBuff
EXTRN	__fltused:DWORD
; Function compile flags: /Ogsp
;	COMDAT ?ProcessBuff@ioCreateDummyByAttackedBuff2@@UAEXM@Z
_TEXT	SEGMENT
_fTimePerSec$ = 8					; size = 4
?ProcessBuff@ioCreateDummyByAttackedBuff2@@UAEXM@Z PROC	; ioCreateDummyByAttackedBuff2::ProcessBuff, COMDAT
; _this$ = ecx

; 43   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 	ioBuff::ProcessBuff( fTimePerSec );

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fTimePerSec$[ebp]
  00008	51		 push	 ecx
  00009	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0000e	e8 00 00 00 00	 call	 ?ProcessBuff@ioBuff@@UAEXM@Z ; ioBuff::ProcessBuff

; 45   : }

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?ProcessBuff@ioCreateDummyByAttackedBuff2@@UAEXM@Z ENDP	; ioCreateDummyByAttackedBuff2::ProcessBuff
_TEXT	ENDS
PUBLIC	?size@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QBEIXZ ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::size
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?size@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	6a 1c		 push	 28			; 0000001cH
  00007	99		 cdq
  00008	59		 pop	 ecx
  00009	f7 f9		 idiv	 ecx

; 880  : 		}

  0000b	c3		 ret	 0
?size@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::size
_TEXT	ENDS
PUBLIC	?empty@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QBE_NXZ ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::empty
; Function compile flags: /Ogsp
;	COMDAT ?empty@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QBE_NXZ PROC ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::empty, COMDAT
; _this$ = ecx

; 889  : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00005	f7 d8		 neg	 eax
  00007	1b c0		 sbb	 eax, eax
  00009	40		 inc	 eax

; 890  : 		}

  0000a	c3		 ret	 0
?empty@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QBE_NXZ ENDP ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::empty
_TEXT	ENDS
PUBLIC	??A?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAEAAUtagDummyCharLoadInfo@@I@Z ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::operator[]
; Function compile flags: /Ogsp
;	COMDAT ??A?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAEAAUtagDummyCharLoadInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAEAAUtagDummyCharLoadInfo@@I@Z PROC ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00006	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00009	03 01		 add	 eax, DWORD PTR [ecx]

; 941  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAEAAUtagDummyCharLoadInfo@@I@Z ENDP ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::operator[]
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 49   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@IBEXXZ ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::_Xlen
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@IBEXXZ PROC ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::_Xlen, COMDAT
; _this$ = ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
  0000b	cc		 int	 3
?_Xlen@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@IBEXXZ ENDP ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::_Xlen
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UtagDummyCharLoadInfo@@@std@@QBEIXZ ; std::allocator<tagDummyCharLoadInfo>::max_size
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@UtagDummyCharLoadInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UtagDummyCharLoadInfo@@@std@@QBEIXZ PROC ; std::allocator<tagDummyCharLoadInfo>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UtagDummyCharLoadInfo@@@std@@QBEIXZ ENDP ; std::allocator<tagDummyCharLoadInfo>::max_size
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@UtagDummyCharLoadInfo@@@std@@YAPAUtagDummyCharLoadInfo@@IPAU1@@Z ; std::_Allocate<tagDummyCharLoadInfo>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@UtagDummyCharLoadInfo@@@std@@YAPAUtagDummyCharLoadInfo@@IPAU1@@Z
_TEXT	SEGMENT
$T531408 = -12						; size = 12
$T531413 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UtagDummyCharLoadInfo@@@std@@YAPAUtagDummyCharLoadInfo@@IPAU1@@Z PROC ; std::_Allocate<tagDummyCharLoadInfo>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 3c		 je	 SHORT $LN5@Allocate

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 49 92 24
	09		 cmp	 ecx, 153391689		; 09249249H
  00015	77 0e		 ja	 SHORT $LN1@Allocate
  00017	6b c9 1c	 imul	 ecx, 28			; 0000001cH
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00020	59		 pop	 ecx
  00021	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00023	75 26		 jne	 SHORT $LN5@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00025	83 65 08 00	 and	 DWORD PTR $T531413[ebp], 0
  00029	8d 45 08	 lea	 eax, DWORD PTR $T531413[ebp]
  0002c	50		 push	 eax
  0002d	8d 4d f4	 lea	 ecx, DWORD PTR $T531408[ebp]
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
  00036	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003b	8d 45 f4	 lea	 eax, DWORD PTR $T531408[ebp]
  0003e	50		 push	 eax
  0003f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T531408[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00046	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate:
$LN5@Allocate:

; 40   : 	}

  0004b	c9		 leave
  0004c	c3		 ret	 0
$LN9@Allocate:
??$_Allocate@UtagDummyCharLoadInfo@@@std@@YAPAUtagDummyCharLoadInfo@@IPAU1@@Z ENDP ; std::_Allocate<tagDummyCharLoadInfo>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@PAUtagDummyCharLoadInfo@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@0@AAPAUtagDummyCharLoadInfo@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >,tagDummyCharLoadInfo *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@PAUtagDummyCharLoadInfo@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@0@AAPAUtagDummyCharLoadInfo@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@PAUtagDummyCharLoadInfo@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@0@AAPAUtagDummyCharLoadInfo@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >,tagDummyCharLoadInfo *>, COMDAT

; 485  : 	{	// return pointer category from arbitrary arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 486  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 487  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 488  : 	}

  00007	c9		 leave
  00008	c3		 ret	 0
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@PAUtagDummyCharLoadInfo@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@0@AAPAUtagDummyCharLoadInfo@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >,tagDummyCharLoadInfo *>
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@QBEABUtagDummyCharLoadInfo@@XZ ; std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >::operator*
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@QBEABUtagDummyCharLoadInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@QBEABUtagDummyCharLoadInfo@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >::operator*, COMDAT
; _this$ = ecx

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);
; 83   : 
; 84   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 85   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@QBEABUtagDummyCharLoadInfo@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >::operator++
; Function compile flags: /Ogsp
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >::operator++, COMDAT
; _this$ = ecx

; 93   : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

  00002	83 00 1c	 add	 DWORD PTR [eax], 28	; 0000001cH

; 111  : 		return (*this);
; 112  : 		}

  00005	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >::operator++
_TEXT	ENDS
PUBLIC	??$forward@ABUtagDummyCharLoadInfo@@@std@@YAABUtagDummyCharLoadInfo@@ABU1@@Z ; std::forward<tagDummyCharLoadInfo const &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABUtagDummyCharLoadInfo@@@std@@YAABUtagDummyCharLoadInfo@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUtagDummyCharLoadInfo@@@std@@YAABUtagDummyCharLoadInfo@@ABU1@@Z PROC ; std::forward<tagDummyCharLoadInfo const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUtagDummyCharLoadInfo@@@std@@YAABUtagDummyCharLoadInfo@@ABU1@@Z ENDP ; std::forward<tagDummyCharLoadInfo const &>
_TEXT	ENDS
PUBLIC	??0tagDummyCharLoadInfo@@QAE@ABU0@@Z		; tagDummyCharLoadInfo::tagDummyCharLoadInfo
EXTRN	__imp_??0ioHashString@@QAE@ABV0@@Z:PROC
; Function compile flags: /Ogsp
;	COMDAT ??0tagDummyCharLoadInfo@@QAE@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0tagDummyCharLoadInfo@@QAE@ABU0@@Z PROC		; tagDummyCharLoadInfo::tagDummyCharLoadInfo, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  00011	d9 47 10	 fld	 DWORD PTR [edi+16]
  00014	d9 5e 10	 fstp	 DWORD PTR [esi+16]
  00017	8b c6		 mov	 eax, esi
  00019	d9 47 14	 fld	 DWORD PTR [edi+20]
  0001c	d9 5e 14	 fstp	 DWORD PTR [esi+20]
  0001f	d9 47 18	 fld	 DWORD PTR [edi+24]
  00022	5f		 pop	 edi
  00023	d9 5e 18	 fstp	 DWORD PTR [esi+24]
  00026	5e		 pop	 esi
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??0tagDummyCharLoadInfo@@QAE@ABU0@@Z ENDP		; tagDummyCharLoadInfo::tagDummyCharLoadInfo
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx9math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR3@@QAE@XZ PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 165  :     D3DXVECTOR3() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx9math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 303  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 304  :     x = fx;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00008	8b c1		 mov	 eax, ecx
  0000a	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 305  :     y = fy;

  0000e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00013	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 306  :     z = fz;

  00018	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0001d	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 307  : }

  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
PUBLIC	??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z			; D3DXVECTOR3::operator+=
; Function compile flags: /Ogsp
;	COMDAT ??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z PROC			; D3DXVECTOR3::operator+=, COMDAT
; _this$ = ecx

; 327  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 328  :     x += v.x;

  00005	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00008	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0000c	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  00010	0f 5a c0	 cvtps2pd xmm0, xmm0
  00013	0f 5a c9	 cvtps2pd xmm1, xmm1
  00016	f2 0f 58 c1	 addsd	 xmm0, xmm1

; 329  :     y += v.y;

  0001a	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  0001f	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00023	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00027	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0002c	0f 5a c0	 cvtps2pd xmm0, xmm0
  0002f	0f 5a c9	 cvtps2pd xmm1, xmm1
  00032	f2 0f 58 c1	 addsd	 xmm0, xmm1

; 330  :     z += v.z;

  00036	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  0003b	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0003f	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  00044	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00049	0f 5a c0	 cvtps2pd xmm0, xmm0
  0004c	0f 5a c9	 cvtps2pd xmm1, xmm1
  0004f	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00053	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00057	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 331  :     return *this;
; 332  : }

  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator+=
_TEXT	ENDS
PUBLIC	??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z			; D3DXVECTOR3::operator+
; Function compile flags: /Ogsp
;	COMDAT ??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z PROC			; D3DXVECTOR3::operator+, COMDAT
; _this$ = ecx

; 380  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 381  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00006	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  0000a	f3 0f 10 09	 movss	 xmm1, DWORD PTR [ecx]
  0000e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00011	0f 5a c0	 cvtps2pd xmm0, xmm0
  00014	0f 5a c9	 cvtps2pd xmm1, xmm1
  00017	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0001b	f3 0f 10 49 04	 movss	 xmm1, DWORD PTR [ecx+4]
  00020	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00024	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00028	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [edx+4]
  0002d	0f 5a c0	 cvtps2pd xmm0, xmm0
  00030	0f 5a c9	 cvtps2pd xmm1, xmm1
  00033	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00037	f3 0f 10 49 08	 movss	 xmm1, DWORD PTR [ecx+8]
  0003c	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00040	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  00045	f3 0f 10 42 08	 movss	 xmm0, DWORD PTR [edx+8]
  0004a	0f 5a c0	 cvtps2pd xmm0, xmm0
  0004d	0f 5a c9	 cvtps2pd xmm1, xmm1
  00050	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00054	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00058	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 382  : }

  0005d	5d		 pop	 ebp
  0005e	c2 08 00	 ret	 8
??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator+
_TEXT	ENDS
PUBLIC	??D@YA?AUD3DXVECTOR3@@MABU0@@Z			; operator*
; Function compile flags: /Ogsp
;	COMDAT ??D@YA?AUD3DXVECTOR3@@MABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_f$ = 12						; size = 4
_v$ = 16						; size = 4
??D@YA?AUD3DXVECTOR3@@MABU0@@Z PROC			; operator*, COMDAT

; 406  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 407  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00003	8b 4d 10	 mov	 ecx, DWORD PTR _v$[ebp]
  00006	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _f$[ebp]
  0000b	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00012	0f 5a c0	 cvtps2pd xmm0, xmm0
  00015	0f 5a c9	 cvtps2pd xmm1, xmm1
  00018	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  0001c	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _f$[ebp]
  00021	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00025	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00029	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0002e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00031	0f 5a c9	 cvtps2pd xmm1, xmm1
  00034	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00038	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _f$[ebp]
  0003d	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00041	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  00046	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  0004b	0f 5a c0	 cvtps2pd xmm0, xmm0
  0004e	0f 5a c9	 cvtps2pd xmm1, xmm1
  00051	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00055	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00059	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 408  : }

  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
??D@YA?AUD3DXVECTOR3@@MABU0@@Z ENDP			; operator*
_TEXT	ENDS
PUBLIC	?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z	; D3DXVec3Cross
; Function compile flags: /Ogsp
;	COMDAT ?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z
_TEXT	SEGMENT
_v$ = -12						; size = 12
_pOut$ = 8						; size = 4
_pV1$ = 12						; size = 4
_pV2$ = 16						; size = 4
?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z PROC	; D3DXVec3Cross, COMDAT

; 1747 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1757 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;
; 1758 : 
; 1759 :     *pOut = v;

  00006	56		 push	 esi
  00007	57		 push	 edi

; 1748 :     D3DXVECTOR3 v;
; 1749 : 
; 1750 : #ifdef D3DX_DEBUG
; 1751 :     if(!pOut || !pV1 || !pV2)
; 1752 :         return NULL;
; 1753 : #endif
; 1754 : 
; 1755 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00008	8b 45 0c	 mov	 eax, DWORD PTR _pV1$[ebp]
  0000b	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00010	f3 0f 10 50 08	 movss	 xmm2, DWORD PTR [eax+8]
  00015	8b 4d 10	 mov	 ecx, DWORD PTR _pV2$[ebp]
  00018	f3 0f 10 49 08	 movss	 xmm1, DWORD PTR [ecx+8]
  0001d	f3 0f 10 59 04	 movss	 xmm3, DWORD PTR [ecx+4]
  00022	0f 5a e8	 cvtps2pd xmm5, xmm0
  00025	0f 5a e1	 cvtps2pd xmm4, xmm1
  00028	0f 5a f2	 cvtps2pd xmm6, xmm2
  0002b	f2 0f 59 e5	 mulsd	 xmm4, xmm5

; 1756 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  0002f	0f 5a d2	 cvtps2pd xmm2, xmm2
  00032	0f 5a c9	 cvtps2pd xmm1, xmm1
  00035	0f 5a eb	 cvtps2pd xmm5, xmm3
  00038	f2 0f 59 ee	 mulsd	 xmm5, xmm6
  0003c	f2 0f 5c e5	 subsd	 xmm4, xmm5
  00040	f3 0f 10 28	 movss	 xmm5, DWORD PTR [eax]

; 1757 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;
; 1758 : 
; 1759 :     *pOut = v;

  00044	8b 45 08	 mov	 eax, DWORD PTR _pOut$[ebp]
  00047	66 0f 5a e4	 cvtpd2ps xmm4, xmm4
  0004b	f3 0f 11 65 f4	 movss	 DWORD PTR _v$[ebp], xmm4
  00050	f3 0f 10 21	 movss	 xmm4, DWORD PTR [ecx]
  00054	0f 5a f4	 cvtps2pd xmm6, xmm4
  00057	f2 0f 59 f2	 mulsd	 xmm6, xmm2
  0005b	0f 5a d5	 cvtps2pd xmm2, xmm5
  0005e	f2 0f 59 d1	 mulsd	 xmm2, xmm1
  00062	f2 0f 5c f2	 subsd	 xmm6, xmm2
  00066	66 0f 5a ce	 cvtpd2ps xmm1, xmm6
  0006a	f3 0f 11 4d f8	 movss	 DWORD PTR _v$[ebp+4], xmm1
  0006f	0f 5a c0	 cvtps2pd xmm0, xmm0
  00072	0f 5a d3	 cvtps2pd xmm2, xmm3
  00075	0f 5a cd	 cvtps2pd xmm1, xmm5
  00078	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  0007c	8d 75 f4	 lea	 esi, DWORD PTR _v$[ebp]
  0007f	8b f8		 mov	 edi, eax
  00081	0f 5a d4	 cvtps2pd xmm2, xmm4
  00084	f2 0f 59 d0	 mulsd	 xmm2, xmm0
  00088	f2 0f 5c ca	 subsd	 xmm1, xmm2
  0008c	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  00090	f3 0f 11 45 fc	 movss	 DWORD PTR _v$[ebp+8], xmm0
  00095	a5		 movsd
  00096	a5		 movsd
  00097	a5		 movsd
  00098	5f		 pop	 edi
  00099	5e		 pop	 esi

; 1760 :     return pOut;
; 1761 : }

  0009a	c9		 leave
  0009b	c3		 ret	 0
?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z ENDP	; D3DXVec3Cross
_TEXT	ENDS
PUBLIC	?_DECSTR@@YAXPADH@Z				; _DECSTR
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stringprotect.h
;	COMDAT ?_DECSTR@@YAXPADH@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_l$ = 12						; size = 4
?_DECSTR@@YAXPADH@Z PROC				; _DECSTR, COMDAT

; 40   : __forceinline void _DECSTR(char* s, int l){int i=0,l4=(l-1)/4,*p=(int*)s;s[l-1]=0;for(;i<l4;++i)*(p++)^=0xEAEBECED;for(i=l4*4;i<l-1;++i)s[i]^=0xED-i%4;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _l$[ebp]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  0000a	57		 push	 edi
  0000b	8d 79 ff	 lea	 edi, DWORD PTR [ecx-1]
  0000e	8b c7		 mov	 eax, edi
  00010	99		 cdq
  00011	83 e2 03	 and	 edx, 3
  00014	03 c2		 add	 eax, edx
  00016	c1 f8 02	 sar	 eax, 2
  00019	8b d6		 mov	 edx, esi
  0001b	c6 44 0e ff 00	 mov	 BYTE PTR [esi+ecx-1], 0
  00020	85 c0		 test	 eax, eax
  00022	7e 0e		 jle	 SHORT $LN4@DECSTR
  00024	8b c8		 mov	 ecx, eax
$LL6@DECSTR:
  00026	81 32 ed ec eb
	ea		 xor	 DWORD PTR [edx], -353637139 ; eaebecedH
  0002c	83 c2 04	 add	 edx, 4
  0002f	49		 dec	 ecx
  00030	75 f4		 jne	 SHORT $LL6@DECSTR
$LN4@DECSTR:
  00032	c1 e0 02	 shl	 eax, 2
  00035	eb 17		 jmp	 SHORT $LN14@DECSTR
$LL3@DECSTR:
  00037	8b c8		 mov	 ecx, eax
  00039	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0003f	79 05		 jns	 SHORT $LN13@DECSTR
  00041	49		 dec	 ecx
  00042	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00045	41		 inc	 ecx
$LN13@DECSTR:
  00046	b2 ed		 mov	 dl, -19			; ffffffedH
  00048	2a d1		 sub	 dl, cl
  0004a	30 14 30	 xor	 BYTE PTR [eax+esi], dl
  0004d	40		 inc	 eax
$LN14@DECSTR:
  0004e	3b c7		 cmp	 eax, edi
  00050	7c e5		 jl	 SHORT $LL3@DECSTR
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?_DECSTR@@YAXPADH@Z ENDP				; _DECSTR
_TEXT	ENDS
PUBLIC	?GetName@ioBuff@@QBEABVioHashString@@XZ		; ioBuff::GetName
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobuff.h
;	COMDAT ?GetName@ioBuff@@QBEABVioHashString@@XZ
_TEXT	SEGMENT
?GetName@ioBuff@@QBEABVioHashString@@XZ PROC		; ioBuff::GetName, COMDAT
; _this$ = ecx

; 440  : 	inline const ioHashString& GetName() const { return m_Name; }

  00000	8d 81 34 02 00
	00		 lea	 eax, DWORD PTR [ecx+564]
  00006	c3		 ret	 0
?GetName@ioBuff@@QBEABVioHashString@@XZ ENDP		; ioBuff::GetName
_TEXT	ENDS
PUBLIC	?size@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBEIXZ ; std::vector<ioHashString,std::allocator<ioHashString> >::size
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?size@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBEIXZ PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 04	 sar	 eax, 4

; 880  : 		}

  00008	c3		 ret	 0
?size@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBEIXZ ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::size
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ ; std::_Vector_val<ioHashString,std::allocator<ioHashString> >::~_Vector_val<ioHashString,std::allocator<ioHashString> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<ioHashString,std::allocator<ioHashString> >::~_Vector_val<ioHashString,std::allocator<ioHashString> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<ioHashString,std::allocator<ioHashString> >::~_Vector_val<ioHashString,std::allocator<ioHashString> >
_TEXT	ENDS
PUBLIC	??0?$allocator@VioHashString@@@std@@QAE@XZ	; std::allocator<ioHashString>::allocator<ioHashString>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@VioHashString@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VioHashString@@@std@@QAE@XZ PROC		; std::allocator<ioHashString>::allocator<ioHashString>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@VioHashString@@@std@@QAE@XZ ENDP		; std::allocator<ioHashString>::allocator<ioHashString>
_TEXT	ENDS
PUBLIC	??0?$allocator@VioHashString@@@std@@QAE@ABV01@@Z ; std::allocator<ioHashString>::allocator<ioHashString>
; Function compile flags: /Ogsp
;	COMDAT ??0?$allocator@VioHashString@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@VioHashString@@@std@@QAE@ABV01@@Z PROC	; std::allocator<ioHashString>::allocator<ioHashString>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@VioHashString@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<ioHashString>::allocator<ioHashString>
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::~_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??1?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::~_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::~_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UtagDummyCharLoadInfo@@@std@@QAE@XZ ; std::allocator<tagDummyCharLoadInfo>::allocator<tagDummyCharLoadInfo>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UtagDummyCharLoadInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UtagDummyCharLoadInfo@@@std@@QAE@XZ PROC	; std::allocator<tagDummyCharLoadInfo>::allocator<tagDummyCharLoadInfo>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@UtagDummyCharLoadInfo@@@std@@QAE@XZ ENDP	; std::allocator<tagDummyCharLoadInfo>::allocator<tagDummyCharLoadInfo>
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IBEXXZ ; std::vector<ioHashString,std::allocator<ioHashString> >::_Xlen
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IBEXXZ PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::_Xlen, COMDAT
; _this$ = ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen@2:
$LN3@Xlen@2:
  0000b	cc		 int	 3
?_Xlen@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IBEXXZ ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::_Xlen
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@I@Z ; std::allocator<ioHashString>::deallocate
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@I@Z PROC ; std::allocator<ioHashString>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 183  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
?deallocate@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@I@Z ENDP ; std::allocator<ioHashString>::deallocate
_TEXT	ENDS
PUBLIC	??0?$allocator@UtagDummyCharLoadInfo@@@std@@QAE@ABV01@@Z ; std::allocator<tagDummyCharLoadInfo>::allocator<tagDummyCharLoadInfo>
; Function compile flags: /Ogsp
;	COMDAT ??0?$allocator@UtagDummyCharLoadInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UtagDummyCharLoadInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<tagDummyCharLoadInfo>::allocator<tagDummyCharLoadInfo>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@UtagDummyCharLoadInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<tagDummyCharLoadInfo>::allocator<tagDummyCharLoadInfo>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UtagDummyCharLoadInfo@@@std@@QAEXPAUtagDummyCharLoadInfo@@I@Z ; std::allocator<tagDummyCharLoadInfo>::deallocate
; Function compile flags: /Ogsp
;	COMDAT ?deallocate@?$allocator@UtagDummyCharLoadInfo@@@std@@QAEXPAUtagDummyCharLoadInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UtagDummyCharLoadInfo@@@std@@QAEXPAUtagDummyCharLoadInfo@@I@Z PROC ; std::allocator<tagDummyCharLoadInfo>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 183  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
?deallocate@?$allocator@UtagDummyCharLoadInfo@@@std@@QAEXPAUtagDummyCharLoadInfo@@I@Z ENDP ; std::allocator<tagDummyCharLoadInfo>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QAE@PAVioHashString@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QAE@PAVioHashString@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QAE@PAVioHashString@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QAE@PAVioHashString@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@VioHashString@@@std@@QBEIXZ ; std::allocator<ioHashString>::max_size
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@VioHashString@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VioHashString@@@std@@QBEIXZ PROC	; std::allocator<ioHashString>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 0f	 mov	 eax, 268435455		; 0fffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@VioHashString@@@std@@QBEIXZ ENDP	; std::allocator<ioHashString>::max_size
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@QAE@PAUtagDummyCharLoadInfo@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@QAE@PAUtagDummyCharLoadInfo@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@QAE@PAUtagDummyCharLoadInfo@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@QAE@PAUtagDummyCharLoadInfo@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::_Compat
; Function compile flags: /Ogsp
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::_Compat, COMDAT
; _this$ = ecx

; 253  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::_Compat
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >::_Compat
; Function compile flags: /Ogsp
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >::_Compat, COMDAT
; _this$ = ecx

; 253  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >::_Compat
_TEXT	ENDS
PUBLIC	??$_Allocate@VioHashString@@@std@@YAPAVioHashString@@IPAV1@@Z ; std::_Allocate<ioHashString>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Allocate@VioHashString@@@std@@YAPAVioHashString@@IPAV1@@Z
_TEXT	SEGMENT
$T531522 = -12						; size = 12
$T531526 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VioHashString@@@std@@YAPAVioHashString@@IPAV1@@Z PROC ; std::_Allocate<ioHashString>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 3c		 je	 SHORT $LN5@Allocate@2

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 ff ff ff
	0f		 cmp	 ecx, 268435455		; 0fffffffH
  00015	77 0e		 ja	 SHORT $LN1@Allocate@2
  00017	c1 e1 04	 shl	 ecx, 4
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00020	59		 pop	 ecx
  00021	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00023	75 26		 jne	 SHORT $LN5@Allocate@2
$LN1@Allocate@2:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00025	83 65 08 00	 and	 DWORD PTR $T531526[ebp], 0
  00029	8d 45 08	 lea	 eax, DWORD PTR $T531526[ebp]
  0002c	50		 push	 eax
  0002d	8d 4d f4	 lea	 ecx, DWORD PTR $T531522[ebp]
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
  00036	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003b	8d 45 f4	 lea	 eax, DWORD PTR $T531522[ebp]
  0003e	50		 push	 eax
  0003f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T531522[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00046	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate@2:
$LN5@Allocate@2:

; 40   : 	}

  0004b	c9		 leave
  0004c	c3		 ret	 0
$LN9@Allocate@2:
??$_Allocate@VioHashString@@@std@@YAPAVioHashString@@IPAV1@@Z ENDP ; std::_Allocate<ioHashString>
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
; Function compile flags: /Ogsp
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$forward@ABVioHashString@@@std@@YAABVioHashString@@ABV1@@Z ; std::forward<ioHashString const &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABVioHashString@@@std@@YAABVioHashString@@ABV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABVioHashString@@@std@@YAABVioHashString@@ABV1@@Z PROC ; std::forward<ioHashString const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABVioHashString@@@std@@YAABVioHashString@@ABV1@@Z ENDP ; std::forward<ioHashString const &>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@VioHashString@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVioHashString@@0@Z ; std::_Ptr_cat<ioHashString,ioHashString>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@VioHashString@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVioHashString@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@VioHashString@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVioHashString@@0@Z PROC ; std::_Ptr_cat<ioHashString,ioHashString>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	c9		 leave
  00008	c3		 ret	 0
??$_Ptr_cat@VioHashString@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVioHashString@@0@Z ENDP ; std::_Ptr_cat<ioHashString,ioHashString>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@UtagDummyCharLoadInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUtagDummyCharLoadInfo@@0@Z ; std::_Ptr_cat<tagDummyCharLoadInfo,tagDummyCharLoadInfo>
; Function compile flags: /Ogsp
;	COMDAT ??$_Ptr_cat@UtagDummyCharLoadInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUtagDummyCharLoadInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UtagDummyCharLoadInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUtagDummyCharLoadInfo@@0@Z PROC ; std::_Ptr_cat<tagDummyCharLoadInfo,tagDummyCharLoadInfo>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	c9		 leave
  00008	c3		 ret	 0
??$_Ptr_cat@UtagDummyCharLoadInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUtagDummyCharLoadInfo@@0@Z ENDP ; std::_Ptr_cat<tagDummyCharLoadInfo,tagDummyCharLoadInfo>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@PAVioHashString@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@0@AAPAVioHashString@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >,ioHashString *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@PAVioHashString@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@0@AAPAVioHashString@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@PAVioHashString@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@0@AAPAVioHashString@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >,ioHashString *>, COMDAT

; 485  : 	{	// return pointer category from arbitrary arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 486  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 487  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 488  : 	}

  00007	c9		 leave
  00008	c3		 ret	 0
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@PAVioHashString@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@0@AAPAVioHashString@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >,ioHashString *>
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QBEABVioHashString@@XZ ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::operator*
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QBEABVioHashString@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QBEABVioHashString@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::operator*, COMDAT
; _this$ = ecx

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);
; 83   : 
; 84   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 85   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QBEABVioHashString@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::operator++
; Function compile flags: /Ogsp
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::operator++, COMDAT
; _this$ = ecx

; 93   : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

  00002	83 00 10	 add	 DWORD PTR [eax], 16	; 00000010H

; 111  : 		return (*this);
; 112  : 		}

  00005	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::operator++
_TEXT	ENDS
PUBLIC	??_GioHashString@@QAEPAXI@Z			; ioHashString::`scalar deleting destructor'
EXTRN	__imp_??1ioHashString@@QAE@XZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ??_GioHashString@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GioHashString@@QAEPAXI@Z PROC			; ioHashString::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  0000c	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00010	74 07		 je	 SHORT $LN1@scalar@2
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	59		 pop	 ecx
$LN1@scalar@2:
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??_GioHashString@@QAEPAXI@Z ENDP			; ioHashString::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1tagDummyCharLoadInfo@@QAE@XZ			; tagDummyCharLoadInfo::~tagDummyCharLoadInfo
; Function compile flags: /Ogsp
;	COMDAT ??1tagDummyCharLoadInfo@@QAE@XZ
_TEXT	SEGMENT
??1tagDummyCharLoadInfo@@QAE@XZ PROC			; tagDummyCharLoadInfo::~tagDummyCharLoadInfo, COMDAT
; _this$ = ecx
  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
??1tagDummyCharLoadInfo@@QAE@XZ ENDP			; tagDummyCharLoadInfo::~tagDummyCharLoadInfo
_TEXT	ENDS
PUBLIC	??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z ; std::_Construct<ioHashString,ioHashString const &>
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__EH_epilog3:PROC
EXTRN	__EH_prolog3:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z$0
__ehfuncinfo$??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z
_TEXT	SEGMENT
$T531555 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$ = 8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z PROC ; std::_Construct<ioHashString,ioHashString const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3

; 47   : 	void _FARQ *_Vptr = _Ptr;

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000f	89 4d 08	 mov	 DWORD PTR __Vptr$[ebp], ecx

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00012	89 4d f0	 mov	 DWORD PTR $T531555[ebp], ecx
  00015	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00019	85 c9		 test	 ecx, ecx
  0001b	74 09		 je	 SHORT $LN3@Construct
  0001d	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
$LN3@Construct:

; 49   : 	}

  00026	e8 00 00 00 00	 call	 __EH_epilog3
  0002b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z$0:
  00000	ff 75 08	 push	 DWORD PTR __Vptr$[ebp]
  00003	ff 75 f0	 push	 DWORD PTR $T531555[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000b	59		 pop	 ecx
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
__ehhandler$??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z ENDP ; std::_Construct<ioHashString,ioHashString const &>
PUBLIC	__real@bf800000
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CreateDummyChar@ioCreateDummyByAttackedBuff2@@QAEXPAVioBaseChar@@@Z ; ioCreateDummyByAttackedBuff2::CreateDummyChar
EXTRN	??1SP2Packet@@UAE@XZ:PROC			; SP2Packet::~SP2Packet
EXTRN	?SendToAllPlayingUser@P2PNetwork@@YAXAAVSP2Packet@@PAVioBaseChar@@@Z:PROC ; P2PNetwork::SendToAllPlayingUser
EXTRN	??6SP2Packet@@QAEAAV0@H@Z:PROC			; SP2Packet::operator<<
EXTRN	??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z:PROC	; SP2Packet::operator<<
EXTRN	??0SP2Packet@@QAE@K@Z:PROC			; SP2Packet::SP2Packet
EXTRN	?CreateDummyChar@ioPlayStage@@QAEPAVioDummyChar@@ABVioHashString@@H0ABUD3DXVECTOR3@@MK_N@Z:PROC ; ioPlayStage::CreateDummyChar
EXTRN	?GetCurLocalIndex@ioDummyCharManager@@QAEHXZ:PROC ; ioDummyCharManager::GetCurLocalIndex
EXTRN	?GetSingleton@ioDummyCharManager@@SAAAV1@XZ:PROC ; ioDummyCharManager::GetSingleton
EXTRN	__imp_?UNIT_Y@ioMath@@2UD3DXVECTOR3@@A:BYTE
EXTRN	_D3DXVec3Normalize@8:PROC
EXTRN	__imp_??D@YA?AUD3DXVECTOR3@@ABUD3DXQUATERNION@@ABU0@@Z:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__chkstk:PROC
;	COMDAT __real@bf800000
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobuff.h
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CreateDummyChar@ioCreateDummyByAttackedBuff2@@QAEXPAVioBaseChar@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateDummyChar@ioCreateDummyByAttackedBuff2@@QAEXPAVioBaseChar@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?CreateDummyChar@ioCreateDummyByAttackedBuff2@@QAEXPAVioBaseChar@@@Z$1
__ehfuncinfo$?CreateDummyChar@ioCreateDummyByAttackedBuff2@@QAEXPAVioBaseChar@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CreateDummyChar@ioCreateDummyByAttackedBuff2@@QAEXPAVioBaseChar@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iocreatedummybyattackedbuff2.cpp
xdata$x	ENDS
;	COMDAT ?CreateDummyChar@ioCreateDummyByAttackedBuff2@@QAEXPAVioBaseChar@@@Z
_TEXT	SEGMENT
_szDummyCharName$530550 = -32908			; size = 16
$T531631 = -32892					; size = 4
_iSize$ = -32888					; size = 4
$T531630 = -32884					; size = 4
$T531632 = -32880					; size = 4
_fStartAngle$530554 = -32876				; size = 4
_pStage$ = -32872					; size = 4
_fSideOffset$530553 = -32868				; size = 4
_this$GSCopy$ = -32864					; size = 4
_iCurIndex$530551 = -32864				; size = 4
_i$530546 = -32860					; size = 4
_kPacket$530561 = -32856				; size = 32792
_vTargetPos$530555 = -64				; size = 12
_vSideDir$ = -52					; size = 12
_v$531608 = -40						; size = 12
$T530542 = -40						; size = 12
_vDir$ = -28						; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pOwner$ = 8						; size = 4
?CreateDummyChar@ioCreateDummyByAttackedBuff2@@QAEXPAVioBaseChar@@@Z PROC ; ioCreateDummyByAttackedBuff2::CreateDummyChar, COMDAT
; _this$ = ecx

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CreateDummyChar@ioCreateDummyByAttackedBuff2@@QAEXPAVioBaseChar@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 80 80 00 00	 mov	 eax, 32896		; 00008080H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00032	8b 5d 08	 mov	 ebx, DWORD PTR _pOwner$[ebp]

; 108  : 	}

  00035	89 8d a0 7f ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  0003b	85 db		 test	 ebx, ebx
  0003d	0f 84 bb 03 00
	00		 je	 $LN2@CreateDumm

; 64   : 	if ( !pOwner )
; 65   : 		return;
; 66   : 
; 67   : 	ioPlayStage *pStage = pOwner->GetCreator();

  00043	8b 83 44 03 00
	00		 mov	 eax, DWORD PTR [ebx+836]
  00049	89 85 98 7f ff
	ff		 mov	 DWORD PTR _pStage$[ebp], eax

; 68   : 	if( !pStage ) return;

  0004f	85 c0		 test	 eax, eax
  00051	0f 84 a7 03 00
	00		 je	 $LN2@CreateDumm

; 69   : 	if( m_DummyList.empty() )

  00057	8b 81 6c 09 00
	00		 mov	 eax, DWORD PTR [ecx+2412]
  0005d	3b 81 70 09 00
	00		 cmp	 eax, DWORD PTR [ecx+2416]
  00063	0f 84 95 03 00
	00		 je	 $LN2@CreateDumm

; 70   : 		return;
; 71   : 
; 72   : 	//g_DummyCharMgr.DestroyDummyCharByNameList( pOwner, m_vDestroyDummyList );
; 73   : 
; 74   : 	D3DXVECTOR3 vDir = pOwner->GetTargetRot() * D3DXVECTOR3( 0.0f, 0.0f, -1.0f );

  00069	0f 57 c0	 xorps	 xmm0, xmm0
  0006c	8d 45 d8	 lea	 eax, DWORD PTR $T530542[ebp]
  0006f	50		 push	 eax
  00070	8d 83 a4 06 00
	00		 lea	 eax, DWORD PTR [ebx+1700]
  00076	50		 push	 eax
  00077	8d 45 e4	 lea	 eax, DWORD PTR _vDir$[ebp]
  0007a	f3 0f 11 45 d8	 movss	 DWORD PTR $T530542[ebp], xmm0
  0007f	f3 0f 11 45 dc	 movss	 DWORD PTR $T530542[ebp+4], xmm0
  00084	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0008c	50		 push	 eax
  0008d	f3 0f 11 45 e0	 movss	 DWORD PTR $T530542[ebp+8], xmm0
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??D@YA?AUD3DXVECTOR3@@ABUD3DXQUATERNION@@ABU0@@Z
  00098	83 c4 0c	 add	 esp, 12			; 0000000cH

; 75   : 	D3DXVec3Normalize( &vDir, &vDir );

  0009b	8d 45 e4	 lea	 eax, DWORD PTR _vDir$[ebp]
  0009e	50		 push	 eax
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8

; 76   : 
; 77   : 	D3DXVECTOR3 vSideDir;
; 78   : 	D3DXVec3Cross( &vSideDir, &ioMath::UNIT_Y, &vDir );

  000a5	f3 0f 10 5d ec	 movss	 xmm3, DWORD PTR _vDir$[ebp+8]
  000aa	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?UNIT_Y@ioMath@@2UD3DXVECTOR3@@A
  000af	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000b4	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  000b9	f3 0f 10 65 e8	 movss	 xmm4, DWORD PTR _vDir$[ebp+4]
  000be	0f 5a d0	 cvtps2pd xmm2, xmm0
  000c1	0f 5a db	 cvtps2pd xmm3, xmm3
  000c4	f2 0f 59 d3	 mulsd	 xmm2, xmm3
  000c8	0f 5a e4	 cvtps2pd xmm4, xmm4
  000cb	0f 5a c0	 cvtps2pd xmm0, xmm0
  000ce	8d 75 d8	 lea	 esi, DWORD PTR _v$531608[ebp]
  000d1	8d 7d cc	 lea	 edi, DWORD PTR _vSideDir$[ebp]
  000d4	0f 5a d9	 cvtps2pd xmm3, xmm1
  000d7	f2 0f 59 dc	 mulsd	 xmm3, xmm4
  000db	f3 0f 10 65 ec	 movss	 xmm4, DWORD PTR _vDir$[ebp+8]
  000e0	f2 0f 5c d3	 subsd	 xmm2, xmm3
  000e4	f3 0f 10 5d e4	 movss	 xmm3, DWORD PTR _vDir$[ebp]
  000e9	0f 5a db	 cvtps2pd xmm3, xmm3
  000ec	66 0f 5a d2	 cvtpd2ps xmm2, xmm2
  000f0	f3 0f 11 55 d8	 movss	 DWORD PTR _v$531608[ebp], xmm2
  000f5	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  000f9	0f 5a c9	 cvtps2pd xmm1, xmm1
  000fc	f2 0f 59 cb	 mulsd	 xmm1, xmm3
  00100	0f 5a da	 cvtps2pd xmm3, xmm2
  00103	0f 5a e4	 cvtps2pd xmm4, xmm4
  00106	f2 0f 59 dc	 mulsd	 xmm3, xmm4
  0010a	f2 0f 5c cb	 subsd	 xmm1, xmm3
  0010e	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  00112	f3 0f 11 4d dc	 movss	 DWORD PTR _v$531608[ebp+4], xmm1
  00117	0f 57 c9	 xorps	 xmm1, xmm1
  0011a	0f 5a ca	 cvtps2pd xmm1, xmm2
  0011d	f3 0f 10 55 e8	 movss	 xmm2, DWORD PTR _vDir$[ebp+4]
  00122	0f 5a d2	 cvtps2pd xmm2, xmm2
  00125	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  00129	f3 0f 10 55 e4	 movss	 xmm2, DWORD PTR _vDir$[ebp]
  0012e	0f 5a d2	 cvtps2pd xmm2, xmm2
  00131	f2 0f 59 c2	 mulsd	 xmm0, xmm2
  00135	f2 0f 5c c8	 subsd	 xmm1, xmm0
  00139	0f 57 c0	 xorps	 xmm0, xmm0
  0013c	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  00140	f3 0f 11 45 e0	 movss	 DWORD PTR _v$531608[ebp+8], xmm0
  00145	a5		 movsd

; 79   : 	D3DXVec3Normalize( &vSideDir, &vSideDir );

  00146	8d 45 cc	 lea	 eax, DWORD PTR _vSideDir$[ebp]
  00149	a5		 movsd
  0014a	50		 push	 eax
  0014b	50		 push	 eax
  0014c	a5		 movsd
  0014d	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8

; 80   : 
; 81   : 	int iSize = m_DummyList.size();

  00152	8b b5 a0 7f ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$[ebp]
  00158	8b 86 70 09 00
	00		 mov	 eax, DWORD PTR [esi+2416]
  0015e	2b 86 6c 09 00
	00		 sub	 eax, DWORD PTR [esi+2412]
  00164	6a 1c		 push	 28			; 0000001cH
  00166	99		 cdq
  00167	59		 pop	 ecx
  00168	f7 f9		 idiv	 ecx

; 82   : 	for( int i=0; i < iSize; ++i )

  0016a	33 ff		 xor	 edi, edi
  0016c	89 bd a4 7f ff
	ff		 mov	 DWORD PTR _i$530546[ebp], edi
  00172	89 85 88 7f ff
	ff		 mov	 DWORD PTR _iSize$[ebp], eax
  00178	3b c7		 cmp	 eax, edi
  0017a	0f 8e 7e 02 00
	00		 jle	 $LN2@CreateDumm
$LL4@CreateDumm:

; 83   : 	{
; 84   : 		ioHashString szDummyCharName = m_DummyList[i].m_DummyCharName;

  00180	8b 86 6c 09 00
	00		 mov	 eax, DWORD PTR [esi+2412]
  00186	03 c7		 add	 eax, edi
  00188	50		 push	 eax
  00189	8d 8d 74 7f ff
	ff		 lea	 ecx, DWORD PTR _szDummyCharName$530550[ebp]
  0018f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  00195	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 85   : 		int iCurIndex = g_DummyCharMgr.GetCurLocalIndex();

  00199	e8 00 00 00 00	 call	 ?GetSingleton@ioDummyCharManager@@SAAAV1@XZ ; ioDummyCharManager::GetSingleton
  0019e	8b c8		 mov	 ecx, eax
  001a0	e8 00 00 00 00	 call	 ?GetCurLocalIndex@ioDummyCharManager@@QAEHXZ ; ioDummyCharManager::GetCurLocalIndex
  001a5	89 85 a0 7f ff
	ff		 mov	 DWORD PTR _iCurIndex$530551[ebp], eax

; 86   : 		float fOffset = m_DummyList[i].m_fDummyCharOffset;

  001ab	8b 86 6c 09 00
	00		 mov	 eax, DWORD PTR [esi+2412]

; 87   : 		float fSideOffset = m_DummyList[i].m_fDummyCharSideOffset;

  001b1	f3 0f 10 4c 38
	14		 movss	 xmm1, DWORD PTR [eax+edi+20]
  001b7	f3 0f 10 44 38
	10		 movss	 xmm0, DWORD PTR [eax+edi+16]
  001bd	f3 0f 11 8d 9c
	7f ff ff	 movss	 DWORD PTR _fSideOffset$530553[ebp], xmm1

; 88   : 		float fStartAngle = m_DummyList[i].m_fDummyCharStartAngle;

  001c5	f3 0f 10 4c 38
	18		 movss	 xmm1, DWORD PTR [eax+edi+24]

; 89   : 
; 90   : 		D3DXVECTOR3 vTargetPos = pOwner->GetWorldPosition() + (fOffset * vDir);

  001cb	8b 03		 mov	 eax, DWORD PTR [ebx]
  001cd	f3 0f 11 8d 94
	7f ff ff	 movss	 DWORD PTR _fStartAngle$530554[ebp], xmm1
  001d5	f3 0f 10 4d e4	 movss	 xmm1, DWORD PTR _vDir$[ebp]
  001da	0f 5a c9	 cvtps2pd xmm1, xmm1
  001dd	0f 5a d0	 cvtps2pd xmm2, xmm0
  001e0	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  001e4	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  001e8	f3 0f 11 8d 90
	7f ff ff	 movss	 DWORD PTR $T531632[ebp], xmm1
  001f0	f3 0f 10 4d e8	 movss	 xmm1, DWORD PTR _vDir$[ebp+4]
  001f5	0f 5a c9	 cvtps2pd xmm1, xmm1
  001f8	0f 5a d0	 cvtps2pd xmm2, xmm0
  001fb	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  001ff	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  00203	f3 0f 11 8d 84
	7f ff ff	 movss	 DWORD PTR $T531631[ebp], xmm1
  0020b	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR _vDir$[ebp+8]
  00210	0f 5a c0	 cvtps2pd xmm0, xmm0
  00213	0f 5a c9	 cvtps2pd xmm1, xmm1
  00216	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  0021a	0f 57 c0	 xorps	 xmm0, xmm0
  0021d	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  00221	8b cb		 mov	 ecx, ebx
  00223	f3 0f 11 85 8c
	7f ff ff	 movss	 DWORD PTR $T531630[ebp], xmm0
  0022b	ff 50 70	 call	 DWORD PTR [eax+112]
  0022e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00232	f3 0f 10 8d 90
	7f ff ff	 movss	 xmm1, DWORD PTR $T531632[ebp]
  0023a	f3 0f 10 95 84
	7f ff ff	 movss	 xmm2, DWORD PTR $T531631[ebp]
  00242	f3 0f 10 9d 8c
	7f ff ff	 movss	 xmm3, DWORD PTR $T531630[ebp]

; 91   : 		vTargetPos += fSideOffset * vSideDir;

  0024a	f3 0f 10 a5 9c
	7f ff ff	 movss	 xmm4, DWORD PTR _fSideOffset$530553[ebp]
  00252	f3 0f 10 ad 9c
	7f ff ff	 movss	 xmm5, DWORD PTR _fSideOffset$530553[ebp]
  0025a	f3 0f 10 b5 9c
	7f ff ff	 movss	 xmm6, DWORD PTR _fSideOffset$530553[ebp]
  00262	0f 5a c0	 cvtps2pd xmm0, xmm0
  00265	0f 5a c9	 cvtps2pd xmm1, xmm1
  00268	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0026c	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  00271	0f 5a d2	 cvtps2pd xmm2, xmm2
  00274	0f 5a db	 cvtps2pd xmm3, xmm3
  00277	0f 5a c9	 cvtps2pd xmm1, xmm1
  0027a	f2 0f 58 ca	 addsd	 xmm1, xmm2
  0027e	f3 0f 10 50 08	 movss	 xmm2, DWORD PTR [eax+8]
  00283	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00287	0f 5a d2	 cvtps2pd xmm2, xmm2
  0028a	f2 0f 58 d3	 addsd	 xmm2, xmm3
  0028e	f3 0f 10 5d cc	 movss	 xmm3, DWORD PTR _vSideDir$[ebp]
  00293	0f 5a e4	 cvtps2pd xmm4, xmm4
  00296	0f 5a db	 cvtps2pd xmm3, xmm3
  00299	f2 0f 59 dc	 mulsd	 xmm3, xmm4
  0029d	f3 0f 10 65 d0	 movss	 xmm4, DWORD PTR _vSideDir$[ebp+4]
  002a2	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  002a6	0f 5a ed	 cvtps2pd xmm5, xmm5
  002a9	66 0f 5a db	 cvtpd2ps xmm3, xmm3
  002ad	0f 5a e4	 cvtps2pd xmm4, xmm4
  002b0	f2 0f 59 e5	 mulsd	 xmm4, xmm5
  002b4	f3 0f 10 6d d4	 movss	 xmm5, DWORD PTR _vSideDir$[ebp+8]
  002b9	f3 0f 5a db	 cvtss2sd xmm3, xmm3
  002bd	f2 0f 58 d8	 addsd	 xmm3, xmm0
  002c1	0f 5a ed	 cvtps2pd xmm5, xmm5
  002c4	66 0f 5a c3	 cvtpd2ps xmm0, xmm3
  002c8	0f 5a f6	 cvtps2pd xmm6, xmm6
  002cb	f2 0f 59 ee	 mulsd	 xmm5, xmm6
  002cf	f3 0f 11 45 c0	 movss	 DWORD PTR _vTargetPos$530555[ebp], xmm0
  002d4	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  002d8	66 0f 5a d2	 cvtpd2ps xmm2, xmm2
  002dc	66 0f 5a e4	 cvtpd2ps xmm4, xmm4
  002e0	66 0f 5a ed	 cvtpd2ps xmm5, xmm5
  002e4	0f 57 c0	 xorps	 xmm0, xmm0
  002e7	f3 0f 5a c4	 cvtss2sd xmm0, xmm4
  002eb	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  002ef	f2 0f 58 c1	 addsd	 xmm0, xmm1
  002f3	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  002f7	f3 0f 11 45 c4	 movss	 DWORD PTR _vTargetPos$530555[ebp+4], xmm0

; 92   : 
; 93   : 		ioDummyChar *pDummy = pStage->CreateDummyChar( szDummyCharName, iCurIndex,
; 94   : 			pOwner->GetCharName(),
; 95   : 			vTargetPos,
; 96   : 			fStartAngle,
; 97   : 			0, true );

  002fc	6a 01		 push	 1
  002fe	0f 57 c0	 xorps	 xmm0, xmm0
  00301	6a 00		 push	 0
  00303	f3 0f 5a c5	 cvtss2sd xmm0, xmm5
  00307	51		 push	 ecx
  00308	8b 8d 98 7f ff
	ff		 mov	 ecx, DWORD PTR _pStage$[ebp]
  0030e	0f 57 c9	 xorps	 xmm1, xmm1
  00311	f3 0f 5a ca	 cvtss2sd xmm1, xmm2
  00315	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00319	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0031d	f3 0f 11 45 c8	 movss	 DWORD PTR _vTargetPos$530555[ebp+8], xmm0
  00322	f3 0f 10 85 94
	7f ff ff	 movss	 xmm0, DWORD PTR _fStartAngle$530554[ebp]
  0032a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0032f	8d 45 c0	 lea	 eax, DWORD PTR _vTargetPos$530555[ebp]
  00332	50		 push	 eax
  00333	8d 83 d4 02 00
	00		 lea	 eax, DWORD PTR [ebx+724]
  00339	50		 push	 eax
  0033a	ff b5 a0 7f ff
	ff		 push	 DWORD PTR _iCurIndex$530551[ebp]
  00340	8d 85 74 7f ff
	ff		 lea	 eax, DWORD PTR _szDummyCharName$530550[ebp]
  00346	50		 push	 eax
  00347	e8 00 00 00 00	 call	 ?CreateDummyChar@ioPlayStage@@QAEPAVioDummyChar@@ABVioHashString@@H0ABUD3DXVECTOR3@@MK_N@Z ; ioPlayStage::CreateDummyChar

; 98   : 
; 99   : 		if ( pOwner->IsNeedSendNetwork() )

  0034c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0034e	8b cb		 mov	 ecx, ebx
  00350	ff 90 04 01 00
	00		 call	 DWORD PTR [eax+260]
  00356	84 c0		 test	 al, al
  00358	74 79		 je	 SHORT $LN1@CreateDumm

; 100  : 		{
; 101  : 			SP2Packet kPacket( CUPK_APPLY_EXTRA_BUFF_INFO );

  0035a	68 45 42 00 00	 push	 16965			; 00004245H
  0035f	8d 8d a8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$530561[ebp]
  00365	e8 00 00 00 00	 call	 ??0SP2Packet@@QAE@K@Z	; SP2Packet::SP2Packet

; 102  : 			kPacket << pOwner->GetCharName();

  0036a	8d 83 d4 02 00
	00		 lea	 eax, DWORD PTR [ebx+724]
  00370	50		 push	 eax
  00371	8d 8d a8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$530561[ebp]
  00377	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0037b	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z ; SP2Packet::operator<<

; 103  : 			kPacket << GetName();

  00380	8d 86 34 02 00
	00		 lea	 eax, DWORD PTR [esi+564]
  00386	50		 push	 eax
  00387	8d 8d a8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$530561[ebp]
  0038d	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z ; SP2Packet::operator<<

; 104  : 			kPacket << i;

  00392	ff b5 a4 7f ff
	ff		 push	 DWORD PTR _i$530546[ebp]
  00398	8d 8d a8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$530561[ebp]
  0039e	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@H@Z ; SP2Packet::operator<<

; 105  : 			kPacket << iCurIndex;

  003a3	ff b5 a0 7f ff
	ff		 push	 DWORD PTR _iCurIndex$530551[ebp]
  003a9	8d 8d a8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$530561[ebp]
  003af	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@H@Z ; SP2Packet::operator<<

; 106  : 			P2PNetwork::SendToAllPlayingUser( kPacket );

  003b4	8d 85 a8 7f ff
	ff		 lea	 eax, DWORD PTR _kPacket$530561[ebp]
  003ba	6a 00		 push	 0
  003bc	50		 push	 eax
  003bd	e8 00 00 00 00	 call	 ?SendToAllPlayingUser@P2PNetwork@@YAXAAVSP2Packet@@PAVioBaseChar@@@Z ; P2PNetwork::SendToAllPlayingUser
  003c2	59		 pop	 ecx
  003c3	59		 pop	 ecx

; 107  : 		}

  003c4	8d 8d a8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$530561[ebp]
  003ca	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  003ce	e8 00 00 00 00	 call	 ??1SP2Packet@@UAE@XZ	; SP2Packet::~SP2Packet
$LN1@CreateDumm:

; 108  : 	}

  003d3	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  003d7	8d 8d 74 7f ff
	ff		 lea	 ecx, DWORD PTR _szDummyCharName$530550[ebp]
  003dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  003e3	ff 85 a4 7f ff
	ff		 inc	 DWORD PTR _i$530546[ebp]
  003e9	8b 85 a4 7f ff
	ff		 mov	 eax, DWORD PTR _i$530546[ebp]
  003ef	83 c7 1c	 add	 edi, 28			; 0000001cH
  003f2	3b 85 88 7f ff
	ff		 cmp	 eax, DWORD PTR _iSize$[ebp]
  003f8	0f 8c 82 fd ff
	ff		 jl	 $LL4@CreateDumm
$LN2@CreateDumm:

; 109  : }

  003fe	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00401	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00408	59		 pop	 ecx
  00409	5f		 pop	 edi
  0040a	5e		 pop	 esi
  0040b	5b		 pop	 ebx
  0040c	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0040f	33 cd		 xor	 ecx, ebp
  00411	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00416	c9		 leave
  00417	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateDummyChar@ioCreateDummyByAttackedBuff2@@QAEXPAVioBaseChar@@@Z$0:
  00000	8d 8d 74 7f ff
	ff		 lea	 ecx, DWORD PTR _szDummyCharName$530550[ebp]
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?CreateDummyChar@ioCreateDummyByAttackedBuff2@@QAEXPAVioBaseChar@@@Z$1:
  0000c	8d 8d a8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$530561[ebp]
  00012	e9 00 00 00 00	 jmp	 ??1SP2Packet@@UAE@XZ	; SP2Packet::~SP2Packet
__ehhandler$?CreateDummyChar@ioCreateDummyByAttackedBuff2@@QAEXPAVioBaseChar@@@Z:
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 8a 70 7f ff
	ff		 mov	 ecx, DWORD PTR [edx-32912]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CreateDummyChar@ioCreateDummyByAttackedBuff2@@QAEXPAVioBaseChar@@@Z
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CreateDummyChar@ioCreateDummyByAttackedBuff2@@QAEXPAVioBaseChar@@@Z ENDP ; ioCreateDummyByAttackedBuff2::CreateDummyChar
PUBLIC	_this$GSCopy$
PUBLIC	?ApplyExtraBuffInfo@ioCreateDummyByAttackedBuff2@@UAEXAAVSP2Packet@@@Z ; ioCreateDummyByAttackedBuff2::ApplyExtraBuffInfo
EXTRN	??5SP2Packet@@QAEAAV0@AAH@Z:PROC		; SP2Packet::operator>>
EXTRN	?GetOwner@ioBuff@@QAEPAVioBaseChar@@XZ:PROC	; ioBuff::GetOwner
EXTRN	__EH_epilog3_GS:PROC
EXTRN	__EH_prolog3_GS:PROC
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasechar.h
xdata$x	SEGMENT
__unwindtable$?ApplyExtraBuffInfo@ioCreateDummyByAttackedBuff2@@UAEXAAVSP2Packet@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ApplyExtraBuffInfo@ioCreateDummyByAttackedBuff2@@UAEXAAVSP2Packet@@@Z$0
__ehfuncinfo$?ApplyExtraBuffInfo@ioCreateDummyByAttackedBuff2@@UAEXAAVSP2Packet@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ApplyExtraBuffInfo@ioCreateDummyByAttackedBuff2@@UAEXAAVSP2Packet@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iocreatedummybyattackedbuff2.cpp
xdata$x	ENDS
;	COMDAT ?ApplyExtraBuffInfo@ioCreateDummyByAttackedBuff2@@UAEXAAVSP2Packet@@@Z
_TEXT	SEGMENT
_szDummyCharName$530579 = -112				; size = 16
_pStage$ = -96						; size = 4
$T531742 = -92						; size = 4
$T531741 = -88						; size = 4
_fStartAngle$530582 = -84				; size = 4
$T531740 = -80						; size = 4
_iDummyIndex$ = -76					; size = 4
_iDummyNum$ = -72					; size = 4
_this$GSCopy$ = -68					; size = 4
_fSideOffset$530581 = -68				; size = 4
_vTargetPos$530583 = -64				; size = 12
_vSideDir$ = -52					; size = 12
_v$531718 = -40						; size = 12
$T530574 = -40						; size = 12
_vDir$ = -28						; size = 12
__$EHRec$ = -12						; size = 12
_rkPacket$ = 8						; size = 4
?ApplyExtraBuffInfo@ioCreateDummyByAttackedBuff2@@UAEXAAVSP2Packet@@@Z PROC ; ioCreateDummyByAttackedBuff2::ApplyExtraBuffInfo, COMDAT
; _this$ = ecx

; 112  : {

  00000	6a 64		 push	 100			; 00000064H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?ApplyExtraBuffInfo@ioCreateDummyByAttackedBuff2@@UAEXAAVSP2Packet@@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000c	8b 75 08	 mov	 esi, DWORD PTR _rkPacket$[ebp]
  0000f	8b f9		 mov	 edi, ecx

; 133  : 	{
; 134  : 		ioHashString szDummyCharName = m_DummyList[iDummyNum].m_DummyCharName;

  00011	89 7d bc	 mov	 DWORD PTR _this$GSCopy$[ebp], edi
  00014	e8 00 00 00 00	 call	 ?GetOwner@ioBuff@@QAEPAVioBaseChar@@XZ ; ioBuff::GetOwner
  00019	8b d8		 mov	 ebx, eax
  0001b	85 db		 test	 ebx, ebx
  0001d	0f 84 e8 02 00
	00		 je	 $LN1@ApplyExtra

; 113  : 	ioBaseChar *pOwner = GetOwner();
; 114  : 	if( !pOwner )
; 115  : 		return;
; 116  : 
; 117  : 	int iDummyNum,iDummyIndex;
; 118  : 	rkPacket >> iDummyNum >> iDummyIndex;

  00023	8d 45 b4	 lea	 eax, DWORD PTR _iDummyIndex$[ebp]
  00026	50		 push	 eax
  00027	8d 45 b8	 lea	 eax, DWORD PTR _iDummyNum$[ebp]
  0002a	50		 push	 eax
  0002b	8b ce		 mov	 ecx, esi
  0002d	e8 00 00 00 00	 call	 ??5SP2Packet@@QAEAAV0@AAH@Z ; SP2Packet::operator>>
  00032	8b c8		 mov	 ecx, eax
  00034	e8 00 00 00 00	 call	 ??5SP2Packet@@QAEAAV0@AAH@Z ; SP2Packet::operator>>

; 119  : 
; 120  : 	ioPlayStage *pStage = pOwner->GetCreator();

  00039	8b 83 44 03 00
	00		 mov	 eax, DWORD PTR [ebx+836]
  0003f	89 45 a0	 mov	 DWORD PTR _pStage$[ebp], eax

; 121  : 	if( !pStage ) return;

  00042	85 c0		 test	 eax, eax
  00044	0f 84 c1 02 00
	00		 je	 $LN1@ApplyExtra

; 122  : 	if( m_DummyList.empty() )

  0004a	8b 87 6c 09 00
	00		 mov	 eax, DWORD PTR [edi+2412]
  00050	3b 87 70 09 00
	00		 cmp	 eax, DWORD PTR [edi+2416]
  00056	0f 84 af 02 00
	00		 je	 $LN1@ApplyExtra

; 123  : 		return;
; 124  : 
; 125  : 	D3DXVECTOR3 vDir = pOwner->GetTargetRot() * D3DXVECTOR3( 0.0f, 0.0f, -1.0f );

  0005c	0f 57 c0	 xorps	 xmm0, xmm0
  0005f	8d 45 d8	 lea	 eax, DWORD PTR $T530574[ebp]
  00062	50		 push	 eax
  00063	8d 83 a4 06 00
	00		 lea	 eax, DWORD PTR [ebx+1700]
  00069	50		 push	 eax
  0006a	8d 45 e4	 lea	 eax, DWORD PTR _vDir$[ebp]
  0006d	f3 0f 11 45 d8	 movss	 DWORD PTR $T530574[ebp], xmm0
  00072	f3 0f 11 45 dc	 movss	 DWORD PTR $T530574[ebp+4], xmm0
  00077	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0007f	50		 push	 eax
  00080	f3 0f 11 45 e0	 movss	 DWORD PTR $T530574[ebp+8], xmm0
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??D@YA?AUD3DXVECTOR3@@ABUD3DXQUATERNION@@ABU0@@Z
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 126  : 	D3DXVec3Normalize( &vDir, &vDir );

  0008e	8d 45 e4	 lea	 eax, DWORD PTR _vDir$[ebp]
  00091	50		 push	 eax
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8

; 127  : 
; 128  : 	D3DXVECTOR3 vSideDir;
; 129  : 	D3DXVec3Cross( &vSideDir, &ioMath::UNIT_Y, &vDir );

  00098	f3 0f 10 5d ec	 movss	 xmm3, DWORD PTR _vDir$[ebp+8]
  0009d	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?UNIT_Y@ioMath@@2UD3DXVECTOR3@@A
  000a2	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000a7	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  000ac	f3 0f 10 65 e8	 movss	 xmm4, DWORD PTR _vDir$[ebp+4]
  000b1	0f 5a d0	 cvtps2pd xmm2, xmm0
  000b4	0f 5a db	 cvtps2pd xmm3, xmm3
  000b7	f2 0f 59 d3	 mulsd	 xmm2, xmm3
  000bb	0f 5a e4	 cvtps2pd xmm4, xmm4
  000be	0f 5a c0	 cvtps2pd xmm0, xmm0
  000c1	8d 75 d8	 lea	 esi, DWORD PTR _v$531718[ebp]
  000c4	8d 7d cc	 lea	 edi, DWORD PTR _vSideDir$[ebp]
  000c7	0f 5a d9	 cvtps2pd xmm3, xmm1
  000ca	f2 0f 59 dc	 mulsd	 xmm3, xmm4
  000ce	f3 0f 10 65 ec	 movss	 xmm4, DWORD PTR _vDir$[ebp+8]
  000d3	f2 0f 5c d3	 subsd	 xmm2, xmm3
  000d7	f3 0f 10 5d e4	 movss	 xmm3, DWORD PTR _vDir$[ebp]
  000dc	0f 5a db	 cvtps2pd xmm3, xmm3
  000df	66 0f 5a d2	 cvtpd2ps xmm2, xmm2
  000e3	f3 0f 11 55 d8	 movss	 DWORD PTR _v$531718[ebp], xmm2
  000e8	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  000ec	0f 5a c9	 cvtps2pd xmm1, xmm1
  000ef	f2 0f 59 cb	 mulsd	 xmm1, xmm3
  000f3	0f 5a da	 cvtps2pd xmm3, xmm2
  000f6	0f 5a e4	 cvtps2pd xmm4, xmm4
  000f9	f2 0f 59 dc	 mulsd	 xmm3, xmm4
  000fd	f2 0f 5c cb	 subsd	 xmm1, xmm3
  00101	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  00105	f3 0f 11 4d dc	 movss	 DWORD PTR _v$531718[ebp+4], xmm1
  0010a	0f 57 c9	 xorps	 xmm1, xmm1
  0010d	0f 5a ca	 cvtps2pd xmm1, xmm2
  00110	f3 0f 10 55 e8	 movss	 xmm2, DWORD PTR _vDir$[ebp+4]
  00115	0f 5a d2	 cvtps2pd xmm2, xmm2
  00118	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  0011c	f3 0f 10 55 e4	 movss	 xmm2, DWORD PTR _vDir$[ebp]
  00121	0f 5a d2	 cvtps2pd xmm2, xmm2
  00124	f2 0f 59 c2	 mulsd	 xmm0, xmm2
  00128	f2 0f 5c c8	 subsd	 xmm1, xmm0
  0012c	0f 57 c0	 xorps	 xmm0, xmm0
  0012f	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  00133	f3 0f 11 45 e0	 movss	 DWORD PTR _v$531718[ebp+8], xmm0
  00138	a5		 movsd

; 130  : 	D3DXVec3Normalize( &vSideDir, &vSideDir );

  00139	8d 45 cc	 lea	 eax, DWORD PTR _vSideDir$[ebp]
  0013c	a5		 movsd
  0013d	50		 push	 eax
  0013e	50		 push	 eax
  0013f	a5		 movsd
  00140	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8

; 131  : 
; 132  : 	if ( COMPARE( iDummyNum, 0, (int)m_DummyList.size() ) )

  00145	8b 4d b8	 mov	 ecx, DWORD PTR _iDummyNum$[ebp]
  00148	85 c9		 test	 ecx, ecx
  0014a	0f 88 bb 01 00
	00		 js	 $LN1@ApplyExtra
  00150	8b 75 bc	 mov	 esi, DWORD PTR _this$GSCopy$[ebp]
  00153	8b 86 70 09 00
	00		 mov	 eax, DWORD PTR [esi+2416]
  00159	2b 86 6c 09 00
	00		 sub	 eax, DWORD PTR [esi+2412]
  0015f	6a 1c		 push	 28			; 0000001cH
  00161	99		 cdq
  00162	5f		 pop	 edi
  00163	f7 ff		 idiv	 edi
  00165	3b c8		 cmp	 ecx, eax
  00167	0f 8d 9e 01 00
	00		 jge	 $LN1@ApplyExtra

; 133  : 	{
; 134  : 		ioHashString szDummyCharName = m_DummyList[iDummyNum].m_DummyCharName;

  0016d	6b c9 1c	 imul	 ecx, 28			; 0000001cH
  00170	03 8e 6c 09 00
	00		 add	 ecx, DWORD PTR [esi+2412]
  00176	51		 push	 ecx
  00177	8d 4d 90	 lea	 ecx, DWORD PTR _szDummyCharName$530579[ebp]
  0017a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z

; 135  : 
; 136  : 		float fOffset = m_DummyList[iDummyNum].m_fDummyCharOffset;

  00180	8b 45 b8	 mov	 eax, DWORD PTR _iDummyNum$[ebp]
  00183	8b 8e 6c 09 00
	00		 mov	 ecx, DWORD PTR [esi+2412]
  00189	6b c0 1c	 imul	 eax, 28			; 0000001cH

; 137  : 		float fSideOffset = m_DummyList[iDummyNum].m_fDummyCharSideOffset;

  0018c	f3 0f 10 4c 08
	14		 movss	 xmm1, DWORD PTR [eax+ecx+20]
  00192	f3 0f 10 44 08
	10		 movss	 xmm0, DWORD PTR [eax+ecx+16]
  00198	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0019c	f3 0f 11 4d bc	 movss	 DWORD PTR _fSideOffset$530581[ebp], xmm1

; 138  : 		float fStartAngle = m_DummyList[iDummyNum].m_fDummyCharStartAngle;

  001a1	f3 0f 10 4c 08
	18		 movss	 xmm1, DWORD PTR [eax+ecx+24]

; 139  : 
; 140  : 		D3DXVECTOR3 vTargetPos = pOwner->GetWorldPosition() + (fOffset * vDir);

  001a7	8b 03		 mov	 eax, DWORD PTR [ebx]
  001a9	f3 0f 11 4d ac	 movss	 DWORD PTR _fStartAngle$530582[ebp], xmm1
  001ae	f3 0f 10 4d e4	 movss	 xmm1, DWORD PTR _vDir$[ebp]
  001b3	0f 5a c9	 cvtps2pd xmm1, xmm1
  001b6	0f 5a d0	 cvtps2pd xmm2, xmm0
  001b9	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  001bd	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  001c1	f3 0f 11 4d a4	 movss	 DWORD PTR $T531742[ebp], xmm1
  001c6	f3 0f 10 4d e8	 movss	 xmm1, DWORD PTR _vDir$[ebp+4]
  001cb	0f 5a c9	 cvtps2pd xmm1, xmm1
  001ce	0f 5a d0	 cvtps2pd xmm2, xmm0
  001d1	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  001d5	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  001d9	f3 0f 11 4d a8	 movss	 DWORD PTR $T531741[ebp], xmm1
  001de	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR _vDir$[ebp+8]
  001e3	0f 5a c0	 cvtps2pd xmm0, xmm0
  001e6	0f 5a c9	 cvtps2pd xmm1, xmm1
  001e9	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  001ed	0f 57 c0	 xorps	 xmm0, xmm0
  001f0	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  001f4	8b cb		 mov	 ecx, ebx
  001f6	f3 0f 11 45 b0	 movss	 DWORD PTR $T531740[ebp], xmm0
  001fb	ff 50 70	 call	 DWORD PTR [eax+112]
  001fe	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00202	f3 0f 10 4d a4	 movss	 xmm1, DWORD PTR $T531742[ebp]
  00207	f3 0f 10 55 a8	 movss	 xmm2, DWORD PTR $T531741[ebp]
  0020c	f3 0f 10 5d b0	 movss	 xmm3, DWORD PTR $T531740[ebp]

; 141  : 		vTargetPos += fSideOffset * vSideDir;

  00211	f3 0f 10 65 bc	 movss	 xmm4, DWORD PTR _fSideOffset$530581[ebp]
  00216	f3 0f 10 6d bc	 movss	 xmm5, DWORD PTR _fSideOffset$530581[ebp]
  0021b	f3 0f 10 75 bc	 movss	 xmm6, DWORD PTR _fSideOffset$530581[ebp]
  00220	0f 5a c0	 cvtps2pd xmm0, xmm0
  00223	0f 5a c9	 cvtps2pd xmm1, xmm1
  00226	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0022a	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  0022f	0f 5a d2	 cvtps2pd xmm2, xmm2
  00232	0f 5a db	 cvtps2pd xmm3, xmm3
  00235	0f 5a c9	 cvtps2pd xmm1, xmm1
  00238	f2 0f 58 ca	 addsd	 xmm1, xmm2
  0023c	f3 0f 10 50 08	 movss	 xmm2, DWORD PTR [eax+8]
  00241	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00245	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00249	0f 5a d2	 cvtps2pd xmm2, xmm2
  0024c	f2 0f 58 d3	 addsd	 xmm2, xmm3
  00250	f3 0f 10 5d cc	 movss	 xmm3, DWORD PTR _vSideDir$[ebp]
  00255	0f 5a e4	 cvtps2pd xmm4, xmm4
  00258	0f 5a db	 cvtps2pd xmm3, xmm3
  0025b	f2 0f 59 dc	 mulsd	 xmm3, xmm4
  0025f	f3 0f 10 65 d0	 movss	 xmm4, DWORD PTR _vSideDir$[ebp+4]
  00264	0f 5a ed	 cvtps2pd xmm5, xmm5
  00267	66 0f 5a db	 cvtpd2ps xmm3, xmm3
  0026b	0f 5a e4	 cvtps2pd xmm4, xmm4
  0026e	f2 0f 59 e5	 mulsd	 xmm4, xmm5
  00272	f3 0f 10 6d d4	 movss	 xmm5, DWORD PTR _vSideDir$[ebp+8]
  00277	f3 0f 5a db	 cvtss2sd xmm3, xmm3
  0027b	f2 0f 58 d8	 addsd	 xmm3, xmm0
  0027f	66 0f 5a c3	 cvtpd2ps xmm0, xmm3
  00283	0f 5a ed	 cvtps2pd xmm5, xmm5
  00286	f3 0f 11 45 c0	 movss	 DWORD PTR _vTargetPos$530583[ebp], xmm0
  0028b	0f 5a f6	 cvtps2pd xmm6, xmm6
  0028e	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  00292	66 0f 5a e4	 cvtpd2ps xmm4, xmm4
  00296	f2 0f 59 ee	 mulsd	 xmm5, xmm6
  0029a	0f 57 c0	 xorps	 xmm0, xmm0
  0029d	66 0f 5a d2	 cvtpd2ps xmm2, xmm2
  002a1	66 0f 5a ed	 cvtpd2ps xmm5, xmm5
  002a5	f3 0f 5a c4	 cvtss2sd xmm0, xmm4
  002a9	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  002ad	f2 0f 58 c1	 addsd	 xmm0, xmm1
  002b1	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  002b5	f3 0f 11 45 c4	 movss	 DWORD PTR _vTargetPos$530583[ebp+4], xmm0

; 142  : 
; 143  : 		ioDummyChar *pDummy = pStage->CreateDummyChar( szDummyCharName, iDummyIndex,
; 144  : 			pOwner->GetCharName(),
; 145  : 			vTargetPos,
; 146  : 			fStartAngle,
; 147  : 			0, true );

  002ba	6a 01		 push	 1
  002bc	0f 57 c0	 xorps	 xmm0, xmm0
  002bf	6a 00		 push	 0
  002c1	f3 0f 5a c5	 cvtss2sd xmm0, xmm5
  002c5	51		 push	 ecx
  002c6	8b 4d a0	 mov	 ecx, DWORD PTR _pStage$[ebp]
  002c9	0f 57 c9	 xorps	 xmm1, xmm1
  002cc	f3 0f 5a ca	 cvtss2sd xmm1, xmm2
  002d0	f2 0f 58 c1	 addsd	 xmm0, xmm1
  002d4	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  002d8	f3 0f 11 45 c8	 movss	 DWORD PTR _vTargetPos$530583[ebp+8], xmm0
  002dd	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _fStartAngle$530582[ebp]
  002e2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002e7	8d 45 c0	 lea	 eax, DWORD PTR _vTargetPos$530583[ebp]
  002ea	50		 push	 eax
  002eb	81 c3 d4 02 00
	00		 add	 ebx, 724		; 000002d4H
  002f1	53		 push	 ebx
  002f2	ff 75 b4	 push	 DWORD PTR _iDummyIndex$[ebp]
  002f5	8d 45 90	 lea	 eax, DWORD PTR _szDummyCharName$530579[ebp]
  002f8	50		 push	 eax
  002f9	e8 00 00 00 00	 call	 ?CreateDummyChar@ioPlayStage@@QAEPAVioDummyChar@@ABVioHashString@@H0ABUD3DXVECTOR3@@MK_N@Z ; ioPlayStage::CreateDummyChar

; 148  : 	}

  002fe	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00302	8d 4d 90	 lea	 ecx, DWORD PTR _szDummyCharName$530579[ebp]
  00305	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
$LN1@ApplyExtra:

; 149  : }

  0030b	e8 00 00 00 00	 call	 __EH_epilog3_GS
  00310	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ApplyExtraBuffInfo@ioCreateDummyByAttackedBuff2@@UAEXAAVSP2Packet@@@Z$0:
  00000	8d 4d 90	 lea	 ecx, DWORD PTR _szDummyCharName$530579[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$?ApplyExtraBuffInfo@ioCreateDummyByAttackedBuff2@@UAEXAAVSP2Packet@@@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a 8c	 mov	 ecx, DWORD PTR [edx-116]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ApplyExtraBuffInfo@ioCreateDummyByAttackedBuff2@@UAEXAAVSP2Packet@@@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ApplyExtraBuffInfo@ioCreateDummyByAttackedBuff2@@UAEXAAVSP2Packet@@@Z ENDP ; ioCreateDummyByAttackedBuff2::ApplyExtraBuffInfo
PUBLIC	?begin@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@2@XZ ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::begin
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?begin@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@2@XZ PROC ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::begin, COMDAT
; _this$ = ecx

; 786  : 		{	// return iterator for beginning of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 787  : 		return (const_iterator(this->_Myfirst, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 788  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@2@XZ ENDP ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@2@XZ ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::end
; Function compile flags: /Ogsp
;	COMDAT ?end@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@2@XZ PROC ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::end, COMDAT
; _this$ = ecx

; 796  : 		{	// return iterator for end of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 797  : 		return (const_iterator(this->_Mylast, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 798  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@2@XZ ENDP ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QBEIXZ ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::max_size
; Function compile flags: /Ogsp
;	COMDAT ?max_size@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (this->_Alval.max_size());

  00000	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UtagDummyCharLoadInfo@@@std@@QAEPAUtagDummyCharLoadInfo@@I@Z ; std::allocator<tagDummyCharLoadInfo>::allocate
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UtagDummyCharLoadInfo@@@std@@QAEPAUtagDummyCharLoadInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UtagDummyCharLoadInfo@@@std@@QAEPAUtagDummyCharLoadInfo@@I@Z PROC ; std::allocator<tagDummyCharLoadInfo>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	6a 00		 push	 0
  00005	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Allocate@UtagDummyCharLoadInfo@@@std@@YAPAUtagDummyCharLoadInfo@@IPAU1@@Z ; std::_Allocate<tagDummyCharLoadInfo>
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx

; 188  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?allocate@?$allocator@UtagDummyCharLoadInfo@@@std@@QAEPAUtagDummyCharLoadInfo@@I@Z ENDP ; std::allocator<tagDummyCharLoadInfo>::allocate
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadInt_e@$0O@@ioINILoader@@QAEHAAY0O@$$CBDH@Z ; ioINILoader::LoadInt_e<14>
EXTRN	__imp_?LoadInt@ioINILoader@@QAEHPBDH@Z:PROC
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\io3dengine\ioiniloader.h
;	COMDAT ??$LoadInt_e@$0O@@ioINILoader@@QAEHAAY0O@$$CBDH@Z
_TEXT	SEGMENT
__k$ = -24						; size = 14
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_i$ = 12						; size = 4
??$LoadInt_e@$0O@@ioINILoader@@QAEHAAY0O@$$CBDH@Z PROC	; ioINILoader::LoadInt_e<14>, COMDAT
; _this$ = ecx

; 118  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 119  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	84 d2		 test	 dl, dl
  0001a	0f 84 64 01 00
	00		 je	 $LN96@LoadInt_e
  00020	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00023	88 55 e8	 mov	 BYTE PTR __k$[ebp], dl
  00026	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00029	84 d2		 test	 dl, dl
  0002b	0f 84 4d 01 00
	00		 je	 $LN95@LoadInt_e
  00031	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00034	88 55 e9	 mov	 BYTE PTR __k$[ebp+1], dl
  00037	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003a	84 d2		 test	 dl, dl
  0003c	0f 84 36 01 00
	00		 je	 $LN94@LoadInt_e
  00042	b1 eb		 mov	 cl, -21			; ffffffebH
  00044	32 d1		 xor	 dl, cl
  00046	88 55 ea	 mov	 BYTE PTR __k$[ebp+2], dl
  00049	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004c	84 d2		 test	 dl, dl
  0004e	0f 84 1e 01 00
	00		 je	 $LN93@LoadInt_e
  00054	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00057	88 55 eb	 mov	 BYTE PTR __k$[ebp+3], dl
  0005a	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005d	84 d2		 test	 dl, dl
  0005f	0f 84 07 01 00
	00		 je	 $LN92@LoadInt_e
  00065	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00068	88 55 ec	 mov	 BYTE PTR __k$[ebp+4], dl
  0006b	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006e	84 d2		 test	 dl, dl
  00070	0f 84 f0 00 00
	00		 je	 $LN91@LoadInt_e
  00076	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00079	88 55 ed	 mov	 BYTE PTR __k$[ebp+5], dl
  0007c	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0007f	84 d2		 test	 dl, dl
  00081	0f 84 da 00 00
	00		 je	 $LN90@LoadInt_e
  00087	32 d1		 xor	 dl, cl
  00089	88 55 ee	 mov	 BYTE PTR __k$[ebp+6], dl
  0008c	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0008f	84 d2		 test	 dl, dl
  00091	0f 84 c4 00 00
	00		 je	 $LN89@LoadInt_e
  00097	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009a	88 55 ef	 mov	 BYTE PTR __k$[ebp+7], dl
  0009d	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a0	84 d2		 test	 dl, dl
  000a2	0f 84 ad 00 00
	00		 je	 $LN88@LoadInt_e
  000a8	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ab	88 55 f0	 mov	 BYTE PTR __k$[ebp+8], dl
  000ae	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b1	84 d2		 test	 dl, dl
  000b3	0f 84 96 00 00
	00		 je	 $LN87@LoadInt_e
  000b9	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000bc	88 55 f1	 mov	 BYTE PTR __k$[ebp+9], dl
  000bf	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c2	84 d2		 test	 dl, dl
  000c4	0f 84 80 00 00
	00		 je	 $LN86@LoadInt_e
  000ca	32 d1		 xor	 dl, cl
  000cc	88 55 f2	 mov	 BYTE PTR __k$[ebp+10], dl
  000cf	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000d2	84 d2		 test	 dl, dl
  000d4	74 6e		 je	 SHORT $LN85@LoadInt_e
  000d6	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000d9	88 55 f3	 mov	 BYTE PTR __k$[ebp+11], dl
  000dc	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000df	84 d2		 test	 dl, dl
  000e1	74 5b		 je	 SHORT $LN84@LoadInt_e
  000e3	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000e6	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000ea	88 55 f4	 mov	 BYTE PTR __k$[ebp+12], dl
  000ed	0f 84 95 00 00
	00		 je	 $LN1@LoadInt_e
  000f3	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  000f6	84 d2		 test	 dl, dl
  000f8	74 3f		 je	 SHORT $LN82@LoadInt_e
  000fa	32 d1		 xor	 dl, cl
  000fc	88 55 f6	 mov	 BYTE PTR __k$[ebp+14], dl
  000ff	8a 50 0f	 mov	 dl, BYTE PTR [eax+15]
  00102	84 d2		 test	 dl, dl
  00104	74 2d		 je	 SHORT $LN81@LoadInt_e
  00106	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00109	88 55 f7	 mov	 BYTE PTR __k$[ebp+15], dl
  0010c	8a 50 10	 mov	 dl, BYTE PTR [eax+16]
  0010f	84 d2		 test	 dl, dl
  00111	74 1a		 je	 SHORT $LN80@LoadInt_e
  00113	8a 40 11	 mov	 al, BYTE PTR [eax+17]
  00116	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00119	88 55 f8	 mov	 BYTE PTR __k$[ebp+16], dl
  0011c	84 c0		 test	 al, al
  0011e	74 07		 je	 SHORT $LN79@LoadInt_e
  00120	34 ec		 xor	 al, -20			; ffffffecH
  00122	88 45 f9	 mov	 BYTE PTR __k$[ebp+17], al
  00125	eb 61		 jmp	 SHORT $LN1@LoadInt_e
$LN79@LoadInt_e:
  00127	c6 45 f9 ec	 mov	 BYTE PTR __k$[ebp+17], -20 ; ffffffecH
  0012b	eb 5b		 jmp	 SHORT $LN1@LoadInt_e
$LN80@LoadInt_e:
  0012d	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+16], -19 ; ffffffedH
  00131	eb 55		 jmp	 SHORT $LN1@LoadInt_e
$LN81@LoadInt_e:
  00133	c6 45 f7 ea	 mov	 BYTE PTR __k$[ebp+15], -22 ; ffffffeaH
  00137	eb 4f		 jmp	 SHORT $LN1@LoadInt_e
$LN82@LoadInt_e:
  00139	88 4d f6	 mov	 BYTE PTR __k$[ebp+14], cl
  0013c	eb 4a		 jmp	 SHORT $LN1@LoadInt_e
$LN84@LoadInt_e:
  0013e	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  00142	eb 44		 jmp	 SHORT $LN1@LoadInt_e
$LN85@LoadInt_e:
  00144	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  00148	eb 3e		 jmp	 SHORT $LN1@LoadInt_e
$LN86@LoadInt_e:
  0014a	88 4d f2	 mov	 BYTE PTR __k$[ebp+10], cl
  0014d	eb 39		 jmp	 SHORT $LN1@LoadInt_e
$LN87@LoadInt_e:
  0014f	c6 45 f1 ec	 mov	 BYTE PTR __k$[ebp+9], -20 ; ffffffecH
  00153	eb 33		 jmp	 SHORT $LN1@LoadInt_e
$LN88@LoadInt_e:
  00155	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  00159	eb 2d		 jmp	 SHORT $LN1@LoadInt_e
$LN89@LoadInt_e:
  0015b	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  0015f	eb 27		 jmp	 SHORT $LN1@LoadInt_e
$LN90@LoadInt_e:
  00161	88 4d ee	 mov	 BYTE PTR __k$[ebp+6], cl
  00164	eb 22		 jmp	 SHORT $LN1@LoadInt_e
$LN91@LoadInt_e:
  00166	c6 45 ed ec	 mov	 BYTE PTR __k$[ebp+5], -20 ; ffffffecH
  0016a	eb 1c		 jmp	 SHORT $LN1@LoadInt_e
$LN92@LoadInt_e:
  0016c	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  00170	eb 16		 jmp	 SHORT $LN1@LoadInt_e
$LN93@LoadInt_e:
  00172	c6 45 eb ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  00176	eb 10		 jmp	 SHORT $LN1@LoadInt_e
$LN94@LoadInt_e:
  00178	c6 45 ea eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  0017c	eb 0a		 jmp	 SHORT $LN1@LoadInt_e
$LN95@LoadInt_e:
  0017e	c6 45 e9 ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  00182	eb 04		 jmp	 SHORT $LN1@LoadInt_e
$LN96@LoadInt_e:
  00184	c6 45 e8 ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@LoadInt_e:
  00188	6a 03		 push	 3
  0018a	8d 45 e8	 lea	 eax, DWORD PTR __k$[ebp]
  0018d	c6 45 f5 00	 mov	 BYTE PTR __k$[ebp+13], 0
  00191	5a		 pop	 edx
$LL104@LoadInt_e:
  00192	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00198	83 c0 04	 add	 eax, 4
  0019b	4a		 dec	 edx
  0019c	75 f4		 jne	 SHORT $LL104@LoadInt_e

; 120  : 		return LoadInt(_k, i);

  0019e	ff 75 0c	 push	 DWORD PTR _i$[ebp]
  001a1	80 75 f4 ed	 xor	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  001a5	8d 45 e8	 lea	 eax, DWORD PTR __k$[ebp]
  001a8	50		 push	 eax
  001a9	8b ce		 mov	 ecx, esi
  001ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 121  : 	}

  001b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b4	33 cd		 xor	 ecx, ebp
  001b6	5e		 pop	 esi
  001b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001bc	c9		 leave
  001bd	c2 08 00	 ret	 8
??$LoadInt_e@$0O@@ioINILoader@@QAEHAAY0O@$$CBDH@Z ENDP	; ioINILoader::LoadInt_e<14>
_TEXT	ENDS
PUBLIC	??$_Construct@UtagDummyCharLoadInfo@@ABU1@@std@@YAXPAUtagDummyCharLoadInfo@@ABU1@@Z ; std::_Construct<tagDummyCharLoadInfo,tagDummyCharLoadInfo const &>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??$_Construct@UtagDummyCharLoadInfo@@ABU1@@std@@YAXPAUtagDummyCharLoadInfo@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@UtagDummyCharLoadInfo@@ABU1@@std@@YAXPAUtagDummyCharLoadInfo@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@UtagDummyCharLoadInfo@@ABU1@@std@@YAXPAUtagDummyCharLoadInfo@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@UtagDummyCharLoadInfo@@ABU1@@std@@YAXPAUtagDummyCharLoadInfo@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@UtagDummyCharLoadInfo@@ABU1@@std@@YAXPAUtagDummyCharLoadInfo@@ABU1@@Z
_TEXT	SEGMENT
$T531845 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$ = 8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UtagDummyCharLoadInfo@@ABU1@@std@@YAXPAUtagDummyCharLoadInfo@@ABU1@@Z PROC ; std::_Construct<tagDummyCharLoadInfo,tagDummyCharLoadInfo const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??$_Construct@UtagDummyCharLoadInfo@@ABU1@@std@@YAXPAUtagDummyCharLoadInfo@@ABU1@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3

; 47   : 	void _FARQ *_Vptr = _Ptr;

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000f	89 4d 08	 mov	 DWORD PTR __Vptr$[ebp], ecx

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00012	89 4d f0	 mov	 DWORD PTR $T531845[ebp], ecx
  00015	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00019	85 c9		 test	 ecx, ecx
  0001b	74 08		 je	 SHORT $LN3@Construct@2
  0001d	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  00020	e8 00 00 00 00	 call	 ??0tagDummyCharLoadInfo@@QAE@ABU0@@Z
$LN3@Construct@2:

; 49   : 	}

  00025	e8 00 00 00 00	 call	 __EH_epilog3
  0002a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@UtagDummyCharLoadInfo@@ABU1@@std@@YAXPAUtagDummyCharLoadInfo@@ABU1@@Z$0:
  00000	ff 75 08	 push	 DWORD PTR __Vptr$[ebp]
  00003	ff 75 f0	 push	 DWORD PTR $T531845[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000b	59		 pop	 ecx
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
__ehhandler$??$_Construct@UtagDummyCharLoadInfo@@ABU1@@std@@YAXPAUtagDummyCharLoadInfo@@ABU1@@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@UtagDummyCharLoadInfo@@ABU1@@std@@YAXPAUtagDummyCharLoadInfo@@ABU1@@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@UtagDummyCharLoadInfo@@ABU1@@std@@YAXPAUtagDummyCharLoadInfo@@ABU1@@Z ENDP ; std::_Construct<tagDummyCharLoadInfo,tagDummyCharLoadInfo const &>
PUBLIC	?begin@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@XZ ; std::vector<ioHashString,std::allocator<ioHashString> >::begin
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?begin@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@XZ PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::begin, COMDAT
; _this$ = ecx

; 786  : 		{	// return iterator for beginning of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 787  : 		return (const_iterator(this->_Myfirst, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 788  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@XZ ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@XZ ; std::vector<ioHashString,std::allocator<ioHashString> >::end
; Function compile flags: /Ogsp
;	COMDAT ?end@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@XZ PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::end, COMDAT
; _this$ = ecx

; 796  : 		{	// return iterator for end of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 797  : 		return (const_iterator(this->_Mylast, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 798  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@XZ ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::end
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@V?$allocator@VioHashString@@@1@@Z ; std::_Vector_val<ioHashString,std::allocator<ioHashString> >::_Vector_val<ioHashString,std::allocator<ioHashString> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@V?$allocator@VioHashString@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@V?$allocator@VioHashString@@@1@@Z PROC ; std::_Vector_val<ioHashString,std::allocator<ioHashString> >::_Vector_val<ioHashString,std::allocator<ioHashString> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@V?$allocator@VioHashString@@@1@@Z ENDP ; std::_Vector_val<ioHashString,std::allocator<ioHashString> >::_Vector_val<ioHashString,std::allocator<ioHashString> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@V?$allocator@UtagDummyCharLoadInfo@@@1@@Z ; std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@V?$allocator@UtagDummyCharLoadInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@V?$allocator@UtagDummyCharLoadInfo@@@1@@Z PROC ; std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@V?$allocator@UtagDummyCharLoadInfo@@@1@@Z ENDP ; std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBEIXZ ; std::vector<ioHashString,std::allocator<ioHashString> >::max_size
; Function compile flags: /Ogsp
;	COMDAT ?max_size@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBEIXZ PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 0f	 mov	 eax, 268435455		; 0fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBEIXZ ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@VioHashString@@@std@@QAEPAVioHashString@@I@Z ; std::allocator<ioHashString>::allocate
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@VioHashString@@@std@@QAEPAVioHashString@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@VioHashString@@@std@@QAEPAVioHashString@@I@Z PROC ; std::allocator<ioHashString>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	6a 00		 push	 0
  00005	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Allocate@VioHashString@@@std@@YAPAVioHashString@@IPAV1@@Z ; std::_Allocate<ioHashString>
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx

; 188  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?allocate@?$allocator@VioHashString@@@std@@QAEPAVioHashString@@I@Z ENDP ; std::allocator<ioHashString>::allocate
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::operator==
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	f7 d8		 neg	 eax
  0000c	1b c0		 sbb	 eax, eax
  0000e	40		 inc	 eax

; 204  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::operator==
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >::operator==
; Function compile flags: /Ogsp
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	f7 d8		 neg	 eax
  0000c	1b c0		 sbb	 eax, eax
  0000e	40		 inc	 eax

; 204  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >::operator==
_TEXT	ENDS
PUBLIC	??$_Destroy@VioHashString@@@std@@YAXPAVioHashString@@@Z ; std::_Destroy<ioHashString>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy@VioHashString@@@std@@YAXPAVioHashString@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VioHashString@@@std@@YAXPAVioHashString@@@Z PROC ; std::_Destroy<ioHashString>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 63   : 	_Ptr->~_Ty();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 64   : 	}

  00006	5d		 pop	 ebp

; 63   : 	_Ptr->~_Ty();

  00007	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
??$_Destroy@VioHashString@@@std@@YAXPAVioHashString@@@Z ENDP ; std::_Destroy<ioHashString>
_TEXT	ENDS
PUBLIC	??_GtagDummyCharLoadInfo@@QAEPAXI@Z		; tagDummyCharLoadInfo::`scalar deleting destructor'
; Function compile flags: /Ogsp
;	COMDAT ??_GtagDummyCharLoadInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GtagDummyCharLoadInfo@@QAEPAXI@Z PROC		; tagDummyCharLoadInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  0000c	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00010	74 07		 je	 SHORT $LN1@scalar@3
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	59		 pop	 ecx
$LN1@scalar@3:
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??_GtagDummyCharLoadInfo@@QAEPAXI@Z ENDP		; tagDummyCharLoadInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?construct@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@ABV3@@Z ; std::allocator<ioHashString>::construct
; Function compile flags: /Ogsp
;	COMDAT ?construct@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@ABV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@ABV3@@Z PROC ; std::allocator<ioHashString>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 		_Construct(_Ptr, _Val);

  00003	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  00006	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00009	e8 00 00 00 00	 call	 ??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z ; std::_Construct<ioHashString,ioHashString const &>
  0000e	59		 pop	 ecx
  0000f	59		 pop	 ecx

; 198  : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?construct@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@ABV3@@Z ENDP ; std::allocator<ioHashString>::construct
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?LoadProperty@ioCreateDummyByAttackedBuff2@@UAEXAAVioINILoader@@@Z ; ioCreateDummyByAttackedBuff2::LoadProperty
EXTRN	?LoadDummyCharCreateDestroyInfo@Help@@YAXAAVioINILoader@@AAV?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@AAV?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@4@@Z:PROC ; Help::LoadDummyCharCreateDestroyInfo
EXTRN	?LoadProperty@ioBuff@@UAEXAAVioINILoader@@@Z:PROC ; ioBuff::LoadProperty
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iocreatedummybyattackedbuff2.cpp
;	COMDAT ?LoadProperty@ioCreateDummyByAttackedBuff2@@UAEXAAVioINILoader@@@Z
_TEXT	SEGMENT
__k$531950 = -24					; size = 14
__$ArrayPad$ = -4					; size = 4
_rkLoader$ = 8						; size = 4
?LoadProperty@ioCreateDummyByAttackedBuff2@@UAEXAAVioINILoader@@@Z PROC ; ioCreateDummyByAttackedBuff2::LoadProperty, COMDAT
; _this$ = ecx

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	8b 7d 08	 mov	 edi, DWORD PTR _rkLoader$[ebp]

; 30   : 	ioBuff::LoadProperty( rkLoader );

  00015	57		 push	 edi
  00016	8b f1		 mov	 esi, ecx
  00018	e8 00 00 00 00	 call	 ?LoadProperty@ioBuff@@UAEXAAVioINILoader@@@Z ; ioBuff::LoadProperty

; 31   : 
; 32   : 	Help::LoadDummyCharCreateDestroyInfo( rkLoader, m_DummyList, m_vDestroyDummyList );

  0001d	8d 86 7c 09 00
	00		 lea	 eax, DWORD PTR [esi+2428]
  00023	50		 push	 eax
  00024	8d 86 6c 09 00
	00		 lea	 eax, DWORD PTR [esi+2412]
  0002a	50		 push	 eax
  0002b	57		 push	 edi
  0002c	e8 00 00 00 00	 call	 ?LoadDummyCharCreateDestroyInfo@Help@@YAXAAVioINILoader@@AAV?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@AAV?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@4@@Z ; Help::LoadDummyCharCreateDestroyInfo
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 33   : 
; 34   : 	m_iCheckPercent = rkLoader.LoadInt_e( "check_percent", 0 );

  00034	6a 03		 push	 3
  00036	c7 45 e8 8e 84
	8e 89		 mov	 DWORD PTR __k$531950[ebp], -1987148658 ; 898e848eH
  0003d	c7 45 ec 86 b3
	9b 8f		 mov	 DWORD PTR __k$531950[ebp+4], -1885621370 ; 8f9bb386H
  00044	c7 45 f0 9f 8f
	8e 84		 mov	 DWORD PTR __k$531950[ebp+8], -2071031905 ; 848e8f9fH
  0004b	8d 45 e8	 lea	 eax, DWORD PTR __k$531950[ebp]
  0004e	66 c7 45 f4 99
	00		 mov	 WORD PTR __k$531950[ebp+12], 153 ; 00000099H
  00054	59		 pop	 ecx
$LL106@LoadProper:
  00055	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0005b	83 c0 04	 add	 eax, 4
  0005e	49		 dec	 ecx
  0005f	75 f4		 jne	 SHORT $LL106@LoadProper
  00061	80 75 f4 ed	 xor	 BYTE PTR __k$531950[ebp+12], -19 ; ffffffedH
  00065	51		 push	 ecx
  00066	8d 45 e8	 lea	 eax, DWORD PTR __k$531950[ebp]
  00069	50		 push	 eax
  0006a	8b cf		 mov	 ecx, edi
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 35   : }

  00072	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00075	5f		 pop	 edi
  00076	89 86 8c 09 00
	00		 mov	 DWORD PTR [esi+2444], eax
  0007c	33 cd		 xor	 ecx, ebp
  0007e	5e		 pop	 esi
  0007f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00084	c9		 leave
  00085	c2 04 00	 ret	 4
?LoadProperty@ioCreateDummyByAttackedBuff2@@UAEXAAVioINILoader@@@Z ENDP ; ioCreateDummyByAttackedBuff2::LoadProperty
_TEXT	ENDS
PUBLIC	?OwnerCharApplyWeapon@ioCreateDummyByAttackedBuff2@@QAEXXZ ; ioCreateDummyByAttackedBuff2::OwnerCharApplyWeapon
EXTRN	??1IORandom@@UAE@XZ:PROC			; IORandom::~IORandom
EXTRN	?Random@IORandom@@QAEII@Z:PROC			; IORandom::Random
EXTRN	?SetRandomSeed@IORandom@@QAEXI@Z:PROC		; IORandom::SetRandomSeed
EXTRN	__imp__timeGetTime@0:PROC
EXTRN	??0IORandom@@QAE@XZ:PROC			; IORandom::IORandom
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?OwnerCharApplyWeapon@ioCreateDummyByAttackedBuff2@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OwnerCharApplyWeapon@ioCreateDummyByAttackedBuff2@@QAEXXZ$0
__ehfuncinfo$?OwnerCharApplyWeapon@ioCreateDummyByAttackedBuff2@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?OwnerCharApplyWeapon@ioCreateDummyByAttackedBuff2@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ?OwnerCharApplyWeapon@ioCreateDummyByAttackedBuff2@@QAEXXZ
_TEXT	SEGMENT
_random$ = -2524					; size = 2508
__$EHRec$ = -12						; size = 12
?OwnerCharApplyWeapon@ioCreateDummyByAttackedBuff2@@QAEXXZ PROC ; ioCreateDummyByAttackedBuff2::OwnerCharApplyWeapon, COMDAT
; _this$ = ecx

; 48   : {

  00000	68 d0 09 00 00	 push	 2512			; 000009d0H
  00005	b8 00 00 00 00	 mov	 eax, __ehhandler$?OwnerCharApplyWeapon@ioCreateDummyByAttackedBuff2@@QAEXXZ
  0000a	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000f	8b f1		 mov	 esi, ecx

; 49   : 	if ( !m_pOwner || !m_pOwner->IsNeedProcess() )

  00011	83 be 74 02 00
	00 00		 cmp	 DWORD PTR [esi+628], 0
  00018	74 67		 je	 SHORT $LN2@OwnerCharA
  0001a	8b 8e 74 02 00
	00		 mov	 ecx, DWORD PTR [esi+628]
  00020	8b 01		 mov	 eax, DWORD PTR [ecx]
  00022	ff 90 00 01 00
	00		 call	 DWORD PTR [eax+256]
  00028	84 c0		 test	 al, al
  0002a	74 55		 je	 SHORT $LN2@OwnerCharA

; 50   : 		return;
; 51   : 
; 52   : 	IORandom random;

  0002c	8d 8d 24 f6 ff
	ff		 lea	 ecx, DWORD PTR _random$[ebp]
  00032	e8 00 00 00 00	 call	 ??0IORandom@@QAE@XZ	; IORandom::IORandom
  00037	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 53   : 	random.SetRandomSeed( timeGetTime() );

  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  00041	50		 push	 eax
  00042	8d 8d 24 f6 ff
	ff		 lea	 ecx, DWORD PTR _random$[ebp]
  00048	e8 00 00 00 00	 call	 ?SetRandomSeed@IORandom@@QAEXI@Z ; IORandom::SetRandomSeed

; 54   : 	int iRand = random.Random( 1000 );

  0004d	68 e8 03 00 00	 push	 1000			; 000003e8H
  00052	8d 8d 24 f6 ff
	ff		 lea	 ecx, DWORD PTR _random$[ebp]
  00058	e8 00 00 00 00	 call	 ?Random@IORandom@@QAEII@Z ; IORandom::Random

; 55   : 
; 56   : 	if ( iRand > m_iCheckPercent )

  0005d	3b 86 8c 09 00
	00		 cmp	 eax, DWORD PTR [esi+2444]

; 57   : 		return;

  00063	7f 0d		 jg	 SHORT $LN8@OwnerCharA

; 58   : 
; 59   : 	CreateDummyChar( m_pOwner );

  00065	ff b6 74 02 00
	00		 push	 DWORD PTR [esi+628]
  0006b	8b ce		 mov	 ecx, esi
  0006d	e8 00 00 00 00	 call	 ?CreateDummyChar@ioCreateDummyByAttackedBuff2@@QAEXPAVioBaseChar@@@Z ; ioCreateDummyByAttackedBuff2::CreateDummyChar
$LN8@OwnerCharA:

; 60   : }

  00072	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00076	8d 8d 24 f6 ff
	ff		 lea	 ecx, DWORD PTR _random$[ebp]
  0007c	e8 00 00 00 00	 call	 ??1IORandom@@UAE@XZ	; IORandom::~IORandom
$LN2@OwnerCharA:
  00081	e8 00 00 00 00	 call	 __EH_epilog3_GS
  00086	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OwnerCharApplyWeapon@ioCreateDummyByAttackedBuff2@@QAEXXZ$0:
  00000	8d 8d 24 f6 ff
	ff		 lea	 ecx, DWORD PTR _random$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1IORandom@@UAE@XZ	; IORandom::~IORandom
__ehhandler$?OwnerCharApplyWeapon@ioCreateDummyByAttackedBuff2@@QAEXXZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 20 f6 ff
	ff		 mov	 ecx, DWORD PTR [edx-2528]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OwnerCharApplyWeapon@ioCreateDummyByAttackedBuff2@@QAEXXZ
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OwnerCharApplyWeapon@ioCreateDummyByAttackedBuff2@@QAEXXZ ENDP ; ioCreateDummyByAttackedBuff2::OwnerCharApplyWeapon
PUBLIC	?_Buy@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@IAE_NI@Z ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::_Buy
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::_Buy, COMDAT
; _this$ = ecx

; 1250 : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1251 : 		this->_Myfirst = 0;

  00004	33 c0		 xor	 eax, eax
  00006	57		 push	 edi

; 1252 : 		this->_Mylast = 0;
; 1253 : 		this->_Myend = 0;
; 1254 : 
; 1255 : 		if (_Capacity == 0)

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Capacity$[ebp]
  0000a	8b f1		 mov	 esi, ecx
  0000c	89 06		 mov	 DWORD PTR [esi], eax
  0000e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00011	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00014	3b f8		 cmp	 edi, eax
  00016	75 04		 jne	 SHORT $LN4@Buy

; 1256 : 			return (false);

  00018	32 c0		 xor	 al, al
  0001a	eb 2b		 jmp	 SHORT $LN5@Buy
$LN4@Buy:

; 1257 : 		else if (max_size() < _Capacity)

  0001c	81 ff 49 92 24
	09		 cmp	 edi, 153391689		; 09249249H
  00022	76 0b		 jbe	 SHORT $LN2@Buy

; 1258 : 			_Xlen();	// result too long

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN19@Buy:
$LN2@Buy:

; 1259 : 		else
; 1260 : 			{	// nonempty array, allocate storage
; 1261 : 			this->_Myfirst = this->_Alval.allocate(_Capacity);

  0002f	50		 push	 eax
  00030	57		 push	 edi
  00031	e8 00 00 00 00	 call	 ??$_Allocate@UtagDummyCharLoadInfo@@@std@@YAPAUtagDummyCharLoadInfo@@IPAU1@@Z ; std::_Allocate<tagDummyCharLoadInfo>

; 1262 : 			this->_Mylast = this->_Myfirst;
; 1263 : 			this->_Myend = this->_Myfirst + _Capacity;

  00036	6b ff 1c	 imul	 edi, 28			; 0000001cH
  00039	03 f8		 add	 edi, eax
  0003b	59		 pop	 ecx
  0003c	89 06		 mov	 DWORD PTR [esi], eax
  0003e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00041	59		 pop	 ecx
  00042	89 7e 08	 mov	 DWORD PTR [esi+8], edi

; 1264 : 			}
; 1265 : 		return (true);

  00045	b0 01		 mov	 al, 1
$LN5@Buy:
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi

; 1266 : 		}

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
$LN18@Buy:
?_Buy@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::_Buy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UtagDummyCharLoadInfo@@@std@@QAEXPAUtagDummyCharLoadInfo@@ABU3@@Z ; std::allocator<tagDummyCharLoadInfo>::construct
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@UtagDummyCharLoadInfo@@@std@@QAEXPAUtagDummyCharLoadInfo@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UtagDummyCharLoadInfo@@@std@@QAEXPAUtagDummyCharLoadInfo@@ABU3@@Z PROC ; std::allocator<tagDummyCharLoadInfo>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 		_Construct(_Ptr, _Val);

  00003	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  00006	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00009	e8 00 00 00 00	 call	 ??$_Construct@UtagDummyCharLoadInfo@@ABU1@@std@@YAXPAUtagDummyCharLoadInfo@@ABU1@@Z ; std::_Construct<tagDummyCharLoadInfo,tagDummyCharLoadInfo const &>
  0000e	59		 pop	 ecx
  0000f	59		 pop	 ecx

; 198  : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?construct@?$allocator@UtagDummyCharLoadInfo@@@std@@QAEXPAUtagDummyCharLoadInfo@@ABU3@@Z ENDP ; std::allocator<tagDummyCharLoadInfo>::construct
_TEXT	ENDS
PUBLIC	??0?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ ; std::vector<ioHashString,std::allocator<ioHashString> >::vector<ioHashString,std::allocator<ioHashString> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::vector<ioHashString,std::allocator<ioHashString> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::vector<ioHashString,std::allocator<ioHashString> >
_TEXT	ENDS
PUBLIC	??0?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@XZ ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAE_NI@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::_Buy
; Function compile flags: /Ogsp
;	COMDAT ?_Buy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAE_NI@Z PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::_Buy, COMDAT
; _this$ = ecx

; 1250 : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1251 : 		this->_Myfirst = 0;

  00004	33 c0		 xor	 eax, eax
  00006	57		 push	 edi

; 1252 : 		this->_Mylast = 0;
; 1253 : 		this->_Myend = 0;
; 1254 : 
; 1255 : 		if (_Capacity == 0)

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Capacity$[ebp]
  0000a	8b f1		 mov	 esi, ecx
  0000c	89 06		 mov	 DWORD PTR [esi], eax
  0000e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00011	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00014	3b f8		 cmp	 edi, eax
  00016	75 04		 jne	 SHORT $LN4@Buy@2

; 1256 : 			return (false);

  00018	32 c0		 xor	 al, al
  0001a	eb 2b		 jmp	 SHORT $LN5@Buy@2
$LN4@Buy@2:

; 1257 : 		else if (max_size() < _Capacity)

  0001c	81 ff ff ff ff
	0f		 cmp	 edi, 268435455		; 0fffffffH
  00022	76 0b		 jbe	 SHORT $LN2@Buy@2

; 1258 : 			_Xlen();	// result too long

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN19@Buy@2:
$LN2@Buy@2:

; 1259 : 		else
; 1260 : 			{	// nonempty array, allocate storage
; 1261 : 			this->_Myfirst = this->_Alval.allocate(_Capacity);

  0002f	50		 push	 eax
  00030	57		 push	 edi
  00031	e8 00 00 00 00	 call	 ??$_Allocate@VioHashString@@@std@@YAPAVioHashString@@IPAV1@@Z ; std::_Allocate<ioHashString>

; 1262 : 			this->_Mylast = this->_Myfirst;
; 1263 : 			this->_Myend = this->_Myfirst + _Capacity;

  00036	c1 e7 04	 shl	 edi, 4
  00039	03 f8		 add	 edi, eax
  0003b	59		 pop	 ecx
  0003c	89 06		 mov	 DWORD PTR [esi], eax
  0003e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00041	59		 pop	 ecx
  00042	89 7e 08	 mov	 DWORD PTR [esi+8], edi

; 1264 : 			}
; 1265 : 		return (true);

  00045	b0 01		 mov	 al, 1
$LN5@Buy@2:
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi

; 1266 : 		}

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
$LN18@Buy@2:
?_Buy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::_Buy
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::operator!=
; Function compile flags: /Ogsp
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 209  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::operator!=
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >::operator!=
; Function compile flags: /Ogsp
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 209  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >::operator!=
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@@Z ; std::allocator<ioHashString>::destroy
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@@Z PROC ; std::allocator<ioHashString>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 213  : 		_Destroy(_Ptr);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ

; 214  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?destroy@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@@Z ENDP ; std::allocator<ioHashString>::destroy
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@VioHashString@@@std@@VioHashString@@ABV3@@std@@YAXAAV?$allocator@VioHashString@@@0@PAVioHashString@@ABV2@@Z ; std::_Cons_val<std::allocator<ioHashString>,ioHashString,ioHashString const &>
; Function compile flags: /Ogsp
;	COMDAT ??$_Cons_val@V?$allocator@VioHashString@@@std@@VioHashString@@ABV3@@std@@YAXAAV?$allocator@VioHashString@@@0@PAVioHashString@@ABV2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@VioHashString@@@std@@VioHashString@@ABV3@@std@@YAXAAV?$allocator@VioHashString@@@0@PAVioHashString@@ABV2@@Z PROC ; std::_Cons_val<std::allocator<ioHashString>,ioHashString,ioHashString const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	ff 75 10	 push	 DWORD PTR __Src$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR __Pdest$[ebp]
  00009	e8 00 00 00 00	 call	 ??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z ; std::_Construct<ioHashString,ioHashString const &>
  0000e	59		 pop	 ecx
  0000f	59		 pop	 ecx

; 281  : 	}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Cons_val@V?$allocator@VioHashString@@@std@@VioHashString@@ABV3@@std@@YAXAAV?$allocator@VioHashString@@@0@PAVioHashString@@ABV2@@Z ENDP ; std::_Cons_val<std::allocator<ioHashString>,ioHashString,ioHashString const &>
_TEXT	ENDS
PUBLIC	??$_Destroy@UtagDummyCharLoadInfo@@@std@@YAXPAUtagDummyCharLoadInfo@@@Z ; std::_Destroy<tagDummyCharLoadInfo>
; Function compile flags: /Ogsp
;	COMDAT ??$_Destroy@UtagDummyCharLoadInfo@@@std@@YAXPAUtagDummyCharLoadInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UtagDummyCharLoadInfo@@@std@@YAXPAUtagDummyCharLoadInfo@@@Z PROC ; std::_Destroy<tagDummyCharLoadInfo>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 63   : 	_Ptr->~_Ty();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 64   : 	}

  00006	5d		 pop	 ebp

; 63   : 	_Ptr->~_Ty();

  00007	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
??$_Destroy@UtagDummyCharLoadInfo@@@std@@YAXPAUtagDummyCharLoadInfo@@@Z ENDP ; std::_Destroy<tagDummyCharLoadInfo>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UtagDummyCharLoadInfo@@@std@@UtagDummyCharLoadInfo@@ABU3@@std@@YAXAAV?$allocator@UtagDummyCharLoadInfo@@@0@PAUtagDummyCharLoadInfo@@ABU2@@Z ; std::_Cons_val<std::allocator<tagDummyCharLoadInfo>,tagDummyCharLoadInfo,tagDummyCharLoadInfo const &>
; Function compile flags: /Ogsp
;	COMDAT ??$_Cons_val@V?$allocator@UtagDummyCharLoadInfo@@@std@@UtagDummyCharLoadInfo@@ABU3@@std@@YAXAAV?$allocator@UtagDummyCharLoadInfo@@@0@PAUtagDummyCharLoadInfo@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UtagDummyCharLoadInfo@@@std@@UtagDummyCharLoadInfo@@ABU3@@std@@YAXAAV?$allocator@UtagDummyCharLoadInfo@@@0@PAUtagDummyCharLoadInfo@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<tagDummyCharLoadInfo>,tagDummyCharLoadInfo,tagDummyCharLoadInfo const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	ff 75 10	 push	 DWORD PTR __Src$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR __Pdest$[ebp]
  00009	e8 00 00 00 00	 call	 ??$_Construct@UtagDummyCharLoadInfo@@ABU1@@std@@YAXPAUtagDummyCharLoadInfo@@ABU1@@Z ; std::_Construct<tagDummyCharLoadInfo,tagDummyCharLoadInfo const &>
  0000e	59		 pop	 ecx
  0000f	59		 pop	 ecx

; 281  : 	}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Cons_val@V?$allocator@UtagDummyCharLoadInfo@@@std@@UtagDummyCharLoadInfo@@ABU3@@std@@YAXAAV?$allocator@UtagDummyCharLoadInfo@@@0@PAUtagDummyCharLoadInfo@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<tagDummyCharLoadInfo>,tagDummyCharLoadInfo,tagDummyCharLoadInfo const &>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@VioHashString@@@std@@VioHashString@@@std@@YAXAAV?$allocator@VioHashString@@@0@PAVioHashString@@@Z ; std::_Dest_val<std::allocator<ioHashString>,ioHashString>
; Function compile flags: /Ogsp
;	COMDAT ??$_Dest_val@V?$allocator@VioHashString@@@std@@VioHashString@@@std@@YAXAAV?$allocator@VioHashString@@@0@PAVioHashString@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@VioHashString@@@std@@VioHashString@@@std@@YAXAAV?$allocator@VioHashString@@@0@PAVioHashString@@@Z PROC ; std::_Dest_val<std::allocator<ioHashString>,ioHashString>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 287  : 	_Alval.destroy(_Pdest);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]

; 288  : 	}

  00006	5d		 pop	 ebp

; 287  : 	_Alval.destroy(_Pdest);

  00007	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
??$_Dest_val@V?$allocator@VioHashString@@@std@@VioHashString@@@std@@YAXAAV?$allocator@VioHashString@@@0@PAVioHashString@@@Z ENDP ; std::_Dest_val<std::allocator<ioHashString>,ioHashString>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UtagDummyCharLoadInfo@@@std@@QAEXPAUtagDummyCharLoadInfo@@@Z ; std::allocator<tagDummyCharLoadInfo>::destroy
; Function compile flags: /Ogsp
;	COMDAT ?destroy@?$allocator@UtagDummyCharLoadInfo@@@std@@QAEXPAUtagDummyCharLoadInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UtagDummyCharLoadInfo@@@std@@QAEXPAUtagDummyCharLoadInfo@@@Z PROC ; std::allocator<tagDummyCharLoadInfo>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 213  : 		_Destroy(_Ptr);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ

; 214  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?destroy@?$allocator@UtagDummyCharLoadInfo@@@std@@QAEXPAUtagDummyCharLoadInfo@@@Z ENDP ; std::allocator<tagDummyCharLoadInfo>::destroy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VioHashString@@@std@@@std@@YAXPAVioHashString@@0AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<ioHashString> >
; Function compile flags: /Ogsp
;	COMDAT ??$_Destroy_range@V?$allocator@VioHashString@@@std@@@std@@YAXPAVioHashString@@0AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@VioHashString@@@std@@@std@@YAXPAVioHashString@@0AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<ioHashString> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 96   : 	for (; _First != _Last; ++_First)

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	eb 0b		 jmp	 SHORT $LN17@Destroy_ra
$LL3@Destroy_ra:

; 97   : 		_Dest_val(_Al, _First);

  00009	8b ce		 mov	 ecx, esi
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00011	83 c6 10	 add	 esi, 16			; 00000010H
$LN17@Destroy_ra:

; 96   : 	for (; _First != _Last; ++_First)

  00014	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00017	75 f0		 jne	 SHORT $LL3@Destroy_ra
  00019	5e		 pop	 esi

; 98   : 	}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Destroy_range@V?$allocator@VioHashString@@@std@@@std@@YAXPAVioHashString@@0AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<ioHashString> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@PAVioHashString@@V?$allocator@VioHashString@@@2@@std@@YAPAVioHashString@@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@0@0PAV1@AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >,ioHashString *,std::allocator<ioHashString> >
EXTRN	__EH_prolog3_catch:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@PAVioHashString@@V?$allocator@VioHashString@@@2@@std@@YAPAVioHashString@@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@0@0PAV1@AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@PAVioHashString@@V?$allocator@VioHashString@@@2@@std@@YAPAVioHashString@@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@0@0PAV1@AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@PAVioHashString@@V?$allocator@VioHashString@@@2@@std@@YAPAVioHashString@@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@0@0PAV1@AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@PAVioHashString@@V?$allocator@VioHashString@@@2@@std@@YAPAVioHashString@@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@0@0PAV1@AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@PAVioHashString@@V?$allocator@VioHashString@@@2@@std@@YAPAVioHashString@@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@0@0PAV1@AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@PAVioHashString@@V?$allocator@VioHashString@@@2@@std@@YAPAVioHashString@@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@0@0PAV1@AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@PAVioHashString@@V?$allocator@VioHashString@@@2@@std@@YAPAVioHashString@@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@0@0PAV1@AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@PAVioHashString@@V?$allocator@VioHashString@@@2@@std@@YAPAVioHashString@@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@0@0PAV1@AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@PAVioHashString@@V?$allocator@VioHashString@@@2@@std@@YAPAVioHashString@@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@0@0PAV1@AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@PAVioHashString@@V?$allocator@VioHashString@@@2@@std@@YAPAVioHashString@@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@0@0PAV1@AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >,ioHashString *,std::allocator<ioHashString> >, COMDAT

; 369  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	6a 08		 push	 8
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@PAVioHashString@@V?$allocator@VioHashString@@@2@@std@@YAPAVioHashString@@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@0@0PAV1@AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_catch

; 370  : 	_DEBUG_RANGE(_First, _Last);
; 371  : 	_DEBUG_POINTER(_Dest);
; 372  : 	_FwdIt _Next = _Dest;

  0000c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 373  : 
; 374  : 	_TRY_BEGIN

  0000f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
  00013	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 375  : 	for (; _First != _Last; ++_Dest, ++_First)

$LL14@Uninit_cop:
  00016	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00019	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001c	74 33		 je	 SHORT $LN4@Uninit_cop

; 376  : 		_Cons_val(_Al, _Dest, *_First);

  0001e	50		 push	 eax
  0001f	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00022	e8 00 00 00 00	 call	 ??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z ; std::_Construct<ioHashString,ioHashString const &>
  00027	83 45 10 10	 add	 DWORD PTR __Dest$[ebp], 16 ; 00000010H
  0002b	83 45 08 10	 add	 DWORD PTR __First$[ebp], 16 ; 00000010H
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
  00031	eb e3		 jmp	 SHORT $LL14@Uninit_cop
__catch$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@PAVioHashString@@V?$allocator@VioHashString@@@2@@std@@YAPAVioHashString@@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@0@0PAV1@AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 377  : 	_CATCH_ALL
; 378  : 	for (; _Next != _Dest; ++_Next)

  00033	8b 75 ec	 mov	 esi, DWORD PTR __Next$[ebp]
  00036	eb 0b		 jmp	 SHORT $LN45@Uninit_cop
$LL3@Uninit_cop:

; 379  : 		_Dest_val(_Al, _Next);

  00038	8b ce		 mov	 ecx, esi
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00040	83 c6 10	 add	 esi, 16			; 00000010H
$LN45@Uninit_cop:

; 377  : 	_CATCH_ALL
; 378  : 	for (; _Next != _Dest; ++_Next)

  00043	3b 75 10	 cmp	 esi, DWORD PTR __Dest$[ebp]
  00046	75 f0		 jne	 SHORT $LL3@Uninit_cop

; 380  : 	_RERAISE;

  00048	6a 00		 push	 0
  0004a	6a 00		 push	 0
  0004c	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN46@Uninit_cop:
$LN4@Uninit_cop:

; 381  : 	_CATCH_END
; 382  : 	return (_Dest);

  00051	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 383  : 	}

  00054	e8 00 00 00 00	 call	 __EH_epilog3
  00059	c3		 ret	 0
$LN44@Uninit_cop:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@PAVioHashString@@V?$allocator@VioHashString@@@2@@std@@YAPAVioHashString@@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@0@0PAV1@AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@PAVioHashString@@V?$allocator@VioHashString@@@2@@std@@YAPAVioHashString@@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@0@0PAV1@AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@PAVioHashString@@V?$allocator@VioHashString@@@2@@std@@YAPAVioHashString@@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@0@0PAV1@AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >,ioHashString *,std::allocator<ioHashString> >
PUBLIC	??$_Dest_val@V?$allocator@UtagDummyCharLoadInfo@@@std@@UtagDummyCharLoadInfo@@@std@@YAXAAV?$allocator@UtagDummyCharLoadInfo@@@0@PAUtagDummyCharLoadInfo@@@Z ; std::_Dest_val<std::allocator<tagDummyCharLoadInfo>,tagDummyCharLoadInfo>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@UtagDummyCharLoadInfo@@@std@@UtagDummyCharLoadInfo@@@std@@YAXAAV?$allocator@UtagDummyCharLoadInfo@@@0@PAUtagDummyCharLoadInfo@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UtagDummyCharLoadInfo@@@std@@UtagDummyCharLoadInfo@@@std@@YAXAAV?$allocator@UtagDummyCharLoadInfo@@@0@PAUtagDummyCharLoadInfo@@@Z PROC ; std::_Dest_val<std::allocator<tagDummyCharLoadInfo>,tagDummyCharLoadInfo>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 287  : 	_Alval.destroy(_Pdest);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]

; 288  : 	}

  00006	5d		 pop	 ebp

; 287  : 	_Alval.destroy(_Pdest);

  00007	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
??$_Dest_val@V?$allocator@UtagDummyCharLoadInfo@@@std@@UtagDummyCharLoadInfo@@@std@@YAXAAV?$allocator@UtagDummyCharLoadInfo@@@0@PAUtagDummyCharLoadInfo@@@Z ENDP ; std::_Dest_val<std::allocator<tagDummyCharLoadInfo>,tagDummyCharLoadInfo>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@PAUtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@2@@std@@YAPAUtagDummyCharLoadInfo@@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@0@0PAU1@AAV?$allocator@UtagDummyCharLoadInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >,tagDummyCharLoadInfo *,std::allocator<tagDummyCharLoadInfo> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@PAUtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@2@@std@@YAPAUtagDummyCharLoadInfo@@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@0@0PAU1@AAV?$allocator@UtagDummyCharLoadInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@PAUtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@2@@std@@YAPAUtagDummyCharLoadInfo@@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@0@0PAU1@AAV?$allocator@UtagDummyCharLoadInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@PAUtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@2@@std@@YAPAUtagDummyCharLoadInfo@@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@0@0PAU1@AAV?$allocator@UtagDummyCharLoadInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@PAUtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@2@@std@@YAPAUtagDummyCharLoadInfo@@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@0@0PAU1@AAV?$allocator@UtagDummyCharLoadInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@PAUtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@2@@std@@YAPAUtagDummyCharLoadInfo@@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@0@0PAU1@AAV?$allocator@UtagDummyCharLoadInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$3
__ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@PAUtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@2@@std@@YAPAUtagDummyCharLoadInfo@@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@0@0PAU1@AAV?$allocator@UtagDummyCharLoadInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@PAUtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@2@@std@@YAPAUtagDummyCharLoadInfo@@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@0@0PAU1@AAV?$allocator@UtagDummyCharLoadInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@PAUtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@2@@std@@YAPAUtagDummyCharLoadInfo@@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@0@0PAU1@AAV?$allocator@UtagDummyCharLoadInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@PAUtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@2@@std@@YAPAUtagDummyCharLoadInfo@@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@0@0PAU1@AAV?$allocator@UtagDummyCharLoadInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@PAUtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@2@@std@@YAPAUtagDummyCharLoadInfo@@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@0@0PAU1@AAV?$allocator@UtagDummyCharLoadInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >,tagDummyCharLoadInfo *,std::allocator<tagDummyCharLoadInfo> >, COMDAT

; 369  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	6a 08		 push	 8
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@PAUtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@2@@std@@YAPAUtagDummyCharLoadInfo@@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@0@0PAU1@AAV?$allocator@UtagDummyCharLoadInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_catch

; 370  : 	_DEBUG_RANGE(_First, _Last);
; 371  : 	_DEBUG_POINTER(_Dest);
; 372  : 	_FwdIt _Next = _Dest;

  0000c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 373  : 
; 374  : 	_TRY_BEGIN

  0000f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
  00013	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 375  : 	for (; _First != _Last; ++_Dest, ++_First)

$LL14@Uninit_cop@2:
  00016	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00019	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001c	74 33		 je	 SHORT $LN4@Uninit_cop@2

; 376  : 		_Cons_val(_Al, _Dest, *_First);

  0001e	50		 push	 eax
  0001f	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00022	e8 00 00 00 00	 call	 ??$_Construct@UtagDummyCharLoadInfo@@ABU1@@std@@YAXPAUtagDummyCharLoadInfo@@ABU1@@Z ; std::_Construct<tagDummyCharLoadInfo,tagDummyCharLoadInfo const &>
  00027	83 45 10 1c	 add	 DWORD PTR __Dest$[ebp], 28 ; 0000001cH
  0002b	83 45 08 1c	 add	 DWORD PTR __First$[ebp], 28 ; 0000001cH
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
  00031	eb e3		 jmp	 SHORT $LL14@Uninit_cop@2
__catch$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@PAUtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@2@@std@@YAPAUtagDummyCharLoadInfo@@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@0@0PAU1@AAV?$allocator@UtagDummyCharLoadInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 377  : 	_CATCH_ALL
; 378  : 	for (; _Next != _Dest; ++_Next)

  00033	8b 75 ec	 mov	 esi, DWORD PTR __Next$[ebp]
  00036	eb 0b		 jmp	 SHORT $LN48@Uninit_cop@2
$LL3@Uninit_cop@2:

; 379  : 		_Dest_val(_Al, _Next);

  00038	8b ce		 mov	 ecx, esi
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00040	83 c6 1c	 add	 esi, 28			; 0000001cH
$LN48@Uninit_cop@2:

; 377  : 	_CATCH_ALL
; 378  : 	for (; _Next != _Dest; ++_Next)

  00043	3b 75 10	 cmp	 esi, DWORD PTR __Dest$[ebp]
  00046	75 f0		 jne	 SHORT $LL3@Uninit_cop@2

; 380  : 	_RERAISE;

  00048	6a 00		 push	 0
  0004a	6a 00		 push	 0
  0004c	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN49@Uninit_cop@2:
$LN4@Uninit_cop@2:

; 381  : 	_CATCH_END
; 382  : 	return (_Dest);

  00051	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 383  : 	}

  00054	e8 00 00 00 00	 call	 __EH_epilog3
  00059	c3		 ret	 0
$LN47@Uninit_cop@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@PAUtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@2@@std@@YAPAUtagDummyCharLoadInfo@@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@0@0PAU1@AAV?$allocator@UtagDummyCharLoadInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@PAUtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@2@@std@@YAPAUtagDummyCharLoadInfo@@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@0@0PAU1@AAV?$allocator@UtagDummyCharLoadInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@PAUtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@2@@std@@YAPAUtagDummyCharLoadInfo@@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@0@0PAU1@AAV?$allocator@UtagDummyCharLoadInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >,tagDummyCharLoadInfo *,std::allocator<tagDummyCharLoadInfo> >
PUBLIC	??$_Destroy_range@V?$allocator@VioHashString@@@std@@@std@@YAXPAVioHashString@@0AAV?$allocator@VioHashString@@@0@@Z ; std::_Destroy_range<std::allocator<ioHashString> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VioHashString@@@std@@@std@@YAXPAVioHashString@@0AAV?$allocator@VioHashString@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@VioHashString@@@std@@@std@@YAXPAVioHashString@@0AAV?$allocator@VioHashString@@@0@@Z PROC ; std::_Destroy_range<std::allocator<ioHashString> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	eb 0b		 jmp	 SHORT $LN21@Destroy_ra@2
$LL7@Destroy_ra@2:
  00009	8b ce		 mov	 ecx, esi
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00011	83 c6 10	 add	 esi, 16			; 00000010H
$LN21@Destroy_ra@2:
  00014	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00017	75 f0		 jne	 SHORT $LL7@Destroy_ra@2
  00019	5e		 pop	 esi

; 89   : 	}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Destroy_range@V?$allocator@VioHashString@@@std@@@std@@YAXPAVioHashString@@0AAV?$allocator@VioHashString@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<ioHashString> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@PAVioHashString@@V?$allocator@VioHashString@@@2@@std@@YAPAVioHashString@@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@0@0PAV1@AAV?$allocator@VioHashString@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >,ioHashString *,std::allocator<ioHashString> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@PAVioHashString@@V?$allocator@VioHashString@@@2@@std@@YAPAVioHashString@@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@0@0PAV1@AAV?$allocator@VioHashString@@@0@@Z
_TEXT	SEGMENT
__Cat$532575 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@PAVioHashString@@V?$allocator@VioHashString@@@2@@std@@YAPAVioHashString@@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@0@0PAV1@AAV?$allocator@VioHashString@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >,ioHashString *,std::allocator<ioHashString> >, COMDAT

; 412  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 413  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 414  : 		_Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$532575[ebp]
  00007	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000a	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000d	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00010	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00013	e8 00 00 00 00	 call	 ??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@PAVioHashString@@V?$allocator@VioHashString@@@2@@std@@YAPAVioHashString@@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@0@0PAV1@AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >,ioHashString *,std::allocator<ioHashString> >
  00018	83 c4 14	 add	 esp, 20			; 00000014H

; 415  : 	}

  0001b	c9		 leave
  0001c	c3		 ret	 0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@PAVioHashString@@V?$allocator@VioHashString@@@2@@std@@YAPAVioHashString@@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@0@0PAV1@AAV?$allocator@VioHashString@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >,ioHashString *,std::allocator<ioHashString> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@YAXPAUtagDummyCharLoadInfo@@0AAV?$allocator@UtagDummyCharLoadInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<tagDummyCharLoadInfo> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@YAXPAUtagDummyCharLoadInfo@@0AAV?$allocator@UtagDummyCharLoadInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@YAXPAUtagDummyCharLoadInfo@@0AAV?$allocator@UtagDummyCharLoadInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<tagDummyCharLoadInfo> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 96   : 	for (; _First != _Last; ++_First)

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	eb 0b		 jmp	 SHORT $LN20@Destroy_ra@3
$LL3@Destroy_ra@3:

; 97   : 		_Dest_val(_Al, _First);

  00009	8b ce		 mov	 ecx, esi
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00011	83 c6 1c	 add	 esi, 28			; 0000001cH
$LN20@Destroy_ra@3:

; 96   : 	for (; _First != _Last; ++_First)

  00014	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00017	75 f0		 jne	 SHORT $LL3@Destroy_ra@3
  00019	5e		 pop	 esi

; 98   : 	}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Destroy_range@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@YAXPAUtagDummyCharLoadInfo@@0AAV?$allocator@UtagDummyCharLoadInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<tagDummyCharLoadInfo> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@PAUtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@2@@std@@YAPAUtagDummyCharLoadInfo@@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@0@0PAU1@AAV?$allocator@UtagDummyCharLoadInfo@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >,tagDummyCharLoadInfo *,std::allocator<tagDummyCharLoadInfo> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@PAUtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@2@@std@@YAPAUtagDummyCharLoadInfo@@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@0@0PAU1@AAV?$allocator@UtagDummyCharLoadInfo@@@0@@Z
_TEXT	SEGMENT
__Cat$532627 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@PAUtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@2@@std@@YAPAUtagDummyCharLoadInfo@@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@0@0PAU1@AAV?$allocator@UtagDummyCharLoadInfo@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >,tagDummyCharLoadInfo *,std::allocator<tagDummyCharLoadInfo> >, COMDAT

; 412  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 413  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 414  : 		_Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$532627[ebp]
  00007	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000a	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000d	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00010	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00013	e8 00 00 00 00	 call	 ??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@PAUtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@2@@std@@YAPAUtagDummyCharLoadInfo@@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@0@0PAU1@AAV?$allocator@UtagDummyCharLoadInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >,tagDummyCharLoadInfo *,std::allocator<tagDummyCharLoadInfo> >
  00018	83 c4 14	 add	 esp, 20			; 00000014H

; 415  : 	}

  0001b	c9		 leave
  0001c	c3		 ret	 0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@PAUtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@2@@std@@YAPAUtagDummyCharLoadInfo@@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@0@0PAU1@AAV?$allocator@UtagDummyCharLoadInfo@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >,tagDummyCharLoadInfo *,std::allocator<tagDummyCharLoadInfo> >
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXPAVioHashString@@0@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::_Destroy
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXPAVioHashString@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXPAVioHashString@@0@Z PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	eb 0b		 jmp	 SHORT $LN23@Destroy
$LL9@Destroy:
  00009	8b ce		 mov	 ecx, esi
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00011	83 c6 10	 add	 esi, 16			; 00000010H
$LN23@Destroy:
  00014	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00017	75 f0		 jne	 SHORT $LL9@Destroy
  00019	5e		 pop	 esi

; 1271 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
?_Destroy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXPAVioHashString@@0@Z ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEPAVioHashString@@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@1@0PAV2@@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > > >
; Function compile flags: /Ogsp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEPAVioHashString@@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@1@0PAV2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$532715 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEPAVioHashString@@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@1@0PAV2@@Z PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > > >, COMDAT
; _this$ = ecx

; 1315 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1316 : 		{	// copy initializing [_First, _Last), using allocator
; 1317 : 		return (_Uninitialized_copy(_First, _Last,
; 1318 : 			_Ptr, this->_Alval));

  00003	ff 75 10	 push	 DWORD PTR __Cat$532715[ebp]
  00006	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00009	51		 push	 ecx
  0000a	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0000d	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00010	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00013	e8 00 00 00 00	 call	 ??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@PAVioHashString@@V?$allocator@VioHashString@@@2@@std@@YAPAVioHashString@@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@0@0PAV1@AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >,ioHashString *,std::allocator<ioHashString> >
  00018	83 c4 14	 add	 esp, 20			; 00000014H

; 1319 : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEPAVioHashString@@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@1@0PAV2@@Z ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > > >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@YAXPAUtagDummyCharLoadInfo@@0AAV?$allocator@UtagDummyCharLoadInfo@@@0@@Z ; std::_Destroy_range<std::allocator<tagDummyCharLoadInfo> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@YAXPAUtagDummyCharLoadInfo@@0AAV?$allocator@UtagDummyCharLoadInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@YAXPAUtagDummyCharLoadInfo@@0AAV?$allocator@UtagDummyCharLoadInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<tagDummyCharLoadInfo> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	eb 0b		 jmp	 SHORT $LN24@Destroy_ra@4
$LL7@Destroy_ra@4:
  00009	8b ce		 mov	 ecx, esi
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00011	83 c6 1c	 add	 esi, 28			; 0000001cH
$LN24@Destroy_ra@4:
  00014	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00017	75 f0		 jne	 SHORT $LL7@Destroy_ra@4
  00019	5e		 pop	 esi

; 89   : 	}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Destroy_range@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@YAXPAUtagDummyCharLoadInfo@@0AAV?$allocator@UtagDummyCharLoadInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<tagDummyCharLoadInfo> >
_TEXT	ENDS
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@IAEPAUtagDummyCharLoadInfo@@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@1@0PAU2@@Z ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > > >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@IAEPAUtagDummyCharLoadInfo@@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@1@0PAU2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$532799 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@IAEPAUtagDummyCharLoadInfo@@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@1@0PAU2@@Z PROC ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > > >, COMDAT
; _this$ = ecx

; 1315 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1316 : 		{	// copy initializing [_First, _Last), using allocator
; 1317 : 		return (_Uninitialized_copy(_First, _Last,
; 1318 : 			_Ptr, this->_Alval));

  00003	ff 75 10	 push	 DWORD PTR __Cat$532799[ebp]
  00006	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00009	51		 push	 ecx
  0000a	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0000d	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00010	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00013	e8 00 00 00 00	 call	 ??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@PAUtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@2@@std@@YAPAUtagDummyCharLoadInfo@@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@0@0PAU1@AAV?$allocator@UtagDummyCharLoadInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >,tagDummyCharLoadInfo *,std::allocator<tagDummyCharLoadInfo> >
  00018	83 c4 14	 add	 esp, 20			; 00000014H

; 1319 : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@IAEPAUtagDummyCharLoadInfo@@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@1@0PAU2@@Z ENDP ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > > >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXXZ ; std::vector<ioHashString,std::allocator<ioHashString> >::_Tidy
EXTRN	__imp_?_Orphan_all@_Container_base0@std@@QAEXXZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ?_Tidy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXXZ PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00006	74 28		 je	 SHORT $LN24@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00008	53		 push	 ebx
  00009	57		 push	 edi
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  00010	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00013	8b 3e		 mov	 edi, DWORD PTR [esi]
  00015	eb 0b		 jmp	 SHORT $LN28@Tidy
$LL12@Tidy:
  00017	8b cf		 mov	 ecx, edi
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  0001f	83 c7 10	 add	 edi, 16			; 00000010H
$LN28@Tidy:
  00022	3b fb		 cmp	 edi, ebx
  00024	75 f1		 jne	 SHORT $LL12@Tidy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002d	59		 pop	 ecx
  0002e	5f		 pop	 edi
  0002f	5b		 pop	 ebx
$LN24@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00030	33 c0		 xor	 eax, eax
  00032	89 06		 mov	 DWORD PTR [esi], eax

; 1310 : 		this->_Mylast = 0;

  00034	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1311 : 		this->_Myend = 0;

  00037	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003a	5e		 pop	 esi

; 1312 : 		}

  0003b	c3		 ret	 0
?_Tidy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXXZ ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@IAEXPAUtagDummyCharLoadInfo@@0@Z ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::_Destroy
; Function compile flags: /Ogsp
;	COMDAT ?_Destroy@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@IAEXPAUtagDummyCharLoadInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@IAEXPAUtagDummyCharLoadInfo@@0@Z PROC ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	eb 0b		 jmp	 SHORT $LN26@Destroy@2
$LL9@Destroy@2:
  00009	8b ce		 mov	 ecx, esi
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00011	83 c6 1c	 add	 esi, 28			; 0000001cH
$LN26@Destroy@2:
  00014	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00017	75 f0		 jne	 SHORT $LL9@Destroy@2
  00019	5e		 pop	 esi

; 1271 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
?_Destroy@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@IAEXPAUtagDummyCharLoadInfo@@0@Z ENDP ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::_Destroy
_TEXT	ENDS
PUBLIC	??0?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@ABV01@@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::vector<ioHashString,std::allocator<ioHashString> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??0?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@ABV01@@Z$0
__unwindtable$??0?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Cat$533078 = 8					; size = 1
__Right$ = 8						; size = 4
??0?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::vector<ioHashString,std::allocator<ioHashString> >, COMDAT
; _this$ = ecx

; 535  : 		{	// construct by copying _Right

  00000	6a 08		 push	 8
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@ABV01@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_catch
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 536  : 		if (_Buy(_Right.size()))

  00011	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]
  00014	33 db		 xor	 ebx, ebx
  00016	89 1e		 mov	 DWORD PTR [esi], ebx
  00018	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0001b	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  0001e	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00021	2b 07		 sub	 eax, DWORD PTR [edi]
  00023	c1 f8 04	 sar	 eax, 4
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?_Buy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAE_NI@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::_Buy
  0002c	84 c0		 test	 al, al
  0002e	74 1f		 je	 SHORT $LN7@vector

; 537  : 			_TRY_BEGIN
; 538  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 539  : 				this->_Myfirst);

  00030	ff 75 08	 push	 DWORD PTR __Cat$533078[ebp]
  00033	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00035	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00038	8b 3f		 mov	 edi, DWORD PTR [edi]
  0003a	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  0003d	52		 push	 edx
  0003e	51		 push	 ecx
  0003f	50		 push	 eax
  00040	57		 push	 edi
  00041	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx
  00044	e8 00 00 00 00	 call	 ??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@PAVioHashString@@V?$allocator@VioHashString@@@2@@std@@YAPAVioHashString@@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@0@0PAV1@AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >,ioHashString *,std::allocator<ioHashString> >
  00049	83 c4 14	 add	 esp, 20			; 00000014H
  0004c	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN7@vector:

; 543  : 			_CATCH_END
; 544  : 		}

  0004f	8b c6		 mov	 eax, esi
  00051	e8 00 00 00 00	 call	 __EH_epilog3
  00056	c2 04 00	 ret	 4
__catch$??0?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@ABV01@@Z$0:

; 540  : 			_CATCH_ALL
; 541  : 			_Tidy();

  00059	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	e8 00 00 00 00	 call	 ?_Tidy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXXZ ; std::vector<ioHashString,std::allocator<ioHashString> >::_Tidy

; 542  : 			_RERAISE;

  00061	33 db		 xor	 ebx, ebx
  00063	53		 push	 ebx
  00064	53		 push	 ebx
  00065	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN38@vector:
$LN37@vector:
  0006a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@ABV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@ABV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::vector<ioHashString,std::allocator<ioHashString> >
PUBLIC	??1?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ ; std::vector<ioHashString,std::allocator<ioHashString> >::~vector<ioHashString,std::allocator<ioHashString> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::~vector<ioHashString,std::allocator<ioHashString> >, COMDAT
; _this$ = ecx

; 705  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXXZ ; std::vector<ioHashString,std::allocator<ioHashString> >::_Tidy
??1?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::~vector<ioHashString,std::allocator<ioHashString> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@IAEXXZ ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::_Tidy
; Function compile flags: /Ogsp
;	COMDAT ?_Tidy@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00006	74 28		 je	 SHORT $LN27@Tidy@2

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00008	53		 push	 ebx
  00009	57		 push	 edi
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  00010	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00013	8b 3e		 mov	 edi, DWORD PTR [esi]
  00015	eb 0b		 jmp	 SHORT $LN31@Tidy@2
$LL12@Tidy@2:
  00017	8b cf		 mov	 ecx, edi
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  0001f	83 c7 1c	 add	 edi, 28			; 0000001cH
$LN31@Tidy@2:
  00022	3b fb		 cmp	 edi, ebx
  00024	75 f1		 jne	 SHORT $LL12@Tidy@2

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002d	59		 pop	 ecx
  0002e	5f		 pop	 edi
  0002f	5b		 pop	 ebx
$LN27@Tidy@2:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00030	33 c0		 xor	 eax, eax
  00032	89 06		 mov	 DWORD PTR [esi], eax

; 1310 : 		this->_Mylast = 0;

  00034	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1311 : 		this->_Myend = 0;

  00037	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003a	5e		 pop	 esi

; 1312 : 		}

  0003b	c3		 ret	 0
?_Tidy@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@ABV01@@Z ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??0?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@ABV01@@Z$0
__unwindtable$??0?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Cat$533305 = 8					; size = 1
__Right$ = 8						; size = 4
??0?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >, COMDAT
; _this$ = ecx

; 535  : 		{	// construct by copying _Right

  00000	6a 08		 push	 8
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@ABV01@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_catch
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 536  : 		if (_Buy(_Right.size()))

  00011	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]
  00014	33 db		 xor	 ebx, ebx
  00016	89 1e		 mov	 DWORD PTR [esi], ebx
  00018	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0001b	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  0001e	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00021	2b 07		 sub	 eax, DWORD PTR [edi]
  00023	6a 1c		 push	 28			; 0000001cH
  00025	59		 pop	 ecx
  00026	99		 cdq
  00027	f7 f9		 idiv	 ecx
  00029	8b ce		 mov	 ecx, esi
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?_Buy@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@IAE_NI@Z ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::_Buy
  00031	84 c0		 test	 al, al
  00033	74 1f		 je	 SHORT $LN7@vector@2

; 537  : 			_TRY_BEGIN
; 538  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 539  : 				this->_Myfirst);

  00035	ff 75 08	 push	 DWORD PTR __Cat$533305[ebp]
  00038	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0003a	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0003d	8b 3f		 mov	 edi, DWORD PTR [edi]
  0003f	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  00042	52		 push	 edx
  00043	51		 push	 ecx
  00044	50		 push	 eax
  00045	57		 push	 edi
  00046	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx
  00049	e8 00 00 00 00	 call	 ??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@std@@PAUtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@2@@std@@YAPAUtagDummyCharLoadInfo@@V?$_Vector_const_iterator@V?$_Vector_val@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@@0@0PAU1@AAV?$allocator@UtagDummyCharLoadInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> > >,tagDummyCharLoadInfo *,std::allocator<tagDummyCharLoadInfo> >
  0004e	83 c4 14	 add	 esp, 20			; 00000014H
  00051	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN7@vector@2:

; 543  : 			_CATCH_END
; 544  : 		}

  00054	8b c6		 mov	 eax, esi
  00056	e8 00 00 00 00	 call	 __EH_epilog3
  0005b	c2 04 00	 ret	 4
__catch$??0?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@ABV01@@Z$0:

; 540  : 			_CATCH_ALL
; 541  : 			_Tidy();

  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@IAEXXZ ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::_Tidy

; 542  : 			_RERAISE;

  00066	33 db		 xor	 ebx, ebx
  00068	53		 push	 ebx
  00069	53		 push	 ebx
  0006a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN38@vector@2:
$LN37@vector@2:
  0006f	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@ABV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@ABV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >
PUBLIC	??1?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@XZ ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::~vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::~vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >, COMDAT
; _this$ = ecx

; 705  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@IAEXXZ ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::_Tidy
??1?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::~vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >
_TEXT	ENDS
PUBLIC	??_7ioCreateDummyByAttackedBuff2@@6B@		; ioCreateDummyByAttackedBuff2::`vftable'
PUBLIC	??0ioCreateDummyByAttackedBuff2@@QAE@XZ		; ioCreateDummyByAttackedBuff2::ioCreateDummyByAttackedBuff2
PUBLIC	??_R4ioCreateDummyByAttackedBuff2@@6B@		; ioCreateDummyByAttackedBuff2::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVioCreateDummyByAttackedBuff2@@@8	; ioCreateDummyByAttackedBuff2 `RTTI Type Descriptor'
PUBLIC	??_R3ioCreateDummyByAttackedBuff2@@8		; ioCreateDummyByAttackedBuff2::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioCreateDummyByAttackedBuff2@@8		; ioCreateDummyByAttackedBuff2::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ioCreateDummyByAttackedBuff2@@8	; ioCreateDummyByAttackedBuff2::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ioBuff@@8				; ioBuff::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVioBuff@@@8				; ioBuff `RTTI Type Descriptor'
PUBLIC	??_R3ioBuff@@8					; ioBuff::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioBuff@@8					; ioBuff::`RTTI Base Class Array'
PUBLIC	?Clone@ioCreateDummyByAttackedBuff2@@UAEPAVioBuff@@XZ ; ioCreateDummyByAttackedBuff2::Clone
PUBLIC	?IsWaitSelfRemove@ioBuff@@UAE_NXZ		; ioBuff::IsWaitSelfRemove
EXTRN	??0ioBuff@@QAE@XZ:PROC				; ioBuff::ioBuff
EXTRN	?StartBuffWithAniTime@ioBuff@@UAEXPAVioBaseChar@@K@Z:PROC ; ioBuff::StartBuffWithAniTime
EXTRN	?ApplyStartBuff@ioBuff@@UAE_NPAVioBaseChar@@KK@Z:PROC ; ioBuff::ApplyStartBuff
EXTRN	?EndBuff@ioBuff@@UAEXXZ:PROC			; ioBuff::EndBuff
EXTRN	?CancelBuff@ioBuff@@UAEXXZ:PROC			; ioBuff::CancelBuff
EXTRN	?GetBuffInfo@ioBuff@@UAEXAAVSP2Packet@@@Z:PROC	; ioBuff::GetBuffInfo
EXTRN	?ApplyBuffInfo@ioBuff@@UAEXAAVSP2Packet@@@Z:PROC ; ioBuff::ApplyBuffInfo
EXTRN	?AccumulateBuff@ioBuff@@UAEXXZ:PROC		; ioBuff::AccumulateBuff
EXTRN	?IsLiveButStopped@ioBuff@@UBE_NXZ:PROC		; ioBuff::IsLiveButStopped
EXTRN	?IsCanJumpAttack@ioBuff@@UBE_NXZ:PROC		; ioBuff::IsCanJumpAttack
EXTRN	?SetAction@ioBuff@@MAEXXZ:PROC			; ioBuff::SetAction
EXTRN	?ProcessDelay@ioBuff@@MAEXM@Z:PROC		; ioBuff::ProcessDelay
EXTRN	?SetExtraDurationByGrowth@ioBuff@@UAEXM@Z:PROC	; ioBuff::SetExtraDurationByGrowth
EXTRN	?SetWeaponIndex@ioBuff@@UAEXK@Z:PROC		; ioBuff::SetWeaponIndex
EXTRN	?OnReduceGauge@ioBuff@@UBE_NXZ:PROC		; ioBuff::OnReduceGauge
EXTRN	?IsCharCollisionSkip@ioBuff@@UBE_NXZ:PROC	; ioBuff::IsCharCollisionSkip
EXTRN	?IsCollisionAvailableWeapon@ioBuff@@UBE_NXZ:PROC ; ioBuff::IsCollisionAvailableWeapon
EXTRN	?IsProtected@ioBuff@@UBE_NXZ:PROC		; ioBuff::IsProtected
EXTRN	?UseActiveCount@ioBuff@@UBE_NXZ:PROC		; ioBuff::UseActiveCount
EXTRN	?CheckActiveCount@ioBuff@@UAEXXZ:PROC		; ioBuff::CheckActiveCount
EXTRN	?CheckRemoveEquipSkillBuff@ioBuff@@UAEX_N@Z:PROC ; ioBuff::CheckRemoveEquipSkillBuff
EXTRN	?SetBuffGrapplingState@ioBuff@@UAE_NPAVioBaseChar@@ABVioHashString@@@Z:PROC ; ioBuff::SetBuffGrapplingState
EXTRN	?GetGrapplingTargetPos@ioBuff@@UAE?AUD3DXVECTOR3@@PAVioBaseChar@@@Z:PROC ; ioBuff::GetGrapplingTargetPos
EXTRN	??_EioCreateDummyByAttackedBuff2@@UAEPAXI@Z:PROC ; ioCreateDummyByAttackedBuff2::`vector deleting destructor'
;	COMDAT ??_R2ioBuff@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
rdata$r	SEGMENT
??_R2ioBuff@@8 DD FLAT:??_R1A@?0A@EA@ioBuff@@8		; ioBuff::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ioBuff@@8
rdata$r	SEGMENT
??_R3ioBuff@@8 DD 00H					; ioBuff::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ioBuff@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioBuff@@@8
_DATA	SEGMENT
??_R0?AVioBuff@@@8 DD FLAT:??_7type_info@@6B@		; ioBuff `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioBuff@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@ioBuff@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioBuff@@8 DD FLAT:??_R0?AVioBuff@@@8	; ioBuff::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioBuff@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ioCreateDummyByAttackedBuff2@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioCreateDummyByAttackedBuff2@@8 DD FLAT:??_R0?AVioCreateDummyByAttackedBuff2@@@8 ; ioCreateDummyByAttackedBuff2::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioCreateDummyByAttackedBuff2@@8
rdata$r	ENDS
;	COMDAT ??_R2ioCreateDummyByAttackedBuff2@@8
rdata$r	SEGMENT
??_R2ioCreateDummyByAttackedBuff2@@8 DD FLAT:??_R1A@?0A@EA@ioCreateDummyByAttackedBuff2@@8 ; ioCreateDummyByAttackedBuff2::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ioBuff@@8
rdata$r	ENDS
;	COMDAT ??_R3ioCreateDummyByAttackedBuff2@@8
rdata$r	SEGMENT
??_R3ioCreateDummyByAttackedBuff2@@8 DD 00H		; ioCreateDummyByAttackedBuff2::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ioCreateDummyByAttackedBuff2@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioCreateDummyByAttackedBuff2@@@8
_DATA	SEGMENT
??_R0?AVioCreateDummyByAttackedBuff2@@@8 DD FLAT:??_7type_info@@6B@ ; ioCreateDummyByAttackedBuff2 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioCreateDummyByAttackedBuff2@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ioCreateDummyByAttackedBuff2@@6B@
rdata$r	SEGMENT
??_R4ioCreateDummyByAttackedBuff2@@6B@ DD 00H		; ioCreateDummyByAttackedBuff2::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVioCreateDummyByAttackedBuff2@@@8
	DD	FLAT:??_R3ioCreateDummyByAttackedBuff2@@8
rdata$r	ENDS
;	COMDAT ??_7ioCreateDummyByAttackedBuff2@@6B@
CONST	SEGMENT
??_7ioCreateDummyByAttackedBuff2@@6B@ DD FLAT:??_R4ioCreateDummyByAttackedBuff2@@6B@ ; ioCreateDummyByAttackedBuff2::`vftable'
	DD	FLAT:?LoadProperty@ioCreateDummyByAttackedBuff2@@UAEXAAVioINILoader@@@Z
	DD	FLAT:?Clone@ioCreateDummyByAttackedBuff2@@UAEPAVioBuff@@XZ
	DD	FLAT:?StartBuff@ioCreateDummyByAttackedBuff2@@UAEXPAVioBaseChar@@@Z
	DD	FLAT:?StartBuffWithAniTime@ioBuff@@UAEXPAVioBaseChar@@K@Z
	DD	FLAT:?ApplyStartBuff@ioBuff@@UAE_NPAVioBaseChar@@KK@Z
	DD	FLAT:?ProcessBuff@ioCreateDummyByAttackedBuff2@@UAEXM@Z
	DD	FLAT:?EndBuff@ioBuff@@UAEXXZ
	DD	FLAT:?CancelBuff@ioBuff@@UAEXXZ
	DD	FLAT:?GetBuffInfo@ioBuff@@UAEXAAVSP2Packet@@@Z
	DD	FLAT:?ApplyBuffInfo@ioBuff@@UAEXAAVSP2Packet@@@Z
	DD	FLAT:?AccumulateBuff@ioBuff@@UAEXXZ
	DD	FLAT:?IsLiveButStopped@ioBuff@@UBE_NXZ
	DD	FLAT:?IsCanJumpAttack@ioBuff@@UBE_NXZ
	DD	FLAT:?SetAction@ioBuff@@MAEXXZ
	DD	FLAT:?ProcessDelay@ioBuff@@MAEXM@Z
	DD	FLAT:?SetExtraDurationByGrowth@ioBuff@@UAEXM@Z
	DD	FLAT:?SetWeaponIndex@ioBuff@@UAEXK@Z
	DD	FLAT:?OnReduceGauge@ioBuff@@UBE_NXZ
	DD	FLAT:?IsCharCollisionSkip@ioBuff@@UBE_NXZ
	DD	FLAT:?IsCollisionAvailableWeapon@ioBuff@@UBE_NXZ
	DD	FLAT:?IsProtected@ioBuff@@UBE_NXZ
	DD	FLAT:?UseActiveCount@ioBuff@@UBE_NXZ
	DD	FLAT:?CheckActiveCount@ioBuff@@UAEXXZ
	DD	FLAT:?CheckRemoveEquipSkillBuff@ioBuff@@UAEX_N@Z
	DD	FLAT:?ApplyExtraBuffInfo@ioCreateDummyByAttackedBuff2@@UAEXAAVSP2Packet@@@Z
	DD	FLAT:?SetBuffGrapplingState@ioBuff@@UAE_NPAVioBaseChar@@ABVioHashString@@@Z
	DD	FLAT:?GetGrapplingTargetPos@ioBuff@@UAE?AUD3DXVECTOR3@@PAVioBaseChar@@@Z
	DD	FLAT:?IsWaitSelfRemove@ioBuff@@UAE_NXZ
	DD	FLAT:??_EioCreateDummyByAttackedBuff2@@UAEPAXI@Z
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iocreatedummybyattackedbuff2.cpp
CONST	ENDS
;	COMDAT ??0ioCreateDummyByAttackedBuff2@@QAE@XZ
_TEXT	SEGMENT
??0ioCreateDummyByAttackedBuff2@@QAE@XZ PROC		; ioCreateDummyByAttackedBuff2::ioCreateDummyByAttackedBuff2, COMDAT
; _this$ = ecx

; 7    : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??0ioBuff@@QAE@XZ	; ioBuff::ioBuff
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioCreateDummyByAttackedBuff2@@6B@
  0000e	33 c9		 xor	 ecx, ecx
  00010	89 8e 6c 09 00
	00		 mov	 DWORD PTR [esi+2412], ecx
  00016	89 8e 70 09 00
	00		 mov	 DWORD PTR [esi+2416], ecx
  0001c	89 8e 74 09 00
	00		 mov	 DWORD PTR [esi+2420], ecx
  00022	89 8e 7c 09 00
	00		 mov	 DWORD PTR [esi+2428], ecx
  00028	89 8e 80 09 00
	00		 mov	 DWORD PTR [esi+2432], ecx
  0002e	89 8e 84 09 00
	00		 mov	 DWORD PTR [esi+2436], ecx

; 8    : }

  00034	8b c6		 mov	 eax, esi
  00036	5e		 pop	 esi
  00037	c3		 ret	 0
??0ioCreateDummyByAttackedBuff2@@QAE@XZ ENDP		; ioCreateDummyByAttackedBuff2::ioCreateDummyByAttackedBuff2
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobuff.h
_TEXT	ENDS
;	COMDAT ?IsWaitSelfRemove@ioBuff@@UAE_NXZ
_TEXT	SEGMENT
?IsWaitSelfRemove@ioBuff@@UAE_NXZ PROC			; ioBuff::IsWaitSelfRemove, COMDAT
; _this$ = ecx

; 519  : 	virtual bool IsWaitSelfRemove() { return m_bWaitSelfRemove; }

  00000	8a 81 65 09 00
	00		 mov	 al, BYTE PTR [ecx+2405]
  00006	c3		 ret	 0
?IsWaitSelfRemove@ioBuff@@UAE_NXZ ENDP			; ioBuff::IsWaitSelfRemove
_TEXT	ENDS
PUBLIC	??0ioCreateDummyByAttackedBuff2@@QAE@ABV0@@Z	; ioCreateDummyByAttackedBuff2::ioCreateDummyByAttackedBuff2
EXTRN	??1ioBuff@@UAE@XZ:PROC				; ioBuff::~ioBuff
EXTRN	??0ioBuff@@QAE@ABV0@@Z:PROC			; ioBuff::ioBuff
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iocreatedummybyattackedbuff2.cpp
xdata$x	SEGMENT
__unwindtable$??0ioCreateDummyByAttackedBuff2@@QAE@ABV0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ioCreateDummyByAttackedBuff2@@QAE@ABV0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0ioCreateDummyByAttackedBuff2@@QAE@ABV0@@Z$1
__ehfuncinfo$??0ioCreateDummyByAttackedBuff2@@QAE@ABV0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0ioCreateDummyByAttackedBuff2@@QAE@ABV0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??0ioCreateDummyByAttackedBuff2@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_rhs$ = 8						; size = 4
??0ioCreateDummyByAttackedBuff2@@QAE@ABV0@@Z PROC	; ioCreateDummyByAttackedBuff2::ioCreateDummyByAttackedBuff2, COMDAT
; _this$ = ecx

; 15   : {

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0ioCreateDummyByAttackedBuff2@@QAE@ABV0@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	8b 7d 08	 mov	 edi, DWORD PTR _rhs$[ebp]
  00014	57		 push	 edi
  00015	e8 00 00 00 00	 call	 ??0ioBuff@@QAE@ABV0@@Z	; ioBuff::ioBuff
  0001a	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0001e	8d 87 6c 09 00
	00		 lea	 eax, DWORD PTR [edi+2412]
  00024	50		 push	 eax
  00025	8d 8e 6c 09 00
	00		 lea	 ecx, DWORD PTR [esi+2412]
  0002b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioCreateDummyByAttackedBuff2@@6B@
  00031	e8 00 00 00 00	 call	 ??0?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@ABV01@@Z ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >
  00036	8d 87 7c 09 00
	00		 lea	 eax, DWORD PTR [edi+2428]
  0003c	50		 push	 eax
  0003d	8d 8e 7c 09 00
	00		 lea	 ecx, DWORD PTR [esi+2428]
  00043	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00047	e8 00 00 00 00	 call	 ??0?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@ABV01@@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::vector<ioHashString,std::allocator<ioHashString> >
  0004c	8b 87 8c 09 00
	00		 mov	 eax, DWORD PTR [edi+2444]
  00052	89 86 8c 09 00
	00		 mov	 DWORD PTR [esi+2444], eax

; 16   : 
; 17   : }

  00058	8b c6		 mov	 eax, esi
  0005a	e8 00 00 00 00	 call	 __EH_epilog3
  0005f	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ioCreateDummyByAttackedBuff2@@QAE@ABV0@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1ioBuff@@UAE@XZ	; ioBuff::~ioBuff
__unwindfunclet$??0ioCreateDummyByAttackedBuff2@@QAE@ABV0@@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	81 c1 6c 09 00
	00		 add	 ecx, 2412		; 0000096cH
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@XZ ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::~vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >
__ehhandler$??0ioCreateDummyByAttackedBuff2@@QAE@ABV0@@Z:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ioCreateDummyByAttackedBuff2@@QAE@ABV0@@Z
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ioCreateDummyByAttackedBuff2@@QAE@ABV0@@Z ENDP	; ioCreateDummyByAttackedBuff2::ioCreateDummyByAttackedBuff2
PUBLIC	??1ioCreateDummyByAttackedBuff2@@UAE@XZ		; ioCreateDummyByAttackedBuff2::~ioCreateDummyByAttackedBuff2
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??1ioCreateDummyByAttackedBuff2@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1ioCreateDummyByAttackedBuff2@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1ioCreateDummyByAttackedBuff2@@UAE@XZ$1
__ehfuncinfo$??1ioCreateDummyByAttackedBuff2@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1ioCreateDummyByAttackedBuff2@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iocreatedummybyattackedbuff2.cpp
xdata$x	ENDS
;	COMDAT ??1ioCreateDummyByAttackedBuff2@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1ioCreateDummyByAttackedBuff2@@UAE@XZ PROC		; ioCreateDummyByAttackedBuff2::~ioCreateDummyByAttackedBuff2, COMDAT
; _this$ = ecx

; 20   : {

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??1ioCreateDummyByAttackedBuff2@@UAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioCreateDummyByAttackedBuff2@@6B@

; 21   : }

  00017	8d 8e 7c 09 00
	00		 lea	 ecx, DWORD PTR [esi+2428]
  0001d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00024	e8 00 00 00 00	 call	 ?_Tidy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXXZ ; std::vector<ioHashString,std::allocator<ioHashString> >::_Tidy
  00029	8d 8e 6c 09 00
	00		 lea	 ecx, DWORD PTR [esi+2412]
  0002f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00033	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@IAEXXZ ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::_Tidy
  00038	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0003c	8b ce		 mov	 ecx, esi
  0003e	e8 00 00 00 00	 call	 ??1ioBuff@@UAE@XZ	; ioBuff::~ioBuff
  00043	e8 00 00 00 00	 call	 __EH_epilog3
  00048	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1ioCreateDummyByAttackedBuff2@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1ioBuff@@UAE@XZ	; ioBuff::~ioBuff
__unwindfunclet$??1ioCreateDummyByAttackedBuff2@@UAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	81 c1 6c 09 00
	00		 add	 ecx, 2412		; 0000096cH
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@UtagDummyCharLoadInfo@@V?$allocator@UtagDummyCharLoadInfo@@@std@@@std@@QAE@XZ ; std::vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >::~vector<tagDummyCharLoadInfo,std::allocator<tagDummyCharLoadInfo> >
__ehhandler$??1ioCreateDummyByAttackedBuff2@@UAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1ioCreateDummyByAttackedBuff2@@UAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1ioCreateDummyByAttackedBuff2@@UAE@XZ ENDP		; ioCreateDummyByAttackedBuff2::~ioCreateDummyByAttackedBuff2
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Clone@ioCreateDummyByAttackedBuff2@@UAEPAVioBuff@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Clone@ioCreateDummyByAttackedBuff2@@UAEPAVioBuff@@XZ$0
__ehfuncinfo$?Clone@ioCreateDummyByAttackedBuff2@@UAEPAVioBuff@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Clone@ioCreateDummyByAttackedBuff2@@UAEPAVioBuff@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ?Clone@ioCreateDummyByAttackedBuff2@@UAEPAVioBuff@@XZ
_TEXT	SEGMENT
$T533428 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Clone@ioCreateDummyByAttackedBuff2@@UAEPAVioBuff@@XZ PROC ; ioCreateDummyByAttackedBuff2::Clone, COMDAT
; _this$ = ecx

; 24   : {

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?Clone@ioCreateDummyByAttackedBuff2@@UAEPAVioBuff@@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx

; 25   : 	return new ioCreateDummyByAttackedBuff2( *this );

  0000e	68 90 09 00 00	 push	 2448			; 00000990H
  00013	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00018	59		 pop	 ecx
  00019	8b c8		 mov	 ecx, eax
  0001b	89 4d f0	 mov	 DWORD PTR $T533428[ebp], ecx
  0001e	33 c0		 xor	 eax, eax
  00020	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], eax
  00023	3b c8		 cmp	 ecx, eax
  00025	74 06		 je	 SHORT $LN3@Clone
  00027	56		 push	 esi
  00028	e8 00 00 00 00	 call	 ??0ioCreateDummyByAttackedBuff2@@QAE@ABV0@@Z ; ioCreateDummyByAttackedBuff2::ioCreateDummyByAttackedBuff2
$LN3@Clone:

; 26   : }

  0002d	e8 00 00 00 00	 call	 __EH_epilog3
  00032	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Clone@ioCreateDummyByAttackedBuff2@@UAEPAVioBuff@@XZ$0:
  00000	ff 75 f0	 push	 DWORD PTR $T533428[ebp]
  00003	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00008	59		 pop	 ecx
  00009	c3		 ret	 0
__ehhandler$?Clone@ioCreateDummyByAttackedBuff2@@UAEPAVioBuff@@XZ:
  0000a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00011	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00014	33 c8		 xor	 ecx, eax
  00016	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Clone@ioCreateDummyByAttackedBuff2@@UAEPAVioBuff@@XZ
  00020	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Clone@ioCreateDummyByAttackedBuff2@@UAEPAVioBuff@@XZ ENDP ; ioCreateDummyByAttackedBuff2::Clone
; Function compile flags: /Ogsp
;	COMDAT ??_GioCreateDummyByAttackedBuff2@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GioCreateDummyByAttackedBuff2@@UAEPAXI@Z PROC	; ioCreateDummyByAttackedBuff2::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1ioCreateDummyByAttackedBuff2@@UAE@XZ ; ioCreateDummyByAttackedBuff2::~ioCreateDummyByAttackedBuff2
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 07		 je	 SHORT $LN1@scalar@4
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	59		 pop	 ecx
$LN1@scalar@4:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??_GioCreateDummyByAttackedBuff2@@UAEPAXI@Z ENDP	; ioCreateDummyByAttackedBuff2::`scalar deleting destructor'
_TEXT	ENDS
END
