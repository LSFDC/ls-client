; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\Lost Saga For Developer\Youtube\Tutorial\Source\src\LSClient\ioBaseCharSpecialState.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_EEM_DS@?$deque@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@2HB ; std::deque<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_EEM_DS
;	COMDAT ?_EEM_DS@?$deque@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@2HB
CONST	SEGMENT
?_EEM_DS@?$deque@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@2HB DD 01H ; std::deque<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_EEM_DS
CONST	ENDS
PUBLIC	?return5@@YAIXZ					; return5
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stdafx.h
;	COMDAT ?return5@@YAIXZ
_TEXT	SEGMENT
?return5@@YAIXZ PROC					; return5, COMDAT

; 18   : 	__forceinline unsigned int return5() { __asm mov eax, 5 };

  00000	b8 05 00 00 00	 mov	 eax, 5
  00005	c3		 ret	 0
?return5@@YAIXZ ENDP					; return5
_TEXT	ENDS
PUBLIC	?return10@@YAIXZ				; return10
; Function compile flags: /Ogsp
;	COMDAT ?return10@@YAIXZ
_TEXT	SEGMENT
?return10@@YAIXZ PROC					; return10, COMDAT

; 21   : 	__forceinline unsigned int return10() { __asm mov eax, 10 };

  00000	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  00005	c3		 ret	 0
?return10@@YAIXZ ENDP					; return10
_TEXT	ENDS
PUBLIC	?IsBoss@ioBaseChar@@QAE_NXZ			; ioBaseChar::IsBoss
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasechar.h
;	COMDAT ?IsBoss@ioBaseChar@@QAE_NXZ
_TEXT	SEGMENT
?IsBoss@ioBaseChar@@QAE_NXZ PROC			; ioBaseChar::IsBoss, COMDAT
; _this$ = ecx

; 1497 : 	bool IsBoss(){ return m_bBossCharacter; }

  00000	8a 81 e0 23 00
	00		 mov	 al, BYTE PTR [ecx+9184]
  00006	c3		 ret	 0
?IsBoss@ioBaseChar@@QAE_NXZ ENDP			; ioBaseChar::IsBoss
_TEXT	ENDS
PUBLIC	?IsGangsi@ioBaseChar@@QBE_NXZ			; ioBaseChar::IsGangsi
; Function compile flags: /Ogsp
;	COMDAT ?IsGangsi@ioBaseChar@@QBE_NXZ
_TEXT	SEGMENT
?IsGangsi@ioBaseChar@@QBE_NXZ PROC			; ioBaseChar::IsGangsi, COMDAT
; _this$ = ecx

; 1498 : 	bool IsGangsi() const { return m_bGangsiCharacter; }

  00000	8a 81 f8 23 00
	00		 mov	 al, BYTE PTR [ecx+9208]
  00006	c3		 ret	 0
?IsGangsi@ioBaseChar@@QBE_NXZ ENDP			; ioBaseChar::IsGangsi
_TEXT	ENDS
PUBLIC	?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ	; ioBaseChar::GetCharName
; Function compile flags: /Ogsp
;	COMDAT ?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ
_TEXT	SEGMENT
?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ PROC	; ioBaseChar::GetCharName, COMDAT
; _this$ = ecx

; 2594 : 	inline const ioHashString& GetCharName() const { return m_Name; }

  00000	8d 81 d4 02 00
	00		 lea	 eax, DWORD PTR [ecx+724]
  00006	c3		 ret	 0
?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ ENDP	; ioBaseChar::GetCharName
_TEXT	ENDS
PUBLIC	_sqrtf
EXTRN	__fltused:DWORD
EXTRN	__CIsqrt:PROC
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv69 = 8						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 434  :         {return ((float)sqrt((double)_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	e8 00 00 00 00	 call	 __CIsqrt
  0000b	d9 5d 08	 fstp	 DWORD PTR tv69[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv69[ebp]
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	??_R0?AVioWeaponItem@@@8			; ioWeaponItem `RTTI Type Descriptor'
PUBLIC	??_R0?AVioHookItem@@@8				; ioHookItem `RTTI Type Descriptor'
PUBLIC	?ToHookItem@@YAPAVioHookItem@@PAVioWeaponItem@@@Z ; ToHookItem
EXTRN	___RTDynamicCast:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT ??_R0?AVioWeaponItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iohookitem.h
_DATA	SEGMENT
??_R0?AVioWeaponItem@@@8 DD FLAT:??_7type_info@@6B@	; ioWeaponItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioWeaponItem@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVioHookItem@@@8
_DATA	SEGMENT
??_R0?AVioHookItem@@@8 DD FLAT:??_7type_info@@6B@	; ioHookItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioHookItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToHookItem@@YAPAVioHookItem@@PAVioWeaponItem@@@Z
_TEXT	SEGMENT
_pWeapon$ = 8						; size = 4
?ToHookItem@@YAPAVioHookItem@@PAVioWeaponItem@@@Z PROC	; ToHookItem, COMDAT

; 122  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 123  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_HOOK )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pWeapon$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 28		 je	 SHORT $LN1@ToHookItem
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 90 f0 02 00
	00		 call	 DWORD PTR [eax+752]
  00015	83 f8 02	 cmp	 eax, 2
  00018	75 19		 jne	 SHORT $LN1@ToHookItem

; 125  : 
; 126  : 	return dynamic_cast< ioHookItem* >( pWeapon );

  0001a	6a 00		 push	 0
  0001c	68 00 00 00 00	 push	 OFFSET ??_R0?AVioHookItem@@@8
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWeaponItem@@@8
  00026	6a 00		 push	 0
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002e	83 c4 14	 add	 esp, 20			; 00000014H
  00031	eb 02		 jmp	 SHORT $LN3@ToHookItem
$LN1@ToHookItem:

; 124  : 		return NULL;

  00033	33 c0		 xor	 eax, eax
$LN3@ToHookItem:
  00035	5e		 pop	 esi

; 127  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?ToHookItem@@YAPAVioHookItem@@PAVioWeaponItem@@@Z ENDP	; ToHookItem
_TEXT	ENDS
PUBLIC	?GetDoubleJumpFlyBuff@ioSummonChargeItem3@@QAEABVioHashString@@XZ ; ioSummonChargeItem3::GetDoubleJumpFlyBuff
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iosummonchargeitem3.h
;	COMDAT ?GetDoubleJumpFlyBuff@ioSummonChargeItem3@@QAEABVioHashString@@XZ
_TEXT	SEGMENT
?GetDoubleJumpFlyBuff@ioSummonChargeItem3@@QAEABVioHashString@@XZ PROC ; ioSummonChargeItem3::GetDoubleJumpFlyBuff, COMDAT
; _this$ = ecx

; 93   : 	const ioHashString& GetDoubleJumpFlyBuff(){ return m_szDoubleJumpFlyBuff; }

  00000	8d 81 4c 1a 00
	00		 lea	 eax, DWORD PTR [ecx+6732]
  00006	c3		 ret	 0
?GetDoubleJumpFlyBuff@ioSummonChargeItem3@@QAEABVioHashString@@XZ ENDP ; ioSummonChargeItem3::GetDoubleJumpFlyBuff
_TEXT	ENDS
PUBLIC	??_R0?AVioSpecialStateBase@@@8			; ioSpecialStateBase `RTTI Type Descriptor'
PUBLIC	??_R0?AVioUroborusSpecialState@@@8		; ioUroborusSpecialState `RTTI Type Descriptor'
PUBLIC	?ToUroborusSpecialState@@YAPAVioUroborusSpecialState@@PAVioSpecialStateBase@@@Z ; ToUroborusSpecialState
;	COMDAT ??_R0?AVioSpecialStateBase@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iouroborusitem.h
_DATA	SEGMENT
??_R0?AVioSpecialStateBase@@@8 DD FLAT:??_7type_info@@6B@ ; ioSpecialStateBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioSpecialStateBase@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVioUroborusSpecialState@@@8
_DATA	SEGMENT
??_R0?AVioUroborusSpecialState@@@8 DD FLAT:??_7type_info@@6B@ ; ioUroborusSpecialState `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioUroborusSpecialState@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToUroborusSpecialState@@YAPAVioUroborusSpecialState@@PAVioSpecialStateBase@@@Z
_TEXT	SEGMENT
_pState$ = 8						; size = 4
?ToUroborusSpecialState@@YAPAVioUroborusSpecialState@@PAVioSpecialStateBase@@@Z PROC ; ToUroborusSpecialState, COMDAT

; 206  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 207  : 	if( !pState || pState->GetState() != CS_UROBORUS )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pState$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 24		 je	 SHORT $LN1@ToUroborus
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 50 10	 call	 DWORD PTR [eax+16]
  00012	3c 4b		 cmp	 al, 75			; 0000004bH
  00014	75 19		 jne	 SHORT $LN1@ToUroborus

; 209  : 
; 210  : 	return dynamic_cast< ioUroborusSpecialState* >( pState );

  00016	6a 00		 push	 0
  00018	68 00 00 00 00	 push	 OFFSET ??_R0?AVioUroborusSpecialState@@@8
  0001d	68 00 00 00 00	 push	 OFFSET ??_R0?AVioSpecialStateBase@@@8
  00022	6a 00		 push	 0
  00024	56		 push	 esi
  00025	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002a	83 c4 14	 add	 esp, 20			; 00000014H
  0002d	eb 02		 jmp	 SHORT $LN3@ToUroborus
$LN1@ToUroborus:

; 208  : 		return NULL;

  0002f	33 c0		 xor	 eax, eax
$LN3@ToUroborus:
  00031	5e		 pop	 esi

; 211  : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?ToUroborusSpecialState@@YAPAVioUroborusSpecialState@@PAVioSpecialStateBase@@@Z ENDP ; ToUroborusSpecialState
_TEXT	ENDS
PUBLIC	?GetSylphidInfo@ioRachelItem@@QBEABUtagSylphidInfo@@XZ ; ioRachelItem::GetSylphidInfo
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iorachelitem.h
;	COMDAT ?GetSylphidInfo@ioRachelItem@@QBEABUtagSylphidInfo@@XZ
_TEXT	SEGMENT
?GetSylphidInfo@ioRachelItem@@QBEABUtagSylphidInfo@@XZ PROC ; ioRachelItem::GetSylphidInfo, COMDAT
; _this$ = ecx

; 155  : 	inline const SylphidInfo& GetSylphidInfo() const { return m_SylphidInfo; }

  00000	8d 81 6c 1a 00
	00		 lea	 eax, DWORD PTR [ecx+6764]
  00006	c3		 ret	 0
?GetSylphidInfo@ioRachelItem@@QBEABUtagSylphidInfo@@XZ ENDP ; ioRachelItem::GetSylphidInfo
_TEXT	ENDS
PUBLIC	??_R0?AVioWitchFlySpecialState@@@8		; ioWitchFlySpecialState `RTTI Type Descriptor'
PUBLIC	?ToWitchFlySpecialState@@YAPAVioWitchFlySpecialState@@PAVioSpecialStateBase@@@Z ; ToWitchFlySpecialState
;	COMDAT ??_R0?AVioWitchFlySpecialState@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iowitchitem.h
_DATA	SEGMENT
??_R0?AVioWitchFlySpecialState@@@8 DD FLAT:??_7type_info@@6B@ ; ioWitchFlySpecialState `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioWitchFlySpecialState@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToWitchFlySpecialState@@YAPAVioWitchFlySpecialState@@PAVioSpecialStateBase@@@Z
_TEXT	SEGMENT
_pState$ = 8						; size = 4
?ToWitchFlySpecialState@@YAPAVioWitchFlySpecialState@@PAVioSpecialStateBase@@@Z PROC ; ToWitchFlySpecialState, COMDAT

; 215  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 216  : 	if( !pState || pState->GetState() != CS_WITCH_FLY )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pState$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 24		 je	 SHORT $LN1@ToWitchFly
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 50 10	 call	 DWORD PTR [eax+16]
  00012	3c 4e		 cmp	 al, 78			; 0000004eH
  00014	75 19		 jne	 SHORT $LN1@ToWitchFly

; 218  : 
; 219  : 	return dynamic_cast< ioWitchFlySpecialState* >( pState );

  00016	6a 00		 push	 0
  00018	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWitchFlySpecialState@@@8
  0001d	68 00 00 00 00	 push	 OFFSET ??_R0?AVioSpecialStateBase@@@8
  00022	6a 00		 push	 0
  00024	56		 push	 esi
  00025	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002a	83 c4 14	 add	 esp, 20			; 00000014H
  0002d	eb 02		 jmp	 SHORT $LN3@ToWitchFly
$LN1@ToWitchFly:

; 217  : 		return NULL;

  0002f	33 c0		 xor	 eax, eax
$LN3@ToWitchFly:
  00031	5e		 pop	 esi

; 220  : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?ToWitchFlySpecialState@@YAPAVioWitchFlySpecialState@@PAVioSpecialStateBase@@@Z ENDP ; ToWitchFlySpecialState
_TEXT	ENDS
PUBLIC	??_R0?AVioGhostStealerSpecialState@@@8		; ioGhostStealerSpecialState `RTTI Type Descriptor'
PUBLIC	?ToGhostStealerSpecialState@@YAPAVioGhostStealerSpecialState@@PAVioSpecialStateBase@@@Z ; ToGhostStealerSpecialState
;	COMDAT ??_R0?AVioGhostStealerSpecialState@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioghoststealer.h
_DATA	SEGMENT
??_R0?AVioGhostStealerSpecialState@@@8 DD FLAT:??_7type_info@@6B@ ; ioGhostStealerSpecialState `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioGhostStealerSpecialState@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToGhostStealerSpecialState@@YAPAVioGhostStealerSpecialState@@PAVioSpecialStateBase@@@Z
_TEXT	SEGMENT
_pState$ = 8						; size = 4
?ToGhostStealerSpecialState@@YAPAVioGhostStealerSpecialState@@PAVioSpecialStateBase@@@Z PROC ; ToGhostStealerSpecialState, COMDAT

; 198  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 199  : 	if( !pState || pState->GetState() != CS_GHOST_STEALER_STATE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pState$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 24		 je	 SHORT $LN1@ToGhostSte
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 50 10	 call	 DWORD PTR [eax+16]
  00012	3c 67		 cmp	 al, 103			; 00000067H
  00014	75 19		 jne	 SHORT $LN1@ToGhostSte

; 201  : 
; 202  : 	return dynamic_cast< ioGhostStealerSpecialState* >( pState );

  00016	6a 00		 push	 0
  00018	68 00 00 00 00	 push	 OFFSET ??_R0?AVioGhostStealerSpecialState@@@8
  0001d	68 00 00 00 00	 push	 OFFSET ??_R0?AVioSpecialStateBase@@@8
  00022	6a 00		 push	 0
  00024	56		 push	 esi
  00025	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002a	83 c4 14	 add	 esp, 20			; 00000014H
  0002d	eb 02		 jmp	 SHORT $LN3@ToGhostSte
$LN1@ToGhostSte:

; 200  : 		return NULL;

  0002f	33 c0		 xor	 eax, eax
$LN3@ToGhostSte:
  00031	5e		 pop	 esi

; 203  : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?ToGhostStealerSpecialState@@YAPAVioGhostStealerSpecialState@@PAVioSpecialStateBase@@@Z ENDP ; ToGhostStealerSpecialState
_TEXT	ENDS
PUBLIC	?GetMeshType@ioSuddenAttackItem@@QBE?BW4ItemMeshType@1@XZ ; ioSuddenAttackItem::GetMeshType
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iosuddenattackitem.h
;	COMDAT ?GetMeshType@ioSuddenAttackItem@@QBE?BW4ItemMeshType@1@XZ
_TEXT	SEGMENT
?GetMeshType@ioSuddenAttackItem@@QBE?BW4ItemMeshType@1@XZ PROC ; ioSuddenAttackItem::GetMeshType, COMDAT
; _this$ = ecx

; 444  : 	const ItemMeshType GetMeshType() const { return m_itemMeshType; }

  00000	8b 81 d4 19 00
	00		 mov	 eax, DWORD PTR [ecx+6612]
  00006	c3		 ret	 0
?GetMeshType@ioSuddenAttackItem@@QBE?BW4ItemMeshType@1@XZ ENDP ; ioSuddenAttackItem::GetMeshType
_TEXT	ENDS
PUBLIC	??_R0?AVioTitanExtendMoveSpecialState@@@8	; ioTitanExtendMoveSpecialState `RTTI Type Descriptor'
PUBLIC	?ToTitanExtendMoveSpecialState@@YAPAVioTitanExtendMoveSpecialState@@PAVioSpecialStateBase@@@Z ; ToTitanExtendMoveSpecialState
;	COMDAT ??_R0?AVioTitanExtendMoveSpecialState@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iotitanitem.h
_DATA	SEGMENT
??_R0?AVioTitanExtendMoveSpecialState@@@8 DD FLAT:??_7type_info@@6B@ ; ioTitanExtendMoveSpecialState `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioTitanExtendMoveSpecialState@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToTitanExtendMoveSpecialState@@YAPAVioTitanExtendMoveSpecialState@@PAVioSpecialStateBase@@@Z
_TEXT	SEGMENT
_pState$ = 8						; size = 4
?ToTitanExtendMoveSpecialState@@YAPAVioTitanExtendMoveSpecialState@@PAVioSpecialStateBase@@@Z PROC ; ToTitanExtendMoveSpecialState, COMDAT

; 155  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 156  : 	if( !pState || pState->GetState() != CS_TITAN_EXTEND_MOVE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pState$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 24		 je	 SHORT $LN1@ToTitanExt
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 50 10	 call	 DWORD PTR [eax+16]
  00012	3c 72		 cmp	 al, 114			; 00000072H
  00014	75 19		 jne	 SHORT $LN1@ToTitanExt

; 158  : 
; 159  : 	return dynamic_cast< ioTitanExtendMoveSpecialState* >( pState );

  00016	6a 00		 push	 0
  00018	68 00 00 00 00	 push	 OFFSET ??_R0?AVioTitanExtendMoveSpecialState@@@8
  0001d	68 00 00 00 00	 push	 OFFSET ??_R0?AVioSpecialStateBase@@@8
  00022	6a 00		 push	 0
  00024	56		 push	 esi
  00025	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002a	83 c4 14	 add	 esp, 20			; 00000014H
  0002d	eb 02		 jmp	 SHORT $LN3@ToTitanExt
$LN1@ToTitanExt:

; 157  : 		return NULL;

  0002f	33 c0		 xor	 eax, eax
$LN3@ToTitanExt:
  00031	5e		 pop	 esi

; 160  : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?ToTitanExtendMoveSpecialState@@YAPAVioTitanExtendMoveSpecialState@@PAVioSpecialStateBase@@@Z ENDP ; ToTitanExtendMoveSpecialState
_TEXT	ENDS
PUBLIC	?GetMeshType@ioDummyCharItem2@@QBE?BW4ItemMeshType@1@XZ ; ioDummyCharItem2::GetMeshType
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iodummycharitem2.h
;	COMDAT ?GetMeshType@ioDummyCharItem2@@QBE?BW4ItemMeshType@1@XZ
_TEXT	SEGMENT
?GetMeshType@ioDummyCharItem2@@QBE?BW4ItemMeshType@1@XZ PROC ; ioDummyCharItem2::GetMeshType, COMDAT
; _this$ = ecx

; 129  : 	const ItemMeshType GetMeshType() const { return m_itemMeshType; }

  00000	8b 81 74 1b 00
	00		 mov	 eax, DWORD PTR [ecx+7028]
  00006	c3		 ret	 0
?GetMeshType@ioDummyCharItem2@@QBE?BW4ItemMeshType@1@XZ ENDP ; ioDummyCharItem2::GetMeshType
_TEXT	ENDS
PUBLIC	?GetWeaponStep@ioSuperDimensionItem@@QAEHXZ	; ioSuperDimensionItem::GetWeaponStep
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iosuperdimensionitem.h
;	COMDAT ?GetWeaponStep@ioSuperDimensionItem@@QAEHXZ
_TEXT	SEGMENT
?GetWeaponStep@ioSuperDimensionItem@@QAEHXZ PROC	; ioSuperDimensionItem::GetWeaponStep, COMDAT
; _this$ = ecx

; 196  : 	int GetWeaponStep(){ return m_nChangedNowStep; }

  00000	8b 81 28 1d 00
	00		 mov	 eax, DWORD PTR [ecx+7464]
  00006	c3		 ret	 0
?GetWeaponStep@ioSuperDimensionItem@@QAEHXZ ENDP	; ioSuperDimensionItem::GetWeaponStep
_TEXT	ENDS
PUBLIC	?GetDoubleJumpFlyBuff@ioValkyrie@@QAEABVioHashString@@XZ ; ioValkyrie::GetDoubleJumpFlyBuff
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iovalkyrie.h
;	COMDAT ?GetDoubleJumpFlyBuff@ioValkyrie@@QAEABVioHashString@@XZ
_TEXT	SEGMENT
?GetDoubleJumpFlyBuff@ioValkyrie@@QAEABVioHashString@@XZ PROC ; ioValkyrie::GetDoubleJumpFlyBuff, COMDAT
; _this$ = ecx

; 121  : 	const ioHashString& GetDoubleJumpFlyBuff(){ return m_szDoubleJumpFlyBuff; }

  00000	8d 81 ac 1b 00
	00		 lea	 eax, DWORD PTR [ecx+7084]
  00006	c3		 ret	 0
?GetDoubleJumpFlyBuff@ioValkyrie@@QAEABVioHashString@@XZ ENDP ; ioValkyrie::GetDoubleJumpFlyBuff
_TEXT	ENDS
PUBLIC	??_R0?AVioJeonWooChiExtendDashSpecialState@@@8	; ioJeonWooChiExtendDashSpecialState `RTTI Type Descriptor'
PUBLIC	?ToJeonWooChiExtendDashSpecialState@@YAPAVioJeonWooChiExtendDashSpecialState@@PAVioSpecialStateBase@@@Z ; ToJeonWooChiExtendDashSpecialState
;	COMDAT ??_R0?AVioJeonWooChiExtendDashSpecialState@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iojeonwoochiitem.h
_DATA	SEGMENT
??_R0?AVioJeonWooChiExtendDashSpecialState@@@8 DD FLAT:??_7type_info@@6B@ ; ioJeonWooChiExtendDashSpecialState `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioJeonWooChiExtendDashSpecialState@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToJeonWooChiExtendDashSpecialState@@YAPAVioJeonWooChiExtendDashSpecialState@@PAVioSpecialStateBase@@@Z
_TEXT	SEGMENT
_pState$ = 8						; size = 4
?ToJeonWooChiExtendDashSpecialState@@YAPAVioJeonWooChiExtendDashSpecialState@@PAVioSpecialStateBase@@@Z PROC ; ToJeonWooChiExtendDashSpecialState, COMDAT

; 263  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 264  : 	if( !pState || pState->GetState() != CS_JEONWOOCHI_EXTEND_DASH )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pState$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 24		 je	 SHORT $LN1@ToJeonWooC
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 50 10	 call	 DWORD PTR [eax+16]
  00012	3c 99		 cmp	 al, 153			; 00000099H
  00014	75 19		 jne	 SHORT $LN1@ToJeonWooC

; 266  : 
; 267  : 	return dynamic_cast< ioJeonWooChiExtendDashSpecialState* >( pState );

  00016	6a 00		 push	 0
  00018	68 00 00 00 00	 push	 OFFSET ??_R0?AVioJeonWooChiExtendDashSpecialState@@@8
  0001d	68 00 00 00 00	 push	 OFFSET ??_R0?AVioSpecialStateBase@@@8
  00022	6a 00		 push	 0
  00024	56		 push	 esi
  00025	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002a	83 c4 14	 add	 esp, 20			; 00000014H
  0002d	eb 02		 jmp	 SHORT $LN3@ToJeonWooC
$LN1@ToJeonWooC:

; 265  : 		return NULL;

  0002f	33 c0		 xor	 eax, eax
$LN3@ToJeonWooC:
  00031	5e		 pop	 esi

; 268  : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?ToJeonWooChiExtendDashSpecialState@@YAPAVioJeonWooChiExtendDashSpecialState@@PAVioSpecialStateBase@@@Z ENDP ; ToJeonWooChiExtendDashSpecialState
_TEXT	ENDS
PUBLIC	??_R0?AVioMutantItemSpecialState@@@8		; ioMutantItemSpecialState `RTTI Type Descriptor'
PUBLIC	?ToMutantSpecialState@@YAPAVioMutantItemSpecialState@@PAVioSpecialStateBase@@@Z ; ToMutantSpecialState
;	COMDAT ??_R0?AVioMutantItemSpecialState@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iomutantitem.h
_DATA	SEGMENT
??_R0?AVioMutantItemSpecialState@@@8 DD FLAT:??_7type_info@@6B@ ; ioMutantItemSpecialState `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioMutantItemSpecialState@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToMutantSpecialState@@YAPAVioMutantItemSpecialState@@PAVioSpecialStateBase@@@Z
_TEXT	SEGMENT
_pState$ = 8						; size = 4
?ToMutantSpecialState@@YAPAVioMutantItemSpecialState@@PAVioSpecialStateBase@@@Z PROC ; ToMutantSpecialState, COMDAT

; 237  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 238  : 	if( !pState || pState->GetState() != CS_MUTANT_SPECIAL_STATE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pState$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 24		 je	 SHORT $LN1@ToMutantSp
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 50 10	 call	 DWORD PTR [eax+16]
  00012	3c a3		 cmp	 al, 163			; 000000a3H
  00014	75 19		 jne	 SHORT $LN1@ToMutantSp

; 240  : 
; 241  : 	return dynamic_cast< ioMutantItemSpecialState* >( pState );

  00016	6a 00		 push	 0
  00018	68 00 00 00 00	 push	 OFFSET ??_R0?AVioMutantItemSpecialState@@@8
  0001d	68 00 00 00 00	 push	 OFFSET ??_R0?AVioSpecialStateBase@@@8
  00022	6a 00		 push	 0
  00024	56		 push	 esi
  00025	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002a	83 c4 14	 add	 esp, 20			; 00000014H
  0002d	eb 02		 jmp	 SHORT $LN3@ToMutantSp
$LN1@ToMutantSp:

; 239  : 		return NULL;

  0002f	33 c0		 xor	 eax, eax
$LN3@ToMutantSp:
  00031	5e		 pop	 esi

; 242  : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?ToMutantSpecialState@@YAPAVioMutantItemSpecialState@@PAVioSpecialStateBase@@@Z ENDP ; ToMutantSpecialState
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx9math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR3@@QAE@XZ PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 165  :     D3DXVECTOR3() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
PUBLIC	??0D3DXQUATERNION@@QAE@XZ			; D3DXQUATERNION::D3DXQUATERNION
; Function compile flags: /Ogsp
;	COMDAT ??0D3DXQUATERNION@@QAE@XZ
_TEXT	SEGMENT
??0D3DXQUATERNION@@QAE@XZ PROC				; D3DXQUATERNION::D3DXQUATERNION, COMDAT
; _this$ = ecx

; 429  :     D3DXQUATERNION() {}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXQUATERNION@@QAE@XZ ENDP				; D3DXQUATERNION::D3DXQUATERNION
_TEXT	ENDS
PUBLIC	??_R0?AVioGunnerItem@@@8			; ioGunnerItem `RTTI Type Descriptor'
PUBLIC	?ToGunnerItem@@YAPAVioGunnerItem@@PAVioWeaponItem@@@Z ; ToGunnerItem
;	COMDAT ??_R0?AVioGunnerItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iogunneritem.h
_DATA	SEGMENT
??_R0?AVioGunnerItem@@@8 DD FLAT:??_7type_info@@6B@	; ioGunnerItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioGunnerItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToGunnerItem@@YAPAVioGunnerItem@@PAVioWeaponItem@@@Z
_TEXT	SEGMENT
_pWeapon$ = 8						; size = 4
?ToGunnerItem@@YAPAVioGunnerItem@@PAVioWeaponItem@@@Z PROC ; ToGunnerItem, COMDAT

; 249  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 250  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_GUNNER )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pWeapon$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 2a		 je	 SHORT $LN1@ToGunnerIt
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 90 f0 02 00
	00		 call	 DWORD PTR [eax+752]
  00015	3d 97 00 00 00	 cmp	 eax, 151		; 00000097H
  0001a	75 19		 jne	 SHORT $LN1@ToGunnerIt

; 252  : 
; 253  : 	return dynamic_cast< ioGunnerItem* >( pWeapon );

  0001c	6a 00		 push	 0
  0001e	68 00 00 00 00	 push	 OFFSET ??_R0?AVioGunnerItem@@@8
  00023	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWeaponItem@@@8
  00028	6a 00		 push	 0
  0002a	56		 push	 esi
  0002b	e8 00 00 00 00	 call	 ___RTDynamicCast
  00030	83 c4 14	 add	 esp, 20			; 00000014H
  00033	eb 02		 jmp	 SHORT $LN3@ToGunnerIt
$LN1@ToGunnerIt:

; 251  : 		return NULL;

  00035	33 c0		 xor	 eax, eax
$LN3@ToGunnerIt:
  00037	5e		 pop	 esi

; 254  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?ToGunnerItem@@YAPAVioGunnerItem@@PAVioWeaponItem@@@Z ENDP ; ToGunnerItem
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx9math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 303  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 304  :     x = fx;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00008	8b c1		 mov	 eax, ecx
  0000a	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 305  :     y = fy;

  0000e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00013	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 306  :     z = fz;

  00018	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0001d	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 307  : }

  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
PUBLIC	__mask@@NegFloat@
PUBLIC	??GD3DXVECTOR3@@QBE?AU0@XZ			; D3DXVECTOR3::operator-
;	COMDAT __mask@@NegFloat@
CONST	SEGMENT
__mask@@NegFloat@ DB 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??GD3DXVECTOR3@@QBE?AU0@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??GD3DXVECTOR3@@QBE?AU0@XZ PROC				; D3DXVECTOR3::operator-, COMDAT
; _this$ = ecx

; 372  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 373  :     return D3DXVECTOR3(-x, -y, -z);

  00003	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __mask@@NegFloat@
  0000b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000e	f3 0f 10 09	 movss	 xmm1, DWORD PTR [ecx]
  00012	0f 57 c8	 xorps	 xmm1, xmm0
  00015	f3 0f 11 08	 movss	 DWORD PTR [eax], xmm1
  00019	f3 0f 10 49 04	 movss	 xmm1, DWORD PTR [ecx+4]
  0001e	0f 57 c8	 xorps	 xmm1, xmm0
  00021	f3 0f 11 48 04	 movss	 DWORD PTR [eax+4], xmm1
  00026	f3 0f 10 49 08	 movss	 xmm1, DWORD PTR [ecx+8]
  0002b	0f 57 c8	 xorps	 xmm1, xmm0
  0002e	f3 0f 11 48 08	 movss	 DWORD PTR [eax+8], xmm1

; 374  : }

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
??GD3DXVECTOR3@@QBE?AU0@XZ ENDP				; D3DXVECTOR3::operator-
_TEXT	ENDS
PUBLIC	??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z			; D3DXVECTOR3::operator+
; Function compile flags: /Ogsp
;	COMDAT ??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z PROC			; D3DXVECTOR3::operator+, COMDAT
; _this$ = ecx

; 380  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 381  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00006	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  0000a	f3 0f 10 09	 movss	 xmm1, DWORD PTR [ecx]
  0000e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00011	0f 5a c0	 cvtps2pd xmm0, xmm0
  00014	0f 5a c9	 cvtps2pd xmm1, xmm1
  00017	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0001b	f3 0f 10 49 04	 movss	 xmm1, DWORD PTR [ecx+4]
  00020	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00024	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00028	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [edx+4]
  0002d	0f 5a c0	 cvtps2pd xmm0, xmm0
  00030	0f 5a c9	 cvtps2pd xmm1, xmm1
  00033	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00037	f3 0f 10 49 08	 movss	 xmm1, DWORD PTR [ecx+8]
  0003c	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00040	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  00045	f3 0f 10 42 08	 movss	 xmm0, DWORD PTR [edx+8]
  0004a	0f 5a c0	 cvtps2pd xmm0, xmm0
  0004d	0f 5a c9	 cvtps2pd xmm1, xmm1
  00050	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00054	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00058	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 382  : }

  0005d	5d		 pop	 ebp
  0005e	c2 08 00	 ret	 8
??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator+
_TEXT	ENDS
PUBLIC	??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z			; D3DXVECTOR3::operator-
; Function compile flags: /Ogsp
;	COMDAT ??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z PROC			; D3DXVECTOR3::operator-, COMDAT
; _this$ = ecx

; 386  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 387  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00006	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0000a	f3 0f 10 0a	 movss	 xmm1, DWORD PTR [edx]
  0000e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00011	0f 5a c0	 cvtps2pd xmm0, xmm0
  00014	0f 5a c9	 cvtps2pd xmm1, xmm1
  00017	f2 0f 5c c1	 subsd	 xmm0, xmm1
  0001b	f3 0f 10 4a 04	 movss	 xmm1, DWORD PTR [edx+4]
  00020	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00024	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00028	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0002d	0f 5a c0	 cvtps2pd xmm0, xmm0
  00030	0f 5a c9	 cvtps2pd xmm1, xmm1
  00033	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00037	f3 0f 10 4a 08	 movss	 xmm1, DWORD PTR [edx+8]
  0003c	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00040	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  00045	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  0004a	0f 5a c0	 cvtps2pd xmm0, xmm0
  0004d	0f 5a c9	 cvtps2pd xmm1, xmm1
  00050	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00054	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00058	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 388  : }

  0005d	5d		 pop	 ebp
  0005e	c2 08 00	 ret	 8
??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator-
_TEXT	ENDS
PUBLIC	??DD3DXVECTOR3@@QBE?AU0@M@Z			; D3DXVECTOR3::operator*
; Function compile flags: /Ogsp
;	COMDAT ??DD3DXVECTOR3@@QBE?AU0@M@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_f$ = 12						; size = 4
??DD3DXVECTOR3@@QBE?AU0@M@Z PROC			; D3DXVECTOR3::operator*, COMDAT
; _this$ = ecx

; 392  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 393  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00003	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _f$[ebp]
  00008	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000f	0f 5a c0	 cvtps2pd xmm0, xmm0
  00012	0f 5a c9	 cvtps2pd xmm1, xmm1
  00015	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00019	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _f$[ebp]
  0001e	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00022	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00026	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0002b	0f 5a c0	 cvtps2pd xmm0, xmm0
  0002e	0f 5a c9	 cvtps2pd xmm1, xmm1
  00031	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00035	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _f$[ebp]
  0003a	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0003e	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  00043	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00048	0f 5a c0	 cvtps2pd xmm0, xmm0
  0004b	0f 5a c9	 cvtps2pd xmm1, xmm1
  0004e	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00052	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00056	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 394  : }

  0005b	5d		 pop	 ebp
  0005c	c2 08 00	 ret	 8
??DD3DXVECTOR3@@QBE?AU0@M@Z ENDP			; D3DXVECTOR3::operator*
_TEXT	ENDS
PUBLIC	??9D3DXVECTOR3@@QBEHABU0@@Z			; D3DXVECTOR3::operator!=
; Function compile flags: /Ogsp
;	COMDAT ??9D3DXVECTOR3@@QBEHABU0@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
??9D3DXVECTOR3@@QBEHABU0@@Z PROC			; D3DXVECTOR3::operator!=, COMDAT
; _this$ = ecx

; 419  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 420  :     return x != v.x || y != v.y || z != v.z;

  00003	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  00006	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0000a	f3 0f 10 0a	 movss	 xmm1, DWORD PTR [edx]
  0000e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00011	0f 5a c9	 cvtps2pd xmm1, xmm1
  00014	66 0f 2e c1	 ucomisd xmm0, xmm1
  00018	9f		 lahf
  00019	f6 c4 44	 test	 ah, 68			; 00000044H
  0001c	7a 38		 jp	 SHORT $LN3@operator
  0001e	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  00023	f3 0f 10 4a 04	 movss	 xmm1, DWORD PTR [edx+4]
  00028	0f 5a c0	 cvtps2pd xmm0, xmm0
  0002b	0f 5a c9	 cvtps2pd xmm1, xmm1
  0002e	66 0f 2e c1	 ucomisd xmm0, xmm1
  00032	9f		 lahf
  00033	f6 c4 44	 test	 ah, 68			; 00000044H
  00036	7a 1e		 jp	 SHORT $LN3@operator
  00038	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  0003d	f3 0f 10 4a 08	 movss	 xmm1, DWORD PTR [edx+8]
  00042	0f 5a c0	 cvtps2pd xmm0, xmm0
  00045	0f 5a c9	 cvtps2pd xmm1, xmm1
  00048	66 0f 2e c1	 ucomisd xmm0, xmm1
  0004c	9f		 lahf
  0004d	f6 c4 44	 test	 ah, 68			; 00000044H
  00050	7a 04		 jp	 SHORT $LN3@operator
  00052	33 c0		 xor	 eax, eax
  00054	eb 03		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00056	33 c0		 xor	 eax, eax
  00058	40		 inc	 eax
$LN4@operator:

; 421  : }

  00059	5d		 pop	 ebp
  0005a	c2 04 00	 ret	 4
??9D3DXVECTOR3@@QBEHABU0@@Z ENDP			; D3DXVECTOR3::operator!=
_TEXT	ENDS
PUBLIC	??_R0?AVioExtendJump@@@8			; ioExtendJump `RTTI Type Descriptor'
PUBLIC	??_R0?AVioRachelJump@@@8			; ioRachelJump `RTTI Type Descriptor'
PUBLIC	?ToRachelJump@@YAPAVioRachelJump@@PAVioExtendJump@@@Z ; ToRachelJump
;	COMDAT ??_R0?AVioExtendJump@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioracheljump.h
_DATA	SEGMENT
??_R0?AVioExtendJump@@@8 DD FLAT:??_7type_info@@6B@	; ioExtendJump `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioExtendJump@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVioRachelJump@@@8
_DATA	SEGMENT
??_R0?AVioRachelJump@@@8 DD FLAT:??_7type_info@@6B@	; ioRachelJump `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioRachelJump@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToRachelJump@@YAPAVioRachelJump@@PAVioExtendJump@@@Z
_TEXT	SEGMENT
_pJump$ = 8						; size = 4
?ToRachelJump@@YAPAVioRachelJump@@PAVioExtendJump@@@Z PROC ; ToRachelJump, COMDAT

; 177  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 178  : 	if( !pJump || pJump->GetType() != JT_RACHEL_JUMP )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pJump$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 25		 je	 SHORT $LN1@ToRachelJu
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 50 08	 call	 DWORD PTR [eax+8]
  00012	83 f8 15	 cmp	 eax, 21			; 00000015H
  00015	75 19		 jne	 SHORT $LN1@ToRachelJu

; 180  : 
; 181  : 	return dynamic_cast< ioRachelJump* >( pJump );

  00017	6a 00		 push	 0
  00019	68 00 00 00 00	 push	 OFFSET ??_R0?AVioRachelJump@@@8
  0001e	68 00 00 00 00	 push	 OFFSET ??_R0?AVioExtendJump@@@8
  00023	6a 00		 push	 0
  00025	56		 push	 esi
  00026	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002b	83 c4 14	 add	 esp, 20			; 00000014H
  0002e	eb 02		 jmp	 SHORT $LN3@ToRachelJu
$LN1@ToRachelJu:

; 179  : 		return NULL;

  00030	33 c0		 xor	 eax, eax
$LN3@ToRachelJu:
  00032	5e		 pop	 esi

; 182  : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?ToRachelJump@@YAPAVioRachelJump@@PAVioExtendJump@@@Z ENDP ; ToRachelJump
_TEXT	ENDS
PUBLIC	?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z		; D3DXVec3Length
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx9math.inl
;	COMDAT ?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
tv169 = 8						; size = 4
tv160 = 8						; size = 4
_pV$ = 8						; size = 4
?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z PROC		; D3DXVec3Length, COMDAT

; 1710 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1711 : #ifdef D3DX_DEBUG
; 1712 :     if(!pV)
; 1713 :         return 0.0f;
; 1714 : #endif
; 1715 : 
; 1716 : #ifdef __cplusplus
; 1717 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pV$[ebp]
  00006	d9 40 04	 fld	 DWORD PTR [eax+4]
  00009	d9 00		 fld	 DWORD PTR [eax]
  0000b	d9 40 08	 fld	 DWORD PTR [eax+8]
  0000e	d9 c1		 fld	 ST(1)
  00010	de ca		 fmulp	 ST(2), ST(0)
  00012	d9 c2		 fld	 ST(2)
  00014	de cb		 fmulp	 ST(3), ST(0)
  00016	d9 c9		 fxch	 ST(1)
  00018	de c2		 faddp	 ST(2), ST(0)
  0001a	d9 c0		 fld	 ST(0)
  0001c	de c9		 fmulp	 ST(1), ST(0)
  0001e	de c1		 faddp	 ST(1), ST(0)
  00020	d9 5d 08	 fstp	 DWORD PTR tv169[ebp]
  00023	d9 45 08	 fld	 DWORD PTR tv169[ebp]
  00026	e8 00 00 00 00	 call	 __CIsqrt
  0002b	d9 5d 08	 fstp	 DWORD PTR tv160[ebp]
  0002e	d9 45 08	 fld	 DWORD PTR tv160[ebp]

; 1718 : #else
; 1719 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1720 : #endif
; 1721 : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z ENDP		; D3DXVec3Length
_TEXT	ENDS
PUBLIC	?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z	; D3DXVec3Cross
; Function compile flags: /Ogsp
;	COMDAT ?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z
_TEXT	SEGMENT
_v$ = -12						; size = 12
_pOut$ = 8						; size = 4
_pV1$ = 12						; size = 4
_pV2$ = 16						; size = 4
?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z PROC	; D3DXVec3Cross, COMDAT

; 1747 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1757 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;
; 1758 : 
; 1759 :     *pOut = v;

  00006	56		 push	 esi
  00007	57		 push	 edi

; 1748 :     D3DXVECTOR3 v;
; 1749 : 
; 1750 : #ifdef D3DX_DEBUG
; 1751 :     if(!pOut || !pV1 || !pV2)
; 1752 :         return NULL;
; 1753 : #endif
; 1754 : 
; 1755 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00008	8b 45 0c	 mov	 eax, DWORD PTR _pV1$[ebp]
  0000b	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00010	f3 0f 10 50 08	 movss	 xmm2, DWORD PTR [eax+8]
  00015	8b 4d 10	 mov	 ecx, DWORD PTR _pV2$[ebp]
  00018	f3 0f 10 49 08	 movss	 xmm1, DWORD PTR [ecx+8]
  0001d	f3 0f 10 59 04	 movss	 xmm3, DWORD PTR [ecx+4]
  00022	0f 5a e8	 cvtps2pd xmm5, xmm0
  00025	0f 5a e1	 cvtps2pd xmm4, xmm1
  00028	0f 5a f2	 cvtps2pd xmm6, xmm2
  0002b	f2 0f 59 e5	 mulsd	 xmm4, xmm5

; 1756 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  0002f	0f 5a d2	 cvtps2pd xmm2, xmm2
  00032	0f 5a c9	 cvtps2pd xmm1, xmm1
  00035	0f 5a eb	 cvtps2pd xmm5, xmm3
  00038	f2 0f 59 ee	 mulsd	 xmm5, xmm6
  0003c	f2 0f 5c e5	 subsd	 xmm4, xmm5
  00040	f3 0f 10 28	 movss	 xmm5, DWORD PTR [eax]

; 1757 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;
; 1758 : 
; 1759 :     *pOut = v;

  00044	8b 45 08	 mov	 eax, DWORD PTR _pOut$[ebp]
  00047	66 0f 5a e4	 cvtpd2ps xmm4, xmm4
  0004b	f3 0f 11 65 f4	 movss	 DWORD PTR _v$[ebp], xmm4
  00050	f3 0f 10 21	 movss	 xmm4, DWORD PTR [ecx]
  00054	0f 5a f4	 cvtps2pd xmm6, xmm4
  00057	f2 0f 59 f2	 mulsd	 xmm6, xmm2
  0005b	0f 5a d5	 cvtps2pd xmm2, xmm5
  0005e	f2 0f 59 d1	 mulsd	 xmm2, xmm1
  00062	f2 0f 5c f2	 subsd	 xmm6, xmm2
  00066	66 0f 5a ce	 cvtpd2ps xmm1, xmm6
  0006a	f3 0f 11 4d f8	 movss	 DWORD PTR _v$[ebp+4], xmm1
  0006f	0f 5a c0	 cvtps2pd xmm0, xmm0
  00072	0f 5a d3	 cvtps2pd xmm2, xmm3
  00075	0f 5a cd	 cvtps2pd xmm1, xmm5
  00078	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  0007c	8d 75 f4	 lea	 esi, DWORD PTR _v$[ebp]
  0007f	8b f8		 mov	 edi, eax
  00081	0f 5a d4	 cvtps2pd xmm2, xmm4
  00084	f2 0f 59 d0	 mulsd	 xmm2, xmm0
  00088	f2 0f 5c ca	 subsd	 xmm1, xmm2
  0008c	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  00090	f3 0f 11 45 fc	 movss	 DWORD PTR _v$[ebp+8], xmm0
  00095	a5		 movsd
  00096	a5		 movsd
  00097	a5		 movsd
  00098	5f		 pop	 edi
  00099	5e		 pop	 esi

; 1760 :     return pOut;
; 1761 : }

  0009a	c9		 leave
  0009b	c3		 ret	 0
?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z ENDP	; D3DXVec3Cross
_TEXT	ENDS
PUBLIC	__real@3f800000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@42c80000
PUBLIC	?SetWereWolfState@ioBaseChar@@QAEXABVioHashString@@M@Z ; ioBaseChar::SetWereWolfState
EXTRN	?SetState@ioBaseChar@@QAEXH_N@Z:PROC		; ioBaseChar::SetState
EXTRN	__imp_?GetAnimationFullTime@ioEntityGroup@@QAEMH@Z:PROC
EXTRN	__imp_?GetLoopSec@ioFrameTimer@@QBEKXZ:PROC
EXTRN	__imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ:PROC
EXTRN	__imp_?SetActionAni@ioEntityGroup@@QAE_NHMMMMMM_N0@Z:PROC
EXTRN	__imp_?ClearAllLoopAni@ioEntityGroup@@QAEXM_N@Z:PROC
EXTRN	__imp_?ClearAllActionAni@ioEntityGroup@@QAEXM_N@Z:PROC
EXTRN	__imp_?GetAnimationIdx@ioEntityGroup@@QAEHABVioHashString@@@Z:PROC
EXTRN	__ftol2:PROC
;	COMDAT __real@3f800000
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasecharspecialstate.cpp
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?SetWereWolfState@ioBaseChar@@QAEXABVioHashString@@M@Z
_TEXT	SEGMENT
_szAni$ = 8						; size = 4
_fTimeRate$ = 12					; size = 4
?SetWereWolfState@ioBaseChar@@QAEXABVioHashString@@M@Z PROC ; ioBaseChar::SetWereWolfState, COMDAT
; _this$ = ecx

; 132  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 133  : 	int iAniID = m_pGroup->GetAnimationIdx( szAni );

  00005	ff 75 08	 push	 DWORD PTR _szAni$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetAnimationIdx@ioEntityGroup@@QAEHABVioHashString@@@Z

; 134  : 
; 135  : 	m_pGroup->ClearAllActionAni( 100.0f, true );

  00013	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42c80000
  0001b	6a 01		 push	 1
  0001d	51		 push	 ecx
  0001e	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00021	8b d8		 mov	 ebx, eax
  00023	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ClearAllActionAni@ioEntityGroup@@QAEXM_N@Z

; 136  : 	m_pGroup->ClearAllLoopAni( 100.0f, true );

  0002e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42c80000
  00036	6a 01		 push	 1
  00038	51		 push	 ecx
  00039	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0003c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ClearAllLoopAni@ioEntityGroup@@QAEXM_N@Z

; 137  : 
; 138  : 	m_pGroup->SetActionAni( iAniID, 100.0f, 100.0f, 1.0f, 1.0f/fTimeRate, 0.0f, 0.0f, true );

  00047	0f 57 c0	 xorps	 xmm0, xmm0
  0004a	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  00052	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00055	6a 01		 push	 1
  00057	6a 01		 push	 1
  00059	83 ec 18	 sub	 esp, 24			; 00000018H
  0005c	f3 0f 11 44 24
	14		 movss	 DWORD PTR [esp+20], xmm0
  00062	f3 0f 11 44 24
	10		 movss	 DWORD PTR [esp+16], xmm0
  00068	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fTimeRate$[ebp]
  0006d	0f 5a c0	 cvtps2pd xmm0, xmm0
  00070	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00074	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  00078	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  0007e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00086	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  0008c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42c80000
  00094	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0009a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0009f	53		 push	 ebx
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetActionAni@ioEntityGroup@@QAE_NHMMMMMM_N0@Z

; 139  : 
; 140  : 	m_AnimationTime.dwStartTime = FRAMEGETTIME();

  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  000ac	8b c8		 mov	 ecx, eax
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ

; 141  : 	m_AnimationTime.dwFullTime  = m_pGroup->GetAnimationFullTime( iAniID ) * fTimeRate;

  000b4	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000b7	53		 push	 ebx
  000b8	89 86 e8 0d 00
	00		 mov	 DWORD PTR [esi+3560], eax
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetAnimationFullTime@ioEntityGroup@@QAEMH@Z
  000c4	d8 4d 0c	 fmul	 DWORD PTR _fTimeRate$[ebp]
  000c7	e8 00 00 00 00	 call	 __ftol2

; 142  : 
; 143  : 	SetState( CS_WEREWOLF );

  000cc	6a 01		 push	 1
  000ce	6a 4c		 push	 76			; 0000004cH
  000d0	8b ce		 mov	 ecx, esi
  000d2	89 86 ec 0d 00
	00		 mov	 DWORD PTR [esi+3564], eax
  000d8	e8 00 00 00 00	 call	 ?SetState@ioBaseChar@@QAEXH_N@Z ; ioBaseChar::SetState
  000dd	5e		 pop	 esi
  000de	5b		 pop	 ebx

; 144  : }

  000df	5d		 pop	 ebp
  000e0	c2 08 00	 ret	 8
?SetWereWolfState@ioBaseChar@@QAEXABVioHashString@@M@Z ENDP ; ioBaseChar::SetWereWolfState
_TEXT	ENDS
PUBLIC	__real@4f800000
PUBLIC	__$ArrayPad$
PUBLIC	?SetGhostStealerState@ioBaseChar@@QAEXABVioHashString@@MABUD3DXVECTOR3@@MMMM@Z ; ioBaseChar::SetGhostStealerState
EXTRN	?SetGhostStealerInfo@ioGhostStealerSpecialState@@QAEXUD3DXVECTOR3@@MMMM@Z:PROC ; ioGhostStealerSpecialState::SetGhostStealerInfo
EXTRN	?CheckCharColSkipTime@ioBaseChar@@QAEXHMK@Z:PROC ; ioBaseChar::CheckCharColSkipTime
EXTRN	_D3DXVec3Normalize@8:PROC
EXTRN	?GetMidPositionByRate@ioGameEntity@@QBE?AUD3DXVECTOR3@@M@Z:PROC ; ioGameEntity::GetMidPositionByRate
EXTRN	__imp_?SetLoopAni@ioEntityGroup@@QAE_NHMMMM@Z:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT __real@4f800000
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
CONST	SEGMENT
__real@4f800000 DD 04f800000r			; 4.29497e+009
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasecharspecialstate.cpp
CONST	ENDS
;	COMDAT ?SetGhostStealerState@ioBaseChar@@QAEXABVioHashString@@MABUD3DXVECTOR3@@MMMM@Z
_TEXT	SEGMENT
_vCurDir$ = -52						; size = 12
_iAniID$ = -40						; size = 4
_fTimeRate$ = -36					; size = 4
tv356 = -32						; size = 4
tv352 = -32						; size = 4
tv348 = -32						; size = 4
$T609763 = -28						; size = 12
_vMoveDir$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_szAniName$ = 8						; size = 4
_fAniRate$ = 12						; size = 4
_vTargetPos$ = 16					; size = 4
_fSpeed$ = 20						; size = 4
_fMoveRate$ = 24					; size = 4
_fEndJumpAmt$ = 28					; size = 4
_fVolumeRate$ = 32					; size = 4
?SetGhostStealerState@ioBaseChar@@QAEXABVioHashString@@MABUD3DXVECTOR3@@MMMM@Z PROC ; ioBaseChar::SetGhostStealerState, COMDAT
; _this$ = ecx

; 1163 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _szAniName$[ebp]
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 10	 mov	 esi, DWORD PTR _vTargetPos$[ebp]
  00018	57		 push	 edi
  00019	8b d9		 mov	 ebx, ecx

; 1164 : 	int iAniID = m_pGroup->GetAnimationIdx( szAniName );

  0001b	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0001e	50		 push	 eax
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetAnimationIdx@ioEntityGroup@@QAEHABVioHashString@@@Z
  00025	89 45 d8	 mov	 DWORD PTR _iAniID$[ebp], eax

; 1165 : 	if( iAniID == -1 )

  00028	83 f8 ff	 cmp	 eax, -1
  0002b	0f 84 06 02 00
	00		 je	 $LN1@SetGhostSt

; 1166 : 		return;
; 1167 : 
; 1168 : 	m_pGroup->ClearAllActionAni( 100.0f, true );

  00031	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42c80000
  00039	6a 01		 push	 1
  0003b	51		 push	 ecx
  0003c	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0003f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ClearAllActionAni@ioEntityGroup@@QAEXM_N@Z

; 1169 : 	m_pGroup->ClearAllLoopAni( 100.0f, true );

  0004a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42c80000
  00052	6a 01		 push	 1
  00054	51		 push	 ecx
  00055	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00058	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ClearAllLoopAni@ioEntityGroup@@QAEXM_N@Z

; 1170 : 
; 1171 : 	float fTimeRate = fAniRate;

  00063	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _fAniRate$[ebp]

; 1172 : 	if( fTimeRate <= 0.0f )

  00068	0f 57 c0	 xorps	 xmm0, xmm0
  0006b	f3 0f 11 4d dc	 movss	 DWORD PTR _fTimeRate$[ebp], xmm1
  00070	0f 2f c1	 comiss	 xmm0, xmm1
  00073	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0007b	72 05		 jb	 SHORT $LN2@SetGhostSt

; 1173 : 		fTimeRate = 1.0f;

  0007d	f3 0f 11 4d dc	 movss	 DWORD PTR _fTimeRate$[ebp], xmm1
$LN2@SetGhostSt:

; 1174 : 
; 1175 : 	m_pGroup->SetLoopAni( iAniID, 100.0f, 1.0f, 1.0f/fTimeRate );

  00082	f2 0f 10 15 00
	00 00 00	 movsd	 xmm2, QWORD PTR __real@3ff0000000000000
  0008a	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0008d	83 ec 10	 sub	 esp, 16			; 00000010H
  00090	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  00096	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _fTimeRate$[ebp]
  0009b	0f 5a c0	 cvtps2pd xmm0, xmm0
  0009e	f2 0f 5e d0	 divsd	 xmm2, xmm0
  000a2	0f 57 c0	 xorps	 xmm0, xmm0
  000a5	66 0f 5a c2	 cvtpd2ps xmm0, xmm2
  000a9	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  000af	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42c80000
  000b7	f3 0f 11 4c 24
	04		 movss	 DWORD PTR [esp+4], xmm1
  000bd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c2	ff 75 d8	 push	 DWORD PTR _iAniID$[ebp]
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetLoopAni@ioEntityGroup@@QAE_NHMMMM@Z

; 1176 : 
; 1177 : 	D3DXVECTOR3 vCurDir = vTargetPos - GetMidPositionByRate();	

  000cb	b8 05 00 00 00	 mov	 eax, 5
  000d0	8b c8		 mov	 ecx, eax
  000d2	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  000d7	89 4d e0	 mov	 DWORD PTR tv356[ebp], ecx
  000da	db 45 e0	 fild	 DWORD PTR tv356[ebp]
  000dd	85 c9		 test	 ecx, ecx
  000df	79 06		 jns	 SHORT $LN18@SetGhostSt
  000e1	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN18@SetGhostSt:
  000e7	89 45 e0	 mov	 DWORD PTR tv352[ebp], eax
  000ea	db 45 e0	 fild	 DWORD PTR tv352[ebp]
  000ed	85 c0		 test	 eax, eax
  000ef	79 06		 jns	 SHORT $LN19@SetGhostSt
  000f1	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN19@SetGhostSt:
  000f7	de f9		 fdivp	 ST(1), ST(0)
  000f9	51		 push	 ecx
  000fa	8d 45 e4	 lea	 eax, DWORD PTR $T609763[ebp]
  000fd	8b cb		 mov	 ecx, ebx
  000ff	d9 5d e0	 fstp	 DWORD PTR tv348[ebp]
  00102	d9 45 e0	 fld	 DWORD PTR tv348[ebp]
  00105	d9 1c 24	 fstp	 DWORD PTR [esp]
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 ?GetMidPositionByRate@ioGameEntity@@QBE?AUD3DXVECTOR3@@M@Z ; ioGameEntity::GetMidPositionByRate
  0010e	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  00112	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  00116	0f 5a c0	 cvtps2pd xmm0, xmm0
  00119	0f 5a c9	 cvtps2pd xmm1, xmm1
  0011c	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00120	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  00125	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00129	f3 0f 11 45 cc	 movss	 DWORD PTR _vCurDir$[ebp], xmm0
  0012e	f3 0f 10 46 04	 movss	 xmm0, DWORD PTR [esi+4]
  00133	0f 5a c0	 cvtps2pd xmm0, xmm0
  00136	0f 5a c9	 cvtps2pd xmm1, xmm1
  00139	f2 0f 5c c1	 subsd	 xmm0, xmm1
  0013d	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  00142	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00146	f3 0f 11 45 d0	 movss	 DWORD PTR _vCurDir$[ebp+4], xmm0
  0014b	f3 0f 10 46 08	 movss	 xmm0, DWORD PTR [esi+8]
  00150	0f 5a c0	 cvtps2pd xmm0, xmm0
  00153	0f 5a c9	 cvtps2pd xmm1, xmm1
  00156	f2 0f 5c c1	 subsd	 xmm0, xmm1
  0015a	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0015e	f3 0f 11 45 d4	 movss	 DWORD PTR _vCurDir$[ebp+8], xmm0

; 1178 : 	D3DXVECTOR3 vMoveDir = vCurDir;

  00163	8d 75 cc	 lea	 esi, DWORD PTR _vCurDir$[ebp]
  00166	8d 7d f0	 lea	 edi, DWORD PTR _vMoveDir$[ebp]
  00169	a5		 movsd

; 1179 : 	D3DXVec3Normalize( &vMoveDir, &vMoveDir );

  0016a	8d 45 f0	 lea	 eax, DWORD PTR _vMoveDir$[ebp]
  0016d	a5		 movsd
  0016e	50		 push	 eax
  0016f	50		 push	 eax
  00170	a5		 movsd
  00171	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8

; 1180 : 
; 1181 : 	float fMoveRange = D3DXVec3Length( &vCurDir ) * fMoveRate;
; 1182 : 
; 1183 : 	CheckCharColSkipTime( iAniID, fTimeRate, 0 );

  00176	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _fTimeRate$[ebp]
  0017b	6a 00		 push	 0
  0017d	51		 push	 ecx
  0017e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00183	ff 75 d8	 push	 DWORD PTR _iAniID$[ebp]
  00186	8b cb		 mov	 ecx, ebx
  00188	e8 00 00 00 00	 call	 ?CheckCharColSkipTime@ioBaseChar@@QAEXHMK@Z ; ioBaseChar::CheckCharColSkipTime

; 1184 : 
; 1185 : 	SetState( CS_GHOST_STEALER_STATE );

  0018d	6a 01		 push	 1
  0018f	6a 67		 push	 103			; 00000067H
  00191	8b cb		 mov	 ecx, ebx
  00193	e8 00 00 00 00	 call	 ?SetState@ioBaseChar@@QAEXH_N@Z ; ioBaseChar::SetState

; 1186 : 
; 1187 : 	ioGhostStealerSpecialState *pGhostStealerSpecialState = ToGhostStealerSpecialState( m_pCharSpeicalState );

  00198	ff b3 14 03 00
	00		 push	 DWORD PTR [ebx+788]
  0019e	e8 00 00 00 00	 call	 ?ToGhostStealerSpecialState@@YAPAVioGhostStealerSpecialState@@PAVioSpecialStateBase@@@Z ; ToGhostStealerSpecialState
  001a3	59		 pop	 ecx

; 1188 : 	if ( pGhostStealerSpecialState )

  001a4	85 c0		 test	 eax, eax
  001a6	0f 84 8b 00 00
	00		 je	 $LN1@SetGhostSt

; 1189 : 		pGhostStealerSpecialState->SetGhostStealerInfo( vMoveDir, fSpeed, fMoveRange, fEndJumpAmt, fVolumeRate );

  001ac	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _vCurDir$[ebp+4]
  001b1	f3 0f 10 4d cc	 movss	 xmm1, DWORD PTR _vCurDir$[ebp]
  001b6	f3 0f 10 55 d4	 movss	 xmm2, DWORD PTR _vCurDir$[ebp+8]
  001bb	f3 0f 10 5d 20	 movss	 xmm3, DWORD PTR _fVolumeRate$[ebp]
  001c0	0f 5a c0	 cvtps2pd xmm0, xmm0
  001c3	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  001c7	0f 5a c9	 cvtps2pd xmm1, xmm1
  001ca	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  001ce	f2 0f 58 c8	 addsd	 xmm1, xmm0
  001d2	0f 57 c0	 xorps	 xmm0, xmm0
  001d5	0f 5a d2	 cvtps2pd xmm2, xmm2
  001d8	83 ec 1c	 sub	 esp, 28			; 0000001cH
  001db	f3 0f 11 5c 24
	18		 movss	 DWORD PTR [esp+24], xmm3
  001e1	f3 0f 10 5d 1c	 movss	 xmm3, DWORD PTR _fEndJumpAmt$[ebp]
  001e6	f2 0f 59 d2	 mulsd	 xmm2, xmm2
  001ea	f2 0f 58 ca	 addsd	 xmm1, xmm2
  001ee	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1
  001f2	f3 0f 10 4d 18	 movss	 xmm1, DWORD PTR _fMoveRate$[ebp]
  001f7	0f 5a c0	 cvtps2pd xmm0, xmm0
  001fa	f2 0f 51 c0	 sqrtsd	 xmm0, xmm0
  001fe	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00202	f3 0f 11 5c 24
	14		 movss	 DWORD PTR [esp+20], xmm3
  00208	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  0020c	0f 5a c9	 cvtps2pd xmm1, xmm1
  0020f	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00213	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00217	f3 0f 11 44 24
	10		 movss	 DWORD PTR [esp+16], xmm0
  0021d	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _fSpeed$[ebp]
  00222	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  00228	8b fc		 mov	 edi, esp
  0022a	8d 75 f0	 lea	 esi, DWORD PTR _vMoveDir$[ebp]
  0022d	a5		 movsd
  0022e	a5		 movsd
  0022f	8b c8		 mov	 ecx, eax
  00231	a5		 movsd
  00232	e8 00 00 00 00	 call	 ?SetGhostStealerInfo@ioGhostStealerSpecialState@@QAEXUD3DXVECTOR3@@MMMM@Z ; ioGhostStealerSpecialState::SetGhostStealerInfo
$LN1@SetGhostSt:

; 1190 : }

  00237	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0023a	5f		 pop	 edi
  0023b	5e		 pop	 esi
  0023c	33 cd		 xor	 ecx, ebp
  0023e	5b		 pop	 ebx
  0023f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00244	c9		 leave
  00245	c2 1c 00	 ret	 28			; 0000001cH
?SetGhostStealerState@ioBaseChar@@QAEXABVioHashString@@MABUD3DXVECTOR3@@MMMM@Z ENDP ; ioBaseChar::SetGhostStealerState
_TEXT	ENDS
PUBLIC	?SetMutantMoveState@ioBaseChar@@QAEXXZ		; ioBaseChar::SetMutantMoveState
EXTRN	?SetMutantMoveInfo@ioMutantItemSpecialState@@QAEXPAVioBaseChar@@@Z:PROC ; ioMutantItemSpecialState::SetMutantMoveInfo
; Function compile flags: /Ogsp
;	COMDAT ?SetMutantMoveState@ioBaseChar@@QAEXXZ
_TEXT	SEGMENT
?SetMutantMoveState@ioBaseChar@@QAEXXZ PROC		; ioBaseChar::SetMutantMoveState, COMDAT
; _this$ = ecx

; 1194 : {

  00000	56		 push	 esi

; 1195 : 	SetState( CS_MUTANT_SPECIAL_STATE );

  00001	6a 01		 push	 1
  00003	68 a3 00 00 00	 push	 163			; 000000a3H
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ?SetState@ioBaseChar@@QAEXH_N@Z ; ioBaseChar::SetState

; 1196 : 
; 1197 : 	ioMutantItemSpecialState *pMutantSpecialState = ToMutantSpecialState( m_pCharSpeicalState );

  0000f	ff b6 14 03 00
	00		 push	 DWORD PTR [esi+788]
  00015	e8 00 00 00 00	 call	 ?ToMutantSpecialState@@YAPAVioMutantItemSpecialState@@PAVioSpecialStateBase@@@Z ; ToMutantSpecialState
  0001a	59		 pop	 ecx

; 1198 : 	if( pMutantSpecialState )

  0001b	85 c0		 test	 eax, eax
  0001d	74 08		 je	 SHORT $LN1@SetMutantM

; 1199 : 		pMutantSpecialState->SetMutantMoveInfo( this );

  0001f	56		 push	 esi
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 ?SetMutantMoveInfo@ioMutantItemSpecialState@@QAEXPAVioBaseChar@@@Z ; ioMutantItemSpecialState::SetMutantMoveInfo
$LN1@SetMutantM:
  00027	5e		 pop	 esi

; 1200 : }

  00028	c3		 ret	 0
?SetMutantMoveState@ioBaseChar@@QAEXXZ ENDP		; ioBaseChar::SetMutantMoveState
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SetTitanExtendMoveState@ioBaseChar@@QAEXABVioHashString@@MUD3DXVECTOR3@@MM_N@Z ; ioBaseChar::SetTitanExtendMoveState
EXTRN	?SetTitanExtendMoveInfo@ioTitanExtendMoveSpecialState@@QAEXUD3DXVECTOR3@@0MM_N@Z:PROC ; ioTitanExtendMoveSpecialState::SetTitanExtendMoveInfo
; Function compile flags: /Ogsp
;	COMDAT ?SetTitanExtendMoveState@ioBaseChar@@QAEXABVioHashString@@MUD3DXVECTOR3@@MM_N@Z
_TEXT	SEGMENT
_vMoveTargetPos$ = -60					; size = 12
tv544 = -48						; size = 4
tv540 = -48						; size = 4
_fMaxRange$ = -48					; size = 4
$T609892 = -44						; size = 12
_vCurDir$ = -44						; size = 12
tv536 = -32						; size = 4
tv490 = -32						; size = 4
tv486 = -32						; size = 4
tv482 = -32						; size = 4
$T609891 = -28						; size = 12
$T609886 = -28						; size = 12
_vMoveDir$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_szAniName$ = 8						; size = 4
_fAniRate$ = 12						; size = 4
_vTargetPos$ = 16					; size = 12
_fSpeed$ = 28						; size = 4
_fMoveRate$ = 32					; size = 4
_bJumpLandAttack$ = 36					; size = 1
?SetTitanExtendMoveState@ioBaseChar@@QAEXABVioHashString@@MUD3DXVECTOR3@@MM_N@Z PROC ; ioBaseChar::SetTitanExtendMoveState, COMDAT
; _this$ = ecx

; 1393 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _szAniName$[ebp]
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8b d9		 mov	 ebx, ecx

; 1394 : 	int iAniID = m_pGroup->GetAnimationIdx( szAniName );

  00018	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0001b	50		 push	 eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetAnimationIdx@ioEntityGroup@@QAEHABVioHashString@@@Z

; 1395 : 	if( iAniID == -1 )

  00022	83 f8 ff	 cmp	 eax, -1
  00025	0f 84 66 02 00
	00		 je	 $LN1@SetTitanEx

; 1396 : 		return;
; 1397 : 	
; 1398 : 	float fTimeRate = fAniRate;

  0002b	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fAniRate$[ebp]

; 1399 : 	if( fTimeRate <= 0.0f )

  00030	0f 57 c9	 xorps	 xmm1, xmm1
  00033	0f 2f c8	 comiss	 xmm1, xmm0
  00036	72 08		 jb	 SHORT $LN2@SetTitanEx

; 1400 : 		fTimeRate = 1.0f;

  00038	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
$LN2@SetTitanEx:

; 1401 : 
; 1402 : 	CheckCharColSkipTime( iAniID, fTimeRate, 0 );

  00040	6a 00		 push	 0
  00042	51		 push	 ecx
  00043	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00048	50		 push	 eax
  00049	8b cb		 mov	 ecx, ebx
  0004b	e8 00 00 00 00	 call	 ?CheckCharColSkipTime@ioBaseChar@@QAEXHMK@Z ; ioBaseChar::CheckCharColSkipTime

; 1403 : 
; 1404 : 	D3DXVECTOR3 vCurDir = vTargetPos - GetMidPositionByRate();

  00050	b8 05 00 00 00	 mov	 eax, 5
  00055	8b c8		 mov	 ecx, eax
  00057	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  0005c	89 4d d0	 mov	 DWORD PTR tv544[ebp], ecx
  0005f	db 45 d0	 fild	 DWORD PTR tv544[ebp]
  00062	85 c9		 test	 ecx, ecx
  00064	79 06		 jns	 SHORT $LN30@SetTitanEx
  00066	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN30@SetTitanEx:
  0006c	89 45 d0	 mov	 DWORD PTR tv540[ebp], eax
  0006f	db 45 d0	 fild	 DWORD PTR tv540[ebp]
  00072	85 c0		 test	 eax, eax
  00074	79 06		 jns	 SHORT $LN31@SetTitanEx
  00076	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN31@SetTitanEx:
  0007c	de f9		 fdivp	 ST(1), ST(0)
  0007e	51		 push	 ecx
  0007f	8d 45 e4	 lea	 eax, DWORD PTR $T609886[ebp]
  00082	8b cb		 mov	 ecx, ebx
  00084	d9 5d e0	 fstp	 DWORD PTR tv536[ebp]
  00087	d9 45 e0	 fld	 DWORD PTR tv536[ebp]
  0008a	d9 1c 24	 fstp	 DWORD PTR [esp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ?GetMidPositionByRate@ioGameEntity@@QBE?AUD3DXVECTOR3@@M@Z ; ioGameEntity::GetMidPositionByRate
  00093	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  00097	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _vTargetPos$[ebp]
  0009c	0f 5a c0	 cvtps2pd xmm0, xmm0
  0009f	0f 5a c9	 cvtps2pd xmm1, xmm1
  000a2	f2 0f 5c c1	 subsd	 xmm0, xmm1
  000a6	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  000ab	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  000af	f3 0f 11 45 d4	 movss	 DWORD PTR _vCurDir$[ebp], xmm0
  000b4	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _vTargetPos$[ebp+4]
  000b9	0f 5a c0	 cvtps2pd xmm0, xmm0
  000bc	0f 5a c9	 cvtps2pd xmm1, xmm1
  000bf	f2 0f 5c c1	 subsd	 xmm0, xmm1
  000c3	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  000c8	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  000cc	f3 0f 11 45 d8	 movss	 DWORD PTR _vCurDir$[ebp+4], xmm0
  000d1	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _vTargetPos$[ebp+8]
  000d6	0f 5a c0	 cvtps2pd xmm0, xmm0
  000d9	0f 5a c9	 cvtps2pd xmm1, xmm1
  000dc	f2 0f 5c c1	 subsd	 xmm0, xmm1
  000e0	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  000e4	f3 0f 11 45 dc	 movss	 DWORD PTR _vCurDir$[ebp+8], xmm0

; 1405 : 	D3DXVECTOR3 vMoveDir = vCurDir;

  000e9	8d 75 d4	 lea	 esi, DWORD PTR _vCurDir$[ebp]
  000ec	8d 7d f0	 lea	 edi, DWORD PTR _vMoveDir$[ebp]
  000ef	a5		 movsd

; 1406 : 	D3DXVec3Normalize( &vMoveDir, &vMoveDir );

  000f0	8d 45 f0	 lea	 eax, DWORD PTR _vMoveDir$[ebp]
  000f3	a5		 movsd
  000f4	50		 push	 eax
  000f5	50		 push	 eax
  000f6	a5		 movsd
  000f7	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8
  000fc	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _vCurDir$[ebp+4]

; 1407 : 
; 1408 : 	float fMaxRange = D3DXVec3Length( &vCurDir ) * fMoveRate;

  00101	f3 0f 10 4d d4	 movss	 xmm1, DWORD PTR _vCurDir$[ebp]
  00106	f3 0f 10 55 dc	 movss	 xmm2, DWORD PTR _vCurDir$[ebp+8]
  0010b	0f 5a c9	 cvtps2pd xmm1, xmm1
  0010e	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  00112	0f 5a c0	 cvtps2pd xmm0, xmm0
  00115	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  00119	f2 0f 58 c8	 addsd	 xmm1, xmm0
  0011d	0f 57 c0	 xorps	 xmm0, xmm0
  00120	0f 5a d2	 cvtps2pd xmm2, xmm2
  00123	f2 0f 59 d2	 mulsd	 xmm2, xmm2
  00127	f2 0f 58 ca	 addsd	 xmm1, xmm2
  0012b	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1
  0012f	f3 0f 10 4d 20	 movss	 xmm1, DWORD PTR _fMoveRate$[ebp]
  00134	0f 5a c9	 cvtps2pd xmm1, xmm1
  00137	0f 5a c0	 cvtps2pd xmm0, xmm0
  0013a	f2 0f 51 c0	 sqrtsd	 xmm0, xmm0
  0013e	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00142	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00146	f2 0f 59 c1	 mulsd	 xmm0, xmm1

; 1409 : 	D3DXVECTOR3 vMoveTargetPos = GetMidPositionByRate() + ( vMoveDir * fMaxRange );

  0014a	f3 0f 10 4d f0	 movss	 xmm1, DWORD PTR _vMoveDir$[ebp]
  0014f	0f 5a c9	 cvtps2pd xmm1, xmm1
  00152	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00156	0f 57 d2	 xorps	 xmm2, xmm2
  00159	f3 0f 5a d0	 cvtss2sd xmm2, xmm0
  0015d	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  00161	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  00165	f3 0f 11 4d d4	 movss	 DWORD PTR $T609892[ebp], xmm1
  0016a	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR _vMoveDir$[ebp+4]
  0016f	0f 5a c9	 cvtps2pd xmm1, xmm1
  00172	0f 57 d2	 xorps	 xmm2, xmm2
  00175	f3 0f 5a d0	 cvtss2sd xmm2, xmm0
  00179	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  0017d	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  00181	f3 0f 11 4d d8	 movss	 DWORD PTR $T609892[ebp+4], xmm1
  00186	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _vMoveDir$[ebp+8]
  0018b	f3 0f 11 45 d0	 movss	 DWORD PTR _fMaxRange$[ebp], xmm0
  00190	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00194	0f 5a c9	 cvtps2pd xmm1, xmm1
  00197	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  0019b	0f 57 c0	 xorps	 xmm0, xmm0
  0019e	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  001a2	f3 0f 11 45 dc	 movss	 DWORD PTR $T609892[ebp+8], xmm0
  001a7	b8 05 00 00 00	 mov	 eax, 5
  001ac	8b c8		 mov	 ecx, eax
  001ae	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  001b3	89 4d e0	 mov	 DWORD PTR tv490[ebp], ecx
  001b6	db 45 e0	 fild	 DWORD PTR tv490[ebp]
  001b9	85 c9		 test	 ecx, ecx
  001bb	79 06		 jns	 SHORT $LN32@SetTitanEx
  001bd	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN32@SetTitanEx:
  001c3	89 45 e0	 mov	 DWORD PTR tv486[ebp], eax
  001c6	db 45 e0	 fild	 DWORD PTR tv486[ebp]
  001c9	85 c0		 test	 eax, eax
  001cb	79 06		 jns	 SHORT $LN33@SetTitanEx
  001cd	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN33@SetTitanEx:
  001d3	de f9		 fdivp	 ST(1), ST(0)
  001d5	51		 push	 ecx
  001d6	8d 45 e4	 lea	 eax, DWORD PTR $T609891[ebp]
  001d9	8b cb		 mov	 ecx, ebx
  001db	d9 5d e0	 fstp	 DWORD PTR tv482[ebp]
  001de	d9 45 e0	 fld	 DWORD PTR tv482[ebp]
  001e1	d9 1c 24	 fstp	 DWORD PTR [esp]
  001e4	50		 push	 eax
  001e5	e8 00 00 00 00	 call	 ?GetMidPositionByRate@ioGameEntity@@QBE?AUD3DXVECTOR3@@M@Z ; ioGameEntity::GetMidPositionByRate
  001ea	f3 0f 10 4d d4	 movss	 xmm1, DWORD PTR $T609892[ebp]
  001ef	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001f3	0f 5a c0	 cvtps2pd xmm0, xmm0
  001f6	0f 5a c9	 cvtps2pd xmm1, xmm1
  001f9	f2 0f 58 c1	 addsd	 xmm0, xmm1
  001fd	f3 0f 10 4d d8	 movss	 xmm1, DWORD PTR $T609892[ebp+4]
  00202	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00206	f3 0f 11 45 c4	 movss	 DWORD PTR _vMoveTargetPos$[ebp], xmm0
  0020b	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00210	0f 5a c0	 cvtps2pd xmm0, xmm0
  00213	0f 5a c9	 cvtps2pd xmm1, xmm1
  00216	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0021a	f3 0f 10 4d dc	 movss	 xmm1, DWORD PTR $T609892[ebp+8]
  0021f	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00223	f3 0f 11 45 c8	 movss	 DWORD PTR _vMoveTargetPos$[ebp+4], xmm0
  00228	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0022d	0f 5a c0	 cvtps2pd xmm0, xmm0
  00230	0f 5a c9	 cvtps2pd xmm1, xmm1

; 1410 : 
; 1411 : 	SetState( CS_TITAN_EXTEND_MOVE );

  00233	6a 01		 push	 1
  00235	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00239	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0023d	6a 72		 push	 114			; 00000072H
  0023f	8b cb		 mov	 ecx, ebx
  00241	f3 0f 11 45 cc	 movss	 DWORD PTR _vMoveTargetPos$[ebp+8], xmm0
  00246	e8 00 00 00 00	 call	 ?SetState@ioBaseChar@@QAEXH_N@Z ; ioBaseChar::SetState

; 1412 : 
; 1413 : 	ioTitanExtendMoveSpecialState *pTitanExtendMoveSpecialState = ToTitanExtendMoveSpecialState( m_pCharSpeicalState );

  0024b	ff b3 14 03 00
	00		 push	 DWORD PTR [ebx+788]
  00251	e8 00 00 00 00	 call	 ?ToTitanExtendMoveSpecialState@@YAPAVioTitanExtendMoveSpecialState@@PAVioSpecialStateBase@@@Z ; ToTitanExtendMoveSpecialState
  00256	59		 pop	 ecx

; 1414 : 	if ( pTitanExtendMoveSpecialState )

  00257	85 c0		 test	 eax, eax
  00259	74 36		 je	 SHORT $LN1@SetTitanEx

; 1415 : 		pTitanExtendMoveSpecialState->SetTitanExtendMoveInfo( vMoveDir, vMoveTargetPos, fSpeed, fMaxRange, bJumpLandAttack );

  0025b	ff 75 24	 push	 DWORD PTR _bJumpLandAttack$[ebp]
  0025e	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _fMaxRange$[ebp]
  00263	83 ec 14	 sub	 esp, 20			; 00000014H
  00266	f3 0f 11 44 24
	10		 movss	 DWORD PTR [esp+16], xmm0
  0026c	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _fSpeed$[ebp]
  00271	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  00277	8b fc		 mov	 edi, esp
  00279	8d 75 c4	 lea	 esi, DWORD PTR _vMoveTargetPos$[ebp]
  0027c	a5		 movsd
  0027d	a5		 movsd
  0027e	a5		 movsd
  0027f	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00282	8b fc		 mov	 edi, esp
  00284	8d 75 f0	 lea	 esi, DWORD PTR _vMoveDir$[ebp]
  00287	a5		 movsd
  00288	a5		 movsd
  00289	8b c8		 mov	 ecx, eax
  0028b	a5		 movsd
  0028c	e8 00 00 00 00	 call	 ?SetTitanExtendMoveInfo@ioTitanExtendMoveSpecialState@@QAEXUD3DXVECTOR3@@0MM_N@Z ; ioTitanExtendMoveSpecialState::SetTitanExtendMoveInfo
$LN1@SetTitanEx:

; 1416 : }

  00291	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00294	5f		 pop	 edi
  00295	5e		 pop	 esi
  00296	33 cd		 xor	 ecx, ebp
  00298	5b		 pop	 ebx
  00299	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0029e	c9		 leave
  0029f	c2 20 00	 ret	 32			; 00000020H
?SetTitanExtendMoveState@ioBaseChar@@QAEXABVioHashString@@MUD3DXVECTOR3@@MM_N@Z ENDP ; ioBaseChar::SetTitanExtendMoveState
_TEXT	ENDS
PUBLIC	?SetJeonWooChiExtenDashState@ioBaseChar@@QAEXUD3DXVECTOR3@@0MM@Z ; ioBaseChar::SetJeonWooChiExtenDashState
EXTRN	?SetExtendDashInfo@ioJeonWooChiExtendDashSpecialState@@QAEXUD3DXVECTOR3@@0MM@Z:PROC ; ioJeonWooChiExtendDashSpecialState::SetExtendDashInfo
; Function compile flags: /Ogsp
;	COMDAT ?SetJeonWooChiExtenDashState@ioBaseChar@@QAEXUD3DXVECTOR3@@0MM@Z
_TEXT	SEGMENT
_vMoveDir$ = 8						; size = 12
_vTargetPos$ = 20					; size = 12
_fMoveSpeed$ = 32					; size = 4
_fMaxRange$ = 36					; size = 4
?SetJeonWooChiExtenDashState@ioBaseChar@@QAEXUD3DXVECTOR3@@0MM@Z PROC ; ioBaseChar::SetJeonWooChiExtenDashState, COMDAT
; _this$ = ecx

; 1420 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1421 : 	SetState( CS_JEONWOOCHI_EXTEND_DASH );

  00005	6a 01		 push	 1
  00007	68 99 00 00 00	 push	 153			; 00000099H
  0000c	8b f1		 mov	 esi, ecx
  0000e	e8 00 00 00 00	 call	 ?SetState@ioBaseChar@@QAEXH_N@Z ; ioBaseChar::SetState

; 1422 : 
; 1423 : 	ioJeonWooChiExtendDashSpecialState *pJeonWooChiExtendDashState = ToJeonWooChiExtendDashSpecialState( m_pCharSpeicalState );

  00013	ff b6 14 03 00
	00		 push	 DWORD PTR [esi+788]
  00019	e8 00 00 00 00	 call	 ?ToJeonWooChiExtendDashSpecialState@@YAPAVioJeonWooChiExtendDashSpecialState@@PAVioSpecialStateBase@@@Z ; ToJeonWooChiExtendDashSpecialState
  0001e	59		 pop	 ecx

; 1424 : 	if( pJeonWooChiExtendDashState )

  0001f	85 c0		 test	 eax, eax
  00021	74 33		 je	 SHORT $LN1@SetJeonWoo

; 1425 : 		pJeonWooChiExtendDashState->SetExtendDashInfo( vMoveDir, vTargetPos, fMoveSpeed, fMaxRange );

  00023	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _fMaxRange$[ebp]
  00028	83 ec 14	 sub	 esp, 20			; 00000014H
  0002b	f3 0f 11 44 24
	10		 movss	 DWORD PTR [esp+16], xmm0
  00031	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _fMoveSpeed$[ebp]
  00036	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  0003c	8b fc		 mov	 edi, esp
  0003e	8d 75 14	 lea	 esi, DWORD PTR _vTargetPos$[ebp]
  00041	a5		 movsd
  00042	a5		 movsd
  00043	a5		 movsd
  00044	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00047	8b fc		 mov	 edi, esp
  00049	8d 75 08	 lea	 esi, DWORD PTR _vMoveDir$[ebp]
  0004c	a5		 movsd
  0004d	a5		 movsd
  0004e	8b c8		 mov	 ecx, eax
  00050	a5		 movsd
  00051	e8 00 00 00 00	 call	 ?SetExtendDashInfo@ioJeonWooChiExtendDashSpecialState@@QAEXUD3DXVECTOR3@@0MM@Z ; ioJeonWooChiExtendDashSpecialState::SetExtendDashInfo
$LN1@SetJeonWoo:

; 1426 : }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5d		 pop	 ebp
  00059	c2 20 00	 ret	 32			; 00000020H
?SetJeonWooChiExtenDashState@ioBaseChar@@QAEXUD3DXVECTOR3@@0MM@Z ENDP ; ioBaseChar::SetJeonWooChiExtenDashState
_TEXT	ENDS
PUBLIC	?GetAt@?$ioTPtrGrowArray@VioBuff@@@@QBEPAVioBuff@@H@Z ; ioTPtrGrowArray<ioBuff>::GetAt
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iotptrgrowarray.h
;	COMDAT ?GetAt@?$ioTPtrGrowArray@VioBuff@@@@QBEPAVioBuff@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetAt@?$ioTPtrGrowArray@VioBuff@@@@QBEPAVioBuff@@H@Z PROC ; ioTPtrGrowArray<ioBuff>::GetAt, COMDAT
; _this$ = ecx

; 60   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 61   : 		if( i>=0 && i<m_iMaxCount )

  00003	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN1@GetAt
  0000a	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0000d	7d 07		 jge	 SHORT $LN1@GetAt

; 62   : 			return m_pBase[i];

  0000f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00011	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00014	eb 02		 jmp	 SHORT $LN2@GetAt
$LN1@GetAt:

; 63   : 
; 64   : 		return NULL;

  00016	33 c0		 xor	 eax, eax
$LN2@GetAt:

; 65   : 	}

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?GetAt@?$ioTPtrGrowArray@VioBuff@@@@QBEPAVioBuff@@H@Z ENDP ; ioTPtrGrowArray<ioBuff>::GetAt
_TEXT	ENDS
PUBLIC	?MaxCount@?$ioTPtrGrowArray@VioBuff@@@@QBEHXZ	; ioTPtrGrowArray<ioBuff>::MaxCount
; Function compile flags: /Ogsp
;	COMDAT ?MaxCount@?$ioTPtrGrowArray@VioBuff@@@@QBEHXZ
_TEXT	SEGMENT
?MaxCount@?$ioTPtrGrowArray@VioBuff@@@@QBEHXZ PROC	; ioTPtrGrowArray<ioBuff>::MaxCount, COMDAT
; _this$ = ecx

; 67   : 	inline int MaxCount() const { return m_iMaxCount; }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?MaxCount@?$ioTPtrGrowArray@VioBuff@@@@QBEHXZ ENDP	; ioTPtrGrowArray<ioBuff>::MaxCount
_TEXT	ENDS
PUBLIC	?DecryptValueToPool@?$CEncrypt@W4JumpState@@@@QAEXPAW4JumpState@@@Z ; CEncrypt<enum JumpState>::DecryptValueToPool
EXTRN	?DecryptByte@ccddaabb@@QBEXPBDPADH@Z:PROC	; ccddaabb::DecryptByte
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
;	COMDAT ?DecryptValueToPool@?$CEncrypt@W4JumpState@@@@QAEXPAW4JumpState@@@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?DecryptValueToPool@?$CEncrypt@W4JumpState@@@@QAEXPAW4JumpState@@@Z PROC ; CEncrypt<enum JumpState>::DecryptValueToPool, COMDAT
; _this$ = ecx

; 2317 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2318 : 		m_RC5.DecryptByte( m_MemPool, m_TempMem, sizeof(JumpState) );

  00004	8d 71 28	 lea	 esi, DWORD PTR [ecx+40]
  00007	6a 04		 push	 4
  00009	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00011	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte

; 2319 : 		*value = *((JumpState*)m_TempMem);

  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0001b	89 01		 mov	 DWORD PTR [ecx], eax
  0001d	5e		 pop	 esi

; 2320 : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?DecryptValueToPool@?$CEncrypt@W4JumpState@@@@QAEXPAW4JumpState@@@Z ENDP ; CEncrypt<enum JumpState>::DecryptValueToPool
_TEXT	ENDS
PUBLIC	__real@3f91df46a2526c7a
PUBLIC	??$DEGtoRAD@M@@YAMM@Z				; DEGtoRAD<float>
;	COMDAT __real@3f91df46a2526c7a
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\veryoftenusedefine.h
CONST	SEGMENT
__real@3f91df46a2526c7a DQ 03f91df46a2526c7ar	; 0.0174533
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??$DEGtoRAD@M@@YAMM@Z
_TEXT	SEGMENT
tv129 = 8						; size = 4
_val$ = 8						; size = 4
??$DEGtoRAD@M@@YAMM@Z PROC				; DEGtoRAD<float>, COMDAT

; 20   : type  DEGtoRAD (type val) {return (type) (val * 0.0174532925199);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR _val$[ebp]
  00006	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3f91df46a2526c7a
  0000c	d9 5d 08	 fstp	 DWORD PTR tv129[ebp]
  0000f	d9 45 08	 fld	 DWORD PTR tv129[ebp]
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$DEGtoRAD@M@@YAMM@Z ENDP				; DEGtoRAD<float>
_TEXT	ENDS
PUBLIC	??_R0?AVioItem@@@8				; ioItem `RTTI Type Descriptor'
PUBLIC	??_R0?AVioAttackableItem@@@8			; ioAttackableItem `RTTI Type Descriptor'
PUBLIC	?ToAttackableItem@@YAPAVioAttackableItem@@PAVioItem@@@Z ; ToAttackableItem
;	COMDAT ??_R0?AVioItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioattackableitem.h
_DATA	SEGMENT
??_R0?AVioItem@@@8 DD FLAT:??_7type_info@@6B@		; ioItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioItem@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVioAttackableItem@@@8
_DATA	SEGMENT
??_R0?AVioAttackableItem@@@8 DD FLAT:??_7type_info@@6B@	; ioAttackableItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioAttackableItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToAttackableItem@@YAPAVioAttackableItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToAttackableItem@@YAPAVioAttackableItem@@PAVioItem@@@Z PROC ; ToAttackableItem, COMDAT

; 737  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 738  : 	if( !pItem )	return NULL;

  00004	8b 75 08	 mov	 esi, DWORD PTR _pItem$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 04		 jne	 SHORT $LN2@ToAttackab
$LN5@ToAttackab:
  0000b	33 c0		 xor	 eax, eax
  0000d	eb 2f		 jmp	 SHORT $LN3@ToAttackab
$LN2@ToAttackab:

; 739  : 	if( pItem->GetType() != ioItem::IT_WEAPON && pItem->GetType() != ioItem::IT_ARMOR )

  0000f	8b 06		 mov	 eax, DWORD PTR [esi]
  00011	8b ce		 mov	 ecx, esi
  00013	ff 50 08	 call	 DWORD PTR [eax+8]
  00016	83 f8 01	 cmp	 eax, 1
  00019	74 0c		 je	 SHORT $LN1@ToAttackab
  0001b	8b 06		 mov	 eax, DWORD PTR [esi]
  0001d	8b ce		 mov	 ecx, esi
  0001f	ff 50 08	 call	 DWORD PTR [eax+8]
  00022	83 f8 02	 cmp	 eax, 2

; 740  : 		return NULL;

  00025	75 e4		 jne	 SHORT $LN5@ToAttackab
$LN1@ToAttackab:

; 741  : 
; 742  : 	return dynamic_cast< ioAttackableItem* >( pItem );

  00027	6a 00		 push	 0
  00029	68 00 00 00 00	 push	 OFFSET ??_R0?AVioAttackableItem@@@8
  0002e	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  00033	6a 00		 push	 0
  00035	56		 push	 esi
  00036	e8 00 00 00 00	 call	 ___RTDynamicCast
  0003b	83 c4 14	 add	 esp, 20			; 00000014H
$LN3@ToAttackab:
  0003e	5e		 pop	 esi

; 743  : }

  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?ToAttackableItem@@YAPAVioAttackableItem@@PAVioItem@@@Z ENDP ; ToAttackableItem
_TEXT	ENDS
PUBLIC	?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z	; ToWeaponItem
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioweaponitem.h
;	COMDAT ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z PROC	; ToWeaponItem, COMDAT

; 303  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 304  : 	if( !pItem || pItem->GetType() != ioItem::IT_WEAPON )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pItem$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 25		 je	 SHORT $LN1@ToWeaponIt
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 50 08	 call	 DWORD PTR [eax+8]
  00012	83 f8 01	 cmp	 eax, 1
  00015	75 19		 jne	 SHORT $LN1@ToWeaponIt

; 306  : 
; 307  : 	return dynamic_cast< ioWeaponItem* >( pItem );

  00017	6a 00		 push	 0
  00019	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWeaponItem@@@8
  0001e	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  00023	6a 00		 push	 0
  00025	56		 push	 esi
  00026	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002b	83 c4 14	 add	 esp, 20			; 00000014H
  0002e	eb 02		 jmp	 SHORT $LN3@ToWeaponIt
$LN1@ToWeaponIt:

; 305  : 		return NULL;

  00030	33 c0		 xor	 eax, eax
$LN3@ToWeaponIt:
  00032	5e		 pop	 esi

; 308  : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ENDP	; ToWeaponItem
_TEXT	ENDS
PUBLIC	??_R0?AVioObjectItem@@@8			; ioObjectItem `RTTI Type Descriptor'
PUBLIC	?ToObjectItem@@YAPAVioObjectItem@@PAVioItem@@@Z	; ToObjectItem
;	COMDAT ??_R0?AVioObjectItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioobjectitem.h
_DATA	SEGMENT
??_R0?AVioObjectItem@@@8 DD FLAT:??_7type_info@@6B@	; ioObjectItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioObjectItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToObjectItem@@YAPAVioObjectItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToObjectItem@@YAPAVioObjectItem@@PAVioItem@@@Z PROC	; ToObjectItem, COMDAT

; 176  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 177  : 	if( !pItem || pItem->GetType() != ioItem::IT_OBJECT )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pItem$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 25		 je	 SHORT $LN1@ToObjectIt
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 50 08	 call	 DWORD PTR [eax+8]
  00012	83 f8 05	 cmp	 eax, 5
  00015	75 19		 jne	 SHORT $LN1@ToObjectIt

; 179  : 
; 180  : 	return dynamic_cast< ioObjectItem* >( pItem );

  00017	6a 00		 push	 0
  00019	68 00 00 00 00	 push	 OFFSET ??_R0?AVioObjectItem@@@8
  0001e	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  00023	6a 00		 push	 0
  00025	56		 push	 esi
  00026	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002b	83 c4 14	 add	 esp, 20			; 00000014H
  0002e	eb 02		 jmp	 SHORT $LN3@ToObjectIt
$LN1@ToObjectIt:

; 178  : 		return NULL;

  00030	33 c0		 xor	 eax, eax
$LN3@ToObjectIt:
  00032	5e		 pop	 esi

; 181  : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?ToObjectItem@@YAPAVioObjectItem@@PAVioItem@@@Z ENDP	; ToObjectItem
_TEXT	ENDS
PUBLIC	?GetTypeID@ioBuff@@QBEHXZ			; ioBuff::GetTypeID
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobuff.h
;	COMDAT ?GetTypeID@ioBuff@@QBEHXZ
_TEXT	SEGMENT
?GetTypeID@ioBuff@@QBEHXZ PROC				; ioBuff::GetTypeID, COMDAT
; _this$ = ecx

; 424  : 	inline int GetTypeID() const { return m_iBuffType; }

  00000	8b 81 cc 03 00
	00		 mov	 eax, DWORD PTR [ecx+972]
  00006	c3		 ret	 0
?GetTypeID@ioBuff@@QBEHXZ ENDP				; ioBuff::GetTypeID
_TEXT	ENDS
PUBLIC	?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z	; CEncrypt<float>::EncryptValueToPool
EXTRN	?EncryptByte@ccddaabb@@QAEXPBDPADH@Z:PROC	; ccddaabb::EncryptByte
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
;	COMDAT ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z PROC	; CEncrypt<float>::EncryptValueToPool, COMDAT
; _this$ = ecx

; 67   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 		m_RC5.EncryptByte( value, m_MemPool, max(m_ValueSize, DEFAULT_ENCRYPT) );

  00003	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00007	83 f8 04	 cmp	 eax, 4
  0000a	77 03		 ja	 SHORT $LN4@EncryptVal
  0000c	6a 04		 push	 4
  0000e	58		 pop	 eax
$LN4@EncryptVal:
  0000f	50		 push	 eax
  00010	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  00013	50		 push	 eax
  00014	ff 75 08	 push	 DWORD PTR _value$[ebp]
  00017	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0001a	e8 00 00 00 00	 call	 ?EncryptByte@ccddaabb@@QAEXPBDPADH@Z ; ccddaabb::EncryptByte

; 69   : 		
; 70   : 	}

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ENDP	; CEncrypt<float>::EncryptValueToPool
_TEXT	ENDS
PUBLIC	?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z	; CEncrypt<float>::DecryptValueToPool
; Function compile flags: /Ogsp
;	COMDAT ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z PROC	; CEncrypt<float>::DecryptValueToPool, COMDAT
; _this$ = ecx

; 1648 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1649 : 		m_RC5.DecryptByte( m_MemPool, m_TempMem, 4 );

  00004	8d 71 28	 lea	 esi, DWORD PTR [ecx+40]
  00007	6a 04		 push	 4
  00009	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00011	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte

; 1650 : 		*value = *((float*)m_TempMem);

  00016	d9 06		 fld	 DWORD PTR [esi]
  00018	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  0001b	d9 18		 fstp	 DWORD PTR [eax]
  0001d	5e		 pop	 esi

; 1651 : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ENDP	; CEncrypt<float>::DecryptValueToPool
_TEXT	ENDS
PUBLIC	?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z	; CEncrypt<unsigned long>::EncryptValueToPool
; Function compile flags: /Ogsp
;	COMDAT ?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z PROC	; CEncrypt<unsigned long>::EncryptValueToPool, COMDAT
; _this$ = ecx

; 67   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 		m_RC5.EncryptByte( value, m_MemPool, max(m_ValueSize, DEFAULT_ENCRYPT) );

  00003	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00007	83 f8 04	 cmp	 eax, 4
  0000a	77 03		 ja	 SHORT $LN4@EncryptVal@2
  0000c	6a 04		 push	 4
  0000e	58		 pop	 eax
$LN4@EncryptVal@2:
  0000f	50		 push	 eax
  00010	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  00013	50		 push	 eax
  00014	ff 75 08	 push	 DWORD PTR _value$[ebp]
  00017	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0001a	e8 00 00 00 00	 call	 ?EncryptByte@ccddaabb@@QAEXPBDPADH@Z ; ccddaabb::EncryptByte

; 69   : 		
; 70   : 	}

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z ENDP	; CEncrypt<unsigned long>::EncryptValueToPool
_TEXT	ENDS
PUBLIC	?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z	; CEncrypt<unsigned long>::DecryptValueToPool
; Function compile flags: /Ogsp
;	COMDAT ?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z PROC	; CEncrypt<unsigned long>::DecryptValueToPool, COMDAT
; _this$ = ecx

; 1256 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1257 : 		m_RC5.DecryptByte( m_MemPool, m_TempMem, 4 );

  00004	8d 71 28	 lea	 esi, DWORD PTR [ecx+40]
  00007	6a 04		 push	 4
  00009	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00011	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte

; 1258 : 		*value = *((DWORD*)m_TempMem);

  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0001b	89 01		 mov	 DWORD PTR [ecx], eax
  0001d	5e		 pop	 esi

; 1259 : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z ENDP	; CEncrypt<unsigned long>::DecryptValueToPool
_TEXT	ENDS
PUBLIC	?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z	; CEncrypt<bool>::DecryptValueToPool
; Function compile flags: /Ogsp
;	COMDAT ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z PROC	; CEncrypt<bool>::DecryptValueToPool, COMDAT
; _this$ = ecx

; 219  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 220  : 		m_RC5.DecryptByte( m_MemPool, m_TempMem, 4 );

  00004	8d 71 28	 lea	 esi, DWORD PTR [ecx+40]
  00007	6a 04		 push	 4
  00009	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00011	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte

; 221  : 		*value = *((bool*)m_TempMem);

  00016	8a 06		 mov	 al, BYTE PTR [esi]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0001b	88 01		 mov	 BYTE PTR [ecx], al
  0001d	5e		 pop	 esi

; 222  : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ENDP	; CEncrypt<bool>::DecryptValueToPool
_TEXT	ENDS
PUBLIC	??_R0?AVioSummonChargeItem3@@@8			; ioSummonChargeItem3 `RTTI Type Descriptor'
PUBLIC	?ToSummonChargeItem3@@YAPAVioSummonChargeItem3@@PAVioItem@@@Z ; ToSummonChargeItem3
;	COMDAT ??_R0?AVioSummonChargeItem3@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iosummonchargeitem3.h
_DATA	SEGMENT
??_R0?AVioSummonChargeItem3@@@8 DD FLAT:??_7type_info@@6B@ ; ioSummonChargeItem3 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioSummonChargeItem3@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToSummonChargeItem3@@YAPAVioSummonChargeItem3@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToSummonChargeItem3@@YAPAVioSummonChargeItem3@@PAVioItem@@@Z PROC ; ToSummonChargeItem3, COMDAT

; 129  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 130  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 131  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_SUMMON_CHARGE3 )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2c		 je	 SHORT $LN1@ToSummonCh
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	3d 94 00 00 00	 cmp	 eax, 148		; 00000094H
  0001f	75 1b		 jne	 SHORT $LN1@ToSummonCh

; 133  : 
; 134  : 	return dynamic_cast< ioSummonChargeItem3* >( pItem );

  00021	6a 00		 push	 0
  00023	68 00 00 00 00	 push	 OFFSET ??_R0?AVioSummonChargeItem3@@@8
  00028	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002d	6a 00		 push	 0
  0002f	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00032	e8 00 00 00 00	 call	 ___RTDynamicCast
  00037	83 c4 14	 add	 esp, 20			; 00000014H

; 135  : }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
$LN1@ToSummonCh:

; 132  : 		return NULL;

  0003c	33 c0		 xor	 eax, eax

; 135  : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?ToSummonChargeItem3@@YAPAVioSummonChargeItem3@@PAVioItem@@@Z ENDP ; ToSummonChargeItem3
_TEXT	ENDS
PUBLIC	??_R0?AVioWereWolfItem@@@8			; ioWereWolfItem `RTTI Type Descriptor'
PUBLIC	?ToWereWolfItem@@YAPAVioWereWolfItem@@PAVioItem@@@Z ; ToWereWolfItem
;	COMDAT ??_R0?AVioWereWolfItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iowerewolfitem.h
_DATA	SEGMENT
??_R0?AVioWereWolfItem@@@8 DD FLAT:??_7type_info@@6B@	; ioWereWolfItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioWereWolfItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToWereWolfItem@@YAPAVioWereWolfItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToWereWolfItem@@YAPAVioWereWolfItem@@PAVioItem@@@Z PROC ; ToWereWolfItem, COMDAT

; 148  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 149  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 150  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_WEREWOLF )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToWereWolf
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 26	 cmp	 eax, 38			; 00000026H
  0001d	75 1b		 jne	 SHORT $LN1@ToWereWolf

; 152  : 
; 153  : 	return dynamic_cast< ioWereWolfItem* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWereWolfItem@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 154  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToWereWolf:

; 151  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 154  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToWereWolfItem@@YAPAVioWereWolfItem@@PAVioItem@@@Z ENDP ; ToWereWolfItem
_TEXT	ENDS
PUBLIC	??_R0?AVioRachelItem@@@8			; ioRachelItem `RTTI Type Descriptor'
PUBLIC	?ToRachelItem@@YAPAVioRachelItem@@PAVioItem@@@Z	; ToRachelItem
;	COMDAT ??_R0?AVioRachelItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iorachelitem.h
_DATA	SEGMENT
??_R0?AVioRachelItem@@@8 DD FLAT:??_7type_info@@6B@	; ioRachelItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioRachelItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToRachelItem@@YAPAVioRachelItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToRachelItem@@YAPAVioRachelItem@@PAVioItem@@@Z PROC	; ToRachelItem, COMDAT

; 174  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 175  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 176  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_RACHEL )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToRachelIt
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  0001d	75 1b		 jne	 SHORT $LN1@ToRachelIt

; 178  : 
; 179  : 	return dynamic_cast< ioRachelItem* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioRachelItem@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 180  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToRachelIt:

; 177  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 180  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToRachelItem@@YAPAVioRachelItem@@PAVioItem@@@Z ENDP	; ToRachelItem
_TEXT	ENDS
PUBLIC	??_R0?AVioIljimaeItem@@@8			; ioIljimaeItem `RTTI Type Descriptor'
PUBLIC	?ToIljimaeItem@@YAPAVioIljimaeItem@@PAVioItem@@@Z ; ToIljimaeItem
;	COMDAT ??_R0?AVioIljimaeItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioiljimaeitem.h
_DATA	SEGMENT
??_R0?AVioIljimaeItem@@@8 DD FLAT:??_7type_info@@6B@	; ioIljimaeItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioIljimaeItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToIljimaeItem@@YAPAVioIljimaeItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToIljimaeItem@@YAPAVioIljimaeItem@@PAVioItem@@@Z PROC	; ToIljimaeItem, COMDAT

; 196  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 198  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_ILJIMAE )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToIljimaeI
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  0001d	75 1b		 jne	 SHORT $LN1@ToIljimaeI

; 200  : 
; 201  : 	return dynamic_cast< ioIljimaeItem* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioIljimaeItem@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 202  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToIljimaeI:

; 199  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 202  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToIljimaeItem@@YAPAVioIljimaeItem@@PAVioItem@@@Z ENDP	; ToIljimaeItem
_TEXT	ENDS
PUBLIC	??_R0?AVioWitchItem@@@8				; ioWitchItem `RTTI Type Descriptor'
PUBLIC	?ToWitchItem@@YAPAVioWitchItem@@PAVioItem@@@Z	; ToWitchItem
;	COMDAT ??_R0?AVioWitchItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iowitchitem.h
_DATA	SEGMENT
??_R0?AVioWitchItem@@@8 DD FLAT:??_7type_info@@6B@	; ioWitchItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioWitchItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToWitchItem@@YAPAVioWitchItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToWitchItem@@YAPAVioWitchItem@@PAVioItem@@@Z PROC	; ToWitchItem, COMDAT

; 171  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 172  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 173  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_WITCH )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToWitchIte
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  0001d	75 1b		 jne	 SHORT $LN1@ToWitchIte

; 175  : 
; 176  : 	return dynamic_cast< ioWitchItem* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWitchItem@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 177  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToWitchIte:

; 174  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 177  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToWitchItem@@YAPAVioWitchItem@@PAVioItem@@@Z ENDP	; ToWitchItem
_TEXT	ENDS
PUBLIC	??_R0?AVioMechanicsItem@@@8			; ioMechanicsItem `RTTI Type Descriptor'
PUBLIC	?ToMechanicsItem@@YAPAVioMechanicsItem@@PAVioItem@@@Z ; ToMechanicsItem
;	COMDAT ??_R0?AVioMechanicsItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iomechanicsitem.h
_DATA	SEGMENT
??_R0?AVioMechanicsItem@@@8 DD FLAT:??_7type_info@@6B@	; ioMechanicsItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioMechanicsItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToMechanicsItem@@YAPAVioMechanicsItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToMechanicsItem@@YAPAVioMechanicsItem@@PAVioItem@@@Z PROC ; ToMechanicsItem, COMDAT

; 203  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 204  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 205  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_MECHANICS )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToMechanic
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 30	 cmp	 eax, 48			; 00000030H
  0001d	75 1b		 jne	 SHORT $LN1@ToMechanic

; 207  : 
; 208  : 	return dynamic_cast< ioMechanicsItem* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioMechanicsItem@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 209  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToMechanic:

; 206  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 209  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToMechanicsItem@@YAPAVioMechanicsItem@@PAVioItem@@@Z ENDP ; ToMechanicsItem
_TEXT	ENDS
PUBLIC	??_R0?AVioMichaelItem@@@8			; ioMichaelItem `RTTI Type Descriptor'
PUBLIC	?ToMichaelItem@@YAPAVioMichaelItem@@PAVioItem@@@Z ; ToMichaelItem
;	COMDAT ??_R0?AVioMichaelItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iomichaelitem.h
_DATA	SEGMENT
??_R0?AVioMichaelItem@@@8 DD FLAT:??_7type_info@@6B@	; ioMichaelItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioMichaelItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToMichaelItem@@YAPAVioMichaelItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToMichaelItem@@YAPAVioMichaelItem@@PAVioItem@@@Z PROC	; ToMichaelItem, COMDAT

; 222  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 223  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 224  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_MICHAEL )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToMichaelI
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 3c	 cmp	 eax, 60			; 0000003cH
  0001d	75 1b		 jne	 SHORT $LN1@ToMichaelI

; 226  : 
; 227  : 	return dynamic_cast< ioMichaelItem* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioMichaelItem@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 228  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToMichaelI:

; 225  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 228  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToMichaelItem@@YAPAVioMichaelItem@@PAVioItem@@@Z ENDP	; ToMichaelItem
_TEXT	ENDS
PUBLIC	??_R0?AVioDraculaItem@@@8			; ioDraculaItem `RTTI Type Descriptor'
PUBLIC	?ToDraculaItem@@YAPAVioDraculaItem@@PAVioItem@@@Z ; ToDraculaItem
;	COMDAT ??_R0?AVioDraculaItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iodraculaitem.h
_DATA	SEGMENT
??_R0?AVioDraculaItem@@@8 DD FLAT:??_7type_info@@6B@	; ioDraculaItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioDraculaItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToDraculaItem@@YAPAVioDraculaItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToDraculaItem@@YAPAVioDraculaItem@@PAVioItem@@@Z PROC	; ToDraculaItem, COMDAT

; 181  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 183  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_DRACULA )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToDraculaI
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 49	 cmp	 eax, 73			; 00000049H
  0001d	75 1b		 jne	 SHORT $LN1@ToDraculaI

; 185  : 
; 186  : 	return dynamic_cast< ioDraculaItem* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioDraculaItem@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 187  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToDraculaI:

; 184  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 187  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToDraculaItem@@YAPAVioDraculaItem@@PAVioItem@@@Z ENDP	; ToDraculaItem
_TEXT	ENDS
PUBLIC	??_R0?AVioHakumenItem@@@8			; ioHakumenItem `RTTI Type Descriptor'
PUBLIC	?ToHakumenItem@@YAPAVioHakumenItem@@PAVioItem@@@Z ; ToHakumenItem
;	COMDAT ??_R0?AVioHakumenItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iohakumenitem.h
_DATA	SEGMENT
??_R0?AVioHakumenItem@@@8 DD FLAT:??_7type_info@@6B@	; ioHakumenItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioHakumenItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToHakumenItem@@YAPAVioHakumenItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToHakumenItem@@YAPAVioHakumenItem@@PAVioItem@@@Z PROC	; ToHakumenItem, COMDAT

; 138  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 139  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 140  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_HAKUMEN )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToHakumenI
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 4c	 cmp	 eax, 76			; 0000004cH
  0001d	75 1b		 jne	 SHORT $LN1@ToHakumenI

; 142  : 
; 143  : 	return dynamic_cast< ioHakumenItem* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioHakumenItem@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 144  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToHakumenI:

; 141  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 144  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToHakumenItem@@YAPAVioHakumenItem@@PAVioItem@@@Z ENDP	; ToHakumenItem
_TEXT	ENDS
PUBLIC	??_R0?AVioFlash_Item@@@8			; ioFlash_Item `RTTI Type Descriptor'
PUBLIC	?ToFlashItem@@YAPAVioFlash_Item@@PAVioItem@@@Z	; ToFlashItem
;	COMDAT ??_R0?AVioFlash_Item@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioflash_item.h
_DATA	SEGMENT
??_R0?AVioFlash_Item@@@8 DD FLAT:??_7type_info@@6B@	; ioFlash_Item `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioFlash_Item@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToFlashItem@@YAPAVioFlash_Item@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToFlashItem@@YAPAVioFlash_Item@@PAVioItem@@@Z PROC	; ToFlashItem, COMDAT

; 281  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 282  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 283  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_FLASHITEM )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToFlashIte
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 4f	 cmp	 eax, 79			; 0000004fH
  0001d	75 1b		 jne	 SHORT $LN1@ToFlashIte

; 285  : 
; 286  : 	return dynamic_cast< ioFlash_Item* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioFlash_Item@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 287  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToFlashIte:

; 284  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 287  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToFlashItem@@YAPAVioFlash_Item@@PAVioItem@@@Z ENDP	; ToFlashItem
_TEXT	ENDS
PUBLIC	??_R0?AVioSlasher_Item@@@8			; ioSlasher_Item `RTTI Type Descriptor'
PUBLIC	?ToSlasherItem@@YAPAVioSlasher_Item@@PAVioItem@@@Z ; ToSlasherItem
;	COMDAT ??_R0?AVioSlasher_Item@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioslasher_item.h
_DATA	SEGMENT
??_R0?AVioSlasher_Item@@@8 DD FLAT:??_7type_info@@6B@	; ioSlasher_Item `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioSlasher_Item@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToSlasherItem@@YAPAVioSlasher_Item@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToSlasherItem@@YAPAVioSlasher_Item@@PAVioItem@@@Z PROC	; ToSlasherItem, COMDAT

; 233  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 234  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00004	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00007	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000c	8b f0		 mov	 esi, eax
  0000e	59		 pop	 ecx

; 235  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_SLASHER_ITEM )

  0000f	85 f6		 test	 esi, esi
  00011	74 28		 je	 SHORT $LN1@ToSlasherI
  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	8b ce		 mov	 ecx, esi
  00017	ff 90 f0 02 00
	00		 call	 DWORD PTR [eax+752]
  0001d	83 f8 53	 cmp	 eax, 83			; 00000053H
  00020	75 19		 jne	 SHORT $LN1@ToSlasherI

; 237  : 
; 238  : 	return dynamic_cast< ioSlasher_Item* >( pWeapon );

  00022	6a 00		 push	 0
  00024	68 00 00 00 00	 push	 OFFSET ??_R0?AVioSlasher_Item@@@8
  00029	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWeaponItem@@@8
  0002e	6a 00		 push	 0
  00030	56		 push	 esi
  00031	e8 00 00 00 00	 call	 ___RTDynamicCast
  00036	83 c4 14	 add	 esp, 20			; 00000014H
  00039	eb 02		 jmp	 SHORT $LN3@ToSlasherI
$LN1@ToSlasherI:

; 236  : 		return NULL;

  0003b	33 c0		 xor	 eax, eax
$LN3@ToSlasherI:
  0003d	5e		 pop	 esi

; 239  : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?ToSlasherItem@@YAPAVioSlasher_Item@@PAVioItem@@@Z ENDP	; ToSlasherItem
_TEXT	ENDS
PUBLIC	??_R0?AVioPhantomItem@@@8			; ioPhantomItem `RTTI Type Descriptor'
PUBLIC	?ToPhantomItem@@YAPAVioPhantomItem@@PAVioItem@@@Z ; ToPhantomItem
;	COMDAT ??_R0?AVioPhantomItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iophantomitem.h
_DATA	SEGMENT
??_R0?AVioPhantomItem@@@8 DD FLAT:??_7type_info@@6B@	; ioPhantomItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioPhantomItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToPhantomItem@@YAPAVioPhantomItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToPhantomItem@@YAPAVioPhantomItem@@PAVioItem@@@Z PROC	; ToPhantomItem, COMDAT

; 233  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 234  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 235  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_PHANTOM )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToPhantomI
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 35	 cmp	 eax, 53			; 00000035H
  0001d	75 1b		 jne	 SHORT $LN1@ToPhantomI

; 237  : 
; 238  : 	return dynamic_cast< ioPhantomItem* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioPhantomItem@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 239  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToPhantomI:

; 236  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 239  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToPhantomItem@@YAPAVioPhantomItem@@PAVioItem@@@Z ENDP	; ToPhantomItem
_TEXT	ENDS
PUBLIC	??_R0?AVioLuciferItem@@@8			; ioLuciferItem `RTTI Type Descriptor'
PUBLIC	?ToLuciferItem@@YAPAVioLuciferItem@@PAVioItem@@@Z ; ToLuciferItem
;	COMDAT ??_R0?AVioLuciferItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioluciferitem.h
_DATA	SEGMENT
??_R0?AVioLuciferItem@@@8 DD FLAT:??_7type_info@@6B@	; ioLuciferItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioLuciferItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToLuciferItem@@YAPAVioLuciferItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToLuciferItem@@YAPAVioLuciferItem@@PAVioItem@@@Z PROC	; ToLuciferItem, COMDAT

; 292  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 293  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 294  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_LUCIFER )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToLuciferI
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 38	 cmp	 eax, 56			; 00000038H
  0001d	75 1b		 jne	 SHORT $LN1@ToLuciferI

; 296  : 
; 297  : 	return dynamic_cast< ioLuciferItem* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioLuciferItem@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 298  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToLuciferI:

; 295  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 298  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToLuciferItem@@YAPAVioLuciferItem@@PAVioItem@@@Z ENDP	; ToLuciferItem
_TEXT	ENDS
PUBLIC	??_R0?AVioNakoruruItem@@@8			; ioNakoruruItem `RTTI Type Descriptor'
PUBLIC	?ToNakoruruItem@@YAPAVioNakoruruItem@@PAVioItem@@@Z ; ToNakoruruItem
;	COMDAT ??_R0?AVioNakoruruItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ionakoruruitem.h
_DATA	SEGMENT
??_R0?AVioNakoruruItem@@@8 DD FLAT:??_7type_info@@6B@	; ioNakoruruItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioNakoruruItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToNakoruruItem@@YAPAVioNakoruruItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToNakoruruItem@@YAPAVioNakoruruItem@@PAVioItem@@@Z PROC ; ToNakoruruItem, COMDAT

; 184  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 185  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 186  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_NAKORURU )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToNakoruru
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  0001d	75 1b		 jne	 SHORT $LN1@ToNakoruru

; 188  : 
; 189  : 	return dynamic_cast< ioNakoruruItem* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioNakoruruItem@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 190  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToNakoruru:

; 187  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 190  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToNakoruruItem@@YAPAVioNakoruruItem@@PAVioItem@@@Z ENDP ; ToNakoruruItem
_TEXT	ENDS
PUBLIC	??_R0?AVioDestroyerItem@@@8			; ioDestroyerItem `RTTI Type Descriptor'
PUBLIC	?ToDestroyerItem@@YAPAVioDestroyerItem@@PAVioItem@@@Z ; ToDestroyerItem
;	COMDAT ??_R0?AVioDestroyerItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iodestroyeritem.h
_DATA	SEGMENT
??_R0?AVioDestroyerItem@@@8 DD FLAT:??_7type_info@@6B@	; ioDestroyerItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioDestroyerItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToDestroyerItem@@YAPAVioDestroyerItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToDestroyerItem@@YAPAVioDestroyerItem@@PAVioItem@@@Z PROC ; ToDestroyerItem, COMDAT

; 267  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 268  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 269  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_DESTROYER )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToDestroye
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 3b	 cmp	 eax, 59			; 0000003bH
  0001d	75 1b		 jne	 SHORT $LN1@ToDestroye

; 271  : 
; 272  : 	return dynamic_cast< ioDestroyerItem* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioDestroyerItem@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 273  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToDestroye:

; 270  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 273  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToDestroyerItem@@YAPAVioDestroyerItem@@PAVioItem@@@Z ENDP ; ToDestroyerItem
_TEXT	ENDS
PUBLIC	??_R0?AVioGoomihoItem@@@8			; ioGoomihoItem `RTTI Type Descriptor'
PUBLIC	?ToGoomihoItem@@YAPAVioGoomihoItem@@PAVioItem@@@Z ; ToGoomihoItem
;	COMDAT ??_R0?AVioGoomihoItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iogoomihoitem.h
_DATA	SEGMENT
??_R0?AVioGoomihoItem@@@8 DD FLAT:??_7type_info@@6B@	; ioGoomihoItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioGoomihoItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToGoomihoItem@@YAPAVioGoomihoItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToGoomihoItem@@YAPAVioGoomihoItem@@PAVioItem@@@Z PROC	; ToGoomihoItem, COMDAT

; 241  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 242  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 243  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_GOOMIHO )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToGoomihoI
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 3e	 cmp	 eax, 62			; 0000003eH
  0001d	75 1b		 jne	 SHORT $LN1@ToGoomihoI

; 245  : 
; 246  : 	return dynamic_cast< ioGoomihoItem* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioGoomihoItem@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 247  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToGoomihoI:

; 244  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 247  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToGoomihoItem@@YAPAVioGoomihoItem@@PAVioItem@@@Z ENDP	; ToGoomihoItem
_TEXT	ENDS
PUBLIC	??_R0?AVioPeterpanItem@@@8			; ioPeterpanItem `RTTI Type Descriptor'
PUBLIC	?ToPeterpanItem@@YAPAVioPeterpanItem@@PAVioItem@@@Z ; ToPeterpanItem
;	COMDAT ??_R0?AVioPeterpanItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iopeterpanitem.h
_DATA	SEGMENT
??_R0?AVioPeterpanItem@@@8 DD FLAT:??_7type_info@@6B@	; ioPeterpanItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioPeterpanItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToPeterpanItem@@YAPAVioPeterpanItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToPeterpanItem@@YAPAVioPeterpanItem@@PAVioItem@@@Z PROC ; ToPeterpanItem, COMDAT

; 225  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 226  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 227  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_PETERPAN )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToPeterpan
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  0001d	75 1b		 jne	 SHORT $LN1@ToPeterpan

; 229  : 
; 230  : 	return dynamic_cast< ioPeterpanItem* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioPeterpanItem@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 231  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToPeterpan:

; 228  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 231  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToPeterpanItem@@YAPAVioPeterpanItem@@PAVioItem@@@Z ENDP ; ToPeterpanItem
_TEXT	ENDS
PUBLIC	??_R0?AVioSuccubusItem@@@8			; ioSuccubusItem `RTTI Type Descriptor'
PUBLIC	?ToSuccubusItem@@YAPAVioSuccubusItem@@PAVioItem@@@Z ; ToSuccubusItem
;	COMDAT ??_R0?AVioSuccubusItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iosuccubusitem.h
_DATA	SEGMENT
??_R0?AVioSuccubusItem@@@8 DD FLAT:??_7type_info@@6B@	; ioSuccubusItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioSuccubusItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToSuccubusItem@@YAPAVioSuccubusItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToSuccubusItem@@YAPAVioSuccubusItem@@PAVioItem@@@Z PROC ; ToSuccubusItem, COMDAT

; 228  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 229  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 230  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_SUCCUBUS )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToSuccubus
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 40	 cmp	 eax, 64			; 00000040H
  0001d	75 1b		 jne	 SHORT $LN1@ToSuccubus

; 232  : 
; 233  : 	return dynamic_cast< ioSuccubusItem* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioSuccubusItem@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 234  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToSuccubus:

; 231  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 234  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToSuccubusItem@@YAPAVioSuccubusItem@@PAVioItem@@@Z ENDP ; ToSuccubusItem
_TEXT	ENDS
PUBLIC	??_R0?AVioCyvogueItem@@@8			; ioCyvogueItem `RTTI Type Descriptor'
PUBLIC	?ToCyvogueItem@@YAPAVioCyvogueItem@@PAVioItem@@@Z ; ToCyvogueItem
;	COMDAT ??_R0?AVioCyvogueItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iocyvogueitem.h
_DATA	SEGMENT
??_R0?AVioCyvogueItem@@@8 DD FLAT:??_7type_info@@6B@	; ioCyvogueItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioCyvogueItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToCyvogueItem@@YAPAVioCyvogueItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToCyvogueItem@@YAPAVioCyvogueItem@@PAVioItem@@@Z PROC	; ToCyvogueItem, COMDAT

; 339  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 340  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 341  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_CYVOGUE )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToCyvogueI
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 41	 cmp	 eax, 65			; 00000041H
  0001d	75 1b		 jne	 SHORT $LN1@ToCyvogueI

; 343  : 
; 344  : 	return dynamic_cast< ioCyvogueItem* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioCyvogueItem@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 345  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToCyvogueI:

; 342  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 345  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToCyvogueItem@@YAPAVioCyvogueItem@@PAVioItem@@@Z ENDP	; ToCyvogueItem
_TEXT	ENDS
PUBLIC	??_R0?AVioTrinityItem@@@8			; ioTrinityItem `RTTI Type Descriptor'
PUBLIC	?ToTrinityItem@@YAPAVioTrinityItem@@PAVioItem@@@Z ; ToTrinityItem
;	COMDAT ??_R0?AVioTrinityItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iotrinityitem.h
_DATA	SEGMENT
??_R0?AVioTrinityItem@@@8 DD FLAT:??_7type_info@@6B@	; ioTrinityItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioTrinityItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToTrinityItem@@YAPAVioTrinityItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToTrinityItem@@YAPAVioTrinityItem@@PAVioItem@@@Z PROC	; ToTrinityItem, COMDAT

; 176  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 177  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 178  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_TRINITY )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToTrinityI
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 42	 cmp	 eax, 66			; 00000042H
  0001d	75 1b		 jne	 SHORT $LN1@ToTrinityI

; 180  : 
; 181  : 	return dynamic_cast< ioTrinityItem* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioTrinityItem@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 182  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToTrinityI:

; 179  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 182  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToTrinityItem@@YAPAVioTrinityItem@@PAVioItem@@@Z ENDP	; ToTrinityItem
_TEXT	ENDS
PUBLIC	??_R0?AVioDevilItem@@@8				; ioDevilItem `RTTI Type Descriptor'
PUBLIC	?ToDevilItem@@YAPAVioDevilItem@@PAVioItem@@@Z	; ToDevilItem
;	COMDAT ??_R0?AVioDevilItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iodevilitem.h
_DATA	SEGMENT
??_R0?AVioDevilItem@@@8 DD FLAT:??_7type_info@@6B@	; ioDevilItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioDevilItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToDevilItem@@YAPAVioDevilItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToDevilItem@@YAPAVioDevilItem@@PAVioItem@@@Z PROC	; ToDevilItem, COMDAT

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 201  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 202  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_DEVIL)

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToDevilIte
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  0001d	75 1b		 jne	 SHORT $LN1@ToDevilIte

; 204  : 
; 205  : 	return dynamic_cast< ioDevilItem* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioDevilItem@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 206  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToDevilIte:

; 203  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 206  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToDevilItem@@YAPAVioDevilItem@@PAVioItem@@@Z ENDP	; ToDevilItem
_TEXT	ENDS
PUBLIC	??_R0?AVioEvyItem@@@8				; ioEvyItem `RTTI Type Descriptor'
PUBLIC	?ToEvyItem@@YAPAVioEvyItem@@PAVioItem@@@Z	; ToEvyItem
;	COMDAT ??_R0?AVioEvyItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioevyitem.h
_DATA	SEGMENT
??_R0?AVioEvyItem@@@8 DD FLAT:??_7type_info@@6B@	; ioEvyItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioEvyItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToEvyItem@@YAPAVioEvyItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToEvyItem@@YAPAVioEvyItem@@PAVioItem@@@Z PROC		; ToEvyItem, COMDAT

; 219  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 220  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 221  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_EVY_ITEM )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToEvyItem
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 50	 cmp	 eax, 80			; 00000050H
  0001d	75 1b		 jne	 SHORT $LN1@ToEvyItem

; 223  : 
; 224  : 	return dynamic_cast< ioEvyItem* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioEvyItem@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 225  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToEvyItem:

; 222  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 225  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToEvyItem@@YAPAVioEvyItem@@PAVioItem@@@Z ENDP		; ToEvyItem
_TEXT	ENDS
PUBLIC	??_R0?AVioSuddenAttackItem@@@8			; ioSuddenAttackItem `RTTI Type Descriptor'
PUBLIC	?ToSuddenAttackItem@@YAPAVioSuddenAttackItem@@PAVioItem@@@Z ; ToSuddenAttackItem
;	COMDAT ??_R0?AVioSuddenAttackItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iosuddenattackitem.h
_DATA	SEGMENT
??_R0?AVioSuddenAttackItem@@@8 DD FLAT:??_7type_info@@6B@ ; ioSuddenAttackItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioSuddenAttackItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToSuddenAttackItem@@YAPAVioSuddenAttackItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToSuddenAttackItem@@YAPAVioSuddenAttackItem@@PAVioItem@@@Z PROC ; ToSuddenAttackItem, COMDAT

; 512  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 513  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 514  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_SUDDEN_ATTACK_ITEM )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToSuddenAt
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 52	 cmp	 eax, 82			; 00000052H
  0001d	75 1b		 jne	 SHORT $LN1@ToSuddenAt

; 516  : 
; 517  : 	return dynamic_cast< ioSuddenAttackItem* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioSuddenAttackItem@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 518  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToSuddenAt:

; 515  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 518  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToSuddenAttackItem@@YAPAVioSuddenAttackItem@@PAVioItem@@@Z ENDP ; ToSuddenAttackItem
_TEXT	ENDS
PUBLIC	??_R0?AVioDummyCharItem2@@@8			; ioDummyCharItem2 `RTTI Type Descriptor'
PUBLIC	?ToDummyCharItem2@@YAPAVioDummyCharItem2@@PAVioItem@@@Z ; ToDummyCharItem2
;	COMDAT ??_R0?AVioDummyCharItem2@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iodummycharitem2.h
_DATA	SEGMENT
??_R0?AVioDummyCharItem2@@@8 DD FLAT:??_7type_info@@6B@	; ioDummyCharItem2 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioDummyCharItem2@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToDummyCharItem2@@YAPAVioDummyCharItem2@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToDummyCharItem2@@YAPAVioDummyCharItem2@@PAVioItem@@@Z PROC ; ToDummyCharItem2, COMDAT

; 164  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 165  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 166  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_DUMMY_CHAR2 )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToDummyCha
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 54	 cmp	 eax, 84			; 00000054H
  0001d	75 1b		 jne	 SHORT $LN1@ToDummyCha

; 168  : 
; 169  : 	return dynamic_cast< ioDummyCharItem2* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioDummyCharItem2@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 170  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToDummyCha:

; 167  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 170  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToDummyCharItem2@@YAPAVioDummyCharItem2@@PAVioItem@@@Z ENDP ; ToDummyCharItem2
_TEXT	ENDS
PUBLIC	??_R0?AVioSuperDimensionItem@@@8		; ioSuperDimensionItem `RTTI Type Descriptor'
PUBLIC	?ToSuperDimensionItem@@YAPAVioSuperDimensionItem@@PAVioItem@@@Z ; ToSuperDimensionItem
;	COMDAT ??_R0?AVioSuperDimensionItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iosuperdimensionitem.h
_DATA	SEGMENT
??_R0?AVioSuperDimensionItem@@@8 DD FLAT:??_7type_info@@6B@ ; ioSuperDimensionItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioSuperDimensionItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToSuperDimensionItem@@YAPAVioSuperDimensionItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToSuperDimensionItem@@YAPAVioSuperDimensionItem@@PAVioItem@@@Z PROC ; ToSuperDimensionItem, COMDAT

; 331  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 332  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00004	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00007	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000c	8b f0		 mov	 esi, eax
  0000e	59		 pop	 ecx

; 333  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_SUPER_DIMENSION_ITEM )

  0000f	85 f6		 test	 esi, esi
  00011	74 28		 je	 SHORT $LN1@ToSuperDim
  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	8b ce		 mov	 ecx, esi
  00017	ff 90 f0 02 00
	00		 call	 DWORD PTR [eax+752]
  0001d	83 f8 57	 cmp	 eax, 87			; 00000057H
  00020	75 19		 jne	 SHORT $LN1@ToSuperDim

; 335  : 
; 336  : 	return dynamic_cast< ioSuperDimensionItem* >( pWeapon );

  00022	6a 00		 push	 0
  00024	68 00 00 00 00	 push	 OFFSET ??_R0?AVioSuperDimensionItem@@@8
  00029	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWeaponItem@@@8
  0002e	6a 00		 push	 0
  00030	56		 push	 esi
  00031	e8 00 00 00 00	 call	 ___RTDynamicCast
  00036	83 c4 14	 add	 esp, 20			; 00000014H
  00039	eb 02		 jmp	 SHORT $LN3@ToSuperDim
$LN1@ToSuperDim:

; 334  : 		return NULL;

  0003b	33 c0		 xor	 eax, eax
$LN3@ToSuperDim:
  0003d	5e		 pop	 esi

; 337  : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?ToSuperDimensionItem@@YAPAVioSuperDimensionItem@@PAVioItem@@@Z ENDP ; ToSuperDimensionItem
_TEXT	ENDS
PUBLIC	??_R0?AVioGalaxyItem@@@8			; ioGalaxyItem `RTTI Type Descriptor'
PUBLIC	?ToGalaxyItem@@YAPAVioGalaxyItem@@PAVioItem@@@Z	; ToGalaxyItem
;	COMDAT ??_R0?AVioGalaxyItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iogalaxyitem.h
_DATA	SEGMENT
??_R0?AVioGalaxyItem@@@8 DD FLAT:??_7type_info@@6B@	; ioGalaxyItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioGalaxyItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToGalaxyItem@@YAPAVioGalaxyItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToGalaxyItem@@YAPAVioGalaxyItem@@PAVioItem@@@Z PROC	; ToGalaxyItem, COMDAT

; 136  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 137  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 138  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_GALAXY_ITEM )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToGalaxyIt
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  0001d	75 1b		 jne	 SHORT $LN1@ToGalaxyIt

; 140  : 
; 141  : 	return dynamic_cast< ioGalaxyItem* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioGalaxyItem@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 142  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToGalaxyIt:

; 139  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 142  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToGalaxyItem@@YAPAVioGalaxyItem@@PAVioItem@@@Z ENDP	; ToGalaxyItem
_TEXT	ENDS
PUBLIC	??_R0?AVioThunderBirdItem@@@8			; ioThunderBirdItem `RTTI Type Descriptor'
PUBLIC	?ToThunderBirdItem@@YAPAVioThunderBirdItem@@PAVioItem@@@Z ; ToThunderBirdItem
;	COMDAT ??_R0?AVioThunderBirdItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iothunderbirditem.h
_DATA	SEGMENT
??_R0?AVioThunderBirdItem@@@8 DD FLAT:??_7type_info@@6B@ ; ioThunderBirdItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioThunderBirdItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToThunderBirdItem@@YAPAVioThunderBirdItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToThunderBirdItem@@YAPAVioThunderBirdItem@@PAVioItem@@@Z PROC ; ToThunderBirdItem, COMDAT

; 138  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 139  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 140  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_THUNDER_BIRD_ITEM )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToThunderB
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 60	 cmp	 eax, 96			; 00000060H
  0001d	75 1b		 jne	 SHORT $LN1@ToThunderB

; 142  : 
; 143  : 	return dynamic_cast< ioThunderBirdItem* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioThunderBirdItem@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 144  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToThunderB:

; 141  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 144  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToThunderBirdItem@@YAPAVioThunderBirdItem@@PAVioItem@@@Z ENDP ; ToThunderBirdItem
_TEXT	ENDS
PUBLIC	??_R0?AVioAliceItem@@@8				; ioAliceItem `RTTI Type Descriptor'
PUBLIC	?ToAliceItem@@YAPAVioAliceItem@@PAVioItem@@@Z	; ToAliceItem
;	COMDAT ??_R0?AVioAliceItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioaliceitem.h
_DATA	SEGMENT
??_R0?AVioAliceItem@@@8 DD FLAT:??_7type_info@@6B@	; ioAliceItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioAliceItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToAliceItem@@YAPAVioAliceItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToAliceItem@@YAPAVioAliceItem@@PAVioItem@@@Z PROC	; ToAliceItem, COMDAT

; 116  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 117  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 118  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_ALICE_ITEM )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToAliceIte
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 61	 cmp	 eax, 97			; 00000061H
  0001d	75 1b		 jne	 SHORT $LN1@ToAliceIte

; 120  : 
; 121  : 	return dynamic_cast< ioAliceItem* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioAliceItem@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 122  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToAliceIte:

; 119  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 122  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToAliceItem@@YAPAVioAliceItem@@PAVioItem@@@Z ENDP	; ToAliceItem
_TEXT	ENDS
PUBLIC	??_R0?AVioValkyrie@@@8				; ioValkyrie `RTTI Type Descriptor'
PUBLIC	?ToValkyrie@@YAPAVioValkyrie@@PAVioItem@@@Z	; ToValkyrie
;	COMDAT ??_R0?AVioValkyrie@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iovalkyrie.h
_DATA	SEGMENT
??_R0?AVioValkyrie@@@8 DD FLAT:??_7type_info@@6B@	; ioValkyrie `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioValkyrie@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToValkyrie@@YAPAVioValkyrie@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToValkyrie@@YAPAVioValkyrie@@PAVioItem@@@Z PROC	; ToValkyrie, COMDAT

; 164  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 165  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 166  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_VALKYRIE )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToValkyrie
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 63	 cmp	 eax, 99			; 00000063H
  0001d	75 1b		 jne	 SHORT $LN1@ToValkyrie

; 168  : 
; 169  : 	return dynamic_cast< ioValkyrie* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioValkyrie@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 170  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToValkyrie:

; 167  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 170  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToValkyrie@@YAPAVioValkyrie@@PAVioItem@@@Z ENDP	; ToValkyrie
_TEXT	ENDS
PUBLIC	??_R0?AVioParkilpyoItem@@@8			; ioParkilpyoItem `RTTI Type Descriptor'
PUBLIC	?ToParkilpyoItem@@YAPAVioParkilpyoItem@@PAVioItem@@@Z ; ToParkilpyoItem
;	COMDAT ??_R0?AVioParkilpyoItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioparkilpyoitem.h
_DATA	SEGMENT
??_R0?AVioParkilpyoItem@@@8 DD FLAT:??_7type_info@@6B@	; ioParkilpyoItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioParkilpyoItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToParkilpyoItem@@YAPAVioParkilpyoItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToParkilpyoItem@@YAPAVioParkilpyoItem@@PAVioItem@@@Z PROC ; ToParkilpyoItem, COMDAT

; 169  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 171  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_PARKILPYO_ITEM )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToParkilpy
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 64	 cmp	 eax, 100		; 00000064H
  0001d	75 1b		 jne	 SHORT $LN1@ToParkilpy

; 173  : 
; 174  : 	return dynamic_cast< ioParkilpyoItem* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioParkilpyoItem@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 175  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToParkilpy:

; 172  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 175  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToParkilpyoItem@@YAPAVioParkilpyoItem@@PAVioItem@@@Z ENDP ; ToParkilpyoItem
_TEXT	ENDS
PUBLIC	??_R0?AVioShadowRangerItem@@@8			; ioShadowRangerItem `RTTI Type Descriptor'
PUBLIC	?ToShadowRangerItem@@YAPAVioShadowRangerItem@@PAVioItem@@@Z ; ToShadowRangerItem
;	COMDAT ??_R0?AVioShadowRangerItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioshadowrangeritem.h
_DATA	SEGMENT
??_R0?AVioShadowRangerItem@@@8 DD FLAT:??_7type_info@@6B@ ; ioShadowRangerItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioShadowRangerItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToShadowRangerItem@@YAPAVioShadowRangerItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToShadowRangerItem@@YAPAVioShadowRangerItem@@PAVioItem@@@Z PROC ; ToShadowRangerItem, COMDAT

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 255  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00004	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00007	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000c	8b f0		 mov	 esi, eax
  0000e	59		 pop	 ecx

; 256  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_SHADOWRANGER_ITEM )

  0000f	85 f6		 test	 esi, esi
  00011	74 28		 je	 SHORT $LN1@ToShadowRa
  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	8b ce		 mov	 ecx, esi
  00017	ff 90 f0 02 00
	00		 call	 DWORD PTR [eax+752]
  0001d	83 f8 69	 cmp	 eax, 105		; 00000069H
  00020	75 19		 jne	 SHORT $LN1@ToShadowRa

; 258  : 
; 259  : 	return dynamic_cast< ioShadowRangerItem* >( pWeapon );

  00022	6a 00		 push	 0
  00024	68 00 00 00 00	 push	 OFFSET ??_R0?AVioShadowRangerItem@@@8
  00029	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWeaponItem@@@8
  0002e	6a 00		 push	 0
  00030	56		 push	 esi
  00031	e8 00 00 00 00	 call	 ___RTDynamicCast
  00036	83 c4 14	 add	 esp, 20			; 00000014H
  00039	eb 02		 jmp	 SHORT $LN3@ToShadowRa
$LN1@ToShadowRa:

; 257  : 		return NULL;

  0003b	33 c0		 xor	 eax, eax
$LN3@ToShadowRa:
  0003d	5e		 pop	 esi

; 260  : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?ToShadowRangerItem@@YAPAVioShadowRangerItem@@PAVioItem@@@Z ENDP ; ToShadowRangerItem
_TEXT	ENDS
PUBLIC	??_R0?AVioNinjaExpansionItem@@@8		; ioNinjaExpansionItem `RTTI Type Descriptor'
PUBLIC	?ToNinjaExpansionItem@@YAPAVioNinjaExpansionItem@@PAVioItem@@@Z ; ToNinjaExpansionItem
;	COMDAT ??_R0?AVioNinjaExpansionItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioninjaexpansionitem.h
_DATA	SEGMENT
??_R0?AVioNinjaExpansionItem@@@8 DD FLAT:??_7type_info@@6B@ ; ioNinjaExpansionItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioNinjaExpansionItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToNinjaExpansionItem@@YAPAVioNinjaExpansionItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToNinjaExpansionItem@@YAPAVioNinjaExpansionItem@@PAVioItem@@@Z PROC ; ToNinjaExpansionItem, COMDAT

; 196  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 198  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_NINJA_EXPANSION_ITEM )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToNinjaExp
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	83 f8 6a	 cmp	 eax, 106		; 0000006aH
  0001d	75 1b		 jne	 SHORT $LN1@ToNinjaExp

; 200  : 
; 201  : 	return dynamic_cast< ioNinjaExpansionItem* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioNinjaExpansionItem@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 202  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToNinjaExp:

; 199  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 202  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToNinjaExpansionItem@@YAPAVioNinjaExpansionItem@@PAVioItem@@@Z ENDP ; ToNinjaExpansionItem
_TEXT	ENDS
PUBLIC	??_R0?AVioNataItem@@@8				; ioNataItem `RTTI Type Descriptor'
PUBLIC	?ToNataItem@@YAPAVioNataItem@@PAVioItem@@@Z	; ToNataItem
;	COMDAT ??_R0?AVioNataItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ionataitem.h
_DATA	SEGMENT
??_R0?AVioNataItem@@@8 DD FLAT:??_7type_info@@6B@	; ioNataItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioNataItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToNataItem@@YAPAVioNataItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToNataItem@@YAPAVioNataItem@@PAVioItem@@@Z PROC	; ToNataItem, COMDAT

; 360  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 361  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00004	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00007	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000c	8b f0		 mov	 esi, eax
  0000e	59		 pop	 ecx

; 362  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_NATA_ITEM )

  0000f	85 f6		 test	 esi, esi
  00011	74 28		 je	 SHORT $LN1@ToNataItem
  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	8b ce		 mov	 ecx, esi
  00017	ff 90 f0 02 00
	00		 call	 DWORD PTR [eax+752]
  0001d	83 f8 77	 cmp	 eax, 119		; 00000077H
  00020	75 19		 jne	 SHORT $LN1@ToNataItem

; 364  : 
; 365  : 	return dynamic_cast< ioNataItem* >( pWeapon );

  00022	6a 00		 push	 0
  00024	68 00 00 00 00	 push	 OFFSET ??_R0?AVioNataItem@@@8
  00029	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWeaponItem@@@8
  0002e	6a 00		 push	 0
  00030	56		 push	 esi
  00031	e8 00 00 00 00	 call	 ___RTDynamicCast
  00036	83 c4 14	 add	 esp, 20			; 00000014H
  00039	eb 02		 jmp	 SHORT $LN3@ToNataItem
$LN1@ToNataItem:

; 363  : 		return NULL;

  0003b	33 c0		 xor	 eax, eax
$LN3@ToNataItem:
  0003d	5e		 pop	 esi

; 366  : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?ToNataItem@@YAPAVioNataItem@@PAVioItem@@@Z ENDP	; ToNataItem
_TEXT	ENDS
PUBLIC	??_R0?AVioOniMushaItem@@@8			; ioOniMushaItem `RTTI Type Descriptor'
PUBLIC	?ToOniMushaItem@@YAPAVioOniMushaItem@@PAVioItem@@@Z ; ToOniMushaItem
;	COMDAT ??_R0?AVioOniMushaItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioonimushaitem.h
_DATA	SEGMENT
??_R0?AVioOniMushaItem@@@8 DD FLAT:??_7type_info@@6B@	; ioOniMushaItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioOniMushaItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToOniMushaItem@@YAPAVioOniMushaItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToOniMushaItem@@YAPAVioOniMushaItem@@PAVioItem@@@Z PROC ; ToOniMushaItem, COMDAT

; 203  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 204  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 205  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_ONIMUSHA_ITEM )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2c		 je	 SHORT $LN1@ToOniMusha
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	3d 8d 00 00 00	 cmp	 eax, 141		; 0000008dH
  0001f	75 1b		 jne	 SHORT $LN1@ToOniMusha

; 207  : 
; 208  : 	return dynamic_cast< ioOniMushaItem* >( pItem );

  00021	6a 00		 push	 0
  00023	68 00 00 00 00	 push	 OFFSET ??_R0?AVioOniMushaItem@@@8
  00028	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002d	6a 00		 push	 0
  0002f	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00032	e8 00 00 00 00	 call	 ___RTDynamicCast
  00037	83 c4 14	 add	 esp, 20			; 00000014H

; 209  : }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
$LN1@ToOniMusha:

; 206  : 		return NULL;

  0003c	33 c0		 xor	 eax, eax

; 209  : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?ToOniMushaItem@@YAPAVioOniMushaItem@@PAVioItem@@@Z ENDP ; ToOniMushaItem
_TEXT	ENDS
PUBLIC	??_R0?AVioDruidItem@@@8				; ioDruidItem `RTTI Type Descriptor'
PUBLIC	?ToDruidItem@@YAPAVioDruidItem@@PAVioItem@@@Z	; ToDruidItem
;	COMDAT ??_R0?AVioDruidItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iodruiditem.h
_DATA	SEGMENT
??_R0?AVioDruidItem@@@8 DD FLAT:??_7type_info@@6B@	; ioDruidItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioDruidItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToDruidItem@@YAPAVioDruidItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToDruidItem@@YAPAVioDruidItem@@PAVioItem@@@Z PROC	; ToDruidItem, COMDAT

; 130  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 131  : 	ioWeaponItem *pWeapon = ToWeaponItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToWeaponItem@@YAPAVioWeaponItem@@PAVioItem@@@Z ; ToWeaponItem
  0000b	59		 pop	 ecx

; 132  : 	if( !pWeapon || pWeapon->GetSubType() != ioWeaponItem::WST_DRUID )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2c		 je	 SHORT $LN1@ToDruidIte
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
  0001a	3d 8f 00 00 00	 cmp	 eax, 143		; 0000008fH
  0001f	75 1b		 jne	 SHORT $LN1@ToDruidIte

; 134  : 
; 135  : 	return dynamic_cast< ioDruidItem* >( pItem );

  00021	6a 00		 push	 0
  00023	68 00 00 00 00	 push	 OFFSET ??_R0?AVioDruidItem@@@8
  00028	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002d	6a 00		 push	 0
  0002f	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00032	e8 00 00 00 00	 call	 ___RTDynamicCast
  00037	83 c4 14	 add	 esp, 20			; 00000014H

; 136  : }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
$LN1@ToDruidIte:

; 133  : 		return NULL;

  0003c	33 c0		 xor	 eax, eax

; 136  : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?ToDruidItem@@YAPAVioDruidItem@@PAVioItem@@@Z ENDP	; ToDruidItem
_TEXT	ENDS
PUBLIC	??_R0?AVioThunderBirdObjectItem@@@8		; ioThunderBirdObjectItem `RTTI Type Descriptor'
PUBLIC	?ToThunderBirdObjectItem@@YAPAVioThunderBirdObjectItem@@PAVioItem@@@Z ; ToThunderBirdObjectItem
;	COMDAT ??_R0?AVioThunderBirdObjectItem@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iothunderbirdobjectitem.h
_DATA	SEGMENT
??_R0?AVioThunderBirdObjectItem@@@8 DD FLAT:??_7type_info@@6B@ ; ioThunderBirdObjectItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioThunderBirdObjectItem@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToThunderBirdObjectItem@@YAPAVioThunderBirdObjectItem@@PAVioItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?ToThunderBirdObjectItem@@YAPAVioThunderBirdObjectItem@@PAVioItem@@@Z PROC ; ToThunderBirdObjectItem, COMDAT

; 121  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 122  : 	ioObjectItem *pObject = ToObjectItem( pItem );

  00003	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00006	e8 00 00 00 00	 call	 ?ToObjectItem@@YAPAVioObjectItem@@PAVioItem@@@Z ; ToObjectItem
  0000b	59		 pop	 ecx

; 123  : 	if( !pObject || pObject->GetObjectSubType() != ioObjectItem::OST_THUNDER_BIRD )

  0000c	85 c0		 test	 eax, eax
  0000e	74 2a		 je	 SHORT $LN1@ToThunderB@2
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	ff 92 04 03 00
	00		 call	 DWORD PTR [edx+772]
  0001a	83 f8 11	 cmp	 eax, 17			; 00000011H
  0001d	75 1b		 jne	 SHORT $LN1@ToThunderB@2

; 125  : 
; 126  : 	return dynamic_cast< ioThunderBirdObjectItem* >( pItem );

  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioThunderBirdObjectItem@@@8
  00026	68 00 00 00 00	 push	 OFFSET ??_R0?AVioItem@@@8
  0002b	6a 00		 push	 0
  0002d	ff 75 08	 push	 DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ___RTDynamicCast
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 127  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN1@ToThunderB@2:

; 124  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax

; 127  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?ToThunderBirdObjectItem@@YAPAVioThunderBirdObjectItem@@PAVioItem@@@Z ENDP ; ToThunderBirdObjectItem
_TEXT	ENDS
PUBLIC	??_R0?AVioBuff@@@8				; ioBuff `RTTI Type Descriptor'
PUBLIC	??_R0?AVioThunderBirdHoldBuff@@@8		; ioThunderBirdHoldBuff `RTTI Type Descriptor'
PUBLIC	?ToThunderBirdHoldBuff@@YAPAVioThunderBirdHoldBuff@@PAVioBuff@@@Z ; ToThunderBirdHoldBuff
;	COMDAT ??_R0?AVioBuff@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobuff.h
_DATA	SEGMENT
??_R0?AVioBuff@@@8 DD FLAT:??_7type_info@@6B@		; ioBuff `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioBuff@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVioThunderBirdHoldBuff@@@8
_DATA	SEGMENT
??_R0?AVioThunderBirdHoldBuff@@@8 DD FLAT:??_7type_info@@6B@ ; ioThunderBirdHoldBuff `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioThunderBirdHoldBuff@@', 00H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iothunderbirdholdbuff.h
_DATA	ENDS
;	COMDAT ?ToThunderBirdHoldBuff@@YAPAVioThunderBirdHoldBuff@@PAVioBuff@@@Z
_TEXT	SEGMENT
_pBuff$ = 8						; size = 4
?ToThunderBirdHoldBuff@@YAPAVioThunderBirdHoldBuff@@PAVioBuff@@@Z PROC ; ToThunderBirdHoldBuff, COMDAT

; 52   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 53   : 	if( !pBuff || pBuff->GetTypeID() != BT_THUNDER_BIRD_HOLD )

  00003	8b 45 08	 mov	 eax, DWORD PTR _pBuff$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 25		 je	 SHORT $LN1@ToThunderB@3
  0000a	81 b8 cc 03 00
	00 b1 00 00 00	 cmp	 DWORD PTR [eax+972], 177 ; 000000b1H
  00014	75 19		 jne	 SHORT $LN1@ToThunderB@3

; 55   : 
; 56   : 	return dynamic_cast< ioThunderBirdHoldBuff* >( pBuff );

  00016	6a 00		 push	 0
  00018	68 00 00 00 00	 push	 OFFSET ??_R0?AVioThunderBirdHoldBuff@@@8
  0001d	68 00 00 00 00	 push	 OFFSET ??_R0?AVioBuff@@@8
  00022	6a 00		 push	 0
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002a	83 c4 14	 add	 esp, 20			; 00000014H

; 57   : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
$LN1@ToThunderB@3:

; 54   : 		return NULL;

  0002f	33 c0		 xor	 eax, eax

; 57   : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?ToThunderBirdHoldBuff@@YAPAVioThunderBirdHoldBuff@@PAVioBuff@@@Z ENDP ; ToThunderBirdHoldBuff
_TEXT	ENDS
PUBLIC	??_R0?AVioCheckStateEndCallBuff@@@8		; ioCheckStateEndCallBuff `RTTI Type Descriptor'
PUBLIC	?ToCheckStateEndCallBuff@@YAPAVioCheckStateEndCallBuff@@PAVioBuff@@@Z ; ToCheckStateEndCallBuff
;	COMDAT ??_R0?AVioCheckStateEndCallBuff@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobuff.h
_DATA	SEGMENT
??_R0?AVioCheckStateEndCallBuff@@@8 DD FLAT:??_7type_info@@6B@ ; ioCheckStateEndCallBuff `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioCheckStateEndCallBuff@@', 00H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iocheckstateendcallbuff.h
_DATA	ENDS
;	COMDAT ?ToCheckStateEndCallBuff@@YAPAVioCheckStateEndCallBuff@@PAVioBuff@@@Z
_TEXT	SEGMENT
_pBuff$ = 8						; size = 4
?ToCheckStateEndCallBuff@@YAPAVioCheckStateEndCallBuff@@PAVioBuff@@@Z PROC ; ToCheckStateEndCallBuff, COMDAT

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 54   : 	if( !pBuff || pBuff->GetTypeID() != BT_CHECK_STATE_END_CALL_BUFF )

  00003	8b 45 08	 mov	 eax, DWORD PTR _pBuff$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 25		 je	 SHORT $LN1@ToCheckSta
  0000a	81 b8 cc 03 00
	00 b3 00 00 00	 cmp	 DWORD PTR [eax+972], 179 ; 000000b3H
  00014	75 19		 jne	 SHORT $LN1@ToCheckSta

; 56   : 
; 57   : 	return dynamic_cast< ioCheckStateEndCallBuff* >( pBuff );

  00016	6a 00		 push	 0
  00018	68 00 00 00 00	 push	 OFFSET ??_R0?AVioCheckStateEndCallBuff@@@8
  0001d	68 00 00 00 00	 push	 OFFSET ??_R0?AVioBuff@@@8
  00022	6a 00		 push	 0
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002a	83 c4 14	 add	 esp, 20			; 00000014H

; 58   : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
$LN1@ToCheckSta:

; 55   : 		return NULL;

  0002f	33 c0		 xor	 eax, eax

; 58   : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?ToCheckStateEndCallBuff@@YAPAVioCheckStateEndCallBuff@@PAVioBuff@@@Z ENDP ; ToCheckStateEndCallBuff
_TEXT	ENDS
PUBLIC	__real@bf800000
PUBLIC	__$ArrayPad$
PUBLIC	?SetUroborusState@ioBaseChar@@QAEXABVioHashString@@MUD3DXVECTOR3@@MMMM@Z ; ioBaseChar::SetUroborusState
EXTRN	?SetUroborusInfo@ioUroborusSpecialState@@QAEXUD3DXVECTOR3@@0MMM@Z:PROC ; ioUroborusSpecialState::SetUroborusInfo
EXTRN	_D3DXQuaternionRotationAxis@12:PROC
EXTRN	__imp_??D@YA?AUD3DXVECTOR3@@ABUD3DXQUATERNION@@ABU0@@Z:PROC
EXTRN	__imp_?UNIT_Y@ioMath@@2UD3DXVECTOR3@@A:BYTE
;	COMDAT __real@bf800000
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx9math.inl
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasecharspecialstate.cpp
CONST	ENDS
;	COMDAT ?SetUroborusState@ioBaseChar@@QAEXABVioHashString@@MUD3DXVECTOR3@@MMMM@Z
_TEXT	SEGMENT
_qtNewRot$609233 = -96					; size = 16
_iAniID$ = -80						; size = 4
tv1081 = -76						; size = 4
tv1077 = -76						; size = 4
_fMoveRange$ = -76					; size = 4
_fTimeRate$ = -72					; size = 4
tv1073 = -68						; size = 4
tv968 = -68						; size = 4
tv890 = -68						; size = 4
tv886 = -68						; size = 4
tv882 = -68						; size = 4
_vMoveTargetPos$ = -64					; size = 12
_vAxis$609226 = -64					; size = 12
_vMoveDir$ = -52					; size = 12
_v$612996 = -40						; size = 12
_v$612982 = -40						; size = 12
$T609242 = -40						; size = 12
$T609238 = -40						; size = 12
$T609231 = -40						; size = 12
$T609243 = -28						; size = 12
_vSightDir$609230 = -28					; size = 12
$T609223 = -28						; size = 12
_vCurDir$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_szAniName$ = 8						; size = 4
_fAniRate$ = 12						; size = 4
_vTargetPos$ = 16					; size = 12
_fSpeed$ = 28						; size = 4
_fOffSetAngle$ = 32					; size = 4
_fMoveRate$ = 36					; size = 4
_fEndJumpAmt$ = 40					; size = 4
?SetUroborusState@ioBaseChar@@QAEXABVioHashString@@MUD3DXVECTOR3@@MMMM@Z PROC ; ioBaseChar::SetUroborusState, COMDAT
; _this$ = ecx

; 18   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _szAniName$[ebp]
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8b d9		 mov	 ebx, ecx

; 19   : 	int iAniID = m_pGroup->GetAnimationIdx( szAniName );

  00018	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0001b	50		 push	 eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetAnimationIdx@ioEntityGroup@@QAEHABVioHashString@@@Z
  00022	89 45 b0	 mov	 DWORD PTR _iAniID$[ebp], eax

; 20   : 	if( iAniID == -1 )

  00025	83 f8 ff	 cmp	 eax, -1
  00028	0f 84 4d 05 00
	00		 je	 $LN1@SetUroboru

; 21   : 		return;
; 22   : 
; 23   : 	m_pGroup->ClearAllActionAni( 100.0f, true );

  0002e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42c80000
  00036	6a 01		 push	 1
  00038	51		 push	 ecx
  00039	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0003c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ClearAllActionAni@ioEntityGroup@@QAEXM_N@Z

; 24   : 	m_pGroup->ClearAllLoopAni( 100.0f, true );

  00047	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42c80000
  0004f	6a 01		 push	 1
  00051	51		 push	 ecx
  00052	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00055	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ClearAllLoopAni@ioEntityGroup@@QAEXM_N@Z

; 25   : 
; 26   : 	float fTimeRate = fAniRate;

  00060	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _fAniRate$[ebp]

; 27   : 	if( fTimeRate <= 0.0f )

  00065	0f 57 c0	 xorps	 xmm0, xmm0
  00068	f3 0f 11 4d b8	 movss	 DWORD PTR _fTimeRate$[ebp], xmm1
  0006d	0f 2f c1	 comiss	 xmm0, xmm1
  00070	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00078	72 05		 jb	 SHORT $LN5@SetUroboru

; 28   : 		fTimeRate = 1.0f;

  0007a	f3 0f 11 4d b8	 movss	 DWORD PTR _fTimeRate$[ebp], xmm1
$LN5@SetUroboru:

; 29   : 
; 30   : 	m_pGroup->SetLoopAni( iAniID, 100.0f, 1.0f, 1.0f/fTimeRate );

  0007f	f2 0f 10 15 00
	00 00 00	 movsd	 xmm2, QWORD PTR __real@3ff0000000000000
  00087	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0008a	83 ec 10	 sub	 esp, 16			; 00000010H
  0008d	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  00093	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _fTimeRate$[ebp]
  00098	0f 5a c0	 cvtps2pd xmm0, xmm0
  0009b	f2 0f 5e d0	 divsd	 xmm2, xmm0
  0009f	0f 57 c0	 xorps	 xmm0, xmm0
  000a2	66 0f 5a c2	 cvtpd2ps xmm0, xmm2
  000a6	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  000ac	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42c80000
  000b4	f3 0f 11 4c 24
	04		 movss	 DWORD PTR [esp+4], xmm1
  000ba	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000bf	ff 75 b0	 push	 DWORD PTR _iAniID$[ebp]
  000c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetLoopAni@ioEntityGroup@@QAE_NHMMMM@Z

; 31   : 
; 32   : 	D3DXVECTOR3 vCurDir = vTargetPos - GetMidPositionByRate();

  000c8	b8 05 00 00 00	 mov	 eax, 5
  000cd	8b c8		 mov	 ecx, eax
  000cf	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  000d4	89 4d b4	 mov	 DWORD PTR tv1081[ebp], ecx
  000d7	db 45 b4	 fild	 DWORD PTR tv1081[ebp]
  000da	85 c9		 test	 ecx, ecx
  000dc	79 06		 jns	 SHORT $LN61@SetUroboru
  000de	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN61@SetUroboru:
  000e4	89 45 b4	 mov	 DWORD PTR tv1077[ebp], eax
  000e7	db 45 b4	 fild	 DWORD PTR tv1077[ebp]
  000ea	85 c0		 test	 eax, eax
  000ec	79 06		 jns	 SHORT $LN62@SetUroboru
  000ee	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN62@SetUroboru:
  000f4	de f9		 fdivp	 ST(1), ST(0)
  000f6	51		 push	 ecx
  000f7	8d 45 e4	 lea	 eax, DWORD PTR $T609223[ebp]
  000fa	8b cb		 mov	 ecx, ebx
  000fc	d9 5d bc	 fstp	 DWORD PTR tv1073[ebp]
  000ff	d9 45 bc	 fld	 DWORD PTR tv1073[ebp]
  00102	d9 1c 24	 fstp	 DWORD PTR [esp]
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 ?GetMidPositionByRate@ioGameEntity@@QBE?AUD3DXVECTOR3@@M@Z ; ioGameEntity::GetMidPositionByRate
  0010b	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  00110	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _vTargetPos$[ebp+4]
  00115	0f 5a c0	 cvtps2pd xmm0, xmm0
  00118	0f 5a c9	 cvtps2pd xmm1, xmm1
  0011b	f2 0f 5c c1	 subsd	 xmm0, xmm1
  0011f	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  00124	0f 57 e4	 xorps	 xmm4, xmm4
  00127	66 0f 5a e0	 cvtpd2ps xmm4, xmm0
  0012b	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _vTargetPos$[ebp+8]
  00130	0f 5a c0	 cvtps2pd xmm0, xmm0
  00133	0f 5a c9	 cvtps2pd xmm1, xmm1
  00136	f2 0f 5c c1	 subsd	 xmm0, xmm1
  0013a	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  0013e	0f 57 ed	 xorps	 xmm5, xmm5
  00141	66 0f 5a e8	 cvtpd2ps xmm5, xmm0
  00145	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _vTargetPos$[ebp]
  0014a	0f 5a c0	 cvtps2pd xmm0, xmm0
  0014d	0f 5a c9	 cvtps2pd xmm1, xmm1
  00150	f2 0f 5c c1	 subsd	 xmm0, xmm1

; 33   : 	if( fOffSetAngle != 0.0f )

  00154	f3 0f 10 4d 20	 movss	 xmm1, DWORD PTR _fOffSetAngle$[ebp]
  00159	0f 57 ff	 xorps	 xmm7, xmm7
  0015c	66 0f 5a f8	 cvtpd2ps xmm7, xmm0
  00160	0f 57 c0	 xorps	 xmm0, xmm0
  00163	0f 2e c8	 ucomiss xmm1, xmm0
  00166	9f		 lahf
  00167	b2 44		 mov	 dl, 68			; 00000044H
  00169	f3 0f 11 7d f0	 movss	 DWORD PTR _vCurDir$[ebp], xmm7
  0016e	f3 0f 11 65 f4	 movss	 DWORD PTR _vCurDir$[ebp+4], xmm4
  00173	f3 0f 11 6d f8	 movss	 DWORD PTR _vCurDir$[ebp+8], xmm5
  00178	84 e2		 test	 ah, dl
  0017a	0f 8b 37 02 00
	00		 jnp	 $LN4@SetUroboru

; 34   : 	{
; 35   : 		D3DXVECTOR3 vAxis;
; 36   : 		if( vCurDir != ioMath::UNIT_Y && vCurDir != -ioMath::UNIT_Y )

  00180	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?UNIT_Y@ioMath@@2UD3DXVECTOR3@@A
  00186	f3 0f 10 31	 movss	 xmm6, DWORD PTR [ecx]
  0018a	0f 57 d2	 xorps	 xmm2, xmm2
  0018d	0f 5a cf	 cvtps2pd xmm1, xmm7
  00190	0f 5a d6	 cvtps2pd xmm2, xmm6
  00193	66 0f 2e ca	 ucomisd xmm1, xmm2
  00197	9f		 lahf
  00198	f3 0f 11 75 bc	 movss	 DWORD PTR tv968[ebp], xmm6
  0019d	84 e2		 test	 ah, dl
  0019f	7a 2c		 jp	 SHORT $LN21@SetUroboru
  001a1	f3 0f 10 51 04	 movss	 xmm2, DWORD PTR [ecx+4]
  001a6	0f 5a cc	 cvtps2pd xmm1, xmm4
  001a9	0f 5a d2	 cvtps2pd xmm2, xmm2
  001ac	66 0f 2e ca	 ucomisd xmm1, xmm2
  001b0	9f		 lahf
  001b1	84 e2		 test	 ah, dl
  001b3	7a 18		 jp	 SHORT $LN21@SetUroboru
  001b5	f3 0f 10 51 08	 movss	 xmm2, DWORD PTR [ecx+8]
  001ba	0f 5a cd	 cvtps2pd xmm1, xmm5
  001bd	0f 5a d2	 cvtps2pd xmm2, xmm2
  001c0	66 0f 2e ca	 ucomisd xmm1, xmm2
  001c4	9f		 lahf
  001c5	84 e2		 test	 ah, dl
  001c7	0f 8b c5 00 00
	00		 jnp	 $LN3@SetUroboru
$LN21@SetUroboru:
  001cd	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __mask@@NegFloat@
  001d5	f3 0f 10 51 04	 movss	 xmm2, DWORD PTR [ecx+4]
  001da	f3 0f 10 59 08	 movss	 xmm3, DWORD PTR [ecx+8]
  001df	0f 57 f1	 xorps	 xmm6, xmm1
  001e2	0f 57 d1	 xorps	 xmm2, xmm1
  001e5	0f 57 d9	 xorps	 xmm3, xmm1
  001e8	0f 5a cf	 cvtps2pd xmm1, xmm7
  001eb	0f 5a f6	 cvtps2pd xmm6, xmm6
  001ee	66 0f 2e ce	 ucomisd xmm1, xmm6
  001f2	9f		 lahf
  001f3	84 e2		 test	 ah, dl
  001f5	7a 1e		 jp	 SHORT $LN29@SetUroboru
  001f7	0f 5a cc	 cvtps2pd xmm1, xmm4
  001fa	0f 5a d2	 cvtps2pd xmm2, xmm2
  001fd	66 0f 2e ca	 ucomisd xmm1, xmm2
  00201	9f		 lahf
  00202	84 e2		 test	 ah, dl
  00204	7a 0f		 jp	 SHORT $LN29@SetUroboru
  00206	0f 5a cd	 cvtps2pd xmm1, xmm5
  00209	0f 5a d3	 cvtps2pd xmm2, xmm3
  0020c	66 0f 2e ca	 ucomisd xmm1, xmm2
  00210	9f		 lahf
  00211	84 e2		 test	 ah, dl
  00213	7b 7d		 jnp	 SHORT $LN3@SetUroboru
$LN29@SetUroboru:

; 37   : 		{
; 38   : 			D3DXVec3Cross( &vAxis, &vCurDir, &ioMath::UNIT_Y );

  00215	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  0021a	f3 0f 10 49 04	 movss	 xmm1, DWORD PTR [ecx+4]
  0021f	0f 5a d0	 cvtps2pd xmm2, xmm0
  00222	0f 5a dc	 cvtps2pd xmm3, xmm4
  00225	f2 0f 59 d3	 mulsd	 xmm2, xmm3
  00229	0f 5a f5	 cvtps2pd xmm6, xmm5
  0022c	0f 5a c0	 cvtps2pd xmm0, xmm0
  0022f	0f 5a d9	 cvtps2pd xmm3, xmm1
  00232	f2 0f 59 de	 mulsd	 xmm3, xmm6
  00236	f2 0f 5c d3	 subsd	 xmm2, xmm3
  0023a	66 0f 5a d2	 cvtpd2ps xmm2, xmm2
  0023e	f3 0f 11 55 d8	 movss	 DWORD PTR _v$612982[ebp], xmm2
  00243	f3 0f 10 55 bc	 movss	 xmm2, DWORD PTR tv968[ebp]
  00248	0f 5a d2	 cvtps2pd xmm2, xmm2
  0024b	0f 5a dd	 cvtps2pd xmm3, xmm5
  0024e	f2 0f 59 d3	 mulsd	 xmm2, xmm3
  00252	0f 5a df	 cvtps2pd xmm3, xmm7
  00255	f2 0f 59 c3	 mulsd	 xmm0, xmm3
  00259	f2 0f 5c d0	 subsd	 xmm2, xmm0
  0025d	0f 57 c0	 xorps	 xmm0, xmm0
  00260	f2 0f 5a c2	 cvtsd2ss xmm0, xmm2
  00264	f3 0f 11 45 dc	 movss	 DWORD PTR _v$612982[ebp+4], xmm0
  00269	0f 57 d2	 xorps	 xmm2, xmm2
  0026c	0f 5a d4	 cvtps2pd xmm2, xmm4
  0026f	0f 5a c1	 cvtps2pd xmm0, xmm1
  00272	0f 5a cf	 cvtps2pd xmm1, xmm7
  00275	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00279	f3 0f 10 4d bc	 movss	 xmm1, DWORD PTR tv968[ebp]
  0027e	0f 5a c9	 cvtps2pd xmm1, xmm1
  00281	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  00285	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00289	66 0f 5a c0	 cvtpd2ps xmm0, xmm0

; 39   : 		}
; 40   : 		else

  0028d	e9 d3 00 00 00	 jmp	 $LN65@SetUroboru
$LN3@SetUroboru:

; 41   : 		{
; 42   : 			D3DXVECTOR3 vSightDir = m_qtTargetRot * D3DXVECTOR3( 0.0f, 0.0f, -1.0f );

  00292	8d 45 d8	 lea	 eax, DWORD PTR $T609231[ebp]
  00295	50		 push	 eax
  00296	8d 83 a4 06 00
	00		 lea	 eax, DWORD PTR [ebx+1700]
  0029c	50		 push	 eax
  0029d	8d 45 e4	 lea	 eax, DWORD PTR _vSightDir$609230[ebp]
  002a0	f3 0f 11 45 d8	 movss	 DWORD PTR $T609231[ebp], xmm0
  002a5	f3 0f 11 45 dc	 movss	 DWORD PTR $T609231[ebp+4], xmm0
  002aa	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  002b2	50		 push	 eax
  002b3	f3 0f 11 45 e0	 movss	 DWORD PTR $T609231[ebp+8], xmm0
  002b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??D@YA?AUD3DXVECTOR3@@ABUD3DXQUATERNION@@ABU0@@Z
  002be	83 c4 0c	 add	 esp, 12			; 0000000cH

; 43   : 			D3DXVec3Normalize( &vSightDir, &vSightDir );

  002c1	8d 45 e4	 lea	 eax, DWORD PTR _vSightDir$609230[ebp]
  002c4	50		 push	 eax
  002c5	50		 push	 eax
  002c6	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8

; 44   : 
; 45   : 			D3DXVec3Cross( &vAxis, &vSightDir, &vCurDir );

  002cb	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _vSightDir$609230[ebp+4]
  002d0	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _vCurDir$[ebp+8]
  002d5	f3 0f 10 55 f4	 movss	 xmm2, DWORD PTR _vCurDir$[ebp+4]
  002da	0f 5a c9	 cvtps2pd xmm1, xmm1
  002dd	0f 5a c0	 cvtps2pd xmm0, xmm0
  002e0	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  002e4	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR _vSightDir$609230[ebp+8]
  002e9	0f 5a c9	 cvtps2pd xmm1, xmm1
  002ec	0f 5a d2	 cvtps2pd xmm2, xmm2
  002ef	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  002f3	f3 0f 10 55 e4	 movss	 xmm2, DWORD PTR _vSightDir$609230[ebp]
  002f8	f2 0f 5c c1	 subsd	 xmm0, xmm1
  002fc	f3 0f 10 4d f0	 movss	 xmm1, DWORD PTR _vCurDir$[ebp]
  00301	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00305	f3 0f 11 45 d8	 movss	 DWORD PTR _v$612996[ebp], xmm0
  0030a	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _vSightDir$609230[ebp+8]
  0030f	0f 5a c9	 cvtps2pd xmm1, xmm1
  00312	0f 5a c0	 cvtps2pd xmm0, xmm0
  00315	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00319	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _vCurDir$[ebp+8]
  0031e	0f 5a c9	 cvtps2pd xmm1, xmm1
  00321	0f 5a d2	 cvtps2pd xmm2, xmm2
  00324	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  00328	f3 0f 10 55 f0	 movss	 xmm2, DWORD PTR _vCurDir$[ebp]
  0032d	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00331	f3 0f 10 4d e4	 movss	 xmm1, DWORD PTR _vSightDir$609230[ebp]
  00336	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0033a	f3 0f 11 45 dc	 movss	 DWORD PTR _v$612996[ebp+4], xmm0
  0033f	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _vCurDir$[ebp+4]
  00344	0f 5a c9	 cvtps2pd xmm1, xmm1
  00347	0f 5a c0	 cvtps2pd xmm0, xmm0
  0034a	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  0034e	f3 0f 10 4d e8	 movss	 xmm1, DWORD PTR _vSightDir$609230[ebp+4]
  00353	0f 5a c9	 cvtps2pd xmm1, xmm1
  00356	0f 5a d2	 cvtps2pd xmm2, xmm2
  00359	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  0035d	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00361	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
$LN65@SetUroboru:
  00365	f3 0f 11 45 e0	 movss	 DWORD PTR _v$612996[ebp+8], xmm0

; 46   : 		}
; 47   : 
; 48   : 		D3DXQUATERNION qtNewRot;
; 49   : 		D3DXQuaternionRotationAxis( &qtNewRot, &vAxis, DEGtoRAD(fOffSetAngle) );

  0036a	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _fOffSetAngle$[ebp]
  0036f	8d 7d c0	 lea	 edi, DWORD PTR _vAxis$609226[ebp]
  00372	8d 75 d8	 lea	 esi, DWORD PTR _v$612996[ebp]
  00375	a5		 movsd
  00376	0f 5a c0	 cvtps2pd xmm0, xmm0
  00379	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3f91df46a2526c7a
  00381	51		 push	 ecx
  00382	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00386	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0038b	8d 45 c0	 lea	 eax, DWORD PTR _vAxis$609226[ebp]
  0038e	a5		 movsd
  0038f	50		 push	 eax
  00390	8d 45 a0	 lea	 eax, DWORD PTR _qtNewRot$609233[ebp]
  00393	50		 push	 eax
  00394	a5		 movsd
  00395	e8 00 00 00 00	 call	 _D3DXQuaternionRotationAxis@12

; 50   : 
; 51   : 		vCurDir = qtNewRot * vCurDir;

  0039a	8d 45 f0	 lea	 eax, DWORD PTR _vCurDir$[ebp]
  0039d	50		 push	 eax
  0039e	8d 45 a0	 lea	 eax, DWORD PTR _qtNewRot$609233[ebp]
  003a1	50		 push	 eax
  003a2	8d 45 d8	 lea	 eax, DWORD PTR $T609238[ebp]
  003a5	50		 push	 eax
  003a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??D@YA?AUD3DXVECTOR3@@ABUD3DXQUATERNION@@ABU0@@Z
  003ac	8b f0		 mov	 esi, eax
  003ae	8d 7d f0	 lea	 edi, DWORD PTR _vCurDir$[ebp]
  003b1	a5		 movsd
  003b2	a5		 movsd
  003b3	83 c4 0c	 add	 esp, 12			; 0000000cH
  003b6	a5		 movsd
$LN4@SetUroboru:

; 52   : 	}
; 53   : 
; 54   : 	D3DXVECTOR3 vMoveDir = vCurDir;

  003b7	8d 75 f0	 lea	 esi, DWORD PTR _vCurDir$[ebp]
  003ba	8d 7d cc	 lea	 edi, DWORD PTR _vMoveDir$[ebp]
  003bd	a5		 movsd

; 55   : 	D3DXVec3Normalize( &vMoveDir, &vMoveDir );

  003be	8d 45 cc	 lea	 eax, DWORD PTR _vMoveDir$[ebp]
  003c1	a5		 movsd
  003c2	50		 push	 eax
  003c3	50		 push	 eax
  003c4	a5		 movsd
  003c5	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8
  003ca	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _vCurDir$[ebp]

; 56   : 
; 57   : 	float fMoveRange = D3DXVec3Length( &vCurDir ) * fMoveRate;

  003cf	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR _vCurDir$[ebp+4]
  003d4	f3 0f 10 55 f8	 movss	 xmm2, DWORD PTR _vCurDir$[ebp+8]
  003d9	0f 5a c9	 cvtps2pd xmm1, xmm1
  003dc	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  003e0	0f 5a c0	 cvtps2pd xmm0, xmm0
  003e3	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  003e7	f2 0f 58 c8	 addsd	 xmm1, xmm0
  003eb	0f 57 c0	 xorps	 xmm0, xmm0
  003ee	0f 5a d2	 cvtps2pd xmm2, xmm2
  003f1	f2 0f 59 d2	 mulsd	 xmm2, xmm2
  003f5	f2 0f 58 ca	 addsd	 xmm1, xmm2
  003f9	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  003fd	f3 0f 10 4d 24	 movss	 xmm1, DWORD PTR _fMoveRate$[ebp]
  00402	0f 5a c9	 cvtps2pd xmm1, xmm1
  00405	0f 5a c0	 cvtps2pd xmm0, xmm0
  00408	f2 0f 51 c0	 sqrtsd	 xmm0, xmm0
  0040c	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00410	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00414	f2 0f 59 c1	 mulsd	 xmm0, xmm1

; 58   : 	D3DXVECTOR3 vMoveTargetPos = GetMidPositionByRate() + (vMoveDir * fMoveRange);

  00418	f3 0f 10 4d cc	 movss	 xmm1, DWORD PTR _vMoveDir$[ebp]
  0041d	0f 5a c9	 cvtps2pd xmm1, xmm1
  00420	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00424	0f 57 d2	 xorps	 xmm2, xmm2
  00427	f3 0f 5a d0	 cvtss2sd xmm2, xmm0
  0042b	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  0042f	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  00433	f3 0f 11 4d e4	 movss	 DWORD PTR $T609243[ebp], xmm1
  00438	f3 0f 10 4d d0	 movss	 xmm1, DWORD PTR _vMoveDir$[ebp+4]
  0043d	0f 5a c9	 cvtps2pd xmm1, xmm1
  00440	f3 0f 11 45 b4	 movss	 DWORD PTR _fMoveRange$[ebp], xmm0
  00445	0f 57 d2	 xorps	 xmm2, xmm2
  00448	f3 0f 5a d0	 cvtss2sd xmm2, xmm0
  0044c	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  00450	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  00454	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00458	f3 0f 11 4d e8	 movss	 DWORD PTR $T609243[ebp+4], xmm1
  0045d	f3 0f 10 4d d4	 movss	 xmm1, DWORD PTR _vMoveDir$[ebp+8]
  00462	0f 5a c9	 cvtps2pd xmm1, xmm1
  00465	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  00469	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  0046d	f3 0f 11 45 ec	 movss	 DWORD PTR $T609243[ebp+8], xmm0
  00472	b8 05 00 00 00	 mov	 eax, 5
  00477	8b c8		 mov	 ecx, eax
  00479	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  0047e	89 4d bc	 mov	 DWORD PTR tv890[ebp], ecx
  00481	db 45 bc	 fild	 DWORD PTR tv890[ebp]
  00484	85 c9		 test	 ecx, ecx
  00486	79 06		 jns	 SHORT $LN63@SetUroboru
  00488	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN63@SetUroboru:
  0048e	89 45 bc	 mov	 DWORD PTR tv886[ebp], eax
  00491	db 45 bc	 fild	 DWORD PTR tv886[ebp]
  00494	85 c0		 test	 eax, eax
  00496	79 06		 jns	 SHORT $LN64@SetUroboru
  00498	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN64@SetUroboru:
  0049e	de f9		 fdivp	 ST(1), ST(0)
  004a0	51		 push	 ecx
  004a1	8d 45 d8	 lea	 eax, DWORD PTR $T609242[ebp]
  004a4	8b cb		 mov	 ecx, ebx
  004a6	d9 5d bc	 fstp	 DWORD PTR tv882[ebp]
  004a9	d9 45 bc	 fld	 DWORD PTR tv882[ebp]
  004ac	d9 1c 24	 fstp	 DWORD PTR [esp]
  004af	50		 push	 eax
  004b0	e8 00 00 00 00	 call	 ?GetMidPositionByRate@ioGameEntity@@QBE?AUD3DXVECTOR3@@M@Z ; ioGameEntity::GetMidPositionByRate
  004b5	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  004b9	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR $T609243[ebp]
  004be	0f 5a c0	 cvtps2pd xmm0, xmm0
  004c1	0f 5a c9	 cvtps2pd xmm1, xmm1
  004c4	f2 0f 58 c1	 addsd	 xmm0, xmm1
  004c8	f3 0f 10 4d e8	 movss	 xmm1, DWORD PTR $T609243[ebp+4]
  004cd	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  004d1	f3 0f 11 45 c0	 movss	 DWORD PTR _vMoveTargetPos$[ebp], xmm0
  004d6	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  004db	0f 5a c0	 cvtps2pd xmm0, xmm0
  004de	0f 5a c9	 cvtps2pd xmm1, xmm1
  004e1	f2 0f 58 c1	 addsd	 xmm0, xmm1
  004e5	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR $T609243[ebp+8]
  004ea	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  004ee	f3 0f 11 45 c4	 movss	 DWORD PTR _vMoveTargetPos$[ebp+4], xmm0
  004f3	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  004f8	0f 5a c0	 cvtps2pd xmm0, xmm0
  004fb	0f 5a c9	 cvtps2pd xmm1, xmm1
  004fe	f2 0f 58 c1	 addsd	 xmm0, xmm1

; 59   : 	
; 60   : 	CheckCharColSkipTime( iAniID, fTimeRate, 0 );

  00502	6a 00		 push	 0
  00504	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00508	51		 push	 ecx
  00509	f3 0f 11 45 c8	 movss	 DWORD PTR _vMoveTargetPos$[ebp+8], xmm0
  0050e	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _fTimeRate$[ebp]
  00513	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00518	ff 75 b0	 push	 DWORD PTR _iAniID$[ebp]
  0051b	8b cb		 mov	 ecx, ebx
  0051d	e8 00 00 00 00	 call	 ?CheckCharColSkipTime@ioBaseChar@@QAEXHMK@Z ; ioBaseChar::CheckCharColSkipTime

; 61   : 
; 62   : 	SetState( CS_UROBORUS );

  00522	6a 01		 push	 1
  00524	6a 4b		 push	 75			; 0000004bH
  00526	8b cb		 mov	 ecx, ebx
  00528	e8 00 00 00 00	 call	 ?SetState@ioBaseChar@@QAEXH_N@Z ; ioBaseChar::SetState

; 63   : 
; 64   : 	ioUroborusSpecialState *pUroborusSpecialState = ToUroborusSpecialState( m_pCharSpeicalState );

  0052d	ff b3 14 03 00
	00		 push	 DWORD PTR [ebx+788]
  00533	e8 00 00 00 00	 call	 ?ToUroborusSpecialState@@YAPAVioUroborusSpecialState@@PAVioSpecialStateBase@@@Z ; ToUroborusSpecialState
  00538	59		 pop	 ecx

; 65   : 	if ( pUroborusSpecialState )

  00539	85 c0		 test	 eax, eax
  0053b	74 3e		 je	 SHORT $LN1@SetUroboru

; 66   : 		pUroborusSpecialState->SetUroborusInfo( vMoveDir, vMoveTargetPos, fSpeed, fMoveRange, fEndJumpAmt );

  0053d	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _fEndJumpAmt$[ebp]
  00542	83 ec 18	 sub	 esp, 24			; 00000018H
  00545	f3 0f 11 44 24
	14		 movss	 DWORD PTR [esp+20], xmm0
  0054b	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _fMoveRange$[ebp]
  00550	f3 0f 11 44 24
	10		 movss	 DWORD PTR [esp+16], xmm0
  00556	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _fSpeed$[ebp]
  0055b	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  00561	8b fc		 mov	 edi, esp
  00563	8d 75 c0	 lea	 esi, DWORD PTR _vMoveTargetPos$[ebp]
  00566	a5		 movsd
  00567	a5		 movsd
  00568	a5		 movsd
  00569	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0056c	8b fc		 mov	 edi, esp
  0056e	8d 75 cc	 lea	 esi, DWORD PTR _vMoveDir$[ebp]
  00571	a5		 movsd
  00572	a5		 movsd
  00573	8b c8		 mov	 ecx, eax
  00575	a5		 movsd
  00576	e8 00 00 00 00	 call	 ?SetUroborusInfo@ioUroborusSpecialState@@QAEXUD3DXVECTOR3@@0MMM@Z ; ioUroborusSpecialState::SetUroborusInfo
$LN1@SetUroboru:

; 67   : }

  0057b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0057e	5f		 pop	 edi
  0057f	5e		 pop	 esi
  00580	33 cd		 xor	 ecx, ebp
  00582	5b		 pop	 ebx
  00583	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00588	c9		 leave
  00589	c2 24 00	 ret	 36			; 00000024H
?SetUroborusState@ioBaseChar@@QAEXABVioHashString@@MUD3DXVECTOR3@@MMMM@Z ENDP ; ioBaseChar::SetUroborusState
_TEXT	ENDS
PUBLIC	?CheckEnableChangeWereWolfGauge@ioBaseChar@@QAEXXZ ; ioBaseChar::CheckEnableChangeWereWolfGauge
EXTRN	?CheckEnableChangeDamage@ioWereWolfItem@@QAEXPAVioBaseChar@@@Z:PROC ; ioWereWolfItem::CheckEnableChangeDamage
EXTRN	?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z:PROC ; ioBaseChar::GetPriorityItem
EXTRN	?IsObejctEquipState@ioBaseChar@@QAE_NW4ObjectEqipState@@@Z:PROC ; ioBaseChar::IsObejctEquipState
EXTRN	?CheckGrapplingExceptionState@ioBaseChar@@QAE_NXZ:PROC ; ioBaseChar::CheckGrapplingExceptionState
; Function compile flags: /Ogsp
;	COMDAT ?CheckEnableChangeWereWolfGauge@ioBaseChar@@QAEXXZ
_TEXT	SEGMENT
?CheckEnableChangeWereWolfGauge@ioBaseChar@@QAEXXZ PROC	; ioBaseChar::CheckEnableChangeWereWolfGauge, COMDAT
; _this$ = ecx

; 71   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 72   : 	if( !IsNeedProcess() )

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 90 00 01 00
	00		 call	 DWORD PTR [eax+256]
  0000b	84 c0		 test	 al, al
  0000d	74 34		 je	 SHORT $LN1@CheckEnabl

; 73   : 		return;
; 74   : 
; 75   : 	if( !CheckGrapplingExceptionState() )

  0000f	8b ce		 mov	 ecx, esi
  00011	e8 00 00 00 00	 call	 ?CheckGrapplingExceptionState@ioBaseChar@@QAE_NXZ ; ioBaseChar::CheckGrapplingExceptionState
  00016	84 c0		 test	 al, al
  00018	74 29		 je	 SHORT $LN1@CheckEnabl

; 76   : 		return;
; 77   : 
; 78   : 	if( IsObejctEquipState( OES_WEREWOLF ) )

  0001a	6a 01		 push	 1
  0001c	8b ce		 mov	 ecx, esi
  0001e	e8 00 00 00 00	 call	 ?IsObejctEquipState@ioBaseChar@@QAE_NW4ObjectEqipState@@@Z ; ioBaseChar::IsObejctEquipState
  00023	84 c0		 test	 al, al
  00025	75 1c		 jne	 SHORT $LN1@CheckEnabl

; 79   : 		return;
; 80   : 
; 81   : 	ioWereWolfItem *pWereWolf = ToWereWolfItem( GetPriorityItem( SPT_ATTACK ) );

  00027	6a 05		 push	 5
  00029	8b ce		 mov	 ecx, esi
  0002b	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?ToWereWolfItem@@YAPAVioWereWolfItem@@PAVioItem@@@Z ; ToWereWolfItem
  00036	59		 pop	 ecx

; 82   : 	if( pWereWolf )

  00037	85 c0		 test	 eax, eax
  00039	74 08		 je	 SHORT $LN1@CheckEnabl

; 83   : 		pWereWolf->CheckEnableChangeDamage( this );

  0003b	56		 push	 esi
  0003c	8b c8		 mov	 ecx, eax
  0003e	e8 00 00 00 00	 call	 ?CheckEnableChangeDamage@ioWereWolfItem@@QAEXPAVioBaseChar@@@Z ; ioWereWolfItem::CheckEnableChangeDamage
$LN1@CheckEnabl:
  00043	5e		 pop	 esi

; 84   : }

  00044	c3		 ret	 0
?CheckEnableChangeWereWolfGauge@ioBaseChar@@QAEXXZ ENDP	; ioBaseChar::CheckEnableChangeWereWolfGauge
_TEXT	ENDS
PUBLIC	?ApplyWereWolfState@ioBaseChar@@QAEXAAVSP2Packet@@@Z ; ioBaseChar::ApplyWereWolfState
EXTRN	?SetEnableChangeDamageEffect@ioWereWolfItem@@QAEXPAVioBaseChar@@@Z:PROC ; ioWereWolfItem::SetEnableChangeDamageEffect
EXTRN	?CreateDummyChar@ioWereWolfItem@@QAE_NPAVioBaseChar@@H@Z:PROC ; ioWereWolfItem::CreateDummyChar
EXTRN	?SetCurChangeDamage@ioWereWolfItem@@QAEXM@Z:PROC ; ioWereWolfItem::SetCurChangeDamage
EXTRN	?GetWeapon@ioEquipSlot@@QBEPAVioWeaponItem@@XZ:PROC ; ioEquipSlot::GetWeapon
EXTRN	??5SP2Packet@@QAEAAV0@AAM@Z:PROC		; SP2Packet::operator>>
EXTRN	??5SP2Packet@@QAEAAV0@AAH@Z:PROC		; SP2Packet::operator>>
; Function compile flags: /Ogsp
;	COMDAT ?ApplyWereWolfState@ioBaseChar@@QAEXAAVSP2Packet@@@Z
_TEXT	SEGMENT
_iType$ = -12						; size = 4
_iDummyIndex$609300 = -8				; size = 4
_fCurChangeDamage$ = -4					; size = 4
_rkPacket$ = 8						; size = 4
?ApplyWereWolfState@ioBaseChar@@QAEXAAVSP2Packet@@@Z PROC ; ioBaseChar::ApplyWereWolfState, COMDAT
; _this$ = ecx

; 147  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi

; 148  : 	int iType;
; 149  : 	rkPacket >> iType;

  00008	8d 45 f4	 lea	 eax, DWORD PTR _iType$[ebp]
  0000b	8b f9		 mov	 edi, ecx
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _rkPacket$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??5SP2Packet@@QAEAAV0@AAH@Z ; SP2Packet::operator>>

; 150  : 
; 151  : 	float fCurChangeDamage;
; 152  : 	rkPacket >> fCurChangeDamage;

  00016	8b 4d 08	 mov	 ecx, DWORD PTR _rkPacket$[ebp]
  00019	8d 45 fc	 lea	 eax, DWORD PTR _fCurChangeDamage$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ??5SP2Packet@@QAEAAV0@AAM@Z ; SP2Packet::operator>>

; 153  : 
; 154  : 	ioWereWolfItem *pWereWolf = ToWereWolfItem( m_pEquipSlot->GetWeapon() );

  00022	8b 8f 48 03 00
	00		 mov	 ecx, DWORD PTR [edi+840]
  00028	e8 00 00 00 00	 call	 ?GetWeapon@ioEquipSlot@@QBEPAVioWeaponItem@@XZ ; ioEquipSlot::GetWeapon
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ?ToWereWolfItem@@YAPAVioWereWolfItem@@PAVioItem@@@Z ; ToWereWolfItem
  00033	8b f0		 mov	 esi, eax

; 155  : 
; 156  : 	switch( iType )

  00035	8b 45 f4	 mov	 eax, DWORD PTR _iType$[ebp]
  00038	48		 dec	 eax
  00039	59		 pop	 ecx
  0003a	74 55		 je	 SHORT $LN8@ApplyWereW
  0003c	48		 dec	 eax
  0003d	48		 dec	 eax
  0003e	74 43		 je	 SHORT $LN5@ApplyWereW
  00040	48		 dec	 eax
  00041	75 6f		 jne	 SHORT $LN7@ApplyWereW

; 176  : 	case WEREWOLF_RIDING_SET:
; 177  : 		if( pWereWolf )

  00043	85 f6		 test	 esi, esi
  00045	74 6b		 je	 SHORT $LN7@ApplyWereW

; 178  : 		{
; 179  : 			pWereWolf->SetChangeWereWolfState( this );

  00047	8b 06		 mov	 eax, DWORD PTR [esi]
  00049	57		 push	 edi
  0004a	8b ce		 mov	 ecx, esi
  0004c	ff 90 64 02 00
	00		 call	 DWORD PTR [eax+612]

; 180  : 			pWereWolf->SetCurChangeDamage( fCurChangeDamage );

  00052	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fCurChangeDamage$[ebp]
  00057	51		 push	 ecx
  00058	8b ce		 mov	 ecx, esi
  0005a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0005f	e8 00 00 00 00	 call	 ?SetCurChangeDamage@ioWereWolfItem@@QAEXM@Z ; ioWereWolfItem::SetCurChangeDamage

; 181  : 
; 182  : 			int iDummyIndex;
; 183  : 			rkPacket >> iDummyIndex;

  00064	8b 4d 08	 mov	 ecx, DWORD PTR _rkPacket$[ebp]
  00067	8d 45 f8	 lea	 eax, DWORD PTR _iDummyIndex$609300[ebp]
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 ??5SP2Packet@@QAEAAV0@AAH@Z ; SP2Packet::operator>>

; 184  : 
; 185  : 			if( iDummyIndex > 0 )

  00070	83 7d f8 00	 cmp	 DWORD PTR _iDummyIndex$609300[ebp], 0
  00074	7e 3c		 jle	 SHORT $LN7@ApplyWereW

; 186  : 				pWereWolf->CreateDummyChar( this, iDummyIndex );

  00076	ff 75 f8	 push	 DWORD PTR _iDummyIndex$609300[ebp]
  00079	8b ce		 mov	 ecx, esi
  0007b	57		 push	 edi
  0007c	e8 00 00 00 00	 call	 ?CreateDummyChar@ioWereWolfItem@@QAE_NPAVioBaseChar@@H@Z ; ioWereWolfItem::CreateDummyChar

; 187  : 		}
; 188  : 		break;

  00081	eb 2f		 jmp	 SHORT $LN7@ApplyWereW
$LN5@ApplyWereW:

; 163  : 		}
; 164  : 		break;
; 165  : 	case WEREWOLF_RELEASE:
; 166  : 		{
; 167  : 		}
; 168  : 		break;
; 169  : 	case WEREWOLF_ENABLE_GAUGE:
; 170  : 		if( pWereWolf )

  00083	85 f6		 test	 esi, esi
  00085	74 2b		 je	 SHORT $LN7@ApplyWereW

; 171  : 		{
; 172  : 			pWereWolf->SetEnableChangeDamageEffect( this );

  00087	57		 push	 edi
  00088	8b ce		 mov	 ecx, esi
  0008a	e8 00 00 00 00	 call	 ?SetEnableChangeDamageEffect@ioWereWolfItem@@QAEXPAVioBaseChar@@@Z ; ioWereWolfItem::SetEnableChangeDamageEffect

; 173  : 			pWereWolf->SetCurChangeDamage( fCurChangeDamage );
; 174  : 		}
; 175  : 		break;

  0008f	eb 0f		 jmp	 SHORT $LN13@ApplyWereW
$LN8@ApplyWereW:

; 157  : 	{
; 158  : 	case WEREWOLF_SET:
; 159  : 		if( pWereWolf )

  00091	85 f6		 test	 esi, esi
  00093	74 1d		 je	 SHORT $LN7@ApplyWereW

; 160  : 		{
; 161  : 			pWereWolf->SetChangeWereWolfState( this );

  00095	8b 06		 mov	 eax, DWORD PTR [esi]
  00097	57		 push	 edi
  00098	8b ce		 mov	 ecx, esi
  0009a	ff 90 64 02 00
	00		 call	 DWORD PTR [eax+612]
$LN13@ApplyWereW:

; 162  : 			pWereWolf->SetCurChangeDamage( fCurChangeDamage );

  000a0	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fCurChangeDamage$[ebp]
  000a5	51		 push	 ecx
  000a6	8b ce		 mov	 ecx, esi
  000a8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ad	e8 00 00 00 00	 call	 ?SetCurChangeDamage@ioWereWolfItem@@QAEXM@Z ; ioWereWolfItem::SetCurChangeDamage
$LN7@ApplyWereW:
  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi

; 189  : 	}
; 190  : }

  000b4	c9		 leave
  000b5	c2 04 00	 ret	 4
?ApplyWereWolfState@ioBaseChar@@QAEXAAVSP2Packet@@@Z ENDP ; ioBaseChar::ApplyWereWolfState
_TEXT	ENDS
PUBLIC	?FillWereWolfStateInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ; ioBaseChar::FillWereWolfStateInfo
EXTRN	??6SP2Packet@@QAEAAV0@M@Z:PROC			; SP2Packet::operator<<
EXTRN	?GetCurChangeDamage@ioWereWolfItem@@QAEMXZ:PROC	; ioWereWolfItem::GetCurChangeDamage
EXTRN	?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ:PROC ; ioBaseChar::GetWeapon
; Function compile flags: /Ogsp
;	COMDAT ?FillWereWolfStateInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z
_TEXT	SEGMENT
_rkPacket$ = 8						; size = 4
?FillWereWolfStateInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z PROC ; ioBaseChar::FillWereWolfStateInfo, COMDAT
; _this$ = ecx

; 193  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 194  : 	ioWereWolfItem *pWereWolf = ToWereWolfItem( GetWeapon() );

  00003	e8 00 00 00 00	 call	 ?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ ; ioBaseChar::GetWeapon
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ?ToWereWolfItem@@YAPAVioWereWolfItem@@PAVioItem@@@Z ; ToWereWolfItem
  0000e	59		 pop	 ecx

; 195  : 	if( !pWereWolf )

  0000f	85 c0		 test	 eax, eax
  00011	74 13		 je	 SHORT $LN2@FillWereWo

; 196  : 		return;
; 197  : 
; 198  : 	rkPacket << pWereWolf->GetCurChangeDamage();

  00013	8b c8		 mov	 ecx, eax
  00015	e8 00 00 00 00	 call	 ?GetCurChangeDamage@ioWereWolfItem@@QAEMXZ ; ioWereWolfItem::GetCurChangeDamage
  0001a	51		 push	 ecx
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _rkPacket$[ebp]
  0001e	d9 1c 24	 fstp	 DWORD PTR [esp]
  00021	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@M@Z ; SP2Packet::operator<<
$LN2@FillWereWo:

; 199  : 	return;
; 200  : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?FillWereWolfStateInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ENDP ; ioBaseChar::FillWereWolfStateInfo
_TEXT	ENDS
PUBLIC	?SetWereWolfStateInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ; ioBaseChar::SetWereWolfStateInfo
EXTRN	?ApplyChangeWereWolfState@ioWereWolfItem@@QAEXPAVioBaseChar@@@Z:PROC ; ioWereWolfItem::ApplyChangeWereWolfState
; Function compile flags: /Ogsp
;	COMDAT ?SetWereWolfStateInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z
_TEXT	SEGMENT
_fCurChangeDamage$ = 8					; size = 4
_rkPacket$ = 8						; size = 4
?SetWereWolfStateInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z PROC ; ioBaseChar::SetWereWolfStateInfo, COMDAT
; _this$ = ecx

; 203  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 204  : 	float fCurChangeDamage;
; 205  : 	rkPacket >> fCurChangeDamage;

  00005	8d 45 08	 lea	 eax, DWORD PTR _fCurChangeDamage$[ebp]
  00008	8b f9		 mov	 edi, ecx
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _rkPacket$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??5SP2Packet@@QAEAAV0@AAM@Z ; SP2Packet::operator>>

; 206  : 
; 207  : 	ioWereWolfItem *pWereWolf = ToWereWolfItem( GetWeapon() );

  00013	8b cf		 mov	 ecx, edi
  00015	e8 00 00 00 00	 call	 ?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ ; ioBaseChar::GetWeapon
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?ToWereWolfItem@@YAPAVioWereWolfItem@@PAVioItem@@@Z ; ToWereWolfItem
  00020	8b f0		 mov	 esi, eax
  00022	59		 pop	 ecx

; 208  : 	if( pWereWolf )

  00023	85 f6		 test	 esi, esi
  00025	74 1a		 je	 SHORT $LN1@SetWereWol

; 209  : 	{
; 210  : 		pWereWolf->ApplyChangeWereWolfState( this );

  00027	57		 push	 edi
  00028	8b ce		 mov	 ecx, esi
  0002a	e8 00 00 00 00	 call	 ?ApplyChangeWereWolfState@ioWereWolfItem@@QAEXPAVioBaseChar@@@Z ; ioWereWolfItem::ApplyChangeWereWolfState

; 211  : 		pWereWolf->SetCurChangeDamage( fCurChangeDamage );

  0002f	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fCurChangeDamage$[ebp]
  00034	51		 push	 ecx
  00035	8b ce		 mov	 ecx, esi
  00037	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003c	e8 00 00 00 00	 call	 ?SetCurChangeDamage@ioWereWolfItem@@QAEXM@Z ; ioWereWolfItem::SetCurChangeDamage
$LN1@SetWereWol:
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi

; 212  : 	}
; 213  : }

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?SetWereWolfStateInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ENDP ; ioBaseChar::SetWereWolfStateInfo
_TEXT	ENDS
PUBLIC	?CheckObjectSylphid@ioBaseChar@@QAE_N_N@Z	; ioBaseChar::CheckObjectSylphid
EXTRN	?DecreaseCoolTime@ioRachelItem@@QAEXH@Z:PROC	; ioRachelItem::DecreaseCoolTime
EXTRN	?CheckSetWeaponSylphid@ioWeaponManager@@QAEHPAVioBaseChar@@@Z:PROC ; ioWeaponManager::CheckSetWeaponSylphid
EXTRN	?GetSingleton@ioWeaponManager@@SAAAV1@XZ:PROC	; ioWeaponManager::GetSingleton
; Function compile flags: /Ogsp
;	COMDAT ?CheckObjectSylphid@ioBaseChar@@QAE_N_N@Z
_TEXT	SEGMENT
_bCheckBullet$ = 8					; size = 1
?CheckObjectSylphid@ioBaseChar@@QAE_N_N@Z PROC		; ioBaseChar::CheckObjectSylphid, COMDAT
; _this$ = ecx

; 536  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 537  : 	ioRachelItem *pRachelItem = ToRachelItem( GetPriorityItem( SPT_ATTACK ) );

  00005	6a 05		 push	 5
  00007	8b f9		 mov	 edi, ecx
  00009	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?ToRachelItem@@YAPAVioRachelItem@@PAVioItem@@@Z ; ToRachelItem
  00014	8b f0		 mov	 esi, eax
  00016	59		 pop	 ecx

; 538  : 	if( !pRachelItem )		//     ...

  00017	85 f6		 test	 esi, esi

; 539  : 		return false;

  00019	74 2e		 je	 SHORT $LN1@CheckObjec

; 540  : 
; 541  : 	if( bCheckBullet && pRachelItem->GetCurBullet() <= 0 )

  0001b	80 7d 08 00	 cmp	 BYTE PTR _bCheckBullet$[ebp], 0
  0001f	74 0b		 je	 SHORT $LN2@CheckObjec
  00021	8b 06		 mov	 eax, DWORD PTR [esi]
  00023	8b ce		 mov	 ecx, esi
  00025	ff 50 64	 call	 DWORD PTR [eax+100]
  00028	85 c0		 test	 eax, eax

; 542  : 		return false;

  0002a	7e 1d		 jle	 SHORT $LN1@CheckObjec
$LN2@CheckObjec:

; 543  : 
; 544  : 	int iNeedCnt = g_WeaponMgr.CheckSetWeaponSylphid( this );

  0002c	57		 push	 edi
  0002d	e8 00 00 00 00	 call	 ?GetSingleton@ioWeaponManager@@SAAAV1@XZ ; ioWeaponManager::GetSingleton
  00032	8b c8		 mov	 ecx, eax
  00034	e8 00 00 00 00	 call	 ?CheckSetWeaponSylphid@ioWeaponManager@@QAEHPAVioBaseChar@@@Z ; ioWeaponManager::CheckSetWeaponSylphid

; 545  : 	if( iNeedCnt > 0 )

  00039	85 c0		 test	 eax, eax
  0003b	7e 0c		 jle	 SHORT $LN1@CheckObjec

; 546  : 	{
; 547  : 		pRachelItem->DecreaseCoolTime( iNeedCnt );

  0003d	50		 push	 eax
  0003e	8b ce		 mov	 ecx, esi
  00040	e8 00 00 00 00	 call	 ?DecreaseCoolTime@ioRachelItem@@QAEXH@Z ; ioRachelItem::DecreaseCoolTime

; 548  : 		return true;

  00045	b0 01		 mov	 al, 1
  00047	eb 02		 jmp	 SHORT $LN4@CheckObjec
$LN1@CheckObjec:

; 549  : 	}
; 550  : 
; 551  : 	return false;

  00049	32 c0		 xor	 al, al
$LN4@CheckObjec:
  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi

; 552  : }

  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
?CheckObjectSylphid@ioBaseChar@@QAE_N_N@Z ENDP		; ioBaseChar::CheckObjectSylphid
_TEXT	ENDS
PUBLIC	?CheckIljimaeTarget@ioBaseChar@@IAEXXZ		; ioBaseChar::CheckIljimaeTarget
EXTRN	?CheckTargetRange@ioIljimaeItem@@QAEXPAVioPlayStage@@@Z:PROC ; ioIljimaeItem::CheckTargetRange
EXTRN	?CheckTargetDuration@ioIljimaeItem@@QAEXPAVioPlayStage@@@Z:PROC ; ioIljimaeItem::CheckTargetDuration
EXTRN	?GetEquipedItem@ioBaseChar@@QAEPAVioItem@@H@Z:PROC ; ioBaseChar::GetEquipedItem
; Function compile flags: /Ogsp
;	COMDAT ?CheckIljimaeTarget@ioBaseChar@@IAEXXZ
_TEXT	SEGMENT
?CheckIljimaeTarget@ioBaseChar@@IAEXXZ PROC		; ioBaseChar::CheckIljimaeTarget, COMDAT
; _this$ = ecx

; 654  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 655  : 	if( !IsNeedProcess() )	return;

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 90 00 01 00
	00		 call	 DWORD PTR [eax+256]
  0000b	84 c0		 test	 al, al
  0000d	74 32		 je	 SHORT $LN3@CheckIljim

; 656  : 
; 657  : 	ioItem *pItem = GetEquipedItem(ES_WEAPON);

  0000f	57		 push	 edi
  00010	6a 00		 push	 0
  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ?GetEquipedItem@ioBaseChar@@QAEPAVioItem@@H@Z ; ioBaseChar::GetEquipedItem

; 658  : 	ioIljimaeItem *pIljimaeItem = ToIljimaeItem( pItem );

  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?ToIljimaeItem@@YAPAVioIljimaeItem@@PAVioItem@@@Z ; ToIljimaeItem
  0001f	8b f8		 mov	 edi, eax
  00021	59		 pop	 ecx

; 659  : 	if( !pIljimaeItem )

  00022	85 ff		 test	 edi, edi
  00024	74 1a		 je	 SHORT $LN5@CheckIljim

; 660  : 	{
; 661  : 		return;
; 662  : 	}
; 663  : 	pIljimaeItem->CheckTargetDuration( m_pCreator );

  00026	ff b6 44 03 00
	00		 push	 DWORD PTR [esi+836]
  0002c	8b cf		 mov	 ecx, edi
  0002e	e8 00 00 00 00	 call	 ?CheckTargetDuration@ioIljimaeItem@@QAEXPAVioPlayStage@@@Z ; ioIljimaeItem::CheckTargetDuration

; 664  : 	pIljimaeItem->CheckTargetRange( m_pCreator );

  00033	ff b6 44 03 00
	00		 push	 DWORD PTR [esi+836]
  00039	8b cf		 mov	 ecx, edi
  0003b	e8 00 00 00 00	 call	 ?CheckTargetRange@ioIljimaeItem@@QAEXPAVioPlayStage@@@Z ; ioIljimaeItem::CheckTargetRange
$LN5@CheckIljim:
  00040	5f		 pop	 edi
$LN3@CheckIljim:
  00041	5e		 pop	 esi

; 665  : }

  00042	c3		 ret	 0
?CheckIljimaeTarget@ioBaseChar@@IAEXXZ ENDP		; ioBaseChar::CheckIljimaeTarget
_TEXT	ENDS
PUBLIC	?SetWitchFlyStateSkill@ioBaseChar@@QAE_NABVioHashString@@ABUtagWitchFlyInfo@@@Z ; ioBaseChar::SetWitchFlyStateSkill
EXTRN	?SetWitchFlyBuffName@ioWitchFlySpecialState@@QAEXVioHashString@@@Z:PROC ; ioWitchFlySpecialState::SetWitchFlyBuffName
EXTRN	__imp_??0ioHashString@@QAE@ABV0@@Z:PROC
EXTRN	?SetWitchFlyState@ioWitchItem@@QAEXPAVioBaseChar@@ABUtagWitchFlyInfo@@_N@Z:PROC ; ioWitchItem::SetWitchFlyState
; Function compile flags: /Ogsp
;	COMDAT ?SetWitchFlyStateSkill@ioBaseChar@@QAE_NABVioHashString@@ABUtagWitchFlyInfo@@@Z
_TEXT	SEGMENT
_szBuffName$ = 8					; size = 4
$T613070 = 12						; size = 4
_rkWitchFlyInfo$ = 12					; size = 4
?SetWitchFlyStateSkill@ioBaseChar@@QAE_NABVioHashString@@ABUtagWitchFlyInfo@@@Z PROC ; ioBaseChar::SetWitchFlyStateSkill, COMDAT
; _this$ = ecx

; 669  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 670  : 	ioWitchItem *pWitchItem = ToWitchItem( GetPriorityItem( SPT_ATTACK ) );

  00004	6a 05		 push	 5
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?ToWitchItem@@YAPAVioWitchItem@@PAVioItem@@@Z ; ToWitchItem
  00013	59		 pop	 ecx

; 671  : 	if( pWitchItem )

  00014	85 c0		 test	 eax, eax
  00016	74 0d		 je	 SHORT $LN2@SetWitchFl

; 672  : 		pWitchItem->SetWitchFlyState( this, rkWitchFlyInfo, true );

  00018	6a 01		 push	 1
  0001a	ff 75 0c	 push	 DWORD PTR _rkWitchFlyInfo$[ebp]
  0001d	8b c8		 mov	 ecx, eax
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 ?SetWitchFlyState@ioWitchItem@@QAEXPAVioBaseChar@@ABUtagWitchFlyInfo@@_N@Z ; ioWitchItem::SetWitchFlyState
$LN2@SetWitchFl:

; 673  : 
; 674  : 	ioWitchFlySpecialState *pWitchFlySpecialState = ToWitchFlySpecialState( m_pCharSpeicalState );

  00025	ff b6 14 03 00
	00		 push	 DWORD PTR [esi+788]
  0002b	e8 00 00 00 00	 call	 ?ToWitchFlySpecialState@@YAPAVioWitchFlySpecialState@@PAVioSpecialStateBase@@@Z ; ToWitchFlySpecialState
  00030	8b f0		 mov	 esi, eax
  00032	59		 pop	 ecx

; 675  : 	if ( pWitchFlySpecialState )

  00033	85 f6		 test	 esi, esi
  00035	74 18		 je	 SHORT $LN1@SetWitchFl

; 676  : 		pWitchFlySpecialState->SetWitchFlyBuffName( szBuffName );

  00037	83 ec 10	 sub	 esp, 16			; 00000010H
  0003a	8b cc		 mov	 ecx, esp
  0003c	89 65 0c	 mov	 DWORD PTR $T613070[ebp], esp
  0003f	ff 75 08	 push	 DWORD PTR _szBuffName$[ebp]
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  00048	8b ce		 mov	 ecx, esi
  0004a	e8 00 00 00 00	 call	 ?SetWitchFlyBuffName@ioWitchFlySpecialState@@QAEXVioHashString@@@Z ; ioWitchFlySpecialState::SetWitchFlyBuffName
$LN1@SetWitchFl:

; 677  : 
; 678  : 	return true;

  0004f	b0 01		 mov	 al, 1

; 679  : }

  00051	5e		 pop	 esi
  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
?SetWitchFlyStateSkill@ioBaseChar@@QAE_NABVioHashString@@ABUtagWitchFlyInfo@@@Z ENDP ; ioBaseChar::SetWitchFlyStateSkill
_TEXT	ENDS
PUBLIC	?CheckEnableWitchGauge@ioBaseChar@@QAEXXZ	; ioBaseChar::CheckEnableWitchGauge
EXTRN	?CheckEnableWitchGauge@ioWitchItem@@QAEXPAVioBaseChar@@@Z:PROC ; ioWitchItem::CheckEnableWitchGauge
; Function compile flags: /Ogsp
;	COMDAT ?CheckEnableWitchGauge@ioBaseChar@@QAEXXZ
_TEXT	SEGMENT
?CheckEnableWitchGauge@ioBaseChar@@QAEXXZ PROC		; ioBaseChar::CheckEnableWitchGauge, COMDAT
; _this$ = ecx

; 682  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 683  : 	if( !IsNeedProcess() )

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 90 00 01 00
	00		 call	 DWORD PTR [eax+256]
  0000b	84 c0		 test	 al, al
  0000d	74 30		 je	 SHORT $LN1@CheckEnabl@2

; 684  : 		return;
; 685  : 
; 686  : 	if( !CheckGrapplingExceptionState() )

  0000f	8b ce		 mov	 ecx, esi
  00011	e8 00 00 00 00	 call	 ?CheckGrapplingExceptionState@ioBaseChar@@QAE_NXZ ; ioBaseChar::CheckGrapplingExceptionState
  00016	84 c0		 test	 al, al
  00018	74 25		 je	 SHORT $LN1@CheckEnabl@2

; 687  : 		return;
; 688  : 
; 689  : 	if( m_CharState == CS_WITCH_FLY )

  0001a	80 be 10 03 00
	00 4e		 cmp	 BYTE PTR [esi+784], 78	; 0000004eH
  00021	74 1c		 je	 SHORT $LN1@CheckEnabl@2

; 690  : 		return;
; 691  : 
; 692  : 	ioWitchItem *pWitchItem = ToWitchItem( GetPriorityItem( SPT_ATTACK ) );

  00023	6a 05		 push	 5
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?ToWitchItem@@YAPAVioWitchItem@@PAVioItem@@@Z ; ToWitchItem
  00032	59		 pop	 ecx

; 693  : 	if( pWitchItem )

  00033	85 c0		 test	 eax, eax
  00035	74 08		 je	 SHORT $LN1@CheckEnabl@2

; 694  : 		pWitchItem->CheckEnableWitchGauge( this );

  00037	56		 push	 esi
  00038	8b c8		 mov	 ecx, eax
  0003a	e8 00 00 00 00	 call	 ?CheckEnableWitchGauge@ioWitchItem@@QAEXPAVioBaseChar@@@Z ; ioWitchItem::CheckEnableWitchGauge
$LN1@CheckEnabl@2:
  0003f	5e		 pop	 esi

; 695  : }

  00040	c3		 ret	 0
?CheckEnableWitchGauge@ioBaseChar@@QAEXXZ ENDP		; ioBaseChar::CheckEnableWitchGauge
_TEXT	ENDS
PUBLIC	?ApplyWitchState@ioBaseChar@@QAEXAAVSP2Packet@@@Z ; ioBaseChar::ApplyWitchState
EXTRN	?SetCurWitchGauge@ioWitchItem@@QAEXM@Z:PROC	; ioWitchItem::SetCurWitchGauge
EXTRN	?SetEnableWitchEffect@ioWitchItem@@QAEXPAVioBaseChar@@@Z:PROC ; ioWitchItem::SetEnableWitchEffect
; Function compile flags: /Ogsp
;	COMDAT ?ApplyWitchState@ioBaseChar@@QAEXAAVSP2Packet@@@Z
_TEXT	SEGMENT
_fCurWitchGauge$ = -8					; size = 4
_iType$ = -4						; size = 4
_rkPacket$ = 8						; size = 4
?ApplyWitchState@ioBaseChar@@QAEXAAVSP2Packet@@@Z PROC	; ioBaseChar::ApplyWitchState, COMDAT
; _this$ = ecx

; 698  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 699  : 	int iType;
; 700  : 	rkPacket >> iType;

  00007	8d 45 fc	 lea	 eax, DWORD PTR _iType$[ebp]
  0000a	8b f1		 mov	 esi, ecx
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _rkPacket$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??5SP2Packet@@QAEAAV0@AAH@Z ; SP2Packet::operator>>

; 701  : 
; 702  : 	float fCurWitchGauge;
; 703  : 	rkPacket >> fCurWitchGauge;

  00015	8b 4d 08	 mov	 ecx, DWORD PTR _rkPacket$[ebp]
  00018	8d 45 f8	 lea	 eax, DWORD PTR _fCurWitchGauge$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??5SP2Packet@@QAEAAV0@AAM@Z ; SP2Packet::operator>>

; 704  : 
; 705  : 	ioWitchItem *pWitchItem = ToWitchItem( m_pEquipSlot->GetWeapon() );

  00021	8b 8e 48 03 00
	00		 mov	 ecx, DWORD PTR [esi+840]
  00027	e8 00 00 00 00	 call	 ?GetWeapon@ioEquipSlot@@QBEPAVioWeaponItem@@XZ ; ioEquipSlot::GetWeapon
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?ToWitchItem@@YAPAVioWitchItem@@PAVioItem@@@Z ; ToWitchItem
  00032	8b f8		 mov	 edi, eax

; 706  : 	switch( iType )

  00034	8b 45 fc	 mov	 eax, DWORD PTR _iType$[ebp]
  00037	48		 dec	 eax
  00038	59		 pop	 ecx
  00039	75 1e		 jne	 SHORT $LN1@ApplyWitch

; 707  : 	{
; 708  : 	case WITCH_ENABLE_GAUGE:
; 709  : 		if( pWitchItem )

  0003b	85 ff		 test	 edi, edi
  0003d	74 1a		 je	 SHORT $LN1@ApplyWitch

; 710  : 		{
; 711  : 			pWitchItem->SetEnableWitchEffect( this );

  0003f	56		 push	 esi
  00040	8b cf		 mov	 ecx, edi
  00042	e8 00 00 00 00	 call	 ?SetEnableWitchEffect@ioWitchItem@@QAEXPAVioBaseChar@@@Z ; ioWitchItem::SetEnableWitchEffect

; 712  : 			pWitchItem->SetCurWitchGauge( fCurWitchGauge );

  00047	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fCurWitchGauge$[ebp]
  0004c	51		 push	 ecx
  0004d	8b cf		 mov	 ecx, edi
  0004f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00054	e8 00 00 00 00	 call	 ?SetCurWitchGauge@ioWitchItem@@QAEXM@Z ; ioWitchItem::SetCurWitchGauge
$LN1@ApplyWitch:
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi

; 713  : 		}
; 714  : 		break;
; 715  : 	}
; 716  : }

  0005b	c9		 leave
  0005c	c2 04 00	 ret	 4
?ApplyWitchState@ioBaseChar@@QAEXAAVSP2Packet@@@Z ENDP	; ioBaseChar::ApplyWitchState
_TEXT	ENDS
PUBLIC	?SetMechanicsFlyState@ioBaseChar@@QAE_NABUtagMechanicsFlyInfo@@@Z ; ioBaseChar::SetMechanicsFlyState
EXTRN	?SetMechanicsFlyState@ioMechanicsItem@@QAEXPAVioBaseChar@@ABUtagMechanicsFlyInfo@@_N@Z:PROC ; ioMechanicsItem::SetMechanicsFlyState
; Function compile flags: /Ogsp
;	COMDAT ?SetMechanicsFlyState@ioBaseChar@@QAE_NABUtagMechanicsFlyInfo@@@Z
_TEXT	SEGMENT
_rkFlyInfo$ = 8						; size = 4
?SetMechanicsFlyState@ioBaseChar@@QAE_NABUtagMechanicsFlyInfo@@@Z PROC ; ioBaseChar::SetMechanicsFlyState, COMDAT
; _this$ = ecx

; 720  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 721  : 	ioMechanicsItem *pMechanics = ToMechanicsItem( GetPriorityItem( SPT_ATTACK ) );

  00004	6a 05		 push	 5
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?ToMechanicsItem@@YAPAVioMechanicsItem@@PAVioItem@@@Z ; ToMechanicsItem
  00013	59		 pop	 ecx

; 722  : 	if( !pMechanics )

  00014	85 c0		 test	 eax, eax
  00016	75 04		 jne	 SHORT $LN1@SetMechani

; 723  : 		return false;

  00018	32 c0		 xor	 al, al
  0001a	eb 0f		 jmp	 SHORT $LN2@SetMechani
$LN1@SetMechani:

; 724  : 
; 725  : 	pMechanics->SetMechanicsFlyState( this, rkFlyInfo, false );

  0001c	6a 00		 push	 0
  0001e	ff 75 08	 push	 DWORD PTR _rkFlyInfo$[ebp]
  00021	8b c8		 mov	 ecx, eax
  00023	56		 push	 esi
  00024	e8 00 00 00 00	 call	 ?SetMechanicsFlyState@ioMechanicsItem@@QAEXPAVioBaseChar@@ABUtagMechanicsFlyInfo@@_N@Z ; ioMechanicsItem::SetMechanicsFlyState

; 726  : 	return true;

  00029	b0 01		 mov	 al, 1
$LN2@SetMechani:
  0002b	5e		 pop	 esi

; 727  : }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?SetMechanicsFlyState@ioBaseChar@@QAE_NABUtagMechanicsFlyInfo@@@Z ENDP ; ioBaseChar::SetMechanicsFlyState
_TEXT	ENDS
PUBLIC	?SetMechanicsFlyStateSkill@ioBaseChar@@QAE_NABVioHashString@@ABUtagMechanicsFlyInfo@@@Z ; ioBaseChar::SetMechanicsFlyStateSkill
EXTRN	__imp_??4ioHashString@@QAEAAV0@ABV0@@Z:PROC
; Function compile flags: /Ogsp
;	COMDAT ?SetMechanicsFlyStateSkill@ioBaseChar@@QAE_NABVioHashString@@ABUtagMechanicsFlyInfo@@@Z
_TEXT	SEGMENT
_szBuffName$ = 8					; size = 4
_rkFlyInfo$ = 12					; size = 4
?SetMechanicsFlyStateSkill@ioBaseChar@@QAE_NABVioHashString@@ABUtagMechanicsFlyInfo@@@Z PROC ; ioBaseChar::SetMechanicsFlyStateSkill, COMDAT
; _this$ = ecx

; 730  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 731  : 	ioMechanicsItem *pMechanics = ToMechanicsItem( GetPriorityItem( SPT_ATTACK ) );

  00004	6a 05		 push	 5
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?ToMechanicsItem@@YAPAVioMechanicsItem@@PAVioItem@@@Z ; ToMechanicsItem
  00013	59		 pop	 ecx

; 732  : 	if( pMechanics )

  00014	85 c0		 test	 eax, eax
  00016	74 20		 je	 SHORT $LN2@SetMechani@2

; 733  : 		pMechanics->SetMechanicsFlyState( this, rkFlyInfo, false );

  00018	6a 00		 push	 0
  0001a	ff 75 0c	 push	 DWORD PTR _rkFlyInfo$[ebp]
  0001d	8b c8		 mov	 ecx, eax
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 ?SetMechanicsFlyState@ioMechanicsItem@@QAEXPAVioBaseChar@@ABUtagMechanicsFlyInfo@@_N@Z ; ioMechanicsItem::SetMechanicsFlyState

; 736  : 
; 737  : 	m_MechanicsBuffName = szBuffName;

  00025	ff 75 08	 push	 DWORD PTR _szBuffName$[ebp]
  00028	8d 8e 30 20 00
	00		 lea	 ecx, DWORD PTR [esi+8240]
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@ABV0@@Z

; 738  : 	return true;

  00034	b0 01		 mov	 al, 1
  00036	eb 02		 jmp	 SHORT $LN3@SetMechani@2
$LN2@SetMechani@2:

; 734  : 	else
; 735  : 		return false;

  00038	32 c0		 xor	 al, al
$LN3@SetMechani@2:
  0003a	5e		 pop	 esi

; 739  : }

  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
?SetMechanicsFlyStateSkill@ioBaseChar@@QAE_NABVioHashString@@ABUtagMechanicsFlyInfo@@@Z ENDP ; ioBaseChar::SetMechanicsFlyStateSkill
_TEXT	ENDS
PUBLIC	?CheckEnableMechanicsGauge@ioBaseChar@@QAEXXZ	; ioBaseChar::CheckEnableMechanicsGauge
EXTRN	?CheckEnableMechanicsGauge@ioMechanicsItem@@QAEXPAVioBaseChar@@@Z:PROC ; ioMechanicsItem::CheckEnableMechanicsGauge
; Function compile flags: /Ogsp
;	COMDAT ?CheckEnableMechanicsGauge@ioBaseChar@@QAEXXZ
_TEXT	SEGMENT
?CheckEnableMechanicsGauge@ioBaseChar@@QAEXXZ PROC	; ioBaseChar::CheckEnableMechanicsGauge, COMDAT
; _this$ = ecx

; 742  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 743  : 	if( !IsNeedProcess() )

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 90 00 01 00
	00		 call	 DWORD PTR [eax+256]
  0000b	84 c0		 test	 al, al
  0000d	74 30		 je	 SHORT $LN1@CheckEnabl@3

; 744  : 		return;
; 745  : 
; 746  : 	if( !CheckGrapplingExceptionState() )

  0000f	8b ce		 mov	 ecx, esi
  00011	e8 00 00 00 00	 call	 ?CheckGrapplingExceptionState@ioBaseChar@@QAE_NXZ ; ioBaseChar::CheckGrapplingExceptionState
  00016	84 c0		 test	 al, al
  00018	74 25		 je	 SHORT $LN1@CheckEnabl@3

; 747  : 		return;
; 748  : 
; 749  : 	if( m_CharState == CS_MECHANICS_FLY )

  0001a	80 be 10 03 00
	00 50		 cmp	 BYTE PTR [esi+784], 80	; 00000050H
  00021	74 1c		 je	 SHORT $LN1@CheckEnabl@3

; 750  : 		return;
; 751  : 
; 752  : 	ioMechanicsItem *pMechanics = ToMechanicsItem( GetPriorityItem( SPT_ATTACK ) );

  00023	6a 05		 push	 5
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?ToMechanicsItem@@YAPAVioMechanicsItem@@PAVioItem@@@Z ; ToMechanicsItem
  00032	59		 pop	 ecx

; 753  : 	if( pMechanics )

  00033	85 c0		 test	 eax, eax
  00035	74 08		 je	 SHORT $LN1@CheckEnabl@3

; 754  : 		pMechanics->CheckEnableMechanicsGauge( this );

  00037	56		 push	 esi
  00038	8b c8		 mov	 ecx, eax
  0003a	e8 00 00 00 00	 call	 ?CheckEnableMechanicsGauge@ioMechanicsItem@@QAEXPAVioBaseChar@@@Z ; ioMechanicsItem::CheckEnableMechanicsGauge
$LN1@CheckEnabl@3:
  0003f	5e		 pop	 esi

; 755  : }

  00040	c3		 ret	 0
?CheckEnableMechanicsGauge@ioBaseChar@@QAEXXZ ENDP	; ioBaseChar::CheckEnableMechanicsGauge
_TEXT	ENDS
PUBLIC	?IsEnableMechanicsFly@ioBaseChar@@QAE_NXZ	; ioBaseChar::IsEnableMechanicsFly
EXTRN	?IsHasCrown@ioBaseChar@@QBE_NXZ:PROC		; ioBaseChar::IsHasCrown
EXTRN	?IsEnableMechanicsGauge@ioMechanicsItem@@QAE_NXZ:PROC ; ioMechanicsItem::IsEnableMechanicsGauge
; Function compile flags: /Ogsp
;	COMDAT ?IsEnableMechanicsFly@ioBaseChar@@QAE_NXZ
_TEXT	SEGMENT
?IsEnableMechanicsFly@ioBaseChar@@QAE_NXZ PROC		; ioBaseChar::IsEnableMechanicsFly, COMDAT
; _this$ = ecx

; 758  : {

  00000	56		 push	 esi

; 759  : 	ioMechanicsItem *pMechanics = ToMechanicsItem( GetPriorityItem( SPT_ATTACK ) );

  00001	6a 05		 push	 5
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?ToMechanicsItem@@YAPAVioMechanicsItem@@PAVioItem@@@Z ; ToMechanicsItem
  00010	59		 pop	 ecx

; 760  : 	if( !pMechanics )

  00011	85 c0		 test	 eax, eax

; 761  : 		return false;

  00013	74 1a		 je	 SHORT $LN1@IsEnableMe

; 762  : 
; 763  : 	if( pMechanics->IsEnableMechanicsGauge() && !IsHasCrown() )

  00015	8b c8		 mov	 ecx, eax
  00017	e8 00 00 00 00	 call	 ?IsEnableMechanicsGauge@ioMechanicsItem@@QAE_NXZ ; ioMechanicsItem::IsEnableMechanicsGauge
  0001c	84 c0		 test	 al, al
  0001e	74 0f		 je	 SHORT $LN1@IsEnableMe
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?IsHasCrown@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsHasCrown
  00027	84 c0		 test	 al, al
  00029	75 04		 jne	 SHORT $LN1@IsEnableMe

; 764  : 		return true;

  0002b	fe c0		 inc	 al
  0002d	5e		 pop	 esi

; 767  : }

  0002e	c3		 ret	 0
$LN1@IsEnableMe:

; 765  : 
; 766  : 	return false;

  0002f	32 c0		 xor	 al, al
  00031	5e		 pop	 esi

; 767  : }

  00032	c3		 ret	 0
?IsEnableMechanicsFly@ioBaseChar@@QAE_NXZ ENDP		; ioBaseChar::IsEnableMechanicsFly
_TEXT	ENDS
PUBLIC	?SetPhantomFlyStateAttack@ioBaseChar@@QAE_NXZ	; ioBaseChar::SetPhantomFlyStateAttack
EXTRN	?SetPhantomFlyStateAttack@ioPhantomItem@@QAEXPAVioBaseChar@@@Z:PROC ; ioPhantomItem::SetPhantomFlyStateAttack
; Function compile flags: /Ogsp
;	COMDAT ?SetPhantomFlyStateAttack@ioBaseChar@@QAE_NXZ
_TEXT	SEGMENT
?SetPhantomFlyStateAttack@ioBaseChar@@QAE_NXZ PROC	; ioBaseChar::SetPhantomFlyStateAttack, COMDAT
; _this$ = ecx

; 771  : {

  00000	56		 push	 esi

; 772  : 	ioPhantomItem *pPhantom = ToPhantomItem( GetPriorityItem( SPT_ATTACK ) );

  00001	6a 05		 push	 5
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?ToPhantomItem@@YAPAVioPhantomItem@@PAVioItem@@@Z ; ToPhantomItem
  00010	59		 pop	 ecx

; 773  : 	if( !pPhantom )

  00011	85 c0		 test	 eax, eax
  00013	75 04		 jne	 SHORT $LN1@SetPhantom

; 774  : 		return false;

  00015	32 c0		 xor	 al, al
  00017	5e		 pop	 esi

; 778  : }

  00018	c3		 ret	 0
$LN1@SetPhantom:

; 775  : 
; 776  : 	pPhantom->SetPhantomFlyStateAttack( this );

  00019	56		 push	 esi
  0001a	8b c8		 mov	 ecx, eax
  0001c	e8 00 00 00 00	 call	 ?SetPhantomFlyStateAttack@ioPhantomItem@@QAEXPAVioBaseChar@@@Z ; ioPhantomItem::SetPhantomFlyStateAttack

; 777  : 	return true;

  00021	b0 01		 mov	 al, 1
  00023	5e		 pop	 esi

; 778  : }

  00024	c3		 ret	 0
?SetPhantomFlyStateAttack@ioBaseChar@@QAE_NXZ ENDP	; ioBaseChar::SetPhantomFlyStateAttack
_TEXT	ENDS
PUBLIC	?SetPhantomFlyState@ioBaseChar@@QAE_NABUtagPhantomFlyInfo@@@Z ; ioBaseChar::SetPhantomFlyState
EXTRN	?SetPhantomFlyState@ioPhantomItem@@QAEXPAVioBaseChar@@ABUtagPhantomFlyInfo@@_N@Z:PROC ; ioPhantomItem::SetPhantomFlyState
; Function compile flags: /Ogsp
;	COMDAT ?SetPhantomFlyState@ioBaseChar@@QAE_NABUtagPhantomFlyInfo@@@Z
_TEXT	SEGMENT
_rkFlyInfo$ = 8						; size = 4
?SetPhantomFlyState@ioBaseChar@@QAE_NABUtagPhantomFlyInfo@@@Z PROC ; ioBaseChar::SetPhantomFlyState, COMDAT
; _this$ = ecx

; 781  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 782  : 	ioPhantomItem *pPhantom = ToPhantomItem( GetPriorityItem( SPT_ATTACK ) );

  00004	6a 05		 push	 5
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?ToPhantomItem@@YAPAVioPhantomItem@@PAVioItem@@@Z ; ToPhantomItem
  00013	59		 pop	 ecx

; 783  : 	if( !pPhantom )

  00014	85 c0		 test	 eax, eax
  00016	75 04		 jne	 SHORT $LN1@SetPhantom@2

; 784  : 		return false;

  00018	32 c0		 xor	 al, al
  0001a	eb 0f		 jmp	 SHORT $LN2@SetPhantom@2
$LN1@SetPhantom@2:

; 785  : 
; 786  : 	pPhantom->SetPhantomFlyState( this, rkFlyInfo, false );

  0001c	6a 00		 push	 0
  0001e	ff 75 08	 push	 DWORD PTR _rkFlyInfo$[ebp]
  00021	8b c8		 mov	 ecx, eax
  00023	56		 push	 esi
  00024	e8 00 00 00 00	 call	 ?SetPhantomFlyState@ioPhantomItem@@QAEXPAVioBaseChar@@ABUtagPhantomFlyInfo@@_N@Z ; ioPhantomItem::SetPhantomFlyState

; 787  : 	return true;

  00029	b0 01		 mov	 al, 1
$LN2@SetPhantom@2:
  0002b	5e		 pop	 esi

; 788  : }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?SetPhantomFlyState@ioBaseChar@@QAE_NABUtagPhantomFlyInfo@@@Z ENDP ; ioBaseChar::SetPhantomFlyState
_TEXT	ENDS
PUBLIC	?SetPhantomFlyStateSkill@ioBaseChar@@QAE_NABVioHashString@@ABUtagPhantomFlyInfo@@@Z ; ioBaseChar::SetPhantomFlyStateSkill
; Function compile flags: /Ogsp
;	COMDAT ?SetPhantomFlyStateSkill@ioBaseChar@@QAE_NABVioHashString@@ABUtagPhantomFlyInfo@@@Z
_TEXT	SEGMENT
_szBuffName$ = 8					; size = 4
_rkFlyInfo$ = 12					; size = 4
?SetPhantomFlyStateSkill@ioBaseChar@@QAE_NABVioHashString@@ABUtagPhantomFlyInfo@@@Z PROC ; ioBaseChar::SetPhantomFlyStateSkill, COMDAT
; _this$ = ecx

; 791  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 792  : 	ioPhantomItem *pPhantom = ToPhantomItem( GetPriorityItem( SPT_ATTACK ) );

  00004	6a 05		 push	 5
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?ToPhantomItem@@YAPAVioPhantomItem@@PAVioItem@@@Z ; ToPhantomItem
  00013	59		 pop	 ecx

; 793  : 	if( pPhantom )

  00014	85 c0		 test	 eax, eax
  00016	74 11		 je	 SHORT $LN2@SetPhantom@3

; 794  : 		pPhantom->SetPhantomFlyState( this, rkFlyInfo, false );

  00018	6a 00		 push	 0
  0001a	ff 75 0c	 push	 DWORD PTR _rkFlyInfo$[ebp]
  0001d	8b c8		 mov	 ecx, eax
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 ?SetPhantomFlyState@ioPhantomItem@@QAEXPAVioBaseChar@@ABUtagPhantomFlyInfo@@_N@Z ; ioPhantomItem::SetPhantomFlyState

; 797  : 
; 798  : 	//m_MechanicsBuffName = szBuffName;
; 799  : 	return true;

  00025	b0 01		 mov	 al, 1
  00027	eb 02		 jmp	 SHORT $LN3@SetPhantom@3
$LN2@SetPhantom@3:

; 795  : 	else
; 796  : 		return false;

  00029	32 c0		 xor	 al, al
$LN3@SetPhantom@3:
  0002b	5e		 pop	 esi

; 800  : }

  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?SetPhantomFlyStateSkill@ioBaseChar@@QAE_NABVioHashString@@ABUtagPhantomFlyInfo@@@Z ENDP ; ioBaseChar::SetPhantomFlyStateSkill
_TEXT	ENDS
PUBLIC	?CheckEnablePhantomGauge@ioBaseChar@@QAEXXZ	; ioBaseChar::CheckEnablePhantomGauge
EXTRN	?CheckEnablePhantomGauge@ioPhantomItem@@QAEXPAVioBaseChar@@@Z:PROC ; ioPhantomItem::CheckEnablePhantomGauge
; Function compile flags: /Ogsp
;	COMDAT ?CheckEnablePhantomGauge@ioBaseChar@@QAEXXZ
_TEXT	SEGMENT
?CheckEnablePhantomGauge@ioBaseChar@@QAEXXZ PROC	; ioBaseChar::CheckEnablePhantomGauge, COMDAT
; _this$ = ecx

; 803  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 804  : 	if( !IsNeedProcess() )

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 90 00 01 00
	00		 call	 DWORD PTR [eax+256]
  0000b	84 c0		 test	 al, al
  0000d	74 30		 je	 SHORT $LN1@CheckEnabl@4

; 805  : 		return;
; 806  : 
; 807  : 	if( !CheckGrapplingExceptionState() )

  0000f	8b ce		 mov	 ecx, esi
  00011	e8 00 00 00 00	 call	 ?CheckGrapplingExceptionState@ioBaseChar@@QAE_NXZ ; ioBaseChar::CheckGrapplingExceptionState
  00016	84 c0		 test	 al, al
  00018	74 25		 je	 SHORT $LN1@CheckEnabl@4

; 808  : 		return;
; 809  : 
; 810  : 	if( m_CharState == CS_PHANTOM_FLY )

  0001a	80 be 10 03 00
	00 54		 cmp	 BYTE PTR [esi+784], 84	; 00000054H
  00021	74 1c		 je	 SHORT $LN1@CheckEnabl@4

; 811  : 		return;
; 812  : 
; 813  : 	ioPhantomItem *pPhantom = ToPhantomItem( GetPriorityItem( SPT_ATTACK ) );

  00023	6a 05		 push	 5
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?ToPhantomItem@@YAPAVioPhantomItem@@PAVioItem@@@Z ; ToPhantomItem
  00032	59		 pop	 ecx

; 814  : 	if( pPhantom )

  00033	85 c0		 test	 eax, eax
  00035	74 08		 je	 SHORT $LN1@CheckEnabl@4

; 815  : 		pPhantom->CheckEnablePhantomGauge( this );

  00037	56		 push	 esi
  00038	8b c8		 mov	 ecx, eax
  0003a	e8 00 00 00 00	 call	 ?CheckEnablePhantomGauge@ioPhantomItem@@QAEXPAVioBaseChar@@@Z ; ioPhantomItem::CheckEnablePhantomGauge
$LN1@CheckEnabl@4:
  0003f	5e		 pop	 esi

; 816  : }

  00040	c3		 ret	 0
?CheckEnablePhantomGauge@ioBaseChar@@QAEXXZ ENDP	; ioBaseChar::CheckEnablePhantomGauge
_TEXT	ENDS
PUBLIC	?IsEnablePhantomFly@ioBaseChar@@QAE_NXZ		; ioBaseChar::IsEnablePhantomFly
EXTRN	?CheckPhantomFlyEnableTime@ioPhantomItem@@QAE_NXZ:PROC ; ioPhantomItem::CheckPhantomFlyEnableTime
EXTRN	?IsEnablePhantomGauge@ioPhantomItem@@QAE_NXZ:PROC ; ioPhantomItem::IsEnablePhantomGauge
; Function compile flags: /Ogsp
;	COMDAT ?IsEnablePhantomFly@ioBaseChar@@QAE_NXZ
_TEXT	SEGMENT
?IsEnablePhantomFly@ioBaseChar@@QAE_NXZ PROC		; ioBaseChar::IsEnablePhantomFly, COMDAT
; _this$ = ecx

; 819  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 820  : 	ioPhantomItem *pPhantom = ToPhantomItem( GetPriorityItem( SPT_ATTACK ) );

  00002	6a 05		 push	 5
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?ToPhantomItem@@YAPAVioPhantomItem@@PAVioItem@@@Z ; ToPhantomItem
  00011	8b f8		 mov	 edi, eax
  00013	59		 pop	 ecx

; 821  : 	if( !pPhantom )

  00014	85 ff		 test	 edi, edi
  00016	75 04		 jne	 SHORT $LN4@IsEnablePh
$LN7@IsEnablePh:

; 822  : 		return false;

  00018	32 c0		 xor	 al, al
  0001a	eb 22		 jmp	 SHORT $LN1@IsEnablePh
$LN4@IsEnablePh:

; 823  : 
; 824  : 	if( IsHasCrown() )

  0001c	8b ce		 mov	 ecx, esi
  0001e	e8 00 00 00 00	 call	 ?IsHasCrown@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsHasCrown
  00023	84 c0		 test	 al, al

; 825  : 		return false;

  00025	75 f1		 jne	 SHORT $LN7@IsEnablePh

; 826  : 
; 827  : 	if( !pPhantom->IsEnablePhantomGauge() )

  00027	8b cf		 mov	 ecx, edi
  00029	e8 00 00 00 00	 call	 ?IsEnablePhantomGauge@ioPhantomItem@@QAE_NXZ ; ioPhantomItem::IsEnablePhantomGauge
  0002e	84 c0		 test	 al, al

; 828  : 		return false;

  00030	74 e6		 je	 SHORT $LN7@IsEnablePh

; 829  : 
; 830  : 	if( !pPhantom->CheckPhantomFlyEnableTime() )

  00032	8b cf		 mov	 ecx, edi
  00034	e8 00 00 00 00	 call	 ?CheckPhantomFlyEnableTime@ioPhantomItem@@QAE_NXZ ; ioPhantomItem::CheckPhantomFlyEnableTime
  00039	84 c0		 test	 al, al
  0003b	0f 95 c0	 setne	 al
$LN1@IsEnablePh:

; 831  : 		return false;
; 832  : 
; 833  : 	return true;
; 834  : }

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	c3		 ret	 0
?IsEnablePhantomFly@ioBaseChar@@QAE_NXZ ENDP		; ioBaseChar::IsEnablePhantomFly
_TEXT	ENDS
PUBLIC	?SetLuciferFlyState@ioBaseChar@@QAE_NABUtagLuciferFlyInfo@@@Z ; ioBaseChar::SetLuciferFlyState
EXTRN	?SetFlyState@ioLuciferItem@@QAEXPAVioBaseChar@@ABUtagLuciferFlyInfo@@_N@Z:PROC ; ioLuciferItem::SetFlyState
; Function compile flags: /Ogsp
;	COMDAT ?SetLuciferFlyState@ioBaseChar@@QAE_NABUtagLuciferFlyInfo@@@Z
_TEXT	SEGMENT
_rkFlyInfo$ = 8						; size = 4
?SetLuciferFlyState@ioBaseChar@@QAE_NABUtagLuciferFlyInfo@@@Z PROC ; ioBaseChar::SetLuciferFlyState, COMDAT
; _this$ = ecx

; 838  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 839  : 	ioLuciferItem *pLucifer = ToLuciferItem( GetPriorityItem( SPT_ATTACK ) );

  00004	6a 05		 push	 5
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?ToLuciferItem@@YAPAVioLuciferItem@@PAVioItem@@@Z ; ToLuciferItem
  00013	59		 pop	 ecx

; 840  : 	if( !pLucifer )

  00014	85 c0		 test	 eax, eax
  00016	75 04		 jne	 SHORT $LN1@SetLucifer

; 841  : 		return false;

  00018	32 c0		 xor	 al, al
  0001a	eb 0f		 jmp	 SHORT $LN2@SetLucifer
$LN1@SetLucifer:

; 842  : 
; 843  : 	pLucifer->SetFlyState( this, rkFlyInfo, false );

  0001c	6a 00		 push	 0
  0001e	ff 75 08	 push	 DWORD PTR _rkFlyInfo$[ebp]
  00021	8b c8		 mov	 ecx, eax
  00023	56		 push	 esi
  00024	e8 00 00 00 00	 call	 ?SetFlyState@ioLuciferItem@@QAEXPAVioBaseChar@@ABUtagLuciferFlyInfo@@_N@Z ; ioLuciferItem::SetFlyState

; 844  : 	return true;

  00029	b0 01		 mov	 al, 1
$LN2@SetLucifer:
  0002b	5e		 pop	 esi

; 845  : }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?SetLuciferFlyState@ioBaseChar@@QAE_NABUtagLuciferFlyInfo@@@Z ENDP ; ioBaseChar::SetLuciferFlyState
_TEXT	ENDS
PUBLIC	?IsEnableLuciferFly@ioBaseChar@@QAE_NXZ		; ioBaseChar::IsEnableLuciferFly
EXTRN	?IsEnableGauge@ioLuciferItem@@QAE_NXZ:PROC	; ioLuciferItem::IsEnableGauge
; Function compile flags: /Ogsp
;	COMDAT ?IsEnableLuciferFly@ioBaseChar@@QAE_NXZ
_TEXT	SEGMENT
?IsEnableLuciferFly@ioBaseChar@@QAE_NXZ PROC		; ioBaseChar::IsEnableLuciferFly, COMDAT
; _this$ = ecx

; 848  : {

  00000	56		 push	 esi

; 849  : 	ioLuciferItem *pLucifer = ToLuciferItem( GetPriorityItem( SPT_ATTACK ) );

  00001	6a 05		 push	 5
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?ToLuciferItem@@YAPAVioLuciferItem@@PAVioItem@@@Z ; ToLuciferItem
  00010	59		 pop	 ecx

; 850  : 	if( !pLucifer )

  00011	85 c0		 test	 eax, eax

; 851  : 		return false;

  00013	74 1a		 je	 SHORT $LN1@IsEnableLu

; 852  : 
; 853  : 	if( pLucifer->IsEnableGauge() && !IsHasCrown() )

  00015	8b c8		 mov	 ecx, eax
  00017	e8 00 00 00 00	 call	 ?IsEnableGauge@ioLuciferItem@@QAE_NXZ ; ioLuciferItem::IsEnableGauge
  0001c	84 c0		 test	 al, al
  0001e	74 0f		 je	 SHORT $LN1@IsEnableLu
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?IsHasCrown@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsHasCrown
  00027	84 c0		 test	 al, al
  00029	75 04		 jne	 SHORT $LN1@IsEnableLu

; 854  : 		return true;

  0002b	fe c0		 inc	 al
  0002d	5e		 pop	 esi

; 857  : }

  0002e	c3		 ret	 0
$LN1@IsEnableLu:

; 855  : 
; 856  : 	return false;

  0002f	32 c0		 xor	 al, al
  00031	5e		 pop	 esi

; 857  : }

  00032	c3		 ret	 0
?IsEnableLuciferFly@ioBaseChar@@QAE_NXZ ENDP		; ioBaseChar::IsEnableLuciferFly
_TEXT	ENDS
PUBLIC	?CheckEnableNakoruruGauge@ioBaseChar@@QAEXXZ	; ioBaseChar::CheckEnableNakoruruGauge
EXTRN	?CheckEnableWitchGauge@ioNakoruruItem@@QAEXPAVioBaseChar@@@Z:PROC ; ioNakoruruItem::CheckEnableWitchGauge
; Function compile flags: /Ogsp
;	COMDAT ?CheckEnableNakoruruGauge@ioBaseChar@@QAEXXZ
_TEXT	SEGMENT
?CheckEnableNakoruruGauge@ioBaseChar@@QAEXXZ PROC	; ioBaseChar::CheckEnableNakoruruGauge, COMDAT
; _this$ = ecx

; 861  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 862  : 	if( !IsNeedProcess() )

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 90 00 01 00
	00		 call	 DWORD PTR [eax+256]
  0000b	84 c0		 test	 al, al
  0000d	74 30		 je	 SHORT $LN1@CheckEnabl@5

; 863  : 		return;
; 864  : 
; 865  : 	if( !CheckGrapplingExceptionState() )

  0000f	8b ce		 mov	 ecx, esi
  00011	e8 00 00 00 00	 call	 ?CheckGrapplingExceptionState@ioBaseChar@@QAE_NXZ ; ioBaseChar::CheckGrapplingExceptionState
  00016	84 c0		 test	 al, al
  00018	74 25		 je	 SHORT $LN1@CheckEnabl@5

; 866  : 		return;
; 867  : 
; 868  : 	if( m_CharState == CS_NAKORURU_FLY )

  0001a	80 be 10 03 00
	00 90		 cmp	 BYTE PTR [esi+784], 144	; 00000090H
  00021	74 1c		 je	 SHORT $LN1@CheckEnabl@5

; 869  : 		return;
; 870  : 
; 871  : 	ioNakoruruItem *pNakoruru  = ToNakoruruItem( GetPriorityItem( SPT_ATTACK ) );

  00023	6a 05		 push	 5
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?ToNakoruruItem@@YAPAVioNakoruruItem@@PAVioItem@@@Z ; ToNakoruruItem
  00032	59		 pop	 ecx

; 872  : 	if( pNakoruru )

  00033	85 c0		 test	 eax, eax
  00035	74 08		 je	 SHORT $LN1@CheckEnabl@5

; 873  : 		pNakoruru->CheckEnableWitchGauge( this );

  00037	56		 push	 esi
  00038	8b c8		 mov	 ecx, eax
  0003a	e8 00 00 00 00	 call	 ?CheckEnableWitchGauge@ioNakoruruItem@@QAEXPAVioBaseChar@@@Z ; ioNakoruruItem::CheckEnableWitchGauge
$LN1@CheckEnabl@5:
  0003f	5e		 pop	 esi

; 874  : }

  00040	c3		 ret	 0
?CheckEnableNakoruruGauge@ioBaseChar@@QAEXXZ ENDP	; ioBaseChar::CheckEnableNakoruruGauge
_TEXT	ENDS
PUBLIC	?ApplyNakoruruState@ioBaseChar@@QAEXAAVSP2Packet@@@Z ; ioBaseChar::ApplyNakoruruState
EXTRN	?SetCurWitchGauge@ioNakoruruItem@@QAEXM@Z:PROC	; ioNakoruruItem::SetCurWitchGauge
EXTRN	?SetEnableWitchEffect@ioNakoruruItem@@QAEXPAVioBaseChar@@@Z:PROC ; ioNakoruruItem::SetEnableWitchEffect
; Function compile flags: /Ogsp
;	COMDAT ?ApplyNakoruruState@ioBaseChar@@QAEXAAVSP2Packet@@@Z
_TEXT	SEGMENT
_fCurWitchGauge$ = -8					; size = 4
_iType$ = -4						; size = 4
_rkPacket$ = 8						; size = 4
?ApplyNakoruruState@ioBaseChar@@QAEXAAVSP2Packet@@@Z PROC ; ioBaseChar::ApplyNakoruruState, COMDAT
; _this$ = ecx

; 877  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 878  : 	int iType;
; 879  : 	rkPacket >> iType;

  00007	8d 45 fc	 lea	 eax, DWORD PTR _iType$[ebp]
  0000a	8b f1		 mov	 esi, ecx
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _rkPacket$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??5SP2Packet@@QAEAAV0@AAH@Z ; SP2Packet::operator>>

; 880  : 
; 881  : 	float fCurWitchGauge;
; 882  : 	rkPacket >> fCurWitchGauge;

  00015	8b 4d 08	 mov	 ecx, DWORD PTR _rkPacket$[ebp]
  00018	8d 45 f8	 lea	 eax, DWORD PTR _fCurWitchGauge$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??5SP2Packet@@QAEAAV0@AAM@Z ; SP2Packet::operator>>

; 883  : 
; 884  : 	ioNakoruruItem *pNakoruru = ToNakoruruItem( m_pEquipSlot->GetWeapon() );

  00021	8b 8e 48 03 00
	00		 mov	 ecx, DWORD PTR [esi+840]
  00027	e8 00 00 00 00	 call	 ?GetWeapon@ioEquipSlot@@QBEPAVioWeaponItem@@XZ ; ioEquipSlot::GetWeapon
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?ToNakoruruItem@@YAPAVioNakoruruItem@@PAVioItem@@@Z ; ToNakoruruItem
  00032	8b f8		 mov	 edi, eax

; 885  : 	switch( iType )

  00034	8b 45 fc	 mov	 eax, DWORD PTR _iType$[ebp]
  00037	48		 dec	 eax
  00038	59		 pop	 ecx
  00039	75 1e		 jne	 SHORT $LN1@ApplyNakor

; 886  : 	{
; 887  : 	case WITCH_ENABLE_GAUGE:
; 888  : 		if( pNakoruru )

  0003b	85 ff		 test	 edi, edi
  0003d	74 1a		 je	 SHORT $LN1@ApplyNakor

; 889  : 		{
; 890  : 			pNakoruru->SetEnableWitchEffect( this );

  0003f	56		 push	 esi
  00040	8b cf		 mov	 ecx, edi
  00042	e8 00 00 00 00	 call	 ?SetEnableWitchEffect@ioNakoruruItem@@QAEXPAVioBaseChar@@@Z ; ioNakoruruItem::SetEnableWitchEffect

; 891  : 			pNakoruru->SetCurWitchGauge( fCurWitchGauge );

  00047	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fCurWitchGauge$[ebp]
  0004c	51		 push	 ecx
  0004d	8b cf		 mov	 ecx, edi
  0004f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00054	e8 00 00 00 00	 call	 ?SetCurWitchGauge@ioNakoruruItem@@QAEXM@Z ; ioNakoruruItem::SetCurWitchGauge
$LN1@ApplyNakor:
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi

; 892  : 		}
; 893  : 		break;
; 894  : 	}
; 895  : }

  0005b	c9		 leave
  0005c	c2 04 00	 ret	 4
?ApplyNakoruruState@ioBaseChar@@QAEXAAVSP2Packet@@@Z ENDP ; ioBaseChar::ApplyNakoruruState
_TEXT	ENDS
PUBLIC	?SetDestroyerFlyState@ioBaseChar@@QAE_NABUtagDestroyerFlyInfo@@@Z ; ioBaseChar::SetDestroyerFlyState
EXTRN	?SetDestroyerFlyState@ioDestroyerItem@@QAEXPAVioBaseChar@@ABUtagDestroyerFlyInfo@@_N@Z:PROC ; ioDestroyerItem::SetDestroyerFlyState
; Function compile flags: /Ogsp
;	COMDAT ?SetDestroyerFlyState@ioBaseChar@@QAE_NABUtagDestroyerFlyInfo@@@Z
_TEXT	SEGMENT
_rkFlyInfo$ = 8						; size = 4
?SetDestroyerFlyState@ioBaseChar@@QAE_NABUtagDestroyerFlyInfo@@@Z PROC ; ioBaseChar::SetDestroyerFlyState, COMDAT
; _this$ = ecx

; 899  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 900  : 	ioDestroyerItem *pDestroyer = ToDestroyerItem( GetPriorityItem( SPT_ATTACK ) );

  00004	6a 05		 push	 5
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?ToDestroyerItem@@YAPAVioDestroyerItem@@PAVioItem@@@Z ; ToDestroyerItem
  00013	59		 pop	 ecx

; 901  : 	if( !pDestroyer )

  00014	85 c0		 test	 eax, eax
  00016	75 04		 jne	 SHORT $LN1@SetDestroy

; 902  : 		return false;

  00018	32 c0		 xor	 al, al
  0001a	eb 0f		 jmp	 SHORT $LN2@SetDestroy
$LN1@SetDestroy:

; 903  : 
; 904  : 	pDestroyer->SetDestroyerFlyState( this, rkFlyInfo, false );

  0001c	6a 00		 push	 0
  0001e	ff 75 08	 push	 DWORD PTR _rkFlyInfo$[ebp]
  00021	8b c8		 mov	 ecx, eax
  00023	56		 push	 esi
  00024	e8 00 00 00 00	 call	 ?SetDestroyerFlyState@ioDestroyerItem@@QAEXPAVioBaseChar@@ABUtagDestroyerFlyInfo@@_N@Z ; ioDestroyerItem::SetDestroyerFlyState

; 905  : 	return true;

  00029	b0 01		 mov	 al, 1
$LN2@SetDestroy:
  0002b	5e		 pop	 esi

; 906  : }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?SetDestroyerFlyState@ioBaseChar@@QAE_NABUtagDestroyerFlyInfo@@@Z ENDP ; ioBaseChar::SetDestroyerFlyState
_TEXT	ENDS
PUBLIC	?SetDestroyerFlyStateSkill@ioBaseChar@@QAE_NABVioHashString@@ABUtagDestroyerFlyInfo@@@Z ; ioBaseChar::SetDestroyerFlyStateSkill
; Function compile flags: /Ogsp
;	COMDAT ?SetDestroyerFlyStateSkill@ioBaseChar@@QAE_NABVioHashString@@ABUtagDestroyerFlyInfo@@@Z
_TEXT	SEGMENT
_szBuffName$ = 8					; size = 4
_rkFlyInfo$ = 12					; size = 4
?SetDestroyerFlyStateSkill@ioBaseChar@@QAE_NABVioHashString@@ABUtagDestroyerFlyInfo@@@Z PROC ; ioBaseChar::SetDestroyerFlyStateSkill, COMDAT
; _this$ = ecx

; 909  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 910  : 	ioDestroyerItem *pDestroyer = ToDestroyerItem( GetPriorityItem( SPT_ATTACK ) );

  00004	6a 05		 push	 5
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?ToDestroyerItem@@YAPAVioDestroyerItem@@PAVioItem@@@Z ; ToDestroyerItem
  00013	59		 pop	 ecx

; 911  : 	if( pDestroyer )

  00014	85 c0		 test	 eax, eax
  00016	74 20		 je	 SHORT $LN2@SetDestroy@2

; 912  : 		pDestroyer->SetDestroyerFlyState( this, rkFlyInfo, false );

  00018	6a 00		 push	 0
  0001a	ff 75 0c	 push	 DWORD PTR _rkFlyInfo$[ebp]
  0001d	8b c8		 mov	 ecx, eax
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 ?SetDestroyerFlyState@ioDestroyerItem@@QAEXPAVioBaseChar@@ABUtagDestroyerFlyInfo@@_N@Z ; ioDestroyerItem::SetDestroyerFlyState

; 915  : 
; 916  : 	m_DestroyerBuffName = szBuffName;

  00025	ff 75 08	 push	 DWORD PTR _szBuffName$[ebp]
  00028	8d 8e 40 20 00
	00		 lea	 ecx, DWORD PTR [esi+8256]
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@ABV0@@Z

; 917  : 	return true;

  00034	b0 01		 mov	 al, 1
  00036	eb 02		 jmp	 SHORT $LN3@SetDestroy@2
$LN2@SetDestroy@2:

; 913  : 	else
; 914  : 		return false;

  00038	32 c0		 xor	 al, al
$LN3@SetDestroy@2:
  0003a	5e		 pop	 esi

; 918  : }

  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
?SetDestroyerFlyStateSkill@ioBaseChar@@QAE_NABVioHashString@@ABUtagDestroyerFlyInfo@@@Z ENDP ; ioBaseChar::SetDestroyerFlyStateSkill
_TEXT	ENDS
PUBLIC	?CheckEnableDestroyerGauge@ioBaseChar@@QAEXXZ	; ioBaseChar::CheckEnableDestroyerGauge
EXTRN	?CheckEnableDestroyerGauge@ioDestroyerItem@@QAEXPAVioBaseChar@@@Z:PROC ; ioDestroyerItem::CheckEnableDestroyerGauge
; Function compile flags: /Ogsp
;	COMDAT ?CheckEnableDestroyerGauge@ioBaseChar@@QAEXXZ
_TEXT	SEGMENT
?CheckEnableDestroyerGauge@ioBaseChar@@QAEXXZ PROC	; ioBaseChar::CheckEnableDestroyerGauge, COMDAT
; _this$ = ecx

; 921  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 922  : 	if( !IsNeedProcess() )

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 90 00 01 00
	00		 call	 DWORD PTR [eax+256]
  0000b	84 c0		 test	 al, al
  0000d	74 30		 je	 SHORT $LN1@CheckEnabl@6

; 923  : 		return;
; 924  : 
; 925  : 	if( !CheckGrapplingExceptionState() )

  0000f	8b ce		 mov	 ecx, esi
  00011	e8 00 00 00 00	 call	 ?CheckGrapplingExceptionState@ioBaseChar@@QAE_NXZ ; ioBaseChar::CheckGrapplingExceptionState
  00016	84 c0		 test	 al, al
  00018	74 25		 je	 SHORT $LN1@CheckEnabl@6

; 926  : 		return;
; 927  : 
; 928  : 	if( m_CharState == CS_DESTROYER_FLY )

  0001a	80 be 10 03 00
	00 5a		 cmp	 BYTE PTR [esi+784], 90	; 0000005aH
  00021	74 1c		 je	 SHORT $LN1@CheckEnabl@6

; 929  : 		return;
; 930  : 
; 931  : 	ioDestroyerItem *pDestroyer = ToDestroyerItem( GetPriorityItem( SPT_ATTACK ) );

  00023	6a 05		 push	 5
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?ToDestroyerItem@@YAPAVioDestroyerItem@@PAVioItem@@@Z ; ToDestroyerItem
  00032	59		 pop	 ecx

; 932  : 	if( pDestroyer )

  00033	85 c0		 test	 eax, eax
  00035	74 08		 je	 SHORT $LN1@CheckEnabl@6

; 933  : 		pDestroyer->CheckEnableDestroyerGauge( this );

  00037	56		 push	 esi
  00038	8b c8		 mov	 ecx, eax
  0003a	e8 00 00 00 00	 call	 ?CheckEnableDestroyerGauge@ioDestroyerItem@@QAEXPAVioBaseChar@@@Z ; ioDestroyerItem::CheckEnableDestroyerGauge
$LN1@CheckEnabl@6:
  0003f	5e		 pop	 esi

; 934  : }

  00040	c3		 ret	 0
?CheckEnableDestroyerGauge@ioBaseChar@@QAEXXZ ENDP	; ioBaseChar::CheckEnableDestroyerGauge
_TEXT	ENDS
PUBLIC	?IsEnableDestroyerFly@ioBaseChar@@QAE_NXZ	; ioBaseChar::IsEnableDestroyerFly
EXTRN	?IsEnableDestroyerGauge@ioDestroyerItem@@QAE_NXZ:PROC ; ioDestroyerItem::IsEnableDestroyerGauge
; Function compile flags: /Ogsp
;	COMDAT ?IsEnableDestroyerFly@ioBaseChar@@QAE_NXZ
_TEXT	SEGMENT
?IsEnableDestroyerFly@ioBaseChar@@QAE_NXZ PROC		; ioBaseChar::IsEnableDestroyerFly, COMDAT
; _this$ = ecx

; 937  : {

  00000	56		 push	 esi

; 938  : 	ioDestroyerItem *pDestroyer = ToDestroyerItem( GetPriorityItem( SPT_ATTACK ) );

  00001	6a 05		 push	 5
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?ToDestroyerItem@@YAPAVioDestroyerItem@@PAVioItem@@@Z ; ToDestroyerItem
  00010	59		 pop	 ecx

; 939  : 	if( !pDestroyer )

  00011	85 c0		 test	 eax, eax

; 940  : 		return false;

  00013	74 1a		 je	 SHORT $LN1@IsEnableDe

; 941  : 
; 942  : 	if( pDestroyer->IsEnableDestroyerGauge() && !IsHasCrown() )

  00015	8b c8		 mov	 ecx, eax
  00017	e8 00 00 00 00	 call	 ?IsEnableDestroyerGauge@ioDestroyerItem@@QAE_NXZ ; ioDestroyerItem::IsEnableDestroyerGauge
  0001c	84 c0		 test	 al, al
  0001e	74 0f		 je	 SHORT $LN1@IsEnableDe
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?IsHasCrown@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsHasCrown
  00027	84 c0		 test	 al, al
  00029	75 04		 jne	 SHORT $LN1@IsEnableDe

; 943  : 		return true;

  0002b	fe c0		 inc	 al
  0002d	5e		 pop	 esi

; 946  : }

  0002e	c3		 ret	 0
$LN1@IsEnableDe:

; 944  : 
; 945  : 	return false;

  0002f	32 c0		 xor	 al, al
  00031	5e		 pop	 esi

; 946  : }

  00032	c3		 ret	 0
?IsEnableDestroyerFly@ioBaseChar@@QAE_NXZ ENDP		; ioBaseChar::IsEnableDestroyerFly
_TEXT	ENDS
PUBLIC	?SetMichaelFlyStateByJumpDash@ioBaseChar@@QAE_NABUtagMichaelFlyInfo@@@Z ; ioBaseChar::SetMichaelFlyStateByJumpDash
EXTRN	?SetMichaelFlyStateByJumpDash@ioMichaelItem@@QAEXPAVioBaseChar@@ABUtagMichaelFlyInfo@@@Z:PROC ; ioMichaelItem::SetMichaelFlyStateByJumpDash
; Function compile flags: /Ogsp
;	COMDAT ?SetMichaelFlyStateByJumpDash@ioBaseChar@@QAE_NABUtagMichaelFlyInfo@@@Z
_TEXT	SEGMENT
_rkFlyInfo$ = 8						; size = 4
?SetMichaelFlyStateByJumpDash@ioBaseChar@@QAE_NABUtagMichaelFlyInfo@@@Z PROC ; ioBaseChar::SetMichaelFlyStateByJumpDash, COMDAT
; _this$ = ecx

; 950  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 951  : 	ioMichaelItem *pMichael = ToMichaelItem( GetPriorityItem( SPT_ATTACK ) );

  00004	6a 05		 push	 5
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?ToMichaelItem@@YAPAVioMichaelItem@@PAVioItem@@@Z ; ToMichaelItem
  00013	59		 pop	 ecx

; 952  : 	if( !pMichael )

  00014	85 c0		 test	 eax, eax
  00016	75 04		 jne	 SHORT $LN1@SetMichael

; 953  : 		return false;

  00018	32 c0		 xor	 al, al
  0001a	eb 0d		 jmp	 SHORT $LN2@SetMichael
$LN1@SetMichael:

; 954  : 
; 955  : 	pMichael->SetMichaelFlyStateByJumpDash( this, rkFlyInfo );

  0001c	ff 75 08	 push	 DWORD PTR _rkFlyInfo$[ebp]
  0001f	8b c8		 mov	 ecx, eax
  00021	56		 push	 esi
  00022	e8 00 00 00 00	 call	 ?SetMichaelFlyStateByJumpDash@ioMichaelItem@@QAEXPAVioBaseChar@@ABUtagMichaelFlyInfo@@@Z ; ioMichaelItem::SetMichaelFlyStateByJumpDash

; 956  : 	return true;

  00027	b0 01		 mov	 al, 1
$LN2@SetMichael:
  00029	5e		 pop	 esi

; 957  : }

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?SetMichaelFlyStateByJumpDash@ioBaseChar@@QAE_NABUtagMichaelFlyInfo@@@Z ENDP ; ioBaseChar::SetMichaelFlyStateByJumpDash
_TEXT	ENDS
PUBLIC	?CheckEnableMichaelGauge@ioBaseChar@@QAEXXZ	; ioBaseChar::CheckEnableMichaelGauge
EXTRN	?CheckEnableMichaelGauge@ioMichaelItem@@QAEXPAVioBaseChar@@@Z:PROC ; ioMichaelItem::CheckEnableMichaelGauge
; Function compile flags: /Ogsp
;	COMDAT ?CheckEnableMichaelGauge@ioBaseChar@@QAEXXZ
_TEXT	SEGMENT
?CheckEnableMichaelGauge@ioBaseChar@@QAEXXZ PROC	; ioBaseChar::CheckEnableMichaelGauge, COMDAT
; _this$ = ecx

; 960  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 961  : 	if( !IsNeedProcess() )

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 90 00 01 00
	00		 call	 DWORD PTR [eax+256]
  0000b	84 c0		 test	 al, al
  0000d	74 30		 je	 SHORT $LN1@CheckEnabl@7

; 962  : 		return;
; 963  : 
; 964  : 	if( !CheckGrapplingExceptionState() )

  0000f	8b ce		 mov	 ecx, esi
  00011	e8 00 00 00 00	 call	 ?CheckGrapplingExceptionState@ioBaseChar@@QAE_NXZ ; ioBaseChar::CheckGrapplingExceptionState
  00016	84 c0		 test	 al, al
  00018	74 25		 je	 SHORT $LN1@CheckEnabl@7

; 965  : 		return;
; 966  : 
; 967  : 	if( m_CharState == CS_MICHAEL_FLY )

  0001a	80 be 10 03 00
	00 5b		 cmp	 BYTE PTR [esi+784], 91	; 0000005bH
  00021	74 1c		 je	 SHORT $LN1@CheckEnabl@7

; 968  : 		return;
; 969  : 
; 970  : 	ioMichaelItem *pMichael = ToMichaelItem( GetPriorityItem( SPT_ATTACK ) );

  00023	6a 05		 push	 5
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?ToMichaelItem@@YAPAVioMichaelItem@@PAVioItem@@@Z ; ToMichaelItem
  00032	59		 pop	 ecx

; 971  : 	if( pMichael )

  00033	85 c0		 test	 eax, eax
  00035	74 08		 je	 SHORT $LN1@CheckEnabl@7

; 972  : 		pMichael->CheckEnableMichaelGauge( this );

  00037	56		 push	 esi
  00038	8b c8		 mov	 ecx, eax
  0003a	e8 00 00 00 00	 call	 ?CheckEnableMichaelGauge@ioMichaelItem@@QAEXPAVioBaseChar@@@Z ; ioMichaelItem::CheckEnableMichaelGauge
$LN1@CheckEnabl@7:
  0003f	5e		 pop	 esi

; 973  : }

  00040	c3		 ret	 0
?CheckEnableMichaelGauge@ioBaseChar@@QAEXXZ ENDP	; ioBaseChar::CheckEnableMichaelGauge
_TEXT	ENDS
PUBLIC	?IsEnableMichaelFly@ioBaseChar@@QAE_NXZ		; ioBaseChar::IsEnableMichaelFly
EXTRN	?IsEnableMichaelGauge@ioMichaelItem@@QAE_NXZ:PROC ; ioMichaelItem::IsEnableMichaelGauge
; Function compile flags: /Ogsp
;	COMDAT ?IsEnableMichaelFly@ioBaseChar@@QAE_NXZ
_TEXT	SEGMENT
?IsEnableMichaelFly@ioBaseChar@@QAE_NXZ PROC		; ioBaseChar::IsEnableMichaelFly, COMDAT
; _this$ = ecx

; 976  : {

  00000	56		 push	 esi

; 977  : 	ioMichaelItem *pMichael = ToMichaelItem( GetPriorityItem( SPT_ATTACK ) );

  00001	6a 05		 push	 5
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?ToMichaelItem@@YAPAVioMichaelItem@@PAVioItem@@@Z ; ToMichaelItem
  00010	59		 pop	 ecx

; 978  : 	if( !pMichael )

  00011	85 c0		 test	 eax, eax

; 979  : 		return false;

  00013	74 1a		 je	 SHORT $LN1@IsEnableMi

; 980  : 
; 981  : 	if( pMichael->IsEnableMichaelGauge() && !IsHasCrown() )

  00015	8b c8		 mov	 ecx, eax
  00017	e8 00 00 00 00	 call	 ?IsEnableMichaelGauge@ioMichaelItem@@QAE_NXZ ; ioMichaelItem::IsEnableMichaelGauge
  0001c	84 c0		 test	 al, al
  0001e	74 0f		 je	 SHORT $LN1@IsEnableMi
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?IsHasCrown@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsHasCrown
  00027	84 c0		 test	 al, al
  00029	75 04		 jne	 SHORT $LN1@IsEnableMi

; 982  : 		return true;

  0002b	fe c0		 inc	 al
  0002d	5e		 pop	 esi

; 985  : }

  0002e	c3		 ret	 0
$LN1@IsEnableMi:

; 983  : 
; 984  : 	return false;

  0002f	32 c0		 xor	 al, al
  00031	5e		 pop	 esi

; 985  : }

  00032	c3		 ret	 0
?IsEnableMichaelFly@ioBaseChar@@QAE_NXZ ENDP		; ioBaseChar::IsEnableMichaelFly
_TEXT	ENDS
PUBLIC	?SetGoomihoFlyStateByJumpDash@ioBaseChar@@QAE_NABUtagGoomihoFlyInfo@@@Z ; ioBaseChar::SetGoomihoFlyStateByJumpDash
EXTRN	?SetGoomihoFlyStateByJumpDash@ioGoomihoItem@@QAEXPAVioBaseChar@@ABUtagGoomihoFlyInfo@@@Z:PROC ; ioGoomihoItem::SetGoomihoFlyStateByJumpDash
; Function compile flags: /Ogsp
;	COMDAT ?SetGoomihoFlyStateByJumpDash@ioBaseChar@@QAE_NABUtagGoomihoFlyInfo@@@Z
_TEXT	SEGMENT
_rkFlyInfo$ = 8						; size = 4
?SetGoomihoFlyStateByJumpDash@ioBaseChar@@QAE_NABUtagGoomihoFlyInfo@@@Z PROC ; ioBaseChar::SetGoomihoFlyStateByJumpDash, COMDAT
; _this$ = ecx

; 989  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 990  : 	ioGoomihoItem *pGoomiho = ToGoomihoItem( GetPriorityItem( SPT_ATTACK) );

  00004	6a 05		 push	 5
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?ToGoomihoItem@@YAPAVioGoomihoItem@@PAVioItem@@@Z ; ToGoomihoItem
  00013	59		 pop	 ecx

; 991  : 	if( !pGoomiho )

  00014	85 c0		 test	 eax, eax
  00016	75 04		 jne	 SHORT $LN1@SetGoomiho

; 992  : 		return false;

  00018	32 c0		 xor	 al, al
  0001a	eb 0d		 jmp	 SHORT $LN2@SetGoomiho
$LN1@SetGoomiho:

; 993  : 
; 994  : 	pGoomiho->SetGoomihoFlyStateByJumpDash( this, rkFlyInfo );

  0001c	ff 75 08	 push	 DWORD PTR _rkFlyInfo$[ebp]
  0001f	8b c8		 mov	 ecx, eax
  00021	56		 push	 esi
  00022	e8 00 00 00 00	 call	 ?SetGoomihoFlyStateByJumpDash@ioGoomihoItem@@QAEXPAVioBaseChar@@ABUtagGoomihoFlyInfo@@@Z ; ioGoomihoItem::SetGoomihoFlyStateByJumpDash

; 995  : 	return true;

  00027	b0 01		 mov	 al, 1
$LN2@SetGoomiho:
  00029	5e		 pop	 esi

; 996  : }

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?SetGoomihoFlyStateByJumpDash@ioBaseChar@@QAE_NABUtagGoomihoFlyInfo@@@Z ENDP ; ioBaseChar::SetGoomihoFlyStateByJumpDash
_TEXT	ENDS
PUBLIC	?CheckEnableGoomihoGauge@ioBaseChar@@QAEXXZ	; ioBaseChar::CheckEnableGoomihoGauge
EXTRN	?CheckEnableGoomihoGauge@ioGoomihoItem@@QAEXPAVioBaseChar@@@Z:PROC ; ioGoomihoItem::CheckEnableGoomihoGauge
; Function compile flags: /Ogsp
;	COMDAT ?CheckEnableGoomihoGauge@ioBaseChar@@QAEXXZ
_TEXT	SEGMENT
?CheckEnableGoomihoGauge@ioBaseChar@@QAEXXZ PROC	; ioBaseChar::CheckEnableGoomihoGauge, COMDAT
; _this$ = ecx

; 999  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1000 : 	if( !IsNeedProcess() )

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 90 00 01 00
	00		 call	 DWORD PTR [eax+256]
  0000b	84 c0		 test	 al, al
  0000d	74 25		 je	 SHORT $LN1@CheckEnabl@8

; 1001 : 		return;
; 1002 : 
; 1003 : 	if( m_CharState == CS_GOOMIHO_LAND_FLY )

  0000f	80 be 10 03 00
	00 5e		 cmp	 BYTE PTR [esi+784], 94	; 0000005eH
  00016	74 1c		 je	 SHORT $LN1@CheckEnabl@8

; 1004 : 		return;
; 1005 : 
; 1006 : 	ioGoomihoItem *pGoomiho = ToGoomihoItem( GetPriorityItem( SPT_ATTACK ) );

  00018	6a 05		 push	 5
  0001a	8b ce		 mov	 ecx, esi
  0001c	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ?ToGoomihoItem@@YAPAVioGoomihoItem@@PAVioItem@@@Z ; ToGoomihoItem
  00027	59		 pop	 ecx

; 1007 : 	if( pGoomiho )

  00028	85 c0		 test	 eax, eax
  0002a	74 08		 je	 SHORT $LN1@CheckEnabl@8

; 1008 : 		pGoomiho->CheckEnableGoomihoGauge( this );

  0002c	56		 push	 esi
  0002d	8b c8		 mov	 ecx, eax
  0002f	e8 00 00 00 00	 call	 ?CheckEnableGoomihoGauge@ioGoomihoItem@@QAEXPAVioBaseChar@@@Z ; ioGoomihoItem::CheckEnableGoomihoGauge
$LN1@CheckEnabl@8:
  00034	5e		 pop	 esi

; 1009 : }

  00035	c3		 ret	 0
?CheckEnableGoomihoGauge@ioBaseChar@@QAEXXZ ENDP	; ioBaseChar::CheckEnableGoomihoGauge
_TEXT	ENDS
PUBLIC	?IsEnableGoomihoFly@ioBaseChar@@QAE_NXZ		; ioBaseChar::IsEnableGoomihoFly
EXTRN	?IsEnableGoomihoGauge@ioGoomihoItem@@QAE_NXZ:PROC ; ioGoomihoItem::IsEnableGoomihoGauge
; Function compile flags: /Ogsp
;	COMDAT ?IsEnableGoomihoFly@ioBaseChar@@QAE_NXZ
_TEXT	SEGMENT
?IsEnableGoomihoFly@ioBaseChar@@QAE_NXZ PROC		; ioBaseChar::IsEnableGoomihoFly, COMDAT
; _this$ = ecx

; 1012 : {

  00000	56		 push	 esi

; 1013 : 	ioGoomihoItem *pGoomiho = ToGoomihoItem( GetPriorityItem( SPT_ATTACK ) );

  00001	6a 05		 push	 5
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?ToGoomihoItem@@YAPAVioGoomihoItem@@PAVioItem@@@Z ; ToGoomihoItem
  00010	59		 pop	 ecx

; 1014 : 	if( !pGoomiho )

  00011	85 c0		 test	 eax, eax

; 1015 : 		return false;

  00013	74 1a		 je	 SHORT $LN1@IsEnableGo

; 1016 : 
; 1017 : 	if( pGoomiho->IsEnableGoomihoGauge() && !IsHasCrown() )

  00015	8b c8		 mov	 ecx, eax
  00017	e8 00 00 00 00	 call	 ?IsEnableGoomihoGauge@ioGoomihoItem@@QAE_NXZ ; ioGoomihoItem::IsEnableGoomihoGauge
  0001c	84 c0		 test	 al, al
  0001e	74 0f		 je	 SHORT $LN1@IsEnableGo
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?IsHasCrown@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsHasCrown
  00027	84 c0		 test	 al, al
  00029	75 04		 jne	 SHORT $LN1@IsEnableGo

; 1018 : 		return true;

  0002b	fe c0		 inc	 al
  0002d	5e		 pop	 esi

; 1021 : }

  0002e	c3		 ret	 0
$LN1@IsEnableGo:

; 1019 : 
; 1020 : 	return false;

  0002f	32 c0		 xor	 al, al
  00031	5e		 pop	 esi

; 1021 : }

  00032	c3		 ret	 0
?IsEnableGoomihoFly@ioBaseChar@@QAE_NXZ ENDP		; ioBaseChar::IsEnableGoomihoFly
_TEXT	ENDS
PUBLIC	?SetPeterpanFlyState@ioBaseChar@@QAE_NABUtagPeterpanFlyInfo@@@Z ; ioBaseChar::SetPeterpanFlyState
EXTRN	?SetFlyState@ioPeterpanItem@@QAEXPAVioBaseChar@@ABUtagPeterpanFlyInfo@@_N@Z:PROC ; ioPeterpanItem::SetFlyState
; Function compile flags: /Ogsp
;	COMDAT ?SetPeterpanFlyState@ioBaseChar@@QAE_NABUtagPeterpanFlyInfo@@@Z
_TEXT	SEGMENT
_rkFlyInfo$ = 8						; size = 4
?SetPeterpanFlyState@ioBaseChar@@QAE_NABUtagPeterpanFlyInfo@@@Z PROC ; ioBaseChar::SetPeterpanFlyState, COMDAT
; _this$ = ecx

; 1025 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1026 : 	ioPeterpanItem *pPeterpan = ToPeterpanItem( GetPriorityItem( SPT_ATTACK ) );

  00004	6a 05		 push	 5
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?ToPeterpanItem@@YAPAVioPeterpanItem@@PAVioItem@@@Z ; ToPeterpanItem
  00013	59		 pop	 ecx

; 1027 : 	if( !pPeterpan )

  00014	85 c0		 test	 eax, eax
  00016	75 04		 jne	 SHORT $LN1@SetPeterpa

; 1028 : 		return false;

  00018	32 c0		 xor	 al, al
  0001a	eb 0f		 jmp	 SHORT $LN2@SetPeterpa
$LN1@SetPeterpa:

; 1029 : 
; 1030 : 	pPeterpan->SetFlyState( this, rkFlyInfo, false );

  0001c	6a 00		 push	 0
  0001e	ff 75 08	 push	 DWORD PTR _rkFlyInfo$[ebp]
  00021	8b c8		 mov	 ecx, eax
  00023	56		 push	 esi
  00024	e8 00 00 00 00	 call	 ?SetFlyState@ioPeterpanItem@@QAEXPAVioBaseChar@@ABUtagPeterpanFlyInfo@@_N@Z ; ioPeterpanItem::SetFlyState

; 1031 : 	return true;

  00029	b0 01		 mov	 al, 1
$LN2@SetPeterpa:
  0002b	5e		 pop	 esi

; 1032 : }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?SetPeterpanFlyState@ioBaseChar@@QAE_NABUtagPeterpanFlyInfo@@@Z ENDP ; ioBaseChar::SetPeterpanFlyState
_TEXT	ENDS
PUBLIC	?IsEnablePeterpanFly@ioBaseChar@@QAE_NXZ	; ioBaseChar::IsEnablePeterpanFly
EXTRN	?IsEnableGauge@ioPeterpanItem@@QAE_NXZ:PROC	; ioPeterpanItem::IsEnableGauge
; Function compile flags: /Ogsp
;	COMDAT ?IsEnablePeterpanFly@ioBaseChar@@QAE_NXZ
_TEXT	SEGMENT
?IsEnablePeterpanFly@ioBaseChar@@QAE_NXZ PROC		; ioBaseChar::IsEnablePeterpanFly, COMDAT
; _this$ = ecx

; 1035 : {

  00000	56		 push	 esi

; 1036 : 	ioPeterpanItem *pPeterpan = ToPeterpanItem( GetPriorityItem( SPT_ATTACK ) );

  00001	6a 05		 push	 5
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?ToPeterpanItem@@YAPAVioPeterpanItem@@PAVioItem@@@Z ; ToPeterpanItem
  00010	59		 pop	 ecx

; 1037 : 	if( !pPeterpan )

  00011	85 c0		 test	 eax, eax

; 1038 : 		return false;

  00013	74 1a		 je	 SHORT $LN1@IsEnablePe

; 1039 : 
; 1040 : 	if( pPeterpan->IsEnableGauge() && !IsHasCrown() )

  00015	8b c8		 mov	 ecx, eax
  00017	e8 00 00 00 00	 call	 ?IsEnableGauge@ioPeterpanItem@@QAE_NXZ ; ioPeterpanItem::IsEnableGauge
  0001c	84 c0		 test	 al, al
  0001e	74 0f		 je	 SHORT $LN1@IsEnablePe
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?IsHasCrown@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsHasCrown
  00027	84 c0		 test	 al, al
  00029	75 04		 jne	 SHORT $LN1@IsEnablePe

; 1041 : 		return true;

  0002b	fe c0		 inc	 al
  0002d	5e		 pop	 esi

; 1044 : }

  0002e	c3		 ret	 0
$LN1@IsEnablePe:

; 1042 : 
; 1043 : 	return false;

  0002f	32 c0		 xor	 al, al
  00031	5e		 pop	 esi

; 1044 : }

  00032	c3		 ret	 0
?IsEnablePeterpanFly@ioBaseChar@@QAE_NXZ ENDP		; ioBaseChar::IsEnablePeterpanFly
_TEXT	ENDS
PUBLIC	?SetSuccubusStateByDash@ioBaseChar@@QAE_NABUtagSuccubusAttackInfo@@@Z ; ioBaseChar::SetSuccubusStateByDash
EXTRN	?SetSuccubusStateByDash@ioSuccubusItem@@QAEXPAVioBaseChar@@ABUtagSuccubusAttackInfo@@@Z:PROC ; ioSuccubusItem::SetSuccubusStateByDash
; Function compile flags: /Ogsp
;	COMDAT ?SetSuccubusStateByDash@ioBaseChar@@QAE_NABUtagSuccubusAttackInfo@@@Z
_TEXT	SEGMENT
_rkInfo$ = 8						; size = 4
?SetSuccubusStateByDash@ioBaseChar@@QAE_NABUtagSuccubusAttackInfo@@@Z PROC ; ioBaseChar::SetSuccubusStateByDash, COMDAT
; _this$ = ecx

; 1048 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1049 : 	ioSuccubusItem *pSuccubus =	ToSuccubusItem( GetPriorityItem( SPT_ATTACK) );

  00004	6a 05		 push	 5
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?ToSuccubusItem@@YAPAVioSuccubusItem@@PAVioItem@@@Z ; ToSuccubusItem
  00013	59		 pop	 ecx

; 1050 : 	if( !pSuccubus )

  00014	85 c0		 test	 eax, eax
  00016	75 04		 jne	 SHORT $LN1@SetSuccubu

; 1051 : 		return false;

  00018	32 c0		 xor	 al, al
  0001a	eb 0d		 jmp	 SHORT $LN2@SetSuccubu
$LN1@SetSuccubu:

; 1052 : 
; 1053 : 	pSuccubus->SetSuccubusStateByDash( this, rkInfo );

  0001c	ff 75 08	 push	 DWORD PTR _rkInfo$[ebp]
  0001f	8b c8		 mov	 ecx, eax
  00021	56		 push	 esi
  00022	e8 00 00 00 00	 call	 ?SetSuccubusStateByDash@ioSuccubusItem@@QAEXPAVioBaseChar@@ABUtagSuccubusAttackInfo@@@Z ; ioSuccubusItem::SetSuccubusStateByDash

; 1054 : 	return true;

  00027	b0 01		 mov	 al, 1
$LN2@SetSuccubu:
  00029	5e		 pop	 esi

; 1055 : }

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?SetSuccubusStateByDash@ioBaseChar@@QAE_NABUtagSuccubusAttackInfo@@@Z ENDP ; ioBaseChar::SetSuccubusStateByDash
_TEXT	ENDS
PUBLIC	?CheckEnableSuccubusGauge@ioBaseChar@@QAEXXZ	; ioBaseChar::CheckEnableSuccubusGauge
EXTRN	?CheckEnableGauge@ioSuccubusItem@@QAEXPAVioBaseChar@@@Z:PROC ; ioSuccubusItem::CheckEnableGauge
; Function compile flags: /Ogsp
;	COMDAT ?CheckEnableSuccubusGauge@ioBaseChar@@QAEXXZ
_TEXT	SEGMENT
?CheckEnableSuccubusGauge@ioBaseChar@@QAEXXZ PROC	; ioBaseChar::CheckEnableSuccubusGauge, COMDAT
; _this$ = ecx

; 1058 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1059 : 	if( !IsNeedProcess() )

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 90 00 01 00
	00		 call	 DWORD PTR [eax+256]
  0000b	84 c0		 test	 al, al
  0000d	74 25		 je	 SHORT $LN1@CheckEnabl@9

; 1060 : 		return;
; 1061 : 
; 1062 : 	if( m_CharState == CS_SUCCUBUS_ATTACK )

  0000f	80 be 10 03 00
	00 61		 cmp	 BYTE PTR [esi+784], 97	; 00000061H
  00016	74 1c		 je	 SHORT $LN1@CheckEnabl@9

; 1063 : 		return;
; 1064 : 
; 1065 : 	ioSuccubusItem *pSuccubus = ToSuccubusItem( GetPriorityItem( SPT_ATTACK ) );

  00018	6a 05		 push	 5
  0001a	8b ce		 mov	 ecx, esi
  0001c	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ?ToSuccubusItem@@YAPAVioSuccubusItem@@PAVioItem@@@Z ; ToSuccubusItem
  00027	59		 pop	 ecx

; 1066 : 	if( pSuccubus )

  00028	85 c0		 test	 eax, eax
  0002a	74 08		 je	 SHORT $LN1@CheckEnabl@9

; 1067 : 		pSuccubus->CheckEnableGauge( this );

  0002c	56		 push	 esi
  0002d	8b c8		 mov	 ecx, eax
  0002f	e8 00 00 00 00	 call	 ?CheckEnableGauge@ioSuccubusItem@@QAEXPAVioBaseChar@@@Z ; ioSuccubusItem::CheckEnableGauge
$LN1@CheckEnabl@9:
  00034	5e		 pop	 esi

; 1068 : }

  00035	c3		 ret	 0
?CheckEnableSuccubusGauge@ioBaseChar@@QAEXXZ ENDP	; ioBaseChar::CheckEnableSuccubusGauge
_TEXT	ENDS
PUBLIC	?IsEnableSuccubusAttack@ioBaseChar@@QAE_NXZ	; ioBaseChar::IsEnableSuccubusAttack
EXTRN	?IsEnableGauge@ioSuccubusItem@@QAE_NXZ:PROC	; ioSuccubusItem::IsEnableGauge
; Function compile flags: /Ogsp
;	COMDAT ?IsEnableSuccubusAttack@ioBaseChar@@QAE_NXZ
_TEXT	SEGMENT
?IsEnableSuccubusAttack@ioBaseChar@@QAE_NXZ PROC	; ioBaseChar::IsEnableSuccubusAttack, COMDAT
; _this$ = ecx

; 1071 : {

  00000	56		 push	 esi

; 1072 : 	ioSuccubusItem *pSuccubus = ToSuccubusItem( GetPriorityItem( SPT_ATTACK ) );

  00001	6a 05		 push	 5
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?ToSuccubusItem@@YAPAVioSuccubusItem@@PAVioItem@@@Z ; ToSuccubusItem
  00010	59		 pop	 ecx

; 1073 : 	if( !pSuccubus )

  00011	85 c0		 test	 eax, eax

; 1074 : 		return false;

  00013	74 1a		 je	 SHORT $LN1@IsEnableSu

; 1075 : 
; 1076 : 	if( pSuccubus->IsEnableGauge() && !IsHasCrown() )

  00015	8b c8		 mov	 ecx, eax
  00017	e8 00 00 00 00	 call	 ?IsEnableGauge@ioSuccubusItem@@QAE_NXZ ; ioSuccubusItem::IsEnableGauge
  0001c	84 c0		 test	 al, al
  0001e	74 0f		 je	 SHORT $LN1@IsEnableSu
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?IsHasCrown@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsHasCrown
  00027	84 c0		 test	 al, al
  00029	75 04		 jne	 SHORT $LN1@IsEnableSu

; 1077 : 		return true;

  0002b	fe c0		 inc	 al
  0002d	5e		 pop	 esi

; 1080 : }

  0002e	c3		 ret	 0
$LN1@IsEnableSu:

; 1078 : 
; 1079 : 	return false;

  0002f	32 c0		 xor	 al, al
  00031	5e		 pop	 esi

; 1080 : }

  00032	c3		 ret	 0
?IsEnableSuccubusAttack@ioBaseChar@@QAE_NXZ ENDP	; ioBaseChar::IsEnableSuccubusAttack
_TEXT	ENDS
PUBLIC	?SetCyvogueModeState@ioBaseChar@@QAE_NABUtagCyvogueFlyInfo@@@Z ; ioBaseChar::SetCyvogueModeState
EXTRN	?SetCyvogueState@ioCyvogueItem@@QAEXPAVioBaseChar@@ABUtagCyvogueFlyInfo@@_N@Z:PROC ; ioCyvogueItem::SetCyvogueState
; Function compile flags: /Ogsp
;	COMDAT ?SetCyvogueModeState@ioBaseChar@@QAE_NABUtagCyvogueFlyInfo@@@Z
_TEXT	SEGMENT
_rkFlyInfo$ = 8						; size = 4
?SetCyvogueModeState@ioBaseChar@@QAE_NABUtagCyvogueFlyInfo@@@Z PROC ; ioBaseChar::SetCyvogueModeState, COMDAT
; _this$ = ecx

; 1084 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1085 : 	ioCyvogueItem *pCyvogue = ToCyvogueItem( GetPriorityItem( SPT_ATTACK ) );

  00004	6a 05		 push	 5
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?ToCyvogueItem@@YAPAVioCyvogueItem@@PAVioItem@@@Z ; ToCyvogueItem
  00013	59		 pop	 ecx

; 1086 : 	if( !pCyvogue )

  00014	85 c0		 test	 eax, eax
  00016	75 04		 jne	 SHORT $LN1@SetCyvogue

; 1087 : 		return false;

  00018	32 c0		 xor	 al, al
  0001a	eb 0f		 jmp	 SHORT $LN2@SetCyvogue
$LN1@SetCyvogue:

; 1088 : 
; 1089 : 	pCyvogue->SetCyvogueState( this, rkFlyInfo, false );

  0001c	6a 00		 push	 0
  0001e	ff 75 08	 push	 DWORD PTR _rkFlyInfo$[ebp]
  00021	8b c8		 mov	 ecx, eax
  00023	56		 push	 esi
  00024	e8 00 00 00 00	 call	 ?SetCyvogueState@ioCyvogueItem@@QAEXPAVioBaseChar@@ABUtagCyvogueFlyInfo@@_N@Z ; ioCyvogueItem::SetCyvogueState

; 1090 : 	return true;

  00029	b0 01		 mov	 al, 1
$LN2@SetCyvogue:
  0002b	5e		 pop	 esi

; 1091 : }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?SetCyvogueModeState@ioBaseChar@@QAE_NABUtagCyvogueFlyInfo@@@Z ENDP ; ioBaseChar::SetCyvogueModeState
_TEXT	ENDS
PUBLIC	?SetCyvogueModeStateSkill@ioBaseChar@@QAE_NABUtagCyvogueFlyInfo@@@Z ; ioBaseChar::SetCyvogueModeStateSkill
; Function compile flags: /Ogsp
;	COMDAT ?SetCyvogueModeStateSkill@ioBaseChar@@QAE_NABUtagCyvogueFlyInfo@@@Z
_TEXT	SEGMENT
_rkFlyInfo$ = 8						; size = 4
?SetCyvogueModeStateSkill@ioBaseChar@@QAE_NABUtagCyvogueFlyInfo@@@Z PROC ; ioBaseChar::SetCyvogueModeStateSkill, COMDAT
; _this$ = ecx

; 1094 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1095 : 	ioCyvogueItem *pCyvogue = ToCyvogueItem( GetPriorityItem( SPT_ATTACK ) );

  00004	6a 05		 push	 5
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?ToCyvogueItem@@YAPAVioCyvogueItem@@PAVioItem@@@Z ; ToCyvogueItem
  00013	59		 pop	 ecx

; 1096 : 	if( pCyvogue )

  00014	85 c0		 test	 eax, eax
  00016	74 11		 je	 SHORT $LN2@SetCyvogue@2

; 1097 : 		pCyvogue->SetCyvogueState( this, rkFlyInfo, false );

  00018	6a 00		 push	 0
  0001a	ff 75 08	 push	 DWORD PTR _rkFlyInfo$[ebp]
  0001d	8b c8		 mov	 ecx, eax
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 ?SetCyvogueState@ioCyvogueItem@@QAEXPAVioBaseChar@@ABUtagCyvogueFlyInfo@@_N@Z ; ioCyvogueItem::SetCyvogueState

; 1100 : 
; 1101 : 	return true;

  00025	b0 01		 mov	 al, 1
  00027	eb 02		 jmp	 SHORT $LN3@SetCyvogue@2
$LN2@SetCyvogue@2:

; 1098 : 	else
; 1099 : 		return false;

  00029	32 c0		 xor	 al, al
$LN3@SetCyvogue@2:
  0002b	5e		 pop	 esi

; 1102 : }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?SetCyvogueModeStateSkill@ioBaseChar@@QAE_NABUtagCyvogueFlyInfo@@@Z ENDP ; ioBaseChar::SetCyvogueModeStateSkill
_TEXT	ENDS
PUBLIC	?CheckEnableCyvogueGauge@ioBaseChar@@QAEXXZ	; ioBaseChar::CheckEnableCyvogueGauge
EXTRN	?CheckEnableCyvogueGauge@ioCyvogueItem@@QAEXPAVioBaseChar@@@Z:PROC ; ioCyvogueItem::CheckEnableCyvogueGauge
; Function compile flags: /Ogsp
;	COMDAT ?CheckEnableCyvogueGauge@ioBaseChar@@QAEXXZ
_TEXT	SEGMENT
?CheckEnableCyvogueGauge@ioBaseChar@@QAEXXZ PROC	; ioBaseChar::CheckEnableCyvogueGauge, COMDAT
; _this$ = ecx

; 1105 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1106 : 	if( !IsNeedProcess() )

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 90 00 01 00
	00		 call	 DWORD PTR [eax+256]
  0000b	84 c0		 test	 al, al
  0000d	74 30		 je	 SHORT $LN1@CheckEnabl@10

; 1107 : 		return;
; 1108 : 
; 1109 : 	if( !CheckGrapplingExceptionState() )

  0000f	8b ce		 mov	 ecx, esi
  00011	e8 00 00 00 00	 call	 ?CheckGrapplingExceptionState@ioBaseChar@@QAE_NXZ ; ioBaseChar::CheckGrapplingExceptionState
  00016	84 c0		 test	 al, al
  00018	74 25		 je	 SHORT $LN1@CheckEnabl@10

; 1110 : 		return;
; 1111 : 
; 1112 : 	if( m_CharState == CS_CYVOGUE_STATE )

  0001a	80 be 10 03 00
	00 62		 cmp	 BYTE PTR [esi+784], 98	; 00000062H
  00021	74 1c		 je	 SHORT $LN1@CheckEnabl@10

; 1113 : 		return;
; 1114 : 
; 1115 : 	ioCyvogueItem *pCyvogue = ToCyvogueItem( GetPriorityItem( SPT_ATTACK ) );

  00023	6a 05		 push	 5
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?ToCyvogueItem@@YAPAVioCyvogueItem@@PAVioItem@@@Z ; ToCyvogueItem
  00032	59		 pop	 ecx

; 1116 : 	if( pCyvogue )

  00033	85 c0		 test	 eax, eax
  00035	74 08		 je	 SHORT $LN1@CheckEnabl@10

; 1117 : 		pCyvogue->CheckEnableCyvogueGauge( this );

  00037	56		 push	 esi
  00038	8b c8		 mov	 ecx, eax
  0003a	e8 00 00 00 00	 call	 ?CheckEnableCyvogueGauge@ioCyvogueItem@@QAEXPAVioBaseChar@@@Z ; ioCyvogueItem::CheckEnableCyvogueGauge
$LN1@CheckEnabl@10:
  0003f	5e		 pop	 esi

; 1118 : }

  00040	c3		 ret	 0
?CheckEnableCyvogueGauge@ioBaseChar@@QAEXXZ ENDP	; ioBaseChar::CheckEnableCyvogueGauge
_TEXT	ENDS
PUBLIC	?IsEnableCyvogueModeState@ioBaseChar@@QAE_NXZ	; ioBaseChar::IsEnableCyvogueModeState
EXTRN	?IsEnableCyvogueGauge@ioCyvogueItem@@QAE_NXZ:PROC ; ioCyvogueItem::IsEnableCyvogueGauge
; Function compile flags: /Ogsp
;	COMDAT ?IsEnableCyvogueModeState@ioBaseChar@@QAE_NXZ
_TEXT	SEGMENT
?IsEnableCyvogueModeState@ioBaseChar@@QAE_NXZ PROC	; ioBaseChar::IsEnableCyvogueModeState, COMDAT
; _this$ = ecx

; 1121 : {

  00000	56		 push	 esi

; 1122 : 	ioCyvogueItem *pCyvogue = ToCyvogueItem( GetPriorityItem( SPT_ATTACK ) );

  00001	6a 05		 push	 5
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?ToCyvogueItem@@YAPAVioCyvogueItem@@PAVioItem@@@Z ; ToCyvogueItem
  00010	59		 pop	 ecx

; 1123 : 	if( !pCyvogue )

  00011	85 c0		 test	 eax, eax

; 1124 : 		return false;

  00013	74 1a		 je	 SHORT $LN1@IsEnableCy

; 1125 : 
; 1126 : 	if( pCyvogue->IsEnableCyvogueGauge() && !IsHasCrown() )

  00015	8b c8		 mov	 ecx, eax
  00017	e8 00 00 00 00	 call	 ?IsEnableCyvogueGauge@ioCyvogueItem@@QAE_NXZ ; ioCyvogueItem::IsEnableCyvogueGauge
  0001c	84 c0		 test	 al, al
  0001e	74 0f		 je	 SHORT $LN1@IsEnableCy
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?IsHasCrown@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsHasCrown
  00027	84 c0		 test	 al, al
  00029	75 04		 jne	 SHORT $LN1@IsEnableCy

; 1127 : 		return true;

  0002b	fe c0		 inc	 al
  0002d	5e		 pop	 esi

; 1130 : }

  0002e	c3		 ret	 0
$LN1@IsEnableCy:

; 1128 : 
; 1129 : 	return false;

  0002f	32 c0		 xor	 al, al
  00031	5e		 pop	 esi

; 1130 : }

  00032	c3		 ret	 0
?IsEnableCyvogueModeState@ioBaseChar@@QAE_NXZ ENDP	; ioBaseChar::IsEnableCyvogueModeState
_TEXT	ENDS
PUBLIC	?SetTrinityState@ioBaseChar@@QAE_NABUtagTrinityInfo@@@Z ; ioBaseChar::SetTrinityState
EXTRN	?SetTrinityState@ioTrinityItem@@QAEXPAVioBaseChar@@ABUtagTrinityInfo@@_N@Z:PROC ; ioTrinityItem::SetTrinityState
; Function compile flags: /Ogsp
;	COMDAT ?SetTrinityState@ioBaseChar@@QAE_NABUtagTrinityInfo@@@Z
_TEXT	SEGMENT
_rkInfo$ = 8						; size = 4
?SetTrinityState@ioBaseChar@@QAE_NABUtagTrinityInfo@@@Z PROC ; ioBaseChar::SetTrinityState, COMDAT
; _this$ = ecx

; 1134 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1135 : 	ioTrinityItem *pTrinityItem = ToTrinityItem( GetPriorityItem( SPT_ATTACK ) );

  00004	6a 05		 push	 5
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?ToTrinityItem@@YAPAVioTrinityItem@@PAVioItem@@@Z ; ToTrinityItem
  00013	59		 pop	 ecx

; 1136 : 	if( !pTrinityItem )

  00014	85 c0		 test	 eax, eax
  00016	75 04		 jne	 SHORT $LN1@SetTrinity

; 1137 : 		return false;

  00018	32 c0		 xor	 al, al
  0001a	eb 0f		 jmp	 SHORT $LN2@SetTrinity
$LN1@SetTrinity:

; 1138 : 
; 1139 : 	pTrinityItem->SetTrinityState( this, rkInfo, false );

  0001c	6a 00		 push	 0
  0001e	ff 75 08	 push	 DWORD PTR _rkInfo$[ebp]
  00021	8b c8		 mov	 ecx, eax
  00023	56		 push	 esi
  00024	e8 00 00 00 00	 call	 ?SetTrinityState@ioTrinityItem@@QAEXPAVioBaseChar@@ABUtagTrinityInfo@@_N@Z ; ioTrinityItem::SetTrinityState

; 1140 : 	return true;

  00029	b0 01		 mov	 al, 1
$LN2@SetTrinity:
  0002b	5e		 pop	 esi

; 1141 : }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?SetTrinityState@ioBaseChar@@QAE_NABUtagTrinityInfo@@@Z ENDP ; ioBaseChar::SetTrinityState
_TEXT	ENDS
PUBLIC	?IsEnableTrinityState@ioBaseChar@@QAE_NXZ	; ioBaseChar::IsEnableTrinityState
; Function compile flags: /Ogsp
;	COMDAT ?IsEnableTrinityState@ioBaseChar@@QAE_NXZ
_TEXT	SEGMENT
?IsEnableTrinityState@ioBaseChar@@QAE_NXZ PROC		; ioBaseChar::IsEnableTrinityState, COMDAT
; _this$ = ecx

; 1144 : {

  00000	56		 push	 esi

; 1145 : 	ioTrinityItem *pTrinity = ToTrinityItem( GetPriorityItem( SPT_ATTACK ) );

  00001	6a 05		 push	 5
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?ToTrinityItem@@YAPAVioTrinityItem@@PAVioItem@@@Z ; ToTrinityItem
  00010	59		 pop	 ecx

; 1146 : 	if( !pTrinity )

  00011	85 c0		 test	 eax, eax
  00013	75 04		 jne	 SHORT $LN2@IsEnableTr

; 1147 : 		return false;

  00015	32 c0		 xor	 al, al
  00017	5e		 pop	 esi

; 1150 : 		return false;
; 1151 : 
; 1152 : 	return true;
; 1153 : }

  00018	c3		 ret	 0
$LN2@IsEnableTr:

; 1148 : 
; 1149 : 	if( IsHasCrown() )

  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?IsHasCrown@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsHasCrown
  00020	f6 d8		 neg	 al
  00022	1a c0		 sbb	 al, al
  00024	fe c0		 inc	 al
  00026	5e		 pop	 esi

; 1150 : 		return false;
; 1151 : 
; 1152 : 	return true;
; 1153 : }

  00027	c3		 ret	 0
?IsEnableTrinityState@ioBaseChar@@QAE_NXZ ENDP		; ioBaseChar::IsEnableTrinityState
_TEXT	ENDS
PUBLIC	?SetDraculaFlyState@ioBaseChar@@QAE_NABUtagDraculaFlyInfo@@@Z ; ioBaseChar::SetDraculaFlyState
EXTRN	?SetFlyState@ioDraculaItem@@QAEXPAVioBaseChar@@ABUtagDraculaFlyInfo@@_N@Z:PROC ; ioDraculaItem::SetFlyState
; Function compile flags: /Ogsp
;	COMDAT ?SetDraculaFlyState@ioBaseChar@@QAE_NABUtagDraculaFlyInfo@@@Z
_TEXT	SEGMENT
_rkInfo$ = 8						; size = 4
?SetDraculaFlyState@ioBaseChar@@QAE_NABUtagDraculaFlyInfo@@@Z PROC ; ioBaseChar::SetDraculaFlyState, COMDAT
; _this$ = ecx

; 1204 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1205 : 	ioDraculaItem *pDraculaItem = ToDraculaItem( GetPriorityItem( SPT_ATTACK ) );

  00004	6a 05		 push	 5
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?ToDraculaItem@@YAPAVioDraculaItem@@PAVioItem@@@Z ; ToDraculaItem
  00013	59		 pop	 ecx

; 1206 : 	if( !pDraculaItem )

  00014	85 c0		 test	 eax, eax
  00016	75 04		 jne	 SHORT $LN1@SetDracula

; 1207 : 		return false;

  00018	32 c0		 xor	 al, al
  0001a	eb 0f		 jmp	 SHORT $LN2@SetDracula
$LN1@SetDracula:

; 1208 : 
; 1209 : 	pDraculaItem->SetFlyState( this, rkInfo, false );

  0001c	6a 00		 push	 0
  0001e	ff 75 08	 push	 DWORD PTR _rkInfo$[ebp]
  00021	8b c8		 mov	 ecx, eax
  00023	56		 push	 esi
  00024	e8 00 00 00 00	 call	 ?SetFlyState@ioDraculaItem@@QAEXPAVioBaseChar@@ABUtagDraculaFlyInfo@@_N@Z ; ioDraculaItem::SetFlyState

; 1210 : 	return true;

  00029	b0 01		 mov	 al, 1
$LN2@SetDracula:
  0002b	5e		 pop	 esi

; 1211 : }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?SetDraculaFlyState@ioBaseChar@@QAE_NABUtagDraculaFlyInfo@@@Z ENDP ; ioBaseChar::SetDraculaFlyState
_TEXT	ENDS
PUBLIC	?IsEnableDraculaFly@ioBaseChar@@QAE_NXZ		; ioBaseChar::IsEnableDraculaFly
EXTRN	?IsEnableGauge@ioDraculaItem@@QAE_NXZ:PROC	; ioDraculaItem::IsEnableGauge
; Function compile flags: /Ogsp
;	COMDAT ?IsEnableDraculaFly@ioBaseChar@@QAE_NXZ
_TEXT	SEGMENT
?IsEnableDraculaFly@ioBaseChar@@QAE_NXZ PROC		; ioBaseChar::IsEnableDraculaFly, COMDAT
; _this$ = ecx

; 1214 : {

  00000	56		 push	 esi

; 1215 : 	ioDraculaItem *pDracula = ToDraculaItem( GetPriorityItem( SPT_ATTACK ) );

  00001	6a 05		 push	 5
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?ToDraculaItem@@YAPAVioDraculaItem@@PAVioItem@@@Z ; ToDraculaItem
  00010	59		 pop	 ecx

; 1216 : 	if( !pDracula )

  00011	85 c0		 test	 eax, eax

; 1217 : 		return false;

  00013	74 1a		 je	 SHORT $LN1@IsEnableDr

; 1218 : 
; 1219 : 	if( pDracula->IsEnableGauge() && !IsHasCrown() )

  00015	8b c8		 mov	 ecx, eax
  00017	e8 00 00 00 00	 call	 ?IsEnableGauge@ioDraculaItem@@QAE_NXZ ; ioDraculaItem::IsEnableGauge
  0001c	84 c0		 test	 al, al
  0001e	74 0f		 je	 SHORT $LN1@IsEnableDr
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?IsHasCrown@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsHasCrown
  00027	84 c0		 test	 al, al
  00029	75 04		 jne	 SHORT $LN1@IsEnableDr

; 1220 : 		return true;

  0002b	fe c0		 inc	 al
  0002d	5e		 pop	 esi

; 1223 : }

  0002e	c3		 ret	 0
$LN1@IsEnableDr:

; 1221 : 
; 1222 : 	return false;

  0002f	32 c0		 xor	 al, al
  00031	5e		 pop	 esi

; 1223 : }

  00032	c3		 ret	 0
?IsEnableDraculaFly@ioBaseChar@@QAE_NXZ ENDP		; ioBaseChar::IsEnableDraculaFly
_TEXT	ENDS
PUBLIC	?SetHakumenDefenseState@ioBaseChar@@QAE_NABUtagHakumenDefenseInfo@@@Z ; ioBaseChar::SetHakumenDefenseState
EXTRN	?SetDefenseState@ioHakumenItem@@QAEXPAVioBaseChar@@ABUtagHakumenDefenseInfo@@_N@Z:PROC ; ioHakumenItem::SetDefenseState
; Function compile flags: /Ogsp
;	COMDAT ?SetHakumenDefenseState@ioBaseChar@@QAE_NABUtagHakumenDefenseInfo@@@Z
_TEXT	SEGMENT
_rkDefenseInfo$ = 8					; size = 4
?SetHakumenDefenseState@ioBaseChar@@QAE_NABUtagHakumenDefenseInfo@@@Z PROC ; ioBaseChar::SetHakumenDefenseState, COMDAT
; _this$ = ecx

; 1227 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1228 : 	ioHakumenItem *pHakumenItem = ToHakumenItem( GetPriorityItem( SPT_ATTACK ) );

  00004	6a 05		 push	 5
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?ToHakumenItem@@YAPAVioHakumenItem@@PAVioItem@@@Z ; ToHakumenItem
  00013	59		 pop	 ecx

; 1229 : 	if( !pHakumenItem )

  00014	85 c0		 test	 eax, eax
  00016	75 04		 jne	 SHORT $LN1@SetHakumen

; 1230 : 		return false;

  00018	32 c0		 xor	 al, al
  0001a	eb 0f		 jmp	 SHORT $LN2@SetHakumen
$LN1@SetHakumen:

; 1231 : 
; 1232 : 	pHakumenItem->SetDefenseState( this, rkDefenseInfo, false );

  0001c	6a 00		 push	 0
  0001e	ff 75 08	 push	 DWORD PTR _rkDefenseInfo$[ebp]
  00021	8b c8		 mov	 ecx, eax
  00023	56		 push	 esi
  00024	e8 00 00 00 00	 call	 ?SetDefenseState@ioHakumenItem@@QAEXPAVioBaseChar@@ABUtagHakumenDefenseInfo@@_N@Z ; ioHakumenItem::SetDefenseState

; 1233 : 	return true;

  00029	b0 01		 mov	 al, 1
$LN2@SetHakumen:
  0002b	5e		 pop	 esi

; 1234 : }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?SetHakumenDefenseState@ioBaseChar@@QAE_NABUtagHakumenDefenseInfo@@@Z ENDP ; ioBaseChar::SetHakumenDefenseState
_TEXT	ENDS
PUBLIC	?IsEnableHakumenDefense@ioBaseChar@@QAE_NXZ	; ioBaseChar::IsEnableHakumenDefense
EXTRN	?IsEnableGauge@ioHakumenItem@@QAE_NXZ:PROC	; ioHakumenItem::IsEnableGauge
; Function compile flags: /Ogsp
;	COMDAT ?IsEnableHakumenDefense@ioBaseChar@@QAE_NXZ
_TEXT	SEGMENT
?IsEnableHakumenDefense@ioBaseChar@@QAE_NXZ PROC	; ioBaseChar::IsEnableHakumenDefense, COMDAT
; _this$ = ecx

; 1237 : {

  00000	56		 push	 esi

; 1238 : 	ioHakumenItem *pHakumen = ToHakumenItem( GetPriorityItem( SPT_ATTACK ) );

  00001	6a 05		 push	 5
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?ToHakumenItem@@YAPAVioHakumenItem@@PAVioItem@@@Z ; ToHakumenItem
  00010	59		 pop	 ecx

; 1239 : 	if( !pHakumen )

  00011	85 c0		 test	 eax, eax

; 1240 : 		return false;

  00013	74 1a		 je	 SHORT $LN1@IsEnableHa

; 1241 : 
; 1242 : 	if( pHakumen->IsEnableGauge() && !IsHasCrown() )

  00015	8b c8		 mov	 ecx, eax
  00017	e8 00 00 00 00	 call	 ?IsEnableGauge@ioHakumenItem@@QAE_NXZ ; ioHakumenItem::IsEnableGauge
  0001c	84 c0		 test	 al, al
  0001e	74 0f		 je	 SHORT $LN1@IsEnableHa
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?IsHasCrown@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsHasCrown
  00027	84 c0		 test	 al, al
  00029	75 04		 jne	 SHORT $LN1@IsEnableHa

; 1243 : 		return true;

  0002b	fe c0		 inc	 al
  0002d	5e		 pop	 esi

; 1246 : }

  0002e	c3		 ret	 0
$LN1@IsEnableHa:

; 1244 : 
; 1245 : 	return false;

  0002f	32 c0		 xor	 al, al
  00031	5e		 pop	 esi

; 1246 : }

  00032	c3		 ret	 0
?IsEnableHakumenDefense@ioBaseChar@@QAE_NXZ ENDP	; ioBaseChar::IsEnableHakumenDefense
_TEXT	ENDS
PUBLIC	?SetDevilFlyState@ioBaseChar@@QAE_NABUtagDevilFlyInfo@@@Z ; ioBaseChar::SetDevilFlyState
EXTRN	?SetFlyState@ioDevilItem@@QAEXPAVioBaseChar@@ABUtagDevilFlyInfo@@_N@Z:PROC ; ioDevilItem::SetFlyState
; Function compile flags: /Ogsp
;	COMDAT ?SetDevilFlyState@ioBaseChar@@QAE_NABUtagDevilFlyInfo@@@Z
_TEXT	SEGMENT
_rkFlyInfo$ = 8						; size = 4
?SetDevilFlyState@ioBaseChar@@QAE_NABUtagDevilFlyInfo@@@Z PROC ; ioBaseChar::SetDevilFlyState, COMDAT
; _this$ = ecx

; 1250 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1251 : 	ioDevilItem *pDevilItem = ToDevilItem( GetPriorityItem( SPT_ATTACK ) );

  00004	6a 05		 push	 5
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?ToDevilItem@@YAPAVioDevilItem@@PAVioItem@@@Z ; ToDevilItem
  00013	59		 pop	 ecx

; 1252 : 	if( !pDevilItem )

  00014	85 c0		 test	 eax, eax
  00016	75 04		 jne	 SHORT $LN1@SetDevilFl

; 1253 : 		return false;

  00018	32 c0		 xor	 al, al
  0001a	eb 0f		 jmp	 SHORT $LN2@SetDevilFl
$LN1@SetDevilFl:

; 1254 : 
; 1255 : 	pDevilItem->SetFlyState( this, rkFlyInfo, false );

  0001c	6a 00		 push	 0
  0001e	ff 75 08	 push	 DWORD PTR _rkFlyInfo$[ebp]
  00021	8b c8		 mov	 ecx, eax
  00023	56		 push	 esi
  00024	e8 00 00 00 00	 call	 ?SetFlyState@ioDevilItem@@QAEXPAVioBaseChar@@ABUtagDevilFlyInfo@@_N@Z ; ioDevilItem::SetFlyState

; 1256 : 	return true;

  00029	b0 01		 mov	 al, 1
$LN2@SetDevilFl:
  0002b	5e		 pop	 esi

; 1257 : }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?SetDevilFlyState@ioBaseChar@@QAE_NABUtagDevilFlyInfo@@@Z ENDP ; ioBaseChar::SetDevilFlyState
_TEXT	ENDS
PUBLIC	?IsEnableDevilFly@ioBaseChar@@QAE_NXZ		; ioBaseChar::IsEnableDevilFly
EXTRN	?IsEnableGauge@ioDevilItem@@QAE_NXZ:PROC	; ioDevilItem::IsEnableGauge
; Function compile flags: /Ogsp
;	COMDAT ?IsEnableDevilFly@ioBaseChar@@QAE_NXZ
_TEXT	SEGMENT
?IsEnableDevilFly@ioBaseChar@@QAE_NXZ PROC		; ioBaseChar::IsEnableDevilFly, COMDAT
; _this$ = ecx

; 1260 : {

  00000	56		 push	 esi

; 1261 : 	ioDevilItem *pDevilItem = ToDevilItem( GetPriorityItem( SPT_ATTACK ) );

  00001	6a 05		 push	 5
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?ToDevilItem@@YAPAVioDevilItem@@PAVioItem@@@Z ; ToDevilItem
  00010	59		 pop	 ecx

; 1262 : 	if( !pDevilItem )

  00011	85 c0		 test	 eax, eax

; 1263 : 		return false;

  00013	74 1a		 je	 SHORT $LN1@IsEnableDe@2

; 1264 : 
; 1265 : 	if( pDevilItem->IsEnableGauge() && !IsHasCrown() )

  00015	8b c8		 mov	 ecx, eax
  00017	e8 00 00 00 00	 call	 ?IsEnableGauge@ioDevilItem@@QAE_NXZ ; ioDevilItem::IsEnableGauge
  0001c	84 c0		 test	 al, al
  0001e	74 0f		 je	 SHORT $LN1@IsEnableDe@2
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?IsHasCrown@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsHasCrown
  00027	84 c0		 test	 al, al
  00029	75 04		 jne	 SHORT $LN1@IsEnableDe@2

; 1266 : 		return true;

  0002b	fe c0		 inc	 al
  0002d	5e		 pop	 esi

; 1269 : }

  0002e	c3		 ret	 0
$LN1@IsEnableDe@2:

; 1267 : 
; 1268 : 	return false;

  0002f	32 c0		 xor	 al, al
  00031	5e		 pop	 esi

; 1269 : }

  00032	c3		 ret	 0
?IsEnableDevilFly@ioBaseChar@@QAE_NXZ ENDP		; ioBaseChar::IsEnableDevilFly
_TEXT	ENDS
PUBLIC	?SetFlashSpecialState@ioBaseChar@@QAE_N_N@Z	; ioBaseChar::SetFlashSpecialState
EXTRN	?SetDashCharge@ioFlash_Item@@QAEXPAVioBaseChar@@@Z:PROC ; ioFlash_Item::SetDashCharge
EXTRN	?SetFlashSpecialState@ioFlash_Item@@QAEXPAVioBaseChar@@@Z:PROC ; ioFlash_Item::SetFlashSpecialState
; Function compile flags: /Ogsp
;	COMDAT ?SetFlashSpecialState@ioBaseChar@@QAE_N_N@Z
_TEXT	SEGMENT
_bDashCharge$ = 8					; size = 1
?SetFlashSpecialState@ioBaseChar@@QAE_N_N@Z PROC	; ioBaseChar::SetFlashSpecialState, COMDAT
; _this$ = ecx

; 1273 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1274 : 	ioFlash_Item *pFlashItem = ToFlashItem( GetPriorityItem( SPT_ATTACK ) );

  00005	6a 05		 push	 5
  00007	8b f1		 mov	 esi, ecx
  00009	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?ToFlashItem@@YAPAVioFlash_Item@@PAVioItem@@@Z ; ToFlashItem
  00014	8b f8		 mov	 edi, eax
  00016	59		 pop	 ecx

; 1275 : 	if( !pFlashItem )

  00017	85 ff		 test	 edi, edi
  00019	75 04		 jne	 SHORT $LN2@SetFlashSp

; 1276 : 		return false;

  0001b	32 c0		 xor	 al, al
  0001d	eb 18		 jmp	 SHORT $LN3@SetFlashSp
$LN2@SetFlashSp:

; 1277 : 
; 1278 : 	pFlashItem->SetFlashSpecialState( this );

  0001f	56		 push	 esi
  00020	8b cf		 mov	 ecx, edi
  00022	e8 00 00 00 00	 call	 ?SetFlashSpecialState@ioFlash_Item@@QAEXPAVioBaseChar@@@Z ; ioFlash_Item::SetFlashSpecialState

; 1279 : 
; 1280 : 	if ( bDashCharge )

  00027	80 7d 08 00	 cmp	 BYTE PTR _bDashCharge$[ebp], 0
  0002b	74 08		 je	 SHORT $LN1@SetFlashSp

; 1281 : 		pFlashItem->SetDashCharge( this );

  0002d	56		 push	 esi
  0002e	8b cf		 mov	 ecx, edi
  00030	e8 00 00 00 00	 call	 ?SetDashCharge@ioFlash_Item@@QAEXPAVioBaseChar@@@Z ; ioFlash_Item::SetDashCharge
$LN1@SetFlashSp:

; 1282 : 
; 1283 : 	return true;

  00035	b0 01		 mov	 al, 1
$LN3@SetFlashSp:
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi

; 1284 : }

  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?SetFlashSpecialState@ioBaseChar@@QAE_N_N@Z ENDP	; ioBaseChar::SetFlashSpecialState
_TEXT	ENDS
PUBLIC	?IsEnableFlashSpecial@ioBaseChar@@QAE_NXZ	; ioBaseChar::IsEnableFlashSpecial
EXTRN	?IsEnableGauge@ioFlash_Item@@QAE_NXZ:PROC	; ioFlash_Item::IsEnableGauge
; Function compile flags: /Ogsp
;	COMDAT ?IsEnableFlashSpecial@ioBaseChar@@QAE_NXZ
_TEXT	SEGMENT
?IsEnableFlashSpecial@ioBaseChar@@QAE_NXZ PROC		; ioBaseChar::IsEnableFlashSpecial, COMDAT
; _this$ = ecx

; 1287 : {

  00000	56		 push	 esi

; 1288 : 	ioFlash_Item *pFlashItem = ToFlashItem( GetPriorityItem( SPT_ATTACK ) );

  00001	6a 05		 push	 5
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?ToFlashItem@@YAPAVioFlash_Item@@PAVioItem@@@Z ; ToFlashItem
  00010	59		 pop	 ecx

; 1289 : 	if( !pFlashItem )

  00011	85 c0		 test	 eax, eax

; 1290 : 		return false;

  00013	74 1a		 je	 SHORT $LN1@IsEnableFl

; 1291 : 
; 1292 : 	if( pFlashItem->IsEnableGauge() && !IsHasCrown() )

  00015	8b c8		 mov	 ecx, eax
  00017	e8 00 00 00 00	 call	 ?IsEnableGauge@ioFlash_Item@@QAE_NXZ ; ioFlash_Item::IsEnableGauge
  0001c	84 c0		 test	 al, al
  0001e	74 0f		 je	 SHORT $LN1@IsEnableFl
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?IsHasCrown@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsHasCrown
  00027	84 c0		 test	 al, al
  00029	75 04		 jne	 SHORT $LN1@IsEnableFl

; 1293 : 		return true;

  0002b	fe c0		 inc	 al
  0002d	5e		 pop	 esi

; 1296 : }

  0002e	c3		 ret	 0
$LN1@IsEnableFl:

; 1294 : 
; 1295 : 	return false;

  0002f	32 c0		 xor	 al, al
  00031	5e		 pop	 esi

; 1296 : }

  00032	c3		 ret	 0
?IsEnableFlashSpecial@ioBaseChar@@QAE_NXZ ENDP		; ioBaseChar::IsEnableFlashSpecial
_TEXT	ENDS
PUBLIC	?SetEvyBlinkStateByJumpDash@ioBaseChar@@QAE_NABUtagEvyBlinkInfo@@@Z ; ioBaseChar::SetEvyBlinkStateByJumpDash
EXTRN	?SetEvyBlinkState@ioEvyItem@@QAEXPAVioBaseChar@@ABUtagEvyBlinkInfo@@_N@Z:PROC ; ioEvyItem::SetEvyBlinkState
; Function compile flags: /Ogsp
;	COMDAT ?SetEvyBlinkStateByJumpDash@ioBaseChar@@QAE_NABUtagEvyBlinkInfo@@@Z
_TEXT	SEGMENT
_rkInfo$ = 8						; size = 4
?SetEvyBlinkStateByJumpDash@ioBaseChar@@QAE_NABUtagEvyBlinkInfo@@@Z PROC ; ioBaseChar::SetEvyBlinkStateByJumpDash, COMDAT
; _this$ = ecx

; 1300 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1301 : 	ioEvyItem *pEvyItem = ToEvyItem( GetPriorityItem( SPT_ATTACK) );

  00004	6a 05		 push	 5
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?ToEvyItem@@YAPAVioEvyItem@@PAVioItem@@@Z ; ToEvyItem
  00013	59		 pop	 ecx

; 1302 : 	if( !pEvyItem )

  00014	85 c0		 test	 eax, eax
  00016	75 04		 jne	 SHORT $LN1@SetEvyBlin

; 1303 : 		return false;

  00018	32 c0		 xor	 al, al
  0001a	eb 0f		 jmp	 SHORT $LN2@SetEvyBlin
$LN1@SetEvyBlin:

; 1304 : 
; 1305 : 	pEvyItem->SetEvyBlinkState( this, rkInfo, false );

  0001c	6a 00		 push	 0
  0001e	ff 75 08	 push	 DWORD PTR _rkInfo$[ebp]
  00021	8b c8		 mov	 ecx, eax
  00023	56		 push	 esi
  00024	e8 00 00 00 00	 call	 ?SetEvyBlinkState@ioEvyItem@@QAEXPAVioBaseChar@@ABUtagEvyBlinkInfo@@_N@Z ; ioEvyItem::SetEvyBlinkState

; 1306 : 	return true;

  00029	b0 01		 mov	 al, 1
$LN2@SetEvyBlin:
  0002b	5e		 pop	 esi

; 1307 : }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?SetEvyBlinkStateByJumpDash@ioBaseChar@@QAE_NABUtagEvyBlinkInfo@@@Z ENDP ; ioBaseChar::SetEvyBlinkStateByJumpDash
_TEXT	ENDS
PUBLIC	?IsSuddenAttackState@ioBaseChar@@QAE_NXZ	; ioBaseChar::IsSuddenAttackState
; Function compile flags: /Ogsp
;	COMDAT ?IsSuddenAttackState@ioBaseChar@@QAE_NXZ
_TEXT	SEGMENT
?IsSuddenAttackState@ioBaseChar@@QAE_NXZ PROC		; ioBaseChar::IsSuddenAttackState, COMDAT
; _this$ = ecx

; 1312 : 	ioAttackableItem *pAttackable = ToAttackableItem(m_pEquipSlot->GetWeapon());

  00000	8b 89 48 03 00
	00		 mov	 ecx, DWORD PTR [ecx+840]
  00006	e8 00 00 00 00	 call	 ?GetWeapon@ioEquipSlot@@QBEPAVioWeaponItem@@XZ ; ioEquipSlot::GetWeapon
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?ToAttackableItem@@YAPAVioAttackableItem@@PAVioItem@@@Z ; ToAttackableItem
  00011	59		 pop	 ecx

; 1313 : 	if( pAttackable && ToSuddenAttackItem( pAttackable ) )

  00012	85 c0		 test	 eax, eax
  00014	74 0e		 je	 SHORT $LN1@IsSuddenAt
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ?ToSuddenAttackItem@@YAPAVioSuddenAttackItem@@PAVioItem@@@Z ; ToSuddenAttackItem
  0001c	59		 pop	 ecx
  0001d	85 c0		 test	 eax, eax
  0001f	74 03		 je	 SHORT $LN1@IsSuddenAt

; 1314 : 		return true;

  00021	b0 01		 mov	 al, 1

; 1317 : }

  00023	c3		 ret	 0
$LN1@IsSuddenAt:

; 1315 : 
; 1316 : 	return false;

  00024	32 c0		 xor	 al, al

; 1317 : }

  00026	c3		 ret	 0
?IsSuddenAttackState@ioBaseChar@@QAE_NXZ ENDP		; ioBaseChar::IsSuddenAttackState
_TEXT	ENDS
PUBLIC	?FillSuddenAttackStateInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ; ioBaseChar::FillSuddenAttackStateInfo
EXTRN	??6SP2Packet@@QAEAAV0@H@Z:PROC			; SP2Packet::operator<<
; Function compile flags: /Ogsp
;	COMDAT ?FillSuddenAttackStateInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z
_TEXT	SEGMENT
_rkPacket$ = 8						; size = 4
?FillSuddenAttackStateInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z PROC ; ioBaseChar::FillSuddenAttackStateInfo, COMDAT
; _this$ = ecx

; 1320 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1321 : 	ioSuddenAttackItem *pSuddenItem = ToSuddenAttackItem( GetWeapon() );

  00003	e8 00 00 00 00	 call	 ?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ ; ioBaseChar::GetWeapon
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ?ToSuddenAttackItem@@YAPAVioSuddenAttackItem@@PAVioItem@@@Z ; ToSuddenAttackItem
  0000e	59		 pop	 ecx

; 1322 : 	if( !pSuddenItem )

  0000f	85 c0		 test	 eax, eax
  00011	74 0e		 je	 SHORT $LN2@FillSudden

; 1323 : 		return;
; 1324 : 
; 1325 : 	rkPacket << (int)pSuddenItem->GetMeshType();

  00013	ff b0 d4 19 00
	00		 push	 DWORD PTR [eax+6612]
  00019	8b 4d 08	 mov	 ecx, DWORD PTR _rkPacket$[ebp]
  0001c	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@H@Z ; SP2Packet::operator<<
$LN2@FillSudden:

; 1326 : 	return;
; 1327 : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?FillSuddenAttackStateInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ENDP ; ioBaseChar::FillSuddenAttackStateInfo
_TEXT	ENDS
PUBLIC	?SetSuddenAttackStateInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ; ioBaseChar::SetSuddenAttackStateInfo
EXTRN	?ChangeAttackType@ioSuddenAttackItem@@QAEXPAVioBaseChar@@W4ItemMeshType@1@_N22@Z:PROC ; ioSuddenAttackItem::ChangeAttackType
; Function compile flags: /Ogsp
;	COMDAT ?SetSuddenAttackStateInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z
_TEXT	SEGMENT
_nMeshType$ = 8						; size = 4
_rkPacket$ = 8						; size = 4
?SetSuddenAttackStateInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z PROC ; ioBaseChar::SetSuddenAttackStateInfo, COMDAT
; _this$ = ecx

; 1330 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1331 : 	int nMeshType;
; 1332 : 	rkPacket >> nMeshType;

  00004	8d 45 08	 lea	 eax, DWORD PTR _nMeshType$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _rkPacket$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??5SP2Packet@@QAEAAV0@AAH@Z ; SP2Packet::operator>>

; 1333 : 
; 1334 : 	m_nSuddenMeshType = nMeshType;

  00012	8b 45 08	 mov	 eax, DWORD PTR _nMeshType$[ebp]

; 1335 : 
; 1336 : 	ioSuddenAttackItem *pSuddenItem = ToSuddenAttackItem( GetWeapon() );

  00015	8b ce		 mov	 ecx, esi
  00017	89 86 3c 3c 00
	00		 mov	 DWORD PTR [esi+15420], eax
  0001d	e8 00 00 00 00	 call	 ?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ ; ioBaseChar::GetWeapon
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?ToSuddenAttackItem@@YAPAVioSuddenAttackItem@@PAVioItem@@@Z ; ToSuddenAttackItem
  00028	59		 pop	 ecx

; 1337 : 	if( pSuddenItem )

  00029	33 c9		 xor	 ecx, ecx
  0002b	3b c1		 cmp	 eax, ecx
  0002d	74 0e		 je	 SHORT $LN1@SetSuddenA

; 1338 : 	{
; 1339 : 		pSuddenItem->ChangeAttackType( this, (ioSuddenAttackItem::ItemMeshType)nMeshType );

  0002f	51		 push	 ecx
  00030	51		 push	 ecx
  00031	51		 push	 ecx
  00032	ff 75 08	 push	 DWORD PTR _nMeshType$[ebp]
  00035	8b c8		 mov	 ecx, eax
  00037	56		 push	 esi
  00038	e8 00 00 00 00	 call	 ?ChangeAttackType@ioSuddenAttackItem@@QAEXPAVioBaseChar@@W4ItemMeshType@1@_N22@Z ; ioSuddenAttackItem::ChangeAttackType
$LN1@SetSuddenA:
  0003d	5e		 pop	 esi

; 1340 : 	}
; 1341 : }

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
?SetSuddenAttackStateInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ENDP ; ioBaseChar::SetSuddenAttackStateInfo
_TEXT	ENDS
PUBLIC	?SetSlasherSpecialState@ioBaseChar@@QAE_NABUtagSlasherRunInfo@@@Z ; ioBaseChar::SetSlasherSpecialState
EXTRN	?SetSpecialState@ioSlasher_Item@@QAEXW4SlasherSpecialState@1@@Z:PROC ; ioSlasher_Item::SetSpecialState
EXTRN	?SetCurRunInfo@ioSlasher_Item@@QAEXABUtagSlasherRunInfo@@_N@Z:PROC ; ioSlasher_Item::SetCurRunInfo
EXTRN	?Init@ioSlasher_Item@@QAEXXZ:PROC		; ioSlasher_Item::Init
; Function compile flags: /Ogsp
;	COMDAT ?SetSlasherSpecialState@ioBaseChar@@QAE_NABUtagSlasherRunInfo@@@Z
_TEXT	SEGMENT
_RunInfo$ = 8						; size = 4
?SetSlasherSpecialState@ioBaseChar@@QAE_NABUtagSlasherRunInfo@@@Z PROC ; ioBaseChar::SetSlasherSpecialState, COMDAT
; _this$ = ecx

; 1345 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1346 : 	ioSlasher_Item *pSlasherItem = ToSlasherItem( GetPriorityItem( SPT_ATTACK ) );

  00005	6a 05		 push	 5
  00007	8b f9		 mov	 edi, ecx
  00009	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?ToSlasherItem@@YAPAVioSlasher_Item@@PAVioItem@@@Z ; ToSlasherItem
  00014	8b f0		 mov	 esi, eax
  00016	59		 pop	 ecx

; 1347 : 	if( !pSlasherItem )

  00017	85 f6		 test	 esi, esi
  00019	75 04		 jne	 SHORT $LN1@SetSlasher

; 1348 : 		return false;

  0001b	32 c0		 xor	 al, al
  0001d	eb 29		 jmp	 SHORT $LN2@SetSlasher
$LN1@SetSlasher:

; 1349 : 
; 1350 : 	pSlasherItem->Init();

  0001f	8b ce		 mov	 ecx, esi
  00021	e8 00 00 00 00	 call	 ?Init@ioSlasher_Item@@QAEXXZ ; ioSlasher_Item::Init

; 1351 : 	pSlasherItem->SetCurRunInfo( RunInfo, true );

  00026	6a 01		 push	 1
  00028	ff 75 08	 push	 DWORD PTR _RunInfo$[ebp]
  0002b	8b ce		 mov	 ecx, esi
  0002d	e8 00 00 00 00	 call	 ?SetCurRunInfo@ioSlasher_Item@@QAEXABUtagSlasherRunInfo@@_N@Z ; ioSlasher_Item::SetCurRunInfo

; 1352 : 	pSlasherItem->SetSpecialState( ioSlasher_Item::SSS_Find_Target );

  00032	6a 01		 push	 1
  00034	8b ce		 mov	 ecx, esi
  00036	e8 00 00 00 00	 call	 ?SetSpecialState@ioSlasher_Item@@QAEXW4SlasherSpecialState@1@@Z ; ioSlasher_Item::SetSpecialState

; 1353 : 
; 1354 : 	SetState( CS_SLASHER_SPECIAL );

  0003b	6a 01		 push	 1
  0003d	6a 71		 push	 113			; 00000071H
  0003f	8b cf		 mov	 ecx, edi
  00041	e8 00 00 00 00	 call	 ?SetState@ioBaseChar@@QAEXH_N@Z ; ioBaseChar::SetState

; 1355 : 
; 1356 : 	return true;

  00046	b0 01		 mov	 al, 1
$LN2@SetSlasher:
  00048	5f		 pop	 edi
  00049	5e		 pop	 esi

; 1357 : }

  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
?SetSlasherSpecialState@ioBaseChar@@QAE_NABUtagSlasherRunInfo@@@Z ENDP ; ioBaseChar::SetSlasherSpecialState
_TEXT	ENDS
PUBLIC	?IsEnableSlasherSpecial@ioBaseChar@@QAE_NXZ	; ioBaseChar::IsEnableSlasherSpecial
EXTRN	?IsEnableGauge@ioSlasher_Item@@QAE_NXZ:PROC	; ioSlasher_Item::IsEnableGauge
; Function compile flags: /Ogsp
;	COMDAT ?IsEnableSlasherSpecial@ioBaseChar@@QAE_NXZ
_TEXT	SEGMENT
?IsEnableSlasherSpecial@ioBaseChar@@QAE_NXZ PROC	; ioBaseChar::IsEnableSlasherSpecial, COMDAT
; _this$ = ecx

; 1360 : {

  00000	56		 push	 esi

; 1361 : 	ioSlasher_Item *pSlasherItem = ToSlasherItem( GetPriorityItem( SPT_ATTACK ) );

  00001	6a 05		 push	 5
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?ToSlasherItem@@YAPAVioSlasher_Item@@PAVioItem@@@Z ; ToSlasherItem
  00010	59		 pop	 ecx

; 1362 : 	if( !pSlasherItem )

  00011	85 c0		 test	 eax, eax

; 1363 : 		return false;

  00013	74 1a		 je	 SHORT $LN1@IsEnableSl

; 1364 : 
; 1365 : 	if( pSlasherItem->IsEnableGauge() && !IsHasCrown() )

  00015	8b c8		 mov	 ecx, eax
  00017	e8 00 00 00 00	 call	 ?IsEnableGauge@ioSlasher_Item@@QAE_NXZ ; ioSlasher_Item::IsEnableGauge
  0001c	84 c0		 test	 al, al
  0001e	74 0f		 je	 SHORT $LN1@IsEnableSl
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?IsHasCrown@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsHasCrown
  00027	84 c0		 test	 al, al
  00029	75 04		 jne	 SHORT $LN1@IsEnableSl

; 1366 : 		return true;

  0002b	fe c0		 inc	 al
  0002d	5e		 pop	 esi

; 1369 : }

  0002e	c3		 ret	 0
$LN1@IsEnableSl:

; 1367 : 
; 1368 : 	return false;

  0002f	32 c0		 xor	 al, al
  00031	5e		 pop	 esi

; 1369 : }

  00032	c3		 ret	 0
?IsEnableSlasherSpecial@ioBaseChar@@QAE_NXZ ENDP	; ioBaseChar::IsEnableSlasherSpecial
_TEXT	ENDS
PUBLIC	?IsTopBlAttackState@ioBaseChar@@QAE_NXZ		; ioBaseChar::IsTopBlAttackState
; Function compile flags: /Ogsp
;	COMDAT ?IsTopBlAttackState@ioBaseChar@@QAE_NXZ
_TEXT	SEGMENT
?IsTopBlAttackState@ioBaseChar@@QAE_NXZ PROC		; ioBaseChar::IsTopBlAttackState, COMDAT
; _this$ = ecx

; 1374 : 	ioAttackableItem *pAttackable = ToAttackableItem(m_pEquipSlot->GetWeapon());

  00000	8b 89 48 03 00
	00		 mov	 ecx, DWORD PTR [ecx+840]
  00006	56		 push	 esi
  00007	e8 00 00 00 00	 call	 ?GetWeapon@ioEquipSlot@@QBEPAVioWeaponItem@@XZ ; ioEquipSlot::GetWeapon
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?ToAttackableItem@@YAPAVioAttackableItem@@PAVioItem@@@Z ; ToAttackableItem
  00012	8b f0		 mov	 esi, eax
  00014	59		 pop	 ecx

; 1375 : 	if( pAttackable && ToDummyCharItem2( pAttackable ) && 
; 1376 : 		ToDummyCharItem2( pAttackable )->GetMeshType() == ioDummyCharItem2::IMT_EXTRA )

  00015	85 f6		 test	 esi, esi
  00017	74 1f		 je	 SHORT $LN1@IsTopBlAtt
  00019	56		 push	 esi
  0001a	e8 00 00 00 00	 call	 ?ToDummyCharItem2@@YAPAVioDummyCharItem2@@PAVioItem@@@Z ; ToDummyCharItem2
  0001f	59		 pop	 ecx
  00020	85 c0		 test	 eax, eax
  00022	74 14		 je	 SHORT $LN1@IsTopBlAtt
  00024	56		 push	 esi
  00025	e8 00 00 00 00	 call	 ?ToDummyCharItem2@@YAPAVioDummyCharItem2@@PAVioItem@@@Z ; ToDummyCharItem2
  0002a	83 b8 74 1b 00
	00 01		 cmp	 DWORD PTR [eax+7028], 1
  00031	59		 pop	 ecx
  00032	75 04		 jne	 SHORT $LN1@IsTopBlAtt

; 1377 : 		return true;

  00034	b0 01		 mov	 al, 1
  00036	5e		 pop	 esi

; 1380 : }

  00037	c3		 ret	 0
$LN1@IsTopBlAtt:

; 1378 : 
; 1379 : 	return false;

  00038	32 c0		 xor	 al, al
  0003a	5e		 pop	 esi

; 1380 : }

  0003b	c3		 ret	 0
?IsTopBlAttackState@ioBaseChar@@QAE_NXZ ENDP		; ioBaseChar::IsTopBlAttackState
_TEXT	ENDS
PUBLIC	?SetTopBlExtendStateInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ; ioBaseChar::SetTopBlExtendStateInfo
EXTRN	?ChangeAttackType@ioDummyCharItem2@@QAEXPAVioBaseChar@@W4ItemMeshType@1@_N22@Z:PROC ; ioDummyCharItem2::ChangeAttackType
; Function compile flags: /Ogsp
;	COMDAT ?SetTopBlExtendStateInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z
_TEXT	SEGMENT
_rkPacket$ = 8						; size = 4
?SetTopBlExtendStateInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z PROC ; ioBaseChar::SetTopBlExtendStateInfo, COMDAT
; _this$ = ecx

; 1383 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1384 : 	ioDummyCharItem2 *pDummyCharItem2 = ToDummyCharItem2( GetWeapon() );

  00003	e8 00 00 00 00	 call	 ?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ ; ioBaseChar::GetWeapon
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ?ToDummyCharItem2@@YAPAVioDummyCharItem2@@PAVioItem@@@Z ; ToDummyCharItem2
  0000e	59		 pop	 ecx

; 1385 : 	if( pDummyCharItem2 )

  0000f	33 c9		 xor	 ecx, ecx
  00011	3b c1		 cmp	 eax, ecx
  00013	74 0d		 je	 SHORT $LN1@SetTopBlEx@2

; 1386 : 		pDummyCharItem2->ChangeAttackType( this, (ioDummyCharItem2::IMT_EXTRA) );

  00015	51		 push	 ecx
  00016	51		 push	 ecx
  00017	51		 push	 ecx
  00018	6a 01		 push	 1
  0001a	56		 push	 esi
  0001b	8b c8		 mov	 ecx, eax
  0001d	e8 00 00 00 00	 call	 ?ChangeAttackType@ioDummyCharItem2@@QAEXPAVioBaseChar@@W4ItemMeshType@1@_N22@Z ; ioDummyCharItem2::ChangeAttackType
$LN1@SetTopBlEx@2:
  00022	5e		 pop	 esi

; 1387 : }

  00023	c2 04 00	 ret	 4
?SetTopBlExtendStateInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ENDP ; ioBaseChar::SetTopBlExtendStateInfo
_TEXT	ENDS
PUBLIC	?IsSuperDimensionWeaponIncState@ioBaseChar@@QAE_NXZ ; ioBaseChar::IsSuperDimensionWeaponIncState
; Function compile flags: /Ogsp
;	COMDAT ?IsSuperDimensionWeaponIncState@ioBaseChar@@QAE_NXZ
_TEXT	SEGMENT
?IsSuperDimensionWeaponIncState@ioBaseChar@@QAE_NXZ PROC ; ioBaseChar::IsSuperDimensionWeaponIncState, COMDAT
; _this$ = ecx

; 1431 : 	ioAttackableItem *pAttackable = ToAttackableItem(m_pEquipSlot->GetWeapon());

  00000	8b 89 48 03 00
	00		 mov	 ecx, DWORD PTR [ecx+840]
  00006	56		 push	 esi
  00007	e8 00 00 00 00	 call	 ?GetWeapon@ioEquipSlot@@QBEPAVioWeaponItem@@XZ ; ioEquipSlot::GetWeapon
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?ToAttackableItem@@YAPAVioAttackableItem@@PAVioItem@@@Z ; ToAttackableItem
  00012	8b f0		 mov	 esi, eax
  00014	59		 pop	 ecx

; 1432 : 	if( pAttackable && ToSuperDimensionItem( pAttackable ) && ToSuperDimensionItem( pAttackable )->GetWeaponStep() >= 0 )

  00015	85 f6		 test	 esi, esi
  00017	74 1f		 je	 SHORT $LN1@IsSuperDim
  00019	56		 push	 esi
  0001a	e8 00 00 00 00	 call	 ?ToSuperDimensionItem@@YAPAVioSuperDimensionItem@@PAVioItem@@@Z ; ToSuperDimensionItem
  0001f	59		 pop	 ecx
  00020	85 c0		 test	 eax, eax
  00022	74 14		 je	 SHORT $LN1@IsSuperDim
  00024	56		 push	 esi
  00025	e8 00 00 00 00	 call	 ?ToSuperDimensionItem@@YAPAVioSuperDimensionItem@@PAVioItem@@@Z ; ToSuperDimensionItem
  0002a	83 b8 28 1d 00
	00 00		 cmp	 DWORD PTR [eax+7464], 0
  00031	59		 pop	 ecx
  00032	7c 04		 jl	 SHORT $LN1@IsSuperDim

; 1433 : 		return true;

  00034	b0 01		 mov	 al, 1
  00036	5e		 pop	 esi

; 1436 : }

  00037	c3		 ret	 0
$LN1@IsSuperDim:

; 1434 : 
; 1435 : 	return false;

  00038	32 c0		 xor	 al, al
  0003a	5e		 pop	 esi

; 1436 : }

  0003b	c3		 ret	 0
?IsSuperDimensionWeaponIncState@ioBaseChar@@QAE_NXZ ENDP ; ioBaseChar::IsSuperDimensionWeaponIncState
_TEXT	ENDS
PUBLIC	?FillSuperDimensionWeaponInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ; ioBaseChar::FillSuperDimensionWeaponInfo
; Function compile flags: /Ogsp
;	COMDAT ?FillSuperDimensionWeaponInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z
_TEXT	SEGMENT
_rkPacket$ = 8						; size = 4
?FillSuperDimensionWeaponInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z PROC ; ioBaseChar::FillSuperDimensionWeaponInfo, COMDAT
; _this$ = ecx

; 1439 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1440 : 	ioSuperDimensionItem* pSuperDimensionItem = ToSuperDimensionItem( GetWeapon() );

  00003	e8 00 00 00 00	 call	 ?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ ; ioBaseChar::GetWeapon
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ?ToSuperDimensionItem@@YAPAVioSuperDimensionItem@@PAVioItem@@@Z ; ToSuperDimensionItem
  0000e	59		 pop	 ecx

; 1441 : 	if( !pSuperDimensionItem )

  0000f	85 c0		 test	 eax, eax
  00011	74 0e		 je	 SHORT $LN2@FillSuperD

; 1442 : 		return;
; 1443 : 
; 1444 : 	rkPacket << pSuperDimensionItem->GetWeaponStep();

  00013	ff b0 28 1d 00
	00		 push	 DWORD PTR [eax+7464]
  00019	8b 4d 08	 mov	 ecx, DWORD PTR _rkPacket$[ebp]
  0001c	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@H@Z ; SP2Packet::operator<<
$LN2@FillSuperD:

; 1445 : 	return;
; 1446 : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?FillSuperDimensionWeaponInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ENDP ; ioBaseChar::FillSuperDimensionWeaponInfo
_TEXT	ENDS
PUBLIC	?SetSuperDimensionWeaponInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ; ioBaseChar::SetSuperDimensionWeaponInfo
EXTRN	?SetWeaponStep@ioSuperDimensionItem@@QAEXPAVioBaseChar@@H@Z:PROC ; ioSuperDimensionItem::SetWeaponStep
; Function compile flags: /Ogsp
;	COMDAT ?SetSuperDimensionWeaponInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z
_TEXT	SEGMENT
_nWeaponStep$ = 8					; size = 4
_rkPacket$ = 8						; size = 4
?SetSuperDimensionWeaponInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z PROC ; ioBaseChar::SetSuperDimensionWeaponInfo, COMDAT
; _this$ = ecx

; 1449 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1450 : 	int nWeaponStep;
; 1451 : 	rkPacket >> nWeaponStep;

  00004	8d 45 08	 lea	 eax, DWORD PTR _nWeaponStep$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _rkPacket$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??5SP2Packet@@QAEAAV0@AAH@Z ; SP2Packet::operator>>

; 1452 : 
; 1453 : 	ioSuperDimensionItem* pSuperDimensionItem = ToSuperDimensionItem( GetWeapon() );

  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ ; ioBaseChar::GetWeapon
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?ToSuperDimensionItem@@YAPAVioSuperDimensionItem@@PAVioItem@@@Z ; ToSuperDimensionItem
  0001f	59		 pop	 ecx

; 1454 : 	if( pSuperDimensionItem )

  00020	85 c0		 test	 eax, eax
  00022	74 0b		 je	 SHORT $LN1@SetSuperDi

; 1455 : 		pSuperDimensionItem->SetWeaponStep( this, nWeaponStep );

  00024	ff 75 08	 push	 DWORD PTR _nWeaponStep$[ebp]
  00027	8b c8		 mov	 ecx, eax
  00029	56		 push	 esi
  0002a	e8 00 00 00 00	 call	 ?SetWeaponStep@ioSuperDimensionItem@@QAEXPAVioBaseChar@@H@Z ; ioSuperDimensionItem::SetWeaponStep
$LN1@SetSuperDi:
  0002f	5e		 pop	 esi

; 1456 : }

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
?SetSuperDimensionWeaponInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ENDP ; ioBaseChar::SetSuperDimensionWeaponInfo
_TEXT	ENDS
PUBLIC	?FillGalaxyInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ; ioBaseChar::FillGalaxyInfo
EXTRN	?FillGalaxyInfo@ioGalaxyItem@@QAEXPAVioBaseChar@@AAVSP2Packet@@@Z:PROC ; ioGalaxyItem::FillGalaxyInfo
; Function compile flags: /Ogsp
;	COMDAT ?FillGalaxyInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z
_TEXT	SEGMENT
_rkPacket$ = 8						; size = 4
?FillGalaxyInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z PROC	; ioBaseChar::FillGalaxyInfo, COMDAT
; _this$ = ecx

; 1460 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1461 : 	ioGalaxyItem* pGalaxy = ToGalaxyItem( GetWeapon() );

  00006	e8 00 00 00 00	 call	 ?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ ; ioBaseChar::GetWeapon
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?ToGalaxyItem@@YAPAVioGalaxyItem@@PAVioItem@@@Z ; ToGalaxyItem
  00011	59		 pop	 ecx

; 1462 : 	if( pGalaxy )

  00012	85 c0		 test	 eax, eax
  00014	74 0b		 je	 SHORT $LN1@FillGalaxy

; 1463 : 		pGalaxy->FillGalaxyInfo( this, rkPacket );

  00016	ff 75 08	 push	 DWORD PTR _rkPacket$[ebp]
  00019	8b c8		 mov	 ecx, eax
  0001b	56		 push	 esi
  0001c	e8 00 00 00 00	 call	 ?FillGalaxyInfo@ioGalaxyItem@@QAEXPAVioBaseChar@@AAVSP2Packet@@@Z ; ioGalaxyItem::FillGalaxyInfo
$LN1@FillGalaxy:
  00021	5e		 pop	 esi

; 1464 : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?FillGalaxyInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ENDP	; ioBaseChar::FillGalaxyInfo
_TEXT	ENDS
PUBLIC	?SetGalaxyInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z	; ioBaseChar::SetGalaxyInfo
EXTRN	?SetGalaxyInfo@ioGalaxyItem@@QAEXPAVioBaseChar@@AAVSP2Packet@@@Z:PROC ; ioGalaxyItem::SetGalaxyInfo
; Function compile flags: /Ogsp
;	COMDAT ?SetGalaxyInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z
_TEXT	SEGMENT
_rkPacket$ = 8						; size = 4
?SetGalaxyInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z PROC	; ioBaseChar::SetGalaxyInfo, COMDAT
; _this$ = ecx

; 1467 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1468 : 	ioGalaxyItem* pGalaxy = ToGalaxyItem( GetWeapon() );

  00006	e8 00 00 00 00	 call	 ?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ ; ioBaseChar::GetWeapon
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?ToGalaxyItem@@YAPAVioGalaxyItem@@PAVioItem@@@Z ; ToGalaxyItem
  00011	59		 pop	 ecx

; 1469 : 	if( pGalaxy )	

  00012	85 c0		 test	 eax, eax
  00014	74 0b		 je	 SHORT $LN1@SetGalaxyI

; 1470 : 		pGalaxy->SetGalaxyInfo( this, rkPacket );

  00016	ff 75 08	 push	 DWORD PTR _rkPacket$[ebp]
  00019	8b c8		 mov	 ecx, eax
  0001b	56		 push	 esi
  0001c	e8 00 00 00 00	 call	 ?SetGalaxyInfo@ioGalaxyItem@@QAEXPAVioBaseChar@@AAVSP2Packet@@@Z ; ioGalaxyItem::SetGalaxyInfo
$LN1@SetGalaxyI:
  00021	5e		 pop	 esi

; 1471 : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?SetGalaxyInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ENDP	; ioBaseChar::SetGalaxyInfo
_TEXT	ENDS
PUBLIC	?SetThunderBirdObjectSpecialState@ioBaseChar@@QAEX_N@Z ; ioBaseChar::SetThunderBirdObjectSpecialState
EXTRN	?Init@ioThunderBirdObjectItem@@QAEXXZ:PROC	; ioThunderBirdObjectItem::Init
EXTRN	?GetObjectA@ioBaseChar@@QBEPAVioObjectItem@@XZ:PROC ; ioBaseChar::GetObjectA
; Function compile flags: /Ogsp
;	COMDAT ?SetThunderBirdObjectSpecialState@ioBaseChar@@QAEX_N@Z
_TEXT	SEGMENT
_bInit$ = 8						; size = 1
?SetThunderBirdObjectSpecialState@ioBaseChar@@QAEX_N@Z PROC ; ioBaseChar::SetThunderBirdObjectSpecialState, COMDAT
; _this$ = ecx

; 1475 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f1		 mov	 esi, ecx

; 1476 : 	ioThunderBirdObjectItem *pThunderBirdObjectItem = ToThunderBirdObjectItem( GetObject() );

  00007	e8 00 00 00 00	 call	 ?GetObjectA@ioBaseChar@@QBEPAVioObjectItem@@XZ ; ioBaseChar::GetObjectA
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?ToThunderBirdObjectItem@@YAPAVioThunderBirdObjectItem@@PAVioItem@@@Z ; ToThunderBirdObjectItem
  00012	8b f8		 mov	 edi, eax
  00014	59		 pop	 ecx

; 1477 : 	if ( !pThunderBirdObjectItem )

  00015	85 ff		 test	 edi, edi
  00017	74 18		 je	 SHORT $LN1@SetThunder

; 1478 : 		return;
; 1479 : 
; 1480 : 	SetState( CS_THUNDER_BIRD_OBJECT_SPECIAL );

  00019	6a 01		 push	 1
  0001b	6a 7c		 push	 124			; 0000007cH
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?SetState@ioBaseChar@@QAEXH_N@Z ; ioBaseChar::SetState

; 1481 : 
; 1482 : 	if ( bInit )

  00024	80 7d 08 00	 cmp	 BYTE PTR _bInit$[ebp], 0
  00028	74 07		 je	 SHORT $LN1@SetThunder

; 1483 : 		pThunderBirdObjectItem->Init();

  0002a	8b cf		 mov	 ecx, edi
  0002c	e8 00 00 00 00	 call	 ?Init@ioThunderBirdObjectItem@@QAEXXZ ; ioThunderBirdObjectItem::Init
$LN1@SetThunder:
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi

; 1484 : }

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?SetThunderBirdObjectSpecialState@ioBaseChar@@QAEX_N@Z ENDP ; ioBaseChar::SetThunderBirdObjectSpecialState
_TEXT	ENDS
PUBLIC	?IsEnableThunderBirdObjectSpecialState@ioBaseChar@@QAE_NXZ ; ioBaseChar::IsEnableThunderBirdObjectSpecialState
EXTRN	?CheckThunderBirdGauge@ioThunderBirdObjectItem@@QAE_NPAVioBaseChar@@@Z:PROC ; ioThunderBirdObjectItem::CheckThunderBirdGauge
; Function compile flags: /Ogsp
;	COMDAT ?IsEnableThunderBirdObjectSpecialState@ioBaseChar@@QAE_NXZ
_TEXT	SEGMENT
?IsEnableThunderBirdObjectSpecialState@ioBaseChar@@QAE_NXZ PROC ; ioBaseChar::IsEnableThunderBirdObjectSpecialState, COMDAT
; _this$ = ecx

; 1487 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1488 : 	ioThunderBirdObjectItem *pThunderBirdObjectItem = ToThunderBirdObjectItem( GetObject() );

  00003	e8 00 00 00 00	 call	 ?GetObjectA@ioBaseChar@@QBEPAVioObjectItem@@XZ ; ioBaseChar::GetObjectA
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ?ToThunderBirdObjectItem@@YAPAVioThunderBirdObjectItem@@PAVioItem@@@Z ; ToThunderBirdObjectItem
  0000e	59		 pop	 ecx

; 1489 : 	if( !pThunderBirdObjectItem )

  0000f	85 c0		 test	 eax, eax
  00011	75 04		 jne	 SHORT $LN2@IsEnableTh

; 1490 : 		return false;

  00013	32 c0		 xor	 al, al
  00015	5e		 pop	 esi

; 1493 : 		return false;
; 1494 : 
; 1495 : 	return true;
; 1496 : }

  00016	c3		 ret	 0
$LN2@IsEnableTh:

; 1491 : 
; 1492 : 	if( pThunderBirdObjectItem->CheckThunderBirdGauge( this ) )

  00017	56		 push	 esi
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 ?CheckThunderBirdGauge@ioThunderBirdObjectItem@@QAE_NPAVioBaseChar@@@Z ; ioThunderBirdObjectItem::CheckThunderBirdGauge
  0001f	f6 d8		 neg	 al
  00021	1a c0		 sbb	 al, al
  00023	fe c0		 inc	 al
  00025	5e		 pop	 esi

; 1493 : 		return false;
; 1494 : 
; 1495 : 	return true;
; 1496 : }

  00026	c3		 ret	 0
?IsEnableThunderBirdObjectSpecialState@ioBaseChar@@QAE_NXZ ENDP ; ioBaseChar::IsEnableThunderBirdObjectSpecialState
_TEXT	ENDS
PUBLIC	?CheckThunderBirdSpecialBuff@ioBaseChar@@QAEX_N@Z ; ioBaseChar::CheckThunderBirdSpecialBuff
EXTRN	?SetCallState@ioCheckStateEndCallBuff@@QAEXPAVioBaseChar@@@Z:PROC ; ioCheckStateEndCallBuff::SetCallState
EXTRN	?IsWait@ioCheckStateEndCallBuff@@QAE_NXZ:PROC	; ioCheckStateEndCallBuff::IsWait
EXTRN	?SetTeamAttack@ioThunderBirdHoldBuff@@QAEX_N0@Z:PROC ; ioThunderBirdHoldBuff::SetTeamAttack
EXTRN	?IsFloating@ioBaseChar@@QAE_NXZ:PROC		; ioBaseChar::IsFloating
EXTRN	?SetReserveEndBuff@ioBuff@@QAEXXZ:PROC		; ioBuff::SetReserveEndBuff
; Function compile flags: /Ogsp
;	COMDAT ?CheckThunderBirdSpecialBuff@ioBaseChar@@QAEX_N@Z
_TEXT	SEGMENT
_bTeamAttacked$ = 8					; size = 1
?CheckThunderBirdSpecialBuff@ioBaseChar@@QAEX_N@Z PROC	; ioBaseChar::CheckThunderBirdSpecialBuff, COMDAT
; _this$ = ecx

; 1499 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1500 : 	for( int i=0; i<m_aBuffArray->MaxCount(); i++ )

  00006	8b 8e 7c 06 00
	00		 mov	 ecx, DWORD PTR [esi+1660]
  0000c	57		 push	 edi
  0000d	33 ff		 xor	 edi, edi
  0000f	39 79 04	 cmp	 DWORD PTR [ecx+4], edi
  00012	7e 74		 jle	 SHORT $LN6@CheckThund
  00014	53		 push	 ebx
$LL8@CheckThund:

; 1501 : 	{
; 1502 : 		ioThunderBirdHoldBuff *pThunderBirdHoldBuff = ToThunderBirdHoldBuff( m_aBuffArray->GetAt(i) );

  00015	57		 push	 edi
  00016	e8 00 00 00 00	 call	 ?GetAt@?$ioTPtrGrowArray@VioBuff@@@@QBEPAVioBuff@@H@Z ; ioTPtrGrowArray<ioBuff>::GetAt
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?ToThunderBirdHoldBuff@@YAPAVioThunderBirdHoldBuff@@PAVioBuff@@@Z ; ToThunderBirdHoldBuff
  00021	8b d8		 mov	 ebx, eax
  00023	59		 pop	 ecx

; 1503 : 		if ( pThunderBirdHoldBuff )

  00024	85 db		 test	 ebx, ebx
  00026	74 07		 je	 SHORT $LN5@CheckThund

; 1504 : 			pThunderBirdHoldBuff->SetReserveEndBuff();

  00028	8b cb		 mov	 ecx, ebx
  0002a	e8 00 00 00 00	 call	 ?SetReserveEndBuff@ioBuff@@QAEXXZ ; ioBuff::SetReserveEndBuff
$LN5@CheckThund:

; 1505 : 
; 1506 : 		if ( bTeamAttacked )

  0002f	80 7d 08 00	 cmp	 BYTE PTR _bTeamAttacked$[ebp], 0
  00033	74 1a		 je	 SHORT $LN4@CheckThund

; 1507 : 		{			
; 1508 : 			if ( pThunderBirdHoldBuff )

  00035	85 db		 test	 ebx, ebx
  00037	74 42		 je	 SHORT $LN7@CheckThund

; 1509 : 				pThunderBirdHoldBuff->SetTeamAttack( true, IsFloating() );

  00039	8b ce		 mov	 ecx, esi
  0003b	e8 00 00 00 00	 call	 ?IsFloating@ioBaseChar@@QAE_NXZ ; ioBaseChar::IsFloating
  00040	0f b6 c0	 movzx	 eax, al
  00043	50		 push	 eax
  00044	6a 01		 push	 1
  00046	8b cb		 mov	 ecx, ebx
  00048	e8 00 00 00 00	 call	 ?SetTeamAttack@ioThunderBirdHoldBuff@@QAEX_N0@Z ; ioThunderBirdHoldBuff::SetTeamAttack

; 1510 : 		}
; 1511 : 		else

  0004d	eb 2c		 jmp	 SHORT $LN7@CheckThund
$LN4@CheckThund:

; 1512 : 		{
; 1513 : 			ioCheckStateEndCallBuff *pCheckStateEndCallBuff = ToCheckStateEndCallBuff( m_aBuffArray->GetAt(i) );

  0004f	8b 8e 7c 06 00
	00		 mov	 ecx, DWORD PTR [esi+1660]
  00055	57		 push	 edi
  00056	e8 00 00 00 00	 call	 ?GetAt@?$ioTPtrGrowArray@VioBuff@@@@QBEPAVioBuff@@H@Z ; ioTPtrGrowArray<ioBuff>::GetAt
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ?ToCheckStateEndCallBuff@@YAPAVioCheckStateEndCallBuff@@PAVioBuff@@@Z ; ToCheckStateEndCallBuff
  00061	8b d8		 mov	 ebx, eax
  00063	59		 pop	 ecx

; 1514 : 			if ( pCheckStateEndCallBuff && pCheckStateEndCallBuff->IsWait() )

  00064	85 db		 test	 ebx, ebx
  00066	74 13		 je	 SHORT $LN7@CheckThund
  00068	8b cb		 mov	 ecx, ebx
  0006a	e8 00 00 00 00	 call	 ?IsWait@ioCheckStateEndCallBuff@@QAE_NXZ ; ioCheckStateEndCallBuff::IsWait
  0006f	84 c0		 test	 al, al
  00071	74 08		 je	 SHORT $LN7@CheckThund

; 1515 : 				pCheckStateEndCallBuff->SetCallState( this );

  00073	56		 push	 esi
  00074	8b cb		 mov	 ecx, ebx
  00076	e8 00 00 00 00	 call	 ?SetCallState@ioCheckStateEndCallBuff@@QAEXPAVioBaseChar@@@Z ; ioCheckStateEndCallBuff::SetCallState
$LN7@CheckThund:

; 1500 : 	for( int i=0; i<m_aBuffArray->MaxCount(); i++ )

  0007b	8b 8e 7c 06 00
	00		 mov	 ecx, DWORD PTR [esi+1660]
  00081	47		 inc	 edi
  00082	3b 79 04	 cmp	 edi, DWORD PTR [ecx+4]
  00085	7c 8e		 jl	 SHORT $LL8@CheckThund
  00087	5b		 pop	 ebx
$LN6@CheckThund:
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi

; 1516 : 		}
; 1517 : 	}
; 1518 : }

  0008a	5d		 pop	 ebp
  0008b	c2 04 00	 ret	 4
?CheckThunderBirdSpecialBuff@ioBaseChar@@QAEX_N@Z ENDP	; ioBaseChar::CheckThunderBirdSpecialBuff
_TEXT	ENDS
PUBLIC	?FillThunderBirdInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ; ioBaseChar::FillThunderBirdInfo
EXTRN	?FillThunderBirdInfo@ioThunderBirdItem@@QAEXPAVioBaseChar@@AAVSP2Packet@@@Z:PROC ; ioThunderBirdItem::FillThunderBirdInfo
; Function compile flags: /Ogsp
;	COMDAT ?FillThunderBirdInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z
_TEXT	SEGMENT
_rkPacket$ = 8						; size = 4
?FillThunderBirdInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z PROC ; ioBaseChar::FillThunderBirdInfo, COMDAT
; _this$ = ecx

; 1521 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1522 : 	ioThunderBirdItem* pThunderBirdItem = ToThunderBirdItem( GetWeapon() );

  00006	e8 00 00 00 00	 call	 ?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ ; ioBaseChar::GetWeapon
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?ToThunderBirdItem@@YAPAVioThunderBirdItem@@PAVioItem@@@Z ; ToThunderBirdItem
  00011	59		 pop	 ecx

; 1523 : 	if( pThunderBirdItem )

  00012	85 c0		 test	 eax, eax
  00014	74 0b		 je	 SHORT $LN1@FillThunde

; 1524 : 		pThunderBirdItem->FillThunderBirdInfo( this, rkPacket );

  00016	ff 75 08	 push	 DWORD PTR _rkPacket$[ebp]
  00019	8b c8		 mov	 ecx, eax
  0001b	56		 push	 esi
  0001c	e8 00 00 00 00	 call	 ?FillThunderBirdInfo@ioThunderBirdItem@@QAEXPAVioBaseChar@@AAVSP2Packet@@@Z ; ioThunderBirdItem::FillThunderBirdInfo
$LN1@FillThunde:
  00021	5e		 pop	 esi

; 1525 : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?FillThunderBirdInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ENDP ; ioBaseChar::FillThunderBirdInfo
_TEXT	ENDS
PUBLIC	?SetThunderBirdInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ; ioBaseChar::SetThunderBirdInfo
EXTRN	?SetThunderBirdInfo@ioThunderBirdItem@@QAEXPAVioBaseChar@@AAVSP2Packet@@@Z:PROC ; ioThunderBirdItem::SetThunderBirdInfo
; Function compile flags: /Ogsp
;	COMDAT ?SetThunderBirdInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z
_TEXT	SEGMENT
_rkPacket$ = 8						; size = 4
?SetThunderBirdInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z PROC ; ioBaseChar::SetThunderBirdInfo, COMDAT
; _this$ = ecx

; 1528 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1529 : 	ioThunderBirdItem* pThunderBirdItem = ToThunderBirdItem( GetWeapon() );

  00006	e8 00 00 00 00	 call	 ?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ ; ioBaseChar::GetWeapon
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?ToThunderBirdItem@@YAPAVioThunderBirdItem@@PAVioItem@@@Z ; ToThunderBirdItem
  00011	59		 pop	 ecx

; 1530 : 	if( pThunderBirdItem )	

  00012	85 c0		 test	 eax, eax
  00014	74 0b		 je	 SHORT $LN1@SetThunder@2

; 1531 : 		pThunderBirdItem->SetThunderBirdInfo( this, rkPacket );

  00016	ff 75 08	 push	 DWORD PTR _rkPacket$[ebp]
  00019	8b c8		 mov	 ecx, eax
  0001b	56		 push	 esi
  0001c	e8 00 00 00 00	 call	 ?SetThunderBirdInfo@ioThunderBirdItem@@QAEXPAVioBaseChar@@AAVSP2Packet@@@Z ; ioThunderBirdItem::SetThunderBirdInfo
$LN1@SetThunder@2:
  00021	5e		 pop	 esi

; 1532 : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?SetThunderBirdInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ENDP ; ioBaseChar::SetThunderBirdInfo
_TEXT	ENDS
PUBLIC	?FillAliceInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z	; ioBaseChar::FillAliceInfo
EXTRN	?FillAliceInfo@ioAliceItem@@QAEXPAVioBaseChar@@AAVSP2Packet@@@Z:PROC ; ioAliceItem::FillAliceInfo
; Function compile flags: /Ogsp
;	COMDAT ?FillAliceInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z
_TEXT	SEGMENT
_rkPacket$ = 8						; size = 4
?FillAliceInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z PROC	; ioBaseChar::FillAliceInfo, COMDAT
; _this$ = ecx

; 1536 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1537 : 	ioAliceItem* pAlice = ToAliceItem( GetWeapon() );

  00006	e8 00 00 00 00	 call	 ?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ ; ioBaseChar::GetWeapon
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?ToAliceItem@@YAPAVioAliceItem@@PAVioItem@@@Z ; ToAliceItem
  00011	59		 pop	 ecx

; 1538 : 	if( pAlice )

  00012	85 c0		 test	 eax, eax
  00014	74 0b		 je	 SHORT $LN1@FillAliceI

; 1539 : 		pAlice->FillAliceInfo( this, rkPacket );

  00016	ff 75 08	 push	 DWORD PTR _rkPacket$[ebp]
  00019	8b c8		 mov	 ecx, eax
  0001b	56		 push	 esi
  0001c	e8 00 00 00 00	 call	 ?FillAliceInfo@ioAliceItem@@QAEXPAVioBaseChar@@AAVSP2Packet@@@Z ; ioAliceItem::FillAliceInfo
$LN1@FillAliceI:
  00021	5e		 pop	 esi

; 1540 : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?FillAliceInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ENDP	; ioBaseChar::FillAliceInfo
_TEXT	ENDS
PUBLIC	?SetAliceInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z	; ioBaseChar::SetAliceInfo
EXTRN	?SetAliceInfo@ioAliceItem@@QAEXPAVioBaseChar@@AAVSP2Packet@@@Z:PROC ; ioAliceItem::SetAliceInfo
; Function compile flags: /Ogsp
;	COMDAT ?SetAliceInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z
_TEXT	SEGMENT
_rkPacket$ = 8						; size = 4
?SetAliceInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z PROC	; ioBaseChar::SetAliceInfo, COMDAT
; _this$ = ecx

; 1543 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1544 : 	ioAliceItem* pAlice = ToAliceItem( GetWeapon() );

  00006	e8 00 00 00 00	 call	 ?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ ; ioBaseChar::GetWeapon
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?ToAliceItem@@YAPAVioAliceItem@@PAVioItem@@@Z ; ToAliceItem
  00011	59		 pop	 ecx

; 1545 : 	if( pAlice )	

  00012	85 c0		 test	 eax, eax
  00014	74 0b		 je	 SHORT $LN1@SetAliceIn

; 1546 : 		pAlice->SetAliceInfo( this, rkPacket );

  00016	ff 75 08	 push	 DWORD PTR _rkPacket$[ebp]
  00019	8b c8		 mov	 ecx, eax
  0001b	56		 push	 esi
  0001c	e8 00 00 00 00	 call	 ?SetAliceInfo@ioAliceItem@@QAEXPAVioBaseChar@@AAVSP2Packet@@@Z ; ioAliceItem::SetAliceInfo
$LN1@SetAliceIn:
  00021	5e		 pop	 esi

; 1547 : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?SetAliceInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ENDP	; ioBaseChar::SetAliceInfo
_TEXT	ENDS
PUBLIC	?ClearValkyrieDobuleJumpFly@ioBaseChar@@QAEXXZ	; ioBaseChar::ClearValkyrieDobuleJumpFly
EXTRN	?GetBuff@ioBaseChar@@QAEPAVioBuff@@ABVioHashString@@@Z:PROC ; ioBaseChar::GetBuff
; Function compile flags: /Ogsp
;	COMDAT ?ClearValkyrieDobuleJumpFly@ioBaseChar@@QAEXXZ
_TEXT	SEGMENT
?ClearValkyrieDobuleJumpFly@ioBaseChar@@QAEXXZ PROC	; ioBaseChar::ClearValkyrieDobuleJumpFly, COMDAT
; _this$ = ecx

; 1551 : {

  00000	56		 push	 esi

; 1552 : 	ioValkyrie *pValkyrie = ToValkyrie( GetPriorityItem( SPT_ATTACK ) );

  00001	6a 05		 push	 5
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?ToValkyrie@@YAPAVioValkyrie@@PAVioItem@@@Z ; ToValkyrie
  00010	59		 pop	 ecx

; 1553 : 	if( pValkyrie )

  00011	85 c0		 test	 eax, eax
  00013	74 18		 je	 SHORT $LN3@ClearValky

; 1554 : 	{		
; 1555 : 		ioBuff* pBuff = GetBuff( pValkyrie->GetDoubleJumpFlyBuff() );

  00015	05 ac 1b 00 00	 add	 eax, 7084		; 00001bacH
  0001a	50		 push	 eax
  0001b	8b ce		 mov	 ecx, esi
  0001d	e8 00 00 00 00	 call	 ?GetBuff@ioBaseChar@@QAEPAVioBuff@@ABVioHashString@@@Z ; ioBaseChar::GetBuff

; 1556 : 		if( pBuff )

  00022	85 c0		 test	 eax, eax
  00024	74 07		 je	 SHORT $LN3@ClearValky

; 1557 : 		{
; 1558 : 			pBuff->SetReserveEndBuff();

  00026	8b c8		 mov	 ecx, eax
  00028	e8 00 00 00 00	 call	 ?SetReserveEndBuff@ioBuff@@QAEXXZ ; ioBuff::SetReserveEndBuff
$LN3@ClearValky:

; 1559 : 		}
; 1560 : 	}
; 1561 : 
; 1562 : 	ioSummonChargeItem3 *pSummonChargeItem3 = ToSummonChargeItem3(GetPriorityItem( SPT_ATTACK ) );

  0002d	6a 05		 push	 5
  0002f	8b ce		 mov	 ecx, esi
  00031	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ?ToSummonChargeItem3@@YAPAVioSummonChargeItem3@@PAVioItem@@@Z ; ToSummonChargeItem3
  0003c	59		 pop	 ecx

; 1563 : 	if( pSummonChargeItem3 )

  0003d	85 c0		 test	 eax, eax
  0003f	74 19		 je	 SHORT $LN1@ClearValky

; 1564 : 	{		
; 1565 : 		ioBuff* pBuff = GetBuff( pSummonChargeItem3->GetDoubleJumpFlyBuff() );

  00041	05 4c 1a 00 00	 add	 eax, 6732		; 00001a4cH
  00046	50		 push	 eax
  00047	8b ce		 mov	 ecx, esi
  00049	e8 00 00 00 00	 call	 ?GetBuff@ioBaseChar@@QAEPAVioBuff@@ABVioHashString@@@Z ; ioBaseChar::GetBuff

; 1566 : 		if( pBuff )

  0004e	85 c0		 test	 eax, eax
  00050	74 08		 je	 SHORT $LN1@ClearValky

; 1567 : 		{
; 1568 : 			pBuff->SetReserveEndBuff();

  00052	8b c8		 mov	 ecx, eax
  00054	5e		 pop	 esi
  00055	e9 00 00 00 00	 jmp	 ?SetReserveEndBuff@ioBuff@@QAEXXZ ; ioBuff::SetReserveEndBuff
$LN1@ClearValky:
  0005a	5e		 pop	 esi

; 1569 : 		}
; 1570 : 	}
; 1571 : }

  0005b	c3		 ret	 0
?ClearValkyrieDobuleJumpFly@ioBaseChar@@QAEXXZ ENDP	; ioBaseChar::ClearValkyrieDobuleJumpFly
_TEXT	ENDS
PUBLIC	?SetParkilpyoEquipObject@ioBaseChar@@QAEXH@Z	; ioBaseChar::SetParkilpyoEquipObject
EXTRN	?ChangeEquipObjectState@ioParkilpyoItem@@QAEXPAVioBaseChar@@W4EquipObjectState@1@@Z:PROC ; ioParkilpyoItem::ChangeEquipObjectState
; Function compile flags: /Ogsp
;	COMDAT ?SetParkilpyoEquipObject@ioBaseChar@@QAEXH@Z
_TEXT	SEGMENT
_nState$ = 8						; size = 4
?SetParkilpyoEquipObject@ioBaseChar@@QAEXH@Z PROC	; ioBaseChar::SetParkilpyoEquipObject, COMDAT
; _this$ = ecx

; 1575 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1576 : 	ioParkilpyoItem *pParkilpyoItem = ToParkilpyoItem( GetWeapon() );

  00006	e8 00 00 00 00	 call	 ?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ ; ioBaseChar::GetWeapon
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?ToParkilpyoItem@@YAPAVioParkilpyoItem@@PAVioItem@@@Z ; ToParkilpyoItem
  00011	59		 pop	 ecx

; 1577 : 	if( !pParkilpyoItem )

  00012	85 c0		 test	 eax, eax
  00014	74 0b		 je	 SHORT $LN2@SetParkilp

; 1578 : 		return;
; 1579 : 
; 1580 : 	pParkilpyoItem->ChangeEquipObjectState( this, (ioParkilpyoItem::EquipObjectState)nState );

  00016	ff 75 08	 push	 DWORD PTR _nState$[ebp]
  00019	8b c8		 mov	 ecx, eax
  0001b	56		 push	 esi
  0001c	e8 00 00 00 00	 call	 ?ChangeEquipObjectState@ioParkilpyoItem@@QAEXPAVioBaseChar@@W4EquipObjectState@1@@Z ; ioParkilpyoItem::ChangeEquipObjectState
$LN2@SetParkilp:
  00021	5e		 pop	 esi

; 1581 : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?SetParkilpyoEquipObject@ioBaseChar@@QAEXH@Z ENDP	; ioBaseChar::SetParkilpyoEquipObject
_TEXT	ENDS
PUBLIC	?IsEnableParkilpyoEquipObject@ioBaseChar@@QAE_NXZ ; ioBaseChar::IsEnableParkilpyoEquipObject
EXTRN	?IsEnableEquipObject@ioParkilpyoItem@@QAE_NXZ:PROC ; ioParkilpyoItem::IsEnableEquipObject
; Function compile flags: /Ogsp
;	COMDAT ?IsEnableParkilpyoEquipObject@ioBaseChar@@QAE_NXZ
_TEXT	SEGMENT
?IsEnableParkilpyoEquipObject@ioBaseChar@@QAE_NXZ PROC	; ioBaseChar::IsEnableParkilpyoEquipObject, COMDAT
; _this$ = ecx

; 1585 : 	ioParkilpyoItem *pParkilpyoItem = ToParkilpyoItem( GetWeapon() );

  00000	e8 00 00 00 00	 call	 ?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ ; ioBaseChar::GetWeapon
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ?ToParkilpyoItem@@YAPAVioParkilpyoItem@@PAVioItem@@@Z ; ToParkilpyoItem
  0000b	59		 pop	 ecx

; 1586 : 	if( !pParkilpyoItem )

  0000c	85 c0		 test	 eax, eax
  0000e	75 03		 jne	 SHORT $LN1@IsEnablePa

; 1587 : 		return false;

  00010	32 c0		 xor	 al, al

; 1590 : }

  00012	c3		 ret	 0
$LN1@IsEnablePa:

; 1588 : 
; 1589 : 	return pParkilpyoItem->IsEnableEquipObject();

  00013	8b c8		 mov	 ecx, eax
  00015	e9 00 00 00 00	 jmp	 ?IsEnableEquipObject@ioParkilpyoItem@@QAE_NXZ ; ioParkilpyoItem::IsEnableEquipObject
?IsEnableParkilpyoEquipObject@ioBaseChar@@QAE_NXZ ENDP	; ioBaseChar::IsEnableParkilpyoEquipObject
_TEXT	ENDS
PUBLIC	?FillParkilpyoInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ; ioBaseChar::FillParkilpyoInfo
EXTRN	?FillParkilpyoInfo@ioParkilpyoItem@@QAEXPAVioBaseChar@@AAVSP2Packet@@@Z:PROC ; ioParkilpyoItem::FillParkilpyoInfo
; Function compile flags: /Ogsp
;	COMDAT ?FillParkilpyoInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z
_TEXT	SEGMENT
_rkPacket$ = 8						; size = 4
?FillParkilpyoInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z PROC ; ioBaseChar::FillParkilpyoInfo, COMDAT
; _this$ = ecx

; 1593 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1594 : 	ioParkilpyoItem* pParkilpyoItem = ToParkilpyoItem( GetWeapon() );

  00006	e8 00 00 00 00	 call	 ?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ ; ioBaseChar::GetWeapon
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?ToParkilpyoItem@@YAPAVioParkilpyoItem@@PAVioItem@@@Z ; ToParkilpyoItem
  00011	59		 pop	 ecx

; 1595 : 	if( pParkilpyoItem )

  00012	85 c0		 test	 eax, eax
  00014	74 0b		 je	 SHORT $LN1@FillParkil

; 1596 : 		pParkilpyoItem->FillParkilpyoInfo( this, rkPacket );

  00016	ff 75 08	 push	 DWORD PTR _rkPacket$[ebp]
  00019	8b c8		 mov	 ecx, eax
  0001b	56		 push	 esi
  0001c	e8 00 00 00 00	 call	 ?FillParkilpyoInfo@ioParkilpyoItem@@QAEXPAVioBaseChar@@AAVSP2Packet@@@Z ; ioParkilpyoItem::FillParkilpyoInfo
$LN1@FillParkil:
  00021	5e		 pop	 esi

; 1597 : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?FillParkilpyoInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ENDP ; ioBaseChar::FillParkilpyoInfo
_TEXT	ENDS
PUBLIC	?SetParkilpyoInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ; ioBaseChar::SetParkilpyoInfo
EXTRN	?SetParkilpyoInfo@ioParkilpyoItem@@QAEXPAVioBaseChar@@AAVSP2Packet@@@Z:PROC ; ioParkilpyoItem::SetParkilpyoInfo
; Function compile flags: /Ogsp
;	COMDAT ?SetParkilpyoInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z
_TEXT	SEGMENT
_rkPacket$ = 8						; size = 4
?SetParkilpyoInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z PROC	; ioBaseChar::SetParkilpyoInfo, COMDAT
; _this$ = ecx

; 1600 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1601 : 	ioParkilpyoItem* pParkilpyoItem = ToParkilpyoItem( GetWeapon() );

  00006	e8 00 00 00 00	 call	 ?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ ; ioBaseChar::GetWeapon
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?ToParkilpyoItem@@YAPAVioParkilpyoItem@@PAVioItem@@@Z ; ToParkilpyoItem
  00011	59		 pop	 ecx

; 1602 : 	if( pParkilpyoItem )

  00012	85 c0		 test	 eax, eax
  00014	74 0b		 je	 SHORT $LN1@SetParkilp@2

; 1603 : 		pParkilpyoItem->SetParkilpyoInfo( this, rkPacket );

  00016	ff 75 08	 push	 DWORD PTR _rkPacket$[ebp]
  00019	8b c8		 mov	 ecx, eax
  0001b	56		 push	 esi
  0001c	e8 00 00 00 00	 call	 ?SetParkilpyoInfo@ioParkilpyoItem@@QAEXPAVioBaseChar@@AAVSP2Packet@@@Z ; ioParkilpyoItem::SetParkilpyoInfo
$LN1@SetParkilp@2:
  00021	5e		 pop	 esi

; 1604 : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?SetParkilpyoInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ENDP	; ioBaseChar::SetParkilpyoInfo
_TEXT	ENDS
PUBLIC	?SetShadowRangerSpecialMoveState@ioBaseChar@@QAE_NM@Z ; ioBaseChar::SetShadowRangerSpecialMoveState
EXTRN	?DecreaseGauge@ioShadowRangerItem@@QAEXM@Z:PROC	; ioShadowRangerItem::DecreaseGauge
EXTRN	?SetSpecialState@ioShadowRangerItem@@QAEXW4SpecialState@1@@Z:PROC ; ioShadowRangerItem::SetSpecialState
EXTRN	?ClearState@ioShadowRangerItem@@QAEXPAVioBaseChar@@@Z:PROC ; ioShadowRangerItem::ClearState
; Function compile flags: /Ogsp
;	COMDAT ?SetShadowRangerSpecialMoveState@ioBaseChar@@QAE_NM@Z
_TEXT	SEGMENT
_fUseGauge$ = 8						; size = 4
?SetShadowRangerSpecialMoveState@ioBaseChar@@QAE_NM@Z PROC ; ioBaseChar::SetShadowRangerSpecialMoveState, COMDAT
; _this$ = ecx

; 1608 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1609 : 	ioShadowRangerItem *pShadowRangerItem = ToShadowRangerItem( GetPriorityItem( SPT_ATTACK ) );

  00005	6a 05		 push	 5
  00007	8b f9		 mov	 edi, ecx
  00009	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?ToShadowRangerItem@@YAPAVioShadowRangerItem@@PAVioItem@@@Z ; ToShadowRangerItem
  00014	8b f0		 mov	 esi, eax
  00016	59		 pop	 ecx

; 1610 : 	if( !pShadowRangerItem )

  00017	85 f6		 test	 esi, esi
  00019	75 04		 jne	 SHORT $LN1@SetShadowR

; 1611 : 		return false;

  0001b	32 c0		 xor	 al, al
  0001d	eb 33		 jmp	 SHORT $LN2@SetShadowR
$LN1@SetShadowR:

; 1612 : 
; 1613 : 	SetState( CS_SHADOW_RANGER_SPECIAL );

  0001f	6a 01		 push	 1
  00021	68 83 00 00 00	 push	 131			; 00000083H
  00026	8b cf		 mov	 ecx, edi
  00028	e8 00 00 00 00	 call	 ?SetState@ioBaseChar@@QAEXH_N@Z ; ioBaseChar::SetState

; 1614 : 
; 1615 : 	pShadowRangerItem->ClearState( this );

  0002d	57		 push	 edi
  0002e	8b ce		 mov	 ecx, esi
  00030	e8 00 00 00 00	 call	 ?ClearState@ioShadowRangerItem@@QAEXPAVioBaseChar@@@Z ; ioShadowRangerItem::ClearState

; 1616 : 	pShadowRangerItem->SetSpecialState( ioShadowRangerItem::SS_Teleport_Move_Predelay );

  00035	6a 03		 push	 3
  00037	8b ce		 mov	 ecx, esi
  00039	e8 00 00 00 00	 call	 ?SetSpecialState@ioShadowRangerItem@@QAEXW4SpecialState@1@@Z ; ioShadowRangerItem::SetSpecialState

; 1617 : 	pShadowRangerItem->DecreaseGauge( fUseGauge );

  0003e	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fUseGauge$[ebp]
  00043	51		 push	 ecx
  00044	8b ce		 mov	 ecx, esi
  00046	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004b	e8 00 00 00 00	 call	 ?DecreaseGauge@ioShadowRangerItem@@QAEXM@Z ; ioShadowRangerItem::DecreaseGauge

; 1618 : 
; 1619 : 	return true;

  00050	b0 01		 mov	 al, 1
$LN2@SetShadowR:
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi

; 1620 : }

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?SetShadowRangerSpecialMoveState@ioBaseChar@@QAE_NM@Z ENDP ; ioBaseChar::SetShadowRangerSpecialMoveState
_TEXT	ENDS
PUBLIC	?IsEnableShadowRangerSpecial@ioBaseChar@@QAE_NM@Z ; ioBaseChar::IsEnableShadowRangerSpecial
EXTRN	?IsEnableGauge@ioShadowRangerItem@@QAE_NM@Z:PROC ; ioShadowRangerItem::IsEnableGauge
; Function compile flags: /Ogsp
;	COMDAT ?IsEnableShadowRangerSpecial@ioBaseChar@@QAE_NM@Z
_TEXT	SEGMENT
_fUseGauge$ = 8						; size = 4
?IsEnableShadowRangerSpecial@ioBaseChar@@QAE_NM@Z PROC	; ioBaseChar::IsEnableShadowRangerSpecial, COMDAT
; _this$ = ecx

; 1623 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1624 : 	ioShadowRangerItem *pShadowRangerItem = ToShadowRangerItem( GetPriorityItem( SPT_ATTACK ) );

  00004	6a 05		 push	 5
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?ToShadowRangerItem@@YAPAVioShadowRangerItem@@PAVioItem@@@Z ; ToShadowRangerItem
  00013	59		 pop	 ecx

; 1625 : 	if( !pShadowRangerItem )

  00014	85 c0		 test	 eax, eax

; 1626 : 		return false;

  00016	74 25		 je	 SHORT $LN1@IsEnableSh

; 1627 : 
; 1628 : 	if( pShadowRangerItem->IsEnableGauge( fUseGauge ) && !IsHasCrown() )

  00018	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fUseGauge$[ebp]
  0001d	51		 push	 ecx
  0001e	8b c8		 mov	 ecx, eax
  00020	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00025	e8 00 00 00 00	 call	 ?IsEnableGauge@ioShadowRangerItem@@QAE_NM@Z ; ioShadowRangerItem::IsEnableGauge
  0002a	84 c0		 test	 al, al
  0002c	74 0f		 je	 SHORT $LN1@IsEnableSh
  0002e	8b ce		 mov	 ecx, esi
  00030	e8 00 00 00 00	 call	 ?IsHasCrown@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsHasCrown
  00035	84 c0		 test	 al, al
  00037	75 04		 jne	 SHORT $LN1@IsEnableSh

; 1629 : 		return true;

  00039	fe c0		 inc	 al
  0003b	eb 02		 jmp	 SHORT $LN3@IsEnableSh
$LN1@IsEnableSh:

; 1630 : 
; 1631 : 	return false;

  0003d	32 c0		 xor	 al, al
$LN3@IsEnableSh:
  0003f	5e		 pop	 esi

; 1632 : }

  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
?IsEnableShadowRangerSpecial@ioBaseChar@@QAE_NM@Z ENDP	; ioBaseChar::IsEnableShadowRangerSpecial
_TEXT	ENDS
PUBLIC	?SetNinjaExpansionMove@ioBaseChar@@QAE_N_N@Z	; ioBaseChar::SetNinjaExpansionMove
EXTRN	?SetNinjaExpansionMove@ioNinjaExpansionItem@@QAEXPAVioBaseChar@@_N@Z:PROC ; ioNinjaExpansionItem::SetNinjaExpansionMove
; Function compile flags: /Ogsp
;	COMDAT ?SetNinjaExpansionMove@ioBaseChar@@QAE_N_N@Z
_TEXT	SEGMENT
_bJump$ = 8						; size = 1
?SetNinjaExpansionMove@ioBaseChar@@QAE_N_N@Z PROC	; ioBaseChar::SetNinjaExpansionMove, COMDAT
; _this$ = ecx

; 1636 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1637 : 	ioNinjaExpansionItem *pNinjaExpansion = ToNinjaExpansionItem( GetPriorityItem( SPT_ATTACK ) );

  00005	6a 05		 push	 5
  00007	8b f1		 mov	 esi, ecx
  00009	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?ToNinjaExpansionItem@@YAPAVioNinjaExpansionItem@@PAVioItem@@@Z ; ToNinjaExpansionItem
  00014	8b f8		 mov	 edi, eax
  00016	59		 pop	 ecx

; 1638 : 	if( !pNinjaExpansion )

  00017	85 ff		 test	 edi, edi
  00019	75 04		 jne	 SHORT $LN1@SetNinjaEx

; 1639 : 		return false;

  0001b	32 c0		 xor	 al, al
  0001d	eb 1b		 jmp	 SHORT $LN2@SetNinjaEx
$LN1@SetNinjaEx:

; 1640 : 
; 1641 : 	SetState( CS_NINJA_EXPANSION_MOVE );

  0001f	6a 01		 push	 1
  00021	68 86 00 00 00	 push	 134			; 00000086H
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?SetState@ioBaseChar@@QAEXH_N@Z ; ioBaseChar::SetState

; 1642 : 
; 1643 : 	pNinjaExpansion->SetNinjaExpansionMove( this, bJump );

  0002d	ff 75 08	 push	 DWORD PTR _bJump$[ebp]
  00030	8b cf		 mov	 ecx, edi
  00032	56		 push	 esi
  00033	e8 00 00 00 00	 call	 ?SetNinjaExpansionMove@ioNinjaExpansionItem@@QAEXPAVioBaseChar@@_N@Z ; ioNinjaExpansionItem::SetNinjaExpansionMove

; 1644 : 	return true;

  00038	b0 01		 mov	 al, 1
$LN2@SetNinjaEx:
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi

; 1645 : }

  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
?SetNinjaExpansionMove@ioBaseChar@@QAE_N_N@Z ENDP	; ioBaseChar::SetNinjaExpansionMove
_TEXT	ENDS
PUBLIC	?SetNataSpecialComboState@ioBaseChar@@QAE_N_N00@Z ; ioBaseChar::SetNataSpecialComboState
EXTRN	?SetNataComboSpecialState@ioNataItem@@QAEXPAVioBaseChar@@_N11@Z:PROC ; ioNataItem::SetNataComboSpecialState
; Function compile flags: /Ogsp
;	COMDAT ?SetNataSpecialComboState@ioBaseChar@@QAE_N_N00@Z
_TEXT	SEGMENT
_bNormal$ = 8						; size = 1
_bDash$ = 12						; size = 1
_bJump$ = 16						; size = 1
?SetNataSpecialComboState@ioBaseChar@@QAE_N_N00@Z PROC	; ioBaseChar::SetNataSpecialComboState, COMDAT
; _this$ = ecx

; 1649 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1650 : 	ioNataItem *pNataItem = ToNataItem( GetPriorityItem( SPT_ATTACK ) );

  00004	6a 05		 push	 5
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?ToNataItem@@YAPAVioNataItem@@PAVioItem@@@Z ; ToNataItem
  00013	59		 pop	 ecx

; 1651 : 	if( !pNataItem )

  00014	85 c0		 test	 eax, eax
  00016	75 04		 jne	 SHORT $LN1@SetNataSpe

; 1652 : 		return false;

  00018	32 c0		 xor	 al, al
  0001a	eb 13		 jmp	 SHORT $LN2@SetNataSpe
$LN1@SetNataSpe:

; 1653 : 	
; 1654 : 	pNataItem->SetNataComboSpecialState( this, bNormal, bDash, bJump );

  0001c	ff 75 10	 push	 DWORD PTR _bJump$[ebp]
  0001f	8b c8		 mov	 ecx, eax
  00021	ff 75 0c	 push	 DWORD PTR _bDash$[ebp]
  00024	ff 75 08	 push	 DWORD PTR _bNormal$[ebp]
  00027	56		 push	 esi
  00028	e8 00 00 00 00	 call	 ?SetNataComboSpecialState@ioNataItem@@QAEXPAVioBaseChar@@_N11@Z ; ioNataItem::SetNataComboSpecialState

; 1655 : 
; 1656 : 	return true;

  0002d	b0 01		 mov	 al, 1
$LN2@SetNataSpe:
  0002f	5e		 pop	 esi

; 1657 : }

  00030	5d		 pop	 ebp
  00031	c2 0c 00	 ret	 12			; 0000000cH
?SetNataSpecialComboState@ioBaseChar@@QAE_N_N00@Z ENDP	; ioBaseChar::SetNataSpecialComboState
_TEXT	ENDS
PUBLIC	?IsEnableNataSpecialCombo@ioBaseChar@@QAE_N_N00@Z ; ioBaseChar::IsEnableNataSpecialCombo
EXTRN	?IsEnableComboGauge@ioNataItem@@QAE_N_N00@Z:PROC ; ioNataItem::IsEnableComboGauge
; Function compile flags: /Ogsp
;	COMDAT ?IsEnableNataSpecialCombo@ioBaseChar@@QAE_N_N00@Z
_TEXT	SEGMENT
_bNormal$ = 8						; size = 1
_bDash$ = 12						; size = 1
_bJump$ = 16						; size = 1
?IsEnableNataSpecialCombo@ioBaseChar@@QAE_N_N00@Z PROC	; ioBaseChar::IsEnableNataSpecialCombo, COMDAT
; _this$ = ecx

; 1660 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1661 : 	ioNataItem *pNataItem = ToNataItem( GetPriorityItem( SPT_ATTACK ) );

  00004	6a 05		 push	 5
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?ToNataItem@@YAPAVioNataItem@@PAVioItem@@@Z ; ToNataItem
  00013	59		 pop	 ecx

; 1662 : 	if( !pNataItem )

  00014	85 c0		 test	 eax, eax

; 1663 : 		return false;

  00016	74 23		 je	 SHORT $LN1@IsEnableNa

; 1664 : 
; 1665 : 	if( pNataItem->IsEnableComboGauge( bNormal, bDash, bJump ) && !IsHasCrown() )

  00018	ff 75 10	 push	 DWORD PTR _bJump$[ebp]
  0001b	8b c8		 mov	 ecx, eax
  0001d	ff 75 0c	 push	 DWORD PTR _bDash$[ebp]
  00020	ff 75 08	 push	 DWORD PTR _bNormal$[ebp]
  00023	e8 00 00 00 00	 call	 ?IsEnableComboGauge@ioNataItem@@QAE_N_N00@Z ; ioNataItem::IsEnableComboGauge
  00028	84 c0		 test	 al, al
  0002a	74 0f		 je	 SHORT $LN1@IsEnableNa
  0002c	8b ce		 mov	 ecx, esi
  0002e	e8 00 00 00 00	 call	 ?IsHasCrown@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsHasCrown
  00033	84 c0		 test	 al, al
  00035	75 04		 jne	 SHORT $LN1@IsEnableNa

; 1666 : 		return true;

  00037	fe c0		 inc	 al
  00039	eb 02		 jmp	 SHORT $LN3@IsEnableNa
$LN1@IsEnableNa:

; 1667 : 
; 1668 : 	return false;

  0003b	32 c0		 xor	 al, al
$LN3@IsEnableNa:
  0003d	5e		 pop	 esi

; 1669 : }

  0003e	5d		 pop	 ebp
  0003f	c2 0c 00	 ret	 12			; 0000000cH
?IsEnableNataSpecialCombo@ioBaseChar@@QAE_N_N00@Z ENDP	; ioBaseChar::IsEnableNataSpecialCombo
_TEXT	ENDS
PUBLIC	?IsEnableNataSpecialFly@ioBaseChar@@QAE_NXZ	; ioBaseChar::IsEnableNataSpecialFly
EXTRN	?IsEnableFlyGauge@ioNataItem@@QAE_NXZ:PROC	; ioNataItem::IsEnableFlyGauge
; Function compile flags: /Ogsp
;	COMDAT ?IsEnableNataSpecialFly@ioBaseChar@@QAE_NXZ
_TEXT	SEGMENT
?IsEnableNataSpecialFly@ioBaseChar@@QAE_NXZ PROC	; ioBaseChar::IsEnableNataSpecialFly, COMDAT
; _this$ = ecx

; 1672 : {

  00000	56		 push	 esi

; 1673 : 	ioNataItem *pNataItem = ToNataItem( GetPriorityItem( SPT_ATTACK ) );

  00001	6a 05		 push	 5
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?ToNataItem@@YAPAVioNataItem@@PAVioItem@@@Z ; ToNataItem
  00010	59		 pop	 ecx

; 1674 : 	if( !pNataItem )

  00011	85 c0		 test	 eax, eax

; 1675 : 		return false;

  00013	74 1a		 je	 SHORT $LN1@IsEnableNa@2

; 1676 : 
; 1677 : 	if( pNataItem->IsEnableFlyGauge() && !IsHasCrown() )

  00015	8b c8		 mov	 ecx, eax
  00017	e8 00 00 00 00	 call	 ?IsEnableFlyGauge@ioNataItem@@QAE_NXZ ; ioNataItem::IsEnableFlyGauge
  0001c	84 c0		 test	 al, al
  0001e	74 0f		 je	 SHORT $LN1@IsEnableNa@2
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?IsHasCrown@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsHasCrown
  00027	84 c0		 test	 al, al
  00029	75 04		 jne	 SHORT $LN1@IsEnableNa@2

; 1678 : 		return true;

  0002b	fe c0		 inc	 al
  0002d	5e		 pop	 esi

; 1681 : }

  0002e	c3		 ret	 0
$LN1@IsEnableNa@2:

; 1679 : 
; 1680 : 	return false;

  0002f	32 c0		 xor	 al, al
  00031	5e		 pop	 esi

; 1681 : }

  00032	c3		 ret	 0
?IsEnableNataSpecialFly@ioBaseChar@@QAE_NXZ ENDP	; ioBaseChar::IsEnableNataSpecialFly
_TEXT	ENDS
PUBLIC	?SetOnimushaEquipObject@ioBaseChar@@QAEXH@Z	; ioBaseChar::SetOnimushaEquipObject
EXTRN	?ChangeEquipObjectState@ioOniMushaItem@@QAEXPAVioBaseChar@@W4EquipObjectState@1@@Z:PROC ; ioOniMushaItem::ChangeEquipObjectState
; Function compile flags: /Ogsp
;	COMDAT ?SetOnimushaEquipObject@ioBaseChar@@QAEXH@Z
_TEXT	SEGMENT
_nState$ = 8						; size = 4
?SetOnimushaEquipObject@ioBaseChar@@QAEXH@Z PROC	; ioBaseChar::SetOnimushaEquipObject, COMDAT
; _this$ = ecx

; 1685 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1686 : 	ioOniMushaItem *pOniMushaItem = ToOniMushaItem( GetWeapon() );

  00006	e8 00 00 00 00	 call	 ?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ ; ioBaseChar::GetWeapon
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?ToOniMushaItem@@YAPAVioOniMushaItem@@PAVioItem@@@Z ; ToOniMushaItem
  00011	59		 pop	 ecx

; 1687 : 	if( !pOniMushaItem )

  00012	85 c0		 test	 eax, eax
  00014	74 0b		 je	 SHORT $LN2@SetOnimush

; 1688 : 		return;
; 1689 : 
; 1690 : 	pOniMushaItem->ChangeEquipObjectState( this, (ioOniMushaItem::EquipObjectState)nState );

  00016	ff 75 08	 push	 DWORD PTR _nState$[ebp]
  00019	8b c8		 mov	 ecx, eax
  0001b	56		 push	 esi
  0001c	e8 00 00 00 00	 call	 ?ChangeEquipObjectState@ioOniMushaItem@@QAEXPAVioBaseChar@@W4EquipObjectState@1@@Z ; ioOniMushaItem::ChangeEquipObjectState
$LN2@SetOnimush:
  00021	5e		 pop	 esi

; 1691 : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?SetOnimushaEquipObject@ioBaseChar@@QAEXH@Z ENDP	; ioBaseChar::SetOnimushaEquipObject
_TEXT	ENDS
PUBLIC	?IsEnableOnimushaEquipObject@ioBaseChar@@QAE_NXZ ; ioBaseChar::IsEnableOnimushaEquipObject
EXTRN	?IsEnableEquipObject@ioOniMushaItem@@QAE_NXZ:PROC ; ioOniMushaItem::IsEnableEquipObject
; Function compile flags: /Ogsp
;	COMDAT ?IsEnableOnimushaEquipObject@ioBaseChar@@QAE_NXZ
_TEXT	SEGMENT
?IsEnableOnimushaEquipObject@ioBaseChar@@QAE_NXZ PROC	; ioBaseChar::IsEnableOnimushaEquipObject, COMDAT
; _this$ = ecx

; 1695 : 	ioOniMushaItem *pOniMushaItem = ToOniMushaItem( GetWeapon() );

  00000	e8 00 00 00 00	 call	 ?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ ; ioBaseChar::GetWeapon
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ?ToOniMushaItem@@YAPAVioOniMushaItem@@PAVioItem@@@Z ; ToOniMushaItem
  0000b	59		 pop	 ecx

; 1696 : 	if( !pOniMushaItem )

  0000c	85 c0		 test	 eax, eax
  0000e	75 03		 jne	 SHORT $LN1@IsEnableOn

; 1697 : 		return false;

  00010	32 c0		 xor	 al, al

; 1700 : }

  00012	c3		 ret	 0
$LN1@IsEnableOn:

; 1698 : 
; 1699 : 	return pOniMushaItem->IsEnableEquipObject();

  00013	8b c8		 mov	 ecx, eax
  00015	e9 00 00 00 00	 jmp	 ?IsEnableEquipObject@ioOniMushaItem@@QAE_NXZ ; ioOniMushaItem::IsEnableEquipObject
?IsEnableOnimushaEquipObject@ioBaseChar@@QAE_NXZ ENDP	; ioBaseChar::IsEnableOnimushaEquipObject
_TEXT	ENDS
PUBLIC	?FillOnimushaInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ; ioBaseChar::FillOnimushaInfo
EXTRN	?FillOnimushaInfo@ioOniMushaItem@@QAEXPAVioBaseChar@@AAVSP2Packet@@@Z:PROC ; ioOniMushaItem::FillOnimushaInfo
; Function compile flags: /Ogsp
;	COMDAT ?FillOnimushaInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z
_TEXT	SEGMENT
_rkPacket$ = 8						; size = 4
?FillOnimushaInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z PROC	; ioBaseChar::FillOnimushaInfo, COMDAT
; _this$ = ecx

; 1703 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1704 : 	ioOniMushaItem *pOniMushaItem = ToOniMushaItem( GetWeapon() );

  00006	e8 00 00 00 00	 call	 ?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ ; ioBaseChar::GetWeapon
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?ToOniMushaItem@@YAPAVioOniMushaItem@@PAVioItem@@@Z ; ToOniMushaItem
  00011	59		 pop	 ecx

; 1705 : 	if( pOniMushaItem )

  00012	85 c0		 test	 eax, eax
  00014	74 0b		 je	 SHORT $LN1@FillOnimus

; 1706 : 		pOniMushaItem->FillOnimushaInfo( this, rkPacket );

  00016	ff 75 08	 push	 DWORD PTR _rkPacket$[ebp]
  00019	8b c8		 mov	 ecx, eax
  0001b	56		 push	 esi
  0001c	e8 00 00 00 00	 call	 ?FillOnimushaInfo@ioOniMushaItem@@QAEXPAVioBaseChar@@AAVSP2Packet@@@Z ; ioOniMushaItem::FillOnimushaInfo
$LN1@FillOnimus:
  00021	5e		 pop	 esi

; 1707 : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?FillOnimushaInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ENDP	; ioBaseChar::FillOnimushaInfo
_TEXT	ENDS
PUBLIC	?SetOnimushaInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ; ioBaseChar::SetOnimushaInfo
EXTRN	?SetOnimushaInfo@ioOniMushaItem@@QAEXPAVioBaseChar@@AAVSP2Packet@@@Z:PROC ; ioOniMushaItem::SetOnimushaInfo
; Function compile flags: /Ogsp
;	COMDAT ?SetOnimushaInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z
_TEXT	SEGMENT
_rkPacket$ = 8						; size = 4
?SetOnimushaInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z PROC	; ioBaseChar::SetOnimushaInfo, COMDAT
; _this$ = ecx

; 1710 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1711 : 	ioOniMushaItem *pOniMushaItem = ToOniMushaItem( GetWeapon() );

  00006	e8 00 00 00 00	 call	 ?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ ; ioBaseChar::GetWeapon
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?ToOniMushaItem@@YAPAVioOniMushaItem@@PAVioItem@@@Z ; ToOniMushaItem
  00011	59		 pop	 ecx

; 1712 : 	if( pOniMushaItem )

  00012	85 c0		 test	 eax, eax
  00014	74 0b		 je	 SHORT $LN1@SetOnimush@2

; 1713 : 		pOniMushaItem->SetOnimushaInfo( this, rkPacket );

  00016	ff 75 08	 push	 DWORD PTR _rkPacket$[ebp]
  00019	8b c8		 mov	 ecx, eax
  0001b	56		 push	 esi
  0001c	e8 00 00 00 00	 call	 ?SetOnimushaInfo@ioOniMushaItem@@QAEXPAVioBaseChar@@AAVSP2Packet@@@Z ; ioOniMushaItem::SetOnimushaInfo
$LN1@SetOnimush@2:
  00021	5e		 pop	 esi

; 1714 : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?SetOnimushaInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ENDP	; ioBaseChar::SetOnimushaInfo
_TEXT	ENDS
PUBLIC	?FillDruidInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z	; ioBaseChar::FillDruidInfo
EXTRN	?FillDruidInfo@ioDruidItem@@QAEXPAVioBaseChar@@AAVSP2Packet@@@Z:PROC ; ioDruidItem::FillDruidInfo
; Function compile flags: /Ogsp
;	COMDAT ?FillDruidInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z
_TEXT	SEGMENT
_rkPacket$ = 8						; size = 4
?FillDruidInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z PROC	; ioBaseChar::FillDruidInfo, COMDAT
; _this$ = ecx

; 1718 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1719 : 	ioDruidItem* pDruid = ToDruidItem( GetWeapon() );

  00006	e8 00 00 00 00	 call	 ?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ ; ioBaseChar::GetWeapon
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?ToDruidItem@@YAPAVioDruidItem@@PAVioItem@@@Z ; ToDruidItem
  00011	59		 pop	 ecx

; 1720 : 	if( pDruid )

  00012	85 c0		 test	 eax, eax
  00014	74 0b		 je	 SHORT $LN1@FillDruidI

; 1721 : 		pDruid->FillDruidInfo( this, rkPacket );

  00016	ff 75 08	 push	 DWORD PTR _rkPacket$[ebp]
  00019	8b c8		 mov	 ecx, eax
  0001b	56		 push	 esi
  0001c	e8 00 00 00 00	 call	 ?FillDruidInfo@ioDruidItem@@QAEXPAVioBaseChar@@AAVSP2Packet@@@Z ; ioDruidItem::FillDruidInfo
$LN1@FillDruidI:
  00021	5e		 pop	 esi

; 1722 : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?FillDruidInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ENDP	; ioBaseChar::FillDruidInfo
_TEXT	ENDS
PUBLIC	?SetDruidInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z	; ioBaseChar::SetDruidInfo
EXTRN	?SetDruidInfo@ioDruidItem@@QAEXPAVioBaseChar@@AAVSP2Packet@@@Z:PROC ; ioDruidItem::SetDruidInfo
; Function compile flags: /Ogsp
;	COMDAT ?SetDruidInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z
_TEXT	SEGMENT
_rkPacket$ = 8						; size = 4
?SetDruidInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z PROC	; ioBaseChar::SetDruidInfo, COMDAT
; _this$ = ecx

; 1725 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1726 : 	ioDruidItem* pDruid = ToDruidItem( GetWeapon() );

  00006	e8 00 00 00 00	 call	 ?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ ; ioBaseChar::GetWeapon
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?ToDruidItem@@YAPAVioDruidItem@@PAVioItem@@@Z ; ToDruidItem
  00011	59		 pop	 ecx

; 1727 : 	if( pDruid )	

  00012	85 c0		 test	 eax, eax
  00014	74 0b		 je	 SHORT $LN1@SetDruidIn

; 1728 : 		pDruid->SetDruidInfo( this, rkPacket );

  00016	ff 75 08	 push	 DWORD PTR _rkPacket$[ebp]
  00019	8b c8		 mov	 ecx, eax
  0001b	56		 push	 esi
  0001c	e8 00 00 00 00	 call	 ?SetDruidInfo@ioDruidItem@@QAEXPAVioBaseChar@@AAVSP2Packet@@@Z ; ioDruidItem::SetDruidInfo
$LN1@SetDruidIn:
  00021	5e		 pop	 esi

; 1729 : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?SetDruidInfo@ioBaseChar@@QAEXAAVSP2Packet@@@Z ENDP	; ioBaseChar::SetDruidInfo
_TEXT	ENDS
PUBLIC	??8?$CEncrypt@K@@QAE_NABH@Z			; CEncrypt<unsigned long>::operator==
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
;	COMDAT ??8?$CEncrypt@K@@QAE_NABH@Z
_TEXT	SEGMENT
_value$ = -4						; size = 4
_inValue$ = 8						; size = 4
??8?$CEncrypt@K@@QAE_NABH@Z PROC			; CEncrypt<unsigned long>::operator==, COMDAT
; _this$ = ecx

; 976  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 977  : 		
; 978  : 		type value;
; 979  : 		DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z ; CEncrypt<unsigned long>::DecryptValueToPool

; 980  : #ifdef _NOTUSE
; 981  : 		Debug();
; 982  : #endif
; 983  : 		return (value == inValue);

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _inValue$[ebp]
  00010	8b 55 fc	 mov	 edx, DWORD PTR _value$[ebp]
  00013	33 c0		 xor	 eax, eax
  00015	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00017	0f 94 c0	 sete	 al

; 984  : 	} 

  0001a	c9		 leave
  0001b	c2 04 00	 ret	 4
??8?$CEncrypt@K@@QAE_NABH@Z ENDP			; CEncrypt<unsigned long>::operator==
_TEXT	ENDS
PUBLIC	??9?$CEncrypt@K@@QAE_NABH@Z			; CEncrypt<unsigned long>::operator!=
; Function compile flags: /Ogsp
;	COMDAT ??9?$CEncrypt@K@@QAE_NABH@Z
_TEXT	SEGMENT
_value$ = -4						; size = 4
_inValue$ = 8						; size = 4
??9?$CEncrypt@K@@QAE_NABH@Z PROC			; CEncrypt<unsigned long>::operator!=, COMDAT
; _this$ = ecx

; 998  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 999  : 		
; 1000 : 		type value;
; 1001 : 		DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z ; CEncrypt<unsigned long>::DecryptValueToPool

; 1002 : #ifdef _NOTUSE
; 1003 : 		Debug();
; 1004 : #endif
; 1005 : 		return (value != inValue);

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _inValue$[ebp]
  00010	8b 55 fc	 mov	 edx, DWORD PTR _value$[ebp]
  00013	33 c0		 xor	 eax, eax
  00015	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00017	0f 95 c0	 setne	 al

; 1006 : 	} 		

  0001a	c9		 leave
  0001b	c2 04 00	 ret	 4
??9?$CEncrypt@K@@QAE_NABH@Z ENDP			; CEncrypt<unsigned long>::operator!=
_TEXT	ENDS
PUBLIC	??8?$CEncrypt@W4JumpState@@@@QAE_NABW4JumpState@@@Z ; CEncrypt<enum JumpState>::operator==
; Function compile flags: /Ogsp
;	COMDAT ??8?$CEncrypt@W4JumpState@@@@QAE_NABW4JumpState@@@Z
_TEXT	SEGMENT
_value$ = -4						; size = 4
_inValue$ = 8						; size = 4
??8?$CEncrypt@W4JumpState@@@@QAE_NABW4JumpState@@@Z PROC ; CEncrypt<enum JumpState>::operator==, COMDAT
; _this$ = ecx

; 2334 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2335 : 		type value;
; 2336 : 		DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4JumpState@@@@QAEXPAW4JumpState@@@Z ; CEncrypt<enum JumpState>::DecryptValueToPool

; 2337 : #ifdef _NOTUSE
; 2338 : 		Debug();
; 2339 : #endif
; 2340 : 		return (value == inValue);

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _inValue$[ebp]
  00010	8b 55 fc	 mov	 edx, DWORD PTR _value$[ebp]
  00013	33 c0		 xor	 eax, eax
  00015	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00017	0f 94 c0	 sete	 al

; 2341 : 	} 

  0001a	c9		 leave
  0001b	c2 04 00	 ret	 4
??8?$CEncrypt@W4JumpState@@@@QAE_NABW4JumpState@@@Z ENDP ; CEncrypt<enum JumpState>::operator==
_TEXT	ENDS
PUBLIC	??B?$CEncrypt@M@@QAEMXZ				; CEncrypt<float>::operator float
; Function compile flags: /Ogsp
;	COMDAT ??B?$CEncrypt@M@@QAEMXZ
_TEXT	SEGMENT
_value$ = -4						; size = 4
??B?$CEncrypt@M@@QAEMXZ PROC				; CEncrypt<float>::operator float, COMDAT
; _this$ = ecx

; 134  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 135  : 		type value;
; 136  : 		DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool

; 137  : 
; 138  : #ifdef _NOTUSE
; 139  : 		Debug();
; 140  : #endif
; 141  : 		return value;

  0000d	d9 45 fc	 fld	 DWORD PTR _value$[ebp]

; 142  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@M@@QAEMXZ ENDP				; CEncrypt<float>::operator float
_TEXT	ENDS
PUBLIC	??4?$CEncrypt@M@@QAEMM@Z			; CEncrypt<float>::operator=
; Function compile flags: /Ogsp
;	COMDAT ??4?$CEncrypt@M@@QAEMM@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
_inValue$ = 8						; size = 4
??4?$CEncrypt@M@@QAEMM@Z PROC				; CEncrypt<float>::operator=, COMDAT
; _this$ = ecx

; 1654 : 	{	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1655 : 		type value = inValue;

  00003	d9 45 08	 fld	 DWORD PTR _inValue$[ebp]

; 1656 : 		EncryptValueToPool((char*)&value);

  00006	8d 45 08	 lea	 eax, DWORD PTR _value$[ebp]
  00009	50		 push	 eax
  0000a	d9 5d 08	 fstp	 DWORD PTR _value$[ebp]
  0000d	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 1657 : #ifdef _NOTUSE
; 1658 : 		m_value = inValue;
; 1659 : 		Debug();
; 1660 : #endif
; 1661 : 		return value;

  00012	d9 45 08	 fld	 DWORD PTR _value$[ebp]

; 1662 : 	}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??4?$CEncrypt@M@@QAEMM@Z ENDP				; CEncrypt<float>::operator=
_TEXT	ENDS
PUBLIC	??B?$CEncrypt@K@@QAEKXZ				; CEncrypt<unsigned long>::operator unsigned long
; Function compile flags: /Ogsp
;	COMDAT ??B?$CEncrypt@K@@QAEKXZ
_TEXT	SEGMENT
_value$ = -4						; size = 4
??B?$CEncrypt@K@@QAEKXZ PROC				; CEncrypt<unsigned long>::operator unsigned long, COMDAT
; _this$ = ecx

; 134  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 135  : 		type value;
; 136  : 		DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z ; CEncrypt<unsigned long>::DecryptValueToPool

; 137  : 
; 138  : #ifdef _NOTUSE
; 139  : 		Debug();
; 140  : #endif
; 141  : 		return value;

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _value$[ebp]

; 142  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@K@@QAEKXZ ENDP				; CEncrypt<unsigned long>::operator unsigned long
_TEXT	ENDS
PUBLIC	??4?$CEncrypt@K@@QAEKH@Z			; CEncrypt<unsigned long>::operator=
; Function compile flags: /Ogsp
;	COMDAT ??4?$CEncrypt@K@@QAEKH@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
_inValue$ = 8						; size = 4
??4?$CEncrypt@K@@QAEKH@Z PROC				; CEncrypt<unsigned long>::operator=, COMDAT
; _this$ = ecx

; 843  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 844  : 		type value = inValue;

  00003	8b 45 08	 mov	 eax, DWORD PTR _inValue$[ebp]
  00006	89 45 08	 mov	 DWORD PTR _value$[ebp], eax

; 845  : 		EncryptValueToPool((char*)&value);

  00009	8d 45 08	 lea	 eax, DWORD PTR _value$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z ; CEncrypt<unsigned long>::EncryptValueToPool

; 846  : #ifdef _NOTUSE
; 847  : 		m_value = inValue;
; 848  : 		Debug();
; 849  : #endif
; 850  : 		return value;

  00012	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]

; 851  : 	}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??4?$CEncrypt@K@@QAEKH@Z ENDP				; CEncrypt<unsigned long>::operator=
_TEXT	ENDS
PUBLIC	??4?$CEncrypt@K@@QAEKK@Z			; CEncrypt<unsigned long>::operator=
; Function compile flags: /Ogsp
;	COMDAT ??4?$CEncrypt@K@@QAEKK@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
_inValue$ = 8						; size = 4
??4?$CEncrypt@K@@QAEKK@Z PROC				; CEncrypt<unsigned long>::operator=, COMDAT
; _this$ = ecx

; 1262 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1263 : 		
; 1264 : 		type value = inValue;

  00003	8b 45 08	 mov	 eax, DWORD PTR _inValue$[ebp]
  00006	89 45 08	 mov	 DWORD PTR _value$[ebp], eax

; 1265 : 		EncryptValueToPool((char*)&value);

  00009	8d 45 08	 lea	 eax, DWORD PTR _value$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z ; CEncrypt<unsigned long>::EncryptValueToPool

; 1266 : #ifdef _NOTUSE
; 1267 : 		m_value = inValue;
; 1268 : 		Debug();
; 1269 : #endif
; 1270 : 		return value;

  00012	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]

; 1271 : 	}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??4?$CEncrypt@K@@QAEKK@Z ENDP				; CEncrypt<unsigned long>::operator=
_TEXT	ENDS
PUBLIC	??B?$CEncrypt@_N@@QAE_NXZ			; CEncrypt<bool>::operator bool
; Function compile flags: /Ogsp
;	COMDAT ??B?$CEncrypt@_N@@QAE_NXZ
_TEXT	SEGMENT
_value$ = -1						; size = 1
??B?$CEncrypt@_N@@QAE_NXZ PROC				; CEncrypt<bool>::operator bool, COMDAT
; _this$ = ecx

; 134  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 135  : 		type value;
; 136  : 		DecryptValueToPool(&value);

  00004	8d 45 ff	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool

; 137  : 
; 138  : #ifdef _NOTUSE
; 139  : 		Debug();
; 140  : #endif
; 141  : 		return value;

  0000d	8a 45 ff	 mov	 al, BYTE PTR _value$[ebp]

; 142  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@_N@@QAE_NXZ ENDP				; CEncrypt<bool>::operator bool
_TEXT	ENDS
PUBLIC	?CheckChangeWereWolfState@ioBaseChar@@QAE_NH@Z	; ioBaseChar::CheckChangeWereWolfState
EXTRN	?IsEquipWait@ioEquipSlot@@QAE_NH@Z:PROC		; ioEquipSlot::IsEquipWait
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasecharspecialstate.cpp
;	COMDAT ?CheckChangeWereWolfState@ioBaseChar@@QAE_NH@Z
_TEXT	SEGMENT
_iExtendType$ = 8					; size = 4
_value$613338 = 11					; size = 1
?CheckChangeWereWolfState@ioBaseChar@@QAE_NH@Z PROC	; ioBaseChar::CheckChangeWereWolfState, COMDAT
; _this$ = ecx

; 87   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 88   : 	if( !CheckGrapplingExceptionState() )

  00006	e8 00 00 00 00	 call	 ?CheckGrapplingExceptionState@ioBaseChar@@QAE_NXZ ; ioBaseChar::CheckGrapplingExceptionState
  0000b	84 c0		 test	 al, al

; 89   : 		return false;

  0000d	0f 84 ed 00 00
	00		 je	 $LN12@CheckChang

; 90   : 
; 91   : 	switch( m_CharState )

  00013	8a 86 10 03 00
	00		 mov	 al, BYTE PTR [esi+784]
  00019	3c 07		 cmp	 al, 7
  0001b	0f 84 df 00 00
	00		 je	 $LN12@CheckChang
  00021	3c 14		 cmp	 al, 20			; 00000014H
  00023	0f 84 d7 00 00
	00		 je	 $LN12@CheckChang

; 96   : 	}
; 97   : 
; 98   : 	if( ToHookItem( GetWeapon() ) && ToHookItem( GetWeapon() )->CheckOnHand() )

  00029	8b ce		 mov	 ecx, esi
  0002b	e8 00 00 00 00	 call	 ?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ ; ioBaseChar::GetWeapon
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?ToHookItem@@YAPAVioHookItem@@PAVioWeaponItem@@@Z ; ToHookItem
  00036	59		 pop	 ecx
  00037	85 c0		 test	 eax, eax
  00039	74 20		 je	 SHORT $LN11@CheckChang
  0003b	8b ce		 mov	 ecx, esi
  0003d	e8 00 00 00 00	 call	 ?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ ; ioBaseChar::GetWeapon
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ?ToHookItem@@YAPAVioHookItem@@PAVioWeaponItem@@@Z ; ToHookItem
  00048	8b 10		 mov	 edx, DWORD PTR [eax]
  0004a	59		 pop	 ecx
  0004b	8b c8		 mov	 ecx, eax
  0004d	ff 92 3c 01 00
	00		 call	 DWORD PTR [edx+316]
  00053	84 c0		 test	 al, al

; 99   : 		return false;

  00055	0f 85 a5 00 00
	00		 jne	 $LN12@CheckChang
$LN11@CheckChang:

; 100  : 
; 101  : 	if( ToGunnerItem( GetWeapon() ) && ToGunnerItem( GetWeapon() )->CheckOnHand() )

  0005b	8b ce		 mov	 ecx, esi
  0005d	e8 00 00 00 00	 call	 ?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ ; ioBaseChar::GetWeapon
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 ?ToGunnerItem@@YAPAVioGunnerItem@@PAVioWeaponItem@@@Z ; ToGunnerItem
  00068	59		 pop	 ecx
  00069	85 c0		 test	 eax, eax
  0006b	74 1c		 je	 SHORT $LN10@CheckChang
  0006d	8b ce		 mov	 ecx, esi
  0006f	e8 00 00 00 00	 call	 ?GetWeapon@ioBaseChar@@QBEPAVioWeaponItem@@XZ ; ioBaseChar::GetWeapon
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 ?ToGunnerItem@@YAPAVioGunnerItem@@PAVioWeaponItem@@@Z ; ToGunnerItem
  0007a	8b 10		 mov	 edx, DWORD PTR [eax]
  0007c	59		 pop	 ecx
  0007d	8b c8		 mov	 ecx, eax
  0007f	ff 92 3c 01 00
	00		 call	 DWORD PTR [edx+316]
  00085	84 c0		 test	 al, al

; 102  : 		return false;

  00087	75 77		 jne	 SHORT $LN12@CheckChang
$LN10@CheckChang:

; 103  : 
; 104  : 	if( IsHasCrown() )

  00089	8b ce		 mov	 ecx, esi
  0008b	e8 00 00 00 00	 call	 ?IsHasCrown@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsHasCrown
  00090	84 c0		 test	 al, al

; 105  : 		return false;

  00092	75 6c		 jne	 SHORT $LN12@CheckChang

; 106  : 
; 107  : 	if( IsGangsi() )

  00094	38 86 f8 23 00
	00		 cmp	 BYTE PTR [esi+9208], al

; 108  : 		return false;

  0009a	75 64		 jne	 SHORT $LN12@CheckChang

; 109  : 
; 110  : 	if( IsBoss() && iExtendType == ioAttackableItem::ECT_RIDER )

  0009c	8a 86 e0 23 00
	00		 mov	 al, BYTE PTR [esi+9184]
  000a2	84 c0		 test	 al, al
  000a4	74 10		 je	 SHORT $LN6@CheckChang
  000a6	83 7d 08 02	 cmp	 DWORD PTR _iExtendType$[ebp], 2

; 111  : 		return false;

  000aa	74 54		 je	 SHORT $LN12@CheckChang

; 112  : 
; 113  : 	if( IsBoss() && iExtendType == ioAttackableItem::ECT_GRIFFIN )

  000ac	84 c0		 test	 al, al
  000ae	74 06		 je	 SHORT $LN6@CheckChang
  000b0	83 7d 08 03	 cmp	 DWORD PTR _iExtendType$[ebp], 3

; 114  : 		return false;

  000b4	74 4a		 je	 SHORT $LN12@CheckChang
$LN6@CheckChang:

; 115  : 
; 116  : 	if( GetObject() )

  000b6	8b ce		 mov	 ecx, esi
  000b8	e8 00 00 00 00	 call	 ?GetObjectA@ioBaseChar@@QBEPAVioObjectItem@@XZ ; ioBaseChar::GetObjectA
  000bd	85 c0		 test	 eax, eax

; 117  : 		return false;

  000bf	75 3f		 jne	 SHORT $LN12@CheckChang

; 118  : 
; 119  : 	if( m_pEquipSlot && m_pEquipSlot->IsEquipWait( ES_OBJECT ) )

  000c1	8b 8e 48 03 00
	00		 mov	 ecx, DWORD PTR [esi+840]
  000c7	85 c9		 test	 ecx, ecx
  000c9	74 0b		 je	 SHORT $LN4@CheckChang
  000cb	6a 04		 push	 4
  000cd	e8 00 00 00 00	 call	 ?IsEquipWait@ioEquipSlot@@QAE_NH@Z ; ioEquipSlot::IsEquipWait
  000d2	84 c0		 test	 al, al

; 120  : 		return false;

  000d4	75 2a		 jne	 SHORT $LN12@CheckChang
$LN4@CheckChang:

; 121  : 
; 122  : 	if( m_bPrisonerMode || m_bCatchState )

  000d6	8d 45 0b	 lea	 eax, DWORD PTR _value$613338[ebp]
  000d9	50		 push	 eax
  000da	8d 8e cc 14 00
	00		 lea	 ecx, DWORD PTR [esi+5324]
  000e0	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  000e5	80 7d 0b 00	 cmp	 BYTE PTR _value$613338[ebp], 0
  000e9	75 15		 jne	 SHORT $LN12@CheckChang
  000eb	80 be 78 23 00
	00 00		 cmp	 BYTE PTR [esi+9080], 0
  000f2	75 0c		 jne	 SHORT $LN12@CheckChang

; 123  : 		return false;
; 124  : 
; 125  : 	if( m_iEtcItemSkeleton != 0 )

  000f4	83 be 40 34 00
	00 00		 cmp	 DWORD PTR [esi+13376], 0
  000fb	0f 94 c0	 sete	 al

; 126  : 		return false;
; 127  : 
; 128  : 	return true;

  000fe	eb 02		 jmp	 SHORT $LN16@CheckChang
$LN12@CheckChang:

; 92   : 	{
; 93   : 	case CS_USING_SKILL:
; 94   : 	case CS_FLY:
; 95   : 		return false;

  00100	32 c0		 xor	 al, al
$LN16@CheckChang:
  00102	5e		 pop	 esi

; 129  : }

  00103	5d		 pop	 ebp
  00104	c2 04 00	 ret	 4
?CheckChangeWereWolfState@ioBaseChar@@QAE_NH@Z ENDP	; ioBaseChar::CheckChangeWereWolfState
_TEXT	ENDS
PUBLIC	?ClearSylphid@ioBaseChar@@QAEXXZ		; ioBaseChar::ClearSylphid
; Function compile flags: /Ogsp
;	COMDAT ?ClearSylphid@ioBaseChar@@QAEXXZ
_TEXT	SEGMENT
_value$613349 = -4					; size = 4
_value$613345 = -4					; size = 4
?ClearSylphid@ioBaseChar@@QAEXXZ PROC			; ioBaseChar::ClearSylphid, COMDAT
; _this$ = ecx

; 555  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 556  : 	m_fSylphidJumpSpeedRate = 1.0f;

  00004	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0000c	56		 push	 esi
  0000d	8b f1		 mov	 esi, ecx
  0000f	8d 45 fc	 lea	 eax, DWORD PTR _value$613345[ebp]
  00012	50		 push	 eax
  00013	8d 8e a0 37 00
	00		 lea	 ecx, DWORD PTR [esi+14240]
  00019	f3 0f 11 45 fc	 movss	 DWORD PTR _value$613345[ebp], xmm0
  0001e	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 557  : 	m_fSylphidJumpGravityRate = 1.0f;

  00023	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0002b	8d 45 fc	 lea	 eax, DWORD PTR _value$613349[ebp]
  0002e	50		 push	 eax
  0002f	8d 8e d0 37 00
	00		 lea	 ecx, DWORD PTR [esi+14288]
  00035	f3 0f 11 45 fc	 movss	 DWORD PTR _value$613349[ebp], xmm0
  0003a	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool
  0003f	5e		 pop	 esi

; 558  : }

  00040	c9		 leave
  00041	c3		 ret	 0
?ClearSylphid@ioBaseChar@@QAEXXZ ENDP			; ioBaseChar::ClearSylphid
_TEXT	ENDS
PUBLIC	?SetReturnMark@ioBaseChar@@QAEXXZ		; ioBaseChar::SetReturnMark
EXTRN	__imp_??1ioHashString@@QAE@XZ:PROC
EXTRN	?GetUniqueID@ioMapEffect@@QBEKXZ:PROC		; ioMapEffect::GetUniqueID
EXTRN	?CreateMapEffect@ioPlayStage@@QAEPAVioMapEffect@@ABVioHashString@@ABUD3DXVECTOR3@@1@Z:PROC ; ioPlayStage::CreateMapEffect
EXTRN	?GetReturnMarkEffet@ioIljimaeItem@@QBEABVioHashString@@XZ:PROC ; ioIljimaeItem::GetReturnMarkEffet
EXTRN	?GetBottomHeight@ioGameEntity@@QBEMXZ:PROC	; ioGameEntity::GetBottomHeight
EXTRN	?EndEffectForce@ioMapEffect@@QAEXXZ:PROC	; ioMapEffect::EndEffectForce
EXTRN	?FindMapEffect@ioPlayStage@@QAEPAVioMapEffect@@K@Z:PROC ; ioPlayStage::FindMapEffect
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__EH_epilog3_GS:PROC
EXTRN	__EH_prolog3_GS:PROC
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
xdata$x	SEGMENT
__unwindtable$?SetReturnMark@ioBaseChar@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetReturnMark@ioBaseChar@@QAEXXZ$0
__ehfuncinfo$?SetReturnMark@ioBaseChar@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetReturnMark@ioBaseChar@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasecharspecialstate.cpp
xdata$x	ENDS
;	COMDAT ?SetReturnMark@ioBaseChar@@QAEXXZ
_TEXT	SEGMENT
_szEffect$609449 = -68					; size = 16
tv263 = -52						; size = 4
_value$613394 = -48					; size = 4
_pIljimaeItem$ = -48					; size = 4
_value$613387 = -44					; size = 4
_value$613383 = -44					; size = 4
_value$613373 = -44					; size = 4
_value$613369 = -44					; size = 4
_value$613377 = -44					; size = 4
_value$613360 = -44					; size = 4
_value$613364 = -44					; size = 4
_vPos$609446 = -40					; size = 12
_vScale$609447 = -28					; size = 12
__$EHRec$ = -12						; size = 12
?SetReturnMark@ioBaseChar@@QAEXXZ PROC			; ioBaseChar::SetReturnMark, COMDAT
; _this$ = ecx

; 562  : {

  00000	6a 38		 push	 56			; 00000038H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetReturnMark@ioBaseChar@@QAEXXZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000c	8b d9		 mov	 ebx, ecx

; 563  : 	if( !IsNeedProcess() )	return;

  0000e	8b 03		 mov	 eax, DWORD PTR [ebx]
  00010	ff 90 00 01 00
	00		 call	 DWORD PTR [eax+256]
  00016	84 c0		 test	 al, al
  00018	0f 84 56 01 00
	00		 je	 $LN2@SetReturnM

; 564  : 
; 565  : 	ioItem *pItem = GetEquipedItem(ES_WEAPON);

  0001e	6a 00		 push	 0
  00020	8b cb		 mov	 ecx, ebx
  00022	e8 00 00 00 00	 call	 ?GetEquipedItem@ioBaseChar@@QAEPAVioItem@@H@Z ; ioBaseChar::GetEquipedItem

; 566  : 	ioIljimaeItem *pIljimaeItem = ToIljimaeItem( pItem );

  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?ToIljimaeItem@@YAPAVioIljimaeItem@@PAVioItem@@@Z ; ToIljimaeItem
  0002d	89 45 d0	 mov	 DWORD PTR _pIljimaeItem$[ebp], eax

; 567  : 	if( !pIljimaeItem )

  00030	85 c0		 test	 eax, eax
  00032	59		 pop	 ecx

; 568  : 	{
; 569  : 		if( m_dwReturnMarkEffectID != -1 )

  00033	8d 45 d4	 lea	 eax, DWORD PTR _value$613360[ebp]
  00036	50		 push	 eax
  00037	75 59		 jne	 SHORT $LN7@SetReturnM
  00039	8d 8b 00 38 00
	00		 lea	 ecx, DWORD PTR [ebx+14336]
  0003f	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z ; CEncrypt<unsigned long>::DecryptValueToPool
  00044	83 7d d4 ff	 cmp	 DWORD PTR _value$613360[ebp], -1
  00048	0f 84 26 01 00
	00		 je	 $LN2@SetReturnM

; 570  : 		{
; 571  : 			ioMapEffect *pMapEffect = m_pCreator->FindMapEffect( m_dwReturnMarkEffectID );

  0004e	8d 45 d4	 lea	 eax, DWORD PTR _value$613364[ebp]
  00051	50		 push	 eax
  00052	8d 8b 00 38 00
	00		 lea	 ecx, DWORD PTR [ebx+14336]
  00058	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z ; CEncrypt<unsigned long>::DecryptValueToPool
  0005d	ff 75 d4	 push	 DWORD PTR _value$613364[ebp]
  00060	8b 8b 44 03 00
	00		 mov	 ecx, DWORD PTR [ebx+836]
  00066	e8 00 00 00 00	 call	 ?FindMapEffect@ioPlayStage@@QAEPAVioMapEffect@@K@Z ; ioPlayStage::FindMapEffect

; 572  : 			if( pMapEffect )

  0006b	85 c0		 test	 eax, eax
  0006d	0f 84 01 01 00
	00		 je	 $LN2@SetReturnM

; 573  : 			{
; 574  : 				pMapEffect->EndEffectForce();

  00073	8b c8		 mov	 ecx, eax
  00075	e8 00 00 00 00	 call	 ?EndEffectForce@ioMapEffect@@QAEXXZ ; ioMapEffect::EndEffectForce

; 575  : 				m_dwReturnMarkEffectID = -1;

  0007a	83 4d d4 ff	 or	 DWORD PTR _value$613369[ebp], -1
  0007e	8d 45 d4	 lea	 eax, DWORD PTR _value$613369[ebp]
  00081	50		 push	 eax
  00082	8d 8b 00 38 00
	00		 lea	 ecx, DWORD PTR [ebx+14336]
  00088	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z ; CEncrypt<unsigned long>::EncryptValueToPool

; 576  : 			}
; 577  : 		}
; 578  : 		return;

  0008d	e9 e2 00 00 00	 jmp	 $LN2@SetReturnM
$LN7@SetReturnM:

; 579  : 	}
; 580  : 
; 581  : 	if( m_dwReturnMarkEffectID != -1 )

  00092	8d b3 00 38 00
	00		 lea	 esi, DWORD PTR [ebx+14336]
  00098	8b ce		 mov	 ecx, esi
  0009a	89 75 cc	 mov	 DWORD PTR tv263[ebp], esi
  0009d	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z ; CEncrypt<unsigned long>::DecryptValueToPool
  000a2	83 7d d4 ff	 cmp	 DWORD PTR _value$613373[ebp], -1
  000a6	74 33		 je	 SHORT $LN22@SetReturnM

; 582  : 	{
; 583  : 		ioMapEffect *pMapEffect = m_pCreator->FindMapEffect( m_dwReturnMarkEffectID );

  000a8	8d 45 d4	 lea	 eax, DWORD PTR _value$613377[ebp]
  000ab	50		 push	 eax
  000ac	8b ce		 mov	 ecx, esi
  000ae	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z ; CEncrypt<unsigned long>::DecryptValueToPool
  000b3	ff 75 d4	 push	 DWORD PTR _value$613377[ebp]
  000b6	8b 8b 44 03 00
	00		 mov	 ecx, DWORD PTR [ebx+836]
  000bc	e8 00 00 00 00	 call	 ?FindMapEffect@ioPlayStage@@QAEPAVioMapEffect@@K@Z ; ioPlayStage::FindMapEffect

; 584  : 		if( pMapEffect )

  000c1	85 c0		 test	 eax, eax
  000c3	74 16		 je	 SHORT $LN22@SetReturnM

; 585  : 		{
; 586  : 			pMapEffect->EndEffectForce();

  000c5	8b c8		 mov	 ecx, eax
  000c7	e8 00 00 00 00	 call	 ?EndEffectForce@ioMapEffect@@QAEXXZ ; ioMapEffect::EndEffectForce

; 587  : 			m_dwReturnMarkEffectID = -1;

  000cc	83 4d d4 ff	 or	 DWORD PTR _value$613383[ebp], -1
  000d0	8d 45 d4	 lea	 eax, DWORD PTR _value$613383[ebp]
  000d3	50		 push	 eax
  000d4	8b ce		 mov	 ecx, esi
  000d6	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z ; CEncrypt<unsigned long>::EncryptValueToPool
$LN22@SetReturnM:

; 588  : 		}
; 589  : 	}
; 590  : 
; 591  : 	if( m_dwReturnMarkEffectID == -1 )

  000db	8d 45 d4	 lea	 eax, DWORD PTR _value$613387[ebp]
  000de	50		 push	 eax
  000df	8b ce		 mov	 ecx, esi
  000e1	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z ; CEncrypt<unsigned long>::DecryptValueToPool
  000e6	83 7d d4 ff	 cmp	 DWORD PTR _value$613387[ebp], -1
  000ea	0f 85 84 00 00
	00		 jne	 $LN2@SetReturnM

; 592  : 	{
; 593  : 		D3DXVECTOR3 vPos = GetWorldPosition();

  000f0	8b 03		 mov	 eax, DWORD PTR [ebx]
  000f2	8b cb		 mov	 ecx, ebx
  000f4	ff 50 70	 call	 DWORD PTR [eax+112]
  000f7	8b f0		 mov	 esi, eax
  000f9	8d 7d d8	 lea	 edi, DWORD PTR _vPos$609446[ebp]
  000fc	a5		 movsd
  000fd	a5		 movsd

; 594  : 		vPos.y = GetBottomHeight();

  000fe	8b cb		 mov	 ecx, ebx
  00100	a5		 movsd
  00101	e8 00 00 00 00	 call	 ?GetBottomHeight@ioGameEntity@@QBEMXZ ; ioGameEntity::GetBottomHeight

; 595  : 		D3DXVECTOR3 vScale = D3DXVECTOR3( 1.0f, 1.0f, 1.0f );

  00106	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000

; 596  : 		ioHashString szEffect = pIljimaeItem->GetReturnMarkEffet();

  0010e	8b 4d d0	 mov	 ecx, DWORD PTR _pIljimaeItem$[ebp]
  00111	d9 5d dc	 fstp	 DWORD PTR _vPos$609446[ebp+4]
  00114	f3 0f 11 45 e4	 movss	 DWORD PTR _vScale$609447[ebp], xmm0
  00119	f3 0f 11 45 e8	 movss	 DWORD PTR _vScale$609447[ebp+4], xmm0
  0011e	f3 0f 11 45 ec	 movss	 DWORD PTR _vScale$609447[ebp+8], xmm0
  00123	e8 00 00 00 00	 call	 ?GetReturnMarkEffet@ioIljimaeItem@@QBEABVioHashString@@XZ ; ioIljimaeItem::GetReturnMarkEffet
  00128	50		 push	 eax
  00129	8d 4d bc	 lea	 ecx, DWORD PTR _szEffect$609449[ebp]
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z

; 597  : 		ioMapEffect *pMapEffect = m_pCreator->CreateMapEffect( szEffect, vPos, vScale );

  00132	8b 8b 44 03 00
	00		 mov	 ecx, DWORD PTR [ebx+836]
  00138	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0013c	8d 45 e4	 lea	 eax, DWORD PTR _vScale$609447[ebp]
  0013f	50		 push	 eax
  00140	8d 45 d8	 lea	 eax, DWORD PTR _vPos$609446[ebp]
  00143	50		 push	 eax
  00144	8d 45 bc	 lea	 eax, DWORD PTR _szEffect$609449[ebp]
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 ?CreateMapEffect@ioPlayStage@@QAEPAVioMapEffect@@ABVioHashString@@ABUD3DXVECTOR3@@1@Z ; ioPlayStage::CreateMapEffect

; 598  : 		if( pMapEffect )

  0014d	85 c0		 test	 eax, eax
  0014f	74 16		 je	 SHORT $LN28@SetReturnM

; 599  : 		{
; 600  : 			m_dwReturnMarkEffectID = pMapEffect->GetUniqueID();

  00151	8b c8		 mov	 ecx, eax
  00153	e8 00 00 00 00	 call	 ?GetUniqueID@ioMapEffect@@QBEKXZ ; ioMapEffect::GetUniqueID
  00158	8b 4d cc	 mov	 ecx, DWORD PTR tv263[ebp]
  0015b	89 45 d0	 mov	 DWORD PTR _value$613394[ebp], eax
  0015e	8d 45 d0	 lea	 eax, DWORD PTR _value$613394[ebp]
  00161	50		 push	 eax
  00162	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z ; CEncrypt<unsigned long>::EncryptValueToPool
$LN28@SetReturnM:

; 601  : 		}
; 602  : 	}

  00167	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0016b	8d 4d bc	 lea	 ecx, DWORD PTR _szEffect$609449[ebp]
  0016e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
$LN2@SetReturnM:

; 603  : }

  00174	e8 00 00 00 00	 call	 __EH_epilog3_GS
  00179	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetReturnMark@ioBaseChar@@QAEXXZ$0:
  00000	8d 4d bc	 lea	 ecx, DWORD PTR _szEffect$609449[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$?SetReturnMark@ioBaseChar@@QAEXXZ:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetReturnMark@ioBaseChar@@QAEXXZ
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetReturnMark@ioBaseChar@@QAEXXZ ENDP			; ioBaseChar::SetReturnMark
PUBLIC	?CheckReturnMark@ioBaseChar@@IAEXXZ		; ioBaseChar::CheckReturnMark
EXTRN	?SetDisableReturnMarkEffect@ioIljimaeItem@@QAEXXZ:PROC ; ioIljimaeItem::SetDisableReturnMarkEffect
EXTRN	?IsShowMarkEffect@ioIljimaeItem@@QAE_NXZ:PROC	; ioIljimaeItem::IsShowMarkEffect
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
xdata$x	SEGMENT
__unwindtable$?CheckReturnMark@ioBaseChar@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CheckReturnMark@ioBaseChar@@IAEXXZ$0
__ehfuncinfo$?CheckReturnMark@ioBaseChar@@IAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CheckReturnMark@ioBaseChar@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasecharspecialstate.cpp
xdata$x	ENDS
;	COMDAT ?CheckReturnMark@ioBaseChar@@IAEXXZ
_TEXT	SEGMENT
_szEffect$609469 = -68					; size = 16
_value$613452 = -52					; size = 4
_value$613438 = -52					; size = 4
_pIljimaeItem$ = -52					; size = 4
tv263 = -48						; size = 4
_value$613443 = -48					; size = 4
_value$613447 = -48					; size = 4
_value$613431 = -44					; size = 4
_value$613427 = -44					; size = 4
_value$613418 = -44					; size = 4
_value$613422 = -44					; size = 4
_vPos$609466 = -40					; size = 12
_vScale$609467 = -28					; size = 12
__$EHRec$ = -12						; size = 12
?CheckReturnMark@ioBaseChar@@IAEXXZ PROC		; ioBaseChar::CheckReturnMark, COMDAT
; _this$ = ecx

; 606  : {

  00000	6a 38		 push	 56			; 00000038H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?CheckReturnMark@ioBaseChar@@IAEXXZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000c	8b d9		 mov	 ebx, ecx

; 607  : 	if( !IsNeedProcess() )	return;

  0000e	8b 03		 mov	 eax, DWORD PTR [ebx]
  00010	ff 90 00 01 00
	00		 call	 DWORD PTR [eax+256]
  00016	84 c0		 test	 al, al
  00018	0f 84 78 01 00
	00		 je	 $LN3@CheckRetur

; 608  : 
; 609  : 	ioItem *pItem = GetEquipedItem(ES_WEAPON);

  0001e	6a 00		 push	 0
  00020	8b cb		 mov	 ecx, ebx
  00022	e8 00 00 00 00	 call	 ?GetEquipedItem@ioBaseChar@@QAEPAVioItem@@H@Z ; ioBaseChar::GetEquipedItem

; 610  : 	ioIljimaeItem *pIljimaeItem = ToIljimaeItem( pItem );

  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?ToIljimaeItem@@YAPAVioIljimaeItem@@PAVioItem@@@Z ; ToIljimaeItem
  0002d	8b f8		 mov	 edi, eax
  0002f	59		 pop	 ecx
  00030	89 7d cc	 mov	 DWORD PTR _pIljimaeItem$[ebp], edi

; 611  : 	if( !pIljimaeItem )

  00033	85 ff		 test	 edi, edi
  00035	75 5d		 jne	 SHORT $LN9@CheckRetur

; 612  : 	{
; 613  : 		if( m_dwReturnMarkEffectID != -1 )

  00037	8d 45 d4	 lea	 eax, DWORD PTR _value$613418[ebp]
  0003a	50		 push	 eax
  0003b	8d 8b 00 38 00
	00		 lea	 ecx, DWORD PTR [ebx+14336]
  00041	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z ; CEncrypt<unsigned long>::DecryptValueToPool
  00046	83 7d d4 ff	 cmp	 DWORD PTR _value$613418[ebp], -1
  0004a	0f 84 46 01 00
	00		 je	 $LN3@CheckRetur

; 614  : 		{
; 615  : 			ioMapEffect *pMapEffect = m_pCreator->FindMapEffect( m_dwReturnMarkEffectID );

  00050	8d 45 d4	 lea	 eax, DWORD PTR _value$613422[ebp]
  00053	50		 push	 eax
  00054	8d 8b 00 38 00
	00		 lea	 ecx, DWORD PTR [ebx+14336]
  0005a	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z ; CEncrypt<unsigned long>::DecryptValueToPool
  0005f	ff 75 d4	 push	 DWORD PTR _value$613422[ebp]
  00062	8b 8b 44 03 00
	00		 mov	 ecx, DWORD PTR [ebx+836]
  00068	e8 00 00 00 00	 call	 ?FindMapEffect@ioPlayStage@@QAEPAVioMapEffect@@K@Z ; ioPlayStage::FindMapEffect

; 616  : 			if( pMapEffect )

  0006d	85 c0		 test	 eax, eax
  0006f	0f 84 21 01 00
	00		 je	 $LN3@CheckRetur

; 617  : 			{
; 618  : 				pMapEffect->EndEffectForce();

  00075	8b c8		 mov	 ecx, eax
  00077	e8 00 00 00 00	 call	 ?EndEffectForce@ioMapEffect@@QAEXXZ ; ioMapEffect::EndEffectForce

; 619  : 				m_dwReturnMarkEffectID = -1;

  0007c	83 4d d4 ff	 or	 DWORD PTR _value$613427[ebp], -1
  00080	8d 45 d4	 lea	 eax, DWORD PTR _value$613427[ebp]
  00083	50		 push	 eax
  00084	8d 8b 00 38 00
	00		 lea	 ecx, DWORD PTR [ebx+14336]
  0008a	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z ; CEncrypt<unsigned long>::EncryptValueToPool

; 620  : 			}
; 621  : 		}
; 622  : 		return;

  0008f	e9 02 01 00 00	 jmp	 $LN3@CheckRetur
$LN9@CheckRetur:

; 623  : 	}
; 624  : 
; 625  : 	if( pIljimaeItem->IsShowMarkEffect() )

  00094	8b cf		 mov	 ecx, edi
  00096	e8 00 00 00 00	 call	 ?IsShowMarkEffect@ioIljimaeItem@@QAE_NXZ ; ioIljimaeItem::IsShowMarkEffect

; 626  : 	{
; 627  : 		if( m_dwReturnMarkEffectID == -1 )

  0009b	8d 8b 00 38 00
	00		 lea	 ecx, DWORD PTR [ebx+14336]
  000a1	84 c0		 test	 al, al
  000a3	0f 84 9c 00 00
	00		 je	 $LN6@CheckRetur
  000a9	8d 45 d4	 lea	 eax, DWORD PTR _value$613431[ebp]
  000ac	50		 push	 eax
  000ad	89 4d d0	 mov	 DWORD PTR tv263[ebp], ecx
  000b0	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z ; CEncrypt<unsigned long>::DecryptValueToPool
  000b5	83 7d d4 ff	 cmp	 DWORD PTR _value$613431[ebp], -1
  000b9	0f 85 d7 00 00
	00		 jne	 $LN3@CheckRetur

; 628  : 		{
; 629  : 			D3DXVECTOR3 vPos = GetWorldPosition();

  000bf	8b 03		 mov	 eax, DWORD PTR [ebx]
  000c1	8b cb		 mov	 ecx, ebx
  000c3	ff 50 70	 call	 DWORD PTR [eax+112]
  000c6	8b f0		 mov	 esi, eax
  000c8	8d 7d d8	 lea	 edi, DWORD PTR _vPos$609466[ebp]
  000cb	a5		 movsd
  000cc	a5		 movsd

; 630  : 			vPos.y = GetBottomHeight();

  000cd	8b cb		 mov	 ecx, ebx
  000cf	a5		 movsd
  000d0	e8 00 00 00 00	 call	 ?GetBottomHeight@ioGameEntity@@QBEMXZ ; ioGameEntity::GetBottomHeight

; 631  : 			D3DXVECTOR3 vScale = D3DXVECTOR3( 1.0f, 1.0f, 1.0f );

  000d5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000

; 632  : 			ioHashString szEffect = pIljimaeItem->GetReturnMarkEffet();

  000dd	8b 4d cc	 mov	 ecx, DWORD PTR _pIljimaeItem$[ebp]
  000e0	d9 5d dc	 fstp	 DWORD PTR _vPos$609466[ebp+4]
  000e3	f3 0f 11 45 e4	 movss	 DWORD PTR _vScale$609467[ebp], xmm0
  000e8	f3 0f 11 45 e8	 movss	 DWORD PTR _vScale$609467[ebp+4], xmm0
  000ed	f3 0f 11 45 ec	 movss	 DWORD PTR _vScale$609467[ebp+8], xmm0
  000f2	e8 00 00 00 00	 call	 ?GetReturnMarkEffet@ioIljimaeItem@@QBEABVioHashString@@XZ ; ioIljimaeItem::GetReturnMarkEffet
  000f7	50		 push	 eax
  000f8	8d 4d bc	 lea	 ecx, DWORD PTR _szEffect$609469[ebp]
  000fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z

; 633  : 			ioMapEffect *pMapEffect = m_pCreator->CreateMapEffect( szEffect, vPos, vScale );

  00101	8b 8b 44 03 00
	00		 mov	 ecx, DWORD PTR [ebx+836]
  00107	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0010b	8d 45 e4	 lea	 eax, DWORD PTR _vScale$609467[ebp]
  0010e	50		 push	 eax
  0010f	8d 45 d8	 lea	 eax, DWORD PTR _vPos$609466[ebp]
  00112	50		 push	 eax
  00113	8d 45 bc	 lea	 eax, DWORD PTR _szEffect$609469[ebp]
  00116	50		 push	 eax
  00117	e8 00 00 00 00	 call	 ?CreateMapEffect@ioPlayStage@@QAEPAVioMapEffect@@ABVioHashString@@ABUD3DXVECTOR3@@1@Z ; ioPlayStage::CreateMapEffect

; 634  : 			if( pMapEffect )

  0011c	85 c0		 test	 eax, eax
  0011e	74 16		 je	 SHORT $LN24@CheckRetur

; 635  : 				m_dwReturnMarkEffectID = pMapEffect->GetUniqueID();

  00120	8b c8		 mov	 ecx, eax
  00122	e8 00 00 00 00	 call	 ?GetUniqueID@ioMapEffect@@QBEKXZ ; ioMapEffect::GetUniqueID
  00127	8b 4d d0	 mov	 ecx, DWORD PTR tv263[ebp]
  0012a	89 45 cc	 mov	 DWORD PTR _value$613438[ebp], eax
  0012d	8d 45 cc	 lea	 eax, DWORD PTR _value$613438[ebp]
  00130	50		 push	 eax
  00131	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z ; CEncrypt<unsigned long>::EncryptValueToPool
$LN24@CheckRetur:

; 636  : 		}

  00136	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0013a	8d 4d bc	 lea	 ecx, DWORD PTR _szEffect$609469[ebp]
  0013d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ

; 637  : 	}
; 638  : 	else

  00143	eb 51		 jmp	 SHORT $LN3@CheckRetur
$LN6@CheckRetur:

; 639  : 	{
; 640  : 		if( m_dwReturnMarkEffectID != -1 )

  00145	8d 45 d0	 lea	 eax, DWORD PTR _value$613443[ebp]
  00148	50		 push	 eax
  00149	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z ; CEncrypt<unsigned long>::DecryptValueToPool
  0014e	83 7d d0 ff	 cmp	 DWORD PTR _value$613443[ebp], -1
  00152	74 3b		 je	 SHORT $LN30@CheckRetur

; 641  : 		{
; 642  : 			ioMapEffect *pMapEffect = m_pCreator->FindMapEffect( m_dwReturnMarkEffectID );

  00154	8d 45 d0	 lea	 eax, DWORD PTR _value$613447[ebp]
  00157	50		 push	 eax
  00158	8d 8b 00 38 00
	00		 lea	 ecx, DWORD PTR [ebx+14336]
  0015e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z ; CEncrypt<unsigned long>::DecryptValueToPool
  00163	ff 75 d0	 push	 DWORD PTR _value$613447[ebp]
  00166	8b 8b 44 03 00
	00		 mov	 ecx, DWORD PTR [ebx+836]
  0016c	e8 00 00 00 00	 call	 ?FindMapEffect@ioPlayStage@@QAEPAVioMapEffect@@K@Z ; ioPlayStage::FindMapEffect

; 643  : 			if( pMapEffect )

  00171	85 c0		 test	 eax, eax
  00173	74 1a		 je	 SHORT $LN30@CheckRetur

; 644  : 			{
; 645  : 				pMapEffect->EndEffectForce();

  00175	8b c8		 mov	 ecx, eax
  00177	e8 00 00 00 00	 call	 ?EndEffectForce@ioMapEffect@@QAEXXZ ; ioMapEffect::EndEffectForce

; 646  : 				m_dwReturnMarkEffectID = -1;

  0017c	83 4d cc ff	 or	 DWORD PTR _value$613452[ebp], -1
  00180	8d 45 cc	 lea	 eax, DWORD PTR _value$613452[ebp]
  00183	50		 push	 eax
  00184	8d 8b 00 38 00
	00		 lea	 ecx, DWORD PTR [ebx+14336]
  0018a	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z ; CEncrypt<unsigned long>::EncryptValueToPool
$LN30@CheckRetur:

; 647  : 			}
; 648  : 		}
; 649  : 		pIljimaeItem->SetDisableReturnMarkEffect();

  0018f	8b cf		 mov	 ecx, edi
  00191	e8 00 00 00 00	 call	 ?SetDisableReturnMarkEffect@ioIljimaeItem@@QAEXXZ ; ioIljimaeItem::SetDisableReturnMarkEffect
$LN3@CheckRetur:

; 650  : 	}
; 651  : }

  00196	e8 00 00 00 00	 call	 __EH_epilog3_GS
  0019b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CheckReturnMark@ioBaseChar@@IAEXXZ$0:
  00000	8d 4d bc	 lea	 ecx, DWORD PTR _szEffect$609469[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$?CheckReturnMark@ioBaseChar@@IAEXXZ:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CheckReturnMark@ioBaseChar@@IAEXXZ
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CheckReturnMark@ioBaseChar@@IAEXXZ ENDP		; ioBaseChar::CheckReturnMark
PUBLIC	__$ArrayPad$
PUBLIC	?CheckSylphid@ioBaseChar@@IAEX_N@Z		; ioBaseChar::CheckSylphid
EXTRN	??1SP2Packet@@UAE@XZ:PROC			; SP2Packet::~SP2Packet
EXTRN	?SetJumpPower@ioBaseChar@@QAEXM@Z:PROC		; ioBaseChar::SetJumpPower
EXTRN	?SetForcePower@ioBaseChar@@QAEXABUD3DXVECTOR3@@MM_N@Z:PROC ; ioBaseChar::SetForcePower
EXTRN	?IsCanDoubleJumpAttack@ioRachelJump@@QAE_NXZ:PROC ; ioRachelJump::IsCanDoubleJumpAttack
EXTRN	?IsJumpDashState@ioRachelJump@@QAE_NXZ:PROC	; ioRachelJump::IsJumpDashState
EXTRN	?SendToAllPlayingUser@P2PNetwork@@YAXAAVSP2Packet@@PAVioBaseChar@@@Z:PROC ; P2PNetwork::SendToAllPlayingUser
EXTRN	??6SP2Packet@@QAEAAV0@_N@Z:PROC			; SP2Packet::operator<<
EXTRN	??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z:PROC	; SP2Packet::operator<<
EXTRN	??0SP2Packet@@QAE@K@Z:PROC			; SP2Packet::SP2Packet
EXTRN	?AttachEffect@ioBaseChar@@QAEPAVioEffect@@ABVioHashString@@PAVioEntityEvent@@_N@Z:PROC ; ioBaseChar::AttachEffect
EXTRN	?EndEffect@ioBaseChar@@QAEXABVioHashString@@_N1@Z:PROC ; ioBaseChar::EndEffect
EXTRN	__imp_?IsEmpty@ioHashString@@QBE_NXZ:PROC
EXTRN	?GetCurExtendJump@ioAttackableItem@@QAEPAVioExtendJump@@XZ:PROC ; ioAttackableItem::GetCurExtendJump
EXTRN	?IsDefenseKey@ioUserKeyInput@@QBE_NXZ:PROC	; ioUserKeyInput::IsDefenseKey
EXTRN	__chkstk:PROC
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasechar.h
xdata$x	SEGMENT
__unwindtable$?CheckSylphid@ioBaseChar@@IAEX_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CheckSylphid@ioBaseChar@@IAEX_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CheckSylphid@ioBaseChar@@IAEX_N@Z$1
__ehfuncinfo$?CheckSylphid@ioBaseChar@@IAEX_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CheckSylphid@ioBaseChar@@IAEX_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasecharspecialstate.cpp
xdata$x	ENDS
;	COMDAT ?CheckSylphid@ioBaseChar@@IAEX_N@Z
_TEXT	SEGMENT
_value$613476 = -65616					; size = 4
_value$613480 = -65616					; size = 4
_iNeedSylphid$ = -65616					; size = 4
_value$613496 = -65612					; size = 4
_value$613492 = -65612					; size = 4
_value$613488 = -65612					; size = 4
_value$613484 = -65612					; size = 4
_pRachelJump$ = -65612					; size = 4
_value$613557 = -65608					; size = 4
_value$613552 = -65608					; size = 4
_value$613547 = -65608					; size = 4
_value$613542 = -65608					; size = 4
_value$613538 = -65608					; size = 4
_value$613534 = -65608					; size = 4
_value$613525 = -65608					; size = 4
_value$613520 = -65608					; size = 4
_value$613516 = -65608					; size = 4
_value$613512 = -65608					; size = 4
_value$613508 = -65608					; size = 4
_value$613500 = -65608					; size = 4
_value$613504 = -65608					; size = 4
_bUseSylphid$ = -65601					; size = 1
_kPacket$609384 = -65600				; size = 32792
_kPacket$609329 = -32808				; size = 32792
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_bDefense$ = 8						; size = 1
?CheckSylphid@ioBaseChar@@IAEX_N@Z PROC			; ioBaseChar::CheckSylphid, COMDAT
; _this$ = ecx

; 217  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CheckSylphid@ioBaseChar@@IAEX_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 44 00 01 00	 mov	 eax, 65604		; 00010044H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00032	8b f1		 mov	 esi, ecx

; 218  : 	if( !m_KeyInput.IsDefenseKey() )

  00034	8d 8e 80 0c 00
	00		 lea	 ecx, DWORD PTR [esi+3200]
  0003a	e8 00 00 00 00	 call	 ?IsDefenseKey@ioUserKeyInput@@QBE_NXZ ; ioUserKeyInput::IsDefenseKey
  0003f	84 c0		 test	 al, al
  00041	0f 84 06 07 00
	00		 je	 $LN31@CheckSylph

; 219  : 		return;
; 220  : 
; 221  : 	ioRachelItem *pRachelItem = ToRachelItem( GetPriorityItem( SPT_ATTACK ) );

  00047	6a 05		 push	 5
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 ?ToRachelItem@@YAPAVioRachelItem@@PAVioItem@@@Z ; ToRachelItem
  00056	8b f8		 mov	 edi, eax
  00058	59		 pop	 ecx

; 222  : 	if( !pRachelItem )		//     ...

  00059	85 ff		 test	 edi, edi
  0005b	0f 84 ec 06 00
	00		 je	 $LN31@CheckSylph

; 223  : 		return;
; 224  : 
; 225  : 	if( pRachelItem->GetCurBullet() <= 0 )

  00061	8b 07		 mov	 eax, DWORD PTR [edi]
  00063	8b cf		 mov	 ecx, edi
  00065	ff 50 64	 call	 DWORD PTR [eax+100]
  00068	85 c0		 test	 eax, eax
  0006a	0f 8e dd 06 00
	00		 jle	 $LN31@CheckSylph

; 226  : 		return;
; 227  : 
; 228  : 	const SylphidInfo &rkInfo = pRachelItem->GetSylphidInfo();
; 229  : 	ioRachelJump *pRachelJump = ToRachelJump( pRachelItem->GetCurExtendJump() );

  00070	8b cf		 mov	 ecx, edi
  00072	e8 00 00 00 00	 call	 ?GetCurExtendJump@ioAttackableItem@@QAEPAVioExtendJump@@XZ ; ioAttackableItem::GetCurExtendJump
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ?ToRachelJump@@YAPAVioRachelJump@@PAVioExtendJump@@@Z ; ToRachelJump

; 230  : 
; 231  : 	if( bDefense )

  0007d	80 7d 08 00	 cmp	 BYTE PTR _bDefense$[ebp], 0
  00081	59		 pop	 ecx
  00082	8b c8		 mov	 ecx, eax
  00084	89 8d b4 ff fe
	ff		 mov	 DWORD PTR _pRachelJump$[ebp], ecx
  0008a	0f 84 ad 00 00
	00		 je	 $LN42@CheckSylph

; 232  : 	{
; 233  : 		ClearSylphid();

  00090	8b ce		 mov	 ecx, esi
  00092	e8 00 00 00 00	 call	 ?ClearSylphid@ioBaseChar@@QAEXXZ ; ioBaseChar::ClearSylphid

; 234  : 
; 235  : 		if( CheckObjectSylphid( true ) )

  00097	33 db		 xor	 ebx, ebx
  00099	43		 inc	 ebx
  0009a	53		 push	 ebx
  0009b	8b ce		 mov	 ecx, esi
  0009d	e8 00 00 00 00	 call	 ?CheckObjectSylphid@ioBaseChar@@QAE_N_N@Z ; ioBaseChar::CheckObjectSylphid
  000a2	84 c0		 test	 al, al
  000a4	0f 84 a3 06 00
	00		 je	 $LN31@CheckSylph

; 236  : 		{
; 237  : 			if( !rkInfo.m_DefaultEffect.IsEmpty() )

  000aa	81 c7 70 1a 00
	00		 add	 edi, 6768		; 00001a70H
  000b0	8b cf		 mov	 ecx, edi
  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  000b8	84 c0		 test	 al, al
  000ba	75 16		 jne	 SHORT $LN40@CheckSylph

; 238  : 			{
; 239  : 				EndEffect( rkInfo.m_DefaultEffect, false );

  000bc	53		 push	 ebx
  000bd	6a 00		 push	 0
  000bf	57		 push	 edi
  000c0	8b ce		 mov	 ecx, esi
  000c2	e8 00 00 00 00	 call	 ?EndEffect@ioBaseChar@@QAEXABVioHashString@@_N1@Z ; ioBaseChar::EndEffect

; 240  : 				AttachEffect( rkInfo.m_DefaultEffect );

  000c7	53		 push	 ebx
  000c8	6a 00		 push	 0
  000ca	57		 push	 edi
  000cb	8b ce		 mov	 ecx, esi
  000cd	e8 00 00 00 00	 call	 ?AttachEffect@ioBaseChar@@QAEPAVioEffect@@ABVioHashString@@PAVioEntityEvent@@_N@Z ; ioBaseChar::AttachEffect
$LN40@CheckSylph:

; 241  : 			}
; 242  : 
; 243  : 			if( IsNeedSendNetwork() )

  000d2	8b 06		 mov	 eax, DWORD PTR [esi]
  000d4	8b ce		 mov	 ecx, esi
  000d6	ff 90 04 01 00
	00		 call	 DWORD PTR [eax+260]
  000dc	84 c0		 test	 al, al
  000de	0f 84 69 06 00
	00		 je	 $LN31@CheckSylph

; 244  : 			{
; 245  : 				SP2Packet kPacket( CUPK_CHAR_ACTION_INFO );

  000e4	68 30 42 00 00	 push	 16944			; 00004230H
  000e9	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$609329[ebp]
  000ef	e8 00 00 00 00	 call	 ??0SP2Packet@@QAE@K@Z	; SP2Packet::SP2Packet
  000f4	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 246  : 				kPacket << GetCharName();

  000f8	81 c6 d4 02 00
	00		 add	 esi, 724		; 000002d4H
  000fe	56		 push	 esi
  000ff	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$609329[ebp]
  00105	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z ; SP2Packet::operator<<

; 247  : 				kPacket << CHAR_ACTION_SYLPHID;

  0010a	53		 push	 ebx
  0010b	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$609329[ebp]
  00111	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@H@Z ; SP2Packet::operator<<

; 248  : 				kPacket << true;		// defense

  00116	53		 push	 ebx
  00117	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$609329[ebp]
  0011d	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@_N@Z ; SP2Packet::operator<<

; 249  : 				P2PNetwork::SendToAllPlayingUser( kPacket );

  00122	8d 85 d8 7f ff
	ff		 lea	 eax, DWORD PTR _kPacket$609329[ebp]
  00128	6a 00		 push	 0
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 ?SendToAllPlayingUser@P2PNetwork@@YAXAAVSP2Packet@@PAVioBaseChar@@@Z ; P2PNetwork::SendToAllPlayingUser
  00130	59		 pop	 ecx
  00131	59		 pop	 ecx

; 250  : 			}

  00132	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$609329[ebp]

; 251  : 		}
; 252  : 
; 253  : 		return;

  00138	e9 07 06 00 00	 jmp	 $LN100@CheckSylph
$LN42@CheckSylph:

; 254  : 	}
; 255  : 
; 256  : 	int iNeedSylphid = (int)rkInfo.m_dwDefaultNeed;
; 257  : 
; 258  : 	switch( m_CharState )

  0013d	0f b6 86 10 03
	00 00		 movzx	 eax, BYTE PTR [esi+784]
  00144	83 e8 04	 sub	 eax, 4
  00147	8b 9f 6c 1a 00
	00		 mov	 ebx, DWORD PTR [edi+6764]
  0014d	74 2b		 je	 SHORT $LN34@CheckSylph
  0014f	48		 dec	 eax
  00150	48		 dec	 eax
  00151	0f 85 f6 05 00
	00		 jne	 $LN31@CheckSylph

; 259  : 	{
; 260  : 	case CS_DASH_ATTACK:
; 261  : 		if( !m_bSetExtraDashAttack && !m_bSetExtraOtherDashAttack )

  00157	38 86 69 2f 00
	00		 cmp	 BYTE PTR [esi+12137], al
  0015d	0f 85 ea 05 00
	00		 jne	 $LN31@CheckSylph
  00163	38 86 9d 2f 00
	00		 cmp	 BYTE PTR [esi+12189], al
  00169	0f 85 de 05 00
	00		 jne	 $LN31@CheckSylph

; 262  : 		{
; 263  : 			iNeedSylphid += (int)rkInfo.m_dwDashAttackNeed;

  0016f	03 9f 88 1a 00
	00		 add	 ebx, DWORD PTR [edi+6792]

; 264  : 			break;

  00175	e9 9f 00 00 00	 jmp	 $LN101@CheckSylph
$LN34@CheckSylph:

; 265  : 		}
; 266  : 		return;
; 267  : 	case CS_JUMP:
; 268  : 		if( pRachelJump && pRachelJump->IsJumpDashState() )

  0017a	85 c9		 test	 ecx, ecx
  0017c	0f 84 cb 05 00
	00		 je	 $LN31@CheckSylph
  00182	e8 00 00 00 00	 call	 ?IsJumpDashState@ioRachelJump@@QAE_NXZ ; ioRachelJump::IsJumpDashState
  00187	84 c0		 test	 al, al
  00189	74 0b		 je	 SHORT $LN33@CheckSylph

; 269  : 		{
; 270  : 			iNeedSylphid += (int)rkInfo.m_dwJumpDashNeed;

  0018b	03 9f a4 1a 00
	00		 add	 ebx, DWORD PTR [edi+6820]

; 271  : 			break;

  00191	e9 83 00 00 00	 jmp	 $LN101@CheckSylph
$LN33@CheckSylph:

; 272  : 		}
; 273  : 		else if( pRachelJump && m_JumpState == JS_JUMPPING )

  00196	8d 85 b0 ff fe
	ff		 lea	 eax, DWORD PTR _value$613476[ebp]
  0019c	50		 push	 eax
  0019d	8d 8e 40 0e 00
	00		 lea	 ecx, DWORD PTR [esi+3648]
  001a3	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4JumpState@@@@QAEXPAW4JumpState@@@Z ; CEncrypt<enum JumpState>::DecryptValueToPool
  001a8	83 bd b0 ff fe
	ff 02		 cmp	 DWORD PTR _value$613476[ebp], 2
  001af	0f 85 98 05 00
	00		 jne	 $LN31@CheckSylph

; 274  : 		{
; 275  : 			if( m_fCurJumpPowerAmt >= m_fGravityAmt )

  001b5	8d 85 b0 ff fe
	ff		 lea	 eax, DWORD PTR _value$613480[ebp]
  001bb	50		 push	 eax
  001bc	8d 8e e8 0b 00
	00		 lea	 ecx, DWORD PTR [esi+3048]
  001c2	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  001c7	f3 0f 10 86 90
	0e 00 00	 movss	 xmm0, DWORD PTR [esi+3728]
  001cf	f3 0f 10 8d b0
	ff fe ff	 movss	 xmm1, DWORD PTR _value$613480[ebp]

; 276  : 			{
; 277  : 				if( pRachelJump->IsCanDoubleJumpAttack() )

  001d7	8b 8d b4 ff fe
	ff		 mov	 ecx, DWORD PTR _pRachelJump$[ebp]
  001dd	0f 5a c0	 cvtps2pd xmm0, xmm0
  001e0	0f 5a c9	 cvtps2pd xmm1, xmm1
  001e3	66 0f 2f c1	 comisd	 xmm0, xmm1
  001e7	72 19		 jb	 SHORT $LN30@CheckSylph
  001e9	e8 00 00 00 00	 call	 ?IsCanDoubleJumpAttack@ioRachelJump@@QAE_NXZ ; ioRachelJump::IsCanDoubleJumpAttack
  001ee	84 c0		 test	 al, al
  001f0	74 08		 je	 SHORT $LN29@CheckSylph

; 278  : 					iNeedSylphid += (int)rkInfo.m_dwUpJumpNeed2;

  001f2	03 9f f8 1a 00
	00		 add	 ebx, DWORD PTR [edi+6904]

; 279  : 				else

  001f8	eb 1f		 jmp	 SHORT $LN101@CheckSylph
$LN29@CheckSylph:

; 280  : 					iNeedSylphid += (int)rkInfo.m_dwUpJumpNeed;

  001fa	03 9f c0 1a 00
	00		 add	 ebx, DWORD PTR [edi+6848]

; 281  : 			}
; 282  : 			else

  00200	eb 17		 jmp	 SHORT $LN101@CheckSylph
$LN30@CheckSylph:

; 283  : 			{
; 284  : 				if( pRachelJump->IsCanDoubleJumpAttack() )

  00202	e8 00 00 00 00	 call	 ?IsCanDoubleJumpAttack@ioRachelJump@@QAE_NXZ ; ioRachelJump::IsCanDoubleJumpAttack
  00207	84 c0		 test	 al, al
  00209	74 08		 je	 SHORT $LN26@CheckSylph

; 285  : 					iNeedSylphid += (int)rkInfo.m_dwDownJumpNeed2;

  0020b	03 9f 14 1b 00
	00		 add	 ebx, DWORD PTR [edi+6932]

; 286  : 				else

  00211	eb 06		 jmp	 SHORT $LN101@CheckSylph
$LN26@CheckSylph:

; 287  : 					iNeedSylphid += (int)rkInfo.m_dwDownJumpNeed;

  00213	03 9f dc 1a 00
	00		 add	 ebx, DWORD PTR [edi+6876]
$LN101@CheckSylph:

; 288  : 			}
; 289  : 			break;
; 290  : 		}
; 291  : 		return;
; 292  : 	default:
; 293  : 		return;
; 294  : 	}
; 295  : 
; 296  : 	ClearSylphid();

  00219	8b ce		 mov	 ecx, esi
  0021b	89 9d b0 ff fe
	ff		 mov	 DWORD PTR _iNeedSylphid$[ebp], ebx
  00221	e8 00 00 00 00	 call	 ?ClearSylphid@ioBaseChar@@QAEXXZ ; ioBaseChar::ClearSylphid

; 297  : 
; 298  : 	bool bUseSylphid = false;

  00226	c6 85 bf ff fe
	ff 00		 mov	 BYTE PTR _bUseSylphid$[ebp], 0

; 299  : 	DWORD dwCurTime = FRAMEGETTIME();

  0022d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  00233	8b c8		 mov	 ecx, eax
  00235	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ

; 300  : 
; 301  : 	switch( m_CharState )

  0023b	0f b6 86 10 03
	00 00		 movzx	 eax, BYTE PTR [esi+784]
  00242	83 e8 04	 sub	 eax, 4
  00245	6a 01		 push	 1
  00247	5b		 pop	 ebx
  00248	0f 84 b7 00 00
	00		 je	 $LN19@CheckSylph
  0024e	48		 dec	 eax
  0024f	48		 dec	 eax
  00250	0f 85 49 04 00
	00		 jne	 $LN15@CheckSylph

; 302  : 	{
; 303  : 	case CS_DASH_ATTACK:
; 304  : 		{
; 305  : 			bUseSylphid = true;
; 306  : 			m_fForceAmt = 0.0f;

  00256	0f 57 c0	 xorps	 xmm0, xmm0
  00259	8d 85 b4 ff fe
	ff		 lea	 eax, DWORD PTR _value$613484[ebp]
  0025f	50		 push	 eax
  00260	8d 8e 88 0b 00
	00		 lea	 ecx, DWORD PTR [esi+2952]
  00266	88 9d bf ff fe
	ff		 mov	 BYTE PTR _bUseSylphid$[ebp], bl
  0026c	f3 0f 11 85 b4
	ff fe ff	 movss	 DWORD PTR _value$613484[ebp], xmm0
  00274	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 307  : 			m_fForceFrictionRate = 1.0f;

  00279	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00281	8d 85 b4 ff fe
	ff		 lea	 eax, DWORD PTR _value$613488[ebp]
  00287	50		 push	 eax
  00288	8d 8e b8 0b 00
	00		 lea	 ecx, DWORD PTR [esi+3000]
  0028e	f3 0f 11 85 b4
	ff fe ff	 movss	 DWORD PTR _value$613488[ebp], xmm0
  00296	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 308  : 
; 309  : 			SetForcePower( m_vMoveDir, rkInfo.m_fDashAttackForceAmt, rkInfo.m_fDashAttackFriction );

  0029b	f3 0f 10 87 84
	1a 00 00	 movss	 xmm0, DWORD PTR [edi+6788]
  002a3	6a 00		 push	 0
  002a5	51		 push	 ecx
  002a6	51		 push	 ecx
  002a7	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  002ad	f3 0f 10 87 80
	1a 00 00	 movss	 xmm0, DWORD PTR [edi+6784]
  002b5	8d 86 b4 06 00
	00		 lea	 eax, DWORD PTR [esi+1716]
  002bb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002c0	50		 push	 eax
  002c1	8b ce		 mov	 ecx, esi
  002c3	e8 00 00 00 00	 call	 ?SetForcePower@ioBaseChar@@QAEXABUD3DXVECTOR3@@MM_N@Z ; ioBaseChar::SetForcePower

; 310  : 
; 311  : 			pRachelItem->DecreaseCoolTime( iNeedSylphid );

  002c8	ff b5 b0 ff fe
	ff		 push	 DWORD PTR _iNeedSylphid$[ebp]
  002ce	8b cf		 mov	 ecx, edi
  002d0	e8 00 00 00 00	 call	 ?DecreaseCoolTime@ioRachelItem@@QAEXH@Z ; ioRachelItem::DecreaseCoolTime

; 312  : 
; 313  : 			if( !rkInfo.m_DashAttackEffect.IsEmpty() )

  002d5	8d 8f 8c 1a 00
	00		 lea	 ecx, DWORD PTR [edi+6796]
  002db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  002e1	84 c0		 test	 al, al
  002e3	0f 85 b6 03 00
	00		 jne	 $LN15@CheckSylph

; 314  : 			{
; 315  : 				EndEffect( rkInfo.m_DashAttackEffect, false );

  002e9	53		 push	 ebx
  002ea	6a 00		 push	 0
  002ec	8d 87 8c 1a 00
	00		 lea	 eax, DWORD PTR [edi+6796]
  002f2	50		 push	 eax
  002f3	8b ce		 mov	 ecx, esi
  002f5	e8 00 00 00 00	 call	 ?EndEffect@ioBaseChar@@QAEXABVioHashString@@_N1@Z ; ioBaseChar::EndEffect

; 316  : 				AttachEffect( rkInfo.m_DashAttackEffect );

  002fa	8d 87 8c 1a 00
	00		 lea	 eax, DWORD PTR [edi+6796]

; 317  : 			}
; 318  : 		}
; 319  : 		break;

  00300	e9 c5 00 00 00	 jmp	 $LN104@CheckSylph
$LN19@CheckSylph:

; 320  : 	case CS_JUMP:
; 321  : 		if( pRachelJump && pRachelJump->IsJumpDashState() )

  00305	8b 8d b4 ff fe
	ff		 mov	 ecx, DWORD PTR _pRachelJump$[ebp]
  0030b	85 c9		 test	 ecx, ecx
  0030d	0f 84 8c 03 00
	00		 je	 $LN15@CheckSylph
  00313	e8 00 00 00 00	 call	 ?IsJumpDashState@ioRachelJump@@QAE_NXZ ; ioRachelJump::IsJumpDashState
  00318	84 c0		 test	 al, al
  0031a	0f 84 ba 00 00
	00		 je	 $LN18@CheckSylph

; 322  : 		{
; 323  : 			bUseSylphid = true;
; 324  : 			m_fForceAmt = 0.0f;

  00320	0f 57 c0	 xorps	 xmm0, xmm0
  00323	8d 85 b4 ff fe
	ff		 lea	 eax, DWORD PTR _value$613492[ebp]
  00329	50		 push	 eax
  0032a	8d 8e 88 0b 00
	00		 lea	 ecx, DWORD PTR [esi+2952]
  00330	88 9d bf ff fe
	ff		 mov	 BYTE PTR _bUseSylphid$[ebp], bl
  00336	f3 0f 11 85 b4
	ff fe ff	 movss	 DWORD PTR _value$613492[ebp], xmm0
  0033e	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 325  : 			m_fForceFrictionRate = 1.0f;

  00343	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0034b	8d 85 b4 ff fe
	ff		 lea	 eax, DWORD PTR _value$613496[ebp]
  00351	50		 push	 eax
  00352	8d 8e b8 0b 00
	00		 lea	 ecx, DWORD PTR [esi+3000]
  00358	f3 0f 11 85 b4
	ff fe ff	 movss	 DWORD PTR _value$613496[ebp], xmm0
  00360	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 326  : 
; 327  : 			SetForcePower( m_vMoveDir, rkInfo.m_fJumpDashForceAmt, rkInfo.m_fJumpDashFriction );

  00365	f3 0f 10 87 a0
	1a 00 00	 movss	 xmm0, DWORD PTR [edi+6816]
  0036d	6a 00		 push	 0
  0036f	51		 push	 ecx
  00370	51		 push	 ecx
  00371	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00377	f3 0f 10 87 9c
	1a 00 00	 movss	 xmm0, DWORD PTR [edi+6812]
  0037f	8d 86 b4 06 00
	00		 lea	 eax, DWORD PTR [esi+1716]
  00385	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0038a	50		 push	 eax
  0038b	8b ce		 mov	 ecx, esi
  0038d	e8 00 00 00 00	 call	 ?SetForcePower@ioBaseChar@@QAEXABUD3DXVECTOR3@@MM_N@Z ; ioBaseChar::SetForcePower

; 328  : 
; 329  : 			pRachelItem->DecreaseCoolTime( iNeedSylphid );

  00392	ff b5 b0 ff fe
	ff		 push	 DWORD PTR _iNeedSylphid$[ebp]
  00398	8b cf		 mov	 ecx, edi
  0039a	e8 00 00 00 00	 call	 ?DecreaseCoolTime@ioRachelItem@@QAEXH@Z ; ioRachelItem::DecreaseCoolTime

; 330  : 
; 331  : 			if( !rkInfo.m_JumpDashEffect.IsEmpty() )

  0039f	8d 8f a8 1a 00
	00		 lea	 ecx, DWORD PTR [edi+6824]
  003a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  003ab	84 c0		 test	 al, al
  003ad	0f 85 ec 02 00
	00		 jne	 $LN15@CheckSylph

; 332  : 			{
; 333  : 				EndEffect( rkInfo.m_JumpDashEffect, false );

  003b3	53		 push	 ebx
  003b4	6a 00		 push	 0
  003b6	8d 87 a8 1a 00
	00		 lea	 eax, DWORD PTR [edi+6824]
  003bc	50		 push	 eax
  003bd	8b ce		 mov	 ecx, esi
  003bf	e8 00 00 00 00	 call	 ?EndEffect@ioBaseChar@@QAEXABVioHashString@@_N1@Z ; ioBaseChar::EndEffect

; 334  : 				AttachEffect( rkInfo.m_JumpDashEffect );

  003c4	8d 87 a8 1a 00
	00		 lea	 eax, DWORD PTR [edi+6824]
$LN104@CheckSylph:
  003ca	53		 push	 ebx
  003cb	6a 00		 push	 0
  003cd	50		 push	 eax
  003ce	8b ce		 mov	 ecx, esi
  003d0	e8 00 00 00 00	 call	 ?AttachEffect@ioBaseChar@@QAEPAVioEffect@@ABVioHashString@@PAVioEntityEvent@@_N@Z ; ioBaseChar::AttachEffect

; 335  : 			}
; 336  : 		}

  003d5	e9 c5 02 00 00	 jmp	 $LN15@CheckSylph
$LN18@CheckSylph:

; 337  : 		else if( pRachelJump && m_JumpState == JS_JUMPPING )

  003da	8d 85 b8 ff fe
	ff		 lea	 eax, DWORD PTR _value$613500[ebp]
  003e0	50		 push	 eax
  003e1	8d 8e 40 0e 00
	00		 lea	 ecx, DWORD PTR [esi+3648]
  003e7	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4JumpState@@@@QAEXPAW4JumpState@@@Z ; CEncrypt<enum JumpState>::DecryptValueToPool
  003ec	83 bd b8 ff fe
	ff 02		 cmp	 DWORD PTR _value$613500[ebp], 2
  003f3	0f 85 a6 02 00
	00		 jne	 $LN15@CheckSylph

; 338  : 		{
; 339  : 			if( m_fCurJumpPowerAmt >= m_fGravityAmt )	// up

  003f9	8d 85 b8 ff fe
	ff		 lea	 eax, DWORD PTR _value$613504[ebp]
  003ff	8d 8e e8 0b 00
	00		 lea	 ecx, DWORD PTR [esi+3048]
  00405	50		 push	 eax
  00406	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  0040b	f3 0f 10 86 90
	0e 00 00	 movss	 xmm0, DWORD PTR [esi+3728]
  00413	f3 0f 10 8d b8
	ff fe ff	 movss	 xmm1, DWORD PTR _value$613504[ebp]
  0041b	0f 5a c0	 cvtps2pd xmm0, xmm0
  0041e	0f 5a c9	 cvtps2pd xmm1, xmm1

; 340  : 			{
; 341  : 				bUseSylphid = true;
; 342  : 				m_fCurJumpPowerAmt = 0.0f;
; 343  : 				m_fGravityAmt = 0.0f;

  00421	8d 85 b8 ff fe
	ff		 lea	 eax, DWORD PTR _value$613508[ebp]
  00427	66 0f 2f c1	 comisd	 xmm0, xmm1
  0042b	0f 57 c0	 xorps	 xmm0, xmm0
  0042e	88 9d bf ff fe
	ff		 mov	 BYTE PTR _bUseSylphid$[ebp], bl
  00434	8d 8e e8 0b 00
	00		 lea	 ecx, DWORD PTR [esi+3048]
  0043a	50		 push	 eax
  0043b	f3 0f 11 86 90
	0e 00 00	 movss	 DWORD PTR [esi+3728], xmm0
  00443	f3 0f 11 85 b8
	ff fe ff	 movss	 DWORD PTR _value$613508[ebp], xmm0
  0044b	0f 82 14 01 00
	00		 jb	 $LN14@CheckSylph
  00451	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 344  : 				m_fForceAmt = 0.0f;

  00456	0f 57 c0	 xorps	 xmm0, xmm0
  00459	8d 85 b8 ff fe
	ff		 lea	 eax, DWORD PTR _value$613512[ebp]
  0045f	50		 push	 eax
  00460	8d 8e 88 0b 00
	00		 lea	 ecx, DWORD PTR [esi+2952]
  00466	f3 0f 11 85 b8
	ff fe ff	 movss	 DWORD PTR _value$613512[ebp], xmm0
  0046e	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 345  : 				m_fForceFrictionRate = 1.0f;

  00473	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0047b	8d 85 b8 ff fe
	ff		 lea	 eax, DWORD PTR _value$613516[ebp]
  00481	50		 push	 eax
  00482	8d 8e b8 0b 00
	00		 lea	 ecx, DWORD PTR [esi+3000]
  00488	f3 0f 11 85 b8
	ff fe ff	 movss	 DWORD PTR _value$613516[ebp], xmm0
  00490	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 346  : 
; 347  : 				if( pRachelJump->IsCanDoubleJumpAttack() )

  00495	8b 8d b4 ff fe
	ff		 mov	 ecx, DWORD PTR _pRachelJump$[ebp]
  0049b	e8 00 00 00 00	 call	 ?IsCanDoubleJumpAttack@ioRachelJump@@QAE_NXZ ; ioRachelJump::IsCanDoubleJumpAttack
  004a0	84 c0		 test	 al, al

; 348  : 				{
; 349  : 					m_fSylphidJumpSpeedRate = rkInfo.m_fUpJumpSpeedRate2;

  004a2	8d 85 b8 ff fe
	ff		 lea	 eax, DWORD PTR _value$613520[ebp]
  004a8	8d 8e a0 37 00
	00		 lea	 ecx, DWORD PTR [esi+14240]
  004ae	50		 push	 eax
  004af	74 5a		 je	 SHORT $LN13@CheckSylph
  004b1	f3 0f 10 87 f4
	1a 00 00	 movss	 xmm0, DWORD PTR [edi+6900]
  004b9	f3 0f 11 85 b8
	ff fe ff	 movss	 DWORD PTR _value$613520[ebp], xmm0
  004c1	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 350  : 					SetJumpPower( rkInfo.m_fUpJumpPowerAmt2 );

  004c6	f3 0f 10 87 f0
	1a 00 00	 movss	 xmm0, DWORD PTR [edi+6896]
  004ce	51		 push	 ecx
  004cf	8b ce		 mov	 ecx, esi
  004d1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004d6	e8 00 00 00 00	 call	 ?SetJumpPower@ioBaseChar@@QAEXM@Z ; ioBaseChar::SetJumpPower

; 351  : 
; 352  : 					if( !rkInfo.m_UpJumpEffect2.IsEmpty() )

  004db	8d 8f fc 1a 00
	00		 lea	 ecx, DWORD PTR [edi+6908]
  004e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  004e7	84 c0		 test	 al, al
  004e9	0f 85 a3 01 00
	00		 jne	 $LN5@CheckSylph

; 353  : 					{
; 354  : 						EndEffect( rkInfo.m_UpJumpEffect2, false );

  004ef	53		 push	 ebx
  004f0	6a 00		 push	 0
  004f2	8d 87 fc 1a 00
	00		 lea	 eax, DWORD PTR [edi+6908]
  004f8	50		 push	 eax
  004f9	8b ce		 mov	 ecx, esi
  004fb	e8 00 00 00 00	 call	 ?EndEffect@ioBaseChar@@QAEXABVioHashString@@_N1@Z ; ioBaseChar::EndEffect

; 355  : 						AttachEffect( rkInfo.m_UpJumpEffect2 );

  00500	8d 87 fc 1a 00
	00		 lea	 eax, DWORD PTR [edi+6908]

; 356  : 					}
; 357  : 				}
; 358  : 				else

  00506	e9 7c 01 00 00	 jmp	 $LN102@CheckSylph
$LN13@CheckSylph:

; 359  : 				{
; 360  : 					m_fSylphidJumpSpeedRate = rkInfo.m_fUpJumpSpeedRate;

  0050b	f3 0f 10 87 bc
	1a 00 00	 movss	 xmm0, DWORD PTR [edi+6844]
  00513	f3 0f 11 85 b8
	ff fe ff	 movss	 DWORD PTR _value$613525[ebp], xmm0
  0051b	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 361  : 					SetJumpPower( rkInfo.m_fUpJumpPowerAmt );

  00520	f3 0f 10 87 b8
	1a 00 00	 movss	 xmm0, DWORD PTR [edi+6840]
  00528	51		 push	 ecx
  00529	8b ce		 mov	 ecx, esi
  0052b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00530	e8 00 00 00 00	 call	 ?SetJumpPower@ioBaseChar@@QAEXM@Z ; ioBaseChar::SetJumpPower

; 362  : 
; 363  : 					if( !rkInfo.m_UpJumpEffect.IsEmpty() )

  00535	8d 8f c4 1a 00
	00		 lea	 ecx, DWORD PTR [edi+6852]
  0053b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00541	84 c0		 test	 al, al
  00543	0f 85 49 01 00
	00		 jne	 $LN5@CheckSylph

; 364  : 					{
; 365  : 						EndEffect( rkInfo.m_UpJumpEffect, false );

  00549	53		 push	 ebx
  0054a	6a 00		 push	 0
  0054c	8d 87 c4 1a 00
	00		 lea	 eax, DWORD PTR [edi+6852]
  00552	50		 push	 eax
  00553	8b ce		 mov	 ecx, esi
  00555	e8 00 00 00 00	 call	 ?EndEffect@ioBaseChar@@QAEXABVioHashString@@_N1@Z ; ioBaseChar::EndEffect

; 366  : 						AttachEffect( rkInfo.m_UpJumpEffect );

  0055a	8d 87 c4 1a 00
	00		 lea	 eax, DWORD PTR [edi+6852]

; 367  : 					}
; 368  : 				}
; 369  : 			}
; 370  : 			else	// down

  00560	e9 22 01 00 00	 jmp	 $LN102@CheckSylph
$LN14@CheckSylph:

; 371  : 			{
; 372  : 				bUseSylphid = true;
; 373  : 				m_fCurJumpPowerAmt = 0.0f;
; 374  : 				m_fGravityAmt = 0.0f;

  00565	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 375  : 				m_fForceAmt = 0.0f;

  0056a	0f 57 c0	 xorps	 xmm0, xmm0
  0056d	8d 85 b8 ff fe
	ff		 lea	 eax, DWORD PTR _value$613534[ebp]
  00573	50		 push	 eax
  00574	8d 8e 88 0b 00
	00		 lea	 ecx, DWORD PTR [esi+2952]
  0057a	f3 0f 11 85 b8
	ff fe ff	 movss	 DWORD PTR _value$613534[ebp], xmm0
  00582	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 376  : 				m_fForceFrictionRate = 1.0f;

  00587	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0058f	8d 85 b8 ff fe
	ff		 lea	 eax, DWORD PTR _value$613538[ebp]
  00595	50		 push	 eax
  00596	8d 8e b8 0b 00
	00		 lea	 ecx, DWORD PTR [esi+3000]
  0059c	f3 0f 11 85 b8
	ff fe ff	 movss	 DWORD PTR _value$613538[ebp], xmm0
  005a4	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 377  : 
; 378  : 				if( pRachelJump->IsCanDoubleJumpAttack() )

  005a9	8b 8d b4 ff fe
	ff		 mov	 ecx, DWORD PTR _pRachelJump$[ebp]
  005af	e8 00 00 00 00	 call	 ?IsCanDoubleJumpAttack@ioRachelJump@@QAE_NXZ ; ioRachelJump::IsCanDoubleJumpAttack
  005b4	84 c0		 test	 al, al

; 379  : 				{
; 380  : 					m_fSylphidJumpSpeedRate = rkInfo.m_fDownJumpSpeedRate2;

  005b6	8d 85 b8 ff fe
	ff		 lea	 eax, DWORD PTR _value$613542[ebp]
  005bc	8d 8e a0 37 00
	00		 lea	 ecx, DWORD PTR [esi+14240]
  005c2	50		 push	 eax
  005c3	74 64		 je	 SHORT $LN8@CheckSylph
  005c5	f3 0f 10 87 10
	1b 00 00	 movss	 xmm0, DWORD PTR [edi+6928]
  005cd	f3 0f 11 85 b8
	ff fe ff	 movss	 DWORD PTR _value$613542[ebp], xmm0
  005d5	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 381  : 					m_fSylphidJumpGravityRate = rkInfo.m_fDownJumpGrabityRate2;

  005da	f3 0f 10 87 0c
	1b 00 00	 movss	 xmm0, DWORD PTR [edi+6924]
  005e2	8d 85 b8 ff fe
	ff		 lea	 eax, DWORD PTR _value$613547[ebp]
  005e8	50		 push	 eax
  005e9	8d 8e d0 37 00
	00		 lea	 ecx, DWORD PTR [esi+14288]
  005ef	f3 0f 11 85 b8
	ff fe ff	 movss	 DWORD PTR _value$613547[ebp], xmm0
  005f7	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 382  : 
; 383  : 					if( !rkInfo.m_DownJumpEffect2.IsEmpty() )

  005fc	8d 8f 18 1b 00
	00		 lea	 ecx, DWORD PTR [edi+6936]
  00602	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00608	84 c0		 test	 al, al
  0060a	0f 85 82 00 00
	00		 jne	 $LN5@CheckSylph

; 384  : 					{
; 385  : 						EndEffect( rkInfo.m_DownJumpEffect2, false );

  00610	53		 push	 ebx
  00611	6a 00		 push	 0
  00613	8d 87 18 1b 00
	00		 lea	 eax, DWORD PTR [edi+6936]
  00619	50		 push	 eax
  0061a	8b ce		 mov	 ecx, esi
  0061c	e8 00 00 00 00	 call	 ?EndEffect@ioBaseChar@@QAEXABVioHashString@@_N1@Z ; ioBaseChar::EndEffect

; 386  : 						AttachEffect( rkInfo.m_DownJumpEffect2 );

  00621	8d 87 18 1b 00
	00		 lea	 eax, DWORD PTR [edi+6936]

; 387  : 					}
; 388  : 				}
; 389  : 				else

  00627	eb 5e		 jmp	 SHORT $LN102@CheckSylph
$LN8@CheckSylph:

; 390  : 				{
; 391  : 					m_fSylphidJumpSpeedRate = rkInfo.m_fDownJumpSpeedRate;

  00629	f3 0f 10 87 d8
	1a 00 00	 movss	 xmm0, DWORD PTR [edi+6872]
  00631	f3 0f 11 85 b8
	ff fe ff	 movss	 DWORD PTR _value$613552[ebp], xmm0
  00639	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 392  : 					m_fSylphidJumpGravityRate = rkInfo.m_fDownJumpGrabityRate;

  0063e	f3 0f 10 87 d4
	1a 00 00	 movss	 xmm0, DWORD PTR [edi+6868]
  00646	8d 85 b8 ff fe
	ff		 lea	 eax, DWORD PTR _value$613557[ebp]
  0064c	50		 push	 eax
  0064d	8d 8e d0 37 00
	00		 lea	 ecx, DWORD PTR [esi+14288]
  00653	f3 0f 11 85 b8
	ff fe ff	 movss	 DWORD PTR _value$613557[ebp], xmm0
  0065b	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 393  : 
; 394  : 					if( !rkInfo.m_DownJumpEffect.IsEmpty() )

  00660	8d 8f e0 1a 00
	00		 lea	 ecx, DWORD PTR [edi+6880]
  00666	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  0066c	84 c0		 test	 al, al
  0066e	75 22		 jne	 SHORT $LN5@CheckSylph

; 395  : 					{
; 396  : 						EndEffect( rkInfo.m_DownJumpEffect, false );

  00670	53		 push	 ebx
  00671	6a 00		 push	 0
  00673	8d 87 e0 1a 00
	00		 lea	 eax, DWORD PTR [edi+6880]
  00679	50		 push	 eax
  0067a	8b ce		 mov	 ecx, esi
  0067c	e8 00 00 00 00	 call	 ?EndEffect@ioBaseChar@@QAEXABVioHashString@@_N1@Z ; ioBaseChar::EndEffect

; 397  : 						AttachEffect( rkInfo.m_DownJumpEffect );

  00681	8d 87 e0 1a 00
	00		 lea	 eax, DWORD PTR [edi+6880]
$LN102@CheckSylph:
  00687	53		 push	 ebx
  00688	6a 00		 push	 0
  0068a	50		 push	 eax
  0068b	8b ce		 mov	 ecx, esi
  0068d	e8 00 00 00 00	 call	 ?AttachEffect@ioBaseChar@@QAEPAVioEffect@@ABVioHashString@@PAVioEntityEvent@@_N@Z ; ioBaseChar::AttachEffect
$LN5@CheckSylph:

; 398  : 					}
; 399  : 				}
; 400  : 			}
; 401  : 
; 402  : 			pRachelItem->DecreaseCoolTime( iNeedSylphid );

  00692	ff b5 b0 ff fe
	ff		 push	 DWORD PTR _iNeedSylphid$[ebp]
  00698	8b cf		 mov	 ecx, edi
  0069a	e8 00 00 00 00	 call	 ?DecreaseCoolTime@ioRachelItem@@QAEXH@Z ; ioRachelItem::DecreaseCoolTime
$LN15@CheckSylph:

; 403  : 		}
; 404  : 		break;
; 405  : 	}
; 406  : 
; 407  : 	if( CheckObjectSylphid( true ) )

  0069f	53		 push	 ebx
  006a0	8b ce		 mov	 ecx, esi
  006a2	e8 00 00 00 00	 call	 ?CheckObjectSylphid@ioBaseChar@@QAE_N_N@Z ; ioBaseChar::CheckObjectSylphid
  006a7	84 c0		 test	 al, al
  006a9	74 06		 je	 SHORT $LN4@CheckSylph

; 408  : 		bUseSylphid = true;

  006ab	88 9d bf ff fe
	ff		 mov	 BYTE PTR _bUseSylphid$[ebp], bl
$LN4@CheckSylph:

; 409  : 
; 410  : 	if( bUseSylphid )

  006b1	80 bd bf ff fe
	ff 00		 cmp	 BYTE PTR _bUseSylphid$[ebp], 0
  006b8	74 28		 je	 SHORT $LN2@CheckSylph

; 411  : 	{
; 412  : 		if( !rkInfo.m_DefaultEffect.IsEmpty() )

  006ba	81 c7 70 1a 00
	00		 add	 edi, 6768		; 00001a70H
  006c0	8b cf		 mov	 ecx, edi
  006c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  006c8	84 c0		 test	 al, al
  006ca	75 16		 jne	 SHORT $LN2@CheckSylph

; 413  : 		{
; 414  : 			EndEffect( rkInfo.m_DefaultEffect, false );

  006cc	53		 push	 ebx
  006cd	6a 00		 push	 0
  006cf	57		 push	 edi
  006d0	8b ce		 mov	 ecx, esi
  006d2	e8 00 00 00 00	 call	 ?EndEffect@ioBaseChar@@QAEXABVioHashString@@_N1@Z ; ioBaseChar::EndEffect

; 415  : 			AttachEffect( rkInfo.m_DefaultEffect );

  006d7	53		 push	 ebx
  006d8	6a 00		 push	 0
  006da	57		 push	 edi
  006db	8b ce		 mov	 ecx, esi
  006dd	e8 00 00 00 00	 call	 ?AttachEffect@ioBaseChar@@QAEPAVioEffect@@ABVioHashString@@PAVioEntityEvent@@_N@Z ; ioBaseChar::AttachEffect
$LN2@CheckSylph:

; 416  : 		}
; 417  : 	}
; 418  : 
; 419  : 	if( IsNeedSendNetwork() )

  006e2	8b 06		 mov	 eax, DWORD PTR [esi]
  006e4	8b ce		 mov	 ecx, esi
  006e6	ff 90 04 01 00
	00		 call	 DWORD PTR [eax+260]
  006ec	84 c0		 test	 al, al
  006ee	74 5d		 je	 SHORT $LN31@CheckSylph

; 420  : 	{
; 421  : 		SP2Packet kPacket( CUPK_CHAR_ACTION_INFO );

  006f0	68 30 42 00 00	 push	 16944			; 00004230H
  006f5	8d 8d c0 ff fe
	ff		 lea	 ecx, DWORD PTR _kPacket$609384[ebp]
  006fb	e8 00 00 00 00	 call	 ??0SP2Packet@@QAE@K@Z	; SP2Packet::SP2Packet

; 422  : 		kPacket << GetCharName();

  00700	81 c6 d4 02 00
	00		 add	 esi, 724		; 000002d4H
  00706	56		 push	 esi
  00707	8d 8d c0 ff fe
	ff		 lea	 ecx, DWORD PTR _kPacket$609384[ebp]
  0070d	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00710	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z ; SP2Packet::operator<<

; 423  : 		kPacket << CHAR_ACTION_SYLPHID;

  00715	53		 push	 ebx
  00716	8d 8d c0 ff fe
	ff		 lea	 ecx, DWORD PTR _kPacket$609384[ebp]
  0071c	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@H@Z ; SP2Packet::operator<<

; 424  : 		kPacket << false;		// defense

  00721	6a 00		 push	 0
  00723	8d 8d c0 ff fe
	ff		 lea	 ecx, DWORD PTR _kPacket$609384[ebp]
  00729	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@_N@Z ; SP2Packet::operator<<

; 425  : 		P2PNetwork::SendToAllPlayingUser( kPacket );

  0072e	8d 85 c0 ff fe
	ff		 lea	 eax, DWORD PTR _kPacket$609384[ebp]
  00734	6a 00		 push	 0
  00736	50		 push	 eax
  00737	e8 00 00 00 00	 call	 ?SendToAllPlayingUser@P2PNetwork@@YAXAAVSP2Packet@@PAVioBaseChar@@@Z ; P2PNetwork::SendToAllPlayingUser
  0073c	59		 pop	 ecx
  0073d	59		 pop	 ecx

; 426  : 	}

  0073e	8d 8d c0 ff fe
	ff		 lea	 ecx, DWORD PTR _kPacket$609384[ebp]
$LN100@CheckSylph:
  00744	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00748	e8 00 00 00 00	 call	 ??1SP2Packet@@UAE@XZ	; SP2Packet::~SP2Packet
$LN31@CheckSylph:

; 427  : }

  0074d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00750	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00757	59		 pop	 ecx
  00758	5f		 pop	 edi
  00759	5e		 pop	 esi
  0075a	5b		 pop	 ebx
  0075b	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0075e	33 cd		 xor	 ecx, ebp
  00760	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00765	c9		 leave
  00766	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CheckSylphid@ioBaseChar@@IAEX_N@Z$0:
  00000	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$609329[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1SP2Packet@@UAE@XZ	; SP2Packet::~SP2Packet
__unwindfunclet$?CheckSylphid@ioBaseChar@@IAEX_N@Z$1:
  0000b	8d 8d c0 ff fe
	ff		 lea	 ecx, DWORD PTR _kPacket$609384[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1SP2Packet@@UAE@XZ	; SP2Packet::~SP2Packet
__ehhandler$?CheckSylphid@ioBaseChar@@IAEX_N@Z:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 8a ac ff fe
	ff		 mov	 ecx, DWORD PTR [edx-65620]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CheckSylphid@ioBaseChar@@IAEX_N@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CheckSylphid@ioBaseChar@@IAEX_N@Z ENDP			; ioBaseChar::CheckSylphid
PUBLIC	?SetSylphid@ioBaseChar@@QAEX_N@Z		; ioBaseChar::SetSylphid
; Function compile flags: /Ogsp
;	COMDAT ?SetSylphid@ioBaseChar@@QAEX_N@Z
_TEXT	SEGMENT
_value$613660 = -8					; size = 4
_value$613655 = -8					; size = 4
_value$613645 = -8					; size = 4
_value$613641 = -8					; size = 4
_value$613637 = -8					; size = 4
_value$613628 = -8					; size = 4
_value$613623 = -8					; size = 4
_value$613619 = -8					; size = 4
_value$613615 = -8					; size = 4
_value$613611 = -8					; size = 4
_value$613603 = -8					; size = 4
_value$613599 = -4					; size = 4
_value$613595 = -4					; size = 4
_value$613591 = -4					; size = 4
_value$613587 = -4					; size = 4
_pRachelJump$ = -4					; size = 4
_value$613607 = 8					; size = 4
_bDefense$ = 8						; size = 1
_bUseSylphid$ = 11					; size = 1
?SetSylphid@ioBaseChar@@QAEX_N@Z PROC			; ioBaseChar::SetSylphid, COMDAT
; _this$ = ecx

; 430  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx
  00006	56		 push	 esi
  00007	57		 push	 edi

; 431  : 	ioRachelItem *pRachelItem = ToRachelItem( GetPriorityItem( SPT_ATTACK ) );

  00008	6a 05		 push	 5
  0000a	8b f1		 mov	 esi, ecx
  0000c	e8 00 00 00 00	 call	 ?GetPriorityItem@ioBaseChar@@QBEPAVioAttackableItem@@W4StatePriorityType@@@Z ; ioBaseChar::GetPriorityItem
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?ToRachelItem@@YAPAVioRachelItem@@PAVioItem@@@Z ; ToRachelItem
  00017	8b f8		 mov	 edi, eax

; 432  : 	if( !pRachelItem )		//     ...

  00019	33 db		 xor	 ebx, ebx
  0001b	59		 pop	 ecx
  0001c	3b fb		 cmp	 edi, ebx
  0001e	0f 84 f0 02 00
	00		 je	 $LN1@SetSylphid

; 433  : 		return;
; 434  : 
; 435  : 	const SylphidInfo &rkInfo = pRachelItem->GetSylphidInfo();
; 436  : 	ioRachelJump *pRachelJump = ToRachelJump( pRachelItem->GetCurExtendJump() );

  00024	8b cf		 mov	 ecx, edi
  00026	e8 00 00 00 00	 call	 ?GetCurExtendJump@ioAttackableItem@@QAEPAVioExtendJump@@XZ ; ioAttackableItem::GetCurExtendJump
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?ToRachelJump@@YAPAVioRachelJump@@PAVioExtendJump@@@Z ; ToRachelJump
  00031	59		 pop	 ecx

; 437  : 
; 438  : 	if( bDefense )
; 439  : 	{
; 440  : 		ClearSylphid();

  00032	8b ce		 mov	 ecx, esi
  00034	89 45 fc	 mov	 DWORD PTR _pRachelJump$[ebp], eax
  00037	e8 00 00 00 00	 call	 ?ClearSylphid@ioBaseChar@@QAEXXZ ; ioBaseChar::ClearSylphid
  0003c	38 5d 08	 cmp	 BYTE PTR _bDefense$[ebp], bl
  0003f	74 0f		 je	 SHORT $LN19@SetSylphid

; 441  : 
; 442  : 		if( CheckObjectSylphid( false ) )

  00041	53		 push	 ebx
  00042	8b ce		 mov	 ecx, esi
  00044	e8 00 00 00 00	 call	 ?CheckObjectSylphid@ioBaseChar@@QAE_N_N@Z ; ioBaseChar::CheckObjectSylphid
  00049	84 c0		 test	 al, al

; 443  : 		{
; 444  : 			if( !rkInfo.m_DefaultEffect.IsEmpty() )
; 445  : 			{
; 446  : 				EndEffect( rkInfo.m_DefaultEffect, false );
; 447  : 				AttachEffect( rkInfo.m_DefaultEffect );
; 448  : 			}
; 449  : 		}
; 450  : 		return;

  0004b	e9 9a 02 00 00	 jmp	 $LN61@SetSylphid
$LN19@SetSylphid:

; 451  : 	}
; 452  : 
; 453  : 	ClearSylphid();
; 454  : 
; 455  : 	bool bUseSylphid = false;

  00050	88 5d 0b	 mov	 BYTE PTR _bUseSylphid$[ebp], bl

; 456  : 	DWORD dwCurTime = FRAMEGETTIME();

  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  00059	8b c8		 mov	 ecx, eax
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ

; 457  : 
; 458  : 	switch( m_CharState )

  00061	0f b6 86 10 03
	00 00		 movzx	 eax, BYTE PTR [esi+784]
  00068	83 e8 04	 sub	 eax, 4
  0006b	74 5a		 je	 SHORT $LN13@SetSylphid
  0006d	48		 dec	 eax
  0006e	48		 dec	 eax
  0006f	0f 85 60 02 00
	00		 jne	 $LN59@SetSylphid

; 459  : 	{
; 460  : 	case CS_DASH_ATTACK:
; 461  : 		{
; 462  : 			bUseSylphid = true;
; 463  : 			m_fForceAmt = 0.0f;

  00075	0f 57 c0	 xorps	 xmm0, xmm0
  00078	8d 45 fc	 lea	 eax, DWORD PTR _value$613587[ebp]
  0007b	50		 push	 eax
  0007c	8d 8e 88 0b 00
	00		 lea	 ecx, DWORD PTR [esi+2952]
  00082	c6 45 0b 01	 mov	 BYTE PTR _bUseSylphid$[ebp], 1
  00086	f3 0f 11 45 fc	 movss	 DWORD PTR _value$613587[ebp], xmm0
  0008b	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 464  : 			m_fForceFrictionRate = 1.0f;

  00090	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00098	8d 45 fc	 lea	 eax, DWORD PTR _value$613591[ebp]
  0009b	50		 push	 eax
  0009c	8d 8e b8 0b 00
	00		 lea	 ecx, DWORD PTR [esi+3000]
  000a2	f3 0f 11 45 fc	 movss	 DWORD PTR _value$613591[ebp], xmm0
  000a7	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 465  : 
; 466  : 			SetForcePower( m_vMoveDir, rkInfo.m_fDashAttackForceAmt, rkInfo.m_fDashAttackFriction );

  000ac	f3 0f 10 87 84
	1a 00 00	 movss	 xmm0, DWORD PTR [edi+6788]
  000b4	53		 push	 ebx
  000b5	51		 push	 ecx
  000b6	51		 push	 ecx
  000b7	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000bd	f3 0f 10 87 80
	1a 00 00	 movss	 xmm0, DWORD PTR [edi+6784]

; 467  : 		}
; 468  : 		break;

  000c5	eb 65		 jmp	 SHORT $LN64@SetSylphid
$LN13@SetSylphid:

; 469  : 	case CS_JUMP:
; 470  : 		if( pRachelJump && pRachelJump->IsJumpDashState() )

  000c7	39 5d fc	 cmp	 DWORD PTR _pRachelJump$[ebp], ebx
  000ca	0f 84 05 02 00
	00		 je	 $LN59@SetSylphid
  000d0	8b 4d fc	 mov	 ecx, DWORD PTR _pRachelJump$[ebp]
  000d3	e8 00 00 00 00	 call	 ?IsJumpDashState@ioRachelJump@@QAE_NXZ ; ioRachelJump::IsJumpDashState
  000d8	84 c0		 test	 al, al
  000da	74 68		 je	 SHORT $LN12@SetSylphid

; 471  : 		{
; 472  : 			bUseSylphid = true;
; 473  : 			m_fForceAmt = 0.0f;

  000dc	0f 57 c0	 xorps	 xmm0, xmm0
  000df	8d 45 fc	 lea	 eax, DWORD PTR _value$613595[ebp]
  000e2	50		 push	 eax
  000e3	8d 8e 88 0b 00
	00		 lea	 ecx, DWORD PTR [esi+2952]
  000e9	c6 45 0b 01	 mov	 BYTE PTR _bUseSylphid$[ebp], 1
  000ed	f3 0f 11 45 fc	 movss	 DWORD PTR _value$613595[ebp], xmm0
  000f2	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 474  : 			m_fForceFrictionRate = 1.0f;

  000f7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000ff	8d 45 fc	 lea	 eax, DWORD PTR _value$613599[ebp]
  00102	50		 push	 eax
  00103	8d 8e b8 0b 00
	00		 lea	 ecx, DWORD PTR [esi+3000]
  00109	f3 0f 11 45 fc	 movss	 DWORD PTR _value$613599[ebp], xmm0
  0010e	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 475  : 
; 476  : 			SetForcePower( m_vMoveDir, rkInfo.m_fJumpDashForceAmt, rkInfo.m_fJumpDashFriction );

  00113	f3 0f 10 87 a0
	1a 00 00	 movss	 xmm0, DWORD PTR [edi+6816]
  0011b	53		 push	 ebx
  0011c	51		 push	 ecx
  0011d	51		 push	 ecx
  0011e	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00124	f3 0f 10 87 9c
	1a 00 00	 movss	 xmm0, DWORD PTR [edi+6812]
$LN64@SetSylphid:
  0012c	8d 86 b4 06 00
	00		 lea	 eax, DWORD PTR [esi+1716]
  00132	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00137	50		 push	 eax
  00138	8b ce		 mov	 ecx, esi
  0013a	e8 00 00 00 00	 call	 ?SetForcePower@ioBaseChar@@QAEXABUD3DXVECTOR3@@MM_N@Z ; ioBaseChar::SetForcePower
  0013f	e9 91 01 00 00	 jmp	 $LN59@SetSylphid
$LN12@SetSylphid:

; 477  : 		}
; 478  : 		else if( pRachelJump && m_JumpState == JS_JUMPPING )

  00144	8d 45 f8	 lea	 eax, DWORD PTR _value$613603[ebp]
  00147	50		 push	 eax
  00148	8d 8e 40 0e 00
	00		 lea	 ecx, DWORD PTR [esi+3648]
  0014e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4JumpState@@@@QAEXPAW4JumpState@@@Z ; CEncrypt<enum JumpState>::DecryptValueToPool
  00153	83 7d f8 02	 cmp	 DWORD PTR _value$613603[ebp], 2
  00157	0f 85 78 01 00
	00		 jne	 $LN59@SetSylphid

; 479  : 		{
; 480  : 			if( m_fCurJumpPowerAmt >= m_fGravityAmt )	// up

  0015d	8d 45 08	 lea	 eax, DWORD PTR _value$613607[ebp]
  00160	50		 push	 eax
  00161	8d 8e e8 0b 00
	00		 lea	 ecx, DWORD PTR [esi+3048]
  00167	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@M@@QAEXPAM@Z ; CEncrypt<float>::DecryptValueToPool
  0016c	f3 0f 10 86 90
	0e 00 00	 movss	 xmm0, DWORD PTR [esi+3728]
  00174	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _value$613607[ebp]
  00179	0f 5a c0	 cvtps2pd xmm0, xmm0
  0017c	0f 5a c9	 cvtps2pd xmm1, xmm1

; 481  : 			{
; 482  : 				bUseSylphid = true;
; 483  : 				m_fCurJumpPowerAmt = 0.0f;
; 484  : 				m_fGravityAmt = 0.0f;

  0017f	8d 45 f8	 lea	 eax, DWORD PTR _value$613611[ebp]
  00182	66 0f 2f c1	 comisd	 xmm0, xmm1
  00186	0f 57 c0	 xorps	 xmm0, xmm0
  00189	c6 45 0b 01	 mov	 BYTE PTR _bUseSylphid$[ebp], 1
  0018d	8d 8e e8 0b 00
	00		 lea	 ecx, DWORD PTR [esi+3048]
  00193	50		 push	 eax
  00194	f3 0f 11 86 90
	0e 00 00	 movss	 DWORD PTR [esi+3728], xmm0
  0019c	f3 0f 11 45 f8	 movss	 DWORD PTR _value$613611[ebp], xmm0
  001a1	0f 82 96 00 00
	00		 jb	 $LN9@SetSylphid
  001a7	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 485  : 				m_fForceAmt = 0.0f;

  001ac	0f 57 c0	 xorps	 xmm0, xmm0
  001af	8d 45 f8	 lea	 eax, DWORD PTR _value$613615[ebp]
  001b2	50		 push	 eax
  001b3	8d 8e 88 0b 00
	00		 lea	 ecx, DWORD PTR [esi+2952]
  001b9	f3 0f 11 45 f8	 movss	 DWORD PTR _value$613615[ebp], xmm0
  001be	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 486  : 				m_fForceFrictionRate = 1.0f;

  001c3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001cb	8d 45 f8	 lea	 eax, DWORD PTR _value$613619[ebp]
  001ce	50		 push	 eax
  001cf	8d 8e b8 0b 00
	00		 lea	 ecx, DWORD PTR [esi+3000]
  001d5	f3 0f 11 45 f8	 movss	 DWORD PTR _value$613619[ebp], xmm0
  001da	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 487  : 
; 488  : 				if( pRachelJump->IsCanDoubleJumpAttack() )

  001df	8b 4d fc	 mov	 ecx, DWORD PTR _pRachelJump$[ebp]
  001e2	e8 00 00 00 00	 call	 ?IsCanDoubleJumpAttack@ioRachelJump@@QAE_NXZ ; ioRachelJump::IsCanDoubleJumpAttack
  001e7	84 c0		 test	 al, al

; 489  : 				{
; 490  : 					m_fSylphidJumpSpeedRate = rkInfo.m_fUpJumpSpeedRate2;

  001e9	8d 45 f8	 lea	 eax, DWORD PTR _value$613623[ebp]
  001ec	8d 8e a0 37 00
	00		 lea	 ecx, DWORD PTR [esi+14240]
  001f2	50		 push	 eax
  001f3	74 1c		 je	 SHORT $LN8@SetSylphid
  001f5	f3 0f 10 87 f4
	1a 00 00	 movss	 xmm0, DWORD PTR [edi+6900]
  001fd	f3 0f 11 45 f8	 movss	 DWORD PTR _value$613623[ebp], xmm0
  00202	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 491  : 					SetJumpPower( rkInfo.m_fUpJumpPowerAmt2 );

  00207	f3 0f 10 87 f0
	1a 00 00	 movss	 xmm0, DWORD PTR [edi+6896]

; 492  : 				}
; 493  : 				else

  0020f	eb 1a		 jmp	 SHORT $LN65@SetSylphid
$LN8@SetSylphid:

; 494  : 				{
; 495  : 					m_fSylphidJumpSpeedRate = rkInfo.m_fUpJumpSpeedRate;

  00211	f3 0f 10 87 bc
	1a 00 00	 movss	 xmm0, DWORD PTR [edi+6844]
  00219	f3 0f 11 45 f8	 movss	 DWORD PTR _value$613628[ebp], xmm0
  0021e	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 496  : 					SetJumpPower( rkInfo.m_fUpJumpPowerAmt );

  00223	f3 0f 10 87 b8
	1a 00 00	 movss	 xmm0, DWORD PTR [edi+6840]
$LN65@SetSylphid:
  0022b	51		 push	 ecx
  0022c	8b ce		 mov	 ecx, esi
  0022e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00233	e8 00 00 00 00	 call	 ?SetJumpPower@ioBaseChar@@QAEXM@Z ; ioBaseChar::SetJumpPower

; 497  : 				}
; 498  : 			}
; 499  : 			else	// down

  00238	e9 98 00 00 00	 jmp	 $LN59@SetSylphid
$LN9@SetSylphid:

; 500  : 			{
; 501  : 				bUseSylphid = true;
; 502  : 				m_fCurJumpPowerAmt = 0.0f;
; 503  : 				m_fGravityAmt = 0.0f;

  0023d	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 504  : 				m_fForceAmt = 0.0f;

  00242	0f 57 c0	 xorps	 xmm0, xmm0
  00245	8d 45 f8	 lea	 eax, DWORD PTR _value$613637[ebp]
  00248	50		 push	 eax
  00249	8d 8e 88 0b 00
	00		 lea	 ecx, DWORD PTR [esi+2952]
  0024f	f3 0f 11 45 f8	 movss	 DWORD PTR _value$613637[ebp], xmm0
  00254	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 505  : 				m_fForceFrictionRate = 1.0f;

  00259	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00261	8d 45 f8	 lea	 eax, DWORD PTR _value$613641[ebp]
  00264	50		 push	 eax
  00265	8d 8e b8 0b 00
	00		 lea	 ecx, DWORD PTR [esi+3000]
  0026b	f3 0f 11 45 f8	 movss	 DWORD PTR _value$613641[ebp], xmm0
  00270	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 506  : 
; 507  : 				if( pRachelJump->IsCanDoubleJumpAttack() )

  00275	8b 4d fc	 mov	 ecx, DWORD PTR _pRachelJump$[ebp]
  00278	e8 00 00 00 00	 call	 ?IsCanDoubleJumpAttack@ioRachelJump@@QAE_NXZ ; ioRachelJump::IsCanDoubleJumpAttack
  0027d	84 c0		 test	 al, al

; 508  : 				{
; 509  : 					m_fSylphidJumpSpeedRate = rkInfo.m_fDownJumpSpeedRate2;

  0027f	8d 45 f8	 lea	 eax, DWORD PTR _value$613645[ebp]
  00282	8d 8e a0 37 00
	00		 lea	 ecx, DWORD PTR [esi+14240]
  00288	50		 push	 eax
  00289	74 1c		 je	 SHORT $LN5@SetSylphid
  0028b	f3 0f 10 87 10
	1b 00 00	 movss	 xmm0, DWORD PTR [edi+6928]
  00293	f3 0f 11 45 f8	 movss	 DWORD PTR _value$613645[ebp], xmm0
  00298	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 510  : 					m_fSylphidJumpGravityRate = rkInfo.m_fDownJumpGrabityRate2;

  0029d	f3 0f 10 87 0c
	1b 00 00	 movss	 xmm0, DWORD PTR [edi+6924]

; 511  : 				}
; 512  : 				else

  002a5	eb 1a		 jmp	 SHORT $LN62@SetSylphid
$LN5@SetSylphid:

; 513  : 				{
; 514  : 					m_fSylphidJumpSpeedRate = rkInfo.m_fDownJumpSpeedRate;

  002a7	f3 0f 10 87 d8
	1a 00 00	 movss	 xmm0, DWORD PTR [edi+6872]
  002af	f3 0f 11 45 f8	 movss	 DWORD PTR _value$613655[ebp], xmm0
  002b4	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool

; 515  : 					m_fSylphidJumpGravityRate = rkInfo.m_fDownJumpGrabityRate;

  002b9	f3 0f 10 87 d4
	1a 00 00	 movss	 xmm0, DWORD PTR [edi+6868]
$LN62@SetSylphid:
  002c1	8d 45 f8	 lea	 eax, DWORD PTR _value$613660[ebp]
  002c4	50		 push	 eax
  002c5	8d 8e d0 37 00
	00		 lea	 ecx, DWORD PTR [esi+14288]
  002cb	f3 0f 11 45 f8	 movss	 DWORD PTR _value$613660[ebp], xmm0
  002d0	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@M@@AAEXPBD@Z ; CEncrypt<float>::EncryptValueToPool
$LN59@SetSylphid:

; 516  : 				}
; 517  : 			}
; 518  : 		}
; 519  : 		break;
; 520  : 	}
; 521  : 
; 522  : 	if( CheckObjectSylphid( false ) )

  002d5	33 db		 xor	 ebx, ebx
  002d7	53		 push	 ebx
  002d8	8b ce		 mov	 ecx, esi
  002da	e8 00 00 00 00	 call	 ?CheckObjectSylphid@ioBaseChar@@QAE_N_N@Z ; ioBaseChar::CheckObjectSylphid
  002df	84 c0		 test	 al, al
  002e1	74 04		 je	 SHORT $LN3@SetSylphid

; 523  : 		bUseSylphid = true;

  002e3	c6 45 0b 01	 mov	 BYTE PTR _bUseSylphid$[ebp], 1
$LN3@SetSylphid:

; 524  : 
; 525  : 	if( bUseSylphid )

  002e7	38 5d 0b	 cmp	 BYTE PTR _bUseSylphid$[ebp], bl
$LN61@SetSylphid:
  002ea	74 28		 je	 SHORT $LN1@SetSylphid

; 526  : 	{
; 527  : 		if( !rkInfo.m_DefaultEffect.IsEmpty() )

  002ec	81 c7 70 1a 00
	00		 add	 edi, 6768		; 00001a70H
  002f2	8b cf		 mov	 ecx, edi
  002f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  002fa	84 c0		 test	 al, al
  002fc	75 16		 jne	 SHORT $LN1@SetSylphid

; 528  : 		{
; 529  : 			EndEffect( rkInfo.m_DefaultEffect, false );

  002fe	6a 01		 push	 1
  00300	53		 push	 ebx
  00301	57		 push	 edi
  00302	8b ce		 mov	 ecx, esi
  00304	e8 00 00 00 00	 call	 ?EndEffect@ioBaseChar@@QAEXABVioHashString@@_N1@Z ; ioBaseChar::EndEffect

; 530  : 			AttachEffect( rkInfo.m_DefaultEffect );

  00309	6a 01		 push	 1
  0030b	53		 push	 ebx
  0030c	57		 push	 edi
  0030d	8b ce		 mov	 ecx, esi
  0030f	e8 00 00 00 00	 call	 ?AttachEffect@ioBaseChar@@QAEPAVioEffect@@ABVioHashString@@PAVioEntityEvent@@_N@Z ; ioBaseChar::AttachEffect
$LN1@SetSylphid:
  00314	5f		 pop	 edi
  00315	5e		 pop	 esi
  00316	5b		 pop	 ebx

; 531  : 		}
; 532  : 	}
; 533  : }

  00317	c9		 leave
  00318	c2 04 00	 ret	 4
?SetSylphid@ioBaseChar@@QAEX_N@Z ENDP			; ioBaseChar::SetSylphid
_TEXT	ENDS
END
