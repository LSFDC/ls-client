; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\Lost Saga For Developer\Youtube\Tutorial\Source\src\LSClient\ioRaptorDummy.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_EEM_DS@?$deque@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@2HB ; std::deque<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_EEM_DS
PUBLIC	?_EEM_DS@?$deque@MV?$allocator@M@std@@@std@@2HB	; std::deque<float,std::allocator<float> >::_EEM_DS
PUBLIC	?_VBITS@?$vector@_NV?$allocator@_N@std@@@std@@2HB ; std::vector<bool,std::allocator<bool> >::_VBITS
;	COMDAT ?_VBITS@?$vector@_NV?$allocator@_N@std@@@std@@2HB
CONST	SEGMENT
?_VBITS@?$vector@_NV?$allocator@_N@std@@@std@@2HB DD 020H ; std::vector<bool,std::allocator<bool> >::_VBITS
CONST	ENDS
;	COMDAT ?_EEM_DS@?$deque@MV?$allocator@M@std@@@std@@2HB
CONST	SEGMENT
?_EEM_DS@?$deque@MV?$allocator@M@std@@@std@@2HB DD 04H	; std::deque<float,std::allocator<float> >::_EEM_DS
CONST	ENDS
;	COMDAT ?_EEM_DS@?$deque@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@2HB
CONST	SEGMENT
?_EEM_DS@?$deque@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@2HB DD 01H ; std::deque<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_EEM_DS
CONST	ENDS
PUBLIC	?return1@@YAIXZ					; return1
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stdafx.h
;	COMDAT ?return1@@YAIXZ
_TEXT	SEGMENT
?return1@@YAIXZ PROC					; return1, COMDAT

; 17   : 	__forceinline unsigned int return1() { __asm mov eax, 1 };

  00000	b8 01 00 00 00	 mov	 eax, 1
  00005	c3		 ret	 0
?return1@@YAIXZ ENDP					; return1
_TEXT	ENDS
PUBLIC	?return5@@YAIXZ					; return5
; Function compile flags: /Ogsp
;	COMDAT ?return5@@YAIXZ
_TEXT	SEGMENT
?return5@@YAIXZ PROC					; return5, COMDAT

; 18   : 	__forceinline unsigned int return5() { __asm mov eax, 5 };

  00000	b8 05 00 00 00	 mov	 eax, 5
  00005	c3		 ret	 0
?return5@@YAIXZ ENDP					; return5
_TEXT	ENDS
PUBLIC	?return10@@YAIXZ				; return10
; Function compile flags: /Ogsp
;	COMDAT ?return10@@YAIXZ
_TEXT	SEGMENT
?return10@@YAIXZ PROC					; return10, COMDAT

; 21   : 	__forceinline unsigned int return10() { __asm mov eax, 10 };

  00000	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  00005	c3		 ret	 0
?return10@@YAIXZ ENDP					; return10
_TEXT	ENDS
PUBLIC	?return100@@YAIXZ				; return100
; Function compile flags: /Ogsp
;	COMDAT ?return100@@YAIXZ
_TEXT	SEGMENT
?return100@@YAIXZ PROC					; return100, COMDAT

; 25   : 	__forceinline unsigned int return100() { __asm mov eax, 100 };

  00000	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  00005	c3		 ret	 0
?return100@@YAIXZ ENDP					; return100
_TEXT	ENDS
PUBLIC	?GetState@ioBaseChar@@QBE?AW4CharState@@XZ	; ioBaseChar::GetState
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasechar.h
;	COMDAT ?GetState@ioBaseChar@@QBE?AW4CharState@@XZ
_TEXT	SEGMENT
?GetState@ioBaseChar@@QBE?AW4CharState@@XZ PROC		; ioBaseChar::GetState, COMDAT
; _this$ = ecx

; 2156 : 	inline CharState GetState() const { return m_CharState; }	

  00000	8a 81 10 03 00
	00		 mov	 al, BYTE PTR [ecx+784]
  00006	c3		 ret	 0
?GetState@ioBaseChar@@QBE?AW4CharState@@XZ ENDP		; ioBaseChar::GetState
_TEXT	ENDS
PUBLIC	?GetTargetRot@ioBaseChar@@QBEABUD3DXQUATERNION@@XZ ; ioBaseChar::GetTargetRot
; Function compile flags: /Ogsp
;	COMDAT ?GetTargetRot@ioBaseChar@@QBEABUD3DXQUATERNION@@XZ
_TEXT	SEGMENT
?GetTargetRot@ioBaseChar@@QBEABUD3DXQUATERNION@@XZ PROC	; ioBaseChar::GetTargetRot, COMDAT
; _this$ = ecx

; 2599 : 	inline const D3DXQUATERNION& GetTargetRot() const { return m_qtTargetRot; }

  00000	8d 81 a4 06 00
	00		 lea	 eax, DWORD PTR [ecx+1700]
  00006	c3		 ret	 0
?GetTargetRot@ioBaseChar@@QBEABUD3DXQUATERNION@@XZ ENDP	; ioBaseChar::GetTargetRot
_TEXT	ENDS
PUBLIC	??_R0?AVioWeapon@@@8				; ioWeapon `RTTI Type Descriptor'
PUBLIC	??_R0?AVioZoneEffectWeapon@@@8			; ioZoneEffectWeapon `RTTI Type Descriptor'
PUBLIC	?ToZoneEffectWeapon@@YAPAVioZoneEffectWeapon@@PAVioWeapon@@@Z ; ToZoneEffectWeapon
EXTRN	___RTDynamicCast:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT ??_R0?AVioWeapon@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iozoneeffectweapon.h
_DATA	SEGMENT
??_R0?AVioWeapon@@@8 DD FLAT:??_7type_info@@6B@		; ioWeapon `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioWeapon@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVioZoneEffectWeapon@@@8
_DATA	SEGMENT
??_R0?AVioZoneEffectWeapon@@@8 DD FLAT:??_7type_info@@6B@ ; ioZoneEffectWeapon `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioZoneEffectWeapon@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToZoneEffectWeapon@@YAPAVioZoneEffectWeapon@@PAVioWeapon@@@Z
_TEXT	SEGMENT
_pWeapon$ = 8						; size = 4
?ToZoneEffectWeapon@@YAPAVioZoneEffectWeapon@@PAVioWeapon@@@Z PROC ; ToZoneEffectWeapon, COMDAT

; 217  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 218  : 	if( !pWeapon || pWeapon->GetType() != ioWeapon::WT_ZONE_EFFECT )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pWeapon$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 28		 je	 SHORT $LN1@ToZoneEffe
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 90 10 01 00
	00		 call	 DWORD PTR [eax+272]
  00015	83 f8 08	 cmp	 eax, 8
  00018	75 19		 jne	 SHORT $LN1@ToZoneEffe

; 220  : 
; 221  : 	return dynamic_cast< ioZoneEffectWeapon* >( pWeapon );

  0001a	6a 00		 push	 0
  0001c	68 00 00 00 00	 push	 OFFSET ??_R0?AVioZoneEffectWeapon@@@8
  00021	68 00 00 00 00	 push	 OFFSET ??_R0?AVioWeapon@@@8
  00026	6a 00		 push	 0
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002e	83 c4 14	 add	 esp, 20			; 00000014H
  00031	eb 02		 jmp	 SHORT $LN3@ToZoneEffe
$LN1@ToZoneEffe:

; 219  : 		return NULL;

  00033	33 c0		 xor	 eax, eax
$LN3@ToZoneEffe:
  00035	5e		 pop	 esi

; 222  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?ToZoneEffectWeapon@@YAPAVioZoneEffectWeapon@@PAVioWeapon@@@Z ENDP ; ToZoneEffectWeapon
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 49   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
EXTRN	__fltused:DWORD
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx9math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 303  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 304  :     x = fx;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00008	8b c1		 mov	 eax, ecx
  0000a	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 305  :     y = fy;

  0000e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00013	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 306  :     z = fz;

  00018	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0001d	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 307  : }

  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
PUBLIC	??_7ioRaptorDummy@@6BioWorldEventReceiver@@@	; ioRaptorDummy::`vftable'
PUBLIC	??_7ioRaptorDummy@@6BioPlayEntity@@@		; ioRaptorDummy::`vftable'
PUBLIC	??0ioRaptorDummy@@QAE@PAVioEntityGroup@@PAVioPlayMode@@@Z ; ioRaptorDummy::ioRaptorDummy
PUBLIC	??_R4ioRaptorDummy@@6BioPlayEntity@@@		; ioRaptorDummy::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVioRaptorDummy@@@8			; ioRaptorDummy `RTTI Type Descriptor'
PUBLIC	??_R3ioRaptorDummy@@8				; ioRaptorDummy::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioRaptorDummy@@8				; ioRaptorDummy::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ioRaptorDummy@@8			; ioRaptorDummy::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ioDummyChar@@8			; ioDummyChar::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVioDummyChar@@@8				; ioDummyChar `RTTI Type Descriptor'
PUBLIC	??_R3ioDummyChar@@8				; ioDummyChar::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioDummyChar@@8				; ioDummyChar::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ioPlayEntity@@8			; ioPlayEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVioPlayEntity@@@8			; ioPlayEntity `RTTI Type Descriptor'
PUBLIC	??_R3ioPlayEntity@@8				; ioPlayEntity::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioPlayEntity@@8				; ioPlayEntity::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ioGameEntity@@8			; ioGameEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVioGameEntity@@@8			; ioGameEntity `RTTI Type Descriptor'
PUBLIC	??_R3ioGameEntity@@8				; ioGameEntity::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioGameEntity@@8				; ioGameEntity::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ioEntityEvent@@8			; ioEntityEvent::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVioEntityEvent@@@8			; ioEntityEvent `RTTI Type Descriptor'
PUBLIC	??_R3ioEntityEvent@@8				; ioEntityEvent::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioEntityEvent@@8				; ioEntityEvent::`RTTI Base Class Array'
PUBLIC	??_R1BMI@?0A@EA@ioWorldEventReceiver@@8		; ioWorldEventReceiver::`RTTI Base Class Descriptor at (456,-1,0,64)'
PUBLIC	??_R0?AVioWorldEventReceiver@@@8		; ioWorldEventReceiver `RTTI Type Descriptor'
PUBLIC	??_R3ioWorldEventReceiver@@8			; ioWorldEventReceiver::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioWorldEventReceiver@@8			; ioWorldEventReceiver::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ioWorldEventReceiver@@8		; ioWorldEventReceiver::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?LoadProperty@ioRaptorDummy@@UAEXAAVioINILoader@@@Z ; ioRaptorDummy::LoadProperty
PUBLIC	?SetTeam@ioPlayEntity@@UAEXW4TeamType@@@Z	; ioPlayEntity::SetTeam
PUBLIC	?ProcessState@ioRaptorDummy@@MAEXMK@Z		; ioRaptorDummy::ProcessState
PUBLIC	?ProcessPos@ioRaptorDummy@@MAEXM@Z		; ioRaptorDummy::ProcessPos
PUBLIC	?ProcessDelayState@ioRaptorDummy@@MAEXM@Z	; ioRaptorDummy::ProcessDelayState
PUBLIC	?ProcessMoveState@ioRaptorDummy@@MAEXM@Z	; ioRaptorDummy::ProcessMoveState
PUBLIC	?ProcessDashState@ioRaptorDummy@@MAEXM@Z	; ioRaptorDummy::ProcessDashState
PUBLIC	?ProcessAttackState@ioRaptorDummy@@MAEXMK@Z	; ioRaptorDummy::ProcessAttackState
PUBLIC	?SetMoveState@ioRaptorDummy@@UAEXXZ		; ioRaptorDummy::SetMoveState
PUBLIC	?SetDashState@ioRaptorDummy@@UAEXXZ		; ioRaptorDummy::SetDashState
PUBLIC	?SetAttackState@ioRaptorDummy@@UAEXXZ		; ioRaptorDummy::SetAttackState
PUBLIC	?IsDummyCharMidSync@ioDummyChar@@UAE_NXZ	; ioDummyChar::IsDummyCharMidSync
PUBLIC	??_R4ioRaptorDummy@@6BioWorldEventReceiver@@@	; ioRaptorDummy::`RTTI Complete Object Locator'
PUBLIC	??_EioRaptorDummy@@WBMI@AEPAXI@Z		; [thunk]:ioRaptorDummy::`vector deleting destructor'
EXTRN	??0ioDummyChar@@QAE@PAVioEntityGroup@@PAVioPlayMode@@@Z:PROC ; ioDummyChar::ioDummyChar
EXTRN	?AddEntityEvent@ioDummyChar@@UAEXPAVioEntity@@@Z:PROC ; ioDummyChar::AddEntityEvent
EXTRN	??_EioRaptorDummy@@UAEPAXI@Z:PROC		; ioRaptorDummy::`vector deleting destructor'
EXTRN	?Update@ioDummyChar@@UAEXMKK@Z:PROC		; ioDummyChar::Update
EXTRN	?UpdateAfter@ioDummyChar@@UAEXM@Z:PROC		; ioDummyChar::UpdateAfter
EXTRN	?GetTypeID@ioPlayEntity@@UBEHXZ:PROC		; ioPlayEntity::GetTypeID
EXTRN	?IsNeedCheckMapCollision@ioDummyChar@@UBE_NXZ:PROC ; ioDummyChar::IsNeedCheckMapCollision
EXTRN	?IsMountAvailable@ioDummyChar@@UBE_NXZ:PROC	; ioDummyChar::IsMountAvailable
EXTRN	?IsMountingAvailable@ioDummyChar@@UBE_NXZ:PROC	; ioDummyChar::IsMountingAvailable
EXTRN	?IsNowMountEnable@ioDummyChar@@UBE_NXZ:PROC	; ioDummyChar::IsNowMountEnable
EXTRN	?IsAllWeaponDefence@ioGameEntity@@UBE_NXZ:PROC	; ioGameEntity::IsAllWeaponDefence
EXTRN	?HasEntity@ioGameEntity@@UAE_NABVioHashString@@@Z:PROC ; ioGameEntity::HasEntity
EXTRN	?AddEntity@ioGameEntity@@UAEPAVioEntity@@ABVioHashString@@@Z:PROC ; ioGameEntity::AddEntity
EXTRN	?DestroyEntity@ioGameEntity@@UAE_NABVioHashString@@@Z:PROC ; ioGameEntity::DestroyEntity
EXTRN	?GetEntity@ioGameEntity@@UAEPAVioEntity@@ABVioHashString@@@Z:PROC ; ioGameEntity::GetEntity
EXTRN	?UpdateBound@ioGameEntity@@MBEXXZ:PROC		; ioGameEntity::UpdateBound
EXTRN	?UpdateBottomHeight@ioDummyChar@@MBEXXZ:PROC	; ioDummyChar::UpdateBottomHeight
EXTRN	?NeedUpdateBottomHeight@ioDummyChar@@UAEXXZ:PROC ; ioDummyChar::NeedUpdateBottomHeight
EXTRN	?SetWorldPosition@ioGameEntity@@UAEXABUD3DXVECTOR3@@@Z:PROC ; ioGameEntity::SetWorldPosition
EXTRN	?SetWorldOrientation@ioGameEntity@@UAEXABUD3DXQUATERNION@@@Z:PROC ; ioGameEntity::SetWorldOrientation
EXTRN	?SetWorldScale@ioGameEntity@@UAEXABUD3DXVECTOR3@@@Z:PROC ; ioGameEntity::SetWorldScale
EXTRN	?Translate@ioDummyChar@@UAEXABUD3DXVECTOR3@@@Z:PROC ; ioDummyChar::Translate
EXTRN	?TranslateByConveyer@ioDummyChar@@UAEXABUD3DXVECTOR3@@@Z:PROC ; ioDummyChar::TranslateByConveyer
EXTRN	?TranslateByWorldEntity@ioDummyChar@@UAEXABUD3DXVECTOR3@@@Z:PROC ; ioDummyChar::TranslateByWorldEntity
EXTRN	?MapCollisionPushingTranslate@ioDummyChar@@UAEXABUD3DXVECTOR3@@@Z:PROC ; ioDummyChar::MapCollisionPushingTranslate
EXTRN	?DontMoveCollisionPushingTranslate@ioGameEntity@@UAEXPAV1@ABUD3DXVECTOR3@@@Z:PROC ; ioGameEntity::DontMoveCollisionPushingTranslate
EXTRN	?Rotate@ioGameEntity@@UAEXABUD3DXVECTOR3@@MW4TransformSpace@ioNode@@@Z:PROC ; ioGameEntity::Rotate
EXTRN	?Scale@ioGameEntity@@UAEXMMM@Z:PROC		; ioGameEntity::Scale
EXTRN	?Scale@ioGameEntity@@UAEXABUD3DXVECTOR3@@@Z:PROC ; ioGameEntity::Scale
EXTRN	?GetWorldPosition@ioGameEntity@@UBEABUD3DXVECTOR3@@XZ:PROC ; ioGameEntity::GetWorldPosition
EXTRN	?GetWorldOrientation@ioGameEntity@@UBEABUD3DXQUATERNION@@XZ:PROC ; ioGameEntity::GetWorldOrientation
EXTRN	?GetWorldScale@ioGameEntity@@UBEABUD3DXVECTOR3@@XZ:PROC ; ioGameEntity::GetWorldScale
EXTRN	?ApplyWeapon@ioDummyChar@@UAE?AW4ApplyWeaponExp@@PAVioWeapon@@@Z:PROC ; ioDummyChar::ApplyWeapon
EXTRN	?IsCollisionAvailableWeapon@ioDummyChar@@UAE_NPAVioWeapon@@@Z:PROC ; ioDummyChar::IsCollisionAvailableWeapon
EXTRN	?IsCollisionAvailableRange@ioPlayEntity@@UAE_NPAVioWeapon@@@Z:PROC ; ioPlayEntity::IsCollisionAvailableRange
EXTRN	?IsEntityCollisionSkipState@ioDummyChar@@UBE_NPAVioGameEntity@@@Z:PROC ; ioDummyChar::IsEntityCollisionSkipState
EXTRN	?IsCharCollisionSkipState@ioDummyChar@@UBE_NW4TeamType@@H@Z:PROC ; ioDummyChar::IsCharCollisionSkipState
EXTRN	?IsWoundedCollision@ioPlayEntity@@UBE_NABVioOrientBox@@PAUD3DXVECTOR3@@@Z:PROC ; ioPlayEntity::IsWoundedCollision
EXTRN	?GetAttackCollisionBox@ioDummyChar@@UAE?AVioOrientBox@@W4AniCollisionType@@_N@Z:PROC ; ioDummyChar::GetAttackCollisionBox
EXTRN	?CheckSphereDistance@ioPlayEntity@@UBE_NABUD3DXVECTOR3@@MAAM@Z:PROC ; ioPlayEntity::CheckSphereDistance
EXTRN	?CheckSpherePoint@ioPlayEntity@@UBE_NABUD3DXVECTOR3@@MAAU2@@Z:PROC ; ioPlayEntity::CheckSpherePoint
EXTRN	?CheckCylinderPoint@ioPlayEntity@@UBE_NABVioCylinder@@ABUD3DXVECTOR3@@AAU3@@Z:PROC ; ioPlayEntity::CheckCylinderPoint
EXTRN	?GetSubType@ioDummyChar@@UBE?AW4PlaySubType@ioPlayEntity@@XZ:PROC ; ioDummyChar::GetSubType
EXTRN	?GetArmorType@ioDummyChar@@UBE?AW4ArmorType@@XZ:PROC ; ioDummyChar::GetArmorType
EXTRN	?DontMoveEntityLevel@ioDummyChar@@UBEHXZ:PROC	; ioDummyChar::DontMoveEntityLevel
EXTRN	?NotifyDontMoveCollisionPushingSkip@ioPlayEntity@@UAEXPAVioGameEntity@@@Z:PROC ; ioPlayEntity::NotifyDontMoveCollisionPushingSkip
EXTRN	?GetWorldEventReceiver@ioDummyChar@@UAEPAVioWorldEventReceiver@@XZ:PROC ; ioDummyChar::GetWorldEventReceiver
EXTRN	?Revival@ioPlayEntity@@UAEXXZ:PROC		; ioPlayEntity::Revival
EXTRN	?UpdateGauge@ioDummyChar@@UAEXXZ:PROC		; ioDummyChar::UpdateGauge
EXTRN	?RenderGauge@ioDummyChar@@UAEXXZ:PROC		; ioDummyChar::RenderGauge
EXTRN	?FillMaxHP@ioPlayEntity@@UAEXXZ:PROC		; ioPlayEntity::FillMaxHP
EXTRN	?ProcessRecovery@ioPlayEntity@@MAEXXZ:PROC	; ioPlayEntity::ProcessRecovery
EXTRN	?AddHeadDamageInfo@ioPlayEntity@@UAEXH_N@Z:PROC	; ioPlayEntity::AddHeadDamageInfo
EXTRN	?RenderHeadInfoList@ioPlayEntity@@UAEXHH@Z:PROC	; ioPlayEntity::RenderHeadInfoList
EXTRN	?UpdateHeadInfoList@ioPlayEntity@@MAEXK@Z:PROC	; ioPlayEntity::UpdateHeadInfoList
EXTRN	?InitDummyCharInfo@ioDummyChar@@UAEXHKABUD3DXVECTOR3@@0M_N@Z:PROC ; ioDummyChar::InitDummyCharInfo
EXTRN	?TestMapCollision@ioDummyChar@@UAE_NPAVioOpcodeShape@@PAVioPlayStage@@PBUD3DXMATRIX@@@Z:PROC ; ioDummyChar::TestMapCollision
EXTRN	?CheckEntityCollision@ioDummyChar@@UAEXPAVioPlayEntity@@@Z:PROC ; ioDummyChar::CheckEntityCollision
EXTRN	?GetDummyGrassType@ioDummyChar@@UAEHXZ:PROC	; ioDummyChar::GetDummyGrassType
EXTRN	?IsActivateWeapon@ioDummyChar@@UAE_NXZ:PROC	; ioDummyChar::IsActivateWeapon
EXTRN	?IsDummyVsDummyCollisionSkipState@ioDummyChar@@UAE_NPBV1@@Z:PROC ; ioDummyChar::IsDummyVsDummyCollisionSkipState
EXTRN	?ApplyDummyCharSync@ioDummyChar@@UAEXPAVioPlayStage@@AAVSP2Packet@@@Z:PROC ; ioDummyChar::ApplyDummyCharSync
EXTRN	?SetDelayState@ioDummyChar@@UAEX_N@Z:PROC	; ioDummyChar::SetDelayState
EXTRN	?SetDieState@ioDummyChar@@UAEX_N0@Z:PROC	; ioDummyChar::SetDieState
EXTRN	?DropZoneCheck@ioDummyChar@@MAEXXZ:PROC		; ioDummyChar::DropZoneCheck
EXTRN	?SendAttackInfoToSkill@ioDummyChar@@MAEXXZ:PROC	; ioDummyChar::SendAttackInfoToSkill
EXTRN	?CheckCollisionWeapon@ioDummyChar@@UAEXPAVioBaseChar@@@Z:PROC ; ioDummyChar::CheckCollisionWeapon
EXTRN	?TranslateMountEntity@ioDummyChar@@MAEXABUD3DXVECTOR3@@@Z:PROC ; ioDummyChar::TranslateMountEntity
EXTRN	?ClearMountEntity@ioDummyChar@@MAEXXZ:PROC	; ioDummyChar::ClearMountEntity
EXTRN	?UpdateMountedEntityList@ioDummyChar@@MAEXXZ:PROC ; ioDummyChar::UpdateMountedEntityList
EXTRN	?UpdateMountedWeaponList@ioDummyChar@@MAEXXZ:PROC ; ioDummyChar::UpdateMountedWeaponList
EXTRN	?SetWorldPositionMountEntity@ioDummyChar@@MAEXM@Z:PROC ; ioDummyChar::SetWorldPositionMountEntity
EXTRN	?DummyDieClearMountEntity@ioDummyChar@@MAEXXZ:PROC ; ioDummyChar::DummyDieClearMountEntity
EXTRN	?FillDummyCharMidSync@ioDummyChar@@UAEXPAVioBaseChar@@AAVSP2Packet@@@Z:PROC ; ioDummyChar::FillDummyCharMidSync
EXTRN	?ApplyDummyCharMidSync@ioDummyChar@@UAEXPAVioBaseChar@@AAVSP2Packet@@@Z:PROC ; ioDummyChar::ApplyDummyCharMidSync
EXTRN	?GetSkillMaxActiveCnt@ioDummyChar@@UAEHXZ:PROC	; ioDummyChar::GetSkillMaxActiveCnt
EXTRN	?GetSkillCurActiveCnt@ioDummyChar@@UAEHXZ:PROC	; ioDummyChar::GetSkillCurActiveCnt
EXTRN	?OnTelepotation@ioDummyChar@@UAEXABUD3DXVECTOR3@@@Z:PROC ; ioDummyChar::OnTelepotation
EXTRN	?OnFireZoneDamage@ioDummyChar@@UAEXMABVioHashString@@@Z:PROC ; ioDummyChar::OnFireZoneDamage
EXTRN	?OnPoisonZoneDamage@ioDummyChar@@UAEXXZ:PROC	; ioDummyChar::OnPoisonZoneDamage
;	COMDAT ??_R4ioRaptorDummy@@6BioWorldEventReceiver@@@
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioraptordummy.cpp
rdata$r	SEGMENT
??_R4ioRaptorDummy@@6BioWorldEventReceiver@@@ DD 00H	; ioRaptorDummy::`RTTI Complete Object Locator'
	DD	01c8H
	DD	00H
	DD	FLAT:??_R0?AVioRaptorDummy@@@8
	DD	FLAT:??_R3ioRaptorDummy@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ioWorldEventReceiver@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioWorldEventReceiver@@8 DD FLAT:??_R0?AVioWorldEventReceiver@@@8 ; ioWorldEventReceiver::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioWorldEventReceiver@@8
rdata$r	ENDS
;	COMDAT ??_R2ioWorldEventReceiver@@8
rdata$r	SEGMENT
??_R2ioWorldEventReceiver@@8 DD FLAT:??_R1A@?0A@EA@ioWorldEventReceiver@@8 ; ioWorldEventReceiver::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ioWorldEventReceiver@@8
rdata$r	SEGMENT
??_R3ioWorldEventReceiver@@8 DD 00H			; ioWorldEventReceiver::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ioWorldEventReceiver@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioWorldEventReceiver@@@8
_DATA	SEGMENT
??_R0?AVioWorldEventReceiver@@@8 DD FLAT:??_7type_info@@6B@ ; ioWorldEventReceiver `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioWorldEventReceiver@@', 00H
_DATA	ENDS
;	COMDAT ??_R1BMI@?0A@EA@ioWorldEventReceiver@@8
rdata$r	SEGMENT
??_R1BMI@?0A@EA@ioWorldEventReceiver@@8 DD FLAT:??_R0?AVioWorldEventReceiver@@@8 ; ioWorldEventReceiver::`RTTI Base Class Descriptor at (456,-1,0,64)'
	DD	00H
	DD	01c8H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioWorldEventReceiver@@8
rdata$r	ENDS
;	COMDAT ??_R2ioEntityEvent@@8
rdata$r	SEGMENT
??_R2ioEntityEvent@@8 DD FLAT:??_R1A@?0A@EA@ioEntityEvent@@8 ; ioEntityEvent::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ioEntityEvent@@8
rdata$r	SEGMENT
??_R3ioEntityEvent@@8 DD 00H				; ioEntityEvent::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ioEntityEvent@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioEntityEvent@@@8
_DATA	SEGMENT
??_R0?AVioEntityEvent@@@8 DD FLAT:??_7type_info@@6B@	; ioEntityEvent `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioEntityEvent@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@ioEntityEvent@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioEntityEvent@@8 DD FLAT:??_R0?AVioEntityEvent@@@8 ; ioEntityEvent::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioEntityEvent@@8
rdata$r	ENDS
;	COMDAT ??_R2ioGameEntity@@8
rdata$r	SEGMENT
??_R2ioGameEntity@@8 DD FLAT:??_R1A@?0A@EA@ioGameEntity@@8 ; ioGameEntity::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ioEntityEvent@@8
rdata$r	ENDS
;	COMDAT ??_R3ioGameEntity@@8
rdata$r	SEGMENT
??_R3ioGameEntity@@8 DD 00H				; ioGameEntity::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ioGameEntity@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioGameEntity@@@8
_DATA	SEGMENT
??_R0?AVioGameEntity@@@8 DD FLAT:??_7type_info@@6B@	; ioGameEntity `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioGameEntity@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@ioGameEntity@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioGameEntity@@8 DD FLAT:??_R0?AVioGameEntity@@@8 ; ioGameEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioGameEntity@@8
rdata$r	ENDS
;	COMDAT ??_R2ioPlayEntity@@8
rdata$r	SEGMENT
??_R2ioPlayEntity@@8 DD FLAT:??_R1A@?0A@EA@ioPlayEntity@@8 ; ioPlayEntity::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ioGameEntity@@8
	DD	FLAT:??_R1A@?0A@EA@ioEntityEvent@@8
rdata$r	ENDS
;	COMDAT ??_R3ioPlayEntity@@8
rdata$r	SEGMENT
??_R3ioPlayEntity@@8 DD 00H				; ioPlayEntity::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2ioPlayEntity@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioPlayEntity@@@8
_DATA	SEGMENT
??_R0?AVioPlayEntity@@@8 DD FLAT:??_7type_info@@6B@	; ioPlayEntity `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioPlayEntity@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@ioPlayEntity@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioPlayEntity@@8 DD FLAT:??_R0?AVioPlayEntity@@@8 ; ioPlayEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioPlayEntity@@8
rdata$r	ENDS
;	COMDAT ??_R2ioDummyChar@@8
rdata$r	SEGMENT
??_R2ioDummyChar@@8 DD FLAT:??_R1A@?0A@EA@ioDummyChar@@8 ; ioDummyChar::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ioPlayEntity@@8
	DD	FLAT:??_R1A@?0A@EA@ioGameEntity@@8
	DD	FLAT:??_R1A@?0A@EA@ioEntityEvent@@8
	DD	FLAT:??_R1BMI@?0A@EA@ioWorldEventReceiver@@8
rdata$r	ENDS
;	COMDAT ??_R3ioDummyChar@@8
rdata$r	SEGMENT
??_R3ioDummyChar@@8 DD 00H				; ioDummyChar::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	FLAT:??_R2ioDummyChar@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioDummyChar@@@8
_DATA	SEGMENT
??_R0?AVioDummyChar@@@8 DD FLAT:??_7type_info@@6B@	; ioDummyChar `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioDummyChar@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@ioDummyChar@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioDummyChar@@8 DD FLAT:??_R0?AVioDummyChar@@@8 ; ioDummyChar::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioDummyChar@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ioRaptorDummy@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioRaptorDummy@@8 DD FLAT:??_R0?AVioRaptorDummy@@@8 ; ioRaptorDummy::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	05H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioRaptorDummy@@8
rdata$r	ENDS
;	COMDAT ??_R2ioRaptorDummy@@8
rdata$r	SEGMENT
??_R2ioRaptorDummy@@8 DD FLAT:??_R1A@?0A@EA@ioRaptorDummy@@8 ; ioRaptorDummy::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ioDummyChar@@8
	DD	FLAT:??_R1A@?0A@EA@ioPlayEntity@@8
	DD	FLAT:??_R1A@?0A@EA@ioGameEntity@@8
	DD	FLAT:??_R1A@?0A@EA@ioEntityEvent@@8
	DD	FLAT:??_R1BMI@?0A@EA@ioWorldEventReceiver@@8
rdata$r	ENDS
;	COMDAT ??_R3ioRaptorDummy@@8
rdata$r	SEGMENT
??_R3ioRaptorDummy@@8 DD 00H				; ioRaptorDummy::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	06H
	DD	FLAT:??_R2ioRaptorDummy@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioRaptorDummy@@@8
_DATA	SEGMENT
??_R0?AVioRaptorDummy@@@8 DD FLAT:??_7type_info@@6B@	; ioRaptorDummy `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioRaptorDummy@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ioRaptorDummy@@6BioPlayEntity@@@
rdata$r	SEGMENT
??_R4ioRaptorDummy@@6BioPlayEntity@@@ DD 00H		; ioRaptorDummy::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVioRaptorDummy@@@8
	DD	FLAT:??_R3ioRaptorDummy@@8
rdata$r	ENDS
;	COMDAT ??_7ioRaptorDummy@@6BioWorldEventReceiver@@@
CONST	SEGMENT
??_7ioRaptorDummy@@6BioWorldEventReceiver@@@ DD FLAT:??_R4ioRaptorDummy@@6BioWorldEventReceiver@@@ ; ioRaptorDummy::`vftable'
	DD	FLAT:?OnTelepotation@ioDummyChar@@UAEXABUD3DXVECTOR3@@@Z
	DD	FLAT:?OnFireZoneDamage@ioDummyChar@@UAEXMABVioHashString@@@Z
	DD	FLAT:?OnPoisonZoneDamage@ioDummyChar@@UAEXXZ
	DD	FLAT:??_EioRaptorDummy@@WBMI@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_7ioRaptorDummy@@6BioPlayEntity@@@
CONST	SEGMENT
??_7ioRaptorDummy@@6BioPlayEntity@@@ DD FLAT:??_R4ioRaptorDummy@@6BioPlayEntity@@@ ; ioRaptorDummy::`vftable'
	DD	FLAT:?AddEntityEvent@ioDummyChar@@UAEXPAVioEntity@@@Z
	DD	FLAT:??_EioRaptorDummy@@UAEPAXI@Z
	DD	FLAT:?Update@ioDummyChar@@UAEXMKK@Z
	DD	FLAT:?UpdateAfter@ioDummyChar@@UAEXM@Z
	DD	FLAT:?GetTypeID@ioPlayEntity@@UBEHXZ
	DD	FLAT:?IsNeedCheckMapCollision@ioDummyChar@@UBE_NXZ
	DD	FLAT:?IsMountAvailable@ioDummyChar@@UBE_NXZ
	DD	FLAT:?IsMountingAvailable@ioDummyChar@@UBE_NXZ
	DD	FLAT:?IsNowMountEnable@ioDummyChar@@UBE_NXZ
	DD	FLAT:?IsAllWeaponDefence@ioGameEntity@@UBE_NXZ
	DD	FLAT:?HasEntity@ioGameEntity@@UAE_NABVioHashString@@@Z
	DD	FLAT:?AddEntity@ioGameEntity@@UAEPAVioEntity@@ABVioHashString@@@Z
	DD	FLAT:?DestroyEntity@ioGameEntity@@UAE_NABVioHashString@@@Z
	DD	FLAT:?GetEntity@ioGameEntity@@UAEPAVioEntity@@ABVioHashString@@@Z
	DD	FLAT:?UpdateBound@ioGameEntity@@MBEXXZ
	DD	FLAT:?UpdateBottomHeight@ioDummyChar@@MBEXXZ
	DD	FLAT:?NeedUpdateBottomHeight@ioDummyChar@@UAEXXZ
	DD	FLAT:?SetWorldPosition@ioGameEntity@@UAEXABUD3DXVECTOR3@@@Z
	DD	FLAT:?SetWorldOrientation@ioGameEntity@@UAEXABUD3DXQUATERNION@@@Z
	DD	FLAT:?SetWorldScale@ioGameEntity@@UAEXABUD3DXVECTOR3@@@Z
	DD	FLAT:?Translate@ioDummyChar@@UAEXABUD3DXVECTOR3@@@Z
	DD	FLAT:?TranslateByConveyer@ioDummyChar@@UAEXABUD3DXVECTOR3@@@Z
	DD	FLAT:?TranslateByWorldEntity@ioDummyChar@@UAEXABUD3DXVECTOR3@@@Z
	DD	FLAT:?MapCollisionPushingTranslate@ioDummyChar@@UAEXABUD3DXVECTOR3@@@Z
	DD	FLAT:?DontMoveCollisionPushingTranslate@ioGameEntity@@UAEXPAV1@ABUD3DXVECTOR3@@@Z
	DD	FLAT:?Rotate@ioGameEntity@@UAEXABUD3DXVECTOR3@@MW4TransformSpace@ioNode@@@Z
	DD	FLAT:?Scale@ioGameEntity@@UAEXMMM@Z
	DD	FLAT:?Scale@ioGameEntity@@UAEXABUD3DXVECTOR3@@@Z
	DD	FLAT:?GetWorldPosition@ioGameEntity@@UBEABUD3DXVECTOR3@@XZ
	DD	FLAT:?GetWorldOrientation@ioGameEntity@@UBEABUD3DXQUATERNION@@XZ
	DD	FLAT:?GetWorldScale@ioGameEntity@@UBEABUD3DXVECTOR3@@XZ
	DD	FLAT:?ApplyWeapon@ioDummyChar@@UAE?AW4ApplyWeaponExp@@PAVioWeapon@@@Z
	DD	FLAT:?IsCollisionAvailableWeapon@ioDummyChar@@UAE_NPAVioWeapon@@@Z
	DD	FLAT:?IsCollisionAvailableRange@ioPlayEntity@@UAE_NPAVioWeapon@@@Z
	DD	FLAT:?IsEntityCollisionSkipState@ioDummyChar@@UBE_NPAVioGameEntity@@@Z
	DD	FLAT:?IsCharCollisionSkipState@ioDummyChar@@UBE_NW4TeamType@@H@Z
	DD	FLAT:?IsWoundedCollision@ioPlayEntity@@UBE_NABVioOrientBox@@PAUD3DXVECTOR3@@@Z
	DD	FLAT:?GetAttackCollisionBox@ioDummyChar@@UAE?AVioOrientBox@@W4AniCollisionType@@_N@Z
	DD	FLAT:?CheckSphereDistance@ioPlayEntity@@UBE_NABUD3DXVECTOR3@@MAAM@Z
	DD	FLAT:?CheckSpherePoint@ioPlayEntity@@UBE_NABUD3DXVECTOR3@@MAAU2@@Z
	DD	FLAT:?CheckCylinderPoint@ioPlayEntity@@UBE_NABVioCylinder@@ABUD3DXVECTOR3@@AAU3@@Z
	DD	FLAT:?GetSubType@ioDummyChar@@UBE?AW4PlaySubType@ioPlayEntity@@XZ
	DD	FLAT:?GetArmorType@ioDummyChar@@UBE?AW4ArmorType@@XZ
	DD	FLAT:?DontMoveEntityLevel@ioDummyChar@@UBEHXZ
	DD	FLAT:?NotifyDontMoveCollisionPushingSkip@ioPlayEntity@@UAEXPAVioGameEntity@@@Z
	DD	FLAT:?LoadProperty@ioRaptorDummy@@UAEXAAVioINILoader@@@Z
	DD	FLAT:?GetWorldEventReceiver@ioDummyChar@@UAEPAVioWorldEventReceiver@@XZ
	DD	FLAT:?Revival@ioPlayEntity@@UAEXXZ
	DD	FLAT:?UpdateGauge@ioDummyChar@@UAEXXZ
	DD	FLAT:?RenderGauge@ioDummyChar@@UAEXXZ
	DD	FLAT:?FillMaxHP@ioPlayEntity@@UAEXXZ
	DD	FLAT:?ProcessRecovery@ioPlayEntity@@MAEXXZ
	DD	FLAT:?AddHeadDamageInfo@ioPlayEntity@@UAEXH_N@Z
	DD	FLAT:?RenderHeadInfoList@ioPlayEntity@@UAEXHH@Z
	DD	FLAT:?UpdateHeadInfoList@ioPlayEntity@@MAEXK@Z
	DD	FLAT:?SetTeam@ioPlayEntity@@UAEXW4TeamType@@@Z
	DD	FLAT:?InitDummyCharInfo@ioDummyChar@@UAEXHKABUD3DXVECTOR3@@0M_N@Z
	DD	FLAT:?TestMapCollision@ioDummyChar@@UAE_NPAVioOpcodeShape@@PAVioPlayStage@@PBUD3DXMATRIX@@@Z
	DD	FLAT:?CheckEntityCollision@ioDummyChar@@UAEXPAVioPlayEntity@@@Z
	DD	FLAT:?GetDummyGrassType@ioDummyChar@@UAEHXZ
	DD	FLAT:?IsActivateWeapon@ioDummyChar@@UAE_NXZ
	DD	FLAT:?IsDummyVsDummyCollisionSkipState@ioDummyChar@@UAE_NPBV1@@Z
	DD	FLAT:?ProcessState@ioRaptorDummy@@MAEXMK@Z
	DD	FLAT:?ProcessPos@ioRaptorDummy@@MAEXM@Z
	DD	FLAT:?ProcessDelayState@ioRaptorDummy@@MAEXM@Z
	DD	FLAT:?ProcessMoveState@ioRaptorDummy@@MAEXM@Z
	DD	FLAT:?ProcessDashState@ioRaptorDummy@@MAEXM@Z
	DD	FLAT:?ProcessAttackState@ioRaptorDummy@@MAEXMK@Z
	DD	FLAT:?ApplyDummyCharSync@ioDummyChar@@UAEXPAVioPlayStage@@AAVSP2Packet@@@Z
	DD	FLAT:?SetDelayState@ioDummyChar@@UAEX_N@Z
	DD	FLAT:?SetMoveState@ioRaptorDummy@@UAEXXZ
	DD	FLAT:?SetDieState@ioDummyChar@@UAEX_N0@Z
	DD	FLAT:?SetDashState@ioRaptorDummy@@UAEXXZ
	DD	FLAT:?SetAttackState@ioRaptorDummy@@UAEXXZ
	DD	FLAT:?DropZoneCheck@ioDummyChar@@MAEXXZ
	DD	FLAT:?SendAttackInfoToSkill@ioDummyChar@@MAEXXZ
	DD	FLAT:?CheckCollisionWeapon@ioDummyChar@@UAEXPAVioBaseChar@@@Z
	DD	FLAT:?TranslateMountEntity@ioDummyChar@@MAEXABUD3DXVECTOR3@@@Z
	DD	FLAT:?ClearMountEntity@ioDummyChar@@MAEXXZ
	DD	FLAT:?UpdateMountedEntityList@ioDummyChar@@MAEXXZ
	DD	FLAT:?UpdateMountedWeaponList@ioDummyChar@@MAEXXZ
	DD	FLAT:?SetWorldPositionMountEntity@ioDummyChar@@MAEXM@Z
	DD	FLAT:?DummyDieClearMountEntity@ioDummyChar@@MAEXXZ
	DD	FLAT:?IsDummyCharMidSync@ioDummyChar@@UAE_NXZ
	DD	FLAT:?FillDummyCharMidSync@ioDummyChar@@UAEXPAVioBaseChar@@AAVSP2Packet@@@Z
	DD	FLAT:?ApplyDummyCharMidSync@ioDummyChar@@UAEXPAVioBaseChar@@AAVSP2Packet@@@Z
	DD	FLAT:?GetSkillMaxActiveCnt@ioDummyChar@@UAEHXZ
	DD	FLAT:?GetSkillCurActiveCnt@ioDummyChar@@UAEHXZ
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??0ioRaptorDummy@@QAE@PAVioEntityGroup@@PAVioPlayMode@@@Z
_TEXT	SEGMENT
_pGrp$ = 8						; size = 4
_pMode$ = 12						; size = 4
??0ioRaptorDummy@@QAE@PAVioEntityGroup@@PAVioPlayMode@@@Z PROC ; ioRaptorDummy::ioRaptorDummy, COMDAT
; _this$ = ecx

; 22   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	ff 75 0c	 push	 DWORD PTR _pMode$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 75 08	 push	 DWORD PTR _pGrp$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0ioDummyChar@@QAE@PAVioEntityGroup@@PAVioPlayMode@@@Z ; ioDummyChar::ioDummyChar
  00011	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioRaptorDummy@@6BioPlayEntity@@@
  00017	c7 86 c8 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+456], OFFSET ??_7ioRaptorDummy@@6BioWorldEventReceiver@@@

; 23   : }

  00021	8b c6		 mov	 eax, esi
  00023	5e		 pop	 esi
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0ioRaptorDummy@@QAE@PAVioEntityGroup@@PAVioPlayMode@@@Z ENDP ; ioRaptorDummy::ioRaptorDummy
_TEXT	ENDS
PUBLIC	??1ioRaptorDummy@@UAE@XZ			; ioRaptorDummy::~ioRaptorDummy
EXTRN	??1ioDummyChar@@UAE@XZ:PROC			; ioDummyChar::~ioDummyChar
; Function compile flags: /Ogsp
;	COMDAT ??1ioRaptorDummy@@UAE@XZ
_TEXT	SEGMENT
??1ioRaptorDummy@@UAE@XZ PROC				; ioRaptorDummy::~ioRaptorDummy, COMDAT
; _this$ = ecx

; 26   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ioRaptorDummy@@6BioPlayEntity@@@
  00006	c7 81 c8 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+456], OFFSET ??_7ioRaptorDummy@@6BioWorldEventReceiver@@@

; 27   : }

  00010	e9 00 00 00 00	 jmp	 ??1ioDummyChar@@UAE@XZ	; ioDummyChar::~ioDummyChar
??1ioRaptorDummy@@UAE@XZ ENDP				; ioRaptorDummy::~ioRaptorDummy
_TEXT	ENDS
EXTRN	?LoadProperty@ioDummyChar@@UAEXAAVioINILoader@@@Z:PROC ; ioDummyChar::LoadProperty
; Function compile flags: /Ogsp
;	COMDAT ?LoadProperty@ioRaptorDummy@@UAEXAAVioINILoader@@@Z
_TEXT	SEGMENT
_rkLoader$ = 8						; size = 4
?LoadProperty@ioRaptorDummy@@UAEXAAVioINILoader@@@Z PROC ; ioRaptorDummy::LoadProperty, COMDAT
; _this$ = ecx

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 32   : 
; 33   : 	char szBuf[MAX_PATH] = "";
; 34   : }

  00003	5d		 pop	 ebp

; 31   : 	ioDummyChar::LoadProperty( rkLoader );

  00004	e9 00 00 00 00	 jmp	 ?LoadProperty@ioDummyChar@@UAEXAAVioINILoader@@@Z ; ioDummyChar::LoadProperty
?LoadProperty@ioRaptorDummy@@UAEXAAVioINILoader@@@Z ENDP ; ioRaptorDummy::LoadProperty
_TEXT	ENDS
EXTRN	?ProcessEffectUpdate@ioDummyChar@@IAEXM@Z:PROC	; ioDummyChar::ProcessEffectUpdate
EXTRN	?ProcessStartState@ioDummyChar@@IAEXM@Z:PROC	; ioDummyChar::ProcessStartState
EXTRN	?CheckExtraAniJump@ioDummyChar@@IAEXXZ:PROC	; ioDummyChar::CheckExtraAniJump
EXTRN	?CheckReservedSliding@ioDummyChar@@QAEXXZ:PROC	; ioDummyChar::CheckReservedSliding
EXTRN	?ProcessDieState@ioDummyChar@@IAEXM@Z:PROC	; ioDummyChar::ProcessDieState
; Function compile flags: /Ogsp
;	COMDAT ?ProcessState@ioRaptorDummy@@MAEXMK@Z
_TEXT	SEGMENT
_fTimePerSec$ = 8					; size = 4
_dwPreTime$ = 12					; size = 4
?ProcessState@ioRaptorDummy@@MAEXMK@Z PROC		; ioRaptorDummy::ProcessState, COMDAT
; _this$ = ecx

; 37   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 38   : 	switch( m_State )

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fTimePerSec$[ebp]
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	8b 86 30 02 00
	00		 mov	 eax, DWORD PTR [esi+560]
  00011	48		 dec	 eax
  00012	74 72		 je	 SHORT $LN6@ProcessSta
  00014	48		 dec	 eax
  00015	74 5f		 je	 SHORT $LN5@ProcessSta
  00017	48		 dec	 eax
  00018	74 4c		 je	 SHORT $LN4@ProcessSta
  0001a	48		 dec	 eax
  0001b	74 39		 je	 SHORT $LN3@ProcessSta
  0001d	48		 dec	 eax
  0001e	74 10		 je	 SHORT $LN2@ProcessSta
  00020	48		 dec	 eax
  00021	75 6e		 jne	 SHORT $LN7@ProcessSta

; 57   : 	case DCS_DIE:
; 58   : 		ProcessDieState( fTimePerSec );

  00023	51		 push	 ecx
  00024	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00029	e8 00 00 00 00	 call	 ?ProcessDieState@ioDummyChar@@IAEXM@Z ; ioDummyChar::ProcessDieState

; 59   : 		break;

  0002e	eb 61		 jmp	 SHORT $LN7@ProcessSta
$LN2@ProcessSta:

; 52   : 	case DCS_ATTACK:
; 53   : 		CheckReservedSliding();

  00030	e8 00 00 00 00	 call	 ?CheckReservedSliding@ioDummyChar@@QAEXXZ ; ioDummyChar::CheckReservedSliding

; 54   : 		CheckExtraAniJump();

  00035	8b ce		 mov	 ecx, esi
  00037	e8 00 00 00 00	 call	 ?CheckExtraAniJump@ioDummyChar@@IAEXXZ ; ioDummyChar::CheckExtraAniJump

; 55   : 		ProcessAttackState( fTimePerSec, dwPreTime );

  0003c	ff 75 0c	 push	 DWORD PTR _dwPreTime$[ebp]
  0003f	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fTimePerSec$[ebp]
  00044	8b 06		 mov	 eax, DWORD PTR [esi]
  00046	51		 push	 ecx
  00047	8b ce		 mov	 ecx, esi
  00049	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004e	ff 90 0c 01 00
	00		 call	 DWORD PTR [eax+268]

; 56   : 		break;

  00054	eb 3b		 jmp	 SHORT $LN7@ProcessSta
$LN3@ProcessSta:

; 49   : 	case DCS_DASH:
; 50   : 		ProcessDashState( fTimePerSec );

  00056	8b 06		 mov	 eax, DWORD PTR [esi]
  00058	51		 push	 ecx
  00059	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0005e	ff 90 08 01 00
	00		 call	 DWORD PTR [eax+264]

; 51   : 		break;

  00064	eb 2b		 jmp	 SHORT $LN7@ProcessSta
$LN4@ProcessSta:

; 46   : 	case DCS_MOVE:
; 47   : 		ProcessMoveState( fTimePerSec );

  00066	8b 06		 mov	 eax, DWORD PTR [esi]
  00068	51		 push	 ecx
  00069	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006e	ff 90 04 01 00
	00		 call	 DWORD PTR [eax+260]

; 48   : 		break;

  00074	eb 1b		 jmp	 SHORT $LN7@ProcessSta
$LN5@ProcessSta:

; 42   : 		break;
; 43   : 	case DCS_DELAY:
; 44   : 		ProcessDelayState( fTimePerSec );

  00076	8b 06		 mov	 eax, DWORD PTR [esi]
  00078	51		 push	 ecx
  00079	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007e	ff 90 00 01 00
	00		 call	 DWORD PTR [eax+256]

; 45   : 		break;

  00084	eb 0b		 jmp	 SHORT $LN7@ProcessSta
$LN6@ProcessSta:

; 39   : 	{
; 40   : 	case DCS_START:
; 41   : 		ProcessStartState( fTimePerSec );

  00086	51		 push	 ecx
  00087	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0008c	e8 00 00 00 00	 call	 ?ProcessStartState@ioDummyChar@@IAEXM@Z ; ioDummyChar::ProcessStartState
$LN7@ProcessSta:

; 60   : 	}
; 61   : 
; 62   : 	ProcessPos( fTimePerSec );

  00091	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fTimePerSec$[ebp]
  00096	8b 06		 mov	 eax, DWORD PTR [esi]
  00098	51		 push	 ecx
  00099	8b ce		 mov	 ecx, esi
  0009b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a0	ff 90 fc 00 00
	00		 call	 DWORD PTR [eax+252]

; 63   : 	ProcessEffectUpdate( fTimePerSec );

  000a6	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fTimePerSec$[ebp]
  000ab	51		 push	 ecx
  000ac	8b ce		 mov	 ecx, esi
  000ae	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b3	e8 00 00 00 00	 call	 ?ProcessEffectUpdate@ioDummyChar@@IAEXM@Z ; ioDummyChar::ProcessEffectUpdate
  000b8	5e		 pop	 esi

; 64   : }

  000b9	5d		 pop	 ebp
  000ba	c2 08 00	 ret	 8
?ProcessState@ioRaptorDummy@@MAEXMK@Z ENDP		; ioRaptorDummy::ProcessState
_TEXT	ENDS
EXTRN	__imp_?GetLoopSec@ioFrameTimer@@QBEKXZ:PROC
EXTRN	__imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ:PROC
EXTRN	?GetOwner@ioDummyChar@@QBEPAVioBaseChar@@XZ:PROC ; ioDummyChar::GetOwner
; Function compile flags: /Ogsp
;	COMDAT ?ProcessPos@ioRaptorDummy@@MAEXM@Z
_TEXT	SEGMENT
_dwCurTime$ = -4					; size = 4
_fTimePerSec$ = 8					; size = 4
?ProcessPos@ioRaptorDummy@@MAEXM@Z PROC			; ioRaptorDummy::ProcessPos, COMDAT
; _this$ = ecx

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f1		 mov	 esi, ecx

; 68   : 	ioBaseChar *pOwner = GetOwner();

  00008	e8 00 00 00 00	 call	 ?GetOwner@ioDummyChar@@QBEPAVioBaseChar@@XZ ; ioDummyChar::GetOwner
  0000d	8b f8		 mov	 edi, eax

; 69   : 	if( !pOwner ) return;

  0000f	85 ff		 test	 edi, edi
  00011	74 48		 je	 SHORT $LN3@ProcessPos

; 70   : 
; 71   : 	DWORD dwCurTime = FRAMEGETTIME();

  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  00019	8b c8		 mov	 ecx, eax
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ

; 72   : 
; 73   : 	if( m_State == DCS_START )

  00021	83 be 30 02 00
	00 01		 cmp	 DWORD PTR [esi+560], 1
  00028	89 45 fc	 mov	 DWORD PTR _dwCurTime$[ebp], eax
  0002b	75 06		 jne	 SHORT $LN1@ProcessPos

; 74   : 	{
; 75   : 		m_dwProcessTime = dwCurTime;

  0002d	89 86 1c 02 00
	00		 mov	 DWORD PTR [esi+540], eax
$LN1@ProcessPos:

; 76   : 	}
; 77   : 
; 78   : 	SetWorldPosition( pOwner->GetWorldPosition() );

  00033	8b 07		 mov	 eax, DWORD PTR [edi]
  00035	53		 push	 ebx
  00036	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00038	8b cf		 mov	 ecx, edi
  0003a	ff 50 70	 call	 DWORD PTR [eax+112]
  0003d	50		 push	 eax
  0003e	8b ce		 mov	 ecx, esi
  00040	ff 53 44	 call	 DWORD PTR [ebx+68]

; 79   : 	SetWorldOrientation( pOwner->GetTargetRot() );

  00043	8b 06		 mov	 eax, DWORD PTR [esi]
  00045	81 c7 a4 06 00
	00		 add	 edi, 1700		; 000006a4H
  0004b	57		 push	 edi
  0004c	8b ce		 mov	 ecx, esi
  0004e	ff 50 48	 call	 DWORD PTR [eax+72]

; 80   : 
; 81   : 	m_dwProcessTime = dwCurTime;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _dwCurTime$[ebp]
  00054	89 86 1c 02 00
	00		 mov	 DWORD PTR [esi+540], eax
  0005a	5b		 pop	 ebx
$LN3@ProcessPos:
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi

; 82   : }

  0005d	c9		 leave
  0005e	c2 04 00	 ret	 4
?ProcessPos@ioRaptorDummy@@MAEXM@Z ENDP			; ioRaptorDummy::ProcessPos
_TEXT	ENDS
EXTRN	?CheckEnableAttackState@ioDummyChar@@QAE_NXZ:PROC ; ioDummyChar::CheckEnableAttackState
EXTRN	?IsObejctEquipState@ioBaseChar@@QAE_NW4ObjectEqipState@@@Z:PROC ; ioBaseChar::IsObejctEquipState
; Function compile flags: /Ogsp
;	COMDAT ?ProcessDelayState@ioRaptorDummy@@MAEXM@Z
_TEXT	SEGMENT
_fTimePerSec$ = 8					; size = 4
?ProcessDelayState@ioRaptorDummy@@MAEXM@Z PROC		; ioRaptorDummy::ProcessDelayState, COMDAT
; _this$ = ecx

; 85   : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f1		 mov	 esi, ecx

; 86   : 	ioBaseChar *pOwner = GetOwner();

  00004	e8 00 00 00 00	 call	 ?GetOwner@ioDummyChar@@QBEPAVioBaseChar@@XZ ; ioDummyChar::GetOwner
  00009	8b f8		 mov	 edi, eax

; 87   : 	if( !pOwner ) return;

  0000b	85 ff		 test	 edi, edi
  0000d	74 60		 je	 SHORT $LN1@ProcessDel

; 88   : 
; 89   : 	DWORD dwCurTime = FRAMEGETTIME();

  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  00015	8b c8		 mov	 ecx, eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ

; 90   : 
; 91   : 	if( !pOwner->IsObejctEquipState() )

  0001d	6a 0a		 push	 10			; 0000000aH
  0001f	8b cf		 mov	 ecx, edi
  00021	e8 00 00 00 00	 call	 ?IsObejctEquipState@ioBaseChar@@QAE_NW4ObjectEqipState@@@Z ; ioBaseChar::IsObejctEquipState

; 92   : 	{
; 93   : 		SetDieState( true );

  00026	8b ce		 mov	 ecx, esi
  00028	84 c0		 test	 al, al
  0002a	75 0e		 jne	 SHORT $LN5@ProcessDel
  0002c	8b 06		 mov	 eax, DWORD PTR [esi]
  0002e	6a 00		 push	 0
  00030	6a 01		 push	 1
  00032	ff 90 1c 01 00
	00		 call	 DWORD PTR [eax+284]

; 94   : 		return;

  00038	eb 35		 jmp	 SHORT $LN1@ProcessDel
$LN5@ProcessDel:

; 95   : 	}
; 96   : 
; 97   : 	if( pOwner->GetState() == CS_RUN )

  0003a	8a 87 10 03 00
	00		 mov	 al, BYTE PTR [edi+784]
  00040	3c 01		 cmp	 al, 1
  00042	75 0a		 jne	 SHORT $LN4@ProcessDel

; 98   : 	{
; 99   : 		SetMoveState();

  00044	8b 06		 mov	 eax, DWORD PTR [esi]
  00046	ff 90 18 01 00
	00		 call	 DWORD PTR [eax+280]

; 100  : 		return;

  0004c	eb 21		 jmp	 SHORT $LN1@ProcessDel
$LN4@ProcessDel:

; 101  : 	}
; 102  : 	else if( pOwner->GetState() == CS_DASH )

  0004e	3c 02		 cmp	 al, 2
  00050	75 0a		 jne	 SHORT $LN2@ProcessDel

; 103  : 	{
; 104  : 		SetDashState();

  00052	8b 06		 mov	 eax, DWORD PTR [esi]
  00054	ff 90 20 01 00
	00		 call	 DWORD PTR [eax+288]

; 105  : 		return;

  0005a	eb 13		 jmp	 SHORT $LN1@ProcessDel
$LN2@ProcessDel:

; 106  : 	}
; 107  : 
; 108  : 	if( CheckEnableAttackState() )

  0005c	e8 00 00 00 00	 call	 ?CheckEnableAttackState@ioDummyChar@@QAE_NXZ ; ioDummyChar::CheckEnableAttackState
  00061	84 c0		 test	 al, al
  00063	74 0a		 je	 SHORT $LN1@ProcessDel

; 109  : 	{
; 110  : 		SetAttackState();

  00065	8b 06		 mov	 eax, DWORD PTR [esi]
  00067	8b ce		 mov	 ecx, esi
  00069	ff 90 24 01 00
	00		 call	 DWORD PTR [eax+292]
$LN1@ProcessDel:

; 111  : 		return;
; 112  : 	}
; 113  : }

  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	c2 04 00	 ret	 4
?ProcessDelayState@ioRaptorDummy@@MAEXM@Z ENDP		; ioRaptorDummy::ProcessDelayState
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?ProcessMoveState@ioRaptorDummy@@MAEXM@Z
_TEXT	SEGMENT
_fTimePerSec$ = 8					; size = 4
?ProcessMoveState@ioRaptorDummy@@MAEXM@Z PROC		; ioRaptorDummy::ProcessMoveState, COMDAT
; _this$ = ecx

; 116  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f1		 mov	 esi, ecx

; 117  : 	ioBaseChar *pOwner = GetOwner();

  00004	e8 00 00 00 00	 call	 ?GetOwner@ioDummyChar@@QBEPAVioBaseChar@@XZ ; ioDummyChar::GetOwner
  00009	8b f8		 mov	 edi, eax

; 118  : 	if( !pOwner ) return;

  0000b	85 ff		 test	 edi, edi
  0000d	74 62		 je	 SHORT $LN1@ProcessMov

; 119  : 
; 120  : 	DWORD dwCurTime = FRAMEGETTIME();

  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  00015	8b c8		 mov	 ecx, eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ

; 121  : 
; 122  : 	if( !pOwner->IsObejctEquipState() )

  0001d	6a 0a		 push	 10			; 0000000aH
  0001f	8b cf		 mov	 ecx, edi
  00021	e8 00 00 00 00	 call	 ?IsObejctEquipState@ioBaseChar@@QAE_NW4ObjectEqipState@@@Z ; ioBaseChar::IsObejctEquipState

; 123  : 	{
; 124  : 		SetDieState( true );

  00026	8b ce		 mov	 ecx, esi
  00028	84 c0		 test	 al, al
  0002a	75 0e		 jne	 SHORT $LN5@ProcessMov
  0002c	8b 06		 mov	 eax, DWORD PTR [esi]
  0002e	6a 00		 push	 0
  00030	6a 01		 push	 1
  00032	ff 90 1c 01 00
	00		 call	 DWORD PTR [eax+284]

; 125  : 		return;

  00038	eb 37		 jmp	 SHORT $LN1@ProcessMov
$LN5@ProcessMov:

; 126  : 	}
; 127  : 
; 128  : 	if( pOwner->GetState() == CS_DELAY )

  0003a	8a 87 10 03 00
	00		 mov	 al, BYTE PTR [edi+784]
  00040	84 c0		 test	 al, al
  00042	75 0c		 jne	 SHORT $LN4@ProcessMov

; 129  : 	{
; 130  : 		SetDelayState( false );

  00044	8b 06		 mov	 eax, DWORD PTR [esi]
  00046	6a 00		 push	 0
  00048	ff 90 14 01 00
	00		 call	 DWORD PTR [eax+276]

; 131  : 		return;

  0004e	eb 21		 jmp	 SHORT $LN1@ProcessMov
$LN4@ProcessMov:

; 132  : 	}
; 133  : 	else if( pOwner->GetState() == CS_DASH )

  00050	3c 02		 cmp	 al, 2
  00052	75 0a		 jne	 SHORT $LN2@ProcessMov

; 134  : 	{
; 135  : 		SetDashState();

  00054	8b 06		 mov	 eax, DWORD PTR [esi]
  00056	ff 90 20 01 00
	00		 call	 DWORD PTR [eax+288]

; 136  : 		return;

  0005c	eb 13		 jmp	 SHORT $LN1@ProcessMov
$LN2@ProcessMov:

; 137  : 	}
; 138  : 
; 139  : 	if( CheckEnableAttackState() )

  0005e	e8 00 00 00 00	 call	 ?CheckEnableAttackState@ioDummyChar@@QAE_NXZ ; ioDummyChar::CheckEnableAttackState
  00063	84 c0		 test	 al, al
  00065	74 0a		 je	 SHORT $LN1@ProcessMov

; 140  : 	{
; 141  : 		SetAttackState();

  00067	8b 06		 mov	 eax, DWORD PTR [esi]
  00069	8b ce		 mov	 ecx, esi
  0006b	ff 90 24 01 00
	00		 call	 DWORD PTR [eax+292]
$LN1@ProcessMov:

; 142  : 		return;
; 143  : 	}
; 144  : }

  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	c2 04 00	 ret	 4
?ProcessMoveState@ioRaptorDummy@@MAEXM@Z ENDP		; ioRaptorDummy::ProcessMoveState
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?ProcessDashState@ioRaptorDummy@@MAEXM@Z
_TEXT	SEGMENT
_fTimePerSec$ = 8					; size = 4
?ProcessDashState@ioRaptorDummy@@MAEXM@Z PROC		; ioRaptorDummy::ProcessDashState, COMDAT
; _this$ = ecx

; 147  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f1		 mov	 esi, ecx

; 148  : 	ioBaseChar *pOwner = GetOwner();

  00004	e8 00 00 00 00	 call	 ?GetOwner@ioDummyChar@@QBEPAVioBaseChar@@XZ ; ioDummyChar::GetOwner
  00009	8b f8		 mov	 edi, eax

; 149  : 	if( !pOwner ) return;

  0000b	85 ff		 test	 edi, edi
  0000d	74 53		 je	 SHORT $LN1@ProcessDas

; 150  : 
; 151  : 	DWORD dwCurTime = FRAMEGETTIME();

  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  00015	8b c8		 mov	 ecx, eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ

; 152  : 
; 153  : 	if( !pOwner->IsObejctEquipState() )

  0001d	6a 0a		 push	 10			; 0000000aH
  0001f	8b cf		 mov	 ecx, edi
  00021	e8 00 00 00 00	 call	 ?IsObejctEquipState@ioBaseChar@@QAE_NW4ObjectEqipState@@@Z ; ioBaseChar::IsObejctEquipState

; 154  : 	{
; 155  : 		SetDieState( true );

  00026	8b ce		 mov	 ecx, esi
  00028	84 c0		 test	 al, al
  0002a	75 0e		 jne	 SHORT $LN3@ProcessDas
  0002c	8b 06		 mov	 eax, DWORD PTR [esi]
  0002e	6a 00		 push	 0
  00030	6a 01		 push	 1
  00032	ff 90 1c 01 00
	00		 call	 DWORD PTR [eax+284]

; 156  : 		return;

  00038	eb 28		 jmp	 SHORT $LN1@ProcessDas
$LN3@ProcessDas:

; 157  : 	}
; 158  : 
; 159  : 	if( pOwner->GetState() == CS_DELAY )

  0003a	80 bf 10 03 00
	00 00		 cmp	 BYTE PTR [edi+784], 0
  00041	75 0c		 jne	 SHORT $LN2@ProcessDas

; 160  : 	{
; 161  : 		SetDelayState( false );

  00043	8b 06		 mov	 eax, DWORD PTR [esi]
  00045	6a 00		 push	 0
  00047	ff 90 14 01 00
	00		 call	 DWORD PTR [eax+276]

; 162  : 		return;

  0004d	eb 13		 jmp	 SHORT $LN1@ProcessDas
$LN2@ProcessDas:

; 163  : 	}
; 164  : 
; 165  : 	if( CheckEnableAttackState() )

  0004f	e8 00 00 00 00	 call	 ?CheckEnableAttackState@ioDummyChar@@QAE_NXZ ; ioDummyChar::CheckEnableAttackState
  00054	84 c0		 test	 al, al
  00056	74 0a		 je	 SHORT $LN1@ProcessDas

; 166  : 	{
; 167  : 		SetAttackState();

  00058	8b 06		 mov	 eax, DWORD PTR [esi]
  0005a	8b ce		 mov	 ecx, esi
  0005c	ff 90 24 01 00
	00		 call	 DWORD PTR [eax+292]
$LN1@ProcessDas:

; 168  : 		return;
; 169  : 	}
; 170  : }

  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	c2 04 00	 ret	 4
?ProcessDashState@ioRaptorDummy@@MAEXM@Z ENDP		; ioRaptorDummy::ProcessDashState
_TEXT	ENDS
EXTRN	?SetAttackState@ioDummyChar@@UAEXXZ:PROC	; ioDummyChar::SetAttackState
; Function compile flags: /Ogsp
;	COMDAT ?SetAttackState@ioRaptorDummy@@UAEXXZ
_TEXT	SEGMENT
?SetAttackState@ioRaptorDummy@@UAEXXZ PROC		; ioRaptorDummy::SetAttackState, COMDAT
; _this$ = ecx

; 174  : 	ioDummyChar::SetAttackState();

  00000	e9 00 00 00 00	 jmp	 ?SetAttackState@ioDummyChar@@UAEXXZ ; ioDummyChar::SetAttackState
?SetAttackState@ioRaptorDummy@@UAEXXZ ENDP		; ioRaptorDummy::SetAttackState
_TEXT	ENDS
PUBLIC	__real@00000000
PUBLIC	__real@4f800000
EXTRN	?SetAttachWeapon@ioDummyChar@@IAEXXZ:PROC	; ioDummyChar::SetAttachWeapon
EXTRN	__imp_?SetLoopAni@ioEntityGroup@@QAE_NHMMMM@Z:PROC
EXTRN	?GetRunDashAniRate@ioBaseChar@@QBEMXZ:PROC	; ioBaseChar::GetRunDashAniRate
EXTRN	__imp_?ClearAllLoopAni@ioEntityGroup@@QAEXM_N@Z:PROC
EXTRN	__imp_?ClearAllActionAni@ioEntityGroup@@QAEXM_N@Z:PROC
EXTRN	__imp_?GetAnimationIdx@ioEntityGroup@@QAEHABVioHashString@@@Z:PROC
EXTRN	__imp_?IsEmpty@ioHashString@@QBE_NXZ:PROC
EXTRN	?CheckChargeWeaponDead@ioDummyChar@@IAEXXZ:PROC	; ioDummyChar::CheckChargeWeaponDead
;	COMDAT __real@00000000
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stdafx.h
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@4f800000
CONST	SEGMENT
__real@4f800000 DD 04f800000r			; 4.29497e+009
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioraptordummy.cpp
CONST	ENDS
;	COMDAT ?SetMoveState@ioRaptorDummy@@UAEXXZ
_TEXT	SEGMENT
tv244 = -4						; size = 4
tv239 = -4						; size = 4
tv225 = -4						; size = 4
tv147 = -4						; size = 4
tv145 = -4						; size = 4
_fAniRate$661519 = -4					; size = 4
?SetMoveState@ioRaptorDummy@@UAEXXZ PROC		; ioRaptorDummy::SetMoveState, COMDAT
; _this$ = ecx

; 255  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 256  : 	ioBaseChar *pOwner = GetOwner();

  00008	e8 00 00 00 00	 call	 ?GetOwner@ioDummyChar@@QBEPAVioBaseChar@@XZ ; ioDummyChar::GetOwner
  0000d	8b d8		 mov	 ebx, eax

; 257  : 	if( !pOwner ) return;

  0000f	85 db		 test	 ebx, ebx
  00011	0f 84 17 01 00
	00		 je	 $LN1@SetMoveSta

; 258  : 
; 259  : 	m_State = DCS_MOVE;
; 260  : 
; 261  : 	CheckChargeWeaponDead();

  00017	57		 push	 edi
  00018	8b ce		 mov	 ecx, esi
  0001a	c7 86 30 02 00
	00 03 00 00 00	 mov	 DWORD PTR [esi+560], 3
  00024	e8 00 00 00 00	 call	 ?CheckChargeWeaponDead@ioDummyChar@@IAEXXZ ; ioDummyChar::CheckChargeWeaponDead

; 262  : 
; 263  : 	if( !m_MoveAnimation.IsEmpty() )

  00029	8d be bc 06 00
	00		 lea	 edi, DWORD PTR [esi+1724]
  0002f	8b cf		 mov	 ecx, edi
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00037	84 c0		 test	 al, al
  00039	0f 85 de 00 00
	00		 jne	 $LN3@SetMoveSta

; 264  : 	{
; 265  : 		int iAniID = m_pGroup->GetAnimationIdx( m_MoveAnimation );

  0003f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00042	57		 push	 edi
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetAnimationIdx@ioEntityGroup@@QAEHABVioHashString@@@Z
  00049	8b f8		 mov	 edi, eax

; 266  : 		if( iAniID != -1 )

  0004b	83 ff ff	 cmp	 edi, -1
  0004e	0f 84 c9 00 00
	00		 je	 $LN3@SetMoveSta

; 267  : 		{
; 268  : 			m_pGroup->ClearAllActionAni( FLOAT100, true );

  00054	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  00059	89 45 fc	 mov	 DWORD PTR tv244[ebp], eax
  0005c	db 45 fc	 fild	 DWORD PTR tv244[ebp]
  0005f	6a 01		 push	 1
  00061	85 c0		 test	 eax, eax
  00063	79 06		 jns	 SHORT $LN18@SetMoveSta
  00065	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN18@SetMoveSta:
  0006b	51		 push	 ecx
  0006c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0006f	d9 1c 24	 fstp	 DWORD PTR [esp]
  00072	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ClearAllActionAni@ioEntityGroup@@QAEXM_N@Z

; 269  : 			m_pGroup->ClearAllLoopAni( FLOAT100, true );

  00078	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  0007d	89 45 fc	 mov	 DWORD PTR tv239[ebp], eax
  00080	db 45 fc	 fild	 DWORD PTR tv239[ebp]
  00083	6a 01		 push	 1
  00085	85 c0		 test	 eax, eax
  00087	79 06		 jns	 SHORT $LN19@SetMoveSta
  00089	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN19@SetMoveSta:
  0008f	51		 push	 ecx
  00090	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00093	d9 1c 24	 fstp	 DWORD PTR [esp]
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ClearAllLoopAni@ioEntityGroup@@QAEXM_N@Z

; 270  : 
; 271  : 			float fAniRate = pOwner->GetRunDashAniRate();

  0009c	8b cb		 mov	 ecx, ebx
  0009e	e8 00 00 00 00	 call	 ?GetRunDashAniRate@ioBaseChar@@QBEMXZ ; ioBaseChar::GetRunDashAniRate
  000a3	d9 5d fc	 fstp	 DWORD PTR _fAniRate$661519[ebp]

; 272  : 			if( fAniRate <= 0.0f )

  000a6	d9 45 fc	 fld	 DWORD PTR _fAniRate$661519[ebp]
  000a9	d9 ee		 fldz
  000ab	df f1		 fcomip	 ST(1)
  000ad	dd d8		 fstp	 ST(0)
  000af	72 18		 jb	 SHORT $LN2@SetMoveSta

; 273  : 				fAniRate = FLOAT1;

  000b1	b8 01 00 00 00	 mov	 eax, 1
  000b6	89 45 fc	 mov	 DWORD PTR tv225[ebp], eax
  000b9	db 45 fc	 fild	 DWORD PTR tv225[ebp]
  000bc	85 c0		 test	 eax, eax
  000be	79 06		 jns	 SHORT $LN20@SetMoveSta
  000c0	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN20@SetMoveSta:
  000c6	d9 5d fc	 fstp	 DWORD PTR _fAniRate$661519[ebp]
$LN2@SetMoveSta:

; 274  : 
; 275  : 			m_pGroup->SetLoopAni( iAniID, FLOAT100, FLOAT1, fAniRate );

  000c9	b8 01 00 00 00	 mov	 eax, 1
  000ce	8b c8		 mov	 ecx, eax
  000d0	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  000d5	0f 57 c0	 xorps	 xmm0, xmm0
  000d8	83 ec 10	 sub	 esp, 16			; 00000010H
  000db	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  000e1	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fAniRate$661519[ebp]
  000e6	89 4d fc	 mov	 DWORD PTR tv147[ebp], ecx
  000e9	db 45 fc	 fild	 DWORD PTR tv147[ebp]
  000ec	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  000f2	85 c9		 test	 ecx, ecx
  000f4	79 06		 jns	 SHORT $LN21@SetMoveSta
  000f6	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN21@SetMoveSta:
  000fc	89 45 fc	 mov	 DWORD PTR tv145[ebp], eax
  000ff	d9 5c 24 04	 fstp	 DWORD PTR [esp+4]
  00103	db 45 fc	 fild	 DWORD PTR tv145[ebp]
  00106	85 c0		 test	 eax, eax
  00108	79 06		 jns	 SHORT $LN22@SetMoveSta
  0010a	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN22@SetMoveSta:
  00110	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00113	d9 1c 24	 fstp	 DWORD PTR [esp]
  00116	57		 push	 edi
  00117	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetLoopAni@ioEntityGroup@@QAE_NHMMMM@Z
$LN3@SetMoveSta:

; 276  : 		}
; 277  : 	}
; 278  : 
; 279  : 	if( m_DummyCharType == DCT_RUSH )

  0011d	83 be 2c 02 00
	00 10		 cmp	 DWORD PTR [esi+556], 16	; 00000010H
  00124	5f		 pop	 edi
  00125	75 07		 jne	 SHORT $LN1@SetMoveSta

; 280  : 		SetAttachWeapon();

  00127	8b ce		 mov	 ecx, esi
  00129	e8 00 00 00 00	 call	 ?SetAttachWeapon@ioDummyChar@@IAEXXZ ; ioDummyChar::SetAttachWeapon
$LN1@SetMoveSta:
  0012e	5e		 pop	 esi
  0012f	5b		 pop	 ebx

; 281  : }

  00130	c9		 leave
  00131	c3		 ret	 0
?SetMoveState@ioRaptorDummy@@UAEXXZ ENDP		; ioRaptorDummy::SetMoveState
_TEXT	ENDS
PUBLIC	?SetMoveStateMid@ioRaptorDummy@@QAEXXZ		; ioRaptorDummy::SetMoveStateMid
EXTRN	__imp_?SetLoopAniInMid@ioEntityGroup@@QAE_NHMMMM@Z:PROC
EXTRN	__imp_?GetCurTime@ioAnimation@@QBEMXZ:PROC
EXTRN	__imp_?GetLoopInPlay@ioEntityGroup@@QAEPAVioAnimation@@H@Z:PROC
EXTRN	__imp_?ClearAllLoopAniExceptOne@ioEntityGroup@@QAE_NHM_N@Z:PROC
EXTRN	__ftol2:PROC
; Function compile flags: /Ogsp
;	COMDAT ?SetMoveStateMid@ioRaptorDummy@@QAEXXZ
_TEXT	SEGMENT
tv246 = -4						; size = 4
tv241 = -4						; size = 4
tv227 = -4						; size = 4
tv86 = -4						; size = 4
tv77 = -4						; size = 4
tv71 = -4						; size = 4
_fAniRate$661536 = -4					; size = 4
?SetMoveStateMid@ioRaptorDummy@@QAEXXZ PROC		; ioRaptorDummy::SetMoveStateMid, COMDAT
; _this$ = ecx

; 284  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 285  : 	ioBaseChar *pOwner = GetOwner();

  00008	e8 00 00 00 00	 call	 ?GetOwner@ioDummyChar@@QBEPAVioBaseChar@@XZ ; ioDummyChar::GetOwner
  0000d	8b d8		 mov	 ebx, eax

; 286  : 	if( !pOwner ) return;

  0000f	85 db		 test	 ebx, ebx
  00011	0f 84 2e 01 00
	00		 je	 $LN3@SetMoveSta@2

; 287  : 
; 288  : 	if( m_State != DCS_MOVE )

  00017	83 be 30 02 00
	00 03		 cmp	 DWORD PTR [esi+560], 3
  0001e	0f 85 21 01 00
	00		 jne	 $LN3@SetMoveSta@2

; 289  : 		return;
; 290  : 
; 291  : 	if( !m_MoveAnimation.IsEmpty() )

  00024	57		 push	 edi
  00025	8d be bc 06 00
	00		 lea	 edi, DWORD PTR [esi+1724]
  0002b	8b cf		 mov	 ecx, edi
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00033	84 c0		 test	 al, al
  00035	0f 85 09 01 00
	00		 jne	 $LN19@SetMoveSta@2

; 292  : 	{
; 293  : 		int iAniID = m_pGroup->GetAnimationIdx( m_MoveAnimation );

  0003b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0003e	57		 push	 edi
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetAnimationIdx@ioEntityGroup@@QAEHABVioHashString@@@Z
  00045	8b f8		 mov	 edi, eax

; 294  : 		if( iAniID != -1 )

  00047	83 ff ff	 cmp	 edi, -1
  0004a	0f 84 f4 00 00
	00		 je	 $LN19@SetMoveSta@2

; 295  : 		{
; 296  : 			m_pGroup->ClearAllActionAni( FLOAT100, true );

  00050	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  00055	89 45 fc	 mov	 DWORD PTR tv246[ebp], eax
  00058	db 45 fc	 fild	 DWORD PTR tv246[ebp]
  0005b	6a 01		 push	 1
  0005d	85 c0		 test	 eax, eax
  0005f	79 06		 jns	 SHORT $LN20@SetMoveSta@2
  00061	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN20@SetMoveSta@2:
  00067	51		 push	 ecx
  00068	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0006b	d9 1c 24	 fstp	 DWORD PTR [esp]
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ClearAllActionAni@ioEntityGroup@@QAEXM_N@Z

; 297  : 			m_pGroup->ClearAllLoopAniExceptOne( iAniID, FLOAT100, true );

  00074	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  00079	89 45 fc	 mov	 DWORD PTR tv241[ebp], eax
  0007c	db 45 fc	 fild	 DWORD PTR tv241[ebp]
  0007f	6a 01		 push	 1
  00081	85 c0		 test	 eax, eax
  00083	79 06		 jns	 SHORT $LN21@SetMoveSta@2
  00085	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN21@SetMoveSta@2:
  0008b	51		 push	 ecx
  0008c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0008f	d9 1c 24	 fstp	 DWORD PTR [esp]
  00092	57		 push	 edi
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ClearAllLoopAniExceptOne@ioEntityGroup@@QAE_NHM_N@Z

; 298  : 
; 299  : 			float fAniRate = pOwner->GetRunDashAniRate();

  00099	8b cb		 mov	 ecx, ebx
  0009b	e8 00 00 00 00	 call	 ?GetRunDashAniRate@ioBaseChar@@QBEMXZ ; ioBaseChar::GetRunDashAniRate
  000a0	d9 5d fc	 fstp	 DWORD PTR _fAniRate$661536[ebp]

; 300  : 			if( fAniRate <= 0.0f )

  000a3	d9 45 fc	 fld	 DWORD PTR _fAniRate$661536[ebp]
  000a6	d9 ee		 fldz
  000a8	df f1		 fcomip	 ST(1)
  000aa	dd d8		 fstp	 ST(0)
  000ac	72 18		 jb	 SHORT $LN2@SetMoveSta@2

; 301  : 				fAniRate = FLOAT1;

  000ae	b8 01 00 00 00	 mov	 eax, 1
  000b3	89 45 fc	 mov	 DWORD PTR tv227[ebp], eax
  000b6	db 45 fc	 fild	 DWORD PTR tv227[ebp]
  000b9	85 c0		 test	 eax, eax
  000bb	79 06		 jns	 SHORT $LN22@SetMoveSta@2
  000bd	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN22@SetMoveSta@2:
  000c3	d9 5d fc	 fstp	 DWORD PTR _fAniRate$661536[ebp]
$LN2@SetMoveSta@2:

; 302  : 
; 303  : 			DWORD dwPlayTime = 0;
; 304  : 			ioAnimation *pAni = m_pGroup->GetLoopInPlay( iAniID );

  000c6	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000c9	57		 push	 edi
  000ca	33 db		 xor	 ebx, ebx
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopInPlay@ioEntityGroup@@QAEPAVioAnimation@@H@Z

; 305  : 			if( pAni ) 

  000d2	85 c0		 test	 eax, eax
  000d4	74 0f		 je	 SHORT $LN1@SetMoveSta@2

; 306  : 				dwPlayTime = pAni->GetCurTime();

  000d6	8b c8		 mov	 ecx, eax
  000d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetCurTime@ioAnimation@@QBEMXZ
  000de	e8 00 00 00 00	 call	 __ftol2
  000e3	8b d8		 mov	 ebx, eax
$LN1@SetMoveSta@2:

; 307  : 
; 308  : 			m_pGroup->SetLoopAniInMid( iAniID, dwPlayTime, FLOAT100, FLOAT1, fAniRate );

  000e5	b8 01 00 00 00	 mov	 eax, 1
  000ea	8b c8		 mov	 ecx, eax
  000ec	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  000f1	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fAniRate$661536[ebp]
  000f6	83 ec 10	 sub	 esp, 16			; 00000010H
  000f9	89 4d fc	 mov	 DWORD PTR tv86[ebp], ecx
  000fc	db 45 fc	 fild	 DWORD PTR tv86[ebp]
  000ff	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  00105	85 c9		 test	 ecx, ecx
  00107	79 06		 jns	 SHORT $LN23@SetMoveSta@2
  00109	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN23@SetMoveSta@2:
  0010f	89 45 fc	 mov	 DWORD PTR tv77[ebp], eax
  00112	d9 5c 24 08	 fstp	 DWORD PTR [esp+8]
  00116	db 45 fc	 fild	 DWORD PTR tv77[ebp]
  00119	85 c0		 test	 eax, eax
  0011b	79 06		 jns	 SHORT $LN24@SetMoveSta@2
  0011d	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN24@SetMoveSta@2:
  00123	89 5d fc	 mov	 DWORD PTR tv71[ebp], ebx
  00126	d9 5c 24 04	 fstp	 DWORD PTR [esp+4]
  0012a	db 45 fc	 fild	 DWORD PTR tv71[ebp]
  0012d	85 db		 test	 ebx, ebx
  0012f	79 06		 jns	 SHORT $LN25@SetMoveSta@2
  00131	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN25@SetMoveSta@2:
  00137	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0013a	d9 1c 24	 fstp	 DWORD PTR [esp]
  0013d	57		 push	 edi
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetLoopAniInMid@ioEntityGroup@@QAE_NHMMMM@Z
$LN19@SetMoveSta@2:
  00144	5f		 pop	 edi
$LN3@SetMoveSta@2:
  00145	5e		 pop	 esi
  00146	5b		 pop	 ebx

; 309  : 		}
; 310  : 	}
; 311  : }

  00147	c9		 leave
  00148	c3		 ret	 0
?SetMoveStateMid@ioRaptorDummy@@QAEXXZ ENDP		; ioRaptorDummy::SetMoveStateMid
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?SetDashState@ioRaptorDummy@@UAEXXZ
_TEXT	SEGMENT
tv244 = -4						; size = 4
tv239 = -4						; size = 4
tv225 = -4						; size = 4
tv147 = -4						; size = 4
tv145 = -4						; size = 4
_fAniRate$661554 = -4					; size = 4
?SetDashState@ioRaptorDummy@@UAEXXZ PROC		; ioRaptorDummy::SetDashState, COMDAT
; _this$ = ecx

; 314  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 315  : 	ioBaseChar *pOwner = GetOwner();

  00008	e8 00 00 00 00	 call	 ?GetOwner@ioDummyChar@@QBEPAVioBaseChar@@XZ ; ioDummyChar::GetOwner
  0000d	8b d8		 mov	 ebx, eax

; 316  : 	if( !pOwner ) return;

  0000f	85 db		 test	 ebx, ebx
  00011	0f 84 17 01 00
	00		 je	 $LN1@SetDashSta

; 317  : 
; 318  : 	m_State = DCS_DASH;
; 319  : 
; 320  : 	CheckChargeWeaponDead();

  00017	57		 push	 edi
  00018	8b ce		 mov	 ecx, esi
  0001a	c7 86 30 02 00
	00 04 00 00 00	 mov	 DWORD PTR [esi+560], 4
  00024	e8 00 00 00 00	 call	 ?CheckChargeWeaponDead@ioDummyChar@@IAEXXZ ; ioDummyChar::CheckChargeWeaponDead

; 321  : 
; 322  : 	if( !m_DashAnimation.IsEmpty() )

  00029	8d be d0 06 00
	00		 lea	 edi, DWORD PTR [esi+1744]
  0002f	8b cf		 mov	 ecx, edi
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00037	84 c0		 test	 al, al
  00039	0f 85 de 00 00
	00		 jne	 $LN3@SetDashSta

; 323  : 	{
; 324  : 		int iAniID = m_pGroup->GetAnimationIdx( m_DashAnimation );

  0003f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00042	57		 push	 edi
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetAnimationIdx@ioEntityGroup@@QAEHABVioHashString@@@Z
  00049	8b f8		 mov	 edi, eax

; 325  : 		if( iAniID != -1 )

  0004b	83 ff ff	 cmp	 edi, -1
  0004e	0f 84 c9 00 00
	00		 je	 $LN3@SetDashSta

; 326  : 		{
; 327  : 			m_pGroup->ClearAllActionAni( FLOAT100, true );

  00054	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  00059	89 45 fc	 mov	 DWORD PTR tv244[ebp], eax
  0005c	db 45 fc	 fild	 DWORD PTR tv244[ebp]
  0005f	6a 01		 push	 1
  00061	85 c0		 test	 eax, eax
  00063	79 06		 jns	 SHORT $LN18@SetDashSta
  00065	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN18@SetDashSta:
  0006b	51		 push	 ecx
  0006c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0006f	d9 1c 24	 fstp	 DWORD PTR [esp]
  00072	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ClearAllActionAni@ioEntityGroup@@QAEXM_N@Z

; 328  : 			m_pGroup->ClearAllLoopAni( FLOAT100, true );

  00078	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  0007d	89 45 fc	 mov	 DWORD PTR tv239[ebp], eax
  00080	db 45 fc	 fild	 DWORD PTR tv239[ebp]
  00083	6a 01		 push	 1
  00085	85 c0		 test	 eax, eax
  00087	79 06		 jns	 SHORT $LN19@SetDashSta
  00089	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN19@SetDashSta:
  0008f	51		 push	 ecx
  00090	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00093	d9 1c 24	 fstp	 DWORD PTR [esp]
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ClearAllLoopAni@ioEntityGroup@@QAEXM_N@Z

; 329  : 
; 330  : 			float fAniRate = pOwner->GetRunDashAniRate();

  0009c	8b cb		 mov	 ecx, ebx
  0009e	e8 00 00 00 00	 call	 ?GetRunDashAniRate@ioBaseChar@@QBEMXZ ; ioBaseChar::GetRunDashAniRate
  000a3	d9 5d fc	 fstp	 DWORD PTR _fAniRate$661554[ebp]

; 331  : 			if( fAniRate <= 0.0f )

  000a6	d9 45 fc	 fld	 DWORD PTR _fAniRate$661554[ebp]
  000a9	d9 ee		 fldz
  000ab	df f1		 fcomip	 ST(1)
  000ad	dd d8		 fstp	 ST(0)
  000af	72 18		 jb	 SHORT $LN2@SetDashSta

; 332  : 				fAniRate = FLOAT1;

  000b1	b8 01 00 00 00	 mov	 eax, 1
  000b6	89 45 fc	 mov	 DWORD PTR tv225[ebp], eax
  000b9	db 45 fc	 fild	 DWORD PTR tv225[ebp]
  000bc	85 c0		 test	 eax, eax
  000be	79 06		 jns	 SHORT $LN20@SetDashSta
  000c0	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN20@SetDashSta:
  000c6	d9 5d fc	 fstp	 DWORD PTR _fAniRate$661554[ebp]
$LN2@SetDashSta:

; 333  : 
; 334  : 			m_pGroup->SetLoopAni( iAniID, FLOAT100, FLOAT1, fAniRate );

  000c9	b8 01 00 00 00	 mov	 eax, 1
  000ce	8b c8		 mov	 ecx, eax
  000d0	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  000d5	0f 57 c0	 xorps	 xmm0, xmm0
  000d8	83 ec 10	 sub	 esp, 16			; 00000010H
  000db	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  000e1	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fAniRate$661554[ebp]
  000e6	89 4d fc	 mov	 DWORD PTR tv147[ebp], ecx
  000e9	db 45 fc	 fild	 DWORD PTR tv147[ebp]
  000ec	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  000f2	85 c9		 test	 ecx, ecx
  000f4	79 06		 jns	 SHORT $LN21@SetDashSta
  000f6	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN21@SetDashSta:
  000fc	89 45 fc	 mov	 DWORD PTR tv145[ebp], eax
  000ff	d9 5c 24 04	 fstp	 DWORD PTR [esp+4]
  00103	db 45 fc	 fild	 DWORD PTR tv145[ebp]
  00106	85 c0		 test	 eax, eax
  00108	79 06		 jns	 SHORT $LN22@SetDashSta
  0010a	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN22@SetDashSta:
  00110	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00113	d9 1c 24	 fstp	 DWORD PTR [esp]
  00116	57		 push	 edi
  00117	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetLoopAni@ioEntityGroup@@QAE_NHMMMM@Z
$LN3@SetDashSta:

; 335  : 		}
; 336  : 	}
; 337  : 
; 338  : 	if( m_DummyCharType == DCT_RUSH )

  0011d	83 be 2c 02 00
	00 10		 cmp	 DWORD PTR [esi+556], 16	; 00000010H
  00124	5f		 pop	 edi
  00125	75 07		 jne	 SHORT $LN1@SetDashSta

; 339  : 		SetAttachWeapon();

  00127	8b ce		 mov	 ecx, esi
  00129	e8 00 00 00 00	 call	 ?SetAttachWeapon@ioDummyChar@@IAEXXZ ; ioDummyChar::SetAttachWeapon
$LN1@SetDashSta:
  0012e	5e		 pop	 esi
  0012f	5b		 pop	 ebx

; 340  : }

  00130	c9		 leave
  00131	c3		 ret	 0
?SetDashState@ioRaptorDummy@@UAEXXZ ENDP		; ioRaptorDummy::SetDashState
_TEXT	ENDS
PUBLIC	?SetDashStateMid@ioRaptorDummy@@QAEXXZ		; ioRaptorDummy::SetDashStateMid
; Function compile flags: /Ogsp
;	COMDAT ?SetDashStateMid@ioRaptorDummy@@QAEXXZ
_TEXT	SEGMENT
tv246 = -4						; size = 4
tv241 = -4						; size = 4
tv227 = -4						; size = 4
tv86 = -4						; size = 4
tv77 = -4						; size = 4
tv71 = -4						; size = 4
_fAniRate$661571 = -4					; size = 4
?SetDashStateMid@ioRaptorDummy@@QAEXXZ PROC		; ioRaptorDummy::SetDashStateMid, COMDAT
; _this$ = ecx

; 343  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 344  : 	ioBaseChar *pOwner = GetOwner();

  00008	e8 00 00 00 00	 call	 ?GetOwner@ioDummyChar@@QBEPAVioBaseChar@@XZ ; ioDummyChar::GetOwner
  0000d	8b d8		 mov	 ebx, eax

; 345  : 	if( !pOwner ) return;

  0000f	85 db		 test	 ebx, ebx
  00011	0f 84 2e 01 00
	00		 je	 $LN3@SetDashSta@2

; 346  : 
; 347  : 	if( m_State != DCS_DASH )

  00017	83 be 30 02 00
	00 04		 cmp	 DWORD PTR [esi+560], 4
  0001e	0f 85 21 01 00
	00		 jne	 $LN3@SetDashSta@2

; 348  : 		return;
; 349  : 
; 350  : 	if( !m_DashAnimation.IsEmpty() )

  00024	57		 push	 edi
  00025	8d be d0 06 00
	00		 lea	 edi, DWORD PTR [esi+1744]
  0002b	8b cf		 mov	 ecx, edi
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00033	84 c0		 test	 al, al
  00035	0f 85 09 01 00
	00		 jne	 $LN19@SetDashSta@2

; 351  : 	{
; 352  : 		int iAniID = m_pGroup->GetAnimationIdx( m_DashAnimation );

  0003b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0003e	57		 push	 edi
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetAnimationIdx@ioEntityGroup@@QAEHABVioHashString@@@Z
  00045	8b f8		 mov	 edi, eax

; 353  : 		if( iAniID != -1 )

  00047	83 ff ff	 cmp	 edi, -1
  0004a	0f 84 f4 00 00
	00		 je	 $LN19@SetDashSta@2

; 354  : 		{
; 355  : 			m_pGroup->ClearAllActionAni( FLOAT100, true );

  00050	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  00055	89 45 fc	 mov	 DWORD PTR tv246[ebp], eax
  00058	db 45 fc	 fild	 DWORD PTR tv246[ebp]
  0005b	6a 01		 push	 1
  0005d	85 c0		 test	 eax, eax
  0005f	79 06		 jns	 SHORT $LN20@SetDashSta@2
  00061	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN20@SetDashSta@2:
  00067	51		 push	 ecx
  00068	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0006b	d9 1c 24	 fstp	 DWORD PTR [esp]
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ClearAllActionAni@ioEntityGroup@@QAEXM_N@Z

; 356  : 			m_pGroup->ClearAllLoopAniExceptOne( iAniID, FLOAT100, true );

  00074	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  00079	89 45 fc	 mov	 DWORD PTR tv241[ebp], eax
  0007c	db 45 fc	 fild	 DWORD PTR tv241[ebp]
  0007f	6a 01		 push	 1
  00081	85 c0		 test	 eax, eax
  00083	79 06		 jns	 SHORT $LN21@SetDashSta@2
  00085	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN21@SetDashSta@2:
  0008b	51		 push	 ecx
  0008c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0008f	d9 1c 24	 fstp	 DWORD PTR [esp]
  00092	57		 push	 edi
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ClearAllLoopAniExceptOne@ioEntityGroup@@QAE_NHM_N@Z

; 357  : 
; 358  : 			float fAniRate = pOwner->GetRunDashAniRate();

  00099	8b cb		 mov	 ecx, ebx
  0009b	e8 00 00 00 00	 call	 ?GetRunDashAniRate@ioBaseChar@@QBEMXZ ; ioBaseChar::GetRunDashAniRate
  000a0	d9 5d fc	 fstp	 DWORD PTR _fAniRate$661571[ebp]

; 359  : 			if( fAniRate <= 0.0f )

  000a3	d9 45 fc	 fld	 DWORD PTR _fAniRate$661571[ebp]
  000a6	d9 ee		 fldz
  000a8	df f1		 fcomip	 ST(1)
  000aa	dd d8		 fstp	 ST(0)
  000ac	72 18		 jb	 SHORT $LN2@SetDashSta@2

; 360  : 				fAniRate = FLOAT1;

  000ae	b8 01 00 00 00	 mov	 eax, 1
  000b3	89 45 fc	 mov	 DWORD PTR tv227[ebp], eax
  000b6	db 45 fc	 fild	 DWORD PTR tv227[ebp]
  000b9	85 c0		 test	 eax, eax
  000bb	79 06		 jns	 SHORT $LN22@SetDashSta@2
  000bd	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN22@SetDashSta@2:
  000c3	d9 5d fc	 fstp	 DWORD PTR _fAniRate$661571[ebp]
$LN2@SetDashSta@2:

; 361  : 
; 362  : 			DWORD dwPlayTime = 0;
; 363  : 			ioAnimation *pAni = m_pGroup->GetLoopInPlay( iAniID );

  000c6	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000c9	57		 push	 edi
  000ca	33 db		 xor	 ebx, ebx
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopInPlay@ioEntityGroup@@QAEPAVioAnimation@@H@Z

; 364  : 			if( pAni ) 

  000d2	85 c0		 test	 eax, eax
  000d4	74 0f		 je	 SHORT $LN1@SetDashSta@2

; 365  : 				dwPlayTime = pAni->GetCurTime();

  000d6	8b c8		 mov	 ecx, eax
  000d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetCurTime@ioAnimation@@QBEMXZ
  000de	e8 00 00 00 00	 call	 __ftol2
  000e3	8b d8		 mov	 ebx, eax
$LN1@SetDashSta@2:

; 366  : 
; 367  : 			m_pGroup->SetLoopAniInMid( iAniID, dwPlayTime, FLOAT100, FLOAT1, fAniRate );

  000e5	b8 01 00 00 00	 mov	 eax, 1
  000ea	8b c8		 mov	 ecx, eax
  000ec	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  000f1	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fAniRate$661571[ebp]
  000f6	83 ec 10	 sub	 esp, 16			; 00000010H
  000f9	89 4d fc	 mov	 DWORD PTR tv86[ebp], ecx
  000fc	db 45 fc	 fild	 DWORD PTR tv86[ebp]
  000ff	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  00105	85 c9		 test	 ecx, ecx
  00107	79 06		 jns	 SHORT $LN23@SetDashSta@2
  00109	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN23@SetDashSta@2:
  0010f	89 45 fc	 mov	 DWORD PTR tv77[ebp], eax
  00112	d9 5c 24 08	 fstp	 DWORD PTR [esp+8]
  00116	db 45 fc	 fild	 DWORD PTR tv77[ebp]
  00119	85 c0		 test	 eax, eax
  0011b	79 06		 jns	 SHORT $LN24@SetDashSta@2
  0011d	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN24@SetDashSta@2:
  00123	89 5d fc	 mov	 DWORD PTR tv71[ebp], ebx
  00126	d9 5c 24 04	 fstp	 DWORD PTR [esp+4]
  0012a	db 45 fc	 fild	 DWORD PTR tv71[ebp]
  0012d	85 db		 test	 ebx, ebx
  0012f	79 06		 jns	 SHORT $LN25@SetDashSta@2
  00131	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN25@SetDashSta@2:
  00137	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0013a	d9 1c 24	 fstp	 DWORD PTR [esp]
  0013d	57		 push	 edi
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetLoopAniInMid@ioEntityGroup@@QAE_NHMMMM@Z
$LN19@SetDashSta@2:
  00144	5f		 pop	 edi
$LN3@SetDashSta@2:
  00145	5e		 pop	 esi
  00146	5b		 pop	 ebx

; 368  : 		}
; 369  : 	}
; 370  : }

  00147	c9		 leave
  00148	c3		 ret	 0
?SetDashStateMid@ioRaptorDummy@@QAEXXZ ENDP		; ioRaptorDummy::SetDashStateMid
_TEXT	ENDS
PUBLIC	?_Nextnode@?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@2@PAU342@@Z ; std::_List_val<FireTime,std::allocator<FireTime> >::_Nextnode
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ?_Nextnode@?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@2@PAU342@@Z PROC ; std::_List_val<FireTime,std::allocator<FireTime> >::_Nextnode, COMDAT

; 560  : 		{	// return reference to successor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 561  : 		return ((_Nodepref)(*_Pnode)._Next);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 562  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Nextnode@?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@2@PAU342@@Z ENDP ; std::_List_val<FireTime,std::allocator<FireTime> >::_Nextnode
_TEXT	ENDS
PUBLIC	?_Prevnode@?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@2@PAU342@@Z ; std::_List_val<FireTime,std::allocator<FireTime> >::_Prevnode
; Function compile flags: /Ogsp
;	COMDAT ?_Prevnode@?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@2@PAU342@@Z PROC ; std::_List_val<FireTime,std::allocator<FireTime> >::_Prevnode, COMDAT

; 565  : 		{	// return reference to predecessor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 566  : 		return ((_Nodepref)(*_Pnode)._Prev);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 567  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Prevnode@?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@2@PAU342@@Z ENDP ; std::_List_val<FireTime,std::allocator<FireTime> >::_Prevnode
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@2@I@Z ; std::allocator<std::_List_nod<FireTime,std::allocator<FireTime> >::_Node>::deallocate
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@2@I@Z PROC ; std::allocator<std::_List_nod<FireTime,std::allocator<FireTime> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 183  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<FireTime,std::allocator<FireTime> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??E?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >::operator++
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >::operator++, COMDAT
; _this$ = ecx

; 221  : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 222  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 223  : 		if (this->_Getcont() == 0
; 224  : 			|| this->_Ptr == 0
; 225  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 226  : 			{	// report error
; 227  : 			_DEBUG_ERROR("list iterator not incrementable");
; 228  : 			_SCL_SECURE_OUT_OF_RANGE;
; 229  : 			}
; 230  : 
; 231  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 232  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 233  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 234  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 235  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 236  : 
; 237  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 238  : 		return (*this);
; 239  : 		}

  00008	c3		 ret	 0
??E?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >::operator++
_TEXT	ENDS
PUBLIC	??E?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_List_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >::operator++
; Function compile flags: /Ogsp
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_List_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >::operator++, COMDAT
; _this$ = ecx

; 242  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 243  : 		_Myiter _Tmp = *this;

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx

; 244  : 		++*this;

  0000a	8b 12		 mov	 edx, DWORD PTR [edx]
  0000c	89 11		 mov	 DWORD PTR [ecx], edx

; 245  : 		return (_Tmp);
; 246  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
??E?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_List_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >::operator++
_TEXT	ENDS
PUBLIC	??8?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >::operator==
; Function compile flags: /Ogsp
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >::operator==, COMDAT
; _this$ = ecx

; 281  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 282  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 283  : 		if (this->_Getcont() == 0
; 284  : 			|| this->_Getcont() != _Right._Getcont())
; 285  : 			{	// report error
; 286  : 			_DEBUG_ERROR("list iterators incompatible");
; 287  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 288  : 			}
; 289  : 
; 290  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 291  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 292  : 			&& this->_Getcont() == _Right._Getcont());
; 293  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 294  : 
; 295  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	f7 d8		 neg	 eax
  0000c	1b c0		 sbb	 eax, eax
  0000e	40		 inc	 eax

; 296  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@2@XZ ; std::_List_unchecked_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> >,std::_Iterator_base0>::_Mynode
; Function compile flags: /Ogsp
;	COMDAT ?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@2@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 93   : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 94   : 		}

  00002	c3		 ret	 0
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@2@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
PUBLIC	?_Myval@?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@SAAAUFireTime@@PAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@2@@Z ; std::_List_val<FireTime,std::allocator<FireTime> >::_Myval
; Function compile flags: /Ogsp
;	COMDAT ?_Myval@?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@SAAAUFireTime@@PAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@SAAAUFireTime@@PAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@2@@Z PROC ; std::_List_val<FireTime,std::allocator<FireTime> >::_Myval, COMDAT

; 570  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 571  : 		return ((reference)(*_Pnode)._Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 572  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@SAAAUFireTime@@PAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@2@@Z ENDP ; std::_List_val<FireTime,std::allocator<FireTime> >::_Myval
_TEXT	ENDS
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@1@PBV?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> >,std::_Iterator_base0>
; Function compile flags: /Ogsp
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@1@PBV?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@1@PBV?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 41   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 42   : 		this->_Adopt(_Plist);
; 43   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_unchecked_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@1@PBV?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	??1FireTime@@QAE@XZ				; FireTime::~FireTime
EXTRN	__imp_??1ioHashString@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__EH_epilog3:PROC
EXTRN	__EH_prolog3:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1FireTime@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1FireTime@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1FireTime@@QAE@XZ$1
__ehfuncinfo$??1FireTime@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1FireTime@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??1FireTime@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1FireTime@@QAE@XZ PROC				; FireTime::~FireTime, COMDAT
; _this$ = ecx
  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??1FireTime@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f9		 mov	 edi, ecx
  0000e	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  00011	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00017	8d 4f 44	 lea	 ecx, DWORD PTR [edi+68]
  0001a	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00021	ff d6		 call	 esi
  00023	8d 4f 30	 lea	 ecx, DWORD PTR [edi+48]
  00026	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0002a	ff d6		 call	 esi
  0002c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00030	8d 4f 14	 lea	 ecx, DWORD PTR [edi+20]
  00033	ff d6		 call	 esi
  00035	e8 00 00 00 00	 call	 __EH_epilog3
  0003a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1FireTime@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 14	 add	 ecx, 20			; 00000014H
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$??1FireTime@@QAE@XZ$1:
  0000c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 30	 add	 ecx, 48			; 00000030H
  00012	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$??1FireTime@@QAE@XZ:
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1FireTime@@QAE@XZ
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1FireTime@@QAE@XZ ENDP				; FireTime::~FireTime
; Function compile flags: /Odsp
;	COMDAT ??_EioRaptorDummy@@WBMI@AEPAXI@Z
_TEXT	SEGMENT
??_EioRaptorDummy@@WBMI@AEPAXI@Z PROC			; [thunk]:ioRaptorDummy::`vector deleting destructor', COMDAT
  00000	81 e9 c8 01 00
	00		 sub	 ecx, 456		; 000001c8H
  00006	e9 00 00 00 00	 jmp	 ??_EioRaptorDummy@@UAEPAXI@Z
??_EioRaptorDummy@@WBMI@AEPAXI@Z ENDP			; [thunk]:ioRaptorDummy::`vector deleting destructor'
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iodummychar.h
_TEXT	ENDS
;	COMDAT ?IsDummyCharMidSync@ioDummyChar@@UAE_NXZ
_TEXT	SEGMENT
?IsDummyCharMidSync@ioDummyChar@@UAE_NXZ PROC		; ioDummyChar::IsDummyCharMidSync, COMDAT
; _this$ = ecx

; 742  : 	virtual bool IsDummyCharMidSync(){ return false; }

  00000	32 c0		 xor	 al, al
  00002	c3		 ret	 0
?IsDummyCharMidSync@ioDummyChar@@UAE_NXZ ENDP		; ioDummyChar::IsDummyCharMidSync
_TEXT	ENDS
PUBLIC	?EncryptValueToPool@?$CEncrypt@W4TeamType@@@@AAEXPBD@Z ; CEncrypt<enum TeamType>::EncryptValueToPool
EXTRN	?EncryptByte@ccddaabb@@QAEXPBDPADH@Z:PROC	; ccddaabb::EncryptByte
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
;	COMDAT ?EncryptValueToPool@?$CEncrypt@W4TeamType@@@@AAEXPBD@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?EncryptValueToPool@?$CEncrypt@W4TeamType@@@@AAEXPBD@Z PROC ; CEncrypt<enum TeamType>::EncryptValueToPool, COMDAT
; _this$ = ecx

; 67   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 		m_RC5.EncryptByte( value, m_MemPool, max(m_ValueSize, DEFAULT_ENCRYPT) );

  00003	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00007	83 f8 04	 cmp	 eax, 4
  0000a	77 03		 ja	 SHORT $LN4@EncryptVal
  0000c	6a 04		 push	 4
  0000e	58		 pop	 eax
$LN4@EncryptVal:
  0000f	50		 push	 eax
  00010	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  00013	50		 push	 eax
  00014	ff 75 08	 push	 DWORD PTR _value$[ebp]
  00017	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0001a	e8 00 00 00 00	 call	 ?EncryptByte@ccddaabb@@QAEXPBDPADH@Z ; ccddaabb::EncryptByte

; 69   : 		
; 70   : 	}

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?EncryptValueToPool@?$CEncrypt@W4TeamType@@@@AAEXPBD@Z ENDP ; CEncrypt<enum TeamType>::EncryptValueToPool
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??_GioRaptorDummy@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GioRaptorDummy@@UAEPAXI@Z PROC			; ioRaptorDummy::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1ioRaptorDummy@@UAE@XZ ; ioRaptorDummy::~ioRaptorDummy
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 07		 je	 SHORT $LN1@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	59		 pop	 ecx
$LN1@scalar:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??_GioRaptorDummy@@UAEPAXI@Z ENDP			; ioRaptorDummy::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??E?$_List_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >::operator++
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ??E?$_List_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >::operator++, COMDAT
; _this$ = ecx

; 369  : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 370  : 		++(*(_Mybase *)this);

  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 371  : 		return (*this);
; 372  : 		}

  00008	c3		 ret	 0
??E?$_List_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >::operator++
_TEXT	ENDS
PUBLIC	??9?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >::operator!=
; Function compile flags: /Ogsp
;	COMDAT ??9?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >::operator!=, COMDAT
; _this$ = ecx

; 299  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 300  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 301  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QBEABUFireTime@@XZ ; std::_List_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >::operator*
; Function compile flags: /Ogsp
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QBEABUFireTime@@XZ
_TEXT	SEGMENT
??D?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QBEABUFireTime@@XZ PROC ; std::_List_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >::operator*, COMDAT
; _this$ = ecx

; 202  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 203  : 		if (this->_Getcont() == 0
; 204  : 			|| this->_Ptr == 0
; 205  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 206  : 			{	// report error
; 207  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 208  : 			_SCL_SECURE_OUT_OF_RANGE;
; 209  : 			}
; 210  : 
; 211  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 212  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 213  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 214  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 215  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 216  : 
; 217  : 		return (_Mylist::_Myval(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 218  : 		}

  00005	c3		 ret	 0
??D?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QBEABUFireTime@@XZ ENDP ; std::_List_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >::operator*
_TEXT	ENDS
PUBLIC	??0?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@1@PBV?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >::_List_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@1@PBV?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@1@PBV?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >::_List_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >, COMDAT
; _this$ = ecx

; 184  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 185  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@1@PBV?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >::_List_const_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >
_TEXT	ENDS
PUBLIC	??1_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@QAE@XZ ; std::_List_nod<FireTime,std::allocator<FireTime> >::_Node::~_Node
; Function compile flags: /Ogsp
;	COMDAT ??1_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@QAE@XZ PROC ; std::_List_nod<FireTime,std::allocator<FireTime> >::_Node::~_Node, COMDAT
; _this$ = ecx
  00000	83 c1 08	 add	 ecx, 8
  00003	e9 00 00 00 00	 jmp	 ??1FireTime@@QAE@XZ
??1_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@QAE@XZ ENDP ; std::_List_nod<FireTime,std::allocator<FireTime> >::_Node::~_Node
_TEXT	ENDS
PUBLIC	??4?$CEncrypt@W4TeamType@@@@QAE?AW4TeamType@@W41@@Z ; CEncrypt<enum TeamType>::operator=
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
;	COMDAT ??4?$CEncrypt@W4TeamType@@@@QAE?AW4TeamType@@W41@@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
_inValue$ = 8						; size = 4
??4?$CEncrypt@W4TeamType@@@@QAE?AW4TeamType@@W41@@Z PROC ; CEncrypt<enum TeamType>::operator=, COMDAT
; _this$ = ecx

; 2965 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2966 : 		type value = inValue;

  00003	8b 45 08	 mov	 eax, DWORD PTR _inValue$[ebp]
  00006	89 45 08	 mov	 DWORD PTR _value$[ebp], eax

; 2967 : 		EncryptValueToPool((char*)&value);

  00009	8d 45 08	 lea	 eax, DWORD PTR _value$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@W4TeamType@@@@AAEXPBD@Z ; CEncrypt<enum TeamType>::EncryptValueToPool

; 2968 : #ifdef _NOTUSE
; 2969 : 		m_value = inValue;
; 2970 : 		Debug();
; 2971 : #endif
; 2972 : 		return value;

  00012	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]

; 2973 : 	}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??4?$CEncrypt@W4TeamType@@@@QAE?AW4TeamType@@W41@@Z ENDP ; CEncrypt<enum TeamType>::operator=
_TEXT	ENDS
PUBLIC	??D?$_List_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QBEAAUFireTime@@XZ ; std::_List_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >::operator*
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ??D?$_List_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QBEAAUFireTime@@XZ
_TEXT	SEGMENT
??D?$_List_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QBEAAUFireTime@@XZ PROC ; std::_List_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >::operator*, COMDAT
; _this$ = ecx

; 360  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 361  : 		}

  00005	c3		 ret	 0
??D?$_List_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QBEAAUFireTime@@XZ ENDP ; std::_List_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >::operator*
_TEXT	ENDS
PUBLIC	??0?$_List_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@1@PBV?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >::_List_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_List_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@1@PBV?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@1@PBV?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >::_List_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >, COMDAT
; _this$ = ecx

; 342  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 343  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@1@PBV?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >::_List_iterator<std::_List_val<FireTime,std::allocator<FireTime> > >
_TEXT	ENDS
PUBLIC	??_G_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@QAEPAXI@Z ; std::_List_nod<FireTime,std::allocator<FireTime> >::_Node::`scalar deleting destructor'
; Function compile flags: /Ogsp
;	COMDAT ??_G_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@QAEPAXI@Z PROC ; std::_List_nod<FireTime,std::allocator<FireTime> >::_Node::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00009	e8 00 00 00 00	 call	 ??1FireTime@@QAE@XZ
  0000e	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00012	74 07		 je	 SHORT $LN1@scalar@2
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001a	59		 pop	 ecx
$LN1@scalar@2:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_G_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@QAEPAXI@Z ENDP ; std::_List_nod<FireTime,std::allocator<FireTime> >::_Node::`scalar deleting destructor'
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioplayentity.h
_TEXT	ENDS
;	COMDAT ?SetTeam@ioPlayEntity@@UAEXW4TeamType@@@Z
_TEXT	SEGMENT
_value$665133 = 8					; size = 4
_eType$ = 8						; size = 4
?SetTeam@ioPlayEntity@@UAEXW4TeamType@@@Z PROC		; ioPlayEntity::SetTeam, COMDAT
; _this$ = ecx

; 106  : 	virtual void SetTeam( TeamType eType ) { m_TeamType = eType; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _eType$[ebp]
  00006	89 45 08	 mov	 DWORD PTR _value$665133[ebp], eax
  00009	8d 45 08	 lea	 eax, DWORD PTR _value$665133[ebp]
  0000c	50		 push	 eax
  0000d	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  00013	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@W4TeamType@@@@AAEXPBD@Z ; CEncrypt<enum TeamType>::EncryptValueToPool
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?SetTeam@ioPlayEntity@@UAEXW4TeamType@@@Z ENDP		; ioPlayEntity::SetTeam
_TEXT	ENDS
PUBLIC	?begin@?$list@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@2@XZ ; std::list<FireTime,std::allocator<FireTime> >::begin
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ?begin@?$list@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@2@XZ PROC ; std::list<FireTime,std::allocator<FireTime> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 782  : 		return (iterator(this->_Nextnode(this->_Myhead), this));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 783  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?begin@?$list@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@2@XZ ENDP ; std::list<FireTime,std::allocator<FireTime> >::begin
_TEXT	ENDS
PUBLIC	?end@?$list@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@2@XZ ; std::list<FireTime,std::allocator<FireTime> >::end
; Function compile flags: /Ogsp
;	COMDAT ?end@?$list@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@2@XZ PROC ; std::list<FireTime,std::allocator<FireTime> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 792  : 		return (iterator(this->_Myhead, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 793  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?end@?$list@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@2@XZ ENDP ; std::list<FireTime,std::allocator<FireTime> >::end
_TEXT	ENDS
PUBLIC	?_Make_iter@?$list@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@2@@Z ; std::list<FireTime,std::allocator<FireTime> >::_Make_iter
; Function compile flags: /Ogsp
;	COMDAT ?_Make_iter@?$list@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$list@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@2@@Z PROC ; std::list<FireTime,std::allocator<FireTime> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 		return (iterator(_Where._Ptr, this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 803  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?_Make_iter@?$list@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@2@@Z ENDP ; std::list<FireTime,std::allocator<FireTime> >::_Make_iter
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<FireTime,std::allocator<FireTime> >::_Node>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@0@@Z PROC ; std::_Destroy<std::_List_nod<FireTime,std::allocator<FireTime> >::_Node>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 63   : 	_Ptr->~_Ty();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	83 c1 08	 add	 ecx, 8

; 64   : 	}

  00009	5d		 pop	 ebp

; 63   : 	_Ptr->~_Ty();

  0000a	e9 00 00 00 00	 jmp	 ??1FireTime@@QAE@XZ
??$_Destroy@U_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<FireTime,std::allocator<FireTime> >::_Node>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@2@@Z ; std::allocator<std::_List_nod<FireTime,std::allocator<FireTime> >::_Node>::destroy
; Function compile flags: /Ogsp
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@2@@Z PROC ; std::allocator<std::_List_nod<FireTime,std::allocator<FireTime> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 213  : 		_Destroy(_Ptr);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	83 c1 08	 add	 ecx, 8
  00009	e8 00 00 00 00	 call	 ??1FireTime@@QAE@XZ

; 214  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?destroy@?$allocator@U_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<FireTime,std::allocator<FireTime> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@U_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@U_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@2@@std@@YAXAAV?$allocator@U_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@0@PAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@0@@Z ; std::_Dest_val<std::allocator<std::_List_nod<FireTime,std::allocator<FireTime> >::_Node>,std::_List_nod<FireTime,std::allocator<FireTime> >::_Node>
; Function compile flags: /Ogsp
;	COMDAT ??$_Dest_val@V?$allocator@U_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@U_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@2@@std@@YAXAAV?$allocator@U_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@0@PAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@U_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@U_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@2@@std@@YAXAAV?$allocator@U_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@0@PAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@0@@Z PROC ; std::_Dest_val<std::allocator<std::_List_nod<FireTime,std::allocator<FireTime> >::_Node>,std::_List_nod<FireTime,std::allocator<FireTime> >::_Node>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 287  : 	_Alval.destroy(_Pdest);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00006	83 c1 08	 add	 ecx, 8

; 288  : 	}

  00009	5d		 pop	 ebp

; 287  : 	_Alval.destroy(_Pdest);

  0000a	e9 00 00 00 00	 jmp	 ??1FireTime@@QAE@XZ
??$_Dest_val@V?$allocator@U_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@std@@U_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@2@@std@@YAXAAV?$allocator@U_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@0@PAU_Node@?$_List_nod@UFireTime@@V?$allocator@UFireTime@@@std@@@0@@Z ENDP ; std::_Dest_val<std::allocator<std::_List_nod<FireTime,std::allocator<FireTime> >::_Node>,std::_List_nod<FireTime,std::allocator<FireTime> >::_Node>
_TEXT	ENDS
PUBLIC	?erase@?$list@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@2@@Z ; std::list<FireTime,std::allocator<FireTime> >::erase
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ?erase@?$list@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$list@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@2@@Z PROC ; std::list<FireTime,std::allocator<FireTime> >::erase, COMDAT
; _this$ = ecx

; 1054 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1055 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1056 : 		if (_Where._Getcont() != this || _Where._Ptr == this->_Myhead)
; 1057 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1058 : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 1059 : 		_Orphan_ptr(*this, _Pnode);
; 1060 : 
; 1061 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1062 : 		_Nodeptr _Pnode = (_Where++)._Mynode();

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Where$[ebp]
  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	89 45 0c	 mov	 DWORD PTR __Where$[ebp], eax

; 1063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1064 : 
; 1065 : 		if (_Pnode != this->_Myhead)

  0000f	3b 37		 cmp	 esi, DWORD PTR [edi]
  00011	74 21		 je	 SHORT $LN1@erase

; 1066 : 			{	// not list head, safe to erase
; 1067 : 			this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1068 : 				this->_Nextnode(_Pnode);

  00013	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00016	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00018	89 08		 mov	 DWORD PTR [eax], ecx

; 1069 : 			this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1070 : 				this->_Prevnode(_Pnode);

  0001a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001d	8b 06		 mov	 eax, DWORD PTR [esi]
  0001f	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1071 : 
; 1072 : 			_Dest_val(this->_Alnod, _Pnode);

  00022	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00025	e8 00 00 00 00	 call	 ??1FireTime@@QAE@XZ

; 1073 : 			this->_Alnod.deallocate(_Pnode, 1);

  0002a	56		 push	 esi
  0002b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1074 : 
; 1075 : 			--this->_Mysize;

  00030	ff 4f 04	 dec	 DWORD PTR [edi+4]
  00033	59		 pop	 ecx
$LN1@erase:

; 1076 : 			}
; 1077 : 		return (_Make_iter(_Where));

  00034	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  0003a	5f		 pop	 edi
  0003b	89 08		 mov	 DWORD PTR [eax], ecx
  0003d	5e		 pop	 esi

; 1078 : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 08 00	 ret	 8
?erase@?$list@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@2@@Z ENDP ; std::list<FireTime,std::allocator<FireTime> >::erase
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
EXTRN	?SetZoneValue@ioZoneEffectWeapon@@QAEX_N0@Z:PROC ; ioZoneEffectWeapon::SetZoneValue
EXTRN	?SetCollisionDir@ioZoneEffectWeapon@@QAEXAAUD3DXVECTOR3@@@Z:PROC ; ioZoneEffectWeapon::SetCollisionDir
EXTRN	?GetOwner@ioWeapon@@QBEPAVioBaseChar@@XZ:PROC	; ioWeapon::GetOwner
EXTRN	?SetPosition@ioWeapon@@QAEXABUD3DXVECTOR3@@@Z:PROC ; ioWeapon::SetPosition
EXTRN	?ExtendFireExplicit@ioBaseChar@@QAEPAVioWeapon@@ABUFireTime@@ABUD3DXVECTOR3@@1ABVioHashString@@@Z:PROC ; ioBaseChar::ExtendFireExplicit
EXTRN	__imp_??0ioHashString@@QAE@PBD@Z:PROC
EXTRN	?GetMidPositionByRate@ioGameEntity@@QBE?AUD3DXVECTOR3@@M@Z:PROC ; ioGameEntity::GetMidPositionByRate
EXTRN	_D3DXVec3Normalize@8:PROC
EXTRN	__imp_??D@YA?AUD3DXVECTOR3@@ABUD3DXQUATERNION@@ABU0@@Z:PROC
EXTRN	__EH_epilog3_GS:PROC
EXTRN	__EH_prolog3_GS:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ProcessAttackState@ioRaptorDummy@@MAEXMK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessAttackState@ioRaptorDummy@@MAEXMK@Z$0
__ehfuncinfo$?ProcessAttackState@ioRaptorDummy@@MAEXMK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ProcessAttackState@ioRaptorDummy@@MAEXMK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioraptordummy.cpp
xdata$x	ENDS
;	COMDAT ?ProcessAttackState@ioRaptorDummy@@MAEXMK@Z
_TEXT	SEGMENT
$T665408 = -108						; size = 16
$T665410 = -92						; size = 4
_pOwner$ = -88						; size = 4
_dwCurTime$ = -84					; size = 4
tv598 = -80						; size = 4
tv588 = -80						; size = 4
tv583 = -80						; size = 4
tv579 = -80						; size = 4
tv568 = -80						; size = 4
tv564 = -80						; size = 4
tv560 = -80						; size = 4
tv549 = -80						; size = 4
_vDir$661500 = -76					; size = 12
$T661495 = -64						; size = 12
$T661502 = -52						; size = 12
$T661325 = -52						; size = 12
_vCurPos$ = -40						; size = 12
_vCurDir$ = -28						; size = 12
__$EHRec$ = -12						; size = 12
_fTimePerSec$ = 8					; size = 4
_dwPreTime$ = 12					; size = 4
?ProcessAttackState@ioRaptorDummy@@MAEXMK@Z PROC	; ioRaptorDummy::ProcessAttackState, COMDAT
; _this$ = ecx

; 178  : {

  00000	6a 60		 push	 96			; 00000060H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?ProcessAttackState@ioRaptorDummy@@MAEXMK@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000c	8b f1		 mov	 esi, ecx

; 179  : 	ioBaseChar *pOwner = GetOwner();

  0000e	e8 00 00 00 00	 call	 ?GetOwner@ioDummyChar@@QBEPAVioBaseChar@@XZ ; ioDummyChar::GetOwner
  00013	8b f8		 mov	 edi, eax

; 180  : 	if( !pOwner ) return;

  00015	33 db		 xor	 ebx, ebx
  00017	89 7d a8	 mov	 DWORD PTR _pOwner$[ebp], edi
  0001a	3b fb		 cmp	 edi, ebx
  0001c	0f 84 5b 02 00
	00		 je	 $LN2@ProcessAtt

; 181  : 
; 182  : 	if( !pOwner->IsObejctEquipState() )

  00022	6a 0a		 push	 10			; 0000000aH
  00024	8b cf		 mov	 ecx, edi
  00026	e8 00 00 00 00	 call	 ?IsObejctEquipState@ioBaseChar@@QAE_NW4ObjectEqipState@@@Z ; ioBaseChar::IsObejctEquipState
  0002b	84 c0		 test	 al, al
  0002d	75 12		 jne	 SHORT $LN14@ProcessAtt

; 183  : 	{
; 184  : 		SetDieState( true );

  0002f	8b 06		 mov	 eax, DWORD PTR [esi]
  00031	53		 push	 ebx
  00032	6a 01		 push	 1
  00034	8b ce		 mov	 ecx, esi
  00036	ff 90 1c 01 00
	00		 call	 DWORD PTR [eax+284]

; 185  : 		return;

  0003c	e9 3c 02 00 00	 jmp	 $LN2@ProcessAtt
$LN14@ProcessAtt:

; 186  : 	}
; 187  : 
; 188  : 	if( pOwner->GetState() == CS_DELAY || pOwner->GetState() == CS_DROP_ZONE_DOWN )

  00041	8a 87 10 03 00
	00		 mov	 al, BYTE PTR [edi+784]
  00047	84 c0		 test	 al, al
  00049	0f 84 23 02 00
	00		 je	 $LN12@ProcessAtt
  0004f	3c 10		 cmp	 al, 16			; 00000010H
  00051	0f 84 1b 02 00
	00		 je	 $LN12@ProcessAtt

; 191  : 		return;
; 192  : 	}
; 193  : 
; 194  : 	if( CheckEnableAttackState() )

  00057	8b ce		 mov	 ecx, esi
  00059	e8 00 00 00 00	 call	 ?CheckEnableAttackState@ioDummyChar@@QAE_NXZ ; ioDummyChar::CheckEnableAttackState
  0005e	84 c0		 test	 al, al
  00060	74 15		 je	 SHORT $LN11@ProcessAtt

; 195  : 	{
; 196  : 		SetAttackState();

  00062	8b 06		 mov	 eax, DWORD PTR [esi]
  00064	8b ce		 mov	 ecx, esi
  00066	ff 90 24 01 00
	00		 call	 DWORD PTR [eax+292]

; 197  : 		m_iReserveAttackCode = 0;

  0006c	89 9e 74 05 00
	00		 mov	 DWORD PTR [esi+1396], ebx

; 198  : 		return;

  00072	e9 06 02 00 00	 jmp	 $LN2@ProcessAtt
$LN11@ProcessAtt:

; 199  : 	}
; 200  : 
; 201  : 	DWORD dwCurTime = FRAMEGETTIME();

  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  0007d	8b c8		 mov	 ecx, eax
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ
  00085	89 45 ac	 mov	 DWORD PTR _dwCurTime$[ebp], eax

; 202  : 
; 203  : 	D3DXVECTOR3 vCurDir = GetWorldOrientation() * D3DXVECTOR3( 0.0f, 0.0f, -FLOAT1 );

  00088	b8 01 00 00 00	 mov	 eax, 1
  0008d	0f 57 c0	 xorps	 xmm0, xmm0
  00090	89 45 b0	 mov	 DWORD PTR tv598[ebp], eax
  00093	db 45 b0	 fild	 DWORD PTR tv598[ebp]
  00096	f3 0f 11 45 cc	 movss	 DWORD PTR $T661325[ebp], xmm0
  0009b	f3 0f 11 45 d0	 movss	 DWORD PTR $T661325[ebp+4], xmm0
  000a0	85 c0		 test	 eax, eax
  000a2	79 06		 jns	 SHORT $LN79@ProcessAtt
  000a4	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN79@ProcessAtt:
  000aa	8d 45 cc	 lea	 eax, DWORD PTR $T661325[ebp]
  000ad	d9 e0		 fchs
  000af	50		 push	 eax
  000b0	d9 5d d4	 fstp	 DWORD PTR $T661325[ebp+8]
  000b3	8b 06		 mov	 eax, DWORD PTR [esi]
  000b5	8b ce		 mov	 ecx, esi
  000b7	ff 50 74	 call	 DWORD PTR [eax+116]
  000ba	50		 push	 eax
  000bb	8d 45 e4	 lea	 eax, DWORD PTR _vCurDir$[ebp]
  000be	50		 push	 eax
  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??D@YA?AUD3DXVECTOR3@@ABUD3DXQUATERNION@@ABU0@@Z
  000c5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 204  : 	D3DXVec3Normalize( &vCurDir, &vCurDir );

  000c8	8d 45 e4	 lea	 eax, DWORD PTR _vCurDir$[ebp]
  000cb	50		 push	 eax
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8

; 205  : 
; 206  : 	D3DXVECTOR3 vCurPos = GetMidPositionByRate();

  000d2	b8 05 00 00 00	 mov	 eax, 5
  000d7	8b c8		 mov	 ecx, eax
  000d9	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  000de	89 4d b0	 mov	 DWORD PTR tv588[ebp], ecx
  000e1	db 45 b0	 fild	 DWORD PTR tv588[ebp]
  000e4	85 c9		 test	 ecx, ecx
  000e6	79 06		 jns	 SHORT $LN80@ProcessAtt
  000e8	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN80@ProcessAtt:
  000ee	89 45 b0	 mov	 DWORD PTR tv583[ebp], eax
  000f1	db 45 b0	 fild	 DWORD PTR tv583[ebp]
  000f4	85 c0		 test	 eax, eax
  000f6	79 06		 jns	 SHORT $LN81@ProcessAtt
  000f8	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN81@ProcessAtt:
  000fe	de f9		 fdivp	 ST(1), ST(0)
  00100	51		 push	 ecx
  00101	8d 45 d8	 lea	 eax, DWORD PTR _vCurPos$[ebp]
  00104	8b ce		 mov	 ecx, esi
  00106	d9 5d b0	 fstp	 DWORD PTR tv579[ebp]
  00109	d9 45 b0	 fld	 DWORD PTR tv579[ebp]
  0010c	d9 1c 24	 fstp	 DWORD PTR [esp]
  0010f	50		 push	 eax
  00110	e8 00 00 00 00	 call	 ?GetMidPositionByRate@ioGameEntity@@QBE?AUD3DXVECTOR3@@M@Z ; ioGameEntity::GetMidPositionByRate

; 207  : 
; 208  : 	DWORD dwLastFireTime = dwPreTime;
; 209  : 	FireTimeList::iterator iter = m_vAttackFireTimeList.begin();

  00115	8b 86 78 05 00
	00		 mov	 eax, DWORD PTR [esi+1400]
  0011b	8b 38		 mov	 edi, DWORD PTR [eax]

; 210  : 	while( iter != m_vAttackFireTimeList.end() )

  0011d	3b f8		 cmp	 edi, eax
  0011f	0f 84 3a 01 00
	00		 je	 $LN9@ProcessAtt
$LL10@ProcessAtt:

; 211  : 	{
; 212  : 		const FireTime &rkFire = *iter;

  00125	8d 5f 08	 lea	 ebx, DWORD PTR [edi+8]

; 213  : 
; 214  : 		DWORD dwFireTime = rkFire.dwStart;

  00128	8b 03		 mov	 eax, DWORD PTR [ebx]

; 215  : 		if( COMPARE( dwFireTime, dwPreTime, dwCurTime ) )

  0012a	3b 45 0c	 cmp	 eax, DWORD PTR _dwPreTime$[ebp]
  0012d	0f 82 1e 01 00
	00		 jb	 $LN8@ProcessAtt
  00133	3b 45 ac	 cmp	 eax, DWORD PTR _dwCurTime$[ebp]
  00136	0f 83 15 01 00
	00		 jae	 $LN8@ProcessAtt

; 216  : 		{
; 217  : 			if( rkFire.iAttributeIdx != NO_WEAPON_ATTRIBUTE )

  0013c	83 7b 08 00	 cmp	 DWORD PTR [ebx+8], 0
  00140	0f 84 f7 00 00
	00		 je	 $LN4@ProcessAtt

; 218  : 			{
; 219  : 				ioWeapon *pWeapon = pOwner->ExtendFireExplicit( rkFire, vCurPos, vCurDir, "" );

  00146	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0014b	8d 4d 94	 lea	 ecx, DWORD PTR $T665408[ebp]
  0014e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  00154	8b 4d a8	 mov	 ecx, DWORD PTR _pOwner$[ebp]
  00157	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0015b	8d 45 94	 lea	 eax, DWORD PTR $T665408[ebp]
  0015e	50		 push	 eax
  0015f	8d 45 e4	 lea	 eax, DWORD PTR _vCurDir$[ebp]
  00162	50		 push	 eax
  00163	8d 45 d8	 lea	 eax, DWORD PTR _vCurPos$[ebp]
  00166	50		 push	 eax
  00167	53		 push	 ebx
  00168	e8 00 00 00 00	 call	 ?ExtendFireExplicit@ioBaseChar@@QAEPAVioWeapon@@ABUFireTime@@ABUD3DXVECTOR3@@1ABVioHashString@@@Z ; ioBaseChar::ExtendFireExplicit
  0016d	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00171	8d 4d 94	 lea	 ecx, DWORD PTR $T665408[ebp]
  00174	8b d8		 mov	 ebx, eax
  00176	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ

; 220  : 				if( pWeapon )

  0017c	85 db		 test	 ebx, ebx
  0017e	0f 84 b9 00 00
	00		 je	 $LN4@ProcessAtt

; 221  : 				{
; 222  : 					pWeapon->SetPosition( GetMidPositionByRate() );

  00184	b8 05 00 00 00	 mov	 eax, 5
  00189	8b c8		 mov	 ecx, eax
  0018b	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  00190	89 4d b0	 mov	 DWORD PTR tv568[ebp], ecx
  00193	db 45 b0	 fild	 DWORD PTR tv568[ebp]
  00196	85 c9		 test	 ecx, ecx
  00198	79 06		 jns	 SHORT $LN82@ProcessAtt
  0019a	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN82@ProcessAtt:
  001a0	89 45 b0	 mov	 DWORD PTR tv564[ebp], eax
  001a3	db 45 b0	 fild	 DWORD PTR tv564[ebp]
  001a6	85 c0		 test	 eax, eax
  001a8	79 06		 jns	 SHORT $LN83@ProcessAtt
  001aa	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN83@ProcessAtt:
  001b0	de f9		 fdivp	 ST(1), ST(0)
  001b2	51		 push	 ecx
  001b3	8d 45 c0	 lea	 eax, DWORD PTR $T661495[ebp]
  001b6	8b ce		 mov	 ecx, esi
  001b8	d9 5d b0	 fstp	 DWORD PTR tv560[ebp]
  001bb	d9 45 b0	 fld	 DWORD PTR tv560[ebp]
  001be	d9 1c 24	 fstp	 DWORD PTR [esp]
  001c1	50		 push	 eax
  001c2	e8 00 00 00 00	 call	 ?GetMidPositionByRate@ioGameEntity@@QBE?AUD3DXVECTOR3@@M@Z ; ioGameEntity::GetMidPositionByRate
  001c7	50		 push	 eax
  001c8	8b cb		 mov	 ecx, ebx
  001ca	e8 00 00 00 00	 call	 ?SetPosition@ioWeapon@@QAEXABUD3DXVECTOR3@@@Z ; ioWeapon::SetPosition

; 223  : 
; 224  : 					ioZoneEffectWeapon *pZone = ToZoneEffectWeapon( pWeapon );

  001cf	53		 push	 ebx
  001d0	e8 00 00 00 00	 call	 ?ToZoneEffectWeapon@@YAPAVioZoneEffectWeapon@@PAVioWeapon@@@Z ; ToZoneEffectWeapon
  001d5	8b d8		 mov	 ebx, eax
  001d7	59		 pop	 ecx

; 225  : 					if( pZone )

  001d8	85 db		 test	 ebx, ebx
  001da	74 61		 je	 SHORT $LN4@ProcessAtt

; 226  : 					{
; 227  : 						ioBaseChar *pChar = pZone->GetOwner();

  001dc	8b cb		 mov	 ecx, ebx
  001de	e8 00 00 00 00	 call	 ?GetOwner@ioWeapon@@QBEPAVioBaseChar@@XZ ; ioWeapon::GetOwner

; 228  : 						if( pChar )

  001e3	85 c0		 test	 eax, eax
  001e5	74 56		 je	 SHORT $LN4@ProcessAtt

; 229  : 						{
; 230  : 							D3DXVECTOR3 vDir = GetWorldOrientation() * D3DXVECTOR3( 0.0f, 0.0f, -FLOAT1 );

  001e7	b8 01 00 00 00	 mov	 eax, 1
  001ec	0f 57 c0	 xorps	 xmm0, xmm0
  001ef	89 45 b0	 mov	 DWORD PTR tv549[ebp], eax
  001f2	db 45 b0	 fild	 DWORD PTR tv549[ebp]
  001f5	f3 0f 11 45 cc	 movss	 DWORD PTR $T661502[ebp], xmm0
  001fa	f3 0f 11 45 d0	 movss	 DWORD PTR $T661502[ebp+4], xmm0
  001ff	85 c0		 test	 eax, eax
  00201	79 06		 jns	 SHORT $LN84@ProcessAtt
  00203	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN84@ProcessAtt:
  00209	8d 45 cc	 lea	 eax, DWORD PTR $T661502[ebp]
  0020c	d9 e0		 fchs
  0020e	50		 push	 eax
  0020f	d9 5d d4	 fstp	 DWORD PTR $T661502[ebp+8]
  00212	8b 06		 mov	 eax, DWORD PTR [esi]
  00214	8b ce		 mov	 ecx, esi
  00216	ff 50 74	 call	 DWORD PTR [eax+116]
  00219	50		 push	 eax
  0021a	8d 45 b4	 lea	 eax, DWORD PTR _vDir$661500[ebp]
  0021d	50		 push	 eax
  0021e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??D@YA?AUD3DXVECTOR3@@ABUD3DXQUATERNION@@ABU0@@Z
  00224	83 c4 0c	 add	 esp, 12			; 0000000cH

; 231  : 							pZone->SetCollisionDir( vDir );

  00227	8d 45 b4	 lea	 eax, DWORD PTR _vDir$661500[ebp]
  0022a	50		 push	 eax
  0022b	8b cb		 mov	 ecx, ebx
  0022d	e8 00 00 00 00	 call	 ?SetCollisionDir@ioZoneEffectWeapon@@QAEXAAUD3DXVECTOR3@@@Z ; ioZoneEffectWeapon::SetCollisionDir

; 232  : 							pZone->SetZoneValue( true, false );

  00232	6a 00		 push	 0
  00234	6a 01		 push	 1
  00236	8b cb		 mov	 ecx, ebx
  00238	e8 00 00 00 00	 call	 ?SetZoneValue@ioZoneEffectWeapon@@QAEX_N0@Z ; ioZoneEffectWeapon::SetZoneValue
$LN4@ProcessAtt:

; 233  : 						}
; 234  : 					}
; 235  : 				}
; 236  : 			}
; 237  : 
; 238  : 			iter = m_vAttackFireTimeList.erase( iter );

  0023d	57		 push	 edi
  0023e	8d 45 a4	 lea	 eax, DWORD PTR $T665410[ebp]
  00241	50		 push	 eax
  00242	8d 8e 78 05 00
	00		 lea	 ecx, DWORD PTR [esi+1400]
  00248	e8 00 00 00 00	 call	 ?erase@?$list@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@UFireTime@@V?$allocator@UFireTime@@@std@@@std@@@2@@Z ; std::list<FireTime,std::allocator<FireTime> >::erase
  0024d	8b 38		 mov	 edi, DWORD PTR [eax]

; 239  : 		}
; 240  : 		else

  0024f	eb 02		 jmp	 SHORT $LN73@ProcessAtt
$LN8@ProcessAtt:

; 241  : 		{
; 242  : 			++iter;

  00251	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN73@ProcessAtt:

; 210  : 	while( iter != m_vAttackFireTimeList.end() )

  00253	3b be 78 05 00
	00		 cmp	 edi, DWORD PTR [esi+1400]
  00259	0f 85 c6 fe ff
	ff		 jne	 $LL10@ProcessAtt
$LN9@ProcessAtt:

; 243  : 		}
; 244  : 	}
; 245  : 
; 246  : 	//
; 247  : 	if( m_dwAttackAniEndTime == 0 || m_dwAttackAniEndTime < dwCurTime )

  0025f	8b 86 e8 06 00
	00		 mov	 eax, DWORD PTR [esi+1768]
  00265	85 c0		 test	 eax, eax
  00267	74 05		 je	 SHORT $LN1@ProcessAtt
  00269	3b 45 ac	 cmp	 eax, DWORD PTR _dwCurTime$[ebp]
  0026c	73 0f		 jae	 SHORT $LN2@ProcessAtt
$LN1@ProcessAtt:

; 248  : 	{
; 249  : 		SetDelayState( false );

  0026e	6a 00		 push	 0

; 250  : 		return;

  00270	eb 01		 jmp	 SHORT $LN85@ProcessAtt
$LN12@ProcessAtt:

; 189  : 	{
; 190  : 		SetDelayState( false );

  00272	53		 push	 ebx
$LN85@ProcessAtt:
  00273	8b 06		 mov	 eax, DWORD PTR [esi]
  00275	8b ce		 mov	 ecx, esi
  00277	ff 90 14 01 00
	00		 call	 DWORD PTR [eax+276]
$LN2@ProcessAtt:

; 251  : 	}
; 252  : }

  0027d	e8 00 00 00 00	 call	 __EH_epilog3_GS
  00282	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ProcessAttackState@ioRaptorDummy@@MAEXMK@Z$0:
  00000	8d 4d 94	 lea	 ecx, DWORD PTR $T665408[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$?ProcessAttackState@ioRaptorDummy@@MAEXMK@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a 90	 mov	 ecx, DWORD PTR [edx-112]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ProcessAttackState@ioRaptorDummy@@MAEXMK@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ProcessAttackState@ioRaptorDummy@@MAEXMK@Z ENDP	; ioRaptorDummy::ProcessAttackState
END
