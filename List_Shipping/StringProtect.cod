; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\Lost Saga For Developer\Youtube\Tutorial\Source\src\LSClient\StringProtect.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_szResultData$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?EncryptDecryptData@SP@@YAXPADHPBDH@Z		; SP::EncryptDecryptData
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stringprotect.cpp
;	COMDAT ?EncryptDecryptData@SP@@YAXPADHPBDH@Z
_TEXT	SEGMENT
tv299 = -48						; size = 4
_szResultData$GSCopy$ = -44				; size = 4
tv287 = -40						; size = 4
_byKey$ = -36						; size = 30
__$ArrayPad$ = -4					; size = 4
_szResultData$ = 8					; size = 4
_iResultSize$ = 12					; size = 4
_szSourceData$ = 16					; size = 4
_iSourceSize$ = 20					; size = 4
?EncryptDecryptData@SP@@YAXPADHPBDH@Z PROC		; SP::EncryptDecryptData, COMDAT

; 10   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 11   : 		enum { MAX_KEY = 30, };
; 12   : 		BYTE byKey[MAX_KEY]={ 100,30,50,70,80,90,30,145,255,139,212,134,6,7,121,143,23,24,24,52,16,19,19,131,113,214,222,228,229,235};
; 13   : 
; 14   : 		for(int i =0; i < iSourceSize; i++)

  00010	8b 45 14	 mov	 eax, DWORD PTR _iSourceSize$[ebp]
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _szResultData$[ebp]
  00016	56		 push	 esi
  00017	33 f6		 xor	 esi, esi

; 17   : 			szResultData[i] = szSourceData[i] ^ byKey[i%MAX_KEY];

  00019	89 4d d4	 mov	 DWORD PTR _szResultData$GSCopy$[ebp], ecx
  0001c	c7 45 dc 64 1e
	32 46		 mov	 DWORD PTR _byKey$[ebp], 1177689700 ; 46321e64H
  00023	c7 45 e0 50 5a
	1e 91		 mov	 DWORD PTR _byKey$[ebp+4], -1860281776 ; 911e5a50H
  0002a	c7 45 e4 ff 8b
	d4 86		 mov	 DWORD PTR _byKey$[ebp+8], -2032890881 ; 86d48bffH
  00031	c7 45 e8 06 07
	79 8f		 mov	 DWORD PTR _byKey$[ebp+12], -1887893754 ; 8f790706H
  00038	c7 45 ec 17 18
	18 34		 mov	 DWORD PTR _byKey$[ebp+16], 873994263 ; 34181817H
  0003f	c7 45 f0 10 13
	13 83		 mov	 DWORD PTR _byKey$[ebp+20], -2095901936 ; 83131310H
  00046	c7 45 f4 71 d6
	de e4		 mov	 DWORD PTR _byKey$[ebp+24], -455158159 ; e4ded671H
  0004d	66 c7 45 f8 e5
	eb		 mov	 WORD PTR _byKey$[ebp+28], 60389 ; 0000ebe5H
  00053	85 c0		 test	 eax, eax
  00055	7e 47		 jle	 SHORT $LN8@EncryptDec

; 18   : 			szResultData[i] = szResultData[i] ^ byKey[(iSourceSize-i)%MAX_KEY];

  00057	89 45 d8	 mov	 DWORD PTR tv287[ebp], eax
  0005a	8b 45 10	 mov	 eax, DWORD PTR _szSourceData$[ebp]
  0005d	53		 push	 ebx
  0005e	2b c1		 sub	 eax, ecx
  00060	57		 push	 edi
  00061	89 45 d0	 mov	 DWORD PTR tv299[ebp], eax
  00064	eb 03		 jmp	 SHORT $LN4@EncryptDec
$LL10@EncryptDec:

; 11   : 		enum { MAX_KEY = 30, };
; 12   : 		BYTE byKey[MAX_KEY]={ 100,30,50,70,80,90,30,145,255,139,212,134,6,7,121,143,23,24,24,52,16,19,19,131,113,214,222,228,229,235};
; 13   : 
; 14   : 		for(int i =0; i < iSourceSize; i++)

  00066	8b 4d d4	 mov	 ecx, DWORD PTR _szResultData$GSCopy$[ebp]
$LN4@EncryptDec:

; 15   : 		{
; 16   : 			if( i >= iResultSize ) break;

  00069	3b 75 0c	 cmp	 esi, DWORD PTR _iResultSize$[ebp]
  0006c	7d 2e		 jge	 SHORT $LN11@EncryptDec

; 18   : 			szResultData[i] = szResultData[i] ^ byKey[(iSourceSize-i)%MAX_KEY];

  0006e	8b 45 d8	 mov	 eax, DWORD PTR tv287[ebp]
  00071	99		 cdq
  00072	6a 1e		 push	 30			; 0000001eH
  00074	5f		 pop	 edi
  00075	f7 ff		 idiv	 edi
  00077	8b c6		 mov	 eax, esi
  00079	6a 1e		 push	 30			; 0000001eH
  0007b	5b		 pop	 ebx
  0007c	03 ce		 add	 ecx, esi
  0007e	8b fa		 mov	 edi, edx
  00080	99		 cdq
  00081	f7 fb		 idiv	 ebx
  00083	8a 44 3d dc	 mov	 al, BYTE PTR _byKey$[ebp+edi]
  00087	32 44 15 dc	 xor	 al, BYTE PTR _byKey$[ebp+edx]
  0008b	8b 55 d0	 mov	 edx, DWORD PTR tv299[ebp]
  0008e	32 04 0a	 xor	 al, BYTE PTR [edx+ecx]
  00091	46		 inc	 esi
  00092	ff 4d d8	 dec	 DWORD PTR tv287[ebp]
  00095	88 01		 mov	 BYTE PTR [ecx], al
  00097	3b 75 14	 cmp	 esi, DWORD PTR _iSourceSize$[ebp]
  0009a	7c ca		 jl	 SHORT $LL10@EncryptDec
$LN11@EncryptDec:
  0009c	5f		 pop	 edi
  0009d	5b		 pop	 ebx
$LN8@EncryptDec:

; 19   : 		}
; 20   : 	}

  0009e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a1	33 cd		 xor	 ecx, ebp
  000a3	5e		 pop	 esi
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	c9		 leave
  000aa	c3		 ret	 0
?EncryptDecryptData@SP@@YAXPADHPBDH@Z ENDP		; SP::EncryptDecryptData
_TEXT	ENDS
PUBLIC	_szPlain$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?Decode@SP@@YAXPBDHPADH@Z			; SP::Decode
EXTRN	__imp__strtol:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogsp
;	COMDAT ?Decode@SP@@YAXPBDHPADH@Z
_TEXT	SEGMENT
_stopstring$505252 = -540				; size = 4
_szPlain$GSCopy$ = -536					; size = 4
_pos$ = -532						; size = 4
_i$505247 = -528					; size = 4
_szTempOneHex$505251 = -524				; size = 260
_szCharCipher$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_szCipher$ = 8						; size = 4
_iCipherSize$ = 12					; size = 4
_szPlain$ = 16						; size = 4
_iPlainSize$ = 20					; size = 4
?Decode@SP@@YAXPBDHPADH@Z PROC				; SP::Decode, COMDAT

; 23   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 1c 02 00
	00		 sub	 esp, 540		; 0000021cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 10	 mov	 eax, DWORD PTR _szPlain$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 08	 mov	 ebx, DWORD PTR _szCipher$[ebp]
  0001a	56		 push	 esi
  0001b	57		 push	 edi

; 24   : 		char szCharCipher[MAX_PATH]="";

  0001c	bf 03 01 00 00	 mov	 edi, 259		; 00000103H
  00021	57		 push	 edi

; 25   : 		int  iCharChipherSize = iCipherSize/2;
; 26   : 		// 16진수 -> char
; 27   : 		int pos = 0;

  00022	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _szPlain$GSCopy$[ebp], eax
  00028	8d 85 f9 fe ff
	ff		 lea	 eax, DWORD PTR _szCharCipher$[ebp+1]
  0002e	6a 00		 push	 0
  00030	50		 push	 eax
  00031	c6 85 f8 fe ff
	ff 00		 mov	 BYTE PTR _szCharCipher$[ebp], 0
  00038	e8 00 00 00 00	 call	 _memset
  0003d	8b 45 0c	 mov	 eax, DWORD PTR _iCipherSize$[ebp]
  00040	83 a5 ec fd ff
	ff 00		 and	 DWORD PTR _pos$[ebp], 0

; 28   : 		for(int i = 0; i < iCharChipherSize; i++)

  00047	83 a5 f0 fd ff
	ff 00		 and	 DWORD PTR _i$505247[ebp], 0
  0004e	99		 cdq
  0004f	2b c2		 sub	 eax, edx
  00051	8b f0		 mov	 esi, eax
  00053	d1 fe		 sar	 esi, 1
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH
  00058	85 f6		 test	 esi, esi
  0005a	7e 78		 jle	 SHORT $LN9@Decode
$LL12@Decode:

; 29   : 		{
; 30   : 			char szTempOneHex[MAX_PATH]="";

  0005c	57		 push	 edi
  0005d	8d 85 f5 fd ff
	ff		 lea	 eax, DWORD PTR _szTempOneHex$505251[ebp+1]
  00063	6a 00		 push	 0
  00065	50		 push	 eax
  00066	c6 85 f4 fd ff
	ff 00		 mov	 BYTE PTR _szTempOneHex$505251[ebp], 0
  0006d	e8 00 00 00 00	 call	 _memset

; 31   : 			char *stopstring;
; 32   : 			if( pos >= iCipherSize )

  00072	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _pos$[ebp]
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007b	3b 45 0c	 cmp	 eax, DWORD PTR _iCipherSize$[ebp]
  0007e	7d 54		 jge	 SHORT $LN9@Decode

; 33   : 				break;
; 34   : 			memcpy(szTempOneHex, &szCipher[pos], 2);

  00080	66 8b 0c 03	 mov	 cx, WORD PTR [ebx+eax]

; 35   : 			pos += 2;

  00084	83 c0 02	 add	 eax, 2

; 36   : 			if( i >= MAX_PATH )

  00087	81 bd f0 fd ff
	ff 04 01 00 00	 cmp	 DWORD PTR _i$505247[ebp], 260 ; 00000104H
  00091	66 89 8d f4 fd
	ff ff		 mov	 WORD PTR _szTempOneHex$505251[ebp], cx
  00098	89 85 ec fd ff
	ff		 mov	 DWORD PTR _pos$[ebp], eax
  0009e	7d 34		 jge	 SHORT $LN9@Decode

; 37   : 				break;
; 38   : 			szCharCipher[i] = (BYTE)strtol(szTempOneHex, &stopstring, 16);

  000a0	6a 10		 push	 16			; 00000010H
  000a2	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _stopstring$505252[ebp]
  000a8	50		 push	 eax
  000a9	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szTempOneHex$505251[ebp]
  000af	50		 push	 eax
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtol
  000b6	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR _i$505247[ebp]
  000bc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bf	ff 85 f0 fd ff
	ff		 inc	 DWORD PTR _i$505247[ebp]
  000c5	88 84 0d f8 fe
	ff ff		 mov	 BYTE PTR _szCharCipher$[ebp+ecx], al
  000cc	39 b5 f0 fd ff
	ff		 cmp	 DWORD PTR _i$505247[ebp], esi
  000d2	7c 88		 jl	 SHORT $LL12@Decode
$LN9@Decode:

; 39   : 		}
; 40   : 
; 41   : 		EncryptDecryptData( szPlain, iPlainSize, szCharCipher, iCharChipherSize );

  000d4	56		 push	 esi
  000d5	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szCharCipher$[ebp]
  000db	50		 push	 eax
  000dc	ff 75 14	 push	 DWORD PTR _iPlainSize$[ebp]
  000df	ff b5 e8 fd ff
	ff		 push	 DWORD PTR _szPlain$GSCopy$[ebp]
  000e5	e8 00 00 00 00	 call	 ?EncryptDecryptData@SP@@YAXPADHPBDH@Z ; SP::EncryptDecryptData

; 42   : 	}

  000ea	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ed	83 c4 10	 add	 esp, 16			; 00000010H
  000f0	5f		 pop	 edi
  000f1	5e		 pop	 esi
  000f2	33 cd		 xor	 ecx, ebp
  000f4	5b		 pop	 ebx
  000f5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fa	c9		 leave
  000fb	c3		 ret	 0
?Decode@SP@@YAXPBDHPADH@Z ENDP				; SP::Decode
_TEXT	ENDS
PUBLIC	?GetDecodeStr@SP@@YAPBDPBD@Z			; SP::GetDecodeStr
EXTRN	__imp__rand:PROC
;	COMDAT ?szPlain@?1??GetDecodeStr@SP@@YAPBDPBD@Z@4PAY0BAE@DA
_BSS	SEGMENT
?szPlain@?1??GetDecodeStr@SP@@YAPBDPBD@Z@4PAY0BAE@DA DB 03f7a0H DUP (?) ; `SP::GetDecodeStr'::`2'::szPlain
_BSS	ENDS
;	COMDAT ?iCnt@?1??GetDecodeStr@SP@@YAPBDPBD@Z@4HA
_BSS	SEGMENT
?iCnt@?1??GetDecodeStr@SP@@YAPBDPBD@Z@4HA DD 01H DUP (?) ; `SP::GetDecodeStr'::`2'::iCnt
_BSS	ENDS
;	COMDAT ?$S1@?1??GetDecodeStr@SP@@YAPBDPBD@Z@4IA
_BSS	SEGMENT
?$S1@?1??GetDecodeStr@SP@@YAPBDPBD@Z@4IA DD 01H DUP (?)	; `SP::GetDecodeStr'::`2'::$S1
; Function compile flags: /Ogsp
_BSS	ENDS
;	COMDAT ?GetDecodeStr@SP@@YAPBDPBD@Z
_TEXT	SEGMENT
_szCipher$ = 8						; size = 4
?GetDecodeStr@SP@@YAPBDPBD@Z PROC			; SP::GetDecodeStr, COMDAT

; 45   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 46   : 		enum { MAX_DATA = 1000, };
; 47   : 		static int iCnt = rand() % MAX_DATA;

  00003	f6 05 00 00 00
	00 01		 test	 BYTE PTR ?$S1@?1??GetDecodeStr@SP@@YAPBDPBD@Z@4IA, 1
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	be e8 03 00 00	 mov	 esi, 1000		; 000003e8H
  00011	75 14		 jne	 SHORT $LN6@GetDecodeS
  00013	83 0d 00 00 00
	00 01		 or	 DWORD PTR ?$S1@?1??GetDecodeStr@SP@@YAPBDPBD@Z@4IA, 1
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand
  00020	99		 cdq
  00021	8b ce		 mov	 ecx, esi
  00023	f7 f9		 idiv	 ecx
  00025	eb 06		 jmp	 SHORT $LN2@GetDecodeS
$LN6@GetDecodeS:
  00027	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?iCnt@?1??GetDecodeStr@SP@@YAPBDPBD@Z@4HA
$LN2@GetDecodeS:

; 48   : 		static char szPlain[MAX_DATA][MAX_PATH];
; 49   : 
; 50   : 		iCnt++;

  0002d	42		 inc	 edx
  0002e	89 15 00 00 00
	00		 mov	 DWORD PTR ?iCnt@?1??GetDecodeStr@SP@@YAPBDPBD@Z@4HA, edx

; 51   : 		if( iCnt >= MAX_DATA )

  00034	3b d6		 cmp	 edx, esi
  00036	7c 08		 jl	 SHORT $LN1@GetDecodeS

; 52   : 			iCnt = 0;

  00038	33 d2		 xor	 edx, edx
  0003a	89 15 00 00 00
	00		 mov	 DWORD PTR ?iCnt@?1??GetDecodeStr@SP@@YAPBDPBD@Z@4HA, edx
$LN1@GetDecodeS:

; 53   : 
; 54   : 		ZeroMemory( szPlain[iCnt], MAX_PATH );

  00040	69 d2 04 01 00
	00		 imul	 edx, 260		; 00000104H
  00046	be 04 01 00 00	 mov	 esi, 260		; 00000104H
  0004b	56		 push	 esi
  0004c	8d ba 00 00 00
	00		 lea	 edi, DWORD PTR ?szPlain@?1??GetDecodeStr@SP@@YAPBDPBD@Z@4PAY0BAE@DA[edx]
  00052	6a 00		 push	 0
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 _memset

; 55   : 		
; 56   : 		Decode( szCipher, strlen( szCipher ), szPlain[iCnt], MAX_PATH );

  0005a	8b 45 08	 mov	 eax, DWORD PTR _szCipher$[ebp]
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00060	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
$LL5@GetDecodeS:
  00063	8a 10		 mov	 dl, BYTE PTR [eax]
  00065	40		 inc	 eax
  00066	84 d2		 test	 dl, dl
  00068	75 f9		 jne	 SHORT $LL5@GetDecodeS
  0006a	56		 push	 esi
  0006b	2b c1		 sub	 eax, ecx
  0006d	57		 push	 edi
  0006e	50		 push	 eax
  0006f	ff 75 08	 push	 DWORD PTR _szCipher$[ebp]
  00072	e8 00 00 00 00	 call	 ?Decode@SP@@YAXPBDHPADH@Z ; SP::Decode

; 57   : 		return szPlain[iCnt];

  00077	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCnt@?1??GetDecodeStr@SP@@YAPBDPBD@Z@4HA
  0007c	69 c0 04 01 00
	00		 imul	 eax, 260		; 00000104H
  00082	83 c4 10	 add	 esp, 16			; 00000010H
  00085	5f		 pop	 edi
  00086	05 00 00 00 00	 add	 eax, OFFSET ?szPlain@?1??GetDecodeStr@SP@@YAPBDPBD@Z@4PAY0BAE@DA
  0008b	5e		 pop	 esi

; 58   : 	}

  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
?GetDecodeStr@SP@@YAPBDPBD@Z ENDP			; SP::GetDecodeStr
_TEXT	ENDS
PUBLIC	?GetRC5DecodeStr@SP@@YAPBDPBDKAAVioHashString@@@Z ; SP::GetRC5DecodeStr
EXTRN	??1ccddaabb@@UAE@XZ:PROC			; ccddaabb::~ccddaabb
EXTRN	__imp_?c_str@ioHashString@@QBEPBDXZ:PROC
EXTRN	__imp_??4ioHashString@@QAEAAV0@PBD@Z:PROC
EXTRN	?DecryptByte@ccddaabb@@QBEXPBDPADH@Z:PROC	; ccddaabb::DecryptByte
EXTRN	?Setup@ccddaabb@@QAEXPBDHH@Z:PROC		; ccddaabb::Setup
EXTRN	??0ccddaabb@@QAE@XZ:PROC			; ccddaabb::ccddaabb
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__EH_epilog3_GS:PROC
EXTRN	__EH_prolog3_GS:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetRC5DecodeStr@SP@@YAPBDPBDKAAVioHashString@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetRC5DecodeStr@SP@@YAPBDPBDKAAVioHashString@@@Z$0
__ehfuncinfo$?GetRC5DecodeStr@SP@@YAPBDPBDKAAVioHashString@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetRC5DecodeStr@SP@@YAPBDPBDKAAVioHashString@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ?GetRC5DecodeStr@SP@@YAPBDPBDKAAVioHashString@@@Z
_TEXT	SEGMENT
_cRC5$ = -308						; size = 16
_szPlain$ = -292					; size = 260
_szKey$ = -32						; size = 16
__$EHRec$ = -12						; size = 12
_szCipher$ = 8						; size = 4
_dwEncryptSize$ = 12					; size = 4
_rsReturn$ = 16						; size = 4
?GetRC5DecodeStr@SP@@YAPBDPBDKAAVioHashString@@@Z PROC	; SP::GetRC5DecodeStr, COMDAT

; 78   : 	{

  00000	68 28 01 00 00	 push	 296			; 00000128H
  00005	b8 00 00 00 00	 mov	 eax, __ehhandler$?GetRC5DecodeStr@SP@@YAPBDPBDKAAVioHashString@@@Z
  0000a	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000f	8b 5d 08	 mov	 ebx, DWORD PTR _szCipher$[ebp]
  00012	8b 7d 10	 mov	 edi, DWORD PTR _rsReturn$[ebp]

; 79   : 		char szPlain[MAX_PATH];
; 80   : 		ZeroMemory( szPlain, sizeof( szPlain ) );

  00015	68 04 01 00 00	 push	 260			; 00000104H
  0001a	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _szPlain$[ebp]
  00020	6a 00		 push	 0
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 _memset

; 81   : 
; 82   : 		//인니
; 83   : 		//unsigned char szKey[ccddaabb::KEY_SIZE]={ 0, 0, 0, 0, 45, 217, 137, 199, 137, 199 , 237, 199, 6, 9, 90, 13 };
; 84   : 		//한국
; 85   : 		unsigned char szKey[ccddaabb::KEY_SIZE]={ 0, 0, 0, 0, 34, 26, 100, 2, 233, 234 , 111, 123, 89, 102, 234, 2 };
; 86   : 		memcpy( szKey, &dwEncryptSize, sizeof( dwEncryptSize ) );

  00028	8b 75 0c	 mov	 esi, DWORD PTR _dwEncryptSize$[ebp]
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 87   : 		ccddaabb cRC5;

  0002e	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR _cRC5$[ebp]
  00034	c7 45 e4 22 1a
	64 02		 mov	 DWORD PTR _szKey$[ebp+4], 40114722 ; 02641a22H
  0003b	c7 45 e8 e9 ea
	6f 7b		 mov	 DWORD PTR _szKey$[ebp+8], 2070932201 ; 7b6feae9H
  00042	c7 45 ec 59 66
	ea 02		 mov	 DWORD PTR _szKey$[ebp+12], 48916057 ; 02ea6659H
  00049	89 75 e0	 mov	 DWORD PTR _szKey$[ebp], esi
  0004c	e8 00 00 00 00	 call	 ??0ccddaabb@@QAE@XZ	; ccddaabb::ccddaabb
  00051	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 88   : 		cRC5.Setup( (const char*)szKey, dwEncryptSize, dwEncryptSize+345783  );

  00055	8d 86 b7 46 05
	00		 lea	 eax, DWORD PTR [esi+345783]
  0005b	50		 push	 eax
  0005c	56		 push	 esi
  0005d	8d 45 e0	 lea	 eax, DWORD PTR _szKey$[ebp]
  00060	50		 push	 eax
  00061	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR _cRC5$[ebp]
  00067	e8 00 00 00 00	 call	 ?Setup@ccddaabb@@QAEXPBDHH@Z ; ccddaabb::Setup

; 89   : 		cRC5.DecryptByte( szCipher, szPlain, (dwEncryptSize%1000) );

  0006c	33 d2		 xor	 edx, edx
  0006e	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00073	8b c6		 mov	 eax, esi
  00075	f7 f1		 div	 ecx
  00077	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _szPlain$[ebp]
  0007d	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR _cRC5$[ebp]
  00083	52		 push	 edx
  00084	50		 push	 eax
  00085	53		 push	 ebx
  00086	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte

; 90   : 
; 91   : 		rsReturn = szPlain;

  0008b	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _szPlain$[ebp]
  00091	50		 push	 eax
  00092	8b cf		 mov	 ecx, edi
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 92   : 		return rsReturn.c_str();

  0009a	8b cf		 mov	 ecx, edi
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  000a2	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000a6	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR _cRC5$[ebp]
  000ac	8b f0		 mov	 esi, eax
  000ae	e8 00 00 00 00	 call	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
  000b3	8b c6		 mov	 eax, esi

; 93   : 	}

  000b5	e8 00 00 00 00	 call	 __EH_epilog3_GS
  000ba	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetRC5DecodeStr@SP@@YAPBDPBDKAAVioHashString@@@Z$0:
  00000	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR _cRC5$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1ccddaabb@@UAE@XZ	; ccddaabb::~ccddaabb
__ehhandler$?GetRC5DecodeStr@SP@@YAPBDPBDKAAVioHashString@@@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a c8 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-312]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetRC5DecodeStr@SP@@YAPBDPBDKAAVioHashString@@@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetRC5DecodeStr@SP@@YAPBDPBDKAAVioHashString@@@Z ENDP	; SP::GetRC5DecodeStr
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft sdks\windows\v7.0a\include\strsafe.h
;	COMDAT ?StringValidateDestA@@YGJPBDII@Z
_TEXT	SEGMENT
_cchMax$ = 8						; size = 4
?StringValidateDestA@@YGJPBDII@Z PROC			; StringValidateDestA, COMDAT
; _cchDest$ = ecx

; 8721 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 8722 :     HRESULT hr = S_OK;

  00003	33 c0		 xor	 eax, eax

; 8723 : 
; 8724 :     if ((cchDest == 0) || (cchDest > cchMax))

  00005	85 c9		 test	 ecx, ecx
  00007	74 05		 je	 SHORT $LN1@StringVali
  00009	3b 4d 08	 cmp	 ecx, DWORD PTR _cchMax$[ebp]
  0000c	76 05		 jbe	 SHORT $LN2@StringVali
$LN1@StringVali:

; 8725 :     {
; 8726 :         hr = STRSAFE_E_INVALID_PARAMETER;

  0000e	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
$LN2@StringVali:

; 8727 :     }
; 8728 : 
; 8729 :     return hr;
; 8730 : }

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?StringValidateDestA@@YGJPBDII@Z ENDP			; StringValidateDestA
_TEXT	ENDS
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Ogsp
;	COMDAT ?StringVPrintfWorkerA@@YGJPADIPAIPBD0@Z
_TEXT	SEGMENT
_pcchNewDestLength$ = 8					; size = 4
_pszFormat$ = 12					; size = 4
_argList$ = 16						; size = 4
?StringVPrintfWorkerA@@YGJPADIPAIPBD0@Z PROC		; StringVPrintfWorkerA, COMDAT
; _pszDest$ = edi
; _cchDest$ = eax

; 9029 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 9030 :     HRESULT hr = S_OK;
; 9031 :     int iRet;
; 9032 :     size_t cchMax;
; 9033 :     size_t cchNewDestLength = 0;
; 9034 : 
; 9035 :     // leave the last space for the null terminator
; 9036 :     cchMax = cchDest - 1;
; 9037 : 
; 9038 : #if (STRSAFE_USE_SECURE_CRT == 1) && !defined(STRSAFE_LIB_IMPL)
; 9039 :     iRet = _vsnprintf_s(pszDest, cchDest, cchMax, pszFormat, argList);
; 9040 : #else
; 9041 :     #pragma warning(push)
; 9042 :     #pragma warning(disable: __WARNING_BANNED_API_USAGE)// "STRSAFE not included"
; 9043 :     iRet = _vsnprintf(pszDest, cchMax, pszFormat, argList);

  00005	ff 75 10	 push	 DWORD PTR _argList$[ebp]
  00008	8d 70 ff	 lea	 esi, DWORD PTR [eax-1]
  0000b	ff 75 0c	 push	 DWORD PTR _pszFormat$[ebp]
  0000e	33 db		 xor	 ebx, ebx
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___vsnprintf
  00018	83 c4 10	 add	 esp, 16			; 00000010H

; 9044 :     #pragma warning(pop)
; 9045 : #endif
; 9046 :     // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));
; 9047 : 
; 9048 :     if ((iRet < 0) || (((size_t)iRet) > cchMax))

  0001b	85 c0		 test	 eax, eax
  0001d	78 0b		 js	 SHORT $LN5@StringVPri
  0001f	3b c6		 cmp	 eax, esi
  00021	77 07		 ja	 SHORT $LN5@StringVPri

; 9058 :     }
; 9059 :     else if (((size_t)iRet) == cchMax)

  00023	75 0f		 jne	 SHORT $LN2@StringVPri

; 9060 :     {
; 9061 :         // need to null terminate the string
; 9062 :         pszDest += cchMax;
; 9063 :         *pszDest = '\0';

  00025	88 1c 3e	 mov	 BYTE PTR [esi+edi], bl

; 9064 : 
; 9065 :         cchNewDestLength = cchMax;
; 9066 :     }
; 9067 :     else

  00028	eb 08		 jmp	 SHORT $LN9@StringVPri
$LN5@StringVPri:

; 9049 :     {
; 9050 :         // need to null terminate the string
; 9051 :         pszDest += cchMax;
; 9052 :         *pszDest = '\0';

  0002a	88 1c 3e	 mov	 BYTE PTR [esi+edi], bl

; 9055 : 
; 9056 :         // we have truncated pszDest
; 9057 :         hr = STRSAFE_E_INSUFFICIENT_BUFFER;

  0002d	bb 7a 00 07 80	 mov	 ebx, -2147024774	; 8007007aH
$LN9@StringVPri:

; 9053 : 
; 9054 :         cchNewDestLength = cchMax;

  00032	8b c6		 mov	 eax, esi
$LN2@StringVPri:

; 9068 :     {
; 9069 :         cchNewDestLength = (size_t)iRet;
; 9070 :     }
; 9071 : 
; 9072 :     if (pcchNewDestLength)

  00034	8b 4d 08	 mov	 ecx, DWORD PTR _pcchNewDestLength$[ebp]
  00037	85 c9		 test	 ecx, ecx
  00039	74 02		 je	 SHORT $LN1@StringVPri

; 9073 :     {
; 9074 :         *pcchNewDestLength = cchNewDestLength;

  0003b	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@StringVPri:
  0003d	5e		 pop	 esi

; 9075 :     }
; 9076 : 
; 9077 :     return hr;

  0003e	8b c3		 mov	 eax, ebx
  00040	5b		 pop	 ebx

; 9078 : }

  00041	5d		 pop	 ebp
  00042	c2 0c 00	 ret	 12			; 0000000cH
?StringVPrintfWorkerA@@YGJPADIPAIPBD0@Z ENDP		; StringVPrintfWorkerA
_TEXT	ENDS
PUBLIC	?StringCbPrintfA@@YAJPADIPBDZZ			; StringCbPrintfA
; Function compile flags: /Ogsp
;	COMDAT ?StringCbPrintfA@@YAJPADIPBDZZ
_TEXT	SEGMENT
_pszDest$ = 8						; size = 4
_cbDest$ = 12						; size = 4
_pszFormat$ = 16					; size = 4
?StringCbPrintfA@@YAJPADIPBDZZ PROC			; StringCbPrintfA, COMDAT

; 4767 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4768 :     HRESULT hr;
; 4769 :     size_t cchDest = cbDest / sizeof(char);
; 4770 : 
; 4771 :     hr = StringValidateDestA(pszDest, cchDest, STRSAFE_MAX_CCH);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _cbDest$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	85 c9		 test	 ecx, ecx
  0000a	74 08		 je	 SHORT $LN4@StringCbPr
  0000c	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  00012	76 05		 jbe	 SHORT $LN5@StringCbPr
$LN4@StringCbPr:
  00014	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
$LN5@StringCbPr:

; 4772 :     
; 4773 :     if (SUCCEEDED(hr))

  00019	85 c0		 test	 eax, eax
  0001b	78 39		 js	 SHORT $LN1@StringCbPr

; 4774 :     {
; 4775 :         va_list argList;
; 4776 : 
; 4777 :         va_start(argList, pszFormat);
; 4778 : 
; 4779 :         hr = StringVPrintfWorkerA(pszDest,
; 4780 :                                   cchDest,
; 4781 :                                   NULL,
; 4782 :                                   pszFormat,
; 4783 :                                   argList);

  0001d	53		 push	 ebx
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	8b 7d 08	 mov	 edi, DWORD PTR _pszDest$[ebp]
  00023	8d 45 14	 lea	 eax, DWORD PTR _pszFormat$[ebp+4]
  00026	50		 push	 eax
  00027	ff 75 10	 push	 DWORD PTR _pszFormat$[ebp]
  0002a	8d 71 ff	 lea	 esi, DWORD PTR [ecx-1]
  0002d	56		 push	 esi
  0002e	57		 push	 edi
  0002f	33 db		 xor	 ebx, ebx
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___vsnprintf
  00037	83 c4 10	 add	 esp, 16			; 00000010H
  0003a	85 c0		 test	 eax, eax
  0003c	78 0b		 js	 SHORT $LN12@StringCbPr
  0003e	3b c6		 cmp	 eax, esi
  00040	77 07		 ja	 SHORT $LN12@StringCbPr
  00042	75 0d		 jne	 SHORT $LN9@StringCbPr
  00044	88 1c 3e	 mov	 BYTE PTR [esi+edi], bl
  00047	eb 08		 jmp	 SHORT $LN9@StringCbPr
$LN12@StringCbPr:
  00049	88 1c 3e	 mov	 BYTE PTR [esi+edi], bl
  0004c	bb 7a 00 07 80	 mov	 ebx, -2147024774	; 8007007aH
$LN9@StringCbPr:
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	8b c3		 mov	 eax, ebx
  00055	5b		 pop	 ebx
$LN1@StringCbPr:

; 4784 : 
; 4785 :         va_end(argList);
; 4786 :     }
; 4787 : 
; 4788 :     return hr;
; 4789 : }

  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?StringCbPrintfA@@YAJPADIPBDZZ ENDP			; StringCbPrintfA
_TEXT	ENDS
PUBLIC	_szCipher$GSCopy$
PUBLIC	?GetAESDecodeStr@SP@@YAPBDPBDKAAVioHashString@@@Z ; SP::GetAESDecodeStr
EXTRN	??1Abcdef@@UAE@XZ:PROC				; Abcdef::~Abcdef
EXTRN	?Decrypt@Abcdef@@QAEXPBDPADIH@Z:PROC		; Abcdef::Decrypt
EXTRN	?MakeKey@Abcdef@@QAEXPBD0HH@Z:PROC		; Abcdef::MakeKey
EXTRN	?sm_chain0@Abcdef@@2PBDB:DWORD			; Abcdef::sm_chain0
EXTRN	??0Abcdef@@QAE@XZ:PROC				; Abcdef::Abcdef
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stringprotect.cpp
xdata$x	SEGMENT
__unwindtable$?GetAESDecodeStr@SP@@YAPBDPBDKAAVioHashString@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetAESDecodeStr@SP@@YAPBDPBDKAAVioHashString@@@Z$0
__ehfuncinfo$?GetAESDecodeStr@SP@@YAPBDPBDKAAVioHashString@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetAESDecodeStr@SP@@YAPBDPBDKAAVioHashString@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ?GetAESDecodeStr@SP@@YAPBDPBDKAAVioHashString@@@Z
_TEXT	SEGMENT
_szCipher$GSCopy$ = -1940				; size = 4
_oRijndael$ = -1936					; size = 1140
_szPlain$ = -796					; size = 260
_szKey$ = -536						; size = 260
_szArgu$ = -276						; size = 260
__$EHRec$ = -12						; size = 12
_szCipher$ = 8						; size = 4
_dwKeyAndSize$ = 12					; size = 4
_rsReturn$ = 16						; size = 4
?GetAESDecodeStr@SP@@YAPBDPBDKAAVioHashString@@@Z PROC	; SP::GetAESDecodeStr, COMDAT

; 61   : 	{

  00000	68 88 07 00 00	 push	 1928			; 00000788H
  00005	b8 00 00 00 00	 mov	 eax, __ehhandler$?GetAESDecodeStr@SP@@YAPBDPBDKAAVioHashString@@@Z
  0000a	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000f	8b 45 08	 mov	 eax, DWORD PTR _szCipher$[ebp]
  00012	8b 7d 10	 mov	 edi, DWORD PTR _rsReturn$[ebp]

; 62   : 		char szKey[MAX_PATH]="";

  00015	33 db		 xor	 ebx, ebx
  00017	68 03 01 00 00	 push	 259			; 00000103H
  0001c	89 85 6c f8 ff
	ff		 mov	 DWORD PTR _szCipher$GSCopy$[ebp], eax
  00022	8d 85 e9 fd ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp+1]
  00028	53		 push	 ebx
  00029	50		 push	 eax
  0002a	88 9d e8 fd ff
	ff		 mov	 BYTE PTR _szKey$[ebp], bl
  00030	e8 00 00 00 00	 call	 _memset

; 63   : 		char szArgu[MAX_PATH]={ 37, 99, 37, 99, 37, 117, 37, 99, 37, 99 , 37, 99, 0 };

  00035	68 f7 00 00 00	 push	 247			; 000000f7H
  0003a	8d 85 f9 fe ff
	ff		 lea	 eax, DWORD PTR _szArgu$[ebp+13]
  00040	53		 push	 ebx
  00041	50		 push	 eax
  00042	c7 85 ec fe ff
	ff 25 63 25 63	 mov	 DWORD PTR _szArgu$[ebp], 1663394597 ; 63256325H
  0004c	c7 85 f0 fe ff
	ff 25 75 25 63	 mov	 DWORD PTR _szArgu$[ebp+4], 1663399205 ; 63257525H
  00056	c7 85 f4 fe ff
	ff 25 63 25 63	 mov	 DWORD PTR _szArgu$[ebp+8], 1663394597 ; 63256325H
  00060	88 9d f8 fe ff
	ff		 mov	 BYTE PTR _szArgu$[ebp+12], bl
  00066	e8 00 00 00 00	 call	 _memset

; 64   : 		StringCbPrintf( szKey, sizeof( szKey ), szArgu, 25, 31, dwKeyAndSize, 48, 125, 75 );

  0006b	6a 4b		 push	 75			; 0000004bH
  0006d	6a 7d		 push	 125			; 0000007dH
  0006f	6a 30		 push	 48			; 00000030H
  00071	ff 75 0c	 push	 DWORD PTR _dwKeyAndSize$[ebp]
  00074	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szArgu$[ebp]
  0007a	6a 1f		 push	 31			; 0000001fH
  0007c	6a 19		 push	 25			; 00000019H
  0007e	50		 push	 eax
  0007f	be 04 01 00 00	 mov	 esi, 260		; 00000104H
  00084	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  0008a	56		 push	 esi
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 ?StringCbPrintfA@@YAJPADIPBDZZ ; StringCbPrintfA

; 65   : 
; 66   : 		char szPlain[MAX_PATH];
; 67   : 		ZeroMemory( szPlain, sizeof( szPlain ) );

  00091	56		 push	 esi
  00092	8d 85 e4 fc ff
	ff		 lea	 eax, DWORD PTR _szPlain$[ebp]
  00098	53		 push	 ebx
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 _memset
  0009f	83 c4 48	 add	 esp, 72			; 00000048H

; 68   : 
; 69   : 		Abcdef oRijndael;                                               

  000a2	8d 8d 70 f8 ff
	ff		 lea	 ecx, DWORD PTR _oRijndael$[ebp]
  000a8	e8 00 00 00 00	 call	 ??0Abcdef@@QAE@XZ	; Abcdef::Abcdef

; 70   : 		oRijndael.MakeKey( szKey ,Abcdef::sm_chain0, 16, 16);

  000ad	6a 10		 push	 16			; 00000010H
  000af	6a 10		 push	 16			; 00000010H
  000b1	ff 35 00 00 00
	00		 push	 DWORD PTR ?sm_chain0@Abcdef@@2PBDB ; Abcdef::sm_chain0
  000b7	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  000bd	50		 push	 eax
  000be	8d 8d 70 f8 ff
	ff		 lea	 ecx, DWORD PTR _oRijndael$[ebp]
  000c4	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  000c7	e8 00 00 00 00	 call	 ?MakeKey@Abcdef@@QAEXPBD0HH@Z ; Abcdef::MakeKey

; 71   : 		oRijndael.Decrypt( szCipher, szPlain, (dwKeyAndSize%1000), (dwKeyAndSize/1000)%3 );

  000cc	8b 45 0c	 mov	 eax, DWORD PTR _dwKeyAndSize$[ebp]
  000cf	33 d2		 xor	 edx, edx
  000d1	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  000d6	f7 f1		 div	 ecx
  000d8	6a 03		 push	 3
  000da	5e		 pop	 esi
  000db	8b ca		 mov	 ecx, edx
  000dd	33 d2		 xor	 edx, edx
  000df	f7 f6		 div	 esi
  000e1	8d 85 e4 fc ff
	ff		 lea	 eax, DWORD PTR _szPlain$[ebp]
  000e7	52		 push	 edx
  000e8	51		 push	 ecx
  000e9	50		 push	 eax
  000ea	ff b5 6c f8 ff
	ff		 push	 DWORD PTR _szCipher$GSCopy$[ebp]
  000f0	8d 8d 70 f8 ff
	ff		 lea	 ecx, DWORD PTR _oRijndael$[ebp]
  000f6	e8 00 00 00 00	 call	 ?Decrypt@Abcdef@@QAEXPBDPADIH@Z ; Abcdef::Decrypt

; 72   : 
; 73   : 		rsReturn = szPlain;

  000fb	8d 85 e4 fc ff
	ff		 lea	 eax, DWORD PTR _szPlain$[ebp]
  00101	50		 push	 eax
  00102	8b cf		 mov	 ecx, edi
  00104	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 74   : 		return rsReturn.c_str();

  0010a	8b cf		 mov	 ecx, edi
  0010c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00112	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00116	8d 8d 70 f8 ff
	ff		 lea	 ecx, DWORD PTR _oRijndael$[ebp]
  0011c	8b f0		 mov	 esi, eax
  0011e	e8 00 00 00 00	 call	 ??1Abcdef@@UAE@XZ	; Abcdef::~Abcdef
  00123	8b c6		 mov	 eax, esi

; 75   : 	}

  00125	e8 00 00 00 00	 call	 __EH_epilog3_GS
  0012a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetAESDecodeStr@SP@@YAPBDPBDKAAVioHashString@@@Z$0:
  00000	8d 8d 70 f8 ff
	ff		 lea	 ecx, DWORD PTR _oRijndael$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1Abcdef@@UAE@XZ	; Abcdef::~Abcdef
__ehhandler$?GetAESDecodeStr@SP@@YAPBDPBDKAAVioHashString@@@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 68 f8 ff
	ff		 mov	 ecx, DWORD PTR [edx-1944]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetAESDecodeStr@SP@@YAPBDPBDKAAVioHashString@@@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetAESDecodeStr@SP@@YAPBDPBDKAAVioHashString@@@Z ENDP	; SP::GetAESDecodeStr
END
