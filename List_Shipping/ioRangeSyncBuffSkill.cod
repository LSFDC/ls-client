; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\Lost Saga For Developer\Youtube\Tutorial\Source\src\LSClient\ioRangeSyncBuffSkill.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_EEM_DS@?$deque@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@2HB ; std::deque<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_EEM_DS
;	COMDAT ?_EEM_DS@?$deque@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@2HB
CONST	SEGMENT
?_EEM_DS@?$deque@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@2HB DD 01H ; std::deque<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_EEM_DS
CONST	ENDS
PUBLIC	?return5@@YAIXZ					; return5
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stdafx.h
;	COMDAT ?return5@@YAIXZ
_TEXT	SEGMENT
?return5@@YAIXZ PROC					; return5, COMDAT

; 18   : 	__forceinline unsigned int return5() { __asm mov eax, 5 };

  00000	b8 05 00 00 00	 mov	 eax, 5
  00005	c3		 ret	 0
?return5@@YAIXZ ENDP					; return5
_TEXT	ENDS
PUBLIC	?return8@@YAIXZ					; return8
; Function compile flags: /Ogsp
;	COMDAT ?return8@@YAIXZ
_TEXT	SEGMENT
?return8@@YAIXZ PROC					; return8, COMDAT

; 19   : 	__forceinline unsigned int return8() { __asm mov eax, 8 };

  00000	b8 08 00 00 00	 mov	 eax, 8
  00005	c3		 ret	 0
?return8@@YAIXZ ENDP					; return8
_TEXT	ENDS
PUBLIC	?return10@@YAIXZ				; return10
; Function compile flags: /Ogsp
;	COMDAT ?return10@@YAIXZ
_TEXT	SEGMENT
?return10@@YAIXZ PROC					; return10, COMDAT

; 21   : 	__forceinline unsigned int return10() { __asm mov eax, 10 };

  00000	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  00005	c3		 ret	 0
?return10@@YAIXZ ENDP					; return10
_TEXT	ENDS
PUBLIC	?return100@@YAIXZ				; return100
; Function compile flags: /Ogsp
;	COMDAT ?return100@@YAIXZ
_TEXT	SEGMENT
?return100@@YAIXZ PROC					; return100, COMDAT

; 25   : 	__forceinline unsigned int return100() { __asm mov eax, 100 };

  00000	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  00005	c3		 ret	 0
?return100@@YAIXZ ENDP					; return100
_TEXT	ENDS
PUBLIC	?GetState@ioBaseChar@@QBE?AW4CharState@@XZ	; ioBaseChar::GetState
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasechar.h
;	COMDAT ?GetState@ioBaseChar@@QBE?AW4CharState@@XZ
_TEXT	SEGMENT
?GetState@ioBaseChar@@QBE?AW4CharState@@XZ PROC		; ioBaseChar::GetState, COMDAT
; _this$ = ecx

; 2156 : 	inline CharState GetState() const { return m_CharState; }	

  00000	8a 81 10 03 00
	00		 mov	 al, BYTE PTR [ecx+784]
  00006	c3		 ret	 0
?GetState@ioBaseChar@@QBE?AW4CharState@@XZ ENDP		; ioBaseChar::GetState
_TEXT	ENDS
PUBLIC	?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ	; ioBaseChar::GetCharName
; Function compile flags: /Ogsp
;	COMDAT ?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ
_TEXT	SEGMENT
?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ PROC	; ioBaseChar::GetCharName, COMDAT
; _this$ = ecx

; 2594 : 	inline const ioHashString& GetCharName() const { return m_Name; }

  00000	8d 81 d4 02 00
	00		 lea	 eax, DWORD PTR [ecx+724]
  00006	c3		 ret	 0
?GetCharName@ioBaseChar@@QBEABVioHashString@@XZ ENDP	; ioBaseChar::GetCharName
_TEXT	ENDS
PUBLIC	?GetTargetRot@ioBaseChar@@QBEABUD3DXQUATERNION@@XZ ; ioBaseChar::GetTargetRot
; Function compile flags: /Ogsp
;	COMDAT ?GetTargetRot@ioBaseChar@@QBEABUD3DXQUATERNION@@XZ
_TEXT	SEGMENT
?GetTargetRot@ioBaseChar@@QBEABUD3DXQUATERNION@@XZ PROC	; ioBaseChar::GetTargetRot, COMDAT
; _this$ = ecx

; 2599 : 	inline const D3DXQUATERNION& GetTargetRot() const { return m_qtTargetRot; }

  00000	8d 81 a4 06 00
	00		 lea	 eax, DWORD PTR [ecx+1700]
  00006	c3		 ret	 0
?GetTargetRot@ioBaseChar@@QBEABUD3DXQUATERNION@@XZ ENDP	; ioBaseChar::GetTargetRot
_TEXT	ENDS
PUBLIC	?GetRandomSeed@ioBaseChar@@QBEKXZ		; ioBaseChar::GetRandomSeed
; Function compile flags: /Ogsp
;	COMDAT ?GetRandomSeed@ioBaseChar@@QBEKXZ
_TEXT	SEGMENT
?GetRandomSeed@ioBaseChar@@QBEKXZ PROC			; ioBaseChar::GetRandomSeed, COMDAT
; _this$ = ecx

; 3372 : 	inline DWORD GetRandomSeed() const { return m_dwRandomSeed; }

  00000	8b 81 74 16 00
	00		 mov	 eax, DWORD PTR [ecx+5748]
  00006	c3		 ret	 0
?GetRandomSeed@ioBaseChar@@QBEKXZ ENDP			; ioBaseChar::GetRandomSeed
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
  00010	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00016	8b c6		 mov	 eax, esi
  00018	5e		 pop	 esi
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogsp
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1exception@std@@UAE@XZ
  00012	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00016	74 07		 je	 SHORT $LN1@scalar
  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001e	59		 pop	 ecx
$LN1@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 56   : 	{	// construct array with placement at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : 	return (_Where);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 58   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogsp
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 62   : 	}

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?GetType@ioGrowthUpInfo@@QBE?AW4GrowthType@@XZ	; ioGrowthUpInfo::GetType
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iogrowthupinfo.h
;	COMDAT ?GetType@ioGrowthUpInfo@@QBE?AW4GrowthType@@XZ
_TEXT	SEGMENT
?GetType@ioGrowthUpInfo@@QBE?AW4GrowthType@@XZ PROC	; ioGrowthUpInfo::GetType, COMDAT
; _this$ = ecx

; 23   : 	inline GrowthType GetType() const { return m_GrowthType; }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetType@ioGrowthUpInfo@@QBE?AW4GrowthType@@XZ ENDP	; ioGrowthUpInfo::GetType
_TEXT	ENDS
PUBLIC	??_R0?AVioGrowthUpInfo@@@8			; ioGrowthUpInfo `RTTI Type Descriptor'
PUBLIC	??_R0?AVioGrowthNormalUpInfo@@@8		; ioGrowthNormalUpInfo `RTTI Type Descriptor'
PUBLIC	?ToNormalUpInfo@@YAPAVioGrowthNormalUpInfo@@PAVioGrowthUpInfo@@@Z ; ToNormalUpInfo
EXTRN	___RTDynamicCast:PROC
;	COMDAT ??_R0?AVioGrowthUpInfo@@@8
_DATA	SEGMENT
??_R0?AVioGrowthUpInfo@@@8 DD FLAT:??_7type_info@@6B@	; ioGrowthUpInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioGrowthUpInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVioGrowthNormalUpInfo@@@8
_DATA	SEGMENT
??_R0?AVioGrowthNormalUpInfo@@@8 DD FLAT:??_7type_info@@6B@ ; ioGrowthNormalUpInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioGrowthNormalUpInfo@@', 00H
; Function compile flags: /Ogsp
_DATA	ENDS
;	COMDAT ?ToNormalUpInfo@@YAPAVioGrowthNormalUpInfo@@PAVioGrowthUpInfo@@@Z
_TEXT	SEGMENT
_pUpInfo$ = 8						; size = 4
?ToNormalUpInfo@@YAPAVioGrowthNormalUpInfo@@PAVioGrowthUpInfo@@@Z PROC ; ToNormalUpInfo, COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 60   : 	if( !pUpInfo || pUpInfo->GetType() == GT_NONE )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pUpInfo$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 39		 je	 SHORT $LN6@ToNormalUp
  0000a	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0000d	85 c0		 test	 eax, eax
  0000f	74 32		 je	 SHORT $LN6@ToNormalUp

; 62   : 
; 63   : 	if( pUpInfo->GetType() == GT_CHAR_ATTACK || pUpInfo->GetType() == GT_SKILL_ATTACK )

  00011	83 f8 01	 cmp	 eax, 1
  00014	74 2d		 je	 SHORT $LN6@ToNormalUp
  00016	83 f8 07	 cmp	 eax, 7
  00019	74 28		 je	 SHORT $LN6@ToNormalUp

; 64   : 		return NULL;
; 65   : 	if( pUpInfo->GetType() == GT_BLOW_PUSH )

  0001b	83 f8 1e	 cmp	 eax, 30			; 0000001eH

; 66   : 		return NULL;

  0001e	74 23		 je	 SHORT $LN6@ToNormalUp

; 67   : 	if( pUpInfo->GetType() == GT_TELEPORT_ANI_RATE )

  00020	83 f8 20	 cmp	 eax, 32			; 00000020H

; 68   : 		return NULL;

  00023	74 1e		 je	 SHORT $LN6@ToNormalUp

; 69   : 	if( pUpInfo->GetType() == GT_SKILL_ATTACK_FORCE )

  00025	83 f8 1c	 cmp	 eax, 28			; 0000001cH

; 70   : 		return NULL;

  00028	74 19		 je	 SHORT $LN6@ToNormalUp

; 71   : 
; 72   : 	return dynamic_cast< ioGrowthNormalUpInfo* >( pUpInfo );

  0002a	6a 00		 push	 0
  0002c	68 00 00 00 00	 push	 OFFSET ??_R0?AVioGrowthNormalUpInfo@@@8
  00031	68 00 00 00 00	 push	 OFFSET ??_R0?AVioGrowthUpInfo@@@8
  00036	6a 00		 push	 0
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ___RTDynamicCast
  0003e	83 c4 14	 add	 esp, 20			; 00000014H

; 73   : }

  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
$LN6@ToNormalUp:

; 61   : 		return NULL;

  00043	33 c0		 xor	 eax, eax

; 73   : }

  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?ToNormalUpInfo@@YAPAVioGrowthNormalUpInfo@@PAVioGrowthUpInfo@@@Z ENDP ; ToNormalUpInfo
_TEXT	ENDS
PUBLIC	??_7ioRangeSyncBuffSkill@@6B@			; ioRangeSyncBuffSkill::`vftable'
PUBLIC	??0ioRangeSyncBuffSkill@@QAE@XZ			; ioRangeSyncBuffSkill::ioRangeSyncBuffSkill
PUBLIC	??_R4ioRangeSyncBuffSkill@@6B@			; ioRangeSyncBuffSkill::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVioRangeSyncBuffSkill@@@8		; ioRangeSyncBuffSkill `RTTI Type Descriptor'
PUBLIC	??_R3ioRangeSyncBuffSkill@@8			; ioRangeSyncBuffSkill::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioRangeSyncBuffSkill@@8			; ioRangeSyncBuffSkill::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ioRangeSyncBuffSkill@@8		; ioRangeSyncBuffSkill::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ioRangeSkill@@8			; ioRangeSkill::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVioRangeSkill@@@8			; ioRangeSkill `RTTI Type Descriptor'
PUBLIC	??_R3ioRangeSkill@@8				; ioRangeSkill::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioRangeSkill@@8				; ioRangeSkill::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ioSkill@@8			; ioSkill::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVioSkill@@@8				; ioSkill `RTTI Type Descriptor'
PUBLIC	??_R3ioSkill@@8					; ioSkill::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioSkill@@8					; ioSkill::`RTTI Base Class Array'
PUBLIC	?LoadProperty@ioRangeSyncBuffSkill@@UAEXAAVioINILoader@@@Z ; ioRangeSyncBuffSkill::LoadProperty
PUBLIC	?Clone@ioRangeSyncBuffSkill@@UAEPAVioSkill@@XZ	; ioRangeSyncBuffSkill::Clone
PUBLIC	?GetDefenseSkillBreakeType@ioSkill@@UBE?AW4DefenseBreakType@@XZ ; ioSkill::GetDefenseSkillBreakeType
PUBLIC	?GetSkillEndNextJumpAmt@ioSkill@@UBEMXZ		; ioSkill::GetSkillEndNextJumpAmt
PUBLIC	?GetSkillEndNextLandRate@ioSkill@@UBEMXZ	; ioSkill::GetSkillEndNextLandRate
PUBLIC	?GetSkillEndNextJumpMustEnable@ioSkill@@UAE?AW4SkillEndJumpType@@XZ ; ioSkill::GetSkillEndNextJumpMustEnable
PUBLIC	?EnableChangeGrapplingTargetPos@ioSkill@@UBE_NXZ ; ioSkill::EnableChangeGrapplingTargetPos
PUBLIC	?OnProcessState@ioRangeSyncBuffSkill@@MAEXPAVioBaseChar@@PAVioPlayStage@@@Z ; ioRangeSyncBuffSkill::OnProcessState
PUBLIC	?OnSkillEnd@ioRangeSyncBuffSkill@@UAEXPAVioBaseChar@@@Z ; ioRangeSyncBuffSkill::OnSkillEnd
PUBLIC	?ApplyExtraSkillInfo@ioRangeSyncBuffSkill@@UAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z ; ioRangeSyncBuffSkill::ApplyExtraSkillInfo
PUBLIC	?IsInvisibleBottomCircle@ioSkill@@UAE_NPAVioBaseChar@@@Z ; ioSkill::IsInvisibleBottomCircle
PUBLIC	?IsCanJumpingSkill@ioSkill@@UBE_NXZ		; ioSkill::IsCanJumpingSkill
PUBLIC	?IsCanJumpingSkillOnBlowWound@ioSkill@@UBE_NXZ	; ioSkill::IsCanJumpingSkillOnBlowWound
PUBLIC	?IsCanDownSkill@ioSkill@@UBE_NXZ		; ioSkill::IsCanDownSkill
PUBLIC	?IsCanBlowWoundSkill@ioSkill@@UBE_NXZ		; ioSkill::IsCanBlowWoundSkill
PUBLIC	?IsCanWoundSkill@ioSkill@@UBE_NXZ		; ioSkill::IsCanWoundSkill
PUBLIC	?IsUseActiveCnt@ioSkill@@UBE_NXZ		; ioSkill::IsUseActiveCnt
PUBLIC	?GetMaxActiveCnt@ioSkill@@UBEHPAVioBaseChar@@@Z	; ioSkill::GetMaxActiveCnt
PUBLIC	?GetCurActiveCnt@ioSkill@@UBEHPAVioBaseChar@@@Z	; ioSkill::GetCurActiveCnt
PUBLIC	?SetLoopState@ioRangeSyncBuffSkill@@MAEXPAVioBaseChar@@PAVioPlayStage@@@Z ; ioRangeSyncBuffSkill::SetLoopState
PUBLIC	?SetEnemyBuffList@ioRangeSyncBuffSkill@@MAE_NPAVioBaseChar@@0@Z ; ioRangeSyncBuffSkill::SetEnemyBuffList
EXTRN	??0ioRangeSkill@@QAE@XZ:PROC			; ioRangeSkill::ioRangeSkill
EXTRN	?GetTypeID@ioRangeSkill@@UBEHXZ:PROC		; ioRangeSkill::GetTypeID
EXTRN	?IsProtected@ioRangeSkill@@UBE_NH@Z:PROC	; ioRangeSkill::IsProtected
EXTRN	?IsCanSwitchSkill@ioSkill@@UBE_NXZ:PROC		; ioSkill::IsCanSwitchSkill
EXTRN	?IsCanSemiSwitchSkill@ioSkill@@UBE_NXZ:PROC	; ioSkill::IsCanSemiSwitchSkill
EXTRN	?IsCanCancelBySkill@ioSkill@@UBE_NPAVioBaseChar@@AAH@Z:PROC ; ioSkill::IsCanCancelBySkill
EXTRN	?IsCanUseZeroHP@ioSkill@@UBE_NPAVioBaseChar@@@Z:PROC ; ioSkill::IsCanUseZeroHP
EXTRN	?IsCanUseSkillWithCrown@ioSkill@@UAE_NPAVioBaseChar@@@Z:PROC ; ioSkill::IsCanUseSkillWithCrown
EXTRN	?IsCanUseBoss@ioSkill@@UBE_NPAVioBaseChar@@@Z:PROC ; ioSkill::IsCanUseBoss
EXTRN	?IsCanUseFootball@ioSkill@@UBE_NXZ:PROC		; ioSkill::IsCanUseFootball
EXTRN	?IsCanUseGangSiMode@ioSkill@@UBE_NXZ:PROC	; ioSkill::IsCanUseGangSiMode
EXTRN	?IsCanUseByWeaponType@ioSkill@@UBE_NPAVioBaseChar@@@Z:PROC ; ioSkill::IsCanUseByWeaponType
EXTRN	?IsCanUseThunderBirdHold@ioSkill@@UBE_NPAVioBaseChar@@@Z:PROC ; ioSkill::IsCanUseThunderBirdHold
EXTRN	?IsCanUseLimitHP@ioSkill@@UBE_NPAVioBaseChar@@@Z:PROC ; ioSkill::IsCanUseLimitHP
EXTRN	?IsCanUseSkill@ioRangeSkill@@UAE_NPAVioBaseChar@@_N@Z:PROC ; ioRangeSkill::IsCanUseSkill
EXTRN	?IsOnOffEnable@ioSkill@@UAE_NXZ:PROC		; ioSkill::IsOnOffEnable
EXTRN	?IsCanDefenseStateSkill@ioSkill@@UAE_NXZ:PROC	; ioSkill::IsCanDefenseStateSkill
EXTRN	?SetDefenseStateSkill@ioSkill@@UAEXPAVioBaseChar@@@Z:PROC ; ioSkill::SetDefenseStateSkill
EXTRN	?HasBuff@ioSkill@@UBE_NH@Z:PROC			; ioSkill::HasBuff
EXTRN	?GetBuffType@ioSkill@@UAEHH@Z:PROC		; ioSkill::GetBuffType
EXTRN	?IsEnableReserve@ioSkill@@UBE_NXZ:PROC		; ioSkill::IsEnableReserve
EXTRN	?IsSkillMotionEnd@ioRangeSkill@@UBE_NKPAVioBaseChar@@@Z:PROC ; ioRangeSkill::IsSkillMotionEnd
EXTRN	?IsCharSkipState@ioSkill@@UBE?AW4SkillCharColType@@XZ:PROC ; ioSkill::IsCharSkipState
EXTRN	?IsEntityCollisionSkipState@ioSkill@@UBE_NXZ:PROC ; ioSkill::IsEntityCollisionSkipState
EXTRN	?IsEndState@ioSkill@@UBE_NXZ:PROC		; ioSkill::IsEndState
EXTRN	?IsAttackEndState@ioSkill@@UBE_NXZ:PROC		; ioSkill::IsAttackEndState
EXTRN	?IsJumpState@ioSkill@@UBE_NXZ:PROC		; ioSkill::IsJumpState
EXTRN	?IsDownState@ioSkill@@UBE_NXZ:PROC		; ioSkill::IsDownState
EXTRN	?IsNoDropState@ioSkill@@UBE_NXZ:PROC		; ioSkill::IsNoDropState
EXTRN	?IsCanSendControl@ioSkill@@UBE_NXZ:PROC		; ioSkill::IsCanSendControl
EXTRN	?IsSkipState@ioSkill@@UBE_NXZ:PROC		; ioSkill::IsSkipState
EXTRN	?GetSkillMoveRate@ioSkill@@UBEMXZ:PROC		; ioSkill::GetSkillMoveRate
EXTRN	?SetSkillGrapplingState@ioSkill@@UAE_NPAVioBaseChar@@ABVioHashString@@@Z:PROC ; ioSkill::SetSkillGrapplingState
EXTRN	?GetGrapplingTargetPos@ioSkill@@UAE?AUD3DXVECTOR3@@PAVioBaseChar@@0@Z:PROC ; ioSkill::GetGrapplingTargetPos
EXTRN	?GetGrapplingTargetPos@ioSkill@@UAE?AUD3DXVECTOR3@@PAVioBaseChar@@@Z:PROC ; ioSkill::GetGrapplingTargetPos
EXTRN	?GetSkillWoundGrapplingInfo@ioSkill@@UAE?AUGrapplingSkillWoundedInfo@@XZ:PROC ; ioSkill::GetSkillWoundGrapplingInfo
EXTRN	?SetCreateWeaponDependency@ioSkill@@UAEXPAVioBaseChar@@PAVioPlayStage@@@Z:PROC ; ioSkill::SetCreateWeaponDependency
EXTRN	?SetNextSkillState@ioSkill@@UAEXPAVioBaseChar@@PAVioWeapon@@@Z:PROC ; ioSkill::SetNextSkillState
EXTRN	?OnSkillStart@ioRangeSkill@@UAE_NPAVioBaseChar@@@Z:PROC ; ioRangeSkill::OnSkillStart
EXTRN	?OnSkillEndByWounded@ioSkill@@UAEXPAVioBaseChar@@@Z:PROC ; ioSkill::OnSkillEndByWounded
EXTRN	?OnProcessNotUseSkill@ioSkill@@UAEXPAVioBaseChar@@PAVioPlayStage@@@Z:PROC ; ioSkill::OnProcessNotUseSkill
EXTRN	?OnSkillItemRelease@ioSkill@@UAEXPAVioBaseChar@@@Z:PROC ; ioSkill::OnSkillItemRelease
EXTRN	?ApplyAttributeToWeapon@ioSkill@@UAEXPAVioWeapon@@PAVioPlayStage@@@Z:PROC ; ioSkill::ApplyAttributeToWeapon
EXTRN	?ApplyEquipSlotSkillExtraInfo@ioSkill@@UAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z:PROC ; ioSkill::ApplyEquipSlotSkillExtraInfo
EXTRN	?ApplyExtraPassiveSkillInfo@ioSkill@@UAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z:PROC ; ioSkill::ApplyExtraPassiveSkillInfo
EXTRN	?StartPreDelayEffect@ioSkill@@UAEXPAVioBaseChar@@@Z:PROC ; ioSkill::StartPreDelayEffect
EXTRN	?EndPreDelayEffect@ioSkill@@UAEXPAVioBaseChar@@@Z:PROC ; ioSkill::EndPreDelayEffect
EXTRN	?IsUseAutoTargetValue@ioSkill@@UAE_NXZ:PROC	; ioSkill::IsUseAutoTargetValue
EXTRN	?IsAutoTargetDownState@ioSkill@@UAE_NXZ:PROC	; ioSkill::IsAutoTargetDownState
EXTRN	?CheckUseBuff@ioSkill@@UAE_NPAVioBaseChar@@@Z:PROC ; ioSkill::CheckUseBuff
EXTRN	?CheckUseItemMesh@ioRangeSkill@@UAE_NXZ:PROC	; ioRangeSkill::CheckUseItemMesh
EXTRN	?CheckUseActiveCount@ioSkill@@UAE_NXZ:PROC	; ioSkill::CheckUseActiveCount
EXTRN	?CheckAniRotate@ioSkill@@UAEXPAVioBaseChar@@@Z:PROC ; ioSkill::CheckAniRotate
EXTRN	?IsEnableDashCheck@ioSkill@@UAE_NPAVioBaseChar@@@Z:PROC ; ioSkill::IsEnableDashCheck
EXTRN	?IsEnableMultiActive@ioSkill@@UAE_NPAVioBaseChar@@@Z:PROC ; ioSkill::IsEnableMultiActive
EXTRN	?GetAutoTargetValue@ioSkill@@UAEXAAM00@Z:PROC	; ioSkill::GetAutoTargetValue
EXTRN	?GetSkillGravityRate@ioSkill@@UAEMXZ:PROC	; ioSkill::GetSkillGravityRate
EXTRN	?GetSkillMotionName@ioSkill@@UBEABVioHashString@@XZ:PROC ; ioSkill::GetSkillMotionName
EXTRN	?HasSkillMotion@ioSkill@@UBE_NXZ:PROC		; ioSkill::HasSkillMotion
EXTRN	?GetSkillMotionRate@ioSkill@@UBEMXZ:PROC	; ioSkill::GetSkillMotionRate
EXTRN	?IsPreDelayProtect@ioSkill@@UBE_NXZ:PROC	; ioSkill::IsPreDelayProtect
EXTRN	?GetPreDelayAniName@ioSkill@@UBEABVioHashString@@XZ:PROC ; ioSkill::GetPreDelayAniName
EXTRN	?GetPreDelayTime@ioSkill@@UBEKXZ:PROC		; ioSkill::GetPreDelayTime
EXTRN	?GetPreDelayOwnerEffect@ioSkill@@UBEABVioHashString@@XZ:PROC ; ioSkill::GetPreDelayOwnerEffect
EXTRN	?GetPreDelayOtherEffect@ioSkill@@UBEABVioHashString@@XZ:PROC ; ioSkill::GetPreDelayOtherEffect
EXTRN	?SetCancelSkill@ioSkill@@UAEXPAVioBaseChar@@@Z:PROC ; ioSkill::SetCancelSkill
EXTRN	?ClearAirJump@ioSkill@@MAEXXZ:PROC		; ioSkill::ClearAirJump
EXTRN	?SetAirJump@ioSkill@@MAEXPAVioBaseChar@@HM@Z:PROC ; ioSkill::SetAirJump
EXTRN	?CheckAirJump@ioSkill@@MAEXPAVioBaseChar@@@Z:PROC ; ioSkill::CheckAirJump
EXTRN	?UseActiveCount@ioSkill@@UAE_NPAVioBaseChar@@@Z:PROC ; ioSkill::UseActiveCount
EXTRN	?GetMaxActiveCount@ioSkill@@UAEHPAVioBaseChar@@@Z:PROC ; ioSkill::GetMaxActiveCount
EXTRN	?GetCurActiveCount@ioSkill@@UAEHPAVioBaseChar@@@Z:PROC ; ioSkill::GetCurActiveCount
EXTRN	?HideHPGauge@ioSkill@@UAE_NXZ:PROC		; ioSkill::HideHPGauge
EXTRN	?SetInfoByApplyWeapon@ioSkill@@UAEXPAVioBaseChar@@0K_N@Z:PROC ; ioSkill::SetInfoByApplyWeapon
EXTRN	?SetCollisionByApplySkill@ioSkill@@UAEXXZ:PROC	; ioSkill::SetCollisionByApplySkill
EXTRN	?SetChargingRateForWeapon@ioSkill@@UAEXPAVioWeapon@@@Z:PROC ; ioSkill::SetChargingRateForWeapon
EXTRN	?CheckExceptionCamera@ioSkill@@UAE_NXZ:PROC	; ioSkill::CheckExceptionCamera
EXTRN	?GetExceptionCameraPos@ioSkill@@UAE?AUD3DXVECTOR3@@PAVioBaseChar@@@Z:PROC ; ioSkill::GetExceptionCameraPos
EXTRN	?IsFixedExceptionCamera@ioSkill@@UAE_NXZ:PROC	; ioSkill::IsFixedExceptionCamera
EXTRN	??_EioRangeSyncBuffSkill@@UAEPAXI@Z:PROC	; ioRangeSyncBuffSkill::`vector deleting destructor'
EXTRN	?StartPreDelayAnimation@ioRangeSkill@@UAE_NPAVioBaseChar@@@Z:PROC ; ioRangeSkill::StartPreDelayAnimation
EXTRN	?SetActionState@ioRangeSkill@@MAEXPAVioBaseChar@@@Z:PROC ; ioRangeSkill::SetActionState
EXTRN	?SetEndState@ioRangeSkill@@MAEXPAVioBaseChar@@@Z:PROC ; ioRangeSkill::SetEndState
EXTRN	?SetEnemyRandomBuffList@ioRangeSkill@@MAE_NPAVioBaseChar@@0@Z:PROC ; ioRangeSkill::SetEnemyRandomBuffList
EXTRN	?IsCanStateEscape@ioRangeSkill@@UBE_NXZ:PROC	; ioRangeSkill::IsCanStateEscape
EXTRN	?IsCanStateEscapeOnStand@ioRangeSkill@@UBE_NPAVioBaseChar@@@Z:PROC ; ioRangeSkill::IsCanStateEscapeOnStand
EXTRN	?IsCanStateEscapeOnAir@ioRangeSkill@@UBE_NPAVioBaseChar@@@Z:PROC ; ioRangeSkill::IsCanStateEscapeOnAir
EXTRN	?IsCanStateEscapeOnDown@ioRangeSkill@@UBE_NPAVioBaseChar@@@Z:PROC ; ioRangeSkill::IsCanStateEscapeOnDown
;	COMDAT ??_R2ioSkill@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iorangesyncbuffskill.cpp
rdata$r	SEGMENT
??_R2ioSkill@@8 DD FLAT:??_R1A@?0A@EA@ioSkill@@8	; ioSkill::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ioSkill@@8
rdata$r	SEGMENT
??_R3ioSkill@@8 DD 00H					; ioSkill::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ioSkill@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioSkill@@@8
_DATA	SEGMENT
??_R0?AVioSkill@@@8 DD FLAT:??_7type_info@@6B@		; ioSkill `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioSkill@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@ioSkill@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioSkill@@8 DD FLAT:??_R0?AVioSkill@@@8	; ioSkill::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioSkill@@8
rdata$r	ENDS
;	COMDAT ??_R2ioRangeSkill@@8
rdata$r	SEGMENT
??_R2ioRangeSkill@@8 DD FLAT:??_R1A@?0A@EA@ioRangeSkill@@8 ; ioRangeSkill::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ioSkill@@8
rdata$r	ENDS
;	COMDAT ??_R3ioRangeSkill@@8
rdata$r	SEGMENT
??_R3ioRangeSkill@@8 DD 00H				; ioRangeSkill::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ioRangeSkill@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioRangeSkill@@@8
_DATA	SEGMENT
??_R0?AVioRangeSkill@@@8 DD FLAT:??_7type_info@@6B@	; ioRangeSkill `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioRangeSkill@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@ioRangeSkill@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioRangeSkill@@8 DD FLAT:??_R0?AVioRangeSkill@@@8 ; ioRangeSkill::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioRangeSkill@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ioRangeSyncBuffSkill@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioRangeSyncBuffSkill@@8 DD FLAT:??_R0?AVioRangeSyncBuffSkill@@@8 ; ioRangeSyncBuffSkill::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioRangeSyncBuffSkill@@8
rdata$r	ENDS
;	COMDAT ??_R2ioRangeSyncBuffSkill@@8
rdata$r	SEGMENT
??_R2ioRangeSyncBuffSkill@@8 DD FLAT:??_R1A@?0A@EA@ioRangeSyncBuffSkill@@8 ; ioRangeSyncBuffSkill::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ioRangeSkill@@8
	DD	FLAT:??_R1A@?0A@EA@ioSkill@@8
rdata$r	ENDS
;	COMDAT ??_R3ioRangeSyncBuffSkill@@8
rdata$r	SEGMENT
??_R3ioRangeSyncBuffSkill@@8 DD 00H			; ioRangeSyncBuffSkill::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2ioRangeSyncBuffSkill@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioRangeSyncBuffSkill@@@8
_DATA	SEGMENT
??_R0?AVioRangeSyncBuffSkill@@@8 DD FLAT:??_7type_info@@6B@ ; ioRangeSyncBuffSkill `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioRangeSyncBuffSkill@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ioRangeSyncBuffSkill@@6B@
rdata$r	SEGMENT
??_R4ioRangeSyncBuffSkill@@6B@ DD 00H			; ioRangeSyncBuffSkill::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVioRangeSyncBuffSkill@@@8
	DD	FLAT:??_R3ioRangeSyncBuffSkill@@8
rdata$r	ENDS
;	COMDAT ??_7ioRangeSyncBuffSkill@@6B@
CONST	SEGMENT
??_7ioRangeSyncBuffSkill@@6B@ DD FLAT:??_R4ioRangeSyncBuffSkill@@6B@ ; ioRangeSyncBuffSkill::`vftable'
	DD	FLAT:?LoadProperty@ioRangeSyncBuffSkill@@UAEXAAVioINILoader@@@Z
	DD	FLAT:?Clone@ioRangeSyncBuffSkill@@UAEPAVioSkill@@XZ
	DD	FLAT:?GetTypeID@ioRangeSkill@@UBEHXZ
	DD	FLAT:?IsProtected@ioRangeSkill@@UBE_NH@Z
	DD	FLAT:?IsCanSwitchSkill@ioSkill@@UBE_NXZ
	DD	FLAT:?IsCanSemiSwitchSkill@ioSkill@@UBE_NXZ
	DD	FLAT:?IsCanCancelBySkill@ioSkill@@UBE_NPAVioBaseChar@@AAH@Z
	DD	FLAT:?IsCanUseZeroHP@ioSkill@@UBE_NPAVioBaseChar@@@Z
	DD	FLAT:?IsCanUseSkillWithCrown@ioSkill@@UAE_NPAVioBaseChar@@@Z
	DD	FLAT:?IsCanUseBoss@ioSkill@@UBE_NPAVioBaseChar@@@Z
	DD	FLAT:?IsCanUseFootball@ioSkill@@UBE_NXZ
	DD	FLAT:?IsCanUseGangSiMode@ioSkill@@UBE_NXZ
	DD	FLAT:?IsCanUseByWeaponType@ioSkill@@UBE_NPAVioBaseChar@@@Z
	DD	FLAT:?IsCanUseThunderBirdHold@ioSkill@@UBE_NPAVioBaseChar@@@Z
	DD	FLAT:?IsCanUseLimitHP@ioSkill@@UBE_NPAVioBaseChar@@@Z
	DD	FLAT:?IsCanUseSkill@ioRangeSkill@@UAE_NPAVioBaseChar@@_N@Z
	DD	FLAT:?IsOnOffEnable@ioSkill@@UAE_NXZ
	DD	FLAT:?IsCanDefenseStateSkill@ioSkill@@UAE_NXZ
	DD	FLAT:?SetDefenseStateSkill@ioSkill@@UAEXPAVioBaseChar@@@Z
	DD	FLAT:?GetDefenseSkillBreakeType@ioSkill@@UBE?AW4DefenseBreakType@@XZ
	DD	FLAT:?HasBuff@ioSkill@@UBE_NH@Z
	DD	FLAT:?GetBuffType@ioSkill@@UAEHH@Z
	DD	FLAT:?IsEnableReserve@ioSkill@@UBE_NXZ
	DD	FLAT:?IsSkillMotionEnd@ioRangeSkill@@UBE_NKPAVioBaseChar@@@Z
	DD	FLAT:?IsCharSkipState@ioSkill@@UBE?AW4SkillCharColType@@XZ
	DD	FLAT:?IsEntityCollisionSkipState@ioSkill@@UBE_NXZ
	DD	FLAT:?GetSkillEndNextJumpAmt@ioSkill@@UBEMXZ
	DD	FLAT:?GetSkillEndNextLandRate@ioSkill@@UBEMXZ
	DD	FLAT:?GetSkillEndNextJumpMustEnable@ioSkill@@UAE?AW4SkillEndJumpType@@XZ
	DD	FLAT:?IsEndState@ioSkill@@UBE_NXZ
	DD	FLAT:?IsAttackEndState@ioSkill@@UBE_NXZ
	DD	FLAT:?IsJumpState@ioSkill@@UBE_NXZ
	DD	FLAT:?IsDownState@ioSkill@@UBE_NXZ
	DD	FLAT:?IsNoDropState@ioSkill@@UBE_NXZ
	DD	FLAT:?IsCanSendControl@ioSkill@@UBE_NXZ
	DD	FLAT:?IsSkipState@ioSkill@@UBE_NXZ
	DD	FLAT:?GetSkillMoveRate@ioSkill@@UBEMXZ
	DD	FLAT:?SetSkillGrapplingState@ioSkill@@UAE_NPAVioBaseChar@@ABVioHashString@@@Z
	DD	FLAT:?GetGrapplingTargetPos@ioSkill@@UAE?AUD3DXVECTOR3@@PAVioBaseChar@@0@Z
	DD	FLAT:?GetGrapplingTargetPos@ioSkill@@UAE?AUD3DXVECTOR3@@PAVioBaseChar@@@Z
	DD	FLAT:?EnableChangeGrapplingTargetPos@ioSkill@@UBE_NXZ
	DD	FLAT:?GetSkillWoundGrapplingInfo@ioSkill@@UAE?AUGrapplingSkillWoundedInfo@@XZ
	DD	FLAT:?SetCreateWeaponDependency@ioSkill@@UAEXPAVioBaseChar@@PAVioPlayStage@@@Z
	DD	FLAT:?SetNextSkillState@ioSkill@@UAEXPAVioBaseChar@@PAVioWeapon@@@Z
	DD	FLAT:?OnSkillStart@ioRangeSkill@@UAE_NPAVioBaseChar@@@Z
	DD	FLAT:?OnProcessState@ioRangeSyncBuffSkill@@MAEXPAVioBaseChar@@PAVioPlayStage@@@Z
	DD	FLAT:?OnSkillEndByWounded@ioSkill@@UAEXPAVioBaseChar@@@Z
	DD	FLAT:?OnSkillEnd@ioRangeSyncBuffSkill@@UAEXPAVioBaseChar@@@Z
	DD	FLAT:?OnProcessNotUseSkill@ioSkill@@UAEXPAVioBaseChar@@PAVioPlayStage@@@Z
	DD	FLAT:?OnSkillItemRelease@ioSkill@@UAEXPAVioBaseChar@@@Z
	DD	FLAT:?ApplyAttributeToWeapon@ioSkill@@UAEXPAVioWeapon@@PAVioPlayStage@@@Z
	DD	FLAT:?ApplyExtraSkillInfo@ioRangeSyncBuffSkill@@UAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z
	DD	FLAT:?ApplyEquipSlotSkillExtraInfo@ioSkill@@UAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z
	DD	FLAT:?ApplyExtraPassiveSkillInfo@ioSkill@@UAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z
	DD	FLAT:?StartPreDelayEffect@ioSkill@@UAEXPAVioBaseChar@@@Z
	DD	FLAT:?EndPreDelayEffect@ioSkill@@UAEXPAVioBaseChar@@@Z
	DD	FLAT:?IsUseAutoTargetValue@ioSkill@@UAE_NXZ
	DD	FLAT:?IsAutoTargetDownState@ioSkill@@UAE_NXZ
	DD	FLAT:?CheckUseBuff@ioSkill@@UAE_NPAVioBaseChar@@@Z
	DD	FLAT:?CheckUseItemMesh@ioRangeSkill@@UAE_NXZ
	DD	FLAT:?CheckUseActiveCount@ioSkill@@UAE_NXZ
	DD	FLAT:?CheckAniRotate@ioSkill@@UAEXPAVioBaseChar@@@Z
	DD	FLAT:?IsEnableDashCheck@ioSkill@@UAE_NPAVioBaseChar@@@Z
	DD	FLAT:?IsEnableMultiActive@ioSkill@@UAE_NPAVioBaseChar@@@Z
	DD	FLAT:?IsInvisibleBottomCircle@ioSkill@@UAE_NPAVioBaseChar@@@Z
	DD	FLAT:?GetAutoTargetValue@ioSkill@@UAEXAAM00@Z
	DD	FLAT:?IsCanJumpingSkill@ioSkill@@UBE_NXZ
	DD	FLAT:?IsCanJumpingSkillOnBlowWound@ioSkill@@UBE_NXZ
	DD	FLAT:?IsCanDownSkill@ioSkill@@UBE_NXZ
	DD	FLAT:?IsCanBlowWoundSkill@ioSkill@@UBE_NXZ
	DD	FLAT:?IsCanWoundSkill@ioSkill@@UBE_NXZ
	DD	FLAT:?GetSkillGravityRate@ioSkill@@UAEMXZ
	DD	FLAT:?GetSkillMotionName@ioSkill@@UBEABVioHashString@@XZ
	DD	FLAT:?HasSkillMotion@ioSkill@@UBE_NXZ
	DD	FLAT:?GetSkillMotionRate@ioSkill@@UBEMXZ
	DD	FLAT:?IsPreDelayProtect@ioSkill@@UBE_NXZ
	DD	FLAT:?GetPreDelayAniName@ioSkill@@UBEABVioHashString@@XZ
	DD	FLAT:?GetPreDelayTime@ioSkill@@UBEKXZ
	DD	FLAT:?GetPreDelayOwnerEffect@ioSkill@@UBEABVioHashString@@XZ
	DD	FLAT:?GetPreDelayOtherEffect@ioSkill@@UBEABVioHashString@@XZ
	DD	FLAT:?SetCancelSkill@ioSkill@@UAEXPAVioBaseChar@@@Z
	DD	FLAT:?ClearAirJump@ioSkill@@MAEXXZ
	DD	FLAT:?SetAirJump@ioSkill@@MAEXPAVioBaseChar@@HM@Z
	DD	FLAT:?CheckAirJump@ioSkill@@MAEXPAVioBaseChar@@@Z
	DD	FLAT:?UseActiveCount@ioSkill@@UAE_NPAVioBaseChar@@@Z
	DD	FLAT:?GetMaxActiveCount@ioSkill@@UAEHPAVioBaseChar@@@Z
	DD	FLAT:?GetCurActiveCount@ioSkill@@UAEHPAVioBaseChar@@@Z
	DD	FLAT:?HideHPGauge@ioSkill@@UAE_NXZ
	DD	FLAT:?SetInfoByApplyWeapon@ioSkill@@UAEXPAVioBaseChar@@0K_N@Z
	DD	FLAT:?SetCollisionByApplySkill@ioSkill@@UAEXXZ
	DD	FLAT:?SetChargingRateForWeapon@ioSkill@@UAEXPAVioWeapon@@@Z
	DD	FLAT:?CheckExceptionCamera@ioSkill@@UAE_NXZ
	DD	FLAT:?GetExceptionCameraPos@ioSkill@@UAE?AUD3DXVECTOR3@@PAVioBaseChar@@@Z
	DD	FLAT:?IsFixedExceptionCamera@ioSkill@@UAE_NXZ
	DD	FLAT:?IsUseActiveCnt@ioSkill@@UBE_NXZ
	DD	FLAT:?GetMaxActiveCnt@ioSkill@@UBEHPAVioBaseChar@@@Z
	DD	FLAT:?GetCurActiveCnt@ioSkill@@UBEHPAVioBaseChar@@@Z
	DD	FLAT:??_EioRangeSyncBuffSkill@@UAEPAXI@Z
	DD	FLAT:?StartPreDelayAnimation@ioRangeSkill@@UAE_NPAVioBaseChar@@@Z
	DD	FLAT:?SetActionState@ioRangeSkill@@MAEXPAVioBaseChar@@@Z
	DD	FLAT:?SetLoopState@ioRangeSyncBuffSkill@@MAEXPAVioBaseChar@@PAVioPlayStage@@@Z
	DD	FLAT:?SetEndState@ioRangeSkill@@MAEXPAVioBaseChar@@@Z
	DD	FLAT:?SetEnemyBuffList@ioRangeSyncBuffSkill@@MAE_NPAVioBaseChar@@0@Z
	DD	FLAT:?SetEnemyRandomBuffList@ioRangeSkill@@MAE_NPAVioBaseChar@@0@Z
	DD	FLAT:?IsCanStateEscape@ioRangeSkill@@UBE_NXZ
	DD	FLAT:?IsCanStateEscapeOnStand@ioRangeSkill@@UBE_NPAVioBaseChar@@@Z
	DD	FLAT:?IsCanStateEscapeOnAir@ioRangeSkill@@UBE_NPAVioBaseChar@@@Z
	DD	FLAT:?IsCanStateEscapeOnDown@ioRangeSkill@@UBE_NPAVioBaseChar@@@Z
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??0ioRangeSyncBuffSkill@@QAE@XZ
_TEXT	SEGMENT
??0ioRangeSyncBuffSkill@@QAE@XZ PROC			; ioRangeSyncBuffSkill::ioRangeSyncBuffSkill, COMDAT
; _this$ = ecx

; 12   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??0ioRangeSkill@@QAE@XZ	; ioRangeSkill::ioRangeSkill
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioRangeSyncBuffSkill@@6B@

; 13   : }

  0000e	8b c6		 mov	 eax, esi
  00010	5e		 pop	 esi
  00011	c3		 ret	 0
??0ioRangeSyncBuffSkill@@QAE@XZ ENDP			; ioRangeSyncBuffSkill::ioRangeSyncBuffSkill
_TEXT	ENDS
PUBLIC	??0ioRangeSyncBuffSkill@@QAE@ABV0@@Z		; ioRangeSyncBuffSkill::ioRangeSyncBuffSkill
EXTRN	??0ioRangeSkill@@QAE@ABV0@@Z:PROC		; ioRangeSkill::ioRangeSkill
; Function compile flags: /Ogsp
;	COMDAT ??0ioRangeSyncBuffSkill@@QAE@ABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??0ioRangeSyncBuffSkill@@QAE@ABV0@@Z PROC		; ioRangeSyncBuffSkill::ioRangeSyncBuffSkill, COMDAT
; _this$ = ecx

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	ff 75 08	 push	 DWORD PTR _rhs$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	e8 00 00 00 00	 call	 ??0ioRangeSkill@@QAE@ABV0@@Z ; ioRangeSkill::ioRangeSkill
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioRangeSyncBuffSkill@@6B@

; 18   : }

  00014	8b c6		 mov	 eax, esi
  00016	5e		 pop	 esi
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
??0ioRangeSyncBuffSkill@@QAE@ABV0@@Z ENDP		; ioRangeSyncBuffSkill::ioRangeSyncBuffSkill
_TEXT	ENDS
PUBLIC	??1ioRangeSyncBuffSkill@@UAE@XZ			; ioRangeSyncBuffSkill::~ioRangeSyncBuffSkill
EXTRN	??1ioRangeSkill@@UAE@XZ:PROC			; ioRangeSkill::~ioRangeSkill
; Function compile flags: /Ogsp
;	COMDAT ??1ioRangeSyncBuffSkill@@UAE@XZ
_TEXT	SEGMENT
??1ioRangeSyncBuffSkill@@UAE@XZ PROC			; ioRangeSyncBuffSkill::~ioRangeSyncBuffSkill, COMDAT
; _this$ = ecx

; 21   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ioRangeSyncBuffSkill@@6B@

; 22   : }

  00006	e9 00 00 00 00	 jmp	 ??1ioRangeSkill@@UAE@XZ	; ioRangeSkill::~ioRangeSkill
??1ioRangeSyncBuffSkill@@UAE@XZ ENDP			; ioRangeSyncBuffSkill::~ioRangeSyncBuffSkill
_TEXT	ENDS
EXTRN	?LoadProperty@ioRangeSkill@@UAEXAAVioINILoader@@@Z:PROC ; ioRangeSkill::LoadProperty
; Function compile flags: /Ogsp
;	COMDAT ?LoadProperty@ioRangeSyncBuffSkill@@UAEXAAVioINILoader@@@Z
_TEXT	SEGMENT
_rkLoader$ = 8						; size = 4
?LoadProperty@ioRangeSyncBuffSkill@@UAEXAAVioINILoader@@@Z PROC ; ioRangeSyncBuffSkill::LoadProperty, COMDAT
; _this$ = ecx

; 25   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 27   : }

  00003	5d		 pop	 ebp

; 26   : 	ioRangeSkill::LoadProperty( rkLoader );

  00004	e9 00 00 00 00	 jmp	 ?LoadProperty@ioRangeSkill@@UAEXAAVioINILoader@@@Z ; ioRangeSkill::LoadProperty
?LoadProperty@ioRangeSyncBuffSkill@@UAEXAAVioINILoader@@@Z ENDP ; ioRangeSyncBuffSkill::LoadProperty
_TEXT	ENDS
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__EH_epilog3:PROC
EXTRN	__EH_prolog3:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Clone@ioRangeSyncBuffSkill@@UAEPAVioSkill@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Clone@ioRangeSyncBuffSkill@@UAEPAVioSkill@@XZ$0
__ehfuncinfo$?Clone@ioRangeSyncBuffSkill@@UAEPAVioSkill@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Clone@ioRangeSyncBuffSkill@@UAEPAVioSkill@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ?Clone@ioRangeSyncBuffSkill@@UAEPAVioSkill@@XZ
_TEXT	SEGMENT
$T532465 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Clone@ioRangeSyncBuffSkill@@UAEPAVioSkill@@XZ PROC	; ioRangeSyncBuffSkill::Clone, COMDAT
; _this$ = ecx

; 30   : {

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?Clone@ioRangeSyncBuffSkill@@UAEPAVioSkill@@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx

; 31   : 	return new ioRangeSyncBuffSkill( *this );

  0000e	68 54 11 00 00	 push	 4436			; 00001154H
  00013	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00018	59		 pop	 ecx
  00019	8b c8		 mov	 ecx, eax
  0001b	89 4d f0	 mov	 DWORD PTR $T532465[ebp], ecx
  0001e	33 c0		 xor	 eax, eax
  00020	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], eax
  00023	3b c8		 cmp	 ecx, eax
  00025	74 06		 je	 SHORT $LN3@Clone
  00027	56		 push	 esi
  00028	e8 00 00 00 00	 call	 ??0ioRangeSyncBuffSkill@@QAE@ABV0@@Z ; ioRangeSyncBuffSkill::ioRangeSyncBuffSkill
$LN3@Clone:

; 32   : }

  0002d	e8 00 00 00 00	 call	 __EH_epilog3
  00032	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Clone@ioRangeSyncBuffSkill@@UAEPAVioSkill@@XZ$0:
  00000	ff 75 f0	 push	 DWORD PTR $T532465[ebp]
  00003	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00008	59		 pop	 ecx
  00009	c3		 ret	 0
__ehhandler$?Clone@ioRangeSyncBuffSkill@@UAEPAVioSkill@@XZ:
  0000a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00011	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00014	33 c8		 xor	 ecx, eax
  00016	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Clone@ioRangeSyncBuffSkill@@UAEPAVioSkill@@XZ
  00020	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Clone@ioRangeSyncBuffSkill@@UAEPAVioSkill@@XZ ENDP	; ioRangeSyncBuffSkill::Clone
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 49   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
PUBLIC	??A?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEAAVioHashString@@I@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::operator[]
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??A?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEAAVioHashString@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEAAVioHashString@@I@Z PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00006	c1 e0 04	 shl	 eax, 4
  00009	03 01		 add	 eax, DWORD PTR [ecx]

; 941  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEAAVioHashString@@I@Z ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::operator[]
_TEXT	ENDS
PUBLIC	?empty@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QBE_NXZ ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::empty
; Function compile flags: /Ogsp
;	COMDAT ?empty@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QBE_NXZ PROC ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::empty, COMDAT
; _this$ = ecx

; 889  : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00005	f7 d8		 neg	 eax
  00007	1b c0		 sbb	 eax, eax
  00009	40		 inc	 eax

; 890  : 		}

  0000a	c3		 ret	 0
?empty@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QBE_NXZ ENDP ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::empty
_TEXT	ENDS
PUBLIC	??A?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEAAUBuffInfoStruct@@I@Z ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::operator[]
; Function compile flags: /Ogsp
;	COMDAT ??A?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEAAUBuffInfoStruct@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEAAUBuffInfoStruct@@I@Z PROC ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00006	6b c0 14	 imul	 eax, 20			; 00000014H
  00009	03 01		 add	 eax, DWORD PTR [ecx]

; 941  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QAEAAUBuffInfoStruct@@I@Z ENDP ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::operator[]
_TEXT	ENDS
PUBLIC	?_Inside@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IBE_NPBVioHashString@@@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::_Inside
; Function compile flags: /Ogsp
;	COMDAT ?_Inside@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IBE_NPBVioHashString@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IBE_NPBVioHashString@@@Z PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 09		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 05		 ja	 SHORT $LN3@Inside
  0000f	33 c0		 xor	 eax, eax
  00011	40		 inc	 eax
  00012	eb 02		 jmp	 SHORT $LN4@Inside
$LN3@Inside:
  00014	33 c0		 xor	 eax, eax
$LN4@Inside:

; 1287 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?_Inside@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IBE_NPBVioHashString@@@Z ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::_Inside
_TEXT	ENDS
PUBLIC	?_Orphan_range@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IBEXPAVioHashString@@0@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::_Orphan_range
; Function compile flags: /Ogsp
;	COMDAT ?_Orphan_range@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IBEXPAVioHashString@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IBEXPAVioHashString@@0@Z PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1454 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IBEXPAVioHashString@@0@Z ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE@XZ ; std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> >::~_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> >::~_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> >::~_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVioBaseChar@@@std@@QAE@XZ	; std::allocator<ioBaseChar *>::allocator<ioBaseChar *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVioBaseChar@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVioBaseChar@@@std@@QAE@XZ PROC		; std::allocator<ioBaseChar *>::allocator<ioBaseChar *>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@PAVioBaseChar@@@std@@QAE@XZ ENDP		; std::allocator<ioBaseChar *>::allocator<ioBaseChar *>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with null pointer

  00000	8b c1		 mov	 eax, ecx
  00002	83 20 00	 and	 DWORD PTR [eax], 0

; 41   : 		}

  00005	c3		 ret	 0
??0?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBEABQAVioBaseChar@@XZ ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator*
; Function compile flags: /Ogsp
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBEABQAVioBaseChar@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBEABQAVioBaseChar@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator*, COMDAT
; _this$ = ecx

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);
; 83   : 
; 84   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 85   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBEABQAVioBaseChar@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator++
; Function compile flags: /Ogsp
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator++, COMDAT
; _this$ = ecx

; 93   : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

  00002	83 00 04	 add	 DWORD PTR [eax], 4

; 111  : 		return (*this);
; 112  : 		}

  00005	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator++
_TEXT	ENDS
PUBLIC	?capacity@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBEIXZ ; std::vector<ioHashString,std::allocator<ioHashString> >::capacity
; Function compile flags: /Ogsp
;	COMDAT ?capacity@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBEIXZ PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::capacity, COMDAT
; _this$ = ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 04	 sar	 eax, 4

; 778  : 		}

  00008	c3		 ret	 0
?capacity@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBEIXZ ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::capacity
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVioBaseChar@@@std@@QAE@ABV01@@Z ; std::allocator<ioBaseChar *>::allocator<ioBaseChar *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVioBaseChar@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVioBaseChar@@@std@@QAE@ABV01@@Z PROC	; std::allocator<ioBaseChar *>::allocator<ioBaseChar *>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@PAVioBaseChar@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<ioBaseChar *>::allocator<ioBaseChar *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVioBaseChar@@@std@@QAEXPAPAVioBaseChar@@I@Z ; std::allocator<ioBaseChar *>::deallocate
; Function compile flags: /Ogsp
;	COMDAT ?deallocate@?$allocator@PAVioBaseChar@@@std@@QAEXPAPAVioBaseChar@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVioBaseChar@@@std@@QAEXPAPAVioBaseChar@@I@Z PROC ; std::allocator<ioBaseChar *>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 183  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVioBaseChar@@@std@@QAEXPAPAVioBaseChar@@I@Z ENDP ; std::allocator<ioBaseChar *>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@PAPAVioBaseChar@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@PAPAVioBaseChar@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@PAPAVioBaseChar@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@PAPAVioBaseChar@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Compat
; Function compile flags: /Ogsp
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Compat, COMDAT
; _this$ = ecx

; 253  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Compat
_TEXT	ENDS
PUBLIC	??$addressof@$$CBVioHashString@@@std@@YAPBVioHashString@@ABV1@@Z ; std::addressof<ioHashString const >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$addressof@$$CBVioHashString@@@std@@YAPBVioHashString@@ABV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBVioHashString@@@std@@YAPBVioHashString@@ABV1@@Z PROC ; std::addressof<ioHashString const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBVioHashString@@@std@@YAPBVioHashString@@ABV1@@Z ENDP ; std::addressof<ioHashString const >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVioBaseChar@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVioBaseChar@@0@Z ; std::_Ptr_cat<ioBaseChar *,ioBaseChar *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVioBaseChar@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVioBaseChar@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVioBaseChar@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVioBaseChar@@0@Z PROC ; std::_Ptr_cat<ioBaseChar *,ioBaseChar *>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	c9		 leave
  00008	c3		 ret	 0
??$_Ptr_cat@PAVioBaseChar@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVioBaseChar@@0@Z ENDP ; std::_Ptr_cat<ioBaseChar *,ioBaseChar *>
_TEXT	ENDS
PUBLIC	??$_Move@PAPAVioBaseChar@@PAPAV1@@std@@YAPAPAVioBaseChar@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<ioBaseChar * *,ioBaseChar * *>
EXTRN	__imp__memmove:PROC
; Function compile flags: /Ogsp
;	COMDAT ??$_Move@PAPAVioBaseChar@@PAPAV1@@std@@YAPAPAVioBaseChar@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAPAVioBaseChar@@PAPAV1@@std@@YAPAPAVioBaseChar@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<ioBaseChar * *,ioBaseChar * *>, COMDAT

; 2522 : 	{	// move [_First, _Last) to [_Dest, ...), pointers to scalars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2523 : 	ptrdiff_t _Count = _Last - _First;

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  00007	2b 75 08	 sub	 esi, DWORD PTR __First$[ebp]
  0000a	57		 push	 edi

; 2524 : 	_CSTD memmove(&*_Dest, &*_First,
; 2525 : 		_Count * sizeof (*_First));

  0000b	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
  0000e	c1 fe 02	 sar	 esi, 2
  00011	c1 e6 02	 shl	 esi, 2
  00014	56		 push	 esi
  00015	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00018	57		 push	 edi
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2526 : 	return (_Dest + _Count);

  00022	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 2527 : 	}

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Move@PAPAVioBaseChar@@PAPAV1@@std@@YAPAPAVioBaseChar@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<ioBaseChar * *,ioBaseChar * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVioBaseChar@@@std@@@std@@YAXPAPAVioBaseChar@@0AAV?$allocator@PAVioBaseChar@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<ioBaseChar *> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVioBaseChar@@@std@@@std@@YAXPAPAVioBaseChar@@0AAV?$allocator@PAVioBaseChar@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVioBaseChar@@@std@@@std@@YAXPAPAVioBaseChar@@0AAV?$allocator@PAVioBaseChar@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<ioBaseChar *> >, COMDAT

; 105  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVioBaseChar@@@std@@@std@@YAXPAPAVioBaseChar@@0AAV?$allocator@PAVioBaseChar@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<ioBaseChar *> >
_TEXT	ENDS
PUBLIC	??$_Val_type@PAVioHashString@@@std@@YAPAVioHashString@@PAV1@@Z ; std::_Val_type<ioHashString *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAVioHashString@@@std@@YAPAVioHashString@@PAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAVioHashString@@@std@@YAPAVioHashString@@PAV1@@Z PROC ; std::_Val_type<ioHashString *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAVioHashString@@@std@@YAPAVioHashString@@PAV1@@Z ENDP ; std::_Val_type<ioHashString *>
_TEXT	ENDS
PUBLIC	??$forward@VioHashString@@@std@@YA$$QAVioHashString@@AAV1@@Z ; std::forward<ioHashString>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@VioHashString@@@std@@YA$$QAVioHashString@@AAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@VioHashString@@@std@@YA$$QAVioHashString@@AAV1@@Z PROC ; std::forward<ioHashString>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@VioHashString@@@std@@YA$$QAVioHashString@@AAV1@@Z ENDP ; std::forward<ioHashString>
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
EXTRN	__fltused:DWORD
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx9math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 303  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 304  :     x = fx;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00008	8b c1		 mov	 eax, ecx
  0000a	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 305  :     y = fy;

  0000e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00013	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 306  :     z = fz;

  00018	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0001d	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 307  : }

  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
PUBLIC	??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z			; D3DXVECTOR3::operator+=
; Function compile flags: /Ogsp
;	COMDAT ??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z PROC			; D3DXVECTOR3::operator+=, COMDAT
; _this$ = ecx

; 327  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 328  :     x += v.x;

  00005	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00008	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0000c	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  00010	0f 5a c0	 cvtps2pd xmm0, xmm0
  00013	0f 5a c9	 cvtps2pd xmm1, xmm1
  00016	f2 0f 58 c1	 addsd	 xmm0, xmm1

; 329  :     y += v.y;

  0001a	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  0001f	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00023	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00027	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0002c	0f 5a c0	 cvtps2pd xmm0, xmm0
  0002f	0f 5a c9	 cvtps2pd xmm1, xmm1
  00032	f2 0f 58 c1	 addsd	 xmm0, xmm1

; 330  :     z += v.z;

  00036	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  0003b	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0003f	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  00044	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00049	0f 5a c0	 cvtps2pd xmm0, xmm0
  0004c	0f 5a c9	 cvtps2pd xmm1, xmm1
  0004f	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00053	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00057	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 331  :     return *this;
; 332  : }

  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator+=
_TEXT	ENDS
PUBLIC	??ZD3DXVECTOR3@@QAEAAU0@ABU0@@Z			; D3DXVECTOR3::operator-=
; Function compile flags: /Ogsp
;	COMDAT ??ZD3DXVECTOR3@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
??ZD3DXVECTOR3@@QAEAAU0@ABU0@@Z PROC			; D3DXVECTOR3::operator-=, COMDAT
; _this$ = ecx

; 336  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 337  :     x -= v.x;

  00005	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00008	f3 0f 10 09	 movss	 xmm1, DWORD PTR [ecx]
  0000c	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00010	0f 5a c0	 cvtps2pd xmm0, xmm0
  00013	0f 5a c9	 cvtps2pd xmm1, xmm1
  00016	f2 0f 5c c1	 subsd	 xmm0, xmm1
  0001a	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0001e	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 338  :     y -= v.y;

  00022	f3 0f 10 49 04	 movss	 xmm1, DWORD PTR [ecx+4]
  00027	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0002c	0f 5a c0	 cvtps2pd xmm0, xmm0
  0002f	0f 5a c9	 cvtps2pd xmm1, xmm1
  00032	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00036	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0003a	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 339  :     z -= v.z;

  0003f	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00044	f3 0f 10 49 08	 movss	 xmm1, DWORD PTR [ecx+8]
  00049	0f 5a c0	 cvtps2pd xmm0, xmm0
  0004c	0f 5a c9	 cvtps2pd xmm1, xmm1
  0004f	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00053	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00057	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 340  :     return *this;
; 341  : }

  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
??ZD3DXVECTOR3@@QAEAAU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator-=
_TEXT	ENDS
PUBLIC	??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z			; D3DXVECTOR3::operator+
; Function compile flags: /Ogsp
;	COMDAT ??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z PROC			; D3DXVECTOR3::operator+, COMDAT
; _this$ = ecx

; 380  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 381  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00006	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  0000a	f3 0f 10 09	 movss	 xmm1, DWORD PTR [ecx]
  0000e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00011	0f 5a c0	 cvtps2pd xmm0, xmm0
  00014	0f 5a c9	 cvtps2pd xmm1, xmm1
  00017	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0001b	f3 0f 10 49 04	 movss	 xmm1, DWORD PTR [ecx+4]
  00020	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00024	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00028	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [edx+4]
  0002d	0f 5a c0	 cvtps2pd xmm0, xmm0
  00030	0f 5a c9	 cvtps2pd xmm1, xmm1
  00033	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00037	f3 0f 10 49 08	 movss	 xmm1, DWORD PTR [ecx+8]
  0003c	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00040	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  00045	f3 0f 10 42 08	 movss	 xmm0, DWORD PTR [edx+8]
  0004a	0f 5a c0	 cvtps2pd xmm0, xmm0
  0004d	0f 5a c9	 cvtps2pd xmm1, xmm1
  00050	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00054	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00058	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 382  : }

  0005d	5d		 pop	 ebp
  0005e	c2 08 00	 ret	 8
??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator+
_TEXT	ENDS
PUBLIC	??DD3DXVECTOR3@@QBE?AU0@M@Z			; D3DXVECTOR3::operator*
; Function compile flags: /Ogsp
;	COMDAT ??DD3DXVECTOR3@@QBE?AU0@M@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_f$ = 12						; size = 4
??DD3DXVECTOR3@@QBE?AU0@M@Z PROC			; D3DXVECTOR3::operator*, COMDAT
; _this$ = ecx

; 392  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 393  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00003	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _f$[ebp]
  00008	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000f	0f 5a c0	 cvtps2pd xmm0, xmm0
  00012	0f 5a c9	 cvtps2pd xmm1, xmm1
  00015	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00019	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _f$[ebp]
  0001e	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00022	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00026	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0002b	0f 5a c0	 cvtps2pd xmm0, xmm0
  0002e	0f 5a c9	 cvtps2pd xmm1, xmm1
  00031	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00035	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _f$[ebp]
  0003a	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0003e	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  00043	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00048	0f 5a c0	 cvtps2pd xmm0, xmm0
  0004b	0f 5a c9	 cvtps2pd xmm1, xmm1
  0004e	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00052	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00056	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 394  : }

  0005b	5d		 pop	 ebp
  0005c	c2 08 00	 ret	 8
??DD3DXVECTOR3@@QBE?AU0@M@Z ENDP			; D3DXVECTOR3::operator*
_TEXT	ENDS
PUBLIC	?_DECSTR@@YAXPADH@Z				; _DECSTR
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stringprotect.h
;	COMDAT ?_DECSTR@@YAXPADH@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_l$ = 12						; size = 4
?_DECSTR@@YAXPADH@Z PROC				; _DECSTR, COMDAT

; 40   : __forceinline void _DECSTR(char* s, int l){int i=0,l4=(l-1)/4,*p=(int*)s;s[l-1]=0;for(;i<l4;++i)*(p++)^=0xEAEBECED;for(i=l4*4;i<l-1;++i)s[i]^=0xED-i%4;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _l$[ebp]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  0000a	57		 push	 edi
  0000b	8d 79 ff	 lea	 edi, DWORD PTR [ecx-1]
  0000e	8b c7		 mov	 eax, edi
  00010	99		 cdq
  00011	83 e2 03	 and	 edx, 3
  00014	03 c2		 add	 eax, edx
  00016	c1 f8 02	 sar	 eax, 2
  00019	8b d6		 mov	 edx, esi
  0001b	c6 44 0e ff 00	 mov	 BYTE PTR [esi+ecx-1], 0
  00020	85 c0		 test	 eax, eax
  00022	7e 0e		 jle	 SHORT $LN4@DECSTR
  00024	8b c8		 mov	 ecx, eax
$LL6@DECSTR:
  00026	81 32 ed ec eb
	ea		 xor	 DWORD PTR [edx], -353637139 ; eaebecedH
  0002c	83 c2 04	 add	 edx, 4
  0002f	49		 dec	 ecx
  00030	75 f4		 jne	 SHORT $LL6@DECSTR
$LN4@DECSTR:
  00032	c1 e0 02	 shl	 eax, 2
  00035	eb 17		 jmp	 SHORT $LN14@DECSTR
$LL3@DECSTR:
  00037	8b c8		 mov	 ecx, eax
  00039	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0003f	79 05		 jns	 SHORT $LN13@DECSTR
  00041	49		 dec	 ecx
  00042	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00045	41		 inc	 ecx
$LN13@DECSTR:
  00046	b2 ed		 mov	 dl, -19			; ffffffedH
  00048	2a d1		 sub	 dl, cl
  0004a	30 14 30	 xor	 BYTE PTR [eax+esi], dl
  0004d	40		 inc	 eax
$LN14@DECSTR:
  0004e	3b c7		 cmp	 eax, edi
  00050	7c e5		 jl	 SHORT $LL3@DECSTR
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?_DECSTR@@YAXPADH@Z ENDP				; _DECSTR
_TEXT	ENDS
PUBLIC	?GetGroup@ioGameEntity@@QBEPAVioEntityGroup@@XZ	; ioGameEntity::GetGroup
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iogameentity.h
;	COMDAT ?GetGroup@ioGameEntity@@QBEPAVioEntityGroup@@XZ
_TEXT	SEGMENT
?GetGroup@ioGameEntity@@QBEPAVioEntityGroup@@XZ PROC	; ioGameEntity::GetGroup, COMDAT
; _this$ = ecx

; 166  : 	inline ioEntityGroup* GetGroup() const { return m_pGroup; }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetGroup@ioGameEntity@@QBEPAVioEntityGroup@@XZ ENDP	; ioGameEntity::GetGroup
_TEXT	ENDS
PUBLIC	?GetName@ioItem@@QBEABVioHashString@@XZ		; ioItem::GetName
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioitem.h
;	COMDAT ?GetName@ioItem@@QBEABVioHashString@@XZ
_TEXT	SEGMENT
?GetName@ioItem@@QBEABVioHashString@@XZ PROC		; ioItem::GetName, COMDAT
; _this$ = ecx

; 269  : 	inline const ioHashString& GetName() const { return m_Name; }

  00000	8d 81 34 01 00
	00		 lea	 eax, DWORD PTR [ecx+308]
  00006	c3		 ret	 0
?GetName@ioItem@@QBEABVioHashString@@XZ ENDP		; ioItem::GetName
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioskill.h
_TEXT	ENDS
;	COMDAT ?GetDefenseSkillBreakeType@ioSkill@@UBE?AW4DefenseBreakType@@XZ
_TEXT	SEGMENT
?GetDefenseSkillBreakeType@ioSkill@@UBE?AW4DefenseBreakType@@XZ PROC ; ioSkill::GetDefenseSkillBreakeType, COMDAT
; _this$ = ecx

; 327  : 	virtual DefenseBreakType GetDefenseSkillBreakeType() const { return m_eDefenseSkillBreakType; }

  00000	8b 81 30 0e 00
	00		 mov	 eax, DWORD PTR [ecx+3632]
  00006	c3		 ret	 0
?GetDefenseSkillBreakeType@ioSkill@@UBE?AW4DefenseBreakType@@XZ ENDP ; ioSkill::GetDefenseSkillBreakeType
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?GetSkillEndNextJumpAmt@ioSkill@@UBEMXZ
_TEXT	SEGMENT
?GetSkillEndNextJumpAmt@ioSkill@@UBEMXZ PROC		; ioSkill::GetSkillEndNextJumpAmt, COMDAT
; _this$ = ecx

; 335  : 	virtual float GetSkillEndNextJumpAmt() const { return m_fSkillEndNextJumpAmt; }

  00000	d9 81 4c 05 00
	00		 fld	 DWORD PTR [ecx+1356]
  00006	c3		 ret	 0
?GetSkillEndNextJumpAmt@ioSkill@@UBEMXZ ENDP		; ioSkill::GetSkillEndNextJumpAmt
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?GetSkillEndNextLandRate@ioSkill@@UBEMXZ
_TEXT	SEGMENT
?GetSkillEndNextLandRate@ioSkill@@UBEMXZ PROC		; ioSkill::GetSkillEndNextLandRate, COMDAT
; _this$ = ecx

; 336  : 	virtual float GetSkillEndNextLandRate() const { return m_fSkillEndNextLandRate; }

  00000	d9 81 50 05 00
	00		 fld	 DWORD PTR [ecx+1360]
  00006	c3		 ret	 0
?GetSkillEndNextLandRate@ioSkill@@UBEMXZ ENDP		; ioSkill::GetSkillEndNextLandRate
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?GetSkillEndNextJumpMustEnable@ioSkill@@UAE?AW4SkillEndJumpType@@XZ
_TEXT	SEGMENT
?GetSkillEndNextJumpMustEnable@ioSkill@@UAE?AW4SkillEndJumpType@@XZ PROC ; ioSkill::GetSkillEndNextJumpMustEnable, COMDAT
; _this$ = ecx

; 337  : 	virtual SkillEndJumpType GetSkillEndNextJumpMustEnable(){ return SEJT_DEFAULT; }

  00000	33 c0		 xor	 eax, eax
  00002	c3		 ret	 0
?GetSkillEndNextJumpMustEnable@ioSkill@@UAE?AW4SkillEndJumpType@@XZ ENDP ; ioSkill::GetSkillEndNextJumpMustEnable
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?EnableChangeGrapplingTargetPos@ioSkill@@UBE_NXZ
_TEXT	SEGMENT
?EnableChangeGrapplingTargetPos@ioSkill@@UBE_NXZ PROC	; ioSkill::EnableChangeGrapplingTargetPos, COMDAT
; _this$ = ecx

; 355  : 	virtual bool EnableChangeGrapplingTargetPos() const { return m_bChangeGrapplingTargetPos; }

  00000	8a 81 40 09 00
	00		 mov	 al, BYTE PTR [ecx+2368]
  00006	c3		 ret	 0
?EnableChangeGrapplingTargetPos@ioSkill@@UBE_NXZ ENDP	; ioSkill::EnableChangeGrapplingTargetPos
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?IsInvisibleBottomCircle@ioSkill@@UAE_NPAVioBaseChar@@@Z
_TEXT	SEGMENT
_pChar$ = 8						; size = 4
?IsInvisibleBottomCircle@ioSkill@@UAE_NPAVioBaseChar@@@Z PROC ; ioSkill::IsInvisibleBottomCircle, COMDAT
; _this$ = ecx

; 393  : 	virtual bool IsInvisibleBottomCircle( ioBaseChar *pChar ) { return false; }

  00000	32 c0		 xor	 al, al
  00002	c2 04 00	 ret	 4
?IsInvisibleBottomCircle@ioSkill@@UAE_NPAVioBaseChar@@@Z ENDP ; ioSkill::IsInvisibleBottomCircle
_TEXT	ENDS
PUBLIC	?GetOwnerItem@ioSkill@@QBEPAVioItem@@XZ		; ioSkill::GetOwnerItem
; Function compile flags: /Ogsp
;	COMDAT ?GetOwnerItem@ioSkill@@QBEPAVioItem@@XZ
_TEXT	SEGMENT
?GetOwnerItem@ioSkill@@QBEPAVioItem@@XZ PROC		; ioSkill::GetOwnerItem, COMDAT
; _this$ = ecx

; 397  : 	inline ioItem *GetOwnerItem() const { return m_pOwnerItem; }

  00000	8b 81 a4 02 00
	00		 mov	 eax, DWORD PTR [ecx+676]
  00006	c3		 ret	 0
?GetOwnerItem@ioSkill@@QBEPAVioItem@@XZ ENDP		; ioSkill::GetOwnerItem
_TEXT	ENDS
PUBLIC	?GetName@ioSkill@@QBEABVioHashString@@XZ	; ioSkill::GetName
; Function compile flags: /Ogsp
;	COMDAT ?GetName@ioSkill@@QBEABVioHashString@@XZ
_TEXT	SEGMENT
?GetName@ioSkill@@QBEABVioHashString@@XZ PROC		; ioSkill::GetName, COMDAT
; _this$ = ecx

; 414  : 	inline const ioHashString& GetName() const { return m_Name; }

  00000	8d 41 24	 lea	 eax, DWORD PTR [ecx+36]
  00003	c3		 ret	 0
?GetName@ioSkill@@QBEABVioHashString@@XZ ENDP		; ioSkill::GetName
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?IsUseActiveCnt@ioSkill@@UBE_NXZ
_TEXT	SEGMENT
?IsUseActiveCnt@ioSkill@@UBE_NXZ PROC			; ioSkill::IsUseActiveCnt, COMDAT
; _this$ = ecx

; 544  : 	virtual bool IsUseActiveCnt() const { return false; }

  00000	32 c0		 xor	 al, al
  00002	c3		 ret	 0
?IsUseActiveCnt@ioSkill@@UBE_NXZ ENDP			; ioSkill::IsUseActiveCnt
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?GetMaxActiveCnt@ioSkill@@UBEHPAVioBaseChar@@@Z
_TEXT	SEGMENT
_pChar$ = 8						; size = 4
?GetMaxActiveCnt@ioSkill@@UBEHPAVioBaseChar@@@Z PROC	; ioSkill::GetMaxActiveCnt, COMDAT
; _this$ = ecx

; 545  : 	virtual int GetMaxActiveCnt( ioBaseChar *pChar ) const { return 0; }

  00000	33 c0		 xor	 eax, eax
  00002	c2 04 00	 ret	 4
?GetMaxActiveCnt@ioSkill@@UBEHPAVioBaseChar@@@Z ENDP	; ioSkill::GetMaxActiveCnt
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?GetCurActiveCnt@ioSkill@@UBEHPAVioBaseChar@@@Z
_TEXT	SEGMENT
_pChar$ = 8						; size = 4
?GetCurActiveCnt@ioSkill@@UBEHPAVioBaseChar@@@Z PROC	; ioSkill::GetCurActiveCnt, COMDAT
; _this$ = ecx

; 546  : 	virtual int GetCurActiveCnt( ioBaseChar *pChar ) const { return 0; }

  00000	33 c0		 xor	 eax, eax
  00002	c2 04 00	 ret	 4
?GetCurActiveCnt@ioSkill@@UBEHPAVioBaseChar@@@Z ENDP	; ioSkill::GetCurActiveCnt
_TEXT	ENDS
PUBLIC	?size@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBEIXZ ; std::vector<ioHashString,std::allocator<ioHashString> >::size
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?size@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBEIXZ PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 04	 sar	 eax, 4

; 880  : 		}

  00008	c3		 ret	 0
?size@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBEIXZ ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::size
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ ; std::_Vector_val<ioHashString,std::allocator<ioHashString> >::~_Vector_val<ioHashString,std::allocator<ioHashString> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<ioHashString,std::allocator<ioHashString> >::~_Vector_val<ioHashString,std::allocator<ioHashString> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<ioHashString,std::allocator<ioHashString> >::~_Vector_val<ioHashString,std::allocator<ioHashString> >
_TEXT	ENDS
PUBLIC	??0?$allocator@VioHashString@@@std@@QAE@XZ	; std::allocator<ioHashString>::allocator<ioHashString>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@VioHashString@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VioHashString@@@std@@QAE@XZ PROC		; std::allocator<ioHashString>::allocator<ioHashString>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@VioHashString@@@std@@QAE@XZ ENDP		; std::allocator<ioHashString>::allocator<ioHashString>
_TEXT	ENDS
PUBLIC	??0?$allocator@VioHashString@@@std@@QAE@ABV01@@Z ; std::allocator<ioHashString>::allocator<ioHashString>
; Function compile flags: /Ogsp
;	COMDAT ??0?$allocator@VioHashString@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@VioHashString@@@std@@QAE@ABV01@@Z PROC	; std::allocator<ioHashString>::allocator<ioHashString>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@VioHashString@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<ioHashString>::allocator<ioHashString>
_TEXT	ENDS
PUBLIC	?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z	; CEncrypt<unsigned long>::EncryptValueToPool
EXTRN	?EncryptByte@ccddaabb@@QAEXPBDPADH@Z:PROC	; ccddaabb::EncryptByte
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
;	COMDAT ?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z PROC	; CEncrypt<unsigned long>::EncryptValueToPool, COMDAT
; _this$ = ecx

; 67   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 		m_RC5.EncryptByte( value, m_MemPool, max(m_ValueSize, DEFAULT_ENCRYPT) );

  00003	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00007	83 f8 04	 cmp	 eax, 4
  0000a	77 03		 ja	 SHORT $LN4@EncryptVal
  0000c	6a 04		 push	 4
  0000e	58		 pop	 eax
$LN4@EncryptVal:
  0000f	50		 push	 eax
  00010	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  00013	50		 push	 eax
  00014	ff 75 08	 push	 DWORD PTR _value$[ebp]
  00017	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0001a	e8 00 00 00 00	 call	 ?EncryptByte@ccddaabb@@QAEXPBDPADH@Z ; ccddaabb::EncryptByte

; 69   : 		
; 70   : 	}

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z ENDP	; CEncrypt<unsigned long>::EncryptValueToPool
_TEXT	ENDS
PUBLIC	?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z	; CEncrypt<unsigned long>::DecryptValueToPool
EXTRN	?DecryptByte@ccddaabb@@QBEXPBDPADH@Z:PROC	; ccddaabb::DecryptByte
; Function compile flags: /Ogsp
;	COMDAT ?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z PROC	; CEncrypt<unsigned long>::DecryptValueToPool, COMDAT
; _this$ = ecx

; 1256 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1257 : 		m_RC5.DecryptByte( m_MemPool, m_TempMem, 4 );

  00004	8d 71 28	 lea	 esi, DWORD PTR [ecx+40]
  00007	6a 04		 push	 4
  00009	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00011	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte

; 1258 : 		*value = *((DWORD*)m_TempMem);

  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0001b	89 01		 mov	 DWORD PTR [ecx], eax
  0001d	5e		 pop	 esi

; 1259 : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z ENDP	; CEncrypt<unsigned long>::DecryptValueToPool
_TEXT	ENDS
PUBLIC	?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z	; CEncrypt<bool>::DecryptValueToPool
; Function compile flags: /Ogsp
;	COMDAT ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z PROC	; CEncrypt<bool>::DecryptValueToPool, COMDAT
; _this$ = ecx

; 219  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 220  : 		m_RC5.DecryptByte( m_MemPool, m_TempMem, 4 );

  00004	8d 71 28	 lea	 esi, DWORD PTR [ecx+40]
  00007	6a 04		 push	 4
  00009	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00011	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte

; 221  : 		*value = *((bool*)m_TempMem);

  00016	8a 06		 mov	 al, BYTE PTR [esi]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0001b	88 01		 mov	 BYTE PTR [ecx], al
  0001d	5e		 pop	 esi

; 222  : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ENDP	; CEncrypt<bool>::DecryptValueToPool
_TEXT	ENDS
PUBLIC	?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
; Function compile flags: /Ogsp
;	COMDAT ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z PROC ; CEncrypt<enum TeamType>::DecryptValueToPool, COMDAT
; _this$ = ecx

; 2959 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2960 : 		m_RC5.DecryptByte( m_MemPool, m_TempMem, sizeof(TeamType) );

  00004	8d 71 28	 lea	 esi, DWORD PTR [ecx+40]
  00007	6a 04		 push	 4
  00009	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00011	e8 00 00 00 00	 call	 ?DecryptByte@ccddaabb@@QBEXPBDPADH@Z ; ccddaabb::DecryptByte

; 2961 : 		*value = *((TeamType*)m_TempMem);

  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0001b	89 01		 mov	 DWORD PTR [ecx], eax
  0001d	5e		 pop	 esi

; 2962 : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ENDP ; CEncrypt<enum TeamType>::DecryptValueToPool
_TEXT	ENDS
PUBLIC	?size@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QBEIXZ ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::size
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?size@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QBEIXZ PROC ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	6a 14		 push	 20			; 00000014H
  00007	99		 cdq
  00008	59		 pop	 ecx
  00009	f7 f9		 idiv	 ecx

; 880  : 		}

  0000b	c3		 ret	 0
?size@?$vector@UBuffInfoStruct@@V?$allocator@UBuffInfoStruct@@@std@@@std@@QBEIXZ ENDP ; std::vector<BuffInfoStruct,std::allocator<BuffInfoStruct> >::size
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IBEXXZ ; std::vector<ioHashString,std::allocator<ioHashString> >::_Xlen
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IBEXXZ PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::_Xlen, COMDAT
; _this$ = ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
  0000b	cc		 int	 3
?_Xlen@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IBEXXZ ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::_Xlen
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@I@Z ; std::allocator<ioHashString>::deallocate
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@I@Z PROC ; std::allocator<ioHashString>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 183  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
?deallocate@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@I@Z ENDP ; std::allocator<ioHashString>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QAE@PAVioHashString@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QAE@PAVioHashString@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QAE@PAVioHashString@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QAE@PAVioHashString@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QAE@PAVioHashString@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::_Vector_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QAE@PAVioHashString@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QAE@PAVioHashString@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::_Vector_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 305  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QAE@PAVioHashString@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::_Vector_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@VioHashString@@@std@@QBEIXZ ; std::allocator<ioHashString>::max_size
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@VioHashString@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VioHashString@@@std@@QBEIXZ PROC	; std::allocator<ioHashString>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 0f	 mov	 eax, 268435455		; 0fffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@VioHashString@@@std@@QBEIXZ ENDP	; std::allocator<ioHashString>::max_size
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::_Compat
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::_Compat, COMDAT
; _this$ = ecx

; 253  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::_Compat
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@VioHashString@@@std@@YAPAVioHashString@@IPAV1@@Z ; std::_Allocate<ioHashString>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@VioHashString@@@std@@YAPAVioHashString@@IPAV1@@Z
_TEXT	SEGMENT
$T532670 = -12						; size = 12
$T532675 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VioHashString@@@std@@YAPAVioHashString@@IPAV1@@Z PROC ; std::_Allocate<ioHashString>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 3c		 je	 SHORT $LN5@Allocate

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 ff ff ff
	0f		 cmp	 ecx, 268435455		; 0fffffffH
  00015	77 0e		 ja	 SHORT $LN1@Allocate
  00017	c1 e1 04	 shl	 ecx, 4
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00020	59		 pop	 ecx
  00021	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00023	75 26		 jne	 SHORT $LN5@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00025	83 65 08 00	 and	 DWORD PTR $T532675[ebp], 0
  00029	8d 45 08	 lea	 eax, DWORD PTR $T532675[ebp]
  0002c	50		 push	 eax
  0002d	8d 4d f4	 lea	 ecx, DWORD PTR $T532670[ebp]
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
  00036	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003b	8d 45 f4	 lea	 eax, DWORD PTR $T532670[ebp]
  0003e	50		 push	 eax
  0003f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T532670[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00046	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate:
$LN5@Allocate:

; 40   : 	}

  0004b	c9		 leave
  0004c	c3		 ret	 0
$LN9@Allocate:
??$_Allocate@VioHashString@@@std@@YAPAVioHashString@@IPAV1@@Z ENDP ; std::_Allocate<ioHashString>
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
; Function compile flags: /Ogsp
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$forward@ABVioHashString@@@std@@YAABVioHashString@@ABV1@@Z ; std::forward<ioHashString const &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABVioHashString@@@std@@YAABVioHashString@@ABV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABVioHashString@@@std@@YAABVioHashString@@ABV1@@Z PROC ; std::forward<ioHashString const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABVioHashString@@@std@@YAABVioHashString@@ABV1@@Z ENDP ; std::forward<ioHashString const &>
_TEXT	ENDS
PUBLIC	??$forward@AAVioHashString@@@std@@YAAAVioHashString@@AAV1@@Z ; std::forward<ioHashString &>
; Function compile flags: /Ogsp
;	COMDAT ??$forward@AAVioHashString@@@std@@YAAAVioHashString@@AAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAVioHashString@@@std@@YAAAVioHashString@@AAV1@@Z PROC ; std::forward<ioHashString &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAVioHashString@@@std@@YAAAVioHashString@@AAV1@@Z ENDP ; std::forward<ioHashString &>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@VioHashString@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVioHashString@@0@Z ; std::_Ptr_cat<ioHashString,ioHashString>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@VioHashString@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVioHashString@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@VioHashString@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVioHashString@@0@Z PROC ; std::_Ptr_cat<ioHashString,ioHashString>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	c9		 leave
  00008	c3		 ret	 0
??$_Ptr_cat@VioHashString@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVioHashString@@0@Z ENDP ; std::_Ptr_cat<ioHashString,ioHashString>
_TEXT	ENDS
PUBLIC	??$move@AAVioHashString@@@std@@YA$$QAVioHashString@@AAV1@@Z ; std::move<ioHashString &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAVioHashString@@@std@@YA$$QAVioHashString@@AAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAVioHashString@@@std@@YA$$QAVioHashString@@AAV1@@Z PROC ; std::move<ioHashString &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAVioHashString@@@std@@YA$$QAVioHashString@@AAV1@@Z ENDP ; std::move<ioHashString &>
_TEXT	ENDS
PUBLIC	??_GioHashString@@QAEPAXI@Z			; ioHashString::`scalar deleting destructor'
EXTRN	__imp_??1ioHashString@@QAE@XZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ??_GioHashString@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GioHashString@@QAEPAXI@Z PROC			; ioHashString::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  0000c	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00010	74 07		 je	 SHORT $LN1@scalar@2
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	59		 pop	 ecx
$LN1@scalar@2:
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??_GioHashString@@QAEPAXI@Z ENDP			; ioHashString::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z ; std::_Construct<ioHashString,ioHashString const &>
EXTRN	__imp_??0ioHashString@@QAE@ABV0@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z$0
__ehfuncinfo$??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z
_TEXT	SEGMENT
$T532694 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$ = 8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z PROC ; std::_Construct<ioHashString,ioHashString const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3

; 47   : 	void _FARQ *_Vptr = _Ptr;

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000f	89 4d 08	 mov	 DWORD PTR __Vptr$[ebp], ecx

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00012	89 4d f0	 mov	 DWORD PTR $T532694[ebp], ecx
  00015	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00019	85 c9		 test	 ecx, ecx
  0001b	74 09		 je	 SHORT $LN3@Construct
  0001d	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
$LN3@Construct:

; 49   : 	}

  00026	e8 00 00 00 00	 call	 __EH_epilog3
  0002b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z$0:
  00000	ff 75 08	 push	 DWORD PTR __Vptr$[ebp]
  00003	ff 75 f0	 push	 DWORD PTR $T532694[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000b	59		 pop	 ecx
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
__ehhandler$??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z ENDP ; std::_Construct<ioHashString,ioHashString const &>
; Function compile flags: /Ogsp
;	COMDAT ??_GioRangeSyncBuffSkill@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GioRangeSyncBuffSkill@@UAEPAXI@Z PROC		; ioRangeSyncBuffSkill::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioRangeSyncBuffSkill@@6B@
  0000c	e8 00 00 00 00	 call	 ??1ioRangeSkill@@UAE@XZ	; ioRangeSkill::~ioRangeSkill
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 07		 je	 SHORT $LN1@scalar@3
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	59		 pop	 ecx
$LN1@scalar@3:
  0001e	8b c6		 mov	 eax, esi
  00020	5e		 pop	 esi
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??_GioRangeSyncBuffSkill@@UAEPAXI@Z ENDP		; ioRangeSyncBuffSkill::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?RemoveBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@@Z ; ioRangeSyncBuffSkill::RemoveBuffList
EXTRN	?RemoveBuffOwnerName@ioBaseChar@@QAE_NABVioHashString@@0@Z:PROC ; ioBaseChar::RemoveBuffOwnerName
EXTRN	?GetBaseChar@ioBaseChar@@QAEPAV1@ABVioHashString@@@Z:PROC ; ioBaseChar::GetBaseChar
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iorangesyncbuffskill.cpp
;	COMDAT ?RemoveBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@@Z
_TEXT	SEGMENT
tv216 = -16						; size = 4
tv257 = -12						; size = 4
tv196 = -12						; size = 4
tv484 = -8						; size = 4
_pChar$531141 = -4					; size = 4
_pOwner$ = 8						; size = 4
?RemoveBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@@Z PROC ; ioRangeSyncBuffSkill::RemoveBuffList, COMDAT
; _this$ = ecx

; 463  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 464  : 	if( !pOwner ) return;

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _pOwner$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	85 db		 test	 ebx, ebx
  0000f	0f 84 fc 00 00
	00		 je	 $LN11@RemoveBuff

; 467  : 
; 468  : 	int iSize = m_vCollisionedList.size();

  00015	8b 86 40 10 00
	00		 mov	 eax, DWORD PTR [esi+4160]
  0001b	2b 86 3c 10 00
	00		 sub	 eax, DWORD PTR [esi+4156]
  00021	c1 f8 04	 sar	 eax, 4

; 469  : 	for( int i=0; i < iSize; ++i )

  00024	85 c0		 test	 eax, eax
  00026	0f 8e e5 00 00
	00		 jle	 $LN11@RemoveBuff

; 465  : 
; 466  : 	const ioHashString& szOwnerName = pOwner->GetCharName();

  0002c	83 65 f8 00	 and	 DWORD PTR tv484[ebp], 0
  00030	89 45 f0	 mov	 DWORD PTR tv216[ebp], eax
  00033	57		 push	 edi
$LL45@RemoveBuff:

; 469  : 	for( int i=0; i < iSize; ++i )

  00034	8b 86 3c 10 00
	00		 mov	 eax, DWORD PTR [esi+4156]
  0003a	03 45 f8	 add	 eax, DWORD PTR tv484[ebp]

; 470  : 	{
; 471  : 		const ioHashString& szName = m_vCollisionedList[i];
; 472  : 
; 473  : 		ioBaseChar *pChar = pOwner->GetBaseChar( szName );

  0003d	8b cb		 mov	 ecx, ebx
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ?GetBaseChar@ioBaseChar@@QAEPAV1@ABVioHashString@@@Z ; ioBaseChar::GetBaseChar
  00045	89 45 fc	 mov	 DWORD PTR _pChar$531141[ebp], eax

; 474  : 		if( pChar )

  00048	85 c0		 test	 eax, eax
  0004a	0f 84 b3 00 00
	00		 je	 $LN12@RemoveBuff

; 475  : 		{
; 476  : 			int iCnt = m_EnemyBuffList.size();

  00050	8b 86 1c 10 00
	00		 mov	 eax, DWORD PTR [esi+4124]
  00056	2b 86 18 10 00
	00		 sub	 eax, DWORD PTR [esi+4120]
  0005c	6a 14		 push	 20			; 00000014H
  0005e	99		 cdq
  0005f	59		 pop	 ecx
  00060	f7 f9		 idiv	 ecx

; 477  : 			for( int j=0; j < iCnt; ++j )

  00062	85 c0		 test	 eax, eax
  00064	7e 25		 jle	 SHORT $LN7@RemoveBuff

; 475  : 		{
; 476  : 			int iCnt = m_EnemyBuffList.size();

  00066	33 ff		 xor	 edi, edi
  00068	89 45 f4	 mov	 DWORD PTR tv257[ebp], eax
$LL43@RemoveBuff:

; 478  : 			{
; 479  : 				const ioHashString& szBuffName = m_EnemyBuffList[j].m_BuffName;
; 480  : 				pChar->RemoveBuffOwnerName( szBuffName, szOwnerName );

  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _pChar$531141[ebp]
  0006e	8d 83 d4 02 00
	00		 lea	 eax, DWORD PTR [ebx+724]
  00074	50		 push	 eax
  00075	8b 86 18 10 00
	00		 mov	 eax, DWORD PTR [esi+4120]
  0007b	03 c7		 add	 eax, edi
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ?RemoveBuffOwnerName@ioBaseChar@@QAE_NABVioHashString@@0@Z ; ioBaseChar::RemoveBuffOwnerName
  00083	83 c7 14	 add	 edi, 20			; 00000014H
  00086	ff 4d f4	 dec	 DWORD PTR tv257[ebp]
  00089	75 e0		 jne	 SHORT $LL43@RemoveBuff
$LN7@RemoveBuff:

; 481  : 			}
; 482  : 
; 483  : 			iCnt = m_OwnerBuffList.size();

  0008b	8b 86 fc 0f 00
	00		 mov	 eax, DWORD PTR [esi+4092]
  00091	2b 86 f8 0f 00
	00		 sub	 eax, DWORD PTR [esi+4088]
  00097	6a 14		 push	 20			; 00000014H
  00099	99		 cdq
  0009a	59		 pop	 ecx
  0009b	f7 f9		 idiv	 ecx

; 484  : 			for( int j=0; j < iCnt; ++j )

  0009d	85 c0		 test	 eax, eax
  0009f	7e 25		 jle	 SHORT $LN4@RemoveBuff

; 481  : 			}
; 482  : 
; 483  : 			iCnt = m_OwnerBuffList.size();

  000a1	33 ff		 xor	 edi, edi
  000a3	89 45 f4	 mov	 DWORD PTR tv196[ebp], eax
$LL44@RemoveBuff:

; 485  : 			{
; 486  : 				const ioHashString& szBuffName = m_OwnerBuffList[j].m_BuffName;
; 487  : 				pChar->RemoveBuffOwnerName( szBuffName, szOwnerName );

  000a6	8b 4d fc	 mov	 ecx, DWORD PTR _pChar$531141[ebp]
  000a9	8d 83 d4 02 00
	00		 lea	 eax, DWORD PTR [ebx+724]
  000af	50		 push	 eax
  000b0	8b 86 f8 0f 00
	00		 mov	 eax, DWORD PTR [esi+4088]
  000b6	03 c7		 add	 eax, edi
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 ?RemoveBuffOwnerName@ioBaseChar@@QAE_NABVioHashString@@0@Z ; ioBaseChar::RemoveBuffOwnerName
  000be	83 c7 14	 add	 edi, 20			; 00000014H
  000c1	ff 4d f4	 dec	 DWORD PTR tv196[ebp]
  000c4	75 e0		 jne	 SHORT $LL44@RemoveBuff
$LN4@RemoveBuff:

; 488  : 			}
; 489  : 
; 490  : 			iCnt = m_TeamBuffList.size();

  000c6	8b 86 0c 10 00
	00		 mov	 eax, DWORD PTR [esi+4108]
  000cc	2b 86 08 10 00
	00		 sub	 eax, DWORD PTR [esi+4104]
  000d2	6a 14		 push	 20			; 00000014H
  000d4	99		 cdq
  000d5	59		 pop	 ecx
  000d6	f7 f9		 idiv	 ecx

; 491  : 			for( int j=0; j < iCnt; ++j )

  000d8	85 c0		 test	 eax, eax
  000da	7e 27		 jle	 SHORT $LN12@RemoveBuff

; 488  : 			}
; 489  : 
; 490  : 			iCnt = m_TeamBuffList.size();

  000dc	33 ff		 xor	 edi, edi
  000de	8b d8		 mov	 ebx, eax
$LL3@RemoveBuff:

; 492  : 			{
; 493  : 				const ioHashString& szBuffName = m_TeamBuffList[j].m_BuffName;
; 494  : 				pChar->RemoveBuffOwnerName( szBuffName, szOwnerName );

  000e0	8b 45 08	 mov	 eax, DWORD PTR _pOwner$[ebp]
  000e3	8b 4d fc	 mov	 ecx, DWORD PTR _pChar$531141[ebp]
  000e6	05 d4 02 00 00	 add	 eax, 724		; 000002d4H
  000eb	50		 push	 eax
  000ec	8b 86 08 10 00
	00		 mov	 eax, DWORD PTR [esi+4104]
  000f2	03 c7		 add	 eax, edi
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 ?RemoveBuffOwnerName@ioBaseChar@@QAE_NABVioHashString@@0@Z ; ioBaseChar::RemoveBuffOwnerName
  000fa	83 c7 14	 add	 edi, 20			; 00000014H
  000fd	4b		 dec	 ebx
  000fe	75 e0		 jne	 SHORT $LL3@RemoveBuff

; 491  : 			for( int j=0; j < iCnt; ++j )

  00100	8b 5d 08	 mov	 ebx, DWORD PTR _pOwner$[ebp]
$LN12@RemoveBuff:

; 469  : 	for( int i=0; i < iSize; ++i )

  00103	83 45 f8 10	 add	 DWORD PTR tv484[ebp], 16 ; 00000010H
  00107	ff 4d f0	 dec	 DWORD PTR tv216[ebp]
  0010a	0f 85 24 ff ff
	ff		 jne	 $LL45@RemoveBuff
  00110	5f		 pop	 edi
$LN11@RemoveBuff:
  00111	5e		 pop	 esi
  00112	5b		 pop	 ebx

; 495  : 			}
; 496  : 		}
; 497  : 	}
; 498  : }

  00113	c9		 leave
  00114	c2 04 00	 ret	 4
?RemoveBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@@Z ENDP ; ioRangeSyncBuffSkill::RemoveBuffList
_TEXT	ENDS
PUBLIC	??O?$CEncrypt@K@@QAE_NABH@Z			; CEncrypt<unsigned long>::operator>
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
;	COMDAT ??O?$CEncrypt@K@@QAE_NABH@Z
_TEXT	SEGMENT
_value$ = -4						; size = 4
_inValue$ = 8						; size = 4
??O?$CEncrypt@K@@QAE_NABH@Z PROC			; CEncrypt<unsigned long>::operator>, COMDAT
; _this$ = ecx

; 1009 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1010 : 		
; 1011 : 		type value;
; 1012 : 		DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z ; CEncrypt<unsigned long>::DecryptValueToPool

; 1013 : #ifdef _NOTUSE
; 1014 : 		Debug();
; 1015 : #endif
; 1016 : 		return (value > inValue);

  0000d	8b 45 08	 mov	 eax, DWORD PTR _inValue$[ebp]
  00010	8b 00		 mov	 eax, DWORD PTR [eax]
  00012	3b 45 fc	 cmp	 eax, DWORD PTR _value$[ebp]
  00015	1b c0		 sbb	 eax, eax
  00017	f7 d8		 neg	 eax

; 1017 : 	}		

  00019	c9		 leave
  0001a	c2 04 00	 ret	 4
??O?$CEncrypt@K@@QAE_NABH@Z ENDP			; CEncrypt<unsigned long>::operator>
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Vector_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Vector_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >, COMDAT
; _this$ = ecx

; 298  : 	_Vector_iterator()

  00000	8b c1		 mov	 eax, ecx
  00002	83 20 00	 and	 DWORD PTR [eax], 0

; 299  : 		{	// construct with null vector pointer
; 300  : 		}

  00005	c3		 ret	 0
??0?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Vector_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBEAAPAVioBaseChar@@XZ ; std::_Vector_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator*
; Function compile flags: /Ogsp
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBEAAPAVioBaseChar@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBEAAPAVioBaseChar@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator*, COMDAT
; _this$ = ecx

; 322  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 323  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBEAAPAVioBaseChar@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator++
; Function compile flags: /Ogsp
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator++, COMDAT
; _this$ = ecx

; 331  : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 332  : 		++*(_Mybase *)this;

  00002	83 00 04	 add	 DWORD PTR [eax], 4

; 333  : 		return (*this);
; 334  : 		}

  00005	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator++
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE@V?$allocator@PAVioBaseChar@@@1@@Z ; std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> >::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE@V?$allocator@PAVioBaseChar@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE@V?$allocator@PAVioBaseChar@@@1@@Z PROC ; std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> >::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE@V?$allocator@PAVioBaseChar@@@1@@Z ENDP ; std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> >::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@PAPAVioBaseChar@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Vector_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@PAPAVioBaseChar@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@PAPAVioBaseChar@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Vector_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 305  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QAE@PAPAVioBaseChar@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::_Vector_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator==
; Function compile flags: /Ogsp
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	f7 d8		 neg	 eax
  0000c	1b c0		 sbb	 eax, eax
  0000e	40		 inc	 eax

; 204  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator==
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@@Z ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::_Make_iter
; Function compile flags: /Ogsp
;	COMDAT ?_Make_iter@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@@Z PROC ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 		return (iterator(_Where._Ptr, this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 803  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?_Make_iter@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@@Z ENDP ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::_Make_iter
_TEXT	ENDS
PUBLIC	??$GetAnimationEventTime_e@$0M@@ioEntityGroup@@QAEMHAAY0M@$$CBD@Z ; ioEntityGroup::GetAnimationEventTime_e<12>
EXTRN	__imp_?GetAnimationEventTime@ioEntityGroup@@QAEMHABVioHashString@@@Z:PROC
EXTRN	__imp_??0ioHashString@@QAE@PBD@Z:PROC
EXTRN	__EH_epilog3_GS:PROC
EXTRN	__EH_prolog3_GS:PROC
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stringprotect.h
xdata$x	SEGMENT
__unwindtable$??$GetAnimationEventTime_e@$0M@@ioEntityGroup@@QAEMHAAY0M@$$CBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetAnimationEventTime_e@$0M@@ioEntityGroup@@QAEMHAAY0M@$$CBD@Z$0
__ehfuncinfo$??$GetAnimationEventTime_e@$0M@@ioEntityGroup@@QAEMHAAY0M@$$CBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$GetAnimationEventTime_e@$0M@@ioEntityGroup@@QAEMHAAY0M@$$CBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\io3dengine\ioentitygroup.h
xdata$x	ENDS
;	COMDAT ??$GetAnimationEventTime_e@$0M@@ioEntityGroup@@QAEMHAAY0M@$$CBD@Z
_TEXT	SEGMENT
$T532823 = -52						; size = 16
$T532822 = -36						; size = 4
_szEncEventType$ = -32					; size = 12
__$EHRec$ = -12						; size = 12
_id$ = 8						; size = 4
_szEventType$ = 12					; size = 4
??$GetAnimationEventTime_e@$0M@@ioEntityGroup@@QAEMHAAY0M@$$CBD@Z PROC ; ioEntityGroup::GetAnimationEventTime_e<12>, COMDAT
; _this$ = ecx

; 414  : 	{

  00000	6a 28		 push	 40			; 00000028H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??$GetAnimationEventTime_e@$0M@@ioEntityGroup@@QAEMHAAY0M@$$CBD@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000c	8b 45 0c	 mov	 eax, DWORD PTR _szEventType$[ebp]
  0000f	8b f1		 mov	 esi, ecx

; 415  : 		_ENCSTR(szEventType, szEncEventType);

  00011	8a 08		 mov	 cl, BYTE PTR [eax]
  00013	84 c9		 test	 cl, cl
  00015	0f 84 36 01 00
	00		 je	 $LN96@GetAnimati
  0001b	b2 ed		 mov	 dl, -19			; ffffffedH
  0001d	32 ca		 xor	 cl, dl
  0001f	88 4d e0	 mov	 BYTE PTR _szEncEventType$[ebp], cl
  00022	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00025	84 c9		 test	 cl, cl
  00027	0f 84 1e 01 00
	00		 je	 $LN95@GetAnimati
  0002d	80 f1 ec	 xor	 cl, -20			; ffffffecH
  00030	88 4d e1	 mov	 BYTE PTR _szEncEventType$[ebp+1], cl
  00033	8a 48 02	 mov	 cl, BYTE PTR [eax+2]
  00036	84 c9		 test	 cl, cl
  00038	0f 84 07 01 00
	00		 je	 $LN94@GetAnimati
  0003e	80 f1 eb	 xor	 cl, -21			; ffffffebH
  00041	88 4d e2	 mov	 BYTE PTR _szEncEventType$[ebp+2], cl
  00044	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  00047	84 c9		 test	 cl, cl
  00049	0f 84 f0 00 00
	00		 je	 $LN93@GetAnimati
  0004f	80 f1 ea	 xor	 cl, -22			; ffffffeaH
  00052	88 4d e3	 mov	 BYTE PTR _szEncEventType$[ebp+3], cl
  00055	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  00058	84 c9		 test	 cl, cl
  0005a	0f 84 da 00 00
	00		 je	 $LN92@GetAnimati
  00060	32 ca		 xor	 cl, dl
  00062	88 4d e4	 mov	 BYTE PTR _szEncEventType$[ebp+4], cl
  00065	8a 48 05	 mov	 cl, BYTE PTR [eax+5]
  00068	84 c9		 test	 cl, cl
  0006a	0f 84 c4 00 00
	00		 je	 $LN91@GetAnimati
  00070	80 f1 ec	 xor	 cl, -20			; ffffffecH
  00073	88 4d e5	 mov	 BYTE PTR _szEncEventType$[ebp+5], cl
  00076	8a 48 06	 mov	 cl, BYTE PTR [eax+6]
  00079	84 c9		 test	 cl, cl
  0007b	0f 84 ad 00 00
	00		 je	 $LN90@GetAnimati
  00081	80 f1 eb	 xor	 cl, -21			; ffffffebH
  00084	88 4d e6	 mov	 BYTE PTR _szEncEventType$[ebp+6], cl
  00087	8a 48 07	 mov	 cl, BYTE PTR [eax+7]
  0008a	84 c9		 test	 cl, cl
  0008c	0f 84 96 00 00
	00		 je	 $LN89@GetAnimati
  00092	80 f1 ea	 xor	 cl, -22			; ffffffeaH
  00095	88 4d e7	 mov	 BYTE PTR _szEncEventType$[ebp+7], cl
  00098	8a 48 08	 mov	 cl, BYTE PTR [eax+8]
  0009b	84 c9		 test	 cl, cl
  0009d	0f 84 80 00 00
	00		 je	 $LN88@GetAnimati
  000a3	32 ca		 xor	 cl, dl
  000a5	88 4d e8	 mov	 BYTE PTR _szEncEventType$[ebp+8], cl
  000a8	8a 48 09	 mov	 cl, BYTE PTR [eax+9]
  000ab	84 c9		 test	 cl, cl
  000ad	74 6e		 je	 SHORT $LN87@GetAnimati
  000af	80 f1 ec	 xor	 cl, -20			; ffffffecH
  000b2	88 4d e9	 mov	 BYTE PTR _szEncEventType$[ebp+9], cl
  000b5	8a 48 0a	 mov	 cl, BYTE PTR [eax+10]
  000b8	84 c9		 test	 cl, cl
  000ba	74 5b		 je	 SHORT $LN86@GetAnimati
  000bc	80 f1 eb	 xor	 cl, -21			; ffffffebH
  000bf	80 78 0b 00	 cmp	 BYTE PTR [eax+11], 0
  000c3	88 4d ea	 mov	 BYTE PTR _szEncEventType$[ebp+10], cl
  000c6	0f 84 89 00 00
	00		 je	 $LN1@GetAnimati
  000cc	8a 48 0c	 mov	 cl, BYTE PTR [eax+12]
  000cf	84 c9		 test	 cl, cl
  000d1	74 3f		 je	 SHORT $LN84@GetAnimati
  000d3	32 ca		 xor	 cl, dl
  000d5	88 4d ec	 mov	 BYTE PTR _szEncEventType$[ebp+12], cl
  000d8	8a 48 0d	 mov	 cl, BYTE PTR [eax+13]
  000db	84 c9		 test	 cl, cl
  000dd	74 2d		 je	 SHORT $LN83@GetAnimati
  000df	80 f1 ec	 xor	 cl, -20			; ffffffecH
  000e2	88 4d ed	 mov	 BYTE PTR _szEncEventType$[ebp+13], cl
  000e5	8a 48 0e	 mov	 cl, BYTE PTR [eax+14]
  000e8	84 c9		 test	 cl, cl
  000ea	74 1a		 je	 SHORT $LN82@GetAnimati
  000ec	8a 40 0f	 mov	 al, BYTE PTR [eax+15]
  000ef	80 f1 eb	 xor	 cl, -21			; ffffffebH
  000f2	88 4d ee	 mov	 BYTE PTR _szEncEventType$[ebp+14], cl
  000f5	84 c0		 test	 al, al
  000f7	74 07		 je	 SHORT $LN81@GetAnimati
  000f9	34 ea		 xor	 al, -22			; ffffffeaH
  000fb	88 45 ef	 mov	 BYTE PTR _szEncEventType$[ebp+15], al
  000fe	eb 55		 jmp	 SHORT $LN1@GetAnimati
$LN81@GetAnimati:
  00100	c6 45 ef ea	 mov	 BYTE PTR _szEncEventType$[ebp+15], -22 ; ffffffeaH
  00104	eb 4f		 jmp	 SHORT $LN1@GetAnimati
$LN82@GetAnimati:
  00106	c6 45 ee eb	 mov	 BYTE PTR _szEncEventType$[ebp+14], -21 ; ffffffebH
  0010a	eb 49		 jmp	 SHORT $LN1@GetAnimati
$LN83@GetAnimati:
  0010c	c6 45 ed ec	 mov	 BYTE PTR _szEncEventType$[ebp+13], -20 ; ffffffecH
  00110	eb 43		 jmp	 SHORT $LN1@GetAnimati
$LN84@GetAnimati:
  00112	88 55 ec	 mov	 BYTE PTR _szEncEventType$[ebp+12], dl
  00115	eb 3e		 jmp	 SHORT $LN1@GetAnimati
$LN86@GetAnimati:
  00117	c6 45 ea eb	 mov	 BYTE PTR _szEncEventType$[ebp+10], -21 ; ffffffebH
  0011b	eb 38		 jmp	 SHORT $LN1@GetAnimati
$LN87@GetAnimati:
  0011d	c6 45 e9 ec	 mov	 BYTE PTR _szEncEventType$[ebp+9], -20 ; ffffffecH
  00121	eb 32		 jmp	 SHORT $LN1@GetAnimati
$LN88@GetAnimati:
  00123	88 55 e8	 mov	 BYTE PTR _szEncEventType$[ebp+8], dl
  00126	eb 2d		 jmp	 SHORT $LN1@GetAnimati
$LN89@GetAnimati:
  00128	c6 45 e7 ea	 mov	 BYTE PTR _szEncEventType$[ebp+7], -22 ; ffffffeaH
  0012c	eb 27		 jmp	 SHORT $LN1@GetAnimati
$LN90@GetAnimati:
  0012e	c6 45 e6 eb	 mov	 BYTE PTR _szEncEventType$[ebp+6], -21 ; ffffffebH
  00132	eb 21		 jmp	 SHORT $LN1@GetAnimati
$LN91@GetAnimati:
  00134	c6 45 e5 ec	 mov	 BYTE PTR _szEncEventType$[ebp+5], -20 ; ffffffecH
  00138	eb 1b		 jmp	 SHORT $LN1@GetAnimati
$LN92@GetAnimati:
  0013a	88 55 e4	 mov	 BYTE PTR _szEncEventType$[ebp+4], dl
  0013d	eb 16		 jmp	 SHORT $LN1@GetAnimati
$LN93@GetAnimati:
  0013f	c6 45 e3 ea	 mov	 BYTE PTR _szEncEventType$[ebp+3], -22 ; ffffffeaH
  00143	eb 10		 jmp	 SHORT $LN1@GetAnimati
$LN94@GetAnimati:
  00145	c6 45 e2 eb	 mov	 BYTE PTR _szEncEventType$[ebp+2], -21 ; ffffffebH
  00149	eb 0a		 jmp	 SHORT $LN1@GetAnimati
$LN95@GetAnimati:
  0014b	c6 45 e1 ec	 mov	 BYTE PTR _szEncEventType$[ebp+1], -20 ; ffffffecH
  0014f	eb 04		 jmp	 SHORT $LN1@GetAnimati
$LN96@GetAnimati:
  00151	c6 45 e0 ed	 mov	 BYTE PTR _szEncEventType$[ebp], -19 ; ffffffedH
$LN1@GetAnimati:
  00155	6a 02		 push	 2
  00157	8d 45 e0	 lea	 eax, DWORD PTR _szEncEventType$[ebp]
  0015a	c6 45 eb 00	 mov	 BYTE PTR _szEncEventType$[ebp+11], 0
  0015e	59		 pop	 ecx
$LL105@GetAnimati:
  0015f	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00165	83 c0 04	 add	 eax, 4
  00168	49		 dec	 ecx
  00169	75 f4		 jne	 SHORT $LL105@GetAnimati
  0016b	6a 08		 push	 8
  0016d	58		 pop	 eax
$LL102@GetAnimati:
  0016e	8b c8		 mov	 ecx, eax
  00170	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00176	79 05		 jns	 SHORT $LN113@GetAnimati
  00178	49		 dec	 ecx
  00179	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0017c	41		 inc	 ecx
$LN113@GetAnimati:
  0017d	b2 ed		 mov	 dl, -19			; ffffffedH
  0017f	2a d1		 sub	 dl, cl
  00181	30 54 05 e0	 xor	 BYTE PTR _szEncEventType$[ebp+eax], dl
  00185	40		 inc	 eax
  00186	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00189	7c e3		 jl	 SHORT $LL102@GetAnimati

; 416  : 		return GetAnimationEventTime(id, szEncEventType);

  0018b	8d 45 e0	 lea	 eax, DWORD PTR _szEncEventType$[ebp]
  0018e	50		 push	 eax
  0018f	8d 4d cc	 lea	 ecx, DWORD PTR $T532823[ebp]
  00192	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  00198	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0019c	8d 45 cc	 lea	 eax, DWORD PTR $T532823[ebp]
  0019f	50		 push	 eax
  001a0	ff 75 08	 push	 DWORD PTR _id$[ebp]
  001a3	8b ce		 mov	 ecx, esi
  001a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetAnimationEventTime@ioEntityGroup@@QAEMHABVioHashString@@@Z
  001ab	d9 5d dc	 fstp	 DWORD PTR $T532822[ebp]
  001ae	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  001b2	8d 4d cc	 lea	 ecx, DWORD PTR $T532823[ebp]
  001b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  001bb	d9 45 dc	 fld	 DWORD PTR $T532822[ebp]

; 417  : 	}

  001be	e8 00 00 00 00	 call	 __EH_epilog3_GS
  001c3	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetAnimationEventTime_e@$0M@@ioEntityGroup@@QAEMHAAY0M@$$CBD@Z$0:
  00000	8d 4d cc	 lea	 ecx, DWORD PTR $T532823[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$??$GetAnimationEventTime_e@$0M@@ioEntityGroup@@QAEMHAAY0M@$$CBD@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$GetAnimationEventTime_e@$0M@@ioEntityGroup@@QAEMHAAY0M@$$CBD@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$GetAnimationEventTime_e@$0M@@ioEntityGroup@@QAEMHAAY0M@$$CBD@Z ENDP ; ioEntityGroup::GetAnimationEventTime_e<12>
PUBLIC	??$_Move@PAPAVioBaseChar@@PAPAV1@@std@@YAPAPAVioBaseChar@@PAPAV1@00@Z ; std::_Move<ioBaseChar * *,ioBaseChar * *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAPAVioBaseChar@@PAPAV1@@std@@YAPAPAVioBaseChar@@PAPAV1@00@Z
_TEXT	SEGMENT
__Cat$532858 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAPAVioBaseChar@@PAPAV1@@std@@YAPAPAVioBaseChar@@PAPAV1@00@Z PROC ; std::_Move<ioBaseChar * *,ioBaseChar * *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$532858[ebp]
  00007	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Move@PAPAVioBaseChar@@PAPAV1@@std@@YAPAPAVioBaseChar@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<ioBaseChar * *,ioBaseChar * *>
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00018	c9		 leave
  00019	c3		 ret	 0
??$_Move@PAPAVioBaseChar@@PAPAV1@@std@@YAPAPAVioBaseChar@@PAPAV1@00@Z ENDP ; std::_Move<ioBaseChar * *,ioBaseChar * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVioBaseChar@@@std@@@std@@YAXPAPAVioBaseChar@@0AAV?$allocator@PAVioBaseChar@@@0@@Z ; std::_Destroy_range<std::allocator<ioBaseChar *> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVioBaseChar@@@std@@@std@@YAXPAPAVioBaseChar@@0AAV?$allocator@PAVioBaseChar@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVioBaseChar@@@std@@@std@@YAXPAPAVioBaseChar@@0AAV?$allocator@PAVioBaseChar@@@0@@Z PROC ; std::_Destroy_range<std::allocator<ioBaseChar *> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVioBaseChar@@@std@@@std@@YAXPAPAVioBaseChar@@0AAV?$allocator@PAVioBaseChar@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<ioBaseChar *> >
_TEXT	ENDS
PUBLIC	??$construct@AAVioHashString@@@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@AAV2@@Z ; std::allocator<ioHashString>::construct<ioHashString &>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??$construct@AAVioHashString@@@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@AAV2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAVioHashString@@@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@AAV2@@Z$0
__ehfuncinfo$??$construct@AAVioHashString@@@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@AAV2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAVioHashString@@@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@AAV2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$construct@AAVioHashString@@@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@AAV2@@Z
_TEXT	SEGMENT
$T532873 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAVioHashString@@@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@AAV2@@Z PROC ; std::allocator<ioHashString>::construct<ioHashString &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??$construct@AAVioHashString@@@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@AAV2@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000f	89 4d f0	 mov	 DWORD PTR $T532873[ebp], ecx
  00012	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00016	85 c9		 test	 ecx, ecx
  00018	74 09		 je	 SHORT $LN3@construct
  0001a	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
$LN3@construct:

; 209  : 		}

  00023	e8 00 00 00 00	 call	 __EH_epilog3
  00028	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAVioHashString@@@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@AAV2@@Z$0:
  00000	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00003	ff 75 f0	 push	 DWORD PTR $T532873[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000b	59		 pop	 ecx
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
__ehhandler$??$construct@AAVioHashString@@@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@AAV2@@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAVioHashString@@@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@AAV2@@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAVioHashString@@@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@AAV2@@Z ENDP ; std::allocator<ioHashString>::construct<ioHashString &>
PUBLIC	?construct@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@$$QAV3@@Z ; std::allocator<ioHashString>::construct
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@$$QAV3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@$$QAV3@@Z$0
__ehfuncinfo$?construct@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@$$QAV3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@$$QAV3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@$$QAV3@@Z
_TEXT	SEGMENT
$T532892 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@$$QAV3@@Z PROC ; std::allocator<ioHashString>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?construct@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@$$QAV3@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000f	89 4d f0	 mov	 DWORD PTR $T532892[ebp], ecx
  00012	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00016	85 c9		 test	 ecx, ecx
  00018	74 09		 je	 SHORT $LN3@construct@2
  0001a	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
$LN3@construct@2:

; 203  : 		}

  00023	e8 00 00 00 00	 call	 __EH_epilog3
  00028	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@$$QAV3@@Z$0:
  00000	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00003	ff 75 f0	 push	 DWORD PTR $T532892[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000b	59		 pop	 ecx
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
__ehhandler$?construct@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@$$QAV3@@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@$$QAV3@@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@$$QAV3@@Z ENDP ; std::allocator<ioHashString>::construct
PUBLIC	??B?$CEncrypt@K@@QBEKXZ				; CEncrypt<unsigned long>::operator unsigned long
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\encryptvalue.h
;	COMDAT ??B?$CEncrypt@K@@QBEKXZ
_TEXT	SEGMENT
_value$ = -4						; size = 4
??B?$CEncrypt@K@@QBEKXZ PROC				; CEncrypt<unsigned long>::operator unsigned long, COMDAT
; _this$ = ecx

; 145  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 146  : 		//UJ 130829, const    --start
; 147  : 		type value;
; 148  : 		CEncrypt<type>* pThis = const_cast<CEncrypt<type>*>(this);
; 149  : 		pThis->DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z ; CEncrypt<unsigned long>::DecryptValueToPool

; 150  : 		//// const DecryptValueToPool     .
; 151  :  		//type value;
; 152  : 		//char szTempMem[MAX_ENCRYPT];
; 153  : 		//m_RC5.DecryptByte( m_MemPool, szTempMem, max(m_ValueSize, DEFAULT_ENCRYPT) );
; 154  : 		//memcpy( &value, szTempMem, m_ValueSize );
; 155  : 		//UJ --end
; 156  : 
; 157  : #ifdef _NOTUSE
; 158  : 		Debug();
; 159  : #endif
; 160  : 		return value;

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _value$[ebp]

; 161  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@K@@QBEKXZ ENDP				; CEncrypt<unsigned long>::operator unsigned long
_TEXT	ENDS
PUBLIC	??4?$CEncrypt@K@@QAEKH@Z			; CEncrypt<unsigned long>::operator=
; Function compile flags: /Ogsp
;	COMDAT ??4?$CEncrypt@K@@QAEKH@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
_inValue$ = 8						; size = 4
??4?$CEncrypt@K@@QAEKH@Z PROC				; CEncrypt<unsigned long>::operator=, COMDAT
; _this$ = ecx

; 843  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 844  : 		type value = inValue;

  00003	8b 45 08	 mov	 eax, DWORD PTR _inValue$[ebp]
  00006	89 45 08	 mov	 DWORD PTR _value$[ebp], eax

; 845  : 		EncryptValueToPool((char*)&value);

  00009	8d 45 08	 lea	 eax, DWORD PTR _value$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z ; CEncrypt<unsigned long>::EncryptValueToPool

; 846  : #ifdef _NOTUSE
; 847  : 		m_value = inValue;
; 848  : 		Debug();
; 849  : #endif
; 850  : 		return value;

  00012	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]

; 851  : 	}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??4?$CEncrypt@K@@QAEKH@Z ENDP				; CEncrypt<unsigned long>::operator=
_TEXT	ENDS
PUBLIC	??B?$CEncrypt@_N@@QAE_NXZ			; CEncrypt<bool>::operator bool
; Function compile flags: /Ogsp
;	COMDAT ??B?$CEncrypt@_N@@QAE_NXZ
_TEXT	SEGMENT
_value$ = -1						; size = 1
??B?$CEncrypt@_N@@QAE_NXZ PROC				; CEncrypt<bool>::operator bool, COMDAT
; _this$ = ecx

; 134  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 135  : 		type value;
; 136  : 		DecryptValueToPool(&value);

  00004	8d 45 ff	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool

; 137  : 
; 138  : #ifdef _NOTUSE
; 139  : 		Debug();
; 140  : #endif
; 141  : 		return value;

  0000d	8a 45 ff	 mov	 al, BYTE PTR _value$[ebp]

; 142  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@_N@@QAE_NXZ ENDP				; CEncrypt<bool>::operator bool
_TEXT	ENDS
PUBLIC	??B?$CEncrypt@_N@@QBE_NXZ			; CEncrypt<bool>::operator bool
; Function compile flags: /Ogsp
;	COMDAT ??B?$CEncrypt@_N@@QBE_NXZ
_TEXT	SEGMENT
_value$ = -1						; size = 1
??B?$CEncrypt@_N@@QBE_NXZ PROC				; CEncrypt<bool>::operator bool, COMDAT
; _this$ = ecx

; 145  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 146  : 		//UJ 130829, const    --start
; 147  : 		type value;
; 148  : 		CEncrypt<type>* pThis = const_cast<CEncrypt<type>*>(this);
; 149  : 		pThis->DecryptValueToPool(&value);

  00004	8d 45 ff	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool

; 150  : 		//// const DecryptValueToPool     .
; 151  :  		//type value;
; 152  : 		//char szTempMem[MAX_ENCRYPT];
; 153  : 		//m_RC5.DecryptByte( m_MemPool, szTempMem, max(m_ValueSize, DEFAULT_ENCRYPT) );
; 154  : 		//memcpy( &value, szTempMem, m_ValueSize );
; 155  : 		//UJ --end
; 156  : 
; 157  : #ifdef _NOTUSE
; 158  : 		Debug();
; 159  : #endif
; 160  : 		return value;

  0000d	8a 45 ff	 mov	 al, BYTE PTR _value$[ebp]

; 161  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@_N@@QBE_NXZ ENDP				; CEncrypt<bool>::operator bool
_TEXT	ENDS
PUBLIC	??B?$CEncrypt@W4TeamType@@@@QBE?AW4TeamType@@XZ	; CEncrypt<enum TeamType>::operator enum TeamType
; Function compile flags: /Ogsp
;	COMDAT ??B?$CEncrypt@W4TeamType@@@@QBE?AW4TeamType@@XZ
_TEXT	SEGMENT
_value$ = -4						; size = 4
??B?$CEncrypt@W4TeamType@@@@QBE?AW4TeamType@@XZ PROC	; CEncrypt<enum TeamType>::operator enum TeamType, COMDAT
; _this$ = ecx

; 145  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 146  : 		//UJ 130829, const    --start
; 147  : 		type value;
; 148  : 		CEncrypt<type>* pThis = const_cast<CEncrypt<type>*>(this);
; 149  : 		pThis->DecryptValueToPool(&value);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool

; 150  : 		//// const DecryptValueToPool     .
; 151  :  		//type value;
; 152  : 		//char szTempMem[MAX_ENCRYPT];
; 153  : 		//m_RC5.DecryptByte( m_MemPool, szTempMem, max(m_ValueSize, DEFAULT_ENCRYPT) );
; 154  : 		//memcpy( &value, szTempMem, m_ValueSize );
; 155  : 		//UJ --end
; 156  : 
; 157  : #ifdef _NOTUSE
; 158  : 		Debug();
; 159  : #endif
; 160  : 		return value;

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _value$[ebp]

; 161  : 	}

  00010	c9		 leave
  00011	c3		 ret	 0
??B?$CEncrypt@W4TeamType@@@@QBE?AW4TeamType@@XZ ENDP	; CEncrypt<enum TeamType>::operator enum TeamType
_TEXT	ENDS
PUBLIC	?begin@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@XZ ; std::vector<ioHashString,std::allocator<ioHashString> >::begin
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?begin@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@XZ PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 782  : 		return (iterator(this->_Myfirst, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 783  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@XZ ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@XZ ; std::vector<ioHashString,std::allocator<ioHashString> >::end
; Function compile flags: /Ogsp
;	COMDAT ?end@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@XZ PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 792  : 		return (iterator(this->_Mylast, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 793  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@XZ ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::end
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@V?$allocator@VioHashString@@@1@@Z ; std::_Vector_val<ioHashString,std::allocator<ioHashString> >::_Vector_val<ioHashString,std::allocator<ioHashString> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@V?$allocator@VioHashString@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@V?$allocator@VioHashString@@@1@@Z PROC ; std::_Vector_val<ioHashString,std::allocator<ioHashString> >::_Vector_val<ioHashString,std::allocator<ioHashString> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@V?$allocator@VioHashString@@@1@@Z ENDP ; std::_Vector_val<ioHashString,std::allocator<ioHashString> >::_Vector_val<ioHashString,std::allocator<ioHashString> >
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::_Make_iter
; Function compile flags: /Ogsp
;	COMDAT ?_Make_iter@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@@Z PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 		return (iterator(_Where._Ptr, this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 803  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?_Make_iter@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@@Z ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBEIXZ ; std::vector<ioHashString,std::allocator<ioHashString> >::max_size
; Function compile flags: /Ogsp
;	COMDAT ?max_size@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBEIXZ PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 0f	 mov	 eax, 268435455		; 0fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QBEIXZ ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@VioHashString@@@std@@QAEPAVioHashString@@I@Z ; std::allocator<ioHashString>::allocate
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@VioHashString@@@std@@QAEPAVioHashString@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@VioHashString@@@std@@QAEPAVioHashString@@I@Z PROC ; std::allocator<ioHashString>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	6a 00		 push	 0
  00005	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Allocate@VioHashString@@@std@@YAPAVioHashString@@IPAV1@@Z ; std::_Allocate<ioHashString>
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx

; 188  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?allocate@?$allocator@VioHashString@@@std@@QAEPAVioHashString@@I@Z ENDP ; std::allocator<ioHashString>::allocate
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::operator==
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	f7 d8		 neg	 eax
  0000c	1b c0		 sbb	 eax, eax
  0000e	40		 inc	 eax

; 204  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::operator==
_TEXT	ENDS
PUBLIC	??$_Move@PAVioHashString@@PAV1@@std@@YAPAVioHashString@@PAV1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<ioHashString *,ioHashString *>
EXTRN	__imp_??4ioHashString@@QAEAAV0@ABV0@@Z:PROC
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAVioHashString@@PAV1@@std@@YAPAVioHashString@@PAV1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAVioHashString@@PAV1@@std@@YAPAVioHashString@@PAV1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<ioHashString *,ioHashString *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	eb 11		 jmp	 SHORT $LN11@Move
$LL3@Move:

; 2514 : 		*_Dest = _STD move(*_First);

  00009	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0000c	56		 push	 esi
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@ABV0@@Z
  00013	83 45 10 10	 add	 DWORD PTR __Dest$[ebp], 16 ; 00000010H
  00017	83 c6 10	 add	 esi, 16			; 00000010H
$LN11@Move:

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  0001a	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001d	75 ea		 jne	 SHORT $LL3@Move

; 2515 : 	return (_Dest);

  0001f	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00022	5e		 pop	 esi

; 2516 : 	}

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$_Move@PAVioHashString@@PAV1@@std@@YAPAVioHashString@@PAV1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<ioHashString *,ioHashString *>
_TEXT	ENDS
PUBLIC	??$_Destroy@VioHashString@@@std@@YAXPAVioHashString@@@Z ; std::_Destroy<ioHashString>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy@VioHashString@@@std@@YAXPAVioHashString@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VioHashString@@@std@@YAXPAVioHashString@@@Z PROC ; std::_Destroy<ioHashString>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 63   : 	_Ptr->~_Ty();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 64   : 	}

  00006	5d		 pop	 ebp

; 63   : 	_Ptr->~_Ty();

  00007	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
??$_Destroy@VioHashString@@@std@@YAXPAVioHashString@@@Z ENDP ; std::_Destroy<ioHashString>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@ABV3@@Z ; std::allocator<ioHashString>::construct
; Function compile flags: /Ogsp
;	COMDAT ?construct@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@ABV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@ABV3@@Z PROC ; std::allocator<ioHashString>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 		_Construct(_Ptr, _Val);

  00003	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  00006	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00009	e8 00 00 00 00	 call	 ??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z ; std::_Construct<ioHashString,ioHashString const &>
  0000e	59		 pop	 ecx
  0000f	59		 pop	 ecx

; 198  : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?construct@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@ABV3@@Z ENDP ; std::allocator<ioHashString>::construct
_TEXT	ENDS
PUBLIC	?GetExperienceMode@ioBaseChar@@QBE?BKXZ		; ioBaseChar::GetExperienceMode
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iobasechar.h
;	COMDAT ?GetExperienceMode@ioBaseChar@@QBE?BKXZ
_TEXT	SEGMENT
_value$533018 = -4					; size = 4
?GetExperienceMode@ioBaseChar@@QBE?BKXZ PROC		; ioBaseChar::GetExperienceMode, COMDAT
; _this$ = ecx

; 3193 : 	inline const DWORD GetExperienceMode() const { return m_ExperienceMode; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$533018[ebp]
  00007	50		 push	 eax
  00008	81 c1 94 1d 00
	00		 add	 ecx, 7572		; 00001d94H
  0000e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z ; CEncrypt<unsigned long>::DecryptValueToPool
  00013	8b 45 fc	 mov	 eax, DWORD PTR _value$533018[ebp]
  00016	c9		 leave
  00017	c3		 ret	 0
?GetExperienceMode@ioBaseChar@@QBE?BKXZ ENDP		; ioBaseChar::GetExperienceMode
_TEXT	ENDS
PUBLIC	??_C@_0DP@KAEFGCEE@ioRangeBuffSkill?3?3SetLoopState?$CI?$CJ@ ; `string'
PUBLIC	__real@3f800000
PUBLIC	__real@4f800000
PUBLIC	_pChar$GSCopy$
EXTRN	?ChangeSkillWeaponMesh@ioBaseChar@@QAE_NPAVioSkill@@ABVioHashString@@_N@Z:PROC ; ioBaseChar::ChangeSkillWeaponMesh
EXTRN	?RestoreSkillWeaponMesh@ioBaseChar@@QAE_NPAVioSkill@@ABVioHashString@@_N2@Z:PROC ; ioBaseChar::RestoreSkillWeaponMesh
EXTRN	__imp_?IsEmpty@ioHashString@@QBE_NXZ:PROC
EXTRN	?CreateMapEffectBySkill@ioBaseChar@@QAEPAVioMapEffect@@ABVioHashString@@ABUD3DXVECTOR3@@AAU4@@Z:PROC ; ioBaseChar::CreateMapEffectBySkill
EXTRN	?GetMidPositionByRate@ioGameEntity@@QBE?AUD3DXVECTOR3@@M@Z:PROC ; ioGameEntity::GetMidPositionByRate
EXTRN	__imp_?SetLoopAni@ioEntityGroup@@QAE_NABVioHashString@@MMMM@Z:PROC
EXTRN	__imp_?PrintTimeAndLog@CLog@@QAAXHPADZZ:PROC
EXTRN	__imp_?LOG@@3VCLog@@A:BYTE
EXTRN	__imp_?c_str@ioHashString@@QBEPBDXZ:PROC
EXTRN	__imp_?GetLoopSec@ioFrameTimer@@QBEKXZ:PROC
EXTRN	__imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ:PROC
EXTRN	__imp_?ClearAllActionAni@ioEntityGroup@@QAEXM_N@Z:PROC
EXTRN	__imp_?ClearAllLoopAni@ioEntityGroup@@QAEXM_N@Z:PROC
EXTRN	__imp_?GetAnimationIdx@ioEntityGroup@@QAEHABVioHashString@@@Z:PROC
EXTRN	__ftol2:PROC
;	COMDAT ??_C@_0DP@KAEFGCEE@ioRangeBuffSkill?3?3SetLoopState?$CI?$CJ@
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx9math.inl
CONST	SEGMENT
??_C@_0DP@KAEFGCEE@ioRangeBuffSkill?3?3SetLoopState?$CI?$CJ@ DB 'ioRangeB'
	DB	'uffSkill::SetLoopState() - %s, Not Exist LoopAnimation', 00H ; `string'
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@4f800000
CONST	SEGMENT
__real@4f800000 DD 04f800000r			; 4.29497e+009
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetLoopState@ioRangeSyncBuffSkill@@MAEXPAVioBaseChar@@PAVioPlayStage@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetLoopState@ioRangeSyncBuffSkill@@MAEXPAVioBaseChar@@PAVioPlayStage@@@Z$0
__ehfuncinfo$?SetLoopState@ioRangeSyncBuffSkill@@MAEXPAVioBaseChar@@PAVioPlayStage@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetLoopState@ioRangeSyncBuffSkill@@MAEXPAVioBaseChar@@PAVioPlayStage@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iorangesyncbuffskill.cpp
xdata$x	ENDS
;	COMDAT ?SetLoopState@ioRangeSyncBuffSkill@@MAEXPAVioBaseChar@@PAVioPlayStage@@@Z
_TEXT	SEGMENT
$T533023 = -84						; size = 12
$T533150 = -72						; size = 16
$T531038 = -68						; size = 12
tv1427 = -56						; size = 4
_pChar$GSCopy$ = -56					; size = 4
$T533149 = -52						; size = 4
_iAniID$ = -52						; size = 4
tv1482 = -48						; size = 4
tv1477 = -48						; size = 4
tv1469 = -48						; size = 4
tv1450 = -48						; size = 4
tv1435 = -48						; size = 4
tv1431 = -48						; size = 4
_vPos$ = -44						; size = 12
_szEncEventType$533163 = -32				; size = 12
$T531037 = -28						; size = 12
__$EHRec$ = -12						; size = 12
_pChar$ = 8						; size = 4
_pStage$ = 12						; size = 4
?SetLoopState@ioRangeSyncBuffSkill@@MAEXPAVioBaseChar@@PAVioPlayStage@@@Z PROC ; ioRangeSyncBuffSkill::SetLoopState, COMDAT
; _this$ = ecx

; 276  : {

  00000	6a 48		 push	 72			; 00000048H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetLoopState@ioRangeSyncBuffSkill@@MAEXPAVioBaseChar@@PAVioPlayStage@@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000c	8b 7d 08	 mov	 edi, DWORD PTR _pChar$[ebp]

; 277  : 	ioEntityGroup *pGrp = pChar->GetGroup();

  0000f	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  00012	8b f1		 mov	 esi, ecx

; 278  : 	int iAniID = pGrp->GetAnimationIdx( m_LoopAnimation );

  00014	8d 86 a4 0f 00
	00		 lea	 eax, DWORD PTR [esi+4004]
  0001a	50		 push	 eax
  0001b	8b cb		 mov	 ecx, ebx
  0001d	89 7d c8	 mov	 DWORD PTR _pChar$GSCopy$[ebp], edi
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetAnimationIdx@ioEntityGroup@@QAEHABVioHashString@@@Z
  00026	89 45 cc	 mov	 DWORD PTR _iAniID$[ebp], eax

; 279  : 
; 280  : 	pGrp->ClearAllLoopAni( FLOAT100, true );

  00029	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  0002e	89 45 d0	 mov	 DWORD PTR tv1482[ebp], eax
  00031	db 45 d0	 fild	 DWORD PTR tv1482[ebp]
  00034	6a 01		 push	 1
  00036	85 c0		 test	 eax, eax
  00038	79 06		 jns	 SHORT $LN145@SetLoopSta
  0003a	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN145@SetLoopSta:
  00040	51		 push	 ecx
  00041	8b cb		 mov	 ecx, ebx
  00043	d9 1c 24	 fstp	 DWORD PTR [esp]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ClearAllLoopAni@ioEntityGroup@@QAEXM_N@Z

; 281  : 	pGrp->ClearAllActionAni( FLOAT100, true );

  0004c	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  00051	89 45 d0	 mov	 DWORD PTR tv1477[ebp], eax
  00054	db 45 d0	 fild	 DWORD PTR tv1477[ebp]
  00057	6a 01		 push	 1
  00059	85 c0		 test	 eax, eax
  0005b	79 06		 jns	 SHORT $LN146@SetLoopSta
  0005d	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN146@SetLoopSta:
  00063	51		 push	 ecx
  00064	8b cb		 mov	 ecx, ebx
  00066	d9 1c 24	 fstp	 DWORD PTR [esp]
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ClearAllActionAni@ioEntityGroup@@QAEXM_N@Z

; 282  : 
; 283  : 	if( iAniID == -1 )

  0006f	83 7d cc ff	 cmp	 DWORD PTR _iAniID$[ebp], -1
  00073	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0007b	75 39		 jne	 SHORT $LN5@SetLoopSta

; 284  : 	{
; 285  : 		m_dwEnableReserveTime = FRAMEGETTIME();

  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  00083	8b c8		 mov	 ecx, eax
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ

; 286  : 		LOG.PrintTimeAndLog( 0, "ioRangeBuffSkill::SetLoopState() - %s, Not Exist LoopAnimation",
; 287  : 								 GetName().c_str() );

  0008b	8d 4e 24	 lea	 ecx, DWORD PTR [esi+36]
  0008e	89 86 dc 02 00
	00		 mov	 DWORD PTR [esi+732], eax
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  0009a	50		 push	 eax
  0009b	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@KAEFGCEE@ioRangeBuffSkill?3?3SetLoopState?$CI?$CJ@
  000a0	6a 00		 push	 0
  000a2	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintTimeAndLog@CLog@@QAAXHPADZZ
  000ae	83 c4 10	 add	 esp, 16			; 00000010H

; 288  : 	}
; 289  : 	else

  000b1	e9 f1 00 00 00	 jmp	 $LN4@SetLoopSta
$LN5@SetLoopSta:

; 290  : 	{
; 291  : 		pGrp->SetLoopAni( m_LoopAnimation, FLOAT100 );

  000b6	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  000bb	0f 57 c9	 xorps	 xmm1, xmm1
  000be	83 ec 10	 sub	 esp, 16			; 00000010H
  000c1	f3 0f 11 4c 24
	0c		 movss	 DWORD PTR [esp+12], xmm1
  000c7	89 45 d0	 mov	 DWORD PTR tv1469[ebp], eax
  000ca	db 45 d0	 fild	 DWORD PTR tv1469[ebp]
  000cd	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  000d3	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000d9	85 c0		 test	 eax, eax
  000db	79 06		 jns	 SHORT $LN147@SetLoopSta
  000dd	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN147@SetLoopSta:
  000e3	8d 86 a4 0f 00
	00		 lea	 eax, DWORD PTR [esi+4004]
  000e9	d9 1c 24	 fstp	 DWORD PTR [esp]
  000ec	50		 push	 eax
  000ed	8b cb		 mov	 ecx, ebx
  000ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetLoopAni@ioEntityGroup@@QAE_NABVioHashString@@MMMM@Z

; 292  : 		m_dwEnableReserveTime = FRAMEGETTIME();

  000f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  000fb	8b c8		 mov	 ecx, eax
  000fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ
  00103	6a 02		 push	 2
  00105	89 86 dc 02 00
	00		 mov	 DWORD PTR [esi+732], eax

; 293  : 		m_dwEnableReserveTime += pGrp->GetAnimationEventTime_e( iAniID, "key_reserve" );

  0010b	c7 45 e0 86 89
	92 b5		 mov	 DWORD PTR _szEncEventType$533163[ebp], -1248687738 ; b5928986H
  00112	c7 45 e4 9f 89
	98 8f		 mov	 DWORD PTR _szEncEventType$533163[ebp+4], -1885828705 ; 8f98899fH
  00119	8d 45 e0	 lea	 eax, DWORD PTR _szEncEventType$533163[ebp]
  0011c	c7 45 e8 9f 9a
	8e 00		 mov	 DWORD PTR _szEncEventType$533163[ebp+8], 9345695 ; 008e9a9fH
  00123	59		 pop	 ecx
$LL122@SetLoopSta:
  00124	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0012a	83 c0 04	 add	 eax, 4
  0012d	49		 dec	 ecx
  0012e	75 f4		 jne	 SHORT $LL122@SetLoopSta
  00130	6a 08		 push	 8
  00132	58		 pop	 eax
$LL119@SetLoopSta:
  00133	8b c8		 mov	 ecx, eax
  00135	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0013b	79 05		 jns	 SHORT $LN148@SetLoopSta
  0013d	49		 dec	 ecx
  0013e	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00141	41		 inc	 ecx
$LN148@SetLoopSta:
  00142	b2 ed		 mov	 dl, -19			; ffffffedH
  00144	2a d1		 sub	 dl, cl
  00146	30 54 05 e0	 xor	 BYTE PTR _szEncEventType$533163[ebp+eax], dl
  0014a	40		 inc	 eax
  0014b	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0014e	7c e3		 jl	 SHORT $LL119@SetLoopSta
  00150	8d 45 e0	 lea	 eax, DWORD PTR _szEncEventType$533163[ebp]
  00153	50		 push	 eax
  00154	8d 4d b8	 lea	 ecx, DWORD PTR $T533150[ebp]
  00157	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  0015d	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00161	8d 45 b8	 lea	 eax, DWORD PTR $T533150[ebp]
  00164	50		 push	 eax
  00165	ff 75 cc	 push	 DWORD PTR _iAniID$[ebp]
  00168	8b cb		 mov	 ecx, ebx
  0016a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetAnimationEventTime@ioEntityGroup@@QAEMHABVioHashString@@@Z
  00170	d9 5d cc	 fstp	 DWORD PTR $T533149[ebp]
  00173	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00177	8d 4d b8	 lea	 ecx, DWORD PTR $T533150[ebp]
  0017a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00180	db 86 dc 02 00
	00		 fild	 DWORD PTR [esi+732]
  00186	8b 86 dc 02 00
	00		 mov	 eax, DWORD PTR [esi+732]
  0018c	85 c0		 test	 eax, eax
  0018e	79 06		 jns	 SHORT $LN149@SetLoopSta
  00190	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN149@SetLoopSta:
  00196	d8 45 cc	 fadd	 DWORD PTR $T533149[ebp]
  00199	e8 00 00 00 00	 call	 __ftol2
  0019e	8b 7d c8	 mov	 edi, DWORD PTR _pChar$GSCopy$[ebp]
  001a1	89 86 dc 02 00
	00		 mov	 DWORD PTR [esi+732], eax
$LN4@SetLoopSta:

; 294  : 	}
; 295  : 
; 296  : 	D3DXVECTOR3 vPos = pChar->GetMidPositionByRate( FLOAT08 ) + m_vEffectDir * m_fOffSet;

  001a7	f3 0f 10 86 78
	0f 00 00	 movss	 xmm0, DWORD PTR [esi+3960]
  001af	f3 0f 10 96 98
	0f 00 00	 movss	 xmm2, DWORD PTR [esi+3992]
  001b7	0f 5a c8	 cvtps2pd xmm1, xmm0
  001ba	0f 5a d2	 cvtps2pd xmm2, xmm2
  001bd	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  001c1	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  001c5	f3 0f 11 4d bc	 movss	 DWORD PTR $T531038[ebp], xmm1
  001ca	f3 0f 10 8e 9c
	0f 00 00	 movss	 xmm1, DWORD PTR [esi+3996]
  001d2	0f 5a c9	 cvtps2pd xmm1, xmm1
  001d5	0f 5a d0	 cvtps2pd xmm2, xmm0
  001d8	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  001dc	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  001e0	f3 0f 11 4d c0	 movss	 DWORD PTR $T531038[ebp+4], xmm1
  001e5	f3 0f 10 8e a0
	0f 00 00	 movss	 xmm1, DWORD PTR [esi+4000]
  001ed	0f 5a c0	 cvtps2pd xmm0, xmm0
  001f0	0f 5a c9	 cvtps2pd xmm1, xmm1
  001f3	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  001f7	0f 57 c0	 xorps	 xmm0, xmm0
  001fa	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  001fe	f3 0f 11 45 c4	 movss	 DWORD PTR $T531038[ebp+8], xmm0
  00203	b8 08 00 00 00	 mov	 eax, 8
  00208	8b c8		 mov	 ecx, eax
  0020a	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  0020f	89 4d d0	 mov	 DWORD PTR tv1435[ebp], ecx
  00212	db 45 d0	 fild	 DWORD PTR tv1435[ebp]
  00215	85 c9		 test	 ecx, ecx
  00217	79 06		 jns	 SHORT $LN150@SetLoopSta
  00219	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN150@SetLoopSta:
  0021f	89 45 d0	 mov	 DWORD PTR tv1431[ebp], eax
  00222	db 45 d0	 fild	 DWORD PTR tv1431[ebp]
  00225	85 c0		 test	 eax, eax
  00227	79 06		 jns	 SHORT $LN151@SetLoopSta
  00229	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN151@SetLoopSta:
  0022f	de f9		 fdivp	 ST(1), ST(0)
  00231	51		 push	 ecx
  00232	8d 45 e4	 lea	 eax, DWORD PTR $T531037[ebp]
  00235	8b cf		 mov	 ecx, edi
  00237	d9 5d c8	 fstp	 DWORD PTR tv1427[ebp]
  0023a	d9 45 c8	 fld	 DWORD PTR tv1427[ebp]
  0023d	d9 1c 24	 fstp	 DWORD PTR [esp]
  00240	50		 push	 eax
  00241	e8 00 00 00 00	 call	 ?GetMidPositionByRate@ioGameEntity@@QBE?AUD3DXVECTOR3@@M@Z ; ioGameEntity::GetMidPositionByRate
  00246	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0024b	f3 0f 10 18	 movss	 xmm3, DWORD PTR [eax]
  0024f	f3 0f 10 4d c0	 movss	 xmm1, DWORD PTR $T531038[ebp+4]
  00254	f3 0f 10 55 c4	 movss	 xmm2, DWORD PTR $T531038[ebp+8]
  00259	0f 5a c9	 cvtps2pd xmm1, xmm1
  0025c	0f 5a c0	 cvtps2pd xmm0, xmm0
  0025f	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00263	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  00268	0f 5a d2	 cvtps2pd xmm2, xmm2

; 297  : 	pChar->CreateMapEffectBySkill( m_RangeEffect, vPos );

  0026b	8d 45 ac	 lea	 eax, DWORD PTR $T533023[ebp]
  0026e	50		 push	 eax
  0026f	0f 5a c9	 cvtps2pd xmm1, xmm1
  00272	f2 0f 58 ca	 addsd	 xmm1, xmm2
  00276	f3 0f 10 55 bc	 movss	 xmm2, DWORD PTR $T531038[ebp]
  0027b	8d 45 d4	 lea	 eax, DWORD PTR _vPos$[ebp]
  0027e	50		 push	 eax
  0027f	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00283	0f 5a d2	 cvtps2pd xmm2, xmm2
  00286	0f 5a db	 cvtps2pd xmm3, xmm3
  00289	8d 86 88 0f 00
	00		 lea	 eax, DWORD PTR [esi+3976]
  0028f	f2 0f 58 d3	 addsd	 xmm2, xmm3
  00293	f3 0f 11 45 d8	 movss	 DWORD PTR _vPos$[ebp+4], xmm0
  00298	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  002a0	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  002a4	f2 0f 5a d2	 cvtsd2ss xmm2, xmm2
  002a8	50		 push	 eax
  002a9	8b cf		 mov	 ecx, edi
  002ab	f3 0f 11 55 d4	 movss	 DWORD PTR _vPos$[ebp], xmm2
  002b0	f3 0f 11 4d dc	 movss	 DWORD PTR _vPos$[ebp+8], xmm1
  002b5	f3 0f 11 45 ac	 movss	 DWORD PTR $T533023[ebp], xmm0
  002ba	f3 0f 11 45 b0	 movss	 DWORD PTR $T533023[ebp+4], xmm0
  002bf	f3 0f 11 45 b4	 movss	 DWORD PTR $T533023[ebp+8], xmm0
  002c4	e8 00 00 00 00	 call	 ?CreateMapEffectBySkill@ioBaseChar@@QAEPAVioMapEffect@@ABVioHashString@@ABUD3DXVECTOR3@@AAU4@@Z ; ioBaseChar::CreateMapEffectBySkill

; 298  : 
; 299  : 	if( m_bSetHandMesh )

  002c9	80 be 0a 0f 00
	00 00		 cmp	 BYTE PTR [esi+3850], 0
  002d0	74 35		 je	 SHORT $LN153@SetLoopSta

; 300  : 	{
; 301  : 		if( !m_StartHandMesh.IsEmpty() )

  002d2	8d 9e 60 10 00
	00		 lea	 ebx, DWORD PTR [esi+4192]
  002d8	8b cb		 mov	 ecx, ebx
  002da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  002e0	84 c0		 test	 al, al
  002e2	75 13		 jne	 SHORT $LN2@SetLoopSta

; 302  : 		{
; 303  : 			pChar->RestoreSkillWeaponMesh( this, m_StartHandMesh, m_bVisibleEquipMesh );

  002e4	0f b6 86 09 0f
	00 00		 movzx	 eax, BYTE PTR [esi+3849]
  002eb	6a 00		 push	 0
  002ed	50		 push	 eax
  002ee	53		 push	 ebx
  002ef	56		 push	 esi
  002f0	8b cf		 mov	 ecx, edi
  002f2	e8 00 00 00 00	 call	 ?RestoreSkillWeaponMesh@ioBaseChar@@QAE_NPAVioSkill@@ABVioHashString@@_N2@Z ; ioBaseChar::RestoreSkillWeaponMesh
$LN2@SetLoopSta:

; 304  : 		}
; 305  : 		m_bSetHandMesh = false;

  002f7	c6 86 0a 0f 00
	00 00		 mov	 BYTE PTR [esi+3850], 0

; 306  : 	}
; 307  : 
; 308  : 	//   
; 309  : 	if( !m_bSetHandMesh && m_bUseItemMesh && !m_LoopHandMesh.IsEmpty() )

  002fe	80 be 0a 0f 00
	00 00		 cmp	 BYTE PTR [esi+3850], 0
  00305	75 33		 jne	 SHORT $LN1@SetLoopSta
$LN153@SetLoopSta:
  00307	80 be 08 0f 00
	00 00		 cmp	 BYTE PTR [esi+3848], 0
  0030e	74 2a		 je	 SHORT $LN1@SetLoopSta
  00310	8d 9e 70 10 00
	00		 lea	 ebx, DWORD PTR [esi+4208]
  00316	8b cb		 mov	 ecx, ebx
  00318	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  0031e	84 c0		 test	 al, al
  00320	75 18		 jne	 SHORT $LN1@SetLoopSta

; 310  : 	{
; 311  : 		pChar->ChangeSkillWeaponMesh( this, m_LoopHandMesh, m_bVisibleEquipMesh );

  00322	0f b6 86 09 0f
	00 00		 movzx	 eax, BYTE PTR [esi+3849]
  00329	50		 push	 eax
  0032a	53		 push	 ebx
  0032b	56		 push	 esi
  0032c	8b cf		 mov	 ecx, edi
  0032e	e8 00 00 00 00	 call	 ?ChangeSkillWeaponMesh@ioBaseChar@@QAE_NPAVioSkill@@ABVioHashString@@_N@Z ; ioBaseChar::ChangeSkillWeaponMesh

; 312  : 		m_bSetHandMesh = true;

  00333	c6 86 0a 0f 00
	00 01		 mov	 BYTE PTR [esi+3850], 1
$LN1@SetLoopSta:

; 313  : 	}
; 314  : 
; 315  : 	m_dwLoopStartTime = FRAMEGETTIME();

  0033a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  00340	8b c8		 mov	 ecx, eax
  00342	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ

; 316  : 	m_dwProtectTime = m_dwLoopStartTime + m_dwLoopProtectDuration;

  00348	8b 8e 64 0f 00
	00		 mov	 ecx, DWORD PTR [esi+3940]
  0034e	03 c8		 add	 ecx, eax
  00350	89 86 b4 0f 00
	00		 mov	 DWORD PTR [esi+4020], eax
  00356	89 8e 68 0f 00
	00		 mov	 DWORD PTR [esi+3944], ecx

; 317  : 
; 318  : 	m_RangeState = RS_LOOP;

  0035c	c7 86 5c 0f 00
	00 03 00 00 00	 mov	 DWORD PTR [esi+3932], 3

; 319  : }

  00366	e8 00 00 00 00	 call	 __EH_epilog3_GS
  0036b	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetLoopState@ioRangeSyncBuffSkill@@MAEXPAVioBaseChar@@PAVioPlayStage@@@Z$0:
  00000	8d 4d b8	 lea	 ecx, DWORD PTR $T533150[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$?SetLoopState@ioRangeSyncBuffSkill@@MAEXPAVioBaseChar@@PAVioPlayStage@@@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetLoopState@ioRangeSyncBuffSkill@@MAEXPAVioBaseChar@@PAVioPlayStage@@@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetLoopState@ioRangeSyncBuffSkill@@MAEXPAVioBaseChar@@PAVioPlayStage@@@Z ENDP ; ioRangeSyncBuffSkill::SetLoopState
PUBLIC	??0?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE@XZ ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::vector<ioBaseChar *,std::allocator<ioBaseChar *> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE@XZ PROC ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::vector<ioBaseChar *,std::allocator<ioBaseChar *> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE@XZ ENDP ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::vector<ioBaseChar *,std::allocator<ioBaseChar *> >
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@XZ ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::begin
; Function compile flags: /Ogsp
;	COMDAT ?begin@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@XZ PROC ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 782  : 		return (iterator(this->_Myfirst, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 783  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@XZ ENDP ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@XZ ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::end
; Function compile flags: /Ogsp
;	COMDAT ?end@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@XZ PROC ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 792  : 		return (iterator(this->_Mylast, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 793  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@XZ ENDP ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::end
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator!=
; Function compile flags: /Ogsp
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 209  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioBaseChar *,std::allocator<ioBaseChar *> > >::operator!=
_TEXT	ENDS
PUBLIC	?_Grow_to@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IBEII@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::_Grow_to
; Function compile flags: /Ogsp
;	COMDAT ?_Grow_to@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IBEII@Z PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1275 : 		size_type _Capacity = capacity();

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00008	ba ff ff ff 0f	 mov	 edx, 268435455		; 0fffffffH
  0000d	c1 f8 04	 sar	 eax, 4
  00010	8b c8		 mov	 ecx, eax
  00012	d1 e9		 shr	 ecx, 1
  00014	2b d1		 sub	 edx, ecx
  00016	3b d0		 cmp	 edx, eax
  00018	73 04		 jae	 SHORT $LN4@Grow_to
  0001a	33 c0		 xor	 eax, eax
  0001c	eb 02		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  0001e	03 c1		 add	 eax, ecx
$LN5@Grow_to:

; 1279 : 		if (_Capacity < _Count)

  00020	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]

; 1280 : 			_Capacity = _Count;

  00023	0f 42 45 08	 cmovb	 eax, DWORD PTR __Count$[ebp]

; 1281 : 		return (_Capacity);
; 1282 : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?_Grow_to@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IBEII@Z ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::_Grow_to
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@IAEXPAPAVioBaseChar@@0@Z ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::_Destroy
; Function compile flags: /Ogsp
;	COMDAT ?_Destroy@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@IAEXPAPAVioBaseChar@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@IAEXPAPAVioBaseChar@@0@Z PROC ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::_Destroy, COMDAT
; _this$ = ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@IAEXPAPAVioBaseChar@@0@Z ENDP ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@VioHashString@@@std@@VioHashString@@AAV3@@std@@YAXAAV?$allocator@VioHashString@@@0@PAVioHashString@@AAV2@@Z ; std::_Cons_val<std::allocator<ioHashString>,ioHashString,ioHashString &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@VioHashString@@@std@@VioHashString@@AAV3@@std@@YAXAAV?$allocator@VioHashString@@@0@PAVioHashString@@AAV2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@VioHashString@@@std@@VioHashString@@AAV3@@std@@YAXAAV?$allocator@VioHashString@@@0@PAVioHashString@@AAV2@@Z PROC ; std::_Cons_val<std::allocator<ioHashString>,ioHashString,ioHashString &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	ff 75 10	 push	 DWORD PTR __Src$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Pdest$[ebp]
  0000c	e8 00 00 00 00	 call	 ??$construct@AAVioHashString@@@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@AAV2@@Z ; std::allocator<ioHashString>::construct<ioHashString &>

; 281  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Cons_val@V?$allocator@VioHashString@@@std@@VioHashString@@AAV3@@std@@YAXAAV?$allocator@VioHashString@@@0@PAVioHashString@@AAV2@@Z ENDP ; std::_Cons_val<std::allocator<ioHashString>,ioHashString,ioHashString &>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@VioHashString@@@std@@VioHashString@@V3@@std@@YAXAAV?$allocator@VioHashString@@@0@PAVioHashString@@$$QAV2@@Z ; std::_Cons_val<std::allocator<ioHashString>,ioHashString,ioHashString>
; Function compile flags: /Ogsp
;	COMDAT ??$_Cons_val@V?$allocator@VioHashString@@@std@@VioHashString@@V3@@std@@YAXAAV?$allocator@VioHashString@@@0@PAVioHashString@@$$QAV2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@VioHashString@@@std@@VioHashString@@V3@@std@@YAXAAV?$allocator@VioHashString@@@0@PAVioHashString@@$$QAV2@@Z PROC ; std::_Cons_val<std::allocator<ioHashString>,ioHashString,ioHashString>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	ff 75 10	 push	 DWORD PTR __Src$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Pdest$[ebp]
  0000c	e8 00 00 00 00	 call	 ?construct@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@$$QAV3@@Z ; std::allocator<ioHashString>::construct

; 281  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Cons_val@V?$allocator@VioHashString@@@std@@VioHashString@@V3@@std@@YAXAAV?$allocator@VioHashString@@@0@PAVioHashString@@$$QAV2@@Z ENDP ; std::_Cons_val<std::allocator<ioHashString>,ioHashString,ioHashString>
_TEXT	ENDS
PUBLIC	?GetTeam@ioPlayEntity@@QBE?AW4TeamType@@XZ	; ioPlayEntity::GetTeam
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioplayentity.h
;	COMDAT ?GetTeam@ioPlayEntity@@QBE?AW4TeamType@@XZ
_TEXT	SEGMENT
_value$533358 = -4					; size = 4
?GetTeam@ioPlayEntity@@QBE?AW4TeamType@@XZ PROC		; ioPlayEntity::GetTeam, COMDAT
; _this$ = ecx

; 107  : 	inline TeamType GetTeam() const { return m_TeamType; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 fc	 lea	 eax, DWORD PTR _value$533358[ebp]
  00007	50		 push	 eax
  00008	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  0000e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  00013	8b 45 fc	 mov	 eax, DWORD PTR _value$533358[ebp]
  00016	c9		 leave
  00017	c3		 ret	 0
?GetTeam@ioPlayEntity@@QBE?AW4TeamType@@XZ ENDP		; ioPlayEntity::GetTeam
_TEXT	ENDS
PUBLIC	?GetSkillMotionTime@ioSkill@@QBEKXZ		; ioSkill::GetSkillMotionTime
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\ioskill.h
;	COMDAT ?GetSkillMotionTime@ioSkill@@QBEKXZ
_TEXT	SEGMENT
_value$533364 = -4					; size = 4
?GetSkillMotionTime@ioSkill@@QBEKXZ PROC		; ioSkill::GetSkillMotionTime, COMDAT
; _this$ = ecx

; 426  : 	inline DWORD GetSkillMotionTime() const { return m_dwMotionEndTime - m_dwMotionStartTime; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	8d 45 fc	 lea	 eax, DWORD PTR _value$533364[ebp]
  0000a	50		 push	 eax
  0000b	8d 8e a8 02 00
	00		 lea	 ecx, DWORD PTR [esi+680]
  00011	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z ; CEncrypt<unsigned long>::DecryptValueToPool
  00016	8b 86 d8 02 00
	00		 mov	 eax, DWORD PTR [esi+728]
  0001c	2b 45 fc	 sub	 eax, DWORD PTR _value$533364[ebp]
  0001f	5e		 pop	 esi
  00020	c9		 leave
  00021	c3		 ret	 0
?GetSkillMotionTime@ioSkill@@QBEKXZ ENDP		; ioSkill::GetSkillMotionTime
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?IsCanJumpingSkill@ioSkill@@UBE_NXZ
_TEXT	SEGMENT
_value$533371 = -1					; size = 1
?IsCanJumpingSkill@ioSkill@@UBE_NXZ PROC		; ioSkill::IsCanJumpingSkill, COMDAT
; _this$ = ecx

; 431  : 	virtual bool IsCanJumpingSkill() const { return m_bEnableJumpingSkill; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 ff	 lea	 eax, DWORD PTR _value$533371[ebp]
  00007	50		 push	 eax
  00008	81 c1 9c 03 00
	00		 add	 ecx, 924		; 0000039cH
  0000e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  00013	8a 45 ff	 mov	 al, BYTE PTR _value$533371[ebp]
  00016	c9		 leave
  00017	c3		 ret	 0
?IsCanJumpingSkill@ioSkill@@UBE_NXZ ENDP		; ioSkill::IsCanJumpingSkill
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?IsCanJumpingSkillOnBlowWound@ioSkill@@UBE_NXZ
_TEXT	SEGMENT
_value$533378 = -1					; size = 1
?IsCanJumpingSkillOnBlowWound@ioSkill@@UBE_NXZ PROC	; ioSkill::IsCanJumpingSkillOnBlowWound, COMDAT
; _this$ = ecx

; 432  : 	virtual bool IsCanJumpingSkillOnBlowWound() const { return m_bEnableJumpingSkillOnBlowWound; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 ff	 lea	 eax, DWORD PTR _value$533378[ebp]
  00007	50		 push	 eax
  00008	81 c1 cc 03 00
	00		 add	 ecx, 972		; 000003ccH
  0000e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  00013	8a 45 ff	 mov	 al, BYTE PTR _value$533378[ebp]
  00016	c9		 leave
  00017	c3		 ret	 0
?IsCanJumpingSkillOnBlowWound@ioSkill@@UBE_NXZ ENDP	; ioSkill::IsCanJumpingSkillOnBlowWound
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?IsCanDownSkill@ioSkill@@UBE_NXZ
_TEXT	SEGMENT
_value$533385 = -1					; size = 1
?IsCanDownSkill@ioSkill@@UBE_NXZ PROC			; ioSkill::IsCanDownSkill, COMDAT
; _this$ = ecx

; 437  : 	virtual bool IsCanDownSkill() const { return m_bEnableDownSkill; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 ff	 lea	 eax, DWORD PTR _value$533385[ebp]
  00007	50		 push	 eax
  00008	81 c1 5c 04 00
	00		 add	 ecx, 1116		; 0000045cH
  0000e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  00013	8a 45 ff	 mov	 al, BYTE PTR _value$533385[ebp]
  00016	c9		 leave
  00017	c3		 ret	 0
?IsCanDownSkill@ioSkill@@UBE_NXZ ENDP			; ioSkill::IsCanDownSkill
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?IsCanBlowWoundSkill@ioSkill@@UBE_NXZ
_TEXT	SEGMENT
_value$533392 = -1					; size = 1
?IsCanBlowWoundSkill@ioSkill@@UBE_NXZ PROC		; ioSkill::IsCanBlowWoundSkill, COMDAT
; _this$ = ecx

; 440  : 	virtual bool IsCanBlowWoundSkill() const { return m_bEnableBlowWoundSkill; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 ff	 lea	 eax, DWORD PTR _value$533392[ebp]
  00007	50		 push	 eax
  00008	81 c1 8c 04 00
	00		 add	 ecx, 1164		; 0000048cH
  0000e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  00013	8a 45 ff	 mov	 al, BYTE PTR _value$533392[ebp]
  00016	c9		 leave
  00017	c3		 ret	 0
?IsCanBlowWoundSkill@ioSkill@@UBE_NXZ ENDP		; ioSkill::IsCanBlowWoundSkill
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?IsCanWoundSkill@ioSkill@@UBE_NXZ
_TEXT	SEGMENT
_value$533399 = -1					; size = 1
?IsCanWoundSkill@ioSkill@@UBE_NXZ PROC			; ioSkill::IsCanWoundSkill, COMDAT
; _this$ = ecx

; 446  : 	virtual bool IsCanWoundSkill() const { return m_bEnableWoundSkill; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 ff	 lea	 eax, DWORD PTR _value$533399[ebp]
  00007	50		 push	 eax
  00008	81 c1 54 05 00
	00		 add	 ecx, 1364		; 00000554H
  0000e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  00013	8a 45 ff	 mov	 al, BYTE PTR _value$533399[ebp]
  00016	c9		 leave
  00017	c3		 ret	 0
?IsCanWoundSkill@ioSkill@@UBE_NXZ ENDP			; ioSkill::IsCanWoundSkill
_TEXT	ENDS
PUBLIC	??0?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ ; std::vector<ioHashString,std::allocator<ioHashString> >::vector<ioHashString,std::allocator<ioHashString> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::vector<ioHashString,std::allocator<ioHashString> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::vector<ioHashString,std::allocator<ioHashString> >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::operator!=
; Function compile flags: /Ogsp
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 209  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<ioHashString,std::allocator<ioHashString> > >::operator!=
_TEXT	ENDS
PUBLIC	??$_Move@PAVioHashString@@PAV1@@std@@YAPAVioHashString@@PAV1@00@Z ; std::_Move<ioHashString *,ioHashString *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAVioHashString@@PAV1@@std@@YAPAVioHashString@@PAV1@00@Z
_TEXT	SEGMENT
__Cat$533434 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAVioHashString@@PAV1@@std@@YAPAVioHashString@@PAV1@00@Z PROC ; std::_Move<ioHashString *,ioHashString *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$533434[ebp]
  00007	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Move@PAVioHashString@@PAV1@@std@@YAPAVioHashString@@PAV1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<ioHashString *,ioHashString *>
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00018	c9		 leave
  00019	c3		 ret	 0
??$_Move@PAVioHashString@@PAV1@@std@@YAPAVioHashString@@PAV1@00@Z ENDP ; std::_Move<ioHashString *,ioHashString *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@@Z ; std::allocator<ioHashString>::destroy
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@@Z PROC ; std::allocator<ioHashString>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 213  : 		_Destroy(_Ptr);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ

; 214  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?destroy@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@@Z ENDP ; std::allocator<ioHashString>::destroy
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@VioHashString@@@std@@VioHashString@@ABV3@@std@@YAXAAV?$allocator@VioHashString@@@0@PAVioHashString@@ABV2@@Z ; std::_Cons_val<std::allocator<ioHashString>,ioHashString,ioHashString const &>
; Function compile flags: /Ogsp
;	COMDAT ??$_Cons_val@V?$allocator@VioHashString@@@std@@VioHashString@@ABV3@@std@@YAXAAV?$allocator@VioHashString@@@0@PAVioHashString@@ABV2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@VioHashString@@@std@@VioHashString@@ABV3@@std@@YAXAAV?$allocator@VioHashString@@@0@PAVioHashString@@ABV2@@Z PROC ; std::_Cons_val<std::allocator<ioHashString>,ioHashString,ioHashString const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	ff 75 10	 push	 DWORD PTR __Src$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR __Pdest$[ebp]
  00009	e8 00 00 00 00	 call	 ??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z ; std::_Construct<ioHashString,ioHashString const &>
  0000e	59		 pop	 ecx
  0000f	59		 pop	 ecx

; 281  : 	}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Cons_val@V?$allocator@VioHashString@@@std@@VioHashString@@ABV3@@std@@YAXAAV?$allocator@VioHashString@@@0@PAVioHashString@@ABV2@@Z ENDP ; std::_Cons_val<std::allocator<ioHashString>,ioHashString,ioHashString const &>
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@0@Z ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::erase
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?erase@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Cat$533531 = 16					; size = 1
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@0@Z PROC ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	8b f1		 mov	 esi, ecx
  0000d	89 07		 mov	 DWORD PTR [edi], eax

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);
; 1193 : 
; 1194 : 		if (_First != _Last)

  0000f	3b 45 10	 cmp	 eax, DWORD PTR __Last_arg$[ebp]
  00012	74 16		 je	 SHORT $LN1@erase

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  00014	ff 75 10	 push	 DWORD PTR __Cat$533531[ebp]
  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	50		 push	 eax
  0001b	51		 push	 ecx
  0001c	ff 75 10	 push	 DWORD PTR __Last_arg$[ebp]
  0001f	e8 00 00 00 00	 call	 ??$_Move@PAPAVioBaseChar@@PAPAV1@@std@@YAPAPAVioBaseChar@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<ioBaseChar * *,ioBaseChar * *>
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);
; 1211 : 			this->_Mylast = _Ptr;

  00027	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN1@erase:

; 1212 : 			}
; 1213 : 		return (_First);

  0002a	8b c7		 mov	 eax, edi
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi

; 1214 : 		}

  0002e	5d		 pop	 ebp
  0002f	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@0@Z ENDP ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@IAEXXZ ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::_Tidy
EXTRN	__imp_?_Orphan_all@_Container_base0@std@@QAEXXZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ?_Tidy@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@IAEXXZ PROC ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00006	74 0e		 je	 SHORT $LN12@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  0000e	ff 36		 push	 DWORD PTR [esi]
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	59		 pop	 ecx
$LN12@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00016	83 26 00	 and	 DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

  00019	83 66 04 00	 and	 DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

  0001d	83 66 08 00	 and	 DWORD PTR [esi+8], 0
  00021	5e		 pop	 esi

; 1312 : 		}

  00022	c3		 ret	 0
?_Tidy@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@IAEXXZ ENDP ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@VioHashString@@@std@@VioHashString@@@std@@YAXAAV?$allocator@VioHashString@@@0@PAVioHashString@@@Z ; std::_Dest_val<std::allocator<ioHashString>,ioHashString>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@VioHashString@@@std@@VioHashString@@@std@@YAXAAV?$allocator@VioHashString@@@0@PAVioHashString@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@VioHashString@@@std@@VioHashString@@@std@@YAXAAV?$allocator@VioHashString@@@0@PAVioHashString@@@Z PROC ; std::_Dest_val<std::allocator<ioHashString>,ioHashString>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 287  : 	_Alval.destroy(_Pdest);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]

; 288  : 	}

  00006	5d		 pop	 ebp

; 287  : 	_Alval.destroy(_Pdest);

  00007	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
??$_Dest_val@V?$allocator@VioHashString@@@std@@VioHashString@@@std@@YAXAAV?$allocator@VioHashString@@@0@PAVioHashString@@@Z ENDP ; std::_Dest_val<std::allocator<ioHashString>,ioHashString>
_TEXT	ENDS
PUBLIC	??1?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE@XZ ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::~vector<ioBaseChar *,std::allocator<ioBaseChar *> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??1?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE@XZ PROC ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::~vector<ioBaseChar *,std::allocator<ioBaseChar *> >, COMDAT
; _this$ = ecx

; 705  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@IAEXXZ ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::_Tidy
??1?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE@XZ ENDP ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::~vector<ioBaseChar *,std::allocator<ioBaseChar *> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAEXXZ ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::clear
; Function compile flags: /Ogsp
;	COMDAT ?clear@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T533634 = -4						; size = 4
?clear@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAEXXZ PROC ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1218 : 		erase(begin(), end());

  00004	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00007	8b 11		 mov	 edx, DWORD PTR [ecx]
  00009	50		 push	 eax
  0000a	52		 push	 edx
  0000b	8d 45 fc	 lea	 eax, DWORD PTR $T533634[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?erase@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@0@Z ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::erase

; 1219 : 		}

  00014	c9		 leave
  00015	c3		 ret	 0
?clear@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAEXXZ ENDP ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::clear
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAVioHashString@@PAV1@V?$allocator@VioHashString@@@std@@V1@@std@@YAPAVioHashString@@PAV1@00AAV?$allocator@VioHashString@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ioHashString *,ioHashString *,std::allocator<ioHashString>,ioHashString>
EXTRN	__EH_prolog3_catch:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAVioHashString@@PAV1@V?$allocator@VioHashString@@@std@@V1@@std@@YAPAVioHashString@@PAV1@00AAV?$allocator@VioHashString@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAVioHashString@@PAV1@V?$allocator@VioHashString@@@std@@V1@@std@@YAPAVioHashString@@PAV1@00AAV?$allocator@VioHashString@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAVioHashString@@PAV1@V?$allocator@VioHashString@@@std@@V1@@std@@YAPAVioHashString@@PAV1@00AAV?$allocator@VioHashString@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAVioHashString@@PAV1@V?$allocator@VioHashString@@@std@@V1@@std@@YAPAVioHashString@@PAV1@00AAV?$allocator@VioHashString@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAVioHashString@@PAV1@V?$allocator@VioHashString@@@std@@V1@@std@@YAPAVioHashString@@PAV1@00AAV?$allocator@VioHashString@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAVioHashString@@PAV1@V?$allocator@VioHashString@@@std@@V1@@std@@YAPAVioHashString@@PAV1@00AAV?$allocator@VioHashString@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAVioHashString@@PAV1@V?$allocator@VioHashString@@@std@@V1@@std@@YAPAVioHashString@@PAV1@00AAV?$allocator@VioHashString@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAVioHashString@@PAV1@V?$allocator@VioHashString@@@std@@V1@@std@@YAPAVioHashString@@PAV1@00AAV?$allocator@VioHashString@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAVioHashString@@PAV1@V?$allocator@VioHashString@@@std@@V1@@std@@YAPAVioHashString@@PAV1@00AAV?$allocator@VioHashString@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAVioHashString@@PAV1@V?$allocator@VioHashString@@@std@@V1@@std@@YAPAVioHashString@@PAV1@00AAV?$allocator@VioHashString@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<ioHashString *,ioHashString *,std::allocator<ioHashString>,ioHashString>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	6a 08		 push	 8
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??$_Uninit_move@PAVioHashString@@PAV1@V?$allocator@VioHashString@@@std@@V1@@std@@YAPAVioHashString@@PAV1@00AAV?$allocator@VioHashString@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_catch

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0000c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 428  : 
; 429  : 	_TRY_BEGIN

  0000f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
  00013	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00016	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LL6@Uninit_mov:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  00019	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001c	74 33		 je	 SHORT $LN4@Uninit_mov

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  0001e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00021	56		 push	 esi
  00022	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00025	e8 00 00 00 00	 call	 ?construct@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@$$QAV3@@Z ; std::allocator<ioHashString>::construct
  0002a	83 45 10 10	 add	 DWORD PTR __Dest$[ebp], 16 ; 00000010H
  0002e	83 c6 10	 add	 esi, 16			; 00000010H
  00031	eb e6		 jmp	 SHORT $LL6@Uninit_mov
__catch$??$_Uninit_move@PAVioHashString@@PAV1@V?$allocator@VioHashString@@@std@@V1@@std@@YAPAVioHashString@@PAV1@00AAV?$allocator@VioHashString@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)

  00033	8b 75 ec	 mov	 esi, DWORD PTR __Next$[ebp]
  00036	eb 0b		 jmp	 SHORT $LN33@Uninit_mov
$LL3@Uninit_mov:

; 434  : 		_Dest_val(_Al, _Next);

  00038	8b ce		 mov	 ecx, esi
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00040	83 c6 10	 add	 esi, 16			; 00000010H
$LN33@Uninit_mov:

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)

  00043	3b 75 10	 cmp	 esi, DWORD PTR __Dest$[ebp]
  00046	75 f0		 jne	 SHORT $LL3@Uninit_mov

; 435  : 	_RERAISE;

  00048	6a 00		 push	 0
  0004a	6a 00		 push	 0
  0004c	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN34@Uninit_mov:
$LN4@Uninit_mov:

; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  00051	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 438  : 	}

  00054	e8 00 00 00 00	 call	 __EH_epilog3
  00059	c3		 ret	 0
$LN32@Uninit_mov:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAVioHashString@@PAV1@V?$allocator@VioHashString@@@std@@V1@@std@@YAPAVioHashString@@PAV1@00AAV?$allocator@VioHashString@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAVioHashString@@PAV1@V?$allocator@VioHashString@@@std@@V1@@std@@YAPAVioHashString@@PAV1@00AAV?$allocator@VioHashString@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAVioHashString@@PAV1@V?$allocator@VioHashString@@@std@@V1@@std@@YAPAVioHashString@@PAV1@00AAV?$allocator@VioHashString@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<ioHashString *,ioHashString *,std::allocator<ioHashString>,ioHashString>
PUBLIC	??$_Destroy_range@V?$allocator@VioHashString@@@std@@@std@@YAXPAVioHashString@@0AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<ioHashString> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VioHashString@@@std@@@std@@YAXPAVioHashString@@0AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@VioHashString@@@std@@@std@@YAXPAVioHashString@@0AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<ioHashString> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 96   : 	for (; _First != _Last; ++_First)

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	eb 0b		 jmp	 SHORT $LN17@Destroy_ra
$LL3@Destroy_ra:

; 97   : 		_Dest_val(_Al, _First);

  00009	8b ce		 mov	 ecx, esi
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00011	83 c6 10	 add	 esi, 16			; 00000010H
$LN17@Destroy_ra:

; 96   : 	for (; _First != _Last; ++_First)

  00014	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00017	75 f0		 jne	 SHORT $LL3@Destroy_ra
  00019	5e		 pop	 esi

; 98   : 	}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Destroy_range@V?$allocator@VioHashString@@@std@@@std@@YAXPAVioHashString@@0AAV?$allocator@VioHashString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<ioHashString> >
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	??_C@_0DA@OOMFFONJ@ioRangeBuffSkill?3?3SetBuffList?$CI?$CJ?5@ ; `string'
PUBLIC	_pStage$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?SetBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@@Z ; ioRangeSyncBuffSkill::SetBuffList
EXTRN	?ReduceNeedGaugeBySkill@ioBaseChar@@QAEMPAVioSkill@@M@Z:PROC ; ioBaseChar::ReduceNeedGaugeBySkill
EXTRN	?GetNeedGauge@ioSkill@@QAEMABVioHashString@@@Z:PROC ; ioSkill::GetNeedGauge
EXTRN	?CheckAttackCnt@ioBaseChar@@QAEXPAV1@@Z:PROC	; ioBaseChar::CheckAttackCnt
EXTRN	?CheckComboSkillHit@ioBaseChar@@QAE_NXZ:PROC	; ioBaseChar::CheckComboSkillHit
EXTRN	?CheckTeamBuffAttackCnt@ioBaseChar@@QAEXPAV1@@Z:PROC ; ioBaseChar::CheckTeamBuffAttackCnt
EXTRN	?SetTeamBuffList@ioRangeSkill@@IAE_NPAVioBaseChar@@0@Z:PROC ; ioRangeSkill::SetTeamBuffList
EXTRN	?SetOwnerBuffList@ioRangeSkill@@IAE_NPAVioBaseChar@@@Z:PROC ; ioRangeSkill::SetOwnerBuffList
EXTRN	__imp_??8ioHashString@@QBE_NABV0@@Z:PROC
EXTRN	?IsEnableTeamAttack@ioBaseChar@@QAE_NXZ:PROC	; ioBaseChar::IsEnableTeamAttack
EXTRN	?CheckTargetWoundType@ioBaseChar@@QAE_NW4TargetWoundType@@@Z:PROC ; ioBaseChar::CheckTargetWoundType
EXTRN	?CheckCollisionLine@ioPlayStage@@QAE_NABUD3DXVECTOR3@@0_N@Z:PROC ; ioPlayStage::CheckCollisionLine
EXTRN	?IsSkipState@ioBaseChar@@QBE?B_NXZ:PROC		; ioBaseChar::IsSkipState
EXTRN	?IsCollisionCheckByMode@ioPlayStage@@QAE_NXZ:PROC ; ioPlayStage::IsCollisionCheckByMode
EXTRN	?HasCollisionAvailableBuff@ioBaseChar@@QBE_NXZ:PROC ; ioBaseChar::HasCollisionAvailableBuff
EXTRN	?CheckTargetNoCollision@Help@@YA_NW4CharState@@@Z:PROC ; Help::CheckTargetNoCollision
EXTRN	?IsCollisioned@ioRangeSkill@@IAE_NPAVioBaseChar@@@Z:PROC ; ioRangeSkill::IsCollisioned
EXTRN	?GetTargetCharListBySphere@ioBaseChar@@QAEXABUD3DXVECTOR3@@MMAAV?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@Z:PROC ; ioBaseChar::GetTargetCharListBySphere
EXTRN	?GetTargetCharListByCylinder@ioBaseChar@@QAEXABUD3DXVECTOR3@@MMMMAAV?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@Z:PROC ; ioBaseChar::GetTargetCharListByCylinder
EXTRN	?GetTargetCharListByBox@ioBaseChar@@QAEXABUD3DXVECTOR3@@MMMMAAV?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@Z:PROC ; ioBaseChar::GetTargetCharListByBox
EXTRN	??1SP2Packet@@UAE@XZ:PROC			; SP2Packet::~SP2Packet
EXTRN	?SendToAllPlayingUser@P2PNetwork@@YAXAAVSP2Packet@@PAVioBaseChar@@@Z:PROC ; P2PNetwork::SendToAllPlayingUser
EXTRN	??6SP2Packet@@QAEAAV0@H@Z:PROC			; SP2Packet::operator<<
EXTRN	??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z:PROC	; SP2Packet::operator<<
EXTRN	??0SP2Packet@@QAE@K@Z:PROC			; SP2Packet::SP2Packet
EXTRN	___security_cookie:DWORD
EXTRN	__chkstk:PROC
;	COMDAT __real@0000000000000000
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_C@_0DA@OOMFFONJ@ioRangeBuffSkill?3?3SetBuffList?$CI?$CJ?5@
CONST	SEGMENT
??_C@_0DA@OOMFFONJ@ioRangeBuffSkill?3?3SetBuffList?$CI?$CJ?5@ DB 'ioRange'
	DB	'BuffSkill::SetBuffList() - Owner is NULL', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SetBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@@Z$1
__ehfuncinfo$?SetBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SetBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iorangesyncbuffskill.cpp
xdata$x	ENDS
;	COMDAT ?SetBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@@Z
_TEXT	SEGMENT
_value$534142 = -32900					; size = 4
_value$534117 = -32896					; size = 4
_value$534130 = -32892					; size = 4
_pStage$GSCopy$ = -32888				; size = 4
tv1386 = -32884						; size = 4
_value$534084 = -32884					; size = 4
_bEnableTeamAttack$530944 = -32877			; size = 1
$T534073 = -32876					; size = 1
tv1231 = -32876						; size = 4
_value$533898 = -32876					; size = 4
$T533884 = -32876					; size = 4
tv1338 = -32872						; size = 4
tv1334 = -32872						; size = 4
tv1330 = -32872						; size = 4
tv1323 = -32872						; size = 4
tv1319 = -32872						; size = 4
tv1315 = -32872						; size = 4
_vTargetList$ = -32868					; size = 16
tv1463 = -32852						; size = 4
tv1459 = -32852						; size = 4
tv1421 = -32852						; size = 4
tv1417 = -32852						; size = 4
tv1394 = -32852						; size = 4
tv1390 = -32852						; size = 4
_value$534155 = -32852					; size = 4
$T533960 = -32852					; size = 4
tv1455 = -32848						; size = 4
tv1413 = -32848						; size = 4
tv1235 = -32848						; size = 4
$T533869 = -32848					; size = 4
_iter$ = -32848						; size = 4
_kPacket$530755 = -32844				; size = 32792
_vEndPos$530940 = -52					; size = 12
_vStartPos$530938 = -40					; size = 12
_vPos$ = -28						; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pOwner$ = 8						; size = 4
_pStage$ = 12						; size = 4
?SetBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@@Z PROC ; ioRangeSyncBuffSkill::SetBuffList, COMDAT
; _this$ = ecx

; 35   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SetBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 78 80 00 00	 mov	 eax, 32888		; 00008078H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00032	8b 7d 08	 mov	 edi, DWORD PTR _pOwner$[ebp]
  00035	8b 45 0c	 mov	 eax, DWORD PTR _pStage$[ebp]

; 36   : 	if( !pOwner )

  00038	33 db		 xor	 ebx, ebx
  0003a	8b f1		 mov	 esi, ecx

; 115  : 		{
; 116  : 			//pOwner->CheckRealComboHit( pChar->GetCharName() );
; 117  : 			pOwner->CheckComboSkillHit();

  0003c	89 85 88 7f ff
	ff		 mov	 DWORD PTR _pStage$GSCopy$[ebp], eax
  00042	3b fb		 cmp	 edi, ebx
  00044	75 1a		 jne	 SHORT $LN28@SetBuffLis

; 37   : 	{
; 38   : 		LOG.PrintTimeAndLog( 0, "ioRangeBuffSkill::SetBuffList() - Owner is NULL" );

  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@OOMFFONJ@ioRangeBuffSkill?3?3SetBuffList?$CI?$CJ?5@
  0004b	53		 push	 ebx
  0004c	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintTimeAndLog@CLog@@QAAXHPADZZ
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH

; 39   : 		return;

  0005b	e9 4f 07 00 00	 jmp	 $LN171@SetBuffLis
$LN28@SetBuffLis:

; 40   : 	}
; 41   : 
; 42   : 	if( !pOwner->IsNeedProcess() )

  00060	8b 07		 mov	 eax, DWORD PTR [edi]
  00062	8b cf		 mov	 ecx, edi
  00064	ff 90 00 01 00
	00		 call	 DWORD PTR [eax+256]
  0006a	84 c0		 test	 al, al
  0006c	0f 84 3d 07 00
	00		 je	 $LN171@SetBuffLis

; 43   : 		return;
; 44   : 
; 45   : 	if( pOwner->IsNeedSendNetwork() )

  00072	8b 07		 mov	 eax, DWORD PTR [edi]
  00074	8b cf		 mov	 ecx, edi
  00076	ff 90 04 01 00
	00		 call	 DWORD PTR [eax+260]
  0007c	84 c0		 test	 al, al
  0007e	74 5f		 je	 SHORT $LN26@SetBuffLis

; 46   : 	{
; 47   : 		SP2Packet kPacket( CUPK_SKILL_EXTRA_INFO );

  00080	68 39 41 00 00	 push	 16697			; 00004139H
  00085	8d 8d b4 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$530755[ebp]
  0008b	e8 00 00 00 00	 call	 ??0SP2Packet@@QAE@K@Z	; SP2Packet::SP2Packet

; 48   : 		kPacket << pOwner->GetCharName();

  00090	8d 87 d4 02 00
	00		 lea	 eax, DWORD PTR [edi+724]
  00096	50		 push	 eax
  00097	8d 8d b4 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$530755[ebp]
  0009d	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  000a0	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z ; SP2Packet::operator<<

; 49   : 		kPacket << GetName();

  000a5	8d 46 24	 lea	 eax, DWORD PTR [esi+36]
  000a8	50		 push	 eax
  000a9	8d 8d b4 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$530755[ebp]
  000af	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z ; SP2Packet::operator<<

; 50   : 		kPacket << ESI_SET_BUFF;

  000b4	6a 01		 push	 1
  000b6	8d 8d b4 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$530755[ebp]
  000bc	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@H@Z ; SP2Packet::operator<<

; 51   : 		P2PNetwork::SendToAllPlayingUser( kPacket );

  000c1	8d 85 b4 7f ff
	ff		 lea	 eax, DWORD PTR _kPacket$530755[ebp]
  000c7	53		 push	 ebx
  000c8	50		 push	 eax
  000c9	e8 00 00 00 00	 call	 ?SendToAllPlayingUser@P2PNetwork@@YAXAAVSP2Packet@@PAVioBaseChar@@@Z ; P2PNetwork::SendToAllPlayingUser

; 52   : 	}

  000ce	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000d2	59		 pop	 ecx
  000d3	59		 pop	 ecx
  000d4	8d 8d b4 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$530755[ebp]
  000da	e8 00 00 00 00	 call	 ??1SP2Packet@@UAE@XZ	; SP2Packet::~SP2Packet
$LN26@SetBuffLis:

; 53   : 
; 54   : 	BaseCharList vTargetList;

  000df	89 9d 9c 7f ff
	ff		 mov	 DWORD PTR _vTargetList$[ebp], ebx
  000e5	89 9d a0 7f ff
	ff		 mov	 DWORD PTR _vTargetList$[ebp+4], ebx
  000eb	89 9d a4 7f ff
	ff		 mov	 DWORD PTR _vTargetList$[ebp+8], ebx
  000f1	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 55   : 	D3DXVECTOR3 vPos = pOwner->GetMidPositionByRate( FLOAT08 );

  000f8	b8 08 00 00 00	 mov	 eax, 8
  000fd	8b c8		 mov	 ecx, eax
  000ff	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  00104	89 8d ac 7f ff
	ff		 mov	 DWORD PTR tv1463[ebp], ecx
  0010a	db 85 ac 7f ff
	ff		 fild	 DWORD PTR tv1463[ebp]
  00110	85 c9		 test	 ecx, ecx
  00112	79 06		 jns	 SHORT $LN180@SetBuffLis
  00114	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN180@SetBuffLis:
  0011a	89 85 ac 7f ff
	ff		 mov	 DWORD PTR tv1459[ebp], eax
  00120	db 85 ac 7f ff
	ff		 fild	 DWORD PTR tv1459[ebp]
  00126	85 c0		 test	 eax, eax
  00128	79 06		 jns	 SHORT $LN181@SetBuffLis
  0012a	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN181@SetBuffLis:
  00130	de f9		 fdivp	 ST(1), ST(0)
  00132	51		 push	 ecx
  00133	8d 45 e4	 lea	 eax, DWORD PTR _vPos$[ebp]
  00136	8b cf		 mov	 ecx, edi
  00138	d9 9d b0 7f ff
	ff		 fstp	 DWORD PTR tv1455[ebp]
  0013e	d9 85 b0 7f ff
	ff		 fld	 DWORD PTR tv1455[ebp]
  00144	d9 1c 24	 fstp	 DWORD PTR [esp]
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 ?GetMidPositionByRate@ioGameEntity@@QBE?AUD3DXVECTOR3@@M@Z ; ioGameEntity::GetMidPositionByRate

; 56   : 	vPos += m_vEffectDir * m_fOffSet;

  0014d	f3 0f 10 86 78
	0f 00 00	 movss	 xmm0, DWORD PTR [esi+3960]
  00155	f3 0f 10 8e 98
	0f 00 00	 movss	 xmm1, DWORD PTR [esi+3992]
  0015d	0f 5a c9	 cvtps2pd xmm1, xmm1
  00160	0f 5a d0	 cvtps2pd xmm2, xmm0
  00163	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  00167	f3 0f 10 96 9c
	0f 00 00	 movss	 xmm2, DWORD PTR [esi+3996]
  0016f	0f 5a d8	 cvtps2pd xmm3, xmm0

; 57   : 
; 58   : 	//    
; 59   : 	switch( m_TargetColType )

  00172	8b 86 54 0f 00
	00		 mov	 eax, DWORD PTR [esi+3924]
  00178	48		 dec	 eax
  00179	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  0017d	0f 5a d2	 cvtps2pd xmm2, xmm2
  00180	f2 0f 59 d3	 mulsd	 xmm2, xmm3
  00184	f3 0f 10 9e a0
	0f 00 00	 movss	 xmm3, DWORD PTR [esi+4000]
  0018c	0f 5a c0	 cvtps2pd xmm0, xmm0
  0018f	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  00193	0f 5a db	 cvtps2pd xmm3, xmm3
  00196	f2 0f 59 d8	 mulsd	 xmm3, xmm0
  0019a	0f 57 c0	 xorps	 xmm0, xmm0
  0019d	66 0f 5a c3	 cvtpd2ps xmm0, xmm3
  001a1	f3 0f 10 5d e4	 movss	 xmm3, DWORD PTR _vPos$[ebp]
  001a6	0f 5a db	 cvtps2pd xmm3, xmm3
  001a9	f2 0f 58 d9	 addsd	 xmm3, xmm1
  001ad	0f 57 c9	 xorps	 xmm1, xmm1
  001b0	66 0f 5a cb	 cvtpd2ps xmm1, xmm3
  001b4	f3 0f 11 4d e4	 movss	 DWORD PTR _vPos$[ebp], xmm1
  001b9	f3 0f 10 4d e8	 movss	 xmm1, DWORD PTR _vPos$[ebp+4]
  001be	0f 5a c9	 cvtps2pd xmm1, xmm1
  001c1	66 0f 5a d2	 cvtpd2ps xmm2, xmm2
  001c5	f3 0f 5a d2	 cvtss2sd xmm2, xmm2
  001c9	f2 0f 58 ca	 addsd	 xmm1, xmm2
  001cd	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  001d1	f3 0f 11 4d e8	 movss	 DWORD PTR _vPos$[ebp+4], xmm1
  001d6	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR _vPos$[ebp+8]
  001db	0f 5a c0	 cvtps2pd xmm0, xmm0
  001de	0f 5a c9	 cvtps2pd xmm1, xmm1
  001e1	f2 0f 58 c8	 addsd	 xmm1, xmm0
  001e5	0f 57 c0	 xorps	 xmm0, xmm0
  001e8	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  001ec	f3 0f 11 45 ec	 movss	 DWORD PTR _vPos$[ebp+8], xmm0
  001f1	0f 84 94 02 00
	00		 je	 $LN23@SetBuffLis
  001f7	48		 dec	 eax
  001f8	0f 84 3f 02 00
	00		 je	 $LN22@SetBuffLis
  001fe	48		 dec	 eax
  001ff	0f 85 b5 02 00
	00		 jne	 $LN24@SetBuffLis

; 67   : 	case TCT_BOX:
; 68   : 		//  center vPos       .
; 69   : 		// /2.0f  * FLOAT05 
; 70   : 		vPos += m_vEffectDir * m_fSkillRange * FLOAT05; 

  00205	b8 05 00 00 00	 mov	 eax, 5
  0020a	8b c8		 mov	 ecx, eax
  0020c	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  00211	f3 0f 10 86 70
	0f 00 00	 movss	 xmm0, DWORD PTR [esi+3952]
  00219	f3 0f 10 96 98
	0f 00 00	 movss	 xmm2, DWORD PTR [esi+3992]
  00221	0f 5a c8	 cvtps2pd xmm1, xmm0
  00224	0f 5a d2	 cvtps2pd xmm2, xmm2
  00227	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  0022b	f3 0f 10 96 9c
	0f 00 00	 movss	 xmm2, DWORD PTR [esi+3996]
  00233	0f 5a d8	 cvtps2pd xmm3, xmm0
  00236	0f 5a d2	 cvtps2pd xmm2, xmm2
  00239	f2 0f 59 d3	 mulsd	 xmm2, xmm3
  0023d	f3 0f 10 9e a0
	0f 00 00	 movss	 xmm3, DWORD PTR [esi+4000]
  00245	0f 5a c0	 cvtps2pd xmm0, xmm0
  00248	0f 5a db	 cvtps2pd xmm3, xmm3
  0024b	f2 0f 59 d8	 mulsd	 xmm3, xmm0
  0024f	0f 57 c0	 xorps	 xmm0, xmm0
  00252	89 8d ac 7f ff
	ff		 mov	 DWORD PTR tv1421[ebp], ecx
  00258	db 85 ac 7f ff
	ff		 fild	 DWORD PTR tv1421[ebp]
  0025e	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  00262	66 0f 5a d2	 cvtpd2ps xmm2, xmm2
  00266	66 0f 5a c3	 cvtpd2ps xmm0, xmm3
  0026a	85 c9		 test	 ecx, ecx
  0026c	79 06		 jns	 SHORT $LN182@SetBuffLis
  0026e	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN182@SetBuffLis:
  00274	89 85 ac 7f ff
	ff		 mov	 DWORD PTR tv1417[ebp], eax
  0027a	db 85 ac 7f ff
	ff		 fild	 DWORD PTR tv1417[ebp]
  00280	85 c0		 test	 eax, eax
  00282	79 06		 jns	 SHORT $LN183@SetBuffLis
  00284	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN183@SetBuffLis:
  0028a	de f9		 fdivp	 ST(1), ST(0)
  0028c	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  00290	f3 0f 5a d2	 cvtss2sd xmm2, xmm2
  00294	0f 5a c0	 cvtps2pd xmm0, xmm0
  00297	d9 9d b0 7f ff
	ff		 fstp	 DWORD PTR tv1413[ebp]
  0029d	d9 85 b0 7f ff
	ff		 fld	 DWORD PTR tv1413[ebp]
  002a3	d9 9d b0 7f ff
	ff		 fstp	 DWORD PTR $T533869[ebp]
  002a9	f3 0f 10 9d b0
	7f ff ff	 movss	 xmm3, DWORD PTR $T533869[ebp]
  002b1	0f 5a db	 cvtps2pd xmm3, xmm3
  002b4	f2 0f 59 cb	 mulsd	 xmm1, xmm3
  002b8	f3 0f 10 9d b0
	7f ff ff	 movss	 xmm3, DWORD PTR $T533869[ebp]
  002c0	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  002c4	0f 5a db	 cvtps2pd xmm3, xmm3
  002c7	f2 0f 59 d3	 mulsd	 xmm2, xmm3
  002cb	f3 0f 10 9d b0
	7f ff ff	 movss	 xmm3, DWORD PTR $T533869[ebp]
  002d3	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  002d7	0f 5a db	 cvtps2pd xmm3, xmm3
  002da	f2 0f 59 c3	 mulsd	 xmm0, xmm3
  002de	f3 0f 10 5d e4	 movss	 xmm3, DWORD PTR _vPos$[ebp]
  002e3	0f 5a db	 cvtps2pd xmm3, xmm3
  002e6	f2 0f 58 cb	 addsd	 xmm1, xmm3
  002ea	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  002ee	f3 0f 11 4d e4	 movss	 DWORD PTR _vPos$[ebp], xmm1
  002f3	f3 0f 10 4d e8	 movss	 xmm1, DWORD PTR _vPos$[ebp+4]
  002f8	0f 5a c9	 cvtps2pd xmm1, xmm1
  002fb	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  002ff	66 0f 5a d2	 cvtpd2ps xmm2, xmm2
  00303	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00307	f3 0f 5a d2	 cvtss2sd xmm2, xmm2
  0030b	f2 0f 58 ca	 addsd	 xmm1, xmm2
  0030f	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  00313	f3 0f 11 4d e8	 movss	 DWORD PTR _vPos$[ebp+4], xmm1
  00318	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR _vPos$[ebp+8]
  0031d	0f 5a c9	 cvtps2pd xmm1, xmm1
  00320	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00324	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  00328	f3 0f 11 45 ec	 movss	 DWORD PTR _vPos$[ebp+8], xmm0

; 71   : 		// /2.0f  * FLOAT05 
; 72   : 		D3DXVECTOR3 vOffset( 0.0f, ( ( m_fUpHeight + m_fUnderHeight ) * FLOAT05 ) - m_fUpHeight, 0.0f );

  0032d	b8 05 00 00 00	 mov	 eax, 5
  00332	8b c8		 mov	 ecx, eax
  00334	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  00339	f3 0f 10 8e 80
	0f 00 00	 movss	 xmm1, DWORD PTR [esi+3968]
  00341	f3 0f 10 96 7c
	0f 00 00	 movss	 xmm2, DWORD PTR [esi+3964]
  00349	89 8d ac 7f ff
	ff		 mov	 DWORD PTR tv1394[ebp], ecx
  0034f	db 85 ac 7f ff
	ff		 fild	 DWORD PTR tv1394[ebp]
  00355	f3 0f 11 8d 94
	7f ff ff	 movss	 DWORD PTR tv1231[ebp], xmm1
  0035d	f3 0f 11 95 b0
	7f ff ff	 movss	 DWORD PTR tv1235[ebp], xmm2
  00365	85 c9		 test	 ecx, ecx
  00367	79 06		 jns	 SHORT $LN184@SetBuffLis
  00369	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN184@SetBuffLis:
  0036f	89 85 ac 7f ff
	ff		 mov	 DWORD PTR tv1390[ebp], eax
  00375	db 85 ac 7f ff
	ff		 fild	 DWORD PTR tv1390[ebp]
  0037b	85 c0		 test	 eax, eax
  0037d	79 06		 jns	 SHORT $LN185@SetBuffLis
  0037f	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN185@SetBuffLis:
  00385	de f9		 fdivp	 ST(1), ST(0)

; 73   : 		vPos -= vOffset;

  00387	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _vPos$[ebp]
  0038c	0f 5a d8	 cvtps2pd xmm3, xmm0
  0038f	f2 0f 5c 1d 00
	00 00 00	 subsd	 xmm3, QWORD PTR __real@0000000000000000
  00397	66 0f 5a db	 cvtpd2ps xmm3, xmm3
  0039b	f3 0f 11 5d e4	 movss	 DWORD PTR _vPos$[ebp], xmm3
  003a0	f3 0f 10 5d e8	 movss	 xmm3, DWORD PTR _vPos$[ebp+4]
  003a5	0f 5a db	 cvtps2pd xmm3, xmm3

; 74   : 		pOwner->GetTargetCharListByBox( vPos, m_fSkillRange, m_fWidth, m_fUpHeight, m_fUnderHeight, vTargetList );

  003a8	8d 85 9c 7f ff
	ff		 lea	 eax, DWORD PTR _vTargetList$[ebp]
  003ae	50		 push	 eax
  003af	83 ec 10	 sub	 esp, 16			; 00000010H
  003b2	f3 0f 11 4c 24
	0c		 movss	 DWORD PTR [esp+12], xmm1
  003b8	f3 0f 11 54 24
	08		 movss	 DWORD PTR [esp+8], xmm2
  003be	8d 45 e4	 lea	 eax, DWORD PTR _vPos$[ebp]
  003c1	8b cf		 mov	 ecx, edi
  003c3	d9 9d 8c 7f ff
	ff		 fstp	 DWORD PTR tv1386[ebp]
  003c9	d9 85 8c 7f ff
	ff		 fld	 DWORD PTR tv1386[ebp]
  003cf	d9 85 b0 7f ff
	ff		 fld	 DWORD PTR tv1235[ebp]
  003d5	d8 85 94 7f ff
	ff		 fadd	 DWORD PTR tv1231[ebp]
  003db	de c9		 fmulp	 ST(1), ST(0)
  003dd	d8 a5 b0 7f ff
	ff		 fsub	 DWORD PTR tv1235[ebp]
  003e3	d9 9d 94 7f ff
	ff		 fstp	 DWORD PTR $T533884[ebp]
  003e9	f3 0f 10 a5 94
	7f ff ff	 movss	 xmm4, DWORD PTR $T533884[ebp]
  003f1	0f 5a e4	 cvtps2pd xmm4, xmm4
  003f4	f2 0f 5c dc	 subsd	 xmm3, xmm4
  003f8	66 0f 5a db	 cvtpd2ps xmm3, xmm3
  003fc	f3 0f 11 5d e8	 movss	 DWORD PTR _vPos$[ebp+4], xmm3
  00401	f3 0f 10 5d ec	 movss	 xmm3, DWORD PTR _vPos$[ebp+8]
  00406	0f 5a db	 cvtps2pd xmm3, xmm3
  00409	f2 0f 5c 1d 00
	00 00 00	 subsd	 xmm3, QWORD PTR __real@0000000000000000
  00411	66 0f 5a c3	 cvtpd2ps xmm0, xmm3
  00415	f3 0f 11 45 ec	 movss	 DWORD PTR _vPos$[ebp+8], xmm0
  0041a	f3 0f 10 86 84
	0f 00 00	 movss	 xmm0, DWORD PTR [esi+3972]
  00422	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00428	f3 0f 10 86 70
	0f 00 00	 movss	 xmm0, DWORD PTR [esi+3952]
  00430	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00435	50		 push	 eax
  00436	e8 00 00 00 00	 call	 ?GetTargetCharListByBox@ioBaseChar@@QAEXABUD3DXVECTOR3@@MMMMAAV?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@Z ; ioBaseChar::GetTargetCharListByBox

; 75   : 		break;

  0043b	eb 7d		 jmp	 SHORT $LN24@SetBuffLis
$LN22@SetBuffLis:

; 63   : 		break;
; 64   : 	case TCT_CYLINDER:
; 65   : 		pOwner->GetTargetCharListByCylinder( vPos, m_fSkillRange, m_fSkillAngle, m_fUpHeight, m_fUnderHeight, vTargetList );

  0043d	f3 0f 10 86 80
	0f 00 00	 movss	 xmm0, DWORD PTR [esi+3968]
  00445	8d 85 9c 7f ff
	ff		 lea	 eax, DWORD PTR _vTargetList$[ebp]
  0044b	50		 push	 eax
  0044c	83 ec 10	 sub	 esp, 16			; 00000010H
  0044f	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  00455	f3 0f 10 86 7c
	0f 00 00	 movss	 xmm0, DWORD PTR [esi+3964]
  0045d	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00463	f3 0f 10 86 74
	0f 00 00	 movss	 xmm0, DWORD PTR [esi+3956]
  0046b	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00471	f3 0f 10 86 70
	0f 00 00	 movss	 xmm0, DWORD PTR [esi+3952]
  00479	8d 45 e4	 lea	 eax, DWORD PTR _vPos$[ebp]
  0047c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00481	50		 push	 eax
  00482	8b cf		 mov	 ecx, edi
  00484	e8 00 00 00 00	 call	 ?GetTargetCharListByCylinder@ioBaseChar@@QAEXABUD3DXVECTOR3@@MMMMAAV?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@Z ; ioBaseChar::GetTargetCharListByCylinder

; 66   : 		break;

  00489	eb 2f		 jmp	 SHORT $LN24@SetBuffLis
$LN23@SetBuffLis:

; 60   : 	{
; 61   : 	case TCT_SPHERE:
; 62   : 		pOwner->GetTargetCharListBySphere( vPos, m_fSkillRange, m_fSkillAngle, vTargetList );

  0048b	f3 0f 10 86 74
	0f 00 00	 movss	 xmm0, DWORD PTR [esi+3956]
  00493	8d 85 9c 7f ff
	ff		 lea	 eax, DWORD PTR _vTargetList$[ebp]
  00499	50		 push	 eax
  0049a	51		 push	 ecx
  0049b	51		 push	 ecx
  0049c	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  004a2	f3 0f 10 86 70
	0f 00 00	 movss	 xmm0, DWORD PTR [esi+3952]
  004aa	8d 45 e4	 lea	 eax, DWORD PTR _vPos$[ebp]
  004ad	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004b2	50		 push	 eax
  004b3	8b cf		 mov	 ecx, edi
  004b5	e8 00 00 00 00	 call	 ?GetTargetCharListBySphere@ioBaseChar@@QAEXABUD3DXVECTOR3@@MMAAV?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@Z ; ioBaseChar::GetTargetCharListBySphere
$LN24@SetBuffLis:

; 76   : 	}
; 77   : 
; 78   : 	if( pOwner->GetExperienceMode() == EMS_EXPERIENCE )

  004ba	8d 85 94 7f ff
	ff		 lea	 eax, DWORD PTR _value$533898[ebp]
  004c0	8d 8f 94 1d 00
	00		 lea	 ecx, DWORD PTR [edi+7572]
  004c6	50		 push	 eax
  004c7	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z ; CEncrypt<unsigned long>::DecryptValueToPool
  004cc	83 bd 94 7f ff
	ff 02		 cmp	 DWORD PTR _value$533898[ebp], 2
  004d3	75 1e		 jne	 SHORT $LN81@SetBuffLis

; 79   : 		vTargetList.clear();

  004d5	ff b5 a0 7f ff
	ff		 push	 DWORD PTR _vTargetList$[ebp+4]
  004db	8d 85 ac 7f ff
	ff		 lea	 eax, DWORD PTR $T533960[ebp]
  004e1	ff b5 9c 7f ff
	ff		 push	 DWORD PTR _vTargetList$[ebp]
  004e7	8d 8d 9c 7f ff
	ff		 lea	 ecx, DWORD PTR _vTargetList$[ebp]
  004ed	50		 push	 eax
  004ee	e8 00 00 00 00	 call	 ?erase@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@0@Z ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::erase
$LN81@SetBuffLis:

; 80   : 
; 81   : 	BaseCharList::iterator iter;
; 82   : 	for( iter = vTargetList.begin(); iter != vTargetList.end(); ++iter )

  004f3	8b 85 9c 7f ff
	ff		 mov	 eax, DWORD PTR _vTargetList$[ebp]
  004f9	e9 6d 02 00 00	 jmp	 $LN190@SetBuffLis
$LL113@SetBuffLis:

; 83   : 	{
; 84   : 		ioBaseChar *pChar = (*iter);

  004fe	8b 18		 mov	 ebx, DWORD PTR [eax]

; 85   : 
; 86   : 		if( !pChar || IsCollisioned(pChar) )	continue;

  00500	85 db		 test	 ebx, ebx
  00502	0f 84 5a 02 00
	00		 je	 $LN18@SetBuffLis
  00508	53		 push	 ebx
  00509	8b ce		 mov	 ecx, esi
  0050b	e8 00 00 00 00	 call	 ?IsCollisioned@ioRangeSkill@@IAE_NPAVioBaseChar@@@Z ; ioRangeSkill::IsCollisioned
  00510	84 c0		 test	 al, al
  00512	0f 85 4a 02 00
	00		 jne	 $LN18@SetBuffLis

; 87   : 		if( !pChar->IsNeedProcess() )			continue;

  00518	8b 03		 mov	 eax, DWORD PTR [ebx]
  0051a	8b cb		 mov	 ecx, ebx
  0051c	ff 90 00 01 00
	00		 call	 DWORD PTR [eax+256]
  00522	84 c0		 test	 al, al
  00524	0f 84 38 02 00
	00		 je	 $LN18@SetBuffLis

; 88   : 		if( pChar->GetState() == CS_SKIP_STUN )	continue;

  0052a	8a 83 10 03 00
	00		 mov	 al, BYTE PTR [ebx+784]
  00530	3c 48		 cmp	 al, 72			; 00000048H
  00532	0f 84 2a 02 00
	00		 je	 $LN18@SetBuffLis

; 89   : 		if( Help::CheckTargetNoCollision( pChar->GetState() ) ) continue;

  00538	88 85 94 7f ff
	ff		 mov	 BYTE PTR $T534073[ebp], al
  0053e	ff b5 94 7f ff
	ff		 push	 DWORD PTR $T534073[ebp]
  00544	e8 00 00 00 00	 call	 ?CheckTargetNoCollision@Help@@YA_NW4CharState@@@Z ; Help::CheckTargetNoCollision
  00549	59		 pop	 ecx
  0054a	84 c0		 test	 al, al
  0054c	0f 85 10 02 00
	00		 jne	 $LN18@SetBuffLis

; 90   : 		if( !pChar->HasCollisionAvailableBuff() ) continue;

  00552	8b cb		 mov	 ecx, ebx
  00554	e8 00 00 00 00	 call	 ?HasCollisionAvailableBuff@ioBaseChar@@QBE_NXZ ; ioBaseChar::HasCollisionAvailableBuff
  00559	84 c0		 test	 al, al
  0055b	0f 84 01 02 00
	00		 je	 $LN18@SetBuffLis

; 91   : 		if( !pStage->IsCollisionCheckByMode() )	continue;

  00561	8b 8d 88 7f ff
	ff		 mov	 ecx, DWORD PTR _pStage$GSCopy$[ebp]
  00567	e8 00 00 00 00	 call	 ?IsCollisionCheckByMode@ioPlayStage@@QAE_NXZ ; ioPlayStage::IsCollisionCheckByMode
  0056c	84 c0		 test	 al, al
  0056e	0f 84 ee 01 00
	00		 je	 $LN18@SetBuffLis

; 92   : 		if( pChar->GetExperienceMode() == EMS_EXPERIENCE ) continue;

  00574	8d 85 8c 7f ff
	ff		 lea	 eax, DWORD PTR _value$534084[ebp]
  0057a	8d 8b 94 1d 00
	00		 lea	 ecx, DWORD PTR [ebx+7572]
  00580	50		 push	 eax
  00581	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z ; CEncrypt<unsigned long>::DecryptValueToPool
  00586	83 bd 8c 7f ff
	ff 02		 cmp	 DWORD PTR _value$534084[ebp], 2
  0058d	0f 84 cf 01 00
	00		 je	 $LN18@SetBuffLis

; 93   : 		if( pChar->IsSkipState() ) continue;

  00593	8b cb		 mov	 ecx, ebx
  00595	e8 00 00 00 00	 call	 ?IsSkipState@ioBaseChar@@QBE?B_NXZ ; ioBaseChar::IsSkipState
  0059a	84 c0		 test	 al, al
  0059c	0f 85 c0 01 00
	00		 jne	 $LN18@SetBuffLis

; 94   : 
; 95   : 		D3DXVECTOR3 vStartPos = pOwner->GetMidPositionByRate();

  005a2	b8 05 00 00 00	 mov	 eax, 5
  005a7	8b c8		 mov	 ecx, eax
  005a9	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  005ae	89 8d 98 7f ff
	ff		 mov	 DWORD PTR tv1338[ebp], ecx
  005b4	db 85 98 7f ff
	ff		 fild	 DWORD PTR tv1338[ebp]
  005ba	85 c9		 test	 ecx, ecx
  005bc	79 06		 jns	 SHORT $LN186@SetBuffLis
  005be	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN186@SetBuffLis:
  005c4	89 85 98 7f ff
	ff		 mov	 DWORD PTR tv1334[ebp], eax
  005ca	db 85 98 7f ff
	ff		 fild	 DWORD PTR tv1334[ebp]
  005d0	85 c0		 test	 eax, eax
  005d2	79 06		 jns	 SHORT $LN187@SetBuffLis
  005d4	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN187@SetBuffLis:
  005da	de f9		 fdivp	 ST(1), ST(0)
  005dc	51		 push	 ecx
  005dd	8d 45 d8	 lea	 eax, DWORD PTR _vStartPos$530938[ebp]
  005e0	8b cf		 mov	 ecx, edi
  005e2	d9 9d 98 7f ff
	ff		 fstp	 DWORD PTR tv1330[ebp]
  005e8	d9 85 98 7f ff
	ff		 fld	 DWORD PTR tv1330[ebp]
  005ee	d9 1c 24	 fstp	 DWORD PTR [esp]
  005f1	50		 push	 eax
  005f2	e8 00 00 00 00	 call	 ?GetMidPositionByRate@ioGameEntity@@QBE?AUD3DXVECTOR3@@M@Z ; ioGameEntity::GetMidPositionByRate

; 96   : 		D3DXVECTOR3 vEndPos = pChar->GetMidPositionByRate();

  005f7	b8 05 00 00 00	 mov	 eax, 5
  005fc	8b c8		 mov	 ecx, eax
  005fe	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  00603	89 8d 98 7f ff
	ff		 mov	 DWORD PTR tv1323[ebp], ecx
  00609	db 85 98 7f ff
	ff		 fild	 DWORD PTR tv1323[ebp]
  0060f	85 c9		 test	 ecx, ecx
  00611	79 06		 jns	 SHORT $LN188@SetBuffLis
  00613	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN188@SetBuffLis:
  00619	89 85 98 7f ff
	ff		 mov	 DWORD PTR tv1319[ebp], eax
  0061f	db 85 98 7f ff
	ff		 fild	 DWORD PTR tv1319[ebp]
  00625	85 c0		 test	 eax, eax
  00627	79 06		 jns	 SHORT $LN189@SetBuffLis
  00629	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN189@SetBuffLis:
  0062f	de f9		 fdivp	 ST(1), ST(0)
  00631	51		 push	 ecx
  00632	8d 45 cc	 lea	 eax, DWORD PTR _vEndPos$530940[ebp]
  00635	8b cb		 mov	 ecx, ebx
  00637	d9 9d 98 7f ff
	ff		 fstp	 DWORD PTR tv1315[ebp]
  0063d	d9 85 98 7f ff
	ff		 fld	 DWORD PTR tv1315[ebp]
  00643	d9 1c 24	 fstp	 DWORD PTR [esp]
  00646	50		 push	 eax
  00647	e8 00 00 00 00	 call	 ?GetMidPositionByRate@ioGameEntity@@QBE?AUD3DXVECTOR3@@M@Z ; ioGameEntity::GetMidPositionByRate

; 97   : 		if( m_bCheckCollisionLine && !pStage->CheckCollisionLine( vStartPos, vEndPos ) )

  0064c	80 be 6e 0f 00
	00 00		 cmp	 BYTE PTR [esi+3950], 0
  00653	74 1d		 je	 SHORT $LN7@SetBuffLis
  00655	8b 8d 88 7f ff
	ff		 mov	 ecx, DWORD PTR _pStage$GSCopy$[ebp]
  0065b	6a 01		 push	 1
  0065d	8d 45 cc	 lea	 eax, DWORD PTR _vEndPos$530940[ebp]
  00660	50		 push	 eax
  00661	8d 45 d8	 lea	 eax, DWORD PTR _vStartPos$530938[ebp]
  00664	50		 push	 eax
  00665	e8 00 00 00 00	 call	 ?CheckCollisionLine@ioPlayStage@@QAE_NABUD3DXVECTOR3@@0_N@Z ; ioPlayStage::CheckCollisionLine
  0066a	84 c0		 test	 al, al
  0066c	0f 84 f0 00 00
	00		 je	 $LN18@SetBuffLis
$LN7@SetBuffLis:

; 98   : 			continue;
; 99   : 
; 100  : 		if( !pChar->CheckTargetWoundType(m_TargetWoundType) )

  00672	ff b6 58 0f 00
	00		 push	 DWORD PTR [esi+3928]
  00678	8b cb		 mov	 ecx, ebx
  0067a	e8 00 00 00 00	 call	 ?CheckTargetWoundType@ioBaseChar@@QAE_NW4TargetWoundType@@@Z ; ioBaseChar::CheckTargetWoundType
  0067f	84 c0		 test	 al, al
  00681	0f 84 db 00 00
	00		 je	 $LN18@SetBuffLis

; 101  : 			continue;
; 102  : 
; 103  : 		bool bEnableTeamAttack = pChar->IsEnableTeamAttack();

  00687	8b cb		 mov	 ecx, ebx
  00689	e8 00 00 00 00	 call	 ?IsEnableTeamAttack@ioBaseChar@@QAE_NXZ ; ioBaseChar::IsEnableTeamAttack
  0068e	88 85 93 7f ff
	ff		 mov	 BYTE PTR _bEnableTeamAttack$530944[ebp], al

; 104  : 
; 105  : 		if( pOwner->GetCharName() == pChar->GetCharName() && !IsCollisioned(pChar) )

  00694	8d 83 d4 02 00
	00		 lea	 eax, DWORD PTR [ebx+724]
  0069a	50		 push	 eax
  0069b	8d 8f d4 02 00
	00		 lea	 ecx, DWORD PTR [edi+724]
  006a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??8ioHashString@@QBE_NABV0@@Z
  006a7	84 c0		 test	 al, al
  006a9	74 16		 je	 SHORT $LN5@SetBuffLis
  006ab	53		 push	 ebx
  006ac	8b ce		 mov	 ecx, esi
  006ae	e8 00 00 00 00	 call	 ?IsCollisioned@ioRangeSkill@@IAE_NPAVioBaseChar@@@Z ; ioRangeSkill::IsCollisioned
  006b3	84 c0		 test	 al, al
  006b5	75 0a		 jne	 SHORT $LN5@SetBuffLis

; 106  : 		{
; 107  : 			SetOwnerBuffList( pChar );

  006b7	53		 push	 ebx
  006b8	8b ce		 mov	 ecx, esi
  006ba	e8 00 00 00 00	 call	 ?SetOwnerBuffList@ioRangeSkill@@IAE_NPAVioBaseChar@@@Z ; ioRangeSkill::SetOwnerBuffList
  006bf	eb 47		 jmp	 SHORT $LN3@SetBuffLis
$LN5@SetBuffLis:

; 108  : 		}
; 109  : 		else if( pOwner->GetTeam() == pChar->GetTeam() && SetTeamBuffList( pOwner, pChar ) )	// Team

  006c1	8d 85 80 7f ff
	ff		 lea	 eax, DWORD PTR _value$534117[ebp]
  006c7	8d 8f 90 00 00
	00		 lea	 ecx, DWORD PTR [edi+144]
  006cd	50		 push	 eax
  006ce	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  006d3	8d 85 84 7f ff
	ff		 lea	 eax, DWORD PTR _value$534130[ebp]
  006d9	8d 8b 90 00 00
	00		 lea	 ecx, DWORD PTR [ebx+144]
  006df	50		 push	 eax
  006e0	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  006e5	8b 85 80 7f ff
	ff		 mov	 eax, DWORD PTR _value$534117[ebp]
  006eb	3b 85 84 7f ff
	ff		 cmp	 eax, DWORD PTR _value$534130[ebp]
  006f1	75 15		 jne	 SHORT $LN3@SetBuffLis
  006f3	53		 push	 ebx
  006f4	57		 push	 edi
  006f5	8b ce		 mov	 ecx, esi
  006f7	e8 00 00 00 00	 call	 ?SetTeamBuffList@ioRangeSkill@@IAE_NPAVioBaseChar@@0@Z ; ioRangeSkill::SetTeamBuffList
  006fc	84 c0		 test	 al, al
  006fe	74 08		 je	 SHORT $LN3@SetBuffLis

; 110  : 		{
; 111  : 			pOwner->CheckTeamBuffAttackCnt( pChar );

  00700	53		 push	 ebx
  00701	8b cf		 mov	 ecx, edi
  00703	e8 00 00 00 00	 call	 ?CheckTeamBuffAttackCnt@ioBaseChar@@QAEXPAV1@@Z ; ioBaseChar::CheckTeamBuffAttackCnt
$LN3@SetBuffLis:

; 112  : 		}
; 113  : 		
; 114  : 		if( (bEnableTeamAttack || pOwner->GetTeam() != pChar->GetTeam()) && SetEnemyBuffList( pOwner, pChar ) )	// Enemy

  00708	80 bd 93 7f ff
	ff 00		 cmp	 BYTE PTR _bEnableTeamAttack$530944[ebp], 0
  0070f	75 32		 jne	 SHORT $LN1@SetBuffLis
  00711	8d 85 7c 7f ff
	ff		 lea	 eax, DWORD PTR _value$534142[ebp]
  00717	8d 8f 90 00 00
	00		 lea	 ecx, DWORD PTR [edi+144]
  0071d	50		 push	 eax
  0071e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  00723	8d 85 ac 7f ff
	ff		 lea	 eax, DWORD PTR _value$534155[ebp]
  00729	8d 8b 90 00 00
	00		 lea	 ecx, DWORD PTR [ebx+144]
  0072f	50		 push	 eax
  00730	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  00735	8b 85 7c 7f ff
	ff		 mov	 eax, DWORD PTR _value$534142[ebp]
  0073b	3b 85 ac 7f ff
	ff		 cmp	 eax, DWORD PTR _value$534155[ebp]
  00741	74 1f		 je	 SHORT $LN18@SetBuffLis
$LN1@SetBuffLis:
  00743	8b 06		 mov	 eax, DWORD PTR [esi]
  00745	53		 push	 ebx
  00746	57		 push	 edi
  00747	8b ce		 mov	 ecx, esi
  00749	ff 90 98 01 00
	00		 call	 DWORD PTR [eax+408]
  0074f	84 c0		 test	 al, al
  00751	74 0f		 je	 SHORT $LN18@SetBuffLis

; 115  : 		{
; 116  : 			//pOwner->CheckRealComboHit( pChar->GetCharName() );
; 117  : 			pOwner->CheckComboSkillHit();

  00753	8b cf		 mov	 ecx, edi
  00755	e8 00 00 00 00	 call	 ?CheckComboSkillHit@ioBaseChar@@QAE_NXZ ; ioBaseChar::CheckComboSkillHit

; 118  : 			pOwner->CheckAttackCnt( pChar );

  0075a	53		 push	 ebx
  0075b	8b cf		 mov	 ecx, edi
  0075d	e8 00 00 00 00	 call	 ?CheckAttackCnt@ioBaseChar@@QAEXPAV1@@Z ; ioBaseChar::CheckAttackCnt
$LN18@SetBuffLis:

; 80   : 
; 81   : 	BaseCharList::iterator iter;
; 82   : 	for( iter = vTargetList.begin(); iter != vTargetList.end(); ++iter )

  00762	8b 85 b0 7f ff
	ff		 mov	 eax, DWORD PTR _iter$[ebp]
  00768	83 c0 04	 add	 eax, 4
$LN190@SetBuffLis:
  0076b	89 85 b0 7f ff
	ff		 mov	 DWORD PTR _iter$[ebp], eax
  00771	3b 85 a0 7f ff
	ff		 cmp	 eax, DWORD PTR _vTargetList$[ebp+4]
  00777	0f 85 81 fd ff
	ff		 jne	 $LL113@SetBuffLis

; 119  : 		}
; 120  : 	}
; 121  : 
; 122  : 	pOwner->ReduceNeedGaugeBySkill( this, GetNeedGauge(pOwner->GetCharName()) );

  0077d	8d 87 d4 02 00
	00		 lea	 eax, DWORD PTR [edi+724]
  00783	50		 push	 eax
  00784	8b ce		 mov	 ecx, esi
  00786	e8 00 00 00 00	 call	 ?GetNeedGauge@ioSkill@@QAEMABVioHashString@@@Z ; ioSkill::GetNeedGauge
  0078b	51		 push	 ecx
  0078c	d9 1c 24	 fstp	 DWORD PTR [esp]
  0078f	56		 push	 esi
  00790	8b cf		 mov	 ecx, edi
  00792	e8 00 00 00 00	 call	 ?ReduceNeedGaugeBySkill@ioBaseChar@@QAEMPAVioSkill@@M@Z ; ioBaseChar::ReduceNeedGaugeBySkill
  00797	dd d8		 fstp	 ST(0)

; 123  : 	m_bReduceGauge = true;
; 124  : }

  00799	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0079d	8d 8d 9c 7f ff
	ff		 lea	 ecx, DWORD PTR _vTargetList$[ebp]
  007a3	c6 86 50 03 00
	00 01		 mov	 BYTE PTR [esi+848], 1
  007aa	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@IAEXXZ ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::_Tidy
$LN171@SetBuffLis:
  007af	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  007b2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  007b9	59		 pop	 ecx
  007ba	5f		 pop	 edi
  007bb	5e		 pop	 esi
  007bc	5b		 pop	 ebx
  007bd	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007c0	33 cd		 xor	 ecx, ebp
  007c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007c7	c9		 leave
  007c8	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@@Z$0:
  00000	8d 8d b4 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$530755[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1SP2Packet@@UAE@XZ	; SP2Packet::~SP2Packet
__unwindfunclet$?SetBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@@Z$1:
  0000b	8d 8d 9c 7f ff
	ff		 lea	 ecx, DWORD PTR _vTargetList$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE@XZ ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::~vector<ioBaseChar *,std::allocator<ioBaseChar *> >
__ehhandler$?SetBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@@Z:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 8a 78 7f ff
	ff		 mov	 ecx, DWORD PTR [edx-32904]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@@Z ENDP ; ioRangeSyncBuffSkill::SetBuffList
; Function compile flags: /Ogsp
;	COMDAT ?OnProcessState@ioRangeSyncBuffSkill@@MAEXPAVioBaseChar@@PAVioPlayStage@@@Z
_TEXT	SEGMENT
_value$534207 = -4					; size = 4
_value$534203 = -4					; size = 4
_dwPreDelayTime$ = -4					; size = 4
_pChar$ = 8						; size = 4
_pStage$ = 12						; size = 4
?OnProcessState@ioRangeSyncBuffSkill@@MAEXPAVioBaseChar@@PAVioPlayStage@@@Z PROC ; ioRangeSyncBuffSkill::OnProcessState, COMDAT
; _this$ = ecx

; 241  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 242  : 	DWORD dwPreDelayTime = GetPreDelayTime();

  00008	8b 06		 mov	 eax, DWORD PTR [esi]
  0000a	57		 push	 edi
  0000b	ff 90 34 01 00
	00		 call	 DWORD PTR [eax+308]
  00011	89 45 fc	 mov	 DWORD PTR _dwPreDelayTime$[ebp], eax

; 243  : 
; 244  : 	switch( m_RangeState )

  00014	8b 86 5c 0f 00
	00		 mov	 eax, DWORD PTR [esi+3932]
  0001a	33 db		 xor	 ebx, ebx
  0001c	2b c3		 sub	 eax, ebx
  0001e	0f 84 dd 00 00
	00		 je	 $LN9@OnProcessS
  00024	48		 dec	 eax
  00025	0f 84 88 00 00
	00		 je	 $LN7@OnProcessS
  0002b	48		 dec	 eax
  0002c	48		 dec	 eax
  0002d	0f 85 11 01 00
	00		 jne	 $LN8@OnProcessS

; 261  : 	case RS_LOOP:
; 262  : 		if( m_dwLoopStartTime > 0 && m_dwLoopStartTime+m_dwLoopTime < FRAMEGETTIME() )

  00033	8b be b4 0f 00
	00		 mov	 edi, DWORD PTR [esi+4020]
  00039	3b fb		 cmp	 edi, ebx
  0003b	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  00041	76 2f		 jbe	 SHORT $LN4@OnProcessS
  00043	ff d3		 call	 ebx
  00045	8b c8		 mov	 ecx, eax
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ
  0004d	8b 8e b8 0f 00
	00		 mov	 ecx, DWORD PTR [esi+4024]
  00053	03 cf		 add	 ecx, edi
  00055	3b c8		 cmp	 ecx, eax
  00057	73 19		 jae	 SHORT $LN4@OnProcessS

; 263  : 		{
; 264  : 			m_dwLoopStartTime = 0;
; 265  : 			SetEndState( pChar );

  00059	ff 75 08	 push	 DWORD PTR _pChar$[ebp]
  0005c	8b 06		 mov	 eax, DWORD PTR [esi]
  0005e	83 a6 b4 0f 00
	00 00		 and	 DWORD PTR [esi+4020], 0
  00065	8b ce		 mov	 ecx, esi
  00067	ff 90 94 01 00
	00		 call	 DWORD PTR [eax+404]
  0006d	e9 d2 00 00 00	 jmp	 $LN8@OnProcessS
$LN4@OnProcessS:

; 266  : 		}
; 267  : 		else if( m_dwLoopStartTime > 0 && ( m_dwDuration == 0 || m_dwLoopStartTime+m_dwDuration > FRAMEGETTIME() ) )

  00072	85 ff		 test	 edi, edi
  00074	0f 84 ca 00 00
	00		 je	 $LN8@OnProcessS
  0007a	83 be 60 0f 00
	00 00		 cmp	 DWORD PTR [esi+3936], 0
  00081	74 1e		 je	 SHORT $LN1@OnProcessS
  00083	ff d3		 call	 ebx
  00085	8b c8		 mov	 ecx, eax
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ
  0008d	8b 8e b4 0f 00
	00		 mov	 ecx, DWORD PTR [esi+4020]
  00093	03 8e 60 0f 00
	00		 add	 ecx, DWORD PTR [esi+3936]
  00099	3b c8		 cmp	 ecx, eax
  0009b	0f 86 a3 00 00
	00		 jbe	 $LN8@OnProcessS
$LN1@OnProcessS:

; 268  : 		{
; 269  : 			SetBuffList( pChar, pStage );

  000a1	ff 75 0c	 push	 DWORD PTR _pStage$[ebp]
  000a4	8b ce		 mov	 ecx, esi
  000a6	ff 75 08	 push	 DWORD PTR _pChar$[ebp]
  000a9	e8 00 00 00 00	 call	 ?SetBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@@Z ; ioRangeSyncBuffSkill::SetBuffList

; 270  : 		}
; 271  : 		break;

  000ae	e9 91 00 00 00	 jmp	 $LN8@OnProcessS
$LN7@OnProcessS:

; 252  : 		}
; 253  : 		break;
; 254  : 	case RS_ACTION:
; 255  : 		if( m_dwMotionStartTime > 0 && m_dwMotionEndTime < FRAMEGETTIME() )

  000b3	8d 45 fc	 lea	 eax, DWORD PTR _value$534203[ebp]
  000b6	50		 push	 eax
  000b7	8d 8e a8 02 00
	00		 lea	 ecx, DWORD PTR [esi+680]
  000bd	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z ; CEncrypt<unsigned long>::DecryptValueToPool
  000c2	39 5d fc	 cmp	 DWORD PTR _value$534203[ebp], ebx
  000c5	76 7d		 jbe	 SHORT $LN8@OnProcessS
  000c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  000cd	8b c8		 mov	 ecx, eax
  000cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ
  000d5	39 86 d8 02 00
	00		 cmp	 DWORD PTR [esi+728], eax
  000db	73 67		 jae	 SHORT $LN8@OnProcessS

; 256  : 		{
; 257  : 			m_dwMotionStartTime = 0;

  000dd	8d 45 fc	 lea	 eax, DWORD PTR _value$534207[ebp]
  000e0	50		 push	 eax
  000e1	8d 8e a8 02 00
	00		 lea	 ecx, DWORD PTR [esi+680]
  000e7	89 5d fc	 mov	 DWORD PTR _value$534207[ebp], ebx
  000ea	e8 00 00 00 00	 call	 ?EncryptValueToPool@?$CEncrypt@K@@AAEXPBD@Z ; CEncrypt<unsigned long>::EncryptValueToPool

; 258  : 			SetLoopState( pChar, pStage );

  000ef	ff 75 0c	 push	 DWORD PTR _pStage$[ebp]
  000f2	8b 06		 mov	 eax, DWORD PTR [esi]
  000f4	ff 75 08	 push	 DWORD PTR _pChar$[ebp]
  000f7	8b ce		 mov	 ecx, esi
  000f9	ff 90 90 01 00
	00		 call	 DWORD PTR [eax+400]

; 259  : 		}
; 260  : 		break;

  000ff	eb 43		 jmp	 SHORT $LN8@OnProcessS
$LN9@OnProcessS:

; 245  : 	{
; 246  : 	case RS_NONE:
; 247  : 		if( m_dwPreDelayStartTime > 0 && m_dwPreDelayStartTime + dwPreDelayTime < FRAMEGETTIME() )

  00101	39 9e 20 02 00
	00		 cmp	 DWORD PTR [esi+544], ebx
  00107	76 3b		 jbe	 SHORT $LN8@OnProcessS
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  0010f	8b c8		 mov	 ecx, eax
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ
  00117	8b 8e 20 02 00
	00		 mov	 ecx, DWORD PTR [esi+544]
  0011d	03 4d fc	 add	 ecx, DWORD PTR _dwPreDelayTime$[ebp]
  00120	3b c8		 cmp	 ecx, eax
  00122	73 20		 jae	 SHORT $LN8@OnProcessS

; 248  : 		{
; 249  : 			m_dwPreDelayStartTime = 0;
; 250  : 			EndPreDelayEffect( pChar );

  00124	ff 75 08	 push	 DWORD PTR _pChar$[ebp]
  00127	8b 06		 mov	 eax, DWORD PTR [esi]
  00129	8b ce		 mov	 ecx, esi
  0012b	89 9e 20 02 00
	00		 mov	 DWORD PTR [esi+544], ebx
  00131	ff 90 dc 00 00
	00		 call	 DWORD PTR [eax+220]

; 251  : 			SetActionState( pChar );

  00137	ff 75 08	 push	 DWORD PTR _pChar$[ebp]
  0013a	8b 06		 mov	 eax, DWORD PTR [esi]
  0013c	8b ce		 mov	 ecx, esi
  0013e	ff 90 8c 01 00
	00		 call	 DWORD PTR [eax+396]
$LN8@OnProcessS:
  00144	5f		 pop	 edi
  00145	5e		 pop	 esi
  00146	5b		 pop	 ebx

; 272  : 	}
; 273  : }

  00147	c9		 leave
  00148	c2 08 00	 ret	 8
?OnProcessState@ioRangeSyncBuffSkill@@MAEXPAVioBaseChar@@PAVioPlayStage@@@Z ENDP ; ioRangeSyncBuffSkill::OnProcessState
_TEXT	ENDS
PUBLIC	_pStage$GSCopy$
PUBLIC	?ApplySetBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z ; ioRangeSyncBuffSkill::ApplySetBuffList
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?ApplySetBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ApplySetBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z$0
__ehfuncinfo$?ApplySetBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ApplySetBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iorangesyncbuffskill.cpp
xdata$x	ENDS
;	COMDAT ?ApplySetBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z
_TEXT	SEGMENT
_value$534531 = -104					; size = 4
_value$534559 = -100					; size = 4
_value$534547 = -96					; size = 4
_pStage$GSCopy$ = -92					; size = 4
_bEnableTeamAttack$531105 = -85				; size = 1
tv1154 = -84						; size = 4
_value$534500 = -84					; size = 4
_value$534322 = -84					; size = 4
$T534309 = -84						; size = 4
_vTargetList$ = -80					; size = 16
tv1382 = -64						; size = 4
tv1378 = -64						; size = 4
tv1341 = -64						; size = 4
tv1336 = -64						; size = 4
tv1313 = -64						; size = 4
tv1309 = -64						; size = 4
_value$534572 = -64					; size = 4
$T534386 = -64						; size = 4
tv1305 = -60						; size = 4
tv1260 = -60						; size = 4
tv1256 = -60						; size = 4
tv1252 = -60						; size = 4
tv1245 = -60						; size = 4
tv1241 = -60						; size = 4
tv1237 = -60						; size = 4
tv1374 = -56						; size = 4
tv1332 = -56						; size = 4
tv1158 = -56						; size = 4
$T534294 = -56						; size = 4
_iter$ = -56						; size = 4
_vEndPos$531101 = -52					; size = 12
_vStartPos$531099 = -40					; size = 12
_vPos$ = -28						; size = 12
__$EHRec$ = -12						; size = 12
_pOwner$ = 8						; size = 4
_pStage$ = 12						; size = 4
_rkPacket$ = 16						; size = 4
?ApplySetBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z PROC ; ioRangeSyncBuffSkill::ApplySetBuffList, COMDAT
; _this$ = ecx

; 338  : {

  00000	6a 5c		 push	 92			; 0000005cH
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?ApplySetBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000c	8b 45 0c	 mov	 eax, DWORD PTR _pStage$[ebp]
  0000f	8b 5d 08	 mov	 ebx, DWORD PTR _pOwner$[ebp]

; 365  : 
; 366  : 	BaseCharList::iterator iter;
; 367  : 	for( iter = vTargetList.begin(); iter != vTargetList.end(); ++iter )

  00012	89 45 a4	 mov	 DWORD PTR _pStage$GSCopy$[ebp], eax
  00015	33 c0		 xor	 eax, eax
  00017	8b f1		 mov	 esi, ecx
  00019	89 45 b0	 mov	 DWORD PTR _vTargetList$[ebp], eax
  0001c	89 45 b4	 mov	 DWORD PTR _vTargetList$[ebp+4], eax
  0001f	89 45 b8	 mov	 DWORD PTR _vTargetList$[ebp+8], eax
  00022	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], eax

; 339  : 	BaseCharList vTargetList;
; 340  : 	D3DXVECTOR3 vPos = pOwner->GetMidPositionByRate( FLOAT08 );

  00025	b8 08 00 00 00	 mov	 eax, 8

; 365  : 
; 366  : 	BaseCharList::iterator iter;
; 367  : 	for( iter = vTargetList.begin(); iter != vTargetList.end(); ++iter )

  0002a	8b c8		 mov	 ecx, eax

; 339  : 	BaseCharList vTargetList;
; 340  : 	D3DXVECTOR3 vPos = pOwner->GetMidPositionByRate( FLOAT08 );

  0002c	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH

; 365  : 
; 366  : 	BaseCharList::iterator iter;
; 367  : 	for( iter = vTargetList.begin(); iter != vTargetList.end(); ++iter )

  00031	89 4d c0	 mov	 DWORD PTR tv1382[ebp], ecx
  00034	db 45 c0	 fild	 DWORD PTR tv1382[ebp]
  00037	85 c9		 test	 ecx, ecx
  00039	79 06		 jns	 SHORT $LN161@ApplySetBu

; 339  : 	BaseCharList vTargetList;
; 340  : 	D3DXVECTOR3 vPos = pOwner->GetMidPositionByRate( FLOAT08 );

  0003b	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN161@ApplySetBu:
  00041	89 45 c0	 mov	 DWORD PTR tv1378[ebp], eax
  00044	db 45 c0	 fild	 DWORD PTR tv1378[ebp]
  00047	85 c0		 test	 eax, eax
  00049	79 06		 jns	 SHORT $LN162@ApplySetBu
  0004b	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN162@ApplySetBu:
  00051	de f9		 fdivp	 ST(1), ST(0)
  00053	51		 push	 ecx
  00054	8d 45 e4	 lea	 eax, DWORD PTR _vPos$[ebp]
  00057	8b cb		 mov	 ecx, ebx
  00059	d9 5d c8	 fstp	 DWORD PTR tv1374[ebp]
  0005c	d9 45 c8	 fld	 DWORD PTR tv1374[ebp]
  0005f	d9 1c 24	 fstp	 DWORD PTR [esp]
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 ?GetMidPositionByRate@ioGameEntity@@QBE?AUD3DXVECTOR3@@M@Z ; ioGameEntity::GetMidPositionByRate

; 341  : 	vPos += m_vEffectDir * m_fOffSet;

  00068	f3 0f 10 86 78
	0f 00 00	 movss	 xmm0, DWORD PTR [esi+3960]
  00070	f3 0f 10 96 98
	0f 00 00	 movss	 xmm2, DWORD PTR [esi+3992]
  00078	0f 5a c8	 cvtps2pd xmm1, xmm0
  0007b	0f 5a d8	 cvtps2pd xmm3, xmm0

; 342  : 
; 343  : 	//    
; 344  : 	switch( m_TargetColType )

  0007e	8b 86 54 0f 00
	00		 mov	 eax, DWORD PTR [esi+3924]
  00084	48		 dec	 eax
  00085	0f 5a d2	 cvtps2pd xmm2, xmm2
  00088	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  0008c	f3 0f 10 96 9c
	0f 00 00	 movss	 xmm2, DWORD PTR [esi+3996]
  00094	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  00098	0f 5a d2	 cvtps2pd xmm2, xmm2
  0009b	f2 0f 59 d3	 mulsd	 xmm2, xmm3
  0009f	f3 0f 10 9e a0
	0f 00 00	 movss	 xmm3, DWORD PTR [esi+4000]
  000a7	0f 5a c0	 cvtps2pd xmm0, xmm0
  000aa	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  000ae	0f 5a db	 cvtps2pd xmm3, xmm3
  000b1	f2 0f 59 d8	 mulsd	 xmm3, xmm0
  000b5	0f 57 c0	 xorps	 xmm0, xmm0
  000b8	66 0f 5a c3	 cvtpd2ps xmm0, xmm3
  000bc	f3 0f 10 5d e4	 movss	 xmm3, DWORD PTR _vPos$[ebp]
  000c1	0f 5a db	 cvtps2pd xmm3, xmm3
  000c4	f2 0f 58 d9	 addsd	 xmm3, xmm1
  000c8	0f 57 c9	 xorps	 xmm1, xmm1
  000cb	66 0f 5a cb	 cvtpd2ps xmm1, xmm3
  000cf	f3 0f 11 4d e4	 movss	 DWORD PTR _vPos$[ebp], xmm1
  000d4	f3 0f 10 4d e8	 movss	 xmm1, DWORD PTR _vPos$[ebp+4]
  000d9	0f 5a c9	 cvtps2pd xmm1, xmm1
  000dc	66 0f 5a d2	 cvtpd2ps xmm2, xmm2
  000e0	f3 0f 5a d2	 cvtss2sd xmm2, xmm2
  000e4	f2 0f 58 ca	 addsd	 xmm1, xmm2
  000e8	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  000ec	f3 0f 11 4d e8	 movss	 DWORD PTR _vPos$[ebp+4], xmm1
  000f1	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR _vPos$[ebp+8]
  000f6	0f 5a c0	 cvtps2pd xmm0, xmm0
  000f9	0f 5a c9	 cvtps2pd xmm1, xmm1
  000fc	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00100	0f 57 c0	 xorps	 xmm0, xmm0
  00103	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  00107	f3 0f 11 45 ec	 movss	 DWORD PTR _vPos$[ebp+8], xmm0
  0010c	0f 84 49 02 00
	00		 je	 $LN19@ApplySetBu
  00112	48		 dec	 eax
  00113	0f 84 f7 01 00
	00		 je	 $LN18@ApplySetBu
  00119	48		 dec	 eax
  0011a	0f 85 67 02 00
	00		 jne	 $LN20@ApplySetBu

; 352  : 	case TCT_BOX:
; 353  : 		//  center vPos       .
; 354  : 		// /2.0f  * FLOAT05 
; 355  : 		vPos += m_vEffectDir * m_fSkillRange * FLOAT05; 

  00120	b8 05 00 00 00	 mov	 eax, 5
  00125	8b c8		 mov	 ecx, eax
  00127	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  0012c	f3 0f 10 86 70
	0f 00 00	 movss	 xmm0, DWORD PTR [esi+3952]
  00134	f3 0f 10 96 98
	0f 00 00	 movss	 xmm2, DWORD PTR [esi+3992]
  0013c	0f 5a c8	 cvtps2pd xmm1, xmm0
  0013f	0f 5a d2	 cvtps2pd xmm2, xmm2
  00142	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  00146	f3 0f 10 96 9c
	0f 00 00	 movss	 xmm2, DWORD PTR [esi+3996]
  0014e	0f 5a d8	 cvtps2pd xmm3, xmm0
  00151	0f 5a d2	 cvtps2pd xmm2, xmm2
  00154	f2 0f 59 d3	 mulsd	 xmm2, xmm3
  00158	f3 0f 10 9e a0
	0f 00 00	 movss	 xmm3, DWORD PTR [esi+4000]
  00160	0f 5a c0	 cvtps2pd xmm0, xmm0
  00163	0f 5a db	 cvtps2pd xmm3, xmm3
  00166	f2 0f 59 d8	 mulsd	 xmm3, xmm0
  0016a	0f 57 c0	 xorps	 xmm0, xmm0
  0016d	89 4d c0	 mov	 DWORD PTR tv1341[ebp], ecx
  00170	db 45 c0	 fild	 DWORD PTR tv1341[ebp]
  00173	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  00177	66 0f 5a d2	 cvtpd2ps xmm2, xmm2
  0017b	66 0f 5a c3	 cvtpd2ps xmm0, xmm3
  0017f	85 c9		 test	 ecx, ecx
  00181	79 06		 jns	 SHORT $LN163@ApplySetBu
  00183	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN163@ApplySetBu:
  00189	89 45 c0	 mov	 DWORD PTR tv1336[ebp], eax
  0018c	db 45 c0	 fild	 DWORD PTR tv1336[ebp]
  0018f	85 c0		 test	 eax, eax
  00191	79 06		 jns	 SHORT $LN164@ApplySetBu
  00193	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN164@ApplySetBu:
  00199	de f9		 fdivp	 ST(1), ST(0)
  0019b	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  0019f	f3 0f 5a d2	 cvtss2sd xmm2, xmm2
  001a3	0f 5a c0	 cvtps2pd xmm0, xmm0
  001a6	d9 5d c8	 fstp	 DWORD PTR tv1332[ebp]
  001a9	d9 45 c8	 fld	 DWORD PTR tv1332[ebp]
  001ac	d9 5d c8	 fstp	 DWORD PTR $T534294[ebp]
  001af	f3 0f 10 5d c8	 movss	 xmm3, DWORD PTR $T534294[ebp]
  001b4	0f 5a db	 cvtps2pd xmm3, xmm3
  001b7	f2 0f 59 cb	 mulsd	 xmm1, xmm3
  001bb	f3 0f 10 5d c8	 movss	 xmm3, DWORD PTR $T534294[ebp]
  001c0	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  001c4	0f 5a db	 cvtps2pd xmm3, xmm3
  001c7	f2 0f 59 d3	 mulsd	 xmm2, xmm3
  001cb	f3 0f 10 5d c8	 movss	 xmm3, DWORD PTR $T534294[ebp]
  001d0	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  001d4	0f 5a db	 cvtps2pd xmm3, xmm3
  001d7	f2 0f 59 c3	 mulsd	 xmm0, xmm3
  001db	f3 0f 10 5d e4	 movss	 xmm3, DWORD PTR _vPos$[ebp]
  001e0	0f 5a db	 cvtps2pd xmm3, xmm3
  001e3	f2 0f 58 cb	 addsd	 xmm1, xmm3
  001e7	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  001eb	f3 0f 11 4d e4	 movss	 DWORD PTR _vPos$[ebp], xmm1
  001f0	f3 0f 10 4d e8	 movss	 xmm1, DWORD PTR _vPos$[ebp+4]
  001f5	0f 5a c9	 cvtps2pd xmm1, xmm1
  001f8	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  001fc	66 0f 5a d2	 cvtpd2ps xmm2, xmm2
  00200	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00204	f3 0f 5a d2	 cvtss2sd xmm2, xmm2
  00208	f2 0f 58 ca	 addsd	 xmm1, xmm2
  0020c	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  00210	f3 0f 11 4d e8	 movss	 DWORD PTR _vPos$[ebp+4], xmm1
  00215	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR _vPos$[ebp+8]
  0021a	0f 5a c9	 cvtps2pd xmm1, xmm1
  0021d	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00221	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  00225	f3 0f 11 45 ec	 movss	 DWORD PTR _vPos$[ebp+8], xmm0

; 356  : 		// /2.0f  * FLOAT05 
; 357  : 		D3DXVECTOR3 vOffset( 0.0f, ( ( m_fUpHeight + m_fUnderHeight ) * FLOAT05 ) - m_fUpHeight, 0.0f );

  0022a	b8 05 00 00 00	 mov	 eax, 5
  0022f	8b c8		 mov	 ecx, eax
  00231	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  00236	f3 0f 10 8e 80
	0f 00 00	 movss	 xmm1, DWORD PTR [esi+3968]
  0023e	f3 0f 10 96 7c
	0f 00 00	 movss	 xmm2, DWORD PTR [esi+3964]
  00246	89 4d c0	 mov	 DWORD PTR tv1313[ebp], ecx
  00249	db 45 c0	 fild	 DWORD PTR tv1313[ebp]
  0024c	f3 0f 11 4d ac	 movss	 DWORD PTR tv1154[ebp], xmm1
  00251	f3 0f 11 55 c8	 movss	 DWORD PTR tv1158[ebp], xmm2
  00256	85 c9		 test	 ecx, ecx
  00258	79 06		 jns	 SHORT $LN165@ApplySetBu
  0025a	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN165@ApplySetBu:
  00260	89 45 c0	 mov	 DWORD PTR tv1309[ebp], eax
  00263	db 45 c0	 fild	 DWORD PTR tv1309[ebp]
  00266	85 c0		 test	 eax, eax
  00268	79 06		 jns	 SHORT $LN166@ApplySetBu
  0026a	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN166@ApplySetBu:
  00270	de f9		 fdivp	 ST(1), ST(0)

; 358  : 		vPos -= vOffset;

  00272	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _vPos$[ebp]
  00277	0f 5a d8	 cvtps2pd xmm3, xmm0
  0027a	f2 0f 5c 1d 00
	00 00 00	 subsd	 xmm3, QWORD PTR __real@0000000000000000
  00282	66 0f 5a db	 cvtpd2ps xmm3, xmm3
  00286	f3 0f 11 5d e4	 movss	 DWORD PTR _vPos$[ebp], xmm3
  0028b	f3 0f 10 5d e8	 movss	 xmm3, DWORD PTR _vPos$[ebp+4]
  00290	0f 5a db	 cvtps2pd xmm3, xmm3

; 359  : 		pOwner->GetTargetCharListByBox( vPos, m_fSkillRange, m_fWidth, m_fUpHeight, m_fUnderHeight, vTargetList );

  00293	8d 45 b0	 lea	 eax, DWORD PTR _vTargetList$[ebp]
  00296	50		 push	 eax
  00297	83 ec 10	 sub	 esp, 16			; 00000010H
  0029a	f3 0f 11 4c 24
	0c		 movss	 DWORD PTR [esp+12], xmm1
  002a0	f3 0f 11 54 24
	08		 movss	 DWORD PTR [esp+8], xmm2
  002a6	8d 45 e4	 lea	 eax, DWORD PTR _vPos$[ebp]
  002a9	8b cb		 mov	 ecx, ebx
  002ab	d9 5d c4	 fstp	 DWORD PTR tv1305[ebp]
  002ae	d9 45 c4	 fld	 DWORD PTR tv1305[ebp]
  002b1	d9 45 c8	 fld	 DWORD PTR tv1158[ebp]
  002b4	d8 45 ac	 fadd	 DWORD PTR tv1154[ebp]
  002b7	de c9		 fmulp	 ST(1), ST(0)
  002b9	d8 65 c8	 fsub	 DWORD PTR tv1158[ebp]
  002bc	d9 5d ac	 fstp	 DWORD PTR $T534309[ebp]
  002bf	f3 0f 10 65 ac	 movss	 xmm4, DWORD PTR $T534309[ebp]
  002c4	0f 5a e4	 cvtps2pd xmm4, xmm4
  002c7	f2 0f 5c dc	 subsd	 xmm3, xmm4
  002cb	66 0f 5a db	 cvtpd2ps xmm3, xmm3
  002cf	f3 0f 11 5d e8	 movss	 DWORD PTR _vPos$[ebp+4], xmm3
  002d4	f3 0f 10 5d ec	 movss	 xmm3, DWORD PTR _vPos$[ebp+8]
  002d9	0f 5a db	 cvtps2pd xmm3, xmm3
  002dc	f2 0f 5c 1d 00
	00 00 00	 subsd	 xmm3, QWORD PTR __real@0000000000000000
  002e4	66 0f 5a c3	 cvtpd2ps xmm0, xmm3
  002e8	f3 0f 11 45 ec	 movss	 DWORD PTR _vPos$[ebp+8], xmm0
  002ed	f3 0f 10 86 84
	0f 00 00	 movss	 xmm0, DWORD PTR [esi+3972]
  002f5	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  002fb	f3 0f 10 86 70
	0f 00 00	 movss	 xmm0, DWORD PTR [esi+3952]
  00303	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00308	50		 push	 eax
  00309	e8 00 00 00 00	 call	 ?GetTargetCharListByBox@ioBaseChar@@QAEXABUD3DXVECTOR3@@MMMMAAV?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@Z ; ioBaseChar::GetTargetCharListByBox

; 360  : 		break;

  0030e	eb 77		 jmp	 SHORT $LN20@ApplySetBu
$LN18@ApplySetBu:

; 348  : 		break;
; 349  : 	case TCT_CYLINDER:
; 350  : 		pOwner->GetTargetCharListByCylinder( vPos, m_fSkillRange, m_fSkillAngle, m_fUpHeight, m_fUnderHeight, vTargetList );

  00310	f3 0f 10 86 80
	0f 00 00	 movss	 xmm0, DWORD PTR [esi+3968]
  00318	8d 45 b0	 lea	 eax, DWORD PTR _vTargetList$[ebp]
  0031b	50		 push	 eax
  0031c	83 ec 10	 sub	 esp, 16			; 00000010H
  0031f	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  00325	f3 0f 10 86 7c
	0f 00 00	 movss	 xmm0, DWORD PTR [esi+3964]
  0032d	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00333	f3 0f 10 86 74
	0f 00 00	 movss	 xmm0, DWORD PTR [esi+3956]
  0033b	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00341	f3 0f 10 86 70
	0f 00 00	 movss	 xmm0, DWORD PTR [esi+3952]
  00349	8d 45 e4	 lea	 eax, DWORD PTR _vPos$[ebp]
  0034c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00351	50		 push	 eax
  00352	8b cb		 mov	 ecx, ebx
  00354	e8 00 00 00 00	 call	 ?GetTargetCharListByCylinder@ioBaseChar@@QAEXABUD3DXVECTOR3@@MMMMAAV?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@Z ; ioBaseChar::GetTargetCharListByCylinder

; 351  : 		break;

  00359	eb 2c		 jmp	 SHORT $LN20@ApplySetBu
$LN19@ApplySetBu:

; 345  : 	{
; 346  : 	case TCT_SPHERE:
; 347  : 		pOwner->GetTargetCharListBySphere( vPos, m_fSkillRange, m_fSkillAngle, vTargetList );

  0035b	f3 0f 10 86 74
	0f 00 00	 movss	 xmm0, DWORD PTR [esi+3956]
  00363	8d 45 b0	 lea	 eax, DWORD PTR _vTargetList$[ebp]
  00366	50		 push	 eax
  00367	51		 push	 ecx
  00368	51		 push	 ecx
  00369	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0036f	f3 0f 10 86 70
	0f 00 00	 movss	 xmm0, DWORD PTR [esi+3952]
  00377	8d 45 e4	 lea	 eax, DWORD PTR _vPos$[ebp]
  0037a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0037f	50		 push	 eax
  00380	8b cb		 mov	 ecx, ebx
  00382	e8 00 00 00 00	 call	 ?GetTargetCharListBySphere@ioBaseChar@@QAEXABUD3DXVECTOR3@@MMAAV?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@Z ; ioBaseChar::GetTargetCharListBySphere
$LN20@ApplySetBu:

; 361  : 	}
; 362  : 
; 363  : 	if( pOwner->GetExperienceMode() == EMS_EXPERIENCE )

  00387	8d 45 ac	 lea	 eax, DWORD PTR _value$534322[ebp]
  0038a	8d 8b 94 1d 00
	00		 lea	 ecx, DWORD PTR [ebx+7572]
  00390	50		 push	 eax
  00391	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z ; CEncrypt<unsigned long>::DecryptValueToPool
  00396	83 7d ac 02	 cmp	 DWORD PTR _value$534322[ebp], 2
  0039a	75 12		 jne	 SHORT $LN69@ApplySetBu

; 364  : 		vTargetList.clear();

  0039c	ff 75 b4	 push	 DWORD PTR _vTargetList$[ebp+4]
  0039f	8d 45 c0	 lea	 eax, DWORD PTR $T534386[ebp]
  003a2	ff 75 b0	 push	 DWORD PTR _vTargetList$[ebp]
  003a5	8d 4d b0	 lea	 ecx, DWORD PTR _vTargetList$[ebp]
  003a8	50		 push	 eax
  003a9	e8 00 00 00 00	 call	 ?erase@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@@2@0@Z ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::erase
$LN69@ApplySetBu:

; 365  : 
; 366  : 	BaseCharList::iterator iter;
; 367  : 	for( iter = vTargetList.begin(); iter != vTargetList.end(); ++iter )

  003ae	8b 45 b0	 mov	 eax, DWORD PTR _vTargetList$[ebp]
  003b1	e9 d6 01 00 00	 jmp	 $LN171@ApplySetBu
$LL101@ApplySetBu:

; 368  : 	{
; 369  : 		ioBaseChar *pChar = (*iter);

  003b6	8b 38		 mov	 edi, DWORD PTR [eax]

; 370  : 
; 371  : 		if( !pChar || IsCollisioned(pChar) ) continue;

  003b8	85 ff		 test	 edi, edi
  003ba	0f 84 c6 01 00
	00		 je	 $LN14@ApplySetBu
  003c0	57		 push	 edi
  003c1	8b ce		 mov	 ecx, esi
  003c3	e8 00 00 00 00	 call	 ?IsCollisioned@ioRangeSkill@@IAE_NPAVioBaseChar@@@Z ; ioRangeSkill::IsCollisioned
  003c8	84 c0		 test	 al, al
  003ca	0f 85 b6 01 00
	00		 jne	 $LN14@ApplySetBu

; 372  : 		if( !pChar->IsNeedProcess() ) continue;

  003d0	8b 07		 mov	 eax, DWORD PTR [edi]
  003d2	8b cf		 mov	 ecx, edi
  003d4	ff 90 00 01 00
	00		 call	 DWORD PTR [eax+256]
  003da	84 c0		 test	 al, al
  003dc	0f 84 a4 01 00
	00		 je	 $LN14@ApplySetBu

; 373  : 		if( !pStage->IsCollisionCheckByMode() ) continue;

  003e2	8b 4d a4	 mov	 ecx, DWORD PTR _pStage$GSCopy$[ebp]
  003e5	e8 00 00 00 00	 call	 ?IsCollisionCheckByMode@ioPlayStage@@QAE_NXZ ; ioPlayStage::IsCollisionCheckByMode
  003ea	84 c0		 test	 al, al
  003ec	0f 84 94 01 00
	00		 je	 $LN14@ApplySetBu

; 374  : 		if( pChar->GetExperienceMode() == EMS_EXPERIENCE ) continue;

  003f2	8d 45 ac	 lea	 eax, DWORD PTR _value$534500[ebp]
  003f5	8d 8f 94 1d 00
	00		 lea	 ecx, DWORD PTR [edi+7572]
  003fb	50		 push	 eax
  003fc	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@K@@QAEXPAK@Z ; CEncrypt<unsigned long>::DecryptValueToPool
  00401	83 7d ac 02	 cmp	 DWORD PTR _value$534500[ebp], 2
  00405	0f 84 7b 01 00
	00		 je	 $LN14@ApplySetBu

; 375  : 
; 376  : 		D3DXVECTOR3 vStartPos = pOwner->GetMidPositionByRate();

  0040b	b8 05 00 00 00	 mov	 eax, 5
  00410	8b c8		 mov	 ecx, eax
  00412	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  00417	89 4d c4	 mov	 DWORD PTR tv1260[ebp], ecx
  0041a	db 45 c4	 fild	 DWORD PTR tv1260[ebp]
  0041d	85 c9		 test	 ecx, ecx
  0041f	79 06		 jns	 SHORT $LN167@ApplySetBu
  00421	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN167@ApplySetBu:
  00427	89 45 c4	 mov	 DWORD PTR tv1256[ebp], eax
  0042a	db 45 c4	 fild	 DWORD PTR tv1256[ebp]
  0042d	85 c0		 test	 eax, eax
  0042f	79 06		 jns	 SHORT $LN168@ApplySetBu
  00431	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN168@ApplySetBu:
  00437	de f9		 fdivp	 ST(1), ST(0)
  00439	51		 push	 ecx
  0043a	8d 45 d8	 lea	 eax, DWORD PTR _vStartPos$531099[ebp]
  0043d	8b cb		 mov	 ecx, ebx
  0043f	d9 5d c4	 fstp	 DWORD PTR tv1252[ebp]
  00442	d9 45 c4	 fld	 DWORD PTR tv1252[ebp]
  00445	d9 1c 24	 fstp	 DWORD PTR [esp]
  00448	50		 push	 eax
  00449	e8 00 00 00 00	 call	 ?GetMidPositionByRate@ioGameEntity@@QBE?AUD3DXVECTOR3@@M@Z ; ioGameEntity::GetMidPositionByRate

; 377  : 		D3DXVECTOR3 vEndPos = pChar->GetMidPositionByRate();

  0044e	b8 05 00 00 00	 mov	 eax, 5
  00453	8b c8		 mov	 ecx, eax
  00455	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  0045a	89 4d c4	 mov	 DWORD PTR tv1245[ebp], ecx
  0045d	db 45 c4	 fild	 DWORD PTR tv1245[ebp]
  00460	85 c9		 test	 ecx, ecx
  00462	79 06		 jns	 SHORT $LN169@ApplySetBu
  00464	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN169@ApplySetBu:
  0046a	89 45 c4	 mov	 DWORD PTR tv1241[ebp], eax
  0046d	db 45 c4	 fild	 DWORD PTR tv1241[ebp]
  00470	85 c0		 test	 eax, eax
  00472	79 06		 jns	 SHORT $LN170@ApplySetBu
  00474	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN170@ApplySetBu:
  0047a	de f9		 fdivp	 ST(1), ST(0)
  0047c	51		 push	 ecx
  0047d	8d 45 cc	 lea	 eax, DWORD PTR _vEndPos$531101[ebp]
  00480	8b cf		 mov	 ecx, edi
  00482	d9 5d c4	 fstp	 DWORD PTR tv1237[ebp]
  00485	d9 45 c4	 fld	 DWORD PTR tv1237[ebp]
  00488	d9 1c 24	 fstp	 DWORD PTR [esp]
  0048b	50		 push	 eax
  0048c	e8 00 00 00 00	 call	 ?GetMidPositionByRate@ioGameEntity@@QBE?AUD3DXVECTOR3@@M@Z ; ioGameEntity::GetMidPositionByRate

; 378  : 		if( m_bCheckCollisionLine && !pStage->CheckCollisionLine( vStartPos, vEndPos ) )

  00491	80 be 6e 0f 00
	00 00		 cmp	 BYTE PTR [esi+3950], 0
  00498	74 1a		 je	 SHORT $LN7@ApplySetBu
  0049a	8b 4d a4	 mov	 ecx, DWORD PTR _pStage$GSCopy$[ebp]
  0049d	6a 01		 push	 1
  0049f	8d 45 cc	 lea	 eax, DWORD PTR _vEndPos$531101[ebp]
  004a2	50		 push	 eax
  004a3	8d 45 d8	 lea	 eax, DWORD PTR _vStartPos$531099[ebp]
  004a6	50		 push	 eax
  004a7	e8 00 00 00 00	 call	 ?CheckCollisionLine@ioPlayStage@@QAE_NABUD3DXVECTOR3@@0_N@Z ; ioPlayStage::CheckCollisionLine
  004ac	84 c0		 test	 al, al
  004ae	0f 84 d2 00 00
	00		 je	 $LN14@ApplySetBu
$LN7@ApplySetBu:

; 379  : 			continue;
; 380  : 
; 381  : 		if( !pChar->CheckTargetWoundType(m_TargetWoundType) )

  004b4	ff b6 58 0f 00
	00		 push	 DWORD PTR [esi+3928]
  004ba	8b cf		 mov	 ecx, edi
  004bc	e8 00 00 00 00	 call	 ?CheckTargetWoundType@ioBaseChar@@QAE_NW4TargetWoundType@@@Z ; ioBaseChar::CheckTargetWoundType
  004c1	84 c0		 test	 al, al
  004c3	0f 84 bd 00 00
	00		 je	 $LN14@ApplySetBu

; 382  : 			continue;
; 383  : 
; 384  : 		bool bEnableTeamAttack = pChar->IsEnableTeamAttack();

  004c9	8b cf		 mov	 ecx, edi
  004cb	e8 00 00 00 00	 call	 ?IsEnableTeamAttack@ioBaseChar@@QAE_NXZ ; ioBaseChar::IsEnableTeamAttack
  004d0	88 45 ab	 mov	 BYTE PTR _bEnableTeamAttack$531105[ebp], al

; 385  : 
; 386  : 		if( pOwner->GetCharName() == pChar->GetCharName() && !IsCollisioned(pChar) )

  004d3	8d 87 d4 02 00
	00		 lea	 eax, DWORD PTR [edi+724]
  004d9	50		 push	 eax
  004da	8d 8b d4 02 00
	00		 lea	 ecx, DWORD PTR [ebx+724]
  004e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??8ioHashString@@QBE_NABV0@@Z
  004e6	84 c0		 test	 al, al
  004e8	74 16		 je	 SHORT $LN5@ApplySetBu
  004ea	57		 push	 edi
  004eb	8b ce		 mov	 ecx, esi
  004ed	e8 00 00 00 00	 call	 ?IsCollisioned@ioRangeSkill@@IAE_NPAVioBaseChar@@@Z ; ioRangeSkill::IsCollisioned
  004f2	84 c0		 test	 al, al
  004f4	75 0a		 jne	 SHORT $LN5@ApplySetBu

; 387  : 		{
; 388  : 			SetOwnerBuffList( pChar );

  004f6	57		 push	 edi
  004f7	8b ce		 mov	 ecx, esi
  004f9	e8 00 00 00 00	 call	 ?SetOwnerBuffList@ioRangeSkill@@IAE_NPAVioBaseChar@@@Z ; ioRangeSkill::SetOwnerBuffList
  004fe	eb 3b		 jmp	 SHORT $LN3@ApplySetBu
$LN5@ApplySetBu:

; 389  : 		}
; 390  : 		else if( pOwner->GetTeam() == pChar->GetTeam() && SetTeamBuffList( pOwner, pChar ) )	// Team

  00500	8d 45 98	 lea	 eax, DWORD PTR _value$534531[ebp]
  00503	8d 8b 90 00 00
	00		 lea	 ecx, DWORD PTR [ebx+144]
  00509	50		 push	 eax
  0050a	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  0050f	8d 45 a0	 lea	 eax, DWORD PTR _value$534547[ebp]
  00512	8d 8f 90 00 00
	00		 lea	 ecx, DWORD PTR [edi+144]
  00518	50		 push	 eax
  00519	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  0051e	8b 45 98	 mov	 eax, DWORD PTR _value$534531[ebp]
  00521	3b 45 a0	 cmp	 eax, DWORD PTR _value$534547[ebp]
  00524	75 15		 jne	 SHORT $LN3@ApplySetBu
  00526	57		 push	 edi
  00527	53		 push	 ebx
  00528	8b ce		 mov	 ecx, esi
  0052a	e8 00 00 00 00	 call	 ?SetTeamBuffList@ioRangeSkill@@IAE_NPAVioBaseChar@@0@Z ; ioRangeSkill::SetTeamBuffList
  0052f	84 c0		 test	 al, al
  00531	74 08		 je	 SHORT $LN3@ApplySetBu

; 391  : 		{
; 392  : 			pOwner->CheckTeamBuffAttackCnt( pChar );

  00533	57		 push	 edi
  00534	8b cb		 mov	 ecx, ebx
  00536	e8 00 00 00 00	 call	 ?CheckTeamBuffAttackCnt@ioBaseChar@@QAEXPAV1@@Z ; ioBaseChar::CheckTeamBuffAttackCnt
$LN3@ApplySetBu:

; 393  : 		}
; 394  : 
; 395  : 		if( (bEnableTeamAttack || pOwner->GetTeam() != pChar->GetTeam()) && SetEnemyBuffList( pOwner, pChar ) )	// Enemy

  0053b	80 7d ab 00	 cmp	 BYTE PTR _bEnableTeamAttack$531105[ebp], 0
  0053f	75 26		 jne	 SHORT $LN1@ApplySetBu
  00541	8d 45 9c	 lea	 eax, DWORD PTR _value$534559[ebp]
  00544	8d 8b 90 00 00
	00		 lea	 ecx, DWORD PTR [ebx+144]
  0054a	50		 push	 eax
  0054b	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  00550	8d 45 c0	 lea	 eax, DWORD PTR _value$534572[ebp]
  00553	8d 8f 90 00 00
	00		 lea	 ecx, DWORD PTR [edi+144]
  00559	50		 push	 eax
  0055a	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@W4TeamType@@@@QAEXPAW4TeamType@@@Z ; CEncrypt<enum TeamType>::DecryptValueToPool
  0055f	8b 45 9c	 mov	 eax, DWORD PTR _value$534559[ebp]
  00562	3b 45 c0	 cmp	 eax, DWORD PTR _value$534572[ebp]
  00565	74 1f		 je	 SHORT $LN14@ApplySetBu
$LN1@ApplySetBu:
  00567	8b 06		 mov	 eax, DWORD PTR [esi]
  00569	57		 push	 edi
  0056a	53		 push	 ebx
  0056b	8b ce		 mov	 ecx, esi
  0056d	ff 90 98 01 00
	00		 call	 DWORD PTR [eax+408]
  00573	84 c0		 test	 al, al
  00575	74 0f		 je	 SHORT $LN14@ApplySetBu

; 396  : 		{
; 397  : 			//pOwner->CheckRealComboHit( pChar->GetCharName() );
; 398  : 			pOwner->CheckComboSkillHit();

  00577	8b cb		 mov	 ecx, ebx
  00579	e8 00 00 00 00	 call	 ?CheckComboSkillHit@ioBaseChar@@QAE_NXZ ; ioBaseChar::CheckComboSkillHit

; 399  : 			pOwner->CheckAttackCnt( pChar );

  0057e	57		 push	 edi
  0057f	8b cb		 mov	 ecx, ebx
  00581	e8 00 00 00 00	 call	 ?CheckAttackCnt@ioBaseChar@@QAEXPAV1@@Z ; ioBaseChar::CheckAttackCnt
$LN14@ApplySetBu:

; 365  : 
; 366  : 	BaseCharList::iterator iter;
; 367  : 	for( iter = vTargetList.begin(); iter != vTargetList.end(); ++iter )

  00586	8b 45 c8	 mov	 eax, DWORD PTR _iter$[ebp]
  00589	83 c0 04	 add	 eax, 4
$LN171@ApplySetBu:
  0058c	89 45 c8	 mov	 DWORD PTR _iter$[ebp], eax
  0058f	3b 45 b4	 cmp	 eax, DWORD PTR _vTargetList$[ebp+4]
  00592	0f 85 1e fe ff
	ff		 jne	 $LL101@ApplySetBu

; 400  : 		}
; 401  : 	}
; 402  : }

  00598	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0059c	8d 4d b0	 lea	 ecx, DWORD PTR _vTargetList$[ebp]
  0059f	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@IAEXXZ ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::_Tidy
  005a4	e8 00 00 00 00	 call	 __EH_epilog3_GS
  005a9	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ApplySetBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z$0:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR _vTargetList$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@PAVioBaseChar@@V?$allocator@PAVioBaseChar@@@std@@@std@@QAE@XZ ; std::vector<ioBaseChar *,std::allocator<ioBaseChar *> >::~vector<ioBaseChar *,std::allocator<ioBaseChar *> >
__ehhandler$?ApplySetBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a 94	 mov	 ecx, DWORD PTR [edx-108]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ApplySetBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ApplySetBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z ENDP ; ioRangeSyncBuffSkill::ApplySetBuffList
PUBLIC	??$_Uninitialized_move@PAVioHashString@@PAV1@V?$allocator@VioHashString@@@std@@@std@@YAPAVioHashString@@PAV1@00AAV?$allocator@VioHashString@@@0@@Z ; std::_Uninitialized_move<ioHashString *,ioHashString *,std::allocator<ioHashString> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAVioHashString@@PAV1@V?$allocator@VioHashString@@@std@@@std@@YAPAVioHashString@@PAV1@00AAV?$allocator@VioHashString@@@0@@Z
_TEXT	SEGMENT
__Cat$534612 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAVioHashString@@PAV1@V?$allocator@VioHashString@@@std@@@std@@YAPAVioHashString@@PAV1@00AAV?$allocator@VioHashString@@@0@@Z PROC ; std::_Uninitialized_move<ioHashString *,ioHashString *,std::allocator<ioHashString> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$534612[ebp]
  00007	6a 00		 push	 0
  00009	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000c	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000f	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00012	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00015	e8 00 00 00 00	 call	 ??$_Uninit_move@PAVioHashString@@PAV1@V?$allocator@VioHashString@@@std@@V1@@std@@YAPAVioHashString@@PAV1@00AAV?$allocator@VioHashString@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ioHashString *,ioHashString *,std::allocator<ioHashString>,ioHashString>
  0001a	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  0001d	c9		 leave
  0001e	c3		 ret	 0
??$_Uninitialized_move@PAVioHashString@@PAV1@V?$allocator@VioHashString@@@std@@@std@@YAPAVioHashString@@PAV1@00AAV?$allocator@VioHashString@@@0@@Z ENDP ; std::_Uninitialized_move<ioHashString *,ioHashString *,std::allocator<ioHashString> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VioHashString@@@std@@@std@@YAXPAVioHashString@@0AAV?$allocator@VioHashString@@@0@@Z ; std::_Destroy_range<std::allocator<ioHashString> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VioHashString@@@std@@@std@@YAXPAVioHashString@@0AAV?$allocator@VioHashString@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@VioHashString@@@std@@@std@@YAXPAVioHashString@@0AAV?$allocator@VioHashString@@@0@@Z PROC ; std::_Destroy_range<std::allocator<ioHashString> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	eb 0b		 jmp	 SHORT $LN21@Destroy_ra@2
$LL7@Destroy_ra@2:
  00009	8b ce		 mov	 ecx, esi
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00011	83 c6 10	 add	 esi, 16			; 00000010H
$LN21@Destroy_ra@2:
  00014	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00017	75 f0		 jne	 SHORT $LL7@Destroy_ra@2
  00019	5e		 pop	 esi

; 89   : 	}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Destroy_range@V?$allocator@VioHashString@@@std@@@std@@YAXPAVioHashString@@0AAV?$allocator@VioHashString@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<ioHashString> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAVioHashString@@@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEPAVioHashString@@PAV2@00@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::_Umove<ioHashString *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAVioHashString@@@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEPAVioHashString@@PAV2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAVioHashString@@@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEPAVioHashString@@PAV2@00@Z PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::_Umove<ioHashString *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	51		 push	 ecx
  00007	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAVioHashString@@PAV1@V?$allocator@VioHashString@@@std@@@std@@YAPAVioHashString@@PAV1@00AAV?$allocator@VioHashString@@@0@@Z ; std::_Uninitialized_move<ioHashString *,ioHashString *,std::allocator<ioHashString> >
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00018	5d		 pop	 ebp
  00019	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAVioHashString@@@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEPAVioHashString@@PAV2@00@Z ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::_Umove<ioHashString *>
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXPAVioHashString@@0@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::_Destroy
; Function compile flags: /Ogsp
;	COMDAT ?_Destroy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXPAVioHashString@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXPAVioHashString@@0@Z PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	eb 0b		 jmp	 SHORT $LN23@Destroy
$LL9@Destroy:
  00009	8b ce		 mov	 ecx, esi
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00011	83 c6 10	 add	 esi, 16			; 00000010H
$LN23@Destroy:
  00014	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00017	75 f0		 jne	 SHORT $LL9@Destroy
  00019	5e		 pop	 esi

; 1271 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
?_Destroy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXPAVioHashString@@0@Z ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::_Destroy
_TEXT	ENDS
PUBLIC	?reserve@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEXI@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::reserve
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
tv300 = -24						; size = 4
__Ptr$531406 = -20					; size = 4
__$EHRec$ = -16						; size = 16
$T534840 = 8						; size = 4
__Count$ = 8						; size = 4
?reserve@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEXI@Z PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	6a 0c		 push	 12			; 0000000cH
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?reserve@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEXI@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_catch
  0000c	8b f1		 mov	 esi, ecx

; 747  : 		if (max_size() < _Count)

  0000e	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00011	81 fb ff ff ff
	0f		 cmp	 ebx, 268435455		; 0fffffffH
  00017	76 0b		 jbe	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN59@reserve:
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	2b 06		 sub	 eax, DWORD PTR [esi]
  00029	c1 f8 04	 sar	 eax, 4
  0002c	3b c3		 cmp	 eax, ebx
  0002e	73 7a		 jae	 SHORT $LN3@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  00030	6a 00		 push	 0
  00032	53		 push	 ebx
  00033	e8 00 00 00 00	 call	 ??$_Allocate@VioHashString@@@std@@YAPAVioHashString@@IPAV1@@Z ; std::_Allocate<ioHashString>

; 752  : 
; 753  : 			_TRY_BEGIN
; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00038	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0003a	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
  0003e	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  00041	52		 push	 edx
  00042	89 45 ec	 mov	 DWORD PTR __Ptr$531406[ebp], eax
  00045	ff 75 ec	 push	 DWORD PTR __Ptr$531406[ebp]
  00048	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0004b	50		 push	 eax
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAVioHashString@@PAV1@V?$allocator@VioHashString@@@std@@@std@@YAPAVioHashString@@PAV1@00AAV?$allocator@VioHashString@@@0@@Z ; std::_Uninitialized_move<ioHashString *,ioHashString *,std::allocator<ioHashString> >

; 758  : 			_CATCH_END
; 759  : 
; 760  : 			size_type _Size = size();

  00052	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00055	8b 06		 mov	 eax, DWORD PTR [esi]
  00057	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0005b	8b f9		 mov	 edi, ecx
  0005d	83 c4 18	 add	 esp, 24			; 00000018H
  00060	2b f8		 sub	 edi, eax
  00062	89 4d e8	 mov	 DWORD PTR tv300[ebp], ecx
  00065	85 c0		 test	 eax, eax
  00067	74 24		 je	 SHORT $LN51@reserve

; 761  : 			if (this->_Myfirst != 0)
; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  00069	89 45 08	 mov	 DWORD PTR $T534840[ebp], eax
  0006c	3b c1		 cmp	 eax, ecx
  0006e	74 15		 je	 SHORT $LN37@reserve
$LN39@reserve:
  00070	8b 4d 08	 mov	 ecx, DWORD PTR $T534840[ebp]
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00079	83 45 08 10	 add	 DWORD PTR $T534840[ebp], 16 ; 00000010H
  0007d	8b 45 08	 mov	 eax, DWORD PTR $T534840[ebp]
  00080	3b 45 e8	 cmp	 eax, DWORD PTR tv300[ebp]
  00083	75 eb		 jne	 SHORT $LN39@reserve
$LN37@reserve:

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  00085	ff 36		 push	 DWORD PTR [esi]
  00087	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008c	59		 pop	 ecx
$LN51@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  0008d	8b ce		 mov	 ecx, esi
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 769  : 			this->_Myend = _Ptr + _Count;

  00095	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$531406[ebp]
  00098	c1 e3 04	 shl	 ebx, 4
  0009b	03 d8		 add	 ebx, eax

; 770  : 			this->_Mylast = _Ptr + _Size;

  0009d	83 e7 f0	 and	 edi, -16		; fffffff0H
  000a0	03 f8		 add	 edi, eax
  000a2	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  000a5	89 7e 04	 mov	 DWORD PTR [esi+4], edi

; 771  : 			this->_Myfirst = _Ptr;

  000a8	89 06		 mov	 DWORD PTR [esi], eax
$LN3@reserve:

; 772  : 			}
; 773  : 		}

  000aa	e8 00 00 00 00	 call	 __EH_epilog3
  000af	c2 04 00	 ret	 4
__catch$?reserve@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  000b2	ff 75 ec	 push	 DWORD PTR __Ptr$531406[ebp]
  000b5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000ba	59		 pop	 ecx

; 757  : 			_RERAISE;

  000bb	6a 00		 push	 0
  000bd	6a 00		 push	 0
  000bf	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN60@reserve:
$LN58@reserve:
  000c4	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEXI@Z ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::reserve
PUBLIC	?erase@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@0@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::erase
; Function compile flags: /Ogsp
;	COMDAT ?erase@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T535035 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Cat$534979 = 16					; size = 1
__Last_arg$ = 16					; size = 4
?erase@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@0@Z PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  00004	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __First_arg$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);
; 1193 : 
; 1194 : 		if (_First != _Last)

  0000f	3b 4d 10	 cmp	 ecx, DWORD PTR __Last_arg$[ebp]
  00012	74 38		 je	 SHORT $LN1@erase@2

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  00014	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00017	53		 push	 ebx
  00018	57		 push	 edi
  00019	ff 75 10	 push	 DWORD PTR __Cat$534979[ebp]
  0001c	51		 push	 ecx
  0001d	50		 push	 eax
  0001e	ff 75 10	 push	 DWORD PTR __Last_arg$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Move@PAVioHashString@@PAV1@@std@@YAPAVioHashString@@PAV1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<ioHashString *,ioHashString *>

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);

  00026	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00029	8b d8		 mov	 ebx, eax
  0002b	83 c4 10	 add	 esp, 16			; 00000010H
  0002e	89 5d fc	 mov	 DWORD PTR $T535035[ebp], ebx
  00031	3b df		 cmp	 ebx, edi
  00033	74 12		 je	 SHORT $LN36@erase@2
$LL52@erase@2:
  00035	8b 4d fc	 mov	 ecx, DWORD PTR $T535035[ebp]
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  0003e	83 45 fc 10	 add	 DWORD PTR $T535035[ebp], 16 ; 00000010H
  00042	39 7d fc	 cmp	 DWORD PTR $T535035[ebp], edi
  00045	75 ee		 jne	 SHORT $LL52@erase@2
$LN36@erase@2:

; 1211 : 			this->_Mylast = _Ptr;

  00047	5f		 pop	 edi
  00048	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0004b	5b		 pop	 ebx
$LN1@erase@2:

; 1212 : 			}
; 1213 : 		return (_First);

  0004c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0004f	5e		 pop	 esi

; 1214 : 		}

  00050	c9		 leave
  00051	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@0@Z ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXXZ ; std::vector<ioHashString,std::allocator<ioHashString> >::_Tidy
; Function compile flags: /Ogsp
;	COMDAT ?_Tidy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXXZ PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00006	74 28		 je	 SHORT $LN24@Tidy@2

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00008	53		 push	 ebx
  00009	57		 push	 edi
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  00010	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00013	8b 3e		 mov	 edi, DWORD PTR [esi]
  00015	eb 0b		 jmp	 SHORT $LN28@Tidy@2
$LL12@Tidy@2:
  00017	8b cf		 mov	 ecx, edi
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  0001f	83 c7 10	 add	 edi, 16			; 00000010H
$LN28@Tidy@2:
  00022	3b fb		 cmp	 edi, ebx
  00024	75 f1		 jne	 SHORT $LL12@Tidy@2

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002d	59		 pop	 ecx
  0002e	5f		 pop	 edi
  0002f	5b		 pop	 ebx
$LN24@Tidy@2:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00030	33 c0		 xor	 eax, eax
  00032	89 06		 mov	 DWORD PTR [esi], eax

; 1310 : 		this->_Mylast = 0;

  00034	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1311 : 		this->_Myend = 0;

  00037	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003a	5e		 pop	 esi

; 1312 : 		}

  0003b	c3		 ret	 0
?_Tidy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXXZ ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Reserve@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXI@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::_Reserve
; Function compile flags: /Ogsp
;	COMDAT ?_Reserve@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXI@Z PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1291 : 		size_type _Size = size();

  00006	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00008	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000b	2b c1		 sub	 eax, ecx

; 1292 : 		if (max_size() - _Count < _Size)

  0000d	ba ff ff ff 0f	 mov	 edx, 268435455		; 0fffffffH
  00012	2b 55 08	 sub	 edx, DWORD PTR __Count$[ebp]
  00015	c1 f8 04	 sar	 eax, 4
  00018	3b d0		 cmp	 edx, eax
  0001a	73 0b		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN21@Reserve:
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00027	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002a	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  0002d	2b d1		 sub	 edx, ecx
  0002f	c1 fa 04	 sar	 edx, 4
  00032	3b c2		 cmp	 eax, edx
  00034	76 10		 jbe	 SHORT $LN1@Reserve

; 1295 : 			;
; 1296 : 		else
; 1297 : 			reserve(_Grow_to(_Size));

  00036	50		 push	 eax
  00037	8b ce		 mov	 ecx, esi
  00039	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IBEII@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::_Grow_to
  0003e	50		 push	 eax
  0003f	8b ce		 mov	 ecx, esi
  00041	e8 00 00 00 00	 call	 ?reserve@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEXI@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::reserve
$LN1@Reserve:
  00046	5e		 pop	 esi

; 1298 : 		}

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN20@Reserve:
?_Reserve@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXI@Z ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::_Reserve
_TEXT	ENDS
PUBLIC	??1?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ ; std::vector<ioHashString,std::allocator<ioHashString> >::~vector<ioHashString,std::allocator<ioHashString> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::~vector<ioHashString,std::allocator<ioHashString> >, COMDAT
; _this$ = ecx

; 705  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXXZ ; std::vector<ioHashString,std::allocator<ioHashString> >::_Tidy
??1?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::~vector<ioHashString,std::allocator<ioHashString> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEXXZ ; std::vector<ioHashString,std::allocator<ioHashString> >::clear
; Function compile flags: /Ogsp
;	COMDAT ?clear@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T535231 = -4						; size = 4
?clear@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEXXZ PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1218 : 		erase(begin(), end());

  00004	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00007	8b 11		 mov	 edx, DWORD PTR [ecx]
  00009	50		 push	 eax
  0000a	52		 push	 edx
  0000b	8d 45 fc	 lea	 eax, DWORD PTR $T535231[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?erase@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@0@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::erase

; 1219 : 		}

  00014	c9		 leave
  00015	c3		 ret	 0
?clear@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEXXZ ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::clear
_TEXT	ENDS
EXTRN	?AttachEffect@ioBaseChar@@QAEPAVioEffect@@ABVioHashString@@PAVioEntityEvent@@_N@Z:PROC ; ioBaseChar::AttachEffect
EXTRN	?RestoreSkillProtection@ioBaseChar@@QAEXXZ:PROC	; ioBaseChar::RestoreSkillProtection
EXTRN	?SetMoveDirByRotate@ioBaseChar@@QAEXABUD3DXQUATERNION@@@Z:PROC ; ioBaseChar::SetMoveDirByRotate
EXTRN	?EndEffect@ioBaseChar@@QAEXABVioHashString@@_N1@Z:PROC ; ioBaseChar::EndEffect
EXTRN	?ShowWeaponItemMesh@ioBaseChar@@QAEX_N0@Z:PROC	; ioBaseChar::ShowWeaponItemMesh
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iorangesyncbuffskill.cpp
;	COMDAT ?OnSkillEnd@ioRangeSyncBuffSkill@@UAEXPAVioBaseChar@@@Z
_TEXT	SEGMENT
$T535433 = 8						; size = 4
$T535353 = 8						; size = 4
_pOwner$ = 8						; size = 4
?OnSkillEnd@ioRangeSyncBuffSkill@@UAEXPAVioBaseChar@@@Z PROC ; ioRangeSyncBuffSkill::OnSkillEnd, COMDAT
; _this$ = ecx

; 414  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 415  : 	//UJ 130823, CPU  state  gauge     
; 416  : 	if( !m_bReduceGauge && pOwner )

  00007	33 db		 xor	 ebx, ebx
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR _pOwner$[ebp]
  0000d	38 9e 50 03 00
	00		 cmp	 BYTE PTR [esi+848], bl
  00013	75 25		 jne	 SHORT $LN6@OnSkillEnd
  00015	3b fb		 cmp	 edi, ebx
  00017	74 21		 je	 SHORT $LN6@OnSkillEnd

; 417  : 	{
; 418  : 		pOwner->ReduceNeedGaugeBySkill( this, GetNeedGauge(pOwner->GetCharName()) );

  00019	8d 87 d4 02 00
	00		 lea	 eax, DWORD PTR [edi+724]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?GetNeedGauge@ioSkill@@QAEMABVioHashString@@@Z ; ioSkill::GetNeedGauge
  00025	51		 push	 ecx
  00026	d9 1c 24	 fstp	 DWORD PTR [esp]
  00029	56		 push	 esi
  0002a	8b cf		 mov	 ecx, edi
  0002c	e8 00 00 00 00	 call	 ?ReduceNeedGaugeBySkill@ioBaseChar@@QAEMPAVioSkill@@M@Z ; ioBaseChar::ReduceNeedGaugeBySkill
  00031	dd d8		 fstp	 ST(0)

; 419  : 		m_bReduceGauge = true;

  00033	c6 86 50 03 00
	00 01		 mov	 BYTE PTR [esi+848], 1
$LN6@OnSkillEnd:

; 420  : 	}
; 421  : 
; 422  : 	//  
; 423  : 	if( m_bUseItemMesh )

  0003a	38 9e 08 0f 00
	00		 cmp	 BYTE PTR [esi+3848], bl
  00040	74 0a		 je	 SHORT $LN5@OnSkillEnd

; 424  : 	{
; 425  : 		pOwner->ShowWeaponItemMesh( true );

  00042	53		 push	 ebx
  00043	6a 01		 push	 1
  00045	8b cf		 mov	 ecx, edi
  00047	e8 00 00 00 00	 call	 ?ShowWeaponItemMesh@ioBaseChar@@QAEX_N0@Z ; ioBaseChar::ShowWeaponItemMesh
$LN5@OnSkillEnd:

; 426  : 	}
; 427  : 
; 428  : 	//      
; 429  : 	m_bSetHandMesh = false; 
; 430  : 
; 431  : 	if( !m_StartHandMesh.IsEmpty() )

  0004c	8d 8e 60 10 00
	00		 lea	 ecx, DWORD PTR [esi+4192]
  00052	88 9e 0a 0f 00
	00		 mov	 BYTE PTR [esi+3850], bl
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  0005e	84 c0		 test	 al, al
  00060	75 18		 jne	 SHORT $LN4@OnSkillEnd

; 432  : 		pOwner->RestoreSkillWeaponMesh( this, m_StartHandMesh, m_bVisibleEquipMesh );

  00062	0f b6 86 09 0f
	00 00		 movzx	 eax, BYTE PTR [esi+3849]
  00069	53		 push	 ebx
  0006a	50		 push	 eax
  0006b	8d 86 60 10 00
	00		 lea	 eax, DWORD PTR [esi+4192]
  00071	50		 push	 eax
  00072	56		 push	 esi
  00073	8b cf		 mov	 ecx, edi
  00075	e8 00 00 00 00	 call	 ?RestoreSkillWeaponMesh@ioBaseChar@@QAE_NPAVioSkill@@ABVioHashString@@_N2@Z ; ioBaseChar::RestoreSkillWeaponMesh
$LN4@OnSkillEnd:

; 433  : 
; 434  : 	if( !m_LoopHandMesh.IsEmpty() )

  0007a	8d 8e 70 10 00
	00		 lea	 ecx, DWORD PTR [esi+4208]
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00086	84 c0		 test	 al, al
  00088	75 18		 jne	 SHORT $LN3@OnSkillEnd

; 435  : 		pOwner->RestoreSkillWeaponMesh( this, m_LoopHandMesh, m_bVisibleEquipMesh );

  0008a	0f b6 86 09 0f
	00 00		 movzx	 eax, BYTE PTR [esi+3849]
  00091	53		 push	 ebx
  00092	50		 push	 eax
  00093	8d 86 70 10 00
	00		 lea	 eax, DWORD PTR [esi+4208]
  00099	50		 push	 eax
  0009a	56		 push	 esi
  0009b	8b cf		 mov	 ecx, edi
  0009d	e8 00 00 00 00	 call	 ?RestoreSkillWeaponMesh@ioBaseChar@@QAE_NPAVioSkill@@ABVioHashString@@_N2@Z ; ioBaseChar::RestoreSkillWeaponMesh
$LN3@OnSkillEnd:

; 436  : 
; 437  : 	if( !m_EndHandMesh.IsEmpty() )

  000a2	8d 8e 80 10 00
	00		 lea	 ecx, DWORD PTR [esi+4224]
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  000ae	84 c0		 test	 al, al
  000b0	75 18		 jne	 SHORT $LN2@OnSkillEnd

; 438  : 		pOwner->RestoreSkillWeaponMesh( this, m_EndHandMesh, m_bVisibleEquipMesh );

  000b2	0f b6 86 09 0f
	00 00		 movzx	 eax, BYTE PTR [esi+3849]
  000b9	53		 push	 ebx
  000ba	50		 push	 eax
  000bb	8d 86 80 10 00
	00		 lea	 eax, DWORD PTR [esi+4224]
  000c1	50		 push	 eax
  000c2	56		 push	 esi
  000c3	8b cf		 mov	 ecx, edi
  000c5	e8 00 00 00 00	 call	 ?RestoreSkillWeaponMesh@ioBaseChar@@QAE_NPAVioSkill@@ABVioHashString@@_N2@Z ; ioBaseChar::RestoreSkillWeaponMesh
$LN2@OnSkillEnd:

; 439  : 
; 440  : 
; 441  : 	EndPreDelayEffect( pOwner );

  000ca	8b 06		 mov	 eax, DWORD PTR [esi]
  000cc	57		 push	 edi
  000cd	8b ce		 mov	 ecx, esi
  000cf	ff 90 dc 00 00
	00		 call	 DWORD PTR [eax+220]

; 442  : 	GetOwnerItem()->ClearTarget();

  000d5	8b 8e a4 02 00
	00		 mov	 ecx, DWORD PTR [esi+676]
  000db	8b 01		 mov	 eax, DWORD PTR [ecx]
  000dd	ff 50 3c	 call	 DWORD PTR [eax+60]

; 443  : 
; 444  : 	pOwner->EndEffect( m_SkillEffectName );

  000e0	6a 01		 push	 1
  000e2	6a 01		 push	 1
  000e4	8d 86 b8 01 00
	00		 lea	 eax, DWORD PTR [esi+440]
  000ea	50		 push	 eax
  000eb	8b cf		 mov	 ecx, edi
  000ed	e8 00 00 00 00	 call	 ?EndEffect@ioBaseChar@@QAEXABVioHashString@@_N1@Z ; ioBaseChar::EndEffect

; 445  : 
; 446  : 	// m_vCollisionedList.clear()  
; 447  : 	RemoveBuffList( pOwner );

  000f2	57		 push	 edi
  000f3	8b ce		 mov	 ecx, esi
  000f5	e8 00 00 00 00	 call	 ?RemoveBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@@Z ; ioRangeSyncBuffSkill::RemoveBuffList

; 448  : 
; 449  : 	m_vCollisionedList.clear();

  000fa	8d 8e 3c 10 00
	00		 lea	 ecx, DWORD PTR [esi+4156]
  00100	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00103	8b 11		 mov	 edx, DWORD PTR [ecx]
  00105	50		 push	 eax
  00106	52		 push	 edx
  00107	8d 45 08	 lea	 eax, DWORD PTR $T535353[ebp]
  0010a	50		 push	 eax
  0010b	e8 00 00 00 00	 call	 ?erase@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@0@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::erase

; 450  : 	m_vBlockedList.clear();

  00110	8d 8e 4c 10 00
	00		 lea	 ecx, DWORD PTR [esi+4172]
  00116	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00119	8b 11		 mov	 edx, DWORD PTR [ecx]
  0011b	50		 push	 eax
  0011c	52		 push	 edx
  0011d	8d 45 08	 lea	 eax, DWORD PTR $T535433[ebp]
  00120	50		 push	 eax
  00121	e8 00 00 00 00	 call	 ?erase@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@@2@0@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::erase

; 451  : 
; 452  : 	m_bReduceGauge = false;
; 453  : 	pOwner->SetMoveDirByRotate( pOwner->GetTargetRot() );

  00126	8d 87 a4 06 00
	00		 lea	 eax, DWORD PTR [edi+1700]
  0012c	50		 push	 eax
  0012d	8b cf		 mov	 ecx, edi
  0012f	88 9e 50 03 00
	00		 mov	 BYTE PTR [esi+848], bl
  00135	e8 00 00 00 00	 call	 ?SetMoveDirByRotate@ioBaseChar@@QAEXABUD3DXQUATERNION@@@Z ; ioBaseChar::SetMoveDirByRotate

; 454  : 	pOwner->RestoreSkillProtection();

  0013a	8b cf		 mov	 ecx, edi
  0013c	e8 00 00 00 00	 call	 ?RestoreSkillProtection@ioBaseChar@@QAEXXZ ; ioBaseChar::RestoreSkillProtection

; 455  : 
; 456  : 	m_SkillUseType = SUT_NORMAL;

  00141	89 5e 74	 mov	 DWORD PTR [esi+116], ebx

; 457  : 
; 458  : 	if( !m_SkillEndEffectName.IsEmpty() )

  00144	81 c6 e8 01 00
	00		 add	 esi, 488		; 000001e8H
  0014a	8b ce		 mov	 ecx, esi
  0014c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00152	84 c0		 test	 al, al
  00154	75 0b		 jne	 SHORT $LN1@OnSkillEnd

; 459  : 		pOwner->AttachEffect( m_SkillEndEffectName );

  00156	6a 01		 push	 1
  00158	53		 push	 ebx
  00159	56		 push	 esi
  0015a	8b cf		 mov	 ecx, edi
  0015c	e8 00 00 00 00	 call	 ?AttachEffect@ioBaseChar@@QAEPAVioEffect@@ABVioHashString@@PAVioEntityEvent@@_N@Z ; ioBaseChar::AttachEffect
$LN1@OnSkillEnd:
  00161	5f		 pop	 edi
  00162	5e		 pop	 esi
  00163	5b		 pop	 ebx

; 460  : }

  00164	5d		 pop	 ebp
  00165	c2 04 00	 ret	 4
?OnSkillEnd@ioRangeSyncBuffSkill@@UAEXPAVioBaseChar@@@Z ENDP ; ioRangeSyncBuffSkill::OnSkillEnd
_TEXT	ENDS
PUBLIC	?push_back@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEXABVioHashString@@@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::push_back
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?push_back@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEXABVioHashString@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEXABVioHashString@@@Z PROC ; std::vector<ioHashString,std::allocator<ioHashString> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  00006	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 29		 jae	 SHORT $LN4@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 23		 ja	 SHORT $LN4@push_back

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx

; 980  : 			if (this->_Mylast == this->_Myend)

  00019	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001c	75 09		 jne	 SHORT $LN3@push_back

; 981  : 				_Reserve(1);

  0001e	6a 01		 push	 1
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?_Reserve@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXI@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::_Reserve
$LN3@push_back:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  00027	83 e7 f0	 and	 edi, -16		; fffffff0H
  0002a	03 3e		 add	 edi, DWORD PTR [esi]
  0002c	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0002f	57		 push	 edi
  00030	ff 76 04	 push	 DWORD PTR [esi+4]
  00033	e8 00 00 00 00	 call	 ??$construct@AAVioHashString@@@?$allocator@VioHashString@@@std@@QAEXPAVioHashString@@AAV2@@Z ; std::allocator<ioHashString>::construct<ioHashString &>

; 986  : 			++this->_Mylast;
; 987  : 			}
; 988  : 		else

  00038	eb 19		 jmp	 SHORT $LN30@push_back
$LN4@push_back:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  0003a	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0003d	75 09		 jne	 SHORT $LN1@push_back

; 991  : 				_Reserve(1);

  0003f	6a 01		 push	 1
  00041	8b ce		 mov	 ecx, esi
  00043	e8 00 00 00 00	 call	 ?_Reserve@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXI@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::_Reserve
$LN1@push_back:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  00048	57		 push	 edi
  00049	ff 76 04	 push	 DWORD PTR [esi+4]
  0004c	e8 00 00 00 00	 call	 ??$_Construct@VioHashString@@ABV1@@std@@YAXPAVioHashString@@ABV1@@Z ; std::_Construct<ioHashString,ioHashString const &>
  00051	59		 pop	 ecx
  00052	59		 pop	 ecx
$LN30@push_back:

; 996  : 			++this->_Mylast;

  00053	83 46 04 10	 add	 DWORD PTR [esi+4], 16	; 00000010H
  00057	5f		 pop	 edi
  00058	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  00059	5d		 pop	 ebp
  0005a	c2 04 00	 ret	 4
?push_back@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEXABVioHashString@@@Z ENDP ; std::vector<ioHashString,std::allocator<ioHashString> >::push_back
_TEXT	ENDS
PUBLIC	??_C@_0BM@MAGKAFAH@PC?5?9SkillAddBuff14?5?3?5?$CFs?0?5?$CFd?$AA@ ; `string'
PUBLIC	_pOwner$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	??6SP2Packet@@QAEAAV0@M@Z:PROC			; SP2Packet::operator<<
EXTRN	??6SP2Packet@@QAEAAV0@_N@Z:PROC			; SP2Packet::operator<<
EXTRN	??6SP2Packet@@QAEAAV0@K@Z:PROC			; SP2Packet::operator<<
EXTRN	?CheckEnableTimeGapUser@Help@@YA_NH@Z:PROC	; Help::CheckEnableTimeGapUser
EXTRN	?SetLastAttackerName@ioBaseChar@@QAEXABVioHashString@@0@Z:PROC ; ioBaseChar::SetLastAttackerName
EXTRN	?AddNewBuffWithAnimateTime@ioBaseChar@@QAEPAVioBuff@@ABVioHashString@@00PAVioSkill@@K_N@Z:PROC ; ioBaseChar::AddNewBuffWithAnimateTime
EXTRN	?IsCanNoWound@ioBaseChar@@QAE_NXZ:PROC		; ioBaseChar::IsCanNoWound
EXTRN	?HasBuff@ioBaseChar@@QBE_NH@Z:PROC		; ioBaseChar::HasBuff
EXTRN	?IsHasCrown@ioBaseChar@@QBE_NXZ:PROC		; ioBaseChar::IsHasCrown
EXTRN	?GetValue@ioGrowthNormalUpInfo@@QAEMPAVioPlayStage@@@Z:PROC ; ioGrowthNormalUpInfo::GetValue
EXTRN	?GetPlayStage@ioSkillMaker@@QAEPAVioPlayStage@@XZ:PROC ; ioSkillMaker::GetPlayStage
EXTRN	?GetSingleton@ioSkillMaker@@SAAAV1@XZ:PROC	; ioSkillMaker::GetSingleton
EXTRN	?GetGrowthUpInfoByType@ioSkill@@QAEPAVioGrowthUpInfo@@HABVioHashString@@@Z:PROC ; ioSkill::GetGrowthUpInfoByType
EXTRN	__imp_??0ioHashString@@QAE@XZ:PROC
EXTRN	?SetRandomSeed@ioBaseChar@@QAEXK@Z:PROC		; ioBaseChar::SetRandomSeed
EXTRN	?SetProtectWound@ioBaseChar@@QAEXH@Z:PROC	; ioBaseChar::SetProtectWound
EXTRN	?IsBlocked@ioRangeSkill@@IAE_NPAVioBaseChar@@@Z:PROC ; ioRangeSkill::IsBlocked
EXTRN	?CheckBlockEmoticonType@ioBaseChar@@QAEHXZ:PROC	; ioBaseChar::CheckBlockEmoticonType
EXTRN	?IsProtectState@ioBaseChar@@QAE_NXZ:PROC	; ioBaseChar::IsProtectState
;	COMDAT ??_C@_0BM@MAGKAFAH@PC?5?9SkillAddBuff14?5?3?5?$CFs?0?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BM@MAGKAFAH@PC?5?9SkillAddBuff14?5?3?5?$CFs?0?5?$CFd?$AA@ DB 'PC -'
	DB	'SkillAddBuff14 : %s, %d', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetEnemyBuffList@ioRangeSyncBuffSkill@@MAE_NPAVioBaseChar@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetEnemyBuffList@ioRangeSyncBuffSkill@@MAE_NPAVioBaseChar@@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SetEnemyBuffList@ioRangeSyncBuffSkill@@MAE_NPAVioBaseChar@@0@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?SetEnemyBuffList@ioRangeSyncBuffSkill@@MAE_NPAVioBaseChar@@0@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?SetEnemyBuffList@ioRangeSyncBuffSkill@@MAE_NPAVioBaseChar@@0@Z$3
__ehfuncinfo$?SetEnemyBuffList@ioRangeSyncBuffSkill@@MAE_NPAVioBaseChar@@0@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetEnemyBuffList@ioRangeSyncBuffSkill@@MAE_NPAVioBaseChar@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iorangesyncbuffskill.cpp
xdata$x	ENDS
;	COMDAT ?SetEnemyBuffList@ioRangeSyncBuffSkill@@MAE_NPAVioBaseChar@@0@Z
_TEXT	SEGMENT
_szItemName$ = -65660					; size = 16
_vBuffList$ = -65644					; size = 16
_fValue$ = -65628					; size = 4
tv643 = -65624						; size = 4
_pOwner$GSCopy$ = -65620				; size = 4
tv549 = -65616						; size = 4
_pBuff$530981 = -65616					; size = 4
tv515 = -65612						; size = 4
tv258 = -65608						; size = 4
_pUpinfo$ = -65608					; size = 4
_value$535559 = -65602					; size = 1
_bResult$ = -65601					; size = 1
_kPacket2$530993 = -65600				; size = 32792
_kPacket$530989 = -32808				; size = 32792
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pOwner$ = 8						; size = 4
_pChar$ = 12						; size = 4
?SetEnemyBuffList@ioRangeSyncBuffSkill@@MAE_NPAVioBaseChar@@0@Z PROC ; ioRangeSyncBuffSkill::SetEnemyBuffList, COMDAT
; _this$ = ecx

; 127  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SetEnemyBuffList@ioRangeSyncBuffSkill@@MAE_NPAVioBaseChar@@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 70 00 01 00	 mov	 eax, 65648		; 00010070H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 234  : 	}
; 235  : 
; 236  : 	return bResult;

  00032	8b 45 08	 mov	 eax, DWORD PTR _pOwner$[ebp]
  00035	8b 7d 0c	 mov	 edi, DWORD PTR _pChar$[ebp]
  00038	8b f1		 mov	 esi, ecx
  0003a	8b cf		 mov	 ecx, edi
  0003c	89 85 ac ff fe
	ff		 mov	 DWORD PTR _pOwner$GSCopy$[ebp], eax
  00042	e8 00 00 00 00	 call	 ?IsProtectState@ioBaseChar@@QAE_NXZ ; ioBaseChar::IsProtectState
  00047	84 c0		 test	 al, al
  00049	74 3a		 je	 SHORT $LN23@SetEnemyBu

; 128  : 	if( pChar->IsProtectState() )
; 129  : 	{
; 130  : 		int iType = pChar->CheckBlockEmoticonType();

  0004b	8b cf		 mov	 ecx, edi
  0004d	e8 00 00 00 00	 call	 ?CheckBlockEmoticonType@ioBaseChar@@QAEHXZ ; ioBaseChar::CheckBlockEmoticonType
  00052	8b d8		 mov	 ebx, eax

; 131  : 		if( iType >= 0 && !IsBlocked( pChar ) )

  00054	85 db		 test	 ebx, ebx
  00056	78 26		 js	 SHORT $LN22@SetEnemyBu
  00058	57		 push	 edi
  00059	8b ce		 mov	 ecx, esi
  0005b	e8 00 00 00 00	 call	 ?IsBlocked@ioRangeSkill@@IAE_NPAVioBaseChar@@@Z ; ioRangeSkill::IsBlocked
  00060	84 c0		 test	 al, al
  00062	75 1a		 jne	 SHORT $LN22@SetEnemyBu

; 132  : 		{
; 133  : 			m_vBlockedList.push_back( pChar->GetCharName() );

  00064	8d 87 d4 02 00
	00		 lea	 eax, DWORD PTR [edi+724]
  0006a	50		 push	 eax
  0006b	8d 8e 4c 10 00
	00		 lea	 ecx, DWORD PTR [esi+4172]
  00071	e8 00 00 00 00	 call	 ?push_back@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEXABVioHashString@@@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::push_back

; 134  : 			pChar->SetProtectWound( iType );

  00076	53		 push	 ebx
  00077	8b cf		 mov	 ecx, edi
  00079	e8 00 00 00 00	 call	 ?SetProtectWound@ioBaseChar@@QAEXH@Z ; ioBaseChar::SetProtectWound
$LN22@SetEnemyBu:

; 135  : 		}
; 136  : 
; 137  : 		return false;

  0007e	32 c0		 xor	 al, al
  00080	e9 fd 03 00 00	 jmp	 $LN24@SetEnemyBu
$LN23@SetEnemyBu:

; 138  : 	}
; 139  : 
; 140  : 	if( m_EnemyBuffList.empty() )

  00085	8b 86 18 10 00
	00		 mov	 eax, DWORD PTR [esi+4120]
  0008b	3b 86 1c 10 00
	00		 cmp	 eax, DWORD PTR [esi+4124]

; 141  : 		return false;

  00091	74 eb		 je	 SHORT $LN22@SetEnemyBu

; 142  : 
; 143  : 	pChar->SetRandomSeed( 0 );

  00093	33 db		 xor	 ebx, ebx
  00095	53		 push	 ebx
  00096	8b cf		 mov	 ecx, edi
  00098	e8 00 00 00 00	 call	 ?SetRandomSeed@ioBaseChar@@QAEXK@Z ; ioBaseChar::SetRandomSeed

; 144  : 
; 145  : 	bool bResult = false;

  0009d	88 9d bf ff fe
	ff		 mov	 BYTE PTR _bResult$[ebp], bl

; 146  : 	ioHashStringVec vBuffList;

  000a3	89 9d 94 ff fe
	ff		 mov	 DWORD PTR _vBuffList$[ebp], ebx
  000a9	89 9d 98 ff fe
	ff		 mov	 DWORD PTR _vBuffList$[ebp+4], ebx
  000af	89 9d 9c ff fe
	ff		 mov	 DWORD PTR _vBuffList$[ebp+8], ebx

; 147  : 
; 148  : 	ioHashString szItemName;

  000b5	8d 8d 84 ff fe
	ff		 lea	 ecx, DWORD PTR _szItemName$[ebp]
  000bb	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ

; 149  : 	ioItem *pItem = GetOwnerItem();

  000c4	8b 86 a4 02 00
	00		 mov	 eax, DWORD PTR [esi+676]
  000ca	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 150  : 	if( pItem )

  000ce	3b c3		 cmp	 eax, ebx
  000d0	74 12		 je	 SHORT $LN20@SetEnemyBu

; 151  : 	{
; 152  : 		szItemName = pItem->GetName();

  000d2	05 34 01 00 00	 add	 eax, 308		; 00000134H
  000d7	50		 push	 eax
  000d8	8d 8d 84 ff fe
	ff		 lea	 ecx, DWORD PTR _szItemName$[ebp]
  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@ABV0@@Z
$LN20@SetEnemyBu:

; 153  : 	}
; 154  : 
; 155  : 	float fValue = 0.0f;

  000e4	0f 57 c0	 xorps	 xmm0, xmm0

; 156  : 	ioGrowthNormalUpInfo *pUpinfo = ToNormalUpInfo( GetGrowthUpInfoByType(GT_BUFF_DURATION, pChar->GetCharName()) );

  000e7	8d 87 d4 02 00
	00		 lea	 eax, DWORD PTR [edi+724]
  000ed	50		 push	 eax
  000ee	6a 0f		 push	 15			; 0000000fH
  000f0	8b ce		 mov	 ecx, esi
  000f2	f3 0f 11 85 a4
	ff fe ff	 movss	 DWORD PTR _fValue$[ebp], xmm0
  000fa	89 85 b4 ff fe
	ff		 mov	 DWORD PTR tv515[ebp], eax
  00100	e8 00 00 00 00	 call	 ?GetGrowthUpInfoByType@ioSkill@@QAEPAVioGrowthUpInfo@@HABVioHashString@@@Z ; ioSkill::GetGrowthUpInfoByType
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 ?ToNormalUpInfo@@YAPAVioGrowthNormalUpInfo@@PAVioGrowthUpInfo@@@Z ; ToNormalUpInfo
  0010b	59		 pop	 ecx
  0010c	89 85 b8 ff fe
	ff		 mov	 DWORD PTR _pUpinfo$[ebp], eax

; 157  : 	if( pUpinfo )

  00112	3b c3		 cmp	 eax, ebx
  00114	74 1e		 je	 SHORT $LN19@SetEnemyBu

; 158  : 	{
; 159  : 		ioPlayStage *pStage = g_SkillMaker.GetPlayStage();

  00116	e8 00 00 00 00	 call	 ?GetSingleton@ioSkillMaker@@SAAAV1@XZ ; ioSkillMaker::GetSingleton
  0011b	8b c8		 mov	 ecx, eax
  0011d	e8 00 00 00 00	 call	 ?GetPlayStage@ioSkillMaker@@QAEPAVioPlayStage@@XZ ; ioSkillMaker::GetPlayStage

; 160  : 		fValue = pUpinfo->GetValue(pStage);

  00122	8b 8d b8 ff fe
	ff		 mov	 ecx, DWORD PTR _pUpinfo$[ebp]
  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 ?GetValue@ioGrowthNormalUpInfo@@QAEMPAVioPlayStage@@@Z ; ioGrowthNormalUpInfo::GetValue
  0012e	d9 9d a4 ff fe
	ff		 fstp	 DWORD PTR _fValue$[ebp]
$LN19@SetEnemyBu:

; 161  : 	}
; 162  : 
; 163  : 	int iCnt = m_EnemyBuffList.size();

  00134	8b 86 1c 10 00
	00		 mov	 eax, DWORD PTR [esi+4124]
  0013a	2b 86 18 10 00
	00		 sub	 eax, DWORD PTR [esi+4120]
  00140	6a 14		 push	 20			; 00000014H
  00142	99		 cdq
  00143	59		 pop	 ecx
  00144	f7 f9		 idiv	 ecx

; 164  : 	for( int i=0; i < iCnt; ++i )

  00146	3b c3		 cmp	 eax, ebx
  00148	0f 8e 0f 03 00
	00		 jle	 $LN5@SetEnemyBu

; 161  : 	}
; 162  : 
; 163  : 	int iCnt = m_EnemyBuffList.size();

  0014e	89 9d a8 ff fe
	ff		 mov	 DWORD PTR tv643[ebp], ebx
  00154	89 85 b8 ff fe
	ff		 mov	 DWORD PTR tv258[ebp], eax
$LN18@SetEnemyBu:

; 165  : 	{
; 166  : 		const ioHashString& szBuffName = m_EnemyBuffList[i].m_BuffName;

  0015a	8b 9e 18 10 00
	00		 mov	 ebx, DWORD PTR [esi+4120]
  00160	03 9d a8 ff fe
	ff		 add	 ebx, DWORD PTR tv643[ebp]

; 167  : 
; 168  : 		if( pChar->IsHasCrown() && m_bDisableKingSkill )

  00166	8b cf		 mov	 ecx, edi
  00168	e8 00 00 00 00	 call	 ?IsHasCrown@ioBaseChar@@QBE_NXZ ; ioBaseChar::IsHasCrown
  0016d	84 c0		 test	 al, al
  0016f	74 1f		 je	 SHORT $LN15@SetEnemyBu
  00171	8d 85 be ff fe
	ff		 lea	 eax, DWORD PTR _value$535559[ebp]
  00177	50		 push	 eax
  00178	8d 8e c4 07 00
	00		 lea	 ecx, DWORD PTR [esi+1988]
  0017e	e8 00 00 00 00	 call	 ?DecryptValueToPool@?$CEncrypt@_N@@QAEXPA_N@Z ; CEncrypt<bool>::DecryptValueToPool
  00183	80 bd be ff fe
	ff 00		 cmp	 BYTE PTR _value$535559[ebp], 0
  0018a	0f 85 b9 00 00
	00		 jne	 $LN17@SetEnemyBu
$LN15@SetEnemyBu:

; 169  : 		{
; 170  : 			continue;
; 171  : 		}
; 172  : 		else if( pChar->HasBuff( BT_ABSOLUTE_PROTECTION ) || pChar->HasBuff(BT_NOT_MOVE_PROTECT) )

  00190	6a 1d		 push	 29			; 0000001dH
  00192	8b cf		 mov	 ecx, edi
  00194	e8 00 00 00 00	 call	 ?HasBuff@ioBaseChar@@QBE_NH@Z ; ioBaseChar::HasBuff
  00199	84 c0		 test	 al, al
  0019b	0f 85 a8 00 00
	00		 jne	 $LN17@SetEnemyBu
  001a1	6a 48		 push	 72			; 00000048H
  001a3	8b cf		 mov	 ecx, edi
  001a5	e8 00 00 00 00	 call	 ?HasBuff@ioBaseChar@@QBE_NH@Z ; ioBaseChar::HasBuff
  001aa	84 c0		 test	 al, al
  001ac	0f 85 97 00 00
	00		 jne	 $LN17@SetEnemyBu

; 173  : 			continue;
; 174  : 		else if( pChar->IsCanNoWound() )

  001b2	8b cf		 mov	 ecx, edi
  001b4	e8 00 00 00 00	 call	 ?IsCanNoWound@ioBaseChar@@QAE_NXZ ; ioBaseChar::IsCanNoWound
  001b9	84 c0		 test	 al, al
  001bb	0f 85 88 00 00
	00		 jne	 $LN17@SetEnemyBu

; 175  : 			continue;
; 176  : 
; 177  : 		if( !szBuffName.IsEmpty() )

  001c1	8b cb		 mov	 ecx, ebx
  001c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  001c9	84 c0		 test	 al, al
  001cb	75 7c		 jne	 SHORT $LN17@SetEnemyBu

; 178  : 		{
; 179  : 			ioBuff *pBuff = pChar->AddNewBuffWithAnimateTime( szBuffName, pOwner->GetCharName(), szItemName, this, GetSkillMotionTime() );

  001cd	6a 00		 push	 0
  001cf	8b ce		 mov	 ecx, esi
  001d1	e8 00 00 00 00	 call	 ?GetSkillMotionTime@ioSkill@@QBEKXZ ; ioSkill::GetSkillMotionTime
  001d6	50		 push	 eax
  001d7	56		 push	 esi
  001d8	8d 85 84 ff fe
	ff		 lea	 eax, DWORD PTR _szItemName$[ebp]
  001de	50		 push	 eax
  001df	8b 85 ac ff fe
	ff		 mov	 eax, DWORD PTR _pOwner$GSCopy$[ebp]
  001e5	05 d4 02 00 00	 add	 eax, 724		; 000002d4H
  001ea	50		 push	 eax
  001eb	53		 push	 ebx
  001ec	8b cf		 mov	 ecx, edi
  001ee	e8 00 00 00 00	 call	 ?AddNewBuffWithAnimateTime@ioBaseChar@@QAEPAVioBuff@@ABVioHashString@@00PAVioSkill@@K_N@Z ; ioBaseChar::AddNewBuffWithAnimateTime
  001f3	89 85 b0 ff fe
	ff		 mov	 DWORD PTR _pBuff$530981[ebp], eax

; 180  : 			if( pBuff )

  001f9	85 c0		 test	 eax, eax
  001fb	74 4c		 je	 SHORT $LN17@SetEnemyBu

; 181  : 			{
; 182  : 				if( m_bEnableAttacker )

  001fd	80 be 6c 0f 00
	00 00		 cmp	 BYTE PTR [esi+3948], 0
  00204	74 17		 je	 SHORT $LN7@SetEnemyBu

; 183  : 				{
; 184  : 					pChar->SetLastAttackerName( pOwner->GetCharName(), GetName() );

  00206	8d 46 24	 lea	 eax, DWORD PTR [esi+36]
  00209	50		 push	 eax
  0020a	8b 85 ac ff fe
	ff		 mov	 eax, DWORD PTR _pOwner$GSCopy$[ebp]
  00210	05 d4 02 00 00	 add	 eax, 724		; 000002d4H
  00215	50		 push	 eax
  00216	8b cf		 mov	 ecx, edi
  00218	e8 00 00 00 00	 call	 ?SetLastAttackerName@ioBaseChar@@QAEXABVioHashString@@0@Z ; ioBaseChar::SetLastAttackerName
$LN7@SetEnemyBu:

; 185  : 				}
; 186  : 
; 187  : 				pBuff->SetExtraDurationByGrowth( fValue );

  0021d	8b 8d b0 ff fe
	ff		 mov	 ecx, DWORD PTR _pBuff$530981[ebp]
  00223	f3 0f 10 85 a4
	ff fe ff	 movss	 xmm0, DWORD PTR _fValue$[ebp]
  0022b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0022d	51		 push	 ecx
  0022e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00233	ff 50 3c	 call	 DWORD PTR [eax+60]

; 188  : 
; 189  : 				vBuffList.push_back( szBuffName );

  00236	53		 push	 ebx
  00237	8d 8d 94 ff fe
	ff		 lea	 ecx, DWORD PTR _vBuffList$[ebp]
  0023d	e8 00 00 00 00	 call	 ?push_back@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEXABVioHashString@@@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::push_back

; 190  : 				bResult = true;

  00242	c6 85 bf ff fe
	ff 01		 mov	 BYTE PTR _bResult$[ebp], 1
$LN17@SetEnemyBu:

; 164  : 	for( int i=0; i < iCnt; ++i )

  00249	83 85 a8 ff fe
	ff 14		 add	 DWORD PTR tv643[ebp], 20 ; 00000014H
  00250	ff 8d b8 ff fe
	ff		 dec	 DWORD PTR tv258[ebp]
  00256	0f 85 fe fe ff
	ff		 jne	 $LN18@SetEnemyBu

; 191  : 			}
; 192  : 		}
; 193  : 	}
; 194  : 
; 195  : 	if( bResult )

  0025c	80 bd bf ff fe
	ff 00		 cmp	 BYTE PTR _bResult$[ebp], 0
  00263	0f 84 f4 01 00
	00		 je	 $LN5@SetEnemyBu

; 196  : 	{
; 197  : 		m_vCollisionedList.push_back( pChar->GetCharName() );

  00269	ff b5 b4 ff fe
	ff		 push	 DWORD PTR tv515[ebp]
  0026f	8d 8e 3c 10 00
	00		 lea	 ecx, DWORD PTR [esi+4156]
  00275	e8 00 00 00 00	 call	 ?push_back@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEXABVioHashString@@@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::push_back

; 198  : 
; 199  : 		int iCurBuffCnt = vBuffList.size();

  0027a	8b 9d 98 ff fe
	ff		 mov	 ebx, DWORD PTR _vBuffList$[ebp+4]
  00280	2b 9d 94 ff fe
	ff		 sub	 ebx, DWORD PTR _vBuffList$[ebp]

; 200  : 		if( pChar->IsNeedSendNetwork() )

  00286	8b 07		 mov	 eax, DWORD PTR [edi]
  00288	8b cf		 mov	 ecx, edi
  0028a	c1 fb 04	 sar	 ebx, 4
  0028d	ff 90 04 01 00
	00		 call	 DWORD PTR [eax+260]
  00293	84 c0		 test	 al, al
  00295	0f 84 c2 01 00
	00		 je	 $LN5@SetEnemyBu

; 201  : 		{
; 202  : 			if( Help::CheckEnableTimeGapUser() )

  0029b	6a 00		 push	 0
  0029d	e8 00 00 00 00	 call	 ?CheckEnableTimeGapUser@Help@@YA_NH@Z ; Help::CheckEnableTimeGapUser
  002a2	59		 pop	 ecx
  002a3	84 c0		 test	 al, al
  002a5	74 2f		 je	 SHORT $LN4@SetEnemyBu

; 203  : 			{
; 204  : 				LOG.PrintTimeAndLog( 0, "PC -SkillAddBuff14 : %s, %d", GetName().c_str(), FRAMEGETTIME() );

  002a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioFrameTimer@@SAAAV1@XZ
  002ad	8b c8		 mov	 ecx, eax
  002af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLoopSec@ioFrameTimer@@QBEKXZ
  002b5	50		 push	 eax
  002b6	8d 4e 24	 lea	 ecx, DWORD PTR [esi+36]
  002b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  002bf	50		 push	 eax
  002c0	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@MAGKAFAH@PC?5?9SkillAddBuff14?5?3?5?$CFs?0?5?$CFd?$AA@
  002c5	6a 00		 push	 0
  002c7	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_?LOG@@3VCLog@@A
  002cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PrintTimeAndLog@CLog@@QAAXHPADZZ
  002d3	83 c4 14	 add	 esp, 20			; 00000014H
$LN4@SetEnemyBu:

; 205  : 			}
; 206  : 			SP2Packet kPacket( CUPK_ADD_NEW_BUFF );

  002d6	68 31 41 00 00	 push	 16689			; 00004131H
  002db	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$530989[ebp]
  002e1	e8 00 00 00 00	 call	 ??0SP2Packet@@QAE@K@Z	; SP2Packet::SP2Packet

; 207  : 			kPacket << pChar->GetCharName();

  002e6	ff b5 b4 ff fe
	ff		 push	 DWORD PTR tv515[ebp]
  002ec	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$530989[ebp]
  002f2	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  002f6	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z ; SP2Packet::operator<<

; 208  : 			kPacket << pOwner->GetCharName();

  002fb	8b 85 ac ff fe
	ff		 mov	 eax, DWORD PTR _pOwner$GSCopy$[ebp]
  00301	05 d4 02 00 00	 add	 eax, 724		; 000002d4H
  00306	50		 push	 eax
  00307	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$530989[ebp]
  0030d	89 85 b0 ff fe
	ff		 mov	 DWORD PTR tv549[ebp], eax
  00313	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z ; SP2Packet::operator<<

; 209  : 			kPacket << szItemName;

  00318	8d 85 84 ff fe
	ff		 lea	 eax, DWORD PTR _szItemName$[ebp]
  0031e	50		 push	 eax
  0031f	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$530989[ebp]
  00325	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z ; SP2Packet::operator<<

; 210  : 			kPacket << pChar->GetRandomSeed();

  0032a	ff b7 74 16 00
	00		 push	 DWORD PTR [edi+5748]
  00330	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$530989[ebp]
  00336	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@K@Z ; SP2Packet::operator<<

; 211  : 			kPacket << true;					//  

  0033b	6a 01		 push	 1
  0033d	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$530989[ebp]
  00343	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@_N@Z ; SP2Packet::operator<<

; 212  : 			kPacket << 0.0f;

  00348	0f 57 c0	 xorps	 xmm0, xmm0
  0034b	51		 push	 ecx
  0034c	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$530989[ebp]
  00352	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00357	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@M@Z ; SP2Packet::operator<<

; 213  : 			kPacket << fValue;

  0035c	f3 0f 10 85 a4
	ff fe ff	 movss	 xmm0, DWORD PTR _fValue$[ebp]
  00364	51		 push	 ecx
  00365	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$530989[ebp]
  0036b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00370	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@M@Z ; SP2Packet::operator<<

; 214  : 			kPacket << 0.0f;

  00375	0f 57 c0	 xorps	 xmm0, xmm0
  00378	51		 push	 ecx
  00379	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$530989[ebp]
  0037f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00384	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@M@Z ; SP2Packet::operator<<

; 215  : 			kPacket << COWT_NONE;				// Check CloseOrderBuff(12.07.13 )

  00389	33 ff		 xor	 edi, edi
  0038b	57		 push	 edi
  0038c	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$530989[ebp]
  00392	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@H@Z ; SP2Packet::operator<<

; 216  : 			kPacket << iCurBuffCnt;

  00397	53		 push	 ebx
  00398	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$530989[ebp]
  0039e	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@H@Z ; SP2Packet::operator<<

; 217  : 
; 218  : 			for( i=0; i < iCurBuffCnt; i++ )

  003a3	3b df		 cmp	 ebx, edi
  003a5	7e 1a		 jle	 SHORT $LN1@SetEnemyBu
$LL3@SetEnemyBu:
  003a7	8b 85 94 ff fe
	ff		 mov	 eax, DWORD PTR _vBuffList$[ebp]
  003ad	03 c7		 add	 eax, edi

; 219  : 			{
; 220  : 				kPacket << vBuffList[i];

  003af	50		 push	 eax
  003b0	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$530989[ebp]
  003b6	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z ; SP2Packet::operator<<
  003bb	83 c7 10	 add	 edi, 16			; 00000010H
  003be	4b		 dec	 ebx
  003bf	75 e6		 jne	 SHORT $LL3@SetEnemyBu
$LN1@SetEnemyBu:

; 221  : 			}
; 222  : 
; 223  : 			kPacket << false;					// Use Force

  003c1	33 ff		 xor	 edi, edi
  003c3	57		 push	 edi
  003c4	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$530989[ebp]
  003ca	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@_N@Z ; SP2Packet::operator<<

; 224  : 
; 225  : 			P2PNetwork::SendToAllPlayingUser( kPacket );

  003cf	8d 85 d8 7f ff
	ff		 lea	 eax, DWORD PTR _kPacket$530989[ebp]
  003d5	57		 push	 edi
  003d6	50		 push	 eax
  003d7	e8 00 00 00 00	 call	 ?SendToAllPlayingUser@P2PNetwork@@YAXAAVSP2Packet@@PAVioBaseChar@@@Z ; P2PNetwork::SendToAllPlayingUser
  003dc	59		 pop	 ecx
  003dd	59		 pop	 ecx

; 226  : 
; 227  : 			SP2Packet kPacket2( CUPK_SKILL_EXTRA_INFO );

  003de	68 39 41 00 00	 push	 16697			; 00004139H
  003e3	8d 8d c0 ff fe
	ff		 lea	 ecx, DWORD PTR _kPacket2$530993[ebp]
  003e9	e8 00 00 00 00	 call	 ??0SP2Packet@@QAE@K@Z	; SP2Packet::SP2Packet

; 228  : 			kPacket2 << pOwner->GetCharName();

  003ee	ff b5 b0 ff fe
	ff		 push	 DWORD PTR tv549[ebp]
  003f4	8d 8d c0 ff fe
	ff		 lea	 ecx, DWORD PTR _kPacket2$530993[ebp]
  003fa	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  003fe	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z ; SP2Packet::operator<<

; 229  : 			kPacket2 << GetName();

  00403	83 c6 24	 add	 esi, 36			; 00000024H
  00406	56		 push	 esi
  00407	8d 8d c0 ff fe
	ff		 lea	 ecx, DWORD PTR _kPacket2$530993[ebp]
  0040d	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z ; SP2Packet::operator<<

; 230  : 			kPacket2 << ESI_COLLISION;

  00412	6a 02		 push	 2
  00414	8d 8d c0 ff fe
	ff		 lea	 ecx, DWORD PTR _kPacket2$530993[ebp]
  0041a	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@H@Z ; SP2Packet::operator<<

; 231  : 			kPacket2 << pChar->GetCharName();

  0041f	ff b5 b4 ff fe
	ff		 push	 DWORD PTR tv515[ebp]
  00425	8d 8d c0 ff fe
	ff		 lea	 ecx, DWORD PTR _kPacket2$530993[ebp]
  0042b	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABVioHashString@@@Z ; SP2Packet::operator<<

; 232  : 			P2PNetwork::SendToAllPlayingUser( kPacket2 );

  00430	8d 85 c0 ff fe
	ff		 lea	 eax, DWORD PTR _kPacket2$530993[ebp]
  00436	57		 push	 edi
  00437	50		 push	 eax
  00438	e8 00 00 00 00	 call	 ?SendToAllPlayingUser@P2PNetwork@@YAXAAVSP2Packet@@PAVioBaseChar@@@Z ; P2PNetwork::SendToAllPlayingUser
  0043d	59		 pop	 ecx
  0043e	59		 pop	 ecx

; 233  : 		}

  0043f	8d 8d c0 ff fe
	ff		 lea	 ecx, DWORD PTR _kPacket2$530993[ebp]
  00445	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00449	e8 00 00 00 00	 call	 ??1SP2Packet@@UAE@XZ	; SP2Packet::~SP2Packet
  0044e	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$530989[ebp]
  00454	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00458	e8 00 00 00 00	 call	 ??1SP2Packet@@UAE@XZ	; SP2Packet::~SP2Packet
$LN5@SetEnemyBu:

; 234  : 	}
; 235  : 
; 236  : 	return bResult;

  0045d	8d 8d 84 ff fe
	ff		 lea	 ecx, DWORD PTR _szItemName$[ebp]
  00463	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00467	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  0046d	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00471	8d 8d 94 ff fe
	ff		 lea	 ecx, DWORD PTR _vBuffList$[ebp]
  00477	e8 00 00 00 00	 call	 ?_Tidy@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@IAEXXZ ; std::vector<ioHashString,std::allocator<ioHashString> >::_Tidy
  0047c	8a 85 bf ff fe
	ff		 mov	 al, BYTE PTR _bResult$[ebp]
$LN24@SetEnemyBu:

; 237  : }

  00482	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00485	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0048c	59		 pop	 ecx
  0048d	5f		 pop	 edi
  0048e	5e		 pop	 esi
  0048f	5b		 pop	 ebx
  00490	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00493	33 cd		 xor	 ecx, ebp
  00495	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0049a	c9		 leave
  0049b	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetEnemyBuffList@ioRangeSyncBuffSkill@@MAE_NPAVioBaseChar@@0@Z$0:
  00000	8d 8d 94 ff fe
	ff		 lea	 ecx, DWORD PTR _vBuffList$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAE@XZ ; std::vector<ioHashString,std::allocator<ioHashString> >::~vector<ioHashString,std::allocator<ioHashString> >
__unwindfunclet$?SetEnemyBuffList@ioRangeSyncBuffSkill@@MAE_NPAVioBaseChar@@0@Z$1:
  0000b	8d 8d 84 ff fe
	ff		 lea	 ecx, DWORD PTR _szItemName$[ebp]
  00011	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__unwindfunclet$?SetEnemyBuffList@ioRangeSyncBuffSkill@@MAE_NPAVioBaseChar@@0@Z$2:
  00017	8d 8d d8 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$530989[ebp]
  0001d	e9 00 00 00 00	 jmp	 ??1SP2Packet@@UAE@XZ	; SP2Packet::~SP2Packet
__unwindfunclet$?SetEnemyBuffList@ioRangeSyncBuffSkill@@MAE_NPAVioBaseChar@@0@Z$3:
  00022	8d 8d c0 ff fe
	ff		 lea	 ecx, DWORD PTR _kPacket2$530993[ebp]
  00028	e9 00 00 00 00	 jmp	 ??1SP2Packet@@UAE@XZ	; SP2Packet::~SP2Packet
__ehhandler$?SetEnemyBuffList@ioRangeSyncBuffSkill@@MAE_NPAVioBaseChar@@0@Z:
  0002d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00031	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00034	8b 8a 80 ff fe
	ff		 mov	 ecx, DWORD PTR [edx-65664]
  0003a	33 c8		 xor	 ecx, eax
  0003c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00041	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00044	33 c8		 xor	 ecx, eax
  00046	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetEnemyBuffList@ioRangeSyncBuffSkill@@MAE_NPAVioBaseChar@@0@Z
  00050	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetEnemyBuffList@ioRangeSyncBuffSkill@@MAE_NPAVioBaseChar@@0@Z ENDP ; ioRangeSyncBuffSkill::SetEnemyBuffList
PUBLIC	?ApplySetCollisioned@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z ; ioRangeSyncBuffSkill::ApplySetCollisioned
EXTRN	??5SP2Packet@@QAEAAV0@AAVioHashString@@@Z:PROC	; SP2Packet::operator>>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ApplySetCollisioned@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ApplySetCollisioned@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z$0
__ehfuncinfo$?ApplySetCollisioned@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ApplySetCollisioned@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ?ApplySetCollisioned@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z
_TEXT	SEGMENT
_szName$ = -28						; size = 16
__$EHRec$ = -12						; size = 12
_pOwner$ = 8						; size = 4
_pStage$ = 12						; size = 4
_rkPacket$ = 16						; size = 4
?ApplySetCollisioned@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z PROC ; ioRangeSyncBuffSkill::ApplySetCollisioned, COMDAT
; _this$ = ecx

; 405  : {

  00000	6a 10		 push	 16			; 00000010H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?ApplySetCollisioned@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx

; 406  : 	ioHashString szName;

  0000e	8d 4d e4	 lea	 ecx, DWORD PTR _szName$[ebp]
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ

; 407  : 	rkPacket >> szName;

  00017	8b 4d 10	 mov	 ecx, DWORD PTR _rkPacket$[ebp]
  0001a	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0001e	8d 45 e4	 lea	 eax, DWORD PTR _szName$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??5SP2Packet@@QAEAAV0@AAVioHashString@@@Z ; SP2Packet::operator>>

; 408  : 
; 409  : 	if( !szName.IsEmpty() )

  00027	8d 4d e4	 lea	 ecx, DWORD PTR _szName$[ebp]
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00030	84 c0		 test	 al, al
  00032	75 0f		 jne	 SHORT $LN1@ApplySetCo

; 410  : 		m_vCollisionedList.push_back( szName );

  00034	8d 45 e4	 lea	 eax, DWORD PTR _szName$[ebp]
  00037	50		 push	 eax
  00038	8d 8e 3c 10 00
	00		 lea	 ecx, DWORD PTR [esi+4156]
  0003e	e8 00 00 00 00	 call	 ?push_back@?$vector@VioHashString@@V?$allocator@VioHashString@@@std@@@std@@QAEXABVioHashString@@@Z ; std::vector<ioHashString,std::allocator<ioHashString> >::push_back
$LN1@ApplySetCo:

; 411  : }

  00043	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00047	8d 4d e4	 lea	 ecx, DWORD PTR _szName$[ebp]
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00050	e8 00 00 00 00	 call	 __EH_epilog3
  00055	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ApplySetCollisioned@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR _szName$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$?ApplySetCollisioned@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ApplySetCollisioned@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ApplySetCollisioned@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z ENDP ; ioRangeSyncBuffSkill::ApplySetCollisioned
EXTRN	??5SP2Packet@@QAEAAV0@AAH@Z:PROC		; SP2Packet::operator>>
; Function compile flags: /Ogsp
;	COMDAT ?ApplyExtraSkillInfo@ioRangeSyncBuffSkill@@UAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z
_TEXT	SEGMENT
_iType$ = -4						; size = 4
_pOwner$ = 8						; size = 4
_pStage$ = 12						; size = 4
_rkPacket$ = 16						; size = 4
?ApplyExtraSkillInfo@ioRangeSyncBuffSkill@@UAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z PROC ; ioRangeSyncBuffSkill::ApplyExtraSkillInfo, COMDAT
; _this$ = ecx

; 322  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 323  : 	int iType;
; 324  : 	rkPacket >> iType;

  00005	8d 45 fc	 lea	 eax, DWORD PTR _iType$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR _rkPacket$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??5SP2Packet@@QAEAAV0@AAH@Z ; SP2Packet::operator>>

; 325  : 
; 326  : 	switch( iType )

  00013	8b 45 fc	 mov	 eax, DWORD PTR _iType$[ebp]
  00016	48		 dec	 eax
  00017	74 15		 je	 SHORT $LN2@ApplyExtra
  00019	48		 dec	 eax
  0001a	75 22		 jne	 SHORT $LN3@ApplyExtra

; 330  : 		break;
; 331  : 	case ESI_COLLISION:
; 332  : 		ApplySetCollisioned( pOwner, pStage, rkPacket );

  0001c	ff 75 10	 push	 DWORD PTR _rkPacket$[ebp]
  0001f	8b ce		 mov	 ecx, esi
  00021	ff 75 0c	 push	 DWORD PTR _pStage$[ebp]
  00024	ff 75 08	 push	 DWORD PTR _pOwner$[ebp]
  00027	e8 00 00 00 00	 call	 ?ApplySetCollisioned@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z ; ioRangeSyncBuffSkill::ApplySetCollisioned

; 333  : 		break;

  0002c	eb 10		 jmp	 SHORT $LN3@ApplyExtra
$LN2@ApplyExtra:

; 327  : 	{
; 328  : 	case ESI_SET_BUFF:
; 329  : 		ApplySetBuffList( pOwner, pStage, rkPacket );

  0002e	ff 75 10	 push	 DWORD PTR _rkPacket$[ebp]
  00031	8b ce		 mov	 ecx, esi
  00033	ff 75 0c	 push	 DWORD PTR _pStage$[ebp]
  00036	ff 75 08	 push	 DWORD PTR _pOwner$[ebp]
  00039	e8 00 00 00 00	 call	 ?ApplySetBuffList@ioRangeSyncBuffSkill@@IAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z ; ioRangeSyncBuffSkill::ApplySetBuffList
$LN3@ApplyExtra:
  0003e	5e		 pop	 esi

; 334  : 	}
; 335  : }

  0003f	c9		 leave
  00040	c2 0c 00	 ret	 12			; 0000000cH
?ApplyExtraSkillInfo@ioRangeSyncBuffSkill@@UAEXPAVioBaseChar@@PAVioPlayStage@@AAVSP2Packet@@@Z ENDP ; ioRangeSyncBuffSkill::ApplyExtraSkillInfo
_TEXT	ENDS
END
