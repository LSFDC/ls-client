; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\Lost Saga For Developer\Youtube\Tutorial\Source\src\LSClient\ioKeyManager.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?ms_Singleton@?$Singleton@VioKeyManager@@@@1PAVioKeyManager@@A ; Singleton<ioKeyManager>::ms_Singleton
;	COMDAT ?ms_Singleton@?$Singleton@VioKeyManager@@@@1PAVioKeyManager@@A
_BSS	SEGMENT
?ms_Singleton@?$Singleton@VioKeyManager@@@@1PAVioKeyManager@@A DD 01H DUP (?) ; Singleton<ioKeyManager>::ms_Singleton
_BSS	ENDS
PUBLIC	?IsRightKey@CKeyInfo@@QAE_NG@Z			; CKeyInfo::IsRightKey
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iokeymanager.cpp
;	COMDAT ?IsRightKey@CKeyInfo@@QAE_NG@Z
_TEXT	SEGMENT
_wKey$ = 8						; size = 2
?IsRightKey@CKeyInfo@@QAE_NG@Z PROC			; CKeyInfo::IsRightKey, COMDAT
; _this$ = ecx

; 45   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 46   : 	if(	wKey == KEY_ENTER  ||
; 47   : 		wKey == KEY_ESCAPE ||
; 48   : 		wKey == KEY_LWIN   ||
; 49   : 		wKey == KEY_RWIN)

  00003	66 8b 45 08	 mov	 ax, WORD PTR _wKey$[ebp]
  00007	66 83 f8 0d	 cmp	 ax, 13			; 0000000dH
  0000b	74 1a		 je	 SHORT $LN1@IsRightKey
  0000d	66 83 f8 1b	 cmp	 ax, 27			; 0000001bH
  00011	74 14		 je	 SHORT $LN1@IsRightKey
  00013	b9 b1 00 00 00	 mov	 ecx, 177		; 000000b1H
  00018	66 3b c1	 cmp	 ax, cx
  0001b	74 0a		 je	 SHORT $LN1@IsRightKey
  0001d	41		 inc	 ecx
  0001e	66 3b c1	 cmp	 ax, cx
  00021	74 04		 je	 SHORT $LN1@IsRightKey

; 52   : 	}
; 53   : 
; 54   : 	return true;

  00023	b0 01		 mov	 al, 1
  00025	eb 02		 jmp	 SHORT $LN3@IsRightKey
$LN1@IsRightKey:

; 50   : 	{
; 51   : 		return false;

  00027	32 c0		 xor	 al, al
$LN3@IsRightKey:

; 55   : }

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?IsRightKey@CKeyInfo@@QAE_NG@Z ENDP			; CKeyInfo::IsRightKey
_TEXT	ENDS
PUBLIC	??_C@_04OKGDLNCL@NONE?$AA@			; `string'
PUBLIC	??_C@_09PHHKGBNE@SOLDIER36?$AA@			; `string'
PUBLIC	??_C@_09NMFHDCBH@SOLDIER35?$AA@			; `string'
PUBLIC	??_C@_09MFEMADFG@SOLDIER34?$AA@			; `string'
PUBLIC	??_C@_09IKANJFJB@SOLDIER33?$AA@			; `string'
PUBLIC	??_C@_09JDBGKENA@SOLDIER32?$AA@			; `string'
PUBLIC	??_C@_09LIDLPHBD@SOLDIER31?$AA@			; `string'
PUBLIC	??_C@_09KBCAMGFC@SOLDIER30?$AA@			; `string'
PUBLIC	??_C@_09HBCABHCM@SOLDIER29?$AA@			; `string'
PUBLIC	??_C@_09GIDLCGGN@SOLDIER28?$AA@			; `string'
PUBLIC	??_C@_09OPKDDKKC@SOLDIER27?$AA@			; `string'
PUBLIC	??_C@_09PGLIALOD@SOLDIER26?$AA@			; `string'
PUBLIC	??_C@_09NNJFFICA@SOLDIER25?$AA@			; `string'
PUBLIC	??_C@_09MEIOGJGB@SOLDIER24?$AA@			; `string'
PUBLIC	??_C@_09ILMPPPKG@SOLDIER23?$AA@			; `string'
PUBLIC	??_C@_09JCNEMOOH@SOLDIER22?$AA@			; `string'
PUBLIC	??_C@_09LJPJJNCE@SOLDIER21?$AA@			; `string'
PUBLIC	??_C@_09KAOCKMGF@SOLDIER20?$AA@			; `string'
PUBLIC	??_C@_09HDGGKJHF@SOLDIER19?$AA@			; `string'
PUBLIC	??_C@_09GKHNJIDE@SOLDIER18?$AA@			; `string'
PUBLIC	??_C@_09ONOFIEPL@SOLDIER17?$AA@			; `string'
PUBLIC	??_C@_09PEPOLFLK@SOLDIER16?$AA@			; `string'
PUBLIC	??_C@_09NPNDOGHJ@SOLDIER15?$AA@			; `string'
PUBLIC	??_C@_09MGMINHDI@SOLDIER14?$AA@			; `string'
PUBLIC	??_C@_09IJIJEBPP@SOLDIER13?$AA@			; `string'
PUBLIC	??_C@_07KIIPOLD@MACRO12?$AA@			; `string'
PUBLIC	??_C@_07CBKFKNHA@MACRO11?$AA@			; `string'
PUBLIC	??_C@_07DILOJMDB@MACRO10?$AA@			; `string'
PUBLIC	??_C@_06IIFOEPAG@MACRO9?$AA@			; `string'
PUBLIC	??_C@_06JBEFHOEH@MACRO8?$AA@			; `string'
PUBLIC	??_C@_06BGNNGCII@MACRO7?$AA@			; `string'
PUBLIC	??_C@_06PMGFDMJ@MACRO6?$AA@			; `string'
PUBLIC	??_C@_06CEOLAAAK@MACRO5?$AA@			; `string'
PUBLIC	??_C@_06DNPADBEL@MACRO4?$AA@			; `string'
PUBLIC	??_C@_06HCLBKHIM@MACRO3?$AA@			; `string'
PUBLIC	??_C@_06GLKKJGMN@MACRO2?$AA@			; `string'
PUBLIC	??_C@_06EAIHMFAO@MACRO1?$AA@			; `string'
PUBLIC	??_C@_09JAJCHALO@SOLDIER12?$AA@			; `string'
PUBLIC	??_C@_09LLLPCDHN@SOLDIER11?$AA@			; `string'
PUBLIC	??_C@_09KCKEBCDM@SOLDIER10?$AA@			; `string'
PUBLIC	??_C@_08CNGDPEIH@SOLDIER9?$AA@			; `string'
PUBLIC	??_C@_08DEHIMFMG@SOLDIER8?$AA@			; `string'
PUBLIC	??_C@_08LDOANJAJ@SOLDIER7?$AA@			; `string'
PUBLIC	??_C@_08KKPLOIEI@SOLDIER6?$AA@			; `string'
PUBLIC	??_C@_08IBNGLLIL@SOLDIER5?$AA@			; `string'
PUBLIC	??_C@_08JIMNIKMK@SOLDIER4?$AA@			; `string'
PUBLIC	??_C@_08NHIMBMAN@SOLDIER3?$AA@			; `string'
PUBLIC	??_C@_08MOJHCNEM@SOLDIER2?$AA@			; `string'
PUBLIC	??_C@_08OFLKHOIP@SOLDIER1?$AA@			; `string'
PUBLIC	??_C@_03LNDAPIDK@PET?$AA@			; `string'
PUBLIC	??_C@_0BD@OCJMKHAN@USERS_CUSTOM_SOUND?$AA@	; `string'
PUBLIC	??_C@_07MFMCNCCJ@ZOOMOUT?$AA@			; `string'
PUBLIC	??_C@_06LJFELFHN@ZOOMIN?$AA@			; `string'
PUBLIC	??_C@_0O@KLNLHGEH@SPECIALMOTION?$AA@		; `string'
PUBLIC	??_C@_0N@LEOKHJFN@MOVIECAPTURE?$AA@		; `string'
PUBLIC	??_C@_0L@JKBDEKEK@SCREENSHOT?$AA@		; `string'
PUBLIC	??_C@_05FHIHOFEA@VOICE?$AA@			; `string'
PUBLIC	??_C@_09GKOJDHFA@MESSENGER?$AA@			; `string'
PUBLIC	??_C@_06OCONPLCM@OPTION?$AA@			; `string'
PUBLIC	??_C@_0L@MAHLJJNH@MYHOMEPAGE?$AA@		; `string'
PUBLIC	??_C@_07FDIOJFJP@PRESENT?$AA@			; `string'
PUBLIC	??_C@_05GFPLGFAD@QUEST?$AA@			; `string'
PUBLIC	??_C@_06HNBFHJGI@GROWTH?$AA@			; `string'
PUBLIC	??_C@_04NJLDFKIC@SHOP?$AA@			; `string'
PUBLIC	??_C@_04DOKPJKJF@HELP?$AA@			; `string'
PUBLIC	??_C@_0N@NALDCAG@CONSUMPTION4?$AA@		; `string'
PUBLIC	??_C@_0N@ECEKKEMB@CONSUMPTION3?$AA@		; `string'
PUBLIC	??_C@_0N@FLFBJFIA@CONSUMPTION2?$AA@		; `string'
PUBLIC	??_C@_0N@HAHMMGED@CONSUMPTION1?$AA@		; `string'
PUBLIC	??_C@_09HJALCCPH@RIGHTDOWN?$AA@			; `string'
PUBLIC	??_C@_08JJOEDBDF@LEFTDOWN?$AA@			; `string'
PUBLIC	??_C@_07LCDAOECB@RIGHTUP?$AA@			; `string'
PUBLIC	??_C@_06PNLNCAEA@LEFTUP?$AA@			; `string'
PUBLIC	??_C@_0N@MKIPNJP@WEAPON_SKILL?$AA@		; `string'
PUBLIC	??_C@_0M@MBKGPLNC@ARMOR_SKILL?$AA@		; `string'
PUBLIC	??_C@_0L@LJKKLEDH@HELM_SKILL?$AA@		; `string'
PUBLIC	??_C@_0M@HONOKLCP@CLOAK_SKILL?$AA@		; `string'
PUBLIC	??_C@_0M@EBJELDJM@SECOND_JUMP?$AA@		; `string'
PUBLIC	??_C@_0P@OECPIJJJ@SECOND_DEFENSE?$AA@		; `string'
PUBLIC	??_C@_0O@KCMDIBLF@SECOND_ATTACK?$AA@		; `string'
PUBLIC	??_C@_0N@BADCDLFF@SECOND_RIGHT?$AA@		; `string'
PUBLIC	??_C@_0M@PGPEDLEG@SECOND_LEFT?$AA@		; `string'
PUBLIC	??_C@_0M@EPAKDHP@SECOND_DOWN?$AA@		; `string'
PUBLIC	??_C@_09BEIBBHHK@SECOND_UP?$AA@			; `string'
PUBLIC	??_C@_04BFLEPEFN@JUMP?$AA@			; `string'
PUBLIC	??_C@_07PABEIMLA@DEFENSE?$AA@			; `string'
PUBLIC	??_C@_06JIJKOHKJ@ATTACK?$AA@			; `string'
PUBLIC	??_C@_05PMAFOJDE@RIGHT?$AA@			; `string'
PUBLIC	??_C@_04KCNEHMIH@LEFT?$AA@			; `string'
PUBLIC	??_C@_04FANAOELO@DOWN?$AA@			; `string'
PUBLIC	??_C@_02NAHCJHOC@UP?$AA@			; `string'
PUBLIC	?GetINIKeyName@CKeyInfo@@IAEPADW4KeyTypeArray@1@@Z ; CKeyInfo::GetINIKeyName
;	COMDAT ??_C@_04OKGDLNCL@NONE?$AA@
CONST	SEGMENT
??_C@_04OKGDLNCL@NONE?$AA@ DB 'NONE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09PHHKGBNE@SOLDIER36?$AA@
CONST	SEGMENT
??_C@_09PHHKGBNE@SOLDIER36?$AA@ DB 'SOLDIER36', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NMFHDCBH@SOLDIER35?$AA@
CONST	SEGMENT
??_C@_09NMFHDCBH@SOLDIER35?$AA@ DB 'SOLDIER35', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MFEMADFG@SOLDIER34?$AA@
CONST	SEGMENT
??_C@_09MFEMADFG@SOLDIER34?$AA@ DB 'SOLDIER34', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09IKANJFJB@SOLDIER33?$AA@
CONST	SEGMENT
??_C@_09IKANJFJB@SOLDIER33?$AA@ DB 'SOLDIER33', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JDBGKENA@SOLDIER32?$AA@
CONST	SEGMENT
??_C@_09JDBGKENA@SOLDIER32?$AA@ DB 'SOLDIER32', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LIDLPHBD@SOLDIER31?$AA@
CONST	SEGMENT
??_C@_09LIDLPHBD@SOLDIER31?$AA@ DB 'SOLDIER31', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09KBCAMGFC@SOLDIER30?$AA@
CONST	SEGMENT
??_C@_09KBCAMGFC@SOLDIER30?$AA@ DB 'SOLDIER30', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09HBCABHCM@SOLDIER29?$AA@
CONST	SEGMENT
??_C@_09HBCABHCM@SOLDIER29?$AA@ DB 'SOLDIER29', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GIDLCGGN@SOLDIER28?$AA@
CONST	SEGMENT
??_C@_09GIDLCGGN@SOLDIER28?$AA@ DB 'SOLDIER28', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OPKDDKKC@SOLDIER27?$AA@
CONST	SEGMENT
??_C@_09OPKDDKKC@SOLDIER27?$AA@ DB 'SOLDIER27', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PGLIALOD@SOLDIER26?$AA@
CONST	SEGMENT
??_C@_09PGLIALOD@SOLDIER26?$AA@ DB 'SOLDIER26', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NNJFFICA@SOLDIER25?$AA@
CONST	SEGMENT
??_C@_09NNJFFICA@SOLDIER25?$AA@ DB 'SOLDIER25', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MEIOGJGB@SOLDIER24?$AA@
CONST	SEGMENT
??_C@_09MEIOGJGB@SOLDIER24?$AA@ DB 'SOLDIER24', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09ILMPPPKG@SOLDIER23?$AA@
CONST	SEGMENT
??_C@_09ILMPPPKG@SOLDIER23?$AA@ DB 'SOLDIER23', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JCNEMOOH@SOLDIER22?$AA@
CONST	SEGMENT
??_C@_09JCNEMOOH@SOLDIER22?$AA@ DB 'SOLDIER22', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LJPJJNCE@SOLDIER21?$AA@
CONST	SEGMENT
??_C@_09LJPJJNCE@SOLDIER21?$AA@ DB 'SOLDIER21', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09KAOCKMGF@SOLDIER20?$AA@
CONST	SEGMENT
??_C@_09KAOCKMGF@SOLDIER20?$AA@ DB 'SOLDIER20', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09HDGGKJHF@SOLDIER19?$AA@
CONST	SEGMENT
??_C@_09HDGGKJHF@SOLDIER19?$AA@ DB 'SOLDIER19', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GKHNJIDE@SOLDIER18?$AA@
CONST	SEGMENT
??_C@_09GKHNJIDE@SOLDIER18?$AA@ DB 'SOLDIER18', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09ONOFIEPL@SOLDIER17?$AA@
CONST	SEGMENT
??_C@_09ONOFIEPL@SOLDIER17?$AA@ DB 'SOLDIER17', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PEPOLFLK@SOLDIER16?$AA@
CONST	SEGMENT
??_C@_09PEPOLFLK@SOLDIER16?$AA@ DB 'SOLDIER16', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NPNDOGHJ@SOLDIER15?$AA@
CONST	SEGMENT
??_C@_09NPNDOGHJ@SOLDIER15?$AA@ DB 'SOLDIER15', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MGMINHDI@SOLDIER14?$AA@
CONST	SEGMENT
??_C@_09MGMINHDI@SOLDIER14?$AA@ DB 'SOLDIER14', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09IJIJEBPP@SOLDIER13?$AA@
CONST	SEGMENT
??_C@_09IJIJEBPP@SOLDIER13?$AA@ DB 'SOLDIER13', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07KIIPOLD@MACRO12?$AA@
CONST	SEGMENT
??_C@_07KIIPOLD@MACRO12?$AA@ DB 'MACRO12', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CBKFKNHA@MACRO11?$AA@
CONST	SEGMENT
??_C@_07CBKFKNHA@MACRO11?$AA@ DB 'MACRO11', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DILOJMDB@MACRO10?$AA@
CONST	SEGMENT
??_C@_07DILOJMDB@MACRO10?$AA@ DB 'MACRO10', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IIFOEPAG@MACRO9?$AA@
CONST	SEGMENT
??_C@_06IIFOEPAG@MACRO9?$AA@ DB 'MACRO9', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JBEFHOEH@MACRO8?$AA@
CONST	SEGMENT
??_C@_06JBEFHOEH@MACRO8?$AA@ DB 'MACRO8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BGNNGCII@MACRO7?$AA@
CONST	SEGMENT
??_C@_06BGNNGCII@MACRO7?$AA@ DB 'MACRO7', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PMGFDMJ@MACRO6?$AA@
CONST	SEGMENT
??_C@_06PMGFDMJ@MACRO6?$AA@ DB 'MACRO6', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CEOLAAAK@MACRO5?$AA@
CONST	SEGMENT
??_C@_06CEOLAAAK@MACRO5?$AA@ DB 'MACRO5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DNPADBEL@MACRO4?$AA@
CONST	SEGMENT
??_C@_06DNPADBEL@MACRO4?$AA@ DB 'MACRO4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HCLBKHIM@MACRO3?$AA@
CONST	SEGMENT
??_C@_06HCLBKHIM@MACRO3?$AA@ DB 'MACRO3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GLKKJGMN@MACRO2?$AA@
CONST	SEGMENT
??_C@_06GLKKJGMN@MACRO2?$AA@ DB 'MACRO2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EAIHMFAO@MACRO1?$AA@
CONST	SEGMENT
??_C@_06EAIHMFAO@MACRO1?$AA@ DB 'MACRO1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09JAJCHALO@SOLDIER12?$AA@
CONST	SEGMENT
??_C@_09JAJCHALO@SOLDIER12?$AA@ DB 'SOLDIER12', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LLLPCDHN@SOLDIER11?$AA@
CONST	SEGMENT
??_C@_09LLLPCDHN@SOLDIER11?$AA@ DB 'SOLDIER11', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09KCKEBCDM@SOLDIER10?$AA@
CONST	SEGMENT
??_C@_09KCKEBCDM@SOLDIER10?$AA@ DB 'SOLDIER10', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08CNGDPEIH@SOLDIER9?$AA@
CONST	SEGMENT
??_C@_08CNGDPEIH@SOLDIER9?$AA@ DB 'SOLDIER9', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08DEHIMFMG@SOLDIER8?$AA@
CONST	SEGMENT
??_C@_08DEHIMFMG@SOLDIER8?$AA@ DB 'SOLDIER8', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08LDOANJAJ@SOLDIER7?$AA@
CONST	SEGMENT
??_C@_08LDOANJAJ@SOLDIER7?$AA@ DB 'SOLDIER7', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KKPLOIEI@SOLDIER6?$AA@
CONST	SEGMENT
??_C@_08KKPLOIEI@SOLDIER6?$AA@ DB 'SOLDIER6', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08IBNGLLIL@SOLDIER5?$AA@
CONST	SEGMENT
??_C@_08IBNGLLIL@SOLDIER5?$AA@ DB 'SOLDIER5', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JIMNIKMK@SOLDIER4?$AA@
CONST	SEGMENT
??_C@_08JIMNIKMK@SOLDIER4?$AA@ DB 'SOLDIER4', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08NHIMBMAN@SOLDIER3?$AA@
CONST	SEGMENT
??_C@_08NHIMBMAN@SOLDIER3?$AA@ DB 'SOLDIER3', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MOJHCNEM@SOLDIER2?$AA@
CONST	SEGMENT
??_C@_08MOJHCNEM@SOLDIER2?$AA@ DB 'SOLDIER2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08OFLKHOIP@SOLDIER1?$AA@
CONST	SEGMENT
??_C@_08OFLKHOIP@SOLDIER1?$AA@ DB 'SOLDIER1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03LNDAPIDK@PET?$AA@
CONST	SEGMENT
??_C@_03LNDAPIDK@PET?$AA@ DB 'PET', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OCJMKHAN@USERS_CUSTOM_SOUND?$AA@
CONST	SEGMENT
??_C@_0BD@OCJMKHAN@USERS_CUSTOM_SOUND?$AA@ DB 'USERS_CUSTOM_SOUND', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MFMCNCCJ@ZOOMOUT?$AA@
CONST	SEGMENT
??_C@_07MFMCNCCJ@ZOOMOUT?$AA@ DB 'ZOOMOUT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LJFELFHN@ZOOMIN?$AA@
CONST	SEGMENT
??_C@_06LJFELFHN@ZOOMIN?$AA@ DB 'ZOOMIN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KLNLHGEH@SPECIALMOTION?$AA@
CONST	SEGMENT
??_C@_0O@KLNLHGEH@SPECIALMOTION?$AA@ DB 'SPECIALMOTION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LEOKHJFN@MOVIECAPTURE?$AA@
CONST	SEGMENT
??_C@_0N@LEOKHJFN@MOVIECAPTURE?$AA@ DB 'MOVIECAPTURE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JKBDEKEK@SCREENSHOT?$AA@
CONST	SEGMENT
??_C@_0L@JKBDEKEK@SCREENSHOT?$AA@ DB 'SCREENSHOT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05FHIHOFEA@VOICE?$AA@
CONST	SEGMENT
??_C@_05FHIHOFEA@VOICE?$AA@ DB 'VOICE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GKOJDHFA@MESSENGER?$AA@
CONST	SEGMENT
??_C@_09GKOJDHFA@MESSENGER?$AA@ DB 'MESSENGER', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06OCONPLCM@OPTION?$AA@
CONST	SEGMENT
??_C@_06OCONPLCM@OPTION?$AA@ DB 'OPTION', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MAHLJJNH@MYHOMEPAGE?$AA@
CONST	SEGMENT
??_C@_0L@MAHLJJNH@MYHOMEPAGE?$AA@ DB 'MYHOMEPAGE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07FDIOJFJP@PRESENT?$AA@
CONST	SEGMENT
??_C@_07FDIOJFJP@PRESENT?$AA@ DB 'PRESENT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GFPLGFAD@QUEST?$AA@
CONST	SEGMENT
??_C@_05GFPLGFAD@QUEST?$AA@ DB 'QUEST', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HNBFHJGI@GROWTH?$AA@
CONST	SEGMENT
??_C@_06HNBFHJGI@GROWTH?$AA@ DB 'GROWTH', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NJLDFKIC@SHOP?$AA@
CONST	SEGMENT
??_C@_04NJLDFKIC@SHOP?$AA@ DB 'SHOP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DOKPJKJF@HELP?$AA@
CONST	SEGMENT
??_C@_04DOKPJKJF@HELP?$AA@ DB 'HELP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NALDCAG@CONSUMPTION4?$AA@
CONST	SEGMENT
??_C@_0N@NALDCAG@CONSUMPTION4?$AA@ DB 'CONSUMPTION4', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ECEKKEMB@CONSUMPTION3?$AA@
CONST	SEGMENT
??_C@_0N@ECEKKEMB@CONSUMPTION3?$AA@ DB 'CONSUMPTION3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FLFBJFIA@CONSUMPTION2?$AA@
CONST	SEGMENT
??_C@_0N@FLFBJFIA@CONSUMPTION2?$AA@ DB 'CONSUMPTION2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HAHMMGED@CONSUMPTION1?$AA@
CONST	SEGMENT
??_C@_0N@HAHMMGED@CONSUMPTION1?$AA@ DB 'CONSUMPTION1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09HJALCCPH@RIGHTDOWN?$AA@
CONST	SEGMENT
??_C@_09HJALCCPH@RIGHTDOWN?$AA@ DB 'RIGHTDOWN', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JJOEDBDF@LEFTDOWN?$AA@
CONST	SEGMENT
??_C@_08JJOEDBDF@LEFTDOWN?$AA@ DB 'LEFTDOWN', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LCDAOECB@RIGHTUP?$AA@
CONST	SEGMENT
??_C@_07LCDAOECB@RIGHTUP?$AA@ DB 'RIGHTUP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PNLNCAEA@LEFTUP?$AA@
CONST	SEGMENT
??_C@_06PNLNCAEA@LEFTUP?$AA@ DB 'LEFTUP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MKIPNJP@WEAPON_SKILL?$AA@
CONST	SEGMENT
??_C@_0N@MKIPNJP@WEAPON_SKILL?$AA@ DB 'WEAPON_SKILL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MBKGPLNC@ARMOR_SKILL?$AA@
CONST	SEGMENT
??_C@_0M@MBKGPLNC@ARMOR_SKILL?$AA@ DB 'ARMOR_SKILL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LJKKLEDH@HELM_SKILL?$AA@
CONST	SEGMENT
??_C@_0L@LJKKLEDH@HELM_SKILL?$AA@ DB 'HELM_SKILL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HONOKLCP@CLOAK_SKILL?$AA@
CONST	SEGMENT
??_C@_0M@HONOKLCP@CLOAK_SKILL?$AA@ DB 'CLOAK_SKILL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EBJELDJM@SECOND_JUMP?$AA@
CONST	SEGMENT
??_C@_0M@EBJELDJM@SECOND_JUMP?$AA@ DB 'SECOND_JUMP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OECPIJJJ@SECOND_DEFENSE?$AA@
CONST	SEGMENT
??_C@_0P@OECPIJJJ@SECOND_DEFENSE?$AA@ DB 'SECOND_DEFENSE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KCMDIBLF@SECOND_ATTACK?$AA@
CONST	SEGMENT
??_C@_0O@KCMDIBLF@SECOND_ATTACK?$AA@ DB 'SECOND_ATTACK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BADCDLFF@SECOND_RIGHT?$AA@
CONST	SEGMENT
??_C@_0N@BADCDLFF@SECOND_RIGHT?$AA@ DB 'SECOND_RIGHT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PGPEDLEG@SECOND_LEFT?$AA@
CONST	SEGMENT
??_C@_0M@PGPEDLEG@SECOND_LEFT?$AA@ DB 'SECOND_LEFT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EPAKDHP@SECOND_DOWN?$AA@
CONST	SEGMENT
??_C@_0M@EPAKDHP@SECOND_DOWN?$AA@ DB 'SECOND_DOWN', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BEIBBHHK@SECOND_UP?$AA@
CONST	SEGMENT
??_C@_09BEIBBHHK@SECOND_UP?$AA@ DB 'SECOND_UP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04BFLEPEFN@JUMP?$AA@
CONST	SEGMENT
??_C@_04BFLEPEFN@JUMP?$AA@ DB 'JUMP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PABEIMLA@DEFENSE?$AA@
CONST	SEGMENT
??_C@_07PABEIMLA@DEFENSE?$AA@ DB 'DEFENSE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JIJKOHKJ@ATTACK?$AA@
CONST	SEGMENT
??_C@_06JIJKOHKJ@ATTACK?$AA@ DB 'ATTACK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PMAFOJDE@RIGHT?$AA@
CONST	SEGMENT
??_C@_05PMAFOJDE@RIGHT?$AA@ DB 'RIGHT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KCNEHMIH@LEFT?$AA@
CONST	SEGMENT
??_C@_04KCNEHMIH@LEFT?$AA@ DB 'LEFT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FANAOELO@DOWN?$AA@
CONST	SEGMENT
??_C@_04FANAOELO@DOWN?$AA@ DB 'DOWN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02NAHCJHOC@UP?$AA@
CONST	SEGMENT
??_C@_02NAHCJHOC@UP?$AA@ DB 'UP', 00H			; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?GetINIKeyName@CKeyInfo@@IAEPADW4KeyTypeArray@1@@Z
_TEXT	SEGMENT
_eKeyTypeArray$ = 8					; size = 4
?GetINIKeyName@CKeyInfo@@IAEPADW4KeyTypeArray@1@@Z PROC	; CKeyInfo::GetINIKeyName, COMDAT
; _this$ = ecx

; 80   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 81   : 	switch(eKeyTypeArray)

  00003	8b 45 08	 mov	 eax, DWORD PTR _eKeyTypeArray$[ebp]
  00006	83 f8 5e	 cmp	 eax, 94			; 0000005eH
  00009	0f 87 55 03 00
	00		 ja	 $LN91@GetINIKeyN
  0000f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN95@GetINIKeyN[eax*4]
$LN90@GetINIKeyN:

; 82   : 	{
; 83   : 		// game key
; 84   : 	case KTA_UP:
; 85   : 		return "UP";

  00016	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_02NAHCJHOC@UP?$AA@
  0001b	e9 49 03 00 00	 jmp	 $LN93@GetINIKeyN
$LN89@GetINIKeyN:

; 86   : 	case KTA_DOWN:
; 87   : 		return "DOWN";

  00020	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04FANAOELO@DOWN?$AA@
  00025	e9 3f 03 00 00	 jmp	 $LN93@GetINIKeyN
$LN88@GetINIKeyN:

; 88   : 	case KTA_LEFT:
; 89   : 		return "LEFT";

  0002a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04KCNEHMIH@LEFT?$AA@
  0002f	e9 35 03 00 00	 jmp	 $LN93@GetINIKeyN
$LN87@GetINIKeyN:

; 90   : 	case KTA_RIGHT: 
; 91   : 		return "RIGHT";

  00034	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_05PMAFOJDE@RIGHT?$AA@
  00039	e9 2b 03 00 00	 jmp	 $LN93@GetINIKeyN
$LN86@GetINIKeyN:

; 92   : 	case KTA_ATTACK:
; 93   : 		return "ATTACK";

  0003e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_06JIJKOHKJ@ATTACK?$AA@
  00043	e9 21 03 00 00	 jmp	 $LN93@GetINIKeyN
$LN85@GetINIKeyN:

; 94   : 	case KTA_DEFENSE:
; 95   : 		return "DEFENSE";

  00048	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_07PABEIMLA@DEFENSE?$AA@
  0004d	e9 17 03 00 00	 jmp	 $LN93@GetINIKeyN
$LN84@GetINIKeyN:

; 96   : 	case KTA_JUMP:
; 97   : 		return "JUMP";

  00052	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04BFLEPEFN@JUMP?$AA@
  00057	e9 0d 03 00 00	 jmp	 $LN93@GetINIKeyN
$LN83@GetINIKeyN:

; 98   : 		// second game key
; 99   : 	case KTA_SECOND_UP:     
; 100  : 		return "SECOND_UP";

  0005c	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09BEIBBHHK@SECOND_UP?$AA@
  00061	e9 03 03 00 00	 jmp	 $LN93@GetINIKeyN
$LN82@GetINIKeyN:

; 101  : 	case KTA_SECOND_DOWN:   
; 102  : 		return "SECOND_DOWN";

  00066	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0M@EPAKDHP@SECOND_DOWN?$AA@
  0006b	e9 f9 02 00 00	 jmp	 $LN93@GetINIKeyN
$LN81@GetINIKeyN:

; 103  : 	case KTA_SECOND_LEFT:   
; 104  : 		return "SECOND_LEFT";

  00070	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0M@PGPEDLEG@SECOND_LEFT?$AA@
  00075	e9 ef 02 00 00	 jmp	 $LN93@GetINIKeyN
$LN80@GetINIKeyN:

; 105  : 	case KTA_SECOND_RIGHT:  
; 106  : 		return "SECOND_RIGHT";

  0007a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0N@BADCDLFF@SECOND_RIGHT?$AA@
  0007f	e9 e5 02 00 00	 jmp	 $LN93@GetINIKeyN
$LN79@GetINIKeyN:

; 107  : 	case KTA_SECOND_ATTACK: 
; 108  : 		return "SECOND_ATTACK";

  00084	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0O@KCMDIBLF@SECOND_ATTACK?$AA@
  00089	e9 db 02 00 00	 jmp	 $LN93@GetINIKeyN
$LN78@GetINIKeyN:

; 109  : 	case KTA_SECOND_DEFENSE:
; 110  : 		return "SECOND_DEFENSE";

  0008e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0P@OECPIJJJ@SECOND_DEFENSE?$AA@
  00093	e9 d1 02 00 00	 jmp	 $LN93@GetINIKeyN
$LN77@GetINIKeyN:

; 111  : 	case KTA_SECOND_JUMP:   
; 112  : 		return "SECOND_JUMP";

  00098	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0M@EBJELDJM@SECOND_JUMP?$AA@
  0009d	e9 c7 02 00 00	 jmp	 $LN93@GetINIKeyN
$LN76@GetINIKeyN:

; 113  : 		// skill key
; 114  : 	case KTA_CLOAK_SKILL:
; 115  : 		return "CLOAK_SKILL";

  000a2	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0M@HONOKLCP@CLOAK_SKILL?$AA@
  000a7	e9 bd 02 00 00	 jmp	 $LN93@GetINIKeyN
$LN75@GetINIKeyN:

; 116  : 	case KTA_HELM_SKILL:
; 117  : 		return "HELM_SKILL";

  000ac	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0L@LJKKLEDH@HELM_SKILL?$AA@
  000b1	e9 b3 02 00 00	 jmp	 $LN93@GetINIKeyN
$LN74@GetINIKeyN:

; 118  : 	case KTA_ARMOR_SKILL:
; 119  : 		return "ARMOR_SKILL";

  000b6	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0M@MBKGPLNC@ARMOR_SKILL?$AA@
  000bb	e9 a9 02 00 00	 jmp	 $LN93@GetINIKeyN
$LN73@GetINIKeyN:

; 120  : 	case KTA_WEAPON_SKILL:
; 121  : 		return "WEAPON_SKILL";

  000c0	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0N@MKIPNJP@WEAPON_SKILL?$AA@
  000c5	e9 9f 02 00 00	 jmp	 $LN93@GetINIKeyN
$LN72@GetINIKeyN:

; 122  : 		// diagonal
; 123  : 	case KTA_LEFTUP:
; 124  : 		return "LEFTUP";

  000ca	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_06PNLNCAEA@LEFTUP?$AA@
  000cf	e9 95 02 00 00	 jmp	 $LN93@GetINIKeyN
$LN71@GetINIKeyN:

; 125  : 	case KTA_RIGHTUP:    
; 126  : 		return "RIGHTUP";

  000d4	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_07LCDAOECB@RIGHTUP?$AA@
  000d9	e9 8b 02 00 00	 jmp	 $LN93@GetINIKeyN
$LN70@GetINIKeyN:

; 127  : 	case KTA_LEFTDOWN:   
; 128  : 		return "LEFTDOWN";

  000de	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08JJOEDBDF@LEFTDOWN?$AA@
  000e3	e9 81 02 00 00	 jmp	 $LN93@GetINIKeyN
$LN69@GetINIKeyN:

; 129  : 	case KTA_RIGHTDOWN:  
; 130  : 		return "RIGHTDOWN";

  000e8	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09HJALCCPH@RIGHTDOWN?$AA@
  000ed	e9 77 02 00 00	 jmp	 $LN93@GetINIKeyN
$LN68@GetINIKeyN:

; 131  : 		// function
; 132  : 	case KTA_CONSUMPTION1:
; 133  : 		return "CONSUMPTION1";

  000f2	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0N@HAHMMGED@CONSUMPTION1?$AA@
  000f7	e9 6d 02 00 00	 jmp	 $LN93@GetINIKeyN
$LN67@GetINIKeyN:

; 134  : 	case KTA_CONSUMPTION2:
; 135  : 		return "CONSUMPTION2";

  000fc	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0N@FLFBJFIA@CONSUMPTION2?$AA@
  00101	e9 63 02 00 00	 jmp	 $LN93@GetINIKeyN
$LN66@GetINIKeyN:

; 136  : 	case KTA_CONSUMPTION3:
; 137  : 		return "CONSUMPTION3";

  00106	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0N@ECEKKEMB@CONSUMPTION3?$AA@
  0010b	e9 59 02 00 00	 jmp	 $LN93@GetINIKeyN
$LN65@GetINIKeyN:

; 138  : 	case KTA_CONSUMPTION4:
; 139  : 		return "CONSUMPTION4";

  00110	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0N@NALDCAG@CONSUMPTION4?$AA@
  00115	e9 4f 02 00 00	 jmp	 $LN93@GetINIKeyN
$LN64@GetINIKeyN:

; 140  : 	case KTA_HELP:
; 141  : 		return "HELP";

  0011a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04DOKPJKJF@HELP?$AA@
  0011f	e9 45 02 00 00	 jmp	 $LN93@GetINIKeyN
$LN63@GetINIKeyN:

; 142  : 	case KTA_SHOP:
; 143  : 		return "SHOP";

  00124	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04NJLDFKIC@SHOP?$AA@
  00129	e9 3b 02 00 00	 jmp	 $LN93@GetINIKeyN
$LN62@GetINIKeyN:

; 144  : 	case KTA_GROWTH:
; 145  : 		return "GROWTH";

  0012e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_06HNBFHJGI@GROWTH?$AA@
  00133	e9 31 02 00 00	 jmp	 $LN93@GetINIKeyN
$LN61@GetINIKeyN:

; 146  : 	case KTA_QUEST:
; 147  : 		return "QUEST";	

  00138	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_05GFPLGFAD@QUEST?$AA@
  0013d	e9 27 02 00 00	 jmp	 $LN93@GetINIKeyN
$LN60@GetINIKeyN:

; 148  : 	case KTA_PRESENT:
; 149  : 		return "PRESENT";

  00142	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_07FDIOJFJP@PRESENT?$AA@
  00147	e9 1d 02 00 00	 jmp	 $LN93@GetINIKeyN
$LN59@GetINIKeyN:

; 150  : 	case KTA_MYHOMEPAGE:
; 151  : 		return "MYHOMEPAGE";	

  0014c	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0L@MAHLJJNH@MYHOMEPAGE?$AA@
  00151	e9 13 02 00 00	 jmp	 $LN93@GetINIKeyN
$LN58@GetINIKeyN:

; 152  : 	case KTA_OPTION:     
; 153  : 		return "OPTION";

  00156	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_06OCONPLCM@OPTION?$AA@
  0015b	e9 09 02 00 00	 jmp	 $LN93@GetINIKeyN
$LN57@GetINIKeyN:

; 154  : 	case KTA_MESSENGER:  
; 155  : 		return "MESSENGER";

  00160	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09GKOJDHFA@MESSENGER?$AA@
  00165	e9 ff 01 00 00	 jmp	 $LN93@GetINIKeyN
$LN56@GetINIKeyN:

; 156  : 	case KTA_VOICE:      
; 157  : 		return "VOICE";

  0016a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_05FHIHOFEA@VOICE?$AA@
  0016f	e9 f5 01 00 00	 jmp	 $LN93@GetINIKeyN
$LN55@GetINIKeyN:

; 158  : 	case KTA_SCREENSHOT: 
; 159  : 		return "SCREENSHOT";

  00174	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0L@JKBDEKEK@SCREENSHOT?$AA@
  00179	e9 eb 01 00 00	 jmp	 $LN93@GetINIKeyN
$LN54@GetINIKeyN:

; 160  : 	case KTA_MOVIECAPTURE:
; 161  : 		return "MOVIECAPTURE";

  0017e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0N@LEOKHJFN@MOVIECAPTURE?$AA@
  00183	e9 e1 01 00 00	 jmp	 $LN93@GetINIKeyN
$LN53@GetINIKeyN:

; 162  : 	case KTA_SPECIAL_MOTION:
; 163  : 		return "SPECIALMOTION";

  00188	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0O@KLNLHGEH@SPECIALMOTION?$AA@
  0018d	e9 d7 01 00 00	 jmp	 $LN93@GetINIKeyN
$LN52@GetINIKeyN:

; 164  : 	case KTA_ZOOMIN:
; 165  : 		return "ZOOMIN";

  00192	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_06LJFELFHN@ZOOMIN?$AA@
  00197	e9 cd 01 00 00	 jmp	 $LN93@GetINIKeyN
$LN51@GetINIKeyN:

; 166  : 	case KTA_ZOOMOUT:
; 167  : 		return "ZOOMOUT";

  0019c	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_07MFMCNCCJ@ZOOMOUT?$AA@
  001a1	e9 c3 01 00 00	 jmp	 $LN93@GetINIKeyN
$LN50@GetINIKeyN:

; 168  : 	case KTA_USERS_CUSTOM_SOUND:
; 169  : 		return "USERS_CUSTOM_SOUND";

  001a6	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BD@OCJMKHAN@USERS_CUSTOM_SOUND?$AA@
  001ab	e9 b9 01 00 00	 jmp	 $LN93@GetINIKeyN
$LN49@GetINIKeyN:

; 170  : 	case KTA_PET:
; 171  : 		return "PET";

  001b0	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03LNDAPIDK@PET?$AA@
  001b5	e9 af 01 00 00	 jmp	 $LN93@GetINIKeyN
$LN48@GetINIKeyN:

; 172  : 		// soldier
; 173  : 	case KTA_SOLDIER1:  
; 174  : 		return "SOLDIER1";

  001ba	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08OFLKHOIP@SOLDIER1?$AA@
  001bf	e9 a5 01 00 00	 jmp	 $LN93@GetINIKeyN
$LN47@GetINIKeyN:

; 175  : 	case KTA_SOLDIER2:  
; 176  : 		return "SOLDIER2";

  001c4	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08MOJHCNEM@SOLDIER2?$AA@
  001c9	e9 9b 01 00 00	 jmp	 $LN93@GetINIKeyN
$LN46@GetINIKeyN:

; 177  : 	case KTA_SOLDIER3:  
; 178  : 		return "SOLDIER3";

  001ce	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08NHIMBMAN@SOLDIER3?$AA@
  001d3	e9 91 01 00 00	 jmp	 $LN93@GetINIKeyN
$LN45@GetINIKeyN:

; 179  : 	case KTA_SOLDIER4:  
; 180  : 		return "SOLDIER4";

  001d8	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08JIMNIKMK@SOLDIER4?$AA@
  001dd	e9 87 01 00 00	 jmp	 $LN93@GetINIKeyN
$LN44@GetINIKeyN:

; 181  : 	case KTA_SOLDIER5:  
; 182  : 		return "SOLDIER5";

  001e2	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08IBNGLLIL@SOLDIER5?$AA@
  001e7	e9 7d 01 00 00	 jmp	 $LN93@GetINIKeyN
$LN43@GetINIKeyN:

; 183  : 	case KTA_SOLDIER6:  
; 184  : 		return "SOLDIER6";

  001ec	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08KKPLOIEI@SOLDIER6?$AA@
  001f1	e9 73 01 00 00	 jmp	 $LN93@GetINIKeyN
$LN42@GetINIKeyN:

; 185  : 	case KTA_SOLDIER7:  
; 186  : 		return "SOLDIER7";

  001f6	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08LDOANJAJ@SOLDIER7?$AA@
  001fb	e9 69 01 00 00	 jmp	 $LN93@GetINIKeyN
$LN41@GetINIKeyN:

; 187  : 	case KTA_SOLDIER8:  
; 188  : 		return "SOLDIER8";

  00200	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08DEHIMFMG@SOLDIER8?$AA@
  00205	e9 5f 01 00 00	 jmp	 $LN93@GetINIKeyN
$LN40@GetINIKeyN:

; 189  : 	case KTA_SOLDIER9:  
; 190  : 		return "SOLDIER9";

  0020a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08CNGDPEIH@SOLDIER9?$AA@
  0020f	e9 55 01 00 00	 jmp	 $LN93@GetINIKeyN
$LN39@GetINIKeyN:

; 191  : 	case KTA_SOLDIER10: 
; 192  : 		return "SOLDIER10";

  00214	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09KCKEBCDM@SOLDIER10?$AA@
  00219	e9 4b 01 00 00	 jmp	 $LN93@GetINIKeyN
$LN38@GetINIKeyN:

; 193  : 	case KTA_SOLDIER11: 
; 194  : 		return "SOLDIER11";

  0021e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09LLLPCDHN@SOLDIER11?$AA@
  00223	e9 41 01 00 00	 jmp	 $LN93@GetINIKeyN
$LN37@GetINIKeyN:

; 195  : 	case KTA_SOLDIER12: 
; 196  : 		return "SOLDIER12";

  00228	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09JAJCHALO@SOLDIER12?$AA@
  0022d	e9 37 01 00 00	 jmp	 $LN93@GetINIKeyN
$LN36@GetINIKeyN:

; 197  : 		// macro
; 198  : 	case KTA_MACRO1:  
; 199  : 		return "MACRO1";

  00232	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_06EAIHMFAO@MACRO1?$AA@
  00237	e9 2d 01 00 00	 jmp	 $LN93@GetINIKeyN
$LN35@GetINIKeyN:

; 200  : 	case KTA_MACRO2:  
; 201  : 		return "MACRO2";

  0023c	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_06GLKKJGMN@MACRO2?$AA@
  00241	e9 23 01 00 00	 jmp	 $LN93@GetINIKeyN
$LN34@GetINIKeyN:

; 202  : 	case KTA_MACRO3:  
; 203  : 		return "MACRO3";

  00246	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_06HCLBKHIM@MACRO3?$AA@
  0024b	e9 19 01 00 00	 jmp	 $LN93@GetINIKeyN
$LN33@GetINIKeyN:

; 204  : 	case KTA_MACRO4:  
; 205  : 		return "MACRO4";

  00250	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_06DNPADBEL@MACRO4?$AA@
  00255	e9 0f 01 00 00	 jmp	 $LN93@GetINIKeyN
$LN32@GetINIKeyN:

; 206  : 	case KTA_MACRO5:  
; 207  : 		return "MACRO5";

  0025a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_06CEOLAAAK@MACRO5?$AA@
  0025f	e9 05 01 00 00	 jmp	 $LN93@GetINIKeyN
$LN31@GetINIKeyN:

; 208  : 	case KTA_MACRO6:  
; 209  : 		return "MACRO6";

  00264	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_06PMGFDMJ@MACRO6?$AA@
  00269	e9 fb 00 00 00	 jmp	 $LN93@GetINIKeyN
$LN30@GetINIKeyN:

; 210  : 	case KTA_MACRO7:  
; 211  : 		return "MACRO7";

  0026e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_06BGNNGCII@MACRO7?$AA@
  00273	e9 f1 00 00 00	 jmp	 $LN93@GetINIKeyN
$LN29@GetINIKeyN:

; 212  : 	case KTA_MACRO8:  
; 213  : 		return "MACRO8";

  00278	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_06JBEFHOEH@MACRO8?$AA@
  0027d	e9 e7 00 00 00	 jmp	 $LN93@GetINIKeyN
$LN28@GetINIKeyN:

; 214  : 	case KTA_MACRO9:  
; 215  : 		return "MACRO9";

  00282	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_06IIFOEPAG@MACRO9?$AA@
  00287	e9 dd 00 00 00	 jmp	 $LN93@GetINIKeyN
$LN27@GetINIKeyN:

; 216  : 	case KTA_MACRO10: 
; 217  : 		return "MACRO10";

  0028c	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_07DILOJMDB@MACRO10?$AA@
  00291	e9 d3 00 00 00	 jmp	 $LN93@GetINIKeyN
$LN26@GetINIKeyN:

; 218  : 	case KTA_MACRO11: 
; 219  : 		return "MACRO11";

  00296	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_07CBKFKNHA@MACRO11?$AA@
  0029b	e9 c9 00 00 00	 jmp	 $LN93@GetINIKeyN
$LN25@GetINIKeyN:

; 220  : 	case KTA_MACRO12: 
; 221  : 		return "MACRO12";

  002a0	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_07KIIPOLD@MACRO12?$AA@
  002a5	e9 bf 00 00 00	 jmp	 $LN93@GetINIKeyN
$LN24@GetINIKeyN:

; 222  : 		// soldier
; 223  : 	case KTA_SOLDIER13:  
; 224  : 		return "SOLDIER13";

  002aa	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09IJIJEBPP@SOLDIER13?$AA@
  002af	e9 b5 00 00 00	 jmp	 $LN93@GetINIKeyN
$LN23@GetINIKeyN:

; 225  : 	case KTA_SOLDIER14:  
; 226  : 		return "SOLDIER14";

  002b4	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09MGMINHDI@SOLDIER14?$AA@
  002b9	e9 ab 00 00 00	 jmp	 $LN93@GetINIKeyN
$LN22@GetINIKeyN:

; 227  : 	case KTA_SOLDIER15:  
; 228  : 		return "SOLDIER15";

  002be	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09NPNDOGHJ@SOLDIER15?$AA@
  002c3	e9 a1 00 00 00	 jmp	 $LN93@GetINIKeyN
$LN21@GetINIKeyN:

; 229  : 	case KTA_SOLDIER16:  
; 230  : 		return "SOLDIER16";

  002c8	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09PEPOLFLK@SOLDIER16?$AA@
  002cd	e9 97 00 00 00	 jmp	 $LN93@GetINIKeyN
$LN20@GetINIKeyN:

; 231  : 	case KTA_SOLDIER17:  
; 232  : 		return "SOLDIER17";

  002d2	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09ONOFIEPL@SOLDIER17?$AA@
  002d7	e9 8d 00 00 00	 jmp	 $LN93@GetINIKeyN
$LN19@GetINIKeyN:

; 233  : 	case KTA_SOLDIER18:  
; 234  : 		return "SOLDIER18";

  002dc	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09GKHNJIDE@SOLDIER18?$AA@
  002e1	e9 83 00 00 00	 jmp	 $LN93@GetINIKeyN
$LN18@GetINIKeyN:

; 235  : 	case KTA_SOLDIER19:  
; 236  : 		return "SOLDIER19";

  002e6	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09HDGGKJHF@SOLDIER19?$AA@
  002eb	eb 7c		 jmp	 SHORT $LN93@GetINIKeyN
$LN17@GetINIKeyN:

; 237  : 	case KTA_SOLDIER20:  
; 238  : 		return "SOLDIER20";

  002ed	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09KAOCKMGF@SOLDIER20?$AA@
  002f2	eb 75		 jmp	 SHORT $LN93@GetINIKeyN
$LN16@GetINIKeyN:

; 239  : 	case KTA_SOLDIER21:  
; 240  : 		return "SOLDIER21";

  002f4	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09LJPJJNCE@SOLDIER21?$AA@
  002f9	eb 6e		 jmp	 SHORT $LN93@GetINIKeyN
$LN15@GetINIKeyN:

; 241  : 	case KTA_SOLDIER22: 
; 242  : 		return "SOLDIER22";

  002fb	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09JCNEMOOH@SOLDIER22?$AA@
  00300	eb 67		 jmp	 SHORT $LN93@GetINIKeyN
$LN14@GetINIKeyN:

; 243  : 	case KTA_SOLDIER23: 
; 244  : 		return "SOLDIER23";

  00302	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09ILMPPPKG@SOLDIER23?$AA@
  00307	eb 60		 jmp	 SHORT $LN93@GetINIKeyN
$LN13@GetINIKeyN:

; 245  : 	case KTA_SOLDIER24: 
; 246  : 		return "SOLDIER24";

  00309	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09MEIOGJGB@SOLDIER24?$AA@
  0030e	eb 59		 jmp	 SHORT $LN93@GetINIKeyN
$LN12@GetINIKeyN:

; 247  : 	case KTA_SOLDIER25:  
; 248  : 		return "SOLDIER25";

  00310	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09NNJFFICA@SOLDIER25?$AA@
  00315	eb 52		 jmp	 SHORT $LN93@GetINIKeyN
$LN11@GetINIKeyN:

; 249  : 	case KTA_SOLDIER26:  
; 250  : 		return "SOLDIER26";

  00317	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09PGLIALOD@SOLDIER26?$AA@
  0031c	eb 4b		 jmp	 SHORT $LN93@GetINIKeyN
$LN10@GetINIKeyN:

; 251  : 	case KTA_SOLDIER27:  
; 252  : 		return "SOLDIER27";

  0031e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09OPKDDKKC@SOLDIER27?$AA@
  00323	eb 44		 jmp	 SHORT $LN93@GetINIKeyN
$LN9@GetINIKeyN:

; 253  : 	case KTA_SOLDIER28:  
; 254  : 		return "SOLDIER28";

  00325	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09GIDLCGGN@SOLDIER28?$AA@
  0032a	eb 3d		 jmp	 SHORT $LN93@GetINIKeyN
$LN8@GetINIKeyN:

; 255  : 	case KTA_SOLDIER29:  
; 256  : 		return "SOLDIER29";

  0032c	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09HBCABHCM@SOLDIER29?$AA@
  00331	eb 36		 jmp	 SHORT $LN93@GetINIKeyN
$LN7@GetINIKeyN:

; 257  : 	case KTA_SOLDIER30:  
; 258  : 		return "SOLDIER30";

  00333	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09KBCAMGFC@SOLDIER30?$AA@
  00338	eb 2f		 jmp	 SHORT $LN93@GetINIKeyN
$LN6@GetINIKeyN:

; 259  : 	case KTA_SOLDIER31:  
; 260  : 		return "SOLDIER31";

  0033a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09LIDLPHBD@SOLDIER31?$AA@
  0033f	eb 28		 jmp	 SHORT $LN93@GetINIKeyN
$LN5@GetINIKeyN:

; 261  : 	case KTA_SOLDIER32:  
; 262  : 		return "SOLDIER32";

  00341	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09JDBGKENA@SOLDIER32?$AA@
  00346	eb 21		 jmp	 SHORT $LN93@GetINIKeyN
$LN4@GetINIKeyN:

; 263  : 	case KTA_SOLDIER33:  
; 264  : 		return "SOLDIER33";

  00348	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09IKANJFJB@SOLDIER33?$AA@
  0034d	eb 1a		 jmp	 SHORT $LN93@GetINIKeyN
$LN3@GetINIKeyN:

; 265  : 	case KTA_SOLDIER34: 
; 266  : 		return "SOLDIER34";

  0034f	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09MFEMADFG@SOLDIER34?$AA@
  00354	eb 13		 jmp	 SHORT $LN93@GetINIKeyN
$LN2@GetINIKeyN:

; 267  : 	case KTA_SOLDIER35: 
; 268  : 		return "SOLDIER35";

  00356	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09NMFHDCBH@SOLDIER35?$AA@
  0035b	eb 0c		 jmp	 SHORT $LN93@GetINIKeyN
$LN1@GetINIKeyN:

; 269  : 	case KTA_SOLDIER36: 
; 270  : 		return "SOLDIER36";

  0035d	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09PHHKGBNE@SOLDIER36?$AA@
  00362	eb 05		 jmp	 SHORT $LN93@GetINIKeyN
$LN91@GetINIKeyN:

; 271  : 	}
; 272  : 
; 273  : 	return "NONE";

  00364	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04OKGDLNCL@NONE?$AA@
$LN93@GetINIKeyN:

; 274  : }

  00369	5d		 pop	 ebp
  0036a	c2 04 00	 ret	 4
  0036d	8d 49 00	 npad	 3
$LN95@GetINIKeyN:
  00370	00 00 00 00	 DD	 $LN90@GetINIKeyN
  00374	00 00 00 00	 DD	 $LN89@GetINIKeyN
  00378	00 00 00 00	 DD	 $LN88@GetINIKeyN
  0037c	00 00 00 00	 DD	 $LN87@GetINIKeyN
  00380	00 00 00 00	 DD	 $LN86@GetINIKeyN
  00384	00 00 00 00	 DD	 $LN85@GetINIKeyN
  00388	00 00 00 00	 DD	 $LN84@GetINIKeyN
  0038c	00 00 00 00	 DD	 $LN83@GetINIKeyN
  00390	00 00 00 00	 DD	 $LN82@GetINIKeyN
  00394	00 00 00 00	 DD	 $LN81@GetINIKeyN
  00398	00 00 00 00	 DD	 $LN80@GetINIKeyN
  0039c	00 00 00 00	 DD	 $LN79@GetINIKeyN
  003a0	00 00 00 00	 DD	 $LN78@GetINIKeyN
  003a4	00 00 00 00	 DD	 $LN77@GetINIKeyN
  003a8	00 00 00 00	 DD	 $LN76@GetINIKeyN
  003ac	00 00 00 00	 DD	 $LN75@GetINIKeyN
  003b0	00 00 00 00	 DD	 $LN74@GetINIKeyN
  003b4	00 00 00 00	 DD	 $LN73@GetINIKeyN
  003b8	00 00 00 00	 DD	 $LN72@GetINIKeyN
  003bc	00 00 00 00	 DD	 $LN71@GetINIKeyN
  003c0	00 00 00 00	 DD	 $LN70@GetINIKeyN
  003c4	00 00 00 00	 DD	 $LN69@GetINIKeyN
  003c8	00 00 00 00	 DD	 $LN91@GetINIKeyN
  003cc	00 00 00 00	 DD	 $LN91@GetINIKeyN
  003d0	00 00 00 00	 DD	 $LN91@GetINIKeyN
  003d4	00 00 00 00	 DD	 $LN63@GetINIKeyN
  003d8	00 00 00 00	 DD	 $LN64@GetINIKeyN
  003dc	00 00 00 00	 DD	 $LN91@GetINIKeyN
  003e0	00 00 00 00	 DD	 $LN62@GetINIKeyN
  003e4	00 00 00 00	 DD	 $LN91@GetINIKeyN
  003e8	00 00 00 00	 DD	 $LN58@GetINIKeyN
  003ec	00 00 00 00	 DD	 $LN57@GetINIKeyN
  003f0	00 00 00 00	 DD	 $LN56@GetINIKeyN
  003f4	00 00 00 00	 DD	 $LN55@GetINIKeyN
  003f8	00 00 00 00	 DD	 $LN54@GetINIKeyN
  003fc	00 00 00 00	 DD	 $LN53@GetINIKeyN
  00400	00 00 00 00	 DD	 $LN52@GetINIKeyN
  00404	00 00 00 00	 DD	 $LN51@GetINIKeyN
  00408	00 00 00 00	 DD	 $LN50@GetINIKeyN
  0040c	00 00 00 00	 DD	 $LN48@GetINIKeyN
  00410	00 00 00 00	 DD	 $LN47@GetINIKeyN
  00414	00 00 00 00	 DD	 $LN46@GetINIKeyN
  00418	00 00 00 00	 DD	 $LN45@GetINIKeyN
  0041c	00 00 00 00	 DD	 $LN44@GetINIKeyN
  00420	00 00 00 00	 DD	 $LN43@GetINIKeyN
  00424	00 00 00 00	 DD	 $LN42@GetINIKeyN
  00428	00 00 00 00	 DD	 $LN41@GetINIKeyN
  0042c	00 00 00 00	 DD	 $LN40@GetINIKeyN
  00430	00 00 00 00	 DD	 $LN39@GetINIKeyN
  00434	00 00 00 00	 DD	 $LN38@GetINIKeyN
  00438	00 00 00 00	 DD	 $LN37@GetINIKeyN
  0043c	00 00 00 00	 DD	 $LN36@GetINIKeyN
  00440	00 00 00 00	 DD	 $LN35@GetINIKeyN
  00444	00 00 00 00	 DD	 $LN34@GetINIKeyN
  00448	00 00 00 00	 DD	 $LN33@GetINIKeyN
  0044c	00 00 00 00	 DD	 $LN32@GetINIKeyN
  00450	00 00 00 00	 DD	 $LN31@GetINIKeyN
  00454	00 00 00 00	 DD	 $LN30@GetINIKeyN
  00458	00 00 00 00	 DD	 $LN29@GetINIKeyN
  0045c	00 00 00 00	 DD	 $LN28@GetINIKeyN
  00460	00 00 00 00	 DD	 $LN27@GetINIKeyN
  00464	00 00 00 00	 DD	 $LN26@GetINIKeyN
  00468	00 00 00 00	 DD	 $LN25@GetINIKeyN
  0046c	00 00 00 00	 DD	 $LN61@GetINIKeyN
  00470	00 00 00 00	 DD	 $LN60@GetINIKeyN
  00474	00 00 00 00	 DD	 $LN59@GetINIKeyN
  00478	00 00 00 00	 DD	 $LN24@GetINIKeyN
  0047c	00 00 00 00	 DD	 $LN23@GetINIKeyN
  00480	00 00 00 00	 DD	 $LN22@GetINIKeyN
  00484	00 00 00 00	 DD	 $LN21@GetINIKeyN
  00488	00 00 00 00	 DD	 $LN20@GetINIKeyN
  0048c	00 00 00 00	 DD	 $LN19@GetINIKeyN
  00490	00 00 00 00	 DD	 $LN18@GetINIKeyN
  00494	00 00 00 00	 DD	 $LN17@GetINIKeyN
  00498	00 00 00 00	 DD	 $LN16@GetINIKeyN
  0049c	00 00 00 00	 DD	 $LN15@GetINIKeyN
  004a0	00 00 00 00	 DD	 $LN14@GetINIKeyN
  004a4	00 00 00 00	 DD	 $LN13@GetINIKeyN
  004a8	00 00 00 00	 DD	 $LN12@GetINIKeyN
  004ac	00 00 00 00	 DD	 $LN11@GetINIKeyN
  004b0	00 00 00 00	 DD	 $LN10@GetINIKeyN
  004b4	00 00 00 00	 DD	 $LN9@GetINIKeyN
  004b8	00 00 00 00	 DD	 $LN8@GetINIKeyN
  004bc	00 00 00 00	 DD	 $LN7@GetINIKeyN
  004c0	00 00 00 00	 DD	 $LN6@GetINIKeyN
  004c4	00 00 00 00	 DD	 $LN5@GetINIKeyN
  004c8	00 00 00 00	 DD	 $LN4@GetINIKeyN
  004cc	00 00 00 00	 DD	 $LN3@GetINIKeyN
  004d0	00 00 00 00	 DD	 $LN2@GetINIKeyN
  004d4	00 00 00 00	 DD	 $LN1@GetINIKeyN
  004d8	00 00 00 00	 DD	 $LN68@GetINIKeyN
  004dc	00 00 00 00	 DD	 $LN67@GetINIKeyN
  004e0	00 00 00 00	 DD	 $LN66@GetINIKeyN
  004e4	00 00 00 00	 DD	 $LN65@GetINIKeyN
  004e8	00 00 00 00	 DD	 $LN49@GetINIKeyN
?GetINIKeyName@CKeyInfo@@IAEPADW4KeyTypeArray@1@@Z ENDP	; CKeyInfo::GetINIKeyName
_TEXT	ENDS
PUBLIC	??4tagMecroTextInfo@CKeyInfo@@QAEAAU01@ABU01@@Z	; CKeyInfo::tagMecroTextInfo::operator=
EXTRN	__imp_??4ioHashString@@QAEAAV0@ABV0@@Z:PROC
; Function compile flags: /Ogsp
;	COMDAT ??4tagMecroTextInfo@CKeyInfo@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4tagMecroTextInfo@CKeyInfo@@QAEAAU01@ABU01@@Z PROC	; CKeyInfo::tagMecroTextInfo::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8a 08		 mov	 cl, BYTE PTR [eax]
  0000b	83 c0 04	 add	 eax, 4
  0000e	88 0e		 mov	 BYTE PTR [esi], cl
  00010	50		 push	 eax
  00011	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@ABV0@@Z
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??4tagMecroTextInfo@CKeyInfo@@QAEAAU01@ABU01@@Z ENDP	; CKeyInfo::tagMecroTextInfo::operator=
_TEXT	ENDS
PUBLIC	??1tagMecroTextInfo@CKeyInfo@@QAE@XZ		; CKeyInfo::tagMecroTextInfo::~tagMecroTextInfo
EXTRN	__imp_??1ioHashString@@QAE@XZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ??1tagMecroTextInfo@CKeyInfo@@QAE@XZ
_TEXT	SEGMENT
??1tagMecroTextInfo@CKeyInfo@@QAE@XZ PROC		; CKeyInfo::tagMecroTextInfo::~tagMecroTextInfo, COMDAT
; _this$ = ecx
  00000	83 c1 04	 add	 ecx, 4
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
??1tagMecroTextInfo@CKeyInfo@@QAE@XZ ENDP		; CKeyInfo::tagMecroTextInfo::~tagMecroTextInfo
_TEXT	ENDS
PUBLIC	?SaveKey@CKeyInfo@@UAEXXZ			; CKeyInfo::SaveKey
; Function compile flags: /Ogsp
;	COMDAT ?SaveKey@CKeyInfo@@UAEXXZ
_TEXT	SEGMENT
?SaveKey@CKeyInfo@@UAEXXZ PROC				; CKeyInfo::SaveKey, COMDAT
; _this$ = ecx

; 357  : 
; 358  : }

  00000	c3		 ret	 0
?SaveKey@CKeyInfo@@UAEXXZ ENDP				; CKeyInfo::SaveKey
_TEXT	ENDS
PUBLIC	?SaveMacroTextInfo@CKeyInfo@@UAEXXZ		; CKeyInfo::SaveMacroTextInfo
; Function compile flags: /Ogsp
;	COMDAT ?SaveMacroTextInfo@CKeyInfo@@UAEXXZ
_TEXT	SEGMENT
?SaveMacroTextInfo@CKeyInfo@@UAEXXZ PROC		; CKeyInfo::SaveMacroTextInfo, COMDAT
; _this$ = ecx

; 362  : 
; 363  : }

  00000	c3		 ret	 0
?SaveMacroTextInfo@CKeyInfo@@UAEXXZ ENDP		; CKeyInfo::SaveMacroTextInfo
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
  00010	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00016	8b c6		 mov	 eax, esi
  00018	5e		 pop	 esi
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogsp
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1exception@std@@UAE@XZ
  00012	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00016	74 07		 je	 SHORT $LN1@scalar
  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001e	59		 pop	 ecx
$LN1@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1ioINILoader_e@@QAE@XZ			; ioINILoader_e::~ioINILoader_e
EXTRN	__imp_??1ioINILoader@@QAE@XZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ??1ioINILoader_e@@QAE@XZ
_TEXT	SEGMENT
??1ioINILoader_e@@QAE@XZ PROC				; ioINILoader_e::~ioINILoader_e, COMDAT
; _this$ = ecx
  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioINILoader@@QAE@XZ
??1ioINILoader_e@@QAE@XZ ENDP				; ioINILoader_e::~ioINILoader_e
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 56   : 	{	// construct array with placement at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : 	return (_Where);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 58   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogsp
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 62   : 	}

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 49   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
PUBLIC	?IsRightKey@CJoyKeyInfo@@QAE_NG@Z		; CJoyKeyInfo::IsRightKey
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iokeymanager.cpp
;	COMDAT ?IsRightKey@CJoyKeyInfo@@QAE_NG@Z
_TEXT	SEGMENT
_wKey$ = 8						; size = 2
?IsRightKey@CJoyKeyInfo@@QAE_NG@Z PROC			; CJoyKeyInfo::IsRightKey, COMDAT
; _this$ = ecx

; 696  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 	if( wKey == KEY_ENTER  ||
; 698  : 		wKey == KEY_ESCAPE ||
; 699  : 		wKey == KEY_LWIN   ||
; 700  : 		wKey == KEY_RWIN)

  00003	66 8b 45 08	 mov	 ax, WORD PTR _wKey$[ebp]
  00007	66 83 f8 0d	 cmp	 ax, 13			; 0000000dH
  0000b	74 1a		 je	 SHORT $LN1@IsRightKey@2
  0000d	66 83 f8 1b	 cmp	 ax, 27			; 0000001bH
  00011	74 14		 je	 SHORT $LN1@IsRightKey@2
  00013	b9 b1 00 00 00	 mov	 ecx, 177		; 000000b1H
  00018	66 3b c1	 cmp	 ax, cx
  0001b	74 0a		 je	 SHORT $LN1@IsRightKey@2
  0001d	41		 inc	 ecx
  0001e	66 3b c1	 cmp	 ax, cx
  00021	74 04		 je	 SHORT $LN1@IsRightKey@2

; 703  : 	}
; 704  : 
; 705  : 	return true;

  00023	b0 01		 mov	 al, 1
  00025	eb 02		 jmp	 SHORT $LN3@IsRightKey@2
$LN1@IsRightKey@2:

; 701  : 	{
; 702  : 		return false;

  00027	32 c0		 xor	 al, al
$LN3@IsRightKey@2:

; 706  : }

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?IsRightKey@CJoyKeyInfo@@QAE_NG@Z ENDP			; CJoyKeyInfo::IsRightKey
_TEXT	ENDS
PUBLIC	?GetINIKeyName@CJoyKeyInfo@@IAEPADW4KeyTypeArray@1@@Z ; CJoyKeyInfo::GetINIKeyName
; Function compile flags: /Ogsp
;	COMDAT ?GetINIKeyName@CJoyKeyInfo@@IAEPADW4KeyTypeArray@1@@Z
_TEXT	SEGMENT
_eKeyTypeArray$ = 8					; size = 4
?GetINIKeyName@CJoyKeyInfo@@IAEPADW4KeyTypeArray@1@@Z PROC ; CJoyKeyInfo::GetINIKeyName, COMDAT
; _this$ = ecx

; 709  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 710  : 	switch(eKeyTypeArray)

  00003	8b 45 08	 mov	 eax, DWORD PTR _eKeyTypeArray$[ebp]
  00006	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00009	0f 87 a7 01 00
	00		 ja	 $LN48@GetINIKeyN@2
  0000f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN52@GetINIKeyN@2[eax*4]
$LN47@GetINIKeyN@2:

; 711  : 	{
; 712  : 		// game key
; 713  : 	case JTA_UP:
; 714  : 		return "UP";

  00016	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_02NAHCJHOC@UP?$AA@
  0001b	e9 9b 01 00 00	 jmp	 $LN50@GetINIKeyN@2
$LN46@GetINIKeyN@2:

; 715  : 	case JTA_DOWN:
; 716  : 		return "DOWN";

  00020	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04FANAOELO@DOWN?$AA@
  00025	e9 91 01 00 00	 jmp	 $LN50@GetINIKeyN@2
$LN45@GetINIKeyN@2:

; 717  : 	case JTA_LEFT:
; 718  : 		return "LEFT";

  0002a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04KCNEHMIH@LEFT?$AA@
  0002f	e9 87 01 00 00	 jmp	 $LN50@GetINIKeyN@2
$LN44@GetINIKeyN@2:

; 719  : 	case JTA_RIGHT: 
; 720  : 		return "RIGHT";

  00034	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_05PMAFOJDE@RIGHT?$AA@
  00039	e9 7d 01 00 00	 jmp	 $LN50@GetINIKeyN@2
$LN43@GetINIKeyN@2:

; 721  : 	case JTA_ATTACK:
; 722  : 		return "ATTACK";

  0003e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_06JIJKOHKJ@ATTACK?$AA@
  00043	e9 73 01 00 00	 jmp	 $LN50@GetINIKeyN@2
$LN42@GetINIKeyN@2:

; 723  : 	case JTA_DEFENSE:
; 724  : 		return "DEFENSE";

  00048	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_07PABEIMLA@DEFENSE?$AA@
  0004d	e9 69 01 00 00	 jmp	 $LN50@GetINIKeyN@2
$LN41@GetINIKeyN@2:

; 725  : 	case JTA_JUMP:
; 726  : 		return "JUMP";

  00052	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04BFLEPEFN@JUMP?$AA@
  00057	e9 5f 01 00 00	 jmp	 $LN50@GetINIKeyN@2
$LN40@GetINIKeyN@2:

; 727  : 		// skill key
; 728  : 	case JTA_CLOAK_SKILL:
; 729  : 		return "CLOAK_SKILL";

  0005c	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0M@HONOKLCP@CLOAK_SKILL?$AA@
  00061	e9 55 01 00 00	 jmp	 $LN50@GetINIKeyN@2
$LN39@GetINIKeyN@2:

; 730  : 	case JTA_HELM_SKILL:
; 731  : 		return "HELM_SKILL";

  00066	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0L@LJKKLEDH@HELM_SKILL?$AA@
  0006b	e9 4b 01 00 00	 jmp	 $LN50@GetINIKeyN@2
$LN38@GetINIKeyN@2:

; 732  : 	case JTA_ARMOR_SKILL:
; 733  : 		return "ARMOR_SKILL";

  00070	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0M@MBKGPLNC@ARMOR_SKILL?$AA@
  00075	e9 41 01 00 00	 jmp	 $LN50@GetINIKeyN@2
$LN37@GetINIKeyN@2:

; 734  : 	case JTA_WEAPON_SKILL:
; 735  : 		return "WEAPON_SKILL";

  0007a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0N@MKIPNJP@WEAPON_SKILL?$AA@
  0007f	e9 37 01 00 00	 jmp	 $LN50@GetINIKeyN@2
$LN36@GetINIKeyN@2:

; 736  : 		// soldier
; 737  : 	case JTA_SOLDIER1:  
; 738  : 		return "SOLDIER1";

  00084	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08OFLKHOIP@SOLDIER1?$AA@
  00089	e9 2d 01 00 00	 jmp	 $LN50@GetINIKeyN@2
$LN35@GetINIKeyN@2:

; 739  : 	case JTA_SOLDIER2:  
; 740  : 		return "SOLDIER2";

  0008e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08MOJHCNEM@SOLDIER2?$AA@
  00093	e9 23 01 00 00	 jmp	 $LN50@GetINIKeyN@2
$LN34@GetINIKeyN@2:

; 741  : 	case JTA_SOLDIER3:  
; 742  : 		return "SOLDIER3";

  00098	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08NHIMBMAN@SOLDIER3?$AA@
  0009d	e9 19 01 00 00	 jmp	 $LN50@GetINIKeyN@2
$LN33@GetINIKeyN@2:

; 743  : 	case JTA_SOLDIER4:  
; 744  : 		return "SOLDIER4";

  000a2	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08JIMNIKMK@SOLDIER4?$AA@
  000a7	e9 0f 01 00 00	 jmp	 $LN50@GetINIKeyN@2
$LN32@GetINIKeyN@2:

; 745  : 	case JTA_SOLDIER5:  
; 746  : 		return "SOLDIER5";

  000ac	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08IBNGLLIL@SOLDIER5?$AA@
  000b1	e9 05 01 00 00	 jmp	 $LN50@GetINIKeyN@2
$LN31@GetINIKeyN@2:

; 747  : 	case JTA_SOLDIER6:  
; 748  : 		return "SOLDIER6";

  000b6	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08KKPLOIEI@SOLDIER6?$AA@
  000bb	e9 fb 00 00 00	 jmp	 $LN50@GetINIKeyN@2
$LN30@GetINIKeyN@2:

; 749  : 	case JTA_SOLDIER7:  
; 750  : 		return "SOLDIER7";

  000c0	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08LDOANJAJ@SOLDIER7?$AA@
  000c5	e9 f1 00 00 00	 jmp	 $LN50@GetINIKeyN@2
$LN29@GetINIKeyN@2:

; 751  : 	case JTA_SOLDIER8:  
; 752  : 		return "SOLDIER8";

  000ca	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08DEHIMFMG@SOLDIER8?$AA@
  000cf	e9 e7 00 00 00	 jmp	 $LN50@GetINIKeyN@2
$LN28@GetINIKeyN@2:

; 753  : 	case JTA_SOLDIER9:  
; 754  : 		return "SOLDIER9";

  000d4	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08CNGDPEIH@SOLDIER9?$AA@
  000d9	e9 dd 00 00 00	 jmp	 $LN50@GetINIKeyN@2
$LN27@GetINIKeyN@2:

; 755  : 	case JTA_SOLDIER10: 
; 756  : 		return "SOLDIER10";

  000de	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09KCKEBCDM@SOLDIER10?$AA@
  000e3	e9 d3 00 00 00	 jmp	 $LN50@GetINIKeyN@2
$LN26@GetINIKeyN@2:

; 757  : 	case JTA_SOLDIER11: 
; 758  : 		return "SOLDIER11";

  000e8	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09LLLPCDHN@SOLDIER11?$AA@
  000ed	e9 c9 00 00 00	 jmp	 $LN50@GetINIKeyN@2
$LN25@GetINIKeyN@2:

; 759  : 	case JTA_SOLDIER12: 
; 760  : 		return "SOLDIER12";

  000f2	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09JAJCHALO@SOLDIER12?$AA@
  000f7	e9 bf 00 00 00	 jmp	 $LN50@GetINIKeyN@2
$LN24@GetINIKeyN@2:

; 761  : 	case JTA_SOLDIER13:  
; 762  : 		return "SOLDIER13";

  000fc	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09IJIJEBPP@SOLDIER13?$AA@
  00101	e9 b5 00 00 00	 jmp	 $LN50@GetINIKeyN@2
$LN23@GetINIKeyN@2:

; 763  : 	case JTA_SOLDIER14:  
; 764  : 		return "SOLDIER14";

  00106	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09MGMINHDI@SOLDIER14?$AA@
  0010b	e9 ab 00 00 00	 jmp	 $LN50@GetINIKeyN@2
$LN22@GetINIKeyN@2:

; 765  : 	case JTA_SOLDIER15:  
; 766  : 		return "SOLDIER15";

  00110	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09NPNDOGHJ@SOLDIER15?$AA@
  00115	e9 a1 00 00 00	 jmp	 $LN50@GetINIKeyN@2
$LN21@GetINIKeyN@2:

; 767  : 	case JTA_SOLDIER16:  
; 768  : 		return "SOLDIER16";

  0011a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09PEPOLFLK@SOLDIER16?$AA@
  0011f	e9 97 00 00 00	 jmp	 $LN50@GetINIKeyN@2
$LN20@GetINIKeyN@2:

; 769  : 	case JTA_SOLDIER17:  
; 770  : 		return "SOLDIER17";

  00124	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09ONOFIEPL@SOLDIER17?$AA@
  00129	e9 8d 00 00 00	 jmp	 $LN50@GetINIKeyN@2
$LN19@GetINIKeyN@2:

; 771  : 	case JTA_SOLDIER18:  
; 772  : 		return "SOLDIER18";

  0012e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09GKHNJIDE@SOLDIER18?$AA@
  00133	e9 83 00 00 00	 jmp	 $LN50@GetINIKeyN@2
$LN18@GetINIKeyN@2:

; 773  : 	case JTA_SOLDIER19: 
; 774  : 		return "SOLDIER19";

  00138	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09HDGGKJHF@SOLDIER19?$AA@
  0013d	eb 7c		 jmp	 SHORT $LN50@GetINIKeyN@2
$LN17@GetINIKeyN@2:

; 775  : 	case JTA_SOLDIER20:  
; 776  : 		return "SOLDIER20";

  0013f	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09KAOCKMGF@SOLDIER20?$AA@
  00144	eb 75		 jmp	 SHORT $LN50@GetINIKeyN@2
$LN16@GetINIKeyN@2:

; 777  : 	case JTA_SOLDIER21:  
; 778  : 		return "SOLDIER21";

  00146	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09LJPJJNCE@SOLDIER21?$AA@
  0014b	eb 6e		 jmp	 SHORT $LN50@GetINIKeyN@2
$LN15@GetINIKeyN@2:

; 779  : 	case JTA_SOLDIER22:  
; 780  : 		return "SOLDIER22";

  0014d	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09JCNEMOOH@SOLDIER22?$AA@
  00152	eb 67		 jmp	 SHORT $LN50@GetINIKeyN@2
$LN14@GetINIKeyN@2:

; 781  : 	case JTA_SOLDIER23: 
; 782  : 		return "SOLDIER23";

  00154	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09ILMPPPKG@SOLDIER23?$AA@
  00159	eb 60		 jmp	 SHORT $LN50@GetINIKeyN@2
$LN13@GetINIKeyN@2:

; 783  : 	case JTA_SOLDIER24: 
; 784  : 		return "SOLDIER24";

  0015b	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09MEIOGJGB@SOLDIER24?$AA@
  00160	eb 59		 jmp	 SHORT $LN50@GetINIKeyN@2
$LN12@GetINIKeyN@2:

; 785  : 	case JTA_SOLDIER25: 
; 786  : 		return "SOLDIER25";

  00162	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09NNJFFICA@SOLDIER25?$AA@
  00167	eb 52		 jmp	 SHORT $LN50@GetINIKeyN@2
$LN11@GetINIKeyN@2:

; 787  : 	case JTA_SOLDIER26:  
; 788  : 		return "SOLDIER26";

  00169	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09PGLIALOD@SOLDIER26?$AA@
  0016e	eb 4b		 jmp	 SHORT $LN50@GetINIKeyN@2
$LN10@GetINIKeyN@2:

; 789  : 	case JTA_SOLDIER27:  
; 790  : 		return "SOLDIER27";

  00170	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09OPKDDKKC@SOLDIER27?$AA@
  00175	eb 44		 jmp	 SHORT $LN50@GetINIKeyN@2
$LN9@GetINIKeyN@2:

; 791  : 	case JTA_SOLDIER28:  
; 792  : 		return "SOLDIER28";

  00177	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09GIDLCGGN@SOLDIER28?$AA@
  0017c	eb 3d		 jmp	 SHORT $LN50@GetINIKeyN@2
$LN8@GetINIKeyN@2:

; 793  : 	case JTA_SOLDIER29:  
; 794  : 		return "SOLDIER29";

  0017e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09HBCABHCM@SOLDIER29?$AA@
  00183	eb 36		 jmp	 SHORT $LN50@GetINIKeyN@2
$LN7@GetINIKeyN@2:

; 795  : 	case JTA_SOLDIER30:  
; 796  : 		return "SOLDIER30";

  00185	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09KBCAMGFC@SOLDIER30?$AA@
  0018a	eb 2f		 jmp	 SHORT $LN50@GetINIKeyN@2
$LN6@GetINIKeyN@2:

; 797  : 	case JTA_SOLDIER31:  
; 798  : 		return "SOLDIER31";

  0018c	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09LIDLPHBD@SOLDIER31?$AA@
  00191	eb 28		 jmp	 SHORT $LN50@GetINIKeyN@2
$LN5@GetINIKeyN@2:

; 799  : 	case JTA_SOLDIER32:  
; 800  : 		return "SOLDIER32";

  00193	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09JDBGKENA@SOLDIER32?$AA@
  00198	eb 21		 jmp	 SHORT $LN50@GetINIKeyN@2
$LN4@GetINIKeyN@2:

; 801  : 	case JTA_SOLDIER33:  
; 802  : 		return "SOLDIER33";

  0019a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09IKANJFJB@SOLDIER33?$AA@
  0019f	eb 1a		 jmp	 SHORT $LN50@GetINIKeyN@2
$LN3@GetINIKeyN@2:

; 803  : 	case JTA_SOLDIER34:  
; 804  : 		return "SOLDIER34";

  001a1	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09MFEMADFG@SOLDIER34?$AA@
  001a6	eb 13		 jmp	 SHORT $LN50@GetINIKeyN@2
$LN2@GetINIKeyN@2:

; 805  : 	case JTA_SOLDIER35: 
; 806  : 		return "SOLDIER35";

  001a8	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09NMFHDCBH@SOLDIER35?$AA@
  001ad	eb 0c		 jmp	 SHORT $LN50@GetINIKeyN@2
$LN1@GetINIKeyN@2:

; 807  : 	case JTA_SOLDIER36: 
; 808  : 		return "SOLDIER36";

  001af	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09PHHKGBNE@SOLDIER36?$AA@
  001b4	eb 05		 jmp	 SHORT $LN50@GetINIKeyN@2
$LN48@GetINIKeyN@2:

; 809  : 	}
; 810  : 
; 811  : 	return "NONE";

  001b6	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04OKGDLNCL@NONE?$AA@
$LN50@GetINIKeyN@2:

; 812  : }

  001bb	5d		 pop	 ebp
  001bc	c2 04 00	 ret	 4
  001bf	90		 npad	 1
$LN52@GetINIKeyN@2:
  001c0	00 00 00 00	 DD	 $LN47@GetINIKeyN@2
  001c4	00 00 00 00	 DD	 $LN46@GetINIKeyN@2
  001c8	00 00 00 00	 DD	 $LN45@GetINIKeyN@2
  001cc	00 00 00 00	 DD	 $LN44@GetINIKeyN@2
  001d0	00 00 00 00	 DD	 $LN43@GetINIKeyN@2
  001d4	00 00 00 00	 DD	 $LN42@GetINIKeyN@2
  001d8	00 00 00 00	 DD	 $LN41@GetINIKeyN@2
  001dc	00 00 00 00	 DD	 $LN40@GetINIKeyN@2
  001e0	00 00 00 00	 DD	 $LN39@GetINIKeyN@2
  001e4	00 00 00 00	 DD	 $LN38@GetINIKeyN@2
  001e8	00 00 00 00	 DD	 $LN37@GetINIKeyN@2
  001ec	00 00 00 00	 DD	 $LN36@GetINIKeyN@2
  001f0	00 00 00 00	 DD	 $LN35@GetINIKeyN@2
  001f4	00 00 00 00	 DD	 $LN34@GetINIKeyN@2
  001f8	00 00 00 00	 DD	 $LN33@GetINIKeyN@2
  001fc	00 00 00 00	 DD	 $LN32@GetINIKeyN@2
  00200	00 00 00 00	 DD	 $LN31@GetINIKeyN@2
  00204	00 00 00 00	 DD	 $LN30@GetINIKeyN@2
  00208	00 00 00 00	 DD	 $LN29@GetINIKeyN@2
  0020c	00 00 00 00	 DD	 $LN28@GetINIKeyN@2
  00210	00 00 00 00	 DD	 $LN27@GetINIKeyN@2
  00214	00 00 00 00	 DD	 $LN26@GetINIKeyN@2
  00218	00 00 00 00	 DD	 $LN25@GetINIKeyN@2
  0021c	00 00 00 00	 DD	 $LN24@GetINIKeyN@2
  00220	00 00 00 00	 DD	 $LN23@GetINIKeyN@2
  00224	00 00 00 00	 DD	 $LN22@GetINIKeyN@2
  00228	00 00 00 00	 DD	 $LN21@GetINIKeyN@2
  0022c	00 00 00 00	 DD	 $LN20@GetINIKeyN@2
  00230	00 00 00 00	 DD	 $LN19@GetINIKeyN@2
  00234	00 00 00 00	 DD	 $LN18@GetINIKeyN@2
  00238	00 00 00 00	 DD	 $LN17@GetINIKeyN@2
  0023c	00 00 00 00	 DD	 $LN16@GetINIKeyN@2
  00240	00 00 00 00	 DD	 $LN15@GetINIKeyN@2
  00244	00 00 00 00	 DD	 $LN14@GetINIKeyN@2
  00248	00 00 00 00	 DD	 $LN13@GetINIKeyN@2
  0024c	00 00 00 00	 DD	 $LN12@GetINIKeyN@2
  00250	00 00 00 00	 DD	 $LN11@GetINIKeyN@2
  00254	00 00 00 00	 DD	 $LN10@GetINIKeyN@2
  00258	00 00 00 00	 DD	 $LN9@GetINIKeyN@2
  0025c	00 00 00 00	 DD	 $LN8@GetINIKeyN@2
  00260	00 00 00 00	 DD	 $LN7@GetINIKeyN@2
  00264	00 00 00 00	 DD	 $LN6@GetINIKeyN@2
  00268	00 00 00 00	 DD	 $LN5@GetINIKeyN@2
  0026c	00 00 00 00	 DD	 $LN4@GetINIKeyN@2
  00270	00 00 00 00	 DD	 $LN3@GetINIKeyN@2
  00274	00 00 00 00	 DD	 $LN2@GetINIKeyN@2
  00278	00 00 00 00	 DD	 $LN1@GetINIKeyN@2
?GetINIKeyName@CJoyKeyInfo@@IAEPADW4KeyTypeArray@1@@Z ENDP ; CJoyKeyInfo::GetINIKeyName
_TEXT	ENDS
PUBLIC	?SaveKey@CJoyKeyInfo@@UAEXXZ			; CJoyKeyInfo::SaveKey
; Function compile flags: /Ogsp
;	COMDAT ?SaveKey@CJoyKeyInfo@@UAEXXZ
_TEXT	SEGMENT
?SaveKey@CJoyKeyInfo@@UAEXXZ PROC			; CJoyKeyInfo::SaveKey, COMDAT
; _this$ = ecx

; 851  : 
; 852  : }

  00000	c3		 ret	 0
?SaveKey@CJoyKeyInfo@@UAEXXZ ENDP			; CJoyKeyInfo::SaveKey
_TEXT	ENDS
PUBLIC	??1?$_Pair_base@$$CBGVioHashString@@@std@@QAE@XZ ; std::_Pair_base<unsigned short const ,ioHashString>::~_Pair_base<unsigned short const ,ioHashString>
; Function compile flags: /Ogsp
;	COMDAT ??1?$_Pair_base@$$CBGVioHashString@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Pair_base@$$CBGVioHashString@@@std@@QAE@XZ PROC	; std::_Pair_base<unsigned short const ,ioHashString>::~_Pair_base<unsigned short const ,ioHashString>, COMDAT
; _this$ = ecx
  00000	83 c1 04	 add	 ecx, 4
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
??1?$_Pair_base@$$CBGVioHashString@@@std@@QAE@XZ ENDP	; std::_Pair_base<unsigned short const ,ioHashString>::~_Pair_base<unsigned short const ,ioHashString>
_TEXT	ENDS
PUBLIC	?SaveJoyKey@ioKeyManager@@QAEXXZ		; ioKeyManager::SaveJoyKey
; Function compile flags: /Ogsp
;	COMDAT ?SaveJoyKey@ioKeyManager@@QAEXXZ
_TEXT	SEGMENT
?SaveJoyKey@ioKeyManager@@QAEXXZ PROC			; ioKeyManager::SaveJoyKey, COMDAT
; _this$ = ecx

; 1490 : {

  00000	56		 push	 esi

; 1491 : 	if( m_bSaveJoyKey )

  00001	8d b1 97 00 00
	00		 lea	 esi, DWORD PTR [ecx+151]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	74 0a		 je	 SHORT $LN1@SaveJoyKey

; 1492 : 	{
; 1493 : 		m_CustomJoyKeyInfo.SaveKey();

  0000c	83 c1 6c	 add	 ecx, 108		; 0000006cH
  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	ff 10		 call	 DWORD PTR [eax]

; 1494 : 		m_bSaveJoyKey = false;

  00013	c6 06 00	 mov	 BYTE PTR [esi], 0
$LN1@SaveJoyKey:
  00016	5e		 pop	 esi

; 1495 : 	}
; 1496 : }

  00017	c3		 ret	 0
?SaveJoyKey@ioKeyManager@@QAEXXZ ENDP			; ioKeyManager::SaveJoyKey
_TEXT	ENDS
PUBLIC	?SaveMacroTextInfo@ioKeyManager@@QAEXXZ		; ioKeyManager::SaveMacroTextInfo
; Function compile flags: /Ogsp
;	COMDAT ?SaveMacroTextInfo@ioKeyManager@@QAEXXZ
_TEXT	SEGMENT
?SaveMacroTextInfo@ioKeyManager@@QAEXXZ PROC		; ioKeyManager::SaveMacroTextInfo, COMDAT
; _this$ = ecx

; 1499 : {

  00000	56		 push	 esi

; 1500 : 	if( m_bSaveMacroText )

  00001	8d b1 98 00 00
	00		 lea	 esi, DWORD PTR [ecx+152]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	74 0b		 je	 SHORT $LN1@SaveMacroT

; 1501 : 	{
; 1502 : 		m_CustomKeyInfo.SaveMacroTextInfo();

  0000c	83 c1 2c	 add	 ecx, 44			; 0000002cH
  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	ff 50 04	 call	 DWORD PTR [eax+4]

; 1503 : 		m_bSaveMacroText = false;

  00014	c6 06 00	 mov	 BYTE PTR [esi], 0
$LN1@SaveMacroT:
  00017	5e		 pop	 esi

; 1504 : 	}
; 1505 : }

  00018	c3		 ret	 0
?SaveMacroTextInfo@ioKeyManager@@QAEXXZ ENDP		; ioKeyManager::SaveMacroTextInfo
_TEXT	ENDS
PUBLIC	?SetServerKeys@ioKeyManager@@QAEXABUControlKeys@@@Z ; ioKeyManager::SetServerKeys
; Function compile flags: /Ogsp
;	COMDAT ?SetServerKeys@ioKeyManager@@QAEXABUControlKeys@@@Z
_TEXT	SEGMENT
_rkServerKeys$ = 8					; size = 4
?SetServerKeys@ioKeyManager@@QAEXABUControlKeys@@@Z PROC ; ioKeyManager::SetServerKeys, COMDAT
; _this$ = ecx

; 1996 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1997 : 	m_kServerKeys = rkServerKeys;

  00004	8b 75 08	 mov	 esi, DWORD PTR _rkServerKeys$[ebp]
  00007	57		 push	 edi
  00008	6a 32		 push	 50			; 00000032H
  0000a	8d b9 99 00 00
	00		 lea	 edi, DWORD PTR [ecx+153]
  00010	59		 pop	 ecx
  00011	f3 a5		 rep movsd
  00013	a4		 movsb
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi

; 1998 : }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?SetServerKeys@ioKeyManager@@QAEXABUControlKeys@@@Z ENDP ; ioKeyManager::SetServerKeys
_TEXT	ENDS
PUBLIC	?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::size
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	d1 f8		 sar	 eax, 1

; 880  : 		}

  00007	c3		 ret	 0
?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@GV?$allocator@G@std@@@std@@QAEAAGI@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::operator[]
; Function compile flags: /Ogsp
;	COMDAT ??A?$vector@GV?$allocator@G@std@@@std@@QAEAAGI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@GV?$allocator@G@std@@@std@@QAEAAGI@Z PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pos$[ebp]
  00008	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]

; 941  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@GV?$allocator@G@std@@@std@@QAEAAGI@Z ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QBEIXZ ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::size
; Function compile flags: /Ogsp
;	COMDAT ?size@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	6a 14		 push	 20			; 00000014H
  00007	99		 cdq
  00008	59		 pop	 ecx
  00009	f7 f9		 idiv	 ecx

; 880  : 		}

  0000b	c3		 ret	 0
?size@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::size
_TEXT	ENDS
PUBLIC	?empty@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QBE_NXZ ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::empty
; Function compile flags: /Ogsp
;	COMDAT ?empty@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QBE_NXZ PROC ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::empty, COMDAT
; _this$ = ecx

; 889  : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00005	f7 d8		 neg	 eax
  00007	1b c0		 sbb	 eax, eax
  00009	40		 inc	 eax

; 890  : 		}

  0000a	c3		 ret	 0
?empty@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QBE_NXZ ENDP ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::empty
_TEXT	ENDS
PUBLIC	??A?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QBEABUtagMecroTextInfo@CKeyInfo@@I@Z ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::operator[]
; Function compile flags: /Ogsp
;	COMDAT ??A?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QBEABUtagMecroTextInfo@CKeyInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QBEABUtagMecroTextInfo@CKeyInfo@@I@Z PROC ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::operator[], COMDAT
; _this$ = ecx

; 912  : 		{	// subscript nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 913  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 914  : 		if (size() <= _Pos)
; 915  : 			{	// report error
; 916  : 			_DEBUG_ERROR("vector subscript out of range");
; 917  : 			_SCL_SECURE_OUT_OF_RANGE;
; 918  : 			}
; 919  : 
; 920  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 921  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 922  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 923  : 
; 924  : 		return (*(this->_Myfirst + _Pos));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00006	6b c0 14	 imul	 eax, 20			; 00000014H
  00009	03 01		 add	 eax, DWORD PTR [ecx]

; 925  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QBEABUtagMecroTextInfo@CKeyInfo@@I@Z ENDP ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEAAUtagMecroTextInfo@CKeyInfo@@I@Z ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::operator[]
; Function compile flags: /Ogsp
;	COMDAT ??A?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEAAUtagMecroTextInfo@CKeyInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEAAUtagMecroTextInfo@CKeyInfo@@I@Z PROC ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00006	6b c0 14	 imul	 eax, 20			; 00000014H
  00009	03 01		 add	 eax, DWORD PTR [ecx]

; 941  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEAAUtagMecroTextInfo@CKeyInfo@@I@Z ENDP ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::operator[]
_TEXT	ENDS
PUBLIC	??0?$Singleton@VioKeyManager@@@@QAE@XZ		; Singleton<ioKeyManager>::Singleton<ioKeyManager>
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\io3dengine\iosingleton.h
;	COMDAT ??0?$Singleton@VioKeyManager@@@@QAE@XZ
_TEXT	SEGMENT
??0?$Singleton@VioKeyManager@@@@QAE@XZ PROC		; Singleton<ioKeyManager>::Singleton<ioKeyManager>, COMDAT
; _this$ = ecx

; 27   : 	Singleton()

  00000	8b c1		 mov	 eax, ecx

; 28   : 	{
; 29   : 		assert( !ms_Singleton );
; 30   : 		int offset = (int)(T*)1 - (int)(Singleton <T>*)(T*)1;
; 31   : 		ms_Singleton = (T*)((int)this + offset);

  00002	8d 48 fc	 lea	 ecx, DWORD PTR [eax-4]
  00005	89 0d 00 00 00
	00		 mov	 DWORD PTR ?ms_Singleton@?$Singleton@VioKeyManager@@@@1PAVioKeyManager@@A, ecx ; Singleton<ioKeyManager>::ms_Singleton

; 32   : 	}

  0000b	c3		 ret	 0
??0?$Singleton@VioKeyManager@@@@QAE@XZ ENDP		; Singleton<ioKeyManager>::Singleton<ioKeyManager>
_TEXT	ENDS
PUBLIC	??1?$Singleton@VioKeyManager@@@@QAE@XZ		; Singleton<ioKeyManager>::~Singleton<ioKeyManager>
; Function compile flags: /Ogsp
;	COMDAT ??1?$Singleton@VioKeyManager@@@@QAE@XZ
_TEXT	SEGMENT
??1?$Singleton@VioKeyManager@@@@QAE@XZ PROC		; Singleton<ioKeyManager>::~Singleton<ioKeyManager>, COMDAT
; _this$ = ecx

; 36   : 		assert( ms_Singleton );
; 37   : 		ms_Singleton = 0;

  00000	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_Singleton@?$Singleton@VioKeyManager@@@@1PAVioKeyManager@@A, 0 ; Singleton<ioKeyManager>::ms_Singleton

; 38   : 	}

  00007	c3		 ret	 0
??1?$Singleton@VioKeyManager@@@@QAE@XZ ENDP		; Singleton<ioKeyManager>::~Singleton<ioKeyManager>
_TEXT	ENDS
PUBLIC	?GetSingleton@?$Singleton@VioKeyManager@@@@SAAAVioKeyManager@@XZ ; Singleton<ioKeyManager>::GetSingleton
; Function compile flags: /Ogsp
;	COMDAT ?GetSingleton@?$Singleton@VioKeyManager@@@@SAAAVioKeyManager@@XZ
_TEXT	SEGMENT
?GetSingleton@?$Singleton@VioKeyManager@@@@SAAAVioKeyManager@@XZ PROC ; Singleton<ioKeyManager>::GetSingleton, COMDAT

; 42   : 		assert( ms_Singleton );
; 43   : 		return (*ms_Singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_Singleton@?$Singleton@VioKeyManager@@@@1PAVioKeyManager@@A ; Singleton<ioKeyManager>::ms_Singleton

; 44   : 	}

  00005	c3		 ret	 0
?GetSingleton@?$Singleton@VioKeyManager@@@@SAAAVioKeyManager@@XZ ENDP ; Singleton<ioKeyManager>::GetSingleton
_TEXT	ENDS
PUBLIC	??R?$less@G@std@@QBE_NABG0@Z			; std::less<unsigned short>::operator()
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xfunctional
;	COMDAT ??R?$less@G@std@@QBE_NABG0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@G@std@@QBE_NABG0@Z PROC			; std::less<unsigned short>::operator(), COMDAT
; _this$ = ecx

; 124  : 		{	// apply operator< to operands

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 125  : 		return (_Left < _Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000c	66 3b 01	 cmp	 ax, WORD PTR [ecx]
  0000f	1b c0		 sbb	 eax, eax
  00011	f7 d8		 neg	 eax

; 126  : 		}

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??R?$less@G@std@@QBE_NABG0@Z ENDP			; std::less<unsigned short>::operator()
_TEXT	ENDS
PUBLIC	?capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::capacity
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::capacity, COMDAT
; _this$ = ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	d1 f8		 sar	 eax, 1

; 778  : 		}

  00007	c3		 ret	 0
?capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::capacity
_TEXT	ENDS
PUBLIC	?_Inside@?$vector@GV?$allocator@G@std@@@std@@IBE_NPBG@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Inside
; Function compile flags: /Ogsp
;	COMDAT ?_Inside@?$vector@GV?$allocator@G@std@@@std@@IBE_NPBG@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@GV?$allocator@G@std@@@std@@IBE_NPBG@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 09		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 05		 ja	 SHORT $LN3@Inside
  0000f	33 c0		 xor	 eax, eax
  00011	40		 inc	 eax
  00012	eb 02		 jmp	 SHORT $LN4@Inside
$LN3@Inside:
  00014	33 c0		 xor	 eax, eax
$LN4@Inside:

; 1287 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?_Inside@?$vector@GV?$allocator@G@std@@@std@@IBE_NPBG@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Inside
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@GV?$allocator@G@std@@@std@@IBEXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Xlen
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@GV?$allocator@G@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@GV?$allocator@G@std@@@std@@IBEXXZ PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::_Xlen, COMDAT
; _this$ = ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
  0000b	cc		 int	 3
?_Xlen@?$vector@GV?$allocator@G@std@@@std@@IBEXXZ ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::_Xlen
_TEXT	ENDS
PUBLIC	?_Orphan_range@?$vector@GV?$allocator@G@std@@@std@@IBEXPAG0@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Orphan_range
; Function compile flags: /Ogsp
;	COMDAT ?_Orphan_range@?$vector@GV?$allocator@G@std@@@std@@IBEXPAG0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@GV?$allocator@G@std@@@std@@IBEXPAG0@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1454 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@GV?$allocator@G@std@@@std@@IBEXPAG0@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@GV?$allocator@G@std@@@std@@QAE@XZ ; std::_Vector_val<unsigned short,std::allocator<unsigned short> >::~_Vector_val<unsigned short,std::allocator<unsigned short> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$_Vector_val@GV?$allocator@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@GV?$allocator@G@std@@@std@@QAE@XZ PROC	; std::_Vector_val<unsigned short,std::allocator<unsigned short> >::~_Vector_val<unsigned short,std::allocator<unsigned short> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@GV?$allocator@G@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<unsigned short,std::allocator<unsigned short> >::~_Vector_val<unsigned short,std::allocator<unsigned short> >
_TEXT	ENDS
PUBLIC	??0?$allocator@G@std@@QAE@XZ			; std::allocator<unsigned short>::allocator<unsigned short>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@G@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@G@std@@QAE@XZ PROC			; std::allocator<unsigned short>::allocator<unsigned short>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@G@std@@QAE@XZ ENDP			; std::allocator<unsigned short>::allocator<unsigned short>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@G@std@@QAEXPAGI@Z	; std::allocator<unsigned short>::deallocate
; Function compile flags: /Ogsp
;	COMDAT ?deallocate@?$allocator@G@std@@QAEXPAGI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@G@std@@QAEXPAGI@Z PROC		; std::allocator<unsigned short>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 183  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
?deallocate@?$allocator@G@std@@QAEXPAGI@Z ENDP		; std::allocator<unsigned short>::deallocate
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QBEIXZ ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::capacity
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::capacity, COMDAT
; _this$ = ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	6a 14		 push	 20			; 00000014H
  00007	99		 cdq
  00008	59		 pop	 ecx
  00009	f7 f9		 idiv	 ecx

; 778  : 		}

  0000b	c3		 ret	 0
?capacity@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::capacity
_TEXT	ENDS
PUBLIC	?_Inside@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IBE_NPBUtagMecroTextInfo@CKeyInfo@@@Z ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Inside
; Function compile flags: /Ogsp
;	COMDAT ?_Inside@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IBE_NPBUtagMecroTextInfo@CKeyInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IBE_NPBUtagMecroTextInfo@CKeyInfo@@@Z PROC ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 09		 jae	 SHORT $LN3@Inside@2
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 05		 ja	 SHORT $LN3@Inside@2
  0000f	33 c0		 xor	 eax, eax
  00011	40		 inc	 eax
  00012	eb 02		 jmp	 SHORT $LN4@Inside@2
$LN3@Inside@2:
  00014	33 c0		 xor	 eax, eax
$LN4@Inside@2:

; 1287 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?_Inside@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IBE_NPBUtagMecroTextInfo@CKeyInfo@@@Z ENDP ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Inside
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IBEXXZ ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Xlen
; Function compile flags: /Ogsp
;	COMDAT ?_Xlen@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IBEXXZ PROC ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Xlen, COMDAT
; _this$ = ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen@2:
$LN3@Xlen@2:
  0000b	cc		 int	 3
?_Xlen@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IBEXXZ ENDP ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Xlen
_TEXT	ENDS
PUBLIC	?_Orphan_range@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IBEXPAUtagMecroTextInfo@CKeyInfo@@0@Z ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Orphan_range
; Function compile flags: /Ogsp
;	COMDAT ?_Orphan_range@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IBEXPAUtagMecroTextInfo@CKeyInfo@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IBEXPAUtagMecroTextInfo@CKeyInfo@@0@Z PROC ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1454 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IBEXPAUtagMecroTextInfo@CKeyInfo@@0@Z ENDP ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::~_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::~_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::~_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAE@XZ ; std::allocator<CKeyInfo::tagMecroTextInfo>::allocator<CKeyInfo::tagMecroTextInfo>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAE@XZ PROC ; std::allocator<CKeyInfo::tagMecroTextInfo>::allocator<CKeyInfo::tagMecroTextInfo>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAE@XZ ENDP ; std::allocator<CKeyInfo::tagMecroTextInfo>::allocator<CKeyInfo::tagMecroTextInfo>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@I@Z ; std::allocator<CKeyInfo::tagMecroTextInfo>::deallocate
; Function compile flags: /Ogsp
;	COMDAT ?deallocate@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@I@Z PROC ; std::allocator<CKeyInfo::tagMecroTextInfo>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 183  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
?deallocate@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@I@Z ENDP ; std::allocator<CKeyInfo::tagMecroTextInfo>::deallocate
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<unsigned short const ,ioHashString> >::allocator<std::pair<unsigned short const ,ioHashString> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<unsigned short const ,ioHashString> >::allocator<std::pair<unsigned short const ,ioHashString> >, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<unsigned short const ,ioHashString> >::allocator<std::pair<unsigned short const ,ioHashString> >
_TEXT	ENDS
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::operator==
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::operator==, COMDAT
; _this$ = ecx

; 316  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 317  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 318  : 		if (this->_Getcont() == 0
; 319  : 			|| this->_Getcont() != _Right._Getcont())
; 320  : 			{	// report error
; 321  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 322  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 323  : 			}
; 324  : 
; 325  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 326  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 327  : 			&& this->_Getcont() == _Right._Getcont());
; 328  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 329  : 
; 330  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	f7 d8		 neg	 eax
  0000c	1b c0		 sbb	 eax, eax
  0000e	40		 inc	 eax

; 331  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >,std::_Iterator_base0>::_Mynode
; Function compile flags: /Ogsp
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 122  : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 123  : 		}

  00002	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
PUBLIC	??0?$allocator@G@std@@QAE@ABV01@@Z		; std::allocator<unsigned short>::allocator<unsigned short>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@G@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@G@std@@QAE@ABV01@@Z PROC			; std::allocator<unsigned short>::allocator<unsigned short>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@G@std@@QAE@ABV01@@Z ENDP			; std::allocator<unsigned short>::allocator<unsigned short>
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@G@std@@QBEIXZ		; std::allocator<unsigned short>::max_size
; Function compile flags: /Ogsp
;	COMDAT ?max_size@?$allocator@G@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@G@std@@QBEIXZ PROC		; std::allocator<unsigned short>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@G@std@@QBEIXZ ENDP		; std::allocator<unsigned short>::max_size
_TEXT	ENDS
PUBLIC	??0?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CKeyInfo::tagMecroTextInfo>::allocator<CKeyInfo::tagMecroTextInfo>
; Function compile flags: /Ogsp
;	COMDAT ??0?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CKeyInfo::tagMecroTextInfo>::allocator<CKeyInfo::tagMecroTextInfo>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CKeyInfo::tagMecroTextInfo>::allocator<CKeyInfo::tagMecroTextInfo>
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QBEIXZ ; std::allocator<CKeyInfo::tagMecroTextInfo>::max_size
; Function compile flags: /Ogsp
;	COMDAT ?max_size@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QBEIXZ PROC ; std::allocator<CKeyInfo::tagMecroTextInfo>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 cc cc cc 0c	 mov	 eax, 214748364		; 0cccccccH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QBEIXZ ENDP ; std::allocator<CKeyInfo::tagMecroTextInfo>::max_size
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Isnil
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Isnil, COMDAT

; 611  : 		{	// return reference to nil flag in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 612  : 		return ((char&)(*_Pnode)._Isnil);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 21	 add	 eax, 33			; 00000021H

; 613  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Isnil@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Left
; Function compile flags: /Ogsp
;	COMDAT ?_Left@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Left, COMDAT

; 621  : 		{	// return reference to left pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 622  : 		return ((_Nodepref)(*_Pnode)._Left);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 623  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Left@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Parent
; Function compile flags: /Ogsp
;	COMDAT ?_Parent@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Parent, COMDAT

; 626  : 		{	// return reference to parent pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 627  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 628  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Parent@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Right
; Function compile flags: /Ogsp
;	COMDAT ?_Right@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Right, COMDAT

; 631  : 		{	// return reference to right pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 632  : 		return ((_Nodepref)(*_Pnode)._Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 633  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Right@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBGVioHashString@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Myval
; Function compile flags: /Ogsp
;	COMDAT ?_Myval@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBGVioHashString@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBGVioHashString@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Myval, COMDAT

; 636  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 637  : 		return ((reference)(*_Pnode)._Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 638  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBGVioHashString@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned short const ,ioHashString> >::allocator<std::pair<unsigned short const ,ioHashString> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<unsigned short const ,ioHashString> >::allocator<std::pair<unsigned short const ,ioHashString> >, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned short const ,ioHashString> >::allocator<std::pair<unsigned short const ,ioHashString> >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Node>::deallocate
; Function compile flags: /Ogsp
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 183  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBGVioHashString@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::operator*
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBGVioHashString@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBGVioHashString@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 231  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 232  : 		if (this->_Getcont() == 0
; 233  : 			|| this->_Ptr == 0
; 234  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 235  : 			{	// report error
; 236  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 237  : 			_SCL_SECURE_OUT_OF_RANGE;
; 238  : 			}
; 239  : 
; 240  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 241  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 242  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 243  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 244  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 245  : 
; 246  : 		return (_Mytree::_Myval(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 247  : 		}

  00005	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBGVioHashString@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::operator*
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Color
; Function compile flags: /Ogsp
;	COMDAT ?_Color@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Color, COMDAT

; 606  : 		{	// return reference to color in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 607  : 		return ((char&)(*_Pnode)._Color);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 20	 add	 eax, 32			; 00000020H

; 608  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Color@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Color
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >,std::_Iterator_base0>
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 44   : 		this->_Adopt(_Plist);
; 45   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@std@@QAE@PAGPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<unsigned short,std::allocator<unsigned short> > >::_Vector_const_iterator<std::_Vector_val<unsigned short,std::allocator<unsigned short> > >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@std@@QAE@PAGPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@std@@QAE@PAGPBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<unsigned short,std::allocator<unsigned short> > >::_Vector_const_iterator<std::_Vector_val<unsigned short,std::allocator<unsigned short> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@std@@QAE@PAGPBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<unsigned short,std::allocator<unsigned short> > >::_Vector_const_iterator<std::_Vector_val<unsigned short,std::allocator<unsigned short> > >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@std@@QAE@PAUtagMecroTextInfo@CKeyInfo@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> > >::_Vector_const_iterator<std::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> > >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@std@@QAE@PAUtagMecroTextInfo@CKeyInfo@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@std@@QAE@PAUtagMecroTextInfo@CKeyInfo@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> > >::_Vector_const_iterator<std::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@std@@QAE@PAUtagMecroTextInfo@CKeyInfo@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> > >::_Vector_const_iterator<std::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> > >
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Max
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Max, COMDAT

; 641  : 		{	// return rightmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		while (!_Isnil(_Right(_Pnode)))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	eb 02		 jmp	 SHORT $LN14@Max
$LL2@Max:

; 643  : 			_Pnode = _Right(_Pnode);

  00008	8b c1		 mov	 eax, ecx
$LN14@Max:

; 642  : 		while (!_Isnil(_Right(_Pnode)))

  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	80 79 21 00	 cmp	 BYTE PTR [ecx+33], 0
  00011	74 f5		 je	 SHORT $LL2@Max

; 644  : 		return (_Pnode);
; 645  : 		}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Max@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Max
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Min
; Function compile flags: /Ogsp
;	COMDAT ?_Min@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Min, COMDAT

; 648  : 		{	// return leftmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 649  : 		while (!_Isnil(_Left(_Pnode)))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	eb 02		 jmp	 SHORT $LN14@Min
$LL2@Min:

; 650  : 			_Pnode = _Left(_Pnode);

  00008	8b c1		 mov	 eax, ecx
$LN14@Min:

; 649  : 		while (!_Isnil(_Left(_Pnode)))

  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	80 79 21 00	 cmp	 BYTE PTR [ecx+33], 0
  00010	74 f6		 je	 SHORT $LL2@Min

; 651  : 		return (_Pnode);
; 652  : 		}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?_Min@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Min
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@QAE@U?$less@G@1@@Z ; std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0>::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??0?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@QAE@U?$less@G@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@QAE@U?$less@G@1@@Z PROC ; std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0>::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0>, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with specified comparator

  00000	8b c1		 mov	 eax, ecx

; 41   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@QAE@U?$less@G@1@@Z ENDP ; std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0>::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0>
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<unsigned short,std::allocator<unsigned short> > >::_Compat
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<unsigned short,std::allocator<unsigned short> > >::_Compat, COMDAT
; _this$ = ecx

; 253  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<unsigned short,std::allocator<unsigned short> > >::_Compat
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> > >::_Compat
; Function compile flags: /Ogsp
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> > >::_Compat, COMDAT
; _this$ = ecx

; 253  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> > >::_Compat
_TEXT	ENDS
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >,std::_Iterator_base0>::operator++
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 58   : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 59   : 		if (_Mytree::_Isnil(_Ptr))

  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	53		 push	 ebx
  00005	32 db		 xor	 bl, bl
  00007	38 59 21	 cmp	 BYTE PTR [ecx+33], bl
  0000a	75 2d		 jne	 SHORT $LN3@operator

; 60   : 			;	// end() shouldn't be incremented, don't move
; 61   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0000c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000f	38 5a 21	 cmp	 BYTE PTR [edx+33], bl
  00012	75 0d		 jne	 SHORT $LN34@operator

; 62   : 			_Ptr = _Mytree::_Min(
; 63   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

$LL18@operator:
  00014	8b ca		 mov	 ecx, edx
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	38 5a 21	 cmp	 BYTE PTR [edx+33], bl
  0001b	74 f7		 je	 SHORT $LL18@operator
  0001d	89 08		 mov	 DWORD PTR [eax], ecx
  0001f	5b		 pop	 ebx

; 71   : 			}
; 72   : 		return (*this);
; 73   : 		}

  00020	c3		 ret	 0
$LN34@operator:

; 64   : 		else
; 65   : 			{	// climb looking for right subtree
; 66   : 			_Nodeptr _Pnode;
; 67   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 68   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  00021	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00024	eb 0c		 jmp	 SHORT $LN38@operator
$LL2@operator:
  00026	8b 08		 mov	 ecx, DWORD PTR [eax]
  00028	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  0002b	75 0a		 jne	 SHORT $LN1@operator

; 69   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0002d	89 10		 mov	 DWORD PTR [eax], edx
  0002f	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
$LN38@operator:

; 64   : 		else
; 65   : 			{	// climb looking for right subtree
; 66   : 			_Nodeptr _Pnode;
; 67   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 68   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  00032	38 5a 21	 cmp	 BYTE PTR [edx+33], bl
  00035	74 ef		 je	 SHORT $LL2@operator
$LN1@operator:

; 70   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00037	89 10		 mov	 DWORD PTR [eax], edx
$LN3@operator:
  00039	5b		 pop	 ebx

; 71   : 			}
; 72   : 		return (*this);
; 73   : 		}

  0003a	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >,std::_Iterator_base0>::operator++
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft sdks\windows\v7.0a\include\strsafe.h
_TEXT	ENDS
;	COMDAT ?StringLengthWorkerA@@YGJPBDIPAI@Z
_TEXT	SEGMENT
?StringLengthWorkerA@@YGJPBDIPAI@Z PROC			; StringLengthWorkerA, COMDAT
; _psz$ = eax
; _cchMax$ = edx
; _pcchLength$ = edi

; 8549 : {

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax

; 8550 :     HRESULT hr = S_OK;

  00003	33 c0		 xor	 eax, eax

; 8551 :     size_t cchOriginalMax = cchMax;

  00005	8b ca		 mov	 ecx, edx

; 8552 : 
; 8553 :     while (cchMax && (*psz != '\0'))

  00007	85 d2		 test	 edx, edx
  00009	74 0c		 je	 SHORT $LN11@StringLeng
$LL6@StringLeng:
  0000b	38 06		 cmp	 BYTE PTR [esi], al
  0000d	74 04		 je	 SHORT $LN5@StringLeng

; 8554 :     {
; 8555 :         psz++;

  0000f	46		 inc	 esi

; 8556 :         cchMax--;

  00010	4a		 dec	 edx
  00011	75 f8		 jne	 SHORT $LL6@StringLeng
$LN5@StringLeng:

; 8557 :     }
; 8558 : 
; 8559 :     if (cchMax == 0)

  00013	85 d2		 test	 edx, edx
  00015	75 05		 jne	 SHORT $LN4@StringLeng
$LN11@StringLeng:

; 8560 :     {
; 8561 :         // the string is longer than cchMax
; 8562 :         hr = STRSAFE_E_INVALID_PARAMETER;

  00017	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
$LN4@StringLeng:
  0001c	5e		 pop	 esi

; 8563 :     }
; 8564 : 
; 8565 :     if (pcchLength)

  0001d	85 ff		 test	 edi, edi
  0001f	74 0c		 je	 SHORT $LN1@StringLeng

; 8566 :     {
; 8567 :         if (SUCCEEDED(hr))

  00021	85 c0		 test	 eax, eax
  00023	78 05		 js	 SHORT $LN2@StringLeng

; 8568 :         {
; 8569 :             *pcchLength = cchOriginalMax - cchMax;

  00025	2b ca		 sub	 ecx, edx
  00027	89 0f		 mov	 DWORD PTR [edi], ecx

; 8574 :         }
; 8575 :     }
; 8576 : 
; 8577 :     return hr;
; 8578 : }

  00029	c3		 ret	 0
$LN2@StringLeng:

; 8570 :         }
; 8571 :         else
; 8572 :         {
; 8573 :             *pcchLength = 0;

  0002a	83 27 00	 and	 DWORD PTR [edi], 0
$LN1@StringLeng:

; 8574 :         }
; 8575 :     }
; 8576 : 
; 8577 :     return hr;
; 8578 : }

  0002d	c3		 ret	 0
?StringLengthWorkerA@@YGJPBDIPAI@Z ENDP			; StringLengthWorkerA
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?StringValidateDestA@@YGJPBDII@Z
_TEXT	SEGMENT
_cchMax$ = 8						; size = 4
?StringValidateDestA@@YGJPBDII@Z PROC			; StringValidateDestA, COMDAT
; _cchDest$ = ecx

; 8721 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 8722 :     HRESULT hr = S_OK;

  00003	33 c0		 xor	 eax, eax

; 8723 : 
; 8724 :     if ((cchDest == 0) || (cchDest > cchMax))

  00005	85 c9		 test	 ecx, ecx
  00007	74 05		 je	 SHORT $LN1@StringVali
  00009	3b 4d 08	 cmp	 ecx, DWORD PTR _cchMax$[ebp]
  0000c	76 05		 jbe	 SHORT $LN2@StringVali
$LN1@StringVali:

; 8725 :     {
; 8726 :         hr = STRSAFE_E_INVALID_PARAMETER;

  0000e	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
$LN2@StringVali:

; 8727 :     }
; 8728 : 
; 8729 :     return hr;
; 8730 : }

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?StringValidateDestA@@YGJPBDII@Z ENDP			; StringValidateDestA
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?StringValidateDestAndLengthA@@YGJPBDIPAII@Z
_TEXT	SEGMENT
_pszDest$ = 8						; size = 4
_cchMax$ = 12						; size = 4
?StringValidateDestAndLengthA@@YGJPBDIPAII@Z PROC	; StringValidateDestAndLengthA, COMDAT
; _cchDest$ = ecx
; _pcchDestLength$ = esi

; 8743 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 8744 :     HRESULT hr;
; 8745 : 
; 8746 :     hr = StringValidateDestA(pszDest, cchDest, cchMax);

  00003	33 c0		 xor	 eax, eax
  00005	85 c9		 test	 ecx, ecx
  00007	74 05		 je	 SHORT $LN5@StringVali@2
  00009	3b 4d 0c	 cmp	 ecx, DWORD PTR _cchMax$[ebp]
  0000c	76 05		 jbe	 SHORT $LN6@StringVali@2
$LN5@StringVali@2:
  0000e	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
$LN6@StringVali@2:

; 8747 : 
; 8748 :     if (SUCCEEDED(hr))

  00013	85 c0		 test	 eax, eax
  00015	78 34		 js	 SHORT $LN2@StringVali@2

; 8749 :     {
; 8750 :         hr = StringLengthWorkerA(pszDest, cchDest, pcchDestLength);

  00017	8b 45 08	 mov	 eax, DWORD PTR _pszDest$[ebp]
  0001a	57		 push	 edi
  0001b	33 ff		 xor	 edi, edi
  0001d	8b d1		 mov	 edx, ecx
  0001f	85 c9		 test	 ecx, ecx
  00021	74 0d		 je	 SHORT $LN19@StringVali@2
$LL14@StringVali@2:
  00023	80 38 00	 cmp	 BYTE PTR [eax], 0
  00026	74 04		 je	 SHORT $LN13@StringVali@2
  00028	40		 inc	 eax
  00029	4a		 dec	 edx
  0002a	75 f7		 jne	 SHORT $LL14@StringVali@2
$LN13@StringVali@2:
  0002c	85 d2		 test	 edx, edx
  0002e	75 05		 jne	 SHORT $LN12@StringVali@2
$LN19@StringVali@2:
  00030	bf 57 00 07 80	 mov	 edi, -2147024809	; 80070057H
$LN12@StringVali@2:
  00035	85 f6		 test	 esi, esi
  00037	74 0d		 je	 SHORT $LN9@StringVali@2
  00039	85 ff		 test	 edi, edi
  0003b	78 06		 js	 SHORT $LN10@StringVali@2
  0003d	2b ca		 sub	 ecx, edx
  0003f	89 0e		 mov	 DWORD PTR [esi], ecx
  00041	eb 03		 jmp	 SHORT $LN9@StringVali@2
$LN10@StringVali@2:
  00043	83 26 00	 and	 DWORD PTR [esi], 0
$LN9@StringVali@2:
  00046	8b c7		 mov	 eax, edi
  00048	5f		 pop	 edi

; 8751 :     }
; 8752 :     else

  00049	eb 03		 jmp	 SHORT $LN1@StringVali@2
$LN2@StringVali@2:

; 8753 :     {
; 8754 :         *pcchDestLength = 0;

  0004b	83 26 00	 and	 DWORD PTR [esi], 0
$LN1@StringVali@2:

; 8755 :     }
; 8756 : 
; 8757 :     return hr;
; 8758 : }

  0004e	5d		 pop	 ebp
  0004f	c2 08 00	 ret	 8
?StringValidateDestAndLengthA@@YGJPBDIPAII@Z ENDP	; StringValidateDestAndLengthA
_TEXT	ENDS
PUBLIC	??$addressof@G@std@@YAPAGAAG@Z			; std::addressof<unsigned short>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$addressof@G@std@@YAPAGAAG@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@G@std@@YAPAGAAG@Z PROC			; std::addressof<unsigned short>, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@G@std@@YAPAGAAG@Z ENDP			; std::addressof<unsigned short>
_TEXT	ENDS
PUBLIC	??$forward@G@std@@YA$$QAGAAG@Z			; std::forward<unsigned short>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@G@std@@YA$$QAGAAG@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@G@std@@YA$$QAGAAG@Z PROC			; std::forward<unsigned short>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@G@std@@YA$$QAGAAG@Z ENDP			; std::forward<unsigned short>
_TEXT	ENDS
PUBLIC	??$addressof@$$CBG@std@@YAPBGABG@Z		; std::addressof<unsigned short const >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$addressof@$$CBG@std@@YAPBGABG@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBG@std@@YAPBGABG@Z PROC			; std::addressof<unsigned short const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBG@std@@YAPBGABG@Z ENDP			; std::addressof<unsigned short const >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft sdks\windows\v7.0a\include\strsafe.h
_TEXT	ENDS
;	COMDAT ?StringCopyWorkerA@@YGJPADIPAIPBDI@Z
_TEXT	SEGMENT
_hr$ = -4						; size = 4
_pcchNewDestLength$ = 8					; size = 4
_pszSrc$ = 12						; size = 4
_cchToCopy$ = 16					; size = 4
?StringCopyWorkerA@@YGJPADIPAIPBDI@Z PROC		; StringCopyWorkerA, COMDAT
; _pszDest$ = ecx
; _cchDest$ = eax

; 8947 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 8948 :     HRESULT hr = S_OK;

  00004	83 65 fc 00	 and	 DWORD PTR _hr$[ebp], 0
  00008	57		 push	 edi
  00009	8b f8		 mov	 edi, eax

; 8949 :     size_t cchNewDestLength = 0;

  0000b	33 c0		 xor	 eax, eax

; 8950 :     
; 8951 :     // ASSERT(cchDest != 0);
; 8952 : 
; 8953 :     while (cchDest && cchToCopy && (*pszSrc != '\0'))

  0000d	85 ff		 test	 edi, edi
  0000f	74 23		 je	 SHORT $LN9@StringCopy

; 8948 :     HRESULT hr = S_OK;

  00011	53		 push	 ebx
  00012	8b 5d 10	 mov	 ebx, DWORD PTR _cchToCopy$[ebp]
  00015	56		 push	 esi

; 8950 :     
; 8951 :     // ASSERT(cchDest != 0);
; 8952 : 
; 8953 :     while (cchDest && cchToCopy && (*pszSrc != '\0'))

  00016	8b 75 0c	 mov	 esi, DWORD PTR _pszSrc$[ebp]
  00019	2b f1		 sub	 esi, ecx
$LL4@StringCopy:
  0001b	85 db		 test	 ebx, ebx
  0001d	74 0f		 je	 SHORT $LN11@StringCopy
  0001f	8a 14 0e	 mov	 dl, BYTE PTR [esi+ecx]
  00022	84 d2		 test	 dl, dl
  00024	74 08		 je	 SHORT $LN11@StringCopy

; 8954 :     {
; 8955 :         *pszDest++ = *pszSrc++;

  00026	88 11		 mov	 BYTE PTR [ecx], dl
  00028	41		 inc	 ecx

; 8956 :         cchDest--;

  00029	4b		 dec	 ebx

; 8957 :         cchToCopy--;
; 8958 : 
; 8959 :         cchNewDestLength++;

  0002a	40		 inc	 eax
  0002b	4f		 dec	 edi
  0002c	75 ed		 jne	 SHORT $LL4@StringCopy
$LN11@StringCopy:
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx

; 8960 :     }
; 8961 : 
; 8962 :     if (cchDest == 0)

  00030	85 ff		 test	 edi, edi
  00032	75 09		 jne	 SHORT $LN2@StringCopy
$LN9@StringCopy:

; 8963 :     {
; 8964 :         // we are going to truncate pszDest
; 8965 :         pszDest--;

  00034	49		 dec	 ecx

; 8966 :         cchNewDestLength--;

  00035	48		 dec	 eax

; 8967 : 
; 8968 :         hr = STRSAFE_E_INSUFFICIENT_BUFFER;

  00036	c7 45 fc 7a 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024774 ; 8007007aH
$LN2@StringCopy:

; 8969 :     }
; 8970 : 
; 8971 :     *pszDest = '\0';

  0003d	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 8972 : 
; 8973 :     if (pcchNewDestLength)

  00040	8b 4d 08	 mov	 ecx, DWORD PTR _pcchNewDestLength$[ebp]
  00043	5f		 pop	 edi
  00044	85 c9		 test	 ecx, ecx
  00046	74 02		 je	 SHORT $LN1@StringCopy

; 8974 :     {
; 8975 :         *pcchNewDestLength = cchNewDestLength;

  00048	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@StringCopy:

; 8976 :     }
; 8977 : 
; 8978 :     return hr;

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 8979 : }

  0004d	c9		 leave
  0004e	c2 0c 00	 ret	 12			; 0000000cH
?StringCopyWorkerA@@YGJPADIPAIPBDI@Z ENDP		; StringCopyWorkerA
_TEXT	ENDS
PUBLIC	??$addressof@$$CBUtagMecroTextInfo@CKeyInfo@@@std@@YAPBUtagMecroTextInfo@CKeyInfo@@ABU12@@Z ; std::addressof<CKeyInfo::tagMecroTextInfo const >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$addressof@$$CBUtagMecroTextInfo@CKeyInfo@@@std@@YAPBUtagMecroTextInfo@CKeyInfo@@ABU12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUtagMecroTextInfo@CKeyInfo@@@std@@YAPBUtagMecroTextInfo@CKeyInfo@@ABU12@@Z PROC ; std::addressof<CKeyInfo::tagMecroTextInfo const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBUtagMecroTextInfo@CKeyInfo@@@std@@YAPBUtagMecroTextInfo@CKeyInfo@@ABU12@@Z ENDP ; std::addressof<CKeyInfo::tagMecroTextInfo const >
_TEXT	ENDS
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft sdks\windows\v7.0a\include\strsafe.h
;	COMDAT ?StringVPrintfWorkerA@@YGJPADIPAIPBD0@Z
_TEXT	SEGMENT
_pcchNewDestLength$ = 8					; size = 4
_pszFormat$ = 12					; size = 4
_argList$ = 16						; size = 4
?StringVPrintfWorkerA@@YGJPADIPAIPBD0@Z PROC		; StringVPrintfWorkerA, COMDAT
; _pszDest$ = edi
; _cchDest$ = eax

; 9029 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 9030 :     HRESULT hr = S_OK;
; 9031 :     int iRet;
; 9032 :     size_t cchMax;
; 9033 :     size_t cchNewDestLength = 0;
; 9034 : 
; 9035 :     // leave the last space for the null terminator
; 9036 :     cchMax = cchDest - 1;
; 9037 : 
; 9038 : #if (STRSAFE_USE_SECURE_CRT == 1) && !defined(STRSAFE_LIB_IMPL)
; 9039 :     iRet = _vsnprintf_s(pszDest, cchDest, cchMax, pszFormat, argList);
; 9040 : #else
; 9041 :     #pragma warning(push)
; 9042 :     #pragma warning(disable: __WARNING_BANNED_API_USAGE)// "STRSAFE not included"
; 9043 :     iRet = _vsnprintf(pszDest, cchMax, pszFormat, argList);

  00005	ff 75 10	 push	 DWORD PTR _argList$[ebp]
  00008	8d 70 ff	 lea	 esi, DWORD PTR [eax-1]
  0000b	ff 75 0c	 push	 DWORD PTR _pszFormat$[ebp]
  0000e	33 db		 xor	 ebx, ebx
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___vsnprintf
  00018	83 c4 10	 add	 esp, 16			; 00000010H

; 9044 :     #pragma warning(pop)
; 9045 : #endif
; 9046 :     // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));
; 9047 : 
; 9048 :     if ((iRet < 0) || (((size_t)iRet) > cchMax))

  0001b	85 c0		 test	 eax, eax
  0001d	78 0b		 js	 SHORT $LN5@StringVPri
  0001f	3b c6		 cmp	 eax, esi
  00021	77 07		 ja	 SHORT $LN5@StringVPri

; 9058 :     }
; 9059 :     else if (((size_t)iRet) == cchMax)

  00023	75 0f		 jne	 SHORT $LN2@StringVPri

; 9060 :     {
; 9061 :         // need to null terminate the string
; 9062 :         pszDest += cchMax;
; 9063 :         *pszDest = '\0';

  00025	88 1c 3e	 mov	 BYTE PTR [esi+edi], bl

; 9064 : 
; 9065 :         cchNewDestLength = cchMax;
; 9066 :     }
; 9067 :     else

  00028	eb 08		 jmp	 SHORT $LN9@StringVPri
$LN5@StringVPri:

; 9049 :     {
; 9050 :         // need to null terminate the string
; 9051 :         pszDest += cchMax;
; 9052 :         *pszDest = '\0';

  0002a	88 1c 3e	 mov	 BYTE PTR [esi+edi], bl

; 9055 : 
; 9056 :         // we have truncated pszDest
; 9057 :         hr = STRSAFE_E_INSUFFICIENT_BUFFER;

  0002d	bb 7a 00 07 80	 mov	 ebx, -2147024774	; 8007007aH
$LN9@StringVPri:

; 9053 : 
; 9054 :         cchNewDestLength = cchMax;

  00032	8b c6		 mov	 eax, esi
$LN2@StringVPri:

; 9068 :     {
; 9069 :         cchNewDestLength = (size_t)iRet;
; 9070 :     }
; 9071 : 
; 9072 :     if (pcchNewDestLength)

  00034	8b 4d 08	 mov	 ecx, DWORD PTR _pcchNewDestLength$[ebp]
  00037	85 c9		 test	 ecx, ecx
  00039	74 02		 je	 SHORT $LN1@StringVPri

; 9073 :     {
; 9074 :         *pcchNewDestLength = cchNewDestLength;

  0003b	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@StringVPri:
  0003d	5e		 pop	 esi

; 9075 :     }
; 9076 : 
; 9077 :     return hr;

  0003e	8b c3		 mov	 eax, ebx
  00040	5b		 pop	 ebx

; 9078 : }

  00041	5d		 pop	 ebp
  00042	c2 0c 00	 ret	 12			; 0000000cH
?StringVPrintfWorkerA@@YGJPADIPAIPBD0@Z ENDP		; StringVPrintfWorkerA
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@G@std@@YAPAGIPAG@Z			; std::_Allocate<unsigned short>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@G@std@@YAPAGIPAG@Z
_TEXT	SEGMENT
$T515830 = -12						; size = 12
$T515835 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@G@std@@YAPAGIPAG@Z PROC			; std::_Allocate<unsigned short>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 3c		 je	 SHORT $LN5@Allocate

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  00015	77 0e		 ja	 SHORT $LN1@Allocate
  00017	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00020	59		 pop	 ecx
  00021	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00023	75 26		 jne	 SHORT $LN5@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00025	83 65 08 00	 and	 DWORD PTR $T515835[ebp], 0
  00029	8d 45 08	 lea	 eax, DWORD PTR $T515835[ebp]
  0002c	50		 push	 eax
  0002d	8d 4d f4	 lea	 ecx, DWORD PTR $T515830[ebp]
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
  00036	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003b	8d 45 f4	 lea	 eax, DWORD PTR $T515830[ebp]
  0003e	50		 push	 eax
  0003f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T515830[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00046	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate:
$LN5@Allocate:

; 40   : 	}

  0004b	c9		 leave
  0004c	c3		 ret	 0
$LN9@Allocate:
??$_Allocate@G@std@@YAPAGIPAG@Z ENDP			; std::_Allocate<unsigned short>
_TEXT	ENDS
PUBLIC	??$_Allocate@UtagMecroTextInfo@CKeyInfo@@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@IPAU12@@Z ; std::_Allocate<CKeyInfo::tagMecroTextInfo>
; Function compile flags: /Ogsp
;	COMDAT ??$_Allocate@UtagMecroTextInfo@CKeyInfo@@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@IPAU12@@Z
_TEXT	SEGMENT
$T515840 = -12						; size = 12
$T515844 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UtagMecroTextInfo@CKeyInfo@@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@IPAU12@@Z PROC ; std::_Allocate<CKeyInfo::tagMecroTextInfo>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 3c		 je	 SHORT $LN5@Allocate@2

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 cc cc cc
	0c		 cmp	 ecx, 214748364		; 0cccccccH
  00015	77 0e		 ja	 SHORT $LN1@Allocate@2
  00017	6b c9 14	 imul	 ecx, 20			; 00000014H
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00020	59		 pop	 ecx
  00021	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00023	75 26		 jne	 SHORT $LN5@Allocate@2
$LN1@Allocate@2:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00025	83 65 08 00	 and	 DWORD PTR $T515844[ebp], 0
  00029	8d 45 08	 lea	 eax, DWORD PTR $T515844[ebp]
  0002c	50		 push	 eax
  0002d	8d 4d f4	 lea	 ecx, DWORD PTR $T515840[ebp]
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
  00036	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003b	8d 45 f4	 lea	 eax, DWORD PTR $T515840[ebp]
  0003e	50		 push	 eax
  0003f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T515840[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00046	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate@2:
$LN5@Allocate@2:

; 40   : 	}

  0004b	c9		 leave
  0004c	c3		 ret	 0
$LN9@Allocate@2:
??$_Allocate@UtagMecroTextInfo@CKeyInfo@@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@IPAU12@@Z ENDP ; std::_Allocate<CKeyInfo::tagMecroTextInfo>
_TEXT	ENDS
PUBLIC	??$addressof@U?$pair@$$CBGVioHashString@@@std@@@std@@YAPAU?$pair@$$CBGVioHashString@@@0@AAU10@@Z ; std::addressof<std::pair<unsigned short const ,ioHashString> >
; Function compile flags: /Ogsp
;	COMDAT ??$addressof@U?$pair@$$CBGVioHashString@@@std@@@std@@YAPAU?$pair@$$CBGVioHashString@@@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBGVioHashString@@@std@@@std@@YAPAU?$pair@$$CBGVioHashString@@@0@AAU10@@Z PROC ; std::addressof<std::pair<unsigned short const ,ioHashString> >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@U?$pair@$$CBGVioHashString@@@std@@@std@@YAPAU?$pair@$$CBGVioHashString@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<unsigned short const ,ioHashString> >
_TEXT	ENDS
PUBLIC	??$_Kfn@$$CBGVioHashString@@@?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@SAABGABU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0>::_Kfn<unsigned short const ,ioHashString>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??$_Kfn@$$CBGVioHashString@@@?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@SAABGABU?$pair@$$CBGVioHashString@@@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBGVioHashString@@@?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@SAABGABU?$pair@$$CBGVioHashString@@@1@@Z PROC ; std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0>::_Kfn<unsigned short const ,ioHashString>, COMDAT

; 66   : 		static const _Kty& _Kfn(const _STD pair<_Ty1, _Ty2>& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 67   : 		{	// extract key from element value
; 68   : 		return (_Val.first);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 69   : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Kfn@$$CBGVioHashString@@@?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@SAABGABU?$pair@$$CBGVioHashString@@@1@@Z ENDP ; std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0>::_Kfn<unsigned short const ,ioHashString>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBGVioHashString@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBGVioHashString@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Node><std::pair<unsigned short const ,ioHashString> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$?0U?$pair@$$CBGVioHashString@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBGVioHashString@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBGVioHashString@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBGVioHashString@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Node><std::pair<unsigned short const ,ioHashString> >, COMDAT
; _this$ = ecx

; 170  : 		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00002	c2 04 00	 ret	 4
??$?0U?$pair@$$CBGVioHashString@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBGVioHashString@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Node><std::pair<unsigned short const ,ioHashString> >
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Node>
; Function compile flags: /Ogsp
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T515856 = -12						; size = 12
$T515860 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Node>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 3c		 je	 SHORT $LN5@Allocate@3

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 c7 71 1c
	07		 cmp	 ecx, 119304647		; 071c71c7H
  00015	77 0e		 ja	 SHORT $LN1@Allocate@3
  00017	6b c9 24	 imul	 ecx, 36			; 00000024H
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00020	59		 pop	 ecx
  00021	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00023	75 26		 jne	 SHORT $LN5@Allocate@3
$LN1@Allocate@3:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00025	83 65 08 00	 and	 DWORD PTR $T515860[ebp], 0
  00029	8d 45 08	 lea	 eax, DWORD PTR $T515860[ebp]
  0002c	50		 push	 eax
  0002d	8d 4d f4	 lea	 ecx, DWORD PTR $T515856[ebp]
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
  00036	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003b	8d 45 f4	 lea	 eax, DWORD PTR $T515856[ebp]
  0003e	50		 push	 eax
  0003f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T515856[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00046	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate@3:
$LN5@Allocate@3:

; 40   : 	}

  0004b	c9		 leave
  0004c	c3		 ret	 0
$LN9@Allocate@3:
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@G@std@@QAEXPAG$$QAG@Z	; std::allocator<unsigned short>::construct
; Function compile flags: /Ogsp
;	COMDAT ?construct@?$allocator@G@std@@QAEXPAG$$QAG@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@G@std@@QAEXPAG$$QAG@Z PROC	; std::allocator<unsigned short>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $LN3@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	66 8b 09	 mov	 cx, WORD PTR [ecx]
  00010	66 89 08	 mov	 WORD PTR [eax], cx
$LN3@construct:

; 203  : 		}

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
?construct@?$allocator@G@std@@QAEXPAG$$QAG@Z ENDP	; std::allocator<unsigned short>::construct
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned short const ,ioHashString> >::max_size
; Function compile flags: /Ogsp
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<unsigned short const ,ioHashString> >::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 cc cc cc 0c	 mov	 eax, 214748364		; 0cccccccH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned short const ,ioHashString> >::max_size
_TEXT	ENDS
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >,std::_Iterator_base0>::operator--
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 83   : 		{	// predecrement

  00000	8b c1		 mov	 eax, ecx

; 84   : 		if (_Mytree::_Isnil(_Ptr))

  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	53		 push	 ebx
  00005	32 db		 xor	 bl, bl
  00007	38 59 21	 cmp	 BYTE PTR [ecx+33], bl
  0000a	74 07		 je	 SHORT $LN8@operator@2

; 85   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  0000c	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0000f	89 08		 mov	 DWORD PTR [eax], ecx
  00011	5b		 pop	 ebx

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  00012	c3		 ret	 0
$LN8@operator@2:

; 86   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	38 5a 21	 cmp	 BYTE PTR [edx+33], bl
  00018	74 07		 je	 SHORT $LN44@operator@2

; 90   : 			{	// climb looking for left subtree
; 91   : 			_Nodeptr _Pnode;
; 92   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 93   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  0001a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001d	eb 17		 jmp	 SHORT $LN46@operator@2

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

$LL22@operator@2:
  0001f	8b d1		 mov	 edx, ecx
$LN44@operator@2:
  00021	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00024	38 59 21	 cmp	 BYTE PTR [ecx+33], bl
  00027	74 f6		 je	 SHORT $LL22@operator@2

; 89   : 		else

  00029	eb 17		 jmp	 SHORT $LN45@operator@2
$LL4@operator@2:

; 90   : 			{	// climb looking for left subtree
; 91   : 			_Nodeptr _Pnode;
; 92   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 93   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  0002b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002d	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0002f	75 0a		 jne	 SHORT $LN3@operator@2

; 94   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  00031	89 10		 mov	 DWORD PTR [eax], edx
  00033	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
$LN46@operator@2:

; 90   : 			{	// climb looking for left subtree
; 91   : 			_Nodeptr _Pnode;
; 92   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 93   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  00036	38 5a 21	 cmp	 BYTE PTR [edx+33], bl
  00039	74 f0		 je	 SHORT $LL4@operator@2
$LN3@operator@2:

; 95   : 			if (_Mytree::_Isnil(_Ptr))

  0003b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003d	38 59 21	 cmp	 BYTE PTR [ecx+33], bl
  00040	75 02		 jne	 SHORT $LN1@operator@2
$LN45@operator@2:

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else
; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  00042	89 10		 mov	 DWORD PTR [eax], edx
$LN1@operator@2:
  00044	5b		 pop	 ebx

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  00045	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >,std::_Iterator_base0>::operator--
_TEXT	ENDS
PUBLIC	??$forward@W4<unnamed-tag>@@@std@@YA$$QAW4<unnamed-tag>@@AAW41@@Z ; std::forward<enum <unnamed-tag> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@W4<unnamed-tag>@@@std@@YA$$QAW4<unnamed-tag>@@AAW41@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@W4<unnamed-tag>@@@std@@YA$$QAW4<unnamed-tag>@@AAW41@@Z PROC ; std::forward<enum <unnamed-tag> >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@W4<unnamed-tag>@@@std@@YA$$QAW4<unnamed-tag>@@AAW41@@Z ENDP ; std::forward<enum <unnamed-tag> >
_TEXT	ENDS
PUBLIC	??$forward@AAY0BAE@D@std@@YAAAY0BAE@DAAY0BAE@D@Z ; std::forward<char (&)[260]>
; Function compile flags: /Ogsp
;	COMDAT ??$forward@AAY0BAE@D@std@@YAAAY0BAE@DAAY0BAE@D@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAY0BAE@D@std@@YAAAY0BAE@DAAY0BAE@D@Z PROC	; std::forward<char (&)[260]>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAY0BAE@D@std@@YAAAY0BAE@DAAY0BAE@D@Z ENDP	; std::forward<char (&)[260]>
_TEXT	ENDS
PUBLIC	??$?0W4<unnamed-tag>@@AAY0BAE@D@?$_Pair_base@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::_Pair_base<unsigned short const ,ioHashString>::_Pair_base<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
EXTRN	__imp_??0ioHashString@@QAE@PBD@Z:PROC
; Function compile flags: /Ogsp
;	COMDAT ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$_Pair_base@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0W4<unnamed-tag>@@AAY0BAE@D@?$_Pair_base@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z PROC ; std::_Pair_base<unsigned short const ,ioHashString>::_Pair_base<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	66 8b 00	 mov	 ax, WORD PTR [eax]
  00009	56		 push	 esi
  0000a	ff 75 0c	 push	 DWORD PTR __Val2$[ebp]
  0000d	8b f1		 mov	 esi, ecx
  0000f	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00012	66 89 06	 mov	 WORD PTR [esi], ax
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z

; 164  : 		}

  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
??$?0W4<unnamed-tag>@@AAY0BAE@D@?$_Pair_base@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ENDP ; std::_Pair_base<unsigned short const ,ioHashString>::_Pair_base<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
_TEXT	ENDS
PUBLIC	??$forward@U?$pair@$$CBGVioHashString@@@std@@@std@@YA$$QAU?$pair@$$CBGVioHashString@@@0@AAU10@@Z ; std::forward<std::pair<unsigned short const ,ioHashString> >
; Function compile flags: /Ogsp
;	COMDAT ??$forward@U?$pair@$$CBGVioHashString@@@std@@@std@@YA$$QAU?$pair@$$CBGVioHashString@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@$$CBGVioHashString@@@std@@@std@@YA$$QAU?$pair@$$CBGVioHashString@@@0@AAU10@@Z PROC ; std::forward<std::pair<unsigned short const ,ioHashString> >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$pair@$$CBGVioHashString@@@std@@@std@@YA$$QAU?$pair@$$CBGVioHashString@@@0@AAU10@@Z ENDP ; std::forward<std::pair<unsigned short const ,ioHashString> >
_TEXT	ENDS
PUBLIC	??$forward@AAG@std@@YAAAGAAG@Z			; std::forward<unsigned short &>
; Function compile flags: /Ogsp
;	COMDAT ??$forward@AAG@std@@YAAAGAAG@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAG@std@@YAAAGAAG@Z PROC			; std::forward<unsigned short &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAG@std@@YAAAGAAG@Z ENDP			; std::forward<unsigned short &>
_TEXT	ENDS
PUBLIC	??$construct@AAG@?$allocator@G@std@@QAEXPAGAAG@Z ; std::allocator<unsigned short>::construct<unsigned short &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$construct@AAG@?$allocator@G@std@@QAEXPAGAAG@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAG@?$allocator@G@std@@QAEXPAGAAG@Z PROC	; std::allocator<unsigned short>::construct<unsigned short &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $LN3@construct@2
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	66 8b 09	 mov	 cx, WORD PTR [ecx]
  00010	66 89 08	 mov	 WORD PTR [eax], cx
$LN3@construct@2:

; 209  : 		}

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??$construct@AAG@?$allocator@G@std@@QAEXPAGAAG@Z ENDP	; std::allocator<unsigned short>::construct<unsigned short &>
_TEXT	ENDS
PUBLIC	??$forward@ABG@std@@YAABGABG@Z			; std::forward<unsigned short const &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABG@std@@YAABGABG@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABG@std@@YAABGABG@Z PROC			; std::forward<unsigned short const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABG@std@@YAABGABG@Z ENDP			; std::forward<unsigned short const &>
_TEXT	ENDS
PUBLIC	??$forward@AAUtagMecroTextInfo@CKeyInfo@@@std@@YAAAUtagMecroTextInfo@CKeyInfo@@AAU12@@Z ; std::forward<CKeyInfo::tagMecroTextInfo &>
; Function compile flags: /Ogsp
;	COMDAT ??$forward@AAUtagMecroTextInfo@CKeyInfo@@@std@@YAAAUtagMecroTextInfo@CKeyInfo@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUtagMecroTextInfo@CKeyInfo@@@std@@YAAAUtagMecroTextInfo@CKeyInfo@@AAU12@@Z PROC ; std::forward<CKeyInfo::tagMecroTextInfo &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAUtagMecroTextInfo@CKeyInfo@@@std@@YAAAUtagMecroTextInfo@CKeyInfo@@AAU12@@Z ENDP ; std::forward<CKeyInfo::tagMecroTextInfo &>
_TEXT	ENDS
PUBLIC	??$forward@ABUtagMecroTextInfo@CKeyInfo@@@std@@YAABUtagMecroTextInfo@CKeyInfo@@ABU12@@Z ; std::forward<CKeyInfo::tagMecroTextInfo const &>
; Function compile flags: /Ogsp
;	COMDAT ??$forward@ABUtagMecroTextInfo@CKeyInfo@@@std@@YAABUtagMecroTextInfo@CKeyInfo@@ABU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUtagMecroTextInfo@CKeyInfo@@@std@@YAABUtagMecroTextInfo@CKeyInfo@@ABU12@@Z PROC ; std::forward<CKeyInfo::tagMecroTextInfo const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUtagMecroTextInfo@CKeyInfo@@@std@@YAABUtagMecroTextInfo@CKeyInfo@@ABU12@@Z ENDP ; std::forward<CKeyInfo::tagMecroTextInfo const &>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@GG@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAG0@Z ; std::_Ptr_cat<unsigned short,unsigned short>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@GG@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAG0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@GG@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAG0@Z PROC ; std::_Ptr_cat<unsigned short,unsigned short>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	c9		 leave
  00008	c3		 ret	 0
??$_Ptr_cat@GG@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAG0@Z ENDP ; std::_Ptr_cat<unsigned short,unsigned short>
_TEXT	ENDS
PUBLIC	??$_Move@PAGPAG@std@@YAPAGPAG00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<unsigned short *,unsigned short *>
EXTRN	__imp__memmove:PROC
; Function compile flags: /Ogsp
;	COMDAT ??$_Move@PAGPAG@std@@YAPAGPAG00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAGPAG@std@@YAPAGPAG00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<unsigned short *,unsigned short *>, COMDAT

; 2522 : 	{	// move [_First, _Last) to [_Dest, ...), pointers to scalars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2523 : 	ptrdiff_t _Count = _Last - _First;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00009	56		 push	 esi
  0000a	57		 push	 edi

; 2524 : 	_CSTD memmove(&*_Dest, &*_First,
; 2525 : 		_Count * sizeof (*_First));

  0000b	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
  0000e	d1 f8		 sar	 eax, 1
  00010	8d 34 00	 lea	 esi, DWORD PTR [eax+eax]
  00013	56		 push	 esi
  00014	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00017	57		 push	 edi
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2526 : 	return (_Dest + _Count);

  00021	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi

; 2527 : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Move@PAGPAG@std@@YAPAGPAG00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<unsigned short *,unsigned short *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<unsigned short> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned short> >, COMDAT

; 105  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned short> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@UtagMecroTextInfo@CKeyInfo@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUtagMecroTextInfo@CKeyInfo@@0@Z ; std::_Ptr_cat<CKeyInfo::tagMecroTextInfo,CKeyInfo::tagMecroTextInfo>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@UtagMecroTextInfo@CKeyInfo@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUtagMecroTextInfo@CKeyInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UtagMecroTextInfo@CKeyInfo@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUtagMecroTextInfo@CKeyInfo@@0@Z PROC ; std::_Ptr_cat<CKeyInfo::tagMecroTextInfo,CKeyInfo::tagMecroTextInfo>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	c9		 leave
  00008	c3		 ret	 0
??$_Ptr_cat@UtagMecroTextInfo@CKeyInfo@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUtagMecroTextInfo@CKeyInfo@@0@Z ENDP ; std::_Ptr_cat<CKeyInfo::tagMecroTextInfo,CKeyInfo::tagMecroTextInfo>
_TEXT	ENDS
PUBLIC	??$_Construct@GABG@std@@YAXPAGABG@Z		; std::_Construct<unsigned short,unsigned short const &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Construct@GABG@std@@YAXPAGABG@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@GABG@std@@YAXPAGABG@Z PROC		; std::_Construct<unsigned short,unsigned short const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $LN3@Construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	66 8b 09	 mov	 cx, WORD PTR [ecx]
  00010	66 89 08	 mov	 WORD PTR [eax], cx
$LN3@Construct:

; 49   : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Construct@GABG@std@@YAXPAGABG@Z ENDP		; std::_Construct<unsigned short,unsigned short const &>
_TEXT	ENDS
PUBLIC	??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > > &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > > &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > > &>
_TEXT	ENDS
PUBLIC	??0tagMecroTextInfo@CKeyInfo@@QAE@ABU01@@Z	; CKeyInfo::tagMecroTextInfo::tagMecroTextInfo
EXTRN	__imp_??0ioHashString@@QAE@ABV0@@Z:PROC
; Function compile flags: /Ogsp
;	COMDAT ??0tagMecroTextInfo@CKeyInfo@@QAE@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0tagMecroTextInfo@CKeyInfo@@QAE@ABU01@@Z PROC		; CKeyInfo::tagMecroTextInfo::tagMecroTextInfo, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8a 08		 mov	 cl, BYTE PTR [eax]
  0000b	83 c0 04	 add	 eax, 4
  0000e	88 0e		 mov	 BYTE PTR [esi], cl
  00010	50		 push	 eax
  00011	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??0tagMecroTextInfo@CKeyInfo@@QAE@ABU01@@Z ENDP		; CKeyInfo::tagMecroTextInfo::tagMecroTextInfo
_TEXT	ENDS
PUBLIC	??$_Val_type@PAG@std@@YAPAGPAG@Z		; std::_Val_type<unsigned short *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAG@std@@YAPAGPAG@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAG@std@@YAPAGPAG@Z PROC			; std::_Val_type<unsigned short *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAG@std@@YAPAGPAG@Z ENDP			; std::_Val_type<unsigned short *>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@GGG@std@@YAPAGPAG00AAV?$allocator@G@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<unsigned short,unsigned short,unsigned short>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninit_move@GGG@std@@YAPAGPAG00AAV?$allocator@G@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@GGG@std@@YAPAGPAG00AAV?$allocator@G@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<unsigned short,unsigned short,unsigned short>, COMDAT

; 456  : 	{	// move [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 457  : 	_DEBUG_RANGE(_First, _Last);
; 458  : 	_DEBUG_POINTER(_Dest);
; 459  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00009	56		 push	 esi
  0000a	d1 f8		 sar	 eax, 1

; 460  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 461  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000c	8d 34 00	 lea	 esi, DWORD PTR [eax+eax]
  0000f	56		 push	 esi
  00010	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00013	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001f	03 c6		 add	 eax, esi
  00021	5e		 pop	 esi

; 462  : 	}

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$_Uninit_move@GGG@std@@YAPAGPAG00AAV?$allocator@G@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<unsigned short,unsigned short,unsigned short>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUtagMecroTextInfo@CKeyInfo@@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@@Z ; std::_Val_type<CKeyInfo::tagMecroTextInfo *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAUtagMecroTextInfo@CKeyInfo@@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUtagMecroTextInfo@CKeyInfo@@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@@Z PROC ; std::_Val_type<CKeyInfo::tagMecroTextInfo *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAUtagMecroTextInfo@CKeyInfo@@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@@Z ENDP ; std::_Val_type<CKeyInfo::tagMecroTextInfo *>
_TEXT	ENDS
PUBLIC	??$move@AAUtagMecroTextInfo@CKeyInfo@@@std@@YA$$QAUtagMecroTextInfo@CKeyInfo@@AAU12@@Z ; std::move<CKeyInfo::tagMecroTextInfo &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAUtagMecroTextInfo@CKeyInfo@@@std@@YA$$QAUtagMecroTextInfo@CKeyInfo@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUtagMecroTextInfo@CKeyInfo@@@std@@YA$$QAUtagMecroTextInfo@CKeyInfo@@AAU12@@Z PROC ; std::move<CKeyInfo::tagMecroTextInfo &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAUtagMecroTextInfo@CKeyInfo@@@std@@YA$$QAUtagMecroTextInfo@CKeyInfo@@AAU12@@Z ENDP ; std::move<CKeyInfo::tagMecroTextInfo &>
_TEXT	ENDS
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > > &>
; Function compile flags: /Ogsp
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > > &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > > &>
_TEXT	ENDS
PUBLIC	??_GtagMecroTextInfo@CKeyInfo@@QAEPAXI@Z	; CKeyInfo::tagMecroTextInfo::`scalar deleting destructor'
; Function compile flags: /Ogsp
;	COMDAT ??_GtagMecroTextInfo@CKeyInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GtagMecroTextInfo@CKeyInfo@@QAEPAXI@Z PROC		; CKeyInfo::tagMecroTextInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  0000f	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00013	74 07		 je	 SHORT $LN1@scalar@2
  00015	56		 push	 esi
  00016	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001b	59		 pop	 ecx
$LN1@scalar@2:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GtagMecroTextInfo@CKeyInfo@@QAEPAXI@Z ENDP		; CKeyInfo::tagMecroTextInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$forward@UtagMecroTextInfo@CKeyInfo@@@std@@YA$$QAUtagMecroTextInfo@CKeyInfo@@AAU12@@Z ; std::forward<CKeyInfo::tagMecroTextInfo>
; Function compile flags: /Ogsp
;	COMDAT ??$forward@UtagMecroTextInfo@CKeyInfo@@@std@@YA$$QAUtagMecroTextInfo@CKeyInfo@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UtagMecroTextInfo@CKeyInfo@@@std@@YA$$QAUtagMecroTextInfo@CKeyInfo@@AAU12@@Z PROC ; std::forward<CKeyInfo::tagMecroTextInfo>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@UtagMecroTextInfo@CKeyInfo@@@std@@YA$$QAUtagMecroTextInfo@CKeyInfo@@AAU12@@Z ENDP ; std::forward<CKeyInfo::tagMecroTextInfo>
_TEXT	ENDS
PUBLIC	??$forward@$$CBG@std@@YA$$QBGABG@Z		; std::forward<unsigned short const >
; Function compile flags: /Ogsp
;	COMDAT ??$forward@$$CBG@std@@YA$$QBGABG@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@$$CBG@std@@YA$$QBGABG@Z PROC			; std::forward<unsigned short const >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@$$CBG@std@@YA$$QBGABG@Z ENDP			; std::forward<unsigned short const >
_TEXT	ENDS
PUBLIC	??$forward@VioHashString@@@std@@YA$$QAVioHashString@@AAV1@@Z ; std::forward<ioHashString>
; Function compile flags: /Ogsp
;	COMDAT ??$forward@VioHashString@@@std@@YA$$QAVioHashString@@AAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@VioHashString@@@std@@YA$$QAVioHashString@@AAV1@@Z PROC ; std::forward<ioHashString>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@VioHashString@@@std@@YA$$QAVioHashString@@AAV1@@Z ENDP ; std::forward<ioHashString>
_TEXT	ENDS
PUBLIC	??$move@ABG@std@@YA$$QBGABG@Z			; std::move<unsigned short const &>
; Function compile flags: /Ogsp
;	COMDAT ??$move@ABG@std@@YA$$QBGABG@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@ABG@std@@YA$$QBGABG@Z PROC			; std::move<unsigned short const &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@ABG@std@@YA$$QBGABG@Z ENDP			; std::move<unsigned short const &>
_TEXT	ENDS
PUBLIC	?_DECSTR@@YAXPADH@Z				; _DECSTR
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stringprotect.h
;	COMDAT ?_DECSTR@@YAXPADH@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_l$ = 12						; size = 4
?_DECSTR@@YAXPADH@Z PROC				; _DECSTR, COMDAT

; 40   : __forceinline void _DECSTR(char* s, int l){int i=0,l4=(l-1)/4,*p=(int*)s;s[l-1]=0;for(;i<l4;++i)*(p++)^=0xEAEBECED;for(i=l4*4;i<l-1;++i)s[i]^=0xED-i%4;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _l$[ebp]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  0000a	57		 push	 edi
  0000b	8d 79 ff	 lea	 edi, DWORD PTR [ecx-1]
  0000e	8b c7		 mov	 eax, edi
  00010	99		 cdq
  00011	83 e2 03	 and	 edx, 3
  00014	03 c2		 add	 eax, edx
  00016	c1 f8 02	 sar	 eax, 2
  00019	8b d6		 mov	 edx, esi
  0001b	c6 44 0e ff 00	 mov	 BYTE PTR [esi+ecx-1], 0
  00020	85 c0		 test	 eax, eax
  00022	7e 0e		 jle	 SHORT $LN4@DECSTR
  00024	8b c8		 mov	 ecx, eax
$LL6@DECSTR:
  00026	81 32 ed ec eb
	ea		 xor	 DWORD PTR [edx], -353637139 ; eaebecedH
  0002c	83 c2 04	 add	 edx, 4
  0002f	49		 dec	 ecx
  00030	75 f4		 jne	 SHORT $LL6@DECSTR
$LN4@DECSTR:
  00032	c1 e0 02	 shl	 eax, 2
  00035	eb 17		 jmp	 SHORT $LN14@DECSTR
$LL3@DECSTR:
  00037	8b c8		 mov	 ecx, eax
  00039	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0003f	79 05		 jns	 SHORT $LN13@DECSTR
  00041	49		 dec	 ecx
  00042	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00045	41		 inc	 ecx
$LN13@DECSTR:
  00046	b2 ed		 mov	 dl, -19			; ffffffedH
  00048	2a d1		 sub	 dl, cl
  0004a	30 14 30	 xor	 BYTE PTR [eax+esi], dl
  0004d	40		 inc	 eax
$LN14@DECSTR:
  0004e	3b c7		 cmp	 eax, edi
  00050	7c e5		 jl	 SHORT $LL3@DECSTR
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?_DECSTR@@YAXPADH@Z ENDP				; _DECSTR
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?IsRight@ControlKeys@@QBE_NXZ			; ControlKeys::IsRight
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iokeymanager.h
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?IsRight@ControlKeys@@QBE_NXZ
_TEXT	SEGMENT
?IsRight@ControlKeys@@QBE_NXZ PROC			; ControlKeys::IsRight, COMDAT
; _this$ = ecx

; 13   : 	{

  00000	56		 push	 esi
  00001	8b d1		 mov	 edx, ecx

; 14   : 		if( strcmp( m_szControlKeys, "" ) == 0 )

  00003	33 c9		 xor	 ecx, ecx
  00005	57		 push	 edi
  00006	41		 inc	 ecx
  00007	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0000c	8b f2		 mov	 esi, edx
  0000e	33 c0		 xor	 eax, eax
  00010	f3 a6		 repe cmpsb
  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	75 03		 jne	 SHORT $LN9@IsRight
$LN14@IsRight:

; 15   : 			return false;

  00016	32 c0		 xor	 al, al

; 32   : 	}

  00018	c3		 ret	 0
$LN9@IsRight:

; 16   : 
; 17   : 		for (int i = 0; i < MAX_CONTROL_KEYS_PLUS_ONE ; i++)

  00019	33 c9		 xor	 ecx, ecx
$LL8@IsRight:

; 18   : 		{
; 19   : 			if( m_szControlKeys[i] == NULL )

  0001b	8a 04 11	 mov	 al, BYTE PTR [ecx+edx]
  0001e	84 c0		 test	 al, al
  00020	74 21		 je	 SHORT $LN6@IsRight

; 20   : 				break;
; 21   : 
; 22   : 			if ((!COMPARE(m_szControlKeys[i], 'A', 'Z'+1)) &&
; 23   : 				(!COMPARE(m_szControlKeys[i], 'a', 'z'+1)) &&
; 24   : 				(!COMPARE(m_szControlKeys[i], '0', '9'+1)) )

  00022	3c 41		 cmp	 al, 65			; 00000041H
  00024	7c 04		 jl	 SHORT $LN3@IsRight
  00026	3c 5b		 cmp	 al, 91			; 0000005bH
  00028	7c 10		 jl	 SHORT $LN7@IsRight
$LN3@IsRight:
  0002a	3c 61		 cmp	 al, 97			; 00000061H
  0002c	7c 04		 jl	 SHORT $LN2@IsRight
  0002e	3c 7b		 cmp	 al, 123			; 0000007bH
  00030	7c 08		 jl	 SHORT $LN7@IsRight
$LN2@IsRight:
  00032	3c 30		 cmp	 al, 48			; 00000030H
  00034	7c e0		 jl	 SHORT $LN14@IsRight
  00036	3c 3a		 cmp	 al, 58			; 0000003aH
  00038	7d dc		 jge	 SHORT $LN14@IsRight
$LN7@IsRight:

; 16   : 
; 17   : 		for (int i = 0; i < MAX_CONTROL_KEYS_PLUS_ONE ; i++)

  0003a	41		 inc	 ecx
  0003b	81 f9 c9 00 00
	00		 cmp	 ecx, 201		; 000000c9H
  00041	7c d8		 jl	 SHORT $LL8@IsRight
$LN6@IsRight:

; 25   : 			{
; 26   : 				return false;
; 27   : 			}
; 28   : 
; 29   : 		}
; 30   : 
; 31   : 		return true;

  00043	b0 01		 mov	 al, 1

; 32   : 	}

  00045	c3		 ret	 0
?IsRight@ControlKeys@@QBE_NXZ ENDP			; ControlKeys::IsRight
_TEXT	ENDS
PUBLIC	?Clear@ControlKeys@@QAEXXZ			; ControlKeys::Clear
EXTRN	_memset:PROC
; Function compile flags: /Ogsp
;	COMDAT ?Clear@ControlKeys@@QAEXXZ
_TEXT	SEGMENT
?Clear@ControlKeys@@QAEXXZ PROC				; ControlKeys::Clear, COMDAT
; _this$ = ecx

; 36   : 		ZeroMemory( m_szControlKeys, sizeof( m_szControlKeys ) );

  00000	68 c9 00 00 00	 push	 201			; 000000c9H
  00005	6a 00		 push	 0
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 _memset
  0000d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 37   : 	}

  00010	c3		 ret	 0
?Clear@ControlKeys@@QAEXXZ ENDP				; ControlKeys::Clear
_TEXT	ENDS
PUBLIC	??0ControlKeys@@QAE@XZ				; ControlKeys::ControlKeys
; Function compile flags: /Ogsp
;	COMDAT ??0ControlKeys@@QAE@XZ
_TEXT	SEGMENT
??0ControlKeys@@QAE@XZ PROC				; ControlKeys::ControlKeys, COMDAT
; _this$ = ecx

; 39   : 	ControlKeys()

  00000	56		 push	 esi

; 40   : 	{
; 41   : 		Clear();

  00001	68 c9 00 00 00	 push	 201			; 000000c9H
  00006	8b f1		 mov	 esi, ecx
  00008	6a 00		 push	 0
  0000a	56		 push	 esi
  0000b	e8 00 00 00 00	 call	 _memset
  00010	83 c4 0c	 add	 esp, 12			; 0000000cH

; 42   : 	}

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c3		 ret	 0
??0ControlKeys@@QAE@XZ ENDP				; ControlKeys::ControlKeys
_TEXT	ENDS
PUBLIC	??0tagMecroTextInfo@CKeyInfo@@QAE@XZ		; CKeyInfo::tagMecroTextInfo::tagMecroTextInfo
EXTRN	__imp_?Clear@ioHashString@@QAEXXZ:PROC
EXTRN	__imp_??0ioHashString@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__EH_epilog3:PROC
EXTRN	__EH_prolog3:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0tagMecroTextInfo@CKeyInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0tagMecroTextInfo@CKeyInfo@@QAE@XZ$0
__ehfuncinfo$??0tagMecroTextInfo@CKeyInfo@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0tagMecroTextInfo@CKeyInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??0tagMecroTextInfo@CKeyInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0tagMecroTextInfo@CKeyInfo@@QAE@XZ PROC		; CKeyInfo::tagMecroTextInfo::tagMecroTextInfo, COMDAT
; _this$ = ecx

; 179  : 		tagMecroTextInfo()

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0tagMecroTextInfo@CKeyInfo@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@XZ
  0001a	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 180  : 		{
; 181  : 			m_bAll = true;
; 182  : 			m_szText.Clear();

  0001e	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00021	c6 06 01	 mov	 BYTE PTR [esi], 1
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Clear@ioHashString@@QAEXXZ

; 183  : 		}

  0002a	8b c6		 mov	 eax, esi
  0002c	e8 00 00 00 00	 call	 __EH_epilog3
  00031	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0tagMecroTextInfo@CKeyInfo@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
__ehhandler$??0tagMecroTextInfo@CKeyInfo@@QAE@XZ:
  0000c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00010	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00013	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00016	33 c8		 xor	 ecx, eax
  00018	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0tagMecroTextInfo@CKeyInfo@@QAE@XZ
  00022	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0tagMecroTextInfo@CKeyInfo@@QAE@XZ ENDP		; CKeyInfo::tagMecroTextInfo::tagMecroTextInfo
PUBLIC	?IsUseKeys@CKeyInfo@@QAE_NXZ			; CKeyInfo::IsUseKeys
; Function compile flags: /Ogsp
;	COMDAT ?IsUseKeys@CKeyInfo@@QAE_NXZ
_TEXT	SEGMENT
?IsUseKeys@CKeyInfo@@QAE_NXZ PROC			; CKeyInfo::IsUseKeys, COMDAT
; _this$ = ecx

; 210  : 	bool IsUseKeys(){ return m_bUse; }

  00000	8a 41 24	 mov	 al, BYTE PTR [ecx+36]
  00003	c3		 ret	 0
?IsUseKeys@CKeyInfo@@QAE_NXZ ENDP			; CKeyInfo::IsUseKeys
_TEXT	ENDS
PUBLIC	?IsAutoFix@CKeyInfo@@QBE_NXZ			; CKeyInfo::IsAutoFix
; Function compile flags: /Ogsp
;	COMDAT ?IsAutoFix@CKeyInfo@@QBE_NXZ
_TEXT	SEGMENT
?IsAutoFix@CKeyInfo@@QBE_NXZ PROC			; CKeyInfo::IsAutoFix, COMDAT
; _this$ = ecx

; 212  : 	bool IsAutoFix() const { return m_bAutoFix; }

  00000	8a 41 25	 mov	 al, BYTE PTR [ecx+37]
  00003	c3		 ret	 0
?IsAutoFix@CKeyInfo@@QBE_NXZ ENDP			; CKeyInfo::IsAutoFix
_TEXT	ENDS
PUBLIC	?IsUseKeys@CJoyKeyInfo@@QAE_NXZ			; CJoyKeyInfo::IsUseKeys
; Function compile flags: /Ogsp
;	COMDAT ?IsUseKeys@CJoyKeyInfo@@QAE_NXZ
_TEXT	SEGMENT
?IsUseKeys@CJoyKeyInfo@@QAE_NXZ PROC			; CJoyKeyInfo::IsUseKeys, COMDAT
; _this$ = ecx

; 331  : 	bool IsUseKeys(){ return m_bUse; }

  00000	8a 41 14	 mov	 al, BYTE PTR [ecx+20]
  00003	c3		 ret	 0
?IsUseKeys@CJoyKeyInfo@@QAE_NXZ ENDP			; CJoyKeyInfo::IsUseKeys
_TEXT	ENDS
PUBLIC	?UseJoyPad@Setting@@SA_NXZ			; Setting::UseJoyPad
EXTRN	?m_Option@Setting@@1USettingOption@@A:BYTE	; Setting::m_Option
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\setting.h
;	COMDAT ?UseJoyPad@Setting@@SA_NXZ
_TEXT	SEGMENT
?UseJoyPad@Setting@@SA_NXZ PROC				; Setting::UseJoyPad, COMDAT

; 353  : 	static bool UseJoyPad() { return m_Option.m_bUseJoyPad; }

  00000	a0 63 00 00 00	 mov	 al, BYTE PTR ?m_Option@Setting@@1USettingOption@@A+99
  00005	c3		 ret	 0
?UseJoyPad@Setting@@SA_NXZ ENDP				; Setting::UseJoyPad
_TEXT	ENDS
PUBLIC	?GetPublicID@ioMyInfo@@QBEABVioHashString@@XZ	; ioMyInfo::GetPublicID
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iomyinfo.h
;	COMDAT ?GetPublicID@ioMyInfo@@QBEABVioHashString@@XZ
_TEXT	SEGMENT
?GetPublicID@ioMyInfo@@QBEABVioHashString@@XZ PROC	; ioMyInfo::GetPublicID, COMDAT
; _this$ = ecx

; 517  : 	const ioHashString& GetPublicID() const { return m_user_data.m_public_id; }    

  00000	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  00003	c3		 ret	 0
?GetPublicID@ioMyInfo@@QBEABVioHashString@@XZ ENDP	; ioMyInfo::GetPublicID
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
; Function compile flags: /Ogsp
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$_Move@AAD@std@@YA$$QADAAD@Z			; std::_Move<char &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$_Move@AAD@std@@YA$$QADAAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAD@std@@YA$$QADAAD@Z PROC			; std::_Move<char &>, COMDAT

; 94   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Move@AAD@std@@YA$$QADAAD@Z ENDP			; std::_Move<char &>
_TEXT	ENDS
PUBLIC	??$move@AA_N@std@@YA$$QA_NAA_N@Z		; std::move<bool &>
; Function compile flags: /Ogsp
;	COMDAT ??$move@AA_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AA_N@std@@YA$$QA_NAA_N@Z PROC			; std::move<bool &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AA_N@std@@YA$$QA_NAA_N@Z ENDP			; std::move<bool &>
_TEXT	ENDS
PUBLIC	??$move@AAVioHashString@@@std@@YA$$QAVioHashString@@AAV1@@Z ; std::move<ioHashString &>
; Function compile flags: /Ogsp
;	COMDAT ??$move@AAVioHashString@@@std@@YA$$QAVioHashString@@AAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAVioHashString@@@std@@YA$$QAVioHashString@@AAV1@@Z PROC ; std::move<ioHashString &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAVioHashString@@@std@@YA$$QAVioHashString@@AAV1@@Z ENDP ; std::move<ioHashString &>
_TEXT	ENDS
PUBLIC	??$forward@_N@std@@YA$$QA_NAA_N@Z		; std::forward<bool>
; Function compile flags: /Ogsp
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
_TEXT	ENDS
PUBLIC	?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z	; CKeyInfo::GetKey
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iokeymanager.cpp
;	COMDAT ?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z
_TEXT	SEGMENT
_eKeyTypeArray$ = 8					; size = 4
?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z PROC		; CKeyInfo::GetKey, COMDAT
; _this$ = ecx

; 21   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 22   : 	if( !COMPARE(eKeyTypeArray, 0, (int)m_vKeyInfo.size() ) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _eKeyTypeArray$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 15		 js	 SHORT $LN1@GetKey
  0000a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000d	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  00010	d1 fa		 sar	 edx, 1
  00012	3b c2		 cmp	 eax, edx
  00014	7d 09		 jge	 SHORT $LN1@GetKey

; 24   : 
; 25   : 	return m_vKeyInfo[eKeyTypeArray];

  00016	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00019	66 8b 04 41	 mov	 ax, WORD PTR [ecx+eax*2]
  0001d	eb 02		 jmp	 SHORT $LN3@GetKey
$LN1@GetKey:

; 23   : 		return KEY_NULL;

  0001f	33 c0		 xor	 eax, eax
$LN3@GetKey:

; 26   : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z ENDP		; CKeyInfo::GetKey
_TEXT	ENDS
PUBLIC	?SetKey@CKeyInfo@@QAE_NW4KeyTypeArray@1@G@Z	; CKeyInfo::SetKey
; Function compile flags: /Ogsp
;	COMDAT ?SetKey@CKeyInfo@@QAE_NW4KeyTypeArray@1@G@Z
_TEXT	SEGMENT
_eKeyTypeArray$ = 8					; size = 4
_wKey$ = 12						; size = 2
?SetKey@CKeyInfo@@QAE_NW4KeyTypeArray@1@G@Z PROC	; CKeyInfo::SetKey, COMDAT
; _this$ = ecx

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 30   : 	if( !COMPARE(eKeyTypeArray, 0, (int)m_vKeyInfo.size()) )

  00005	8b 7d 08	 mov	 edi, DWORD PTR _eKeyTypeArray$[ebp]
  00008	8b d1		 mov	 edx, ecx
  0000a	85 ff		 test	 edi, edi
  0000c	78 2f		 js	 SHORT $LN3@SetKey
  0000e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00011	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00014	d1 f8		 sar	 eax, 1
  00016	3b f8		 cmp	 edi, eax
  00018	7d 23		 jge	 SHORT $LN3@SetKey

; 32   : 
; 33   : 	if( !IsRightKey( wKey ) )

  0001a	8b 75 0c	 mov	 esi, DWORD PTR _wKey$[ebp]
  0001d	56		 push	 esi
  0001e	e8 00 00 00 00	 call	 ?IsRightKey@CKeyInfo@@QAE_NG@Z ; CKeyInfo::IsRightKey
  00023	84 c0		 test	 al, al

; 34   : 		return false;

  00025	74 16		 je	 SHORT $LN3@SetKey

; 35   : 
; 36   : 	if( m_vKeyInfo[eKeyTypeArray] == wKey )

  00027	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0002a	8d 04 78	 lea	 eax, DWORD PTR [eax+edi*2]
  0002d	66 39 30	 cmp	 WORD PTR [eax], si

; 37   : 		return false;

  00030	74 0b		 je	 SHORT $LN3@SetKey

; 38   : 
; 39   : 	m_bUse = true;

  00032	c6 42 24 01	 mov	 BYTE PTR [edx+36], 1

; 40   : 	m_vKeyInfo[eKeyTypeArray] = wKey;

  00036	66 89 30	 mov	 WORD PTR [eax], si

; 41   : 	return true;

  00039	b0 01		 mov	 al, 1
  0003b	eb 02		 jmp	 SHORT $LN5@SetKey
$LN3@SetKey:

; 31   : 		return false;

  0003d	32 c0		 xor	 al, al
$LN5@SetKey:
  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi

; 42   : }

  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
?SetKey@CKeyInfo@@QAE_NW4KeyTypeArray@1@G@Z ENDP	; CKeyInfo::SetKey
_TEXT	ENDS
PUBLIC	?IsRightMacro@CKeyInfo@@QAE_NABV1@@Z		; CKeyInfo::IsRightMacro
EXTRN	__imp_??9ioHashString@@QBE_NABV0@@Z:PROC
; Function compile flags: /Ogsp
;	COMDAT ?IsRightMacro@CKeyInfo@@QAE_NABV1@@Z
_TEXT	SEGMENT
_rKeyInfo$ = 8						; size = 4
?IsRightMacro@CKeyInfo@@QAE_NABV1@@Z PROC		; CKeyInfo::IsRightMacro, COMDAT
; _this$ = ecx

; 58   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b d9		 mov	 ebx, ecx

; 59   : 	if( m_vMecroTextInfo.empty() )

  00006	8b 4b 14	 mov	 ecx, DWORD PTR [ebx+20]
  00009	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  0000c	3b c8		 cmp	 ecx, eax
  0000e	75 04		 jne	 SHORT $LN9@IsRightMac
$LN35@IsRightMac:

; 60   : 		return false;

  00010	32 c0		 xor	 al, al
  00012	eb 5f		 jmp	 SHORT $LN10@IsRightMac
$LN9@IsRightMac:

; 61   : 	if( m_vMecroTextInfo.size() < MAX_MACRO )

  00014	2b c1		 sub	 eax, ecx
  00016	6a 14		 push	 20			; 00000014H
  00018	99		 cdq
  00019	59		 pop	 ecx
  0001a	f7 f9		 idiv	 ecx
  0001c	83 f8 0c	 cmp	 eax, 12			; 0000000cH

; 62   : 		return false;

  0001f	72 ef		 jb	 SHORT $LN35@IsRightMac

; 63   : 
; 64   : 	if( rKeyInfo.m_vMecroTextInfo.empty() )

  00021	57		 push	 edi
  00022	8b 7d 08	 mov	 edi, DWORD PTR _rKeyInfo$[ebp]
  00025	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  00028	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  0002b	3b c8		 cmp	 ecx, eax

; 65   : 		return false;

  0002d	74 0d		 je	 SHORT $LN34@IsRightMac

; 66   : 	if( rKeyInfo.m_vMecroTextInfo.size() < MAX_MACRO )

  0002f	2b c1		 sub	 eax, ecx
  00031	6a 14		 push	 20			; 00000014H
  00033	99		 cdq
  00034	59		 pop	 ecx
  00035	f7 f9		 idiv	 ecx
  00037	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  0003a	73 04		 jae	 SHORT $LN6@IsRightMac
$LN34@IsRightMac:

; 67   : 		return false;

  0003c	32 c0		 xor	 al, al
  0003e	eb 32		 jmp	 SHORT $LN32@IsRightMac
$LN6@IsRightMac:
  00040	56		 push	 esi

; 68   : 
; 69   : 	for(int i = 0;i < MAX_MACRO;i++)

  00041	33 f6		 xor	 esi, esi
$LL5@IsRightMac:

; 70   : 	{
; 71   : 		if( m_vMecroTextInfo[i].m_bAll != rKeyInfo.m_vMecroTextInfo[i].m_bAll )

  00043	8b 4b 14	 mov	 ecx, DWORD PTR [ebx+20]
  00046	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00049	03 ce		 add	 ecx, esi
  0004b	8a 11		 mov	 dl, BYTE PTR [ecx]
  0004d	03 c6		 add	 eax, esi
  0004f	3a 10		 cmp	 dl, BYTE PTR [eax]
  00051	75 25		 jne	 SHORT $LN30@IsRightMac

; 72   : 			return false;
; 73   : 		if( m_vMecroTextInfo[i].m_szText != rKeyInfo.m_vMecroTextInfo[i].m_szText )

  00053	83 c0 04	 add	 eax, 4
  00056	50		 push	 eax
  00057	83 c1 04	 add	 ecx, 4
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??9ioHashString@@QBE_NABV0@@Z
  00060	84 c0		 test	 al, al
  00062	75 14		 jne	 SHORT $LN30@IsRightMac

; 68   : 
; 69   : 	for(int i = 0;i < MAX_MACRO;i++)

  00064	83 c6 14	 add	 esi, 20			; 00000014H
  00067	81 fe f0 00 00
	00		 cmp	 esi, 240		; 000000f0H
  0006d	7c d4		 jl	 SHORT $LL5@IsRightMac

; 75   : 	}
; 76   : 	return true;

  0006f	fe c0		 inc	 al
$LN33@IsRightMac:
  00071	5e		 pop	 esi
$LN32@IsRightMac:
  00072	5f		 pop	 edi
$LN10@IsRightMac:
  00073	5b		 pop	 ebx

; 77   : }

  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
$LN30@IsRightMac:

; 74   : 			return false;

  00078	32 c0		 xor	 al, al
  0007a	eb f5		 jmp	 SHORT $LN33@IsRightMac
?IsRightMacro@CKeyInfo@@QAE_NABV1@@Z ENDP		; CKeyInfo::IsRightMacro
_TEXT	ENDS
PUBLIC	?GetMacroTextInfo@CKeyInfo@@QAEPAUtagMecroTextInfo@1@W4KeyTypeArray@1@@Z ; CKeyInfo::GetMacroTextInfo
; Function compile flags: /Ogsp
;	COMDAT ?GetMacroTextInfo@CKeyInfo@@QAEPAUtagMecroTextInfo@1@W4KeyTypeArray@1@@Z
_TEXT	SEGMENT
_eKeyTypeArray$ = 8					; size = 4
?GetMacroTextInfo@CKeyInfo@@QAEPAUtagMecroTextInfo@1@W4KeyTypeArray@1@@Z PROC ; CKeyInfo::GetMacroTextInfo, COMDAT
; _this$ = ecx

; 277  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 278  : 	if( !COMPARE( eKeyTypeArray, KTA_MACRO1, KTA_MACRO12 +1 ) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _eKeyTypeArray$[ebp]
  00006	8d 50 cd	 lea	 edx, DWORD PTR [eax-51]
  00009	56		 push	 esi
  0000a	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  0000d	77 23		 ja	 SHORT $LN3@GetMacroTe

; 280  : 
; 281  : 	int iMacroArray = eKeyTypeArray - KTA_MACRO1;

  0000f	8d 70 cd	 lea	 esi, DWORD PTR [eax-51]

; 282  : 
; 283  : 	if( !COMPARE( iMacroArray, 0, (int) m_vMecroTextInfo.size() ) )

  00012	85 f6		 test	 esi, esi
  00014	78 1c		 js	 SHORT $LN3@GetMacroTe
  00016	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00019	2b 41 14	 sub	 eax, DWORD PTR [ecx+20]
  0001c	57		 push	 edi
  0001d	6a 14		 push	 20			; 00000014H
  0001f	99		 cdq
  00020	5f		 pop	 edi
  00021	f7 ff		 idiv	 edi
  00023	5f		 pop	 edi
  00024	3b f0		 cmp	 esi, eax
  00026	7d 0a		 jge	 SHORT $LN3@GetMacroTe

; 284  : 		return NULL;
; 285  : 
; 286  : 	return &m_vMecroTextInfo[iMacroArray];

  00028	8b c6		 mov	 eax, esi
  0002a	6b c0 14	 imul	 eax, 20			; 00000014H
  0002d	03 41 14	 add	 eax, DWORD PTR [ecx+20]
  00030	eb 02		 jmp	 SHORT $LN5@GetMacroTe
$LN3@GetMacroTe:

; 279  : 		return NULL;

  00032	33 c0		 xor	 eax, eax
$LN5@GetMacroTe:
  00034	5e		 pop	 esi

; 287  : }

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
?GetMacroTextInfo@CKeyInfo@@QAEPAUtagMecroTextInfo@1@W4KeyTypeArray@1@@Z ENDP ; CKeyInfo::GetMacroTextInfo
_TEXT	ENDS
PUBLIC	?SetMacroTextInfo@CKeyInfo@@QAE_NW4KeyTypeArray@1@ABUtagMecroTextInfo@1@@Z ; CKeyInfo::SetMacroTextInfo
EXTRN	__imp_??8ioHashString@@QBE_NABV0@@Z:PROC
; Function compile flags: /Ogsp
;	COMDAT ?SetMacroTextInfo@CKeyInfo@@QAE_NW4KeyTypeArray@1@ABUtagMecroTextInfo@1@@Z
_TEXT	SEGMENT
tv209 = 8						; size = 4
_eKeyTypeArray$ = 8					; size = 4
_rMacroTextInfo$ = 12					; size = 4
?SetMacroTextInfo@CKeyInfo@@QAE_NW4KeyTypeArray@1@ABUtagMecroTextInfo@1@@Z PROC ; CKeyInfo::SetMacroTextInfo, COMDAT
; _this$ = ecx

; 290  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 291  : 	if( !COMPARE( eKeyTypeArray, KTA_MACRO1, KTA_MACRO12 +1 ) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _eKeyTypeArray$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	8d 48 cd	 lea	 ecx, DWORD PTR [eax-51]
  0000e	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  00011	77 58		 ja	 SHORT $LN4@SetMacroTe

; 293  : 
; 294  : 	int iMacroArray = eKeyTypeArray - KTA_MACRO1;

  00013	8d 70 cd	 lea	 esi, DWORD PTR [eax-51]

; 295  : 
; 296  : 	if( !COMPARE( iMacroArray, 0, (int) m_vMecroTextInfo.size() ) )

  00016	85 f6		 test	 esi, esi
  00018	78 51		 js	 SHORT $LN4@SetMacroTe
  0001a	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  0001d	2b 47 14	 sub	 eax, DWORD PTR [edi+20]
  00020	6a 14		 push	 20			; 00000014H
  00022	99		 cdq
  00023	59		 pop	 ecx
  00024	f7 f9		 idiv	 ecx
  00026	3b f0		 cmp	 esi, eax
  00028	7d 41		 jge	 SHORT $LN4@SetMacroTe

; 297  : 		return false;
; 298  : 
; 299  : 	if( m_vMecroTextInfo[iMacroArray].m_szText == rMacroTextInfo.m_szText &&
; 300  : 		m_vMecroTextInfo[iMacroArray].m_bAll   == rMacroTextInfo.m_bAll )

  0002a	8b 5d 0c	 mov	 ebx, DWORD PTR _rMacroTextInfo$[ebp]
  0002d	6b f6 14	 imul	 esi, 20			; 00000014H
  00030	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00033	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  00036	89 4d 08	 mov	 DWORD PTR tv209[ebp], ecx
  00039	51		 push	 ecx
  0003a	8d 4c 30 04	 lea	 ecx, DWORD PTR [eax+esi+4]
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??8ioHashString@@QBE_NABV0@@Z
  00044	84 c0		 test	 al, al
  00046	74 0a		 je	 SHORT $LN1@SetMacroTe
  00048	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  0004b	8a 04 06	 mov	 al, BYTE PTR [esi+eax]
  0004e	3a 03		 cmp	 al, BYTE PTR [ebx]

; 301  : 		return false;

  00050	74 19		 je	 SHORT $LN4@SetMacroTe
$LN1@SetMacroTe:

; 302  : 
; 303  : 	m_vMecroTextInfo[iMacroArray] = rMacroTextInfo;

  00052	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00055	8a 0b		 mov	 cl, BYTE PTR [ebx]
  00057	ff 75 08	 push	 DWORD PTR tv209[ebp]
  0005a	88 0c 30	 mov	 BYTE PTR [eax+esi], cl
  0005d	8d 4c 30 04	 lea	 ecx, DWORD PTR [eax+esi+4]
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@ABV0@@Z

; 304  : 
; 305  : 	return true;

  00067	b0 01		 mov	 al, 1
  00069	eb 02		 jmp	 SHORT $LN6@SetMacroTe
$LN4@SetMacroTe:

; 292  : 		return false;

  0006b	32 c0		 xor	 al, al
$LN6@SetMacroTe:
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	5b		 pop	 ebx

; 306  : }

  00070	5d		 pop	 ebp
  00071	c2 08 00	 ret	 8
?SetMacroTextInfo@CKeyInfo@@QAE_NW4KeyTypeArray@1@ABUtagMecroTextInfo@1@@Z ENDP ; CKeyInfo::SetMacroTextInfo
_TEXT	ENDS
PUBLIC	?GetEqual@CKeyInfo@@QAE?AW4KeyTypeArray@1@G@Z	; CKeyInfo::GetEqual
; Function compile flags: /Ogsp
;	COMDAT ?GetEqual@CKeyInfo@@QAE?AW4KeyTypeArray@1@G@Z
_TEXT	SEGMENT
_wKey$ = 8						; size = 2
?GetEqual@CKeyInfo@@QAE?AW4KeyTypeArray@1@G@Z PROC	; CKeyInfo::GetEqual, COMDAT
; _this$ = ecx

; 309  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 310  : 	for (int i = 0; i < KTA_MAX ; i++)

  00007	33 f6		 xor	 esi, esi
$LL4@GetEqual:

; 311  : 	{
; 312  : 		KeyTypeArray eType = (KeyTypeArray) i ;
; 313  : 		if( wKey == GetKey( eType ) )

  00009	56		 push	 esi
  0000a	8b cf		 mov	 ecx, edi
  0000c	e8 00 00 00 00	 call	 ?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CKeyInfo::GetKey
  00011	66 39 45 08	 cmp	 WORD PTR _wKey$[ebp], ax
  00015	74 0f		 je	 SHORT $LN8@GetEqual

; 310  : 	for (int i = 0; i < KTA_MAX ; i++)

  00017	46		 inc	 esi
  00018	83 fe 5f	 cmp	 esi, 95			; 0000005fH
  0001b	7c ec		 jl	 SHORT $LL4@GetEqual

; 315  : 	}
; 316  : 
; 317  : 	return KTA_NONE;

  0001d	83 c8 ff	 or	 eax, -1
$LN5@GetEqual:
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 318  : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN8@GetEqual:

; 314  : 			return eType;

  00026	8b c6		 mov	 eax, esi
  00028	eb f6		 jmp	 SHORT $LN5@GetEqual
?GetEqual@CKeyInfo@@QAE?AW4KeyTypeArray@1@G@Z ENDP	; CKeyInfo::GetEqual
_TEXT	ENDS
PUBLIC	??4CKeyInfo@@QAEAAV0@AAV0@@Z			; CKeyInfo::operator=
; Function compile flags: /Ogsp
;	COMDAT ??4CKeyInfo@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
tv189 = 8						; size = 4
_rKeyInfo$ = 8						; size = 4
??4CKeyInfo@@QAEAAV0@AAV0@@Z PROC			; CKeyInfo::operator=, COMDAT
; _this$ = ecx

; 337  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 338  : 	for (int i = 0; i < CKeyInfo::KTA_MAX ; i++)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _rKeyInfo$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	33 f6		 xor	 esi, esi
$LL7@operator@3:

; 339  : 	{
; 340  : 		CKeyInfo::KeyTypeArray eType = (CKeyInfo::KeyTypeArray)i;
; 341  : 		SetKey( eType, rKeyInfo.GetKey( eType ) );

  0000d	56		 push	 esi
  0000e	8b cb		 mov	 ecx, ebx
  00010	e8 00 00 00 00	 call	 ?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CKeyInfo::GetKey
  00015	0f b7 c0	 movzx	 eax, ax
  00018	50		 push	 eax
  00019	56		 push	 esi
  0001a	8b cf		 mov	 ecx, edi
  0001c	e8 00 00 00 00	 call	 ?SetKey@CKeyInfo@@QAE_NW4KeyTypeArray@1@G@Z ; CKeyInfo::SetKey
  00021	46		 inc	 esi
  00022	83 fe 5f	 cmp	 esi, 95			; 0000005fH
  00025	7c e6		 jl	 SHORT $LL7@operator@3

; 342  : 	}
; 343  : 
; 344  : 	for( int i = 0; i < CKeyInfo::MAX_MACRO; i++)

  00027	6a 33		 push	 51			; 00000033H
  00029	5e		 pop	 esi
  0002a	c7 45 08 0c 00
	00 00		 mov	 DWORD PTR tv189[ebp], 12 ; 0000000cH
$LL4@operator@3:

; 345  : 	{
; 346  : 		CKeyInfo::KeyTypeArray eType = (CKeyInfo::KeyTypeArray) (i+CKeyInfo::KTA_MACRO1);
; 347  : 		CKeyInfo::MecroTextInfo *pInfo = rKeyInfo.GetMacroTextInfo( eType );

  00031	56		 push	 esi
  00032	8b cb		 mov	 ecx, ebx
  00034	e8 00 00 00 00	 call	 ?GetMacroTextInfo@CKeyInfo@@QAEPAUtagMecroTextInfo@1@W4KeyTypeArray@1@@Z ; CKeyInfo::GetMacroTextInfo

; 348  : 		if( pInfo )

  00039	85 c0		 test	 eax, eax
  0003b	74 09		 je	 SHORT $LN3@operator@3

; 349  : 			SetMacroTextInfo( eType,  *pInfo);

  0003d	50		 push	 eax
  0003e	56		 push	 esi
  0003f	8b cf		 mov	 ecx, edi
  00041	e8 00 00 00 00	 call	 ?SetMacroTextInfo@CKeyInfo@@QAE_NW4KeyTypeArray@1@ABUtagMecroTextInfo@1@@Z ; CKeyInfo::SetMacroTextInfo
$LN3@operator@3:

; 342  : 	}
; 343  : 
; 344  : 	for( int i = 0; i < CKeyInfo::MAX_MACRO; i++)

  00046	46		 inc	 esi
  00047	ff 4d 08	 dec	 DWORD PTR tv189[ebp]
  0004a	75 e5		 jne	 SHORT $LL4@operator@3

; 350  : 	}
; 351  : 	m_bUse = rKeyInfo.IsUseKeys();

  0004c	8a 43 24	 mov	 al, BYTE PTR [ebx+36]
  0004f	88 47 24	 mov	 BYTE PTR [edi+36], al

; 352  : 	return *this;

  00052	8b c7		 mov	 eax, edi
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx

; 353  : }

  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
??4CKeyInfo@@QAEAAV0@AAV0@@Z ENDP			; CKeyInfo::operator=
_TEXT	ENDS
PUBLIC	?GetKey@CJoyKeyInfo@@QAEGW4KeyTypeArray@1@@Z	; CJoyKeyInfo::GetKey
; Function compile flags: /Ogsp
;	COMDAT ?GetKey@CJoyKeyInfo@@QAEGW4KeyTypeArray@1@@Z
_TEXT	SEGMENT
_eKeyTypeArray$ = 8					; size = 4
?GetKey@CJoyKeyInfo@@QAEGW4KeyTypeArray@1@@Z PROC	; CJoyKeyInfo::GetKey, COMDAT
; _this$ = ecx

; 672  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 673  : 	if( !COMPARE(eKeyTypeArray, 0, (int)m_vKeyInfo.size() ) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _eKeyTypeArray$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 15		 js	 SHORT $LN1@GetKey@2
  0000a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000d	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  00010	d1 fa		 sar	 edx, 1
  00012	3b c2		 cmp	 eax, edx
  00014	7d 09		 jge	 SHORT $LN1@GetKey@2

; 675  : 
; 676  : 	return m_vKeyInfo[eKeyTypeArray];

  00016	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00019	66 8b 04 41	 mov	 ax, WORD PTR [ecx+eax*2]
  0001d	eb 02		 jmp	 SHORT $LN3@GetKey@2
$LN1@GetKey@2:

; 674  : 		return KEY_NULL;

  0001f	33 c0		 xor	 eax, eax
$LN3@GetKey@2:

; 677  : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?GetKey@CJoyKeyInfo@@QAEGW4KeyTypeArray@1@@Z ENDP	; CJoyKeyInfo::GetKey
_TEXT	ENDS
PUBLIC	?SetKey@CJoyKeyInfo@@QAE_NW4KeyTypeArray@1@G@Z	; CJoyKeyInfo::SetKey
; Function compile flags: /Ogsp
;	COMDAT ?SetKey@CJoyKeyInfo@@QAE_NW4KeyTypeArray@1@G@Z
_TEXT	SEGMENT
_eKeyTypeArray$ = 8					; size = 4
_wKey$ = 12						; size = 2
?SetKey@CJoyKeyInfo@@QAE_NW4KeyTypeArray@1@G@Z PROC	; CJoyKeyInfo::SetKey, COMDAT
; _this$ = ecx

; 680  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 681  : 	if( !COMPARE(eKeyTypeArray, 0, (int)m_vKeyInfo.size()) )

  00005	8b 7d 08	 mov	 edi, DWORD PTR _eKeyTypeArray$[ebp]
  00008	8b d1		 mov	 edx, ecx
  0000a	85 ff		 test	 edi, edi
  0000c	78 2f		 js	 SHORT $LN3@SetKey@2
  0000e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00011	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00014	d1 f8		 sar	 eax, 1
  00016	3b f8		 cmp	 edi, eax
  00018	7d 23		 jge	 SHORT $LN3@SetKey@2

; 683  : 
; 684  : 	if( !IsRightKey( wKey ) )

  0001a	8b 75 0c	 mov	 esi, DWORD PTR _wKey$[ebp]
  0001d	56		 push	 esi
  0001e	e8 00 00 00 00	 call	 ?IsRightKey@CJoyKeyInfo@@QAE_NG@Z ; CJoyKeyInfo::IsRightKey
  00023	84 c0		 test	 al, al

; 685  : 		return false;

  00025	74 16		 je	 SHORT $LN3@SetKey@2

; 686  : 
; 687  : 	if( m_vKeyInfo[eKeyTypeArray] == wKey )

  00027	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0002a	8d 04 78	 lea	 eax, DWORD PTR [eax+edi*2]
  0002d	66 39 30	 cmp	 WORD PTR [eax], si

; 688  : 		return false;

  00030	74 0b		 je	 SHORT $LN3@SetKey@2

; 689  : 
; 690  : 	m_bUse = true;

  00032	c6 42 14 01	 mov	 BYTE PTR [edx+20], 1

; 691  : 	m_vKeyInfo[eKeyTypeArray] = wKey;

  00036	66 89 30	 mov	 WORD PTR [eax], si

; 692  : 	return true;

  00039	b0 01		 mov	 al, 1
  0003b	eb 02		 jmp	 SHORT $LN5@SetKey@2
$LN3@SetKey@2:

; 682  : 		return false;

  0003d	32 c0		 xor	 al, al
$LN5@SetKey@2:
  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi

; 693  : }

  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
?SetKey@CJoyKeyInfo@@QAE_NW4KeyTypeArray@1@G@Z ENDP	; CJoyKeyInfo::SetKey
_TEXT	ENDS
PUBLIC	?GetEqual@CJoyKeyInfo@@QAE?AW4KeyTypeArray@1@G@Z ; CJoyKeyInfo::GetEqual
; Function compile flags: /Ogsp
;	COMDAT ?GetEqual@CJoyKeyInfo@@QAE?AW4KeyTypeArray@1@G@Z
_TEXT	SEGMENT
_wKey$ = 8						; size = 2
?GetEqual@CJoyKeyInfo@@QAE?AW4KeyTypeArray@1@G@Z PROC	; CJoyKeyInfo::GetEqual, COMDAT
; _this$ = ecx

; 815  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 816  : 	for (int i = 0; i < JTA_MAX ; i++)

  00007	33 f6		 xor	 esi, esi
$LL4@GetEqual@2:

; 817  : 	{
; 818  : 		KeyTypeArray eType = (KeyTypeArray) i ;
; 819  : 		if( wKey == GetKey( eType ) )

  00009	56		 push	 esi
  0000a	8b cf		 mov	 ecx, edi
  0000c	e8 00 00 00 00	 call	 ?GetKey@CJoyKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CJoyKeyInfo::GetKey
  00011	66 39 45 08	 cmp	 WORD PTR _wKey$[ebp], ax
  00015	74 0f		 je	 SHORT $LN8@GetEqual@2

; 816  : 	for (int i = 0; i < JTA_MAX ; i++)

  00017	46		 inc	 esi
  00018	83 fe 2f	 cmp	 esi, 47			; 0000002fH
  0001b	7c ec		 jl	 SHORT $LL4@GetEqual@2

; 821  : 	}
; 822  : 
; 823  : 	return JTA_NONE;

  0001d	83 c8 ff	 or	 eax, -1
$LN5@GetEqual@2:
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 824  : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN8@GetEqual@2:

; 820  : 			return eType;

  00026	8b c6		 mov	 eax, esi
  00028	eb f6		 jmp	 SHORT $LN5@GetEqual@2
?GetEqual@CJoyKeyInfo@@QAE?AW4KeyTypeArray@1@G@Z ENDP	; CJoyKeyInfo::GetEqual
_TEXT	ENDS
PUBLIC	??4CJoyKeyInfo@@QAEAAV0@AAV0@@Z			; CJoyKeyInfo::operator=
; Function compile flags: /Ogsp
;	COMDAT ??4CJoyKeyInfo@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
_rKeyInfo$ = 8						; size = 4
??4CJoyKeyInfo@@QAEAAV0@AAV0@@Z PROC			; CJoyKeyInfo::operator=, COMDAT
; _this$ = ecx

; 838  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 839  : 	for (int i = 0; i < CJoyKeyInfo::JTA_MAX ; i++)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _rKeyInfo$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	33 f6		 xor	 esi, esi
$LL3@operator@4:

; 840  : 	{
; 841  : 		CJoyKeyInfo::KeyTypeArray eType = (CJoyKeyInfo::KeyTypeArray)i;
; 842  : 		SetKey( eType, rKeyInfo.GetKey( eType ) );

  0000d	56		 push	 esi
  0000e	8b cb		 mov	 ecx, ebx
  00010	e8 00 00 00 00	 call	 ?GetKey@CJoyKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CJoyKeyInfo::GetKey
  00015	0f b7 c0	 movzx	 eax, ax
  00018	50		 push	 eax
  00019	56		 push	 esi
  0001a	8b cf		 mov	 ecx, edi
  0001c	e8 00 00 00 00	 call	 ?SetKey@CJoyKeyInfo@@QAE_NW4KeyTypeArray@1@G@Z ; CJoyKeyInfo::SetKey
  00021	46		 inc	 esi
  00022	83 fe 2f	 cmp	 esi, 47			; 0000002fH
  00025	7c e6		 jl	 SHORT $LL3@operator@4

; 843  : 	}
; 844  : 
; 845  : 	m_bUse = rKeyInfo.IsUseKeys();

  00027	8a 43 14	 mov	 al, BYTE PTR [ebx+20]
  0002a	88 47 14	 mov	 BYTE PTR [edi+20], al

; 846  : 	return *this;

  0002d	8b c7		 mov	 eax, edi
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx

; 847  : }

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??4CJoyKeyInfo@@QAEAAV0@AAV0@@Z ENDP			; CJoyKeyInfo::operator=
_TEXT	ENDS
PUBLIC	??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ	; std::pair<unsigned short const ,ioHashString>::~pair<unsigned short const ,ioHashString>
; Function compile flags: /Ogsp
;	COMDAT ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ PROC		; std::pair<unsigned short const ,ioHashString>::~pair<unsigned short const ,ioHashString>, COMDAT
; _this$ = ecx
  00000	83 c1 04	 add	 ecx, 4
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ ENDP		; std::pair<unsigned short const ,ioHashString>::~pair<unsigned short const ,ioHashString>
_TEXT	ENDS
PUBLIC	?SetCustomKey@ioKeyManager@@QAEXW4KeyTypeArray@CKeyInfo@@G@Z ; ioKeyManager::SetCustomKey
; Function compile flags: /Ogsp
;	COMDAT ?SetCustomKey@ioKeyManager@@QAEXW4KeyTypeArray@CKeyInfo@@G@Z
_TEXT	SEGMENT
_eKeyTypeArray$ = 8					; size = 4
_wKey$ = 12						; size = 2
?SetCustomKey@ioKeyManager@@QAEXW4KeyTypeArray@CKeyInfo@@G@Z PROC ; ioKeyManager::SetCustomKey, COMDAT
; _this$ = ecx

; 1508 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1509 : 	if( m_CustomKeyInfo.SetKey(eKeyTypeArray, wKey) )

  00004	ff 75 0c	 push	 DWORD PTR _wKey$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 75 08	 push	 DWORD PTR _eKeyTypeArray$[ebp]
  0000c	8d 4e 2c	 lea	 ecx, DWORD PTR [esi+44]
  0000f	e8 00 00 00 00	 call	 ?SetKey@CKeyInfo@@QAE_NW4KeyTypeArray@1@G@Z ; CKeyInfo::SetKey
  00014	84 c0		 test	 al, al
  00016	74 07		 je	 SHORT $LN1@SetCustomK

; 1510 : 		m_bSaveKey = true;

  00018	c6 86 95 00 00
	00 01		 mov	 BYTE PTR [esi+149], 1
$LN1@SetCustomK:
  0001f	5e		 pop	 esi

; 1511 : }

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
?SetCustomKey@ioKeyManager@@QAEXW4KeyTypeArray@CKeyInfo@@G@Z ENDP ; ioKeyManager::SetCustomKey
_TEXT	ENDS
PUBLIC	?GetCustomKey@ioKeyManager@@QAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetCustomKey
; Function compile flags: /Ogsp
;	COMDAT ?GetCustomKey@ioKeyManager@@QAEGW4KeyTypeArray@CKeyInfo@@@Z
_TEXT	SEGMENT
_eKeyTypeArray$ = 8					; size = 4
?GetCustomKey@ioKeyManager@@QAEGW4KeyTypeArray@CKeyInfo@@@Z PROC ; ioKeyManager::GetCustomKey, COMDAT
; _this$ = ecx

; 1514 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1515 : 	return m_CustomKeyInfo.GetKey(eKeyTypeArray);

  00003	83 c1 2c	 add	 ecx, 44			; 0000002cH

; 1516 : }

  00006	5d		 pop	 ebp

; 1515 : 	return m_CustomKeyInfo.GetKey(eKeyTypeArray);

  00007	e9 00 00 00 00	 jmp	 ?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CKeyInfo::GetKey
?GetCustomKey@ioKeyManager@@QAEGW4KeyTypeArray@CKeyInfo@@@Z ENDP ; ioKeyManager::GetCustomKey
_TEXT	ENDS
PUBLIC	?GetDefaultKey@ioKeyManager@@QAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetDefaultKey
; Function compile flags: /Ogsp
;	COMDAT ?GetDefaultKey@ioKeyManager@@QAEGW4KeyTypeArray@CKeyInfo@@@Z
_TEXT	SEGMENT
_eKeyTypeArray$ = 8					; size = 4
?GetDefaultKey@ioKeyManager@@QAEGW4KeyTypeArray@CKeyInfo@@@Z PROC ; ioKeyManager::GetDefaultKey, COMDAT
; _this$ = ecx

; 1519 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return m_DefaultKeyInfo.GetKey(eKeyTypeArray);

  00003	83 c1 04	 add	 ecx, 4

; 1521 : }

  00006	5d		 pop	 ebp

; 1520 : 	return m_DefaultKeyInfo.GetKey(eKeyTypeArray);

  00007	e9 00 00 00 00	 jmp	 ?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CKeyInfo::GetKey
?GetDefaultKey@ioKeyManager@@QAEGW4KeyTypeArray@CKeyInfo@@@Z ENDP ; ioKeyManager::GetDefaultKey
_TEXT	ENDS
PUBLIC	?SetCustomJoyKey@ioKeyManager@@QAEXW4KeyTypeArray@CJoyKeyInfo@@G@Z ; ioKeyManager::SetCustomJoyKey
; Function compile flags: /Ogsp
;	COMDAT ?SetCustomJoyKey@ioKeyManager@@QAEXW4KeyTypeArray@CJoyKeyInfo@@G@Z
_TEXT	SEGMENT
_eKeyTypeArray$ = 8					; size = 4
_wKey$ = 12						; size = 2
?SetCustomJoyKey@ioKeyManager@@QAEXW4KeyTypeArray@CJoyKeyInfo@@G@Z PROC ; ioKeyManager::SetCustomJoyKey, COMDAT
; _this$ = ecx

; 1524 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1525 : 	if( m_CustomJoyKeyInfo.SetKey(eKeyTypeArray, wKey) )

  00004	ff 75 0c	 push	 DWORD PTR _wKey$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 75 08	 push	 DWORD PTR _eKeyTypeArray$[ebp]
  0000c	8d 4e 6c	 lea	 ecx, DWORD PTR [esi+108]
  0000f	e8 00 00 00 00	 call	 ?SetKey@CJoyKeyInfo@@QAE_NW4KeyTypeArray@1@G@Z ; CJoyKeyInfo::SetKey
  00014	84 c0		 test	 al, al
  00016	74 07		 je	 SHORT $LN1@SetCustomJ

; 1526 : 		m_bSaveJoyKey = true;

  00018	c6 86 97 00 00
	00 01		 mov	 BYTE PTR [esi+151], 1
$LN1@SetCustomJ:
  0001f	5e		 pop	 esi

; 1527 : }

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
?SetCustomJoyKey@ioKeyManager@@QAEXW4KeyTypeArray@CJoyKeyInfo@@G@Z ENDP ; ioKeyManager::SetCustomJoyKey
_TEXT	ENDS
PUBLIC	?GetCustomJoyKey@ioKeyManager@@QAEGW4KeyTypeArray@CJoyKeyInfo@@@Z ; ioKeyManager::GetCustomJoyKey
; Function compile flags: /Ogsp
;	COMDAT ?GetCustomJoyKey@ioKeyManager@@QAEGW4KeyTypeArray@CJoyKeyInfo@@@Z
_TEXT	SEGMENT
_eKeyTypeArray$ = 8					; size = 4
?GetCustomJoyKey@ioKeyManager@@QAEGW4KeyTypeArray@CJoyKeyInfo@@@Z PROC ; ioKeyManager::GetCustomJoyKey, COMDAT
; _this$ = ecx

; 1530 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1531 : 	return m_CustomJoyKeyInfo.GetKey(eKeyTypeArray);

  00003	83 c1 6c	 add	 ecx, 108		; 0000006cH

; 1532 : }

  00006	5d		 pop	 ebp

; 1531 : 	return m_CustomJoyKeyInfo.GetKey(eKeyTypeArray);

  00007	e9 00 00 00 00	 jmp	 ?GetKey@CJoyKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CJoyKeyInfo::GetKey
?GetCustomJoyKey@ioKeyManager@@QAEGW4KeyTypeArray@CJoyKeyInfo@@@Z ENDP ; ioKeyManager::GetCustomJoyKey
_TEXT	ENDS
PUBLIC	?GetDefaultJoyKey@ioKeyManager@@QAEGW4KeyTypeArray@CJoyKeyInfo@@@Z ; ioKeyManager::GetDefaultJoyKey
; Function compile flags: /Ogsp
;	COMDAT ?GetDefaultJoyKey@ioKeyManager@@QAEGW4KeyTypeArray@CJoyKeyInfo@@@Z
_TEXT	SEGMENT
_eKeyTypeArray$ = 8					; size = 4
?GetDefaultJoyKey@ioKeyManager@@QAEGW4KeyTypeArray@CJoyKeyInfo@@@Z PROC ; ioKeyManager::GetDefaultJoyKey, COMDAT
; _this$ = ecx

; 1535 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1536 : 	return m_DefaultJoyKeyInfo.GetKey(eKeyTypeArray);

  00003	83 c1 54	 add	 ecx, 84			; 00000054H

; 1537 : }

  00006	5d		 pop	 ebp

; 1536 : 	return m_DefaultJoyKeyInfo.GetKey(eKeyTypeArray);

  00007	e9 00 00 00 00	 jmp	 ?GetKey@CJoyKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CJoyKeyInfo::GetKey
?GetDefaultJoyKey@ioKeyManager@@QAEGW4KeyTypeArray@CJoyKeyInfo@@@Z ENDP ; ioKeyManager::GetDefaultJoyKey
_TEXT	ENDS
PUBLIC	?SetCustomMacroTextInfo@ioKeyManager@@QAEXW4KeyTypeArray@CKeyInfo@@ABUtagMecroTextInfo@3@@Z ; ioKeyManager::SetCustomMacroTextInfo
; Function compile flags: /Ogsp
;	COMDAT ?SetCustomMacroTextInfo@ioKeyManager@@QAEXW4KeyTypeArray@CKeyInfo@@ABUtagMecroTextInfo@3@@Z
_TEXT	SEGMENT
_eKeyTypeArray$ = 8					; size = 4
_rMacroTextInfo$ = 12					; size = 4
?SetCustomMacroTextInfo@ioKeyManager@@QAEXW4KeyTypeArray@CKeyInfo@@ABUtagMecroTextInfo@3@@Z PROC ; ioKeyManager::SetCustomMacroTextInfo, COMDAT
; _this$ = ecx

; 1540 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1541 : 	if( m_CustomKeyInfo.SetMacroTextInfo( eKeyTypeArray, rMacroTextInfo ) )

  00004	ff 75 0c	 push	 DWORD PTR _rMacroTextInfo$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 75 08	 push	 DWORD PTR _eKeyTypeArray$[ebp]
  0000c	8d 4e 2c	 lea	 ecx, DWORD PTR [esi+44]
  0000f	e8 00 00 00 00	 call	 ?SetMacroTextInfo@CKeyInfo@@QAE_NW4KeyTypeArray@1@ABUtagMecroTextInfo@1@@Z ; CKeyInfo::SetMacroTextInfo
  00014	84 c0		 test	 al, al
  00016	74 07		 je	 SHORT $LN1@SetCustomM

; 1542 : 		m_bSaveMacroText = true;

  00018	c6 86 98 00 00
	00 01		 mov	 BYTE PTR [esi+152], 1
$LN1@SetCustomM:
  0001f	5e		 pop	 esi

; 1543 : }

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
?SetCustomMacroTextInfo@ioKeyManager@@QAEXW4KeyTypeArray@CKeyInfo@@ABUtagMecroTextInfo@3@@Z ENDP ; ioKeyManager::SetCustomMacroTextInfo
_TEXT	ENDS
PUBLIC	?GetCustomMacroTextInfo@ioKeyManager@@QAEPAUtagMecroTextInfo@CKeyInfo@@W4KeyTypeArray@3@@Z ; ioKeyManager::GetCustomMacroTextInfo
; Function compile flags: /Ogsp
;	COMDAT ?GetCustomMacroTextInfo@ioKeyManager@@QAEPAUtagMecroTextInfo@CKeyInfo@@W4KeyTypeArray@3@@Z
_TEXT	SEGMENT
_eKeyTypeArray$ = 8					; size = 4
?GetCustomMacroTextInfo@ioKeyManager@@QAEPAUtagMecroTextInfo@CKeyInfo@@W4KeyTypeArray@3@@Z PROC ; ioKeyManager::GetCustomMacroTextInfo, COMDAT
; _this$ = ecx

; 1546 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1547 : 	return m_CustomKeyInfo.GetMacroTextInfo(eKeyTypeArray);

  00003	83 c1 2c	 add	 ecx, 44			; 0000002cH

; 1548 : }

  00006	5d		 pop	 ebp

; 1547 : 	return m_CustomKeyInfo.GetMacroTextInfo(eKeyTypeArray);

  00007	e9 00 00 00 00	 jmp	 ?GetMacroTextInfo@CKeyInfo@@QAEPAUtagMecroTextInfo@1@W4KeyTypeArray@1@@Z ; CKeyInfo::GetMacroTextInfo
?GetCustomMacroTextInfo@ioKeyManager@@QAEPAUtagMecroTextInfo@CKeyInfo@@W4KeyTypeArray@3@@Z ENDP ; ioKeyManager::GetCustomMacroTextInfo
_TEXT	ENDS
PUBLIC	?GetDefaultMacroTextInfo@ioKeyManager@@QAEPAUtagMecroTextInfo@CKeyInfo@@W4KeyTypeArray@3@@Z ; ioKeyManager::GetDefaultMacroTextInfo
; Function compile flags: /Ogsp
;	COMDAT ?GetDefaultMacroTextInfo@ioKeyManager@@QAEPAUtagMecroTextInfo@CKeyInfo@@W4KeyTypeArray@3@@Z
_TEXT	SEGMENT
_eKeyTypeArray$ = 8					; size = 4
?GetDefaultMacroTextInfo@ioKeyManager@@QAEPAUtagMecroTextInfo@CKeyInfo@@W4KeyTypeArray@3@@Z PROC ; ioKeyManager::GetDefaultMacroTextInfo, COMDAT
; _this$ = ecx

; 1551 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1552 : 	return m_DefaultKeyInfo.GetMacroTextInfo(eKeyTypeArray);

  00003	83 c1 04	 add	 ecx, 4

; 1553 : }

  00006	5d		 pop	 ebp

; 1552 : 	return m_DefaultKeyInfo.GetMacroTextInfo(eKeyTypeArray);

  00007	e9 00 00 00 00	 jmp	 ?GetMacroTextInfo@CKeyInfo@@QAEPAUtagMecroTextInfo@1@W4KeyTypeArray@1@@Z ; CKeyInfo::GetMacroTextInfo
?GetDefaultMacroTextInfo@ioKeyManager@@QAEPAUtagMecroTextInfo@CKeyInfo@@W4KeyTypeArray@3@@Z ENDP ; ioKeyManager::GetDefaultMacroTextInfo
_TEXT	ENDS
PUBLIC	?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey
; Function compile flags: /Ogsp
;	COMDAT ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z
_TEXT	SEGMENT
_eKeyTypeArray$ = 8					; size = 4
?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z PROC ; ioKeyManager::GetKey, COMDAT
; _this$ = ecx

; 1556 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1557 : 	if(m_bUseCustom)

  00003	80 b9 94 00 00
	00 00		 cmp	 BYTE PTR [ecx+148], 0
  0000a	74 09		 je	 SHORT $LN2@GetKey@3

; 1558 : 		return GetCustomKey( eKeyTypeArray );

  0000c	83 c1 2c	 add	 ecx, 44			; 0000002cH
$LN11@GetKey@3:

; 1561 : }

  0000f	5d		 pop	 ebp

; 1558 : 		return GetCustomKey( eKeyTypeArray );

  00010	e9 00 00 00 00	 jmp	 ?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CKeyInfo::GetKey
$LN2@GetKey@3:

; 1559 : 	else
; 1560 : 		return GetDefaultKey( eKeyTypeArray );

  00015	83 c1 04	 add	 ecx, 4
  00018	eb f5		 jmp	 SHORT $LN11@GetKey@3
?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ENDP ; ioKeyManager::GetKey
_TEXT	ENDS
PUBLIC	?GetJoyKey@ioKeyManager@@AAEGW4KeyTypeArray@CJoyKeyInfo@@@Z ; ioKeyManager::GetJoyKey
; Function compile flags: /Ogsp
;	COMDAT ?GetJoyKey@ioKeyManager@@AAEGW4KeyTypeArray@CJoyKeyInfo@@@Z
_TEXT	SEGMENT
_eKeyTypeArray$ = 8					; size = 4
?GetJoyKey@ioKeyManager@@AAEGW4KeyTypeArray@CJoyKeyInfo@@@Z PROC ; ioKeyManager::GetJoyKey, COMDAT
; _this$ = ecx

; 1564 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1565 : 	if(m_bUseJoyCustom)

  00003	80 b9 96 00 00
	00 00		 cmp	 BYTE PTR [ecx+150], 0
  0000a	74 09		 je	 SHORT $LN2@GetJoyKey

; 1566 : 		return GetCustomJoyKey( eKeyTypeArray );

  0000c	83 c1 6c	 add	 ecx, 108		; 0000006cH
$LN11@GetJoyKey:

; 1569 : }

  0000f	5d		 pop	 ebp

; 1566 : 		return GetCustomJoyKey( eKeyTypeArray );

  00010	e9 00 00 00 00	 jmp	 ?GetKey@CJoyKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CJoyKeyInfo::GetKey
$LN2@GetJoyKey:

; 1567 : 	else
; 1568 : 		return GetDefaultJoyKey( eKeyTypeArray );

  00015	83 c1 54	 add	 ecx, 84			; 00000054H
  00018	eb f5		 jmp	 SHORT $LN11@GetJoyKey
?GetJoyKey@ioKeyManager@@AAEGW4KeyTypeArray@CJoyKeyInfo@@@Z ENDP ; ioKeyManager::GetJoyKey
_TEXT	ENDS
PUBLIC	?GetGameKey@ioKeyManager@@QAEXAAUtagUseKeyValue@ioUserKeyInput@@@Z ; ioKeyManager::GetGameKey
; Function compile flags: /Ogsp
;	COMDAT ?GetGameKey@ioKeyManager@@QAEXAAUtagUseKeyValue@ioUserKeyInput@@@Z
_TEXT	SEGMENT
_rkKeys$ = 8						; size = 4
?GetGameKey@ioKeyManager@@QAEXAAUtagUseKeyValue@ioUserKeyInput@@@Z PROC ; ioKeyManager::GetGameKey, COMDAT
; _this$ = ecx

; 1572 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1573 : 	rkKeys.m_wLeftKey        = GetKey(CKeyInfo::KTA_LEFT);

  00005	6a 02		 push	 2
  00007	8b f9		 mov	 edi, ecx
  00009	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey
  0000e	8b 75 08	 mov	 esi, DWORD PTR _rkKeys$[ebp]

; 1574 : 	rkKeys.m_wRightKey	     = GetKey(CKeyInfo::KTA_RIGHT);		

  00011	6a 03		 push	 3
  00013	8b cf		 mov	 ecx, edi
  00015	66 89 06	 mov	 WORD PTR [esi], ax
  00018	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey

; 1575 : 	rkKeys.m_wUpKey          = GetKey(CKeyInfo::KTA_UP);	

  0001d	6a 00		 push	 0
  0001f	8b cf		 mov	 ecx, edi
  00021	66 89 46 02	 mov	 WORD PTR [esi+2], ax
  00025	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey

; 1576 : 	rkKeys.m_wDownKey	     = GetKey(CKeyInfo::KTA_DOWN);		

  0002a	6a 01		 push	 1
  0002c	8b cf		 mov	 ecx, edi
  0002e	66 89 46 04	 mov	 WORD PTR [esi+4], ax
  00032	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey

; 1577 : 	rkKeys.m_wDefenseKey     = GetKey(CKeyInfo::KTA_DEFENSE);     

  00037	6a 05		 push	 5
  00039	8b cf		 mov	 ecx, edi
  0003b	66 89 46 06	 mov	 WORD PTR [esi+6], ax
  0003f	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey

; 1578 : 	rkKeys.m_wJumpKey        = GetKey(CKeyInfo::KTA_JUMP);      

  00044	6a 06		 push	 6
  00046	8b cf		 mov	 ecx, edi
  00048	66 89 46 10	 mov	 WORD PTR [esi+16], ax
  0004c	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey

; 1579 : 	rkKeys.m_wAttackKey      = GetKey(CKeyInfo::KTA_ATTACK);     

  00051	6a 04		 push	 4
  00053	8b cf		 mov	 ecx, edi
  00055	66 89 46 12	 mov	 WORD PTR [esi+18], ax
  00059	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey

; 1580 : 	rkKeys.m_wCloakSkillKey  = GetKey(CKeyInfo::KTA_CLOAK_SKILL );

  0005e	6a 0e		 push	 14			; 0000000eH
  00060	8b cf		 mov	 ecx, edi
  00062	66 89 46 14	 mov	 WORD PTR [esi+20], ax
  00066	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey

; 1581 : 	rkKeys.m_wHelmetSkillKey = GetKey(CKeyInfo::KTA_HELM_SKILL );

  0006b	6a 0f		 push	 15			; 0000000fH
  0006d	8b cf		 mov	 ecx, edi
  0006f	66 89 46 1c	 mov	 WORD PTR [esi+28], ax
  00073	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey

; 1582 : 	rkKeys.m_wArmorSkillKey  = GetKey(CKeyInfo::KTA_ARMOR_SKILL );

  00078	6a 10		 push	 16			; 00000010H
  0007a	8b cf		 mov	 ecx, edi
  0007c	66 89 46 1a	 mov	 WORD PTR [esi+26], ax
  00080	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey

; 1583 : 	rkKeys.m_wWeaponSkillKey = GetKey(CKeyInfo::KTA_WEAPON_SKILL );

  00085	6a 11		 push	 17			; 00000011H
  00087	8b cf		 mov	 ecx, edi
  00089	66 89 46 18	 mov	 WORD PTR [esi+24], ax
  0008d	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey
  00092	5f		 pop	 edi
  00093	66 89 46 16	 mov	 WORD PTR [esi+22], ax
  00097	5e		 pop	 esi

; 1584 : }

  00098	5d		 pop	 ebp
  00099	c2 04 00	 ret	 4
?GetGameKey@ioKeyManager@@QAEXAAUtagUseKeyValue@ioUserKeyInput@@@Z ENDP ; ioKeyManager::GetGameKey
_TEXT	ENDS
PUBLIC	?GetSecondGameKey@ioKeyManager@@QAEXAAUtagUseKeyValue@ioUserKeyInput@@@Z ; ioKeyManager::GetSecondGameKey
; Function compile flags: /Ogsp
;	COMDAT ?GetSecondGameKey@ioKeyManager@@QAEXAAUtagUseKeyValue@ioUserKeyInput@@@Z
_TEXT	SEGMENT
_rkKeys$ = 8						; size = 4
?GetSecondGameKey@ioKeyManager@@QAEXAAUtagUseKeyValue@ioUserKeyInput@@@Z PROC ; ioKeyManager::GetSecondGameKey, COMDAT
; _this$ = ecx

; 1587 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1588 : 	rkKeys.m_wLeftUpKey    = GetKey(CKeyInfo::KTA_LEFTUP);     

  00005	6a 12		 push	 18			; 00000012H
  00007	8b f9		 mov	 edi, ecx
  00009	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey
  0000e	8b 75 08	 mov	 esi, DWORD PTR _rkKeys$[ebp]

; 1589 : 	rkKeys.m_wLeftDownKey  = GetKey(CKeyInfo::KTA_LEFTDOWN);     

  00011	6a 14		 push	 20			; 00000014H
  00013	8b cf		 mov	 ecx, edi
  00015	66 89 46 08	 mov	 WORD PTR [esi+8], ax
  00019	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey

; 1590 : 	rkKeys.m_wRightUpKey   = GetKey(CKeyInfo::KTA_RIGHTUP);     

  0001e	6a 13		 push	 19			; 00000013H
  00020	8b cf		 mov	 ecx, edi
  00022	66 89 46 0a	 mov	 WORD PTR [esi+10], ax
  00026	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey

; 1591 : 	rkKeys.m_wRightDownKey = GetKey(CKeyInfo::KTA_RIGHTDOWN);  

  0002b	6a 15		 push	 21			; 00000015H
  0002d	8b cf		 mov	 ecx, edi
  0002f	66 89 46 0c	 mov	 WORD PTR [esi+12], ax
  00033	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey

; 1592 : 	rkKeys.m_wDefenseKey   = GetKey(CKeyInfo::KTA_SECOND_DEFENSE);     

  00038	6a 0c		 push	 12			; 0000000cH
  0003a	8b cf		 mov	 ecx, edi
  0003c	66 89 46 0e	 mov	 WORD PTR [esi+14], ax
  00040	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey

; 1593 : 	rkKeys.m_wJumpKey      = GetKey(CKeyInfo::KTA_SECOND_JUMP);      

  00045	6a 0d		 push	 13			; 0000000dH
  00047	8b cf		 mov	 ecx, edi
  00049	66 89 46 10	 mov	 WORD PTR [esi+16], ax
  0004d	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey

; 1594 : 	rkKeys.m_wAttackKey    = GetKey(CKeyInfo::KTA_SECOND_ATTACK);  

  00052	6a 0b		 push	 11			; 0000000bH
  00054	8b cf		 mov	 ecx, edi
  00056	66 89 46 12	 mov	 WORD PTR [esi+18], ax
  0005a	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey
  0005f	66 89 46 14	 mov	 WORD PTR [esi+20], ax

; 1595 : 
; 1596 : 	//  Second key  
; 1597 : 	rkKeys.m_wLeftKey   = KEY_NULL;

  00063	33 c0		 xor	 eax, eax
  00065	5f		 pop	 edi
  00066	66 89 06	 mov	 WORD PTR [esi], ax

; 1598 : 	rkKeys.m_wRightKey  = KEY_NULL;

  00069	66 89 46 02	 mov	 WORD PTR [esi+2], ax

; 1599 : 	rkKeys.m_wUpKey     = KEY_NULL;

  0006d	66 89 46 04	 mov	 WORD PTR [esi+4], ax

; 1600 : 	rkKeys.m_wDownKey   = KEY_NULL;

  00071	66 89 46 06	 mov	 WORD PTR [esi+6], ax
  00075	5e		 pop	 esi

; 1601 : 
; 1602 : 	// 	SafeGetKey(rkKeys.m_wLeftKey,     CKeyInfo::KTA_SECOND_LEFT);
; 1603 : 	// 	SafeGetKey(rkKeys.m_wRightKey,	  CKeyInfo::KTA_SECOND_RIGHT);		
; 1604 : 	// 	SafeGetKey(rkKeys.m_wUpKey,		  CKeyInfo::KTA_SECOND_UP);	
; 1605 : 	// 	SafeGetKey(rkKeys.m_wDownKey,	  CKeyInfo::KTA_SECOND_DOWN);		     
; 1606 : }

  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
?GetSecondGameKey@ioKeyManager@@QAEXAAUtagUseKeyValue@ioUserKeyInput@@@Z ENDP ; ioKeyManager::GetSecondGameKey
_TEXT	ENDS
PUBLIC	?GetJoyGameKey@ioKeyManager@@QAEXAAUtagUseKeyValue@ioUserKeyInput@@@Z ; ioKeyManager::GetJoyGameKey
; Function compile flags: /Ogsp
;	COMDAT ?GetJoyGameKey@ioKeyManager@@QAEXAAUtagUseKeyValue@ioUserKeyInput@@@Z
_TEXT	SEGMENT
_rkKeys$ = 8						; size = 4
?GetJoyGameKey@ioKeyManager@@QAEXAAUtagUseKeyValue@ioUserKeyInput@@@Z PROC ; ioKeyManager::GetJoyGameKey, COMDAT
; _this$ = ecx

; 1609 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1610 : 	if( Setting::UseJoyPad() )

  00003	80 3d 63 00 00
	00 00		 cmp	 BYTE PTR ?m_Option@Setting@@1USettingOption@@A+99, 0
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	0f 84 93 00 00
	00		 je	 $LN2@GetJoyGame

; 1611 : 	{
; 1612 : 		rkKeys.m_wLeftKey        = GetJoyKey(CJoyKeyInfo::JTA_LEFT);

  00013	56		 push	 esi
  00014	6a 02		 push	 2
  00016	e8 00 00 00 00	 call	 ?GetJoyKey@ioKeyManager@@AAEGW4KeyTypeArray@CJoyKeyInfo@@@Z ; ioKeyManager::GetJoyKey
  0001b	8b 75 08	 mov	 esi, DWORD PTR _rkKeys$[ebp]

; 1613 : 		rkKeys.m_wRightKey       = GetJoyKey(CJoyKeyInfo::JTA_RIGHT);

  0001e	6a 03		 push	 3
  00020	8b cf		 mov	 ecx, edi
  00022	66 89 06	 mov	 WORD PTR [esi], ax
  00025	e8 00 00 00 00	 call	 ?GetJoyKey@ioKeyManager@@AAEGW4KeyTypeArray@CJoyKeyInfo@@@Z ; ioKeyManager::GetJoyKey

; 1614 : 		rkKeys.m_wUpKey          = GetJoyKey(CJoyKeyInfo::JTA_UP);

  0002a	6a 00		 push	 0
  0002c	8b cf		 mov	 ecx, edi
  0002e	66 89 46 02	 mov	 WORD PTR [esi+2], ax
  00032	e8 00 00 00 00	 call	 ?GetJoyKey@ioKeyManager@@AAEGW4KeyTypeArray@CJoyKeyInfo@@@Z ; ioKeyManager::GetJoyKey

; 1615 : 		rkKeys.m_wDownKey        = GetJoyKey(CJoyKeyInfo::JTA_DOWN);

  00037	6a 01		 push	 1
  00039	8b cf		 mov	 ecx, edi
  0003b	66 89 46 04	 mov	 WORD PTR [esi+4], ax
  0003f	e8 00 00 00 00	 call	 ?GetJoyKey@ioKeyManager@@AAEGW4KeyTypeArray@CJoyKeyInfo@@@Z ; ioKeyManager::GetJoyKey

; 1616 : 		
; 1617 : 		rkKeys.m_wDefenseKey     = GetJoyKey(CJoyKeyInfo::JTA_DEFENSE);

  00044	6a 05		 push	 5
  00046	8b cf		 mov	 ecx, edi
  00048	66 89 46 06	 mov	 WORD PTR [esi+6], ax
  0004c	e8 00 00 00 00	 call	 ?GetJoyKey@ioKeyManager@@AAEGW4KeyTypeArray@CJoyKeyInfo@@@Z ; ioKeyManager::GetJoyKey

; 1618 : 		rkKeys.m_wJumpKey        = GetJoyKey(CJoyKeyInfo::JTA_JUMP);

  00051	6a 06		 push	 6
  00053	8b cf		 mov	 ecx, edi
  00055	66 89 46 10	 mov	 WORD PTR [esi+16], ax
  00059	e8 00 00 00 00	 call	 ?GetJoyKey@ioKeyManager@@AAEGW4KeyTypeArray@CJoyKeyInfo@@@Z ; ioKeyManager::GetJoyKey

; 1619 : 		rkKeys.m_wAttackKey      = GetJoyKey(CJoyKeyInfo::JTA_ATTACK);

  0005e	6a 04		 push	 4
  00060	8b cf		 mov	 ecx, edi
  00062	66 89 46 12	 mov	 WORD PTR [esi+18], ax
  00066	e8 00 00 00 00	 call	 ?GetJoyKey@ioKeyManager@@AAEGW4KeyTypeArray@CJoyKeyInfo@@@Z ; ioKeyManager::GetJoyKey

; 1620 : 		
; 1621 : 		rkKeys.m_wCloakSkillKey  = GetJoyKey(CJoyKeyInfo::JTA_CLOAK_SKILL );

  0006b	6a 07		 push	 7
  0006d	8b cf		 mov	 ecx, edi
  0006f	66 89 46 14	 mov	 WORD PTR [esi+20], ax
  00073	e8 00 00 00 00	 call	 ?GetJoyKey@ioKeyManager@@AAEGW4KeyTypeArray@CJoyKeyInfo@@@Z ; ioKeyManager::GetJoyKey

; 1622 : 		rkKeys.m_wHelmetSkillKey = GetJoyKey(CJoyKeyInfo::JTA_HELM_SKILL );

  00078	6a 08		 push	 8
  0007a	8b cf		 mov	 ecx, edi
  0007c	66 89 46 1c	 mov	 WORD PTR [esi+28], ax
  00080	e8 00 00 00 00	 call	 ?GetJoyKey@ioKeyManager@@AAEGW4KeyTypeArray@CJoyKeyInfo@@@Z ; ioKeyManager::GetJoyKey

; 1623 : 		rkKeys.m_wArmorSkillKey  = GetJoyKey(CJoyKeyInfo::JTA_ARMOR_SKILL );

  00085	6a 09		 push	 9
  00087	8b cf		 mov	 ecx, edi
  00089	66 89 46 1a	 mov	 WORD PTR [esi+26], ax
  0008d	e8 00 00 00 00	 call	 ?GetJoyKey@ioKeyManager@@AAEGW4KeyTypeArray@CJoyKeyInfo@@@Z ; ioKeyManager::GetJoyKey

; 1624 : 		rkKeys.m_wWeaponSkillKey = GetJoyKey(CJoyKeyInfo::JTA_WEAPON_SKILL );

  00092	6a 0a		 push	 10			; 0000000aH
  00094	8b cf		 mov	 ecx, edi
  00096	66 89 46 18	 mov	 WORD PTR [esi+24], ax
  0009a	e8 00 00 00 00	 call	 ?GetJoyKey@ioKeyManager@@AAEGW4KeyTypeArray@CJoyKeyInfo@@@Z ; ioKeyManager::GetJoyKey
  0009f	66 89 46 16	 mov	 WORD PTR [esi+22], ax
  000a3	5e		 pop	 esi

; 1625 : 	}
; 1626 : 	else

  000a4	eb 30		 jmp	 SHORT $LN1@GetJoyGame
$LN2@GetJoyGame:

; 1627 : 	{
; 1628 : 		rkKeys.m_wLeftKey   = KEY_NULL;

  000a6	8b 45 08	 mov	 eax, DWORD PTR _rkKeys$[ebp]
  000a9	33 c9		 xor	 ecx, ecx
  000ab	66 89 08	 mov	 WORD PTR [eax], cx

; 1629 : 		rkKeys.m_wRightKey  = KEY_NULL;

  000ae	66 89 48 02	 mov	 WORD PTR [eax+2], cx

; 1630 : 		rkKeys.m_wUpKey     = KEY_NULL;

  000b2	66 89 48 04	 mov	 WORD PTR [eax+4], cx

; 1631 : 		rkKeys.m_wDownKey   = KEY_NULL;

  000b6	66 89 48 06	 mov	 WORD PTR [eax+6], cx

; 1632 : 
; 1633 : 		rkKeys.m_wDefenseKey	= KEY_NULL;

  000ba	66 89 48 10	 mov	 WORD PTR [eax+16], cx

; 1634 : 		rkKeys.m_wJumpKey		= KEY_NULL;

  000be	66 89 48 12	 mov	 WORD PTR [eax+18], cx

; 1635 : 		rkKeys.m_wAttackKey		= KEY_NULL;

  000c2	66 89 48 14	 mov	 WORD PTR [eax+20], cx

; 1636 : 
; 1637 : 		rkKeys.m_wCloakSkillKey		= KEY_NULL;

  000c6	66 89 48 1c	 mov	 WORD PTR [eax+28], cx

; 1638 : 		rkKeys.m_wHelmetSkillKey	= KEY_NULL;

  000ca	66 89 48 1a	 mov	 WORD PTR [eax+26], cx

; 1639 : 		rkKeys.m_wArmorSkillKey		= KEY_NULL;

  000ce	66 89 48 18	 mov	 WORD PTR [eax+24], cx

; 1640 : 		rkKeys.m_wWeaponSkillKey	= KEY_NULL;

  000d2	66 89 48 16	 mov	 WORD PTR [eax+22], cx
$LN1@GetJoyGame:
  000d6	5f		 pop	 edi

; 1641 : 	}
; 1642 : }

  000d7	5d		 pop	 ebp
  000d8	c2 04 00	 ret	 4
?GetJoyGameKey@ioKeyManager@@QAEXAAUtagUseKeyValue@ioUserKeyInput@@@Z ENDP ; ioKeyManager::GetJoyGameKey
_TEXT	ENDS
PUBLIC	?GetMacroTextInfo@ioKeyManager@@QAEPAUtagMecroTextInfo@CKeyInfo@@W4KeyTypeArray@3@@Z ; ioKeyManager::GetMacroTextInfo
; Function compile flags: /Ogsp
;	COMDAT ?GetMacroTextInfo@ioKeyManager@@QAEPAUtagMecroTextInfo@CKeyInfo@@W4KeyTypeArray@3@@Z
_TEXT	SEGMENT
_eKeyTypeArray$ = 8					; size = 4
?GetMacroTextInfo@ioKeyManager@@QAEPAUtagMecroTextInfo@CKeyInfo@@W4KeyTypeArray@3@@Z PROC ; ioKeyManager::GetMacroTextInfo, COMDAT
; _this$ = ecx

; 1645 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1646 : 	if( !m_DefaultKeyInfo.IsRightMacro( m_CustomKeyInfo ) )

  00005	8d 71 2c	 lea	 esi, DWORD PTR [ecx+44]
  00008	8d 79 04	 lea	 edi, DWORD PTR [ecx+4]
  0000b	56		 push	 esi
  0000c	8b cf		 mov	 ecx, edi
  0000e	e8 00 00 00 00	 call	 ?IsRightMacro@CKeyInfo@@QAE_NABV1@@Z ; CKeyInfo::IsRightMacro

; 1647 : 		return GetCustomMacroTextInfo( eKeyTypeArray );

  00013	ff 75 08	 push	 DWORD PTR _eKeyTypeArray$[ebp]
  00016	8b ce		 mov	 ecx, esi
  00018	84 c0		 test	 al, al
  0001a	74 02		 je	 SHORT $LN9@GetMacroTe@2

; 1648 : 	else
; 1649 : 		return GetDefaultMacroTextInfo( eKeyTypeArray );

  0001c	8b cf		 mov	 ecx, edi
$LN9@GetMacroTe@2:
  0001e	e8 00 00 00 00	 call	 ?GetMacroTextInfo@CKeyInfo@@QAEPAUtagMecroTextInfo@1@W4KeyTypeArray@1@@Z ; CKeyInfo::GetMacroTextInfo
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi

; 1650 : }

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?GetMacroTextInfo@ioKeyManager@@QAEPAUtagMecroTextInfo@CKeyInfo@@W4KeyTypeArray@3@@Z ENDP ; ioKeyManager::GetMacroTextInfo
_TEXT	ENDS
PUBLIC	?GetSingleton@ioKeyManager@@SAAAV1@XZ		; ioKeyManager::GetSingleton
; Function compile flags: /Ogsp
;	COMDAT ?GetSingleton@ioKeyManager@@SAAAV1@XZ
_TEXT	SEGMENT
?GetSingleton@ioKeyManager@@SAAAV1@XZ PROC		; ioKeyManager::GetSingleton, COMDAT

; 1654 : 	return Singleton< ioKeyManager >::GetSingleton(); 

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_Singleton@?$Singleton@VioKeyManager@@@@1PAVioKeyManager@@A ; Singleton<ioKeyManager>::ms_Singleton

; 1655 : }

  00005	c3		 ret	 0
?GetSingleton@ioKeyManager@@SAAAV1@XZ ENDP		; ioKeyManager::GetSingleton
_TEXT	ENDS
PUBLIC	?IsHelpKeyPress@ioKeyManager@@QAE_NXZ		; ioKeyManager::IsHelpKeyPress
EXTRN	?IsKeyPress@CDirectInput@@QAI_NG@Z:PROC		; CDirectInput::IsKeyPress
EXTRN	?GetSingleton@CDirectInput@@SAAAV1@XZ:PROC	; CDirectInput::GetSingleton
; Function compile flags: /Ogsp
;	COMDAT ?IsHelpKeyPress@ioKeyManager@@QAE_NXZ
_TEXT	SEGMENT
?IsHelpKeyPress@ioKeyManager@@QAE_NXZ PROC		; ioKeyManager::IsHelpKeyPress, COMDAT
; _this$ = ecx

; 1658 : {

  00000	56		 push	 esi

; 1659 : 	return g_Input.IsKeyPress( GetKey(CKeyInfo::KTA_HELP) );

  00001	6a 1a		 push	 26			; 0000001aH
  00003	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey
  00008	0f b7 f0	 movzx	 esi, ax
  0000b	e8 00 00 00 00	 call	 ?GetSingleton@CDirectInput@@SAAAV1@XZ ; CDirectInput::GetSingleton
  00010	8b d6		 mov	 edx, esi
  00012	8b c8		 mov	 ecx, eax
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ?IsKeyPress@CDirectInput@@QAI_NG@Z ; CDirectInput::IsKeyPress
?IsHelpKeyPress@ioKeyManager@@QAE_NXZ ENDP		; ioKeyManager::IsHelpKeyPress
_TEXT	ENDS
PUBLIC	?IsShopKeyPress@ioKeyManager@@QAE_NXZ		; ioKeyManager::IsShopKeyPress
; Function compile flags: /Ogsp
;	COMDAT ?IsShopKeyPress@ioKeyManager@@QAE_NXZ
_TEXT	SEGMENT
?IsShopKeyPress@ioKeyManager@@QAE_NXZ PROC		; ioKeyManager::IsShopKeyPress, COMDAT
; _this$ = ecx

; 1663 : {

  00000	56		 push	 esi

; 1664 : 	return g_Input.IsKeyPress( GetKey( CKeyInfo::KTA_SHOP ) );

  00001	6a 19		 push	 25			; 00000019H
  00003	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey
  00008	0f b7 f0	 movzx	 esi, ax
  0000b	e8 00 00 00 00	 call	 ?GetSingleton@CDirectInput@@SAAAV1@XZ ; CDirectInput::GetSingleton
  00010	8b d6		 mov	 edx, esi
  00012	8b c8		 mov	 ecx, eax
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ?IsKeyPress@CDirectInput@@QAI_NG@Z ; CDirectInput::IsKeyPress
?IsShopKeyPress@ioKeyManager@@QAE_NXZ ENDP		; ioKeyManager::IsShopKeyPress
_TEXT	ENDS
PUBLIC	?IsGrowthKeyPress@ioKeyManager@@QAE_NXZ		; ioKeyManager::IsGrowthKeyPress
; Function compile flags: /Ogsp
;	COMDAT ?IsGrowthKeyPress@ioKeyManager@@QAE_NXZ
_TEXT	SEGMENT
?IsGrowthKeyPress@ioKeyManager@@QAE_NXZ PROC		; ioKeyManager::IsGrowthKeyPress, COMDAT
; _this$ = ecx

; 1668 : {

  00000	56		 push	 esi

; 1669 : 	return g_Input.IsKeyPress( GetKey( CKeyInfo::KTA_GROWTH ) );

  00001	6a 1c		 push	 28			; 0000001cH
  00003	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey
  00008	0f b7 f0	 movzx	 esi, ax
  0000b	e8 00 00 00 00	 call	 ?GetSingleton@CDirectInput@@SAAAV1@XZ ; CDirectInput::GetSingleton
  00010	8b d6		 mov	 edx, esi
  00012	8b c8		 mov	 ecx, eax
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ?IsKeyPress@CDirectInput@@QAI_NG@Z ; CDirectInput::IsKeyPress
?IsGrowthKeyPress@ioKeyManager@@QAE_NXZ ENDP		; ioKeyManager::IsGrowthKeyPress
_TEXT	ENDS
PUBLIC	?IsQuestKeyPress@ioKeyManager@@QAE_NXZ		; ioKeyManager::IsQuestKeyPress
; Function compile flags: /Ogsp
;	COMDAT ?IsQuestKeyPress@ioKeyManager@@QAE_NXZ
_TEXT	SEGMENT
?IsQuestKeyPress@ioKeyManager@@QAE_NXZ PROC		; ioKeyManager::IsQuestKeyPress, COMDAT
; _this$ = ecx

; 1673 : {

  00000	56		 push	 esi

; 1674 : 	return g_Input.IsKeyPress( GetKey( CKeyInfo::KTA_QUEST ) );

  00001	6a 3f		 push	 63			; 0000003fH
  00003	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey
  00008	0f b7 f0	 movzx	 esi, ax
  0000b	e8 00 00 00 00	 call	 ?GetSingleton@CDirectInput@@SAAAV1@XZ ; CDirectInput::GetSingleton
  00010	8b d6		 mov	 edx, esi
  00012	8b c8		 mov	 ecx, eax
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ?IsKeyPress@CDirectInput@@QAI_NG@Z ; CDirectInput::IsKeyPress
?IsQuestKeyPress@ioKeyManager@@QAE_NXZ ENDP		; ioKeyManager::IsQuestKeyPress
_TEXT	ENDS
PUBLIC	?IsPresentKeyPress@ioKeyManager@@QAE_NXZ	; ioKeyManager::IsPresentKeyPress
; Function compile flags: /Ogsp
;	COMDAT ?IsPresentKeyPress@ioKeyManager@@QAE_NXZ
_TEXT	SEGMENT
?IsPresentKeyPress@ioKeyManager@@QAE_NXZ PROC		; ioKeyManager::IsPresentKeyPress, COMDAT
; _this$ = ecx

; 1678 : {

  00000	56		 push	 esi

; 1679 : 	return g_Input.IsKeyPress( GetKey( CKeyInfo::KTA_PRESENT ) );

  00001	6a 40		 push	 64			; 00000040H
  00003	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey
  00008	0f b7 f0	 movzx	 esi, ax
  0000b	e8 00 00 00 00	 call	 ?GetSingleton@CDirectInput@@SAAAV1@XZ ; CDirectInput::GetSingleton
  00010	8b d6		 mov	 edx, esi
  00012	8b c8		 mov	 ecx, eax
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ?IsKeyPress@CDirectInput@@QAI_NG@Z ; CDirectInput::IsKeyPress
?IsPresentKeyPress@ioKeyManager@@QAE_NXZ ENDP		; ioKeyManager::IsPresentKeyPress
_TEXT	ENDS
PUBLIC	?IsMyHomePageKeyPress@ioKeyManager@@QAE_NXZ	; ioKeyManager::IsMyHomePageKeyPress
; Function compile flags: /Ogsp
;	COMDAT ?IsMyHomePageKeyPress@ioKeyManager@@QAE_NXZ
_TEXT	SEGMENT
?IsMyHomePageKeyPress@ioKeyManager@@QAE_NXZ PROC	; ioKeyManager::IsMyHomePageKeyPress, COMDAT
; _this$ = ecx

; 1683 : {

  00000	56		 push	 esi

; 1684 : 	return g_Input.IsKeyPress( GetKey( CKeyInfo::KTA_MYHOMEPAGE ) );

  00001	6a 41		 push	 65			; 00000041H
  00003	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey
  00008	0f b7 f0	 movzx	 esi, ax
  0000b	e8 00 00 00 00	 call	 ?GetSingleton@CDirectInput@@SAAAV1@XZ ; CDirectInput::GetSingleton
  00010	8b d6		 mov	 edx, esi
  00012	8b c8		 mov	 ecx, eax
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ?IsKeyPress@CDirectInput@@QAI_NG@Z ; CDirectInput::IsKeyPress
?IsMyHomePageKeyPress@ioKeyManager@@QAE_NXZ ENDP	; ioKeyManager::IsMyHomePageKeyPress
_TEXT	ENDS
PUBLIC	?IsOptionKeyPress@ioKeyManager@@QAE_NXZ		; ioKeyManager::IsOptionKeyPress
; Function compile flags: /Ogsp
;	COMDAT ?IsOptionKeyPress@ioKeyManager@@QAE_NXZ
_TEXT	SEGMENT
?IsOptionKeyPress@ioKeyManager@@QAE_NXZ PROC		; ioKeyManager::IsOptionKeyPress, COMDAT
; _this$ = ecx

; 1688 : {

  00000	56		 push	 esi

; 1689 : 	return g_Input.IsKeyPress( GetKey( CKeyInfo::KTA_OPTION) );

  00001	6a 1e		 push	 30			; 0000001eH
  00003	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey
  00008	0f b7 f0	 movzx	 esi, ax
  0000b	e8 00 00 00 00	 call	 ?GetSingleton@CDirectInput@@SAAAV1@XZ ; CDirectInput::GetSingleton
  00010	8b d6		 mov	 edx, esi
  00012	8b c8		 mov	 ecx, eax
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ?IsKeyPress@CDirectInput@@QAI_NG@Z ; CDirectInput::IsKeyPress
?IsOptionKeyPress@ioKeyManager@@QAE_NXZ ENDP		; ioKeyManager::IsOptionKeyPress
_TEXT	ENDS
PUBLIC	?IsMessengerKeyPress@ioKeyManager@@QAE_NXZ	; ioKeyManager::IsMessengerKeyPress
; Function compile flags: /Ogsp
;	COMDAT ?IsMessengerKeyPress@ioKeyManager@@QAE_NXZ
_TEXT	SEGMENT
?IsMessengerKeyPress@ioKeyManager@@QAE_NXZ PROC		; ioKeyManager::IsMessengerKeyPress, COMDAT
; _this$ = ecx

; 1693 : {

  00000	56		 push	 esi

; 1694 : 	return g_Input.IsKeyPress( GetKey( CKeyInfo::KTA_MESSENGER ) );

  00001	6a 1f		 push	 31			; 0000001fH
  00003	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey
  00008	0f b7 f0	 movzx	 esi, ax
  0000b	e8 00 00 00 00	 call	 ?GetSingleton@CDirectInput@@SAAAV1@XZ ; CDirectInput::GetSingleton
  00010	8b d6		 mov	 edx, esi
  00012	8b c8		 mov	 ecx, eax
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ?IsKeyPress@CDirectInput@@QAI_NG@Z ; CDirectInput::IsKeyPress
?IsMessengerKeyPress@ioKeyManager@@QAE_NXZ ENDP		; ioKeyManager::IsMessengerKeyPress
_TEXT	ENDS
PUBLIC	?IsVoiceChatKeyPress@ioKeyManager@@QAE_NXZ	; ioKeyManager::IsVoiceChatKeyPress
; Function compile flags: /Ogsp
;	COMDAT ?IsVoiceChatKeyPress@ioKeyManager@@QAE_NXZ
_TEXT	SEGMENT
?IsVoiceChatKeyPress@ioKeyManager@@QAE_NXZ PROC		; ioKeyManager::IsVoiceChatKeyPress, COMDAT
; _this$ = ecx

; 1698 : {

  00000	56		 push	 esi

; 1699 : 	return g_Input.IsKeyPress( GetKey( CKeyInfo::KTA_VOICE) );

  00001	6a 20		 push	 32			; 00000020H
  00003	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey
  00008	0f b7 f0	 movzx	 esi, ax
  0000b	e8 00 00 00 00	 call	 ?GetSingleton@CDirectInput@@SAAAV1@XZ ; CDirectInput::GetSingleton
  00010	8b d6		 mov	 edx, esi
  00012	8b c8		 mov	 ecx, eax
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ?IsKeyPress@CDirectInput@@QAI_NG@Z ; CDirectInput::IsKeyPress
?IsVoiceChatKeyPress@ioKeyManager@@QAE_NXZ ENDP		; ioKeyManager::IsVoiceChatKeyPress
_TEXT	ENDS
PUBLIC	?IsScreenShotKeyPress@ioKeyManager@@QAE_NXZ	; ioKeyManager::IsScreenShotKeyPress
; Function compile flags: /Ogsp
;	COMDAT ?IsScreenShotKeyPress@ioKeyManager@@QAE_NXZ
_TEXT	SEGMENT
?IsScreenShotKeyPress@ioKeyManager@@QAE_NXZ PROC	; ioKeyManager::IsScreenShotKeyPress, COMDAT
; _this$ = ecx

; 1703 : {

  00000	56		 push	 esi

; 1704 : 	return g_Input.IsKeyPress( GetKey( CKeyInfo::KTA_SCREENSHOT ) );

  00001	6a 21		 push	 33			; 00000021H
  00003	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey
  00008	0f b7 f0	 movzx	 esi, ax
  0000b	e8 00 00 00 00	 call	 ?GetSingleton@CDirectInput@@SAAAV1@XZ ; CDirectInput::GetSingleton
  00010	8b d6		 mov	 edx, esi
  00012	8b c8		 mov	 ecx, eax
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ?IsKeyPress@CDirectInput@@QAI_NG@Z ; CDirectInput::IsKeyPress
?IsScreenShotKeyPress@ioKeyManager@@QAE_NXZ ENDP	; ioKeyManager::IsScreenShotKeyPress
_TEXT	ENDS
PUBLIC	?IsMovieCaptureKeyPress@ioKeyManager@@QAE_NXZ	; ioKeyManager::IsMovieCaptureKeyPress
; Function compile flags: /Ogsp
;	COMDAT ?IsMovieCaptureKeyPress@ioKeyManager@@QAE_NXZ
_TEXT	SEGMENT
?IsMovieCaptureKeyPress@ioKeyManager@@QAE_NXZ PROC	; ioKeyManager::IsMovieCaptureKeyPress, COMDAT
; _this$ = ecx

; 1708 : {

  00000	56		 push	 esi

; 1709 : 	return g_Input.IsKeyPress( GetKey( CKeyInfo::KTA_MOVIECAPTURE ) );

  00001	6a 22		 push	 34			; 00000022H
  00003	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey
  00008	0f b7 f0	 movzx	 esi, ax
  0000b	e8 00 00 00 00	 call	 ?GetSingleton@CDirectInput@@SAAAV1@XZ ; CDirectInput::GetSingleton
  00010	8b d6		 mov	 edx, esi
  00012	8b c8		 mov	 ecx, eax
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ?IsKeyPress@CDirectInput@@QAI_NG@Z ; CDirectInput::IsKeyPress
?IsMovieCaptureKeyPress@ioKeyManager@@QAE_NXZ ENDP	; ioKeyManager::IsMovieCaptureKeyPress
_TEXT	ENDS
PUBLIC	?IsSpecialMotionKeyPress@ioKeyManager@@QAE_NXZ	; ioKeyManager::IsSpecialMotionKeyPress
; Function compile flags: /Ogsp
;	COMDAT ?IsSpecialMotionKeyPress@ioKeyManager@@QAE_NXZ
_TEXT	SEGMENT
?IsSpecialMotionKeyPress@ioKeyManager@@QAE_NXZ PROC	; ioKeyManager::IsSpecialMotionKeyPress, COMDAT
; _this$ = ecx

; 1713 : {

  00000	56		 push	 esi

; 1714 : 	return g_Input.IsKeyPress( GetKey( CKeyInfo::KTA_SPECIAL_MOTION ) );

  00001	6a 23		 push	 35			; 00000023H
  00003	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey
  00008	0f b7 f0	 movzx	 esi, ax
  0000b	e8 00 00 00 00	 call	 ?GetSingleton@CDirectInput@@SAAAV1@XZ ; CDirectInput::GetSingleton
  00010	8b d6		 mov	 edx, esi
  00012	8b c8		 mov	 ecx, eax
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ?IsKeyPress@CDirectInput@@QAI_NG@Z ; CDirectInput::IsKeyPress
?IsSpecialMotionKeyPress@ioKeyManager@@QAE_NXZ ENDP	; ioKeyManager::IsSpecialMotionKeyPress
_TEXT	ENDS
PUBLIC	?IsUsersCustomSoundKeyPress@ioKeyManager@@QAE_NXZ ; ioKeyManager::IsUsersCustomSoundKeyPress
; Function compile flags: /Ogsp
;	COMDAT ?IsUsersCustomSoundKeyPress@ioKeyManager@@QAE_NXZ
_TEXT	SEGMENT
?IsUsersCustomSoundKeyPress@ioKeyManager@@QAE_NXZ PROC	; ioKeyManager::IsUsersCustomSoundKeyPress, COMDAT
; _this$ = ecx

; 1718 : {

  00000	56		 push	 esi

; 1719 : 	return g_Input.IsKeyPress( GetKey( CKeyInfo::KTA_USERS_CUSTOM_SOUND ) );

  00001	6a 26		 push	 38			; 00000026H
  00003	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey
  00008	0f b7 f0	 movzx	 esi, ax
  0000b	e8 00 00 00 00	 call	 ?GetSingleton@CDirectInput@@SAAAV1@XZ ; CDirectInput::GetSingleton
  00010	8b d6		 mov	 edx, esi
  00012	8b c8		 mov	 ecx, eax
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ?IsKeyPress@CDirectInput@@QAI_NG@Z ; CDirectInput::IsKeyPress
?IsUsersCustomSoundKeyPress@ioKeyManager@@QAE_NXZ ENDP	; ioKeyManager::IsUsersCustomSoundKeyPress
_TEXT	ENDS
PUBLIC	?IsZoomInKeyRepeat@ioKeyManager@@QAE_NXZ	; ioKeyManager::IsZoomInKeyRepeat
EXTRN	?IsKeyRepeat@CDirectInput@@QAI_NG@Z:PROC	; CDirectInput::IsKeyRepeat
; Function compile flags: /Ogsp
;	COMDAT ?IsZoomInKeyRepeat@ioKeyManager@@QAE_NXZ
_TEXT	SEGMENT
?IsZoomInKeyRepeat@ioKeyManager@@QAE_NXZ PROC		; ioKeyManager::IsZoomInKeyRepeat, COMDAT
; _this$ = ecx

; 1723 : {

  00000	56		 push	 esi

; 1724 : 	return g_Input.IsKeyRepeat( GetKey( CKeyInfo::KTA_ZOOMIN ) );

  00001	6a 24		 push	 36			; 00000024H
  00003	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey
  00008	0f b7 f0	 movzx	 esi, ax
  0000b	e8 00 00 00 00	 call	 ?GetSingleton@CDirectInput@@SAAAV1@XZ ; CDirectInput::GetSingleton
  00010	8b d6		 mov	 edx, esi
  00012	8b c8		 mov	 ecx, eax
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ?IsKeyRepeat@CDirectInput@@QAI_NG@Z ; CDirectInput::IsKeyRepeat
?IsZoomInKeyRepeat@ioKeyManager@@QAE_NXZ ENDP		; ioKeyManager::IsZoomInKeyRepeat
_TEXT	ENDS
PUBLIC	?IsZoomOutKeyRepeat@ioKeyManager@@QAE_NXZ	; ioKeyManager::IsZoomOutKeyRepeat
; Function compile flags: /Ogsp
;	COMDAT ?IsZoomOutKeyRepeat@ioKeyManager@@QAE_NXZ
_TEXT	SEGMENT
?IsZoomOutKeyRepeat@ioKeyManager@@QAE_NXZ PROC		; ioKeyManager::IsZoomOutKeyRepeat, COMDAT
; _this$ = ecx

; 1728 : {

  00000	56		 push	 esi

; 1729 : 	return g_Input.IsKeyRepeat( GetKey( CKeyInfo::KTA_ZOOMOUT ) );

  00001	6a 25		 push	 37			; 00000025H
  00003	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey
  00008	0f b7 f0	 movzx	 esi, ax
  0000b	e8 00 00 00 00	 call	 ?GetSingleton@CDirectInput@@SAAAV1@XZ ; CDirectInput::GetSingleton
  00010	8b d6		 mov	 edx, esi
  00012	8b c8		 mov	 ecx, eax
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ?IsKeyRepeat@CDirectInput@@QAI_NG@Z ; CDirectInput::IsKeyRepeat
?IsZoomOutKeyRepeat@ioKeyManager@@QAE_NXZ ENDP		; ioKeyManager::IsZoomOutKeyRepeat
_TEXT	ENDS
PUBLIC	?IsPetKeyPress@ioKeyManager@@QAE_NXZ		; ioKeyManager::IsPetKeyPress
; Function compile flags: /Ogsp
;	COMDAT ?IsPetKeyPress@ioKeyManager@@QAE_NXZ
_TEXT	SEGMENT
?IsPetKeyPress@ioKeyManager@@QAE_NXZ PROC		; ioKeyManager::IsPetKeyPress, COMDAT
; _this$ = ecx

; 1733 : {

  00000	56		 push	 esi

; 1734 : 	return g_Input.IsKeyPress( GetKey( CKeyInfo::KTA_PET ) );

  00001	6a 5e		 push	 94			; 0000005eH
  00003	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey
  00008	0f b7 f0	 movzx	 esi, ax
  0000b	e8 00 00 00 00	 call	 ?GetSingleton@CDirectInput@@SAAAV1@XZ ; CDirectInput::GetSingleton
  00010	8b d6		 mov	 edx, esi
  00012	8b c8		 mov	 ecx, eax
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ?IsKeyPress@CDirectInput@@QAI_NG@Z ; CDirectInput::IsKeyPress
?IsPetKeyPress@ioKeyManager@@QAE_NXZ ENDP		; ioKeyManager::IsPetKeyPress
_TEXT	ENDS
PUBLIC	?GetConsumptionKeyPress@ioKeyManager@@QAEHXZ	; ioKeyManager::GetConsumptionKeyPress
; Function compile flags: /Ogsp
;	COMDAT ?GetConsumptionKeyPress@ioKeyManager@@QAEHXZ
_TEXT	SEGMENT
?GetConsumptionKeyPress@ioKeyManager@@QAEHXZ PROC	; ioKeyManager::GetConsumptionKeyPress, COMDAT
; _this$ = ecx

; 1738 : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 1739 : 	if( g_Input.IsKeyPress( GetKey( CKeyInfo::KTA_CONSUMPTION1 ) ))

  00002	6a 5a		 push	 90			; 0000005aH
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey
  0000b	0f b7 f8	 movzx	 edi, ax
  0000e	e8 00 00 00 00	 call	 ?GetSingleton@CDirectInput@@SAAAV1@XZ ; CDirectInput::GetSingleton
  00013	8b d7		 mov	 edx, edi
  00015	8b c8		 mov	 ecx, eax
  00017	e8 00 00 00 00	 call	 ?IsKeyPress@CDirectInput@@QAI_NG@Z ; CDirectInput::IsKeyPress
  0001c	84 c0		 test	 al, al
  0001e	74 05		 je	 SHORT $LN7@GetConsump

; 1740 : 		return ((int)CKeyInfo::KTA_CONSUMPTION1);

  00020	6a 5a		 push	 90			; 0000005aH
$LN10@GetConsump:
  00022	58		 pop	 eax
  00023	eb 69		 jmp	 SHORT $LN1@GetConsump
$LN7@GetConsump:

; 1741 : 	else if( g_Input.IsKeyPress( GetKey( CKeyInfo::KTA_CONSUMPTION2 ) ))

  00025	6a 5b		 push	 91			; 0000005bH
  00027	8b ce		 mov	 ecx, esi
  00029	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey
  0002e	0f b7 f8	 movzx	 edi, ax
  00031	e8 00 00 00 00	 call	 ?GetSingleton@CDirectInput@@SAAAV1@XZ ; CDirectInput::GetSingleton
  00036	8b d7		 mov	 edx, edi
  00038	8b c8		 mov	 ecx, eax
  0003a	e8 00 00 00 00	 call	 ?IsKeyPress@CDirectInput@@QAI_NG@Z ; CDirectInput::IsKeyPress
  0003f	84 c0		 test	 al, al
  00041	74 04		 je	 SHORT $LN5@GetConsump

; 1742 : 		return ((int)CKeyInfo::KTA_CONSUMPTION2);

  00043	6a 5b		 push	 91			; 0000005bH
  00045	eb db		 jmp	 SHORT $LN10@GetConsump
$LN5@GetConsump:

; 1743 : 	else if( g_Input.IsKeyPress( GetKey( CKeyInfo::KTA_CONSUMPTION3 ) ))

  00047	6a 5c		 push	 92			; 0000005cH
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey
  00050	0f b7 f8	 movzx	 edi, ax
  00053	e8 00 00 00 00	 call	 ?GetSingleton@CDirectInput@@SAAAV1@XZ ; CDirectInput::GetSingleton
  00058	8b d7		 mov	 edx, edi
  0005a	8b c8		 mov	 ecx, eax
  0005c	e8 00 00 00 00	 call	 ?IsKeyPress@CDirectInput@@QAI_NG@Z ; CDirectInput::IsKeyPress
  00061	84 c0		 test	 al, al
  00063	74 04		 je	 SHORT $LN3@GetConsump

; 1744 : 		return ((int)CKeyInfo::KTA_CONSUMPTION3);

  00065	6a 5c		 push	 92			; 0000005cH
  00067	eb b9		 jmp	 SHORT $LN10@GetConsump
$LN3@GetConsump:

; 1745 : 	else if( g_Input.IsKeyPress( GetKey( CKeyInfo::KTA_CONSUMPTION4 ) ))

  00069	6a 5d		 push	 93			; 0000005dH
  0006b	8b ce		 mov	 ecx, esi
  0006d	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey
  00072	0f b7 f0	 movzx	 esi, ax
  00075	e8 00 00 00 00	 call	 ?GetSingleton@CDirectInput@@SAAAV1@XZ ; CDirectInput::GetSingleton
  0007a	8b d6		 mov	 edx, esi
  0007c	8b c8		 mov	 ecx, eax
  0007e	e8 00 00 00 00	 call	 ?IsKeyPress@CDirectInput@@QAI_NG@Z ; CDirectInput::IsKeyPress
  00083	0f b6 c0	 movzx	 eax, al
  00086	f7 d8		 neg	 eax
  00088	1b c0		 sbb	 eax, eax
  0008a	83 e0 5e	 and	 eax, 94			; 0000005eH
  0008d	48		 dec	 eax
$LN1@GetConsump:

; 1746 : 		return ((int)CKeyInfo::KTA_CONSUMPTION4);
; 1747 : 
; 1748 : 	return -1;
; 1749 : }

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	c3		 ret	 0
?GetConsumptionKeyPress@ioKeyManager@@QAEHXZ ENDP	; ioKeyManager::GetConsumptionKeyPress
_TEXT	ENDS
PUBLIC	?GetSoldierKeyPressArray@ioKeyManager@@QAEHXZ	; ioKeyManager::GetSoldierKeyPressArray
; Function compile flags: /Ogsp
;	COMDAT ?GetSoldierKeyPressArray@ioKeyManager@@QAEHXZ
_TEXT	SEGMENT
?GetSoldierKeyPressArray@ioKeyManager@@QAEHXZ PROC	; ioKeyManager::GetSoldierKeyPressArray, COMDAT
; _this$ = ecx

; 1752 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx

; 1753 : 	for (int i = 0; i < MAX_CHARACTER_KEY ; i++)

  00005	33 f6		 xor	 esi, esi
$LL19@GetSoldier:

; 1754 : 	{
; 1755 : 		enum { FIRST_KEY_MAX = 12, SECOND_KEY_MAX = 36, };
; 1756 : 		CKeyInfo::KeyTypeArray eKeyTypeArray = CKeyInfo::KTA_NONE;

  00007	83 c8 ff	 or	 eax, -1

; 1757 : 		if( COMPARE( i, 0, FIRST_KEY_MAX ) )

  0000a	85 f6		 test	 esi, esi
  0000c	78 0a		 js	 SHORT $LN6@GetSoldier
  0000e	83 fe 0c	 cmp	 esi, 12			; 0000000cH
  00011	7d 0a		 jge	 SHORT $LN18@GetSoldier

; 1758 : 			eKeyTypeArray = (CKeyInfo::KeyTypeArray) ( CKeyInfo::KTA_SOLDIER1 + i );

  00013	8d 46 27	 lea	 eax, DWORD PTR [esi+39]
  00016	eb 0d		 jmp	 SHORT $LN4@GetSoldier
$LN6@GetSoldier:

; 1759 : 		else if( COMPARE( i, FIRST_KEY_MAX, SECOND_KEY_MAX ) )

  00018	83 fe 0c	 cmp	 esi, 12			; 0000000cH
  0001b	7c 08		 jl	 SHORT $LN4@GetSoldier
$LN18@GetSoldier:
  0001d	83 fe 24	 cmp	 esi, 36			; 00000024H
  00020	7d 03		 jge	 SHORT $LN4@GetSoldier

; 1760 : 			eKeyTypeArray = (CKeyInfo::KeyTypeArray) ( CKeyInfo::KTA_SOLDIER13 + ( i - FIRST_KEY_MAX ) );

  00022	8d 46 36	 lea	 eax, DWORD PTR [esi+54]
$LN4@GetSoldier:

; 1761 : 
; 1762 : 		if( g_Input.IsKeyPress( GetKey( eKeyTypeArray ) ) )

  00025	50		 push	 eax
  00026	8b cf		 mov	 ecx, edi
  00028	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey
  0002d	0f b7 d8	 movzx	 ebx, ax
  00030	e8 00 00 00 00	 call	 ?GetSingleton@CDirectInput@@SAAAV1@XZ ; CDirectInput::GetSingleton
  00035	8b d3		 mov	 edx, ebx
  00037	8b c8		 mov	 ecx, eax
  00039	e8 00 00 00 00	 call	 ?IsKeyPress@CDirectInput@@QAI_NG@Z ; CDirectInput::IsKeyPress
  0003e	84 c0		 test	 al, al
  00040	75 35		 jne	 SHORT $LN15@GetSoldier

; 1764 : 
; 1765 : 		if( Setting::UseJoyPad() )

  00042	38 05 63 00 00
	00		 cmp	 BYTE PTR ?m_Option@Setting@@1USettingOption@@A+99, al
  00048	74 20		 je	 SHORT $LN8@GetSoldier

; 1766 : 		{
; 1767 : 			if( g_Input.IsKeyPress( GetJoyKey( (CJoyKeyInfo::KeyTypeArray)( CJoyKeyInfo::JTA_SOLDIER1+i) ) ) )

  0004a	8d 46 0b	 lea	 eax, DWORD PTR [esi+11]
  0004d	50		 push	 eax
  0004e	8b cf		 mov	 ecx, edi
  00050	e8 00 00 00 00	 call	 ?GetJoyKey@ioKeyManager@@AAEGW4KeyTypeArray@CJoyKeyInfo@@@Z ; ioKeyManager::GetJoyKey
  00055	0f b7 d8	 movzx	 ebx, ax
  00058	e8 00 00 00 00	 call	 ?GetSingleton@CDirectInput@@SAAAV1@XZ ; CDirectInput::GetSingleton
  0005d	8b d3		 mov	 edx, ebx
  0005f	8b c8		 mov	 ecx, eax
  00061	e8 00 00 00 00	 call	 ?IsKeyPress@CDirectInput@@QAI_NG@Z ; CDirectInput::IsKeyPress
  00066	84 c0		 test	 al, al
  00068	75 0d		 jne	 SHORT $LN15@GetSoldier
$LN8@GetSoldier:

; 1753 : 	for (int i = 0; i < MAX_CHARACTER_KEY ; i++)

  0006a	46		 inc	 esi
  0006b	83 fe 24	 cmp	 esi, 36			; 00000024H
  0006e	7c 97		 jl	 SHORT $LL19@GetSoldier

; 1768 : 				return i;
; 1769 : 		}
; 1770 : 	}
; 1771 : 
; 1772 : 	return -1;

  00070	83 c8 ff	 or	 eax, -1
$LN10@GetSoldier:
  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx

; 1773 : }

  00076	c3		 ret	 0
$LN15@GetSoldier:

; 1763 : 			return i;

  00077	8b c6		 mov	 eax, esi
  00079	eb f8		 jmp	 SHORT $LN10@GetSoldier
?GetSoldierKeyPressArray@ioKeyManager@@QAEHXZ ENDP	; ioKeyManager::GetSoldierKeyPressArray
_TEXT	ENDS
PUBLIC	?GetMacroKeyPress@ioKeyManager@@QAE?AW4KeyTypeArray@CKeyInfo@@XZ ; ioKeyManager::GetMacroKeyPress
; Function compile flags: /Ogsp
;	COMDAT ?GetMacroKeyPress@ioKeyManager@@QAE?AW4KeyTypeArray@CKeyInfo@@XZ
_TEXT	SEGMENT
?GetMacroKeyPress@ioKeyManager@@QAE?AW4KeyTypeArray@CKeyInfo@@XZ PROC ; ioKeyManager::GetMacroKeyPress, COMDAT
; _this$ = ecx

; 1776 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx

; 1777 : 	for (int i = 0; i < CKeyInfo::MAX_MACRO ; i++)

  00005	33 f6		 xor	 esi, esi
$LL4@GetMacroKe:

; 1778 : 	{
; 1779 : 		if( g_Input.IsKeyPress( GetKey( (CKeyInfo::KeyTypeArray)( CKeyInfo::KTA_MACRO1+i) ) ) )

  00007	8d 46 33	 lea	 eax, DWORD PTR [esi+51]
  0000a	50		 push	 eax
  0000b	8b cf		 mov	 ecx, edi
  0000d	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey
  00012	0f b7 d8	 movzx	 ebx, ax
  00015	e8 00 00 00 00	 call	 ?GetSingleton@CDirectInput@@SAAAV1@XZ ; CDirectInput::GetSingleton
  0001a	8b d3		 mov	 edx, ebx
  0001c	8b c8		 mov	 ecx, eax
  0001e	e8 00 00 00 00	 call	 ?IsKeyPress@CDirectInput@@QAI_NG@Z ; CDirectInput::IsKeyPress
  00023	84 c0		 test	 al, al
  00025	75 0d		 jne	 SHORT $LN8@GetMacroKe

; 1777 : 	for (int i = 0; i < CKeyInfo::MAX_MACRO ; i++)

  00027	46		 inc	 esi
  00028	83 fe 0c	 cmp	 esi, 12			; 0000000cH
  0002b	7c da		 jl	 SHORT $LL4@GetMacroKe

; 1781 : 	}
; 1782 : 
; 1783 : 	return CKeyInfo::KTA_NONE;

  0002d	83 c8 ff	 or	 eax, -1
$LN5@GetMacroKe:
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx

; 1784 : }

  00033	c3		 ret	 0
$LN8@GetMacroKe:

; 1780 : 			return (CKeyInfo::KeyTypeArray)(i+CKeyInfo::KTA_MACRO1);

  00034	8d 46 33	 lea	 eax, DWORD PTR [esi+51]
  00037	eb f7		 jmp	 SHORT $LN5@GetMacroKe
?GetMacroKeyPress@ioKeyManager@@QAE?AW4KeyTypeArray@CKeyInfo@@XZ ENDP ; ioKeyManager::GetMacroKeyPress
_TEXT	ENDS
PUBLIC	?GetCurrentSoldierKey@ioKeyManager@@QAEGH@Z	; ioKeyManager::GetCurrentSoldierKey
; Function compile flags: /Ogsp
;	COMDAT ?GetCurrentSoldierKey@ioKeyManager@@QAEGH@Z
_TEXT	SEGMENT
_iSoldierNumber$ = 8					; size = 4
?GetCurrentSoldierKey@ioKeyManager@@QAEGH@Z PROC	; ioKeyManager::GetCurrentSoldierKey, COMDAT
; _this$ = ecx

; 1787 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1788 : 	enum { FIRST_KEY_MAX = 12, SECOND_KEY_MAX = 36, };
; 1789 : 	CKeyInfo::KeyTypeArray eKeyTypeArray = CKeyInfo::KTA_NONE;
; 1790 : 	if( COMPARE( iSoldierNumber, 0, FIRST_KEY_MAX ) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iSoldierNumber$[ebp]
  00006	83 ca ff	 or	 edx, -1
  00009	85 c0		 test	 eax, eax
  0000b	78 0a		 js	 SHORT $LN3@GetCurrent
  0000d	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  00010	7d 0a		 jge	 SHORT $LN6@GetCurrent

; 1791 : 		eKeyTypeArray = (CKeyInfo::KeyTypeArray) ( CKeyInfo::KTA_SOLDIER1 + iSoldierNumber );

  00012	8d 50 27	 lea	 edx, DWORD PTR [eax+39]
  00015	eb 0d		 jmp	 SHORT $LN1@GetCurrent
$LN3@GetCurrent:

; 1792 : 	else if( COMPARE( iSoldierNumber, FIRST_KEY_MAX, SECOND_KEY_MAX ) )

  00017	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  0001a	7c 08		 jl	 SHORT $LN1@GetCurrent
$LN6@GetCurrent:
  0001c	83 f8 24	 cmp	 eax, 36			; 00000024H
  0001f	7d 03		 jge	 SHORT $LN1@GetCurrent

; 1793 : 		eKeyTypeArray = (CKeyInfo::KeyTypeArray) ( CKeyInfo::KTA_SOLDIER13 + ( iSoldierNumber - FIRST_KEY_MAX ) );

  00021	8d 50 36	 lea	 edx, DWORD PTR [eax+54]
$LN1@GetCurrent:

; 1794 : 		
; 1795 : 	return GetKey( eKeyTypeArray );

  00024	52		 push	 edx
  00025	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey

; 1796 : }

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?GetCurrentSoldierKey@ioKeyManager@@QAEGH@Z ENDP	; ioKeyManager::GetCurrentSoldierKey
_TEXT	ENDS
PUBLIC	?GetCurrentConsumptionKey@ioKeyManager@@QAEGH@Z	; ioKeyManager::GetCurrentConsumptionKey
; Function compile flags: /Ogsp
;	COMDAT ?GetCurrentConsumptionKey@ioKeyManager@@QAEGH@Z
_TEXT	SEGMENT
_nSlot$ = 8						; size = 4
?GetCurrentConsumptionKey@ioKeyManager@@QAEGH@Z PROC	; ioKeyManager::GetCurrentConsumptionKey, COMDAT
; _this$ = ecx

; 1799 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1800 : 	return GetKey( (CKeyInfo::KeyTypeArray)(CKeyInfo::KTA_CONSUMPTION1 + nSlot));

  00003	8b 45 08	 mov	 eax, DWORD PTR _nSlot$[ebp]
  00006	83 c0 5a	 add	 eax, 90			; 0000005aH
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey

; 1801 : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?GetCurrentConsumptionKey@ioKeyManager@@QAEGH@Z ENDP	; ioKeyManager::GetCurrentConsumptionKey
_TEXT	ENDS
PUBLIC	?GetCurrentHelpKey@ioKeyManager@@QAEGXZ		; ioKeyManager::GetCurrentHelpKey
; Function compile flags: /Ogsp
;	COMDAT ?GetCurrentHelpKey@ioKeyManager@@QAEGXZ
_TEXT	SEGMENT
?GetCurrentHelpKey@ioKeyManager@@QAEGXZ PROC		; ioKeyManager::GetCurrentHelpKey, COMDAT
; _this$ = ecx

; 1805 : 	return GetKey( CKeyInfo::KTA_HELP );

  00000	6a 1a		 push	 26			; 0000001aH
  00002	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey

; 1806 : }

  00007	c3		 ret	 0
?GetCurrentHelpKey@ioKeyManager@@QAEGXZ ENDP		; ioKeyManager::GetCurrentHelpKey
_TEXT	ENDS
PUBLIC	?GetCurrentShopKey@ioKeyManager@@QAEGXZ		; ioKeyManager::GetCurrentShopKey
; Function compile flags: /Ogsp
;	COMDAT ?GetCurrentShopKey@ioKeyManager@@QAEGXZ
_TEXT	SEGMENT
?GetCurrentShopKey@ioKeyManager@@QAEGXZ PROC		; ioKeyManager::GetCurrentShopKey, COMDAT
; _this$ = ecx

; 1810 : 	return GetKey( CKeyInfo::KTA_SHOP );

  00000	6a 19		 push	 25			; 00000019H
  00002	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey

; 1811 : }

  00007	c3		 ret	 0
?GetCurrentShopKey@ioKeyManager@@QAEGXZ ENDP		; ioKeyManager::GetCurrentShopKey
_TEXT	ENDS
PUBLIC	?GetCurrentGrowthKey@ioKeyManager@@QAEGXZ	; ioKeyManager::GetCurrentGrowthKey
; Function compile flags: /Ogsp
;	COMDAT ?GetCurrentGrowthKey@ioKeyManager@@QAEGXZ
_TEXT	SEGMENT
?GetCurrentGrowthKey@ioKeyManager@@QAEGXZ PROC		; ioKeyManager::GetCurrentGrowthKey, COMDAT
; _this$ = ecx

; 1815 : 	return GetKey( CKeyInfo::KTA_GROWTH );

  00000	6a 1c		 push	 28			; 0000001cH
  00002	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey

; 1816 : }

  00007	c3		 ret	 0
?GetCurrentGrowthKey@ioKeyManager@@QAEGXZ ENDP		; ioKeyManager::GetCurrentGrowthKey
_TEXT	ENDS
PUBLIC	?GetCurrentQuestKey@ioKeyManager@@QAEGXZ	; ioKeyManager::GetCurrentQuestKey
; Function compile flags: /Ogsp
;	COMDAT ?GetCurrentQuestKey@ioKeyManager@@QAEGXZ
_TEXT	SEGMENT
?GetCurrentQuestKey@ioKeyManager@@QAEGXZ PROC		; ioKeyManager::GetCurrentQuestKey, COMDAT
; _this$ = ecx

; 1820 : 	return GetKey( CKeyInfo::KTA_QUEST );

  00000	6a 3f		 push	 63			; 0000003fH
  00002	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey

; 1821 : }

  00007	c3		 ret	 0
?GetCurrentQuestKey@ioKeyManager@@QAEGXZ ENDP		; ioKeyManager::GetCurrentQuestKey
_TEXT	ENDS
PUBLIC	?GetCurrentPresentKey@ioKeyManager@@QAEGXZ	; ioKeyManager::GetCurrentPresentKey
; Function compile flags: /Ogsp
;	COMDAT ?GetCurrentPresentKey@ioKeyManager@@QAEGXZ
_TEXT	SEGMENT
?GetCurrentPresentKey@ioKeyManager@@QAEGXZ PROC		; ioKeyManager::GetCurrentPresentKey, COMDAT
; _this$ = ecx

; 1825 : 	return GetKey( CKeyInfo::KTA_PRESENT );

  00000	6a 40		 push	 64			; 00000040H
  00002	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey

; 1826 : }

  00007	c3		 ret	 0
?GetCurrentPresentKey@ioKeyManager@@QAEGXZ ENDP		; ioKeyManager::GetCurrentPresentKey
_TEXT	ENDS
PUBLIC	?GetCurrentMyHomePageKey@ioKeyManager@@QAEGXZ	; ioKeyManager::GetCurrentMyHomePageKey
; Function compile flags: /Ogsp
;	COMDAT ?GetCurrentMyHomePageKey@ioKeyManager@@QAEGXZ
_TEXT	SEGMENT
?GetCurrentMyHomePageKey@ioKeyManager@@QAEGXZ PROC	; ioKeyManager::GetCurrentMyHomePageKey, COMDAT
; _this$ = ecx

; 1830 : 	return GetKey( CKeyInfo::KTA_MYHOMEPAGE );

  00000	6a 41		 push	 65			; 00000041H
  00002	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey

; 1831 : }

  00007	c3		 ret	 0
?GetCurrentMyHomePageKey@ioKeyManager@@QAEGXZ ENDP	; ioKeyManager::GetCurrentMyHomePageKey
_TEXT	ENDS
PUBLIC	?GetCurrentOptionKey@ioKeyManager@@QAEGXZ	; ioKeyManager::GetCurrentOptionKey
; Function compile flags: /Ogsp
;	COMDAT ?GetCurrentOptionKey@ioKeyManager@@QAEGXZ
_TEXT	SEGMENT
?GetCurrentOptionKey@ioKeyManager@@QAEGXZ PROC		; ioKeyManager::GetCurrentOptionKey, COMDAT
; _this$ = ecx

; 1835 : 	return GetKey( CKeyInfo::KTA_OPTION );

  00000	6a 1e		 push	 30			; 0000001eH
  00002	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey

; 1836 : }

  00007	c3		 ret	 0
?GetCurrentOptionKey@ioKeyManager@@QAEGXZ ENDP		; ioKeyManager::GetCurrentOptionKey
_TEXT	ENDS
PUBLIC	?GetCurrentMessengerKey@ioKeyManager@@QAEGXZ	; ioKeyManager::GetCurrentMessengerKey
; Function compile flags: /Ogsp
;	COMDAT ?GetCurrentMessengerKey@ioKeyManager@@QAEGXZ
_TEXT	SEGMENT
?GetCurrentMessengerKey@ioKeyManager@@QAEGXZ PROC	; ioKeyManager::GetCurrentMessengerKey, COMDAT
; _this$ = ecx

; 1840 : 	return GetKey( CKeyInfo::KTA_MESSENGER );

  00000	6a 1f		 push	 31			; 0000001fH
  00002	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey

; 1841 : }

  00007	c3		 ret	 0
?GetCurrentMessengerKey@ioKeyManager@@QAEGXZ ENDP	; ioKeyManager::GetCurrentMessengerKey
_TEXT	ENDS
PUBLIC	?GetCurrentScreenShotKey@ioKeyManager@@QAEGXZ	; ioKeyManager::GetCurrentScreenShotKey
; Function compile flags: /Ogsp
;	COMDAT ?GetCurrentScreenShotKey@ioKeyManager@@QAEGXZ
_TEXT	SEGMENT
?GetCurrentScreenShotKey@ioKeyManager@@QAEGXZ PROC	; ioKeyManager::GetCurrentScreenShotKey, COMDAT
; _this$ = ecx

; 1845 : 	return GetKey( CKeyInfo::KTA_SCREENSHOT );

  00000	6a 21		 push	 33			; 00000021H
  00002	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey

; 1846 : }

  00007	c3		 ret	 0
?GetCurrentScreenShotKey@ioKeyManager@@QAEGXZ ENDP	; ioKeyManager::GetCurrentScreenShotKey
_TEXT	ENDS
PUBLIC	?GetCurrentMovieCaptureKey@ioKeyManager@@QAEGXZ	; ioKeyManager::GetCurrentMovieCaptureKey
; Function compile flags: /Ogsp
;	COMDAT ?GetCurrentMovieCaptureKey@ioKeyManager@@QAEGXZ
_TEXT	SEGMENT
?GetCurrentMovieCaptureKey@ioKeyManager@@QAEGXZ PROC	; ioKeyManager::GetCurrentMovieCaptureKey, COMDAT
; _this$ = ecx

; 1850 : 	return GetKey( CKeyInfo::KTA_MOVIECAPTURE );

  00000	6a 22		 push	 34			; 00000022H
  00002	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey

; 1851 : }

  00007	c3		 ret	 0
?GetCurrentMovieCaptureKey@ioKeyManager@@QAEGXZ ENDP	; ioKeyManager::GetCurrentMovieCaptureKey
_TEXT	ENDS
PUBLIC	?GetCurrentPetKey@ioKeyManager@@QAEGXZ		; ioKeyManager::GetCurrentPetKey
; Function compile flags: /Ogsp
;	COMDAT ?GetCurrentPetKey@ioKeyManager@@QAEGXZ
_TEXT	SEGMENT
?GetCurrentPetKey@ioKeyManager@@QAEGXZ PROC		; ioKeyManager::GetCurrentPetKey, COMDAT
; _this$ = ecx

; 1855 : 	return GetKey( CKeyInfo::KTA_PET );

  00000	6a 5e		 push	 94			; 0000005eH
  00002	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey

; 1856 : }

  00007	c3		 ret	 0
?GetCurrentPetKey@ioKeyManager@@QAEGXZ ENDP		; ioKeyManager::GetCurrentPetKey
_TEXT	ENDS
PUBLIC	?GetDefault@ioKeyManager@@QAEXAAVCKeyInfo@@@Z	; ioKeyManager::GetDefault
; Function compile flags: /Ogsp
;	COMDAT ?GetDefault@ioKeyManager@@QAEXAAVCKeyInfo@@@Z
_TEXT	SEGMENT
_rKeyInfo$ = 8						; size = 4
?GetDefault@ioKeyManager@@QAEXAAVCKeyInfo@@@Z PROC	; ioKeyManager::GetDefault, COMDAT
; _this$ = ecx

; 1878 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1879 : 	rKeyInfo = m_DefaultKeyInfo;

  00003	83 c1 04	 add	 ecx, 4
  00006	51		 push	 ecx
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _rKeyInfo$[ebp]
  0000a	e8 00 00 00 00	 call	 ??4CKeyInfo@@QAEAAV0@AAV0@@Z ; CKeyInfo::operator=

; 1880 : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?GetDefault@ioKeyManager@@QAEXAAVCKeyInfo@@@Z ENDP	; ioKeyManager::GetDefault
_TEXT	ENDS
PUBLIC	?GetCustom@ioKeyManager@@QAEXAAVCKeyInfo@@@Z	; ioKeyManager::GetCustom
; Function compile flags: /Ogsp
;	COMDAT ?GetCustom@ioKeyManager@@QAEXAAVCKeyInfo@@@Z
_TEXT	SEGMENT
_rKeyInfo$ = 8						; size = 4
?GetCustom@ioKeyManager@@QAEXAAVCKeyInfo@@@Z PROC	; ioKeyManager::GetCustom, COMDAT
; _this$ = ecx

; 1883 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1884 : 	rKeyInfo = m_CustomKeyInfo;

  00003	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00006	51		 push	 ecx
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _rKeyInfo$[ebp]
  0000a	e8 00 00 00 00	 call	 ??4CKeyInfo@@QAEAAV0@AAV0@@Z ; CKeyInfo::operator=

; 1885 : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?GetCustom@ioKeyManager@@QAEXAAVCKeyInfo@@@Z ENDP	; ioKeyManager::GetCustom
_TEXT	ENDS
PUBLIC	?GetDefaultTextInfo@ioKeyManager@@QAEXAAVCKeyInfo@@@Z ; ioKeyManager::GetDefaultTextInfo
; Function compile flags: /Ogsp
;	COMDAT ?GetDefaultTextInfo@ioKeyManager@@QAEXAAVCKeyInfo@@@Z
_TEXT	SEGMENT
_rKeyInfo$ = 8						; size = 4
?GetDefaultTextInfo@ioKeyManager@@QAEXAAVCKeyInfo@@@Z PROC ; ioKeyManager::GetDefaultTextInfo, COMDAT
; _this$ = ecx

; 1888 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1889 : 	for( int i = 0; i < CKeyInfo::MAX_MACRO; i++)

  00006	6a 33		 push	 51			; 00000033H
  00008	5e		 pop	 esi
  00009	6a 0c		 push	 12			; 0000000cH
  0000b	8d 79 04	 lea	 edi, DWORD PTR [ecx+4]
  0000e	5b		 pop	 ebx
$LL4@GetDefault:

; 1890 : 	{
; 1891 : 		CKeyInfo::KeyTypeArray eType = (CKeyInfo::KeyTypeArray) (i+CKeyInfo::KTA_MACRO1);
; 1892 : 		CKeyInfo::MecroTextInfo *pInfo = m_DefaultKeyInfo.GetMacroTextInfo( eType );

  0000f	56		 push	 esi
  00010	8b cf		 mov	 ecx, edi
  00012	e8 00 00 00 00	 call	 ?GetMacroTextInfo@CKeyInfo@@QAEPAUtagMecroTextInfo@1@W4KeyTypeArray@1@@Z ; CKeyInfo::GetMacroTextInfo

; 1893 : 		if( pInfo )

  00017	85 c0		 test	 eax, eax
  00019	74 0a		 je	 SHORT $LN3@GetDefault

; 1894 : 			rKeyInfo.SetMacroTextInfo( eType,  *pInfo);

  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _rKeyInfo$[ebp]
  0001e	50		 push	 eax
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 ?SetMacroTextInfo@CKeyInfo@@QAE_NW4KeyTypeArray@1@ABUtagMecroTextInfo@1@@Z ; CKeyInfo::SetMacroTextInfo
$LN3@GetDefault:

; 1889 : 	for( int i = 0; i < CKeyInfo::MAX_MACRO; i++)

  00025	46		 inc	 esi
  00026	4b		 dec	 ebx
  00027	75 e6		 jne	 SHORT $LL4@GetDefault
  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx

; 1895 : 	}
; 1896 : }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?GetDefaultTextInfo@ioKeyManager@@QAEXAAVCKeyInfo@@@Z ENDP ; ioKeyManager::GetDefaultTextInfo
_TEXT	ENDS
PUBLIC	?GetCustomTextInfo@ioKeyManager@@QAEXAAVCKeyInfo@@@Z ; ioKeyManager::GetCustomTextInfo
; Function compile flags: /Ogsp
;	COMDAT ?GetCustomTextInfo@ioKeyManager@@QAEXAAVCKeyInfo@@@Z
_TEXT	SEGMENT
_rKeyInfo$ = 8						; size = 4
?GetCustomTextInfo@ioKeyManager@@QAEXAAVCKeyInfo@@@Z PROC ; ioKeyManager::GetCustomTextInfo, COMDAT
; _this$ = ecx

; 1899 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1900 : 	for( int i = 0; i < CKeyInfo::MAX_MACRO; i++)

  00006	6a 33		 push	 51			; 00000033H
  00008	5e		 pop	 esi
  00009	6a 0c		 push	 12			; 0000000cH
  0000b	8d 79 2c	 lea	 edi, DWORD PTR [ecx+44]
  0000e	5b		 pop	 ebx
$LL4@GetCustomT:

; 1901 : 	{
; 1902 : 		CKeyInfo::KeyTypeArray eType = (CKeyInfo::KeyTypeArray) (i+CKeyInfo::KTA_MACRO1);
; 1903 : 		CKeyInfo::MecroTextInfo *pInfo = m_CustomKeyInfo.GetMacroTextInfo( eType );

  0000f	56		 push	 esi
  00010	8b cf		 mov	 ecx, edi
  00012	e8 00 00 00 00	 call	 ?GetMacroTextInfo@CKeyInfo@@QAEPAUtagMecroTextInfo@1@W4KeyTypeArray@1@@Z ; CKeyInfo::GetMacroTextInfo

; 1904 : 		if( pInfo )

  00017	85 c0		 test	 eax, eax
  00019	74 0a		 je	 SHORT $LN3@GetCustomT

; 1905 : 			rKeyInfo.SetMacroTextInfo( eType,  *pInfo);

  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _rKeyInfo$[ebp]
  0001e	50		 push	 eax
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 ?SetMacroTextInfo@CKeyInfo@@QAE_NW4KeyTypeArray@1@ABUtagMecroTextInfo@1@@Z ; CKeyInfo::SetMacroTextInfo
$LN3@GetCustomT:

; 1900 : 	for( int i = 0; i < CKeyInfo::MAX_MACRO; i++)

  00025	46		 inc	 esi
  00026	4b		 dec	 ebx
  00027	75 e6		 jne	 SHORT $LL4@GetCustomT
  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx

; 1906 : 	}
; 1907 : }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?GetCustomTextInfo@ioKeyManager@@QAEXAAVCKeyInfo@@@Z ENDP ; ioKeyManager::GetCustomTextInfo
_TEXT	ENDS
PUBLIC	?GetJoyDefault@ioKeyManager@@QAEXAAVCJoyKeyInfo@@@Z ; ioKeyManager::GetJoyDefault
; Function compile flags: /Ogsp
;	COMDAT ?GetJoyDefault@ioKeyManager@@QAEXAAVCJoyKeyInfo@@@Z
_TEXT	SEGMENT
_rKeyInfo$ = 8						; size = 4
?GetJoyDefault@ioKeyManager@@QAEXAAVCJoyKeyInfo@@@Z PROC ; ioKeyManager::GetJoyDefault, COMDAT
; _this$ = ecx

; 1918 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1919 : 	rKeyInfo = m_DefaultJoyKeyInfo;

  00003	83 c1 54	 add	 ecx, 84			; 00000054H
  00006	51		 push	 ecx
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _rKeyInfo$[ebp]
  0000a	e8 00 00 00 00	 call	 ??4CJoyKeyInfo@@QAEAAV0@AAV0@@Z ; CJoyKeyInfo::operator=

; 1920 : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?GetJoyDefault@ioKeyManager@@QAEXAAVCJoyKeyInfo@@@Z ENDP ; ioKeyManager::GetJoyDefault
_TEXT	ENDS
PUBLIC	?GetJoyCustom@ioKeyManager@@QAEXAAVCJoyKeyInfo@@@Z ; ioKeyManager::GetJoyCustom
; Function compile flags: /Ogsp
;	COMDAT ?GetJoyCustom@ioKeyManager@@QAEXAAVCJoyKeyInfo@@@Z
_TEXT	SEGMENT
_rKeyInfo$ = 8						; size = 4
?GetJoyCustom@ioKeyManager@@QAEXAAVCJoyKeyInfo@@@Z PROC	; ioKeyManager::GetJoyCustom, COMDAT
; _this$ = ecx

; 1923 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1924 : 	rKeyInfo = m_CustomJoyKeyInfo;

  00003	83 c1 6c	 add	 ecx, 108		; 0000006cH
  00006	51		 push	 ecx
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _rKeyInfo$[ebp]
  0000a	e8 00 00 00 00	 call	 ??4CJoyKeyInfo@@QAEAAV0@AAV0@@Z ; CJoyKeyInfo::operator=

; 1925 : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?GetJoyCustom@ioKeyManager@@QAEXAAVCJoyKeyInfo@@@Z ENDP	; ioKeyManager::GetJoyCustom
_TEXT	ENDS
PUBLIC	?SetCustomKey@ioKeyManager@@QAE_NAAVCKeyInfo@@@Z ; ioKeyManager::SetCustomKey
; Function compile flags: /Ogsp
;	COMDAT ?SetCustomKey@ioKeyManager@@QAE_NAAVCKeyInfo@@@Z
_TEXT	SEGMENT
_rKeyInfo$ = 8						; size = 4
?SetCustomKey@ioKeyManager@@QAE_NAAVCKeyInfo@@@Z PROC	; ioKeyManager::SetCustomKey, COMDAT
; _this$ = ecx

; 1928 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f1		 mov	 esi, ecx

; 1929 : 	for (int i = 0; i < CKeyInfo::KTA_MAX ; i++)

  00007	33 ff		 xor	 edi, edi
$LL6@SetCustomK@2:

; 1930 : 	{
; 1931 : 		CKeyInfo::KeyTypeArray eType = (CKeyInfo::KeyTypeArray)i;
; 1932 : 		SetCustomKey( eType, rKeyInfo.GetKey( eType ) );

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _rKeyInfo$[ebp]
  0000c	57		 push	 edi
  0000d	e8 00 00 00 00	 call	 ?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CKeyInfo::GetKey
  00012	0f b7 c0	 movzx	 eax, ax
  00015	50		 push	 eax
  00016	57		 push	 edi
  00017	8b ce		 mov	 ecx, esi
  00019	e8 00 00 00 00	 call	 ?SetCustomKey@ioKeyManager@@QAEXW4KeyTypeArray@CKeyInfo@@G@Z ; ioKeyManager::SetCustomKey
  0001e	47		 inc	 edi
  0001f	83 ff 5f	 cmp	 edi, 95			; 0000005fH
  00022	7c e5		 jl	 SHORT $LL6@SetCustomK@2

; 1933 : 	}
; 1934 : 
; 1935 : 	if(m_bSaveKey)

  00024	8a 86 95 00 00
	00		 mov	 al, BYTE PTR [esi+149]
  0002a	84 c0		 test	 al, al
  0002c	74 0d		 je	 SHORT $LN2@SetCustomK@2

; 1936 : 	{
; 1937 : 		if( m_CustomKeyInfo.IsUseKeys() )

  0002e	80 7e 50 00	 cmp	 BYTE PTR [esi+80], 0
  00032	0f 95 c1	 setne	 cl
  00035	88 8e 94 00 00
	00		 mov	 BYTE PTR [esi+148], cl
$LN2@SetCustomK@2:
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi

; 1938 : 			m_bUseCustom = true;
; 1939 : 		else
; 1940 : 			m_bUseCustom = false;
; 1941 : 	}
; 1942 : 
; 1943 : 	return m_bSaveKey;
; 1944 : }

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
?SetCustomKey@ioKeyManager@@QAE_NAAVCKeyInfo@@@Z ENDP	; ioKeyManager::SetCustomKey
_TEXT	ENDS
PUBLIC	?SetCustomJoyKey@ioKeyManager@@QAE_NAAVCJoyKeyInfo@@@Z ; ioKeyManager::SetCustomJoyKey
; Function compile flags: /Ogsp
;	COMDAT ?SetCustomJoyKey@ioKeyManager@@QAE_NAAVCJoyKeyInfo@@@Z
_TEXT	SEGMENT
_rKeyInfo$ = 8						; size = 4
?SetCustomJoyKey@ioKeyManager@@QAE_NAAVCJoyKeyInfo@@@Z PROC ; ioKeyManager::SetCustomJoyKey, COMDAT
; _this$ = ecx

; 1947 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f1		 mov	 esi, ecx

; 1948 : 	for (int i = 0; i < CJoyKeyInfo::JTA_MAX ; i++)

  00007	33 ff		 xor	 edi, edi
$LL6@SetCustomJ@2:

; 1949 : 	{
; 1950 : 		CJoyKeyInfo::KeyTypeArray eType = (CJoyKeyInfo::KeyTypeArray)i;
; 1951 : 		SetCustomJoyKey( eType, rKeyInfo.GetKey( eType ) );

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _rKeyInfo$[ebp]
  0000c	57		 push	 edi
  0000d	e8 00 00 00 00	 call	 ?GetKey@CJoyKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CJoyKeyInfo::GetKey
  00012	0f b7 c0	 movzx	 eax, ax
  00015	50		 push	 eax
  00016	57		 push	 edi
  00017	8b ce		 mov	 ecx, esi
  00019	e8 00 00 00 00	 call	 ?SetCustomJoyKey@ioKeyManager@@QAEXW4KeyTypeArray@CJoyKeyInfo@@G@Z ; ioKeyManager::SetCustomJoyKey
  0001e	47		 inc	 edi
  0001f	83 ff 2f	 cmp	 edi, 47			; 0000002fH
  00022	7c e5		 jl	 SHORT $LL6@SetCustomJ@2

; 1952 : 	}
; 1953 : 
; 1954 : 	if(m_bSaveJoyKey)

  00024	8a 86 97 00 00
	00		 mov	 al, BYTE PTR [esi+151]
  0002a	84 c0		 test	 al, al
  0002c	74 10		 je	 SHORT $LN2@SetCustomJ@2

; 1955 : 	{
; 1956 : 		if( m_CustomJoyKeyInfo.IsUseKeys() )

  0002e	80 be 80 00 00
	00 00		 cmp	 BYTE PTR [esi+128], 0
  00035	0f 95 c1	 setne	 cl
  00038	88 8e 96 00 00
	00		 mov	 BYTE PTR [esi+150], cl
$LN2@SetCustomJ@2:
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi

; 1957 : 			m_bUseJoyCustom = true;
; 1958 : 		else
; 1959 : 			m_bUseJoyCustom = false;
; 1960 : 	}
; 1961 : 
; 1962 : 	return m_bSaveJoyKey;
; 1963 : }

  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
?SetCustomJoyKey@ioKeyManager@@QAE_NAAVCJoyKeyInfo@@@Z ENDP ; ioKeyManager::SetCustomJoyKey
_TEXT	ENDS
PUBLIC	?SetCustomMacroTextInfo@ioKeyManager@@QAE_NAAVCKeyInfo@@@Z ; ioKeyManager::SetCustomMacroTextInfo
; Function compile flags: /Ogsp
;	COMDAT ?SetCustomMacroTextInfo@ioKeyManager@@QAE_NAAVCKeyInfo@@@Z
_TEXT	SEGMENT
_rKeyInfo$ = 8						; size = 4
?SetCustomMacroTextInfo@ioKeyManager@@QAE_NAAVCKeyInfo@@@Z PROC ; ioKeyManager::SetCustomMacroTextInfo, COMDAT
; _this$ = ecx

; 1966 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1967 : 	for( int i = 0; i < CKeyInfo::MAX_MACRO; i++)

  00006	6a 33		 push	 51			; 00000033H
  00008	5e		 pop	 esi
  00009	6a 0c		 push	 12			; 0000000cH
  0000b	8b f9		 mov	 edi, ecx
  0000d	5b		 pop	 ebx
$LL4@SetCustomM@2:

; 1968 : 	{
; 1969 : 		CKeyInfo::KeyTypeArray eType = (CKeyInfo::KeyTypeArray) (i+CKeyInfo::KTA_MACRO1);
; 1970 : 		CKeyInfo::MecroTextInfo *pInfo = rKeyInfo.GetMacroTextInfo( eType );

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _rKeyInfo$[ebp]
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ?GetMacroTextInfo@CKeyInfo@@QAEPAUtagMecroTextInfo@1@W4KeyTypeArray@1@@Z ; CKeyInfo::GetMacroTextInfo

; 1971 : 		if( pInfo )

  00017	85 c0		 test	 eax, eax
  00019	74 09		 je	 SHORT $LN3@SetCustomM@2

; 1972 : 			SetCustomMacroTextInfo( eType,  *pInfo);

  0001b	50		 push	 eax
  0001c	56		 push	 esi
  0001d	8b cf		 mov	 ecx, edi
  0001f	e8 00 00 00 00	 call	 ?SetCustomMacroTextInfo@ioKeyManager@@QAEXW4KeyTypeArray@CKeyInfo@@ABUtagMecroTextInfo@3@@Z ; ioKeyManager::SetCustomMacroTextInfo
$LN3@SetCustomM@2:

; 1967 : 	for( int i = 0; i < CKeyInfo::MAX_MACRO; i++)

  00024	46		 inc	 esi
  00025	4b		 dec	 ebx
  00026	75 e6		 jne	 SHORT $LL4@SetCustomM@2

; 1973 : 	}
; 1974 : 
; 1975 : 	return m_bSaveMacroText;

  00028	8a 87 98 00 00
	00		 mov	 al, BYTE PTR [edi+152]
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx

; 1976 : }

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?SetCustomMacroTextInfo@ioKeyManager@@QAE_NAAVCKeyInfo@@@Z ENDP ; ioKeyManager::SetCustomMacroTextInfo
_TEXT	ENDS
PUBLIC	?IsAutoFix@ioKeyManager@@QAE_NXZ		; ioKeyManager::IsAutoFix
; Function compile flags: /Ogsp
;	COMDAT ?IsAutoFix@ioKeyManager@@QAE_NXZ
_TEXT	SEGMENT
?IsAutoFix@ioKeyManager@@QAE_NXZ PROC			; ioKeyManager::IsAutoFix, COMDAT
; _this$ = ecx

; 2002 : 	return m_CustomKeyInfo.IsAutoFix();

  00000	8a 41 51	 mov	 al, BYTE PTR [ecx+81]

; 2003 : }

  00003	c3		 ret	 0
?IsAutoFix@ioKeyManager@@QAE_NXZ ENDP			; ioKeyManager::IsAutoFix
_TEXT	ENDS
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::operator!=
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::operator!=, COMDAT
; _this$ = ecx

; 334  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 335  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 336  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::operator!=
_TEXT	ENDS
PUBLIC	?max_size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::max_size
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?max_size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::max_size
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@GV?$allocator@G@std@@@std@@QAE@V?$allocator@G@1@@Z ; std::_Vector_val<unsigned short,std::allocator<unsigned short> >::_Vector_val<unsigned short,std::allocator<unsigned short> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Vector_val@GV?$allocator@G@std@@@std@@QAE@V?$allocator@G@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@GV?$allocator@G@std@@@std@@QAE@V?$allocator@G@1@@Z PROC ; std::_Vector_val<unsigned short,std::allocator<unsigned short> >::_Vector_val<unsigned short,std::allocator<unsigned short> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@GV?$allocator@G@std@@@std@@QAE@V?$allocator@G@1@@Z ENDP ; std::_Vector_val<unsigned short,std::allocator<unsigned short> >::_Vector_val<unsigned short,std::allocator<unsigned short> >
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@G@std@@QAEPAGI@Z		; std::allocator<unsigned short>::allocate
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@G@std@@QAEPAGI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@G@std@@QAEPAGI@Z PROC		; std::allocator<unsigned short>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	6a 00		 push	 0
  00005	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Allocate@G@std@@YAPAGIPAG@Z ; std::_Allocate<unsigned short>
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx

; 188  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?allocate@?$allocator@G@std@@QAEPAGI@Z ENDP		; std::allocator<unsigned short>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QBEIXZ ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::max_size
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?max_size@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (this->_Alval.max_size());

  00000	b8 cc cc cc 0c	 mov	 eax, 214748364		; 0cccccccH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::max_size
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@1@@Z ; std::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@1@@Z PROC ; std::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@1@@Z ENDP ; std::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEPAUtagMecroTextInfo@CKeyInfo@@I@Z ; std::allocator<CKeyInfo::tagMecroTextInfo>::allocate
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEPAUtagMecroTextInfo@CKeyInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEPAUtagMecroTextInfo@CKeyInfo@@I@Z PROC ; std::allocator<CKeyInfo::tagMecroTextInfo>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	6a 00		 push	 0
  00005	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Allocate@UtagMecroTextInfo@CKeyInfo@@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@IPAU12@@Z ; std::_Allocate<CKeyInfo::tagMecroTextInfo>
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx

; 188  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?allocate@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEPAUtagMecroTextInfo@CKeyInfo@@I@Z ENDP ; std::allocator<CKeyInfo::tagMecroTextInfo>::allocate
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Lmost
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1759 : 		return (this->_Left(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1760 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Rmost
; Function compile flags: /Ogsp
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1784 : 		return (this->_Right(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 08	 add	 eax, 8

; 1785 : 		}

  00006	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Root
; Function compile flags: /Ogsp
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1789 : 		return (this->_Parent(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 04	 add	 eax, 4

; 1790 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Root
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >, COMDAT
; _this$ = ecx

; 555  : 		this->_Alnod.deallocate(this->_Myhead, 1);

  00000	ff 71 04	 push	 DWORD PTR [ecx+4]
  00003	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00008	59		 pop	 ecx

; 556  : 		}

  00009	c3		 ret	 0
??1?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAAAGPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Key
; Function compile flags: /Ogsp
;	COMDAT ?_Key@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAAAGPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAAAGPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Key, COMDAT

; 616  : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 617  : 		return ((key_type&)_Traits::_Kfn(_Myval(_Pnode)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 618  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Key@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@SAAAGPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Key
_TEXT	ENDS
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBGVioHashString@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::operator*
; Function compile flags: /Ogsp
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBGVioHashString@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBGVioHashString@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 396  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 397  : 		}

  00005	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBGVioHashString@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::operator*
_TEXT	ENDS
PUBLIC	?_Grow_to@?$vector@GV?$allocator@G@std@@@std@@IBEII@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Grow_to
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@GV?$allocator@G@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@GV?$allocator@G@std@@@std@@IBEII@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1275 : 		size_type _Capacity = capacity();

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00008	ba ff ff ff 7f	 mov	 edx, 2147483647		; 7fffffffH
  0000d	d1 f8		 sar	 eax, 1
  0000f	8b c8		 mov	 ecx, eax
  00011	d1 e9		 shr	 ecx, 1
  00013	2b d1		 sub	 edx, ecx
  00015	3b d0		 cmp	 edx, eax
  00017	73 04		 jae	 SHORT $LN4@Grow_to
  00019	33 c0		 xor	 eax, eax
  0001b	eb 02		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  0001d	03 c1		 add	 eax, ecx
$LN5@Grow_to:

; 1279 : 		if (_Capacity < _Count)

  0001f	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]

; 1280 : 			_Capacity = _Count;

  00022	0f 42 45 08	 cmovb	 eax, DWORD PTR __Count$[ebp]

; 1281 : 		return (_Capacity);
; 1282 : 		}

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?_Grow_to@?$vector@GV?$allocator@G@std@@@std@@IBEII@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Grow_to
_TEXT	ENDS
PUBLIC	?_Grow_to@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IBEII@Z ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Grow_to
; Function compile flags: /Ogsp
;	COMDAT ?_Grow_to@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IBEII@Z PROC ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1275 : 		size_type _Capacity = capacity();

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	6a 14		 push	 20			; 00000014H
  0000a	99		 cdq
  0000b	59		 pop	 ecx
  0000c	f7 f9		 idiv	 ecx

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0000e	ba cc cc cc 0c	 mov	 edx, 214748364		; 0cccccccH
  00013	8b c8		 mov	 ecx, eax
  00015	d1 e9		 shr	 ecx, 1
  00017	2b d1		 sub	 edx, ecx
  00019	3b d0		 cmp	 edx, eax
  0001b	73 04		 jae	 SHORT $LN4@Grow_to@2
  0001d	33 c0		 xor	 eax, eax
  0001f	eb 02		 jmp	 SHORT $LN5@Grow_to@2
$LN4@Grow_to@2:
  00021	03 c1		 add	 eax, ecx
$LN5@Grow_to@2:

; 1279 : 		if (_Capacity < _Count)

  00023	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]

; 1280 : 			_Capacity = _Count;

  00026	0f 42 45 08	 cmovb	 eax, DWORD PTR __Count$[ebp]

; 1281 : 		return (_Capacity);
; 1282 : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?_Grow_to@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IBEII@Z ENDP ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Grow_to
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@ABG@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Lbound
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@ABG@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@ABG@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1741 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1742 : 		_Nodeptr _Pnode = _Root();

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00009	80 79 21 00	 cmp	 BYTE PTR [ecx+33], 0
  0000d	75 1b		 jne	 SHORT $LN3@Lbound
  0000f	8b 55 08	 mov	 edx, DWORD PTR __Keyval$[ebp]
  00012	0f b7 12	 movzx	 edx, WORD PTR [edx]
$LL4@Lbound:

; 1746 : 			if (_DEBUG_LT_PRED(this->comp, this->_Key(_Pnode), _Keyval))

  00015	66 39 51 0c	 cmp	 WORD PTR [ecx+12], dx
  00019	73 05		 jae	 SHORT $LN2@Lbound

; 1747 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  0001b	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 1748 : 			else

  0001e	eb 04		 jmp	 SHORT $LN1@Lbound
$LN2@Lbound:

; 1749 : 				{	// _Pnode not less than _Keyval, remember it
; 1750 : 				_Wherenode = _Pnode;

  00020	8b c1		 mov	 eax, ecx

; 1751 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  00022	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN1@Lbound:

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00024	80 79 21 00	 cmp	 BYTE PTR [ecx+33], 0
  00028	74 eb		 je	 SHORT $LL4@Lbound
$LN3@Lbound:

; 1752 : 				}
; 1753 : 
; 1754 : 		return (_Wherenode);	// return best remembered candidate
; 1755 : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@ABG@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >, COMDAT
; _this$ = ecx

; 213  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 214  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@std@@QAE@PAGPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<unsigned short,std::allocator<unsigned short> > >::_Vector_iterator<std::_Vector_val<unsigned short,std::allocator<unsigned short> > >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@std@@QAE@PAGPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@std@@QAE@PAGPBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<unsigned short,std::allocator<unsigned short> > >::_Vector_iterator<std::_Vector_val<unsigned short,std::allocator<unsigned short> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 305  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@std@@QAE@PAGPBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<unsigned short,std::allocator<unsigned short> > >::_Vector_iterator<std::_Vector_val<unsigned short,std::allocator<unsigned short> > >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@std@@QAE@PAUtagMecroTextInfo@CKeyInfo@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> > >::_Vector_iterator<std::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> > >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@std@@QAE@PAUtagMecroTextInfo@CKeyInfo@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@std@@QAE@PAUtagMecroTextInfo@CKeyInfo@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> > >::_Vector_iterator<std::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 305  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@std@@QAE@PAUtagMecroTextInfo@CKeyInfo@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> > >::_Vector_iterator<std::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> > >
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@G@1@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@G@1@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@G@1@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >, COMDAT
; _this$ = ecx

; 482  : 		{	// construct traits from _Parg and allocators from _Al

  00000	8b c1		 mov	 eax, ecx

; 483  : 		}

  00002	c2 08 00	 ret	 8
??0?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@G@1@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Node>::allocate
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	6a 00		 push	 0
  00005	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Node>
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx

; 188  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<unsigned short,std::allocator<unsigned short> > >::operator==
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<unsigned short,std::allocator<unsigned short> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	f7 d8		 neg	 eax
  0000c	1b c0		 sbb	 eax, eax
  0000e	40		 inc	 eax

; 204  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<unsigned short,std::allocator<unsigned short> > >::operator==
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> > >::operator==
; Function compile flags: /Ogsp
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	f7 d8		 neg	 eax
  0000c	1b c0		 sbb	 eax, eax
  0000e	40		 inc	 eax

; 204  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> > >::operator==
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Lrotate
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1763 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1764 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00009	56		 push	 esi

; 1765 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0000a	8b 30		 mov	 esi, DWORD PTR [eax]
  0000c	89 72 08	 mov	 DWORD PTR [edx+8], esi

; 1766 : 
; 1767 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  0000f	8b 30		 mov	 esi, DWORD PTR [eax]
  00011	80 7e 21 00	 cmp	 BYTE PTR [esi+33], 0
  00015	75 03		 jne	 SHORT $LN5@Lrotate

; 1768 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN5@Lrotate:

; 1769 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1770 : 
; 1771 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	5e		 pop	 esi
  00024	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00027	75 05		 jne	 SHORT $LN4@Lrotate

; 1772 : 			_Root() = _Pnode;

  00029	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1773 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  0002c	eb 0e		 jmp	 SHORT $LN1@Lrotate
$LN4@Lrotate:
  0002e	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00031	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00033	75 04		 jne	 SHORT $LN2@Lrotate

; 1774 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  00035	89 01		 mov	 DWORD PTR [ecx], eax

; 1775 : 		else

  00037	eb 03		 jmp	 SHORT $LN1@Lrotate
$LN2@Lrotate:

; 1776 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00039	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN1@Lrotate:

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0003c	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0003e	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Rrotate
; Function compile flags: /Ogsp
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1793 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1794 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	56		 push	 esi

; 1795 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  00009	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0000c	89 32		 mov	 DWORD PTR [edx], esi

; 1796 : 
; 1797 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  0000e	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00011	80 7e 21 00	 cmp	 BYTE PTR [esi+33], 0
  00015	75 03		 jne	 SHORT $LN5@Rrotate

; 1798 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN5@Rrotate:

; 1799 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1800 : 
; 1801 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	5e		 pop	 esi
  00024	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00027	75 05		 jne	 SHORT $LN4@Rrotate

; 1802 : 			_Root() = _Pnode;

  00029	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1803 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  0002c	eb 0f		 jmp	 SHORT $LN1@Rrotate
$LN4@Rrotate:
  0002e	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00031	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00034	75 05		 jne	 SHORT $LN2@Rrotate

; 1804 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00036	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1805 : 		else

  00039	eb 02		 jmp	 SHORT $LN1@Rrotate
$LN2@Rrotate:

; 1806 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0003b	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@Rrotate:

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  0003d	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  00040	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::operator++
; Function compile flags: /Ogsp
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 250  : 		{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 251  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 252  : 		if (this->_Getcont() == 0
; 253  : 			|| this->_Ptr == 0
; 254  : 			|| _Mytree::_Isnil(this->_Ptr))
; 255  : 			{	// report error
; 256  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 257  : 			_SCL_SECURE_OUT_OF_RANGE;
; 258  : 			}
; 259  : 
; 260  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 261  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 262  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 263  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 264  : 
; 265  : 		++(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >,std::_Iterator_base0>::operator++

; 266  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 267  : 		}

  0000b	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::operator++
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$SetTitle_e@$09@ioINILoader@@QAEXAAY09$$CBD@Z	; ioINILoader::SetTitle_e<10>
EXTRN	__imp_?SetTitle@ioINILoader@@QAEXPBD@Z:PROC
EXTRN	___security_cookie:DWORD
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\io3dengine\ioiniloader.h
;	COMDAT ??$SetTitle_e@$09@ioINILoader@@QAEXAAY09$$CBD@Z
_TEXT	SEGMENT
__t$ = -20						; size = 10
__$ArrayPad$ = -4					; size = 4
_t$ = 8							; size = 4
??$SetTitle_e@$09@ioINILoader@@QAEXAAY09$$CBD@Z PROC	; ioINILoader::SetTitle_e<10>, COMDAT
; _this$ = ecx

; 188  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]

; 189  : 		_ENCSTR(t, _t);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	84 d2		 test	 dl, dl
  00017	0f 84 0d 01 00
	00		 je	 $LN96@SetTitle_e
  0001d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00020	88 55 ec	 mov	 BYTE PTR __t$[ebp], dl
  00023	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00026	84 d2		 test	 dl, dl
  00028	0f 84 f6 00 00
	00		 je	 $LN95@SetTitle_e
  0002e	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00031	88 55 ed	 mov	 BYTE PTR __t$[ebp+1], dl
  00034	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  00037	84 d2		 test	 dl, dl
  00039	0f 84 df 00 00
	00		 je	 $LN94@SetTitle_e
  0003f	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00042	88 55 ee	 mov	 BYTE PTR __t$[ebp+2], dl
  00045	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  00048	84 d2		 test	 dl, dl
  0004a	0f 84 c8 00 00
	00		 je	 $LN93@SetTitle_e
  00050	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00053	88 55 ef	 mov	 BYTE PTR __t$[ebp+3], dl
  00056	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  00059	84 d2		 test	 dl, dl
  0005b	0f 84 b1 00 00
	00		 je	 $LN92@SetTitle_e
  00061	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00064	88 55 f0	 mov	 BYTE PTR __t$[ebp+4], dl
  00067	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006a	84 d2		 test	 dl, dl
  0006c	0f 84 9a 00 00
	00		 je	 $LN91@SetTitle_e
  00072	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00075	88 55 f1	 mov	 BYTE PTR __t$[ebp+5], dl
  00078	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0007b	84 d2		 test	 dl, dl
  0007d	0f 84 83 00 00
	00		 je	 $LN90@SetTitle_e
  00083	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00086	88 55 f2	 mov	 BYTE PTR __t$[ebp+6], dl
  00089	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0008c	84 d2		 test	 dl, dl
  0008e	74 70		 je	 SHORT $LN89@SetTitle_e
  00090	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00093	88 55 f3	 mov	 BYTE PTR __t$[ebp+7], dl
  00096	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  00099	84 d2		 test	 dl, dl
  0009b	74 5d		 je	 SHORT $LN88@SetTitle_e
  0009d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000a0	80 78 09 00	 cmp	 BYTE PTR [eax+9], 0
  000a4	88 55 f4	 mov	 BYTE PTR __t$[ebp+8], dl
  000a7	0f 84 81 00 00
	00		 je	 $LN1@SetTitle_e
  000ad	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000b0	84 d2		 test	 dl, dl
  000b2	74 40		 je	 SHORT $LN86@SetTitle_e
  000b4	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000b7	88 55 f6	 mov	 BYTE PTR __t$[ebp+10], dl
  000ba	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000bd	84 d2		 test	 dl, dl
  000bf	74 2d		 je	 SHORT $LN85@SetTitle_e
  000c1	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000c4	88 55 f7	 mov	 BYTE PTR __t$[ebp+11], dl
  000c7	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000ca	84 d2		 test	 dl, dl
  000cc	74 1a		 je	 SHORT $LN84@SetTitle_e
  000ce	8a 40 0d	 mov	 al, BYTE PTR [eax+13]
  000d1	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000d4	88 55 f8	 mov	 BYTE PTR __t$[ebp+12], dl
  000d7	84 c0		 test	 al, al
  000d9	74 07		 je	 SHORT $LN83@SetTitle_e
  000db	34 ec		 xor	 al, -20			; ffffffecH
  000dd	88 45 f9	 mov	 BYTE PTR __t$[ebp+13], al
  000e0	eb 4c		 jmp	 SHORT $LN1@SetTitle_e
$LN83@SetTitle_e:
  000e2	c6 45 f9 ec	 mov	 BYTE PTR __t$[ebp+13], -20 ; ffffffecH
  000e6	eb 46		 jmp	 SHORT $LN1@SetTitle_e
$LN84@SetTitle_e:
  000e8	c6 45 f8 ed	 mov	 BYTE PTR __t$[ebp+12], -19 ; ffffffedH
  000ec	eb 40		 jmp	 SHORT $LN1@SetTitle_e
$LN85@SetTitle_e:
  000ee	c6 45 f7 ea	 mov	 BYTE PTR __t$[ebp+11], -22 ; ffffffeaH
  000f2	eb 3a		 jmp	 SHORT $LN1@SetTitle_e
$LN86@SetTitle_e:
  000f4	c6 45 f6 eb	 mov	 BYTE PTR __t$[ebp+10], -21 ; ffffffebH
  000f8	eb 34		 jmp	 SHORT $LN1@SetTitle_e
$LN88@SetTitle_e:
  000fa	c6 45 f4 ed	 mov	 BYTE PTR __t$[ebp+8], -19 ; ffffffedH
  000fe	eb 2e		 jmp	 SHORT $LN1@SetTitle_e
$LN89@SetTitle_e:
  00100	c6 45 f3 ea	 mov	 BYTE PTR __t$[ebp+7], -22 ; ffffffeaH
  00104	eb 28		 jmp	 SHORT $LN1@SetTitle_e
$LN90@SetTitle_e:
  00106	c6 45 f2 eb	 mov	 BYTE PTR __t$[ebp+6], -21 ; ffffffebH
  0010a	eb 22		 jmp	 SHORT $LN1@SetTitle_e
$LN91@SetTitle_e:
  0010c	c6 45 f1 ec	 mov	 BYTE PTR __t$[ebp+5], -20 ; ffffffecH
  00110	eb 1c		 jmp	 SHORT $LN1@SetTitle_e
$LN92@SetTitle_e:
  00112	c6 45 f0 ed	 mov	 BYTE PTR __t$[ebp+4], -19 ; ffffffedH
  00116	eb 16		 jmp	 SHORT $LN1@SetTitle_e
$LN93@SetTitle_e:
  00118	c6 45 ef ea	 mov	 BYTE PTR __t$[ebp+3], -22 ; ffffffeaH
  0011c	eb 10		 jmp	 SHORT $LN1@SetTitle_e
$LN94@SetTitle_e:
  0011e	c6 45 ee eb	 mov	 BYTE PTR __t$[ebp+2], -21 ; ffffffebH
  00122	eb 0a		 jmp	 SHORT $LN1@SetTitle_e
$LN95@SetTitle_e:
  00124	c6 45 ed ec	 mov	 BYTE PTR __t$[ebp+1], -20 ; ffffffecH
  00128	eb 04		 jmp	 SHORT $LN1@SetTitle_e
$LN96@SetTitle_e:
  0012a	c6 45 ec ed	 mov	 BYTE PTR __t$[ebp], -19	; ffffffedH
$LN1@SetTitle_e:
  0012e	6a 02		 push	 2
  00130	8d 45 ec	 lea	 eax, DWORD PTR __t$[ebp]
  00133	c6 45 f5 00	 mov	 BYTE PTR __t$[ebp+9], 0
  00137	5a		 pop	 edx
$LL104@SetTitle_e:
  00138	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0013e	83 c0 04	 add	 eax, 4
  00141	4a		 dec	 edx
  00142	75 f4		 jne	 SHORT $LL104@SetTitle_e
  00144	80 75 f4 ed	 xor	 BYTE PTR __t$[ebp+8], -19 ; ffffffedH

; 190  : 		SetTitle(_t);

  00148	8d 45 ec	 lea	 eax, DWORD PTR __t$[ebp]
  0014b	50		 push	 eax
  0014c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z

; 191  : 	}

  00152	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00155	33 cd		 xor	 ecx, ebp
  00157	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015c	c9		 leave
  0015d	c2 04 00	 ret	 4
??$SetTitle_e@$09@ioINILoader@@QAEXAAY09$$CBD@Z ENDP	; ioINILoader::SetTitle_e<10>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$SetTitle_e@$06@ioINILoader@@QAEXAAY06$$CBD@Z	; ioINILoader::SetTitle_e<7>
; Function compile flags: /Ogsp
;	COMDAT ??$SetTitle_e@$06@ioINILoader@@QAEXAAY06$$CBD@Z
_TEXT	SEGMENT
__t$ = -16						; size = 7
__$ArrayPad$ = -4					; size = 4
_t$ = 8							; size = 4
??$SetTitle_e@$06@ioINILoader@@QAEXAAY06$$CBD@Z PROC	; ioINILoader::SetTitle_e<7>, COMDAT
; _this$ = ecx

; 188  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]

; 189  : 		_ENCSTR(t, _t);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	84 d2		 test	 dl, dl
  0001a	0f 84 c0 00 00
	00		 je	 $LN96@SetTitle_e@2
  00020	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00023	88 55 f0	 mov	 BYTE PTR __t$[ebp], dl
  00026	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00029	84 d2		 test	 dl, dl
  0002b	0f 84 a9 00 00
	00		 je	 $LN95@SetTitle_e@2
  00031	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00034	88 55 f1	 mov	 BYTE PTR __t$[ebp+1], dl
  00037	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003a	84 d2		 test	 dl, dl
  0003c	0f 84 92 00 00
	00		 je	 $LN94@SetTitle_e@2
  00042	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00045	88 55 f2	 mov	 BYTE PTR __t$[ebp+2], dl
  00048	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004b	84 d2		 test	 dl, dl
  0004d	74 7f		 je	 SHORT $LN93@SetTitle_e@2
  0004f	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00052	88 55 f3	 mov	 BYTE PTR __t$[ebp+3], dl
  00055	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  00058	84 d2		 test	 dl, dl
  0005a	74 6c		 je	 SHORT $LN92@SetTitle_e@2
  0005c	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0005f	88 55 f4	 mov	 BYTE PTR __t$[ebp+4], dl
  00062	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00065	84 d2		 test	 dl, dl
  00067	74 59		 je	 SHORT $LN91@SetTitle_e@2
  00069	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0006c	80 78 06 00	 cmp	 BYTE PTR [eax+6], 0
  00070	88 55 f5	 mov	 BYTE PTR __t$[ebp+5], dl
  00073	74 6f		 je	 SHORT $LN1@SetTitle_e@2
  00075	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00078	84 d2		 test	 dl, dl
  0007a	74 40		 je	 SHORT $LN89@SetTitle_e@2
  0007c	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0007f	88 55 f7	 mov	 BYTE PTR __t$[ebp+7], dl
  00082	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  00085	84 d2		 test	 dl, dl
  00087	74 2d		 je	 SHORT $LN88@SetTitle_e@2
  00089	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0008c	88 55 f8	 mov	 BYTE PTR __t$[ebp+8], dl
  0008f	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  00092	84 d2		 test	 dl, dl
  00094	74 1a		 je	 SHORT $LN87@SetTitle_e@2
  00096	8a 40 0a	 mov	 al, BYTE PTR [eax+10]
  00099	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0009c	88 55 f9	 mov	 BYTE PTR __t$[ebp+9], dl
  0009f	84 c0		 test	 al, al
  000a1	74 07		 je	 SHORT $LN86@SetTitle_e@2
  000a3	34 eb		 xor	 al, -21			; ffffffebH
  000a5	88 45 fa	 mov	 BYTE PTR __t$[ebp+10], al
  000a8	eb 3a		 jmp	 SHORT $LN1@SetTitle_e@2
$LN86@SetTitle_e@2:
  000aa	c6 45 fa eb	 mov	 BYTE PTR __t$[ebp+10], -21 ; ffffffebH
  000ae	eb 34		 jmp	 SHORT $LN1@SetTitle_e@2
$LN87@SetTitle_e@2:
  000b0	c6 45 f9 ec	 mov	 BYTE PTR __t$[ebp+9], -20 ; ffffffecH
  000b4	eb 2e		 jmp	 SHORT $LN1@SetTitle_e@2
$LN88@SetTitle_e@2:
  000b6	c6 45 f8 ed	 mov	 BYTE PTR __t$[ebp+8], -19 ; ffffffedH
  000ba	eb 28		 jmp	 SHORT $LN1@SetTitle_e@2
$LN89@SetTitle_e@2:
  000bc	c6 45 f7 ea	 mov	 BYTE PTR __t$[ebp+7], -22 ; ffffffeaH
  000c0	eb 22		 jmp	 SHORT $LN1@SetTitle_e@2
$LN91@SetTitle_e@2:
  000c2	c6 45 f5 ec	 mov	 BYTE PTR __t$[ebp+5], -20 ; ffffffecH
  000c6	eb 1c		 jmp	 SHORT $LN1@SetTitle_e@2
$LN92@SetTitle_e@2:
  000c8	c6 45 f4 ed	 mov	 BYTE PTR __t$[ebp+4], -19 ; ffffffedH
  000cc	eb 16		 jmp	 SHORT $LN1@SetTitle_e@2
$LN93@SetTitle_e@2:
  000ce	c6 45 f3 ea	 mov	 BYTE PTR __t$[ebp+3], -22 ; ffffffeaH
  000d2	eb 10		 jmp	 SHORT $LN1@SetTitle_e@2
$LN94@SetTitle_e@2:
  000d4	c6 45 f2 eb	 mov	 BYTE PTR __t$[ebp+2], -21 ; ffffffebH
  000d8	eb 0a		 jmp	 SHORT $LN1@SetTitle_e@2
$LN95@SetTitle_e@2:
  000da	c6 45 f1 ec	 mov	 BYTE PTR __t$[ebp+1], -20 ; ffffffecH
  000de	eb 04		 jmp	 SHORT $LN1@SetTitle_e@2
$LN96@SetTitle_e@2:
  000e0	c6 45 f0 ed	 mov	 BYTE PTR __t$[ebp], -19	; ffffffedH
$LN1@SetTitle_e@2:
  000e4	81 75 f0 ed ec
	eb ea		 xor	 DWORD PTR __t$[ebp], -353637139 ; eaebecedH
  000eb	6a 04		 push	 4
  000ed	c6 45 f6 00	 mov	 BYTE PTR __t$[ebp+6], 0
  000f1	58		 pop	 eax
$LL101@SetTitle_e@2:
  000f2	8b c8		 mov	 ecx, eax
  000f4	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  000fa	79 05		 jns	 SHORT $LN111@SetTitle_e@2
  000fc	49		 dec	 ecx
  000fd	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00100	41		 inc	 ecx
$LN111@SetTitle_e@2:
  00101	b2 ed		 mov	 dl, -19			; ffffffedH
  00103	2a d1		 sub	 dl, cl
  00105	30 54 05 f0	 xor	 BYTE PTR __t$[ebp+eax], dl
  00109	40		 inc	 eax
  0010a	83 f8 06	 cmp	 eax, 6
  0010d	7c e3		 jl	 SHORT $LL101@SetTitle_e@2

; 190  : 		SetTitle(_t);

  0010f	8d 45 f0	 lea	 eax, DWORD PTR __t$[ebp]
  00112	50		 push	 eax
  00113	8b ce		 mov	 ecx, esi
  00115	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z

; 191  : 	}

  0011b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011e	33 cd		 xor	 ecx, ebp
  00120	5e		 pop	 esi
  00121	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00126	c9		 leave
  00127	c2 04 00	 ret	 4
??$SetTitle_e@$06@ioINILoader@@QAEXAAY06$$CBD@Z ENDP	; ioINILoader::SetTitle_e<7>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadInt_e@$07@ioINILoader@@QAEHAAY07$$CBDH@Z	; ioINILoader::LoadInt_e<8>
EXTRN	__imp_?LoadInt@ioINILoader@@QAEHPBDH@Z:PROC
; Function compile flags: /Ogsp
;	COMDAT ??$LoadInt_e@$07@ioINILoader@@QAEHAAY07$$CBDH@Z
_TEXT	SEGMENT
__k$ = -16						; size = 8
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_i$ = 12						; size = 4
??$LoadInt_e@$07@ioINILoader@@QAEHAAY07$$CBDH@Z PROC	; ioINILoader::LoadInt_e<8>, COMDAT
; _this$ = ecx

; 118  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 119  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	84 d2		 test	 dl, dl
  0001a	0f 84 d7 00 00
	00		 je	 $LN96@LoadInt_e
  00020	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00023	88 55 f0	 mov	 BYTE PTR __k$[ebp], dl
  00026	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00029	84 d2		 test	 dl, dl
  0002b	0f 84 c0 00 00
	00		 je	 $LN95@LoadInt_e
  00031	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00034	88 55 f1	 mov	 BYTE PTR __k$[ebp+1], dl
  00037	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003a	84 d2		 test	 dl, dl
  0003c	0f 84 a9 00 00
	00		 je	 $LN94@LoadInt_e
  00042	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00045	88 55 f2	 mov	 BYTE PTR __k$[ebp+2], dl
  00048	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004b	84 d2		 test	 dl, dl
  0004d	0f 84 92 00 00
	00		 je	 $LN93@LoadInt_e
  00053	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00056	88 55 f3	 mov	 BYTE PTR __k$[ebp+3], dl
  00059	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005c	84 d2		 test	 dl, dl
  0005e	74 7f		 je	 SHORT $LN92@LoadInt_e
  00060	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00063	88 55 f4	 mov	 BYTE PTR __k$[ebp+4], dl
  00066	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00069	84 d2		 test	 dl, dl
  0006b	74 6c		 je	 SHORT $LN91@LoadInt_e
  0006d	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00070	88 55 f5	 mov	 BYTE PTR __k$[ebp+5], dl
  00073	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00076	84 d2		 test	 dl, dl
  00078	74 59		 je	 SHORT $LN90@LoadInt_e
  0007a	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0007d	80 78 07 00	 cmp	 BYTE PTR [eax+7], 0
  00081	88 55 f6	 mov	 BYTE PTR __k$[ebp+6], dl
  00084	74 75		 je	 SHORT $LN1@LoadInt_e
  00086	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  00089	84 d2		 test	 dl, dl
  0008b	74 40		 je	 SHORT $LN88@LoadInt_e
  0008d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00090	88 55 f8	 mov	 BYTE PTR __k$[ebp+8], dl
  00093	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  00096	84 d2		 test	 dl, dl
  00098	74 2d		 je	 SHORT $LN87@LoadInt_e
  0009a	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0009d	88 55 f9	 mov	 BYTE PTR __k$[ebp+9], dl
  000a0	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000a3	84 d2		 test	 dl, dl
  000a5	74 1a		 je	 SHORT $LN86@LoadInt_e
  000a7	8a 40 0b	 mov	 al, BYTE PTR [eax+11]
  000aa	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000ad	88 55 fa	 mov	 BYTE PTR __k$[ebp+10], dl
  000b0	84 c0		 test	 al, al
  000b2	74 07		 je	 SHORT $LN85@LoadInt_e
  000b4	34 ea		 xor	 al, -22			; ffffffeaH
  000b6	88 45 fb	 mov	 BYTE PTR __k$[ebp+11], al
  000b9	eb 40		 jmp	 SHORT $LN1@LoadInt_e
$LN85@LoadInt_e:
  000bb	c6 45 fb ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  000bf	eb 3a		 jmp	 SHORT $LN1@LoadInt_e
$LN86@LoadInt_e:
  000c1	c6 45 fa eb	 mov	 BYTE PTR __k$[ebp+10], -21 ; ffffffebH
  000c5	eb 34		 jmp	 SHORT $LN1@LoadInt_e
$LN87@LoadInt_e:
  000c7	c6 45 f9 ec	 mov	 BYTE PTR __k$[ebp+9], -20 ; ffffffecH
  000cb	eb 2e		 jmp	 SHORT $LN1@LoadInt_e
$LN88@LoadInt_e:
  000cd	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  000d1	eb 28		 jmp	 SHORT $LN1@LoadInt_e
$LN90@LoadInt_e:
  000d3	c6 45 f6 eb	 mov	 BYTE PTR __k$[ebp+6], -21 ; ffffffebH
  000d7	eb 22		 jmp	 SHORT $LN1@LoadInt_e
$LN91@LoadInt_e:
  000d9	c6 45 f5 ec	 mov	 BYTE PTR __k$[ebp+5], -20 ; ffffffecH
  000dd	eb 1c		 jmp	 SHORT $LN1@LoadInt_e
$LN92@LoadInt_e:
  000df	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  000e3	eb 16		 jmp	 SHORT $LN1@LoadInt_e
$LN93@LoadInt_e:
  000e5	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  000e9	eb 10		 jmp	 SHORT $LN1@LoadInt_e
$LN94@LoadInt_e:
  000eb	c6 45 f2 eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  000ef	eb 0a		 jmp	 SHORT $LN1@LoadInt_e
$LN95@LoadInt_e:
  000f1	c6 45 f1 ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  000f5	eb 04		 jmp	 SHORT $LN1@LoadInt_e
$LN96@LoadInt_e:
  000f7	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@LoadInt_e:
  000fb	81 75 f0 ed ec
	eb ea		 xor	 DWORD PTR __k$[ebp], -353637139 ; eaebecedH
  00102	6a 04		 push	 4
  00104	c6 45 f7 00	 mov	 BYTE PTR __k$[ebp+7], 0
  00108	58		 pop	 eax
$LL101@LoadInt_e:
  00109	8b c8		 mov	 ecx, eax
  0010b	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00111	79 05		 jns	 SHORT $LN111@LoadInt_e
  00113	49		 dec	 ecx
  00114	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00117	41		 inc	 ecx
$LN111@LoadInt_e:
  00118	b2 ed		 mov	 dl, -19			; ffffffedH
  0011a	2a d1		 sub	 dl, cl
  0011c	30 54 05 f0	 xor	 BYTE PTR __k$[ebp+eax], dl
  00120	40		 inc	 eax
  00121	83 f8 07	 cmp	 eax, 7
  00124	7c e3		 jl	 SHORT $LL101@LoadInt_e

; 120  : 		return LoadInt(_k, i);

  00126	ff 75 0c	 push	 DWORD PTR _i$[ebp]
  00129	8d 45 f0	 lea	 eax, DWORD PTR __k$[ebp]
  0012c	50		 push	 eax
  0012d	8b ce		 mov	 ecx, esi
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z

; 121  : 	}

  00135	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00138	33 cd		 xor	 ecx, ebp
  0013a	5e		 pop	 esi
  0013b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00140	c9		 leave
  00141	c2 08 00	 ret	 8
??$LoadInt_e@$07@ioINILoader@@QAEHAAY07$$CBDH@Z ENDP	; ioINILoader::LoadInt_e<8>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$SetTitle_e@$08@ioINILoader@@QAEXAAY08$$CBD@Z	; ioINILoader::SetTitle_e<9>
; Function compile flags: /Ogsp
;	COMDAT ??$SetTitle_e@$08@ioINILoader@@QAEXAAY08$$CBD@Z
_TEXT	SEGMENT
__t$ = -20						; size = 9
__$ArrayPad$ = -4					; size = 4
_t$ = 8							; size = 4
??$SetTitle_e@$08@ioINILoader@@QAEXAAY08$$CBD@Z PROC	; ioINILoader::SetTitle_e<9>, COMDAT
; _this$ = ecx

; 188  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]

; 189  : 		_ENCSTR(t, _t);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	84 d2		 test	 dl, dl
  00017	0f 84 ee 00 00
	00		 je	 $LN96@SetTitle_e@3
  0001d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00020	88 55 ec	 mov	 BYTE PTR __t$[ebp], dl
  00023	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00026	84 d2		 test	 dl, dl
  00028	0f 84 d7 00 00
	00		 je	 $LN95@SetTitle_e@3
  0002e	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00031	88 55 ed	 mov	 BYTE PTR __t$[ebp+1], dl
  00034	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  00037	84 d2		 test	 dl, dl
  00039	0f 84 c0 00 00
	00		 je	 $LN94@SetTitle_e@3
  0003f	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00042	88 55 ee	 mov	 BYTE PTR __t$[ebp+2], dl
  00045	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  00048	84 d2		 test	 dl, dl
  0004a	0f 84 a9 00 00
	00		 je	 $LN93@SetTitle_e@3
  00050	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00053	88 55 ef	 mov	 BYTE PTR __t$[ebp+3], dl
  00056	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  00059	84 d2		 test	 dl, dl
  0005b	0f 84 92 00 00
	00		 je	 $LN92@SetTitle_e@3
  00061	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00064	88 55 f0	 mov	 BYTE PTR __t$[ebp+4], dl
  00067	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006a	84 d2		 test	 dl, dl
  0006c	74 7f		 je	 SHORT $LN91@SetTitle_e@3
  0006e	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00071	88 55 f1	 mov	 BYTE PTR __t$[ebp+5], dl
  00074	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00077	84 d2		 test	 dl, dl
  00079	74 6c		 je	 SHORT $LN90@SetTitle_e@3
  0007b	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0007e	88 55 f2	 mov	 BYTE PTR __t$[ebp+6], dl
  00081	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00084	84 d2		 test	 dl, dl
  00086	74 59		 je	 SHORT $LN89@SetTitle_e@3
  00088	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0008b	80 78 08 00	 cmp	 BYTE PTR [eax+8], 0
  0008f	88 55 f3	 mov	 BYTE PTR __t$[ebp+7], dl
  00092	74 7b		 je	 SHORT $LN1@SetTitle_e@3
  00094	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  00097	84 d2		 test	 dl, dl
  00099	74 40		 je	 SHORT $LN87@SetTitle_e@3
  0009b	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0009e	88 55 f5	 mov	 BYTE PTR __t$[ebp+9], dl
  000a1	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000a4	84 d2		 test	 dl, dl
  000a6	74 2d		 je	 SHORT $LN86@SetTitle_e@3
  000a8	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000ab	88 55 f6	 mov	 BYTE PTR __t$[ebp+10], dl
  000ae	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000b1	84 d2		 test	 dl, dl
  000b3	74 1a		 je	 SHORT $LN85@SetTitle_e@3
  000b5	8a 40 0c	 mov	 al, BYTE PTR [eax+12]
  000b8	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000bb	88 55 f7	 mov	 BYTE PTR __t$[ebp+11], dl
  000be	84 c0		 test	 al, al
  000c0	74 07		 je	 SHORT $LN84@SetTitle_e@3
  000c2	34 ed		 xor	 al, -19			; ffffffedH
  000c4	88 45 f8	 mov	 BYTE PTR __t$[ebp+12], al
  000c7	eb 46		 jmp	 SHORT $LN1@SetTitle_e@3
$LN84@SetTitle_e@3:
  000c9	c6 45 f8 ed	 mov	 BYTE PTR __t$[ebp+12], -19 ; ffffffedH
  000cd	eb 40		 jmp	 SHORT $LN1@SetTitle_e@3
$LN85@SetTitle_e@3:
  000cf	c6 45 f7 ea	 mov	 BYTE PTR __t$[ebp+11], -22 ; ffffffeaH
  000d3	eb 3a		 jmp	 SHORT $LN1@SetTitle_e@3
$LN86@SetTitle_e@3:
  000d5	c6 45 f6 eb	 mov	 BYTE PTR __t$[ebp+10], -21 ; ffffffebH
  000d9	eb 34		 jmp	 SHORT $LN1@SetTitle_e@3
$LN87@SetTitle_e@3:
  000db	c6 45 f5 ec	 mov	 BYTE PTR __t$[ebp+9], -20 ; ffffffecH
  000df	eb 2e		 jmp	 SHORT $LN1@SetTitle_e@3
$LN89@SetTitle_e@3:
  000e1	c6 45 f3 ea	 mov	 BYTE PTR __t$[ebp+7], -22 ; ffffffeaH
  000e5	eb 28		 jmp	 SHORT $LN1@SetTitle_e@3
$LN90@SetTitle_e@3:
  000e7	c6 45 f2 eb	 mov	 BYTE PTR __t$[ebp+6], -21 ; ffffffebH
  000eb	eb 22		 jmp	 SHORT $LN1@SetTitle_e@3
$LN91@SetTitle_e@3:
  000ed	c6 45 f1 ec	 mov	 BYTE PTR __t$[ebp+5], -20 ; ffffffecH
  000f1	eb 1c		 jmp	 SHORT $LN1@SetTitle_e@3
$LN92@SetTitle_e@3:
  000f3	c6 45 f0 ed	 mov	 BYTE PTR __t$[ebp+4], -19 ; ffffffedH
  000f7	eb 16		 jmp	 SHORT $LN1@SetTitle_e@3
$LN93@SetTitle_e@3:
  000f9	c6 45 ef ea	 mov	 BYTE PTR __t$[ebp+3], -22 ; ffffffeaH
  000fd	eb 10		 jmp	 SHORT $LN1@SetTitle_e@3
$LN94@SetTitle_e@3:
  000ff	c6 45 ee eb	 mov	 BYTE PTR __t$[ebp+2], -21 ; ffffffebH
  00103	eb 0a		 jmp	 SHORT $LN1@SetTitle_e@3
$LN95@SetTitle_e@3:
  00105	c6 45 ed ec	 mov	 BYTE PTR __t$[ebp+1], -20 ; ffffffecH
  00109	eb 04		 jmp	 SHORT $LN1@SetTitle_e@3
$LN96@SetTitle_e@3:
  0010b	c6 45 ec ed	 mov	 BYTE PTR __t$[ebp], -19	; ffffffedH
$LN1@SetTitle_e@3:
  0010f	6a 02		 push	 2
  00111	8d 45 ec	 lea	 eax, DWORD PTR __t$[ebp]
  00114	c6 45 f4 00	 mov	 BYTE PTR __t$[ebp+8], 0
  00118	5a		 pop	 edx
$LL104@SetTitle_e@3:
  00119	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0011f	83 c0 04	 add	 eax, 4
  00122	4a		 dec	 edx
  00123	75 f4		 jne	 SHORT $LL104@SetTitle_e@3

; 190  : 		SetTitle(_t);

  00125	8d 45 ec	 lea	 eax, DWORD PTR __t$[ebp]
  00128	50		 push	 eax
  00129	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z

; 191  : 	}

  0012f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00132	33 cd		 xor	 ecx, ebp
  00134	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00139	c9		 leave
  0013a	c2 04 00	 ret	 4
??$SetTitle_e@$08@ioINILoader@@QAEXAAY08$$CBD@Z ENDP	; ioINILoader::SetTitle_e<9>
_TEXT	ENDS
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadString_e@$0O@@ioINILoader@@QAEXAAY0O@$$CBDAAY00$$CBDPADH@Z ; ioINILoader::LoadString_e<14>
EXTRN	__imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z:PROC
; Function compile flags: /Ogsp
;	COMDAT ??$LoadString_e@$0O@@ioINILoader@@QAEXAAY0O@$$CBDAAY00$$CBDPADH@Z
_TEXT	SEGMENT
_this$GSCopy$ = -28					; size = 4
__k$ = -24						; size = 14
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_d$ = 12						; size = 4
_b$ = 16						; size = 4
_i$ = 20						; size = 4
??$LoadString_e@$0O@@ioINILoader@@QAEXAAY0O@$$CBDAAY00$$CBDPADH@Z PROC ; ioINILoader::LoadString_e<14>, COMDAT
; _this$ = ecx

; 161  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 162  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b 75 0c	 mov	 esi, DWORD PTR _d$[ebp]
  00019	57		 push	 edi
  0001a	8b 7d 10	 mov	 edi, DWORD PTR _b$[ebp]
  0001d	89 4d e4	 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  00020	84 d2		 test	 dl, dl
  00022	0f 84 64 01 00
	00		 je	 $LN96@LoadString
  00028	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0002b	88 55 e8	 mov	 BYTE PTR __k$[ebp], dl
  0002e	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00031	84 d2		 test	 dl, dl
  00033	0f 84 4d 01 00
	00		 je	 $LN95@LoadString
  00039	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0003c	88 55 e9	 mov	 BYTE PTR __k$[ebp+1], dl
  0003f	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  00042	84 d2		 test	 dl, dl
  00044	0f 84 36 01 00
	00		 je	 $LN94@LoadString
  0004a	b1 eb		 mov	 cl, -21			; ffffffebH
  0004c	32 d1		 xor	 dl, cl
  0004e	88 55 ea	 mov	 BYTE PTR __k$[ebp+2], dl
  00051	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  00054	84 d2		 test	 dl, dl
  00056	0f 84 1e 01 00
	00		 je	 $LN93@LoadString
  0005c	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0005f	88 55 eb	 mov	 BYTE PTR __k$[ebp+3], dl
  00062	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  00065	84 d2		 test	 dl, dl
  00067	0f 84 07 01 00
	00		 je	 $LN92@LoadString
  0006d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00070	88 55 ec	 mov	 BYTE PTR __k$[ebp+4], dl
  00073	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00076	84 d2		 test	 dl, dl
  00078	0f 84 f0 00 00
	00		 je	 $LN91@LoadString
  0007e	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00081	88 55 ed	 mov	 BYTE PTR __k$[ebp+5], dl
  00084	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00087	84 d2		 test	 dl, dl
  00089	0f 84 da 00 00
	00		 je	 $LN90@LoadString
  0008f	32 d1		 xor	 dl, cl
  00091	88 55 ee	 mov	 BYTE PTR __k$[ebp+6], dl
  00094	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00097	84 d2		 test	 dl, dl
  00099	0f 84 c4 00 00
	00		 je	 $LN89@LoadString
  0009f	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000a2	88 55 ef	 mov	 BYTE PTR __k$[ebp+7], dl
  000a5	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a8	84 d2		 test	 dl, dl
  000aa	0f 84 ad 00 00
	00		 je	 $LN88@LoadString
  000b0	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000b3	88 55 f0	 mov	 BYTE PTR __k$[ebp+8], dl
  000b6	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b9	84 d2		 test	 dl, dl
  000bb	0f 84 96 00 00
	00		 je	 $LN87@LoadString
  000c1	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000c4	88 55 f1	 mov	 BYTE PTR __k$[ebp+9], dl
  000c7	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000ca	84 d2		 test	 dl, dl
  000cc	0f 84 80 00 00
	00		 je	 $LN86@LoadString
  000d2	32 d1		 xor	 dl, cl
  000d4	88 55 f2	 mov	 BYTE PTR __k$[ebp+10], dl
  000d7	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000da	84 d2		 test	 dl, dl
  000dc	74 6e		 je	 SHORT $LN85@LoadString
  000de	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000e1	88 55 f3	 mov	 BYTE PTR __k$[ebp+11], dl
  000e4	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000e7	84 d2		 test	 dl, dl
  000e9	74 5b		 je	 SHORT $LN84@LoadString
  000eb	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ee	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000f2	88 55 f4	 mov	 BYTE PTR __k$[ebp+12], dl
  000f5	0f 84 95 00 00
	00		 je	 $LN111@LoadString
  000fb	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  000fe	84 d2		 test	 dl, dl
  00100	74 3f		 je	 SHORT $LN82@LoadString
  00102	32 d1		 xor	 dl, cl
  00104	88 55 f6	 mov	 BYTE PTR __k$[ebp+14], dl
  00107	8a 50 0f	 mov	 dl, BYTE PTR [eax+15]
  0010a	84 d2		 test	 dl, dl
  0010c	74 2d		 je	 SHORT $LN81@LoadString
  0010e	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00111	88 55 f7	 mov	 BYTE PTR __k$[ebp+15], dl
  00114	8a 50 10	 mov	 dl, BYTE PTR [eax+16]
  00117	84 d2		 test	 dl, dl
  00119	74 1a		 je	 SHORT $LN80@LoadString
  0011b	8a 40 11	 mov	 al, BYTE PTR [eax+17]
  0011e	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00121	88 55 f8	 mov	 BYTE PTR __k$[ebp+16], dl
  00124	84 c0		 test	 al, al
  00126	74 07		 je	 SHORT $LN79@LoadString
  00128	34 ec		 xor	 al, -20			; ffffffecH
  0012a	88 45 f9	 mov	 BYTE PTR __k$[ebp+17], al
  0012d	eb 61		 jmp	 SHORT $LN111@LoadString
$LN79@LoadString:
  0012f	c6 45 f9 ec	 mov	 BYTE PTR __k$[ebp+17], -20 ; ffffffecH
  00133	eb 5b		 jmp	 SHORT $LN111@LoadString
$LN80@LoadString:
  00135	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+16], -19 ; ffffffedH
  00139	eb 55		 jmp	 SHORT $LN111@LoadString
$LN81@LoadString:
  0013b	c6 45 f7 ea	 mov	 BYTE PTR __k$[ebp+15], -22 ; ffffffeaH
  0013f	eb 4f		 jmp	 SHORT $LN111@LoadString
$LN82@LoadString:
  00141	88 4d f6	 mov	 BYTE PTR __k$[ebp+14], cl
  00144	eb 4a		 jmp	 SHORT $LN111@LoadString
$LN84@LoadString:
  00146	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  0014a	eb 44		 jmp	 SHORT $LN111@LoadString
$LN85@LoadString:
  0014c	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  00150	eb 3e		 jmp	 SHORT $LN111@LoadString
$LN86@LoadString:
  00152	88 4d f2	 mov	 BYTE PTR __k$[ebp+10], cl
  00155	eb 39		 jmp	 SHORT $LN111@LoadString
$LN87@LoadString:
  00157	c6 45 f1 ec	 mov	 BYTE PTR __k$[ebp+9], -20 ; ffffffecH
  0015b	eb 33		 jmp	 SHORT $LN111@LoadString
$LN88@LoadString:
  0015d	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  00161	eb 2d		 jmp	 SHORT $LN111@LoadString
$LN89@LoadString:
  00163	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  00167	eb 27		 jmp	 SHORT $LN111@LoadString
$LN90@LoadString:
  00169	88 4d ee	 mov	 BYTE PTR __k$[ebp+6], cl
  0016c	eb 22		 jmp	 SHORT $LN111@LoadString
$LN91@LoadString:
  0016e	c6 45 ed ec	 mov	 BYTE PTR __k$[ebp+5], -20 ; ffffffecH
  00172	eb 1c		 jmp	 SHORT $LN111@LoadString
$LN92@LoadString:
  00174	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  00178	eb 16		 jmp	 SHORT $LN111@LoadString
$LN93@LoadString:
  0017a	c6 45 eb ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  0017e	eb 10		 jmp	 SHORT $LN111@LoadString
$LN94@LoadString:
  00180	c6 45 ea eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  00184	eb 0a		 jmp	 SHORT $LN111@LoadString
$LN95@LoadString:
  00186	c6 45 e9 ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  0018a	eb 04		 jmp	 SHORT $LN111@LoadString
$LN96@LoadString:
  0018c	c6 45 e8 ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN111@LoadString:
  00190	6a 03		 push	 3
  00192	8d 45 e8	 lea	 eax, DWORD PTR __k$[ebp]
  00195	c6 45 f5 00	 mov	 BYTE PTR __k$[ebp+13], 0
  00199	5a		 pop	 edx
$LL104@LoadString:
  0019a	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  001a0	83 c0 04	 add	 eax, 4
  001a3	4a		 dec	 edx
  001a4	75 f4		 jne	 SHORT $LL104@LoadString

; 163  : 		LoadString(_k, d, b, i);

  001a6	ff 75 14	 push	 DWORD PTR _i$[ebp]
  001a9	8b 4d e4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  001ac	80 75 f4 ed	 xor	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  001b0	57		 push	 edi
  001b1	56		 push	 esi
  001b2	8d 45 e8	 lea	 eax, DWORD PTR __k$[ebp]
  001b5	50		 push	 eax
  001b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 164  : 	}

  001bc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001bf	5f		 pop	 edi
  001c0	33 cd		 xor	 ecx, ebp
  001c2	5e		 pop	 esi
  001c3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c8	c9		 leave
  001c9	c2 10 00	 ret	 16			; 00000010H
??$LoadString_e@$0O@@ioINILoader@@QAEXAAY0O@$$CBDAAY00$$CBDPADH@Z ENDP ; ioINILoader::LoadString_e<14>
_TEXT	ENDS
PUBLIC	??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z PROC ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	66 8b 00	 mov	 ax, WORD PTR [eax]
  00009	56		 push	 esi
  0000a	ff 75 0c	 push	 DWORD PTR __Val2$[ebp]
  0000d	8b f1		 mov	 esi, ecx
  0000f	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00012	66 89 06	 mov	 WORD PTR [esi], ax
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z

; 248  : 		}

  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ENDP ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadString_e@$07@ioINILoader@@QAEXAAY07$$CBDAAY00$$CBDPADH@Z ; ioINILoader::LoadString_e<8>
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\io3dengine\ioiniloader.h
;	COMDAT ??$LoadString_e@$07@ioINILoader@@QAEXAAY07$$CBDAAY00$$CBDPADH@Z
_TEXT	SEGMENT
__k$ = -16						; size = 8
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_d$ = 12						; size = 4
_b$ = 16						; size = 4
_i$ = 20						; size = 4
??$LoadString_e@$07@ioINILoader@@QAEXAAY07$$CBDAAY00$$CBDPADH@Z PROC ; ioINILoader::LoadString_e<8>, COMDAT
; _this$ = ecx

; 161  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 162  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	8b 75 0c	 mov	 esi, DWORD PTR _d$[ebp]
  0001a	57		 push	 edi
  0001b	8b 7d 10	 mov	 edi, DWORD PTR _b$[ebp]
  0001e	84 d2		 test	 dl, dl
  00020	0f 84 d7 00 00
	00		 je	 $LN96@LoadString@2
  00026	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00029	88 55 f0	 mov	 BYTE PTR __k$[ebp], dl
  0002c	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002f	84 d2		 test	 dl, dl
  00031	0f 84 c0 00 00
	00		 je	 $LN95@LoadString@2
  00037	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0003a	88 55 f1	 mov	 BYTE PTR __k$[ebp+1], dl
  0003d	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  00040	84 d2		 test	 dl, dl
  00042	0f 84 a9 00 00
	00		 je	 $LN94@LoadString@2
  00048	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0004b	88 55 f2	 mov	 BYTE PTR __k$[ebp+2], dl
  0004e	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  00051	84 d2		 test	 dl, dl
  00053	0f 84 92 00 00
	00		 je	 $LN93@LoadString@2
  00059	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0005c	88 55 f3	 mov	 BYTE PTR __k$[ebp+3], dl
  0005f	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  00062	84 d2		 test	 dl, dl
  00064	74 7f		 je	 SHORT $LN92@LoadString@2
  00066	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00069	88 55 f4	 mov	 BYTE PTR __k$[ebp+4], dl
  0006c	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006f	84 d2		 test	 dl, dl
  00071	74 6c		 je	 SHORT $LN91@LoadString@2
  00073	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00076	88 55 f5	 mov	 BYTE PTR __k$[ebp+5], dl
  00079	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0007c	84 d2		 test	 dl, dl
  0007e	74 59		 je	 SHORT $LN90@LoadString@2
  00080	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00083	80 78 07 00	 cmp	 BYTE PTR [eax+7], 0
  00087	88 55 f6	 mov	 BYTE PTR __k$[ebp+6], dl
  0008a	74 75		 je	 SHORT $LN1@LoadString@2
  0008c	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  0008f	84 d2		 test	 dl, dl
  00091	74 40		 je	 SHORT $LN88@LoadString@2
  00093	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00096	88 55 f8	 mov	 BYTE PTR __k$[ebp+8], dl
  00099	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  0009c	84 d2		 test	 dl, dl
  0009e	74 2d		 je	 SHORT $LN87@LoadString@2
  000a0	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000a3	88 55 f9	 mov	 BYTE PTR __k$[ebp+9], dl
  000a6	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000a9	84 d2		 test	 dl, dl
  000ab	74 1a		 je	 SHORT $LN86@LoadString@2
  000ad	8a 40 0b	 mov	 al, BYTE PTR [eax+11]
  000b0	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000b3	88 55 fa	 mov	 BYTE PTR __k$[ebp+10], dl
  000b6	84 c0		 test	 al, al
  000b8	74 07		 je	 SHORT $LN85@LoadString@2
  000ba	34 ea		 xor	 al, -22			; ffffffeaH
  000bc	88 45 fb	 mov	 BYTE PTR __k$[ebp+11], al
  000bf	eb 40		 jmp	 SHORT $LN1@LoadString@2
$LN85@LoadString@2:
  000c1	c6 45 fb ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  000c5	eb 3a		 jmp	 SHORT $LN1@LoadString@2
$LN86@LoadString@2:
  000c7	c6 45 fa eb	 mov	 BYTE PTR __k$[ebp+10], -21 ; ffffffebH
  000cb	eb 34		 jmp	 SHORT $LN1@LoadString@2
$LN87@LoadString@2:
  000cd	c6 45 f9 ec	 mov	 BYTE PTR __k$[ebp+9], -20 ; ffffffecH
  000d1	eb 2e		 jmp	 SHORT $LN1@LoadString@2
$LN88@LoadString@2:
  000d3	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  000d7	eb 28		 jmp	 SHORT $LN1@LoadString@2
$LN90@LoadString@2:
  000d9	c6 45 f6 eb	 mov	 BYTE PTR __k$[ebp+6], -21 ; ffffffebH
  000dd	eb 22		 jmp	 SHORT $LN1@LoadString@2
$LN91@LoadString@2:
  000df	c6 45 f5 ec	 mov	 BYTE PTR __k$[ebp+5], -20 ; ffffffecH
  000e3	eb 1c		 jmp	 SHORT $LN1@LoadString@2
$LN92@LoadString@2:
  000e5	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  000e9	eb 16		 jmp	 SHORT $LN1@LoadString@2
$LN93@LoadString@2:
  000eb	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  000ef	eb 10		 jmp	 SHORT $LN1@LoadString@2
$LN94@LoadString@2:
  000f1	c6 45 f2 eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  000f5	eb 0a		 jmp	 SHORT $LN1@LoadString@2
$LN95@LoadString@2:
  000f7	c6 45 f1 ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  000fb	eb 04		 jmp	 SHORT $LN1@LoadString@2
$LN96@LoadString@2:
  000fd	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@LoadString@2:
  00101	81 75 f0 ed ec
	eb ea		 xor	 DWORD PTR __k$[ebp], -353637139 ; eaebecedH
  00108	6a 04		 push	 4
  0010a	c6 45 f7 00	 mov	 BYTE PTR __k$[ebp+7], 0
  0010e	58		 pop	 eax
$LL101@LoadString@2:
  0010f	8b d0		 mov	 edx, eax
  00111	81 e2 03 00 00
	80		 and	 edx, -2147483645	; 80000003H
  00117	79 05		 jns	 SHORT $LN111@LoadString@2
  00119	4a		 dec	 edx
  0011a	83 ca fc	 or	 edx, -4			; fffffffcH
  0011d	42		 inc	 edx
$LN111@LoadString@2:
  0011e	b3 ed		 mov	 bl, -19			; ffffffedH
  00120	2a da		 sub	 bl, dl
  00122	30 5c 05 f0	 xor	 BYTE PTR __k$[ebp+eax], bl
  00126	40		 inc	 eax
  00127	83 f8 07	 cmp	 eax, 7
  0012a	7c e3		 jl	 SHORT $LL101@LoadString@2

; 163  : 		LoadString(_k, d, b, i);

  0012c	ff 75 14	 push	 DWORD PTR _i$[ebp]
  0012f	8d 45 f0	 lea	 eax, DWORD PTR __k$[ebp]
  00132	57		 push	 edi
  00133	56		 push	 esi
  00134	50		 push	 eax
  00135	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 164  : 	}

  0013b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013e	5f		 pop	 edi
  0013f	5e		 pop	 esi
  00140	33 cd		 xor	 ecx, ebp
  00142	5b		 pop	 ebx
  00143	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00148	c9		 leave
  00149	c2 10 00	 ret	 16			; 00000010H
??$LoadString_e@$07@ioINILoader@@QAEXAAY07$$CBDAAY00$$CBDPADH@Z ENDP ; ioINILoader::LoadString_e<8>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadString_e@$09@ioINILoader@@QAEXAAY09$$CBDAAY00$$CBDPADH@Z ; ioINILoader::LoadString_e<10>
; Function compile flags: /Ogsp
;	COMDAT ??$LoadString_e@$09@ioINILoader@@QAEXAAY09$$CBDAAY00$$CBDPADH@Z
_TEXT	SEGMENT
__k$ = -20						; size = 10
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_d$ = 12						; size = 4
_b$ = 16						; size = 4
_i$ = 20						; size = 4
??$LoadString_e@$09@ioINILoader@@QAEXAAY09$$CBDAAY00$$CBDPADH@Z PROC ; ioINILoader::LoadString_e<10>, COMDAT
; _this$ = ecx

; 161  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 162  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b 75 0c	 mov	 esi, DWORD PTR _d$[ebp]
  00019	57		 push	 edi
  0001a	8b 7d 10	 mov	 edi, DWORD PTR _b$[ebp]
  0001d	84 d2		 test	 dl, dl
  0001f	0f 84 0d 01 00
	00		 je	 $LN96@LoadString@3
  00025	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00028	88 55 ec	 mov	 BYTE PTR __k$[ebp], dl
  0002b	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002e	84 d2		 test	 dl, dl
  00030	0f 84 f6 00 00
	00		 je	 $LN95@LoadString@3
  00036	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00039	88 55 ed	 mov	 BYTE PTR __k$[ebp+1], dl
  0003c	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003f	84 d2		 test	 dl, dl
  00041	0f 84 df 00 00
	00		 je	 $LN94@LoadString@3
  00047	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0004a	88 55 ee	 mov	 BYTE PTR __k$[ebp+2], dl
  0004d	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  00050	84 d2		 test	 dl, dl
  00052	0f 84 c8 00 00
	00		 je	 $LN93@LoadString@3
  00058	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0005b	88 55 ef	 mov	 BYTE PTR __k$[ebp+3], dl
  0005e	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  00061	84 d2		 test	 dl, dl
  00063	0f 84 b1 00 00
	00		 je	 $LN92@LoadString@3
  00069	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0006c	88 55 f0	 mov	 BYTE PTR __k$[ebp+4], dl
  0006f	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00072	84 d2		 test	 dl, dl
  00074	0f 84 9a 00 00
	00		 je	 $LN91@LoadString@3
  0007a	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0007d	88 55 f1	 mov	 BYTE PTR __k$[ebp+5], dl
  00080	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00083	84 d2		 test	 dl, dl
  00085	0f 84 83 00 00
	00		 je	 $LN90@LoadString@3
  0008b	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0008e	88 55 f2	 mov	 BYTE PTR __k$[ebp+6], dl
  00091	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00094	84 d2		 test	 dl, dl
  00096	74 70		 je	 SHORT $LN89@LoadString@3
  00098	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009b	88 55 f3	 mov	 BYTE PTR __k$[ebp+7], dl
  0009e	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a1	84 d2		 test	 dl, dl
  000a3	74 5d		 je	 SHORT $LN88@LoadString@3
  000a5	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000a8	80 78 09 00	 cmp	 BYTE PTR [eax+9], 0
  000ac	88 55 f4	 mov	 BYTE PTR __k$[ebp+8], dl
  000af	0f 84 81 00 00
	00		 je	 $LN1@LoadString@3
  000b5	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000b8	84 d2		 test	 dl, dl
  000ba	74 40		 je	 SHORT $LN86@LoadString@3
  000bc	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000bf	88 55 f6	 mov	 BYTE PTR __k$[ebp+10], dl
  000c2	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000c5	84 d2		 test	 dl, dl
  000c7	74 2d		 je	 SHORT $LN85@LoadString@3
  000c9	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000cc	88 55 f7	 mov	 BYTE PTR __k$[ebp+11], dl
  000cf	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000d2	84 d2		 test	 dl, dl
  000d4	74 1a		 je	 SHORT $LN84@LoadString@3
  000d6	8a 40 0d	 mov	 al, BYTE PTR [eax+13]
  000d9	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000dc	88 55 f8	 mov	 BYTE PTR __k$[ebp+12], dl
  000df	84 c0		 test	 al, al
  000e1	74 07		 je	 SHORT $LN83@LoadString@3
  000e3	34 ec		 xor	 al, -20			; ffffffecH
  000e5	88 45 f9	 mov	 BYTE PTR __k$[ebp+13], al
  000e8	eb 4c		 jmp	 SHORT $LN1@LoadString@3
$LN83@LoadString@3:
  000ea	c6 45 f9 ec	 mov	 BYTE PTR __k$[ebp+13], -20 ; ffffffecH
  000ee	eb 46		 jmp	 SHORT $LN1@LoadString@3
$LN84@LoadString@3:
  000f0	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  000f4	eb 40		 jmp	 SHORT $LN1@LoadString@3
$LN85@LoadString@3:
  000f6	c6 45 f7 ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  000fa	eb 3a		 jmp	 SHORT $LN1@LoadString@3
$LN86@LoadString@3:
  000fc	c6 45 f6 eb	 mov	 BYTE PTR __k$[ebp+10], -21 ; ffffffebH
  00100	eb 34		 jmp	 SHORT $LN1@LoadString@3
$LN88@LoadString@3:
  00102	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  00106	eb 2e		 jmp	 SHORT $LN1@LoadString@3
$LN89@LoadString@3:
  00108	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  0010c	eb 28		 jmp	 SHORT $LN1@LoadString@3
$LN90@LoadString@3:
  0010e	c6 45 f2 eb	 mov	 BYTE PTR __k$[ebp+6], -21 ; ffffffebH
  00112	eb 22		 jmp	 SHORT $LN1@LoadString@3
$LN91@LoadString@3:
  00114	c6 45 f1 ec	 mov	 BYTE PTR __k$[ebp+5], -20 ; ffffffecH
  00118	eb 1c		 jmp	 SHORT $LN1@LoadString@3
$LN92@LoadString@3:
  0011a	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  0011e	eb 16		 jmp	 SHORT $LN1@LoadString@3
$LN93@LoadString@3:
  00120	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  00124	eb 10		 jmp	 SHORT $LN1@LoadString@3
$LN94@LoadString@3:
  00126	c6 45 ee eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  0012a	eb 0a		 jmp	 SHORT $LN1@LoadString@3
$LN95@LoadString@3:
  0012c	c6 45 ed ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  00130	eb 04		 jmp	 SHORT $LN1@LoadString@3
$LN96@LoadString@3:
  00132	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@LoadString@3:
  00136	6a 02		 push	 2
  00138	8d 45 ec	 lea	 eax, DWORD PTR __k$[ebp]
  0013b	c6 45 f5 00	 mov	 BYTE PTR __k$[ebp+9], 0
  0013f	5a		 pop	 edx
$LL104@LoadString@3:
  00140	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00146	83 c0 04	 add	 eax, 4
  00149	4a		 dec	 edx
  0014a	75 f4		 jne	 SHORT $LL104@LoadString@3

; 163  : 		LoadString(_k, d, b, i);

  0014c	ff 75 14	 push	 DWORD PTR _i$[ebp]
  0014f	80 75 f4 ed	 xor	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  00153	57		 push	 edi
  00154	56		 push	 esi
  00155	8d 45 ec	 lea	 eax, DWORD PTR __k$[ebp]
  00158	50		 push	 eax
  00159	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 164  : 	}

  0015f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00162	5f		 pop	 edi
  00163	33 cd		 xor	 ecx, ebp
  00165	5e		 pop	 esi
  00166	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016b	c9		 leave
  0016c	c2 10 00	 ret	 16			; 00000010H
??$LoadString_e@$09@ioINILoader@@QAEXAAY09$$CBDAAY00$$CBDPADH@Z ENDP ; ioINILoader::LoadString_e<10>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadString_e@$0L@@ioINILoader@@QAEXAAY0L@$$CBDAAY00$$CBDPADH@Z ; ioINILoader::LoadString_e<11>
; Function compile flags: /Ogsp
;	COMDAT ??$LoadString_e@$0L@@ioINILoader@@QAEXAAY0L@$$CBDAAY00$$CBDPADH@Z
_TEXT	SEGMENT
__k$ = -20						; size = 11
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_d$ = 12						; size = 4
_b$ = 16						; size = 4
_i$ = 20						; size = 4
??$LoadString_e@$0L@@ioINILoader@@QAEXAAY0L@$$CBDAAY00$$CBDPADH@Z PROC ; ioINILoader::LoadString_e<11>, COMDAT
; _this$ = ecx

; 161  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 162  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	8b 75 0c	 mov	 esi, DWORD PTR _d$[ebp]
  0001a	57		 push	 edi
  0001b	8b 7d 10	 mov	 edi, DWORD PTR _b$[ebp]
  0001e	84 d2		 test	 dl, dl
  00020	0f 84 1b 01 00
	00		 je	 $LN96@LoadString@4
  00026	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00029	88 55 ec	 mov	 BYTE PTR __k$[ebp], dl
  0002c	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002f	84 d2		 test	 dl, dl
  00031	0f 84 04 01 00
	00		 je	 $LN95@LoadString@4
  00037	b3 ec		 mov	 bl, -20			; ffffffecH
  00039	32 d3		 xor	 dl, bl
  0003b	88 55 ed	 mov	 BYTE PTR __k$[ebp+1], dl
  0003e	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  00041	84 d2		 test	 dl, dl
  00043	0f 84 ec 00 00
	00		 je	 $LN94@LoadString@4
  00049	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0004c	88 55 ee	 mov	 BYTE PTR __k$[ebp+2], dl
  0004f	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  00052	84 d2		 test	 dl, dl
  00054	0f 84 d5 00 00
	00		 je	 $LN93@LoadString@4
  0005a	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0005d	88 55 ef	 mov	 BYTE PTR __k$[ebp+3], dl
  00060	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  00063	84 d2		 test	 dl, dl
  00065	0f 84 be 00 00
	00		 je	 $LN92@LoadString@4
  0006b	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0006e	88 55 f0	 mov	 BYTE PTR __k$[ebp+4], dl
  00071	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00074	84 d2		 test	 dl, dl
  00076	0f 84 a8 00 00
	00		 je	 $LN91@LoadString@4
  0007c	32 d3		 xor	 dl, bl
  0007e	88 55 f1	 mov	 BYTE PTR __k$[ebp+5], dl
  00081	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00084	84 d2		 test	 dl, dl
  00086	0f 84 92 00 00
	00		 je	 $LN90@LoadString@4
  0008c	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0008f	88 55 f2	 mov	 BYTE PTR __k$[ebp+6], dl
  00092	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00095	84 d2		 test	 dl, dl
  00097	74 7f		 je	 SHORT $LN89@LoadString@4
  00099	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0009c	88 55 f3	 mov	 BYTE PTR __k$[ebp+7], dl
  0009f	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a2	84 d2		 test	 dl, dl
  000a4	74 6c		 je	 SHORT $LN88@LoadString@4
  000a6	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000a9	88 55 f4	 mov	 BYTE PTR __k$[ebp+8], dl
  000ac	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000af	84 d2		 test	 dl, dl
  000b1	74 5a		 je	 SHORT $LN87@LoadString@4
  000b3	32 d3		 xor	 dl, bl
  000b5	80 78 0a 00	 cmp	 BYTE PTR [eax+10], 0
  000b9	88 55 f5	 mov	 BYTE PTR __k$[ebp+9], dl
  000bc	0f 84 83 00 00
	00		 je	 $LN1@LoadString@4
  000c2	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000c5	84 d2		 test	 dl, dl
  000c7	74 3e		 je	 SHORT $LN85@LoadString@4
  000c9	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000cc	88 55 f7	 mov	 BYTE PTR __k$[ebp+11], dl
  000cf	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000d2	84 d2		 test	 dl, dl
  000d4	74 2b		 je	 SHORT $LN84@LoadString@4
  000d6	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000d9	88 55 f8	 mov	 BYTE PTR __k$[ebp+12], dl
  000dc	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000df	84 d2		 test	 dl, dl
  000e1	74 19		 je	 SHORT $LN83@LoadString@4
  000e3	8a 40 0e	 mov	 al, BYTE PTR [eax+14]
  000e6	32 d3		 xor	 dl, bl
  000e8	88 55 f9	 mov	 BYTE PTR __k$[ebp+13], dl
  000eb	84 c0		 test	 al, al
  000ed	74 07		 je	 SHORT $LN82@LoadString@4
  000ef	34 eb		 xor	 al, -21			; ffffffebH
  000f1	88 45 fa	 mov	 BYTE PTR __k$[ebp+14], al
  000f4	eb 4f		 jmp	 SHORT $LN1@LoadString@4
$LN82@LoadString@4:
  000f6	c6 45 fa eb	 mov	 BYTE PTR __k$[ebp+14], -21 ; ffffffebH
  000fa	eb 49		 jmp	 SHORT $LN1@LoadString@4
$LN83@LoadString@4:
  000fc	88 5d f9	 mov	 BYTE PTR __k$[ebp+13], bl
  000ff	eb 44		 jmp	 SHORT $LN1@LoadString@4
$LN84@LoadString@4:
  00101	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  00105	eb 3e		 jmp	 SHORT $LN1@LoadString@4
$LN85@LoadString@4:
  00107	c6 45 f7 ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  0010b	eb 38		 jmp	 SHORT $LN1@LoadString@4
$LN87@LoadString@4:
  0010d	88 5d f5	 mov	 BYTE PTR __k$[ebp+9], bl
  00110	eb 33		 jmp	 SHORT $LN1@LoadString@4
$LN88@LoadString@4:
  00112	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  00116	eb 2d		 jmp	 SHORT $LN1@LoadString@4
$LN89@LoadString@4:
  00118	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  0011c	eb 27		 jmp	 SHORT $LN1@LoadString@4
$LN90@LoadString@4:
  0011e	c6 45 f2 eb	 mov	 BYTE PTR __k$[ebp+6], -21 ; ffffffebH
  00122	eb 21		 jmp	 SHORT $LN1@LoadString@4
$LN91@LoadString@4:
  00124	88 5d f1	 mov	 BYTE PTR __k$[ebp+5], bl
  00127	eb 1c		 jmp	 SHORT $LN1@LoadString@4
$LN92@LoadString@4:
  00129	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  0012d	eb 16		 jmp	 SHORT $LN1@LoadString@4
$LN93@LoadString@4:
  0012f	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  00133	eb 10		 jmp	 SHORT $LN1@LoadString@4
$LN94@LoadString@4:
  00135	c6 45 ee eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  00139	eb 0a		 jmp	 SHORT $LN1@LoadString@4
$LN95@LoadString@4:
  0013b	c6 45 ed ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  0013f	eb 04		 jmp	 SHORT $LN1@LoadString@4
$LN96@LoadString@4:
  00141	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@LoadString@4:
  00145	6a 02		 push	 2
  00147	8d 45 ec	 lea	 eax, DWORD PTR __k$[ebp]
  0014a	c6 45 f6 00	 mov	 BYTE PTR __k$[ebp+10], 0
  0014e	5a		 pop	 edx
$LL104@LoadString@4:
  0014f	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00155	83 c0 04	 add	 eax, 4
  00158	4a		 dec	 edx
  00159	75 f4		 jne	 SHORT $LL104@LoadString@4
  0015b	6a 08		 push	 8
  0015d	58		 pop	 eax
$LL101@LoadString@4:
  0015e	8b d0		 mov	 edx, eax
  00160	81 e2 03 00 00
	80		 and	 edx, -2147483645	; 80000003H
  00166	79 05		 jns	 SHORT $LN111@LoadString@4
  00168	4a		 dec	 edx
  00169	83 ca fc	 or	 edx, -4			; fffffffcH
  0016c	42		 inc	 edx
$LN111@LoadString@4:
  0016d	b3 ed		 mov	 bl, -19			; ffffffedH
  0016f	2a da		 sub	 bl, dl
  00171	30 5c 05 ec	 xor	 BYTE PTR __k$[ebp+eax], bl
  00175	40		 inc	 eax
  00176	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00179	7c e3		 jl	 SHORT $LL101@LoadString@4

; 163  : 		LoadString(_k, d, b, i);

  0017b	ff 75 14	 push	 DWORD PTR _i$[ebp]
  0017e	8d 45 ec	 lea	 eax, DWORD PTR __k$[ebp]
  00181	57		 push	 edi
  00182	56		 push	 esi
  00183	50		 push	 eax
  00184	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 164  : 	}

  0018a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018d	5f		 pop	 edi
  0018e	5e		 pop	 esi
  0018f	33 cd		 xor	 ecx, ebp
  00191	5b		 pop	 ebx
  00192	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00197	c9		 leave
  00198	c2 10 00	 ret	 16			; 00000010H
??$LoadString_e@$0L@@ioINILoader@@QAEXAAY0L@$$CBDAAY00$$CBDPADH@Z ENDP ; ioINILoader::LoadString_e<11>
_TEXT	ENDS
PUBLIC	?StringCbCatA@@YGJPADIPBD@Z			; StringCbCatA
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft sdks\windows\v7.0a\include\strsafe.h
;	COMDAT ?StringCbCatA@@YGJPADIPBD@Z
_TEXT	SEGMENT
_pszDest$ = 8						; size = 4
_cbDest$ = 12						; size = 4
_pszSrc$ = 16						; size = 4
?StringCbCatA@@YGJPADIPBD@Z PROC			; StringCbCatA, COMDAT

; 2449 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 2450 :     HRESULT hr;
; 2451 :     size_t cchDestLength;
; 2452 :     size_t cchDest = cbDest / sizeof(char);
; 2453 : 
; 2454 :     hr = StringValidateDestAndLengthA(pszDest,
; 2455 :                                       cchDest,
; 2456 :                                       &cchDestLength,
; 2457 :                                       STRSAFE_MAX_CCH);

  00005	8b 75 0c	 mov	 esi, DWORD PTR _cbDest$[ebp]
  00008	33 c0		 xor	 eax, eax
  0000a	57		 push	 edi
  0000b	b9 57 00 07 80	 mov	 ecx, -2147024809	; 80070057H
  00010	85 f6		 test	 esi, esi
  00012	74 08		 je	 SHORT $LN8@StringCbCa
  00014	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH
  0001a	76 02		 jbe	 SHORT $LN9@StringCbCa
$LN8@StringCbCa:
  0001c	8b c1		 mov	 eax, ecx
$LN9@StringCbCa:
  0001e	8b 7d 08	 mov	 edi, DWORD PTR _pszDest$[ebp]
  00021	85 c0		 test	 eax, eax
  00023	78 24		 js	 SHORT $LN5@StringCbCa
  00025	33 db		 xor	 ebx, ebx
  00027	8b d6		 mov	 edx, esi
  00029	8b c7		 mov	 eax, edi
  0002b	85 f6		 test	 esi, esi
  0002d	74 0c		 je	 SHORT $LN33@StringCbCa
$LL17@StringCbCa:
  0002f	38 18		 cmp	 BYTE PTR [eax], bl
  00031	74 04		 je	 SHORT $LN16@StringCbCa
  00033	40		 inc	 eax
  00034	4a		 dec	 edx
  00035	75 f8		 jne	 SHORT $LL17@StringCbCa
$LN16@StringCbCa:
  00037	85 d2		 test	 edx, edx
  00039	75 08		 jne	 SHORT $LN32@StringCbCa
$LN33@StringCbCa:
  0003b	8b d9		 mov	 ebx, ecx
  0003d	33 c9		 xor	 ecx, ecx
$LN12@StringCbCa:
  0003f	8b c3		 mov	 eax, ebx
  00041	eb 08		 jmp	 SHORT $LN4@StringCbCa
$LN32@StringCbCa:
  00043	8b ce		 mov	 ecx, esi
  00045	2b ca		 sub	 ecx, edx
  00047	eb f6		 jmp	 SHORT $LN12@StringCbCa
$LN5@StringCbCa:
  00049	33 c9		 xor	 ecx, ecx
$LN4@StringCbCa:

; 2458 :     
; 2459 :     if (SUCCEEDED(hr))

  0004b	85 c0		 test	 eax, eax
  0004d	78 3d		 js	 SHORT $LN1@StringCbCa

; 2460 :     {
; 2461 :         hr = StringCopyWorkerA(pszDest + cchDestLength,
; 2462 :                                cchDest - cchDestLength,
; 2463 :                                NULL,
; 2464 :                                pszSrc,
; 2465 :                                STRSAFE_MAX_CCH);

  0004f	8b d6		 mov	 edx, esi
  00051	2b d1		 sub	 edx, ecx
  00053	6a 00		 push	 0
  00055	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  00058	5b		 pop	 ebx
  00059	74 26		 je	 SHORT $LN30@StringCbCa
  0005b	8b fa		 mov	 edi, edx
  0005d	2b fe		 sub	 edi, esi
  0005f	8b 75 10	 mov	 esi, DWORD PTR _pszSrc$[ebp]
  00062	8d bc 0f ff ff
	ff 7f		 lea	 edi, DWORD PTR [edi+ecx+2147483647]
  00069	2b f0		 sub	 esi, eax
$LL23@StringCbCa:
  0006b	85 ff		 test	 edi, edi
  0006d	74 0e		 je	 SHORT $LN34@StringCbCa
  0006f	8a 0c 06	 mov	 cl, BYTE PTR [esi+eax]
  00072	84 c9		 test	 cl, cl
  00074	74 07		 je	 SHORT $LN34@StringCbCa
  00076	88 08		 mov	 BYTE PTR [eax], cl
  00078	40		 inc	 eax
  00079	4f		 dec	 edi
  0007a	4a		 dec	 edx
  0007b	75 ee		 jne	 SHORT $LL23@StringCbCa
$LN34@StringCbCa:
  0007d	85 d2		 test	 edx, edx
  0007f	75 06		 jne	 SHORT $LN21@StringCbCa
$LN30@StringCbCa:
  00081	48		 dec	 eax
  00082	bb 7a 00 07 80	 mov	 ebx, -2147024774	; 8007007aH
$LN21@StringCbCa:
  00087	c6 00 00	 mov	 BYTE PTR [eax], 0
  0008a	8b c3		 mov	 eax, ebx
$LN1@StringCbCa:
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx

; 2466 :     }
; 2467 : 
; 2468 :     return hr;
; 2469 : }

  0008f	5d		 pop	 ebp
  00090	c2 0c 00	 ret	 12			; 0000000cH
?StringCbCatA@@YGJPADIPBD@Z ENDP			; StringCbCatA
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadString_e@$08@ioINILoader@@QAEXAAY08$$CBDAAY00$$CBDPADH@Z ; ioINILoader::LoadString_e<9>
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\io3dengine\ioiniloader.h
;	COMDAT ??$LoadString_e@$08@ioINILoader@@QAEXAAY08$$CBDAAY00$$CBDPADH@Z
_TEXT	SEGMENT
__k$ = -20						; size = 9
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_d$ = 12						; size = 4
_b$ = 16						; size = 4
_i$ = 20						; size = 4
??$LoadString_e@$08@ioINILoader@@QAEXAAY08$$CBDAAY00$$CBDPADH@Z PROC ; ioINILoader::LoadString_e<9>, COMDAT
; _this$ = ecx

; 161  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 162  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b 75 0c	 mov	 esi, DWORD PTR _d$[ebp]
  00019	57		 push	 edi
  0001a	8b 7d 10	 mov	 edi, DWORD PTR _b$[ebp]
  0001d	84 d2		 test	 dl, dl
  0001f	0f 84 ee 00 00
	00		 je	 $LN96@LoadString@5
  00025	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00028	88 55 ec	 mov	 BYTE PTR __k$[ebp], dl
  0002b	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002e	84 d2		 test	 dl, dl
  00030	0f 84 d7 00 00
	00		 je	 $LN95@LoadString@5
  00036	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00039	88 55 ed	 mov	 BYTE PTR __k$[ebp+1], dl
  0003c	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003f	84 d2		 test	 dl, dl
  00041	0f 84 c0 00 00
	00		 je	 $LN94@LoadString@5
  00047	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0004a	88 55 ee	 mov	 BYTE PTR __k$[ebp+2], dl
  0004d	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  00050	84 d2		 test	 dl, dl
  00052	0f 84 a9 00 00
	00		 je	 $LN93@LoadString@5
  00058	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0005b	88 55 ef	 mov	 BYTE PTR __k$[ebp+3], dl
  0005e	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  00061	84 d2		 test	 dl, dl
  00063	0f 84 92 00 00
	00		 je	 $LN92@LoadString@5
  00069	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0006c	88 55 f0	 mov	 BYTE PTR __k$[ebp+4], dl
  0006f	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00072	84 d2		 test	 dl, dl
  00074	74 7f		 je	 SHORT $LN91@LoadString@5
  00076	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00079	88 55 f1	 mov	 BYTE PTR __k$[ebp+5], dl
  0007c	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0007f	84 d2		 test	 dl, dl
  00081	74 6c		 je	 SHORT $LN90@LoadString@5
  00083	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00086	88 55 f2	 mov	 BYTE PTR __k$[ebp+6], dl
  00089	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0008c	84 d2		 test	 dl, dl
  0008e	74 59		 je	 SHORT $LN89@LoadString@5
  00090	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00093	80 78 08 00	 cmp	 BYTE PTR [eax+8], 0
  00097	88 55 f3	 mov	 BYTE PTR __k$[ebp+7], dl
  0009a	74 7b		 je	 SHORT $LN1@LoadString@5
  0009c	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  0009f	84 d2		 test	 dl, dl
  000a1	74 40		 je	 SHORT $LN87@LoadString@5
  000a3	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000a6	88 55 f5	 mov	 BYTE PTR __k$[ebp+9], dl
  000a9	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000ac	84 d2		 test	 dl, dl
  000ae	74 2d		 je	 SHORT $LN86@LoadString@5
  000b0	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000b3	88 55 f6	 mov	 BYTE PTR __k$[ebp+10], dl
  000b6	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000b9	84 d2		 test	 dl, dl
  000bb	74 1a		 je	 SHORT $LN85@LoadString@5
  000bd	8a 40 0c	 mov	 al, BYTE PTR [eax+12]
  000c0	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000c3	88 55 f7	 mov	 BYTE PTR __k$[ebp+11], dl
  000c6	84 c0		 test	 al, al
  000c8	74 07		 je	 SHORT $LN84@LoadString@5
  000ca	34 ed		 xor	 al, -19			; ffffffedH
  000cc	88 45 f8	 mov	 BYTE PTR __k$[ebp+12], al
  000cf	eb 46		 jmp	 SHORT $LN1@LoadString@5
$LN84@LoadString@5:
  000d1	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  000d5	eb 40		 jmp	 SHORT $LN1@LoadString@5
$LN85@LoadString@5:
  000d7	c6 45 f7 ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  000db	eb 3a		 jmp	 SHORT $LN1@LoadString@5
$LN86@LoadString@5:
  000dd	c6 45 f6 eb	 mov	 BYTE PTR __k$[ebp+10], -21 ; ffffffebH
  000e1	eb 34		 jmp	 SHORT $LN1@LoadString@5
$LN87@LoadString@5:
  000e3	c6 45 f5 ec	 mov	 BYTE PTR __k$[ebp+9], -20 ; ffffffecH
  000e7	eb 2e		 jmp	 SHORT $LN1@LoadString@5
$LN89@LoadString@5:
  000e9	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  000ed	eb 28		 jmp	 SHORT $LN1@LoadString@5
$LN90@LoadString@5:
  000ef	c6 45 f2 eb	 mov	 BYTE PTR __k$[ebp+6], -21 ; ffffffebH
  000f3	eb 22		 jmp	 SHORT $LN1@LoadString@5
$LN91@LoadString@5:
  000f5	c6 45 f1 ec	 mov	 BYTE PTR __k$[ebp+5], -20 ; ffffffecH
  000f9	eb 1c		 jmp	 SHORT $LN1@LoadString@5
$LN92@LoadString@5:
  000fb	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  000ff	eb 16		 jmp	 SHORT $LN1@LoadString@5
$LN93@LoadString@5:
  00101	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  00105	eb 10		 jmp	 SHORT $LN1@LoadString@5
$LN94@LoadString@5:
  00107	c6 45 ee eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  0010b	eb 0a		 jmp	 SHORT $LN1@LoadString@5
$LN95@LoadString@5:
  0010d	c6 45 ed ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  00111	eb 04		 jmp	 SHORT $LN1@LoadString@5
$LN96@LoadString@5:
  00113	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@LoadString@5:
  00117	6a 02		 push	 2
  00119	8d 45 ec	 lea	 eax, DWORD PTR __k$[ebp]
  0011c	c6 45 f4 00	 mov	 BYTE PTR __k$[ebp+8], 0
  00120	5a		 pop	 edx
$LL104@LoadString@5:
  00121	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00127	83 c0 04	 add	 eax, 4
  0012a	4a		 dec	 edx
  0012b	75 f4		 jne	 SHORT $LL104@LoadString@5

; 163  : 		LoadString(_k, d, b, i);

  0012d	ff 75 14	 push	 DWORD PTR _i$[ebp]
  00130	8d 45 ec	 lea	 eax, DWORD PTR __k$[ebp]
  00133	57		 push	 edi
  00134	56		 push	 esi
  00135	50		 push	 eax
  00136	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 164  : 	}

  0013c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013f	5f		 pop	 edi
  00140	33 cd		 xor	 ecx, ebp
  00142	5e		 pop	 esi
  00143	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00148	c9		 leave
  00149	c2 10 00	 ret	 16			; 00000010H
??$LoadString_e@$08@ioINILoader@@QAEXAAY08$$CBDAAY00$$CBDPADH@Z ENDP ; ioINILoader::LoadString_e<9>
_TEXT	ENDS
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadString_e@$0M@@ioINILoader@@QAEXAAY0M@$$CBDAAY00$$CBDPADH@Z ; ioINILoader::LoadString_e<12>
; Function compile flags: /Ogsp
;	COMDAT ??$LoadString_e@$0M@@ioINILoader@@QAEXAAY0M@$$CBDAAY00$$CBDPADH@Z
_TEXT	SEGMENT
_this$GSCopy$ = -24					; size = 4
__k$ = -20						; size = 12
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_d$ = 12						; size = 4
_b$ = 16						; size = 4
_i$ = 20						; size = 4
??$LoadString_e@$0M@@ioINILoader@@QAEXAAY0M@$$CBDAAY00$$CBDPADH@Z PROC ; ioINILoader::LoadString_e<12>, COMDAT
; _this$ = ecx

; 161  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 162  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b 75 0c	 mov	 esi, DWORD PTR _d$[ebp]
  00019	57		 push	 edi
  0001a	8b 7d 10	 mov	 edi, DWORD PTR _b$[ebp]
  0001d	89 4d e8	 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  00020	84 d2		 test	 dl, dl
  00022	0f 84 32 01 00
	00		 je	 $LN96@LoadString@6
  00028	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0002b	88 55 ec	 mov	 BYTE PTR __k$[ebp], dl
  0002e	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00031	84 d2		 test	 dl, dl
  00033	0f 84 1b 01 00
	00		 je	 $LN95@LoadString@6
  00039	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0003c	88 55 ed	 mov	 BYTE PTR __k$[ebp+1], dl
  0003f	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  00042	84 d2		 test	 dl, dl
  00044	0f 84 04 01 00
	00		 je	 $LN94@LoadString@6
  0004a	b1 eb		 mov	 cl, -21			; ffffffebH
  0004c	32 d1		 xor	 dl, cl
  0004e	88 55 ee	 mov	 BYTE PTR __k$[ebp+2], dl
  00051	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  00054	84 d2		 test	 dl, dl
  00056	0f 84 ec 00 00
	00		 je	 $LN93@LoadString@6
  0005c	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0005f	88 55 ef	 mov	 BYTE PTR __k$[ebp+3], dl
  00062	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  00065	84 d2		 test	 dl, dl
  00067	0f 84 d5 00 00
	00		 je	 $LN92@LoadString@6
  0006d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00070	88 55 f0	 mov	 BYTE PTR __k$[ebp+4], dl
  00073	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00076	84 d2		 test	 dl, dl
  00078	0f 84 be 00 00
	00		 je	 $LN91@LoadString@6
  0007e	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00081	88 55 f1	 mov	 BYTE PTR __k$[ebp+5], dl
  00084	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00087	84 d2		 test	 dl, dl
  00089	0f 84 a8 00 00
	00		 je	 $LN90@LoadString@6
  0008f	32 d1		 xor	 dl, cl
  00091	88 55 f2	 mov	 BYTE PTR __k$[ebp+6], dl
  00094	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00097	84 d2		 test	 dl, dl
  00099	0f 84 92 00 00
	00		 je	 $LN89@LoadString@6
  0009f	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000a2	88 55 f3	 mov	 BYTE PTR __k$[ebp+7], dl
  000a5	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a8	84 d2		 test	 dl, dl
  000aa	74 7f		 je	 SHORT $LN88@LoadString@6
  000ac	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000af	88 55 f4	 mov	 BYTE PTR __k$[ebp+8], dl
  000b2	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b5	84 d2		 test	 dl, dl
  000b7	74 6c		 je	 SHORT $LN87@LoadString@6
  000b9	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000bc	88 55 f5	 mov	 BYTE PTR __k$[ebp+9], dl
  000bf	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c2	84 d2		 test	 dl, dl
  000c4	74 5a		 je	 SHORT $LN86@LoadString@6
  000c6	32 d1		 xor	 dl, cl
  000c8	80 78 0b 00	 cmp	 BYTE PTR [eax+11], 0
  000cc	88 55 f6	 mov	 BYTE PTR __k$[ebp+10], dl
  000cf	0f 84 89 00 00
	00		 je	 $LN111@LoadString@6
  000d5	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000d8	84 d2		 test	 dl, dl
  000da	74 3e		 je	 SHORT $LN84@LoadString@6
  000dc	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000df	88 55 f8	 mov	 BYTE PTR __k$[ebp+12], dl
  000e2	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000e5	84 d2		 test	 dl, dl
  000e7	74 2b		 je	 SHORT $LN83@LoadString@6
  000e9	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000ec	88 55 f9	 mov	 BYTE PTR __k$[ebp+13], dl
  000ef	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  000f2	84 d2		 test	 dl, dl
  000f4	74 19		 je	 SHORT $LN82@LoadString@6
  000f6	8a 40 0f	 mov	 al, BYTE PTR [eax+15]
  000f9	32 d1		 xor	 dl, cl
  000fb	88 55 fa	 mov	 BYTE PTR __k$[ebp+14], dl
  000fe	84 c0		 test	 al, al
  00100	74 07		 je	 SHORT $LN81@LoadString@6
  00102	34 ea		 xor	 al, -22			; ffffffeaH
  00104	88 45 fb	 mov	 BYTE PTR __k$[ebp+15], al
  00107	eb 55		 jmp	 SHORT $LN111@LoadString@6
$LN81@LoadString@6:
  00109	c6 45 fb ea	 mov	 BYTE PTR __k$[ebp+15], -22 ; ffffffeaH
  0010d	eb 4f		 jmp	 SHORT $LN111@LoadString@6
$LN82@LoadString@6:
  0010f	88 4d fa	 mov	 BYTE PTR __k$[ebp+14], cl
  00112	eb 4a		 jmp	 SHORT $LN111@LoadString@6
$LN83@LoadString@6:
  00114	c6 45 f9 ec	 mov	 BYTE PTR __k$[ebp+13], -20 ; ffffffecH
  00118	eb 44		 jmp	 SHORT $LN111@LoadString@6
$LN84@LoadString@6:
  0011a	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  0011e	eb 3e		 jmp	 SHORT $LN111@LoadString@6
$LN86@LoadString@6:
  00120	88 4d f6	 mov	 BYTE PTR __k$[ebp+10], cl
  00123	eb 39		 jmp	 SHORT $LN111@LoadString@6
$LN87@LoadString@6:
  00125	c6 45 f5 ec	 mov	 BYTE PTR __k$[ebp+9], -20 ; ffffffecH
  00129	eb 33		 jmp	 SHORT $LN111@LoadString@6
$LN88@LoadString@6:
  0012b	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  0012f	eb 2d		 jmp	 SHORT $LN111@LoadString@6
$LN89@LoadString@6:
  00131	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  00135	eb 27		 jmp	 SHORT $LN111@LoadString@6
$LN90@LoadString@6:
  00137	88 4d f2	 mov	 BYTE PTR __k$[ebp+6], cl
  0013a	eb 22		 jmp	 SHORT $LN111@LoadString@6
$LN91@LoadString@6:
  0013c	c6 45 f1 ec	 mov	 BYTE PTR __k$[ebp+5], -20 ; ffffffecH
  00140	eb 1c		 jmp	 SHORT $LN111@LoadString@6
$LN92@LoadString@6:
  00142	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  00146	eb 16		 jmp	 SHORT $LN111@LoadString@6
$LN93@LoadString@6:
  00148	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  0014c	eb 10		 jmp	 SHORT $LN111@LoadString@6
$LN94@LoadString@6:
  0014e	c6 45 ee eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  00152	eb 0a		 jmp	 SHORT $LN111@LoadString@6
$LN95@LoadString@6:
  00154	c6 45 ed ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  00158	eb 04		 jmp	 SHORT $LN111@LoadString@6
$LN96@LoadString@6:
  0015a	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN111@LoadString@6:
  0015e	6a 02		 push	 2
  00160	8d 45 ec	 lea	 eax, DWORD PTR __k$[ebp]
  00163	c6 45 f7 00	 mov	 BYTE PTR __k$[ebp+11], 0
  00167	5a		 pop	 edx
$LL104@LoadString@6:
  00168	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0016e	83 c0 04	 add	 eax, 4
  00171	4a		 dec	 edx
  00172	75 f4		 jne	 SHORT $LL104@LoadString@6
  00174	6a 08		 push	 8
  00176	58		 pop	 eax
$LL101@LoadString@6:
  00177	8b c8		 mov	 ecx, eax
  00179	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0017f	79 05		 jns	 SHORT $LN112@LoadString@6
  00181	49		 dec	 ecx
  00182	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00185	41		 inc	 ecx
$LN112@LoadString@6:
  00186	b2 ed		 mov	 dl, -19			; ffffffedH
  00188	2a d1		 sub	 dl, cl
  0018a	30 54 05 ec	 xor	 BYTE PTR __k$[ebp+eax], dl
  0018e	40		 inc	 eax
  0018f	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00192	7c e3		 jl	 SHORT $LL101@LoadString@6

; 163  : 		LoadString(_k, d, b, i);

  00194	ff 75 14	 push	 DWORD PTR _i$[ebp]
  00197	8b 4d e8	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0019a	57		 push	 edi
  0019b	56		 push	 esi
  0019c	8d 45 ec	 lea	 eax, DWORD PTR __k$[ebp]
  0019f	50		 push	 eax
  001a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 164  : 	}

  001a6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a9	5f		 pop	 edi
  001aa	33 cd		 xor	 ecx, ebp
  001ac	5e		 pop	 esi
  001ad	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b2	c9		 leave
  001b3	c2 10 00	 ret	 16			; 00000010H
??$LoadString_e@$0M@@ioINILoader@@QAEXAAY0M@$$CBDAAY00$$CBDPADH@Z ENDP ; ioINILoader::LoadString_e<12>
_TEXT	ENDS
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadString_e@$0P@@ioINILoader@@QAEXAAY0P@$$CBDAAY00$$CBDPADH@Z ; ioINILoader::LoadString_e<15>
; Function compile flags: /Ogsp
;	COMDAT ??$LoadString_e@$0P@@ioINILoader@@QAEXAAY0P@$$CBDAAY00$$CBDPADH@Z
_TEXT	SEGMENT
_this$GSCopy$ = -28					; size = 4
__k$ = -24						; size = 15
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_d$ = 12						; size = 4
_b$ = 16						; size = 4
_i$ = 20						; size = 4
??$LoadString_e@$0P@@ioINILoader@@QAEXAAY0P@$$CBDAAY00$$CBDPADH@Z PROC ; ioINILoader::LoadString_e<15>, COMDAT
; _this$ = ecx

; 161  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 162  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b 75 0c	 mov	 esi, DWORD PTR _d$[ebp]
  00019	57		 push	 edi
  0001a	8b 7d 10	 mov	 edi, DWORD PTR _b$[ebp]
  0001d	89 4d e4	 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  00020	84 d2		 test	 dl, dl
  00022	0f 84 75 01 00
	00		 je	 $LN96@LoadString@7
  00028	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0002b	88 55 e8	 mov	 BYTE PTR __k$[ebp], dl
  0002e	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00031	84 d2		 test	 dl, dl
  00033	0f 84 5e 01 00
	00		 je	 $LN95@LoadString@7
  00039	b1 ec		 mov	 cl, -20			; ffffffecH
  0003b	32 d1		 xor	 dl, cl
  0003d	88 55 e9	 mov	 BYTE PTR __k$[ebp+1], dl
  00040	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  00043	84 d2		 test	 dl, dl
  00045	0f 84 46 01 00
	00		 je	 $LN94@LoadString@7
  0004b	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0004e	88 55 ea	 mov	 BYTE PTR __k$[ebp+2], dl
  00051	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  00054	84 d2		 test	 dl, dl
  00056	0f 84 2f 01 00
	00		 je	 $LN93@LoadString@7
  0005c	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0005f	88 55 eb	 mov	 BYTE PTR __k$[ebp+3], dl
  00062	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  00065	84 d2		 test	 dl, dl
  00067	0f 84 18 01 00
	00		 je	 $LN92@LoadString@7
  0006d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00070	88 55 ec	 mov	 BYTE PTR __k$[ebp+4], dl
  00073	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00076	84 d2		 test	 dl, dl
  00078	0f 84 02 01 00
	00		 je	 $LN91@LoadString@7
  0007e	32 d1		 xor	 dl, cl
  00080	88 55 ed	 mov	 BYTE PTR __k$[ebp+5], dl
  00083	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00086	84 d2		 test	 dl, dl
  00088	0f 84 ec 00 00
	00		 je	 $LN90@LoadString@7
  0008e	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00091	88 55 ee	 mov	 BYTE PTR __k$[ebp+6], dl
  00094	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00097	84 d2		 test	 dl, dl
  00099	0f 84 d5 00 00
	00		 je	 $LN89@LoadString@7
  0009f	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000a2	88 55 ef	 mov	 BYTE PTR __k$[ebp+7], dl
  000a5	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a8	84 d2		 test	 dl, dl
  000aa	0f 84 be 00 00
	00		 je	 $LN88@LoadString@7
  000b0	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000b3	88 55 f0	 mov	 BYTE PTR __k$[ebp+8], dl
  000b6	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b9	84 d2		 test	 dl, dl
  000bb	0f 84 a8 00 00
	00		 je	 $LN87@LoadString@7
  000c1	32 d1		 xor	 dl, cl
  000c3	88 55 f1	 mov	 BYTE PTR __k$[ebp+9], dl
  000c6	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c9	84 d2		 test	 dl, dl
  000cb	0f 84 92 00 00
	00		 je	 $LN86@LoadString@7
  000d1	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000d4	88 55 f2	 mov	 BYTE PTR __k$[ebp+10], dl
  000d7	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000da	84 d2		 test	 dl, dl
  000dc	74 7f		 je	 SHORT $LN85@LoadString@7
  000de	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000e1	88 55 f3	 mov	 BYTE PTR __k$[ebp+11], dl
  000e4	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000e7	84 d2		 test	 dl, dl
  000e9	74 6c		 je	 SHORT $LN84@LoadString@7
  000eb	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000ee	88 55 f4	 mov	 BYTE PTR __k$[ebp+12], dl
  000f1	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000f4	84 d2		 test	 dl, dl
  000f6	74 5a		 je	 SHORT $LN83@LoadString@7
  000f8	32 d1		 xor	 dl, cl
  000fa	80 78 0e 00	 cmp	 BYTE PTR [eax+14], 0
  000fe	88 55 f5	 mov	 BYTE PTR __k$[ebp+13], dl
  00101	0f 84 9a 00 00
	00		 je	 $LN111@LoadString@7
  00107	8a 50 0f	 mov	 dl, BYTE PTR [eax+15]
  0010a	84 d2		 test	 dl, dl
  0010c	74 3e		 je	 SHORT $LN81@LoadString@7
  0010e	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00111	88 55 f7	 mov	 BYTE PTR __k$[ebp+15], dl
  00114	8a 50 10	 mov	 dl, BYTE PTR [eax+16]
  00117	84 d2		 test	 dl, dl
  00119	74 2b		 je	 SHORT $LN80@LoadString@7
  0011b	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0011e	88 55 f8	 mov	 BYTE PTR __k$[ebp+16], dl
  00121	8a 50 11	 mov	 dl, BYTE PTR [eax+17]
  00124	84 d2		 test	 dl, dl
  00126	74 19		 je	 SHORT $LN79@LoadString@7
  00128	8a 40 12	 mov	 al, BYTE PTR [eax+18]
  0012b	32 d1		 xor	 dl, cl
  0012d	88 55 f9	 mov	 BYTE PTR __k$[ebp+17], dl
  00130	84 c0		 test	 al, al
  00132	74 07		 je	 SHORT $LN78@LoadString@7
  00134	34 eb		 xor	 al, -21			; ffffffebH
  00136	88 45 fa	 mov	 BYTE PTR __k$[ebp+18], al
  00139	eb 66		 jmp	 SHORT $LN111@LoadString@7
$LN78@LoadString@7:
  0013b	c6 45 fa eb	 mov	 BYTE PTR __k$[ebp+18], -21 ; ffffffebH
  0013f	eb 60		 jmp	 SHORT $LN111@LoadString@7
$LN79@LoadString@7:
  00141	88 4d f9	 mov	 BYTE PTR __k$[ebp+17], cl
  00144	eb 5b		 jmp	 SHORT $LN111@LoadString@7
$LN80@LoadString@7:
  00146	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+16], -19 ; ffffffedH
  0014a	eb 55		 jmp	 SHORT $LN111@LoadString@7
$LN81@LoadString@7:
  0014c	c6 45 f7 ea	 mov	 BYTE PTR __k$[ebp+15], -22 ; ffffffeaH
  00150	eb 4f		 jmp	 SHORT $LN111@LoadString@7
$LN83@LoadString@7:
  00152	88 4d f5	 mov	 BYTE PTR __k$[ebp+13], cl
  00155	eb 4a		 jmp	 SHORT $LN111@LoadString@7
$LN84@LoadString@7:
  00157	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  0015b	eb 44		 jmp	 SHORT $LN111@LoadString@7
$LN85@LoadString@7:
  0015d	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  00161	eb 3e		 jmp	 SHORT $LN111@LoadString@7
$LN86@LoadString@7:
  00163	c6 45 f2 eb	 mov	 BYTE PTR __k$[ebp+10], -21 ; ffffffebH
  00167	eb 38		 jmp	 SHORT $LN111@LoadString@7
$LN87@LoadString@7:
  00169	88 4d f1	 mov	 BYTE PTR __k$[ebp+9], cl
  0016c	eb 33		 jmp	 SHORT $LN111@LoadString@7
$LN88@LoadString@7:
  0016e	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  00172	eb 2d		 jmp	 SHORT $LN111@LoadString@7
$LN89@LoadString@7:
  00174	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  00178	eb 27		 jmp	 SHORT $LN111@LoadString@7
$LN90@LoadString@7:
  0017a	c6 45 ee eb	 mov	 BYTE PTR __k$[ebp+6], -21 ; ffffffebH
  0017e	eb 21		 jmp	 SHORT $LN111@LoadString@7
$LN91@LoadString@7:
  00180	88 4d ed	 mov	 BYTE PTR __k$[ebp+5], cl
  00183	eb 1c		 jmp	 SHORT $LN111@LoadString@7
$LN92@LoadString@7:
  00185	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  00189	eb 16		 jmp	 SHORT $LN111@LoadString@7
$LN93@LoadString@7:
  0018b	c6 45 eb ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  0018f	eb 10		 jmp	 SHORT $LN111@LoadString@7
$LN94@LoadString@7:
  00191	c6 45 ea eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  00195	eb 0a		 jmp	 SHORT $LN111@LoadString@7
$LN95@LoadString@7:
  00197	c6 45 e9 ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  0019b	eb 04		 jmp	 SHORT $LN111@LoadString@7
$LN96@LoadString@7:
  0019d	c6 45 e8 ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN111@LoadString@7:
  001a1	6a 03		 push	 3
  001a3	8d 45 e8	 lea	 eax, DWORD PTR __k$[ebp]
  001a6	c6 45 f6 00	 mov	 BYTE PTR __k$[ebp+14], 0
  001aa	5a		 pop	 edx
$LL104@LoadString@7:
  001ab	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  001b1	83 c0 04	 add	 eax, 4
  001b4	4a		 dec	 edx
  001b5	75 f4		 jne	 SHORT $LL104@LoadString@7
  001b7	6a 0c		 push	 12			; 0000000cH
  001b9	58		 pop	 eax
$LL101@LoadString@7:
  001ba	8b c8		 mov	 ecx, eax
  001bc	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  001c2	79 05		 jns	 SHORT $LN112@LoadString@7
  001c4	49		 dec	 ecx
  001c5	83 c9 fc	 or	 ecx, -4			; fffffffcH
  001c8	41		 inc	 ecx
$LN112@LoadString@7:
  001c9	b2 ed		 mov	 dl, -19			; ffffffedH
  001cb	2a d1		 sub	 dl, cl
  001cd	30 54 05 e8	 xor	 BYTE PTR __k$[ebp+eax], dl
  001d1	40		 inc	 eax
  001d2	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  001d5	7c e3		 jl	 SHORT $LL101@LoadString@7

; 163  : 		LoadString(_k, d, b, i);

  001d7	ff 75 14	 push	 DWORD PTR _i$[ebp]
  001da	8b 4d e4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  001dd	57		 push	 edi
  001de	56		 push	 esi
  001df	8d 45 e8	 lea	 eax, DWORD PTR __k$[ebp]
  001e2	50		 push	 eax
  001e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 164  : 	}

  001e9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ec	5f		 pop	 edi
  001ed	33 cd		 xor	 ecx, ebp
  001ef	5e		 pop	 esi
  001f0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f5	c9		 leave
  001f6	c2 10 00	 ret	 16			; 00000010H
??$LoadString_e@$0P@@ioINILoader@@QAEXAAY0P@$$CBDAAY00$$CBDPADH@Z ENDP ; ioINILoader::LoadString_e<15>
_TEXT	ENDS
PUBLIC	?StringCbPrintfA@@YAJPADIPBDZZ			; StringCbPrintfA
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft sdks\windows\v7.0a\include\strsafe.h
;	COMDAT ?StringCbPrintfA@@YAJPADIPBDZZ
_TEXT	SEGMENT
_pszDest$ = 8						; size = 4
_cbDest$ = 12						; size = 4
_pszFormat$ = 16					; size = 4
?StringCbPrintfA@@YAJPADIPBDZZ PROC			; StringCbPrintfA, COMDAT

; 4767 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4768 :     HRESULT hr;
; 4769 :     size_t cchDest = cbDest / sizeof(char);
; 4770 : 
; 4771 :     hr = StringValidateDestA(pszDest, cchDest, STRSAFE_MAX_CCH);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _cbDest$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	85 c9		 test	 ecx, ecx
  0000a	74 08		 je	 SHORT $LN4@StringCbPr
  0000c	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  00012	76 05		 jbe	 SHORT $LN5@StringCbPr
$LN4@StringCbPr:
  00014	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
$LN5@StringCbPr:

; 4772 :     
; 4773 :     if (SUCCEEDED(hr))

  00019	85 c0		 test	 eax, eax
  0001b	78 39		 js	 SHORT $LN1@StringCbPr

; 4774 :     {
; 4775 :         va_list argList;
; 4776 : 
; 4777 :         va_start(argList, pszFormat);
; 4778 : 
; 4779 :         hr = StringVPrintfWorkerA(pszDest,
; 4780 :                                   cchDest,
; 4781 :                                   NULL,
; 4782 :                                   pszFormat,
; 4783 :                                   argList);

  0001d	53		 push	 ebx
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	8b 7d 08	 mov	 edi, DWORD PTR _pszDest$[ebp]
  00023	8d 45 14	 lea	 eax, DWORD PTR _pszFormat$[ebp+4]
  00026	50		 push	 eax
  00027	ff 75 10	 push	 DWORD PTR _pszFormat$[ebp]
  0002a	8d 71 ff	 lea	 esi, DWORD PTR [ecx-1]
  0002d	56		 push	 esi
  0002e	57		 push	 edi
  0002f	33 db		 xor	 ebx, ebx
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___vsnprintf
  00037	83 c4 10	 add	 esp, 16			; 00000010H
  0003a	85 c0		 test	 eax, eax
  0003c	78 0b		 js	 SHORT $LN12@StringCbPr
  0003e	3b c6		 cmp	 eax, esi
  00040	77 07		 ja	 SHORT $LN12@StringCbPr
  00042	75 0d		 jne	 SHORT $LN9@StringCbPr
  00044	88 1c 3e	 mov	 BYTE PTR [esi+edi], bl
  00047	eb 08		 jmp	 SHORT $LN9@StringCbPr
$LN12@StringCbPr:
  00049	88 1c 3e	 mov	 BYTE PTR [esi+edi], bl
  0004c	bb 7a 00 07 80	 mov	 ebx, -2147024774	; 8007007aH
$LN9@StringCbPr:
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	8b c3		 mov	 eax, ebx
  00055	5b		 pop	 ebx
$LN1@StringCbPr:

; 4784 : 
; 4785 :         va_end(argList);
; 4786 :     }
; 4787 : 
; 4788 :     return hr;
; 4789 : }

  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?StringCbPrintfA@@YAJPADIPBDZZ ENDP			; StringCbPrintfA
_TEXT	ENDS
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadString_e@$0N@@ioINILoader@@QAEXAAY0N@$$CBDAAY00$$CBDPADH@Z ; ioINILoader::LoadString_e<13>
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\io3dengine\ioiniloader.h
;	COMDAT ??$LoadString_e@$0N@@ioINILoader@@QAEXAAY0N@$$CBDAAY00$$CBDPADH@Z
_TEXT	SEGMENT
_this$GSCopy$ = -28					; size = 4
__k$ = -24						; size = 13
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_d$ = 12						; size = 4
_b$ = 16						; size = 4
_i$ = 20						; size = 4
??$LoadString_e@$0N@@ioINILoader@@QAEXAAY0N@$$CBDAAY00$$CBDPADH@Z PROC ; ioINILoader::LoadString_e<13>, COMDAT
; _this$ = ecx

; 161  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 162  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b 75 0c	 mov	 esi, DWORD PTR _d$[ebp]
  00019	57		 push	 edi
  0001a	8b 7d 10	 mov	 edi, DWORD PTR _b$[ebp]
  0001d	89 4d e4	 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  00020	84 d2		 test	 dl, dl
  00022	0f 84 4d 01 00
	00		 je	 $LN96@LoadString@8
  00028	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0002b	88 55 e8	 mov	 BYTE PTR __k$[ebp], dl
  0002e	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00031	84 d2		 test	 dl, dl
  00033	0f 84 36 01 00
	00		 je	 $LN95@LoadString@8
  00039	b1 ec		 mov	 cl, -20			; ffffffecH
  0003b	32 d1		 xor	 dl, cl
  0003d	88 55 e9	 mov	 BYTE PTR __k$[ebp+1], dl
  00040	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  00043	84 d2		 test	 dl, dl
  00045	0f 84 1e 01 00
	00		 je	 $LN94@LoadString@8
  0004b	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0004e	88 55 ea	 mov	 BYTE PTR __k$[ebp+2], dl
  00051	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  00054	84 d2		 test	 dl, dl
  00056	0f 84 07 01 00
	00		 je	 $LN93@LoadString@8
  0005c	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0005f	88 55 eb	 mov	 BYTE PTR __k$[ebp+3], dl
  00062	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  00065	84 d2		 test	 dl, dl
  00067	0f 84 f0 00 00
	00		 je	 $LN92@LoadString@8
  0006d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00070	88 55 ec	 mov	 BYTE PTR __k$[ebp+4], dl
  00073	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00076	84 d2		 test	 dl, dl
  00078	0f 84 da 00 00
	00		 je	 $LN91@LoadString@8
  0007e	32 d1		 xor	 dl, cl
  00080	88 55 ed	 mov	 BYTE PTR __k$[ebp+5], dl
  00083	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00086	84 d2		 test	 dl, dl
  00088	0f 84 c4 00 00
	00		 je	 $LN90@LoadString@8
  0008e	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00091	88 55 ee	 mov	 BYTE PTR __k$[ebp+6], dl
  00094	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00097	84 d2		 test	 dl, dl
  00099	0f 84 ad 00 00
	00		 je	 $LN89@LoadString@8
  0009f	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000a2	88 55 ef	 mov	 BYTE PTR __k$[ebp+7], dl
  000a5	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a8	84 d2		 test	 dl, dl
  000aa	0f 84 96 00 00
	00		 je	 $LN88@LoadString@8
  000b0	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000b3	88 55 f0	 mov	 BYTE PTR __k$[ebp+8], dl
  000b6	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b9	84 d2		 test	 dl, dl
  000bb	0f 84 80 00 00
	00		 je	 $LN87@LoadString@8
  000c1	32 d1		 xor	 dl, cl
  000c3	88 55 f1	 mov	 BYTE PTR __k$[ebp+9], dl
  000c6	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000c9	84 d2		 test	 dl, dl
  000cb	74 6e		 je	 SHORT $LN86@LoadString@8
  000cd	80 f2 eb	 xor	 dl, -21			; ffffffebH
  000d0	88 55 f2	 mov	 BYTE PTR __k$[ebp+10], dl
  000d3	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000d6	84 d2		 test	 dl, dl
  000d8	74 5b		 je	 SHORT $LN85@LoadString@8
  000da	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000dd	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  000e1	88 55 f3	 mov	 BYTE PTR __k$[ebp+11], dl
  000e4	0f 84 8f 00 00
	00		 je	 $LN111@LoadString@8
  000ea	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000ed	84 d2		 test	 dl, dl
  000ef	74 3f		 je	 SHORT $LN83@LoadString@8
  000f1	32 d1		 xor	 dl, cl
  000f3	88 55 f5	 mov	 BYTE PTR __k$[ebp+13], dl
  000f6	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  000f9	84 d2		 test	 dl, dl
  000fb	74 2d		 je	 SHORT $LN82@LoadString@8
  000fd	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00100	88 55 f6	 mov	 BYTE PTR __k$[ebp+14], dl
  00103	8a 50 0f	 mov	 dl, BYTE PTR [eax+15]
  00106	84 d2		 test	 dl, dl
  00108	74 1a		 je	 SHORT $LN81@LoadString@8
  0010a	8a 40 10	 mov	 al, BYTE PTR [eax+16]
  0010d	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00110	88 55 f7	 mov	 BYTE PTR __k$[ebp+15], dl
  00113	84 c0		 test	 al, al
  00115	74 07		 je	 SHORT $LN80@LoadString@8
  00117	34 ed		 xor	 al, -19			; ffffffedH
  00119	88 45 f8	 mov	 BYTE PTR __k$[ebp+16], al
  0011c	eb 5b		 jmp	 SHORT $LN111@LoadString@8
$LN80@LoadString@8:
  0011e	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+16], -19 ; ffffffedH
  00122	eb 55		 jmp	 SHORT $LN111@LoadString@8
$LN81@LoadString@8:
  00124	c6 45 f7 ea	 mov	 BYTE PTR __k$[ebp+15], -22 ; ffffffeaH
  00128	eb 4f		 jmp	 SHORT $LN111@LoadString@8
$LN82@LoadString@8:
  0012a	c6 45 f6 eb	 mov	 BYTE PTR __k$[ebp+14], -21 ; ffffffebH
  0012e	eb 49		 jmp	 SHORT $LN111@LoadString@8
$LN83@LoadString@8:
  00130	88 4d f5	 mov	 BYTE PTR __k$[ebp+13], cl
  00133	eb 44		 jmp	 SHORT $LN111@LoadString@8
$LN85@LoadString@8:
  00135	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  00139	eb 3e		 jmp	 SHORT $LN111@LoadString@8
$LN86@LoadString@8:
  0013b	c6 45 f2 eb	 mov	 BYTE PTR __k$[ebp+10], -21 ; ffffffebH
  0013f	eb 38		 jmp	 SHORT $LN111@LoadString@8
$LN87@LoadString@8:
  00141	88 4d f1	 mov	 BYTE PTR __k$[ebp+9], cl
  00144	eb 33		 jmp	 SHORT $LN111@LoadString@8
$LN88@LoadString@8:
  00146	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  0014a	eb 2d		 jmp	 SHORT $LN111@LoadString@8
$LN89@LoadString@8:
  0014c	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  00150	eb 27		 jmp	 SHORT $LN111@LoadString@8
$LN90@LoadString@8:
  00152	c6 45 ee eb	 mov	 BYTE PTR __k$[ebp+6], -21 ; ffffffebH
  00156	eb 21		 jmp	 SHORT $LN111@LoadString@8
$LN91@LoadString@8:
  00158	88 4d ed	 mov	 BYTE PTR __k$[ebp+5], cl
  0015b	eb 1c		 jmp	 SHORT $LN111@LoadString@8
$LN92@LoadString@8:
  0015d	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  00161	eb 16		 jmp	 SHORT $LN111@LoadString@8
$LN93@LoadString@8:
  00163	c6 45 eb ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  00167	eb 10		 jmp	 SHORT $LN111@LoadString@8
$LN94@LoadString@8:
  00169	c6 45 ea eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  0016d	eb 0a		 jmp	 SHORT $LN111@LoadString@8
$LN95@LoadString@8:
  0016f	c6 45 e9 ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  00173	eb 04		 jmp	 SHORT $LN111@LoadString@8
$LN96@LoadString@8:
  00175	c6 45 e8 ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN111@LoadString@8:
  00179	6a 03		 push	 3
  0017b	8d 45 e8	 lea	 eax, DWORD PTR __k$[ebp]
  0017e	c6 45 f4 00	 mov	 BYTE PTR __k$[ebp+12], 0
  00182	5a		 pop	 edx
$LL104@LoadString@8:
  00183	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00189	83 c0 04	 add	 eax, 4
  0018c	4a		 dec	 edx
  0018d	75 f4		 jne	 SHORT $LL104@LoadString@8

; 163  : 		LoadString(_k, d, b, i);

  0018f	ff 75 14	 push	 DWORD PTR _i$[ebp]
  00192	8b 4d e4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00195	57		 push	 edi
  00196	56		 push	 esi
  00197	8d 45 e8	 lea	 eax, DWORD PTR __k$[ebp]
  0019a	50		 push	 eax
  0019b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 164  : 	}

  001a1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a4	5f		 pop	 edi
  001a5	33 cd		 xor	 ecx, ebp
  001a7	5e		 pop	 esi
  001a8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ad	c9		 leave
  001ae	c2 10 00	 ret	 16			; 00000010H
??$LoadString_e@$0N@@ioINILoader@@QAEXAAY0N@$$CBDAAY00$$CBDPADH@Z ENDP ; ioINILoader::LoadString_e<13>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadString_e@$05@ioINILoader@@QAEXAAY05$$CBDAAY00$$CBDPADH@Z ; ioINILoader::LoadString_e<6>
; Function compile flags: /Ogsp
;	COMDAT ??$LoadString_e@$05@ioINILoader@@QAEXAAY05$$CBDAAY00$$CBDPADH@Z
_TEXT	SEGMENT
__k$ = -16						; size = 6
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_d$ = 12						; size = 4
_b$ = 16						; size = 4
_i$ = 20						; size = 4
??$LoadString_e@$05@ioINILoader@@QAEXAAY05$$CBDAAY00$$CBDPADH@Z PROC ; ioINILoader::LoadString_e<6>, COMDAT
; _this$ = ecx

; 161  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 162  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b 75 0c	 mov	 esi, DWORD PTR _d$[ebp]
  00019	57		 push	 edi
  0001a	8b 7d 10	 mov	 edi, DWORD PTR _b$[ebp]
  0001d	84 d2		 test	 dl, dl
  0001f	0f 84 a9 00 00
	00		 je	 $LN96@LoadString@9
  00025	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00028	88 55 f0	 mov	 BYTE PTR __k$[ebp], dl
  0002b	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002e	84 d2		 test	 dl, dl
  00030	0f 84 92 00 00
	00		 je	 $LN95@LoadString@9
  00036	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00039	88 55 f1	 mov	 BYTE PTR __k$[ebp+1], dl
  0003c	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  0003f	84 d2		 test	 dl, dl
  00041	74 7f		 je	 SHORT $LN94@LoadString@9
  00043	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00046	88 55 f2	 mov	 BYTE PTR __k$[ebp+2], dl
  00049	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  0004c	84 d2		 test	 dl, dl
  0004e	74 6c		 je	 SHORT $LN93@LoadString@9
  00050	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00053	88 55 f3	 mov	 BYTE PTR __k$[ebp+3], dl
  00056	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  00059	84 d2		 test	 dl, dl
  0005b	74 59		 je	 SHORT $LN92@LoadString@9
  0005d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00060	80 78 05 00	 cmp	 BYTE PTR [eax+5], 0
  00064	88 55 f4	 mov	 BYTE PTR __k$[ebp+4], dl
  00067	74 69		 je	 SHORT $LN1@LoadString@9
  00069	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  0006c	84 d2		 test	 dl, dl
  0006e	74 40		 je	 SHORT $LN90@LoadString@9
  00070	80 f2 eb	 xor	 dl, -21			; ffffffebH
  00073	88 55 f6	 mov	 BYTE PTR __k$[ebp+6], dl
  00076	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00079	84 d2		 test	 dl, dl
  0007b	74 2d		 je	 SHORT $LN89@LoadString@9
  0007d	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00080	88 55 f7	 mov	 BYTE PTR __k$[ebp+7], dl
  00083	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  00086	84 d2		 test	 dl, dl
  00088	74 1a		 je	 SHORT $LN88@LoadString@9
  0008a	8a 40 09	 mov	 al, BYTE PTR [eax+9]
  0008d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00090	88 55 f8	 mov	 BYTE PTR __k$[ebp+8], dl
  00093	84 c0		 test	 al, al
  00095	74 07		 je	 SHORT $LN87@LoadString@9
  00097	34 ec		 xor	 al, -20			; ffffffecH
  00099	88 45 f9	 mov	 BYTE PTR __k$[ebp+9], al
  0009c	eb 34		 jmp	 SHORT $LN1@LoadString@9
$LN87@LoadString@9:
  0009e	c6 45 f9 ec	 mov	 BYTE PTR __k$[ebp+9], -20 ; ffffffecH
  000a2	eb 2e		 jmp	 SHORT $LN1@LoadString@9
$LN88@LoadString@9:
  000a4	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  000a8	eb 28		 jmp	 SHORT $LN1@LoadString@9
$LN89@LoadString@9:
  000aa	c6 45 f7 ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  000ae	eb 22		 jmp	 SHORT $LN1@LoadString@9
$LN90@LoadString@9:
  000b0	c6 45 f6 eb	 mov	 BYTE PTR __k$[ebp+6], -21 ; ffffffebH
  000b4	eb 1c		 jmp	 SHORT $LN1@LoadString@9
$LN92@LoadString@9:
  000b6	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  000ba	eb 16		 jmp	 SHORT $LN1@LoadString@9
$LN93@LoadString@9:
  000bc	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  000c0	eb 10		 jmp	 SHORT $LN1@LoadString@9
$LN94@LoadString@9:
  000c2	c6 45 f2 eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  000c6	eb 0a		 jmp	 SHORT $LN1@LoadString@9
$LN95@LoadString@9:
  000c8	c6 45 f1 ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  000cc	eb 04		 jmp	 SHORT $LN1@LoadString@9
$LN96@LoadString@9:
  000ce	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@LoadString@9:

; 163  : 		LoadString(_k, d, b, i);

  000d2	ff 75 14	 push	 DWORD PTR _i$[ebp]
  000d5	81 75 f0 ed ec
	eb ea		 xor	 DWORD PTR __k$[ebp], -353637139 ; eaebecedH
  000dc	80 75 f4 ed	 xor	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  000e0	57		 push	 edi
  000e1	56		 push	 esi
  000e2	8d 45 f0	 lea	 eax, DWORD PTR __k$[ebp]
  000e5	50		 push	 eax
  000e6	c6 45 f5 00	 mov	 BYTE PTR __k$[ebp+5], 0
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 164  : 	}

  000f0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f3	5f		 pop	 edi
  000f4	33 cd		 xor	 ecx, ebp
  000f6	5e		 pop	 esi
  000f7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fc	c9		 leave
  000fd	c2 10 00	 ret	 16			; 00000010H
??$LoadString_e@$05@ioINILoader@@QAEXAAY05$$CBDAAY00$$CBDPADH@Z ENDP ; ioINILoader::LoadString_e<6>
_TEXT	ENDS
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadString_e@$0BA@@ioINILoader@@QAEXAAY0BA@$$CBDAAY00$$CBDPADH@Z ; ioINILoader::LoadString_e<16>
; Function compile flags: /Ogsp
;	COMDAT ??$LoadString_e@$0BA@@ioINILoader@@QAEXAAY0BA@$$CBDAAY00$$CBDPADH@Z
_TEXT	SEGMENT
_this$GSCopy$ = -28					; size = 4
__k$ = -24						; size = 16
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_d$ = 12						; size = 4
_b$ = 16						; size = 4
_i$ = 20						; size = 4
??$LoadString_e@$0BA@@ioINILoader@@QAEXAAY0BA@$$CBDAAY00$$CBDPADH@Z PROC ; ioINILoader::LoadString_e<16>, COMDAT
; _this$ = ecx

; 161  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 162  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	56		 push	 esi
  00016	8b 75 0c	 mov	 esi, DWORD PTR _d$[ebp]
  00019	57		 push	 edi
  0001a	8b 7d 10	 mov	 edi, DWORD PTR _b$[ebp]
  0001d	89 4d e4	 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  00020	84 d2		 test	 dl, dl
  00022	0f 84 8c 01 00
	00		 je	 $LN96@LoadString@10
  00028	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0002b	88 55 e8	 mov	 BYTE PTR __k$[ebp], dl
  0002e	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00031	84 d2		 test	 dl, dl
  00033	0f 84 75 01 00
	00		 je	 $LN95@LoadString@10
  00039	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0003c	88 55 e9	 mov	 BYTE PTR __k$[ebp+1], dl
  0003f	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  00042	84 d2		 test	 dl, dl
  00044	0f 84 5e 01 00
	00		 je	 $LN94@LoadString@10
  0004a	b1 eb		 mov	 cl, -21			; ffffffebH
  0004c	32 d1		 xor	 dl, cl
  0004e	88 55 ea	 mov	 BYTE PTR __k$[ebp+2], dl
  00051	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  00054	84 d2		 test	 dl, dl
  00056	0f 84 46 01 00
	00		 je	 $LN93@LoadString@10
  0005c	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0005f	88 55 eb	 mov	 BYTE PTR __k$[ebp+3], dl
  00062	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  00065	84 d2		 test	 dl, dl
  00067	0f 84 2f 01 00
	00		 je	 $LN92@LoadString@10
  0006d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00070	88 55 ec	 mov	 BYTE PTR __k$[ebp+4], dl
  00073	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00076	84 d2		 test	 dl, dl
  00078	0f 84 18 01 00
	00		 je	 $LN91@LoadString@10
  0007e	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00081	88 55 ed	 mov	 BYTE PTR __k$[ebp+5], dl
  00084	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00087	84 d2		 test	 dl, dl
  00089	0f 84 02 01 00
	00		 je	 $LN90@LoadString@10
  0008f	32 d1		 xor	 dl, cl
  00091	88 55 ee	 mov	 BYTE PTR __k$[ebp+6], dl
  00094	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  00097	84 d2		 test	 dl, dl
  00099	0f 84 ec 00 00
	00		 je	 $LN89@LoadString@10
  0009f	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000a2	88 55 ef	 mov	 BYTE PTR __k$[ebp+7], dl
  000a5	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  000a8	84 d2		 test	 dl, dl
  000aa	0f 84 d5 00 00
	00		 je	 $LN88@LoadString@10
  000b0	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000b3	88 55 f0	 mov	 BYTE PTR __k$[ebp+8], dl
  000b6	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  000b9	84 d2		 test	 dl, dl
  000bb	0f 84 be 00 00
	00		 je	 $LN87@LoadString@10
  000c1	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000c4	88 55 f1	 mov	 BYTE PTR __k$[ebp+9], dl
  000c7	8a 50 0a	 mov	 dl, BYTE PTR [eax+10]
  000ca	84 d2		 test	 dl, dl
  000cc	0f 84 a8 00 00
	00		 je	 $LN86@LoadString@10
  000d2	32 d1		 xor	 dl, cl
  000d4	88 55 f2	 mov	 BYTE PTR __k$[ebp+10], dl
  000d7	8a 50 0b	 mov	 dl, BYTE PTR [eax+11]
  000da	84 d2		 test	 dl, dl
  000dc	0f 84 92 00 00
	00		 je	 $LN85@LoadString@10
  000e2	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000e5	88 55 f3	 mov	 BYTE PTR __k$[ebp+11], dl
  000e8	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]
  000eb	84 d2		 test	 dl, dl
  000ed	74 7f		 je	 SHORT $LN84@LoadString@10
  000ef	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000f2	88 55 f4	 mov	 BYTE PTR __k$[ebp+12], dl
  000f5	8a 50 0d	 mov	 dl, BYTE PTR [eax+13]
  000f8	84 d2		 test	 dl, dl
  000fa	74 6c		 je	 SHORT $LN83@LoadString@10
  000fc	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000ff	88 55 f5	 mov	 BYTE PTR __k$[ebp+13], dl
  00102	8a 50 0e	 mov	 dl, BYTE PTR [eax+14]
  00105	84 d2		 test	 dl, dl
  00107	74 5a		 je	 SHORT $LN82@LoadString@10
  00109	32 d1		 xor	 dl, cl
  0010b	80 78 0f 00	 cmp	 BYTE PTR [eax+15], 0
  0010f	88 55 f6	 mov	 BYTE PTR __k$[ebp+14], dl
  00112	0f 84 a0 00 00
	00		 je	 $LN111@LoadString@10
  00118	8a 50 10	 mov	 dl, BYTE PTR [eax+16]
  0011b	84 d2		 test	 dl, dl
  0011d	74 3e		 je	 SHORT $LN80@LoadString@10
  0011f	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00122	88 55 f8	 mov	 BYTE PTR __k$[ebp+16], dl
  00125	8a 50 11	 mov	 dl, BYTE PTR [eax+17]
  00128	84 d2		 test	 dl, dl
  0012a	74 2b		 je	 SHORT $LN79@LoadString@10
  0012c	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0012f	88 55 f9	 mov	 BYTE PTR __k$[ebp+17], dl
  00132	8a 50 12	 mov	 dl, BYTE PTR [eax+18]
  00135	84 d2		 test	 dl, dl
  00137	74 19		 je	 SHORT $LN78@LoadString@10
  00139	8a 40 13	 mov	 al, BYTE PTR [eax+19]
  0013c	32 d1		 xor	 dl, cl
  0013e	88 55 fa	 mov	 BYTE PTR __k$[ebp+18], dl
  00141	84 c0		 test	 al, al
  00143	74 07		 je	 SHORT $LN77@LoadString@10
  00145	34 ea		 xor	 al, -22			; ffffffeaH
  00147	88 45 fb	 mov	 BYTE PTR __k$[ebp+19], al
  0014a	eb 6c		 jmp	 SHORT $LN111@LoadString@10
$LN77@LoadString@10:
  0014c	c6 45 fb ea	 mov	 BYTE PTR __k$[ebp+19], -22 ; ffffffeaH
  00150	eb 66		 jmp	 SHORT $LN111@LoadString@10
$LN78@LoadString@10:
  00152	88 4d fa	 mov	 BYTE PTR __k$[ebp+18], cl
  00155	eb 61		 jmp	 SHORT $LN111@LoadString@10
$LN79@LoadString@10:
  00157	c6 45 f9 ec	 mov	 BYTE PTR __k$[ebp+17], -20 ; ffffffecH
  0015b	eb 5b		 jmp	 SHORT $LN111@LoadString@10
$LN80@LoadString@10:
  0015d	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+16], -19 ; ffffffedH
  00161	eb 55		 jmp	 SHORT $LN111@LoadString@10
$LN82@LoadString@10:
  00163	88 4d f6	 mov	 BYTE PTR __k$[ebp+14], cl
  00166	eb 50		 jmp	 SHORT $LN111@LoadString@10
$LN83@LoadString@10:
  00168	c6 45 f5 ec	 mov	 BYTE PTR __k$[ebp+13], -20 ; ffffffecH
  0016c	eb 4a		 jmp	 SHORT $LN111@LoadString@10
$LN84@LoadString@10:
  0016e	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+12], -19 ; ffffffedH
  00172	eb 44		 jmp	 SHORT $LN111@LoadString@10
$LN85@LoadString@10:
  00174	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+11], -22 ; ffffffeaH
  00178	eb 3e		 jmp	 SHORT $LN111@LoadString@10
$LN86@LoadString@10:
  0017a	88 4d f2	 mov	 BYTE PTR __k$[ebp+10], cl
  0017d	eb 39		 jmp	 SHORT $LN111@LoadString@10
$LN87@LoadString@10:
  0017f	c6 45 f1 ec	 mov	 BYTE PTR __k$[ebp+9], -20 ; ffffffecH
  00183	eb 33		 jmp	 SHORT $LN111@LoadString@10
$LN88@LoadString@10:
  00185	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  00189	eb 2d		 jmp	 SHORT $LN111@LoadString@10
$LN89@LoadString@10:
  0018b	c6 45 ef ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  0018f	eb 27		 jmp	 SHORT $LN111@LoadString@10
$LN90@LoadString@10:
  00191	88 4d ee	 mov	 BYTE PTR __k$[ebp+6], cl
  00194	eb 22		 jmp	 SHORT $LN111@LoadString@10
$LN91@LoadString@10:
  00196	c6 45 ed ec	 mov	 BYTE PTR __k$[ebp+5], -20 ; ffffffecH
  0019a	eb 1c		 jmp	 SHORT $LN111@LoadString@10
$LN92@LoadString@10:
  0019c	c6 45 ec ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  001a0	eb 16		 jmp	 SHORT $LN111@LoadString@10
$LN93@LoadString@10:
  001a2	c6 45 eb ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  001a6	eb 10		 jmp	 SHORT $LN111@LoadString@10
$LN94@LoadString@10:
  001a8	c6 45 ea eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  001ac	eb 0a		 jmp	 SHORT $LN111@LoadString@10
$LN95@LoadString@10:
  001ae	c6 45 e9 ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  001b2	eb 04		 jmp	 SHORT $LN111@LoadString@10
$LN96@LoadString@10:
  001b4	c6 45 e8 ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN111@LoadString@10:
  001b8	6a 03		 push	 3
  001ba	8d 45 e8	 lea	 eax, DWORD PTR __k$[ebp]
  001bd	c6 45 f7 00	 mov	 BYTE PTR __k$[ebp+15], 0
  001c1	5a		 pop	 edx
$LL104@LoadString@10:
  001c2	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  001c8	83 c0 04	 add	 eax, 4
  001cb	4a		 dec	 edx
  001cc	75 f4		 jne	 SHORT $LL104@LoadString@10
  001ce	6a 0c		 push	 12			; 0000000cH
  001d0	58		 pop	 eax
$LL101@LoadString@10:
  001d1	8b c8		 mov	 ecx, eax
  001d3	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  001d9	79 05		 jns	 SHORT $LN112@LoadString@10
  001db	49		 dec	 ecx
  001dc	83 c9 fc	 or	 ecx, -4			; fffffffcH
  001df	41		 inc	 ecx
$LN112@LoadString@10:
  001e0	b2 ed		 mov	 dl, -19			; ffffffedH
  001e2	2a d1		 sub	 dl, cl
  001e4	30 54 05 e8	 xor	 BYTE PTR __k$[ebp+eax], dl
  001e8	40		 inc	 eax
  001e9	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  001ec	7c e3		 jl	 SHORT $LL101@LoadString@10

; 163  : 		LoadString(_k, d, b, i);

  001ee	ff 75 14	 push	 DWORD PTR _i$[ebp]
  001f1	8b 4d e4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  001f4	57		 push	 edi
  001f5	56		 push	 esi
  001f6	8d 45 e8	 lea	 eax, DWORD PTR __k$[ebp]
  001f9	50		 push	 eax
  001fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 164  : 	}

  00200	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00203	5f		 pop	 edi
  00204	33 cd		 xor	 ecx, ebp
  00206	5e		 pop	 esi
  00207	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0020c	c9		 leave
  0020d	c2 10 00	 ret	 16			; 00000010H
??$LoadString_e@$0BA@@ioINILoader@@QAEXAAY0BA@$$CBDAAY00$$CBDPADH@Z ENDP ; ioINILoader::LoadString_e<16>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??$LoadString_e@$06@ioINILoader@@QAEXAAY06$$CBDAAY00$$CBDPADH@Z ; ioINILoader::LoadString_e<7>
; Function compile flags: /Ogsp
;	COMDAT ??$LoadString_e@$06@ioINILoader@@QAEXAAY06$$CBDAAY00$$CBDPADH@Z
_TEXT	SEGMENT
__k$ = -16						; size = 7
__$ArrayPad$ = -4					; size = 4
_k$ = 8							; size = 4
_d$ = 12						; size = 4
_b$ = 16						; size = 4
_i$ = 20						; size = 4
??$LoadString_e@$06@ioINILoader@@QAEXAAY06$$CBDAAY00$$CBDPADH@Z PROC ; ioINILoader::LoadString_e<7>, COMDAT
; _this$ = ecx

; 161  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]

; 162  : 		_ENCSTR(k, _k);

  00013	8a 10		 mov	 dl, BYTE PTR [eax]
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	8b 75 0c	 mov	 esi, DWORD PTR _d$[ebp]
  0001a	57		 push	 edi
  0001b	8b 7d 10	 mov	 edi, DWORD PTR _b$[ebp]
  0001e	84 d2		 test	 dl, dl
  00020	0f 84 c0 00 00
	00		 je	 $LN96@LoadString@11
  00026	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00029	88 55 f0	 mov	 BYTE PTR __k$[ebp], dl
  0002c	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002f	84 d2		 test	 dl, dl
  00031	0f 84 a9 00 00
	00		 je	 $LN95@LoadString@11
  00037	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0003a	88 55 f1	 mov	 BYTE PTR __k$[ebp+1], dl
  0003d	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
  00040	84 d2		 test	 dl, dl
  00042	0f 84 92 00 00
	00		 je	 $LN94@LoadString@11
  00048	80 f2 eb	 xor	 dl, -21			; ffffffebH
  0004b	88 55 f2	 mov	 BYTE PTR __k$[ebp+2], dl
  0004e	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  00051	84 d2		 test	 dl, dl
  00053	74 7f		 je	 SHORT $LN93@LoadString@11
  00055	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00058	88 55 f3	 mov	 BYTE PTR __k$[ebp+3], dl
  0005b	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0005e	84 d2		 test	 dl, dl
  00060	74 6c		 je	 SHORT $LN92@LoadString@11
  00062	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00065	88 55 f4	 mov	 BYTE PTR __k$[ebp+4], dl
  00068	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  0006b	84 d2		 test	 dl, dl
  0006d	74 59		 je	 SHORT $LN91@LoadString@11
  0006f	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00072	80 78 06 00	 cmp	 BYTE PTR [eax+6], 0
  00076	88 55 f5	 mov	 BYTE PTR __k$[ebp+5], dl
  00079	74 6f		 je	 SHORT $LN1@LoadString@11
  0007b	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0007e	84 d2		 test	 dl, dl
  00080	74 40		 je	 SHORT $LN89@LoadString@11
  00082	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00085	88 55 f7	 mov	 BYTE PTR __k$[ebp+7], dl
  00088	8a 50 08	 mov	 dl, BYTE PTR [eax+8]
  0008b	84 d2		 test	 dl, dl
  0008d	74 2d		 je	 SHORT $LN88@LoadString@11
  0008f	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00092	88 55 f8	 mov	 BYTE PTR __k$[ebp+8], dl
  00095	8a 50 09	 mov	 dl, BYTE PTR [eax+9]
  00098	84 d2		 test	 dl, dl
  0009a	74 1a		 je	 SHORT $LN87@LoadString@11
  0009c	8a 40 0a	 mov	 al, BYTE PTR [eax+10]
  0009f	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000a2	88 55 f9	 mov	 BYTE PTR __k$[ebp+9], dl
  000a5	84 c0		 test	 al, al
  000a7	74 07		 je	 SHORT $LN86@LoadString@11
  000a9	34 eb		 xor	 al, -21			; ffffffebH
  000ab	88 45 fa	 mov	 BYTE PTR __k$[ebp+10], al
  000ae	eb 3a		 jmp	 SHORT $LN1@LoadString@11
$LN86@LoadString@11:
  000b0	c6 45 fa eb	 mov	 BYTE PTR __k$[ebp+10], -21 ; ffffffebH
  000b4	eb 34		 jmp	 SHORT $LN1@LoadString@11
$LN87@LoadString@11:
  000b6	c6 45 f9 ec	 mov	 BYTE PTR __k$[ebp+9], -20 ; ffffffecH
  000ba	eb 2e		 jmp	 SHORT $LN1@LoadString@11
$LN88@LoadString@11:
  000bc	c6 45 f8 ed	 mov	 BYTE PTR __k$[ebp+8], -19 ; ffffffedH
  000c0	eb 28		 jmp	 SHORT $LN1@LoadString@11
$LN89@LoadString@11:
  000c2	c6 45 f7 ea	 mov	 BYTE PTR __k$[ebp+7], -22 ; ffffffeaH
  000c6	eb 22		 jmp	 SHORT $LN1@LoadString@11
$LN91@LoadString@11:
  000c8	c6 45 f5 ec	 mov	 BYTE PTR __k$[ebp+5], -20 ; ffffffecH
  000cc	eb 1c		 jmp	 SHORT $LN1@LoadString@11
$LN92@LoadString@11:
  000ce	c6 45 f4 ed	 mov	 BYTE PTR __k$[ebp+4], -19 ; ffffffedH
  000d2	eb 16		 jmp	 SHORT $LN1@LoadString@11
$LN93@LoadString@11:
  000d4	c6 45 f3 ea	 mov	 BYTE PTR __k$[ebp+3], -22 ; ffffffeaH
  000d8	eb 10		 jmp	 SHORT $LN1@LoadString@11
$LN94@LoadString@11:
  000da	c6 45 f2 eb	 mov	 BYTE PTR __k$[ebp+2], -21 ; ffffffebH
  000de	eb 0a		 jmp	 SHORT $LN1@LoadString@11
$LN95@LoadString@11:
  000e0	c6 45 f1 ec	 mov	 BYTE PTR __k$[ebp+1], -20 ; ffffffecH
  000e4	eb 04		 jmp	 SHORT $LN1@LoadString@11
$LN96@LoadString@11:
  000e6	c6 45 f0 ed	 mov	 BYTE PTR __k$[ebp], -19	; ffffffedH
$LN1@LoadString@11:
  000ea	81 75 f0 ed ec
	eb ea		 xor	 DWORD PTR __k$[ebp], -353637139 ; eaebecedH
  000f1	6a 04		 push	 4
  000f3	c6 45 f6 00	 mov	 BYTE PTR __k$[ebp+6], 0
  000f7	58		 pop	 eax
$LL101@LoadString@11:
  000f8	8b d0		 mov	 edx, eax
  000fa	81 e2 03 00 00
	80		 and	 edx, -2147483645	; 80000003H
  00100	79 05		 jns	 SHORT $LN111@LoadString@11
  00102	4a		 dec	 edx
  00103	83 ca fc	 or	 edx, -4			; fffffffcH
  00106	42		 inc	 edx
$LN111@LoadString@11:
  00107	b3 ed		 mov	 bl, -19			; ffffffedH
  00109	2a da		 sub	 bl, dl
  0010b	30 5c 05 f0	 xor	 BYTE PTR __k$[ebp+eax], bl
  0010f	40		 inc	 eax
  00110	83 f8 06	 cmp	 eax, 6
  00113	7c e3		 jl	 SHORT $LL101@LoadString@11

; 163  : 		LoadString(_k, d, b, i);

  00115	ff 75 14	 push	 DWORD PTR _i$[ebp]
  00118	8d 45 f0	 lea	 eax, DWORD PTR __k$[ebp]
  0011b	57		 push	 edi
  0011c	56		 push	 esi
  0011d	50		 push	 eax
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 164  : 	}

  00124	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00127	5f		 pop	 edi
  00128	5e		 pop	 esi
  00129	33 cd		 xor	 ecx, ebp
  0012b	5b		 pop	 ebx
  0012c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00131	c9		 leave
  00132	c2 10 00	 ret	 16			; 00000010H
??$LoadString_e@$06@ioINILoader@@QAEXAAY06$$CBDAAY00$$CBDPADH@Z ENDP ; ioINILoader::LoadString_e<7>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@G@std@@GG@std@@YAXAAV?$allocator@G@0@PAG$$QAG@Z ; std::_Cons_val<std::allocator<unsigned short>,unsigned short,unsigned short>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@G@std@@GG@std@@YAXAAV?$allocator@G@0@PAG$$QAG@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@G@std@@GG@std@@YAXAAV?$allocator@G@0@PAG$$QAG@Z PROC ; std::_Cons_val<std::allocator<unsigned short>,unsigned short,unsigned short>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $LN7@Cons_val
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	66 8b 09	 mov	 cx, WORD PTR [ecx]
  00010	66 89 08	 mov	 WORD PTR [eax], cx
$LN7@Cons_val:

; 281  : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Cons_val@V?$allocator@G@std@@GG@std@@YAXAAV?$allocator@G@0@PAG$$QAG@Z ENDP ; std::_Cons_val<std::allocator<unsigned short>,unsigned short,unsigned short>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@G@std@@GAAG@std@@YAXAAV?$allocator@G@0@PAGAAG@Z ; std::_Cons_val<std::allocator<unsigned short>,unsigned short,unsigned short &>
; Function compile flags: /Ogsp
;	COMDAT ??$_Cons_val@V?$allocator@G@std@@GAAG@std@@YAXAAV?$allocator@G@0@PAGAAG@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@G@std@@GAAG@std@@YAXAAV?$allocator@G@0@PAGAAG@Z PROC ; std::_Cons_val<std::allocator<unsigned short>,unsigned short,unsigned short &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $LN7@Cons_val@2
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	66 8b 09	 mov	 cx, WORD PTR [ecx]
  00010	66 89 08	 mov	 WORD PTR [eax], cx
$LN7@Cons_val@2:

; 281  : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Cons_val@V?$allocator@G@std@@GAAG@std@@YAXAAV?$allocator@G@0@PAGAAG@Z ENDP ; std::_Cons_val<std::allocator<unsigned short>,unsigned short,unsigned short &>
_TEXT	ENDS
PUBLIC	??$_Move@PAGPAG@std@@YAPAGPAG00@Z		; std::_Move<unsigned short *,unsigned short *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAGPAG@std@@YAPAGPAG00@Z
_TEXT	SEGMENT
__Cat$517391 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAGPAG@std@@YAPAGPAG00@Z PROC			; std::_Move<unsigned short *,unsigned short *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$517391[ebp]
  00007	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Move@PAGPAG@std@@YAPAGPAG00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<unsigned short *,unsigned short *>
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00018	c9		 leave
  00019	c3		 ret	 0
??$_Move@PAGPAG@std@@YAPAGPAG00@Z ENDP			; std::_Move<unsigned short *,unsigned short *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@@Z ; std::_Destroy_range<std::allocator<unsigned short> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned short> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned short> >
_TEXT	ENDS
PUBLIC	?construct@?$allocator@G@std@@QAEXPAGABG@Z	; std::allocator<unsigned short>::construct
; Function compile flags: /Ogsp
;	COMDAT ?construct@?$allocator@G@std@@QAEXPAGABG@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@G@std@@QAEXPAGABG@Z PROC		; std::allocator<unsigned short>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 		_Construct(_Ptr, _Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $LN5@construct@3
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	66 8b 09	 mov	 cx, WORD PTR [ecx]
  00010	66 89 08	 mov	 WORD PTR [eax], cx
$LN5@construct@3:

; 198  : 		}

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
?construct@?$allocator@G@std@@QAEXPAGABG@Z ENDP		; std::allocator<unsigned short>::construct
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::max_size
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::max_size, COMDAT
; _this$ = ecx

; 874  : 		return (this->_Alval.max_size());

  00000	b8 cc cc cc 0c	 mov	 eax, 214748364		; 0cccccccH

; 875  : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::max_size
_TEXT	ENDS
PUBLIC	??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >,bool>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000f	8a 09		 mov	 cl, BYTE PTR [ecx]
  00011	88 48 04	 mov	 BYTE PTR [eax+4], cl

; 146  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::operator--
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 277  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 278  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 279  : 		if (this->_Getcont() == 0
; 280  : 			|| this->_Ptr == 0)
; 281  : 			{	// report error
; 282  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 283  : 			_SCL_SECURE_OUT_OF_RANGE;
; 284  : 			}
; 285  : 
; 286  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 287  : 		--(*(_Mybase *)this);
; 288  : 		if (_Ptrsav == this->_Ptr)
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 291  : 			_SCL_SECURE_OUT_OF_RANGE;
; 292  : 			}
; 293  : 
; 294  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 295  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 296  : 
; 297  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 298  : 		--(*(_Mybase *)this);
; 299  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 300  : 
; 301  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 302  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >,std::_Iterator_base0>::operator--

; 303  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 304  : 
; 305  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 306  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::operator--
_TEXT	ENDS
PUBLIC	??$encodeString@$0BL@@ioINILoader_e@@AAEPADAAY0BL@$$CBDPAD@Z ; ioINILoader_e::encodeString<27>
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\io3dengine\ioiniloader.h
;	COMDAT ??$encodeString@$0BL@@ioINILoader_e@@AAEPADAAY0BL@$$CBDPAD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_e$ = 12						; size = 4
??$encodeString@$0BL@@ioINILoader_e@@AAEPADAAY0BL@$$CBDPAD@Z PROC ; ioINILoader_e::encodeString<27>, COMDAT
; _this$ = ecx

; 215  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 216  : 		__ENCSTR(s, e);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00006	8a 11		 mov	 dl, BYTE PTR [ecx]
  00008	8b 45 0c	 mov	 eax, DWORD PTR _e$[ebp]
  0000b	53		 push	 ebx
  0000c	84 d2		 test	 dl, dl
  0000e	0f 84 6a 04 00
	00		 je	 $LN96@encodeStri
  00014	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00017	88 10		 mov	 BYTE PTR [eax], dl
  00019	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  0001c	84 d2		 test	 dl, dl
  0001e	0f 84 54 04 00
	00		 je	 $LN95@encodeStri
  00024	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00027	88 50 01	 mov	 BYTE PTR [eax+1], dl
  0002a	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  0002d	84 d2		 test	 dl, dl
  0002f	0f 84 3d 04 00
	00		 je	 $LN94@encodeStri
  00035	b3 eb		 mov	 bl, -21			; ffffffebH
  00037	32 d3		 xor	 dl, bl
  00039	88 50 02	 mov	 BYTE PTR [eax+2], dl
  0003c	8a 51 03	 mov	 dl, BYTE PTR [ecx+3]
  0003f	84 d2		 test	 dl, dl
  00041	0f 84 25 04 00
	00		 je	 $LN93@encodeStri
  00047	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0004a	88 50 03	 mov	 BYTE PTR [eax+3], dl
  0004d	8a 51 04	 mov	 dl, BYTE PTR [ecx+4]
  00050	84 d2		 test	 dl, dl
  00052	0f 84 0e 04 00
	00		 je	 $LN92@encodeStri
  00058	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0005b	88 50 04	 mov	 BYTE PTR [eax+4], dl
  0005e	8a 51 05	 mov	 dl, BYTE PTR [ecx+5]
  00061	84 d2		 test	 dl, dl
  00063	0f 84 f7 03 00
	00		 je	 $LN91@encodeStri
  00069	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0006c	88 50 05	 mov	 BYTE PTR [eax+5], dl
  0006f	8a 51 06	 mov	 dl, BYTE PTR [ecx+6]
  00072	84 d2		 test	 dl, dl
  00074	0f 84 e1 03 00
	00		 je	 $LN90@encodeStri
  0007a	32 d3		 xor	 dl, bl
  0007c	88 50 06	 mov	 BYTE PTR [eax+6], dl
  0007f	8a 51 07	 mov	 dl, BYTE PTR [ecx+7]
  00082	84 d2		 test	 dl, dl
  00084	0f 84 cb 03 00
	00		 je	 $LN89@encodeStri
  0008a	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0008d	88 50 07	 mov	 BYTE PTR [eax+7], dl
  00090	8a 51 08	 mov	 dl, BYTE PTR [ecx+8]
  00093	84 d2		 test	 dl, dl
  00095	0f 84 b4 03 00
	00		 je	 $LN88@encodeStri
  0009b	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0009e	88 50 08	 mov	 BYTE PTR [eax+8], dl
  000a1	8a 51 09	 mov	 dl, BYTE PTR [ecx+9]
  000a4	84 d2		 test	 dl, dl
  000a6	0f 84 9d 03 00
	00		 je	 $LN87@encodeStri
  000ac	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000af	88 50 09	 mov	 BYTE PTR [eax+9], dl
  000b2	8a 51 0a	 mov	 dl, BYTE PTR [ecx+10]
  000b5	84 d2		 test	 dl, dl
  000b7	0f 84 87 03 00
	00		 je	 $LN86@encodeStri
  000bd	32 d3		 xor	 dl, bl
  000bf	88 50 0a	 mov	 BYTE PTR [eax+10], dl
  000c2	8a 51 0b	 mov	 dl, BYTE PTR [ecx+11]
  000c5	84 d2		 test	 dl, dl
  000c7	0f 84 71 03 00
	00		 je	 $LN85@encodeStri
  000cd	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000d0	88 50 0b	 mov	 BYTE PTR [eax+11], dl
  000d3	8a 51 0c	 mov	 dl, BYTE PTR [ecx+12]
  000d6	84 d2		 test	 dl, dl
  000d8	0f 84 5a 03 00
	00		 je	 $LN84@encodeStri
  000de	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000e1	88 50 0c	 mov	 BYTE PTR [eax+12], dl
  000e4	8a 51 0d	 mov	 dl, BYTE PTR [ecx+13]
  000e7	84 d2		 test	 dl, dl
  000e9	0f 84 43 03 00
	00		 je	 $LN83@encodeStri
  000ef	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000f2	88 50 0d	 mov	 BYTE PTR [eax+13], dl
  000f5	8a 51 0e	 mov	 dl, BYTE PTR [ecx+14]
  000f8	84 d2		 test	 dl, dl
  000fa	0f 84 2d 03 00
	00		 je	 $LN82@encodeStri
  00100	32 d3		 xor	 dl, bl
  00102	88 50 0e	 mov	 BYTE PTR [eax+14], dl
  00105	8a 51 0f	 mov	 dl, BYTE PTR [ecx+15]
  00108	84 d2		 test	 dl, dl
  0010a	0f 84 17 03 00
	00		 je	 $LN81@encodeStri
  00110	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00113	88 50 0f	 mov	 BYTE PTR [eax+15], dl
  00116	8a 51 10	 mov	 dl, BYTE PTR [ecx+16]
  00119	84 d2		 test	 dl, dl
  0011b	0f 84 00 03 00
	00		 je	 $LN80@encodeStri
  00121	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00124	88 50 10	 mov	 BYTE PTR [eax+16], dl
  00127	8a 51 11	 mov	 dl, BYTE PTR [ecx+17]
  0012a	84 d2		 test	 dl, dl
  0012c	0f 84 e9 02 00
	00		 je	 $LN79@encodeStri
  00132	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00135	88 50 11	 mov	 BYTE PTR [eax+17], dl
  00138	8a 51 12	 mov	 dl, BYTE PTR [ecx+18]
  0013b	84 d2		 test	 dl, dl
  0013d	0f 84 d3 02 00
	00		 je	 $LN78@encodeStri
  00143	32 d3		 xor	 dl, bl
  00145	88 50 12	 mov	 BYTE PTR [eax+18], dl
  00148	8a 51 13	 mov	 dl, BYTE PTR [ecx+19]
  0014b	84 d2		 test	 dl, dl
  0014d	0f 84 bd 02 00
	00		 je	 $LN77@encodeStri
  00153	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00156	88 50 13	 mov	 BYTE PTR [eax+19], dl
  00159	8a 51 14	 mov	 dl, BYTE PTR [ecx+20]
  0015c	84 d2		 test	 dl, dl
  0015e	0f 84 a6 02 00
	00		 je	 $LN76@encodeStri
  00164	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00167	88 50 14	 mov	 BYTE PTR [eax+20], dl
  0016a	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  0016d	84 d2		 test	 dl, dl
  0016f	0f 84 8f 02 00
	00		 je	 $LN75@encodeStri
  00175	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00178	88 50 15	 mov	 BYTE PTR [eax+21], dl
  0017b	8a 51 16	 mov	 dl, BYTE PTR [ecx+22]
  0017e	84 d2		 test	 dl, dl
  00180	0f 84 79 02 00
	00		 je	 $LN74@encodeStri
  00186	32 d3		 xor	 dl, bl
  00188	88 50 16	 mov	 BYTE PTR [eax+22], dl
  0018b	8a 51 17	 mov	 dl, BYTE PTR [ecx+23]
  0018e	84 d2		 test	 dl, dl
  00190	0f 84 60 02 00
	00		 je	 $LN73@encodeStri
  00196	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00199	88 50 17	 mov	 BYTE PTR [eax+23], dl
  0019c	8a 51 18	 mov	 dl, BYTE PTR [ecx+24]
  0019f	84 d2		 test	 dl, dl
  001a1	0f 84 46 02 00
	00		 je	 $LN72@encodeStri
  001a7	80 f2 ed	 xor	 dl, -19			; ffffffedH
  001aa	88 50 18	 mov	 BYTE PTR [eax+24], dl
  001ad	8a 51 19	 mov	 dl, BYTE PTR [ecx+25]
  001b0	84 d2		 test	 dl, dl
  001b2	0f 84 2c 02 00
	00		 je	 $LN71@encodeStri
  001b8	80 f2 ec	 xor	 dl, -20			; ffffffecH
  001bb	88 50 19	 mov	 BYTE PTR [eax+25], dl
  001be	8a 51 1a	 mov	 dl, BYTE PTR [ecx+26]
  001c1	84 d2		 test	 dl, dl
  001c3	0f 84 13 02 00
	00		 je	 $LN70@encodeStri
  001c9	32 d3		 xor	 dl, bl
  001cb	88 50 1a	 mov	 BYTE PTR [eax+26], dl
  001ce	8a 51 1b	 mov	 dl, BYTE PTR [ecx+27]
  001d1	84 d2		 test	 dl, dl
  001d3	0f 84 fa 01 00
	00		 je	 $LN69@encodeStri
  001d9	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  001dc	88 50 1b	 mov	 BYTE PTR [eax+27], dl
  001df	8a 51 1c	 mov	 dl, BYTE PTR [ecx+28]
  001e2	84 d2		 test	 dl, dl
  001e4	0f 84 e0 01 00
	00		 je	 $LN68@encodeStri
  001ea	80 f2 ed	 xor	 dl, -19			; ffffffedH
  001ed	88 50 1c	 mov	 BYTE PTR [eax+28], dl
  001f0	8a 51 1d	 mov	 dl, BYTE PTR [ecx+29]
  001f3	84 d2		 test	 dl, dl
  001f5	0f 84 c6 01 00
	00		 je	 $LN67@encodeStri
  001fb	80 f2 ec	 xor	 dl, -20			; ffffffecH
  001fe	88 50 1d	 mov	 BYTE PTR [eax+29], dl
  00201	8a 51 1e	 mov	 dl, BYTE PTR [ecx+30]
  00204	84 d2		 test	 dl, dl
  00206	0f 84 ad 01 00
	00		 je	 $LN66@encodeStri
  0020c	32 d3		 xor	 dl, bl
  0020e	88 50 1e	 mov	 BYTE PTR [eax+30], dl
  00211	8a 51 1f	 mov	 dl, BYTE PTR [ecx+31]
  00214	84 d2		 test	 dl, dl
  00216	0f 84 94 01 00
	00		 je	 $LN65@encodeStri
  0021c	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0021f	88 50 1f	 mov	 BYTE PTR [eax+31], dl
  00222	8a 51 20	 mov	 dl, BYTE PTR [ecx+32]
  00225	84 d2		 test	 dl, dl
  00227	0f 84 7a 01 00
	00		 je	 $LN64@encodeStri
  0022d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00230	88 50 20	 mov	 BYTE PTR [eax+32], dl
  00233	8a 51 21	 mov	 dl, BYTE PTR [ecx+33]
  00236	84 d2		 test	 dl, dl
  00238	0f 84 60 01 00
	00		 je	 $LN63@encodeStri
  0023e	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00241	88 50 21	 mov	 BYTE PTR [eax+33], dl
  00244	8a 51 22	 mov	 dl, BYTE PTR [ecx+34]
  00247	84 d2		 test	 dl, dl
  00249	0f 84 47 01 00
	00		 je	 $LN62@encodeStri
  0024f	32 d3		 xor	 dl, bl
  00251	88 50 22	 mov	 BYTE PTR [eax+34], dl
  00254	8a 51 23	 mov	 dl, BYTE PTR [ecx+35]
  00257	84 d2		 test	 dl, dl
  00259	0f 84 2e 01 00
	00		 je	 $LN61@encodeStri
  0025f	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00262	88 50 23	 mov	 BYTE PTR [eax+35], dl
  00265	8a 51 24	 mov	 dl, BYTE PTR [ecx+36]
  00268	84 d2		 test	 dl, dl
  0026a	0f 84 14 01 00
	00		 je	 $LN60@encodeStri
  00270	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00273	88 50 24	 mov	 BYTE PTR [eax+36], dl
  00276	8a 51 25	 mov	 dl, BYTE PTR [ecx+37]
  00279	84 d2		 test	 dl, dl
  0027b	0f 84 fa 00 00
	00		 je	 $LN59@encodeStri
  00281	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00284	88 50 25	 mov	 BYTE PTR [eax+37], dl
  00287	8a 51 26	 mov	 dl, BYTE PTR [ecx+38]
  0028a	84 d2		 test	 dl, dl
  0028c	0f 84 e1 00 00
	00		 je	 $LN58@encodeStri
  00292	32 d3		 xor	 dl, bl
  00294	88 50 26	 mov	 BYTE PTR [eax+38], dl
  00297	8a 51 27	 mov	 dl, BYTE PTR [ecx+39]
  0029a	84 d2		 test	 dl, dl
  0029c	0f 84 c8 00 00
	00		 je	 $LN57@encodeStri
  002a2	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  002a5	88 50 27	 mov	 BYTE PTR [eax+39], dl
  002a8	8a 51 28	 mov	 dl, BYTE PTR [ecx+40]
  002ab	84 d2		 test	 dl, dl
  002ad	0f 84 ae 00 00
	00		 je	 $LN56@encodeStri
  002b3	80 f2 ed	 xor	 dl, -19			; ffffffedH
  002b6	88 50 28	 mov	 BYTE PTR [eax+40], dl
  002b9	8a 51 29	 mov	 dl, BYTE PTR [ecx+41]
  002bc	84 d2		 test	 dl, dl
  002be	0f 84 94 00 00
	00		 je	 $LN55@encodeStri
  002c4	80 f2 ec	 xor	 dl, -20			; ffffffecH
  002c7	88 50 29	 mov	 BYTE PTR [eax+41], dl
  002ca	8a 51 2a	 mov	 dl, BYTE PTR [ecx+42]
  002cd	84 d2		 test	 dl, dl
  002cf	74 7f		 je	 SHORT $LN54@encodeStri
  002d1	32 d3		 xor	 dl, bl
  002d3	88 50 2a	 mov	 BYTE PTR [eax+42], dl
  002d6	8a 51 2b	 mov	 dl, BYTE PTR [ecx+43]
  002d9	84 d2		 test	 dl, dl
  002db	74 6a		 je	 SHORT $LN53@encodeStri
  002dd	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  002e0	88 50 2b	 mov	 BYTE PTR [eax+43], dl
  002e3	8a 51 2c	 mov	 dl, BYTE PTR [ecx+44]
  002e6	84 d2		 test	 dl, dl
  002e8	74 54		 je	 SHORT $LN52@encodeStri
  002ea	80 f2 ed	 xor	 dl, -19			; ffffffedH
  002ed	88 50 2c	 mov	 BYTE PTR [eax+44], dl
  002f0	8a 51 2d	 mov	 dl, BYTE PTR [ecx+45]
  002f3	84 d2		 test	 dl, dl
  002f5	74 3e		 je	 SHORT $LN51@encodeStri
  002f7	80 f2 ec	 xor	 dl, -20			; ffffffecH
  002fa	88 50 2d	 mov	 BYTE PTR [eax+45], dl
  002fd	8a 51 2e	 mov	 dl, BYTE PTR [ecx+46]
  00300	84 d2		 test	 dl, dl
  00302	74 29		 je	 SHORT $LN50@encodeStri
  00304	32 d3		 xor	 dl, bl
  00306	88 50 2e	 mov	 BYTE PTR [eax+46], dl
  00309	8a 51 2f	 mov	 dl, BYTE PTR [ecx+47]
  0030c	84 d2		 test	 dl, dl
  0030e	74 14		 je	 SHORT $LN49@encodeStri
  00310	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00313	88 50 2f	 mov	 BYTE PTR [eax+47], dl
  00316	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  00319	80 f1 ed	 xor	 cl, -19			; ffffffedH
  0031c	88 48 30	 mov	 BYTE PTR [eax+48], cl
  0031f	e9 5d 01 00 00	 jmp	 $LN1@encodeStri
$LN49@encodeStri:
  00324	c6 40 2f ea	 mov	 BYTE PTR [eax+47], -22	; ffffffeaH
  00328	e9 54 01 00 00	 jmp	 $LN1@encodeStri
$LN50@encodeStri:
  0032d	88 58 2e	 mov	 BYTE PTR [eax+46], bl
  00330	e9 4c 01 00 00	 jmp	 $LN1@encodeStri
$LN51@encodeStri:
  00335	c6 40 2d ec	 mov	 BYTE PTR [eax+45], -20	; ffffffecH
  00339	e9 43 01 00 00	 jmp	 $LN1@encodeStri
$LN52@encodeStri:
  0033e	c6 40 2c ed	 mov	 BYTE PTR [eax+44], -19	; ffffffedH
  00342	e9 3a 01 00 00	 jmp	 $LN1@encodeStri
$LN53@encodeStri:
  00347	c6 40 2b ea	 mov	 BYTE PTR [eax+43], -22	; ffffffeaH
  0034b	e9 31 01 00 00	 jmp	 $LN1@encodeStri
$LN54@encodeStri:
  00350	88 58 2a	 mov	 BYTE PTR [eax+42], bl
  00353	e9 29 01 00 00	 jmp	 $LN1@encodeStri
$LN55@encodeStri:
  00358	c6 40 29 ec	 mov	 BYTE PTR [eax+41], -20	; ffffffecH
  0035c	e9 20 01 00 00	 jmp	 $LN1@encodeStri
$LN56@encodeStri:
  00361	c6 40 28 ed	 mov	 BYTE PTR [eax+40], -19	; ffffffedH
  00365	e9 17 01 00 00	 jmp	 $LN1@encodeStri
$LN57@encodeStri:
  0036a	c6 40 27 ea	 mov	 BYTE PTR [eax+39], -22	; ffffffeaH
  0036e	e9 0e 01 00 00	 jmp	 $LN1@encodeStri
$LN58@encodeStri:
  00373	88 58 26	 mov	 BYTE PTR [eax+38], bl
  00376	e9 06 01 00 00	 jmp	 $LN1@encodeStri
$LN59@encodeStri:
  0037b	c6 40 25 ec	 mov	 BYTE PTR [eax+37], -20	; ffffffecH
  0037f	e9 fd 00 00 00	 jmp	 $LN1@encodeStri
$LN60@encodeStri:
  00384	c6 40 24 ed	 mov	 BYTE PTR [eax+36], -19	; ffffffedH
  00388	e9 f4 00 00 00	 jmp	 $LN1@encodeStri
$LN61@encodeStri:
  0038d	c6 40 23 ea	 mov	 BYTE PTR [eax+35], -22	; ffffffeaH
  00391	e9 eb 00 00 00	 jmp	 $LN1@encodeStri
$LN62@encodeStri:
  00396	88 58 22	 mov	 BYTE PTR [eax+34], bl
  00399	e9 e3 00 00 00	 jmp	 $LN1@encodeStri
$LN63@encodeStri:
  0039e	c6 40 21 ec	 mov	 BYTE PTR [eax+33], -20	; ffffffecH
  003a2	e9 da 00 00 00	 jmp	 $LN1@encodeStri
$LN64@encodeStri:
  003a7	c6 40 20 ed	 mov	 BYTE PTR [eax+32], -19	; ffffffedH
  003ab	e9 d1 00 00 00	 jmp	 $LN1@encodeStri
$LN65@encodeStri:
  003b0	c6 40 1f ea	 mov	 BYTE PTR [eax+31], -22	; ffffffeaH
  003b4	e9 c8 00 00 00	 jmp	 $LN1@encodeStri
$LN66@encodeStri:
  003b9	88 58 1e	 mov	 BYTE PTR [eax+30], bl
  003bc	e9 c0 00 00 00	 jmp	 $LN1@encodeStri
$LN67@encodeStri:
  003c1	c6 40 1d ec	 mov	 BYTE PTR [eax+29], -20	; ffffffecH
  003c5	e9 b7 00 00 00	 jmp	 $LN1@encodeStri
$LN68@encodeStri:
  003ca	c6 40 1c ed	 mov	 BYTE PTR [eax+28], -19	; ffffffedH
  003ce	e9 ae 00 00 00	 jmp	 $LN1@encodeStri
$LN69@encodeStri:
  003d3	c6 40 1b ea	 mov	 BYTE PTR [eax+27], -22	; ffffffeaH
  003d7	e9 a5 00 00 00	 jmp	 $LN1@encodeStri
$LN70@encodeStri:
  003dc	88 58 1a	 mov	 BYTE PTR [eax+26], bl
  003df	e9 9d 00 00 00	 jmp	 $LN1@encodeStri
$LN71@encodeStri:
  003e4	c6 40 19 ec	 mov	 BYTE PTR [eax+25], -20	; ffffffecH
  003e8	e9 94 00 00 00	 jmp	 $LN1@encodeStri
$LN72@encodeStri:
  003ed	c6 40 18 ed	 mov	 BYTE PTR [eax+24], -19	; ffffffedH
  003f1	e9 8b 00 00 00	 jmp	 $LN1@encodeStri
$LN73@encodeStri:
  003f6	c6 40 17 ea	 mov	 BYTE PTR [eax+23], -22	; ffffffeaH
  003fa	e9 82 00 00 00	 jmp	 $LN1@encodeStri
$LN74@encodeStri:
  003ff	88 58 16	 mov	 BYTE PTR [eax+22], bl
  00402	eb 7d		 jmp	 SHORT $LN1@encodeStri
$LN75@encodeStri:
  00404	c6 40 15 ec	 mov	 BYTE PTR [eax+21], -20	; ffffffecH
  00408	eb 77		 jmp	 SHORT $LN1@encodeStri
$LN76@encodeStri:
  0040a	c6 40 14 ed	 mov	 BYTE PTR [eax+20], -19	; ffffffedH
  0040e	eb 71		 jmp	 SHORT $LN1@encodeStri
$LN77@encodeStri:
  00410	c6 40 13 ea	 mov	 BYTE PTR [eax+19], -22	; ffffffeaH
  00414	eb 6b		 jmp	 SHORT $LN1@encodeStri
$LN78@encodeStri:
  00416	88 58 12	 mov	 BYTE PTR [eax+18], bl
  00419	eb 66		 jmp	 SHORT $LN1@encodeStri
$LN79@encodeStri:
  0041b	c6 40 11 ec	 mov	 BYTE PTR [eax+17], -20	; ffffffecH
  0041f	eb 60		 jmp	 SHORT $LN1@encodeStri
$LN80@encodeStri:
  00421	c6 40 10 ed	 mov	 BYTE PTR [eax+16], -19	; ffffffedH
  00425	eb 5a		 jmp	 SHORT $LN1@encodeStri
$LN81@encodeStri:
  00427	c6 40 0f ea	 mov	 BYTE PTR [eax+15], -22	; ffffffeaH
  0042b	eb 54		 jmp	 SHORT $LN1@encodeStri
$LN82@encodeStri:
  0042d	88 58 0e	 mov	 BYTE PTR [eax+14], bl
  00430	eb 4f		 jmp	 SHORT $LN1@encodeStri
$LN83@encodeStri:
  00432	c6 40 0d ec	 mov	 BYTE PTR [eax+13], -20	; ffffffecH
  00436	eb 49		 jmp	 SHORT $LN1@encodeStri
$LN84@encodeStri:
  00438	c6 40 0c ed	 mov	 BYTE PTR [eax+12], -19	; ffffffedH
  0043c	eb 43		 jmp	 SHORT $LN1@encodeStri
$LN85@encodeStri:
  0043e	c6 40 0b ea	 mov	 BYTE PTR [eax+11], -22	; ffffffeaH
  00442	eb 3d		 jmp	 SHORT $LN1@encodeStri
$LN86@encodeStri:
  00444	88 58 0a	 mov	 BYTE PTR [eax+10], bl
  00447	eb 38		 jmp	 SHORT $LN1@encodeStri
$LN87@encodeStri:
  00449	c6 40 09 ec	 mov	 BYTE PTR [eax+9], -20	; ffffffecH
  0044d	eb 32		 jmp	 SHORT $LN1@encodeStri
$LN88@encodeStri:
  0044f	c6 40 08 ed	 mov	 BYTE PTR [eax+8], -19	; ffffffedH
  00453	eb 2c		 jmp	 SHORT $LN1@encodeStri
$LN89@encodeStri:
  00455	c6 40 07 ea	 mov	 BYTE PTR [eax+7], -22	; ffffffeaH
  00459	eb 26		 jmp	 SHORT $LN1@encodeStri
$LN90@encodeStri:
  0045b	88 58 06	 mov	 BYTE PTR [eax+6], bl
  0045e	eb 21		 jmp	 SHORT $LN1@encodeStri
$LN91@encodeStri:
  00460	c6 40 05 ec	 mov	 BYTE PTR [eax+5], -20	; ffffffecH
  00464	eb 1b		 jmp	 SHORT $LN1@encodeStri
$LN92@encodeStri:
  00466	c6 40 04 ed	 mov	 BYTE PTR [eax+4], -19	; ffffffedH
  0046a	eb 15		 jmp	 SHORT $LN1@encodeStri
$LN93@encodeStri:
  0046c	c6 40 03 ea	 mov	 BYTE PTR [eax+3], -22	; ffffffeaH
  00470	eb 0f		 jmp	 SHORT $LN1@encodeStri
$LN94@encodeStri:
  00472	c6 40 02 eb	 mov	 BYTE PTR [eax+2], -21	; ffffffebH
  00476	eb 09		 jmp	 SHORT $LN1@encodeStri
$LN95@encodeStri:
  00478	c6 40 01 ec	 mov	 BYTE PTR [eax+1], -20	; ffffffecH
  0047c	eb 03		 jmp	 SHORT $LN1@encodeStri
$LN96@encodeStri:
  0047e	c6 00 ed	 mov	 BYTE PTR [eax], -19	; ffffffedH
$LN1@encodeStri:
  00481	6a 06		 push	 6
  00483	5a		 pop	 edx
  00484	8b c8		 mov	 ecx, eax
  00486	c6 40 1a 00	 mov	 BYTE PTR [eax+26], 0
  0048a	5b		 pop	 ebx
$LL104@encodeStri:
  0048b	81 31 ed ec eb
	ea		 xor	 DWORD PTR [ecx], -353637139 ; eaebecedH
  00491	83 c1 04	 add	 ecx, 4
  00494	4a		 dec	 edx
  00495	75 f4		 jne	 SHORT $LL104@encodeStri
  00497	56		 push	 esi
  00498	6a 18		 push	 24			; 00000018H
  0049a	5e		 pop	 esi
$LL101@encodeStri:
  0049b	8b ce		 mov	 ecx, esi
  0049d	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  004a3	79 05		 jns	 SHORT $LN111@encodeStri
  004a5	49		 dec	 ecx
  004a6	83 c9 fc	 or	 ecx, -4			; fffffffcH
  004a9	41		 inc	 ecx
$LN111@encodeStri:
  004aa	b2 ed		 mov	 dl, -19			; ffffffedH
  004ac	2a d1		 sub	 dl, cl
  004ae	30 14 06	 xor	 BYTE PTR [esi+eax], dl
  004b1	46		 inc	 esi
  004b2	83 fe 1a	 cmp	 esi, 26			; 0000001aH
  004b5	7c e4		 jl	 SHORT $LL101@encodeStri
  004b7	5e		 pop	 esi

; 217  : 		return e;
; 218  : 	}

  004b8	5d		 pop	 ebp
  004b9	c2 08 00	 ret	 8
??$encodeString@$0BL@@ioINILoader_e@@AAEPADAAY0BL@$$CBDPAD@Z ENDP ; ioINILoader_e::encodeString<27>
_TEXT	ENDS
PUBLIC	??$encodeString@$0BO@@ioINILoader_e@@AAEPADAAY0BO@$$CBDPAD@Z ; ioINILoader_e::encodeString<30>
; Function compile flags: /Ogsp
;	COMDAT ??$encodeString@$0BO@@ioINILoader_e@@AAEPADAAY0BO@$$CBDPAD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_e$ = 12						; size = 4
??$encodeString@$0BO@@ioINILoader_e@@AAEPADAAY0BO@$$CBDPAD@Z PROC ; ioINILoader_e::encodeString<30>, COMDAT
; _this$ = ecx

; 215  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 216  : 		__ENCSTR(s, e);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00006	8a 11		 mov	 dl, BYTE PTR [ecx]
  00008	8b 45 0c	 mov	 eax, DWORD PTR _e$[ebp]
  0000b	53		 push	 ebx
  0000c	84 d2		 test	 dl, dl
  0000e	0f 84 6a 04 00
	00		 je	 $LN96@encodeStri@2
  00014	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00017	88 10		 mov	 BYTE PTR [eax], dl
  00019	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  0001c	84 d2		 test	 dl, dl
  0001e	0f 84 54 04 00
	00		 je	 $LN95@encodeStri@2
  00024	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00027	88 50 01	 mov	 BYTE PTR [eax+1], dl
  0002a	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  0002d	84 d2		 test	 dl, dl
  0002f	0f 84 3d 04 00
	00		 je	 $LN94@encodeStri@2
  00035	b3 eb		 mov	 bl, -21			; ffffffebH
  00037	32 d3		 xor	 dl, bl
  00039	88 50 02	 mov	 BYTE PTR [eax+2], dl
  0003c	8a 51 03	 mov	 dl, BYTE PTR [ecx+3]
  0003f	84 d2		 test	 dl, dl
  00041	0f 84 25 04 00
	00		 je	 $LN93@encodeStri@2
  00047	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0004a	88 50 03	 mov	 BYTE PTR [eax+3], dl
  0004d	8a 51 04	 mov	 dl, BYTE PTR [ecx+4]
  00050	84 d2		 test	 dl, dl
  00052	0f 84 0e 04 00
	00		 je	 $LN92@encodeStri@2
  00058	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0005b	88 50 04	 mov	 BYTE PTR [eax+4], dl
  0005e	8a 51 05	 mov	 dl, BYTE PTR [ecx+5]
  00061	84 d2		 test	 dl, dl
  00063	0f 84 f7 03 00
	00		 je	 $LN91@encodeStri@2
  00069	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0006c	88 50 05	 mov	 BYTE PTR [eax+5], dl
  0006f	8a 51 06	 mov	 dl, BYTE PTR [ecx+6]
  00072	84 d2		 test	 dl, dl
  00074	0f 84 e1 03 00
	00		 je	 $LN90@encodeStri@2
  0007a	32 d3		 xor	 dl, bl
  0007c	88 50 06	 mov	 BYTE PTR [eax+6], dl
  0007f	8a 51 07	 mov	 dl, BYTE PTR [ecx+7]
  00082	84 d2		 test	 dl, dl
  00084	0f 84 cb 03 00
	00		 je	 $LN89@encodeStri@2
  0008a	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0008d	88 50 07	 mov	 BYTE PTR [eax+7], dl
  00090	8a 51 08	 mov	 dl, BYTE PTR [ecx+8]
  00093	84 d2		 test	 dl, dl
  00095	0f 84 b4 03 00
	00		 je	 $LN88@encodeStri@2
  0009b	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0009e	88 50 08	 mov	 BYTE PTR [eax+8], dl
  000a1	8a 51 09	 mov	 dl, BYTE PTR [ecx+9]
  000a4	84 d2		 test	 dl, dl
  000a6	0f 84 9d 03 00
	00		 je	 $LN87@encodeStri@2
  000ac	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000af	88 50 09	 mov	 BYTE PTR [eax+9], dl
  000b2	8a 51 0a	 mov	 dl, BYTE PTR [ecx+10]
  000b5	84 d2		 test	 dl, dl
  000b7	0f 84 87 03 00
	00		 je	 $LN86@encodeStri@2
  000bd	32 d3		 xor	 dl, bl
  000bf	88 50 0a	 mov	 BYTE PTR [eax+10], dl
  000c2	8a 51 0b	 mov	 dl, BYTE PTR [ecx+11]
  000c5	84 d2		 test	 dl, dl
  000c7	0f 84 71 03 00
	00		 je	 $LN85@encodeStri@2
  000cd	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000d0	88 50 0b	 mov	 BYTE PTR [eax+11], dl
  000d3	8a 51 0c	 mov	 dl, BYTE PTR [ecx+12]
  000d6	84 d2		 test	 dl, dl
  000d8	0f 84 5a 03 00
	00		 je	 $LN84@encodeStri@2
  000de	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000e1	88 50 0c	 mov	 BYTE PTR [eax+12], dl
  000e4	8a 51 0d	 mov	 dl, BYTE PTR [ecx+13]
  000e7	84 d2		 test	 dl, dl
  000e9	0f 84 43 03 00
	00		 je	 $LN83@encodeStri@2
  000ef	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000f2	88 50 0d	 mov	 BYTE PTR [eax+13], dl
  000f5	8a 51 0e	 mov	 dl, BYTE PTR [ecx+14]
  000f8	84 d2		 test	 dl, dl
  000fa	0f 84 2d 03 00
	00		 je	 $LN82@encodeStri@2
  00100	32 d3		 xor	 dl, bl
  00102	88 50 0e	 mov	 BYTE PTR [eax+14], dl
  00105	8a 51 0f	 mov	 dl, BYTE PTR [ecx+15]
  00108	84 d2		 test	 dl, dl
  0010a	0f 84 17 03 00
	00		 je	 $LN81@encodeStri@2
  00110	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00113	88 50 0f	 mov	 BYTE PTR [eax+15], dl
  00116	8a 51 10	 mov	 dl, BYTE PTR [ecx+16]
  00119	84 d2		 test	 dl, dl
  0011b	0f 84 00 03 00
	00		 je	 $LN80@encodeStri@2
  00121	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00124	88 50 10	 mov	 BYTE PTR [eax+16], dl
  00127	8a 51 11	 mov	 dl, BYTE PTR [ecx+17]
  0012a	84 d2		 test	 dl, dl
  0012c	0f 84 e9 02 00
	00		 je	 $LN79@encodeStri@2
  00132	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00135	88 50 11	 mov	 BYTE PTR [eax+17], dl
  00138	8a 51 12	 mov	 dl, BYTE PTR [ecx+18]
  0013b	84 d2		 test	 dl, dl
  0013d	0f 84 d3 02 00
	00		 je	 $LN78@encodeStri@2
  00143	32 d3		 xor	 dl, bl
  00145	88 50 12	 mov	 BYTE PTR [eax+18], dl
  00148	8a 51 13	 mov	 dl, BYTE PTR [ecx+19]
  0014b	84 d2		 test	 dl, dl
  0014d	0f 84 bd 02 00
	00		 je	 $LN77@encodeStri@2
  00153	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00156	88 50 13	 mov	 BYTE PTR [eax+19], dl
  00159	8a 51 14	 mov	 dl, BYTE PTR [ecx+20]
  0015c	84 d2		 test	 dl, dl
  0015e	0f 84 a6 02 00
	00		 je	 $LN76@encodeStri@2
  00164	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00167	88 50 14	 mov	 BYTE PTR [eax+20], dl
  0016a	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  0016d	84 d2		 test	 dl, dl
  0016f	0f 84 8f 02 00
	00		 je	 $LN75@encodeStri@2
  00175	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00178	88 50 15	 mov	 BYTE PTR [eax+21], dl
  0017b	8a 51 16	 mov	 dl, BYTE PTR [ecx+22]
  0017e	84 d2		 test	 dl, dl
  00180	0f 84 79 02 00
	00		 je	 $LN74@encodeStri@2
  00186	32 d3		 xor	 dl, bl
  00188	88 50 16	 mov	 BYTE PTR [eax+22], dl
  0018b	8a 51 17	 mov	 dl, BYTE PTR [ecx+23]
  0018e	84 d2		 test	 dl, dl
  00190	0f 84 60 02 00
	00		 je	 $LN73@encodeStri@2
  00196	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00199	88 50 17	 mov	 BYTE PTR [eax+23], dl
  0019c	8a 51 18	 mov	 dl, BYTE PTR [ecx+24]
  0019f	84 d2		 test	 dl, dl
  001a1	0f 84 46 02 00
	00		 je	 $LN72@encodeStri@2
  001a7	80 f2 ed	 xor	 dl, -19			; ffffffedH
  001aa	88 50 18	 mov	 BYTE PTR [eax+24], dl
  001ad	8a 51 19	 mov	 dl, BYTE PTR [ecx+25]
  001b0	84 d2		 test	 dl, dl
  001b2	0f 84 2c 02 00
	00		 je	 $LN71@encodeStri@2
  001b8	80 f2 ec	 xor	 dl, -20			; ffffffecH
  001bb	88 50 19	 mov	 BYTE PTR [eax+25], dl
  001be	8a 51 1a	 mov	 dl, BYTE PTR [ecx+26]
  001c1	84 d2		 test	 dl, dl
  001c3	0f 84 13 02 00
	00		 je	 $LN70@encodeStri@2
  001c9	32 d3		 xor	 dl, bl
  001cb	88 50 1a	 mov	 BYTE PTR [eax+26], dl
  001ce	8a 51 1b	 mov	 dl, BYTE PTR [ecx+27]
  001d1	84 d2		 test	 dl, dl
  001d3	0f 84 fa 01 00
	00		 je	 $LN69@encodeStri@2
  001d9	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  001dc	88 50 1b	 mov	 BYTE PTR [eax+27], dl
  001df	8a 51 1c	 mov	 dl, BYTE PTR [ecx+28]
  001e2	84 d2		 test	 dl, dl
  001e4	0f 84 e0 01 00
	00		 je	 $LN68@encodeStri@2
  001ea	80 f2 ed	 xor	 dl, -19			; ffffffedH
  001ed	88 50 1c	 mov	 BYTE PTR [eax+28], dl
  001f0	8a 51 1d	 mov	 dl, BYTE PTR [ecx+29]
  001f3	84 d2		 test	 dl, dl
  001f5	0f 84 c6 01 00
	00		 je	 $LN67@encodeStri@2
  001fb	80 f2 ec	 xor	 dl, -20			; ffffffecH
  001fe	88 50 1d	 mov	 BYTE PTR [eax+29], dl
  00201	8a 51 1e	 mov	 dl, BYTE PTR [ecx+30]
  00204	84 d2		 test	 dl, dl
  00206	0f 84 ad 01 00
	00		 je	 $LN66@encodeStri@2
  0020c	32 d3		 xor	 dl, bl
  0020e	88 50 1e	 mov	 BYTE PTR [eax+30], dl
  00211	8a 51 1f	 mov	 dl, BYTE PTR [ecx+31]
  00214	84 d2		 test	 dl, dl
  00216	0f 84 94 01 00
	00		 je	 $LN65@encodeStri@2
  0021c	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0021f	88 50 1f	 mov	 BYTE PTR [eax+31], dl
  00222	8a 51 20	 mov	 dl, BYTE PTR [ecx+32]
  00225	84 d2		 test	 dl, dl
  00227	0f 84 7a 01 00
	00		 je	 $LN64@encodeStri@2
  0022d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00230	88 50 20	 mov	 BYTE PTR [eax+32], dl
  00233	8a 51 21	 mov	 dl, BYTE PTR [ecx+33]
  00236	84 d2		 test	 dl, dl
  00238	0f 84 60 01 00
	00		 je	 $LN63@encodeStri@2
  0023e	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00241	88 50 21	 mov	 BYTE PTR [eax+33], dl
  00244	8a 51 22	 mov	 dl, BYTE PTR [ecx+34]
  00247	84 d2		 test	 dl, dl
  00249	0f 84 47 01 00
	00		 je	 $LN62@encodeStri@2
  0024f	32 d3		 xor	 dl, bl
  00251	88 50 22	 mov	 BYTE PTR [eax+34], dl
  00254	8a 51 23	 mov	 dl, BYTE PTR [ecx+35]
  00257	84 d2		 test	 dl, dl
  00259	0f 84 2e 01 00
	00		 je	 $LN61@encodeStri@2
  0025f	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00262	88 50 23	 mov	 BYTE PTR [eax+35], dl
  00265	8a 51 24	 mov	 dl, BYTE PTR [ecx+36]
  00268	84 d2		 test	 dl, dl
  0026a	0f 84 14 01 00
	00		 je	 $LN60@encodeStri@2
  00270	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00273	88 50 24	 mov	 BYTE PTR [eax+36], dl
  00276	8a 51 25	 mov	 dl, BYTE PTR [ecx+37]
  00279	84 d2		 test	 dl, dl
  0027b	0f 84 fa 00 00
	00		 je	 $LN59@encodeStri@2
  00281	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00284	88 50 25	 mov	 BYTE PTR [eax+37], dl
  00287	8a 51 26	 mov	 dl, BYTE PTR [ecx+38]
  0028a	84 d2		 test	 dl, dl
  0028c	0f 84 e1 00 00
	00		 je	 $LN58@encodeStri@2
  00292	32 d3		 xor	 dl, bl
  00294	88 50 26	 mov	 BYTE PTR [eax+38], dl
  00297	8a 51 27	 mov	 dl, BYTE PTR [ecx+39]
  0029a	84 d2		 test	 dl, dl
  0029c	0f 84 c8 00 00
	00		 je	 $LN57@encodeStri@2
  002a2	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  002a5	88 50 27	 mov	 BYTE PTR [eax+39], dl
  002a8	8a 51 28	 mov	 dl, BYTE PTR [ecx+40]
  002ab	84 d2		 test	 dl, dl
  002ad	0f 84 ae 00 00
	00		 je	 $LN56@encodeStri@2
  002b3	80 f2 ed	 xor	 dl, -19			; ffffffedH
  002b6	88 50 28	 mov	 BYTE PTR [eax+40], dl
  002b9	8a 51 29	 mov	 dl, BYTE PTR [ecx+41]
  002bc	84 d2		 test	 dl, dl
  002be	0f 84 94 00 00
	00		 je	 $LN55@encodeStri@2
  002c4	80 f2 ec	 xor	 dl, -20			; ffffffecH
  002c7	88 50 29	 mov	 BYTE PTR [eax+41], dl
  002ca	8a 51 2a	 mov	 dl, BYTE PTR [ecx+42]
  002cd	84 d2		 test	 dl, dl
  002cf	74 7f		 je	 SHORT $LN54@encodeStri@2
  002d1	32 d3		 xor	 dl, bl
  002d3	88 50 2a	 mov	 BYTE PTR [eax+42], dl
  002d6	8a 51 2b	 mov	 dl, BYTE PTR [ecx+43]
  002d9	84 d2		 test	 dl, dl
  002db	74 6a		 je	 SHORT $LN53@encodeStri@2
  002dd	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  002e0	88 50 2b	 mov	 BYTE PTR [eax+43], dl
  002e3	8a 51 2c	 mov	 dl, BYTE PTR [ecx+44]
  002e6	84 d2		 test	 dl, dl
  002e8	74 54		 je	 SHORT $LN52@encodeStri@2
  002ea	80 f2 ed	 xor	 dl, -19			; ffffffedH
  002ed	88 50 2c	 mov	 BYTE PTR [eax+44], dl
  002f0	8a 51 2d	 mov	 dl, BYTE PTR [ecx+45]
  002f3	84 d2		 test	 dl, dl
  002f5	74 3e		 je	 SHORT $LN51@encodeStri@2
  002f7	80 f2 ec	 xor	 dl, -20			; ffffffecH
  002fa	88 50 2d	 mov	 BYTE PTR [eax+45], dl
  002fd	8a 51 2e	 mov	 dl, BYTE PTR [ecx+46]
  00300	84 d2		 test	 dl, dl
  00302	74 29		 je	 SHORT $LN50@encodeStri@2
  00304	32 d3		 xor	 dl, bl
  00306	88 50 2e	 mov	 BYTE PTR [eax+46], dl
  00309	8a 51 2f	 mov	 dl, BYTE PTR [ecx+47]
  0030c	84 d2		 test	 dl, dl
  0030e	74 14		 je	 SHORT $LN49@encodeStri@2
  00310	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00313	88 50 2f	 mov	 BYTE PTR [eax+47], dl
  00316	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  00319	80 f1 ed	 xor	 cl, -19			; ffffffedH
  0031c	88 48 30	 mov	 BYTE PTR [eax+48], cl
  0031f	e9 5d 01 00 00	 jmp	 $LN1@encodeStri@2
$LN49@encodeStri@2:
  00324	c6 40 2f ea	 mov	 BYTE PTR [eax+47], -22	; ffffffeaH
  00328	e9 54 01 00 00	 jmp	 $LN1@encodeStri@2
$LN50@encodeStri@2:
  0032d	88 58 2e	 mov	 BYTE PTR [eax+46], bl
  00330	e9 4c 01 00 00	 jmp	 $LN1@encodeStri@2
$LN51@encodeStri@2:
  00335	c6 40 2d ec	 mov	 BYTE PTR [eax+45], -20	; ffffffecH
  00339	e9 43 01 00 00	 jmp	 $LN1@encodeStri@2
$LN52@encodeStri@2:
  0033e	c6 40 2c ed	 mov	 BYTE PTR [eax+44], -19	; ffffffedH
  00342	e9 3a 01 00 00	 jmp	 $LN1@encodeStri@2
$LN53@encodeStri@2:
  00347	c6 40 2b ea	 mov	 BYTE PTR [eax+43], -22	; ffffffeaH
  0034b	e9 31 01 00 00	 jmp	 $LN1@encodeStri@2
$LN54@encodeStri@2:
  00350	88 58 2a	 mov	 BYTE PTR [eax+42], bl
  00353	e9 29 01 00 00	 jmp	 $LN1@encodeStri@2
$LN55@encodeStri@2:
  00358	c6 40 29 ec	 mov	 BYTE PTR [eax+41], -20	; ffffffecH
  0035c	e9 20 01 00 00	 jmp	 $LN1@encodeStri@2
$LN56@encodeStri@2:
  00361	c6 40 28 ed	 mov	 BYTE PTR [eax+40], -19	; ffffffedH
  00365	e9 17 01 00 00	 jmp	 $LN1@encodeStri@2
$LN57@encodeStri@2:
  0036a	c6 40 27 ea	 mov	 BYTE PTR [eax+39], -22	; ffffffeaH
  0036e	e9 0e 01 00 00	 jmp	 $LN1@encodeStri@2
$LN58@encodeStri@2:
  00373	88 58 26	 mov	 BYTE PTR [eax+38], bl
  00376	e9 06 01 00 00	 jmp	 $LN1@encodeStri@2
$LN59@encodeStri@2:
  0037b	c6 40 25 ec	 mov	 BYTE PTR [eax+37], -20	; ffffffecH
  0037f	e9 fd 00 00 00	 jmp	 $LN1@encodeStri@2
$LN60@encodeStri@2:
  00384	c6 40 24 ed	 mov	 BYTE PTR [eax+36], -19	; ffffffedH
  00388	e9 f4 00 00 00	 jmp	 $LN1@encodeStri@2
$LN61@encodeStri@2:
  0038d	c6 40 23 ea	 mov	 BYTE PTR [eax+35], -22	; ffffffeaH
  00391	e9 eb 00 00 00	 jmp	 $LN1@encodeStri@2
$LN62@encodeStri@2:
  00396	88 58 22	 mov	 BYTE PTR [eax+34], bl
  00399	e9 e3 00 00 00	 jmp	 $LN1@encodeStri@2
$LN63@encodeStri@2:
  0039e	c6 40 21 ec	 mov	 BYTE PTR [eax+33], -20	; ffffffecH
  003a2	e9 da 00 00 00	 jmp	 $LN1@encodeStri@2
$LN64@encodeStri@2:
  003a7	c6 40 20 ed	 mov	 BYTE PTR [eax+32], -19	; ffffffedH
  003ab	e9 d1 00 00 00	 jmp	 $LN1@encodeStri@2
$LN65@encodeStri@2:
  003b0	c6 40 1f ea	 mov	 BYTE PTR [eax+31], -22	; ffffffeaH
  003b4	e9 c8 00 00 00	 jmp	 $LN1@encodeStri@2
$LN66@encodeStri@2:
  003b9	88 58 1e	 mov	 BYTE PTR [eax+30], bl
  003bc	e9 c0 00 00 00	 jmp	 $LN1@encodeStri@2
$LN67@encodeStri@2:
  003c1	c6 40 1d ec	 mov	 BYTE PTR [eax+29], -20	; ffffffecH
  003c5	e9 b7 00 00 00	 jmp	 $LN1@encodeStri@2
$LN68@encodeStri@2:
  003ca	c6 40 1c ed	 mov	 BYTE PTR [eax+28], -19	; ffffffedH
  003ce	e9 ae 00 00 00	 jmp	 $LN1@encodeStri@2
$LN69@encodeStri@2:
  003d3	c6 40 1b ea	 mov	 BYTE PTR [eax+27], -22	; ffffffeaH
  003d7	e9 a5 00 00 00	 jmp	 $LN1@encodeStri@2
$LN70@encodeStri@2:
  003dc	88 58 1a	 mov	 BYTE PTR [eax+26], bl
  003df	e9 9d 00 00 00	 jmp	 $LN1@encodeStri@2
$LN71@encodeStri@2:
  003e4	c6 40 19 ec	 mov	 BYTE PTR [eax+25], -20	; ffffffecH
  003e8	e9 94 00 00 00	 jmp	 $LN1@encodeStri@2
$LN72@encodeStri@2:
  003ed	c6 40 18 ed	 mov	 BYTE PTR [eax+24], -19	; ffffffedH
  003f1	e9 8b 00 00 00	 jmp	 $LN1@encodeStri@2
$LN73@encodeStri@2:
  003f6	c6 40 17 ea	 mov	 BYTE PTR [eax+23], -22	; ffffffeaH
  003fa	e9 82 00 00 00	 jmp	 $LN1@encodeStri@2
$LN74@encodeStri@2:
  003ff	88 58 16	 mov	 BYTE PTR [eax+22], bl
  00402	eb 7d		 jmp	 SHORT $LN1@encodeStri@2
$LN75@encodeStri@2:
  00404	c6 40 15 ec	 mov	 BYTE PTR [eax+21], -20	; ffffffecH
  00408	eb 77		 jmp	 SHORT $LN1@encodeStri@2
$LN76@encodeStri@2:
  0040a	c6 40 14 ed	 mov	 BYTE PTR [eax+20], -19	; ffffffedH
  0040e	eb 71		 jmp	 SHORT $LN1@encodeStri@2
$LN77@encodeStri@2:
  00410	c6 40 13 ea	 mov	 BYTE PTR [eax+19], -22	; ffffffeaH
  00414	eb 6b		 jmp	 SHORT $LN1@encodeStri@2
$LN78@encodeStri@2:
  00416	88 58 12	 mov	 BYTE PTR [eax+18], bl
  00419	eb 66		 jmp	 SHORT $LN1@encodeStri@2
$LN79@encodeStri@2:
  0041b	c6 40 11 ec	 mov	 BYTE PTR [eax+17], -20	; ffffffecH
  0041f	eb 60		 jmp	 SHORT $LN1@encodeStri@2
$LN80@encodeStri@2:
  00421	c6 40 10 ed	 mov	 BYTE PTR [eax+16], -19	; ffffffedH
  00425	eb 5a		 jmp	 SHORT $LN1@encodeStri@2
$LN81@encodeStri@2:
  00427	c6 40 0f ea	 mov	 BYTE PTR [eax+15], -22	; ffffffeaH
  0042b	eb 54		 jmp	 SHORT $LN1@encodeStri@2
$LN82@encodeStri@2:
  0042d	88 58 0e	 mov	 BYTE PTR [eax+14], bl
  00430	eb 4f		 jmp	 SHORT $LN1@encodeStri@2
$LN83@encodeStri@2:
  00432	c6 40 0d ec	 mov	 BYTE PTR [eax+13], -20	; ffffffecH
  00436	eb 49		 jmp	 SHORT $LN1@encodeStri@2
$LN84@encodeStri@2:
  00438	c6 40 0c ed	 mov	 BYTE PTR [eax+12], -19	; ffffffedH
  0043c	eb 43		 jmp	 SHORT $LN1@encodeStri@2
$LN85@encodeStri@2:
  0043e	c6 40 0b ea	 mov	 BYTE PTR [eax+11], -22	; ffffffeaH
  00442	eb 3d		 jmp	 SHORT $LN1@encodeStri@2
$LN86@encodeStri@2:
  00444	88 58 0a	 mov	 BYTE PTR [eax+10], bl
  00447	eb 38		 jmp	 SHORT $LN1@encodeStri@2
$LN87@encodeStri@2:
  00449	c6 40 09 ec	 mov	 BYTE PTR [eax+9], -20	; ffffffecH
  0044d	eb 32		 jmp	 SHORT $LN1@encodeStri@2
$LN88@encodeStri@2:
  0044f	c6 40 08 ed	 mov	 BYTE PTR [eax+8], -19	; ffffffedH
  00453	eb 2c		 jmp	 SHORT $LN1@encodeStri@2
$LN89@encodeStri@2:
  00455	c6 40 07 ea	 mov	 BYTE PTR [eax+7], -22	; ffffffeaH
  00459	eb 26		 jmp	 SHORT $LN1@encodeStri@2
$LN90@encodeStri@2:
  0045b	88 58 06	 mov	 BYTE PTR [eax+6], bl
  0045e	eb 21		 jmp	 SHORT $LN1@encodeStri@2
$LN91@encodeStri@2:
  00460	c6 40 05 ec	 mov	 BYTE PTR [eax+5], -20	; ffffffecH
  00464	eb 1b		 jmp	 SHORT $LN1@encodeStri@2
$LN92@encodeStri@2:
  00466	c6 40 04 ed	 mov	 BYTE PTR [eax+4], -19	; ffffffedH
  0046a	eb 15		 jmp	 SHORT $LN1@encodeStri@2
$LN93@encodeStri@2:
  0046c	c6 40 03 ea	 mov	 BYTE PTR [eax+3], -22	; ffffffeaH
  00470	eb 0f		 jmp	 SHORT $LN1@encodeStri@2
$LN94@encodeStri@2:
  00472	c6 40 02 eb	 mov	 BYTE PTR [eax+2], -21	; ffffffebH
  00476	eb 09		 jmp	 SHORT $LN1@encodeStri@2
$LN95@encodeStri@2:
  00478	c6 40 01 ec	 mov	 BYTE PTR [eax+1], -20	; ffffffecH
  0047c	eb 03		 jmp	 SHORT $LN1@encodeStri@2
$LN96@encodeStri@2:
  0047e	c6 00 ed	 mov	 BYTE PTR [eax], -19	; ffffffedH
$LN1@encodeStri@2:
  00481	6a 07		 push	 7
  00483	5a		 pop	 edx
  00484	8b c8		 mov	 ecx, eax
  00486	c6 40 1d 00	 mov	 BYTE PTR [eax+29], 0
  0048a	5b		 pop	 ebx
$LL104@encodeStri@2:
  0048b	81 31 ed ec eb
	ea		 xor	 DWORD PTR [ecx], -353637139 ; eaebecedH
  00491	83 c1 04	 add	 ecx, 4
  00494	4a		 dec	 edx
  00495	75 f4		 jne	 SHORT $LL104@encodeStri@2
  00497	80 70 1c ed	 xor	 BYTE PTR [eax+28], -19	; ffffffedH

; 217  : 		return e;
; 218  : 	}

  0049b	5d		 pop	 ebp
  0049c	c2 08 00	 ret	 8
??$encodeString@$0BO@@ioINILoader_e@@AAEPADAAY0BO@$$CBDPAD@Z ENDP ; ioINILoader_e::encodeString<30>
_TEXT	ENDS
PUBLIC	??$encodeString@$0BI@@ioINILoader_e@@AAEPADAAY0BI@$$CBDPAD@Z ; ioINILoader_e::encodeString<24>
; Function compile flags: /Ogsp
;	COMDAT ??$encodeString@$0BI@@ioINILoader_e@@AAEPADAAY0BI@$$CBDPAD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_e$ = 12						; size = 4
??$encodeString@$0BI@@ioINILoader_e@@AAEPADAAY0BI@$$CBDPAD@Z PROC ; ioINILoader_e::encodeString<24>, COMDAT
; _this$ = ecx

; 215  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 216  : 		__ENCSTR(s, e);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00006	8a 11		 mov	 dl, BYTE PTR [ecx]
  00008	8b 45 0c	 mov	 eax, DWORD PTR _e$[ebp]
  0000b	53		 push	 ebx
  0000c	84 d2		 test	 dl, dl
  0000e	0f 84 6a 04 00
	00		 je	 $LN96@encodeStri@3
  00014	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00017	88 10		 mov	 BYTE PTR [eax], dl
  00019	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  0001c	84 d2		 test	 dl, dl
  0001e	0f 84 54 04 00
	00		 je	 $LN95@encodeStri@3
  00024	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00027	88 50 01	 mov	 BYTE PTR [eax+1], dl
  0002a	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  0002d	84 d2		 test	 dl, dl
  0002f	0f 84 3d 04 00
	00		 je	 $LN94@encodeStri@3
  00035	b3 eb		 mov	 bl, -21			; ffffffebH
  00037	32 d3		 xor	 dl, bl
  00039	88 50 02	 mov	 BYTE PTR [eax+2], dl
  0003c	8a 51 03	 mov	 dl, BYTE PTR [ecx+3]
  0003f	84 d2		 test	 dl, dl
  00041	0f 84 25 04 00
	00		 je	 $LN93@encodeStri@3
  00047	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0004a	88 50 03	 mov	 BYTE PTR [eax+3], dl
  0004d	8a 51 04	 mov	 dl, BYTE PTR [ecx+4]
  00050	84 d2		 test	 dl, dl
  00052	0f 84 0e 04 00
	00		 je	 $LN92@encodeStri@3
  00058	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0005b	88 50 04	 mov	 BYTE PTR [eax+4], dl
  0005e	8a 51 05	 mov	 dl, BYTE PTR [ecx+5]
  00061	84 d2		 test	 dl, dl
  00063	0f 84 f7 03 00
	00		 je	 $LN91@encodeStri@3
  00069	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0006c	88 50 05	 mov	 BYTE PTR [eax+5], dl
  0006f	8a 51 06	 mov	 dl, BYTE PTR [ecx+6]
  00072	84 d2		 test	 dl, dl
  00074	0f 84 e1 03 00
	00		 je	 $LN90@encodeStri@3
  0007a	32 d3		 xor	 dl, bl
  0007c	88 50 06	 mov	 BYTE PTR [eax+6], dl
  0007f	8a 51 07	 mov	 dl, BYTE PTR [ecx+7]
  00082	84 d2		 test	 dl, dl
  00084	0f 84 cb 03 00
	00		 je	 $LN89@encodeStri@3
  0008a	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0008d	88 50 07	 mov	 BYTE PTR [eax+7], dl
  00090	8a 51 08	 mov	 dl, BYTE PTR [ecx+8]
  00093	84 d2		 test	 dl, dl
  00095	0f 84 b4 03 00
	00		 je	 $LN88@encodeStri@3
  0009b	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0009e	88 50 08	 mov	 BYTE PTR [eax+8], dl
  000a1	8a 51 09	 mov	 dl, BYTE PTR [ecx+9]
  000a4	84 d2		 test	 dl, dl
  000a6	0f 84 9d 03 00
	00		 je	 $LN87@encodeStri@3
  000ac	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000af	88 50 09	 mov	 BYTE PTR [eax+9], dl
  000b2	8a 51 0a	 mov	 dl, BYTE PTR [ecx+10]
  000b5	84 d2		 test	 dl, dl
  000b7	0f 84 87 03 00
	00		 je	 $LN86@encodeStri@3
  000bd	32 d3		 xor	 dl, bl
  000bf	88 50 0a	 mov	 BYTE PTR [eax+10], dl
  000c2	8a 51 0b	 mov	 dl, BYTE PTR [ecx+11]
  000c5	84 d2		 test	 dl, dl
  000c7	0f 84 71 03 00
	00		 je	 $LN85@encodeStri@3
  000cd	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000d0	88 50 0b	 mov	 BYTE PTR [eax+11], dl
  000d3	8a 51 0c	 mov	 dl, BYTE PTR [ecx+12]
  000d6	84 d2		 test	 dl, dl
  000d8	0f 84 5a 03 00
	00		 je	 $LN84@encodeStri@3
  000de	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000e1	88 50 0c	 mov	 BYTE PTR [eax+12], dl
  000e4	8a 51 0d	 mov	 dl, BYTE PTR [ecx+13]
  000e7	84 d2		 test	 dl, dl
  000e9	0f 84 43 03 00
	00		 je	 $LN83@encodeStri@3
  000ef	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000f2	88 50 0d	 mov	 BYTE PTR [eax+13], dl
  000f5	8a 51 0e	 mov	 dl, BYTE PTR [ecx+14]
  000f8	84 d2		 test	 dl, dl
  000fa	0f 84 2d 03 00
	00		 je	 $LN82@encodeStri@3
  00100	32 d3		 xor	 dl, bl
  00102	88 50 0e	 mov	 BYTE PTR [eax+14], dl
  00105	8a 51 0f	 mov	 dl, BYTE PTR [ecx+15]
  00108	84 d2		 test	 dl, dl
  0010a	0f 84 17 03 00
	00		 je	 $LN81@encodeStri@3
  00110	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00113	88 50 0f	 mov	 BYTE PTR [eax+15], dl
  00116	8a 51 10	 mov	 dl, BYTE PTR [ecx+16]
  00119	84 d2		 test	 dl, dl
  0011b	0f 84 00 03 00
	00		 je	 $LN80@encodeStri@3
  00121	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00124	88 50 10	 mov	 BYTE PTR [eax+16], dl
  00127	8a 51 11	 mov	 dl, BYTE PTR [ecx+17]
  0012a	84 d2		 test	 dl, dl
  0012c	0f 84 e9 02 00
	00		 je	 $LN79@encodeStri@3
  00132	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00135	88 50 11	 mov	 BYTE PTR [eax+17], dl
  00138	8a 51 12	 mov	 dl, BYTE PTR [ecx+18]
  0013b	84 d2		 test	 dl, dl
  0013d	0f 84 d3 02 00
	00		 je	 $LN78@encodeStri@3
  00143	32 d3		 xor	 dl, bl
  00145	88 50 12	 mov	 BYTE PTR [eax+18], dl
  00148	8a 51 13	 mov	 dl, BYTE PTR [ecx+19]
  0014b	84 d2		 test	 dl, dl
  0014d	0f 84 bd 02 00
	00		 je	 $LN77@encodeStri@3
  00153	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00156	88 50 13	 mov	 BYTE PTR [eax+19], dl
  00159	8a 51 14	 mov	 dl, BYTE PTR [ecx+20]
  0015c	84 d2		 test	 dl, dl
  0015e	0f 84 a6 02 00
	00		 je	 $LN76@encodeStri@3
  00164	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00167	88 50 14	 mov	 BYTE PTR [eax+20], dl
  0016a	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  0016d	84 d2		 test	 dl, dl
  0016f	0f 84 8f 02 00
	00		 je	 $LN75@encodeStri@3
  00175	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00178	88 50 15	 mov	 BYTE PTR [eax+21], dl
  0017b	8a 51 16	 mov	 dl, BYTE PTR [ecx+22]
  0017e	84 d2		 test	 dl, dl
  00180	0f 84 79 02 00
	00		 je	 $LN74@encodeStri@3
  00186	32 d3		 xor	 dl, bl
  00188	88 50 16	 mov	 BYTE PTR [eax+22], dl
  0018b	8a 51 17	 mov	 dl, BYTE PTR [ecx+23]
  0018e	84 d2		 test	 dl, dl
  00190	0f 84 60 02 00
	00		 je	 $LN73@encodeStri@3
  00196	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00199	88 50 17	 mov	 BYTE PTR [eax+23], dl
  0019c	8a 51 18	 mov	 dl, BYTE PTR [ecx+24]
  0019f	84 d2		 test	 dl, dl
  001a1	0f 84 46 02 00
	00		 je	 $LN72@encodeStri@3
  001a7	80 f2 ed	 xor	 dl, -19			; ffffffedH
  001aa	88 50 18	 mov	 BYTE PTR [eax+24], dl
  001ad	8a 51 19	 mov	 dl, BYTE PTR [ecx+25]
  001b0	84 d2		 test	 dl, dl
  001b2	0f 84 2c 02 00
	00		 je	 $LN71@encodeStri@3
  001b8	80 f2 ec	 xor	 dl, -20			; ffffffecH
  001bb	88 50 19	 mov	 BYTE PTR [eax+25], dl
  001be	8a 51 1a	 mov	 dl, BYTE PTR [ecx+26]
  001c1	84 d2		 test	 dl, dl
  001c3	0f 84 13 02 00
	00		 je	 $LN70@encodeStri@3
  001c9	32 d3		 xor	 dl, bl
  001cb	88 50 1a	 mov	 BYTE PTR [eax+26], dl
  001ce	8a 51 1b	 mov	 dl, BYTE PTR [ecx+27]
  001d1	84 d2		 test	 dl, dl
  001d3	0f 84 fa 01 00
	00		 je	 $LN69@encodeStri@3
  001d9	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  001dc	88 50 1b	 mov	 BYTE PTR [eax+27], dl
  001df	8a 51 1c	 mov	 dl, BYTE PTR [ecx+28]
  001e2	84 d2		 test	 dl, dl
  001e4	0f 84 e0 01 00
	00		 je	 $LN68@encodeStri@3
  001ea	80 f2 ed	 xor	 dl, -19			; ffffffedH
  001ed	88 50 1c	 mov	 BYTE PTR [eax+28], dl
  001f0	8a 51 1d	 mov	 dl, BYTE PTR [ecx+29]
  001f3	84 d2		 test	 dl, dl
  001f5	0f 84 c6 01 00
	00		 je	 $LN67@encodeStri@3
  001fb	80 f2 ec	 xor	 dl, -20			; ffffffecH
  001fe	88 50 1d	 mov	 BYTE PTR [eax+29], dl
  00201	8a 51 1e	 mov	 dl, BYTE PTR [ecx+30]
  00204	84 d2		 test	 dl, dl
  00206	0f 84 ad 01 00
	00		 je	 $LN66@encodeStri@3
  0020c	32 d3		 xor	 dl, bl
  0020e	88 50 1e	 mov	 BYTE PTR [eax+30], dl
  00211	8a 51 1f	 mov	 dl, BYTE PTR [ecx+31]
  00214	84 d2		 test	 dl, dl
  00216	0f 84 94 01 00
	00		 je	 $LN65@encodeStri@3
  0021c	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0021f	88 50 1f	 mov	 BYTE PTR [eax+31], dl
  00222	8a 51 20	 mov	 dl, BYTE PTR [ecx+32]
  00225	84 d2		 test	 dl, dl
  00227	0f 84 7a 01 00
	00		 je	 $LN64@encodeStri@3
  0022d	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00230	88 50 20	 mov	 BYTE PTR [eax+32], dl
  00233	8a 51 21	 mov	 dl, BYTE PTR [ecx+33]
  00236	84 d2		 test	 dl, dl
  00238	0f 84 60 01 00
	00		 je	 $LN63@encodeStri@3
  0023e	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00241	88 50 21	 mov	 BYTE PTR [eax+33], dl
  00244	8a 51 22	 mov	 dl, BYTE PTR [ecx+34]
  00247	84 d2		 test	 dl, dl
  00249	0f 84 47 01 00
	00		 je	 $LN62@encodeStri@3
  0024f	32 d3		 xor	 dl, bl
  00251	88 50 22	 mov	 BYTE PTR [eax+34], dl
  00254	8a 51 23	 mov	 dl, BYTE PTR [ecx+35]
  00257	84 d2		 test	 dl, dl
  00259	0f 84 2e 01 00
	00		 je	 $LN61@encodeStri@3
  0025f	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00262	88 50 23	 mov	 BYTE PTR [eax+35], dl
  00265	8a 51 24	 mov	 dl, BYTE PTR [ecx+36]
  00268	84 d2		 test	 dl, dl
  0026a	0f 84 14 01 00
	00		 je	 $LN60@encodeStri@3
  00270	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00273	88 50 24	 mov	 BYTE PTR [eax+36], dl
  00276	8a 51 25	 mov	 dl, BYTE PTR [ecx+37]
  00279	84 d2		 test	 dl, dl
  0027b	0f 84 fa 00 00
	00		 je	 $LN59@encodeStri@3
  00281	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00284	88 50 25	 mov	 BYTE PTR [eax+37], dl
  00287	8a 51 26	 mov	 dl, BYTE PTR [ecx+38]
  0028a	84 d2		 test	 dl, dl
  0028c	0f 84 e1 00 00
	00		 je	 $LN58@encodeStri@3
  00292	32 d3		 xor	 dl, bl
  00294	88 50 26	 mov	 BYTE PTR [eax+38], dl
  00297	8a 51 27	 mov	 dl, BYTE PTR [ecx+39]
  0029a	84 d2		 test	 dl, dl
  0029c	0f 84 c8 00 00
	00		 je	 $LN57@encodeStri@3
  002a2	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  002a5	88 50 27	 mov	 BYTE PTR [eax+39], dl
  002a8	8a 51 28	 mov	 dl, BYTE PTR [ecx+40]
  002ab	84 d2		 test	 dl, dl
  002ad	0f 84 ae 00 00
	00		 je	 $LN56@encodeStri@3
  002b3	80 f2 ed	 xor	 dl, -19			; ffffffedH
  002b6	88 50 28	 mov	 BYTE PTR [eax+40], dl
  002b9	8a 51 29	 mov	 dl, BYTE PTR [ecx+41]
  002bc	84 d2		 test	 dl, dl
  002be	0f 84 94 00 00
	00		 je	 $LN55@encodeStri@3
  002c4	80 f2 ec	 xor	 dl, -20			; ffffffecH
  002c7	88 50 29	 mov	 BYTE PTR [eax+41], dl
  002ca	8a 51 2a	 mov	 dl, BYTE PTR [ecx+42]
  002cd	84 d2		 test	 dl, dl
  002cf	74 7f		 je	 SHORT $LN54@encodeStri@3
  002d1	32 d3		 xor	 dl, bl
  002d3	88 50 2a	 mov	 BYTE PTR [eax+42], dl
  002d6	8a 51 2b	 mov	 dl, BYTE PTR [ecx+43]
  002d9	84 d2		 test	 dl, dl
  002db	74 6a		 je	 SHORT $LN53@encodeStri@3
  002dd	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  002e0	88 50 2b	 mov	 BYTE PTR [eax+43], dl
  002e3	8a 51 2c	 mov	 dl, BYTE PTR [ecx+44]
  002e6	84 d2		 test	 dl, dl
  002e8	74 54		 je	 SHORT $LN52@encodeStri@3
  002ea	80 f2 ed	 xor	 dl, -19			; ffffffedH
  002ed	88 50 2c	 mov	 BYTE PTR [eax+44], dl
  002f0	8a 51 2d	 mov	 dl, BYTE PTR [ecx+45]
  002f3	84 d2		 test	 dl, dl
  002f5	74 3e		 je	 SHORT $LN51@encodeStri@3
  002f7	80 f2 ec	 xor	 dl, -20			; ffffffecH
  002fa	88 50 2d	 mov	 BYTE PTR [eax+45], dl
  002fd	8a 51 2e	 mov	 dl, BYTE PTR [ecx+46]
  00300	84 d2		 test	 dl, dl
  00302	74 29		 je	 SHORT $LN50@encodeStri@3
  00304	32 d3		 xor	 dl, bl
  00306	88 50 2e	 mov	 BYTE PTR [eax+46], dl
  00309	8a 51 2f	 mov	 dl, BYTE PTR [ecx+47]
  0030c	84 d2		 test	 dl, dl
  0030e	74 14		 je	 SHORT $LN49@encodeStri@3
  00310	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00313	88 50 2f	 mov	 BYTE PTR [eax+47], dl
  00316	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  00319	80 f1 ed	 xor	 cl, -19			; ffffffedH
  0031c	88 48 30	 mov	 BYTE PTR [eax+48], cl
  0031f	e9 5d 01 00 00	 jmp	 $LN1@encodeStri@3
$LN49@encodeStri@3:
  00324	c6 40 2f ea	 mov	 BYTE PTR [eax+47], -22	; ffffffeaH
  00328	e9 54 01 00 00	 jmp	 $LN1@encodeStri@3
$LN50@encodeStri@3:
  0032d	88 58 2e	 mov	 BYTE PTR [eax+46], bl
  00330	e9 4c 01 00 00	 jmp	 $LN1@encodeStri@3
$LN51@encodeStri@3:
  00335	c6 40 2d ec	 mov	 BYTE PTR [eax+45], -20	; ffffffecH
  00339	e9 43 01 00 00	 jmp	 $LN1@encodeStri@3
$LN52@encodeStri@3:
  0033e	c6 40 2c ed	 mov	 BYTE PTR [eax+44], -19	; ffffffedH
  00342	e9 3a 01 00 00	 jmp	 $LN1@encodeStri@3
$LN53@encodeStri@3:
  00347	c6 40 2b ea	 mov	 BYTE PTR [eax+43], -22	; ffffffeaH
  0034b	e9 31 01 00 00	 jmp	 $LN1@encodeStri@3
$LN54@encodeStri@3:
  00350	88 58 2a	 mov	 BYTE PTR [eax+42], bl
  00353	e9 29 01 00 00	 jmp	 $LN1@encodeStri@3
$LN55@encodeStri@3:
  00358	c6 40 29 ec	 mov	 BYTE PTR [eax+41], -20	; ffffffecH
  0035c	e9 20 01 00 00	 jmp	 $LN1@encodeStri@3
$LN56@encodeStri@3:
  00361	c6 40 28 ed	 mov	 BYTE PTR [eax+40], -19	; ffffffedH
  00365	e9 17 01 00 00	 jmp	 $LN1@encodeStri@3
$LN57@encodeStri@3:
  0036a	c6 40 27 ea	 mov	 BYTE PTR [eax+39], -22	; ffffffeaH
  0036e	e9 0e 01 00 00	 jmp	 $LN1@encodeStri@3
$LN58@encodeStri@3:
  00373	88 58 26	 mov	 BYTE PTR [eax+38], bl
  00376	e9 06 01 00 00	 jmp	 $LN1@encodeStri@3
$LN59@encodeStri@3:
  0037b	c6 40 25 ec	 mov	 BYTE PTR [eax+37], -20	; ffffffecH
  0037f	e9 fd 00 00 00	 jmp	 $LN1@encodeStri@3
$LN60@encodeStri@3:
  00384	c6 40 24 ed	 mov	 BYTE PTR [eax+36], -19	; ffffffedH
  00388	e9 f4 00 00 00	 jmp	 $LN1@encodeStri@3
$LN61@encodeStri@3:
  0038d	c6 40 23 ea	 mov	 BYTE PTR [eax+35], -22	; ffffffeaH
  00391	e9 eb 00 00 00	 jmp	 $LN1@encodeStri@3
$LN62@encodeStri@3:
  00396	88 58 22	 mov	 BYTE PTR [eax+34], bl
  00399	e9 e3 00 00 00	 jmp	 $LN1@encodeStri@3
$LN63@encodeStri@3:
  0039e	c6 40 21 ec	 mov	 BYTE PTR [eax+33], -20	; ffffffecH
  003a2	e9 da 00 00 00	 jmp	 $LN1@encodeStri@3
$LN64@encodeStri@3:
  003a7	c6 40 20 ed	 mov	 BYTE PTR [eax+32], -19	; ffffffedH
  003ab	e9 d1 00 00 00	 jmp	 $LN1@encodeStri@3
$LN65@encodeStri@3:
  003b0	c6 40 1f ea	 mov	 BYTE PTR [eax+31], -22	; ffffffeaH
  003b4	e9 c8 00 00 00	 jmp	 $LN1@encodeStri@3
$LN66@encodeStri@3:
  003b9	88 58 1e	 mov	 BYTE PTR [eax+30], bl
  003bc	e9 c0 00 00 00	 jmp	 $LN1@encodeStri@3
$LN67@encodeStri@3:
  003c1	c6 40 1d ec	 mov	 BYTE PTR [eax+29], -20	; ffffffecH
  003c5	e9 b7 00 00 00	 jmp	 $LN1@encodeStri@3
$LN68@encodeStri@3:
  003ca	c6 40 1c ed	 mov	 BYTE PTR [eax+28], -19	; ffffffedH
  003ce	e9 ae 00 00 00	 jmp	 $LN1@encodeStri@3
$LN69@encodeStri@3:
  003d3	c6 40 1b ea	 mov	 BYTE PTR [eax+27], -22	; ffffffeaH
  003d7	e9 a5 00 00 00	 jmp	 $LN1@encodeStri@3
$LN70@encodeStri@3:
  003dc	88 58 1a	 mov	 BYTE PTR [eax+26], bl
  003df	e9 9d 00 00 00	 jmp	 $LN1@encodeStri@3
$LN71@encodeStri@3:
  003e4	c6 40 19 ec	 mov	 BYTE PTR [eax+25], -20	; ffffffecH
  003e8	e9 94 00 00 00	 jmp	 $LN1@encodeStri@3
$LN72@encodeStri@3:
  003ed	c6 40 18 ed	 mov	 BYTE PTR [eax+24], -19	; ffffffedH
  003f1	e9 8b 00 00 00	 jmp	 $LN1@encodeStri@3
$LN73@encodeStri@3:
  003f6	c6 40 17 ea	 mov	 BYTE PTR [eax+23], -22	; ffffffeaH
  003fa	e9 82 00 00 00	 jmp	 $LN1@encodeStri@3
$LN74@encodeStri@3:
  003ff	88 58 16	 mov	 BYTE PTR [eax+22], bl
  00402	eb 7d		 jmp	 SHORT $LN1@encodeStri@3
$LN75@encodeStri@3:
  00404	c6 40 15 ec	 mov	 BYTE PTR [eax+21], -20	; ffffffecH
  00408	eb 77		 jmp	 SHORT $LN1@encodeStri@3
$LN76@encodeStri@3:
  0040a	c6 40 14 ed	 mov	 BYTE PTR [eax+20], -19	; ffffffedH
  0040e	eb 71		 jmp	 SHORT $LN1@encodeStri@3
$LN77@encodeStri@3:
  00410	c6 40 13 ea	 mov	 BYTE PTR [eax+19], -22	; ffffffeaH
  00414	eb 6b		 jmp	 SHORT $LN1@encodeStri@3
$LN78@encodeStri@3:
  00416	88 58 12	 mov	 BYTE PTR [eax+18], bl
  00419	eb 66		 jmp	 SHORT $LN1@encodeStri@3
$LN79@encodeStri@3:
  0041b	c6 40 11 ec	 mov	 BYTE PTR [eax+17], -20	; ffffffecH
  0041f	eb 60		 jmp	 SHORT $LN1@encodeStri@3
$LN80@encodeStri@3:
  00421	c6 40 10 ed	 mov	 BYTE PTR [eax+16], -19	; ffffffedH
  00425	eb 5a		 jmp	 SHORT $LN1@encodeStri@3
$LN81@encodeStri@3:
  00427	c6 40 0f ea	 mov	 BYTE PTR [eax+15], -22	; ffffffeaH
  0042b	eb 54		 jmp	 SHORT $LN1@encodeStri@3
$LN82@encodeStri@3:
  0042d	88 58 0e	 mov	 BYTE PTR [eax+14], bl
  00430	eb 4f		 jmp	 SHORT $LN1@encodeStri@3
$LN83@encodeStri@3:
  00432	c6 40 0d ec	 mov	 BYTE PTR [eax+13], -20	; ffffffecH
  00436	eb 49		 jmp	 SHORT $LN1@encodeStri@3
$LN84@encodeStri@3:
  00438	c6 40 0c ed	 mov	 BYTE PTR [eax+12], -19	; ffffffedH
  0043c	eb 43		 jmp	 SHORT $LN1@encodeStri@3
$LN85@encodeStri@3:
  0043e	c6 40 0b ea	 mov	 BYTE PTR [eax+11], -22	; ffffffeaH
  00442	eb 3d		 jmp	 SHORT $LN1@encodeStri@3
$LN86@encodeStri@3:
  00444	88 58 0a	 mov	 BYTE PTR [eax+10], bl
  00447	eb 38		 jmp	 SHORT $LN1@encodeStri@3
$LN87@encodeStri@3:
  00449	c6 40 09 ec	 mov	 BYTE PTR [eax+9], -20	; ffffffecH
  0044d	eb 32		 jmp	 SHORT $LN1@encodeStri@3
$LN88@encodeStri@3:
  0044f	c6 40 08 ed	 mov	 BYTE PTR [eax+8], -19	; ffffffedH
  00453	eb 2c		 jmp	 SHORT $LN1@encodeStri@3
$LN89@encodeStri@3:
  00455	c6 40 07 ea	 mov	 BYTE PTR [eax+7], -22	; ffffffeaH
  00459	eb 26		 jmp	 SHORT $LN1@encodeStri@3
$LN90@encodeStri@3:
  0045b	88 58 06	 mov	 BYTE PTR [eax+6], bl
  0045e	eb 21		 jmp	 SHORT $LN1@encodeStri@3
$LN91@encodeStri@3:
  00460	c6 40 05 ec	 mov	 BYTE PTR [eax+5], -20	; ffffffecH
  00464	eb 1b		 jmp	 SHORT $LN1@encodeStri@3
$LN92@encodeStri@3:
  00466	c6 40 04 ed	 mov	 BYTE PTR [eax+4], -19	; ffffffedH
  0046a	eb 15		 jmp	 SHORT $LN1@encodeStri@3
$LN93@encodeStri@3:
  0046c	c6 40 03 ea	 mov	 BYTE PTR [eax+3], -22	; ffffffeaH
  00470	eb 0f		 jmp	 SHORT $LN1@encodeStri@3
$LN94@encodeStri@3:
  00472	c6 40 02 eb	 mov	 BYTE PTR [eax+2], -21	; ffffffebH
  00476	eb 09		 jmp	 SHORT $LN1@encodeStri@3
$LN95@encodeStri@3:
  00478	c6 40 01 ec	 mov	 BYTE PTR [eax+1], -20	; ffffffecH
  0047c	eb 03		 jmp	 SHORT $LN1@encodeStri@3
$LN96@encodeStri@3:
  0047e	c6 00 ed	 mov	 BYTE PTR [eax], -19	; ffffffedH
$LN1@encodeStri@3:
  00481	6a 05		 push	 5
  00483	5a		 pop	 edx
  00484	8b c8		 mov	 ecx, eax
  00486	c6 40 17 00	 mov	 BYTE PTR [eax+23], 0
  0048a	5b		 pop	 ebx
$LL104@encodeStri@3:
  0048b	81 31 ed ec eb
	ea		 xor	 DWORD PTR [ecx], -353637139 ; eaebecedH
  00491	83 c1 04	 add	 ecx, 4
  00494	4a		 dec	 edx
  00495	75 f4		 jne	 SHORT $LL104@encodeStri@3
  00497	56		 push	 esi
  00498	6a 14		 push	 20			; 00000014H
  0049a	5e		 pop	 esi
$LL101@encodeStri@3:
  0049b	8b ce		 mov	 ecx, esi
  0049d	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  004a3	79 05		 jns	 SHORT $LN111@encodeStri@3
  004a5	49		 dec	 ecx
  004a6	83 c9 fc	 or	 ecx, -4			; fffffffcH
  004a9	41		 inc	 ecx
$LN111@encodeStri@3:
  004aa	b2 ed		 mov	 dl, -19			; ffffffedH
  004ac	2a d1		 sub	 dl, cl
  004ae	30 14 06	 xor	 BYTE PTR [esi+eax], dl
  004b1	46		 inc	 esi
  004b2	83 fe 17	 cmp	 esi, 23			; 00000017H
  004b5	7c e4		 jl	 SHORT $LL101@encodeStri@3
  004b7	5e		 pop	 esi

; 217  : 		return e;
; 218  : 	}

  004b8	5d		 pop	 ebp
  004b9	c2 08 00	 ret	 8
??$encodeString@$0BI@@ioINILoader_e@@AAEPADAAY0BI@$$CBDPAD@Z ENDP ; ioINILoader_e::encodeString<24>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAGPAGV?$allocator@G@std@@@std@@YAPAGPAG00AAV?$allocator@G@0@@Z ; std::_Uninitialized_move<unsigned short *,unsigned short *,std::allocator<unsigned short> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAGPAGV?$allocator@G@std@@@std@@YAPAGPAG00AAV?$allocator@G@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAGPAGV?$allocator@G@std@@@std@@YAPAGPAG00AAV?$allocator@G@0@@Z PROC ; std::_Uninitialized_move<unsigned short *,unsigned short *,std::allocator<unsigned short> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00009	56		 push	 esi
  0000a	d1 f8		 sar	 eax, 1
  0000c	8d 34 00	 lea	 esi, DWORD PTR [eax+eax]
  0000f	56		 push	 esi
  00010	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00013	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001f	03 c6		 add	 eax, esi
  00021	5e		 pop	 esi

; 472  : 	}

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$_Uninitialized_move@PAGPAGV?$allocator@G@std@@@std@@YAPAGPAG00AAV?$allocator@G@0@@Z ENDP ; std::_Uninitialized_move<unsigned short *,unsigned short *,std::allocator<unsigned short> >
_TEXT	ENDS
PUBLIC	??$construct@AAUtagMecroTextInfo@CKeyInfo@@@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@AAU23@@Z ; std::allocator<CKeyInfo::tagMecroTextInfo>::construct<CKeyInfo::tagMecroTextInfo &>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAUtagMecroTextInfo@CKeyInfo@@@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@AAU23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAUtagMecroTextInfo@CKeyInfo@@@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@AAU23@@Z$0
__ehfuncinfo$??$construct@AAUtagMecroTextInfo@CKeyInfo@@@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@AAU23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAUtagMecroTextInfo@CKeyInfo@@@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@AAU23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??$construct@AAUtagMecroTextInfo@CKeyInfo@@@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@AAU23@@Z
_TEXT	SEGMENT
$T517522 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUtagMecroTextInfo@CKeyInfo@@@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@AAU23@@Z PROC ; std::allocator<CKeyInfo::tagMecroTextInfo>::construct<CKeyInfo::tagMecroTextInfo &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??$construct@AAUtagMecroTextInfo@CKeyInfo@@@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@AAU23@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR $T517522[ebp], eax
  00012	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00016	85 c0		 test	 eax, eax
  00018	74 14		 je	 SHORT $LN3@construct@4
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0001d	8a 11		 mov	 dl, BYTE PTR [ecx]
  0001f	83 c1 04	 add	 ecx, 4
  00022	51		 push	 ecx
  00023	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00026	88 10		 mov	 BYTE PTR [eax], dl
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
$LN3@construct@4:

; 209  : 		}

  0002e	e8 00 00 00 00	 call	 __EH_epilog3
  00033	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAUtagMecroTextInfo@CKeyInfo@@@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@AAU23@@Z$0:
  00000	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00003	ff 75 f0	 push	 DWORD PTR $T517522[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000b	59		 pop	 ecx
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
__ehhandler$??$construct@AAUtagMecroTextInfo@CKeyInfo@@@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@AAU23@@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAUtagMecroTextInfo@CKeyInfo@@@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@AAU23@@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAUtagMecroTextInfo@CKeyInfo@@@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@AAU23@@Z ENDP ; std::allocator<CKeyInfo::tagMecroTextInfo>::construct<CKeyInfo::tagMecroTextInfo &>
PUBLIC	??$_Move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<CKeyInfo::tagMecroTextInfo *,CKeyInfo::tagMecroTextInfo *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<CKeyInfo::tagMecroTextInfo *,CKeyInfo::tagMecroTextInfo *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
$LN13@Move:
  0000b	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0000e	74 19		 je	 SHORT $LN1@Move

; 2514 : 		*_Dest = _STD move(*_First);

  00010	8a 06		 mov	 al, BYTE PTR [esi]
  00012	88 07		 mov	 BYTE PTR [edi], al
  00014	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00017	50		 push	 eax
  00018	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@ABV0@@Z
  00021	83 c7 14	 add	 edi, 20			; 00000014H
  00024	83 c6 14	 add	 esi, 20			; 00000014H
  00027	eb e2		 jmp	 SHORT $LN13@Move
$LN1@Move:

; 2515 : 	return (_Dest);

  00029	8b c7		 mov	 eax, edi
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi

; 2516 : 	}

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??$_Move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<CKeyInfo::tagMecroTextInfo *,CKeyInfo::tagMecroTextInfo *>
_TEXT	ENDS
PUBLIC	??$_Construct@UtagMecroTextInfo@CKeyInfo@@ABU12@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@ABU12@@Z ; std::_Construct<CKeyInfo::tagMecroTextInfo,CKeyInfo::tagMecroTextInfo const &>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$_Construct@UtagMecroTextInfo@CKeyInfo@@ABU12@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@ABU12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@UtagMecroTextInfo@CKeyInfo@@ABU12@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@ABU12@@Z$0
__ehfuncinfo$??$_Construct@UtagMecroTextInfo@CKeyInfo@@ABU12@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@ABU12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@UtagMecroTextInfo@CKeyInfo@@ABU12@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@ABU12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??$_Construct@UtagMecroTextInfo@CKeyInfo@@ABU12@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@ABU12@@Z
_TEXT	SEGMENT
$T517557 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$ = 8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UtagMecroTextInfo@CKeyInfo@@ABU12@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@ABU12@@Z PROC ; std::_Construct<CKeyInfo::tagMecroTextInfo,CKeyInfo::tagMecroTextInfo const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??$_Construct@UtagMecroTextInfo@CKeyInfo@@ABU12@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@ABU12@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3

; 47   : 	void _FARQ *_Vptr = _Ptr;

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	89 45 08	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00012	89 45 f0	 mov	 DWORD PTR $T517557[ebp], eax
  00015	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00019	85 c0		 test	 eax, eax
  0001b	74 14		 je	 SHORT $LN3@Construct@2
  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  00020	8a 11		 mov	 dl, BYTE PTR [ecx]
  00022	83 c1 04	 add	 ecx, 4
  00025	51		 push	 ecx
  00026	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00029	88 10		 mov	 BYTE PTR [eax], dl
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
$LN3@Construct@2:

; 49   : 	}

  00031	e8 00 00 00 00	 call	 __EH_epilog3
  00036	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@UtagMecroTextInfo@CKeyInfo@@ABU12@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@ABU12@@Z$0:
  00000	ff 75 08	 push	 DWORD PTR __Vptr$[ebp]
  00003	ff 75 f0	 push	 DWORD PTR $T517557[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000b	59		 pop	 ecx
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
__ehhandler$??$_Construct@UtagMecroTextInfo@CKeyInfo@@ABU12@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@ABU12@@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@UtagMecroTextInfo@CKeyInfo@@ABU12@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@ABU12@@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@UtagMecroTextInfo@CKeyInfo@@ABU12@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@ABU12@@Z ENDP ; std::_Construct<CKeyInfo::tagMecroTextInfo,CKeyInfo::tagMecroTextInfo const &>
PUBLIC	??_G?$pair@$$CBGVioHashString@@@std@@QAEPAXI@Z	; std::pair<unsigned short const ,ioHashString>::`scalar deleting destructor'
; Function compile flags: /Ogsp
;	COMDAT ??_G?$pair@$$CBGVioHashString@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$pair@$$CBGVioHashString@@@std@@QAEPAXI@Z PROC	; std::pair<unsigned short const ,ioHashString>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  0000f	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00013	74 07		 je	 SHORT $LN1@scalar@3
  00015	56		 push	 esi
  00016	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001b	59		 pop	 ecx
$LN1@scalar@3:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$pair@$$CBGVioHashString@@@std@@QAEPAXI@Z ENDP	; std::pair<unsigned short const ,ioHashString>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Buynode
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Buynode@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
$T517613 = -16						; size = 12
$T517597 = -4						; size = 4
?_Buynode@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 559  : 		{	// allocate a node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00007	6a 24		 push	 36			; 00000024H
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	59		 pop	 ecx
  00011	33 c9		 xor	 ecx, ecx
  00013	3b c1		 cmp	 eax, ecx
  00015	74 18		 je	 SHORT $LN5@Buynode

; 561  : 
; 562  : 		this->_Left(_Wherenode) = this->_Myhead;

  00017	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0001a	89 10		 mov	 DWORD PTR [eax], edx

; 563  : 		this->_Parent(_Wherenode) = this->_Myhead;

  0001c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0001f	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 564  : 		this->_Right(_Wherenode) = this->_Myhead;

  00022	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00025	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 565  : 		this->_Color(_Wherenode) = this->_Red;

  00028	66 89 48 20	 mov	 WORD PTR [eax+32], cx
  0002c	5e		 pop	 esi

; 566  : 		this->_Isnil(_Wherenode) = false;
; 567  : 		return (_Wherenode);
; 568  : 		}

  0002d	c9		 leave
  0002e	c3		 ret	 0

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

$LN5@Buynode:
  0002f	8d 45 fc	 lea	 eax, DWORD PTR $T517597[ebp]
  00032	89 4d fc	 mov	 DWORD PTR $T517597[ebp], ecx
  00035	50		 push	 eax
  00036	8d 4d f0	 lea	 ecx, DWORD PTR $T517613[ebp]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
  0003f	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00044	8d 45 f0	 lea	 eax, DWORD PTR $T517613[ebp]
  00047	50		 push	 eax
  00048	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T517613[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004f	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN27@Buynode:
$LN26@Buynode:
  00054	cc		 int	 3
?_Buynode@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > > &,bool>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000f	8a 09		 mov	 cl, BYTE PTR [ecx]
  00011	88 48 04	 mov	 BYTE PTR [eax+4], cl

; 164  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	??$_Destroy@UtagMecroTextInfo@CKeyInfo@@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@@Z ; std::_Destroy<CKeyInfo::tagMecroTextInfo>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy@UtagMecroTextInfo@CKeyInfo@@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UtagMecroTextInfo@CKeyInfo@@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@@Z PROC ; std::_Destroy<CKeyInfo::tagMecroTextInfo>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 63   : 	_Ptr->~_Ty();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	83 c1 04	 add	 ecx, 4

; 64   : 	}

  00009	5d		 pop	 ebp

; 63   : 	_Ptr->~_Ty();

  0000a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
??$_Destroy@UtagMecroTextInfo@CKeyInfo@@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@@Z ENDP ; std::_Destroy<CKeyInfo::tagMecroTextInfo>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@$$QAU34@@Z ; std::allocator<CKeyInfo::tagMecroTextInfo>::construct
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@$$QAU34@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@$$QAU34@@Z$0
__ehfuncinfo$?construct@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@$$QAU34@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@$$QAU34@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@$$QAU34@@Z
_TEXT	SEGMENT
$T517666 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@$$QAU34@@Z PROC ; std::allocator<CKeyInfo::tagMecroTextInfo>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?construct@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@$$QAU34@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR $T517666[ebp], eax
  00012	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00016	85 c0		 test	 eax, eax
  00018	74 14		 je	 SHORT $LN3@construct@5
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0001d	8a 11		 mov	 dl, BYTE PTR [ecx]
  0001f	83 c1 04	 add	 ecx, 4
  00022	51		 push	 ecx
  00023	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00026	88 10		 mov	 BYTE PTR [eax], dl
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z
$LN3@construct@5:

; 203  : 		}

  0002e	e8 00 00 00 00	 call	 __EH_epilog3
  00033	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@$$QAU34@@Z$0:
  00000	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00003	ff 75 f0	 push	 DWORD PTR $T517666[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000b	59		 pop	 ecx
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
__ehhandler$?construct@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@$$QAU34@@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@$$QAU34@@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@$$QAU34@@Z ENDP ; std::allocator<CKeyInfo::tagMecroTextInfo>::construct
PUBLIC	??0?$_Pair_base@$$CBGVioHashString@@@std@@QAE@$$QBG$$QAVioHashString@@@Z ; std::_Pair_base<unsigned short const ,ioHashString>::_Pair_base<unsigned short const ,ioHashString>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$_Pair_base@$$CBGVioHashString@@@std@@QAE@$$QBG$$QAVioHashString@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@$$CBGVioHashString@@@std@@QAE@$$QBG$$QAVioHashString@@@Z PROC ; std::_Pair_base<unsigned short const ,ioHashString>::_Pair_base<unsigned short const ,ioHashString>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	66 8b 00	 mov	 ax, WORD PTR [eax]
  00009	56		 push	 esi
  0000a	ff 75 0c	 push	 DWORD PTR __Val2$[ebp]
  0000d	8b f1		 mov	 esi, ecx
  0000f	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00012	66 89 06	 mov	 WORD PTR [esi], ax
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z

; 146  : 		}

  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
??0?$_Pair_base@$$CBGVioHashString@@@std@@QAE@$$QBG$$QAVioHashString@@@Z ENDP ; std::_Pair_base<unsigned short const ,ioHashString>::_Pair_base<unsigned short const ,ioHashString>
_TEXT	ENDS
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
; Function compile flags: /Ogsp
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 101  : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 102  : 	_Ty _Tmp = _Move(_Left);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	56		 push	 esi

; 103  : 	_Left = _Move(_Right);

  00009	8b 75 0c	 mov	 esi, DWORD PTR __Right$[ebp]
  0000c	8a 16		 mov	 dl, BYTE PTR [esi]
  0000e	88 10		 mov	 BYTE PTR [eax], dl

; 104  : 	_Right = _Move(_Tmp);

  00010	88 0e		 mov	 BYTE PTR [esi], cl
  00012	5e		 pop	 esi

; 105  : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
_TEXT	ENDS
PUBLIC	??_C@_03CCEPDEKL@Key?$AA@			; `string'
PUBLIC	??_C@_07NGFJPNPN@Version?$AA@			; `string'
PUBLIC	??_C@_01NOFIACDB@w?$AA@				; `string'
PUBLIC	??_C@_04INACKGJP@Save?$AA@			; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	_this$GSCopy$
PUBLIC	?SaveKey@CCustomKeyInfo@@UAEXXZ			; CCustomKeyInfo::SaveKey
EXTRN	__imp_?SaveInt@ioINILoader@@QAEXPBDH@Z:PROC
EXTRN	__imp_??0ioINILoader@@QAE@PBD_N@Z:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__CreateDirectoryA@8:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp_?c_str@ioHashString@@QBEPBDXZ:PROC
EXTRN	__imp_?IsEmpty@ioHashString@@QBE_NXZ:PROC
EXTRN	?GetSingleton@ioMyInfo@@SAAAV1@XZ:PROC		; ioMyInfo::GetSingleton
EXTRN	__EH_epilog3_GS:PROC
EXTRN	__EH_prolog3_GS:PROC
;	COMDAT ??_C@_03CCEPDEKL@Key?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
CONST	SEGMENT
??_C@_03CCEPDEKL@Key?$AA@ DB 'Key', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07NGFJPNPN@Version?$AA@
CONST	SEGMENT
??_C@_07NGFJPNPN@Version?$AA@ DB 'Version', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST	SEGMENT
??_C@_01NOFIACDB@w?$AA@ DB 'w', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04INACKGJP@Save?$AA@
CONST	SEGMENT
??_C@_04INACKGJP@Save?$AA@ DB 'Save', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SaveKey@CCustomKeyInfo@@UAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SaveKey@CCustomKeyInfo@@UAEXXZ$0
__ehfuncinfo$?SaveKey@CCustomKeyInfo@@UAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SaveKey@CCustomKeyInfo@@UAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iokeymanager.cpp
xdata$x	ENDS
;	COMDAT ?SaveKey@CCustomKeyInfo@@UAEXXZ
_TEXT	SEGMENT
_this$GSCopy$ = -1116					; size = 4
_kLoader$ = -1112					; size = 784
_fName$ = -328						; size = 260
___encStr$506437 = -68					; size = 8
__t$517804 = -56					; size = 7
___encStr$506590 = -44					; size = 22
___encStr$506283 = -44					; size = 22
__$EHRec$ = -12						; size = 12
?SaveKey@CCustomKeyInfo@@UAEXXZ PROC			; CCustomKeyInfo::SaveKey, COMDAT
; _this$ = ecx

; 595  : {

  00000	68 50 04 00 00	 push	 1104			; 00000450H
  00005	b8 00 00 00 00	 mov	 eax, __ehhandler$?SaveKey@CCustomKeyInfo@@UAEXXZ
  0000a	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000f	89 8d a4 fb ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], ecx

; 596  : 	if(g_MyInfo.GetPublicID().IsEmpty()) return;

  00015	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  0001a	8d 48 1c	 lea	 ecx, DWORD PTR [eax+28]
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00023	84 c0		 test	 al, al
  00025	0f 85 60 02 00
	00		 jne	 $LN305@SaveKey

; 597  : 
; 598  : 	char fName[MAX_PATH]="";

  0002b	33 db		 xor	 ebx, ebx
  0002d	68 03 01 00 00	 push	 259			; 00000103H
  00032	8d 85 b9 fe ff
	ff		 lea	 eax, DWORD PTR _fName$[ebp+1]
  00038	53		 push	 ebx
  00039	50		 push	 eax
  0003a	88 9d b8 fe ff
	ff		 mov	 BYTE PTR _fName$[ebp], bl
  00040	e8 00 00 00 00	 call	 _memset
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
  00048	6a 05		 push	 5

; 599  : 	StringCbPrintf_e( fName, sizeof(fName), "Save\\%s\\customkey.ini",g_MyInfo.GetPublicID().c_str() );

  0004a	c7 45 d4 be 8d
	9d 8f		 mov	 DWORD PTR ___encStr$506283[ebp], -1885499970 ; 8f9d8dbeH
  00051	c7 45 d8 b1 c9
	98 b6		 mov	 DWORD PTR ___encStr$506283[ebp+4], -1231500879 ; b698c9b1H
  00058	c7 45 dc 8e 99
	98 9e		 mov	 DWORD PTR ___encStr$506283[ebp+8], -1634166386 ; 9e98998eH
  0005f	c7 45 e0 82 81
	80 8f		 mov	 DWORD PTR ___encStr$506283[ebp+12], -1887403646 ; 8f808182H
  00066	c7 45 e4 94 c2
	82 84		 mov	 DWORD PTR ___encStr$506283[ebp+16], -2071805292 ; 8482c294H
  0006d	8d 45 d4	 lea	 eax, DWORD PTR ___encStr$506283[ebp]
  00070	66 c7 45 e8 84
	00		 mov	 WORD PTR ___encStr$506283[ebp+20], 132 ; 00000084H
  00076	59		 pop	 ecx
$LL315@SaveKey:
  00077	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0007d	83 c0 04	 add	 eax, 4
  00080	49		 dec	 ecx
  00081	75 f4		 jne	 SHORT $LL315@SaveKey
  00083	80 75 e8 ed	 xor	 BYTE PTR ___encStr$506283[ebp+20], -19 ; ffffffedH
  00087	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  0008c	8d 48 1c	 lea	 ecx, DWORD PTR [eax+28]
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00095	50		 push	 eax
  00096	8d 45 d4	 lea	 eax, DWORD PTR ___encStr$506283[ebp]
  00099	50		 push	 eax
  0009a	bf 04 01 00 00	 mov	 edi, 260		; 00000104H
  0009f	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR _fName$[ebp]
  000a5	57		 push	 edi
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 ?StringCbPrintfA@@YAJPADIPBDZZ ; StringCbPrintfA

; 600  : 
; 601  : 	FILE *fp = fopen( fName, "r" );

  000ac	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR _fName$[ebp]
  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  000b7	50		 push	 eax
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  000be	83 c4 18	 add	 esp, 24			; 00000018H

; 602  : 	if( !fp )

  000c1	3b c3		 cmp	 eax, ebx
  000c3	0f 85 eb 00 00
	00		 jne	 $LN5@SaveKey

; 603  : 	{
; 604  : 		StringCbPrintf_e( fName, sizeof( fName ), "Save\\%s" , g_MyInfo.GetPublicID().c_str() );

  000c9	6a 04		 push	 4
  000cb	c7 45 bc be 8d
	9d 8f		 mov	 DWORD PTR ___encStr$506437[ebp], -1885499970 ; 8f9d8dbeH
  000d2	81 75 bc ed ec
	eb ea		 xor	 DWORD PTR ___encStr$506437[ebp], -353637139 ; eaebecedH
  000d9	c7 45 c0 b1 c9
	98 00		 mov	 DWORD PTR ___encStr$506437[ebp+4], 10013105 ; 0098c9b1H
  000e0	5e		 pop	 esi
$LL322@SaveKey:
  000e1	8b c6		 mov	 eax, esi
  000e3	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  000e8	79 05		 jns	 SHORT $LN471@SaveKey
  000ea	48		 dec	 eax
  000eb	83 c8 fc	 or	 eax, -4			; fffffffcH
  000ee	40		 inc	 eax
$LN471@SaveKey:
  000ef	b1 ed		 mov	 cl, -19			; ffffffedH
  000f1	2a c8		 sub	 cl, al
  000f3	30 4c 35 bc	 xor	 BYTE PTR ___encStr$506437[ebp+esi], cl
  000f7	46		 inc	 esi
  000f8	83 fe 07	 cmp	 esi, 7
  000fb	7c e4		 jl	 SHORT $LL322@SaveKey
  000fd	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  00102	8d 48 1c	 lea	 ecx, DWORD PTR [eax+28]
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  0010b	50		 push	 eax
  0010c	8d 45 bc	 lea	 eax, DWORD PTR ___encStr$506437[ebp]
  0010f	50		 push	 eax
  00110	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR _fName$[ebp]
  00116	57		 push	 edi
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 ?StringCbPrintfA@@YAJPADIPBDZZ ; StringCbPrintfA

; 605  : 		CreateDirectory( "Save", NULL );

  0011d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CreateDirectoryA@8
  00123	83 c4 10	 add	 esp, 16			; 00000010H
  00126	53		 push	 ebx
  00127	68 00 00 00 00	 push	 OFFSET ??_C@_04INACKGJP@Save?$AA@
  0012c	ff d6		 call	 esi

; 606  : 		CreateDirectory( fName, NULL );

  0012e	53		 push	 ebx
  0012f	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR _fName$[ebp]
  00135	50		 push	 eax
  00136	ff d6		 call	 esi
  00138	6a 05		 push	 5

; 607  : 		StringCbPrintf_e( fName, sizeof( fName ), "Save\\%s\\customkey.ini", g_MyInfo.GetPublicID().c_str() );

  0013a	c7 45 d4 be 8d
	9d 8f		 mov	 DWORD PTR ___encStr$506590[ebp], -1885499970 ; 8f9d8dbeH
  00141	c7 45 d8 b1 c9
	98 b6		 mov	 DWORD PTR ___encStr$506590[ebp+4], -1231500879 ; b698c9b1H
  00148	c7 45 dc 8e 99
	98 9e		 mov	 DWORD PTR ___encStr$506590[ebp+8], -1634166386 ; 9e98998eH
  0014f	c7 45 e0 82 81
	80 8f		 mov	 DWORD PTR ___encStr$506590[ebp+12], -1887403646 ; 8f808182H
  00156	c7 45 e4 94 c2
	82 84		 mov	 DWORD PTR ___encStr$506590[ebp+16], -2071805292 ; 8482c294H
  0015d	8d 45 d4	 lea	 eax, DWORD PTR ___encStr$506590[ebp]
  00160	66 c7 45 e8 84
	00		 mov	 WORD PTR ___encStr$506590[ebp+20], 132 ; 00000084H
  00166	59		 pop	 ecx
$LL335@SaveKey:
  00167	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0016d	83 c0 04	 add	 eax, 4
  00170	49		 dec	 ecx
  00171	75 f4		 jne	 SHORT $LL335@SaveKey
  00173	80 75 e8 ed	 xor	 BYTE PTR ___encStr$506590[ebp+20], -19 ; ffffffedH
  00177	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  0017c	8d 48 1c	 lea	 ecx, DWORD PTR [eax+28]
  0017f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00185	50		 push	 eax
  00186	8d 45 d4	 lea	 eax, DWORD PTR ___encStr$506590[ebp]
  00189	50		 push	 eax
  0018a	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR _fName$[ebp]
  00190	57		 push	 edi
  00191	50		 push	 eax
  00192	e8 00 00 00 00	 call	 ?StringCbPrintfA@@YAJPADIPBDZZ ; StringCbPrintfA

; 608  : 
; 609  : 		fp = fopen( fName, "w" );

  00197	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR _fName$[ebp]
  0019d	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  001a2	50		 push	 eax
  001a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  001a9	83 c4 18	 add	 esp, 24			; 00000018H

; 610  : 		if( !fp )

  001ac	3b c3		 cmp	 eax, ebx
  001ae	0f 84 d7 00 00
	00		 je	 $LN305@SaveKey
$LN5@SaveKey:

; 611  : 			return;
; 612  : 	}
; 613  : 	fclose( fp );

  001b4	50		 push	 eax
  001b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  001bb	59		 pop	 ecx

; 614  : 
; 615  : 	ioINILoader kLoader( fName, false );

  001bc	53		 push	 ebx
  001bd	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR _fName$[ebp]
  001c3	50		 push	 eax
  001c4	8d 8d a8 fb ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  001ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioINILoader@@QAE@PBD_N@Z

; 616  : 	kLoader.SetTitle_e( "Common" );

  001d0	6a 04		 push	 4
  001d2	c7 45 c8 ae 83
	86 87		 mov	 DWORD PTR __t$517804[ebp], -2021227602 ; 878683aeH
  001d9	81 75 c8 ed ec
	eb ea		 xor	 DWORD PTR __t$517804[ebp], -353637139 ; eaebecedH
  001e0	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  001e3	66 c7 45 cc 82
	82		 mov	 WORD PTR __t$517804[ebp+4], 33410 ; 00008282H
  001e9	88 5d ce	 mov	 BYTE PTR __t$517804[ebp+6], bl
  001ec	5e		 pop	 esi
$LL440@SaveKey:
  001ed	8b c6		 mov	 eax, esi
  001ef	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  001f4	79 05		 jns	 SHORT $LN472@SaveKey
  001f6	48		 dec	 eax
  001f7	83 c8 fc	 or	 eax, -4			; fffffffcH
  001fa	40		 inc	 eax
$LN472@SaveKey:
  001fb	b1 ed		 mov	 cl, -19			; ffffffedH
  001fd	2a c8		 sub	 cl, al
  001ff	30 4c 35 c8	 xor	 BYTE PTR __t$517804[ebp+esi], cl
  00203	46		 inc	 esi
  00204	83 fe 06	 cmp	 esi, 6
  00207	7c e4		 jl	 SHORT $LL440@SaveKey
  00209	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z
  0020f	8d 45 c8	 lea	 eax, DWORD PTR __t$517804[ebp]
  00212	50		 push	 eax
  00213	8d 8d a8 fb ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00219	ff d7		 call	 edi

; 617  : 	kLoader.SaveInt("Version" , CUSTOMKEY_VERSION );

  0021b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?SaveInt@ioINILoader@@QAEXPBDH@Z
  00221	68 73 51 33 01	 push	 20140403		; 01335173H
  00226	68 00 00 00 00	 push	 OFFSET ??_C@_07NGFJPNPN@Version?$AA@
  0022b	8d 8d a8 fb ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00231	ff d6		 call	 esi

; 618  : 
; 619  : 	kLoader.SetTitle( "Key" );

  00233	68 00 00 00 00	 push	 OFFSET ??_C@_03CCEPDEKL@Key?$AA@
  00238	8d 8d a8 fb ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0023e	ff d7		 call	 edi

; 620  : 	int iMax = m_vKeyInfo.size();

  00240	8b 8d a4 fb ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00246	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]
  00249	2b 79 04	 sub	 edi, DWORD PTR [ecx+4]
  0024c	d1 ff		 sar	 edi, 1

; 621  : 	for (int i = 0; i < iMax ; i++)

  0024e	3b fb		 cmp	 edi, ebx
  00250	7e 29		 jle	 SHORT $LN459@SaveKey
  00252	eb 06		 jmp	 SHORT $LN4@SaveKey
$LL469@SaveKey:
  00254	8b 8d a4 fb ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
$LN4@SaveKey:

; 622  : 	{
; 623  : 		if( i >= KTA_MAX ) break;

  0025a	83 fb 5f	 cmp	 ebx, 95			; 0000005fH
  0025d	7d 1c		 jge	 SHORT $LN459@SaveKey

; 624  : 		kLoader.SaveInt(GetINIKeyName((KeyTypeArray)i), m_vKeyInfo[i]);

  0025f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00262	0f b7 04 58	 movzx	 eax, WORD PTR [eax+ebx*2]
  00266	50		 push	 eax
  00267	53		 push	 ebx
  00268	e8 00 00 00 00	 call	 ?GetINIKeyName@CKeyInfo@@IAEPADW4KeyTypeArray@1@@Z ; CKeyInfo::GetINIKeyName
  0026d	50		 push	 eax
  0026e	8d 8d a8 fb ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00274	ff d6		 call	 esi
  00276	43		 inc	 ebx
  00277	3b df		 cmp	 ebx, edi
  00279	7c d9		 jl	 SHORT $LL469@SaveKey
$LN459@SaveKey:

; 625  : 	}
; 626  : }

  0027b	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0027f	8d 8d a8 fb ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00285	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioINILoader@@QAE@XZ
$LN305@SaveKey:
  0028b	e8 00 00 00 00	 call	 __EH_epilog3_GS
  00290	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SaveKey@CCustomKeyInfo@@UAEXXZ$0:
  00000	8d 8d a8 fb ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioINILoader@@QAE@XZ
__ehhandler$?SaveKey@CCustomKeyInfo@@UAEXXZ:
  0000c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00010	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00013	8b 8a a0 fb ff
	ff		 mov	 ecx, DWORD PTR [edx-1120]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SaveKey@CCustomKeyInfo@@UAEXXZ
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SaveKey@CCustomKeyInfo@@UAEXXZ ENDP			; CCustomKeyInfo::SaveKey
PUBLIC	_this$GSCopy$
PUBLIC	?SaveMacroTextInfo@CCustomKeyInfo@@UAEXXZ	; CCustomKeyInfo::SaveMacroTextInfo
EXTRN	__imp_?SaveBool@ioINILoader@@QAEXPBD_N@Z:PROC
EXTRN	__imp_?SaveString@ioINILoader@@QAEXPBD0@Z:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?SaveMacroTextInfo@CCustomKeyInfo@@UAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SaveMacroTextInfo@CCustomKeyInfo@@UAEXXZ$0
__ehfuncinfo$?SaveMacroTextInfo@CCustomKeyInfo@@UAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SaveMacroTextInfo@CCustomKeyInfo@@UAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iokeymanager.cpp
xdata$x	ENDS
;	COMDAT ?SaveMacroTextInfo@CCustomKeyInfo@@UAEXXZ
_TEXT	SEGMENT
_iMax$ = -1392						; size = 4
_this$GSCopy$ = -1388					; size = 4
tv4244 = -1384						; size = 4
tv3746 = -1380						; size = 4
_i$506906 = -1380					; size = 4
_kLoader$ = -1376					; size = 784
_fName$ = -592						; size = 260
_szKeyName$506911 = -332				; size = 260
___encStr$506756 = -72					; size = 22
__t$518089 = -44					; size = 10
___encStr$507066 = -44					; size = 7
__t$517991 = -28					; size = 7
___encStr$506915 = -28					; size = 7
__$EHRec$ = -12						; size = 12
?SaveMacroTextInfo@CCustomKeyInfo@@UAEXXZ PROC		; CCustomKeyInfo::SaveMacroTextInfo, COMDAT
; _this$ = ecx

; 629  : {

  00000	68 64 05 00 00	 push	 1380			; 00000564H
  00005	b8 00 00 00 00	 mov	 eax, __ehhandler$?SaveMacroTextInfo@CCustomKeyInfo@@UAEXXZ
  0000a	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000f	89 8d 94 fa ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], ecx

; 630  : 	if(g_MyInfo.GetPublicID().IsEmpty()) return;

  00015	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  0001a	8d 48 1c	 lea	 ecx, DWORD PTR [eax+28]
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00023	84 c0		 test	 al, al
  00025	0f 85 b7 02 00
	00		 jne	 $LN303@SaveMacroT@2

; 631  : 
; 632  : 	char fName[MAX_PATH]="";

  0002b	33 db		 xor	 ebx, ebx
  0002d	68 03 01 00 00	 push	 259			; 00000103H
  00032	8d 85 b1 fd ff
	ff		 lea	 eax, DWORD PTR _fName$[ebp+1]
  00038	53		 push	 ebx
  00039	50		 push	 eax
  0003a	88 9d b0 fd ff
	ff		 mov	 BYTE PTR _fName$[ebp], bl
  00040	e8 00 00 00 00	 call	 _memset
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
  00048	6a 05		 push	 5

; 633  : 	StringCbPrintf_e( fName, sizeof(fName), "Save\\%s\\customkey.ini",g_MyInfo.GetPublicID().c_str() );

  0004a	c7 45 b8 be 8d
	9d 8f		 mov	 DWORD PTR ___encStr$506756[ebp], -1885499970 ; 8f9d8dbeH
  00051	c7 45 bc b1 c9
	98 b6		 mov	 DWORD PTR ___encStr$506756[ebp+4], -1231500879 ; b698c9b1H
  00058	c7 45 c0 8e 99
	98 9e		 mov	 DWORD PTR ___encStr$506756[ebp+8], -1634166386 ; 9e98998eH
  0005f	c7 45 c4 82 81
	80 8f		 mov	 DWORD PTR ___encStr$506756[ebp+12], -1887403646 ; 8f808182H
  00066	c7 45 c8 94 c2
	82 84		 mov	 DWORD PTR ___encStr$506756[ebp+16], -2071805292 ; 8482c294H
  0006d	8d 45 b8	 lea	 eax, DWORD PTR ___encStr$506756[ebp]
  00070	66 c7 45 cc 84
	00		 mov	 WORD PTR ___encStr$506756[ebp+20], 132 ; 00000084H
  00076	59		 pop	 ecx
  00077	bf ed ec eb ea	 mov	 edi, -353637139		; eaebecedH
$LL313@SaveMacroT@2:
  0007c	31 38		 xor	 DWORD PTR [eax], edi
  0007e	83 c0 04	 add	 eax, 4
  00081	49		 dec	 ecx
  00082	75 f8		 jne	 SHORT $LL313@SaveMacroT@2
  00084	80 75 cc ed	 xor	 BYTE PTR ___encStr$506756[ebp+20], -19 ; ffffffedH
  00088	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  0008d	8d 48 1c	 lea	 ecx, DWORD PTR [eax+28]
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00096	50		 push	 eax
  00097	8d 45 b8	 lea	 eax, DWORD PTR ___encStr$506756[ebp]
  0009a	50		 push	 eax
  0009b	be 04 01 00 00	 mov	 esi, 260		; 00000104H
  000a0	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR _fName$[ebp]
  000a6	56		 push	 esi
  000a7	50		 push	 eax
  000a8	e8 00 00 00 00	 call	 ?StringCbPrintfA@@YAJPADIPBDZZ ; StringCbPrintfA
  000ad	83 c4 10	 add	 esp, 16			; 00000010H

; 634  : 
; 635  : 	ioINILoader kLoader( fName, false );

  000b0	53		 push	 ebx
  000b1	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR _fName$[ebp]
  000b7	50		 push	 eax
  000b8	8d 8d a0 fa ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioINILoader@@QAE@PBD_N@Z

; 636  : 	kLoader.SetTitle_e( "Common" );

  000c4	6a 04		 push	 4
  000c6	c7 45 e4 ae 83
	86 87		 mov	 DWORD PTR __t$517991[ebp], -2021227602 ; 878683aeH
  000cd	31 7d e4	 xor	 DWORD PTR __t$517991[ebp], edi
  000d0	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  000d3	66 c7 45 e8 82
	82		 mov	 WORD PTR __t$517991[ebp+4], 33410 ; 00008282H
  000d9	88 5d ea	 mov	 BYTE PTR __t$517991[ebp+6], bl
  000dc	58		 pop	 eax
$LL418@SaveMacroT@2:
  000dd	8b c8		 mov	 ecx, eax
  000df	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  000e5	79 05		 jns	 SHORT $LN577@SaveMacroT@2
  000e7	49		 dec	 ecx
  000e8	83 c9 fc	 or	 ecx, -4			; fffffffcH
  000eb	41		 inc	 ecx
$LN577@SaveMacroT@2:
  000ec	b2 ed		 mov	 dl, -19			; ffffffedH
  000ee	2a d1		 sub	 dl, cl
  000f0	30 54 05 e4	 xor	 BYTE PTR __t$517991[ebp+eax], dl
  000f4	40		 inc	 eax
  000f5	83 f8 06	 cmp	 eax, 6
  000f8	7c e3		 jl	 SHORT $LL418@SaveMacroT@2
  000fa	8d 45 e4	 lea	 eax, DWORD PTR __t$517991[ebp]
  000fd	50		 push	 eax
  000fe	8d 8d a0 fa ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00104	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z

; 637  : 	kLoader.SaveInt("Version" , CUSTOMKEY_VERSION );

  0010a	68 73 51 33 01	 push	 20140403		; 01335173H
  0010f	68 00 00 00 00	 push	 OFFSET ??_C@_07NGFJPNPN@Version?$AA@
  00114	8d 8d a0 fa ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SaveInt@ioINILoader@@QAEXPBDH@Z
  00120	6a 02		 push	 2

; 638  : 
; 639  : 	kLoader.SetTitle_e( "MacroText" );

  00122	c7 45 d4 a0 8d
	88 98		 mov	 DWORD PTR __t$518089[ebp], -1735881312 ; 98888da0H
  00129	c7 45 d8 82 b8
	8e 92		 mov	 DWORD PTR __t$518089[ebp+4], -1836140414 ; 928eb882H
  00130	8d 45 d4	 lea	 eax, DWORD PTR __t$518089[ebp]
  00133	66 c7 45 dc 99
	00		 mov	 WORD PTR __t$518089[ebp+8], 153 ; 00000099H
  00139	59		 pop	 ecx
$LL527@SaveMacroT@2:
  0013a	31 38		 xor	 DWORD PTR [eax], edi
  0013c	83 c0 04	 add	 eax, 4
  0013f	49		 dec	 ecx
  00140	75 f8		 jne	 SHORT $LL527@SaveMacroT@2
  00142	80 75 dc ed	 xor	 BYTE PTR __t$518089[ebp+8], -19 ; ffffffedH
  00146	8d 45 d4	 lea	 eax, DWORD PTR __t$518089[ebp]
  00149	50		 push	 eax
  0014a	8d 8d a0 fa ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00150	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z

; 640  : 	int iMax = m_vMecroTextInfo.size();

  00156	8b 8d 94 fa ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0015c	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  0015f	2b 41 14	 sub	 eax, DWORD PTR [ecx+20]
  00162	6a 14		 push	 20			; 00000014H
  00164	99		 cdq
  00165	59		 pop	 ecx
  00166	f7 f9		 idiv	 ecx

; 641  : 	for(int i = 0; i < iMax; i++)

  00168	89 9d 9c fa ff
	ff		 mov	 DWORD PTR _i$506906[ebp], ebx
  0016e	89 85 90 fa ff
	ff		 mov	 DWORD PTR _iMax$[ebp], eax
  00174	3b c3		 cmp	 eax, ebx
  00176	0f 8e 56 01 00
	00		 jle	 $LN563@SaveMacroT@2

; 638  : 
; 639  : 	kLoader.SetTitle_e( "MacroText" );

  0017c	89 9d 98 fa ff
	ff		 mov	 DWORD PTR tv4244[ebp], ebx
$LN202@SaveMacroT@2:

; 642  : 	{
; 643  : 		if(i >= MAX_MACRO ) break;

  00182	81 bd 98 fa ff
	ff f0 00 00 00	 cmp	 DWORD PTR tv4244[ebp], 240 ; 000000f0H
  0018c	0f 8d 40 01 00
	00		 jge	 $LN563@SaveMacroT@2

; 644  : 
; 645  : 		char szKeyName[MAX_PATH]="";

  00192	68 03 01 00 00	 push	 259			; 00000103H
  00197	8d 85 b5 fe ff
	ff		 lea	 eax, DWORD PTR _szKeyName$506911[ebp+1]
  0019d	53		 push	 ebx
  0019e	50		 push	 eax
  0019f	88 9d b4 fe ff
	ff		 mov	 BYTE PTR _szKeyName$506911[ebp], bl
  001a5	e8 00 00 00 00	 call	 _memset
  001aa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 646  : 		StringCbPrintf_e(szKeyName, sizeof(szKeyName), "Text%d", i+1);

  001ad	6a 04		 push	 4
  001af	c7 45 e4 b9 89
	93 9e		 mov	 DWORD PTR ___encStr$506915[ebp], -1634498119 ; 9e9389b9H
  001b6	31 7d e4	 xor	 DWORD PTR ___encStr$506915[ebp], edi
  001b9	66 c7 45 e8 c8
	88		 mov	 WORD PTR ___encStr$506915[ebp+4], 35016 ; 000088c8H
  001bf	88 5d ea	 mov	 BYTE PTR ___encStr$506915[ebp+6], bl
  001c2	58		 pop	 eax
$LL534@SaveMacroT@2:
  001c3	8b c8		 mov	 ecx, eax
  001c5	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  001cb	79 05		 jns	 SHORT $LN578@SaveMacroT@2
  001cd	49		 dec	 ecx
  001ce	83 c9 fc	 or	 ecx, -4			; fffffffcH
  001d1	41		 inc	 ecx
$LN578@SaveMacroT@2:
  001d2	b2 ed		 mov	 dl, -19			; ffffffedH
  001d4	2a d1		 sub	 dl, cl
  001d6	30 54 05 e4	 xor	 BYTE PTR ___encStr$506915[ebp+eax], dl
  001da	40		 inc	 eax
  001db	83 f8 06	 cmp	 eax, 6
  001de	7c e3		 jl	 SHORT $LL534@SaveMacroT@2
  001e0	8b 85 9c fa ff
	ff		 mov	 eax, DWORD PTR _i$506906[ebp]
  001e6	40		 inc	 eax
  001e7	50		 push	 eax
  001e8	89 85 9c fa ff
	ff		 mov	 DWORD PTR tv3746[ebp], eax
  001ee	8d 45 e4	 lea	 eax, DWORD PTR ___encStr$506915[ebp]
  001f1	50		 push	 eax
  001f2	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _szKeyName$506911[ebp]
  001f8	56		 push	 esi
  001f9	50		 push	 eax
  001fa	e8 00 00 00 00	 call	 ?StringCbPrintfA@@YAJPADIPBDZZ ; StringCbPrintfA

; 647  : 		kLoader.SaveString(szKeyName, m_vMecroTextInfo[i].m_szText.c_str());

  001ff	8b 85 94 fa ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$[ebp]
  00205	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00208	03 8d 98 fa ff
	ff		 add	 ecx, DWORD PTR tv4244[ebp]
  0020e	83 c4 10	 add	 esp, 16			; 00000010H
  00211	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]
  00214	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  0021a	50		 push	 eax
  0021b	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _szKeyName$506911[ebp]
  00221	50		 push	 eax
  00222	8d 8d a0 fa ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00228	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SaveString@ioINILoader@@QAEXPBD0@Z

; 648  : 
; 649  : 		ZeroMemory( szKeyName, sizeof(szKeyName) );

  0022e	56		 push	 esi
  0022f	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _szKeyName$506911[ebp]
  00235	53		 push	 ebx
  00236	50		 push	 eax
  00237	e8 00 00 00 00	 call	 _memset
  0023c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 650  : 		StringCbPrintf_e(szKeyName, sizeof(szKeyName), "Type%d", i+1);

  0023f	6a 04		 push	 4
  00241	c7 45 d4 b9 95
	9b 8f		 mov	 DWORD PTR ___encStr$507066[ebp], -1885628999 ; 8f9b95b9H
  00248	31 7d d4	 xor	 DWORD PTR ___encStr$507066[ebp], edi
  0024b	66 c7 45 d8 c8
	88		 mov	 WORD PTR ___encStr$507066[ebp+4], 35016 ; 000088c8H
  00251	88 5d da	 mov	 BYTE PTR ___encStr$507066[ebp+6], bl
  00254	58		 pop	 eax
$LL544@SaveMacroT@2:
  00255	8b c8		 mov	 ecx, eax
  00257	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0025d	79 05		 jns	 SHORT $LN579@SaveMacroT@2
  0025f	49		 dec	 ecx
  00260	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00263	41		 inc	 ecx
$LN579@SaveMacroT@2:
  00264	b2 ed		 mov	 dl, -19			; ffffffedH
  00266	2a d1		 sub	 dl, cl
  00268	30 54 05 d4	 xor	 BYTE PTR ___encStr$507066[ebp+eax], dl
  0026c	40		 inc	 eax
  0026d	83 f8 06	 cmp	 eax, 6
  00270	7c e3		 jl	 SHORT $LL544@SaveMacroT@2
  00272	ff b5 9c fa ff
	ff		 push	 DWORD PTR tv3746[ebp]
  00278	8d 45 d4	 lea	 eax, DWORD PTR ___encStr$507066[ebp]
  0027b	50		 push	 eax
  0027c	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _szKeyName$506911[ebp]
  00282	56		 push	 esi
  00283	50		 push	 eax
  00284	e8 00 00 00 00	 call	 ?StringCbPrintfA@@YAJPADIPBDZZ ; StringCbPrintfA

; 651  : 		kLoader.SaveBool( szKeyName, m_vMecroTextInfo[i].m_bAll );

  00289	8b 85 94 fa ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$[ebp]
  0028f	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00292	8b 8d 98 fa ff
	ff		 mov	 ecx, DWORD PTR tv4244[ebp]
  00298	0f b6 04 08	 movzx	 eax, BYTE PTR [eax+ecx]
  0029c	83 c4 10	 add	 esp, 16			; 00000010H
  0029f	50		 push	 eax
  002a0	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _szKeyName$506911[ebp]
  002a6	50		 push	 eax
  002a7	8d 8d a0 fa ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  002ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SaveBool@ioINILoader@@QAEXPBD_N@Z
  002b3	8b 85 9c fa ff
	ff		 mov	 eax, DWORD PTR tv3746[ebp]
  002b9	83 85 98 fa ff
	ff 14		 add	 DWORD PTR tv4244[ebp], 20 ; 00000014H
  002c0	89 85 9c fa ff
	ff		 mov	 DWORD PTR _i$506906[ebp], eax
  002c6	3b 85 90 fa ff
	ff		 cmp	 eax, DWORD PTR _iMax$[ebp]
  002cc	0f 8c b0 fe ff
	ff		 jl	 $LN202@SaveMacroT@2
$LN563@SaveMacroT@2:

; 652  : 	}
; 653  : }

  002d2	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  002d6	8d 8d a0 fa ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  002dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioINILoader@@QAE@XZ
$LN303@SaveMacroT@2:
  002e2	e8 00 00 00 00	 call	 __EH_epilog3_GS
  002e7	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SaveMacroTextInfo@CCustomKeyInfo@@UAEXXZ$0:
  00000	8d 8d a0 fa ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioINILoader@@QAE@XZ
__ehhandler$?SaveMacroTextInfo@CCustomKeyInfo@@UAEXXZ:
  0000c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00010	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00013	8b 8a 8c fa ff
	ff		 mov	 ecx, DWORD PTR [edx-1396]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SaveMacroTextInfo@CCustomKeyInfo@@UAEXXZ
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SaveMacroTextInfo@CCustomKeyInfo@@UAEXXZ ENDP		; CCustomKeyInfo::SaveMacroTextInfo
PUBLIC	_this$GSCopy$
PUBLIC	?SaveKey@CCustomJoyKeyInfo@@UAEXXZ		; CCustomJoyKeyInfo::SaveKey
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?SaveKey@CCustomJoyKeyInfo@@UAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SaveKey@CCustomJoyKeyInfo@@UAEXXZ$0
__ehfuncinfo$?SaveKey@CCustomJoyKeyInfo@@UAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SaveKey@CCustomJoyKeyInfo@@UAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iokeymanager.cpp
xdata$x	ENDS
;	COMDAT ?SaveKey@CCustomJoyKeyInfo@@UAEXXZ
_TEXT	SEGMENT
_this$GSCopy$ = -1120					; size = 4
_kLoader$ = -1116					; size = 784
_fName$ = -332						; size = 260
___encStr$507700 = -72					; size = 8
__t$518366 = -60					; size = 7
___encStr$507851 = -48					; size = 25
___encStr$507547 = -48					; size = 25
__$EHRec$ = -12						; size = 12
?SaveKey@CCustomJoyKeyInfo@@UAEXXZ PROC			; CCustomJoyKeyInfo::SaveKey, COMDAT
; _this$ = ecx

; 935  : {

  00000	68 54 04 00 00	 push	 1108			; 00000454H
  00005	b8 00 00 00 00	 mov	 eax, __ehhandler$?SaveKey@CCustomJoyKeyInfo@@UAEXXZ
  0000a	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000f	89 8d a0 fb ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], ecx

; 936  : 	if(g_MyInfo.GetPublicID().IsEmpty()) return;

  00015	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  0001a	8d 48 1c	 lea	 ecx, DWORD PTR [eax+28]
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00023	84 c0		 test	 al, al
  00025	0f 85 60 02 00
	00		 jne	 $LN305@SaveKey@2

; 937  : 
; 938  : 	char fName[MAX_PATH]="";

  0002b	33 db		 xor	 ebx, ebx
  0002d	68 03 01 00 00	 push	 259			; 00000103H
  00032	8d 85 b5 fe ff
	ff		 lea	 eax, DWORD PTR _fName$[ebp+1]
  00038	53		 push	 ebx
  00039	50		 push	 eax
  0003a	88 9d b4 fe ff
	ff		 mov	 BYTE PTR _fName$[ebp], bl
  00040	e8 00 00 00 00	 call	 _memset
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
  00048	6a 06		 push	 6

; 939  : 	StringCbPrintf_e( fName, sizeof(fName), "Save\\%s\\customjoykey.ini",g_MyInfo.GetPublicID().c_str() );

  0004a	c7 45 d0 be 8d
	9d 8f		 mov	 DWORD PTR ___encStr$507547[ebp], -1885499970 ; 8f9d8dbeH
  00051	c7 45 d4 b1 c9
	98 b6		 mov	 DWORD PTR ___encStr$507547[ebp+4], -1231500879 ; b698c9b1H
  00058	c7 45 d8 8e 99
	98 9e		 mov	 DWORD PTR ___encStr$507547[ebp+8], -1634166386 ; 9e98998eH
  0005f	c7 45 dc 82 81
	81 85		 mov	 DWORD PTR ___encStr$507547[ebp+12], -2055110270 ; 85818182H
  00066	c7 45 e0 94 87
	8e 93		 mov	 DWORD PTR ___encStr$507547[ebp+16], -1819375724 ; 938e8794H
  0006d	c7 45 e4 c3 85
	85 83		 mov	 DWORD PTR ___encStr$507547[ebp+20], -2088401469 ; 838585c3H
  00074	8d 45 d0	 lea	 eax, DWORD PTR ___encStr$507547[ebp]
  00077	88 5d e8	 mov	 BYTE PTR ___encStr$507547[ebp+24], bl
  0007a	59		 pop	 ecx
$LL315@SaveKey@2:
  0007b	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00081	83 c0 04	 add	 eax, 4
  00084	49		 dec	 ecx
  00085	75 f4		 jne	 SHORT $LL315@SaveKey@2
  00087	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  0008c	8d 48 1c	 lea	 ecx, DWORD PTR [eax+28]
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00095	50		 push	 eax
  00096	8d 45 d0	 lea	 eax, DWORD PTR ___encStr$507547[ebp]
  00099	50		 push	 eax
  0009a	bf 04 01 00 00	 mov	 edi, 260		; 00000104H
  0009f	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _fName$[ebp]
  000a5	57		 push	 edi
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 ?StringCbPrintfA@@YAJPADIPBDZZ ; StringCbPrintfA

; 940  : 
; 941  : 	FILE *fp = fopen( fName, "r" );

  000ac	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _fName$[ebp]
  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  000b7	50		 push	 eax
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  000be	83 c4 18	 add	 esp, 24			; 00000018H

; 942  : 	if( !fp )

  000c1	3b c3		 cmp	 eax, ebx
  000c3	0f 85 eb 00 00
	00		 jne	 $LN5@SaveKey@2

; 943  : 	{
; 944  : 		StringCbPrintf_e( fName, sizeof( fName ), "Save\\%s" , g_MyInfo.GetPublicID().c_str() );

  000c9	6a 04		 push	 4
  000cb	c7 45 b8 be 8d
	9d 8f		 mov	 DWORD PTR ___encStr$507700[ebp], -1885499970 ; 8f9d8dbeH
  000d2	81 75 b8 ed ec
	eb ea		 xor	 DWORD PTR ___encStr$507700[ebp], -353637139 ; eaebecedH
  000d9	c7 45 bc b1 c9
	98 00		 mov	 DWORD PTR ___encStr$507700[ebp+4], 10013105 ; 0098c9b1H
  000e0	5e		 pop	 esi
$LL322@SaveKey@2:
  000e1	8b c6		 mov	 eax, esi
  000e3	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  000e8	79 05		 jns	 SHORT $LN471@SaveKey@2
  000ea	48		 dec	 eax
  000eb	83 c8 fc	 or	 eax, -4			; fffffffcH
  000ee	40		 inc	 eax
$LN471@SaveKey@2:
  000ef	b1 ed		 mov	 cl, -19			; ffffffedH
  000f1	2a c8		 sub	 cl, al
  000f3	30 4c 35 b8	 xor	 BYTE PTR ___encStr$507700[ebp+esi], cl
  000f7	46		 inc	 esi
  000f8	83 fe 07	 cmp	 esi, 7
  000fb	7c e4		 jl	 SHORT $LL322@SaveKey@2
  000fd	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  00102	8d 48 1c	 lea	 ecx, DWORD PTR [eax+28]
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  0010b	50		 push	 eax
  0010c	8d 45 b8	 lea	 eax, DWORD PTR ___encStr$507700[ebp]
  0010f	50		 push	 eax
  00110	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _fName$[ebp]
  00116	57		 push	 edi
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 ?StringCbPrintfA@@YAJPADIPBDZZ ; StringCbPrintfA

; 945  : 		CreateDirectory( "Save", NULL );

  0011d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CreateDirectoryA@8
  00123	83 c4 10	 add	 esp, 16			; 00000010H
  00126	53		 push	 ebx
  00127	68 00 00 00 00	 push	 OFFSET ??_C@_04INACKGJP@Save?$AA@
  0012c	ff d6		 call	 esi

; 946  : 		CreateDirectory( fName, NULL );

  0012e	53		 push	 ebx
  0012f	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _fName$[ebp]
  00135	50		 push	 eax
  00136	ff d6		 call	 esi
  00138	6a 06		 push	 6

; 947  : 		StringCbPrintf_e( fName, sizeof( fName ), "Save\\%s\\customjoykey.ini", g_MyInfo.GetPublicID().c_str() );

  0013a	c7 45 d0 be 8d
	9d 8f		 mov	 DWORD PTR ___encStr$507851[ebp], -1885499970 ; 8f9d8dbeH
  00141	c7 45 d4 b1 c9
	98 b6		 mov	 DWORD PTR ___encStr$507851[ebp+4], -1231500879 ; b698c9b1H
  00148	c7 45 d8 8e 99
	98 9e		 mov	 DWORD PTR ___encStr$507851[ebp+8], -1634166386 ; 9e98998eH
  0014f	c7 45 dc 82 81
	81 85		 mov	 DWORD PTR ___encStr$507851[ebp+12], -2055110270 ; 85818182H
  00156	c7 45 e0 94 87
	8e 93		 mov	 DWORD PTR ___encStr$507851[ebp+16], -1819375724 ; 938e8794H
  0015d	c7 45 e4 c3 85
	85 83		 mov	 DWORD PTR ___encStr$507851[ebp+20], -2088401469 ; 838585c3H
  00164	8d 45 d0	 lea	 eax, DWORD PTR ___encStr$507851[ebp]
  00167	88 5d e8	 mov	 BYTE PTR ___encStr$507851[ebp+24], bl
  0016a	59		 pop	 ecx
$LL335@SaveKey@2:
  0016b	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00171	83 c0 04	 add	 eax, 4
  00174	49		 dec	 ecx
  00175	75 f4		 jne	 SHORT $LL335@SaveKey@2
  00177	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  0017c	8d 48 1c	 lea	 ecx, DWORD PTR [eax+28]
  0017f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  00185	50		 push	 eax
  00186	8d 45 d0	 lea	 eax, DWORD PTR ___encStr$507851[ebp]
  00189	50		 push	 eax
  0018a	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _fName$[ebp]
  00190	57		 push	 edi
  00191	50		 push	 eax
  00192	e8 00 00 00 00	 call	 ?StringCbPrintfA@@YAJPADIPBDZZ ; StringCbPrintfA

; 948  : 
; 949  : 		fp = fopen( fName, "w" );

  00197	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _fName$[ebp]
  0019d	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  001a2	50		 push	 eax
  001a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  001a9	83 c4 18	 add	 esp, 24			; 00000018H

; 950  : 		if( !fp )

  001ac	3b c3		 cmp	 eax, ebx
  001ae	0f 84 d7 00 00
	00		 je	 $LN305@SaveKey@2
$LN5@SaveKey@2:

; 951  : 			return;
; 952  : 	}
; 953  : 	fclose( fp );

  001b4	50		 push	 eax
  001b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  001bb	59		 pop	 ecx

; 954  : 
; 955  : 	ioINILoader kLoader( fName, false );

  001bc	53		 push	 ebx
  001bd	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _fName$[ebp]
  001c3	50		 push	 eax
  001c4	8d 8d a4 fb ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  001ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioINILoader@@QAE@PBD_N@Z

; 956  : 	kLoader.SetTitle_e( "Common" );

  001d0	6a 04		 push	 4
  001d2	c7 45 c4 ae 83
	86 87		 mov	 DWORD PTR __t$518366[ebp], -2021227602 ; 878683aeH
  001d9	81 75 c4 ed ec
	eb ea		 xor	 DWORD PTR __t$518366[ebp], -353637139 ; eaebecedH
  001e0	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  001e3	66 c7 45 c8 82
	82		 mov	 WORD PTR __t$518366[ebp+4], 33410 ; 00008282H
  001e9	88 5d ca	 mov	 BYTE PTR __t$518366[ebp+6], bl
  001ec	5e		 pop	 esi
$LL440@SaveKey@2:
  001ed	8b c6		 mov	 eax, esi
  001ef	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  001f4	79 05		 jns	 SHORT $LN472@SaveKey@2
  001f6	48		 dec	 eax
  001f7	83 c8 fc	 or	 eax, -4			; fffffffcH
  001fa	40		 inc	 eax
$LN472@SaveKey@2:
  001fb	b1 ed		 mov	 cl, -19			; ffffffedH
  001fd	2a c8		 sub	 cl, al
  001ff	30 4c 35 c4	 xor	 BYTE PTR __t$518366[ebp+esi], cl
  00203	46		 inc	 esi
  00204	83 fe 06	 cmp	 esi, 6
  00207	7c e4		 jl	 SHORT $LL440@SaveKey@2
  00209	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z
  0020f	8d 45 c4	 lea	 eax, DWORD PTR __t$518366[ebp]
  00212	50		 push	 eax
  00213	8d 8d a4 fb ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00219	ff d7		 call	 edi

; 957  : 	kLoader.SaveInt("Version" , CUSTOMKEY_VERSION );

  0021b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?SaveInt@ioINILoader@@QAEXPBDH@Z
  00221	68 50 05 33 01	 push	 20120912		; 01330550H
  00226	68 00 00 00 00	 push	 OFFSET ??_C@_07NGFJPNPN@Version?$AA@
  0022b	8d 8d a4 fb ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00231	ff d6		 call	 esi

; 958  : 
; 959  : 	kLoader.SetTitle( "Key" );

  00233	68 00 00 00 00	 push	 OFFSET ??_C@_03CCEPDEKL@Key?$AA@
  00238	8d 8d a4 fb ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0023e	ff d7		 call	 edi

; 960  : 	int iMax = m_vKeyInfo.size();

  00240	8b 8d a0 fb ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00246	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]
  00249	2b 79 04	 sub	 edi, DWORD PTR [ecx+4]
  0024c	d1 ff		 sar	 edi, 1

; 961  : 	for (int i = 0; i < iMax ; i++)

  0024e	3b fb		 cmp	 edi, ebx
  00250	7e 29		 jle	 SHORT $LN459@SaveKey@2
  00252	eb 06		 jmp	 SHORT $LN4@SaveKey@2
$LL469@SaveKey@2:
  00254	8b 8d a0 fb ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
$LN4@SaveKey@2:

; 962  : 	{
; 963  : 		if( i >= JTA_MAX ) break;

  0025a	83 fb 2f	 cmp	 ebx, 47			; 0000002fH
  0025d	7d 1c		 jge	 SHORT $LN459@SaveKey@2

; 964  : 		kLoader.SaveInt(GetINIKeyName((KeyTypeArray)i), m_vKeyInfo[i]);

  0025f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00262	0f b7 04 58	 movzx	 eax, WORD PTR [eax+ebx*2]
  00266	50		 push	 eax
  00267	53		 push	 ebx
  00268	e8 00 00 00 00	 call	 ?GetINIKeyName@CJoyKeyInfo@@IAEPADW4KeyTypeArray@1@@Z ; CJoyKeyInfo::GetINIKeyName
  0026d	50		 push	 eax
  0026e	8d 8d a4 fb ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00274	ff d6		 call	 esi
  00276	43		 inc	 ebx
  00277	3b df		 cmp	 ebx, edi
  00279	7c d9		 jl	 SHORT $LL469@SaveKey@2
$LN459@SaveKey@2:

; 965  : 	}
; 966  : }

  0027b	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0027f	8d 8d a4 fb ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00285	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioINILoader@@QAE@XZ
$LN305@SaveKey@2:
  0028b	e8 00 00 00 00	 call	 __EH_epilog3_GS
  00290	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SaveKey@CCustomJoyKeyInfo@@UAEXXZ$0:
  00000	8d 8d a4 fb ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioINILoader@@QAE@XZ
__ehhandler$?SaveKey@CCustomJoyKeyInfo@@UAEXXZ:
  0000c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00010	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00013	8b 8a 9c fb ff
	ff		 mov	 ecx, DWORD PTR [edx-1124]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SaveKey@CCustomJoyKeyInfo@@UAEXXZ
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SaveKey@CCustomJoyKeyInfo@@UAEXXZ ENDP			; CCustomJoyKeyInfo::SaveKey
PUBLIC	?GetCurrent@ioKeyManager@@QAEXAAVCKeyInfo@@@Z	; ioKeyManager::GetCurrent
; Function compile flags: /Ogsp
;	COMDAT ?GetCurrent@ioKeyManager@@QAEXAAVCKeyInfo@@@Z
_TEXT	SEGMENT
_rKeyInfo$ = 8						; size = 4
?GetCurrent@ioKeyManager@@QAEXAAVCKeyInfo@@@Z PROC	; ioKeyManager::GetCurrent, COMDAT
; _this$ = ecx

; 1867 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1868 : 	if( m_bUseCustom )

  00006	80 be 94 00 00
	00 00		 cmp	 BYTE PTR [esi+148], 0

; 1869 : 		GetCustom( rKeyInfo );

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _rKeyInfo$[ebp]
  00010	8d 46 2c	 lea	 eax, DWORD PTR [esi+44]
  00013	75 03		 jne	 SHORT $LN10@GetCurrent@2

; 1870 : 	else
; 1871 : 		GetDefault( rKeyInfo );

  00015	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
$LN10@GetCurrent@2:
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??4CKeyInfo@@QAEAAV0@AAV0@@Z ; CKeyInfo::operator=

; 1872 : 	
; 1873 : 	if( !m_DefaultKeyInfo.IsRightMacro( m_CustomKeyInfo ) )

  0001e	8d 46 2c	 lea	 eax, DWORD PTR [esi+44]
  00021	50		 push	 eax
  00022	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00025	e8 00 00 00 00	 call	 ?IsRightMacro@CKeyInfo@@QAE_NABV1@@Z ; CKeyInfo::IsRightMacro
  0002a	84 c0		 test	 al, al
  0002c	75 0a		 jne	 SHORT $LN1@GetCurrent@2

; 1874 : 		GetCustomTextInfo( rKeyInfo );

  0002e	ff 75 08	 push	 DWORD PTR _rKeyInfo$[ebp]
  00031	8b ce		 mov	 ecx, esi
  00033	e8 00 00 00 00	 call	 ?GetCustomTextInfo@ioKeyManager@@QAEXAAVCKeyInfo@@@Z ; ioKeyManager::GetCustomTextInfo
$LN1@GetCurrent@2:
  00038	5e		 pop	 esi

; 1875 : }

  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?GetCurrent@ioKeyManager@@QAEXAAVCKeyInfo@@@Z ENDP	; ioKeyManager::GetCurrent
_TEXT	ENDS
PUBLIC	?GetJoyCurrent@ioKeyManager@@QAEXAAVCJoyKeyInfo@@@Z ; ioKeyManager::GetJoyCurrent
; Function compile flags: /Ogsp
;	COMDAT ?GetJoyCurrent@ioKeyManager@@QAEXAAVCJoyKeyInfo@@@Z
_TEXT	SEGMENT
_rKeyInfo$ = 8						; size = 4
?GetJoyCurrent@ioKeyManager@@QAEXAAVCJoyKeyInfo@@@Z PROC ; ioKeyManager::GetJoyCurrent, COMDAT
; _this$ = ecx

; 1910 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1911 : 	if(m_bUseJoyCustom)

  00003	80 b9 96 00 00
	00 00		 cmp	 BYTE PTR [ecx+150], 0
  0000a	74 05		 je	 SHORT $LN2@GetJoyCurr

; 1912 : 		GetJoyCustom( rKeyInfo );

  0000c	83 c1 6c	 add	 ecx, 108		; 0000006cH

; 1913 : 	else

  0000f	eb 03		 jmp	 SHORT $LN9@GetJoyCurr
$LN2@GetJoyCurr:

; 1914 : 		GetJoyDefault( rKeyInfo );

  00011	83 c1 54	 add	 ecx, 84			; 00000054H
$LN9@GetJoyCurr:
  00014	51		 push	 ecx
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _rKeyInfo$[ebp]
  00018	e8 00 00 00 00	 call	 ??4CJoyKeyInfo@@QAEAAV0@AAV0@@Z ; CJoyKeyInfo::operator=

; 1915 : }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?GetJoyCurrent@ioKeyManager@@QAEXAAVCJoyKeyInfo@@@Z ENDP ; ioKeyManager::GetJoyCurrent
_TEXT	ENDS
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?SendKey@ioKeyManager@@AAEXXZ			; ioKeyManager::SendKey
EXTRN	??1SP2Packet@@UAE@XZ:PROC			; SP2Packet::~SP2Packet
EXTRN	?SendToServer@TCPNetwork@@YAXAAVSP2Packet@@@Z:PROC ; TCPNetwork::SendToServer
EXTRN	??6SP2Packet@@QAEAAV0@ABUControlKeys@@@Z:PROC	; SP2Packet::operator<<
EXTRN	??0SP2Packet@@QAE@K@Z:PROC			; SP2Packet::SP2Packet
EXTRN	__chkstk:PROC
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stringprotect.h
xdata$x	SEGMENT
__unwindtable$?SendKey@ioKeyManager@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SendKey@ioKeyManager@@AAEXXZ$0
__ehfuncinfo$?SendKey@ioKeyManager@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SendKey@ioKeyManager@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iokeymanager.cpp
xdata$x	ENDS
;	COMDAT ?SendKey@ioKeyManager@@AAEXXZ
_TEXT	SEGMENT
_this$GSCopy$ = -33032					; size = 4
_szTempHex$509569 = -33028				; size = 3
_kPacket$ = -33024					; size = 32792
_kControlKeys$ = -232					; size = 201
___encStr$509573 = -28					; size = 5
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?SendKey@ioKeyManager@@AAEXXZ PROC			; ioKeyManager::SendKey, COMDAT
; _this$ = ecx

; 1979 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SendKey@ioKeyManager@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 fc 80 00 00	 mov	 eax, 33020		; 000080fcH
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1980 : 	ControlKeys kControlKeys;

  00032	be c9 00 00 00	 mov	 esi, 201		; 000000c9H
  00037	56		 push	 esi
  00038	33 db		 xor	 ebx, ebx
  0003a	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _kControlKeys$[ebp]
  00040	53		 push	 ebx
  00041	50		 push	 eax
  00042	89 8d f8 7e ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  00048	e8 00 00 00 00	 call	 _memset
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LL102@SendKey:

; 1981 : 	enum { MAX_HAX = 3, };
; 1982 : 	for (int i = 0; i < CKeyInfo::KTA_MAX ; i++)
; 1983 : 	{
; 1984 : 		char szTempHex[MAX_HAX]="";
; 1985 : 		StringCbPrintf_e( szTempHex, sizeof( szTempHex ), "%02x", GetKey( (CKeyInfo::KeyTypeArray) i ) );

  00050	8b 8d f8 7e ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00056	33 c0		 xor	 eax, eax
  00058	c6 85 fc 7e ff
	ff 00		 mov	 BYTE PTR _szTempHex$509569[ebp], 0
  0005f	8d bd fd 7e ff
	ff		 lea	 edi, DWORD PTR _szTempHex$509569[ebp+1]
  00065	c7 45 e4 c8 dc
	d9 92		 mov	 DWORD PTR ___encStr$509573[ebp], -1831215928 ; 92d9dcc8H
  0006c	81 75 e4 ed ec
	eb ea		 xor	 DWORD PTR ___encStr$509573[ebp], -353637139 ; eaebecedH
  00073	53		 push	 ebx
  00074	66 ab		 stosw
  00076	88 45 e8	 mov	 BYTE PTR ___encStr$509573[ebp+4], al
  00079	e8 00 00 00 00	 call	 ?GetKey@ioKeyManager@@AAEGW4KeyTypeArray@CKeyInfo@@@Z ; ioKeyManager::GetKey
  0007e	0f b7 c0	 movzx	 eax, ax
  00081	50		 push	 eax
  00082	8d 45 e4	 lea	 eax, DWORD PTR ___encStr$509573[ebp]
  00085	50		 push	 eax
  00086	8d 85 fc 7e ff
	ff		 lea	 eax, DWORD PTR _szTempHex$509569[ebp]
  0008c	6a 03		 push	 3
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?StringCbPrintfA@@YAJPADIPBDZZ ; StringCbPrintfA
  00094	83 c4 10	 add	 esp, 16			; 00000010H

; 1986 : 		StringCbCat( kControlKeys.m_szControlKeys, sizeof( kControlKeys.m_szControlKeys ), szTempHex );

  00097	8d 85 fc 7e ff
	ff		 lea	 eax, DWORD PTR _szTempHex$509569[ebp]
  0009d	50		 push	 eax
  0009e	56		 push	 esi
  0009f	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _kControlKeys$[ebp]
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 ?StringCbCatA@@YGJPADIPBD@Z ; StringCbCatA
  000ab	43		 inc	 ebx
  000ac	83 fb 5f	 cmp	 ebx, 95			; 0000005fH
  000af	7c 9f		 jl	 SHORT $LL102@SendKey

; 1987 : 	}
; 1988 : 
; 1989 : 	m_kServerKeys = kControlKeys;

  000b1	8b bd f8 7e ff
	ff		 mov	 edi, DWORD PTR _this$GSCopy$[ebp]
  000b7	6a 32		 push	 50			; 00000032H
  000b9	59		 pop	 ecx
  000ba	81 c7 99 00 00
	00		 add	 edi, 153		; 00000099H
  000c0	8d b5 18 ff ff
	ff		 lea	 esi, DWORD PTR _kControlKeys$[ebp]
  000c6	f3 a5		 rep movsd

; 1990 : 	SP2Packet kPacket( CTPK_CONTROL_KEYS );

  000c8	68 02 02 00 00	 push	 514			; 00000202H
  000cd	8d 8d 00 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$[ebp]
  000d3	a4		 movsb
  000d4	e8 00 00 00 00	 call	 ??0SP2Packet@@QAE@K@Z	; SP2Packet::SP2Packet
  000d9	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 1991 : 	kPacket << kControlKeys;

  000dd	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _kControlKeys$[ebp]
  000e3	50		 push	 eax
  000e4	8d 8d 00 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$[ebp]
  000ea	e8 00 00 00 00	 call	 ??6SP2Packet@@QAEAAV0@ABUControlKeys@@@Z ; SP2Packet::operator<<

; 1992 : 	TCPNetwork::SendToServer( kPacket );

  000ef	8d 85 00 7f ff
	ff		 lea	 eax, DWORD PTR _kPacket$[ebp]
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 ?SendToServer@TCPNetwork@@YAXAAVSP2Packet@@@Z ; TCPNetwork::SendToServer

; 1993 : }

  000fb	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000ff	59		 pop	 ecx
  00100	8d 8d 00 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$[ebp]
  00106	e8 00 00 00 00	 call	 ??1SP2Packet@@UAE@XZ	; SP2Packet::~SP2Packet
  0010b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0010e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00115	59		 pop	 ecx
  00116	5f		 pop	 edi
  00117	5e		 pop	 esi
  00118	5b		 pop	 ebx
  00119	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011c	33 cd		 xor	 ecx, ebp
  0011e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00123	c9		 leave
  00124	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SendKey@ioKeyManager@@AAEXXZ$0:
  00000	8d 8d 00 7f ff
	ff		 lea	 ecx, DWORD PTR _kPacket$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1SP2Packet@@UAE@XZ	; SP2Packet::~SP2Packet
__ehhandler$?SendKey@ioKeyManager@@AAEXXZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a f4 7e ff
	ff		 mov	 ecx, DWORD PTR [edx-33036]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SendKey@ioKeyManager@@AAEXXZ
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SendKey@ioKeyManager@@AAEXXZ ENDP			; ioKeyManager::SendKey
PUBLIC	??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ	; std::vector<unsigned short,std::allocator<unsigned short> >::vector<unsigned short,std::allocator<unsigned short> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::vector<unsigned short,std::allocator<unsigned short> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::vector<unsigned short,std::allocator<unsigned short> >
_TEXT	ENDS
PUBLIC	??0?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE@XZ ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >
_TEXT	ENDS
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBGVioHashString@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::operator->
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBGVioHashString@@@1@XZ
_TEXT	SEGMENT
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBGVioHashString@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::operator->, COMDAT
; _this$ = ecx

; 401  : 		return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 402  : 		}

  00005	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBGVioHashString@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::operator->
_TEXT	ENDS
PUBLIC	?begin@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@XZ ; std::vector<unsigned short,std::allocator<unsigned short> >::begin
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?begin@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@XZ PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 782  : 		return (iterator(this->_Myfirst, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 783  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@XZ ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@XZ ; std::vector<unsigned short,std::allocator<unsigned short> >::end
; Function compile flags: /Ogsp
;	COMDAT ?end@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@XZ PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 792  : 		return (iterator(this->_Mylast, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 793  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@XZ ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::end
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@GV?$allocator@G@std@@@std@@IAEXPAG0@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Destroy
; Function compile flags: /Ogsp
;	COMDAT ?_Destroy@?$vector@GV?$allocator@G@std@@@std@@IAEXPAG0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@GV?$allocator@G@std@@@std@@IAEXPAG0@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Destroy, COMDAT
; _this$ = ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@GV?$allocator@G@std@@@std@@IAEXPAG0@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@GV?$allocator@G@std@@@std@@IAEXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Tidy
EXTRN	__imp_?_Orphan_all@_Container_base0@std@@QAEXXZ:PROC
; Function compile flags: /Ogsp
;	COMDAT ?_Tidy@?$vector@GV?$allocator@G@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@GV?$allocator@G@std@@@std@@IAEXXZ PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00006	74 0e		 je	 SHORT $LN12@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  0000e	ff 36		 push	 DWORD PTR [esi]
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	59		 pop	 ecx
$LN12@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00016	83 26 00	 and	 DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

  00019	83 66 04 00	 and	 DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

  0001d	83 66 08 00	 and	 DWORD PTR [esi+8], 0
  00021	5e		 pop	 esi

; 1312 : 		}

  00022	c3		 ret	 0
?_Tidy@?$vector@GV?$allocator@G@std@@@std@@IAEXXZ ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::_Tidy
_TEXT	ENDS
PUBLIC	?begin@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@XZ ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::begin
; Function compile flags: /Ogsp
;	COMDAT ?begin@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@XZ PROC ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 782  : 		return (iterator(this->_Myfirst, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 783  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@XZ ENDP ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@XZ ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::end
; Function compile flags: /Ogsp
;	COMDAT ?end@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@XZ PROC ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 792  : 		return (iterator(this->_Mylast, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 793  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@XZ ENDP ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::end
_TEXT	ENDS
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >, COMDAT
; _this$ = ecx

; 378  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 379  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@GV?$allocator@G@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Make_iter
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@GV?$allocator@G@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@GV?$allocator@G@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 		return (iterator(_Where._Ptr, this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 803  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?_Make_iter@?$vector@GV?$allocator@G@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@@Z ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Make_iter
; Function compile flags: /Ogsp
;	COMDAT ?_Make_iter@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@@Z PROC ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 		return (iterator(_Where._Ptr, this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 803  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?_Make_iter@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@@Z ENDP ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Make_iter
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::begin
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::begin, COMDAT
; _this$ = ecx

; 806  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 807  : 		return (iterator(_Lmost(), this));

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx

; 808  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::begin
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@G@1@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@G@1@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@1@@Z
_TEXT	SEGMENT
$T518863 = -16						; size = 12
$T518840 = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@G@1@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >, COMDAT
; _this$ = ecx

; 542  : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 543  : 		this->_Mysize = 0;

  00009	83 66 08 00	 and	 DWORD PTR [esi+8], 0

; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

  0000d	6a 24		 push	 36			; 00000024H
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00014	59		 pop	 ecx
  00015	85 c0		 test	 eax, eax
  00017	74 26		 je	 SHORT $LN15@Tree_val
  00019	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 545  : 
; 546  : 		this->_Left(this->_Myhead) = this->_Myhead;

  0001c	89 00		 mov	 DWORD PTR [eax], eax

; 547  : 		this->_Parent(this->_Myhead) = this->_Myhead;

  0001e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00021	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 548  : 		this->_Right(this->_Myhead) = this->_Myhead;

  00024	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00027	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 549  : 		this->_Color(this->_Myhead) = this->_Black;

  0002a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002d	c6 40 20 01	 mov	 BYTE PTR [eax+32], 1

; 550  : 		this->_Isnil(this->_Myhead) = true;

  00031	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00034	c6 40 21 01	 mov	 BYTE PTR [eax+33], 1

; 551  : 		}

  00038	8b c6		 mov	 eax, esi
  0003a	5e		 pop	 esi
  0003b	c9		 leave
  0003c	c2 08 00	 ret	 8

; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

$LN15@Tree_val:
  0003f	83 65 fc 00	 and	 DWORD PTR $T518840[ebp], 0
  00043	8d 45 fc	 lea	 eax, DWORD PTR $T518840[ebp]
  00046	50		 push	 eax
  00047	8d 4d f0	 lea	 ecx, DWORD PTR $T518863[ebp]
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
  00050	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00055	8d 45 f0	 lea	 eax, DWORD PTR $T518863[ebp]
  00058	50		 push	 eax
  00059	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T518863[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00060	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN37@Tree_val:
$LN36@Tree_val:
  00065	cc		 int	 3
??0?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@G@1@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<unsigned short,std::allocator<unsigned short> > >::operator!=
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<unsigned short,std::allocator<unsigned short> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 209  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<unsigned short,std::allocator<unsigned short> > >::operator!=
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> > >::operator!=
; Function compile flags: /Ogsp
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 209  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> > >::operator!=
_TEXT	ENDS
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::operator++
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 270  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : 		_Myiter _Tmp = *this;

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 06		 mov	 DWORD PTR [esi], eax

; 272  : 		++*this;

  0000b	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >,std::_Iterator_base0>::operator++

; 273  : 		return (_Tmp);

  00010	8b c6		 mov	 eax, esi
  00012	5e		 pop	 esi

; 274  : 		}

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::operator++
_TEXT	ENDS
PUBLIC	??$?0$0BL@@ioINILoader_e@@QAE@AAY0BL@$$CBD_N@Z	; ioINILoader_e::ioINILoader_e<27>
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\io3dengine\ioiniloader.h
;	COMDAT ??$?0$0BL@@ioINILoader_e@@QAE@AAY0BL@$$CBD_N@Z
_TEXT	SEGMENT
_fn$ = 8						; size = 4
_b$ = 12						; size = 1
??$?0$0BL@@ioINILoader_e@@QAE@AAY0BL@$$CBD_N@Z PROC	; ioINILoader_e::ioINILoader_e<27>, COMDAT
; _this$ = ecx

; 224  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _fn$[ebp]
  0000b	8a 11		 mov	 dl, BYTE PTR [ecx]
  0000d	8d 87 50 03 00
	00		 lea	 eax, DWORD PTR [edi+848]
  00013	84 d2		 test	 dl, dl
  00015	0f 84 6a 04 00
	00		 je	 $LN99@ioINILoade
  0001b	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0001e	88 10		 mov	 BYTE PTR [eax], dl
  00020	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  00023	84 d2		 test	 dl, dl
  00025	0f 84 54 04 00
	00		 je	 $LN98@ioINILoade
  0002b	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0002e	88 50 01	 mov	 BYTE PTR [eax+1], dl
  00031	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  00034	84 d2		 test	 dl, dl
  00036	0f 84 3d 04 00
	00		 je	 $LN97@ioINILoade
  0003c	b3 eb		 mov	 bl, -21			; ffffffebH
  0003e	32 d3		 xor	 dl, bl
  00040	88 50 02	 mov	 BYTE PTR [eax+2], dl
  00043	8a 51 03	 mov	 dl, BYTE PTR [ecx+3]
  00046	84 d2		 test	 dl, dl
  00048	0f 84 25 04 00
	00		 je	 $LN96@ioINILoade
  0004e	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00051	88 50 03	 mov	 BYTE PTR [eax+3], dl
  00054	8a 51 04	 mov	 dl, BYTE PTR [ecx+4]
  00057	84 d2		 test	 dl, dl
  00059	0f 84 0e 04 00
	00		 je	 $LN95@ioINILoade
  0005f	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00062	88 50 04	 mov	 BYTE PTR [eax+4], dl
  00065	8a 51 05	 mov	 dl, BYTE PTR [ecx+5]
  00068	84 d2		 test	 dl, dl
  0006a	0f 84 f7 03 00
	00		 je	 $LN94@ioINILoade
  00070	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00073	88 50 05	 mov	 BYTE PTR [eax+5], dl
  00076	8a 51 06	 mov	 dl, BYTE PTR [ecx+6]
  00079	84 d2		 test	 dl, dl
  0007b	0f 84 e1 03 00
	00		 je	 $LN93@ioINILoade
  00081	32 d3		 xor	 dl, bl
  00083	88 50 06	 mov	 BYTE PTR [eax+6], dl
  00086	8a 51 07	 mov	 dl, BYTE PTR [ecx+7]
  00089	84 d2		 test	 dl, dl
  0008b	0f 84 cb 03 00
	00		 je	 $LN92@ioINILoade
  00091	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00094	88 50 07	 mov	 BYTE PTR [eax+7], dl
  00097	8a 51 08	 mov	 dl, BYTE PTR [ecx+8]
  0009a	84 d2		 test	 dl, dl
  0009c	0f 84 b4 03 00
	00		 je	 $LN91@ioINILoade
  000a2	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000a5	88 50 08	 mov	 BYTE PTR [eax+8], dl
  000a8	8a 51 09	 mov	 dl, BYTE PTR [ecx+9]
  000ab	84 d2		 test	 dl, dl
  000ad	0f 84 9d 03 00
	00		 je	 $LN90@ioINILoade
  000b3	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000b6	88 50 09	 mov	 BYTE PTR [eax+9], dl
  000b9	8a 51 0a	 mov	 dl, BYTE PTR [ecx+10]
  000bc	84 d2		 test	 dl, dl
  000be	0f 84 87 03 00
	00		 je	 $LN89@ioINILoade
  000c4	32 d3		 xor	 dl, bl
  000c6	88 50 0a	 mov	 BYTE PTR [eax+10], dl
  000c9	8a 51 0b	 mov	 dl, BYTE PTR [ecx+11]
  000cc	84 d2		 test	 dl, dl
  000ce	0f 84 71 03 00
	00		 je	 $LN88@ioINILoade
  000d4	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000d7	88 50 0b	 mov	 BYTE PTR [eax+11], dl
  000da	8a 51 0c	 mov	 dl, BYTE PTR [ecx+12]
  000dd	84 d2		 test	 dl, dl
  000df	0f 84 5a 03 00
	00		 je	 $LN87@ioINILoade
  000e5	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000e8	88 50 0c	 mov	 BYTE PTR [eax+12], dl
  000eb	8a 51 0d	 mov	 dl, BYTE PTR [ecx+13]
  000ee	84 d2		 test	 dl, dl
  000f0	0f 84 43 03 00
	00		 je	 $LN86@ioINILoade
  000f6	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000f9	88 50 0d	 mov	 BYTE PTR [eax+13], dl
  000fc	8a 51 0e	 mov	 dl, BYTE PTR [ecx+14]
  000ff	84 d2		 test	 dl, dl
  00101	0f 84 2d 03 00
	00		 je	 $LN85@ioINILoade
  00107	32 d3		 xor	 dl, bl
  00109	88 50 0e	 mov	 BYTE PTR [eax+14], dl
  0010c	8a 51 0f	 mov	 dl, BYTE PTR [ecx+15]
  0010f	84 d2		 test	 dl, dl
  00111	0f 84 17 03 00
	00		 je	 $LN84@ioINILoade
  00117	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0011a	88 50 0f	 mov	 BYTE PTR [eax+15], dl
  0011d	8a 51 10	 mov	 dl, BYTE PTR [ecx+16]
  00120	84 d2		 test	 dl, dl
  00122	0f 84 00 03 00
	00		 je	 $LN83@ioINILoade
  00128	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0012b	88 50 10	 mov	 BYTE PTR [eax+16], dl
  0012e	8a 51 11	 mov	 dl, BYTE PTR [ecx+17]
  00131	84 d2		 test	 dl, dl
  00133	0f 84 e9 02 00
	00		 je	 $LN82@ioINILoade
  00139	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0013c	88 50 11	 mov	 BYTE PTR [eax+17], dl
  0013f	8a 51 12	 mov	 dl, BYTE PTR [ecx+18]
  00142	84 d2		 test	 dl, dl
  00144	0f 84 d3 02 00
	00		 je	 $LN81@ioINILoade
  0014a	32 d3		 xor	 dl, bl
  0014c	88 50 12	 mov	 BYTE PTR [eax+18], dl
  0014f	8a 51 13	 mov	 dl, BYTE PTR [ecx+19]
  00152	84 d2		 test	 dl, dl
  00154	0f 84 bd 02 00
	00		 je	 $LN80@ioINILoade
  0015a	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0015d	88 50 13	 mov	 BYTE PTR [eax+19], dl
  00160	8a 51 14	 mov	 dl, BYTE PTR [ecx+20]
  00163	84 d2		 test	 dl, dl
  00165	0f 84 a6 02 00
	00		 je	 $LN79@ioINILoade
  0016b	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0016e	88 50 14	 mov	 BYTE PTR [eax+20], dl
  00171	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00174	84 d2		 test	 dl, dl
  00176	0f 84 8f 02 00
	00		 je	 $LN78@ioINILoade
  0017c	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0017f	88 50 15	 mov	 BYTE PTR [eax+21], dl
  00182	8a 51 16	 mov	 dl, BYTE PTR [ecx+22]
  00185	84 d2		 test	 dl, dl
  00187	0f 84 79 02 00
	00		 je	 $LN77@ioINILoade
  0018d	32 d3		 xor	 dl, bl
  0018f	88 50 16	 mov	 BYTE PTR [eax+22], dl
  00192	8a 51 17	 mov	 dl, BYTE PTR [ecx+23]
  00195	84 d2		 test	 dl, dl
  00197	0f 84 60 02 00
	00		 je	 $LN76@ioINILoade
  0019d	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  001a0	88 50 17	 mov	 BYTE PTR [eax+23], dl
  001a3	8a 51 18	 mov	 dl, BYTE PTR [ecx+24]
  001a6	84 d2		 test	 dl, dl
  001a8	0f 84 46 02 00
	00		 je	 $LN75@ioINILoade
  001ae	80 f2 ed	 xor	 dl, -19			; ffffffedH
  001b1	88 50 18	 mov	 BYTE PTR [eax+24], dl
  001b4	8a 51 19	 mov	 dl, BYTE PTR [ecx+25]
  001b7	84 d2		 test	 dl, dl
  001b9	0f 84 2c 02 00
	00		 je	 $LN74@ioINILoade
  001bf	80 f2 ec	 xor	 dl, -20			; ffffffecH
  001c2	88 50 19	 mov	 BYTE PTR [eax+25], dl
  001c5	8a 51 1a	 mov	 dl, BYTE PTR [ecx+26]
  001c8	84 d2		 test	 dl, dl
  001ca	0f 84 13 02 00
	00		 je	 $LN73@ioINILoade
  001d0	32 d3		 xor	 dl, bl
  001d2	88 50 1a	 mov	 BYTE PTR [eax+26], dl
  001d5	8a 51 1b	 mov	 dl, BYTE PTR [ecx+27]
  001d8	84 d2		 test	 dl, dl
  001da	0f 84 fa 01 00
	00		 je	 $LN72@ioINILoade
  001e0	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  001e3	88 50 1b	 mov	 BYTE PTR [eax+27], dl
  001e6	8a 51 1c	 mov	 dl, BYTE PTR [ecx+28]
  001e9	84 d2		 test	 dl, dl
  001eb	0f 84 e0 01 00
	00		 je	 $LN71@ioINILoade
  001f1	80 f2 ed	 xor	 dl, -19			; ffffffedH
  001f4	88 50 1c	 mov	 BYTE PTR [eax+28], dl
  001f7	8a 51 1d	 mov	 dl, BYTE PTR [ecx+29]
  001fa	84 d2		 test	 dl, dl
  001fc	0f 84 c6 01 00
	00		 je	 $LN70@ioINILoade
  00202	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00205	88 50 1d	 mov	 BYTE PTR [eax+29], dl
  00208	8a 51 1e	 mov	 dl, BYTE PTR [ecx+30]
  0020b	84 d2		 test	 dl, dl
  0020d	0f 84 ad 01 00
	00		 je	 $LN69@ioINILoade
  00213	32 d3		 xor	 dl, bl
  00215	88 50 1e	 mov	 BYTE PTR [eax+30], dl
  00218	8a 51 1f	 mov	 dl, BYTE PTR [ecx+31]
  0021b	84 d2		 test	 dl, dl
  0021d	0f 84 94 01 00
	00		 je	 $LN68@ioINILoade
  00223	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00226	88 50 1f	 mov	 BYTE PTR [eax+31], dl
  00229	8a 51 20	 mov	 dl, BYTE PTR [ecx+32]
  0022c	84 d2		 test	 dl, dl
  0022e	0f 84 7a 01 00
	00		 je	 $LN67@ioINILoade
  00234	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00237	88 50 20	 mov	 BYTE PTR [eax+32], dl
  0023a	8a 51 21	 mov	 dl, BYTE PTR [ecx+33]
  0023d	84 d2		 test	 dl, dl
  0023f	0f 84 60 01 00
	00		 je	 $LN66@ioINILoade
  00245	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00248	88 50 21	 mov	 BYTE PTR [eax+33], dl
  0024b	8a 51 22	 mov	 dl, BYTE PTR [ecx+34]
  0024e	84 d2		 test	 dl, dl
  00250	0f 84 47 01 00
	00		 je	 $LN65@ioINILoade
  00256	32 d3		 xor	 dl, bl
  00258	88 50 22	 mov	 BYTE PTR [eax+34], dl
  0025b	8a 51 23	 mov	 dl, BYTE PTR [ecx+35]
  0025e	84 d2		 test	 dl, dl
  00260	0f 84 2e 01 00
	00		 je	 $LN64@ioINILoade
  00266	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00269	88 50 23	 mov	 BYTE PTR [eax+35], dl
  0026c	8a 51 24	 mov	 dl, BYTE PTR [ecx+36]
  0026f	84 d2		 test	 dl, dl
  00271	0f 84 14 01 00
	00		 je	 $LN63@ioINILoade
  00277	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0027a	88 50 24	 mov	 BYTE PTR [eax+36], dl
  0027d	8a 51 25	 mov	 dl, BYTE PTR [ecx+37]
  00280	84 d2		 test	 dl, dl
  00282	0f 84 fa 00 00
	00		 je	 $LN62@ioINILoade
  00288	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0028b	88 50 25	 mov	 BYTE PTR [eax+37], dl
  0028e	8a 51 26	 mov	 dl, BYTE PTR [ecx+38]
  00291	84 d2		 test	 dl, dl
  00293	0f 84 e1 00 00
	00		 je	 $LN61@ioINILoade
  00299	32 d3		 xor	 dl, bl
  0029b	88 50 26	 mov	 BYTE PTR [eax+38], dl
  0029e	8a 51 27	 mov	 dl, BYTE PTR [ecx+39]
  002a1	84 d2		 test	 dl, dl
  002a3	0f 84 c8 00 00
	00		 je	 $LN60@ioINILoade
  002a9	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  002ac	88 50 27	 mov	 BYTE PTR [eax+39], dl
  002af	8a 51 28	 mov	 dl, BYTE PTR [ecx+40]
  002b2	84 d2		 test	 dl, dl
  002b4	0f 84 ae 00 00
	00		 je	 $LN59@ioINILoade
  002ba	80 f2 ed	 xor	 dl, -19			; ffffffedH
  002bd	88 50 28	 mov	 BYTE PTR [eax+40], dl
  002c0	8a 51 29	 mov	 dl, BYTE PTR [ecx+41]
  002c3	84 d2		 test	 dl, dl
  002c5	0f 84 94 00 00
	00		 je	 $LN58@ioINILoade
  002cb	80 f2 ec	 xor	 dl, -20			; ffffffecH
  002ce	88 50 29	 mov	 BYTE PTR [eax+41], dl
  002d1	8a 51 2a	 mov	 dl, BYTE PTR [ecx+42]
  002d4	84 d2		 test	 dl, dl
  002d6	74 7f		 je	 SHORT $LN57@ioINILoade
  002d8	32 d3		 xor	 dl, bl
  002da	88 50 2a	 mov	 BYTE PTR [eax+42], dl
  002dd	8a 51 2b	 mov	 dl, BYTE PTR [ecx+43]
  002e0	84 d2		 test	 dl, dl
  002e2	74 6a		 je	 SHORT $LN56@ioINILoade
  002e4	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  002e7	88 50 2b	 mov	 BYTE PTR [eax+43], dl
  002ea	8a 51 2c	 mov	 dl, BYTE PTR [ecx+44]
  002ed	84 d2		 test	 dl, dl
  002ef	74 54		 je	 SHORT $LN55@ioINILoade
  002f1	80 f2 ed	 xor	 dl, -19			; ffffffedH
  002f4	88 50 2c	 mov	 BYTE PTR [eax+44], dl
  002f7	8a 51 2d	 mov	 dl, BYTE PTR [ecx+45]
  002fa	84 d2		 test	 dl, dl
  002fc	74 3e		 je	 SHORT $LN54@ioINILoade
  002fe	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00301	88 50 2d	 mov	 BYTE PTR [eax+45], dl
  00304	8a 51 2e	 mov	 dl, BYTE PTR [ecx+46]
  00307	84 d2		 test	 dl, dl
  00309	74 29		 je	 SHORT $LN53@ioINILoade
  0030b	32 d3		 xor	 dl, bl
  0030d	88 50 2e	 mov	 BYTE PTR [eax+46], dl
  00310	8a 51 2f	 mov	 dl, BYTE PTR [ecx+47]
  00313	84 d2		 test	 dl, dl
  00315	74 14		 je	 SHORT $LN52@ioINILoade
  00317	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0031a	88 50 2f	 mov	 BYTE PTR [eax+47], dl
  0031d	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  00320	80 f1 ed	 xor	 cl, -19			; ffffffedH
  00323	88 48 30	 mov	 BYTE PTR [eax+48], cl
  00326	e9 5d 01 00 00	 jmp	 $LN4@ioINILoade
$LN52@ioINILoade:
  0032b	c6 40 2f ea	 mov	 BYTE PTR [eax+47], -22	; ffffffeaH
  0032f	e9 54 01 00 00	 jmp	 $LN4@ioINILoade
$LN53@ioINILoade:
  00334	88 58 2e	 mov	 BYTE PTR [eax+46], bl
  00337	e9 4c 01 00 00	 jmp	 $LN4@ioINILoade
$LN54@ioINILoade:
  0033c	c6 40 2d ec	 mov	 BYTE PTR [eax+45], -20	; ffffffecH
  00340	e9 43 01 00 00	 jmp	 $LN4@ioINILoade
$LN55@ioINILoade:
  00345	c6 40 2c ed	 mov	 BYTE PTR [eax+44], -19	; ffffffedH
  00349	e9 3a 01 00 00	 jmp	 $LN4@ioINILoade
$LN56@ioINILoade:
  0034e	c6 40 2b ea	 mov	 BYTE PTR [eax+43], -22	; ffffffeaH
  00352	e9 31 01 00 00	 jmp	 $LN4@ioINILoade
$LN57@ioINILoade:
  00357	88 58 2a	 mov	 BYTE PTR [eax+42], bl
  0035a	e9 29 01 00 00	 jmp	 $LN4@ioINILoade
$LN58@ioINILoade:
  0035f	c6 40 29 ec	 mov	 BYTE PTR [eax+41], -20	; ffffffecH
  00363	e9 20 01 00 00	 jmp	 $LN4@ioINILoade
$LN59@ioINILoade:
  00368	c6 40 28 ed	 mov	 BYTE PTR [eax+40], -19	; ffffffedH
  0036c	e9 17 01 00 00	 jmp	 $LN4@ioINILoade
$LN60@ioINILoade:
  00371	c6 40 27 ea	 mov	 BYTE PTR [eax+39], -22	; ffffffeaH
  00375	e9 0e 01 00 00	 jmp	 $LN4@ioINILoade
$LN61@ioINILoade:
  0037a	88 58 26	 mov	 BYTE PTR [eax+38], bl
  0037d	e9 06 01 00 00	 jmp	 $LN4@ioINILoade
$LN62@ioINILoade:
  00382	c6 40 25 ec	 mov	 BYTE PTR [eax+37], -20	; ffffffecH
  00386	e9 fd 00 00 00	 jmp	 $LN4@ioINILoade
$LN63@ioINILoade:
  0038b	c6 40 24 ed	 mov	 BYTE PTR [eax+36], -19	; ffffffedH
  0038f	e9 f4 00 00 00	 jmp	 $LN4@ioINILoade
$LN64@ioINILoade:
  00394	c6 40 23 ea	 mov	 BYTE PTR [eax+35], -22	; ffffffeaH
  00398	e9 eb 00 00 00	 jmp	 $LN4@ioINILoade
$LN65@ioINILoade:
  0039d	88 58 22	 mov	 BYTE PTR [eax+34], bl
  003a0	e9 e3 00 00 00	 jmp	 $LN4@ioINILoade
$LN66@ioINILoade:
  003a5	c6 40 21 ec	 mov	 BYTE PTR [eax+33], -20	; ffffffecH
  003a9	e9 da 00 00 00	 jmp	 $LN4@ioINILoade
$LN67@ioINILoade:
  003ae	c6 40 20 ed	 mov	 BYTE PTR [eax+32], -19	; ffffffedH
  003b2	e9 d1 00 00 00	 jmp	 $LN4@ioINILoade
$LN68@ioINILoade:
  003b7	c6 40 1f ea	 mov	 BYTE PTR [eax+31], -22	; ffffffeaH
  003bb	e9 c8 00 00 00	 jmp	 $LN4@ioINILoade
$LN69@ioINILoade:
  003c0	88 58 1e	 mov	 BYTE PTR [eax+30], bl
  003c3	e9 c0 00 00 00	 jmp	 $LN4@ioINILoade
$LN70@ioINILoade:
  003c8	c6 40 1d ec	 mov	 BYTE PTR [eax+29], -20	; ffffffecH
  003cc	e9 b7 00 00 00	 jmp	 $LN4@ioINILoade
$LN71@ioINILoade:
  003d1	c6 40 1c ed	 mov	 BYTE PTR [eax+28], -19	; ffffffedH
  003d5	e9 ae 00 00 00	 jmp	 $LN4@ioINILoade
$LN72@ioINILoade:
  003da	c6 40 1b ea	 mov	 BYTE PTR [eax+27], -22	; ffffffeaH
  003de	e9 a5 00 00 00	 jmp	 $LN4@ioINILoade
$LN73@ioINILoade:
  003e3	88 58 1a	 mov	 BYTE PTR [eax+26], bl
  003e6	e9 9d 00 00 00	 jmp	 $LN4@ioINILoade
$LN74@ioINILoade:
  003eb	c6 40 19 ec	 mov	 BYTE PTR [eax+25], -20	; ffffffecH
  003ef	e9 94 00 00 00	 jmp	 $LN4@ioINILoade
$LN75@ioINILoade:
  003f4	c6 40 18 ed	 mov	 BYTE PTR [eax+24], -19	; ffffffedH
  003f8	e9 8b 00 00 00	 jmp	 $LN4@ioINILoade
$LN76@ioINILoade:
  003fd	c6 40 17 ea	 mov	 BYTE PTR [eax+23], -22	; ffffffeaH
  00401	e9 82 00 00 00	 jmp	 $LN4@ioINILoade
$LN77@ioINILoade:
  00406	88 58 16	 mov	 BYTE PTR [eax+22], bl
  00409	eb 7d		 jmp	 SHORT $LN4@ioINILoade
$LN78@ioINILoade:
  0040b	c6 40 15 ec	 mov	 BYTE PTR [eax+21], -20	; ffffffecH
  0040f	eb 77		 jmp	 SHORT $LN4@ioINILoade
$LN79@ioINILoade:
  00411	c6 40 14 ed	 mov	 BYTE PTR [eax+20], -19	; ffffffedH
  00415	eb 71		 jmp	 SHORT $LN4@ioINILoade
$LN80@ioINILoade:
  00417	c6 40 13 ea	 mov	 BYTE PTR [eax+19], -22	; ffffffeaH
  0041b	eb 6b		 jmp	 SHORT $LN4@ioINILoade
$LN81@ioINILoade:
  0041d	88 58 12	 mov	 BYTE PTR [eax+18], bl
  00420	eb 66		 jmp	 SHORT $LN4@ioINILoade
$LN82@ioINILoade:
  00422	c6 40 11 ec	 mov	 BYTE PTR [eax+17], -20	; ffffffecH
  00426	eb 60		 jmp	 SHORT $LN4@ioINILoade
$LN83@ioINILoade:
  00428	c6 40 10 ed	 mov	 BYTE PTR [eax+16], -19	; ffffffedH
  0042c	eb 5a		 jmp	 SHORT $LN4@ioINILoade
$LN84@ioINILoade:
  0042e	c6 40 0f ea	 mov	 BYTE PTR [eax+15], -22	; ffffffeaH
  00432	eb 54		 jmp	 SHORT $LN4@ioINILoade
$LN85@ioINILoade:
  00434	88 58 0e	 mov	 BYTE PTR [eax+14], bl
  00437	eb 4f		 jmp	 SHORT $LN4@ioINILoade
$LN86@ioINILoade:
  00439	c6 40 0d ec	 mov	 BYTE PTR [eax+13], -20	; ffffffecH
  0043d	eb 49		 jmp	 SHORT $LN4@ioINILoade
$LN87@ioINILoade:
  0043f	c6 40 0c ed	 mov	 BYTE PTR [eax+12], -19	; ffffffedH
  00443	eb 43		 jmp	 SHORT $LN4@ioINILoade
$LN88@ioINILoade:
  00445	c6 40 0b ea	 mov	 BYTE PTR [eax+11], -22	; ffffffeaH
  00449	eb 3d		 jmp	 SHORT $LN4@ioINILoade
$LN89@ioINILoade:
  0044b	88 58 0a	 mov	 BYTE PTR [eax+10], bl
  0044e	eb 38		 jmp	 SHORT $LN4@ioINILoade
$LN90@ioINILoade:
  00450	c6 40 09 ec	 mov	 BYTE PTR [eax+9], -20	; ffffffecH
  00454	eb 32		 jmp	 SHORT $LN4@ioINILoade
$LN91@ioINILoade:
  00456	c6 40 08 ed	 mov	 BYTE PTR [eax+8], -19	; ffffffedH
  0045a	eb 2c		 jmp	 SHORT $LN4@ioINILoade
$LN92@ioINILoade:
  0045c	c6 40 07 ea	 mov	 BYTE PTR [eax+7], -22	; ffffffeaH
  00460	eb 26		 jmp	 SHORT $LN4@ioINILoade
$LN93@ioINILoade:
  00462	88 58 06	 mov	 BYTE PTR [eax+6], bl
  00465	eb 21		 jmp	 SHORT $LN4@ioINILoade
$LN94@ioINILoade:
  00467	c6 40 05 ec	 mov	 BYTE PTR [eax+5], -20	; ffffffecH
  0046b	eb 1b		 jmp	 SHORT $LN4@ioINILoade
$LN95@ioINILoade:
  0046d	c6 40 04 ed	 mov	 BYTE PTR [eax+4], -19	; ffffffedH
  00471	eb 15		 jmp	 SHORT $LN4@ioINILoade
$LN96@ioINILoade:
  00473	c6 40 03 ea	 mov	 BYTE PTR [eax+3], -22	; ffffffeaH
  00477	eb 0f		 jmp	 SHORT $LN4@ioINILoade
$LN97@ioINILoade:
  00479	c6 40 02 eb	 mov	 BYTE PTR [eax+2], -21	; ffffffebH
  0047d	eb 09		 jmp	 SHORT $LN4@ioINILoade
$LN98@ioINILoade:
  0047f	c6 40 01 ec	 mov	 BYTE PTR [eax+1], -20	; ffffffecH
  00483	eb 03		 jmp	 SHORT $LN4@ioINILoade
$LN99@ioINILoade:
  00485	c6 00 ed	 mov	 BYTE PTR [eax], -19	; ffffffedH
$LN4@ioINILoade:
  00488	6a 06		 push	 6
  0048a	8b c8		 mov	 ecx, eax
  0048c	c6 40 1a 00	 mov	 BYTE PTR [eax+26], 0
  00490	5a		 pop	 edx
$LL107@ioINILoade:
  00491	81 31 ed ec eb
	ea		 xor	 DWORD PTR [ecx], -353637139 ; eaebecedH
  00497	83 c1 04	 add	 ecx, 4
  0049a	4a		 dec	 edx
  0049b	75 f4		 jne	 SHORT $LL107@ioINILoade
  0049d	6a 18		 push	 24			; 00000018H
  0049f	5e		 pop	 esi
$LL104@ioINILoade:
  004a0	8b ce		 mov	 ecx, esi
  004a2	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  004a8	79 05		 jns	 SHORT $LN114@ioINILoade
  004aa	49		 dec	 ecx
  004ab	83 c9 fc	 or	 ecx, -4			; fffffffcH
  004ae	41		 inc	 ecx
$LN114@ioINILoade:
  004af	b2 ed		 mov	 dl, -19			; ffffffedH
  004b1	2a d1		 sub	 dl, cl
  004b3	30 14 06	 xor	 BYTE PTR [esi+eax], dl
  004b6	46		 inc	 esi
  004b7	83 fe 1a	 cmp	 esi, 26			; 0000001aH
  004ba	7c e4		 jl	 SHORT $LL104@ioINILoade
  004bc	ff 75 0c	 push	 DWORD PTR _b$[ebp]
  004bf	8b cf		 mov	 ecx, edi
  004c1	50		 push	 eax
  004c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioINILoader@@QAE@PBD_N@Z

; 225  : 	}

  004c8	8b c7		 mov	 eax, edi
  004ca	5f		 pop	 edi
  004cb	5e		 pop	 esi
  004cc	5b		 pop	 ebx
  004cd	5d		 pop	 ebp
  004ce	c2 08 00	 ret	 8
??$?0$0BL@@ioINILoader_e@@QAE@AAY0BL@$$CBD_N@Z ENDP	; ioINILoader_e::ioINILoader_e<27>
_TEXT	ENDS
PUBLIC	??$?0$0BO@@ioINILoader_e@@QAE@AAY0BO@$$CBD_N@Z	; ioINILoader_e::ioINILoader_e<30>
; Function compile flags: /Ogsp
;	COMDAT ??$?0$0BO@@ioINILoader_e@@QAE@AAY0BO@$$CBD_N@Z
_TEXT	SEGMENT
_fn$ = 8						; size = 4
_b$ = 12						; size = 1
??$?0$0BO@@ioINILoader_e@@QAE@AAY0BO@$$CBD_N@Z PROC	; ioINILoader_e::ioINILoader_e<30>, COMDAT
; _this$ = ecx

; 224  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _fn$[ebp]
  0000a	8a 11		 mov	 dl, BYTE PTR [ecx]
  0000c	8d 86 50 03 00
	00		 lea	 eax, DWORD PTR [esi+848]
  00012	84 d2		 test	 dl, dl
  00014	0f 84 6a 04 00
	00		 je	 $LN99@ioINILoade@2
  0001a	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0001d	88 10		 mov	 BYTE PTR [eax], dl
  0001f	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  00022	84 d2		 test	 dl, dl
  00024	0f 84 54 04 00
	00		 je	 $LN98@ioINILoade@2
  0002a	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0002d	88 50 01	 mov	 BYTE PTR [eax+1], dl
  00030	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  00033	84 d2		 test	 dl, dl
  00035	0f 84 3d 04 00
	00		 je	 $LN97@ioINILoade@2
  0003b	b3 eb		 mov	 bl, -21			; ffffffebH
  0003d	32 d3		 xor	 dl, bl
  0003f	88 50 02	 mov	 BYTE PTR [eax+2], dl
  00042	8a 51 03	 mov	 dl, BYTE PTR [ecx+3]
  00045	84 d2		 test	 dl, dl
  00047	0f 84 25 04 00
	00		 je	 $LN96@ioINILoade@2
  0004d	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00050	88 50 03	 mov	 BYTE PTR [eax+3], dl
  00053	8a 51 04	 mov	 dl, BYTE PTR [ecx+4]
  00056	84 d2		 test	 dl, dl
  00058	0f 84 0e 04 00
	00		 je	 $LN95@ioINILoade@2
  0005e	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00061	88 50 04	 mov	 BYTE PTR [eax+4], dl
  00064	8a 51 05	 mov	 dl, BYTE PTR [ecx+5]
  00067	84 d2		 test	 dl, dl
  00069	0f 84 f7 03 00
	00		 je	 $LN94@ioINILoade@2
  0006f	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00072	88 50 05	 mov	 BYTE PTR [eax+5], dl
  00075	8a 51 06	 mov	 dl, BYTE PTR [ecx+6]
  00078	84 d2		 test	 dl, dl
  0007a	0f 84 e1 03 00
	00		 je	 $LN93@ioINILoade@2
  00080	32 d3		 xor	 dl, bl
  00082	88 50 06	 mov	 BYTE PTR [eax+6], dl
  00085	8a 51 07	 mov	 dl, BYTE PTR [ecx+7]
  00088	84 d2		 test	 dl, dl
  0008a	0f 84 cb 03 00
	00		 je	 $LN92@ioINILoade@2
  00090	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00093	88 50 07	 mov	 BYTE PTR [eax+7], dl
  00096	8a 51 08	 mov	 dl, BYTE PTR [ecx+8]
  00099	84 d2		 test	 dl, dl
  0009b	0f 84 b4 03 00
	00		 je	 $LN91@ioINILoade@2
  000a1	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000a4	88 50 08	 mov	 BYTE PTR [eax+8], dl
  000a7	8a 51 09	 mov	 dl, BYTE PTR [ecx+9]
  000aa	84 d2		 test	 dl, dl
  000ac	0f 84 9d 03 00
	00		 je	 $LN90@ioINILoade@2
  000b2	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000b5	88 50 09	 mov	 BYTE PTR [eax+9], dl
  000b8	8a 51 0a	 mov	 dl, BYTE PTR [ecx+10]
  000bb	84 d2		 test	 dl, dl
  000bd	0f 84 87 03 00
	00		 je	 $LN89@ioINILoade@2
  000c3	32 d3		 xor	 dl, bl
  000c5	88 50 0a	 mov	 BYTE PTR [eax+10], dl
  000c8	8a 51 0b	 mov	 dl, BYTE PTR [ecx+11]
  000cb	84 d2		 test	 dl, dl
  000cd	0f 84 71 03 00
	00		 je	 $LN88@ioINILoade@2
  000d3	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000d6	88 50 0b	 mov	 BYTE PTR [eax+11], dl
  000d9	8a 51 0c	 mov	 dl, BYTE PTR [ecx+12]
  000dc	84 d2		 test	 dl, dl
  000de	0f 84 5a 03 00
	00		 je	 $LN87@ioINILoade@2
  000e4	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000e7	88 50 0c	 mov	 BYTE PTR [eax+12], dl
  000ea	8a 51 0d	 mov	 dl, BYTE PTR [ecx+13]
  000ed	84 d2		 test	 dl, dl
  000ef	0f 84 43 03 00
	00		 je	 $LN86@ioINILoade@2
  000f5	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000f8	88 50 0d	 mov	 BYTE PTR [eax+13], dl
  000fb	8a 51 0e	 mov	 dl, BYTE PTR [ecx+14]
  000fe	84 d2		 test	 dl, dl
  00100	0f 84 2d 03 00
	00		 je	 $LN85@ioINILoade@2
  00106	32 d3		 xor	 dl, bl
  00108	88 50 0e	 mov	 BYTE PTR [eax+14], dl
  0010b	8a 51 0f	 mov	 dl, BYTE PTR [ecx+15]
  0010e	84 d2		 test	 dl, dl
  00110	0f 84 17 03 00
	00		 je	 $LN84@ioINILoade@2
  00116	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00119	88 50 0f	 mov	 BYTE PTR [eax+15], dl
  0011c	8a 51 10	 mov	 dl, BYTE PTR [ecx+16]
  0011f	84 d2		 test	 dl, dl
  00121	0f 84 00 03 00
	00		 je	 $LN83@ioINILoade@2
  00127	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0012a	88 50 10	 mov	 BYTE PTR [eax+16], dl
  0012d	8a 51 11	 mov	 dl, BYTE PTR [ecx+17]
  00130	84 d2		 test	 dl, dl
  00132	0f 84 e9 02 00
	00		 je	 $LN82@ioINILoade@2
  00138	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0013b	88 50 11	 mov	 BYTE PTR [eax+17], dl
  0013e	8a 51 12	 mov	 dl, BYTE PTR [ecx+18]
  00141	84 d2		 test	 dl, dl
  00143	0f 84 d3 02 00
	00		 je	 $LN81@ioINILoade@2
  00149	32 d3		 xor	 dl, bl
  0014b	88 50 12	 mov	 BYTE PTR [eax+18], dl
  0014e	8a 51 13	 mov	 dl, BYTE PTR [ecx+19]
  00151	84 d2		 test	 dl, dl
  00153	0f 84 bd 02 00
	00		 je	 $LN80@ioINILoade@2
  00159	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0015c	88 50 13	 mov	 BYTE PTR [eax+19], dl
  0015f	8a 51 14	 mov	 dl, BYTE PTR [ecx+20]
  00162	84 d2		 test	 dl, dl
  00164	0f 84 a6 02 00
	00		 je	 $LN79@ioINILoade@2
  0016a	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0016d	88 50 14	 mov	 BYTE PTR [eax+20], dl
  00170	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00173	84 d2		 test	 dl, dl
  00175	0f 84 8f 02 00
	00		 je	 $LN78@ioINILoade@2
  0017b	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0017e	88 50 15	 mov	 BYTE PTR [eax+21], dl
  00181	8a 51 16	 mov	 dl, BYTE PTR [ecx+22]
  00184	84 d2		 test	 dl, dl
  00186	0f 84 79 02 00
	00		 je	 $LN77@ioINILoade@2
  0018c	32 d3		 xor	 dl, bl
  0018e	88 50 16	 mov	 BYTE PTR [eax+22], dl
  00191	8a 51 17	 mov	 dl, BYTE PTR [ecx+23]
  00194	84 d2		 test	 dl, dl
  00196	0f 84 60 02 00
	00		 je	 $LN76@ioINILoade@2
  0019c	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0019f	88 50 17	 mov	 BYTE PTR [eax+23], dl
  001a2	8a 51 18	 mov	 dl, BYTE PTR [ecx+24]
  001a5	84 d2		 test	 dl, dl
  001a7	0f 84 46 02 00
	00		 je	 $LN75@ioINILoade@2
  001ad	80 f2 ed	 xor	 dl, -19			; ffffffedH
  001b0	88 50 18	 mov	 BYTE PTR [eax+24], dl
  001b3	8a 51 19	 mov	 dl, BYTE PTR [ecx+25]
  001b6	84 d2		 test	 dl, dl
  001b8	0f 84 2c 02 00
	00		 je	 $LN74@ioINILoade@2
  001be	80 f2 ec	 xor	 dl, -20			; ffffffecH
  001c1	88 50 19	 mov	 BYTE PTR [eax+25], dl
  001c4	8a 51 1a	 mov	 dl, BYTE PTR [ecx+26]
  001c7	84 d2		 test	 dl, dl
  001c9	0f 84 13 02 00
	00		 je	 $LN73@ioINILoade@2
  001cf	32 d3		 xor	 dl, bl
  001d1	88 50 1a	 mov	 BYTE PTR [eax+26], dl
  001d4	8a 51 1b	 mov	 dl, BYTE PTR [ecx+27]
  001d7	84 d2		 test	 dl, dl
  001d9	0f 84 fa 01 00
	00		 je	 $LN72@ioINILoade@2
  001df	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  001e2	88 50 1b	 mov	 BYTE PTR [eax+27], dl
  001e5	8a 51 1c	 mov	 dl, BYTE PTR [ecx+28]
  001e8	84 d2		 test	 dl, dl
  001ea	0f 84 e0 01 00
	00		 je	 $LN71@ioINILoade@2
  001f0	80 f2 ed	 xor	 dl, -19			; ffffffedH
  001f3	88 50 1c	 mov	 BYTE PTR [eax+28], dl
  001f6	8a 51 1d	 mov	 dl, BYTE PTR [ecx+29]
  001f9	84 d2		 test	 dl, dl
  001fb	0f 84 c6 01 00
	00		 je	 $LN70@ioINILoade@2
  00201	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00204	88 50 1d	 mov	 BYTE PTR [eax+29], dl
  00207	8a 51 1e	 mov	 dl, BYTE PTR [ecx+30]
  0020a	84 d2		 test	 dl, dl
  0020c	0f 84 ad 01 00
	00		 je	 $LN69@ioINILoade@2
  00212	32 d3		 xor	 dl, bl
  00214	88 50 1e	 mov	 BYTE PTR [eax+30], dl
  00217	8a 51 1f	 mov	 dl, BYTE PTR [ecx+31]
  0021a	84 d2		 test	 dl, dl
  0021c	0f 84 94 01 00
	00		 je	 $LN68@ioINILoade@2
  00222	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00225	88 50 1f	 mov	 BYTE PTR [eax+31], dl
  00228	8a 51 20	 mov	 dl, BYTE PTR [ecx+32]
  0022b	84 d2		 test	 dl, dl
  0022d	0f 84 7a 01 00
	00		 je	 $LN67@ioINILoade@2
  00233	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00236	88 50 20	 mov	 BYTE PTR [eax+32], dl
  00239	8a 51 21	 mov	 dl, BYTE PTR [ecx+33]
  0023c	84 d2		 test	 dl, dl
  0023e	0f 84 60 01 00
	00		 je	 $LN66@ioINILoade@2
  00244	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00247	88 50 21	 mov	 BYTE PTR [eax+33], dl
  0024a	8a 51 22	 mov	 dl, BYTE PTR [ecx+34]
  0024d	84 d2		 test	 dl, dl
  0024f	0f 84 47 01 00
	00		 je	 $LN65@ioINILoade@2
  00255	32 d3		 xor	 dl, bl
  00257	88 50 22	 mov	 BYTE PTR [eax+34], dl
  0025a	8a 51 23	 mov	 dl, BYTE PTR [ecx+35]
  0025d	84 d2		 test	 dl, dl
  0025f	0f 84 2e 01 00
	00		 je	 $LN64@ioINILoade@2
  00265	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00268	88 50 23	 mov	 BYTE PTR [eax+35], dl
  0026b	8a 51 24	 mov	 dl, BYTE PTR [ecx+36]
  0026e	84 d2		 test	 dl, dl
  00270	0f 84 14 01 00
	00		 je	 $LN63@ioINILoade@2
  00276	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00279	88 50 24	 mov	 BYTE PTR [eax+36], dl
  0027c	8a 51 25	 mov	 dl, BYTE PTR [ecx+37]
  0027f	84 d2		 test	 dl, dl
  00281	0f 84 fa 00 00
	00		 je	 $LN62@ioINILoade@2
  00287	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0028a	88 50 25	 mov	 BYTE PTR [eax+37], dl
  0028d	8a 51 26	 mov	 dl, BYTE PTR [ecx+38]
  00290	84 d2		 test	 dl, dl
  00292	0f 84 e1 00 00
	00		 je	 $LN61@ioINILoade@2
  00298	32 d3		 xor	 dl, bl
  0029a	88 50 26	 mov	 BYTE PTR [eax+38], dl
  0029d	8a 51 27	 mov	 dl, BYTE PTR [ecx+39]
  002a0	84 d2		 test	 dl, dl
  002a2	0f 84 c8 00 00
	00		 je	 $LN60@ioINILoade@2
  002a8	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  002ab	88 50 27	 mov	 BYTE PTR [eax+39], dl
  002ae	8a 51 28	 mov	 dl, BYTE PTR [ecx+40]
  002b1	84 d2		 test	 dl, dl
  002b3	0f 84 ae 00 00
	00		 je	 $LN59@ioINILoade@2
  002b9	80 f2 ed	 xor	 dl, -19			; ffffffedH
  002bc	88 50 28	 mov	 BYTE PTR [eax+40], dl
  002bf	8a 51 29	 mov	 dl, BYTE PTR [ecx+41]
  002c2	84 d2		 test	 dl, dl
  002c4	0f 84 94 00 00
	00		 je	 $LN58@ioINILoade@2
  002ca	80 f2 ec	 xor	 dl, -20			; ffffffecH
  002cd	88 50 29	 mov	 BYTE PTR [eax+41], dl
  002d0	8a 51 2a	 mov	 dl, BYTE PTR [ecx+42]
  002d3	84 d2		 test	 dl, dl
  002d5	74 7f		 je	 SHORT $LN57@ioINILoade@2
  002d7	32 d3		 xor	 dl, bl
  002d9	88 50 2a	 mov	 BYTE PTR [eax+42], dl
  002dc	8a 51 2b	 mov	 dl, BYTE PTR [ecx+43]
  002df	84 d2		 test	 dl, dl
  002e1	74 6a		 je	 SHORT $LN56@ioINILoade@2
  002e3	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  002e6	88 50 2b	 mov	 BYTE PTR [eax+43], dl
  002e9	8a 51 2c	 mov	 dl, BYTE PTR [ecx+44]
  002ec	84 d2		 test	 dl, dl
  002ee	74 54		 je	 SHORT $LN55@ioINILoade@2
  002f0	80 f2 ed	 xor	 dl, -19			; ffffffedH
  002f3	88 50 2c	 mov	 BYTE PTR [eax+44], dl
  002f6	8a 51 2d	 mov	 dl, BYTE PTR [ecx+45]
  002f9	84 d2		 test	 dl, dl
  002fb	74 3e		 je	 SHORT $LN54@ioINILoade@2
  002fd	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00300	88 50 2d	 mov	 BYTE PTR [eax+45], dl
  00303	8a 51 2e	 mov	 dl, BYTE PTR [ecx+46]
  00306	84 d2		 test	 dl, dl
  00308	74 29		 je	 SHORT $LN53@ioINILoade@2
  0030a	32 d3		 xor	 dl, bl
  0030c	88 50 2e	 mov	 BYTE PTR [eax+46], dl
  0030f	8a 51 2f	 mov	 dl, BYTE PTR [ecx+47]
  00312	84 d2		 test	 dl, dl
  00314	74 14		 je	 SHORT $LN52@ioINILoade@2
  00316	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00319	88 50 2f	 mov	 BYTE PTR [eax+47], dl
  0031c	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  0031f	80 f1 ed	 xor	 cl, -19			; ffffffedH
  00322	88 48 30	 mov	 BYTE PTR [eax+48], cl
  00325	e9 5d 01 00 00	 jmp	 $LN4@ioINILoade@2
$LN52@ioINILoade@2:
  0032a	c6 40 2f ea	 mov	 BYTE PTR [eax+47], -22	; ffffffeaH
  0032e	e9 54 01 00 00	 jmp	 $LN4@ioINILoade@2
$LN53@ioINILoade@2:
  00333	88 58 2e	 mov	 BYTE PTR [eax+46], bl
  00336	e9 4c 01 00 00	 jmp	 $LN4@ioINILoade@2
$LN54@ioINILoade@2:
  0033b	c6 40 2d ec	 mov	 BYTE PTR [eax+45], -20	; ffffffecH
  0033f	e9 43 01 00 00	 jmp	 $LN4@ioINILoade@2
$LN55@ioINILoade@2:
  00344	c6 40 2c ed	 mov	 BYTE PTR [eax+44], -19	; ffffffedH
  00348	e9 3a 01 00 00	 jmp	 $LN4@ioINILoade@2
$LN56@ioINILoade@2:
  0034d	c6 40 2b ea	 mov	 BYTE PTR [eax+43], -22	; ffffffeaH
  00351	e9 31 01 00 00	 jmp	 $LN4@ioINILoade@2
$LN57@ioINILoade@2:
  00356	88 58 2a	 mov	 BYTE PTR [eax+42], bl
  00359	e9 29 01 00 00	 jmp	 $LN4@ioINILoade@2
$LN58@ioINILoade@2:
  0035e	c6 40 29 ec	 mov	 BYTE PTR [eax+41], -20	; ffffffecH
  00362	e9 20 01 00 00	 jmp	 $LN4@ioINILoade@2
$LN59@ioINILoade@2:
  00367	c6 40 28 ed	 mov	 BYTE PTR [eax+40], -19	; ffffffedH
  0036b	e9 17 01 00 00	 jmp	 $LN4@ioINILoade@2
$LN60@ioINILoade@2:
  00370	c6 40 27 ea	 mov	 BYTE PTR [eax+39], -22	; ffffffeaH
  00374	e9 0e 01 00 00	 jmp	 $LN4@ioINILoade@2
$LN61@ioINILoade@2:
  00379	88 58 26	 mov	 BYTE PTR [eax+38], bl
  0037c	e9 06 01 00 00	 jmp	 $LN4@ioINILoade@2
$LN62@ioINILoade@2:
  00381	c6 40 25 ec	 mov	 BYTE PTR [eax+37], -20	; ffffffecH
  00385	e9 fd 00 00 00	 jmp	 $LN4@ioINILoade@2
$LN63@ioINILoade@2:
  0038a	c6 40 24 ed	 mov	 BYTE PTR [eax+36], -19	; ffffffedH
  0038e	e9 f4 00 00 00	 jmp	 $LN4@ioINILoade@2
$LN64@ioINILoade@2:
  00393	c6 40 23 ea	 mov	 BYTE PTR [eax+35], -22	; ffffffeaH
  00397	e9 eb 00 00 00	 jmp	 $LN4@ioINILoade@2
$LN65@ioINILoade@2:
  0039c	88 58 22	 mov	 BYTE PTR [eax+34], bl
  0039f	e9 e3 00 00 00	 jmp	 $LN4@ioINILoade@2
$LN66@ioINILoade@2:
  003a4	c6 40 21 ec	 mov	 BYTE PTR [eax+33], -20	; ffffffecH
  003a8	e9 da 00 00 00	 jmp	 $LN4@ioINILoade@2
$LN67@ioINILoade@2:
  003ad	c6 40 20 ed	 mov	 BYTE PTR [eax+32], -19	; ffffffedH
  003b1	e9 d1 00 00 00	 jmp	 $LN4@ioINILoade@2
$LN68@ioINILoade@2:
  003b6	c6 40 1f ea	 mov	 BYTE PTR [eax+31], -22	; ffffffeaH
  003ba	e9 c8 00 00 00	 jmp	 $LN4@ioINILoade@2
$LN69@ioINILoade@2:
  003bf	88 58 1e	 mov	 BYTE PTR [eax+30], bl
  003c2	e9 c0 00 00 00	 jmp	 $LN4@ioINILoade@2
$LN70@ioINILoade@2:
  003c7	c6 40 1d ec	 mov	 BYTE PTR [eax+29], -20	; ffffffecH
  003cb	e9 b7 00 00 00	 jmp	 $LN4@ioINILoade@2
$LN71@ioINILoade@2:
  003d0	c6 40 1c ed	 mov	 BYTE PTR [eax+28], -19	; ffffffedH
  003d4	e9 ae 00 00 00	 jmp	 $LN4@ioINILoade@2
$LN72@ioINILoade@2:
  003d9	c6 40 1b ea	 mov	 BYTE PTR [eax+27], -22	; ffffffeaH
  003dd	e9 a5 00 00 00	 jmp	 $LN4@ioINILoade@2
$LN73@ioINILoade@2:
  003e2	88 58 1a	 mov	 BYTE PTR [eax+26], bl
  003e5	e9 9d 00 00 00	 jmp	 $LN4@ioINILoade@2
$LN74@ioINILoade@2:
  003ea	c6 40 19 ec	 mov	 BYTE PTR [eax+25], -20	; ffffffecH
  003ee	e9 94 00 00 00	 jmp	 $LN4@ioINILoade@2
$LN75@ioINILoade@2:
  003f3	c6 40 18 ed	 mov	 BYTE PTR [eax+24], -19	; ffffffedH
  003f7	e9 8b 00 00 00	 jmp	 $LN4@ioINILoade@2
$LN76@ioINILoade@2:
  003fc	c6 40 17 ea	 mov	 BYTE PTR [eax+23], -22	; ffffffeaH
  00400	e9 82 00 00 00	 jmp	 $LN4@ioINILoade@2
$LN77@ioINILoade@2:
  00405	88 58 16	 mov	 BYTE PTR [eax+22], bl
  00408	eb 7d		 jmp	 SHORT $LN4@ioINILoade@2
$LN78@ioINILoade@2:
  0040a	c6 40 15 ec	 mov	 BYTE PTR [eax+21], -20	; ffffffecH
  0040e	eb 77		 jmp	 SHORT $LN4@ioINILoade@2
$LN79@ioINILoade@2:
  00410	c6 40 14 ed	 mov	 BYTE PTR [eax+20], -19	; ffffffedH
  00414	eb 71		 jmp	 SHORT $LN4@ioINILoade@2
$LN80@ioINILoade@2:
  00416	c6 40 13 ea	 mov	 BYTE PTR [eax+19], -22	; ffffffeaH
  0041a	eb 6b		 jmp	 SHORT $LN4@ioINILoade@2
$LN81@ioINILoade@2:
  0041c	88 58 12	 mov	 BYTE PTR [eax+18], bl
  0041f	eb 66		 jmp	 SHORT $LN4@ioINILoade@2
$LN82@ioINILoade@2:
  00421	c6 40 11 ec	 mov	 BYTE PTR [eax+17], -20	; ffffffecH
  00425	eb 60		 jmp	 SHORT $LN4@ioINILoade@2
$LN83@ioINILoade@2:
  00427	c6 40 10 ed	 mov	 BYTE PTR [eax+16], -19	; ffffffedH
  0042b	eb 5a		 jmp	 SHORT $LN4@ioINILoade@2
$LN84@ioINILoade@2:
  0042d	c6 40 0f ea	 mov	 BYTE PTR [eax+15], -22	; ffffffeaH
  00431	eb 54		 jmp	 SHORT $LN4@ioINILoade@2
$LN85@ioINILoade@2:
  00433	88 58 0e	 mov	 BYTE PTR [eax+14], bl
  00436	eb 4f		 jmp	 SHORT $LN4@ioINILoade@2
$LN86@ioINILoade@2:
  00438	c6 40 0d ec	 mov	 BYTE PTR [eax+13], -20	; ffffffecH
  0043c	eb 49		 jmp	 SHORT $LN4@ioINILoade@2
$LN87@ioINILoade@2:
  0043e	c6 40 0c ed	 mov	 BYTE PTR [eax+12], -19	; ffffffedH
  00442	eb 43		 jmp	 SHORT $LN4@ioINILoade@2
$LN88@ioINILoade@2:
  00444	c6 40 0b ea	 mov	 BYTE PTR [eax+11], -22	; ffffffeaH
  00448	eb 3d		 jmp	 SHORT $LN4@ioINILoade@2
$LN89@ioINILoade@2:
  0044a	88 58 0a	 mov	 BYTE PTR [eax+10], bl
  0044d	eb 38		 jmp	 SHORT $LN4@ioINILoade@2
$LN90@ioINILoade@2:
  0044f	c6 40 09 ec	 mov	 BYTE PTR [eax+9], -20	; ffffffecH
  00453	eb 32		 jmp	 SHORT $LN4@ioINILoade@2
$LN91@ioINILoade@2:
  00455	c6 40 08 ed	 mov	 BYTE PTR [eax+8], -19	; ffffffedH
  00459	eb 2c		 jmp	 SHORT $LN4@ioINILoade@2
$LN92@ioINILoade@2:
  0045b	c6 40 07 ea	 mov	 BYTE PTR [eax+7], -22	; ffffffeaH
  0045f	eb 26		 jmp	 SHORT $LN4@ioINILoade@2
$LN93@ioINILoade@2:
  00461	88 58 06	 mov	 BYTE PTR [eax+6], bl
  00464	eb 21		 jmp	 SHORT $LN4@ioINILoade@2
$LN94@ioINILoade@2:
  00466	c6 40 05 ec	 mov	 BYTE PTR [eax+5], -20	; ffffffecH
  0046a	eb 1b		 jmp	 SHORT $LN4@ioINILoade@2
$LN95@ioINILoade@2:
  0046c	c6 40 04 ed	 mov	 BYTE PTR [eax+4], -19	; ffffffedH
  00470	eb 15		 jmp	 SHORT $LN4@ioINILoade@2
$LN96@ioINILoade@2:
  00472	c6 40 03 ea	 mov	 BYTE PTR [eax+3], -22	; ffffffeaH
  00476	eb 0f		 jmp	 SHORT $LN4@ioINILoade@2
$LN97@ioINILoade@2:
  00478	c6 40 02 eb	 mov	 BYTE PTR [eax+2], -21	; ffffffebH
  0047c	eb 09		 jmp	 SHORT $LN4@ioINILoade@2
$LN98@ioINILoade@2:
  0047e	c6 40 01 ec	 mov	 BYTE PTR [eax+1], -20	; ffffffecH
  00482	eb 03		 jmp	 SHORT $LN4@ioINILoade@2
$LN99@ioINILoade@2:
  00484	c6 00 ed	 mov	 BYTE PTR [eax], -19	; ffffffedH
$LN4@ioINILoade@2:
  00487	6a 07		 push	 7
  00489	8b c8		 mov	 ecx, eax
  0048b	c6 40 1d 00	 mov	 BYTE PTR [eax+29], 0
  0048f	5a		 pop	 edx
$LL107@ioINILoade@2:
  00490	81 31 ed ec eb
	ea		 xor	 DWORD PTR [ecx], -353637139 ; eaebecedH
  00496	83 c1 04	 add	 ecx, 4
  00499	4a		 dec	 edx
  0049a	75 f4		 jne	 SHORT $LL107@ioINILoade@2
  0049c	ff 75 0c	 push	 DWORD PTR _b$[ebp]
  0049f	80 70 1c ed	 xor	 BYTE PTR [eax+28], -19	; ffffffedH
  004a3	50		 push	 eax
  004a4	8b ce		 mov	 ecx, esi
  004a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioINILoader@@QAE@PBD_N@Z

; 225  : 	}

  004ac	8b c6		 mov	 eax, esi
  004ae	5e		 pop	 esi
  004af	5b		 pop	 ebx
  004b0	5d		 pop	 ebp
  004b1	c2 08 00	 ret	 8
??$?0$0BO@@ioINILoader_e@@QAE@AAY0BO@$$CBD_N@Z ENDP	; ioINILoader_e::ioINILoader_e<30>
_TEXT	ENDS
PUBLIC	??$?0$0BI@@ioINILoader_e@@QAE@AAY0BI@$$CBD_N@Z	; ioINILoader_e::ioINILoader_e<24>
; Function compile flags: /Ogsp
;	COMDAT ??$?0$0BI@@ioINILoader_e@@QAE@AAY0BI@$$CBD_N@Z
_TEXT	SEGMENT
_fn$ = 8						; size = 4
_b$ = 12						; size = 1
??$?0$0BI@@ioINILoader_e@@QAE@AAY0BI@$$CBD_N@Z PROC	; ioINILoader_e::ioINILoader_e<24>, COMDAT
; _this$ = ecx

; 224  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _fn$[ebp]
  0000b	8a 11		 mov	 dl, BYTE PTR [ecx]
  0000d	8d 87 50 03 00
	00		 lea	 eax, DWORD PTR [edi+848]
  00013	84 d2		 test	 dl, dl
  00015	0f 84 6a 04 00
	00		 je	 $LN99@ioINILoade@3
  0001b	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0001e	88 10		 mov	 BYTE PTR [eax], dl
  00020	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  00023	84 d2		 test	 dl, dl
  00025	0f 84 54 04 00
	00		 je	 $LN98@ioINILoade@3
  0002b	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0002e	88 50 01	 mov	 BYTE PTR [eax+1], dl
  00031	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  00034	84 d2		 test	 dl, dl
  00036	0f 84 3d 04 00
	00		 je	 $LN97@ioINILoade@3
  0003c	b3 eb		 mov	 bl, -21			; ffffffebH
  0003e	32 d3		 xor	 dl, bl
  00040	88 50 02	 mov	 BYTE PTR [eax+2], dl
  00043	8a 51 03	 mov	 dl, BYTE PTR [ecx+3]
  00046	84 d2		 test	 dl, dl
  00048	0f 84 25 04 00
	00		 je	 $LN96@ioINILoade@3
  0004e	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00051	88 50 03	 mov	 BYTE PTR [eax+3], dl
  00054	8a 51 04	 mov	 dl, BYTE PTR [ecx+4]
  00057	84 d2		 test	 dl, dl
  00059	0f 84 0e 04 00
	00		 je	 $LN95@ioINILoade@3
  0005f	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00062	88 50 04	 mov	 BYTE PTR [eax+4], dl
  00065	8a 51 05	 mov	 dl, BYTE PTR [ecx+5]
  00068	84 d2		 test	 dl, dl
  0006a	0f 84 f7 03 00
	00		 je	 $LN94@ioINILoade@3
  00070	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00073	88 50 05	 mov	 BYTE PTR [eax+5], dl
  00076	8a 51 06	 mov	 dl, BYTE PTR [ecx+6]
  00079	84 d2		 test	 dl, dl
  0007b	0f 84 e1 03 00
	00		 je	 $LN93@ioINILoade@3
  00081	32 d3		 xor	 dl, bl
  00083	88 50 06	 mov	 BYTE PTR [eax+6], dl
  00086	8a 51 07	 mov	 dl, BYTE PTR [ecx+7]
  00089	84 d2		 test	 dl, dl
  0008b	0f 84 cb 03 00
	00		 je	 $LN92@ioINILoade@3
  00091	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00094	88 50 07	 mov	 BYTE PTR [eax+7], dl
  00097	8a 51 08	 mov	 dl, BYTE PTR [ecx+8]
  0009a	84 d2		 test	 dl, dl
  0009c	0f 84 b4 03 00
	00		 je	 $LN91@ioINILoade@3
  000a2	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000a5	88 50 08	 mov	 BYTE PTR [eax+8], dl
  000a8	8a 51 09	 mov	 dl, BYTE PTR [ecx+9]
  000ab	84 d2		 test	 dl, dl
  000ad	0f 84 9d 03 00
	00		 je	 $LN90@ioINILoade@3
  000b3	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000b6	88 50 09	 mov	 BYTE PTR [eax+9], dl
  000b9	8a 51 0a	 mov	 dl, BYTE PTR [ecx+10]
  000bc	84 d2		 test	 dl, dl
  000be	0f 84 87 03 00
	00		 je	 $LN89@ioINILoade@3
  000c4	32 d3		 xor	 dl, bl
  000c6	88 50 0a	 mov	 BYTE PTR [eax+10], dl
  000c9	8a 51 0b	 mov	 dl, BYTE PTR [ecx+11]
  000cc	84 d2		 test	 dl, dl
  000ce	0f 84 71 03 00
	00		 je	 $LN88@ioINILoade@3
  000d4	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  000d7	88 50 0b	 mov	 BYTE PTR [eax+11], dl
  000da	8a 51 0c	 mov	 dl, BYTE PTR [ecx+12]
  000dd	84 d2		 test	 dl, dl
  000df	0f 84 5a 03 00
	00		 je	 $LN87@ioINILoade@3
  000e5	80 f2 ed	 xor	 dl, -19			; ffffffedH
  000e8	88 50 0c	 mov	 BYTE PTR [eax+12], dl
  000eb	8a 51 0d	 mov	 dl, BYTE PTR [ecx+13]
  000ee	84 d2		 test	 dl, dl
  000f0	0f 84 43 03 00
	00		 je	 $LN86@ioINILoade@3
  000f6	80 f2 ec	 xor	 dl, -20			; ffffffecH
  000f9	88 50 0d	 mov	 BYTE PTR [eax+13], dl
  000fc	8a 51 0e	 mov	 dl, BYTE PTR [ecx+14]
  000ff	84 d2		 test	 dl, dl
  00101	0f 84 2d 03 00
	00		 je	 $LN85@ioINILoade@3
  00107	32 d3		 xor	 dl, bl
  00109	88 50 0e	 mov	 BYTE PTR [eax+14], dl
  0010c	8a 51 0f	 mov	 dl, BYTE PTR [ecx+15]
  0010f	84 d2		 test	 dl, dl
  00111	0f 84 17 03 00
	00		 je	 $LN84@ioINILoade@3
  00117	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0011a	88 50 0f	 mov	 BYTE PTR [eax+15], dl
  0011d	8a 51 10	 mov	 dl, BYTE PTR [ecx+16]
  00120	84 d2		 test	 dl, dl
  00122	0f 84 00 03 00
	00		 je	 $LN83@ioINILoade@3
  00128	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0012b	88 50 10	 mov	 BYTE PTR [eax+16], dl
  0012e	8a 51 11	 mov	 dl, BYTE PTR [ecx+17]
  00131	84 d2		 test	 dl, dl
  00133	0f 84 e9 02 00
	00		 je	 $LN82@ioINILoade@3
  00139	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0013c	88 50 11	 mov	 BYTE PTR [eax+17], dl
  0013f	8a 51 12	 mov	 dl, BYTE PTR [ecx+18]
  00142	84 d2		 test	 dl, dl
  00144	0f 84 d3 02 00
	00		 je	 $LN81@ioINILoade@3
  0014a	32 d3		 xor	 dl, bl
  0014c	88 50 12	 mov	 BYTE PTR [eax+18], dl
  0014f	8a 51 13	 mov	 dl, BYTE PTR [ecx+19]
  00152	84 d2		 test	 dl, dl
  00154	0f 84 bd 02 00
	00		 je	 $LN80@ioINILoade@3
  0015a	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0015d	88 50 13	 mov	 BYTE PTR [eax+19], dl
  00160	8a 51 14	 mov	 dl, BYTE PTR [ecx+20]
  00163	84 d2		 test	 dl, dl
  00165	0f 84 a6 02 00
	00		 je	 $LN79@ioINILoade@3
  0016b	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0016e	88 50 14	 mov	 BYTE PTR [eax+20], dl
  00171	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00174	84 d2		 test	 dl, dl
  00176	0f 84 8f 02 00
	00		 je	 $LN78@ioINILoade@3
  0017c	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0017f	88 50 15	 mov	 BYTE PTR [eax+21], dl
  00182	8a 51 16	 mov	 dl, BYTE PTR [ecx+22]
  00185	84 d2		 test	 dl, dl
  00187	0f 84 79 02 00
	00		 je	 $LN77@ioINILoade@3
  0018d	32 d3		 xor	 dl, bl
  0018f	88 50 16	 mov	 BYTE PTR [eax+22], dl
  00192	8a 51 17	 mov	 dl, BYTE PTR [ecx+23]
  00195	84 d2		 test	 dl, dl
  00197	0f 84 60 02 00
	00		 je	 $LN76@ioINILoade@3
  0019d	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  001a0	88 50 17	 mov	 BYTE PTR [eax+23], dl
  001a3	8a 51 18	 mov	 dl, BYTE PTR [ecx+24]
  001a6	84 d2		 test	 dl, dl
  001a8	0f 84 46 02 00
	00		 je	 $LN75@ioINILoade@3
  001ae	80 f2 ed	 xor	 dl, -19			; ffffffedH
  001b1	88 50 18	 mov	 BYTE PTR [eax+24], dl
  001b4	8a 51 19	 mov	 dl, BYTE PTR [ecx+25]
  001b7	84 d2		 test	 dl, dl
  001b9	0f 84 2c 02 00
	00		 je	 $LN74@ioINILoade@3
  001bf	80 f2 ec	 xor	 dl, -20			; ffffffecH
  001c2	88 50 19	 mov	 BYTE PTR [eax+25], dl
  001c5	8a 51 1a	 mov	 dl, BYTE PTR [ecx+26]
  001c8	84 d2		 test	 dl, dl
  001ca	0f 84 13 02 00
	00		 je	 $LN73@ioINILoade@3
  001d0	32 d3		 xor	 dl, bl
  001d2	88 50 1a	 mov	 BYTE PTR [eax+26], dl
  001d5	8a 51 1b	 mov	 dl, BYTE PTR [ecx+27]
  001d8	84 d2		 test	 dl, dl
  001da	0f 84 fa 01 00
	00		 je	 $LN72@ioINILoade@3
  001e0	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  001e3	88 50 1b	 mov	 BYTE PTR [eax+27], dl
  001e6	8a 51 1c	 mov	 dl, BYTE PTR [ecx+28]
  001e9	84 d2		 test	 dl, dl
  001eb	0f 84 e0 01 00
	00		 je	 $LN71@ioINILoade@3
  001f1	80 f2 ed	 xor	 dl, -19			; ffffffedH
  001f4	88 50 1c	 mov	 BYTE PTR [eax+28], dl
  001f7	8a 51 1d	 mov	 dl, BYTE PTR [ecx+29]
  001fa	84 d2		 test	 dl, dl
  001fc	0f 84 c6 01 00
	00		 je	 $LN70@ioINILoade@3
  00202	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00205	88 50 1d	 mov	 BYTE PTR [eax+29], dl
  00208	8a 51 1e	 mov	 dl, BYTE PTR [ecx+30]
  0020b	84 d2		 test	 dl, dl
  0020d	0f 84 ad 01 00
	00		 je	 $LN69@ioINILoade@3
  00213	32 d3		 xor	 dl, bl
  00215	88 50 1e	 mov	 BYTE PTR [eax+30], dl
  00218	8a 51 1f	 mov	 dl, BYTE PTR [ecx+31]
  0021b	84 d2		 test	 dl, dl
  0021d	0f 84 94 01 00
	00		 je	 $LN68@ioINILoade@3
  00223	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00226	88 50 1f	 mov	 BYTE PTR [eax+31], dl
  00229	8a 51 20	 mov	 dl, BYTE PTR [ecx+32]
  0022c	84 d2		 test	 dl, dl
  0022e	0f 84 7a 01 00
	00		 je	 $LN67@ioINILoade@3
  00234	80 f2 ed	 xor	 dl, -19			; ffffffedH
  00237	88 50 20	 mov	 BYTE PTR [eax+32], dl
  0023a	8a 51 21	 mov	 dl, BYTE PTR [ecx+33]
  0023d	84 d2		 test	 dl, dl
  0023f	0f 84 60 01 00
	00		 je	 $LN66@ioINILoade@3
  00245	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00248	88 50 21	 mov	 BYTE PTR [eax+33], dl
  0024b	8a 51 22	 mov	 dl, BYTE PTR [ecx+34]
  0024e	84 d2		 test	 dl, dl
  00250	0f 84 47 01 00
	00		 je	 $LN65@ioINILoade@3
  00256	32 d3		 xor	 dl, bl
  00258	88 50 22	 mov	 BYTE PTR [eax+34], dl
  0025b	8a 51 23	 mov	 dl, BYTE PTR [ecx+35]
  0025e	84 d2		 test	 dl, dl
  00260	0f 84 2e 01 00
	00		 je	 $LN64@ioINILoade@3
  00266	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  00269	88 50 23	 mov	 BYTE PTR [eax+35], dl
  0026c	8a 51 24	 mov	 dl, BYTE PTR [ecx+36]
  0026f	84 d2		 test	 dl, dl
  00271	0f 84 14 01 00
	00		 je	 $LN63@ioINILoade@3
  00277	80 f2 ed	 xor	 dl, -19			; ffffffedH
  0027a	88 50 24	 mov	 BYTE PTR [eax+36], dl
  0027d	8a 51 25	 mov	 dl, BYTE PTR [ecx+37]
  00280	84 d2		 test	 dl, dl
  00282	0f 84 fa 00 00
	00		 je	 $LN62@ioINILoade@3
  00288	80 f2 ec	 xor	 dl, -20			; ffffffecH
  0028b	88 50 25	 mov	 BYTE PTR [eax+37], dl
  0028e	8a 51 26	 mov	 dl, BYTE PTR [ecx+38]
  00291	84 d2		 test	 dl, dl
  00293	0f 84 e1 00 00
	00		 je	 $LN61@ioINILoade@3
  00299	32 d3		 xor	 dl, bl
  0029b	88 50 26	 mov	 BYTE PTR [eax+38], dl
  0029e	8a 51 27	 mov	 dl, BYTE PTR [ecx+39]
  002a1	84 d2		 test	 dl, dl
  002a3	0f 84 c8 00 00
	00		 je	 $LN60@ioINILoade@3
  002a9	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  002ac	88 50 27	 mov	 BYTE PTR [eax+39], dl
  002af	8a 51 28	 mov	 dl, BYTE PTR [ecx+40]
  002b2	84 d2		 test	 dl, dl
  002b4	0f 84 ae 00 00
	00		 je	 $LN59@ioINILoade@3
  002ba	80 f2 ed	 xor	 dl, -19			; ffffffedH
  002bd	88 50 28	 mov	 BYTE PTR [eax+40], dl
  002c0	8a 51 29	 mov	 dl, BYTE PTR [ecx+41]
  002c3	84 d2		 test	 dl, dl
  002c5	0f 84 94 00 00
	00		 je	 $LN58@ioINILoade@3
  002cb	80 f2 ec	 xor	 dl, -20			; ffffffecH
  002ce	88 50 29	 mov	 BYTE PTR [eax+41], dl
  002d1	8a 51 2a	 mov	 dl, BYTE PTR [ecx+42]
  002d4	84 d2		 test	 dl, dl
  002d6	74 7f		 je	 SHORT $LN57@ioINILoade@3
  002d8	32 d3		 xor	 dl, bl
  002da	88 50 2a	 mov	 BYTE PTR [eax+42], dl
  002dd	8a 51 2b	 mov	 dl, BYTE PTR [ecx+43]
  002e0	84 d2		 test	 dl, dl
  002e2	74 6a		 je	 SHORT $LN56@ioINILoade@3
  002e4	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  002e7	88 50 2b	 mov	 BYTE PTR [eax+43], dl
  002ea	8a 51 2c	 mov	 dl, BYTE PTR [ecx+44]
  002ed	84 d2		 test	 dl, dl
  002ef	74 54		 je	 SHORT $LN55@ioINILoade@3
  002f1	80 f2 ed	 xor	 dl, -19			; ffffffedH
  002f4	88 50 2c	 mov	 BYTE PTR [eax+44], dl
  002f7	8a 51 2d	 mov	 dl, BYTE PTR [ecx+45]
  002fa	84 d2		 test	 dl, dl
  002fc	74 3e		 je	 SHORT $LN54@ioINILoade@3
  002fe	80 f2 ec	 xor	 dl, -20			; ffffffecH
  00301	88 50 2d	 mov	 BYTE PTR [eax+45], dl
  00304	8a 51 2e	 mov	 dl, BYTE PTR [ecx+46]
  00307	84 d2		 test	 dl, dl
  00309	74 29		 je	 SHORT $LN53@ioINILoade@3
  0030b	32 d3		 xor	 dl, bl
  0030d	88 50 2e	 mov	 BYTE PTR [eax+46], dl
  00310	8a 51 2f	 mov	 dl, BYTE PTR [ecx+47]
  00313	84 d2		 test	 dl, dl
  00315	74 14		 je	 SHORT $LN52@ioINILoade@3
  00317	80 f2 ea	 xor	 dl, -22			; ffffffeaH
  0031a	88 50 2f	 mov	 BYTE PTR [eax+47], dl
  0031d	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  00320	80 f1 ed	 xor	 cl, -19			; ffffffedH
  00323	88 48 30	 mov	 BYTE PTR [eax+48], cl
  00326	e9 5d 01 00 00	 jmp	 $LN4@ioINILoade@3
$LN52@ioINILoade@3:
  0032b	c6 40 2f ea	 mov	 BYTE PTR [eax+47], -22	; ffffffeaH
  0032f	e9 54 01 00 00	 jmp	 $LN4@ioINILoade@3
$LN53@ioINILoade@3:
  00334	88 58 2e	 mov	 BYTE PTR [eax+46], bl
  00337	e9 4c 01 00 00	 jmp	 $LN4@ioINILoade@3
$LN54@ioINILoade@3:
  0033c	c6 40 2d ec	 mov	 BYTE PTR [eax+45], -20	; ffffffecH
  00340	e9 43 01 00 00	 jmp	 $LN4@ioINILoade@3
$LN55@ioINILoade@3:
  00345	c6 40 2c ed	 mov	 BYTE PTR [eax+44], -19	; ffffffedH
  00349	e9 3a 01 00 00	 jmp	 $LN4@ioINILoade@3
$LN56@ioINILoade@3:
  0034e	c6 40 2b ea	 mov	 BYTE PTR [eax+43], -22	; ffffffeaH
  00352	e9 31 01 00 00	 jmp	 $LN4@ioINILoade@3
$LN57@ioINILoade@3:
  00357	88 58 2a	 mov	 BYTE PTR [eax+42], bl
  0035a	e9 29 01 00 00	 jmp	 $LN4@ioINILoade@3
$LN58@ioINILoade@3:
  0035f	c6 40 29 ec	 mov	 BYTE PTR [eax+41], -20	; ffffffecH
  00363	e9 20 01 00 00	 jmp	 $LN4@ioINILoade@3
$LN59@ioINILoade@3:
  00368	c6 40 28 ed	 mov	 BYTE PTR [eax+40], -19	; ffffffedH
  0036c	e9 17 01 00 00	 jmp	 $LN4@ioINILoade@3
$LN60@ioINILoade@3:
  00371	c6 40 27 ea	 mov	 BYTE PTR [eax+39], -22	; ffffffeaH
  00375	e9 0e 01 00 00	 jmp	 $LN4@ioINILoade@3
$LN61@ioINILoade@3:
  0037a	88 58 26	 mov	 BYTE PTR [eax+38], bl
  0037d	e9 06 01 00 00	 jmp	 $LN4@ioINILoade@3
$LN62@ioINILoade@3:
  00382	c6 40 25 ec	 mov	 BYTE PTR [eax+37], -20	; ffffffecH
  00386	e9 fd 00 00 00	 jmp	 $LN4@ioINILoade@3
$LN63@ioINILoade@3:
  0038b	c6 40 24 ed	 mov	 BYTE PTR [eax+36], -19	; ffffffedH
  0038f	e9 f4 00 00 00	 jmp	 $LN4@ioINILoade@3
$LN64@ioINILoade@3:
  00394	c6 40 23 ea	 mov	 BYTE PTR [eax+35], -22	; ffffffeaH
  00398	e9 eb 00 00 00	 jmp	 $LN4@ioINILoade@3
$LN65@ioINILoade@3:
  0039d	88 58 22	 mov	 BYTE PTR [eax+34], bl
  003a0	e9 e3 00 00 00	 jmp	 $LN4@ioINILoade@3
$LN66@ioINILoade@3:
  003a5	c6 40 21 ec	 mov	 BYTE PTR [eax+33], -20	; ffffffecH
  003a9	e9 da 00 00 00	 jmp	 $LN4@ioINILoade@3
$LN67@ioINILoade@3:
  003ae	c6 40 20 ed	 mov	 BYTE PTR [eax+32], -19	; ffffffedH
  003b2	e9 d1 00 00 00	 jmp	 $LN4@ioINILoade@3
$LN68@ioINILoade@3:
  003b7	c6 40 1f ea	 mov	 BYTE PTR [eax+31], -22	; ffffffeaH
  003bb	e9 c8 00 00 00	 jmp	 $LN4@ioINILoade@3
$LN69@ioINILoade@3:
  003c0	88 58 1e	 mov	 BYTE PTR [eax+30], bl
  003c3	e9 c0 00 00 00	 jmp	 $LN4@ioINILoade@3
$LN70@ioINILoade@3:
  003c8	c6 40 1d ec	 mov	 BYTE PTR [eax+29], -20	; ffffffecH
  003cc	e9 b7 00 00 00	 jmp	 $LN4@ioINILoade@3
$LN71@ioINILoade@3:
  003d1	c6 40 1c ed	 mov	 BYTE PTR [eax+28], -19	; ffffffedH
  003d5	e9 ae 00 00 00	 jmp	 $LN4@ioINILoade@3
$LN72@ioINILoade@3:
  003da	c6 40 1b ea	 mov	 BYTE PTR [eax+27], -22	; ffffffeaH
  003de	e9 a5 00 00 00	 jmp	 $LN4@ioINILoade@3
$LN73@ioINILoade@3:
  003e3	88 58 1a	 mov	 BYTE PTR [eax+26], bl
  003e6	e9 9d 00 00 00	 jmp	 $LN4@ioINILoade@3
$LN74@ioINILoade@3:
  003eb	c6 40 19 ec	 mov	 BYTE PTR [eax+25], -20	; ffffffecH
  003ef	e9 94 00 00 00	 jmp	 $LN4@ioINILoade@3
$LN75@ioINILoade@3:
  003f4	c6 40 18 ed	 mov	 BYTE PTR [eax+24], -19	; ffffffedH
  003f8	e9 8b 00 00 00	 jmp	 $LN4@ioINILoade@3
$LN76@ioINILoade@3:
  003fd	c6 40 17 ea	 mov	 BYTE PTR [eax+23], -22	; ffffffeaH
  00401	e9 82 00 00 00	 jmp	 $LN4@ioINILoade@3
$LN77@ioINILoade@3:
  00406	88 58 16	 mov	 BYTE PTR [eax+22], bl
  00409	eb 7d		 jmp	 SHORT $LN4@ioINILoade@3
$LN78@ioINILoade@3:
  0040b	c6 40 15 ec	 mov	 BYTE PTR [eax+21], -20	; ffffffecH
  0040f	eb 77		 jmp	 SHORT $LN4@ioINILoade@3
$LN79@ioINILoade@3:
  00411	c6 40 14 ed	 mov	 BYTE PTR [eax+20], -19	; ffffffedH
  00415	eb 71		 jmp	 SHORT $LN4@ioINILoade@3
$LN80@ioINILoade@3:
  00417	c6 40 13 ea	 mov	 BYTE PTR [eax+19], -22	; ffffffeaH
  0041b	eb 6b		 jmp	 SHORT $LN4@ioINILoade@3
$LN81@ioINILoade@3:
  0041d	88 58 12	 mov	 BYTE PTR [eax+18], bl
  00420	eb 66		 jmp	 SHORT $LN4@ioINILoade@3
$LN82@ioINILoade@3:
  00422	c6 40 11 ec	 mov	 BYTE PTR [eax+17], -20	; ffffffecH
  00426	eb 60		 jmp	 SHORT $LN4@ioINILoade@3
$LN83@ioINILoade@3:
  00428	c6 40 10 ed	 mov	 BYTE PTR [eax+16], -19	; ffffffedH
  0042c	eb 5a		 jmp	 SHORT $LN4@ioINILoade@3
$LN84@ioINILoade@3:
  0042e	c6 40 0f ea	 mov	 BYTE PTR [eax+15], -22	; ffffffeaH
  00432	eb 54		 jmp	 SHORT $LN4@ioINILoade@3
$LN85@ioINILoade@3:
  00434	88 58 0e	 mov	 BYTE PTR [eax+14], bl
  00437	eb 4f		 jmp	 SHORT $LN4@ioINILoade@3
$LN86@ioINILoade@3:
  00439	c6 40 0d ec	 mov	 BYTE PTR [eax+13], -20	; ffffffecH
  0043d	eb 49		 jmp	 SHORT $LN4@ioINILoade@3
$LN87@ioINILoade@3:
  0043f	c6 40 0c ed	 mov	 BYTE PTR [eax+12], -19	; ffffffedH
  00443	eb 43		 jmp	 SHORT $LN4@ioINILoade@3
$LN88@ioINILoade@3:
  00445	c6 40 0b ea	 mov	 BYTE PTR [eax+11], -22	; ffffffeaH
  00449	eb 3d		 jmp	 SHORT $LN4@ioINILoade@3
$LN89@ioINILoade@3:
  0044b	88 58 0a	 mov	 BYTE PTR [eax+10], bl
  0044e	eb 38		 jmp	 SHORT $LN4@ioINILoade@3
$LN90@ioINILoade@3:
  00450	c6 40 09 ec	 mov	 BYTE PTR [eax+9], -20	; ffffffecH
  00454	eb 32		 jmp	 SHORT $LN4@ioINILoade@3
$LN91@ioINILoade@3:
  00456	c6 40 08 ed	 mov	 BYTE PTR [eax+8], -19	; ffffffedH
  0045a	eb 2c		 jmp	 SHORT $LN4@ioINILoade@3
$LN92@ioINILoade@3:
  0045c	c6 40 07 ea	 mov	 BYTE PTR [eax+7], -22	; ffffffeaH
  00460	eb 26		 jmp	 SHORT $LN4@ioINILoade@3
$LN93@ioINILoade@3:
  00462	88 58 06	 mov	 BYTE PTR [eax+6], bl
  00465	eb 21		 jmp	 SHORT $LN4@ioINILoade@3
$LN94@ioINILoade@3:
  00467	c6 40 05 ec	 mov	 BYTE PTR [eax+5], -20	; ffffffecH
  0046b	eb 1b		 jmp	 SHORT $LN4@ioINILoade@3
$LN95@ioINILoade@3:
  0046d	c6 40 04 ed	 mov	 BYTE PTR [eax+4], -19	; ffffffedH
  00471	eb 15		 jmp	 SHORT $LN4@ioINILoade@3
$LN96@ioINILoade@3:
  00473	c6 40 03 ea	 mov	 BYTE PTR [eax+3], -22	; ffffffeaH
  00477	eb 0f		 jmp	 SHORT $LN4@ioINILoade@3
$LN97@ioINILoade@3:
  00479	c6 40 02 eb	 mov	 BYTE PTR [eax+2], -21	; ffffffebH
  0047d	eb 09		 jmp	 SHORT $LN4@ioINILoade@3
$LN98@ioINILoade@3:
  0047f	c6 40 01 ec	 mov	 BYTE PTR [eax+1], -20	; ffffffecH
  00483	eb 03		 jmp	 SHORT $LN4@ioINILoade@3
$LN99@ioINILoade@3:
  00485	c6 00 ed	 mov	 BYTE PTR [eax], -19	; ffffffedH
$LN4@ioINILoade@3:
  00488	6a 05		 push	 5
  0048a	8b c8		 mov	 ecx, eax
  0048c	c6 40 17 00	 mov	 BYTE PTR [eax+23], 0
  00490	5a		 pop	 edx
$LL107@ioINILoade@3:
  00491	81 31 ed ec eb
	ea		 xor	 DWORD PTR [ecx], -353637139 ; eaebecedH
  00497	83 c1 04	 add	 ecx, 4
  0049a	4a		 dec	 edx
  0049b	75 f4		 jne	 SHORT $LL107@ioINILoade@3
  0049d	6a 14		 push	 20			; 00000014H
  0049f	5e		 pop	 esi
$LL104@ioINILoade@3:
  004a0	8b ce		 mov	 ecx, esi
  004a2	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  004a8	79 05		 jns	 SHORT $LN114@ioINILoade@3
  004aa	49		 dec	 ecx
  004ab	83 c9 fc	 or	 ecx, -4			; fffffffcH
  004ae	41		 inc	 ecx
$LN114@ioINILoade@3:
  004af	b2 ed		 mov	 dl, -19			; ffffffedH
  004b1	2a d1		 sub	 dl, cl
  004b3	30 14 06	 xor	 BYTE PTR [esi+eax], dl
  004b6	46		 inc	 esi
  004b7	83 fe 17	 cmp	 esi, 23			; 00000017H
  004ba	7c e4		 jl	 SHORT $LL104@ioINILoade@3
  004bc	ff 75 0c	 push	 DWORD PTR _b$[ebp]
  004bf	8b cf		 mov	 ecx, edi
  004c1	50		 push	 eax
  004c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioINILoader@@QAE@PBD_N@Z

; 225  : 	}

  004c8	8b c7		 mov	 eax, edi
  004ca	5f		 pop	 edi
  004cb	5e		 pop	 esi
  004cc	5b		 pop	 ebx
  004cd	5d		 pop	 ebp
  004ce	c2 08 00	 ret	 8
??$?0$0BI@@ioINILoader_e@@QAE@AAY0BI@$$CBD_N@Z ENDP	; ioINILoader_e::ioINILoader_e<24>
_TEXT	ENDS
PUBLIC	??$_Umove@PAG@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAG00@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Umove<unsigned short *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAG@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAG00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAG@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAG00@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Umove<unsigned short *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00009	56		 push	 esi
  0000a	d1 f8		 sar	 eax, 1
  0000c	8d 34 00	 lea	 esi, DWORD PTR [eax+eax]
  0000f	56		 push	 esi
  00010	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00013	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001f	03 c6		 add	 eax, esi
  00021	5e		 pop	 esi

; 1326 : 		}

  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAG@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAG00@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Umove<unsigned short *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@G@std@@GABG@std@@YAXAAV?$allocator@G@0@PAGABG@Z ; std::_Cons_val<std::allocator<unsigned short>,unsigned short,unsigned short const &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@G@std@@GABG@std@@YAXAAV?$allocator@G@0@PAGABG@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@G@std@@GABG@std@@YAXAAV?$allocator@G@0@PAGABG@Z PROC ; std::_Cons_val<std::allocator<unsigned short>,unsigned short,unsigned short const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $LN9@Cons_val@3
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	66 8b 09	 mov	 cx, WORD PTR [ecx]
  00010	66 89 08	 mov	 WORD PTR [eax], cx
$LN9@Cons_val@3:

; 281  : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Cons_val@V?$allocator@G@std@@GABG@std@@YAXAAV?$allocator@G@0@PAGABG@Z ENDP ; std::_Cons_val<std::allocator<unsigned short>,unsigned short,unsigned short const &>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@UtagMecroTextInfo@CKeyInfo@@AAU34@@std@@YAXAAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@PAUtagMecroTextInfo@CKeyInfo@@AAU23@@Z ; std::_Cons_val<std::allocator<CKeyInfo::tagMecroTextInfo>,CKeyInfo::tagMecroTextInfo,CKeyInfo::tagMecroTextInfo &>
; Function compile flags: /Ogsp
;	COMDAT ??$_Cons_val@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@UtagMecroTextInfo@CKeyInfo@@AAU34@@std@@YAXAAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@PAUtagMecroTextInfo@CKeyInfo@@AAU23@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@UtagMecroTextInfo@CKeyInfo@@AAU34@@std@@YAXAAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@PAUtagMecroTextInfo@CKeyInfo@@AAU23@@Z PROC ; std::_Cons_val<std::allocator<CKeyInfo::tagMecroTextInfo>,CKeyInfo::tagMecroTextInfo,CKeyInfo::tagMecroTextInfo &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	ff 75 10	 push	 DWORD PTR __Src$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Pdest$[ebp]
  0000c	e8 00 00 00 00	 call	 ??$construct@AAUtagMecroTextInfo@CKeyInfo@@@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@AAU23@@Z ; std::allocator<CKeyInfo::tagMecroTextInfo>::construct<CKeyInfo::tagMecroTextInfo &>

; 281  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Cons_val@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@UtagMecroTextInfo@CKeyInfo@@AAU34@@std@@YAXAAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@PAUtagMecroTextInfo@CKeyInfo@@AAU23@@Z ENDP ; std::_Cons_val<std::allocator<CKeyInfo::tagMecroTextInfo>,CKeyInfo::tagMecroTextInfo,CKeyInfo::tagMecroTextInfo &>
_TEXT	ENDS
PUBLIC	??$_Move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00@Z ; std::_Move<CKeyInfo::tagMecroTextInfo *,CKeyInfo::tagMecroTextInfo *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00@Z
_TEXT	SEGMENT
__Cat$519382 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00@Z PROC ; std::_Move<CKeyInfo::tagMecroTextInfo *,CKeyInfo::tagMecroTextInfo *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$519382[ebp]
  00007	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<CKeyInfo::tagMecroTextInfo *,CKeyInfo::tagMecroTextInfo *>
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00018	c9		 leave
  00019	c3		 ret	 0
??$_Move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00@Z ENDP ; std::_Move<CKeyInfo::tagMecroTextInfo *,CKeyInfo::tagMecroTextInfo *>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@ABU34@@Z ; std::allocator<CKeyInfo::tagMecroTextInfo>::construct
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@ABU34@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@ABU34@@Z PROC ; std::allocator<CKeyInfo::tagMecroTextInfo>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 		_Construct(_Ptr, _Val);

  00003	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  00006	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00009	e8 00 00 00 00	 call	 ??$_Construct@UtagMecroTextInfo@CKeyInfo@@ABU12@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@ABU12@@Z ; std::_Construct<CKeyInfo::tagMecroTextInfo,CKeyInfo::tagMecroTextInfo const &>
  0000e	59		 pop	 ecx
  0000f	59		 pop	 ecx

; 198  : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?construct@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@ABU34@@Z ENDP ; std::allocator<CKeyInfo::tagMecroTextInfo>::construct
_TEXT	ENDS
PUBLIC	??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >,bool>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000f	8a 09		 mov	 cl, BYTE PTR [ecx]
  00011	88 48 04	 mov	 BYTE PTR [eax+4], cl

; 228  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::operator--
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 418  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 419  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >,std::_Iterator_base0>::operator--

; 420  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 421  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >::operator--
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > > &,bool>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000f	8a 09		 mov	 cl, BYTE PTR [ecx]
  00011	88 48 04	 mov	 BYTE PTR [eax+4], cl

; 248  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	??$_Destroy@U?$pair@$$CBGVioHashString@@@std@@@std@@YAXPAU?$pair@$$CBGVioHashString@@@0@@Z ; std::_Destroy<std::pair<unsigned short const ,ioHashString> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy@U?$pair@$$CBGVioHashString@@@std@@@std@@YAXPAU?$pair@$$CBGVioHashString@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U?$pair@$$CBGVioHashString@@@std@@@std@@YAXPAU?$pair@$$CBGVioHashString@@@0@@Z PROC ; std::_Destroy<std::pair<unsigned short const ,ioHashString> >, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 63   : 	_Ptr->~_Ty();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	83 c1 04	 add	 ecx, 4

; 64   : 	}

  00009	5d		 pop	 ebp

; 63   : 	_Ptr->~_Ty();

  0000a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
??$_Destroy@U?$pair@$$CBGVioHashString@@@std@@@std@@YAXPAU?$pair@$$CBGVioHashString@@@0@@Z ENDP ; std::_Destroy<std::pair<unsigned short const ,ioHashString> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@@Z ; std::allocator<CKeyInfo::tagMecroTextInfo>::destroy
; Function compile flags: /Ogsp
;	COMDAT ?destroy@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@@Z PROC ; std::allocator<CKeyInfo::tagMecroTextInfo>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 213  : 		_Destroy(_Ptr);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	83 c1 04	 add	 ecx, 4
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ

; 214  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?destroy@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@@Z ENDP ; std::allocator<CKeyInfo::tagMecroTextInfo>::destroy
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@UtagMecroTextInfo@CKeyInfo@@U34@@std@@YAXAAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@PAUtagMecroTextInfo@CKeyInfo@@$$QAU23@@Z ; std::_Cons_val<std::allocator<CKeyInfo::tagMecroTextInfo>,CKeyInfo::tagMecroTextInfo,CKeyInfo::tagMecroTextInfo>
; Function compile flags: /Ogsp
;	COMDAT ??$_Cons_val@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@UtagMecroTextInfo@CKeyInfo@@U34@@std@@YAXAAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@PAUtagMecroTextInfo@CKeyInfo@@$$QAU23@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@UtagMecroTextInfo@CKeyInfo@@U34@@std@@YAXAAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@PAUtagMecroTextInfo@CKeyInfo@@$$QAU23@@Z PROC ; std::_Cons_val<std::allocator<CKeyInfo::tagMecroTextInfo>,CKeyInfo::tagMecroTextInfo,CKeyInfo::tagMecroTextInfo>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	ff 75 10	 push	 DWORD PTR __Src$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Pdest$[ebp]
  0000c	e8 00 00 00 00	 call	 ?construct@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@$$QAU34@@Z ; std::allocator<CKeyInfo::tagMecroTextInfo>::construct

; 281  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Cons_val@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@UtagMecroTextInfo@CKeyInfo@@U34@@std@@YAXAAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@PAUtagMecroTextInfo@CKeyInfo@@$$QAU23@@Z ENDP ; std::_Cons_val<std::allocator<CKeyInfo::tagMecroTextInfo>,CKeyInfo::tagMecroTextInfo,CKeyInfo::tagMecroTextInfo>
_TEXT	ENDS
PUBLIC	??$?0$$CBGVioHashString@@@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAU01@@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><unsigned short const ,ioHashString>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0$$CBGVioHashString@@@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0$$CBGVioHashString@@@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAU01@@Z PROC ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><unsigned short const ,ioHashString>, COMDAT
; _this$ = ecx

; 255  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000c	83 c0 04	 add	 eax, 4
  0000f	66 89 0e	 mov	 WORD PTR [esi], cx
  00012	50		 push	 eax
  00013	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@ABV0@@Z

; 256  : 		}

  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??$?0$$CBGVioHashString@@@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAU01@@Z ENDP ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><unsigned short const ,ioHashString>
_TEXT	ENDS
PUBLIC	?SaveKey@ioKeyManager@@QAEXXZ			; ioKeyManager::SaveKey
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iokeymanager.cpp
;	COMDAT ?SaveKey@ioKeyManager@@QAEXXZ
_TEXT	SEGMENT
?SaveKey@ioKeyManager@@QAEXXZ PROC			; ioKeyManager::SaveKey, COMDAT
; _this$ = ecx

; 1480 : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 1481 : 	if( m_bSaveKey )

  00004	80 bf 95 00 00
	00 00		 cmp	 BYTE PTR [edi+149], 0
  0000b	74 15		 je	 SHORT $LN1@SaveKey@3

; 1482 : 	{
; 1483 : 		m_CustomKeyInfo.SaveKey();

  0000d	8d 4f 2c	 lea	 ecx, DWORD PTR [edi+44]
  00010	8b 01		 mov	 eax, DWORD PTR [ecx]
  00012	ff 10		 call	 DWORD PTR [eax]

; 1484 : 		SendKey();

  00014	8b cf		 mov	 ecx, edi
  00016	e8 00 00 00 00	 call	 ?SendKey@ioKeyManager@@AAEXXZ ; ioKeyManager::SendKey

; 1485 : 		m_bSaveKey = false;

  0001b	c6 87 95 00 00
	00 00		 mov	 BYTE PTR [edi+149], 0
$LN1@SaveKey@3:

; 1486 : 	}
; 1487 : }

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	c3		 ret	 0
?SaveKey@ioKeyManager@@QAEXXZ ENDP			; ioKeyManager::SaveKey
_TEXT	ENDS
PUBLIC	??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ	; std::vector<unsigned short,std::allocator<unsigned short> >::~vector<unsigned short,std::allocator<unsigned short> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::~vector<unsigned short,std::allocator<unsigned short> >, COMDAT
; _this$ = ecx

; 705  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@GV?$allocator@G@std@@@std@@IAEXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Tidy
??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::~vector<unsigned short,std::allocator<unsigned short> >
_TEXT	ENDS
PUBLIC	?reserve@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::reserve
; Function compile flags: /Ogsp
;	COMDAT ?reserve@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?reserve@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 747  : 		if (max_size() < _Count)

  00003	81 7d 08 ff ff
	ff 7f		 cmp	 DWORD PTR __Count$[ebp], 2147483647 ; 7fffffffH
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	76 0b		 jbe	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN51@reserve:
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  0001a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0001d	2b 06		 sub	 eax, DWORD PTR [esi]
  0001f	d1 f8		 sar	 eax, 1
  00021	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00024	73 54		 jae	 SHORT $LN3@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  00026	53		 push	 ebx
  00027	57		 push	 edi
  00028	6a 00		 push	 0
  0002a	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$_Allocate@G@std@@YAPAGIPAG@Z ; std::_Allocate<unsigned short>

; 752  : 
; 753  : 			_TRY_BEGIN
; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00032	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00034	8b d8		 mov	 ebx, eax
  00036	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00039	2b c1		 sub	 eax, ecx
  0003b	d1 f8		 sar	 eax, 1
  0003d	03 c0		 add	 eax, eax
  0003f	50		 push	 eax
  00040	51		 push	 ecx
  00041	53		 push	 ebx
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);
; 757  : 			_RERAISE;
; 758  : 			_CATCH_END
; 759  : 
; 760  : 			size_type _Size = size();

  00048	8b 06		 mov	 eax, DWORD PTR [esi]
  0004a	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0004d	2b f8		 sub	 edi, eax
  0004f	83 c4 14	 add	 esp, 20			; 00000014H
  00052	d1 ff		 sar	 edi, 1

; 761  : 			if (this->_Myfirst != 0)

  00054	85 c0		 test	 eax, eax
  00056	74 07		 je	 SHORT $LN47@reserve

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);
; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0005e	59		 pop	 ecx
$LN47@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  0005f	8b ce		 mov	 ecx, esi
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 769  : 			this->_Myend = _Ptr + _Count;

  00067	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0006a	8d 04 43	 lea	 eax, DWORD PTR [ebx+eax*2]
  0006d	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 770  : 			this->_Mylast = _Ptr + _Size;

  00070	8d 04 7b	 lea	 eax, DWORD PTR [ebx+edi*2]
  00073	5f		 pop	 edi

; 771  : 			this->_Myfirst = _Ptr;

  00074	89 1e		 mov	 DWORD PTR [esi], ebx
  00076	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00079	5b		 pop	 ebx
$LN3@reserve:
  0007a	5e		 pop	 esi

; 772  : 			}
; 773  : 		}

  0007b	5d		 pop	 ebp
  0007c	c2 04 00	 ret	 4
$LN50@reserve:
?reserve@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::reserve
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::end
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::end, COMDAT
; _this$ = ecx

; 816  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 817  : 		return (iterator(this->_Myhead, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 818  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::end
_TEXT	ENDS
PUBLIC	?erase@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@0@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::erase
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?erase@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Cat$519730 = 16					; size = 1
__Last_arg$ = 16					; size = 4
?erase@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@0@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	8b f1		 mov	 esi, ecx
  0000d	89 07		 mov	 DWORD PTR [edi], eax

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);
; 1193 : 
; 1194 : 		if (_First != _Last)

  0000f	3b 45 10	 cmp	 eax, DWORD PTR __Last_arg$[ebp]
  00012	74 16		 je	 SHORT $LN1@erase

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  00014	ff 75 10	 push	 DWORD PTR __Cat$519730[ebp]
  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	50		 push	 eax
  0001b	51		 push	 ecx
  0001c	ff 75 10	 push	 DWORD PTR __Last_arg$[ebp]
  0001f	e8 00 00 00 00	 call	 ??$_Move@PAGPAG@std@@YAPAGPAG00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<unsigned short *,unsigned short *>
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);
; 1211 : 			this->_Mylast = _Ptr;

  00027	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN1@erase:

; 1212 : 			}
; 1213 : 		return (_First);

  0002a	8b c7		 mov	 eax, edi
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi

; 1214 : 		}

  0002e	5d		 pop	 ebp
  0002f	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@0@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::erase
_TEXT	ENDS
PUBLIC	?_Reserve@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Reserve
; Function compile flags: /Ogsp
;	COMDAT ?_Reserve@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1291 : 		size_type _Size = size();

  00006	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00008	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000b	2b c1		 sub	 eax, ecx

; 1292 : 		if (max_size() - _Count < _Size)

  0000d	ba ff ff ff 7f	 mov	 edx, 2147483647		; 7fffffffH
  00012	2b 55 08	 sub	 edx, DWORD PTR __Count$[ebp]
  00015	d1 f8		 sar	 eax, 1
  00017	3b d0		 cmp	 edx, eax
  00019	73 0b		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN21@Reserve:
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00026	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00029	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  0002c	2b d1		 sub	 edx, ecx
  0002e	d1 fa		 sar	 edx, 1
  00030	3b c2		 cmp	 eax, edx
  00032	76 10		 jbe	 SHORT $LN1@Reserve

; 1295 : 			;
; 1296 : 		else
; 1297 : 			reserve(_Grow_to(_Size));

  00034	50		 push	 eax
  00035	8b ce		 mov	 ecx, esi
  00037	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@GV?$allocator@G@std@@@std@@IBEII@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Grow_to
  0003c	50		 push	 eax
  0003d	8b ce		 mov	 ecx, esi
  0003f	e8 00 00 00 00	 call	 ?reserve@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::reserve
$LN1@Reserve:
  00044	5e		 pop	 esi

; 1298 : 		}

  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
$LN20@Reserve:
?_Reserve@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Reserve
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@G@1@ABV?$allocator@U?$pair@$$CBGVioHashString@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@G@1@ABV?$allocator@U?$pair@$$CBGVioHashString@@@std@@@1@@Z
_TEXT	SEGMENT
$T519800 = -4						; size = 4
$T519795 = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@G@1@ABV?$allocator@U?$pair@$$CBGVioHashString@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >, COMDAT
; _this$ = ecx

; 698  : 		{	// construct empty tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	51		 push	 ecx
  00006	89 65 fc	 mov	 DWORD PTR $T519795[ebp], esp
  00009	89 65 fc	 mov	 DWORD PTR $T519800[ebp], esp
  0000c	ff 75 08	 push	 DWORD PTR __Parg$[ebp]
  0000f	8b f1		 mov	 esi, ecx
  00011	e8 00 00 00 00	 call	 ??0?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@G@1@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >

; 699  : 		}

  00016	8b c6		 mov	 eax, esi
  00018	5e		 pop	 esi
  00019	c9		 leave
  0001a	c2 08 00	 ret	 8
??0?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@G@1@ABV?$allocator@U?$pair@$$CBGVioHashString@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@ABG@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::lower_bound
; Function compile flags: /Ogsp
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@ABG@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@ABG@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1449 : 		{	// find leftmost node not less than _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1450 : 		return (iterator(_Lbound(_Keyval), this));

  00003	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  00006	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@ABG@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Lbound
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000e	89 01		 mov	 DWORD PTR [ecx], eax
  00010	8b c1		 mov	 eax, ecx

; 1451 : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@ABG@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@UtagMecroTextInfo@CKeyInfo@@ABU34@@std@@YAXAAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@PAUtagMecroTextInfo@CKeyInfo@@ABU23@@Z ; std::_Cons_val<std::allocator<CKeyInfo::tagMecroTextInfo>,CKeyInfo::tagMecroTextInfo,CKeyInfo::tagMecroTextInfo const &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@UtagMecroTextInfo@CKeyInfo@@ABU34@@std@@YAXAAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@PAUtagMecroTextInfo@CKeyInfo@@ABU23@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@UtagMecroTextInfo@CKeyInfo@@ABU34@@std@@YAXAAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@PAUtagMecroTextInfo@CKeyInfo@@ABU23@@Z PROC ; std::_Cons_val<std::allocator<CKeyInfo::tagMecroTextInfo>,CKeyInfo::tagMecroTextInfo,CKeyInfo::tagMecroTextInfo const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	ff 75 10	 push	 DWORD PTR __Src$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR __Pdest$[ebp]
  00009	e8 00 00 00 00	 call	 ??$_Construct@UtagMecroTextInfo@CKeyInfo@@ABU12@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@ABU12@@Z ; std::_Construct<CKeyInfo::tagMecroTextInfo,CKeyInfo::tagMecroTextInfo const &>
  0000e	59		 pop	 ecx
  0000f	59		 pop	 ecx

; 281  : 	}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Cons_val@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@UtagMecroTextInfo@CKeyInfo@@ABU34@@std@@YAXAAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@PAUtagMecroTextInfo@CKeyInfo@@ABU23@@Z ENDP ; std::_Cons_val<std::allocator<CKeyInfo::tagMecroTextInfo>,CKeyInfo::tagMecroTextInfo,CKeyInfo::tagMecroTextInfo const &>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@QAEXPAU?$pair@$$CBGVioHashString@@@2@@Z ; std::allocator<std::pair<unsigned short const ,ioHashString> >::destroy
; Function compile flags: /Ogsp
;	COMDAT ?destroy@?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@QAEXPAU?$pair@$$CBGVioHashString@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@QAEXPAU?$pair@$$CBGVioHashString@@@2@@Z PROC ; std::allocator<std::pair<unsigned short const ,ioHashString> >::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 213  : 		_Destroy(_Ptr);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	83 c1 04	 add	 ecx, 4
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ

; 214  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?destroy@?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@QAEXPAU?$pair@$$CBGVioHashString@@@2@@Z ENDP ; std::allocator<std::pair<unsigned short const ,ioHashString> >::destroy
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@UtagMecroTextInfo@CKeyInfo@@@std@@YAXAAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@PAUtagMecroTextInfo@CKeyInfo@@@Z ; std::_Dest_val<std::allocator<CKeyInfo::tagMecroTextInfo>,CKeyInfo::tagMecroTextInfo>
; Function compile flags: /Ogsp
;	COMDAT ??$_Dest_val@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@UtagMecroTextInfo@CKeyInfo@@@std@@YAXAAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@PAUtagMecroTextInfo@CKeyInfo@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@UtagMecroTextInfo@CKeyInfo@@@std@@YAXAAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@PAUtagMecroTextInfo@CKeyInfo@@@Z PROC ; std::_Dest_val<std::allocator<CKeyInfo::tagMecroTextInfo>,CKeyInfo::tagMecroTextInfo>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 287  : 	_Alval.destroy(_Pdest);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00006	83 c1 04	 add	 ecx, 4

; 288  : 	}

  00009	5d		 pop	 ebp

; 287  : 	_Alval.destroy(_Pdest);

  0000a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
??$_Dest_val@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@UtagMecroTextInfo@CKeyInfo@@@std@@YAXAAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@PAUtagMecroTextInfo@CKeyInfo@@@Z ENDP ; std::_Dest_val<std::allocator<CKeyInfo::tagMecroTextInfo>,CKeyInfo::tagMecroTextInfo>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@QAEXPAU?$pair@$$CBGVioHashString@@@2@$$QAU32@@Z ; std::allocator<std::pair<unsigned short const ,ioHashString> >::construct
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@QAEXPAU?$pair@$$CBGVioHashString@@@2@$$QAU32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@QAEXPAU?$pair@$$CBGVioHashString@@@2@$$QAU32@@Z$0
__ehfuncinfo$?construct@?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@QAEXPAU?$pair@$$CBGVioHashString@@@2@$$QAU32@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@QAEXPAU?$pair@$$CBGVioHashString@@@2@$$QAU32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@QAEXPAU?$pair@$$CBGVioHashString@@@2@$$QAU32@@Z
_TEXT	SEGMENT
$T519900 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@QAEXPAU?$pair@$$CBGVioHashString@@@2@$$QAU32@@Z PROC ; std::allocator<std::pair<unsigned short const ,ioHashString> >::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?construct@?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@QAEXPAU?$pair@$$CBGVioHashString@@@2@$$QAU32@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000f	89 4d f0	 mov	 DWORD PTR $T519900[ebp], ecx
  00012	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00016	85 c9		 test	 ecx, ecx
  00018	74 08		 je	 SHORT $LN3@construct@6
  0001a	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$?0$$CBGVioHashString@@@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAU01@@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><unsigned short const ,ioHashString>
$LN3@construct@6:

; 203  : 		}

  00022	e8 00 00 00 00	 call	 __EH_epilog3
  00027	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@QAEXPAU?$pair@$$CBGVioHashString@@@2@$$QAU32@@Z$0:
  00000	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00003	ff 75 f0	 push	 DWORD PTR $T519900[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000b	59		 pop	 ecx
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
__ehhandler$?construct@?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@QAEXPAU?$pair@$$CBGVioHashString@@@2@$$QAU32@@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@QAEXPAU?$pair@$$CBGVioHashString@@@2@$$QAU32@@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@QAEXPAU?$pair@$$CBGVioHashString@@@2@$$QAU32@@Z ENDP ; std::allocator<std::pair<unsigned short const ,ioHashString> >::construct
PUBLIC	??_7CJoyKeyInfo@@6B@				; CJoyKeyInfo::`vftable'
PUBLIC	??0CJoyKeyInfo@@QAE@XZ				; CJoyKeyInfo::CJoyKeyInfo
PUBLIC	??_R4CJoyKeyInfo@@6B@				; CJoyKeyInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCJoyKeyInfo@@@8				; CJoyKeyInfo `RTTI Type Descriptor'
PUBLIC	??_R3CJoyKeyInfo@@8				; CJoyKeyInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CJoyKeyInfo@@8				; CJoyKeyInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CJoyKeyInfo@@8			; CJoyKeyInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_ECJoyKeyInfo@@UAEPAXI@Z:PROC			; CJoyKeyInfo::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CJoyKeyInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CJoyKeyInfo@@8 DD FLAT:??_R0?AVCJoyKeyInfo@@@8 ; CJoyKeyInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CJoyKeyInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CJoyKeyInfo@@8
rdata$r	SEGMENT
??_R2CJoyKeyInfo@@8 DD FLAT:??_R1A@?0A@EA@CJoyKeyInfo@@8 ; CJoyKeyInfo::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CJoyKeyInfo@@8
rdata$r	SEGMENT
??_R3CJoyKeyInfo@@8 DD 00H				; CJoyKeyInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CJoyKeyInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCJoyKeyInfo@@@8
_DATA	SEGMENT
??_R0?AVCJoyKeyInfo@@@8 DD FLAT:??_7type_info@@6B@	; CJoyKeyInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCJoyKeyInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CJoyKeyInfo@@6B@
rdata$r	SEGMENT
??_R4CJoyKeyInfo@@6B@ DD 00H				; CJoyKeyInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCJoyKeyInfo@@@8
	DD	FLAT:??_R3CJoyKeyInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CJoyKeyInfo@@6B@
CONST	SEGMENT
??_7CJoyKeyInfo@@6B@ DD FLAT:??_R4CJoyKeyInfo@@6B@	; CJoyKeyInfo::`vftable'
	DD	FLAT:?SaveKey@CJoyKeyInfo@@UAEXXZ
	DD	FLAT:??_ECJoyKeyInfo@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CJoyKeyInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CJoyKeyInfo@@QAE@XZ$0
__ehfuncinfo$??0CJoyKeyInfo@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CJoyKeyInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iokeymanager.cpp
xdata$x	ENDS
;	COMDAT ??0CJoyKeyInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CJoyKeyInfo@@QAE@XZ PROC				; CJoyKeyInfo::CJoyKeyInfo, COMDAT
; _this$ = ecx

; 656  : {

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0CJoyKeyInfo@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00014	33 c0		 xor	 eax, eax
  00016	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CJoyKeyInfo@@6B@
  0001c	89 01		 mov	 DWORD PTR [ecx], eax
  0001e	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00021	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 657  : 	m_vKeyInfo.reserve(30);

  00024	6a 1e		 push	 30			; 0000001eH
  00026	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], eax
  00029	c6 46 14 01	 mov	 BYTE PTR [esi+20], 1
  0002d	e8 00 00 00 00	 call	 ?reserve@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::reserve

; 658  : }

  00032	8b c6		 mov	 eax, esi
  00034	e8 00 00 00 00	 call	 __EH_epilog3
  00039	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CJoyKeyInfo@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ ; std::vector<unsigned short,std::allocator<unsigned short> >::~vector<unsigned short,std::allocator<unsigned short> >
__ehhandler$??0CJoyKeyInfo@@QAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CJoyKeyInfo@@QAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CJoyKeyInfo@@QAE@XZ ENDP				; CJoyKeyInfo::CJoyKeyInfo
PUBLIC	?push_back@?$vector@GV?$allocator@G@std@@@std@@QAEX$$QAG@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::push_back
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?push_back@?$vector@GV?$allocator@G@std@@@std@@QAEX$$QAG@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@GV?$allocator@G@std@@@std@@QAEX$$QAG@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::push_back, COMDAT
; _this$ = ecx

; 631  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 632  : 		if (_Inside(_STD addressof(_Val)))

  00006	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 20		 jae	 SHORT $LN4@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 1a		 ja	 SHORT $LN4@push_back

; 633  : 			{	// push back an element
; 634  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	d1 ff		 sar	 edi, 1

; 635  : 			if (this->_Mylast == this->_Myend)

  0001b	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001e	75 09		 jne	 SHORT $LN3@push_back

; 636  : 				_Reserve(1);

  00020	6a 01		 push	 1
  00022	8b ce		 mov	 ecx, esi
  00024	e8 00 00 00 00	 call	 ?_Reserve@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Reserve
$LN3@push_back:

; 637  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 638  : 			_Cons_val(this->_Alval,
; 639  : 				this->_Mylast,
; 640  : 				_STD forward<_Ty>(this->_Myfirst[_Idx]));

  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	8d 04 78	 lea	 eax, DWORD PTR [eax+edi*2]
  0002e	50		 push	 eax

; 641  : 			++this->_Mylast;
; 642  : 			}
; 643  : 		else

  0002f	eb 0f		 jmp	 SHORT $LN24@push_back
$LN4@push_back:

; 644  : 			{	// push back a non-element
; 645  : 			if (this->_Mylast == this->_Myend)

  00031	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00034	75 09		 jne	 SHORT $LN1@push_back

; 646  : 				_Reserve(1);

  00036	6a 01		 push	 1
  00038	8b ce		 mov	 ecx, esi
  0003a	e8 00 00 00 00	 call	 ?_Reserve@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Reserve
$LN1@push_back:

; 647  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 648  : 			_Cons_val(this->_Alval,
; 649  : 				this->_Mylast,
; 650  : 				_STD forward<_Ty>(_Val));

  0003f	57		 push	 edi
$LN24@push_back:
  00040	ff 76 04	 push	 DWORD PTR [esi+4]
  00043	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@G@std@@GG@std@@YAXAAV?$allocator@G@0@PAG$$QAG@Z ; std::_Cons_val<std::allocator<unsigned short>,unsigned short,unsigned short>
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 651  : 			++this->_Mylast;

  0004f	83 46 04 02	 add	 DWORD PTR [esi+4], 2
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi

; 652  : 			}
; 653  : 		}

  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
?push_back@?$vector@GV?$allocator@G@std@@@std@@QAEX$$QAG@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$vector@GV?$allocator@G@std@@@std@@QAEXABG@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::push_back
; Function compile flags: /Ogsp
;	COMDAT ?push_back@?$vector@GV?$allocator@G@std@@@std@@QAEXABG@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@GV?$allocator@G@std@@@std@@QAEXABG@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  00006	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 2c		 jae	 SHORT $LN4@push_back@2
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 26		 ja	 SHORT $LN4@push_back@2

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	d1 ff		 sar	 edi, 1

; 980  : 			if (this->_Mylast == this->_Myend)

  0001b	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001e	75 09		 jne	 SHORT $LN3@push_back@2

; 981  : 				_Reserve(1);

  00020	6a 01		 push	 1
  00022	8b ce		 mov	 ecx, esi
  00024	e8 00 00 00 00	 call	 ?_Reserve@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Reserve
$LN3@push_back@2:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	8d 04 78	 lea	 eax, DWORD PTR [eax+edi*2]
  0002e	50		 push	 eax
  0002f	ff 76 04	 push	 DWORD PTR [esi+4]
  00032	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@G@std@@GAAG@std@@YAXAAV?$allocator@G@0@PAGAAG@Z ; std::_Cons_val<std::allocator<unsigned short>,unsigned short,unsigned short &>

; 986  : 			++this->_Mylast;
; 987  : 			}
; 988  : 		else

  0003b	eb 1b		 jmp	 SHORT $LN20@push_back@2
$LN4@push_back@2:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  0003d	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00040	75 09		 jne	 SHORT $LN1@push_back@2

; 991  : 				_Reserve(1);

  00042	6a 01		 push	 1
  00044	8b ce		 mov	 ecx, esi
  00046	e8 00 00 00 00	 call	 ?_Reserve@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Reserve
$LN1@push_back@2:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  0004b	57		 push	 edi
  0004c	ff 76 04	 push	 DWORD PTR [esi+4]
  0004f	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@G@std@@GABG@std@@YAXAAV?$allocator@G@0@PAGABG@Z ; std::_Cons_val<std::allocator<unsigned short>,unsigned short,unsigned short const &>
$LN20@push_back@2:
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  0005b	83 46 04 02	 add	 DWORD PTR [esi+4], 2
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
?push_back@?$vector@GV?$allocator@G@std@@@std@@QAEXABG@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::push_back
_TEXT	ENDS
PUBLIC	?clear@?$vector@GV?$allocator@G@std@@@std@@QAEXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::clear
; Function compile flags: /Ogsp
;	COMDAT ?clear@?$vector@GV?$allocator@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T520008 = -4						; size = 4
?clear@?$vector@GV?$allocator@G@std@@@std@@QAEXXZ PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1218 : 		erase(begin(), end());

  00004	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00007	8b 11		 mov	 edx, DWORD PTR [ecx]
  00009	50		 push	 eax
  0000a	52		 push	 edx
  0000b	8d 45 fc	 lea	 eax, DWORD PTR $T520008[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?erase@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@0@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::erase

; 1219 : 		}

  00014	c9		 leave
  00015	c3		 ret	 0
?clear@?$vector@GV?$allocator@G@std@@@std@@QAEXXZ ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::clear
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@ABG@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::find
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@ABG@Z
_TEXT	SEGMENT
$T520064 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@ABG@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::find, COMDAT
; _this$ = ecx

; 1423 : 		{	// find an element in mutable sequence that matches _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1424 : 		iterator _Where = lower_bound(_Keyval);

  00006	8b 7d 0c	 mov	 edi, DWORD PTR __Keyval$[ebp]
  00009	57		 push	 edi
  0000a	8b f1		 mov	 esi, ecx
  0000c	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@ABG@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Lbound

; 1425 : 		return (_Where == end()
; 1426 : 			|| _DEBUG_LT_PRED(this->comp,
; 1427 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1428 : 					? end() : _Where);

  00011	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  00014	89 45 0c	 mov	 DWORD PTR __Where$[ebp], eax
  00017	3b c6		 cmp	 eax, esi
  00019	74 0e		 je	 SHORT $LN3@find
  0001b	66 8b 0f	 mov	 cx, WORD PTR [edi]
  0001e	66 3b 48 0c	 cmp	 cx, WORD PTR [eax+12]
  00022	72 05		 jb	 SHORT $LN3@find
  00024	8d 45 0c	 lea	 eax, DWORD PTR __Where$[ebp]
  00027	eb 06		 jmp	 SHORT $LN4@find
$LN3@find:
  00029	89 75 fc	 mov	 DWORD PTR $T520064[ebp], esi
  0002c	8d 45 fc	 lea	 eax, DWORD PTR $T520064[ebp]
$LN4@find:
  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00031	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00034	5f		 pop	 edi
  00035	89 08		 mov	 DWORD PTR [eax], ecx
  00037	5e		 pop	 esi

; 1429 : 		}

  00038	c9		 leave
  00039	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@ABG@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::find
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@U?$pair@$$CBGVioHashString@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBGVioHashString@@@std@@@0@PAU?$pair@$$CBGVioHashString@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned short const ,ioHashString> >,std::pair<unsigned short const ,ioHashString> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@U?$pair@$$CBGVioHashString@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBGVioHashString@@@std@@@0@PAU?$pair@$$CBGVioHashString@@@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@U?$pair@$$CBGVioHashString@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBGVioHashString@@@std@@@0@PAU?$pair@$$CBGVioHashString@@@0@@Z PROC ; std::_Dest_val<std::allocator<std::pair<unsigned short const ,ioHashString> >,std::pair<unsigned short const ,ioHashString> >, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 287  : 	_Alval.destroy(_Pdest);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00006	83 c1 04	 add	 ecx, 4

; 288  : 	}

  00009	5d		 pop	 ebp

; 287  : 	_Alval.destroy(_Pdest);

  0000a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
??$_Dest_val@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@U?$pair@$$CBGVioHashString@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBGVioHashString@@@std@@@0@PAU?$pair@$$CBGVioHashString@@@0@@Z ENDP ; std::_Dest_val<std::allocator<std::pair<unsigned short const ,ioHashString> >,std::pair<unsigned short const ,ioHashString> >
_TEXT	ENDS
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Insert
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
CONST	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Newnode$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@1@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1631 : 		{	// add node with value next to _Wherenode, to left if _Addleft

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 1632 : 		if (max_size() - 1 <= this->_Mysize)

  00008	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0000b	3d cb cc cc 0c	 cmp	 eax, 214748363		; 0ccccccbH
  00010	72 1f		 jb	 SHORT $LN17@Insert

; 1633 : 			{	// tree would get too big, fail
; 1634 : 			_Dest_val(this->_Alval,
; 1635 : 				_STD addressof(this->_Myval(_Newnode)));

  00012	8b 75 14	 mov	 esi, DWORD PTR __Newnode$[ebp]
  00015	8d 4e 10	 lea	 ecx, DWORD PTR [esi+16]
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ

; 1636 : 
; 1637 : 			this->_Alnod.deallocate(_Newnode, 1);

  0001e	56		 push	 esi
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1638 : 
; 1639 : 			_Xlength_error("map/set<T> too long");

  00024	c7 04 24 00 00
	00 00		 mov	 DWORD PTR [esp], OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN197@Insert:
$LN17@Insert:

; 1640 : 			}
; 1641 : 		++this->_Mysize;
; 1642 : 		_Newnode->_Parent = _Wherenode;

  00031	8b 5d 14	 mov	 ebx, DWORD PTR __Newnode$[ebp]
  00034	40		 inc	 eax
  00035	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00038	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0003b	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 1643 : 
; 1644 : 		if (_Wherenode == this->_Myhead)

  0003e	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00041	3b c1		 cmp	 eax, ecx
  00043	75 10		 jne	 SHORT $LN16@Insert

; 1645 : 			{	// first node in tree, just set head values
; 1646 : 			_Root() = _Newnode;

  00045	89 59 04	 mov	 DWORD PTR [ecx+4], ebx

; 1647 : 			_Lmost() = _Newnode;

  00048	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0004b	89 18		 mov	 DWORD PTR [eax], ebx

; 1648 : 			_Rmost() = _Newnode;

  0004d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00050	89 58 08	 mov	 DWORD PTR [eax+8], ebx
  00053	eb 21		 jmp	 SHORT $LN11@Insert
$LN16@Insert:

; 1649 : 			}
; 1650 : 		else if (_Addleft)

  00055	80 7d 0c 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  00059	74 0d		 je	 SHORT $LN14@Insert

; 1651 : 			{	// add to left of _Wherenode
; 1652 : 			this->_Left(_Wherenode) = _Newnode;

  0005b	89 18		 mov	 DWORD PTR [eax], ebx

; 1653 : 			if (_Wherenode == _Lmost())

  0005d	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00060	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00062	75 12		 jne	 SHORT $LN11@Insert

; 1654 : 				_Lmost() = _Newnode;

  00064	89 19		 mov	 DWORD PTR [ecx], ebx

; 1655 : 			}
; 1656 : 		else

  00066	eb 0e		 jmp	 SHORT $LN11@Insert
$LN14@Insert:

; 1657 : 			{	// add to right of _Wherenode
; 1658 : 			this->_Right(_Wherenode) = _Newnode;

  00068	89 58 08	 mov	 DWORD PTR [eax+8], ebx

; 1659 : 			if (_Wherenode == _Rmost())

  0006b	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0006e	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00071	75 03		 jne	 SHORT $LN11@Insert

; 1660 : 				_Rmost() = _Newnode;

  00073	89 59 08	 mov	 DWORD PTR [ecx+8], ebx
$LN11@Insert:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;
; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00076	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00079	8b f3		 mov	 esi, ebx
  0007b	e9 93 00 00 00	 jmp	 $LN195@Insert
$LL10@Insert:

; 1665 : 			if (this->_Parent(_Pnode)
; 1666 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  00080	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00083	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00086	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00088	75 38		 jne	 SHORT $LN8@Insert

; 1667 : 				{	// fixup red-red in left subtree
; 1668 : 				_Wherenode =
; 1669 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));

  0008a	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 1670 : 				if (this->_Color(_Wherenode) == this->_Red)

  0008d	80 79 20 00	 cmp	 BYTE PTR [ecx+32], 0

; 1671 : 					{	// parent has two red children, blacken both
; 1672 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1673 : 					this->_Color(_Wherenode) = this->_Black;
; 1674 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1675 : 						= this->_Red;
; 1676 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1677 : 					}
; 1678 : 				else

  00091	74 37		 je	 SHORT $LN196@Insert

; 1679 : 					{	// parent has red and black children
; 1680 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  00093	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00096	75 0a		 jne	 SHORT $LN5@Insert

; 1681 : 						{	// rotate right child to left
; 1682 : 						_Pnode = this->_Parent(_Pnode);

  00098	8b f0		 mov	 esi, eax

; 1683 : 						_Lrotate(_Pnode);

  0009a	56		 push	 esi
  0009b	8b cf		 mov	 ecx, edi
  0009d	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Lrotate
$LN5@Insert:

; 1684 : 						}
; 1685 : 					this->_Color(this->_Parent(_Pnode)) =
; 1686 : 						this->_Black;	// propagate red up

  000a2	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000a5	c6 40 20 01	 mov	 BYTE PTR [eax+32], 1

; 1687 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1688 : 						this->_Red;

  000a9	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000ac	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000af	c6 40 20 00	 mov	 BYTE PTR [eax+32], 0

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  000b3	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000b6	ff 70 04	 push	 DWORD PTR [eax+4]
  000b9	8b cf		 mov	 ecx, edi
  000bb	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Rrotate

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  000c0	eb 4e		 jmp	 SHORT $LN2@Insert
$LN8@Insert:

; 1693 : 				{	// fixup red-red in right subtree
; 1694 : 				_Wherenode =
; 1695 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));

  000c2	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 1696 : 				if (this->_Color(_Wherenode) == this->_Red)

  000c4	80 79 20 00	 cmp	 BYTE PTR [ecx+32], 0
  000c8	75 1a		 jne	 SHORT $LN3@Insert
$LN196@Insert:

; 1697 : 					{	// parent has two red children, blacken both
; 1698 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  000ca	c6 40 20 01	 mov	 BYTE PTR [eax+32], 1

; 1699 : 					this->_Color(_Wherenode) = this->_Black;

  000ce	c6 41 20 01	 mov	 BYTE PTR [ecx+32], 1

; 1700 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1701 : 						this->_Red;

  000d2	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000d5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000d8	c6 40 20 00	 mov	 BYTE PTR [eax+32], 0

; 1702 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  000dc	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000df	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 1703 : 					}
; 1704 : 				else

  000e2	eb 2c		 jmp	 SHORT $LN2@Insert
$LN3@Insert:

; 1705 : 					{	// parent has red and black children
; 1706 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  000e4	3b 30		 cmp	 esi, DWORD PTR [eax]
  000e6	75 0a		 jne	 SHORT $LN1@Insert

; 1707 : 						{	// rotate left child to right
; 1708 : 						_Pnode = this->_Parent(_Pnode);

  000e8	8b f0		 mov	 esi, eax

; 1709 : 						_Rrotate(_Pnode);

  000ea	56		 push	 esi
  000eb	8b cf		 mov	 ecx, edi
  000ed	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Rrotate
$LN1@Insert:

; 1710 : 						}
; 1711 : 					this->_Color(this->_Parent(_Pnode)) =
; 1712 : 						this->_Black;	// propagate red up

  000f2	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000f5	c6 40 20 01	 mov	 BYTE PTR [eax+32], 1

; 1713 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1714 : 						this->_Red;

  000f9	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000fc	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000ff	c6 40 20 00	 mov	 BYTE PTR [eax+32], 0

; 1715 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  00103	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00106	ff 70 04	 push	 DWORD PTR [eax+4]
  00109	8b cf		 mov	 ecx, edi
  0010b	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Lrotate
$LN2@Insert:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;
; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00110	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
$LN195@Insert:
  00113	80 78 20 00	 cmp	 BYTE PTR [eax+32], 0
  00117	0f 84 63 ff ff
	ff		 je	 $LL10@Insert

; 1716 : 					}
; 1717 : 				}
; 1718 : 
; 1719 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  0011d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00120	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00123	5f		 pop	 edi
  00124	c6 40 20 01	 mov	 BYTE PTR [eax+32], 1

; 1720 : 		return (iterator(_Newnode, this));

  00128	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0012b	5e		 pop	 esi
  0012c	89 18		 mov	 DWORD PTR [eax], ebx
  0012e	5b		 pop	 ebx

; 1721 : 		}

  0012f	5d		 pop	 ebp
  00130	c2 10 00	 ret	 16			; 00000010H
$LN194@Insert:
?_Insert@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@1@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Insert
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@0AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CKeyInfo::tagMecroTextInfo> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@0AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@0AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CKeyInfo::tagMecroTextInfo> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 96   : 	for (; _First != _Last; ++_First)

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	eb 0c		 jmp	 SHORT $LN20@Destroy_ra
$LL3@Destroy_ra:

; 97   : 		_Dest_val(_Al, _First);

  00009	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00012	83 c6 14	 add	 esi, 20			; 00000014H
$LN20@Destroy_ra:

; 96   : 	for (; _First != _Last; ++_First)

  00015	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00018	75 ef		 jne	 SHORT $LL3@Destroy_ra
  0001a	5e		 pop	 esi

; 98   : 	}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$_Destroy_range@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@0AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CKeyInfo::tagMecroTextInfo> >
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@U?$pair@$$CBGVioHashString@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBGVioHashString@@@std@@@0@PAU?$pair@$$CBGVioHashString@@@0@$$QAU20@@Z ; std::_Cons_val<std::allocator<std::pair<unsigned short const ,ioHashString> >,std::pair<unsigned short const ,ioHashString>,std::pair<unsigned short const ,ioHashString> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??$_Cons_val@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@U?$pair@$$CBGVioHashString@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBGVioHashString@@@std@@@0@PAU?$pair@$$CBGVioHashString@@@0@$$QAU20@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Cons_val@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@U?$pair@$$CBGVioHashString@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBGVioHashString@@@std@@@0@PAU?$pair@$$CBGVioHashString@@@0@$$QAU20@@Z$0
__ehfuncinfo$??$_Cons_val@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@U?$pair@$$CBGVioHashString@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBGVioHashString@@@std@@@0@PAU?$pair@$$CBGVioHashString@@@0@$$QAU20@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Cons_val@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@U?$pair@$$CBGVioHashString@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBGVioHashString@@@std@@@0@PAU?$pair@$$CBGVioHashString@@@0@$$QAU20@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@U?$pair@$$CBGVioHashString@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBGVioHashString@@@std@@@0@PAU?$pair@$$CBGVioHashString@@@0@$$QAU20@@Z
_TEXT	SEGMENT
$T520643 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@U?$pair@$$CBGVioHashString@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBGVioHashString@@@std@@@0@PAU?$pair@$$CBGVioHashString@@@0@$$QAU20@@Z PROC ; std::_Cons_val<std::allocator<std::pair<unsigned short const ,ioHashString> >,std::pair<unsigned short const ,ioHashString>,std::pair<unsigned short const ,ioHashString> >, COMDAT

; 279  : 	{	// construct using allocator

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??$_Cons_val@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@U?$pair@$$CBGVioHashString@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBGVioHashString@@@std@@@0@PAU?$pair@$$CBGVioHashString@@@0@$$QAU20@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  0000f	89 4d f0	 mov	 DWORD PTR $T520643[ebp], ecx
  00012	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00016	85 c9		 test	 ecx, ecx
  00018	74 08		 je	 SHORT $LN7@Cons_val@4
  0001a	ff 75 10	 push	 DWORD PTR __Src$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$?0$$CBGVioHashString@@@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAU01@@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><unsigned short const ,ioHashString>
$LN7@Cons_val@4:

; 281  : 	}

  00022	e8 00 00 00 00	 call	 __EH_epilog3
  00027	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Cons_val@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@U?$pair@$$CBGVioHashString@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBGVioHashString@@@std@@@0@PAU?$pair@$$CBGVioHashString@@@0@$$QAU20@@Z$0:
  00000	ff 75 0c	 push	 DWORD PTR __Pdest$[ebp]
  00003	ff 75 f0	 push	 DWORD PTR $T520643[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000b	59		 pop	 ecx
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
__ehhandler$??$_Cons_val@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@U?$pair@$$CBGVioHashString@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBGVioHashString@@@std@@@0@PAU?$pair@$$CBGVioHashString@@@0@$$QAU20@@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Cons_val@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@U?$pair@$$CBGVioHashString@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBGVioHashString@@@std@@@0@PAU?$pair@$$CBGVioHashString@@@0@$$QAU20@@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Cons_val@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@U?$pair@$$CBGVioHashString@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBGVioHashString@@@std@@@0@PAU?$pair@$$CBGVioHashString@@@0@$$QAU20@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<unsigned short const ,ioHashString> >,std::pair<unsigned short const ,ioHashString>,std::pair<unsigned short const ,ioHashString> >
PUBLIC	??$_Uninit_move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@U12@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CKeyInfo::tagMecroTextInfo *,CKeyInfo::tagMecroTextInfo *,std::allocator<CKeyInfo::tagMecroTextInfo>,CKeyInfo::tagMecroTextInfo>
EXTRN	__EH_prolog3_catch:PROC
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iokeymanager.cpp
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@U12@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@U12@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@U12@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@U12@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@U12@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$3
__ehfuncinfo$??$_Uninit_move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@U12@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@U12@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@U12@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@U12@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@U12@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CKeyInfo::tagMecroTextInfo *,CKeyInfo::tagMecroTextInfo *,std::allocator<CKeyInfo::tagMecroTextInfo>,CKeyInfo::tagMecroTextInfo>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	6a 08		 push	 8
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??$_Uninit_move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@U12@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_catch

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0000c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 428  : 
; 429  : 	_TRY_BEGIN

  0000f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
  00013	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00016	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LL6@Uninit_mov:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  00019	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001c	74 34		 je	 SHORT $LN4@Uninit_mov

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  0001e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00021	56		 push	 esi
  00022	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00025	e8 00 00 00 00	 call	 ?construct@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@$$QAU34@@Z ; std::allocator<CKeyInfo::tagMecroTextInfo>::construct
  0002a	83 45 10 14	 add	 DWORD PTR __Dest$[ebp], 20 ; 00000014H
  0002e	83 c6 14	 add	 esi, 20			; 00000014H
  00031	eb e6		 jmp	 SHORT $LL6@Uninit_mov
__catch$??$_Uninit_move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@U12@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)

  00033	8b 75 ec	 mov	 esi, DWORD PTR __Next$[ebp]
  00036	eb 0c		 jmp	 SHORT $LN36@Uninit_mov
$LL3@Uninit_mov:

; 434  : 		_Dest_val(_Al, _Next);

  00038	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00041	83 c6 14	 add	 esi, 20			; 00000014H
$LN36@Uninit_mov:

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)

  00044	3b 75 10	 cmp	 esi, DWORD PTR __Dest$[ebp]
  00047	75 ef		 jne	 SHORT $LL3@Uninit_mov

; 435  : 	_RERAISE;

  00049	6a 00		 push	 0
  0004b	6a 00		 push	 0
  0004d	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN37@Uninit_mov:
$LN4@Uninit_mov:

; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  00052	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 438  : 	}

  00055	e8 00 00 00 00	 call	 __EH_epilog3
  0005a	c3		 ret	 0
$LN35@Uninit_mov:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@U12@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@U12@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@U12@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CKeyInfo::tagMecroTextInfo *,CKeyInfo::tagMecroTextInfo *,std::allocator<CKeyInfo::tagMecroTextInfo>,CKeyInfo::tagMecroTextInfo>
PUBLIC	??1CJoyKeyInfo@@UAE@XZ				; CJoyKeyInfo::~CJoyKeyInfo
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iokeymanager.cpp
;	COMDAT ??1CJoyKeyInfo@@UAE@XZ
_TEXT	SEGMENT
$T520791 = -4						; size = 4
??1CJoyKeyInfo@@UAE@XZ PROC				; CJoyKeyInfo::~CJoyKeyInfo, COMDAT
; _this$ = ecx

; 661  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 662  : 	m_vKeyInfo.clear();

  00005	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  00008	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CJoyKeyInfo@@6B@
  0000e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	50		 push	 eax
  00014	51		 push	 ecx
  00015	8d 45 fc	 lea	 eax, DWORD PTR $T520791[ebp]
  00018	50		 push	 eax
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?erase@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@0@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::erase

; 663  : }

  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?_Tidy@?$vector@GV?$allocator@G@std@@@std@@IAEXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Tidy
  00027	5e		 pop	 esi
  00028	c9		 leave
  00029	c3		 ret	 0
??1CJoyKeyInfo@@UAE@XZ ENDP				; CJoyKeyInfo::~CJoyKeyInfo
_TEXT	ENDS
PUBLIC	?Clear@CJoyKeyInfo@@QAEXXZ			; CJoyKeyInfo::Clear
; Function compile flags: /Ogsp
;	COMDAT ?Clear@CJoyKeyInfo@@QAEXXZ
_TEXT	SEGMENT
$T520881 = -4						; size = 4
?Clear@CJoyKeyInfo@@QAEXXZ PROC				; CJoyKeyInfo::Clear, COMDAT
; _this$ = ecx

; 666  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 667  : 	m_vKeyInfo.clear();

  00007	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0000a	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	50		 push	 eax
  00010	52		 push	 edx
  00011	8d 45 fc	 lea	 eax, DWORD PTR $T520881[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?erase@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@0@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::erase

; 668  : 	m_bUse = false;

  0001a	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  0001e	5e		 pop	 esi

; 669  : }

  0001f	c9		 leave
  00020	c3		 ret	 0
?Clear@CJoyKeyInfo@@QAEXXZ ENDP				; CJoyKeyInfo::Clear
_TEXT	ENDS
PUBLIC	?Load@CJoyKeyInfo@@QAEXXZ			; CJoyKeyInfo::Load
; Function compile flags: /Ogsp
;	COMDAT ?Load@CJoyKeyInfo@@QAEXXZ
_TEXT	SEGMENT
$T520902 = -4						; size = 2
?Load@CJoyKeyInfo@@QAEXXZ PROC				; CJoyKeyInfo::Load, COMDAT
; _this$ = ecx

; 828  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 829  : 	for (int i = 0; i < JTA_MAX ; i++)

  00007	6a 2f		 push	 47			; 0000002fH
  00009	8b f1		 mov	 esi, ecx
  0000b	5b		 pop	 ebx
$LL3@Load:

; 830  : 	{
; 831  : 		m_vKeyInfo.push_back( 0 );

  0000c	83 65 fc 00	 and	 DWORD PTR $T520902[ebp], 0
  00010	8d 45 fc	 lea	 eax, DWORD PTR $T520902[ebp]
  00013	50		 push	 eax
  00014	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00017	e8 00 00 00 00	 call	 ?push_back@?$vector@GV?$allocator@G@std@@@std@@QAEX$$QAG@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::push_back
  0001c	4b		 dec	 ebx
  0001d	75 ed		 jne	 SHORT $LL3@Load

; 832  : 	}
; 833  : 
; 834  : 	m_bUse = false;

  0001f	5f		 pop	 edi
  00020	88 5e 14	 mov	 BYTE PTR [esi+20], bl
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx

; 835  : }

  00025	c9		 leave
  00026	c3		 ret	 0
?Load@CJoyKeyInfo@@QAEXXZ ENDP				; CJoyKeyInfo::Load
_TEXT	ENDS
PUBLIC	??_7CDefaultJoyKeyInfo@@6B@			; CDefaultJoyKeyInfo::`vftable'
PUBLIC	??0CDefaultJoyKeyInfo@@QAE@XZ			; CDefaultJoyKeyInfo::CDefaultJoyKeyInfo
PUBLIC	??_R4CDefaultJoyKeyInfo@@6B@			; CDefaultJoyKeyInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCDefaultJoyKeyInfo@@@8			; CDefaultJoyKeyInfo `RTTI Type Descriptor'
PUBLIC	??_R3CDefaultJoyKeyInfo@@8			; CDefaultJoyKeyInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDefaultJoyKeyInfo@@8			; CDefaultJoyKeyInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CDefaultJoyKeyInfo@@8		; CDefaultJoyKeyInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Load@CDefaultJoyKeyInfo@@UAEXXZ		; CDefaultJoyKeyInfo::Load
EXTRN	??_ECDefaultJoyKeyInfo@@UAEPAXI@Z:PROC		; CDefaultJoyKeyInfo::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CDefaultJoyKeyInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CDefaultJoyKeyInfo@@8 DD FLAT:??_R0?AVCDefaultJoyKeyInfo@@@8 ; CDefaultJoyKeyInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CDefaultJoyKeyInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CDefaultJoyKeyInfo@@8
rdata$r	SEGMENT
??_R2CDefaultJoyKeyInfo@@8 DD FLAT:??_R1A@?0A@EA@CDefaultJoyKeyInfo@@8 ; CDefaultJoyKeyInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CJoyKeyInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CDefaultJoyKeyInfo@@8
rdata$r	SEGMENT
??_R3CDefaultJoyKeyInfo@@8 DD 00H			; CDefaultJoyKeyInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CDefaultJoyKeyInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDefaultJoyKeyInfo@@@8
_DATA	SEGMENT
??_R0?AVCDefaultJoyKeyInfo@@@8 DD FLAT:??_7type_info@@6B@ ; CDefaultJoyKeyInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDefaultJoyKeyInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CDefaultJoyKeyInfo@@6B@
rdata$r	SEGMENT
??_R4CDefaultJoyKeyInfo@@6B@ DD 00H			; CDefaultJoyKeyInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCDefaultJoyKeyInfo@@@8
	DD	FLAT:??_R3CDefaultJoyKeyInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CDefaultJoyKeyInfo@@6B@
CONST	SEGMENT
??_7CDefaultJoyKeyInfo@@6B@ DD FLAT:??_R4CDefaultJoyKeyInfo@@6B@ ; CDefaultJoyKeyInfo::`vftable'
	DD	FLAT:?SaveKey@CJoyKeyInfo@@UAEXXZ
	DD	FLAT:??_ECDefaultJoyKeyInfo@@UAEPAXI@Z
	DD	FLAT:?Load@CDefaultJoyKeyInfo@@UAEXXZ
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??0CDefaultJoyKeyInfo@@QAE@XZ
_TEXT	SEGMENT
??0CDefaultJoyKeyInfo@@QAE@XZ PROC			; CDefaultJoyKeyInfo::CDefaultJoyKeyInfo, COMDAT
; _this$ = ecx

; 856  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??0CJoyKeyInfo@@QAE@XZ	; CJoyKeyInfo::CJoyKeyInfo
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CDefaultJoyKeyInfo@@6B@

; 857  : 
; 858  : }

  0000e	8b c6		 mov	 eax, esi
  00010	5e		 pop	 esi
  00011	c3		 ret	 0
??0CDefaultJoyKeyInfo@@QAE@XZ ENDP			; CDefaultJoyKeyInfo::CDefaultJoyKeyInfo
_TEXT	ENDS
PUBLIC	??1CDefaultJoyKeyInfo@@UAE@XZ			; CDefaultJoyKeyInfo::~CDefaultJoyKeyInfo
; Function compile flags: /Ogsp
;	COMDAT ??1CDefaultJoyKeyInfo@@UAE@XZ
_TEXT	SEGMENT
??1CDefaultJoyKeyInfo@@UAE@XZ PROC			; CDefaultJoyKeyInfo::~CDefaultJoyKeyInfo, COMDAT
; _this$ = ecx

; 861  : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CDefaultJoyKeyInfo@@6B@

; 862  : }

  00006	e9 00 00 00 00	 jmp	 ??1CJoyKeyInfo@@UAE@XZ	; CJoyKeyInfo::~CJoyKeyInfo
??1CDefaultJoyKeyInfo@@UAE@XZ ENDP			; CDefaultJoyKeyInfo::~CDefaultJoyKeyInfo
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Load@CDefaultJoyKeyInfo@@UAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Load@CDefaultJoyKeyInfo@@UAEXXZ$0
__ehfuncinfo$?Load@CDefaultJoyKeyInfo@@UAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Load@CDefaultJoyKeyInfo@@UAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ?Load@CDefaultJoyKeyInfo@@UAEXXZ
_TEXT	SEGMENT
_wKey$507360 = -936					; size = 2
$T520979 = -936						; size = 4
_i$507356 = -932					; size = 4
_kLoader$ = -928					; size = 912
__$EHRec$ = -12						; size = 12
?Load@CDefaultJoyKeyInfo@@UAEXXZ PROC			; CDefaultJoyKeyInfo::Load, COMDAT
; _this$ = ecx

; 865  : {

  00000	68 9c 03 00 00	 push	 924			; 0000039cH
  00005	b8 00 00 00 00	 mov	 eax, __ehhandler$?Load@CDefaultJoyKeyInfo@@UAEXXZ
  0000a	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000f	8b f9		 mov	 edi, ecx

; 866  : 	m_vKeyInfo.clear();

  00011	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00014	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00017	50		 push	 eax
  00018	51		 push	 ecx
  00019	8d 85 58 fc ff
	ff		 lea	 eax, DWORD PTR $T520979[ebp]
  0001f	50		 push	 eax
  00020	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00023	e8 00 00 00 00	 call	 ?erase@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@0@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::erase

; 867  : 
; 868  : 	ioINILoader_e kLoader( "config/sp2_default_joykey.ini" );

  00028	6a 07		 push	 7
  0002a	c7 45 b0 8e 83
	85 8c		 mov	 DWORD PTR _kLoader$[ebp+848], -1937407090 ; 8c85838eH
  00031	c7 45 b4 84 8b
	c4 99		 mov	 DWORD PTR _kLoader$[ebp+852], -1715172476 ; 99c48b84H
  00038	c7 45 b8 9d de
	b4 8e		 mov	 DWORD PTR _kLoader$[ebp+856], -1900749155 ; 8eb4de9dH
  0003f	c7 45 bc 88 8a
	8a 9f		 mov	 DWORD PTR _kLoader$[ebp+860], -1618310520 ; 9f8a8a88H
  00046	c7 45 c0 81 98
	b4 80		 mov	 DWORD PTR _kLoader$[ebp+864], -2135648127 ; 80b49881H
  0004d	c7 45 c4 82 95
	80 8f		 mov	 DWORD PTR _kLoader$[ebp+868], -1887398526 ; 8f809582H
  00054	c7 45 c8 94 c2
	82 84		 mov	 DWORD PTR _kLoader$[ebp+872], -2071805292 ; 8482c294H
  0005b	8d 45 b0	 lea	 eax, DWORD PTR _kLoader$[ebp+848]
  0005e	66 c7 45 cc 84
	00		 mov	 WORD PTR _kLoader$[ebp+876], 132 ; 00000084H
  00064	59		 pop	 ecx
$LL131@Load@2:
  00065	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0006b	83 c0 04	 add	 eax, 4
  0006e	49		 dec	 ecx
  0006f	75 f4		 jne	 SHORT $LL131@Load@2
  00071	80 75 cc ed	 xor	 BYTE PTR _kLoader$[ebp+876], -19 ; ffffffedH
  00075	6a 01		 push	 1
  00077	8d 45 b0	 lea	 eax, DWORD PTR _kLoader$[ebp+848]
  0007a	50		 push	 eax
  0007b	8d 8d 60 fc ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioINILoader@@QAE@PBD_N@Z
  00087	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 869  : 	kLoader.SetTitle( "Key" );

  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_03CCEPDEKL@Key?$AA@
  00090	8d 8d 60 fc ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z

; 870  : 	for (int i = 0; i < JTA_MAX ; i++)

  0009c	83 a5 5c fc ff
	ff 00		 and	 DWORD PTR _i$507356[ebp], 0
$LN3@Load@2:

; 871  : 	{
; 872  : 		WORD wKey = kLoader.LoadInt(GetINIKeyName((KeyTypeArray)i), 0);

  000a3	6a 00		 push	 0
  000a5	ff b5 5c fc ff
	ff		 push	 DWORD PTR _i$507356[ebp]
  000ab	8b cf		 mov	 ecx, edi
  000ad	e8 00 00 00 00	 call	 ?GetINIKeyName@CJoyKeyInfo@@IAEPADW4KeyTypeArray@1@@Z ; CJoyKeyInfo::GetINIKeyName
  000b2	50		 push	 eax
  000b3	8d 8d 60 fc ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  000b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  000bf	0f b7 c0	 movzx	 eax, ax
  000c2	89 85 58 fc ff
	ff		 mov	 DWORD PTR _wKey$507360[ebp], eax

; 873  : 		m_vKeyInfo.push_back(wKey);

  000c8	8d 85 58 fc ff
	ff		 lea	 eax, DWORD PTR _wKey$507360[ebp]
  000ce	50		 push	 eax
  000cf	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  000d2	e8 00 00 00 00	 call	 ?push_back@?$vector@GV?$allocator@G@std@@@std@@QAEXABG@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::push_back
  000d7	ff 85 5c fc ff
	ff		 inc	 DWORD PTR _i$507356[ebp]
  000dd	83 bd 5c fc ff
	ff 2f		 cmp	 DWORD PTR _i$507356[ebp], 47 ; 0000002fH
  000e4	7c bd		 jl	 SHORT $LN3@Load@2

; 874  : 	}
; 875  : }

  000e6	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000ea	8d 8d 60 fc ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  000f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioINILoader@@QAE@XZ
  000f6	e8 00 00 00 00	 call	 __EH_epilog3_GS
  000fb	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Load@CDefaultJoyKeyInfo@@UAEXXZ$0:
  00000	8d 8d 60 fc ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1ioINILoader_e@@QAE@XZ
__ehhandler$?Load@CDefaultJoyKeyInfo@@UAEXXZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 54 fc ff
	ff		 mov	 ecx, DWORD PTR [edx-940]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Load@CDefaultJoyKeyInfo@@UAEXXZ
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Load@CDefaultJoyKeyInfo@@UAEXXZ ENDP			; CDefaultJoyKeyInfo::Load
PUBLIC	??_7CCustomJoyKeyInfo@@6B@			; CCustomJoyKeyInfo::`vftable'
PUBLIC	??0CCustomJoyKeyInfo@@QAE@XZ			; CCustomJoyKeyInfo::CCustomJoyKeyInfo
PUBLIC	??_R4CCustomJoyKeyInfo@@6B@			; CCustomJoyKeyInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCCustomJoyKeyInfo@@@8			; CCustomJoyKeyInfo `RTTI Type Descriptor'
PUBLIC	??_R3CCustomJoyKeyInfo@@8			; CCustomJoyKeyInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CCustomJoyKeyInfo@@8			; CCustomJoyKeyInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CCustomJoyKeyInfo@@8		; CCustomJoyKeyInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Load@CCustomJoyKeyInfo@@UAEXXZ			; CCustomJoyKeyInfo::Load
EXTRN	??_ECCustomJoyKeyInfo@@UAEPAXI@Z:PROC		; CCustomJoyKeyInfo::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CCustomJoyKeyInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CCustomJoyKeyInfo@@8 DD FLAT:??_R0?AVCCustomJoyKeyInfo@@@8 ; CCustomJoyKeyInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CCustomJoyKeyInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CCustomJoyKeyInfo@@8
rdata$r	SEGMENT
??_R2CCustomJoyKeyInfo@@8 DD FLAT:??_R1A@?0A@EA@CCustomJoyKeyInfo@@8 ; CCustomJoyKeyInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CJoyKeyInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CCustomJoyKeyInfo@@8
rdata$r	SEGMENT
??_R3CCustomJoyKeyInfo@@8 DD 00H			; CCustomJoyKeyInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CCustomJoyKeyInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCCustomJoyKeyInfo@@@8
_DATA	SEGMENT
??_R0?AVCCustomJoyKeyInfo@@@8 DD FLAT:??_7type_info@@6B@ ; CCustomJoyKeyInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCCustomJoyKeyInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CCustomJoyKeyInfo@@6B@
rdata$r	SEGMENT
??_R4CCustomJoyKeyInfo@@6B@ DD 00H			; CCustomJoyKeyInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCCustomJoyKeyInfo@@@8
	DD	FLAT:??_R3CCustomJoyKeyInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CCustomJoyKeyInfo@@6B@
CONST	SEGMENT
??_7CCustomJoyKeyInfo@@6B@ DD FLAT:??_R4CCustomJoyKeyInfo@@6B@ ; CCustomJoyKeyInfo::`vftable'
	DD	FLAT:?SaveKey@CCustomJoyKeyInfo@@UAEXXZ
	DD	FLAT:??_ECCustomJoyKeyInfo@@UAEPAXI@Z
	DD	FLAT:?Load@CCustomJoyKeyInfo@@UAEXXZ
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??0CCustomJoyKeyInfo@@QAE@XZ
_TEXT	SEGMENT
??0CCustomJoyKeyInfo@@QAE@XZ PROC			; CCustomJoyKeyInfo::CCustomJoyKeyInfo, COMDAT
; _this$ = ecx

; 879  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??0CJoyKeyInfo@@QAE@XZ	; CJoyKeyInfo::CJoyKeyInfo
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CCustomJoyKeyInfo@@6B@

; 880  : 
; 881  : }

  0000e	8b c6		 mov	 eax, esi
  00010	5e		 pop	 esi
  00011	c3		 ret	 0
??0CCustomJoyKeyInfo@@QAE@XZ ENDP			; CCustomJoyKeyInfo::CCustomJoyKeyInfo
_TEXT	ENDS
PUBLIC	??1CCustomJoyKeyInfo@@UAE@XZ			; CCustomJoyKeyInfo::~CCustomJoyKeyInfo
; Function compile flags: /Ogsp
;	COMDAT ??1CCustomJoyKeyInfo@@UAE@XZ
_TEXT	SEGMENT
??1CCustomJoyKeyInfo@@UAE@XZ PROC			; CCustomJoyKeyInfo::~CCustomJoyKeyInfo, COMDAT
; _this$ = ecx

; 884  : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CCustomJoyKeyInfo@@6B@

; 885  : 
; 886  : }

  00006	e9 00 00 00 00	 jmp	 ??1CJoyKeyInfo@@UAE@XZ	; CJoyKeyInfo::~CJoyKeyInfo
??1CCustomJoyKeyInfo@@UAE@XZ ENDP			; CCustomJoyKeyInfo::~CCustomJoyKeyInfo
_TEXT	ENDS
PUBLIC	_this$GSCopy$
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\stringprotect.h
xdata$x	SEGMENT
__unwindtable$?Load@CCustomJoyKeyInfo@@UAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Load@CCustomJoyKeyInfo@@UAEXXZ$0
__ehfuncinfo$?Load@CCustomJoyKeyInfo@@UAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Load@CCustomJoyKeyInfo@@UAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iokeymanager.cpp
xdata$x	ENDS
;	COMDAT ?Load@CCustomJoyKeyInfo@@UAEXXZ
_TEXT	SEGMENT
_wKey$507537 = -1116					; size = 2
$T521330 = -1116					; size = 4
_this$GSCopy$ = -1112					; size = 4
_i$507533 = -1108					; size = 4
_kLoader$ = -1104					; size = 784
_fName$ = -320						; size = 260
___encStr$507380 = -60					; size = 25
__k$521505 = -28					; size = 8
__t$521407 = -28					; size = 7
__$EHRec$ = -12						; size = 12
?Load@CCustomJoyKeyInfo@@UAEXXZ PROC			; CCustomJoyKeyInfo::Load, COMDAT
; _this$ = ecx

; 889  : {

  00000	68 50 04 00 00	 push	 1104			; 00000450H
  00005	b8 00 00 00 00	 mov	 eax, __ehhandler$?Load@CCustomJoyKeyInfo@@UAEXXZ
  0000a	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000f	8b f1		 mov	 esi, ecx

; 913  : 		{
; 914  : 			WORD wKey = kLoader.LoadInt( GetINIKeyName((KeyTypeArray)i), 0 );

  00011	89 b5 a8 fb ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], esi
  00017	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  0001c	8d 48 1c	 lea	 ecx, DWORD PTR [eax+28]
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00025	84 c0		 test	 al, al
  00027	0f 85 b5 01 00
	00		 jne	 $LN106@Load@3

; 890  : 	if( g_MyInfo.GetPublicID().IsEmpty() )
; 891  : 		return;
; 892  : 
; 893  : 	m_vKeyInfo.clear();

  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00033	50		 push	 eax
  00034	51		 push	 ecx
  00035	8d 85 a4 fb ff
	ff		 lea	 eax, DWORD PTR $T521330[ebp]
  0003b	50		 push	 eax
  0003c	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0003f	e8 00 00 00 00	 call	 ?erase@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@0@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::erase

; 894  : 
; 895  : 	char fName[MAX_PATH]="";

  00044	33 db		 xor	 ebx, ebx
  00046	68 03 01 00 00	 push	 259			; 00000103H
  0004b	8d 85 c1 fe ff
	ff		 lea	 eax, DWORD PTR _fName$[ebp+1]
  00051	53		 push	 ebx
  00052	50		 push	 eax
  00053	88 9d c0 fe ff
	ff		 mov	 BYTE PTR _fName$[ebp], bl
  00059	e8 00 00 00 00	 call	 _memset
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00061	6a 06		 push	 6

; 896  : 	StringCbPrintf_e( fName, sizeof(fName), "Save\\%s\\customjoykey.ini", g_MyInfo.GetPublicID().c_str() );

  00063	c7 45 c4 be 8d
	9d 8f		 mov	 DWORD PTR ___encStr$507380[ebp], -1885499970 ; 8f9d8dbeH
  0006a	c7 45 c8 b1 c9
	98 b6		 mov	 DWORD PTR ___encStr$507380[ebp+4], -1231500879 ; b698c9b1H
  00071	c7 45 cc 8e 99
	98 9e		 mov	 DWORD PTR ___encStr$507380[ebp+8], -1634166386 ; 9e98998eH
  00078	c7 45 d0 82 81
	81 85		 mov	 DWORD PTR ___encStr$507380[ebp+12], -2055110270 ; 85818182H
  0007f	c7 45 d4 94 87
	8e 93		 mov	 DWORD PTR ___encStr$507380[ebp+16], -1819375724 ; 938e8794H
  00086	c7 45 d8 c3 85
	85 83		 mov	 DWORD PTR ___encStr$507380[ebp+20], -2088401469 ; 838585c3H
  0008d	8d 45 c4	 lea	 eax, DWORD PTR ___encStr$507380[ebp]
  00090	88 5d dc	 mov	 BYTE PTR ___encStr$507380[ebp+24], bl
  00093	59		 pop	 ecx
  00094	bf ed ec eb ea	 mov	 edi, -353637139		; eaebecedH
$LL134@Load@3:
  00099	31 38		 xor	 DWORD PTR [eax], edi
  0009b	83 c0 04	 add	 eax, 4
  0009e	49		 dec	 ecx
  0009f	75 f8		 jne	 SHORT $LL134@Load@3
  000a1	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  000a6	8d 48 1c	 lea	 ecx, DWORD PTR [eax+28]
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  000af	50		 push	 eax
  000b0	8d 45 c4	 lea	 eax, DWORD PTR ___encStr$507380[ebp]
  000b3	50		 push	 eax
  000b4	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR _fName$[ebp]
  000ba	68 04 01 00 00	 push	 260			; 00000104H
  000bf	50		 push	 eax
  000c0	e8 00 00 00 00	 call	 ?StringCbPrintfA@@YAJPADIPBDZZ ; StringCbPrintfA
  000c5	83 c4 10	 add	 esp, 16			; 00000010H

; 897  : 
; 898  : 	ioINILoader kLoader( fName, false );

  000c8	53		 push	 ebx
  000c9	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR _fName$[ebp]
  000cf	50		 push	 eax
  000d0	8d 8d b0 fb ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioINILoader@@QAE@PBD_N@Z

; 899  : 	kLoader.SetTitle_e( "Common" );

  000dc	6a 04		 push	 4
  000de	c7 45 e4 ae 83
	86 87		 mov	 DWORD PTR __t$521407[ebp], -2021227602 ; 878683aeH
  000e5	31 7d e4	 xor	 DWORD PTR __t$521407[ebp], edi
  000e8	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  000eb	66 c7 45 e8 82
	82		 mov	 WORD PTR __t$521407[ebp+4], 33410 ; 00008282H
  000f1	88 5d ea	 mov	 BYTE PTR __t$521407[ebp+6], bl
  000f4	58		 pop	 eax
$LL239@Load@3:
  000f5	8b c8		 mov	 ecx, eax
  000f7	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  000fd	79 05		 jns	 SHORT $LN367@Load@3
  000ff	49		 dec	 ecx
  00100	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00103	41		 inc	 ecx
$LN367@Load@3:
  00104	b2 ed		 mov	 dl, -19			; ffffffedH
  00106	2a d1		 sub	 dl, cl
  00108	30 54 05 e4	 xor	 BYTE PTR __t$521407[ebp+eax], dl
  0010c	40		 inc	 eax
  0010d	83 f8 06	 cmp	 eax, 6
  00110	7c e3		 jl	 SHORT $LL239@Load@3
  00112	8d 45 e4	 lea	 eax, DWORD PTR __t$521407[ebp]
  00115	50		 push	 eax
  00116	8d 8d b0 fb ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0011c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z

; 900  : 
; 901  : 	int iVersion = kLoader.LoadInt_e("Version", 0);

  00122	c7 45 e4 bb 89
	99 99		 mov	 DWORD PTR __k$521505[ebp], -1717990981 ; 999989bbH
  00129	31 7d e4	 xor	 DWORD PTR __k$521505[ebp], edi
  0012c	6a 04		 push	 4
  0012e	c7 45 e8 84 83
	85 00		 mov	 DWORD PTR __k$521505[ebp+4], 8749956 ; 00858384H
  00135	5f		 pop	 edi
$LL345@Load@3:
  00136	8b c7		 mov	 eax, edi
  00138	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  0013d	79 05		 jns	 SHORT $LN368@Load@3
  0013f	48		 dec	 eax
  00140	83 c8 fc	 or	 eax, -4			; fffffffcH
  00143	40		 inc	 eax
$LN368@Load@3:
  00144	b1 ed		 mov	 cl, -19			; ffffffedH
  00146	2a c8		 sub	 cl, al
  00148	30 4c 3d e4	 xor	 BYTE PTR __k$521505[ebp+edi], cl
  0014c	47		 inc	 edi
  0014d	83 ff 07	 cmp	 edi, 7
  00150	7c e4		 jl	 SHORT $LL345@Load@3
  00152	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  00158	53		 push	 ebx
  00159	8d 45 e4	 lea	 eax, DWORD PTR __k$521505[ebp]
  0015c	50		 push	 eax
  0015d	8d 8d b0 fb ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00163	ff d7		 call	 edi

; 902  : 	if( iVersion != CUSTOMKEY_VERSION ) 

  00165	3d 50 05 33 01	 cmp	 eax, 20120912		; 01330550H
  0016a	74 0d		 je	 SHORT $LN5@Load@3

; 903  : 	{
; 904  : 		//
; 905  : 		CJoyKeyInfo::Load();

  0016c	8b 8d a8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00172	e8 00 00 00 00	 call	 ?Load@CJoyKeyInfo@@QAEXXZ ; CJoyKeyInfo::Load

; 906  : 	}
; 907  : 	else

  00177	eb 59		 jmp	 SHORT $LN1@Load@3
$LN5@Load@3:

; 908  : 	{
; 909  : 		// 
; 910  : 		int i = 0;
; 911  : 		kLoader.SetTitle( "Key" );

  00179	68 00 00 00 00	 push	 OFFSET ??_C@_03CCEPDEKL@Key?$AA@
  0017e	8d 8d b0 fb ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00184	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z

; 912  : 		for (i = 0; i < JTA_MAX ; i++)

  0018a	89 9d ac fb ff
	ff		 mov	 DWORD PTR _i$507533[ebp], ebx
$LN3@Load@3:

; 913  : 		{
; 914  : 			WORD wKey = kLoader.LoadInt( GetINIKeyName((KeyTypeArray)i), 0 );

  00190	8b 8d a8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00196	53		 push	 ebx
  00197	ff b5 ac fb ff
	ff		 push	 DWORD PTR _i$507533[ebp]
  0019d	e8 00 00 00 00	 call	 ?GetINIKeyName@CJoyKeyInfo@@IAEPADW4KeyTypeArray@1@@Z ; CJoyKeyInfo::GetINIKeyName
  001a2	50		 push	 eax
  001a3	8d 8d b0 fb ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  001a9	ff d7		 call	 edi
  001ab	0f b7 c0	 movzx	 eax, ax
  001ae	89 85 a4 fb ff
	ff		 mov	 DWORD PTR _wKey$507537[ebp], eax

; 915  : 			m_vKeyInfo.push_back(wKey);

  001b4	8d 85 a4 fb ff
	ff		 lea	 eax, DWORD PTR _wKey$507537[ebp]
  001ba	50		 push	 eax
  001bb	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  001be	e8 00 00 00 00	 call	 ?push_back@?$vector@GV?$allocator@G@std@@@std@@QAEXABG@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::push_back
  001c3	ff 85 ac fb ff
	ff		 inc	 DWORD PTR _i$507533[ebp]
  001c9	83 bd ac fb ff
	ff 2f		 cmp	 DWORD PTR _i$507533[ebp], 47 ; 0000002fH
  001d0	7c be		 jl	 SHORT $LN3@Load@3
$LN1@Load@3:

; 916  : 		}
; 917  : 
; 918  : 		//    NULL   
; 919  : 		// HARDCODE ::          
; 920  : 		//                 . 2013.03.15. KDH
; 921  : 		/*
; 922  : 		ioINILoader_e kDefaultLoader( "config/sp2_default_joykey.ini" );
; 923  : 		kDefaultLoader.SetTitle_e( "Key" );
; 924  : 		int iKeySize = m_vKeyInfo.size();
; 925  : 		for (i = 0; i < iKeySize ; i++)
; 926  : 		{
; 927  : 			if( m_vKeyInfo[i] == 0 )
; 928  : 				m_vKeyInfo[i] = kDefaultLoader.LoadInt( GetINIKeyName((KeyTypeArray)i), 0 );
; 929  : 		}
; 930  : 		*/
; 931  : 	}
; 932  : }

  001d2	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  001d6	8d 8d b0 fb ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  001dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioINILoader@@QAE@XZ
$LN106@Load@3:
  001e2	e8 00 00 00 00	 call	 __EH_epilog3_GS
  001e7	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Load@CCustomJoyKeyInfo@@UAEXXZ$0:
  00000	8d 8d b0 fb ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioINILoader@@QAE@XZ
__ehhandler$?Load@CCustomJoyKeyInfo@@UAEXXZ:
  0000c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00010	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00013	8b 8a a0 fb ff
	ff		 mov	 ecx, DWORD PTR [edx-1120]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Load@CCustomJoyKeyInfo@@UAEXXZ
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Load@CCustomJoyKeyInfo@@UAEXXZ ENDP			; CCustomJoyKeyInfo::Load
PUBLIC	??_C@_0BJ@DLKBPACM@ioKeyManager?3?3GetKeyText?$AA@ ; `string'
PUBLIC	?GetKeyText@ioKeyManager@@QAEPBDG@Z		; ioKeyManager::GetKeyText
EXTRN	__imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z:PROC
EXTRN	__imp_?GetSingleton@ioStringManager@@SAAAV1@XZ:PROC
;	COMDAT ??_C@_0BJ@DLKBPACM@ioKeyManager?3?3GetKeyText?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
CONST	SEGMENT
??_C@_0BJ@DLKBPACM@ioKeyManager?3?3GetKeyText?$AA@ DB 'ioKeyManager::GetK'
	DB	'eyText', 00H				; `string'
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iokeymanager.cpp
CONST	ENDS
;	COMDAT ?GetKeyText@ioKeyManager@@QAEPBDG@Z
_TEXT	SEGMENT
_iter$ = -4						; size = 4
_wKey$ = 8						; size = 2
?GetKeyText@ioKeyManager@@QAEPBDG@Z PROC		; ioKeyManager::GetKeyText, COMDAT
; _this$ = ecx

; 1859 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 1860 : 	KeyTextMap::iterator iter = m_KeyTextMap.find( wKey );

  00005	8d 45 08	 lea	 eax, DWORD PTR _wKey$[ebp]
  00008	50		 push	 eax
  00009	8b f1		 mov	 esi, ecx
  0000b	8d 45 fc	 lea	 eax, DWORD PTR _iter$[ebp]
  0000e	50		 push	 eax
  0000f	8d 8e 84 00 00
	00		 lea	 ecx, DWORD PTR [esi+132]
  00015	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@ABG@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::find

; 1861 : 	if( iter != m_KeyTextMap.end() )

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _iter$[ebp]
  0001d	3b 86 88 00 00
	00		 cmp	 eax, DWORD PTR [esi+136]
  00023	5e		 pop	 esi
  00024	74 0b		 je	 SHORT $LN1@GetKeyText

; 1862 : 		return iter->second.c_str();

  00026	8d 48 10	 lea	 ecx, DWORD PTR [eax+16]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  0002f	eb 1c		 jmp	 SHORT $LN2@GetKeyText
$LN1@GetKeyText:

; 1863 : 	return STR(1);

  00031	6a 00		 push	 0
  00033	6a 01		 push	 1
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DLKBPACM@ioKeyManager?3?3GetKeyText?$AA@
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSingleton@ioStringManager@@SAAAV1@XZ
  00045	8b c8		 mov	 ecx, eax
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@ioStringManager@@QAEPADPBD0HW4FileNamePrefix@1@@Z
$LN2@GetKeyText:

; 1864 : }

  0004d	c9		 leave
  0004e	c2 04 00	 ret	 4
?GetKeyText@ioKeyManager@@QAEPBDG@Z ENDP		; ioKeyManager::GetKeyText
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Erase
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1610 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1611 : 		for (_Nodeptr _Pnode = _Rootnode;

  00006	8b 7d 08	 mov	 edi, DWORD PTR __Rootnode$[ebp]

; 1612 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00009	80 7f 21 00	 cmp	 BYTE PTR [edi+33], 0
  0000d	8b d9		 mov	 ebx, ecx
  0000f	8b f7		 mov	 esi, edi
  00011	75 24		 jne	 SHORT $LN1@Erase
$LL3@Erase:

; 1613 : 			{	// free subtrees, then node
; 1614 : 			_Erase(this->_Right(_Pnode));

  00013	ff 76 08	 push	 DWORD PTR [esi+8]
  00016	8b cb		 mov	 ecx, ebx
  00018	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Erase

; 1615 : 			_Pnode = this->_Left(_Pnode);

  0001d	8b 36		 mov	 esi, DWORD PTR [esi]

; 1616 : 			_Dest_val(this->_Alval,
; 1617 : 				_STD addressof(this->_Myval(_Rootnode)));

  0001f	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ

; 1618 : 
; 1619 : 			this->_Alnod.deallocate(_Rootnode, 1);

  00028	57		 push	 edi
  00029	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002e	80 7e 21 00	 cmp	 BYTE PTR [esi+33], 0
  00032	59		 pop	 ecx
  00033	8b fe		 mov	 edi, esi
  00035	74 dc		 je	 SHORT $LL3@Erase
$LN1@Erase:
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx

; 1620 : 			}
; 1621 : 		}

  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Erase
_TEXT	ENDS
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::erase
EXTRN	__imp_?_Xout_of_range@std@@YAXPBD@Z:PROC
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
CONST	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::erase, COMDAT
; _this$ = ecx

; 1195 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1198 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1199 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1200 : 		++_Where;	// save successor iterator for return
; 1201 : 		_Orphan_ptr(*this, _Erasednode);
; 1202 : 
; 1203 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1204 : 		if (this->_Isnil(_Where._Mynode()))

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR __Where$[ebp]
  00008	80 7b 21 00	 cmp	 BYTE PTR [ebx+33], 0
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00011	74 0b		 je	 SHORT $LN40@erase@2

; 1205 : 			_Xout_of_range("invalid map/set<T> iterator");

  00013	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN338@erase@2:
$LN40@erase@2:

; 1206 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1207 : 		++_Where;	// save successor iterator for return

  0001e	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00021	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >,std::_Iterator_base0>::operator++

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1211 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1212 : 		_Nodeptr _Pnode = _Erasednode;
; 1213 : 
; 1214 : 		if (this->_Isnil(this->_Left(_Pnode)))

  00026	8b 13		 mov	 edx, DWORD PTR [ebx]
  00028	80 7a 21 00	 cmp	 BYTE PTR [edx+33], 0
  0002c	74 05		 je	 SHORT $LN39@erase@2

; 1215 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  0002e	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 1216 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  00031	eb 17		 jmp	 SHORT $LN330@erase@2
$LN39@erase@2:
  00033	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00036	80 78 21 00	 cmp	 BYTE PTR [eax+33], 0
  0003a	74 04		 je	 SHORT $LN37@erase@2

; 1217 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  0003c	8b fa		 mov	 edi, edx

; 1218 : 		else

  0003e	eb 0a		 jmp	 SHORT $LN330@erase@2
$LN37@erase@2:

; 1219 : 			{	// two subtrees, must lift successor node to replace erased
; 1220 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

  00040	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 1221 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  00043	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 1222 : 			}
; 1223 : 
; 1224 : 		if (_Pnode == _Erasednode)

  00046	3b c3		 cmp	 eax, ebx
  00048	75 76		 jne	 SHORT $LN35@erase@2
$LN330@erase@2:

; 1225 : 			{	// at most one subtree, relink it
; 1226 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1227 : 			if (!this->_Isnil(_Fixnode))

  0004a	80 7f 21 00	 cmp	 BYTE PTR [edi+33], 0
  0004e	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00051	75 03		 jne	 SHORT $LN34@erase@2

; 1228 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  00053	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN34@erase@2:

; 1229 : 
; 1230 : 			if (_Root() == _Erasednode)

  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0005c	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  0005f	75 05		 jne	 SHORT $LN33@erase@2

; 1231 : 				_Root() = _Fixnode;	// link down from root

  00061	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 1232 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  00064	eb 0b		 jmp	 SHORT $LN30@erase@2
$LN33@erase@2:
  00066	39 1e		 cmp	 DWORD PTR [esi], ebx
  00068	75 04		 jne	 SHORT $LN31@erase@2

; 1233 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  0006a	89 3e		 mov	 DWORD PTR [esi], edi

; 1234 : 			else

  0006c	eb 03		 jmp	 SHORT $LN30@erase@2
$LN31@erase@2:

; 1235 : 				this->_Right(_Fixnodeparent) =
; 1236 : 					_Fixnode;	// link down to right

  0006e	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$LN30@erase@2:

; 1237 : 
; 1238 : 			if (_Lmost() == _Erasednode)

  00071	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00074	39 19		 cmp	 DWORD PTR [ecx], ebx
  00076	75 1c		 jne	 SHORT $LN29@erase@2

; 1239 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1240 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1241 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  00078	80 7f 21 00	 cmp	 BYTE PTR [edi+33], 0
  0007c	74 04		 je	 SHORT $LN43@erase@2
  0007e	8b d6		 mov	 edx, esi
  00080	eb 10		 jmp	 SHORT $LN97@erase@2
$LN43@erase@2:
  00082	8b 07		 mov	 eax, DWORD PTR [edi]
  00084	8b d7		 mov	 edx, edi
  00086	eb 04		 jmp	 SHORT $LN332@erase@2
$LL98@erase@2:
  00088	8b d0		 mov	 edx, eax
  0008a	8b 02		 mov	 eax, DWORD PTR [edx]
$LN332@erase@2:
  0008c	80 78 21 00	 cmp	 BYTE PTR [eax+33], 0
  00090	74 f6		 je	 SHORT $LL98@erase@2
$LN97@erase@2:
  00092	89 11		 mov	 DWORD PTR [ecx], edx
$LN29@erase@2:

; 1242 : 
; 1243 : 			if (_Rmost() == _Erasednode)

  00094	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009a	39 59 08	 cmp	 DWORD PTR [ecx+8], ebx
  0009d	75 7b		 jne	 SHORT $LN185@erase@2

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  0009f	80 7f 21 00	 cmp	 BYTE PTR [edi+33], 0
  000a3	74 04		 je	 SHORT $LN45@erase@2
  000a5	8b d6		 mov	 edx, esi
  000a7	eb 12		 jmp	 SHORT $LN117@erase@2
$LN45@erase@2:
  000a9	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000ac	8b d7		 mov	 edx, edi
  000ae	eb 05		 jmp	 SHORT $LN333@erase@2
$LL118@erase@2:
  000b0	8b d0		 mov	 edx, eax
  000b2	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
$LN333@erase@2:
  000b5	80 78 21 00	 cmp	 BYTE PTR [eax+33], 0
  000b9	74 f5		 je	 SHORT $LL118@erase@2
$LN117@erase@2:
  000bb	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 1247 : 			}
; 1248 : 		else

  000be	eb 5a		 jmp	 SHORT $LN185@erase@2
$LN35@erase@2:

; 1249 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1250 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1251 : 				_Pnode;	// link left up

  000c0	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1252 : 			this->_Left(_Pnode) =
; 1253 : 				this->_Left(_Erasednode);	// link successor down

  000c3	8b 13		 mov	 edx, DWORD PTR [ebx]
  000c5	89 10		 mov	 DWORD PTR [eax], edx

; 1254 : 
; 1255 : 			if (_Pnode == this->_Right(_Erasednode))

  000c7	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  000ca	75 04		 jne	 SHORT $LN26@erase@2

; 1256 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  000cc	8b f0		 mov	 esi, eax

; 1257 : 			else

  000ce	eb 1a		 jmp	 SHORT $LN25@erase@2
$LN26@erase@2:

; 1258 : 				{	// successor further down, link in place of erased
; 1259 : 				_Fixnodeparent =
; 1260 : 					this->_Parent(_Pnode);	// parent is successor's
; 1261 : 				if (!this->_Isnil(_Fixnode))

  000d0	80 7f 21 00	 cmp	 BYTE PTR [edi+33], 0
  000d4	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000d7	75 03		 jne	 SHORT $LN24@erase@2

; 1262 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  000d9	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN24@erase@2:

; 1263 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  000dc	89 3e		 mov	 DWORD PTR [esi], edi

; 1264 : 				this->_Right(_Pnode) =
; 1265 : 					this->_Right(_Erasednode);	// link next down

  000de	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  000e1	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1266 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1267 : 					_Pnode;	// right up

  000e4	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  000e7	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN25@erase@2:

; 1268 : 				}
; 1269 : 
; 1270 : 			if (_Root() == _Erasednode)

  000ea	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ed	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000f0	39 59 04	 cmp	 DWORD PTR [ecx+4], ebx
  000f3	75 05		 jne	 SHORT $LN23@erase@2

; 1271 : 				_Root() = _Pnode;	// link down from root

  000f5	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1272 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  000f8	eb 0e		 jmp	 SHORT $LN20@erase@2
$LN23@erase@2:
  000fa	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000fd	39 19		 cmp	 DWORD PTR [ecx], ebx
  000ff	75 04		 jne	 SHORT $LN21@erase@2

; 1273 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1274 : 					_Pnode;	// link down to left

  00101	89 01		 mov	 DWORD PTR [ecx], eax

; 1275 : 			else

  00103	eb 03		 jmp	 SHORT $LN20@erase@2
$LN21@erase@2:

; 1276 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1277 : 					_Pnode;	// link down to right

  00105	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN20@erase@2:

; 1278 : 
; 1279 : 			this->_Parent(_Pnode) =
; 1280 : 				this->_Parent(_Erasednode);	// link successor up

  00108	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0010b	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1281 : 			_STD swap(this->_Color(_Pnode),
; 1282 : 				this->_Color(_Erasednode));	// recolor it

  0010e	8a 53 20	 mov	 dl, BYTE PTR [ebx+32]
  00111	8a 48 20	 mov	 cl, BYTE PTR [eax+32]
  00114	88 50 20	 mov	 BYTE PTR [eax+32], dl
  00117	88 4b 20	 mov	 BYTE PTR [ebx+32], cl
$LN185@erase@2:

; 1283 : 			}
; 1284 : 
; 1285 : 		if (this->_Color(_Erasednode) == this->_Black)

  0011a	80 7b 20 01	 cmp	 BYTE PTR [ebx+32], 1
  0011e	0f 85 03 01 00
	00		 jne	 $LN19@erase@2

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  00124	e9 b2 00 00 00	 jmp	 $LN335@erase@2
$LL18@erase@2:
  00129	80 7f 20 01	 cmp	 BYTE PTR [edi+32], 1
  0012d	0f 85 f0 00 00
	00		 jne	 $LN16@erase@2

; 1290 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  00133	8b 06		 mov	 eax, DWORD PTR [esi]
  00135	3b f8		 cmp	 edi, eax
  00137	75 6c		 jne	 SHORT $LN15@erase@2

; 1291 : 					{	// fixup left subtree
; 1292 : 					_Pnode = this->_Right(_Fixnodeparent);

  00139	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 1293 : 					if (this->_Color(_Pnode) == this->_Red)

  0013c	80 78 20 00	 cmp	 BYTE PTR [eax+32], 0
  00140	75 11		 jne	 SHORT $LN14@erase@2

; 1294 : 						{	// rotate red up from right subtree
; 1295 : 						this->_Color(_Pnode) = this->_Black;

  00142	c6 40 20 01	 mov	 BYTE PTR [eax+32], 1

; 1296 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1297 : 						_Lrotate(_Fixnodeparent);

  00146	56		 push	 esi
  00147	c6 46 20 00	 mov	 BYTE PTR [esi+32], 0
  0014b	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Lrotate

; 1298 : 						_Pnode = this->_Right(_Fixnodeparent);

  00150	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
$LN14@erase@2:

; 1299 : 						}
; 1300 : 
; 1301 : 					if (this->_Isnil(_Pnode))

  00153	80 78 21 00	 cmp	 BYTE PTR [eax+33], 0

; 1302 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1303 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black

  00157	75 7d		 jne	 SHORT $LN336@erase@2

; 1304 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  00159	8b 08		 mov	 ecx, DWORD PTR [eax]
  0015b	80 79 20 01	 cmp	 BYTE PTR [ecx+32], 1
  0015f	75 09		 jne	 SHORT $LN11@erase@2
  00161	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00164	80 79 20 01	 cmp	 BYTE PTR [ecx+32], 1
  00168	74 68		 je	 SHORT $LN337@erase@2
$LN11@erase@2:

; 1305 : 						{	// redden right subtree with black children
; 1306 : 						this->_Color(_Pnode) = this->_Red;
; 1307 : 						_Fixnode = _Fixnodeparent;
; 1308 : 						}
; 1309 : 					else
; 1310 : 						{	// must rearrange right subtree
; 1311 : 						if (this->_Color(this->_Right(_Pnode))
; 1312 : 							== this->_Black)

  0016a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0016d	80 79 20 01	 cmp	 BYTE PTR [ecx+32], 1
  00171	75 16		 jne	 SHORT $LN9@erase@2

; 1313 : 							{	// rotate red up from left sub-subtree
; 1314 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  00173	8b 08		 mov	 ecx, DWORD PTR [eax]
  00175	c6 41 20 01	 mov	 BYTE PTR [ecx+32], 1

; 1315 : 							this->_Color(_Pnode) = this->_Red;
; 1316 : 							_Rrotate(_Pnode);

  00179	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0017c	50		 push	 eax
  0017d	c6 40 20 00	 mov	 BYTE PTR [eax+32], 0
  00181	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Rrotate

; 1317 : 							_Pnode = this->_Right(_Fixnodeparent);

  00186	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
$LN9@erase@2:

; 1318 : 							}
; 1319 : 
; 1320 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  00189	8a 4e 20	 mov	 cl, BYTE PTR [esi+32]
  0018c	88 48 20	 mov	 BYTE PTR [eax+32], cl

; 1321 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1322 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1323 : 						_Lrotate(_Fixnodeparent);

  0018f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00192	c6 46 20 01	 mov	 BYTE PTR [esi+32], 1
  00196	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00199	56		 push	 esi
  0019a	c6 40 20 01	 mov	 BYTE PTR [eax+32], 1
  0019e	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Lrotate

; 1324 : 						break;	// tree now recolored/rebalanced

  001a3	eb 7e		 jmp	 SHORT $LN16@erase@2
$LN15@erase@2:

; 1325 : 						}
; 1326 : 					}
; 1327 : 				else
; 1328 : 					{	// fixup right subtree
; 1329 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1330 : 					if (this->_Color(_Pnode) == this->_Red)

  001a5	80 78 20 00	 cmp	 BYTE PTR [eax+32], 0
  001a9	75 10		 jne	 SHORT $LN7@erase@2

; 1331 : 						{	// rotate red up from left subtree
; 1332 : 						this->_Color(_Pnode) = this->_Black;

  001ab	c6 40 20 01	 mov	 BYTE PTR [eax+32], 1

; 1333 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1334 : 						_Rrotate(_Fixnodeparent);

  001af	56		 push	 esi
  001b0	c6 46 20 00	 mov	 BYTE PTR [esi+32], 0
  001b4	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Rrotate

; 1335 : 						_Pnode = this->_Left(_Fixnodeparent);

  001b9	8b 06		 mov	 eax, DWORD PTR [esi]
$LN7@erase@2:

; 1336 : 						}
; 1337 : 					if (this->_Isnil(_Pnode))

  001bb	80 78 21 00	 cmp	 BYTE PTR [eax+33], 0

; 1338 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1339 : 					else if (this->_Color(this->_Right(_Pnode)) ==

  001bf	75 15		 jne	 SHORT $LN336@erase@2

; 1340 : 						this->_Black
; 1341 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  001c1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001c4	80 79 20 01	 cmp	 BYTE PTR [ecx+32], 1
  001c8	75 22		 jne	 SHORT $LN4@erase@2
  001ca	8b 08		 mov	 ecx, DWORD PTR [eax]
  001cc	80 79 20 01	 cmp	 BYTE PTR [ecx+32], 1
  001d0	75 1a		 jne	 SHORT $LN4@erase@2
$LN337@erase@2:

; 1342 : 						{	// redden left subtree with black children
; 1343 : 						this->_Color(_Pnode) = this->_Red;

  001d2	c6 40 20 00	 mov	 BYTE PTR [eax+32], 0
$LN336@erase@2:

; 1344 : 						_Fixnode = _Fixnodeparent;

  001d6	8b fe		 mov	 edi, esi
  001d8	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
$LN335@erase@2:

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001db	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001de	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001e1	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  001e4	0f 85 3f ff ff
	ff		 jne	 $LL18@erase@2
  001ea	eb 37		 jmp	 SHORT $LN16@erase@2
$LN4@erase@2:

; 1345 : 						}
; 1346 : 					else
; 1347 : 						{	// must rearrange left subtree
; 1348 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  001ec	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ee	80 79 20 01	 cmp	 BYTE PTR [ecx+32], 1
  001f2	75 16		 jne	 SHORT $LN2@erase@2

; 1349 : 							{	// rotate red up from right sub-subtree
; 1350 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  001f4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001f7	c6 41 20 01	 mov	 BYTE PTR [ecx+32], 1

; 1351 : 							this->_Color(_Pnode) = this->_Red;
; 1352 : 							_Lrotate(_Pnode);

  001fb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001fe	50		 push	 eax
  001ff	c6 40 20 00	 mov	 BYTE PTR [eax+32], 0
  00203	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Lrotate

; 1353 : 							_Pnode = this->_Left(_Fixnodeparent);

  00208	8b 06		 mov	 eax, DWORD PTR [esi]
$LN2@erase@2:

; 1354 : 							}
; 1355 : 
; 1356 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  0020a	8a 4e 20	 mov	 cl, BYTE PTR [esi+32]
  0020d	88 48 20	 mov	 BYTE PTR [eax+32], cl

; 1357 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1358 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1359 : 						_Rrotate(_Fixnodeparent);

  00210	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00213	c6 46 20 01	 mov	 BYTE PTR [esi+32], 1
  00217	8b 00		 mov	 eax, DWORD PTR [eax]
  00219	56		 push	 esi
  0021a	c6 40 20 01	 mov	 BYTE PTR [eax+32], 1
  0021e	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Rrotate
$LN16@erase@2:

; 1360 : 						break;	// tree now recolored/rebalanced
; 1361 : 						}
; 1362 : 					}
; 1363 : 
; 1364 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  00223	c6 47 20 01	 mov	 BYTE PTR [edi+32], 1
$LN19@erase@2:

; 1365 : 			}
; 1366 : 
; 1367 : 		_Dest_val(this->_Alval,
; 1368 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node

  00227	8d 4b 10	 lea	 ecx, DWORD PTR [ebx+16]
  0022a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ

; 1369 : 
; 1370 : 		this->_Alnod.deallocate(_Erasednode, 1);

  00230	53		 push	 ebx
  00231	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00236	59		 pop	 ecx

; 1371 : 
; 1372 : 		if (0 < this->_Mysize)

  00237	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0023a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0023d	5f		 pop	 edi
  0023e	5e		 pop	 esi
  0023f	5b		 pop	 ebx
  00240	85 c0		 test	 eax, eax
  00242	74 04		 je	 SHORT $LN1@erase@2

; 1373 : 			--this->_Mysize;

  00244	48		 dec	 eax
  00245	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN1@erase@2:

; 1374 : 
; 1375 : 		return (iterator(_Where._Ptr, this));	// return successor iterator

  00248	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0024b	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  0024e	89 08		 mov	 DWORD PTR [eax], ecx

; 1376 : 		}

  00250	c9		 leave
  00251	c2 08 00	 ret	 8
$LN331@erase@2:
?erase@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::erase
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@0AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CKeyInfo::tagMecroTextInfo> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@0AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@0AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CKeyInfo::tagMecroTextInfo> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	eb 0c		 jmp	 SHORT $LN24@Destroy_ra@2
$LL7@Destroy_ra@2:
  00009	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00012	83 c6 14	 add	 esi, 20			; 00000014H
$LN24@Destroy_ra@2:
  00015	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00018	75 ef		 jne	 SHORT $LL7@Destroy_ra@2
  0001a	5e		 pop	 esi

; 89   : 	}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$_Destroy_range@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@0AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CKeyInfo::tagMecroTextInfo> >
_TEXT	ENDS
PUBLIC	?_Linsert@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Linsert
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Linsert@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@_N@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Node$ = 12						; size = 4
$T522389 = 16						; size = 4
__Where$513718 = 16					; size = 4
__Leftish$ = 16						; size = 1
?_Linsert@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@_N@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Linsert, COMDAT
; _this$ = ecx

; 944  : 		{	// try to insert node at _Node, on left if _Leftish

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 945  : 		const value_type& _Val = this->_Myval(_Node);
; 946  : 
; 947  : 		_Nodeptr _Trynode = _Root();
; 948  : 		_Nodeptr _Wherenode = this->_Myhead;
; 949  : 		bool _Addleft = true;	// add to left of head if tree empty
; 950  : 		while (!this->_Isnil(_Trynode))

  00004	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0000e	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00011	80 78 21 00	 cmp	 BYTE PTR [eax+33], 0
  00015	8b d9		 mov	 ebx, ecx
  00017	b1 01		 mov	 cl, 1
  00019	57		 push	 edi
  0001a	88 4d fc	 mov	 BYTE PTR __Addleft$[ebp], cl
  0001d	75 31		 jne	 SHORT $LN11@Linsert
  0001f	0f b7 7a 0c	 movzx	 edi, WORD PTR [edx+12]
$LL12@Linsert:

; 951  : 			{	// look for leaf to insert before (_Addleft) or after
; 952  : 			_Wherenode = _Trynode;
; 953  : 			if (_Leftish)

  00023	80 7d 10 00	 cmp	 BYTE PTR __Leftish$[ebp], 0
  00027	8b d8		 mov	 ebx, eax
  00029	74 0a		 je	 SHORT $LN10@Linsert

; 954  : 				_Addleft = !_DEBUG_LT_PRED(this->comp,

  0002b	66 39 78 0c	 cmp	 WORD PTR [eax+12], di
  0002f	1a c9		 sbb	 cl, cl
  00031	fe c1		 inc	 cl

; 955  : 					this->_Key(_Trynode),
; 956  : 					this->_Kfn(_Val));	// favor left end
; 957  : 			else

  00033	eb 07		 jmp	 SHORT $LN161@Linsert
$LN10@Linsert:

; 958  : 				_Addleft = _DEBUG_LT_PRED(this->comp,

  00035	66 3b 78 0c	 cmp	 di, WORD PTR [eax+12]
  00039	0f 92 c1	 setb	 cl
$LN161@Linsert:
  0003c	88 4d fc	 mov	 BYTE PTR __Addleft$[ebp], cl

; 959  : 					this->_Kfn(_Val),
; 960  : 					this->_Key(_Trynode));	// favor right end
; 961  : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 962  : 				: this->_Right(_Trynode);

  0003f	84 c9		 test	 cl, cl
  00041	74 04		 je	 SHORT $LN15@Linsert
  00043	8b 00		 mov	 eax, DWORD PTR [eax]
  00045	eb 03		 jmp	 SHORT $LN16@Linsert
$LN15@Linsert:
  00047	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$LN16@Linsert:

; 945  : 		const value_type& _Val = this->_Myval(_Node);
; 946  : 
; 947  : 		_Nodeptr _Trynode = _Root();
; 948  : 		_Nodeptr _Wherenode = this->_Myhead;
; 949  : 		bool _Addleft = true;	// add to left of head if tree empty
; 950  : 		while (!this->_Isnil(_Trynode))

  0004a	80 78 21 00	 cmp	 BYTE PTR [eax+33], 0
  0004e	74 d3		 je	 SHORT $LL12@Linsert
$LN11@Linsert:

; 963  : 			}
; 964  : 
; 965  : 		if (this->_Multi)
; 966  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));
; 967  : 		else
; 968  : 			{	// insert only if unique
; 969  : 			iterator _Where = iterator(_Wherenode, this);

  00050	8b fb		 mov	 edi, ebx
  00052	89 7d 10	 mov	 DWORD PTR __Where$513718[ebp], edi

; 970  : 			if (!_Addleft)

  00055	84 c9		 test	 cl, cl
  00057	74 31		 je	 SHORT $LN99@Linsert

; 971  : 				;	// need to test if insert after is okay
; 972  : 			else if (_Where == begin())

  00059	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0005c	3b 18		 cmp	 ebx, DWORD PTR [eax]
  0005e	75 1c		 jne	 SHORT $LN4@Linsert

; 973  : 				return (_Pairib(_Insert(true, _Wherenode, _Node), true));

  00060	52		 push	 edx
  00061	53		 push	 ebx
  00062	6a 01		 push	 1
$LN162@Linsert:
  00064	8d 45 10	 lea	 eax, DWORD PTR $T522389[ebp]
  00067	50		 push	 eax
  00068	8b ce		 mov	 ecx, esi
  0006a	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Insert
  0006f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00071	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00074	89 08		 mov	 DWORD PTR [eax], ecx
  00076	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  0007a	eb 3a		 jmp	 SHORT $LN1@Linsert
$LN4@Linsert:

; 974  : 			else
; 975  : 				--_Where;	// need to test if insert before is okay

  0007c	8d 4d 10	 lea	 ecx, DWORD PTR __Where$513718[ebp]
  0007f	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >,std::_Iterator_base0>::operator--
  00084	8b 7d 10	 mov	 edi, DWORD PTR __Where$513718[ebp]
  00087	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
$LN99@Linsert:

; 976  : 
; 977  : 			if (_DEBUG_LT_PRED(this->comp,

  0008a	66 8b 47 0c	 mov	 ax, WORD PTR [edi+12]
  0008e	66 3b 42 0c	 cmp	 ax, WORD PTR [edx+12]
  00092	73 07		 jae	 SHORT $LN2@Linsert

; 978  : 				this->_Key(_Where._Mynode()),
; 979  : 				this->_Kfn(_Val)))
; 980  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));

  00094	52		 push	 edx
  00095	53		 push	 ebx
  00096	ff 75 fc	 push	 DWORD PTR __Addleft$[ebp]
  00099	eb c9		 jmp	 SHORT $LN162@Linsert
$LN2@Linsert:

; 981  : 			else
; 982  : 				{	// duplicate, don't insert
; 983  : 				_Dest_val(this->_Alval,
; 984  : 					_STD addressof(this->_Myval(_Node)));

  0009b	8d 4a 10	 lea	 ecx, DWORD PTR [edx+16]
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ

; 985  : 
; 986  : 				this->_Alnod.deallocate(_Node, 1);

  000a4	ff 75 0c	 push	 DWORD PTR __Node$[ebp]
  000a7	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 987  : 
; 988  : 				return (_Pairib(_Where, false));

  000ac	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000af	59		 pop	 ecx
  000b0	89 38		 mov	 DWORD PTR [eax], edi
  000b2	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
$LN1@Linsert:
  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  000b9	c9		 leave
  000ba	c2 0c 00	 ret	 12			; 0000000cH
?_Linsert@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@_N@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Linsert
_TEXT	ENDS
PUBLIC	??$_Buynode@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Buynode<std::pair<unsigned short const ,ioHashString> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Buynode@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Buynode@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z$0
__unwindtable$??$_Buynode@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Buynode@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Buynode@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z$2
__ehfuncinfo$??$_Buynode@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Buynode@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Buynode@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??$_Buynode@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z
_TEXT	SEGMENT
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 4
??$_Buynode@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Buynode<std::pair<unsigned short const ,ioHashString> >, COMDAT
; _this$ = ecx

; 586  : 		_Nodeptr _Buynode(_Valty&& _Val)

  00000	6a 08		 push	 8
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??$_Buynode@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_catch
  0000c	8b f1		 mov	 esi, ecx

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

  0000e	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Buynode

; 589  : 
; 590  : 		_TRY_BEGIN
; 591  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Wherenode)),
; 592  : 			_STD forward<_Valty>(_Val));

  00013	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  00016	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
  0001a	8b f8		 mov	 edi, eax
  0001c	8d 47 0c	 lea	 eax, DWORD PTR [edi+12]
  0001f	50		 push	 eax
  00020	83 c6 0d	 add	 esi, 13			; 0000000dH
  00023	56		 push	 esi
  00024	89 7d ec	 mov	 DWORD PTR __Wherenode$[ebp], edi
  00027	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@std@@U?$pair@$$CBGVioHashString@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBGVioHashString@@@std@@@0@PAU?$pair@$$CBGVioHashString@@@0@$$QAU20@@Z ; std::_Cons_val<std::allocator<std::pair<unsigned short const ,ioHashString> >,std::pair<unsigned short const ,ioHashString>,std::pair<unsigned short const ,ioHashString> >
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 596  : 		_CATCH_END
; 597  : 
; 598  : 		return (_Wherenode);

  0002f	8b c7		 mov	 eax, edi

; 599  : 		}

  00031	e8 00 00 00 00	 call	 __EH_epilog3
  00036	c2 04 00	 ret	 4
__catch$??$_Buynode@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z$0:

; 593  : 		_CATCH_ALL
; 594  : 		this->_Alnod.deallocate(_Wherenode, 1);

  00039	ff 75 ec	 push	 DWORD PTR __Wherenode$[ebp]
  0003c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00041	59		 pop	 ecx

; 595  : 		_RERAISE;

  00042	6a 00		 push	 0
  00044	6a 00		 push	 0
  00046	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN19@Buynode@2:
$LN18@Buynode@2:
  0004b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Buynode@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Buynode@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Buynode@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Buynode<std::pair<unsigned short const ,ioHashString> >
PUBLIC	??$_Uninitialized_move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@@Z ; std::_Uninitialized_move<CKeyInfo::tagMecroTextInfo *,CKeyInfo::tagMecroTextInfo *,std::allocator<CKeyInfo::tagMecroTextInfo> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@@Z
_TEXT	SEGMENT
__Cat$522791 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@@Z PROC ; std::_Uninitialized_move<CKeyInfo::tagMecroTextInfo *,CKeyInfo::tagMecroTextInfo *,std::allocator<CKeyInfo::tagMecroTextInfo> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$522791[ebp]
  00007	6a 00		 push	 0
  00009	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000c	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000f	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00012	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00015	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@U12@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CKeyInfo::tagMecroTextInfo *,CKeyInfo::tagMecroTextInfo *,std::allocator<CKeyInfo::tagMecroTextInfo>,CKeyInfo::tagMecroTextInfo>
  0001a	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  0001d	c9		 leave
  0001e	c3		 ret	 0
??$_Uninitialized_move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@@Z ENDP ; std::_Uninitialized_move<CKeyInfo::tagMecroTextInfo *,CKeyInfo::tagMecroTextInfo *,std::allocator<CKeyInfo::tagMecroTextInfo> >
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??_GCJoyKeyInfo@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCJoyKeyInfo@@UAEPAXI@Z PROC				; CJoyKeyInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CJoyKeyInfo@@UAE@XZ	; CJoyKeyInfo::~CJoyKeyInfo
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 07		 je	 SHORT $LN1@scalar@4
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	59		 pop	 ecx
$LN1@scalar@4:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??_GCJoyKeyInfo@@UAEPAXI@Z ENDP				; CJoyKeyInfo::`scalar deleting destructor'
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??_GCDefaultJoyKeyInfo@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCDefaultJoyKeyInfo@@UAEPAXI@Z PROC			; CDefaultJoyKeyInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CDefaultJoyKeyInfo@@6B@
  0000c	e8 00 00 00 00	 call	 ??1CJoyKeyInfo@@UAE@XZ	; CJoyKeyInfo::~CJoyKeyInfo
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 07		 je	 SHORT $LN1@scalar@5
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	59		 pop	 ecx
$LN1@scalar@5:
  0001e	8b c6		 mov	 eax, esi
  00020	5e		 pop	 esi
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??_GCDefaultJoyKeyInfo@@UAEPAXI@Z ENDP			; CDefaultJoyKeyInfo::`scalar deleting destructor'
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??_GCCustomJoyKeyInfo@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCCustomJoyKeyInfo@@UAEPAXI@Z PROC			; CCustomJoyKeyInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CCustomJoyKeyInfo@@6B@
  0000c	e8 00 00 00 00	 call	 ??1CJoyKeyInfo@@UAE@XZ	; CJoyKeyInfo::~CJoyKeyInfo
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 07		 je	 SHORT $LN1@scalar@6
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	59		 pop	 ecx
$LN1@scalar@6:
  0001e	8b c6		 mov	 eax, esi
  00020	5e		 pop	 esi
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??_GCCustomJoyKeyInfo@@UAEPAXI@Z ENDP			; CCustomJoyKeyInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::clear
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::clear, COMDAT
; _this$ = ecx

; 1410 : 		{	// erase all

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		this->_Orphan_ptr(*this, 0);
; 1413 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1414 : 
; 1415 : 		_Erase(_Root());

  00004	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00007	ff 70 04	 push	 DWORD PTR [eax+4]
  0000a	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Erase

; 1416 : 		_Root() = this->_Myhead;

  0000f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00012	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1417 : 		_Lmost() = this->_Myhead;

  00015	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00018	89 00		 mov	 DWORD PTR [eax], eax

; 1418 : 		_Rmost() = this->_Myhead;

  0001a	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  0001d	89 76 08	 mov	 DWORD PTR [esi+8], esi

; 1419 : 		this->_Mysize = 0;

  00020	83 67 08 00	 and	 DWORD PTR [edi+8], 0
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi

; 1420 : 		}

  00026	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::clear
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IAEXPAUtagMecroTextInfo@CKeyInfo@@0@Z ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Destroy
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IAEXPAUtagMecroTextInfo@CKeyInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IAEXPAUtagMecroTextInfo@CKeyInfo@@0@Z PROC ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	51		 push	 ecx
  00007	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@0AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CKeyInfo::tagMecroTextInfo> >
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?_Destroy@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IAEXPAUtagMecroTextInfo@CKeyInfo@@0@Z ENDP ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IAEXXZ ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Tidy
; Function compile flags: /Ogsp
;	COMDAT ?_Tidy@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00006	74 1e		 je	 SHORT $LN6@Tidy@2

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0000e	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00011	50		 push	 eax
  00012	ff 76 04	 push	 DWORD PTR [esi+4]
  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@0AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CKeyInfo::tagMecroTextInfo> >

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  0001c	ff 36		 push	 DWORD PTR [esi]
  0001e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00023	83 c4 10	 add	 esp, 16			; 00000010H
$LN6@Tidy@2:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00026	83 26 00	 and	 DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

  00029	83 66 04 00	 and	 DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

  0002d	83 66 08 00	 and	 DWORD PTR [esi+8], 0
  00031	5e		 pop	 esi

; 1312 : 		}

  00032	c3		 ret	 0
?_Tidy@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::erase
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T522866 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::erase, COMDAT
; _this$ = ecx

; 1379 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 1380 : 		if (_First == begin() && _Last == end())

  00007	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  0000d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000f	75 13		 jne	 SHORT $LN65@erase@3
  00011	39 45 10	 cmp	 DWORD PTR __Last$[ebp], eax
  00014	75 0e		 jne	 SHORT $LN65@erase@3

; 1381 : 			{	// erase all
; 1382 : 			clear();

  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::clear

; 1383 : 			return (begin());

  0001d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00020	8b 08		 mov	 ecx, DWORD PTR [eax]
  00022	eb 25		 jmp	 SHORT $LN1@erase@3
$LN65@erase@3:

; 1384 : 			}
; 1385 : 		else
; 1386 : 			{	// partial erase, one at a time
; 1387 : 			while (_First != _Last)

  00024	3b 4d 10	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00027	74 20		 je	 SHORT $LN1@erase@3
  00029	57		 push	 edi
$LL2@erase@3:

; 1388 : 				erase(_First++);

  0002a	8b f9		 mov	 edi, ecx
  0002c	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0002f	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >,std::_Iterator_base0>::operator++
  00034	57		 push	 edi
  00035	8d 45 fc	 lea	 eax, DWORD PTR $T522866[ebp]
  00038	50		 push	 eax
  00039	8b ce		 mov	 ecx, esi
  0003b	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::erase
  00040	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00043	3b 4d 10	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00046	75 e2		 jne	 SHORT $LL2@erase@3
  00048	5f		 pop	 edi
$LN1@erase@3:

; 1389 : 			return (iterator(_First._Ptr, this));

  00049	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
  0004e	5e		 pop	 esi

; 1390 : 			}
; 1391 : 		}

  0004f	c9		 leave
  00050	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::erase
_TEXT	ENDS
PUBLIC	??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
; Function compile flags: /Ogsp
;	COMDAT ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >, COMDAT
; _this$ = ecx

; 753  : 		_Pairib insert(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 754  : 		{	// try to insert node with value _Val, favoring right side
; 755  : 		return (_Linsert(this->_Buynode(_STD forward<_Valty>(_Val)),
; 756  : 			false));

  00004	6a 00		 push	 0
  00006	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Buynode<std::pair<unsigned short const ,ioHashString> >
  00010	50		 push	 eax
  00011	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00014	8b ce		 mov	 ecx, esi
  00016	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Linsert
  0001b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001e	5e		 pop	 esi

; 757  : 		}

  0001f	5d		 pop	 ebp
  00020	c2 08 00	 ret	 8
??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAUtagMecroTextInfo@CKeyInfo@@@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IAEPAUtagMecroTextInfo@CKeyInfo@@PAU23@00@Z ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Umove<CKeyInfo::tagMecroTextInfo *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAUtagMecroTextInfo@CKeyInfo@@@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IAEPAUtagMecroTextInfo@CKeyInfo@@PAU23@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUtagMecroTextInfo@CKeyInfo@@@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IAEPAUtagMecroTextInfo@CKeyInfo@@PAU23@00@Z PROC ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Umove<CKeyInfo::tagMecroTextInfo *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	51		 push	 ecx
  00007	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@@Z ; std::_Uninitialized_move<CKeyInfo::tagMecroTextInfo *,CKeyInfo::tagMecroTextInfo *,std::allocator<CKeyInfo::tagMecroTextInfo> >
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00018	5d		 pop	 ebp
  00019	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUtagMecroTextInfo@CKeyInfo@@@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IAEPAUtagMecroTextInfo@CKeyInfo@@PAU23@00@Z ENDP ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Umove<CKeyInfo::tagMecroTextInfo *>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?Load@ioKeyManager@@QAEXXZ			; ioKeyManager::Load
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iokeymanager.cpp
xdata$x	SEGMENT
__ehfuncinfo$?Load@ioKeyManager@@QAEXXZ DD 019930522H
	DD	099H
	DD	FLAT:__unwindtable$?Load@ioKeyManager@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Load@ioKeyManager@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$3
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$4
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$5
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$6
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$7
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$8
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$9
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$10
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$11
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$12
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$13
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$14
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$15
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$16
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$17
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$18
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$19
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$20
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$21
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$22
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$23
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$24
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$25
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$26
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$27
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$28
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$29
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$30
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$31
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$32
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$33
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$34
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$35
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$36
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$37
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$38
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$39
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$40
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$41
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$42
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$43
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$44
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$45
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$46
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$47
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$48
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$49
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$50
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$51
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$52
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$53
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$54
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$55
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$56
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$57
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$58
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$59
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$60
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$61
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$62
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$63
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$64
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$65
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$66
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$67
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$68
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$69
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$70
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$71
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$72
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$73
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$74
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$75
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$76
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$77
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$78
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$79
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$80
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$81
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$82
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$83
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$84
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$85
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$86
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$87
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$88
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$89
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$90
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$91
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$92
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$93
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$94
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$95
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$96
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$97
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$98
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$99
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$100
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$101
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$102
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$103
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$104
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$105
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$106
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$107
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$108
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$109
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$110
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$111
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$112
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$113
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$114
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$115
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$116
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$117
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$118
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$119
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$120
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$121
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$122
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$123
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$124
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$125
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$126
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$127
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$128
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$129
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$130
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$131
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$132
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$133
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$134
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$135
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$136
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$137
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$138
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$139
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$140
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$141
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$142
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$143
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$144
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$145
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$146
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$147
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$148
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$149
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$150
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$151
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$152
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ?Load@ioKeyManager@@QAEXXZ
_TEXT	SEGMENT
$T523145 = -6684					; size = 20
$T523325 = -6664					; size = 20
$T523142 = -6644					; size = 20
$T523229 = -6624					; size = 20
$T523514 = -6604					; size = 20
$T523277 = -6584					; size = 20
$T523511 = -6564					; size = 20
$T523181 = -6544					; size = 20
$T523508 = -6524					; size = 20
$T523301 = -6504					; size = 20
$T523505 = -6484					; size = 20
$T523253 = -6464					; size = 20
$T523502 = -6444					; size = 20
$T523205 = -6424					; size = 20
$T523499 = -6404					; size = 20
$T523157 = -6384					; size = 20
$T523496 = -6364					; size = 20
$T523313 = -6344					; size = 20
$T523493 = -6324					; size = 20
$T523289 = -6304					; size = 20
$T523490 = -6284					; size = 20
$T523265 = -6264					; size = 20
$T523487 = -6244					; size = 20
$T523241 = -6224					; size = 20
$T523484 = -6204					; size = 20
$T523217 = -6184					; size = 20
$T523481 = -6164					; size = 20
$T523193 = -6144					; size = 20
$T523478 = -6124					; size = 20
$T523169 = -6104					; size = 20
$T523475 = -6084					; size = 20
$T523331 = -6064					; size = 20
$T523472 = -6044					; size = 20
$T523319 = -6024					; size = 20
$T523469 = -6004					; size = 20
$T523307 = -5984					; size = 20
$T523466 = -5964					; size = 20
$T523139 = -5944					; size = 20
$T523463 = -5924					; size = 20
$T523283 = -5904					; size = 20
$T523460 = -5884					; size = 20
$T523271 = -5864					; size = 20
$T523457 = -5844					; size = 20
$T523259 = -5824					; size = 20
$T523454 = -5804					; size = 20
$T523247 = -5784					; size = 20
$T523451 = -5764					; size = 20
$T523235 = -5744					; size = 20
$T523448 = -5724					; size = 20
$T523223 = -5704					; size = 20
$T523445 = -5684					; size = 20
$T523211 = -5664					; size = 20
$T523442 = -5644					; size = 20
$T523199 = -5624					; size = 20
$T523439 = -5604					; size = 20
$T523187 = -5584					; size = 20
$T523436 = -5564					; size = 20
$T523175 = -5544					; size = 20
$T523433 = -5524					; size = 20
$T523163 = -5504					; size = 20
$T523430 = -5484					; size = 20
$T523151 = -5464					; size = 20
$T523427 = -5444					; size = 20
$T523328 = -5424					; size = 20
$T523424 = -5404					; size = 20
$T523322 = -5384					; size = 20
$T523421 = -5364					; size = 20
$T523316 = -5344					; size = 20
$T523418 = -5324					; size = 20
$T523310 = -5304					; size = 20
$T523415 = -5284					; size = 20
$T523304 = -5264					; size = 20
$T523412 = -5244					; size = 20
$T523298 = -5224					; size = 20
$T523409 = -5204					; size = 20
$T523292 = -5184					; size = 20
$T523406 = -5164					; size = 20
$T523286 = -5144					; size = 20
$T523403 = -5124					; size = 20
$T523280 = -5104					; size = 20
$T523400 = -5084					; size = 20
$T523274 = -5064					; size = 20
$T523397 = -5044					; size = 20
$T523268 = -5024					; size = 20
$T523394 = -5004					; size = 20
$T523262 = -4984					; size = 20
$T523391 = -4964					; size = 20
$T523256 = -4944					; size = 20
$T523388 = -4924					; size = 20
$T523250 = -4904					; size = 20
$T523385 = -4884					; size = 20
$T523244 = -4864					; size = 20
$T523382 = -4844					; size = 20
$T523238 = -4824					; size = 20
$T523379 = -4804					; size = 20
$T523232 = -4784					; size = 20
$T523376 = -4764					; size = 20
$T523226 = -4744					; size = 20
$T523373 = -4724					; size = 20
$T523220 = -4704					; size = 20
$T523370 = -4684					; size = 20
$T523214 = -4664					; size = 20
$T523367 = -4644					; size = 20
$T523208 = -4624					; size = 20
$T523364 = -4604					; size = 20
$T523202 = -4584					; size = 20
$T523361 = -4564					; size = 20
$T523196 = -4544					; size = 20
$T523358 = -4524					; size = 20
$T523190 = -4504					; size = 20
$T523355 = -4484					; size = 20
$T523184 = -4464					; size = 20
$T523352 = -4444					; size = 20
$T523178 = -4424					; size = 20
$T523349 = -4404					; size = 20
$T523172 = -4384					; size = 20
$T523346 = -4364					; size = 20
$T523166 = -4344					; size = 20
$T523343 = -4324					; size = 20
$T523160 = -4304					; size = 20
$T523340 = -4284					; size = 20
$T523154 = -4264					; size = 20
$T523337 = -4244					; size = 20
$T523148 = -4224					; size = 20
$T523334 = -4204					; size = 20
$T523295 = -4184					; size = 20
$T523064 = -4164					; size = 20
$T523091 = -4144					; size = 20
$T523070 = -4124					; size = 20
$T523103 = -4104					; size = 20
$T523136 = -4084					; size = 20
$T523079 = -4064					; size = 20
$T523133 = -4044					; size = 20
$T523097 = -4024					; size = 20
$T523130 = -4004					; size = 20
$T523061 = -3984					; size = 20
$T523127 = -3964					; size = 20
$T523073 = -3944					; size = 20
$T523124 = -3924					; size = 20
$T523100 = -3904					; size = 20
$T523121 = -3884					; size = 20
$T523094 = -3864					; size = 20
$T523118 = -3844					; size = 20
$T523088 = -3824					; size = 20
$T523115 = -3804					; size = 20
$T523082 = -3784					; size = 20
$T523112 = -3764					; size = 20
$T523076 = -3744					; size = 20
$T523109 = -3724					; size = 20
$T523067 = -3704					; size = 20
$T523106 = -3684					; size = 20
$T523085 = -3664					; size = 20
tv115978 = -3644					; size = 4
$T523516 = -3640					; size = 8
$T523513 = -3640					; size = 8
$T523510 = -3640					; size = 8
$T523507 = -3640					; size = 8
$T523504 = -3640					; size = 8
$T523501 = -3640					; size = 8
$T523498 = -3640					; size = 8
$T523495 = -3640					; size = 8
$T523492 = -3640					; size = 8
$T523489 = -3640					; size = 8
$T523486 = -3640					; size = 8
$T523483 = -3640					; size = 8
$T523480 = -3640					; size = 8
$T523477 = -3640					; size = 8
$T523474 = -3640					; size = 8
$T523471 = -3640					; size = 8
$T523468 = -3640					; size = 8
$T523465 = -3640					; size = 8
$T523462 = -3640					; size = 8
$T523459 = -3640					; size = 8
$T523456 = -3640					; size = 8
$T523453 = -3640					; size = 8
$T523450 = -3640					; size = 8
$T523447 = -3640					; size = 8
$T523444 = -3640					; size = 8
$T523441 = -3640					; size = 8
$T523438 = -3640					; size = 8
$T523435 = -3640					; size = 8
$T523432 = -3640					; size = 8
$T523429 = -3640					; size = 8
$T523426 = -3640					; size = 8
$T523423 = -3640					; size = 8
$T523420 = -3640					; size = 8
$T523417 = -3640					; size = 8
$T523414 = -3640					; size = 8
$T523411 = -3640					; size = 8
$T523408 = -3640					; size = 8
$T523405 = -3640					; size = 8
$T523402 = -3640					; size = 8
$T523399 = -3640					; size = 8
$T523396 = -3640					; size = 8
$T523393 = -3640					; size = 8
$T523390 = -3640					; size = 8
$T523387 = -3640					; size = 8
$T523384 = -3640					; size = 8
$T523381 = -3640					; size = 8
$T523378 = -3640					; size = 8
$T523375 = -3640					; size = 8
$T523372 = -3640					; size = 8
$T523369 = -3640					; size = 8
$T523366 = -3640					; size = 8
$T523363 = -3640					; size = 8
$T523360 = -3640					; size = 8
$T523357 = -3640					; size = 8
$T523354 = -3640					; size = 8
$T523351 = -3640					; size = 8
$T523348 = -3640					; size = 8
$T523345 = -3640					; size = 8
$T523342 = -3640					; size = 8
$T523339 = -3640					; size = 8
$T523336 = -3640					; size = 8
$T523333 = -3640					; size = 8
$T523330 = -3640					; size = 8
$T523327 = -3640					; size = 8
$T523324 = -3640					; size = 8
$T523321 = -3640					; size = 8
$T523318 = -3640					; size = 8
$T523315 = -3640					; size = 8
$T523312 = -3640					; size = 8
$T523309 = -3640					; size = 8
$T523306 = -3640					; size = 8
$T523303 = -3640					; size = 8
$T523300 = -3640					; size = 8
$T523297 = -3640					; size = 8
$T523294 = -3640					; size = 8
$T523291 = -3640					; size = 8
$T523288 = -3640					; size = 8
$T523285 = -3640					; size = 8
$T523282 = -3640					; size = 8
$T523279 = -3640					; size = 8
$T523276 = -3640					; size = 8
$T523273 = -3640					; size = 8
$T523270 = -3640					; size = 8
$T523267 = -3640					; size = 8
$T523264 = -3640					; size = 8
$T523261 = -3640					; size = 8
$T523258 = -3640					; size = 8
$T523255 = -3640					; size = 8
$T523252 = -3640					; size = 8
$T523249 = -3640					; size = 8
$T523246 = -3640					; size = 8
$T523243 = -3640					; size = 8
$T523240 = -3640					; size = 8
$T523237 = -3640					; size = 8
$T523234 = -3640					; size = 8
$T523231 = -3640					; size = 8
$T523228 = -3640					; size = 8
$T523225 = -3640					; size = 8
$T523222 = -3640					; size = 8
$T523219 = -3640					; size = 8
$T523216 = -3640					; size = 8
$T523213 = -3640					; size = 8
$T523210 = -3640					; size = 8
$T523207 = -3640					; size = 8
$T523204 = -3640					; size = 8
$T523201 = -3640					; size = 8
$T523198 = -3640					; size = 8
$T523195 = -3640					; size = 8
$T523192 = -3640					; size = 8
$T523189 = -3640					; size = 8
$T523186 = -3640					; size = 8
$T523183 = -3640					; size = 8
$T523180 = -3640					; size = 8
$T523177 = -3640					; size = 8
$T523174 = -3640					; size = 8
$T523171 = -3640					; size = 8
$T523168 = -3640					; size = 8
$T523165 = -3640					; size = 8
$T523162 = -3640					; size = 8
$T523159 = -3640					; size = 8
$T523156 = -3640					; size = 8
$T523153 = -3640					; size = 8
$T523150 = -3640					; size = 8
$T523147 = -3640					; size = 8
$T523144 = -3640					; size = 8
$T523141 = -3640					; size = 8
$T523138 = -3640					; size = 8
$T523135 = -3640					; size = 8
$T523132 = -3640					; size = 8
$T523129 = -3640					; size = 8
$T523126 = -3640					; size = 8
$T523123 = -3640					; size = 8
$T523120 = -3640					; size = 8
$T523117 = -3640					; size = 8
$T523114 = -3640					; size = 8
$T523111 = -3640					; size = 8
$T523108 = -3640					; size = 8
$T523105 = -3640					; size = 8
$T523102 = -3640					; size = 8
$T523099 = -3640					; size = 8
$T523096 = -3640					; size = 8
$T523093 = -3640					; size = 8
$T523090 = -3640					; size = 8
$T523087 = -3640					; size = 8
$T523084 = -3640					; size = 8
$T523081 = -3640					; size = 8
$T523078 = -3640					; size = 8
$T523075 = -3640					; size = 8
$T523072 = -3640					; size = 8
$T523069 = -3640					; size = 8
$T523066 = -3640					; size = 8
$T523063 = -3640					; size = 8
$T523515 = -3636					; size = 4
$T523512 = -3636					; size = 4
$T523509 = -3636					; size = 4
$T523506 = -3636					; size = 4
$T523503 = -3636					; size = 4
$T523500 = -3636					; size = 4
$T523497 = -3636					; size = 4
$T523494 = -3636					; size = 4
$T523491 = -3636					; size = 4
$T523488 = -3636					; size = 4
$T523485 = -3636					; size = 4
$T523482 = -3636					; size = 4
$T523479 = -3636					; size = 4
$T523476 = -3636					; size = 4
$T523473 = -3636					; size = 4
$T523470 = -3636					; size = 4
$T523467 = -3636					; size = 4
$T523464 = -3636					; size = 4
$T523461 = -3636					; size = 4
$T523458 = -3636					; size = 4
$T523455 = -3636					; size = 4
$T523452 = -3636					; size = 4
$T523449 = -3636					; size = 4
$T523446 = -3636					; size = 4
$T523443 = -3636					; size = 4
$T523440 = -3636					; size = 4
$T523437 = -3636					; size = 4
$T523434 = -3636					; size = 4
$T523431 = -3636					; size = 4
$T523428 = -3636					; size = 4
$T523425 = -3636					; size = 4
$T523422 = -3636					; size = 4
$T523419 = -3636					; size = 4
$T523416 = -3636					; size = 4
$T523413 = -3636					; size = 4
$T523410 = -3636					; size = 4
$T523407 = -3636					; size = 4
$T523404 = -3636					; size = 4
$T523401 = -3636					; size = 4
$T523398 = -3636					; size = 4
$T523395 = -3636					; size = 4
$T523392 = -3636					; size = 4
$T523389 = -3636					; size = 4
$T523386 = -3636					; size = 4
$T523383 = -3636					; size = 4
$T523380 = -3636					; size = 4
$T523377 = -3636					; size = 4
$T523374 = -3636					; size = 4
$T523371 = -3636					; size = 4
$T523368 = -3636					; size = 4
$T523365 = -3636					; size = 4
$T523362 = -3636					; size = 4
$T523359 = -3636					; size = 4
$T523356 = -3636					; size = 4
$T523353 = -3636					; size = 4
$T523350 = -3636					; size = 4
$T523347 = -3636					; size = 4
$T523344 = -3636					; size = 4
$T523341 = -3636					; size = 4
$T523338 = -3636					; size = 4
$T523335 = -3636					; size = 4
$T523332 = -3636					; size = 4
$T523329 = -3636					; size = 4
$T523326 = -3636					; size = 4
$T523323 = -3636					; size = 4
$T523320 = -3636					; size = 4
$T523317 = -3636					; size = 4
$T523314 = -3636					; size = 4
$T523311 = -3636					; size = 4
$T523308 = -3636					; size = 4
$T523305 = -3636					; size = 4
$T523302 = -3636					; size = 4
$T523299 = -3636					; size = 4
$T523296 = -3636					; size = 4
$T523293 = -3636					; size = 4
$T523290 = -3636					; size = 4
$T523287 = -3636					; size = 4
$T523284 = -3636					; size = 4
$T523281 = -3636					; size = 4
$T523278 = -3636					; size = 4
$T523275 = -3636					; size = 4
$T523272 = -3636					; size = 4
$T523269 = -3636					; size = 4
$T523266 = -3636					; size = 4
$T523263 = -3636					; size = 4
$T523260 = -3636					; size = 4
$T523257 = -3636					; size = 4
$T523254 = -3636					; size = 4
$T523251 = -3636					; size = 4
$T523248 = -3636					; size = 4
$T523245 = -3636					; size = 4
$T523242 = -3636					; size = 4
$T523239 = -3636					; size = 4
$T523236 = -3636					; size = 4
$T523233 = -3636					; size = 4
$T523230 = -3636					; size = 4
$T523227 = -3636					; size = 4
$T523224 = -3636					; size = 4
$T523221 = -3636					; size = 4
$T523218 = -3636					; size = 4
$T523215 = -3636					; size = 4
$T523212 = -3636					; size = 4
$T523209 = -3636					; size = 4
$T523206 = -3636					; size = 4
$T523203 = -3636					; size = 4
$T523200 = -3636					; size = 4
$T523197 = -3636					; size = 4
$T523194 = -3636					; size = 4
$T523191 = -3636					; size = 4
$T523188 = -3636					; size = 4
$T523185 = -3636					; size = 4
$T523182 = -3636					; size = 4
$T523179 = -3636					; size = 4
$T523176 = -3636					; size = 4
$T523173 = -3636					; size = 4
$T523170 = -3636					; size = 4
$T523167 = -3636					; size = 4
$T523164 = -3636					; size = 4
$T523161 = -3636					; size = 4
$T523158 = -3636					; size = 4
$T523155 = -3636					; size = 4
$T523152 = -3636					; size = 4
$T523149 = -3636					; size = 4
$T523146 = -3636					; size = 4
$T523143 = -3636					; size = 4
$T523140 = -3636					; size = 4
_kLoader$ = -3632					; size = 912
__k$538087 = -2720					; size = 9
__k$538492 = -2704					; size = 9
__t$523933 = -2688					; size = 9
__k$539842 = -2672					; size = 9
__k$526981 = -2656					; size = 9
__k$540112 = -2640					; size = 9
__k$526643 = -2624					; size = 9
__k$539572 = -2608					; size = 9
__k$524953 = -2592					; size = 9
__k$540247 = -2576					; size = 9
__k$541597 = -2560					; size = 9
__k$539977 = -2544					; size = 9
__k$541462 = -2528					; size = 9
__k$539707 = -2512					; size = 9
__k$540652 = -2496					; size = 9
__k$539437 = -2480					; size = 9
__k$540517 = -2464					; size = 9
__k$538357 = -2448					; size = 9
__k$540382 = -2432					; size = 9
__k$534307 = -2416					; size = 9
__k$539167 = -2400					; size = 13
__k$543487 = -2380					; size = 13
__k$538910 = -2360					; size = 13
__k$544040 = -2340					; size = 13
__k$538629 = -2320					; size = 13
__k$544297 = -2300					; size = 13
__k$535522 = -2280					; size = 13
__k$543768 = -2260					; size = 13
__k$542542 = -2240					; size = 13
__k$543095 = -2220					; size = 13
__k$535117 = -2200					; size = 13
__k$544175 = -2180					; size = 13
__k$530122 = -2160					; size = 13
__k$543905 = -2140					; size = 13
__k$529865 = -2120					; size = 13
__k$543622 = -2100					; size = 13
__k$529312 = -2080					; size = 13
__k$526487 = -2060					; size = 13
__k$545120 = -2040					; size = 13
__k$540935 = -2020					; size = 13
__k$544432 = -2000					; size = 13
__k$543352 = -1980					; size = 13
__k$532147 = -1960					; size = 6
__k$532417 = -1948					; size = 6
__k$532025 = -1936					; size = 6
__k$531337 = -1924					; size = 6
__k$531890 = -1912					; size = 6
__k$533915 = -1900					; size = 6
__k$531755 = -1888					; size = 6
__k$532970 = -1876					; size = 6
__k$531202 = -1864					; size = 6
__k$527501 = -1852					; size = 6
__k$531067 = -1840					; size = 6
__k$533645 = -1828					; size = 6
__k$530945 = -1816					; size = 6
__k$533227 = -1804					; size = 6
__k$530810 = -1792					; size = 6
__k$532700 = -1780					; size = 6
__k$532282 = -1768					; size = 6
__k$527670 = -1756					; size = 6
__k$530675 = -1744					; size = 6
__k$534050 = -1732					; size = 6
__k$528920 = -1720					; size = 6
__k$533780 = -1708					; size = 6
__k$528785 = -1696					; size = 6
__k$533497 = -1684					; size = 6
__k$528650 = -1672					; size = 6
__k$533362 = -1660					; size = 6
__k$528515 = -1648					; size = 6
__k$533102 = -1636					; size = 6
__k$528333 = -1624					; size = 6
__k$532835 = -1612					; size = 6
__k$528164 = -1600					; size = 6
__k$532565 = -1588					; size = 6
__k$527995 = -1576					; size = 6
__k$531485 = -1564					; size = 6
__k$527839 = -1552					; size = 6
__k$531620 = -1540					; size = 6
__k$542015 = -1528					; size = 16
__k$535387 = -1508					; size = 12
__k$529595 = -1492					; size = 16
__k$529730 = -1472					; size = 10
__k$543217 = -1456					; size = 15
__k$526307 = -1436					; size = 11
__k$542825 = -1420					; size = 15
__k$540800 = -1400					; size = 12
__k$542677 = -1384					; size = 15
__k$534187 = -1364					; size = 11
__k$542272 = -1348					; size = 15
__k$545255 = -1328					; size = 10
__k$542137 = -1312					; size = 15
__k$525291 = -1292					; size = 10
__k$541880 = -1276					; size = 15
__k$538775 = -1256					; size = 12
__k$541057 = -1240					; size = 15
__k$534727 = -1220					; size = 11
__k$535805 = -1204					; size = 15
__k$529462 = -1184					; size = 11
__k$534982 = -1168					; size = 15
__k$525137 = -1148					; size = 11
__k$530392 = -1132					; size = 15
__k$534590 = -1112					; size = 10
__k$525967 = -1096					; size = 15
__k$527319 = -1076					; size = 10
__k$544850 = -1060					; size = 14
__k$524429 = -1040					; size = 10
__k$544702 = -1024					; size = 14
__k$539032 = -1004					; size = 12
__k$544567 = -988					; size = 14
__k$535927 = -968					; size = 12
__k$541745 = -952					; size = 14
__k$525629 = -932					; size = 12
__k$541192 = -916					; size = 14
__k$534444 = -896					; size = 11
__k$539302 = -880					; size = 14
__k$530272 = -860					; size = 11
__k$536062 = -844					; size = 14
__k$527165 = -824					; size = 11
__k$535670 = -808					; size = 14
__k$526151 = -788					; size = 11
__k$535252 = -772					; size = 14
__k$524610 = -752					; size = 11
__k$534860 = -736					; size = 14
__k$541340 = -716					; size = 10
__k$529987 = -700					; size = 14
__k$530540 = -680					; size = 10
__k$529177 = -664					; size = 14
__k$529055 = -644					; size = 10
__k$525798 = -628					; size = 14
__k$526825 = -608					; size = 10
__k$524058 = -592					; size = 14
__k$524787 = -572					; size = 10
__k$545377 = -556					; size = 12
__k$542420 = -540					; size = 16
__k$544972 = -520					; size = 12
__k$525475 = -504					; size = 11
__k$542960 = -488					; size = 16
__k$538222 = -468					; size = 8
__k$537412 = -456					; size = 8
__k$537965 = -444					; size = 8
__k$537547 = -432					; size = 8
__k$537830 = -420					; size = 8
__k$537695 = -408					; size = 8
__k$524237 = -396					; size = 8
__k$536489 = -384					; size = 7
__k$536630 = -372					; size = 7
__k$536225 = -360					; size = 7
__k$536765 = -348					; size = 7
__k$537035 = -336					; size = 7
__k$536900 = -324					; size = 7
__k$536360 = -312					; size = 7
__k$537305 = -300					; size = 7
__k$537170 = -288					; size = 7
_szKeyText$ = -276					; size = 260
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Load@ioKeyManager@@QAEXXZ PROC				; ioKeyManager::Load, COMDAT
; _this$ = ecx

; 989  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Load@ioKeyManager@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 10 1a 00 00	 mov	 eax, 6672		; 00001a10H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00032	8b f1		 mov	 esi, ecx

; 990  : 	m_DefaultKeyInfo.Load();

  00034	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00037	8b 01		 mov	 eax, DWORD PTR [ecx]
  00039	ff 50 0c	 call	 DWORD PTR [eax+12]

; 991  : 	m_CustomKeyInfo.Load( m_kServerKeys );

  0003c	8d 4e 2c	 lea	 ecx, DWORD PTR [esi+44]
  0003f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00041	8d be 99 00 00
	00		 lea	 edi, DWORD PTR [esi+153]
  00047	57		 push	 edi
  00048	ff 50 0c	 call	 DWORD PTR [eax+12]

; 992  : 
; 993  : 	m_DefaultJoyKeyInfo.Load();

  0004b	8d 4e 54	 lea	 ecx, DWORD PTR [esi+84]
  0004e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00050	ff 50 08	 call	 DWORD PTR [eax+8]

; 994  : 	m_CustomJoyKeyInfo.Load();

  00053	8d 4e 6c	 lea	 ecx, DWORD PTR [esi+108]
  00056	8b 01		 mov	 eax, DWORD PTR [ecx]
  00058	ff 50 08	 call	 DWORD PTR [eax+8]

; 995  : 
; 996  : 	if( m_CustomKeyInfo.IsUseKeys() )

  0005b	8a 46 50	 mov	 al, BYTE PTR [esi+80]
  0005e	84 c0		 test	 al, al
  00060	0f 95 c0	 setne	 al
  00063	88 86 94 00 00
	00		 mov	 BYTE PTR [esi+148], al

; 997  : 		m_bUseCustom = true;
; 998  : 	else
; 999  : 		m_bUseCustom = false;
; 1000 : 
; 1001 : 	if( m_CustomJoyKeyInfo.IsUseKeys() )

  00069	80 be 80 00 00
	00 00		 cmp	 BYTE PTR [esi+128], 0

; 1002 : 		m_bUseJoyCustom = true;
; 1003 : 	else
; 1004 : 		m_bUseJoyCustom = false;
; 1005 : 
; 1006 : 	if( m_kServerKeys.IsRight() && m_CustomKeyInfo.IsAutoFix() )

  00070	8b cf		 mov	 ecx, edi
  00072	0f 95 c0	 setne	 al
  00075	88 86 96 00 00
	00		 mov	 BYTE PTR [esi+150], al
  0007b	e8 00 00 00 00	 call	 ?IsRight@ControlKeys@@QBE_NXZ ; ControlKeys::IsRight
  00080	84 c0		 test	 al, al
  00082	74 0d		 je	 SHORT $LN1@Load@4
  00084	80 7e 51 00	 cmp	 BYTE PTR [esi+81], 0
  00088	74 07		 je	 SHORT $LN1@Load@4

; 1007 : 		SendKey();

  0008a	8b ce		 mov	 ecx, esi
  0008c	e8 00 00 00 00	 call	 ?SendKey@ioKeyManager@@AAEXXZ ; ioKeyManager::SendKey
$LN1@Load@4:

; 1008 : 
; 1009 : 	//  
; 1010 : 	m_KeyTextMap.clear();

  00091	8d 8e 84 00 00
	00		 lea	 ecx, DWORD PTR [esi+132]
  00097	89 8d c4 f1 ff
	ff		 mov	 DWORD PTR tv115978[ebp], ecx
  0009d	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::clear

; 1011 : 	char szKeyText[MAX_PATH] = "";

  000a2	68 03 01 00 00	 push	 259			; 00000103H
  000a7	8d 85 ed fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp+1]
  000ad	6a 00		 push	 0
  000af	50		 push	 eax
  000b0	c6 85 ec fe ff
	ff 00		 mov	 BYTE PTR _szKeyText$[ebp], 0
  000b7	e8 00 00 00 00	 call	 _memset
  000bc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bf	6a 05		 push	 5

; 1012 : 	ioINILoader_e kLoader( "config/sp2_key_text.ini" );

  000c1	c7 85 20 f5 ff
	ff 8e 83 85 8c	 mov	 DWORD PTR _kLoader$[ebp+848], -1937407090 ; 8c85838eH
  000cb	c7 85 24 f5 ff
	ff 84 8b c4 99	 mov	 DWORD PTR _kLoader$[ebp+852], -1715172476 ; 99c48b84H
  000d5	c7 85 28 f5 ff
	ff 9d de b4 81	 mov	 DWORD PTR _kLoader$[ebp+856], -2118852963 ; 81b4de9dH
  000df	c7 85 2c f5 ff
	ff 88 95 b4 9e	 mov	 DWORD PTR _kLoader$[ebp+860], -1632332408 ; 9eb49588H
  000e9	c7 85 30 f5 ff
	ff 88 94 9f c4	 mov	 DWORD PTR _kLoader$[ebp+864], -996174712 ; c49f9488H
  000f3	8d 85 20 f5 ff
	ff		 lea	 eax, DWORD PTR _kLoader$[ebp+848]
  000f9	c7 85 34 f5 ff
	ff 84 82 82 00	 mov	 DWORD PTR _kLoader$[ebp+868], 8553092 ; 00828284H
  00103	59		 pop	 ecx
  00104	be ed ec eb ea	 mov	 esi, -353637139		; eaebecedH
$LL273@Load@4:
  00109	31 30		 xor	 DWORD PTR [eax], esi
  0010b	83 c0 04	 add	 eax, 4
  0010e	49		 dec	 ecx
  0010f	75 f8		 jne	 SHORT $LL273@Load@4
  00111	6a 14		 push	 20			; 00000014H
  00113	58		 pop	 eax
$LL270@Load@4:
  00114	8b c8		 mov	 ecx, eax
  00116	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0011c	79 05		 jns	 SHORT $LN18410@Load@4
  0011e	49		 dec	 ecx
  0011f	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00122	41		 inc	 ecx
$LN18410@Load@4:
  00123	b2 ed		 mov	 dl, -19			; ffffffedH
  00125	2a d1		 sub	 dl, cl
  00127	30 94 05 20 f5
	ff ff		 xor	 BYTE PTR _kLoader$[ebp+eax+848], dl
  0012e	40		 inc	 eax
  0012f	83 f8 17	 cmp	 eax, 23			; 00000017H
  00132	7c e0		 jl	 SHORT $LL270@Load@4
  00134	6a 01		 push	 1
  00136	8d 85 20 f5 ff
	ff		 lea	 eax, DWORD PTR _kLoader$[ebp+848]
  0013c	50		 push	 eax
  0013d	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00143	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioINILoader@@QAE@PBD_N@Z
  00149	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0014d	6a 02		 push	 2

; 1013 : 	kLoader.SetTitle_e( "key_text" );

  0014f	c7 85 80 f5 ff
	ff 86 89 92 b5	 mov	 DWORD PTR __t$523933[ebp], -1248687738 ; b5928986H
  00159	c7 85 84 f5 ff
	ff 99 89 93 9e	 mov	 DWORD PTR __t$523933[ebp+4], -1634498151 ; 9e938999H
  00163	8d 85 80 f5 ff
	ff		 lea	 eax, DWORD PTR __t$523933[ebp]
  00169	c6 85 88 f5 ff
	ff 00		 mov	 BYTE PTR __t$523933[ebp+8], 0
  00170	59		 pop	 ecx
$LL379@Load@4:
  00171	31 30		 xor	 DWORD PTR [eax], esi
  00173	83 c0 04	 add	 eax, 4
  00176	49		 dec	 ecx
  00177	75 f8		 jne	 SHORT $LL379@Load@4
  00179	8d 85 80 f5 ff
	ff		 lea	 eax, DWORD PTR __t$523933[ebp]
  0017f	50		 push	 eax
  00180	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00186	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z
  0018c	6a 03		 push	 3

; 1014 : 
; 1015 : 	kLoader.LoadString_e( "KEY_BACKSPACE", "", szKeyText, MAX_PATH );

  0018e	c7 85 b0 fd ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$524058[ebp], -1246582362 ; b5b2a9a6H
  00198	c7 85 b4 fd ff
	ff af ad a8 a1	 mov	 DWORD PTR __k$524058[ebp+4], -1582781009 ; a1a8adafH
  001a2	c7 85 b8 fd ff
	ff be bc aa a9	 mov	 DWORD PTR __k$524058[ebp+8], -1448428354 ; a9aabcbeH
  001ac	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR __k$524058[ebp]
  001b2	66 c7 85 bc fd
	ff ff a8 00	 mov	 WORD PTR __k$524058[ebp+12], 168 ; 000000a8H
  001bb	59		 pop	 ecx
$LL485@Load@4:
  001bc	31 30		 xor	 DWORD PTR [eax], esi
  001be	83 c0 04	 add	 eax, 4
  001c1	49		 dec	 ecx
  001c2	75 f8		 jne	 SHORT $LL485@Load@4
  001c4	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z
  001ca	80 b5 bc fd ff
	ff ed		 xor	 BYTE PTR __k$524058[ebp+12], -19 ; ffffffedH
  001d1	be 04 01 00 00	 mov	 esi, 260		; 00000104H
  001d6	56		 push	 esi
  001d7	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  001dd	50		 push	 eax
  001de	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  001e3	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR __k$524058[ebp]
  001e9	50		 push	 eax
  001ea	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  001f0	ff d7		 call	 edi

; 1016 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_BACKSPACE, szKeyText ) );

  001f2	6a 08		 push	 8
  001f4	58		 pop	 eax
  001f5	66 89 85 70 f0
	ff ff		 mov	 WORD PTR $T523061[ebp], ax
  001fc	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00202	50		 push	 eax
  00203	8d 8d 74 f0 ff
	ff		 lea	 ecx, DWORD PTR $T523061[ebp+4]
  00209	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  0020f	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  00215	6a 00		 push	 0
  00217	8d 85 70 f0 ff
	ff		 lea	 eax, DWORD PTR $T523061[ebp]
  0021d	50		 push	 eax
  0021e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00222	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Buynode<std::pair<unsigned short const ,ioHashString> >
  00227	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  0022d	50		 push	 eax
  0022e	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523063[ebp]
  00234	50		 push	 eax
  00235	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Linsert
  0023a	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00240	8d 8d 74 f0 ff
	ff		 lea	 ecx, DWORD PTR $T523061[ebp+4]
  00246	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0024a	ff d3		 call	 ebx

; 1017 : 
; 1018 : 	kLoader.LoadString_e( "KEY_TAB", "", szKeyText, MAX_PATH );

  0024c	6a 04		 push	 4
  0024e	c7 85 74 fe ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$524237[ebp], -1246582362 ; b5b2a9a6H
  00258	81 b5 74 fe ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$524237[ebp], -353637139 ; eaebecedH
  00262	c7 85 78 fe ff
	ff b9 ad a9 00	 mov	 DWORD PTR __k$524237[ebp+4], 11120057 ; 00a9adb9H
  0026c	58		 pop	 eax
$LL612@Load@4:
  0026d	8b c8		 mov	 ecx, eax
  0026f	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00275	79 05		 jns	 SHORT $LN18411@Load@4
  00277	49		 dec	 ecx
  00278	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0027b	41		 inc	 ecx
$LN18411@Load@4:
  0027c	b2 ed		 mov	 dl, -19			; ffffffedH
  0027e	2a d1		 sub	 dl, cl
  00280	30 94 05 74 fe
	ff ff		 xor	 BYTE PTR __k$524237[ebp+eax], dl
  00287	40		 inc	 eax
  00288	83 f8 07	 cmp	 eax, 7
  0028b	7c e0		 jl	 SHORT $LL612@Load@4
  0028d	56		 push	 esi
  0028e	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00294	50		 push	 eax
  00295	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0029a	8d 85 74 fe ff
	ff		 lea	 eax, DWORD PTR __k$524237[ebp]
  002a0	50		 push	 eax
  002a1	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  002a7	ff d7		 call	 edi

; 1019 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_TAB, szKeyText ) );

  002a9	6a 09		 push	 9
  002ab	58		 pop	 eax
  002ac	66 89 85 bc ef
	ff ff		 mov	 WORD PTR $T523064[ebp], ax
  002b3	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  002b9	50		 push	 eax
  002ba	8d 8d c0 ef ff
	ff		 lea	 ecx, DWORD PTR $T523064[ebp+4]
  002c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  002c6	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  002cc	6a 00		 push	 0
  002ce	8d 85 bc ef ff
	ff		 lea	 eax, DWORD PTR $T523064[ebp]
  002d4	50		 push	 eax
  002d5	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  002d9	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Buynode<std::pair<unsigned short const ,ioHashString> >
  002de	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  002e4	50		 push	 eax
  002e5	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523066[ebp]
  002eb	50		 push	 eax
  002ec	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Linsert
  002f1	8d 8d c0 ef ff
	ff		 lea	 ecx, DWORD PTR $T523064[ebp+4]
  002f7	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  002fb	ff d3		 call	 ebx
  002fd	6a 02		 push	 2

; 1020 : 
; 1021 : 	kLoader.LoadString_e( "KEY_ENTER", "", szKeyText, MAX_PATH );

  002ff	c7 85 f0 fb ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$524429[ebp], -1246582362 ; b5b2a9a6H
  00309	c7 85 f4 fb ff
	ff a8 a2 bf af	 mov	 DWORD PTR __k$524429[ebp+4], -1346395480 ; afbfa2a8H
  00313	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR __k$524429[ebp]
  00319	66 c7 85 f8 fb
	ff ff bf 00	 mov	 WORD PTR __k$524429[ebp+8], 191 ; 000000bfH
  00322	59		 pop	 ecx
$LL745@Load@4:
  00323	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00329	83 c0 04	 add	 eax, 4
  0032c	49		 dec	 ecx
  0032d	75 f4		 jne	 SHORT $LL745@Load@4
  0032f	80 b5 f8 fb ff
	ff ed		 xor	 BYTE PTR __k$524429[ebp+8], -19 ; ffffffedH
  00336	56		 push	 esi
  00337	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0033d	50		 push	 eax
  0033e	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00343	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR __k$524429[ebp]
  00349	50		 push	 eax
  0034a	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00350	ff d7		 call	 edi

; 1022 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_ENTER, szKeyText ) );

  00352	6a 0d		 push	 13			; 0000000dH
  00354	58		 pop	 eax
  00355	66 89 85 88 f1
	ff ff		 mov	 WORD PTR $T523067[ebp], ax
  0035c	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00362	50		 push	 eax
  00363	8d 8d 8c f1 ff
	ff		 lea	 ecx, DWORD PTR $T523067[ebp+4]
  00369	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  0036f	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  00375	6a 00		 push	 0
  00377	8d 85 88 f1 ff
	ff		 lea	 eax, DWORD PTR $T523067[ebp]
  0037d	50		 push	 eax
  0037e	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00382	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Buynode<std::pair<unsigned short const ,ioHashString> >
  00387	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  0038d	50		 push	 eax
  0038e	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523069[ebp]
  00394	50		 push	 eax
  00395	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Linsert
  0039a	8d 8d 8c f1 ff
	ff		 lea	 ecx, DWORD PTR $T523067[ebp+4]
  003a0	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  003a4	ff d3		 call	 ebx
  003a6	6a 02		 push	 2

; 1023 : 
; 1024 : 	kLoader.LoadString_e( "KEY_ESCAPE", "", szKeyText, MAX_PATH );

  003a8	c7 85 10 fd ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$524610[ebp], -1246582362 ; b5b2a9a6H
  003b2	c7 85 14 fd ff
	ff a8 bf a8 ab	 mov	 DWORD PTR __k$524610[ebp+4], -1415004248 ; aba8bfa8H
  003bc	66 c7 85 18 fd
	ff ff bd a9	 mov	 WORD PTR __k$524610[ebp+8], 43453 ; 0000a9bdH
  003c5	8d 85 10 fd ff
	ff		 lea	 eax, DWORD PTR __k$524610[ebp]
  003cb	c6 85 1a fd ff
	ff 00		 mov	 BYTE PTR __k$524610[ebp+10], 0
  003d2	59		 pop	 ecx
$LL875@Load@4:
  003d3	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  003d9	83 c0 04	 add	 eax, 4
  003dc	49		 dec	 ecx
  003dd	75 f4		 jne	 SHORT $LL875@Load@4
  003df	6a 08		 push	 8
  003e1	58		 pop	 eax
$LL872@Load@4:
  003e2	8b c8		 mov	 ecx, eax
  003e4	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  003ea	79 05		 jns	 SHORT $LN18412@Load@4
  003ec	49		 dec	 ecx
  003ed	83 c9 fc	 or	 ecx, -4			; fffffffcH
  003f0	41		 inc	 ecx
$LN18412@Load@4:
  003f1	b2 ed		 mov	 dl, -19			; ffffffedH
  003f3	2a d1		 sub	 dl, cl
  003f5	30 94 05 10 fd
	ff ff		 xor	 BYTE PTR __k$524610[ebp+eax], dl
  003fc	40		 inc	 eax
  003fd	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00400	7c e0		 jl	 SHORT $LL872@Load@4
  00402	56		 push	 esi
  00403	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00409	50		 push	 eax
  0040a	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0040f	8d 85 10 fd ff
	ff		 lea	 eax, DWORD PTR __k$524610[ebp]
  00415	50		 push	 eax
  00416	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0041c	ff d7		 call	 edi

; 1025 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_ESCAPE, szKeyText ) );

  0041e	6a 1b		 push	 27			; 0000001bH
  00420	58		 pop	 eax
  00421	66 89 85 e4 ef
	ff ff		 mov	 WORD PTR $T523070[ebp], ax
  00428	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0042e	50		 push	 eax
  0042f	8d 8d e8 ef ff
	ff		 lea	 ecx, DWORD PTR $T523070[ebp+4]
  00435	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  0043b	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  00441	6a 00		 push	 0
  00443	8d 85 e4 ef ff
	ff		 lea	 eax, DWORD PTR $T523070[ebp]
  00449	50		 push	 eax
  0044a	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0044e	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Buynode<std::pair<unsigned short const ,ioHashString> >
  00453	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  00459	50		 push	 eax
  0045a	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523072[ebp]
  00460	50		 push	 eax
  00461	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Linsert
  00466	8d 8d e8 ef ff
	ff		 lea	 ecx, DWORD PTR $T523070[ebp+4]
  0046c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00470	ff d3		 call	 ebx
  00472	6a 02		 push	 2

; 1026 : 
; 1027 : 	kLoader.LoadString_e( "KEY_SPACE", "", szKeyText, MAX_PATH );

  00474	c7 85 c4 fd ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$524787[ebp], -1246582362 ; b5b2a9a6H
  0047e	c7 85 c8 fd ff
	ff be bc aa a9	 mov	 DWORD PTR __k$524787[ebp+4], -1448428354 ; a9aabcbeH
  00488	8d 85 c4 fd ff
	ff		 lea	 eax, DWORD PTR __k$524787[ebp]
  0048e	66 c7 85 cc fd
	ff ff a8 00	 mov	 WORD PTR __k$524787[ebp+8], 168 ; 000000a8H
  00497	59		 pop	 ecx
$LL1005@Load@4:
  00498	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0049e	83 c0 04	 add	 eax, 4
  004a1	49		 dec	 ecx
  004a2	75 f4		 jne	 SHORT $LL1005@Load@4
  004a4	80 b5 cc fd ff
	ff ed		 xor	 BYTE PTR __k$524787[ebp+8], -19 ; ffffffedH
  004ab	56		 push	 esi
  004ac	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  004b2	50		 push	 eax
  004b3	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  004b8	8d 85 c4 fd ff
	ff		 lea	 eax, DWORD PTR __k$524787[ebp]
  004be	50		 push	 eax
  004bf	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  004c5	ff d7		 call	 edi

; 1028 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_SPACE, szKeyText ) );

  004c7	6a 20		 push	 32			; 00000020H
  004c9	58		 pop	 eax
  004ca	66 89 85 98 f0
	ff ff		 mov	 WORD PTR $T523073[ebp], ax
  004d1	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  004d7	50		 push	 eax
  004d8	8d 8d 9c f0 ff
	ff		 lea	 ecx, DWORD PTR $T523073[ebp+4]
  004de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  004e4	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  004ea	6a 00		 push	 0
  004ec	8d 85 98 f0 ff
	ff		 lea	 eax, DWORD PTR $T523073[ebp]
  004f2	50		 push	 eax
  004f3	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  004f7	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Buynode<std::pair<unsigned short const ,ioHashString> >
  004fc	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  00502	50		 push	 eax
  00503	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523075[ebp]
  00509	50		 push	 eax
  0050a	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Linsert
  0050f	8d 8d 9c f0 ff
	ff		 lea	 ecx, DWORD PTR $T523073[ebp+4]
  00515	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00519	ff d3		 call	 ebx
  0051b	6a 02		 push	 2

; 1029 : 
; 1030 : 	kLoader.LoadString_e( "KEY_BANG", "", szKeyText, MAX_PATH );

  0051d	c7 85 e0 f5 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$524953[ebp], -1246582362 ; b5b2a9a6H
  00527	c7 85 e4 f5 ff
	ff af ad a5 ad	 mov	 DWORD PTR __k$524953[ebp+4], -1381651025 ; ada5adafH
  00531	8d 85 e0 f5 ff
	ff		 lea	 eax, DWORD PTR __k$524953[ebp]
  00537	c6 85 e8 f5 ff
	ff 00		 mov	 BYTE PTR __k$524953[ebp+8], 0
  0053e	59		 pop	 ecx
$LL1135@Load@4:
  0053f	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00545	83 c0 04	 add	 eax, 4
  00548	49		 dec	 ecx
  00549	75 f4		 jne	 SHORT $LL1135@Load@4
  0054b	56		 push	 esi
  0054c	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00552	50		 push	 eax
  00553	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00558	8d 85 e0 f5 ff
	ff		 lea	 eax, DWORD PTR __k$524953[ebp]
  0055e	50		 push	 eax
  0055f	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00565	ff d7		 call	 edi

; 1031 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_BANG, szKeyText ) );

  00567	6a 21		 push	 33			; 00000021H
  00569	58		 pop	 eax
  0056a	66 89 85 60 f1
	ff ff		 mov	 WORD PTR $T523076[ebp], ax
  00571	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00577	50		 push	 eax
  00578	8d 8d 64 f1 ff
	ff		 lea	 ecx, DWORD PTR $T523076[ebp+4]
  0057e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  00584	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  0058a	8d 85 60 f1 ff
	ff		 lea	 eax, DWORD PTR $T523076[ebp]
  00590	50		 push	 eax
  00591	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523078[ebp]
  00597	50		 push	 eax
  00598	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  0059c	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  005a1	8d 8d 64 f1 ff
	ff		 lea	 ecx, DWORD PTR $T523076[ebp+4]
  005a7	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  005ab	ff d3		 call	 ebx
  005ad	6a 02		 push	 2

; 1032 : 
; 1033 : 	kLoader.LoadString_e( "KEY_DQUOTE", "", szKeyText, MAX_PATH );

  005af	c7 85 84 fb ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$525137[ebp], -1246582362 ; b5b2a9a6H
  005b9	c7 85 88 fb ff
	ff a9 bd be a5	 mov	 DWORD PTR __k$525137[ebp+4], -1514226263 ; a5bebda9H
  005c3	66 c7 85 8c fb
	ff ff b9 a9	 mov	 WORD PTR __k$525137[ebp+8], 43449 ; 0000a9b9H
  005cc	8d 85 84 fb ff
	ff		 lea	 eax, DWORD PTR __k$525137[ebp]
  005d2	c6 85 8e fb ff
	ff 00		 mov	 BYTE PTR __k$525137[ebp+10], 0
  005d9	59		 pop	 ecx
$LL1261@Load@4:
  005da	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  005e0	83 c0 04	 add	 eax, 4
  005e3	49		 dec	 ecx
  005e4	75 f4		 jne	 SHORT $LL1261@Load@4
  005e6	6a 08		 push	 8
  005e8	58		 pop	 eax
$LL1258@Load@4:
  005e9	8b c8		 mov	 ecx, eax
  005eb	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  005f1	79 05		 jns	 SHORT $LN18413@Load@4
  005f3	49		 dec	 ecx
  005f4	83 c9 fc	 or	 ecx, -4			; fffffffcH
  005f7	41		 inc	 ecx
$LN18413@Load@4:
  005f8	b2 ed		 mov	 dl, -19			; ffffffedH
  005fa	2a d1		 sub	 dl, cl
  005fc	30 94 05 84 fb
	ff ff		 xor	 BYTE PTR __k$525137[ebp+eax], dl
  00603	40		 inc	 eax
  00604	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00607	7c e0		 jl	 SHORT $LL1258@Load@4
  00609	56		 push	 esi
  0060a	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00610	50		 push	 eax
  00611	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00616	8d 85 84 fb ff
	ff		 lea	 eax, DWORD PTR __k$525137[ebp]
  0061c	50		 push	 eax
  0061d	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00623	ff d7		 call	 edi

; 1034 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_DQUOTE, szKeyText ) );

  00625	6a 22		 push	 34			; 00000022H
  00627	58		 pop	 eax
  00628	66 89 85 20 f0
	ff ff		 mov	 WORD PTR $T523079[ebp], ax
  0062f	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00635	50		 push	 eax
  00636	8d 8d 24 f0 ff
	ff		 lea	 ecx, DWORD PTR $T523079[ebp+4]
  0063c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  00642	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  00648	8d 85 20 f0 ff
	ff		 lea	 eax, DWORD PTR $T523079[ebp]
  0064e	50		 push	 eax
  0064f	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523081[ebp]
  00655	50		 push	 eax
  00656	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  0065a	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  0065f	8d 8d 24 f0 ff
	ff		 lea	 ecx, DWORD PTR $T523079[ebp+4]
  00665	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00669	ff d3		 call	 ebx
  0066b	6a 02		 push	 2

; 1035 : 
; 1036 : 	kLoader.LoadString_e( "KEY_POUND", "", szKeyText, MAX_PATH );

  0066d	c7 85 f4 fa ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$525291[ebp], -1246582362 ; b5b2a9a6H
  00677	c7 85 f8 fa ff
	ff bd a3 be a4	 mov	 DWORD PTR __k$525291[ebp+4], -1531010115 ; a4bea3bdH
  00681	8d 85 f4 fa ff
	ff		 lea	 eax, DWORD PTR __k$525291[ebp]
  00687	66 c7 85 fc fa
	ff ff a9 00	 mov	 WORD PTR __k$525291[ebp+8], 169 ; 000000a9H
  00690	59		 pop	 ecx
$LL1387@Load@4:
  00691	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00697	83 c0 04	 add	 eax, 4
  0069a	49		 dec	 ecx
  0069b	75 f4		 jne	 SHORT $LL1387@Load@4
  0069d	80 b5 fc fa ff
	ff ed		 xor	 BYTE PTR __k$525291[ebp+8], -19 ; ffffffedH
  006a4	56		 push	 esi
  006a5	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  006ab	50		 push	 eax
  006ac	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  006b1	8d 85 f4 fa ff
	ff		 lea	 eax, DWORD PTR __k$525291[ebp]
  006b7	50		 push	 eax
  006b8	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  006be	ff d7		 call	 edi

; 1037 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_POUND, szKeyText ) );

  006c0	6a 23		 push	 35			; 00000023H
  006c2	58		 pop	 eax
  006c3	66 89 85 38 f1
	ff ff		 mov	 WORD PTR $T523082[ebp], ax
  006ca	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  006d0	50		 push	 eax
  006d1	8d 8d 3c f1 ff
	ff		 lea	 ecx, DWORD PTR $T523082[ebp+4]
  006d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  006dd	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  006e3	8d 85 38 f1 ff
	ff		 lea	 eax, DWORD PTR $T523082[ebp]
  006e9	50		 push	 eax
  006ea	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523084[ebp]
  006f0	50		 push	 eax
  006f1	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  006f5	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  006fa	8d 8d 3c f1 ff
	ff		 lea	 ecx, DWORD PTR $T523082[ebp+4]
  00700	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00704	ff d3		 call	 ebx
  00706	6a 02		 push	 2

; 1038 : 
; 1039 : 	kLoader.LoadString_e( "KEY_DOLLAR", "", szKeyText, MAX_PATH );

  00708	c7 85 08 fe ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$525475[ebp], -1246582362 ; b5b2a9a6H
  00712	c7 85 0c fe ff
	ff a9 a3 a7 a6	 mov	 DWORD PTR __k$525475[ebp+4], -1498963031 ; a6a7a3a9H
  0071c	66 c7 85 10 fe
	ff ff ac be	 mov	 WORD PTR __k$525475[ebp+8], 48812 ; 0000beacH
  00725	8d 85 08 fe ff
	ff		 lea	 eax, DWORD PTR __k$525475[ebp]
  0072b	c6 85 12 fe ff
	ff 00		 mov	 BYTE PTR __k$525475[ebp+10], 0
  00732	59		 pop	 ecx
$LL1513@Load@4:
  00733	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00739	83 c0 04	 add	 eax, 4
  0073c	49		 dec	 ecx
  0073d	75 f4		 jne	 SHORT $LL1513@Load@4
  0073f	6a 08		 push	 8
  00741	58		 pop	 eax
$LL1510@Load@4:
  00742	8b c8		 mov	 ecx, eax
  00744	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0074a	79 05		 jns	 SHORT $LN18414@Load@4
  0074c	49		 dec	 ecx
  0074d	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00750	41		 inc	 ecx
$LN18414@Load@4:
  00751	b2 ed		 mov	 dl, -19			; ffffffedH
  00753	2a d1		 sub	 dl, cl
  00755	30 94 05 08 fe
	ff ff		 xor	 BYTE PTR __k$525475[ebp+eax], dl
  0075c	40		 inc	 eax
  0075d	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00760	7c e0		 jl	 SHORT $LL1510@Load@4
  00762	56		 push	 esi
  00763	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00769	50		 push	 eax
  0076a	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0076f	8d 85 08 fe ff
	ff		 lea	 eax, DWORD PTR __k$525475[ebp]
  00775	50		 push	 eax
  00776	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0077c	ff d7		 call	 edi

; 1040 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_DOLLAR, szKeyText ) );

  0077e	6a 24		 push	 36			; 00000024H
  00780	58		 pop	 eax
  00781	66 89 85 b0 f1
	ff ff		 mov	 WORD PTR $T523085[ebp], ax
  00788	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0078e	50		 push	 eax
  0078f	8d 8d b4 f1 ff
	ff		 lea	 ecx, DWORD PTR $T523085[ebp+4]
  00795	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  0079b	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  007a1	8d 85 b0 f1 ff
	ff		 lea	 eax, DWORD PTR $T523085[ebp]
  007a7	50		 push	 eax
  007a8	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523087[ebp]
  007ae	50		 push	 eax
  007af	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  007b3	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  007b8	8d 8d b4 f1 ff
	ff		 lea	 ecx, DWORD PTR $T523085[ebp+4]
  007be	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  007c2	ff d3		 call	 ebx
  007c4	6a 02		 push	 2

; 1041 : 
; 1042 : 	kLoader.LoadString_e( "KEY_PERCENT", "", szKeyText, MAX_PATH );

  007c6	c7 85 5c fc ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$525629[ebp], -1246582362 ; b5b2a9a6H
  007d0	c7 85 60 fc ff
	ff bd a9 b9 a9	 mov	 DWORD PTR __k$525629[ebp+4], -1447450179 ; a9b9a9bdH
  007da	8d 85 5c fc ff
	ff		 lea	 eax, DWORD PTR __k$525629[ebp]
  007e0	c7 85 64 fc ff
	ff a8 a2 bf 00	 mov	 DWORD PTR __k$525629[ebp+8], 12559016 ; 00bfa2a8H
  007ea	59		 pop	 ecx
$LL1639@Load@4:
  007eb	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  007f1	83 c0 04	 add	 eax, 4
  007f4	49		 dec	 ecx
  007f5	75 f4		 jne	 SHORT $LL1639@Load@4
  007f7	6a 08		 push	 8
  007f9	58		 pop	 eax
$LL1636@Load@4:
  007fa	8b c8		 mov	 ecx, eax
  007fc	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00802	79 05		 jns	 SHORT $LN18415@Load@4
  00804	49		 dec	 ecx
  00805	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00808	41		 inc	 ecx
$LN18415@Load@4:
  00809	b2 ed		 mov	 dl, -19			; ffffffedH
  0080b	2a d1		 sub	 dl, cl
  0080d	30 94 05 5c fc
	ff ff		 xor	 BYTE PTR __k$525629[ebp+eax], dl
  00814	40		 inc	 eax
  00815	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00818	7c e0		 jl	 SHORT $LL1636@Load@4
  0081a	56		 push	 esi
  0081b	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00821	50		 push	 eax
  00822	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00827	8d 85 5c fc ff
	ff		 lea	 eax, DWORD PTR __k$525629[ebp]
  0082d	50		 push	 eax
  0082e	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00834	ff d7		 call	 edi

; 1043 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_PERCENT, szKeyText ) );

  00836	6a 25		 push	 37			; 00000025H
  00838	58		 pop	 eax
  00839	66 89 85 10 f1
	ff ff		 mov	 WORD PTR $T523088[ebp], ax
  00840	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00846	50		 push	 eax
  00847	8d 8d 14 f1 ff
	ff		 lea	 ecx, DWORD PTR $T523088[ebp+4]
  0084d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  00853	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  00859	8d 85 10 f1 ff
	ff		 lea	 eax, DWORD PTR $T523088[ebp]
  0085f	50		 push	 eax
  00860	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523090[ebp]
  00866	50		 push	 eax
  00867	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  0086b	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  00870	8d 8d 14 f1 ff
	ff		 lea	 ecx, DWORD PTR $T523088[ebp+4]
  00876	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0087a	ff d3		 call	 ebx
  0087c	6a 03		 push	 3

; 1044 : 
; 1045 : 	kLoader.LoadString_e( "KEY_AMPERSAND", "", szKeyText, MAX_PATH );

  0087e	c7 85 8c fd ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$525798[ebp], -1246582362 ; b5b2a9a6H
  00888	c7 85 90 fd ff
	ff ac a1 bb af	 mov	 DWORD PTR __k$525798[ebp+4], -1346657876 ; afbba1acH
  00892	c7 85 94 fd ff
	ff bf bf aa a4	 mov	 DWORD PTR __k$525798[ebp+8], -1532313665 ; a4aabfbfH
  0089c	8d 85 8c fd ff
	ff		 lea	 eax, DWORD PTR __k$525798[ebp]
  008a2	66 c7 85 98 fd
	ff ff a9 00	 mov	 WORD PTR __k$525798[ebp+12], 169 ; 000000a9H
  008ab	59		 pop	 ecx
$LL1765@Load@4:
  008ac	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  008b2	83 c0 04	 add	 eax, 4
  008b5	49		 dec	 ecx
  008b6	75 f4		 jne	 SHORT $LL1765@Load@4
  008b8	80 b5 98 fd ff
	ff ed		 xor	 BYTE PTR __k$525798[ebp+12], -19 ; ffffffedH
  008bf	56		 push	 esi
  008c0	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  008c6	50		 push	 eax
  008c7	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  008cc	8d 85 8c fd ff
	ff		 lea	 eax, DWORD PTR __k$525798[ebp]
  008d2	50		 push	 eax
  008d3	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  008d9	ff d7		 call	 edi

; 1046 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_AMPERSAND, szKeyText ) );

  008db	6a 26		 push	 38			; 00000026H
  008dd	58		 pop	 eax
  008de	66 89 85 d0 ef
	ff ff		 mov	 WORD PTR $T523091[ebp], ax
  008e5	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  008eb	50		 push	 eax
  008ec	8d 8d d4 ef ff
	ff		 lea	 ecx, DWORD PTR $T523091[ebp+4]
  008f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  008f8	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  008fe	8d 85 d0 ef ff
	ff		 lea	 eax, DWORD PTR $T523091[ebp]
  00904	50		 push	 eax
  00905	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523093[ebp]
  0090b	50		 push	 eax
  0090c	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  00910	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  00915	8d 8d d4 ef ff
	ff		 lea	 ecx, DWORD PTR $T523091[ebp+4]
  0091b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0091f	ff d3		 call	 ebx
  00921	6a 03		 push	 3

; 1047 : 
; 1048 : 	kLoader.LoadString_e( "KEY_APOSTROPHE", "", szKeyText, MAX_PATH );

  00923	c7 85 b8 fb ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$525967[ebp], -1246582362 ; b5b2a9a6H
  0092d	c7 85 bc fb ff
	ff ac bc a4 b9	 mov	 DWORD PTR __k$525967[ebp+4], -1180386132 ; b9a4bcacH
  00937	c7 85 c0 fb ff
	ff b9 be a4 ba	 mov	 DWORD PTR __k$525967[ebp+8], -1163608391 ; baa4beb9H
  00941	66 c7 85 c4 fb
	ff ff a5 a9	 mov	 WORD PTR __k$525967[ebp+12], 43429 ; 0000a9a5H
  0094a	8d 85 b8 fb ff
	ff		 lea	 eax, DWORD PTR __k$525967[ebp]
  00950	c6 85 c6 fb ff
	ff 00		 mov	 BYTE PTR __k$525967[ebp+14], 0
  00957	59		 pop	 ecx
$LL1891@Load@4:
  00958	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0095e	83 c0 04	 add	 eax, 4
  00961	49		 dec	 ecx
  00962	75 f4		 jne	 SHORT $LL1891@Load@4
  00964	6a 0c		 push	 12			; 0000000cH
  00966	58		 pop	 eax
$LL1888@Load@4:
  00967	8b c8		 mov	 ecx, eax
  00969	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0096f	79 05		 jns	 SHORT $LN18416@Load@4
  00971	49		 dec	 ecx
  00972	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00975	41		 inc	 ecx
$LN18416@Load@4:
  00976	b2 ed		 mov	 dl, -19			; ffffffedH
  00978	2a d1		 sub	 dl, cl
  0097a	30 94 05 b8 fb
	ff ff		 xor	 BYTE PTR __k$525967[ebp+eax], dl
  00981	40		 inc	 eax
  00982	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  00985	7c e0		 jl	 SHORT $LL1888@Load@4
  00987	56		 push	 esi
  00988	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0098e	50		 push	 eax
  0098f	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00994	8d 85 b8 fb ff
	ff		 lea	 eax, DWORD PTR __k$525967[ebp]
  0099a	50		 push	 eax
  0099b	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  009a1	ff d7		 call	 edi

; 1049 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_APOSTROPHE, szKeyText ) );

  009a3	6a 27		 push	 39			; 00000027H
  009a5	58		 pop	 eax
  009a6	66 89 85 e8 f0
	ff ff		 mov	 WORD PTR $T523094[ebp], ax
  009ad	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  009b3	50		 push	 eax
  009b4	8d 8d ec f0 ff
	ff		 lea	 ecx, DWORD PTR $T523094[ebp+4]
  009ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  009c0	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  009c6	8d 85 e8 f0 ff
	ff		 lea	 eax, DWORD PTR $T523094[ebp]
  009cc	50		 push	 eax
  009cd	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523096[ebp]
  009d3	50		 push	 eax
  009d4	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  009d8	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  009dd	8d 8d ec f0 ff
	ff		 lea	 ecx, DWORD PTR $T523094[ebp+4]
  009e3	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  009e7	ff d3		 call	 ebx
  009e9	6a 02		 push	 2

; 1050 : 
; 1051 : 	kLoader.LoadString_e( "KEY_LBRACE", "", szKeyText, MAX_PATH );

  009eb	c7 85 ec fc ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$526151[ebp], -1246582362 ; b5b2a9a6H
  009f5	c7 85 f0 fc ff
	ff a1 ae b9 ab	 mov	 DWORD PTR __k$526151[ebp+4], -1413894495 ; abb9aea1H
  009ff	66 c7 85 f4 fc
	ff ff ae a9	 mov	 WORD PTR __k$526151[ebp+8], 43438 ; 0000a9aeH
  00a08	8d 85 ec fc ff
	ff		 lea	 eax, DWORD PTR __k$526151[ebp]
  00a0e	c6 85 f6 fc ff
	ff 00		 mov	 BYTE PTR __k$526151[ebp+10], 0
  00a15	59		 pop	 ecx
$LL2017@Load@4:
  00a16	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00a1c	83 c0 04	 add	 eax, 4
  00a1f	49		 dec	 ecx
  00a20	75 f4		 jne	 SHORT $LL2017@Load@4
  00a22	6a 08		 push	 8
  00a24	58		 pop	 eax
$LL2014@Load@4:
  00a25	8b c8		 mov	 ecx, eax
  00a27	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00a2d	79 05		 jns	 SHORT $LN18417@Load@4
  00a2f	49		 dec	 ecx
  00a30	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00a33	41		 inc	 ecx
$LN18417@Load@4:
  00a34	b2 ed		 mov	 dl, -19			; ffffffedH
  00a36	2a d1		 sub	 dl, cl
  00a38	30 94 05 ec fc
	ff ff		 xor	 BYTE PTR __k$526151[ebp+eax], dl
  00a3f	40		 inc	 eax
  00a40	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00a43	7c e0		 jl	 SHORT $LL2014@Load@4
  00a45	56		 push	 esi
  00a46	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00a4c	50		 push	 eax
  00a4d	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00a52	8d 85 ec fc ff
	ff		 lea	 eax, DWORD PTR __k$526151[ebp]
  00a58	50		 push	 eax
  00a59	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00a5f	ff d7		 call	 edi

; 1052 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_LBRACE, szKeyText ) );

  00a61	6a 28		 push	 40			; 00000028H
  00a63	58		 pop	 eax
  00a64	66 89 85 48 f0
	ff ff		 mov	 WORD PTR $T523097[ebp], ax
  00a6b	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00a71	50		 push	 eax
  00a72	8d 8d 4c f0 ff
	ff		 lea	 ecx, DWORD PTR $T523097[ebp+4]
  00a78	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  00a7e	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  00a84	8d 85 48 f0 ff
	ff		 lea	 eax, DWORD PTR $T523097[ebp]
  00a8a	50		 push	 eax
  00a8b	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523099[ebp]
  00a91	50		 push	 eax
  00a92	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  00a96	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  00a9b	8d 8d 4c f0 ff
	ff		 lea	 ecx, DWORD PTR $T523097[ebp+4]
  00aa1	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00aa5	ff d3		 call	 ebx
  00aa7	6a 02		 push	 2

; 1053 : 
; 1054 : 	kLoader.LoadString_e( "KEY_RBRACE", "", szKeyText, MAX_PATH );

  00aa9	c7 85 64 fa ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$526307[ebp], -1246582362 ; b5b2a9a6H
  00ab3	c7 85 68 fa ff
	ff bf ae b9 ab	 mov	 DWORD PTR __k$526307[ebp+4], -1413894465 ; abb9aebfH
  00abd	66 c7 85 6c fa
	ff ff ae a9	 mov	 WORD PTR __k$526307[ebp+8], 43438 ; 0000a9aeH
  00ac6	8d 85 64 fa ff
	ff		 lea	 eax, DWORD PTR __k$526307[ebp]
  00acc	c6 85 6e fa ff
	ff 00		 mov	 BYTE PTR __k$526307[ebp+10], 0
  00ad3	59		 pop	 ecx
$LL2143@Load@4:
  00ad4	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00ada	83 c0 04	 add	 eax, 4
  00add	49		 dec	 ecx
  00ade	75 f4		 jne	 SHORT $LL2143@Load@4
  00ae0	6a 08		 push	 8
  00ae2	58		 pop	 eax
$LL2140@Load@4:
  00ae3	8b c8		 mov	 ecx, eax
  00ae5	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00aeb	79 05		 jns	 SHORT $LN18418@Load@4
  00aed	49		 dec	 ecx
  00aee	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00af1	41		 inc	 ecx
$LN18418@Load@4:
  00af2	b2 ed		 mov	 dl, -19			; ffffffedH
  00af4	2a d1		 sub	 dl, cl
  00af6	30 94 05 64 fa
	ff ff		 xor	 BYTE PTR __k$526307[ebp+eax], dl
  00afd	40		 inc	 eax
  00afe	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00b01	7c e0		 jl	 SHORT $LL2140@Load@4
  00b03	56		 push	 esi
  00b04	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00b0a	50		 push	 eax
  00b0b	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00b10	8d 85 64 fa ff
	ff		 lea	 eax, DWORD PTR __k$526307[ebp]
  00b16	50		 push	 eax
  00b17	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00b1d	ff d7		 call	 edi

; 1055 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_RBRACE, szKeyText ) );

  00b1f	6a 29		 push	 41			; 00000029H
  00b21	58		 pop	 eax
  00b22	66 89 85 c0 f0
	ff ff		 mov	 WORD PTR $T523100[ebp], ax
  00b29	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00b2f	50		 push	 eax
  00b30	8d 8d c4 f0 ff
	ff		 lea	 ecx, DWORD PTR $T523100[ebp+4]
  00b36	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  00b3c	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  00b42	8d 85 c0 f0 ff
	ff		 lea	 eax, DWORD PTR $T523100[ebp]
  00b48	50		 push	 eax
  00b49	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523102[ebp]
  00b4f	50		 push	 eax
  00b50	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  00b54	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  00b59	8d 8d c4 f0 ff
	ff		 lea	 ecx, DWORD PTR $T523100[ebp+4]
  00b5f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00b63	ff d3		 call	 ebx
  00b65	6a 03		 push	 3

; 1056 : 
; 1057 : 	kLoader.LoadString_e( "KEY_ASTERISC", "", szKeyText, MAX_PATH );

  00b67	c7 85 f4 f7 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$526487[ebp], -1246582362 ; b5b2a9a6H
  00b71	c7 85 f8 f7 ff
	ff ac bf bf af	 mov	 DWORD PTR __k$526487[ebp+4], -1346388052 ; afbfbfacH
  00b7b	c7 85 fc f7 ff
	ff bf a5 b8 a9	 mov	 DWORD PTR __k$526487[ebp+8], -1447516737 ; a9b8a5bfH
  00b85	8d 85 f4 f7 ff
	ff		 lea	 eax, DWORD PTR __k$526487[ebp]
  00b8b	c6 85 00 f8 ff
	ff 00		 mov	 BYTE PTR __k$526487[ebp+12], 0
  00b92	59		 pop	 ecx
$LL2269@Load@4:
  00b93	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00b99	83 c0 04	 add	 eax, 4
  00b9c	49		 dec	 ecx
  00b9d	75 f4		 jne	 SHORT $LL2269@Load@4
  00b9f	56		 push	 esi
  00ba0	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00ba6	50		 push	 eax
  00ba7	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00bac	8d 85 f4 f7 ff
	ff		 lea	 eax, DWORD PTR __k$526487[ebp]
  00bb2	50		 push	 eax
  00bb3	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00bb9	ff d7		 call	 edi

; 1058 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_ASTERISC, szKeyText ) );

  00bbb	6a 2a		 push	 42			; 0000002aH
  00bbd	58		 pop	 eax
  00bbe	66 89 85 f8 ef
	ff ff		 mov	 WORD PTR $T523103[ebp], ax
  00bc5	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00bcb	50		 push	 eax
  00bcc	8d 8d fc ef ff
	ff		 lea	 ecx, DWORD PTR $T523103[ebp+4]
  00bd2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  00bd8	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  00bde	8d 85 f8 ef ff
	ff		 lea	 eax, DWORD PTR $T523103[ebp]
  00be4	50		 push	 eax
  00be5	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523105[ebp]
  00beb	50		 push	 eax
  00bec	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  00bf0	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  00bf5	8d 8d fc ef ff
	ff		 lea	 ecx, DWORD PTR $T523103[ebp+4]
  00bfb	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00bff	ff d3		 call	 ebx
  00c01	6a 02		 push	 2

; 1059 : 
; 1060 : 	kLoader.LoadString_e( "KEY_PLUS", "", szKeyText, MAX_PATH );

  00c03	c7 85 c0 f5 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$526643[ebp], -1246582362 ; b5b2a9a6H
  00c0d	c7 85 c4 f5 ff
	ff bd a0 be b9	 mov	 DWORD PTR __k$526643[ebp+4], -1178689347 ; b9bea0bdH
  00c17	8d 85 c0 f5 ff
	ff		 lea	 eax, DWORD PTR __k$526643[ebp]
  00c1d	c6 85 c8 f5 ff
	ff 00		 mov	 BYTE PTR __k$526643[ebp+8], 0
  00c24	59		 pop	 ecx
$LL2395@Load@4:
  00c25	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00c2b	83 c0 04	 add	 eax, 4
  00c2e	49		 dec	 ecx
  00c2f	75 f4		 jne	 SHORT $LL2395@Load@4
  00c31	56		 push	 esi
  00c32	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00c38	50		 push	 eax
  00c39	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00c3e	8d 85 c0 f5 ff
	ff		 lea	 eax, DWORD PTR __k$526643[ebp]
  00c44	50		 push	 eax
  00c45	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00c4b	ff d7		 call	 edi

; 1061 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_PLUS, szKeyText ) );

  00c4d	6a 2b		 push	 43			; 0000002bH
  00c4f	58		 pop	 eax
  00c50	66 89 85 9c f1
	ff ff		 mov	 WORD PTR $T523106[ebp], ax
  00c57	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00c5d	50		 push	 eax
  00c5e	8d 8d a0 f1 ff
	ff		 lea	 ecx, DWORD PTR $T523106[ebp+4]
  00c64	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  00c6a	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  00c70	8d 85 9c f1 ff
	ff		 lea	 eax, DWORD PTR $T523106[ebp]
  00c76	50		 push	 eax
  00c77	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523108[ebp]
  00c7d	50		 push	 eax
  00c7e	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+8], 16 ; 00000010H
  00c82	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  00c87	8d 8d a0 f1 ff
	ff		 lea	 ecx, DWORD PTR $T523106[ebp+4]
  00c8d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00c91	ff d3		 call	 ebx
  00c93	6a 02		 push	 2

; 1062 : 
; 1063 : 	kLoader.LoadString_e( "KEY_COMMA", "", szKeyText, MAX_PATH );

  00c95	c7 85 a0 fd ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$526825[ebp], -1246582362 ; b5b2a9a6H
  00c9f	c7 85 a4 fd ff
	ff ae a3 a6 a7	 mov	 DWORD PTR __k$526825[ebp+4], -1482251346 ; a7a6a3aeH
  00ca9	8d 85 a0 fd ff
	ff		 lea	 eax, DWORD PTR __k$526825[ebp]
  00caf	66 c7 85 a8 fd
	ff ff ac 00	 mov	 WORD PTR __k$526825[ebp+8], 172 ; 000000acH
  00cb8	59		 pop	 ecx
$LL2521@Load@4:
  00cb9	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00cbf	83 c0 04	 add	 eax, 4
  00cc2	49		 dec	 ecx
  00cc3	75 f4		 jne	 SHORT $LL2521@Load@4
  00cc5	80 b5 a8 fd ff
	ff ed		 xor	 BYTE PTR __k$526825[ebp+8], -19 ; ffffffedH
  00ccc	56		 push	 esi
  00ccd	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00cd3	50		 push	 eax
  00cd4	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00cd9	8d 85 a0 fd ff
	ff		 lea	 eax, DWORD PTR __k$526825[ebp]
  00cdf	50		 push	 eax
  00ce0	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00ce6	ff d7		 call	 edi

; 1064 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_COMMA, szKeyText ) );

  00ce8	6a 2c		 push	 44			; 0000002cH
  00cea	58		 pop	 eax
  00ceb	66 89 85 74 f1
	ff ff		 mov	 WORD PTR $T523109[ebp], ax
  00cf2	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00cf8	50		 push	 eax
  00cf9	8d 8d 78 f1 ff
	ff		 lea	 ecx, DWORD PTR $T523109[ebp+4]
  00cff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  00d05	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  00d0b	8d 85 74 f1 ff
	ff		 lea	 eax, DWORD PTR $T523109[ebp]
  00d11	50		 push	 eax
  00d12	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523111[ebp]
  00d18	50		 push	 eax
  00d19	c6 45 fc 11	 mov	 BYTE PTR __$EHRec$[ebp+8], 17 ; 00000011H
  00d1d	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  00d22	8d 8d 78 f1 ff
	ff		 lea	 ecx, DWORD PTR $T523109[ebp+4]
  00d28	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00d2c	ff d3		 call	 ebx
  00d2e	6a 02		 push	 2

; 1065 : 
; 1066 : 	kLoader.LoadString_e( "KEY_DASH", "", szKeyText, MAX_PATH );

  00d30	c7 85 a0 f5 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$526981[ebp], -1246582362 ; b5b2a9a6H
  00d3a	c7 85 a4 f5 ff
	ff a9 ad b8 a2	 mov	 DWORD PTR __k$526981[ebp+4], -1564955223 ; a2b8ada9H
  00d44	8d 85 a0 f5 ff
	ff		 lea	 eax, DWORD PTR __k$526981[ebp]
  00d4a	c6 85 a8 f5 ff
	ff 00		 mov	 BYTE PTR __k$526981[ebp+8], 0
  00d51	59		 pop	 ecx
$LL2647@Load@4:
  00d52	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00d58	83 c0 04	 add	 eax, 4
  00d5b	49		 dec	 ecx
  00d5c	75 f4		 jne	 SHORT $LL2647@Load@4
  00d5e	56		 push	 esi
  00d5f	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00d65	50		 push	 eax
  00d66	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00d6b	8d 85 a0 f5 ff
	ff		 lea	 eax, DWORD PTR __k$526981[ebp]
  00d71	50		 push	 eax
  00d72	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00d78	ff d7		 call	 edi

; 1067 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_DASH, szKeyText ) );

  00d7a	6a 2d		 push	 45			; 0000002dH
  00d7c	58		 pop	 eax
  00d7d	66 89 85 4c f1
	ff ff		 mov	 WORD PTR $T523112[ebp], ax
  00d84	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00d8a	50		 push	 eax
  00d8b	8d 8d 50 f1 ff
	ff		 lea	 ecx, DWORD PTR $T523112[ebp+4]
  00d91	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  00d97	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  00d9d	8d 85 4c f1 ff
	ff		 lea	 eax, DWORD PTR $T523112[ebp]
  00da3	50		 push	 eax
  00da4	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523114[ebp]
  00daa	50		 push	 eax
  00dab	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+8], 18 ; 00000012H
  00daf	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  00db4	8d 8d 50 f1 ff
	ff		 lea	 ecx, DWORD PTR $T523112[ebp+4]
  00dba	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00dbe	ff d3		 call	 ebx
  00dc0	6a 02		 push	 2

; 1068 : 
; 1069 : 	kLoader.LoadString_e( "KEY_PERIOD", "", szKeyText, MAX_PATH );

  00dc2	c7 85 c8 fc ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$527165[ebp], -1246582362 ; b5b2a9a6H
  00dcc	c7 85 cc fc ff
	ff bd a9 b9 a3	 mov	 DWORD PTR __k$527165[ebp+4], -1548113475 ; a3b9a9bdH
  00dd6	66 c7 85 d0 fc
	ff ff a2 a8	 mov	 WORD PTR __k$527165[ebp+8], 43170 ; 0000a8a2H
  00ddf	8d 85 c8 fc ff
	ff		 lea	 eax, DWORD PTR __k$527165[ebp]
  00de5	c6 85 d2 fc ff
	ff 00		 mov	 BYTE PTR __k$527165[ebp+10], 0
  00dec	59		 pop	 ecx
$LL2773@Load@4:
  00ded	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00df3	83 c0 04	 add	 eax, 4
  00df6	49		 dec	 ecx
  00df7	75 f4		 jne	 SHORT $LL2773@Load@4
  00df9	6a 08		 push	 8
  00dfb	58		 pop	 eax
$LL2770@Load@4:
  00dfc	8b c8		 mov	 ecx, eax
  00dfe	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00e04	79 05		 jns	 SHORT $LN18419@Load@4
  00e06	49		 dec	 ecx
  00e07	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00e0a	41		 inc	 ecx
$LN18419@Load@4:
  00e0b	b2 ed		 mov	 dl, -19			; ffffffedH
  00e0d	2a d1		 sub	 dl, cl
  00e0f	30 94 05 c8 fc
	ff ff		 xor	 BYTE PTR __k$527165[ebp+eax], dl
  00e16	40		 inc	 eax
  00e17	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00e1a	7c e0		 jl	 SHORT $LL2770@Load@4
  00e1c	56		 push	 esi
  00e1d	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00e23	50		 push	 eax
  00e24	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00e29	8d 85 c8 fc ff
	ff		 lea	 eax, DWORD PTR __k$527165[ebp]
  00e2f	50		 push	 eax
  00e30	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00e36	ff d7		 call	 edi

; 1070 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_PERIOD, szKeyText ) );

  00e38	6a 2e		 push	 46			; 0000002eH
  00e3a	58		 pop	 eax
  00e3b	66 89 85 24 f1
	ff ff		 mov	 WORD PTR $T523115[ebp], ax
  00e42	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00e48	50		 push	 eax
  00e49	8d 8d 28 f1 ff
	ff		 lea	 ecx, DWORD PTR $T523115[ebp+4]
  00e4f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  00e55	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  00e5b	8d 85 24 f1 ff
	ff		 lea	 eax, DWORD PTR $T523115[ebp]
  00e61	50		 push	 eax
  00e62	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523117[ebp]
  00e68	50		 push	 eax
  00e69	c6 45 fc 13	 mov	 BYTE PTR __$EHRec$[ebp+8], 19 ; 00000013H
  00e6d	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  00e72	8d 8d 28 f1 ff
	ff		 lea	 ecx, DWORD PTR $T523115[ebp+4]
  00e78	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00e7c	ff d3		 call	 ebx
  00e7e	6a 02		 push	 2

; 1071 : 
; 1072 : 	kLoader.LoadString_e( "KEY_SLASH", "", szKeyText, MAX_PATH );

  00e80	c7 85 cc fb ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$527319[ebp], -1246582362 ; b5b2a9a6H
  00e8a	c7 85 d0 fb ff
	ff be a0 aa b9	 mov	 DWORD PTR __k$527319[ebp+4], -1180000066 ; b9aaa0beH
  00e94	8d 85 cc fb ff
	ff		 lea	 eax, DWORD PTR __k$527319[ebp]
  00e9a	66 c7 85 d4 fb
	ff ff a5 00	 mov	 WORD PTR __k$527319[ebp+8], 165 ; 000000a5H
  00ea3	59		 pop	 ecx
$LL2899@Load@4:
  00ea4	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00eaa	83 c0 04	 add	 eax, 4
  00ead	49		 dec	 ecx
  00eae	75 f4		 jne	 SHORT $LL2899@Load@4
  00eb0	80 b5 d4 fb ff
	ff ed		 xor	 BYTE PTR __k$527319[ebp+8], -19 ; ffffffedH
  00eb7	56		 push	 esi
  00eb8	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00ebe	50		 push	 eax
  00ebf	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00ec4	8d 85 cc fb ff
	ff		 lea	 eax, DWORD PTR __k$527319[ebp]
  00eca	50		 push	 eax
  00ecb	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00ed1	ff d7		 call	 edi

; 1073 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_SLASH, szKeyText ) );

  00ed3	6a 2f		 push	 47			; 0000002fH
  00ed5	58		 pop	 eax
  00ed6	66 89 85 fc f0
	ff ff		 mov	 WORD PTR $T523118[ebp], ax
  00edd	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00ee3	50		 push	 eax
  00ee4	8d 8d 00 f1 ff
	ff		 lea	 ecx, DWORD PTR $T523118[ebp+4]
  00eea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  00ef0	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  00ef6	8d 85 fc f0 ff
	ff		 lea	 eax, DWORD PTR $T523118[ebp]
  00efc	50		 push	 eax
  00efd	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523120[ebp]
  00f03	50		 push	 eax
  00f04	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
  00f08	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  00f0d	8d 8d 00 f1 ff
	ff		 lea	 ecx, DWORD PTR $T523118[ebp+4]
  00f13	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00f17	ff d3		 call	 ebx

; 1074 : 
; 1075 : 	kLoader.LoadString_e( "KEY_0", "", szKeyText, MAX_PATH );

  00f19	56		 push	 esi
  00f1a	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00f20	50		 push	 eax
  00f21	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00f26	8d 85 c4 f8 ff
	ff		 lea	 eax, DWORD PTR __k$527501[ebp]
  00f2c	c7 85 c4 f8 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$527501[ebp], -1246582362 ; b5b2a9a6H
  00f36	81 b5 c4 f8 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$527501[ebp], -353637139 ; eaebecedH
  00f40	50		 push	 eax
  00f41	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00f47	66 c7 85 c8 f8
	ff ff 30 00	 mov	 WORD PTR __k$527501[ebp+4], 48 ; 00000030H
  00f50	ff d7		 call	 edi

; 1076 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_0, szKeyText ) );

  00f52	6a 30		 push	 48			; 00000030H
  00f54	58		 pop	 eax
  00f55	66 89 85 d4 f0
	ff ff		 mov	 WORD PTR $T523121[ebp], ax
  00f5c	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00f62	50		 push	 eax
  00f63	8d 8d d8 f0 ff
	ff		 lea	 ecx, DWORD PTR $T523121[ebp+4]
  00f69	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  00f6f	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  00f75	8d 85 d4 f0 ff
	ff		 lea	 eax, DWORD PTR $T523121[ebp]
  00f7b	50		 push	 eax
  00f7c	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523123[ebp]
  00f82	50		 push	 eax
  00f83	c6 45 fc 15	 mov	 BYTE PTR __$EHRec$[ebp+8], 21 ; 00000015H
  00f87	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  00f8c	8d 8d d8 f0 ff
	ff		 lea	 ecx, DWORD PTR $T523121[ebp+4]
  00f92	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00f96	ff d3		 call	 ebx

; 1077 : 
; 1078 : 	kLoader.LoadString_e( "KEY_1", "", szKeyText, MAX_PATH );

  00f98	56		 push	 esi
  00f99	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00f9f	50		 push	 eax
  00fa0	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00fa5	8d 85 24 f9 ff
	ff		 lea	 eax, DWORD PTR __k$527670[ebp]
  00fab	c7 85 24 f9 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$527670[ebp], -1246582362 ; b5b2a9a6H
  00fb5	81 b5 24 f9 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$527670[ebp], -353637139 ; eaebecedH
  00fbf	50		 push	 eax
  00fc0	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00fc6	66 c7 85 28 f9
	ff ff 31 00	 mov	 WORD PTR __k$527670[ebp+4], 49 ; 00000031H
  00fcf	ff d7		 call	 edi

; 1079 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_1, szKeyText ) );

  00fd1	6a 31		 push	 49			; 00000031H
  00fd3	58		 pop	 eax
  00fd4	66 89 85 ac f0
	ff ff		 mov	 WORD PTR $T523124[ebp], ax
  00fdb	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  00fe1	50		 push	 eax
  00fe2	8d 8d b0 f0 ff
	ff		 lea	 ecx, DWORD PTR $T523124[ebp+4]
  00fe8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  00fee	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  00ff4	8d 85 ac f0 ff
	ff		 lea	 eax, DWORD PTR $T523124[ebp]
  00ffa	50		 push	 eax
  00ffb	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523126[ebp]
  01001	c6 45 fc 16	 mov	 BYTE PTR __$EHRec$[ebp+8], 22 ; 00000016H
  01005	50		 push	 eax
  01006	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  0100b	8d 8d b0 f0 ff
	ff		 lea	 ecx, DWORD PTR $T523124[ebp+4]
  01011	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01015	ff d3		 call	 ebx

; 1080 : 
; 1081 : 	kLoader.LoadString_e( "KEY_2", "", szKeyText, MAX_PATH );

  01017	56		 push	 esi
  01018	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0101e	50		 push	 eax
  0101f	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  01024	8d 85 f0 f9 ff
	ff		 lea	 eax, DWORD PTR __k$527839[ebp]
  0102a	c7 85 f0 f9 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$527839[ebp], -1246582362 ; b5b2a9a6H
  01034	81 b5 f0 f9 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$527839[ebp], -353637139 ; eaebecedH
  0103e	50		 push	 eax
  0103f	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01045	66 c7 85 f4 f9
	ff ff 32 00	 mov	 WORD PTR __k$527839[ebp+4], 50 ; 00000032H
  0104e	ff d7		 call	 edi

; 1082 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_2, szKeyText ) );

  01050	6a 32		 push	 50			; 00000032H
  01052	58		 pop	 eax
  01053	66 89 85 84 f0
	ff ff		 mov	 WORD PTR $T523127[ebp], ax
  0105a	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01060	50		 push	 eax
  01061	8d 8d 88 f0 ff
	ff		 lea	 ecx, DWORD PTR $T523127[ebp+4]
  01067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  0106d	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  01073	8d 85 84 f0 ff
	ff		 lea	 eax, DWORD PTR $T523127[ebp]
  01079	50		 push	 eax
  0107a	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523129[ebp]
  01080	50		 push	 eax
  01081	c6 45 fc 17	 mov	 BYTE PTR __$EHRec$[ebp+8], 23 ; 00000017H
  01085	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  0108a	8d 8d 88 f0 ff
	ff		 lea	 ecx, DWORD PTR $T523127[ebp+4]
  01090	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01094	ff d3		 call	 ebx

; 1083 : 
; 1084 : 	kLoader.LoadString_e( "KEY_3", "", szKeyText, MAX_PATH );

  01096	56		 push	 esi
  01097	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0109d	50		 push	 eax
  0109e	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  010a3	8d 85 d8 f9 ff
	ff		 lea	 eax, DWORD PTR __k$527995[ebp]
  010a9	c7 85 d8 f9 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$527995[ebp], -1246582362 ; b5b2a9a6H
  010b3	81 b5 d8 f9 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$527995[ebp], -353637139 ; eaebecedH
  010bd	50		 push	 eax
  010be	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  010c4	66 c7 85 dc f9
	ff ff 33 00	 mov	 WORD PTR __k$527995[ebp+4], 51 ; 00000033H
  010cd	ff d7		 call	 edi

; 1085 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_3, szKeyText ) );

  010cf	6a 33		 push	 51			; 00000033H
  010d1	58		 pop	 eax
  010d2	66 89 85 5c f0
	ff ff		 mov	 WORD PTR $T523130[ebp], ax
  010d9	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  010df	50		 push	 eax
  010e0	8d 8d 60 f0 ff
	ff		 lea	 ecx, DWORD PTR $T523130[ebp+4]
  010e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  010ec	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  010f2	8d 85 5c f0 ff
	ff		 lea	 eax, DWORD PTR $T523130[ebp]
  010f8	50		 push	 eax
  010f9	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523132[ebp]
  010ff	50		 push	 eax
  01100	c6 45 fc 18	 mov	 BYTE PTR __$EHRec$[ebp+8], 24 ; 00000018H
  01104	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  01109	8d 8d 60 f0 ff
	ff		 lea	 ecx, DWORD PTR $T523130[ebp+4]
  0110f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01113	ff d3		 call	 ebx

; 1086 : 
; 1087 : 	kLoader.LoadString_e( "KEY_4", "", szKeyText, MAX_PATH );

  01115	56		 push	 esi
  01116	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0111c	50		 push	 eax
  0111d	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  01122	8d 85 c0 f9 ff
	ff		 lea	 eax, DWORD PTR __k$528164[ebp]
  01128	c7 85 c0 f9 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$528164[ebp], -1246582362 ; b5b2a9a6H
  01132	81 b5 c0 f9 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$528164[ebp], -353637139 ; eaebecedH
  0113c	50		 push	 eax
  0113d	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01143	66 c7 85 c4 f9
	ff ff 34 00	 mov	 WORD PTR __k$528164[ebp+4], 52 ; 00000034H
  0114c	ff d7		 call	 edi

; 1088 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_4, szKeyText ) );

  0114e	6a 34		 push	 52			; 00000034H
  01150	58		 pop	 eax
  01151	66 89 85 34 f0
	ff ff		 mov	 WORD PTR $T523133[ebp], ax
  01158	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0115e	50		 push	 eax
  0115f	8d 8d 38 f0 ff
	ff		 lea	 ecx, DWORD PTR $T523133[ebp+4]
  01165	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  0116b	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  01171	8d 85 34 f0 ff
	ff		 lea	 eax, DWORD PTR $T523133[ebp]
  01177	50		 push	 eax
  01178	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523135[ebp]
  0117e	50		 push	 eax
  0117f	c6 45 fc 19	 mov	 BYTE PTR __$EHRec$[ebp+8], 25 ; 00000019H
  01183	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  01188	8d 8d 38 f0 ff
	ff		 lea	 ecx, DWORD PTR $T523133[ebp+4]
  0118e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01192	ff d3		 call	 ebx

; 1089 : 
; 1090 : 	kLoader.LoadString_e( "KEY_5", "", szKeyText, MAX_PATH );

  01194	56		 push	 esi
  01195	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0119b	50		 push	 eax
  0119c	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  011a1	8d 85 a8 f9 ff
	ff		 lea	 eax, DWORD PTR __k$528333[ebp]
  011a7	c7 85 a8 f9 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$528333[ebp], -1246582362 ; b5b2a9a6H
  011b1	81 b5 a8 f9 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$528333[ebp], -353637139 ; eaebecedH
  011bb	50		 push	 eax
  011bc	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  011c2	66 c7 85 ac f9
	ff ff 35 00	 mov	 WORD PTR __k$528333[ebp+4], 53 ; 00000035H
  011cb	ff d7		 call	 edi

; 1091 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_5, szKeyText ) );

  011cd	6a 35		 push	 53			; 00000035H
  011cf	58		 pop	 eax
  011d0	66 89 85 0c f0
	ff ff		 mov	 WORD PTR $T523136[ebp], ax
  011d7	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  011dd	50		 push	 eax
  011de	8d 8d 10 f0 ff
	ff		 lea	 ecx, DWORD PTR $T523136[ebp+4]
  011e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioHashString@@QAE@PBD@Z
  011ea	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  011f0	8d 85 0c f0 ff
	ff		 lea	 eax, DWORD PTR $T523136[ebp]
  011f6	50		 push	 eax
  011f7	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523138[ebp]
  011fd	50		 push	 eax
  011fe	c6 45 fc 1a	 mov	 BYTE PTR __$EHRec$[ebp+8], 26 ; 0000001aH
  01202	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  01207	8d 8d 10 f0 ff
	ff		 lea	 ecx, DWORD PTR $T523136[ebp+4]
  0120d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01211	ff d3		 call	 ebx

; 1092 : 
; 1093 : 	kLoader.LoadString_e( "KEY_6", "", szKeyText, MAX_PATH );

  01213	56		 push	 esi
  01214	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0121a	50		 push	 eax
  0121b	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  01220	8d 85 90 f9 ff
	ff		 lea	 eax, DWORD PTR __k$528515[ebp]
  01226	c7 85 90 f9 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$528515[ebp], -1246582362 ; b5b2a9a6H
  01230	81 b5 90 f9 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$528515[ebp], -353637139 ; eaebecedH
  0123a	50		 push	 eax
  0123b	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01241	66 c7 85 94 f9
	ff ff 36 00	 mov	 WORD PTR __k$528515[ebp+4], 54 ; 00000036H
  0124a	ff d7		 call	 edi

; 1094 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_6, szKeyText ) );

  0124c	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01252	50		 push	 eax
  01253	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523140[ebp]
  01259	50		 push	 eax
  0125a	8d 8d c8 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523139[ebp]
  01260	c7 85 cc f1 ff
	ff 36 00 00 00	 mov	 DWORD PTR $T523140[ebp], 54 ; 00000036H
  0126a	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  0126f	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  01275	50		 push	 eax
  01276	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523141[ebp]
  0127c	50		 push	 eax
  0127d	c6 45 fc 1b	 mov	 BYTE PTR __$EHRec$[ebp+8], 27 ; 0000001bH
  01281	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  01286	8d 8d cc e8 ff
	ff		 lea	 ecx, DWORD PTR $T523139[ebp+4]
  0128c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01290	ff d3		 call	 ebx

; 1095 : 
; 1096 : 	kLoader.LoadString_e( "KEY_7", "", szKeyText, MAX_PATH );

  01292	56		 push	 esi
  01293	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01299	50		 push	 eax
  0129a	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0129f	8d 85 78 f9 ff
	ff		 lea	 eax, DWORD PTR __k$528650[ebp]
  012a5	c7 85 78 f9 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$528650[ebp], -1246582362 ; b5b2a9a6H
  012af	81 b5 78 f9 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$528650[ebp], -353637139 ; eaebecedH
  012b9	50		 push	 eax
  012ba	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  012c0	66 c7 85 7c f9
	ff ff 37 00	 mov	 WORD PTR __k$528650[ebp+4], 55 ; 00000037H
  012c9	ff d7		 call	 edi

; 1097 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_7, szKeyText ) );

  012cb	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  012d1	c7 85 cc f1 ff
	ff 37 00 00 00	 mov	 DWORD PTR $T523143[ebp], 55 ; 00000037H
  012db	50		 push	 eax
  012dc	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523143[ebp]
  012e2	50		 push	 eax
  012e3	8d 8d 0c e6 ff
	ff		 lea	 ecx, DWORD PTR $T523142[ebp]
  012e9	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  012ee	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  012f4	50		 push	 eax
  012f5	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523144[ebp]
  012fb	50		 push	 eax
  012fc	c6 45 fc 1c	 mov	 BYTE PTR __$EHRec$[ebp+8], 28 ; 0000001cH
  01300	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  01305	8d 8d 10 e6 ff
	ff		 lea	 ecx, DWORD PTR $T523142[ebp+4]
  0130b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0130f	ff d3		 call	 ebx

; 1098 : 
; 1099 : 	kLoader.LoadString_e( "KEY_8", "", szKeyText, MAX_PATH );

  01311	56		 push	 esi
  01312	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01318	50		 push	 eax
  01319	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0131e	8d 85 60 f9 ff
	ff		 lea	 eax, DWORD PTR __k$528785[ebp]
  01324	c7 85 60 f9 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$528785[ebp], -1246582362 ; b5b2a9a6H
  0132e	81 b5 60 f9 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$528785[ebp], -353637139 ; eaebecedH
  01338	50		 push	 eax
  01339	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0133f	66 c7 85 64 f9
	ff ff 38 00	 mov	 WORD PTR __k$528785[ebp+4], 56 ; 00000038H
  01348	ff d7		 call	 edi

; 1100 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_8, szKeyText ) );

  0134a	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01350	50		 push	 eax
  01351	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523146[ebp]
  01357	50		 push	 eax
  01358	8d 8d e4 e5 ff
	ff		 lea	 ecx, DWORD PTR $T523145[ebp]
  0135e	c7 85 cc f1 ff
	ff 38 00 00 00	 mov	 DWORD PTR $T523146[ebp], 56 ; 00000038H
  01368	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  0136d	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  01373	50		 push	 eax
  01374	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523147[ebp]
  0137a	50		 push	 eax
  0137b	c6 45 fc 1d	 mov	 BYTE PTR __$EHRec$[ebp+8], 29 ; 0000001dH
  0137f	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  01384	8d 8d e8 e5 ff
	ff		 lea	 ecx, DWORD PTR $T523145[ebp+4]
  0138a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0138e	ff d3		 call	 ebx

; 1101 : 
; 1102 : 	kLoader.LoadString_e( "KEY_9", "", szKeyText, MAX_PATH );

  01390	56		 push	 esi
  01391	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01397	50		 push	 eax
  01398	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0139d	8d 85 48 f9 ff
	ff		 lea	 eax, DWORD PTR __k$528920[ebp]
  013a3	c7 85 48 f9 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$528920[ebp], -1246582362 ; b5b2a9a6H
  013ad	81 b5 48 f9 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$528920[ebp], -353637139 ; eaebecedH
  013b7	50		 push	 eax
  013b8	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  013be	66 c7 85 4c f9
	ff ff 39 00	 mov	 WORD PTR __k$528920[ebp+4], 57 ; 00000039H
  013c7	ff d7		 call	 edi

; 1103 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_9, szKeyText ) );

  013c9	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  013cf	50		 push	 eax
  013d0	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523149[ebp]
  013d6	50		 push	 eax
  013d7	8d 8d 80 ef ff
	ff		 lea	 ecx, DWORD PTR $T523148[ebp]
  013dd	c7 85 cc f1 ff
	ff 39 00 00 00	 mov	 DWORD PTR $T523149[ebp], 57 ; 00000039H
  013e7	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  013ec	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  013f2	50		 push	 eax
  013f3	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523150[ebp]
  013f9	50		 push	 eax
  013fa	c6 45 fc 1e	 mov	 BYTE PTR __$EHRec$[ebp+8], 30 ; 0000001eH
  013fe	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  01403	8d 8d 84 ef ff
	ff		 lea	 ecx, DWORD PTR $T523148[ebp+4]
  01409	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0140d	ff d3		 call	 ebx
  0140f	6a 02		 push	 2

; 1104 : 
; 1105 : 	kLoader.LoadString_e( "KEY_COLON", "", szKeyText, MAX_PATH );

  01411	c7 85 7c fd ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$529055[ebp], -1246582362 ; b5b2a9a6H
  0141b	c7 85 80 fd ff
	ff ae a3 a7 a5	 mov	 DWORD PTR __k$529055[ebp+4], -1515740242 ; a5a7a3aeH
  01425	8d 85 7c fd ff
	ff		 lea	 eax, DWORD PTR __k$529055[ebp]
  0142b	66 c7 85 84 fd
	ff ff a3 00	 mov	 WORD PTR __k$529055[ebp+8], 163 ; 000000a3H
  01434	59		 pop	 ecx
$LL4229@Load@4:
  01435	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0143b	83 c0 04	 add	 eax, 4
  0143e	49		 dec	 ecx
  0143f	75 f4		 jne	 SHORT $LL4229@Load@4
  01441	80 b5 84 fd ff
	ff ed		 xor	 BYTE PTR __k$529055[ebp+8], -19 ; ffffffedH
  01448	56		 push	 esi
  01449	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0144f	50		 push	 eax
  01450	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  01455	8d 85 7c fd ff
	ff		 lea	 eax, DWORD PTR __k$529055[ebp]
  0145b	50		 push	 eax
  0145c	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01462	ff d7		 call	 edi

; 1106 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_COLON, szKeyText ) );

  01464	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0146a	50		 push	 eax
  0146b	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523152[ebp]
  01471	50		 push	 eax
  01472	8d 8d a8 ea ff
	ff		 lea	 ecx, DWORD PTR $T523151[ebp]
  01478	c7 85 cc f1 ff
	ff 3a 00 00 00	 mov	 DWORD PTR $T523152[ebp], 58 ; 0000003aH
  01482	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  01487	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  0148d	50		 push	 eax
  0148e	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523153[ebp]
  01494	50		 push	 eax
  01495	c6 45 fc 1f	 mov	 BYTE PTR __$EHRec$[ebp+8], 31 ; 0000001fH
  01499	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  0149e	8d 8d ac ea ff
	ff		 lea	 ecx, DWORD PTR $T523151[ebp+4]
  014a4	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  014a8	ff d3		 call	 ebx
  014aa	6a 03		 push	 3

; 1107 : 
; 1108 : 	kLoader.LoadString_e( "KEY_SEMICOLON", "", szKeyText, MAX_PATH );

  014ac	c7 85 68 fd ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$529177[ebp], -1246582362 ; b5b2a9a6H
  014b6	c7 85 6c fd ff
	ff be a9 a6 a3	 mov	 DWORD PTR __k$529177[ebp+4], -1549358658 ; a3a6a9beH
  014c0	c7 85 70 fd ff
	ff ae a3 a7 a5	 mov	 DWORD PTR __k$529177[ebp+8], -1515740242 ; a5a7a3aeH
  014ca	8d 85 68 fd ff
	ff		 lea	 eax, DWORD PTR __k$529177[ebp]
  014d0	66 c7 85 74 fd
	ff ff a3 00	 mov	 WORD PTR __k$529177[ebp+12], 163 ; 000000a3H
  014d9	59		 pop	 ecx
$LL4341@Load@4:
  014da	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  014e0	83 c0 04	 add	 eax, 4
  014e3	49		 dec	 ecx
  014e4	75 f4		 jne	 SHORT $LL4341@Load@4
  014e6	80 b5 74 fd ff
	ff ed		 xor	 BYTE PTR __k$529177[ebp+12], -19 ; ffffffedH
  014ed	56		 push	 esi
  014ee	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  014f4	50		 push	 eax
  014f5	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  014fa	8d 85 68 fd ff
	ff		 lea	 eax, DWORD PTR __k$529177[ebp]
  01500	50		 push	 eax
  01501	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01507	ff d7		 call	 edi

; 1109 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_SEMICOLON, szKeyText ) );

  01509	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0150f	50		 push	 eax
  01510	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523155[ebp]
  01516	50		 push	 eax
  01517	8d 8d 58 ef ff
	ff		 lea	 ecx, DWORD PTR $T523154[ebp]
  0151d	c7 85 cc f1 ff
	ff 3b 00 00 00	 mov	 DWORD PTR $T523155[ebp], 59 ; 0000003bH
  01527	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  0152c	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  01532	50		 push	 eax
  01533	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523156[ebp]
  01539	50		 push	 eax
  0153a	c6 45 fc 20	 mov	 BYTE PTR __$EHRec$[ebp+8], 32 ; 00000020H
  0153e	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  01543	8d 8d 5c ef ff
	ff		 lea	 ecx, DWORD PTR $T523154[ebp+4]
  01549	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0154d	ff d3		 call	 ebx
  0154f	6a 03		 push	 3

; 1110 : 
; 1111 : 	kLoader.LoadString_e( "KEY_LESSTHEN", "", szKeyText, MAX_PATH );

  01551	c7 85 e0 f7 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$529312[ebp], -1246582362 ; b5b2a9a6H
  0155b	c7 85 e4 f7 ff
	ff a1 a9 b8 b9	 mov	 DWORD PTR __k$529312[ebp+4], -1179080287 ; b9b8a9a1H
  01565	c7 85 e8 f7 ff
	ff b9 a4 ae a4	 mov	 DWORD PTR __k$529312[ebp+8], -1532058439 ; a4aea4b9H
  0156f	8d 85 e0 f7 ff
	ff		 lea	 eax, DWORD PTR __k$529312[ebp]
  01575	c6 85 ec f7 ff
	ff 00		 mov	 BYTE PTR __k$529312[ebp+12], 0
  0157c	59		 pop	 ecx
$LL4453@Load@4:
  0157d	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  01583	83 c0 04	 add	 eax, 4
  01586	49		 dec	 ecx
  01587	75 f4		 jne	 SHORT $LL4453@Load@4
  01589	56		 push	 esi
  0158a	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01590	50		 push	 eax
  01591	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  01596	8d 85 e0 f7 ff
	ff		 lea	 eax, DWORD PTR __k$529312[ebp]
  0159c	50		 push	 eax
  0159d	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  015a3	ff d7		 call	 edi

; 1112 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_LESSTHEN, szKeyText ) );

  015a5	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  015ab	50		 push	 eax
  015ac	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523158[ebp]
  015b2	50		 push	 eax
  015b3	8d 8d 10 e7 ff
	ff		 lea	 ecx, DWORD PTR $T523157[ebp]
  015b9	c7 85 cc f1 ff
	ff 3c 00 00 00	 mov	 DWORD PTR $T523158[ebp], 60 ; 0000003cH
  015c3	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  015c8	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  015ce	50		 push	 eax
  015cf	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523159[ebp]
  015d5	50		 push	 eax
  015d6	c6 45 fc 21	 mov	 BYTE PTR __$EHRec$[ebp+8], 33 ; 00000021H
  015da	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  015df	8d 8d 14 e7 ff
	ff		 lea	 ecx, DWORD PTR $T523157[ebp+4]
  015e5	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  015e9	ff d3		 call	 ebx
  015eb	6a 02		 push	 2

; 1113 : 
; 1114 : 	kLoader.LoadString_e( "KEY_EQUALS", "", szKeyText, MAX_PATH );

  015ed	c7 85 60 fb ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$529462[ebp], -1246582362 ; b5b2a9a6H
  015f7	c7 85 64 fb ff
	ff a8 bd be ab	 mov	 DWORD PTR __k$529462[ebp+4], -1413562968 ; abbebda8H
  01601	66 c7 85 68 fb
	ff ff a1 bf	 mov	 WORD PTR __k$529462[ebp+8], 49057 ; 0000bfa1H
  0160a	8d 85 60 fb ff
	ff		 lea	 eax, DWORD PTR __k$529462[ebp]
  01610	c6 85 6a fb ff
	ff 00		 mov	 BYTE PTR __k$529462[ebp+10], 0
  01617	59		 pop	 ecx
$LL4565@Load@4:
  01618	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0161e	83 c0 04	 add	 eax, 4
  01621	49		 dec	 ecx
  01622	75 f4		 jne	 SHORT $LL4565@Load@4
  01624	6a 08		 push	 8
  01626	58		 pop	 eax
$LL4562@Load@4:
  01627	8b c8		 mov	 ecx, eax
  01629	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0162f	79 05		 jns	 SHORT $LN18420@Load@4
  01631	49		 dec	 ecx
  01632	83 c9 fc	 or	 ecx, -4			; fffffffcH
  01635	41		 inc	 ecx
$LN18420@Load@4:
  01636	b2 ed		 mov	 dl, -19			; ffffffedH
  01638	2a d1		 sub	 dl, cl
  0163a	30 94 05 60 fb
	ff ff		 xor	 BYTE PTR __k$529462[ebp+eax], dl
  01641	40		 inc	 eax
  01642	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  01645	7c e0		 jl	 SHORT $LL4562@Load@4
  01647	56		 push	 esi
  01648	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0164e	50		 push	 eax
  0164f	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  01654	8d 85 60 fb ff
	ff		 lea	 eax, DWORD PTR __k$529462[ebp]
  0165a	50		 push	 eax
  0165b	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01661	ff d7		 call	 edi

; 1115 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_EQUALS, szKeyText ) );

  01663	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01669	50		 push	 eax
  0166a	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523161[ebp]
  01670	50		 push	 eax
  01671	8d 8d 30 ef ff
	ff		 lea	 ecx, DWORD PTR $T523160[ebp]
  01677	c7 85 cc f1 ff
	ff 3d 00 00 00	 mov	 DWORD PTR $T523161[ebp], 61 ; 0000003dH
  01681	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  01686	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  0168c	50		 push	 eax
  0168d	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523162[ebp]
  01693	50		 push	 eax
  01694	c6 45 fc 22	 mov	 BYTE PTR __$EHRec$[ebp+8], 34 ; 00000022H
  01698	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  0169d	8d 8d 34 ef ff
	ff		 lea	 ecx, DWORD PTR $T523160[ebp+4]
  016a3	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  016a7	ff d3		 call	 ebx
  016a9	6a 03		 push	 3

; 1116 : 
; 1117 : 	kLoader.LoadString_e( "KEY_GREATERTHEN", "", szKeyText, MAX_PATH );

  016ab	c7 85 2c fa ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$529595[ebp], -1246582362 ; b5b2a9a6H
  016b5	c7 85 30 fa ff
	ff aa be ae ab	 mov	 DWORD PTR __k$529595[ebp+4], -1414611286 ; abaebeaaH
  016bf	c7 85 34 fa ff
	ff b9 a9 b9 be	 mov	 DWORD PTR __k$529595[ebp+8], -1095128647 ; beb9a9b9H
  016c9	8d 85 2c fa ff
	ff		 lea	 eax, DWORD PTR __k$529595[ebp]
  016cf	c7 85 38 fa ff
	ff a5 a9 a5 00	 mov	 DWORD PTR __k$529595[ebp+12], 10856869 ; 00a5a9a5H
  016d9	59		 pop	 ecx
$LL4677@Load@4:
  016da	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  016e0	83 c0 04	 add	 eax, 4
  016e3	49		 dec	 ecx
  016e4	75 f4		 jne	 SHORT $LL4677@Load@4
  016e6	6a 0c		 push	 12			; 0000000cH
  016e8	58		 pop	 eax
$LL4674@Load@4:
  016e9	8b c8		 mov	 ecx, eax
  016eb	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  016f1	79 05		 jns	 SHORT $LN18421@Load@4
  016f3	49		 dec	 ecx
  016f4	83 c9 fc	 or	 ecx, -4			; fffffffcH
  016f7	41		 inc	 ecx
$LN18421@Load@4:
  016f8	b2 ed		 mov	 dl, -19			; ffffffedH
  016fa	2a d1		 sub	 dl, cl
  016fc	30 94 05 2c fa
	ff ff		 xor	 BYTE PTR __k$529595[ebp+eax], dl
  01703	40		 inc	 eax
  01704	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  01707	7c e0		 jl	 SHORT $LL4674@Load@4
  01709	56		 push	 esi
  0170a	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01710	50		 push	 eax
  01711	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  01716	8d 85 2c fa ff
	ff		 lea	 eax, DWORD PTR __k$529595[ebp]
  0171c	50		 push	 eax
  0171d	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01723	ff d7		 call	 edi

; 1118 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_GREATERTHEN, szKeyText ) );

  01725	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0172b	50		 push	 eax
  0172c	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523164[ebp]
  01732	50		 push	 eax
  01733	8d 8d 80 ea ff
	ff		 lea	 ecx, DWORD PTR $T523163[ebp]
  01739	c7 85 cc f1 ff
	ff 3e 00 00 00	 mov	 DWORD PTR $T523164[ebp], 62 ; 0000003eH
  01743	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  01748	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  0174e	50		 push	 eax
  0174f	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523165[ebp]
  01755	50		 push	 eax
  01756	c6 45 fc 23	 mov	 BYTE PTR __$EHRec$[ebp+8], 35 ; 00000023H
  0175a	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  0175f	8d 8d 84 ea ff
	ff		 lea	 ecx, DWORD PTR $T523163[ebp+4]
  01765	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01769	ff d3		 call	 ebx
  0176b	6a 02		 push	 2

; 1119 : 
; 1120 : 	kLoader.LoadString_e( "KEY_QMARK", "", szKeyText, MAX_PATH );

  0176d	c7 85 40 fa ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$529730[ebp], -1246582362 ; b5b2a9a6H
  01777	c7 85 44 fa ff
	ff bc a1 aa b8	 mov	 DWORD PTR __k$529730[ebp+4], -1196777028 ; b8aaa1bcH
  01781	8d 85 40 fa ff
	ff		 lea	 eax, DWORD PTR __k$529730[ebp]
  01787	66 c7 85 48 fa
	ff ff a6 00	 mov	 WORD PTR __k$529730[ebp+8], 166 ; 000000a6H
  01790	59		 pop	 ecx
$LL4789@Load@4:
  01791	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  01797	83 c0 04	 add	 eax, 4
  0179a	49		 dec	 ecx
  0179b	75 f4		 jne	 SHORT $LL4789@Load@4
  0179d	80 b5 48 fa ff
	ff ed		 xor	 BYTE PTR __k$529730[ebp+8], -19 ; ffffffedH
  017a4	56		 push	 esi
  017a5	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  017ab	50		 push	 eax
  017ac	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  017b1	8d 85 40 fa ff
	ff		 lea	 eax, DWORD PTR __k$529730[ebp]
  017b7	50		 push	 eax
  017b8	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  017be	ff d7		 call	 edi

; 1121 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_QMARK, szKeyText ) );

  017c0	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  017c6	50		 push	 eax
  017c7	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523167[ebp]
  017cd	50		 push	 eax
  017ce	8d 8d 08 ef ff
	ff		 lea	 ecx, DWORD PTR $T523166[ebp]
  017d4	c7 85 cc f1 ff
	ff 3f 00 00 00	 mov	 DWORD PTR $T523167[ebp], 63 ; 0000003fH
  017de	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  017e3	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  017e9	50		 push	 eax
  017ea	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523168[ebp]
  017f0	50		 push	 eax
  017f1	c6 45 fc 24	 mov	 BYTE PTR __$EHRec$[ebp+8], 36 ; 00000024H
  017f5	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  017fa	8d 8d 0c ef ff
	ff		 lea	 ecx, DWORD PTR $T523166[ebp+4]
  01800	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01804	ff d3		 call	 ebx
  01806	6a 03		 push	 3

; 1122 : 
; 1123 : 	kLoader.LoadString_e( "KEY_LBRACKET", "", szKeyText, MAX_PATH );

  01808	c7 85 b8 f7 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$529865[ebp], -1246582362 ; b5b2a9a6H
  01812	c7 85 bc f7 ff
	ff a1 ae b9 ab	 mov	 DWORD PTR __k$529865[ebp+4], -1413894495 ; abb9aea1H
  0181c	c7 85 c0 f7 ff
	ff ae a7 ae be	 mov	 DWORD PTR __k$529865[ebp+8], -1095850066 ; beaea7aeH
  01826	8d 85 b8 f7 ff
	ff		 lea	 eax, DWORD PTR __k$529865[ebp]
  0182c	c6 85 c4 f7 ff
	ff 00		 mov	 BYTE PTR __k$529865[ebp+12], 0
  01833	59		 pop	 ecx
$LL4901@Load@4:
  01834	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0183a	83 c0 04	 add	 eax, 4
  0183d	49		 dec	 ecx
  0183e	75 f4		 jne	 SHORT $LL4901@Load@4
  01840	56		 push	 esi
  01841	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01847	50		 push	 eax
  01848	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0184d	8d 85 b8 f7 ff
	ff		 lea	 eax, DWORD PTR __k$529865[ebp]
  01853	50		 push	 eax
  01854	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0185a	ff d7		 call	 edi

; 1124 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_LBRACKET, szKeyText ) );

  0185c	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01862	50		 push	 eax
  01863	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523170[ebp]
  01869	50		 push	 eax
  0186a	8d 8d 28 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523169[ebp]
  01870	c7 85 cc f1 ff
	ff 5b 00 00 00	 mov	 DWORD PTR $T523170[ebp], 91 ; 0000005bH
  0187a	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  0187f	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  01885	50		 push	 eax
  01886	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523171[ebp]
  0188c	50		 push	 eax
  0188d	c6 45 fc 25	 mov	 BYTE PTR __$EHRec$[ebp+8], 37 ; 00000025H
  01891	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  01896	8d 8d 2c e8 ff
	ff		 lea	 ecx, DWORD PTR $T523169[ebp+4]
  0189c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  018a0	ff d3		 call	 ebx
  018a2	6a 03		 push	 3

; 1125 : 
; 1126 : 	kLoader.LoadString_e( "KEY_BACKSLASH", "", szKeyText, MAX_PATH );

  018a4	c7 85 44 fd ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$529987[ebp], -1246582362 ; b5b2a9a6H
  018ae	c7 85 48 fd ff
	ff af ad a8 a1	 mov	 DWORD PTR __k$529987[ebp+4], -1582781009 ; a1a8adafH
  018b8	c7 85 4c fd ff
	ff be a0 aa b9	 mov	 DWORD PTR __k$529987[ebp+8], -1180000066 ; b9aaa0beH
  018c2	8d 85 44 fd ff
	ff		 lea	 eax, DWORD PTR __k$529987[ebp]
  018c8	66 c7 85 50 fd
	ff ff a5 00	 mov	 WORD PTR __k$529987[ebp+12], 165 ; 000000a5H
  018d1	59		 pop	 ecx
$LL5013@Load@4:
  018d2	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  018d8	83 c0 04	 add	 eax, 4
  018db	49		 dec	 ecx
  018dc	75 f4		 jne	 SHORT $LL5013@Load@4
  018de	80 b5 50 fd ff
	ff ed		 xor	 BYTE PTR __k$529987[ebp+12], -19 ; ffffffedH
  018e5	56		 push	 esi
  018e6	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  018ec	50		 push	 eax
  018ed	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  018f2	8d 85 44 fd ff
	ff		 lea	 eax, DWORD PTR __k$529987[ebp]
  018f8	50		 push	 eax
  018f9	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  018ff	ff d7		 call	 edi

; 1127 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_BACKSLASH, szKeyText ) );

  01901	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01907	50		 push	 eax
  01908	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523173[ebp]
  0190e	50		 push	 eax
  0190f	8d 8d e0 ee ff
	ff		 lea	 ecx, DWORD PTR $T523172[ebp]
  01915	c7 85 cc f1 ff
	ff 5c 00 00 00	 mov	 DWORD PTR $T523173[ebp], 92 ; 0000005cH
  0191f	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  01924	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  0192a	50		 push	 eax
  0192b	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523174[ebp]
  01931	50		 push	 eax
  01932	c6 45 fc 26	 mov	 BYTE PTR __$EHRec$[ebp+8], 38 ; 00000026H
  01936	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  0193b	8d 8d e4 ee ff
	ff		 lea	 ecx, DWORD PTR $T523172[ebp+4]
  01941	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01945	ff d3		 call	 ebx
  01947	6a 03		 push	 3

; 1128 : 
; 1129 : 	kLoader.LoadString_e( "KEY_RBRACKET", "", szKeyText, MAX_PATH );

  01949	c7 85 90 f7 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$530122[ebp], -1246582362 ; b5b2a9a6H
  01953	c7 85 94 f7 ff
	ff bf ae b9 ab	 mov	 DWORD PTR __k$530122[ebp+4], -1413894465 ; abb9aebfH
  0195d	c7 85 98 f7 ff
	ff ae a7 ae be	 mov	 DWORD PTR __k$530122[ebp+8], -1095850066 ; beaea7aeH
  01967	8d 85 90 f7 ff
	ff		 lea	 eax, DWORD PTR __k$530122[ebp]
  0196d	c6 85 9c f7 ff
	ff 00		 mov	 BYTE PTR __k$530122[ebp+12], 0
  01974	59		 pop	 ecx
$LL5125@Load@4:
  01975	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0197b	83 c0 04	 add	 eax, 4
  0197e	49		 dec	 ecx
  0197f	75 f4		 jne	 SHORT $LL5125@Load@4
  01981	56		 push	 esi
  01982	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01988	50		 push	 eax
  01989	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0198e	8d 85 90 f7 ff
	ff		 lea	 eax, DWORD PTR __k$530122[ebp]
  01994	50		 push	 eax
  01995	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0199b	ff d7		 call	 edi

; 1130 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_RBRACKET, szKeyText ) );

  0199d	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  019a3	50		 push	 eax
  019a4	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523176[ebp]
  019aa	50		 push	 eax
  019ab	8d 8d 58 ea ff
	ff		 lea	 ecx, DWORD PTR $T523175[ebp]
  019b1	c7 85 cc f1 ff
	ff 5d 00 00 00	 mov	 DWORD PTR $T523176[ebp], 93 ; 0000005dH
  019bb	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  019c0	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  019c6	50		 push	 eax
  019c7	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523177[ebp]
  019cd	50		 push	 eax
  019ce	c6 45 fc 27	 mov	 BYTE PTR __$EHRec$[ebp+8], 39 ; 00000027H
  019d2	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  019d7	8d 8d 5c ea ff
	ff		 lea	 ecx, DWORD PTR $T523175[ebp+4]
  019dd	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  019e1	ff d3		 call	 ebx
  019e3	6a 02		 push	 2

; 1131 : 
; 1132 : 	kLoader.LoadString_e( "KEY_CARETE", "", szKeyText, MAX_PATH );

  019e5	c7 85 a4 fc ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$530272[ebp], -1246582362 ; b5b2a9a6H
  019ef	c7 85 a8 fc ff
	ff ae ad b9 af	 mov	 DWORD PTR __k$530272[ebp+4], -1346785874 ; afb9adaeH
  019f9	66 c7 85 ac fc
	ff ff b9 a9	 mov	 WORD PTR __k$530272[ebp+8], 43449 ; 0000a9b9H
  01a02	8d 85 a4 fc ff
	ff		 lea	 eax, DWORD PTR __k$530272[ebp]
  01a08	c6 85 ae fc ff
	ff 00		 mov	 BYTE PTR __k$530272[ebp+10], 0
  01a0f	59		 pop	 ecx
$LL5237@Load@4:
  01a10	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  01a16	83 c0 04	 add	 eax, 4
  01a19	49		 dec	 ecx
  01a1a	75 f4		 jne	 SHORT $LL5237@Load@4
  01a1c	6a 08		 push	 8
  01a1e	58		 pop	 eax
$LL5234@Load@4:
  01a1f	8b c8		 mov	 ecx, eax
  01a21	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  01a27	79 05		 jns	 SHORT $LN18422@Load@4
  01a29	49		 dec	 ecx
  01a2a	83 c9 fc	 or	 ecx, -4			; fffffffcH
  01a2d	41		 inc	 ecx
$LN18422@Load@4:
  01a2e	b2 ed		 mov	 dl, -19			; ffffffedH
  01a30	2a d1		 sub	 dl, cl
  01a32	30 94 05 a4 fc
	ff ff		 xor	 BYTE PTR __k$530272[ebp+eax], dl
  01a39	40		 inc	 eax
  01a3a	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  01a3d	7c e0		 jl	 SHORT $LL5234@Load@4
  01a3f	56		 push	 esi
  01a40	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01a46	50		 push	 eax
  01a47	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  01a4c	8d 85 a4 fc ff
	ff		 lea	 eax, DWORD PTR __k$530272[ebp]
  01a52	50		 push	 eax
  01a53	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01a59	ff d7		 call	 edi

; 1133 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_CARETE, szKeyText ) );

  01a5b	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01a61	50		 push	 eax
  01a62	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523179[ebp]
  01a68	50		 push	 eax
  01a69	8d 8d b8 ee ff
	ff		 lea	 ecx, DWORD PTR $T523178[ebp]
  01a6f	c7 85 cc f1 ff
	ff 5e 00 00 00	 mov	 DWORD PTR $T523179[ebp], 94 ; 0000005eH
  01a79	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  01a7e	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  01a84	50		 push	 eax
  01a85	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523180[ebp]
  01a8b	50		 push	 eax
  01a8c	c6 45 fc 28	 mov	 BYTE PTR __$EHRec$[ebp+8], 40 ; 00000028H
  01a90	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  01a95	8d 8d bc ee ff
	ff		 lea	 ecx, DWORD PTR $T523178[ebp+4]
  01a9b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01a9f	ff d3		 call	 ebx
  01aa1	6a 03		 push	 3

; 1134 : 
; 1135 : 	kLoader.LoadString_e( "KEY_UNDERSCORE", "", szKeyText, MAX_PATH );

  01aa3	c7 85 94 fb ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$530392[ebp], -1246582362 ; b5b2a9a6H
  01aad	c7 85 98 fb ff
	ff b8 a2 af af	 mov	 DWORD PTR __k$530392[ebp+4], -1347444040 ; afafa2b8H
  01ab7	c7 85 9c fb ff
	ff bf bf a8 a5	 mov	 DWORD PTR __k$530392[ebp+8], -1515667521 ; a5a8bfbfH
  01ac1	66 c7 85 a0 fb
	ff ff bf a9	 mov	 WORD PTR __k$530392[ebp+12], 43455 ; 0000a9bfH
  01aca	8d 85 94 fb ff
	ff		 lea	 eax, DWORD PTR __k$530392[ebp]
  01ad0	c6 85 a2 fb ff
	ff 00		 mov	 BYTE PTR __k$530392[ebp+14], 0
  01ad7	59		 pop	 ecx
$LL5349@Load@4:
  01ad8	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  01ade	83 c0 04	 add	 eax, 4
  01ae1	49		 dec	 ecx
  01ae2	75 f4		 jne	 SHORT $LL5349@Load@4
  01ae4	6a 0c		 push	 12			; 0000000cH
  01ae6	58		 pop	 eax
$LL5346@Load@4:
  01ae7	8b c8		 mov	 ecx, eax
  01ae9	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  01aef	79 05		 jns	 SHORT $LN18423@Load@4
  01af1	49		 dec	 ecx
  01af2	83 c9 fc	 or	 ecx, -4			; fffffffcH
  01af5	41		 inc	 ecx
$LN18423@Load@4:
  01af6	b2 ed		 mov	 dl, -19			; ffffffedH
  01af8	2a d1		 sub	 dl, cl
  01afa	30 94 05 94 fb
	ff ff		 xor	 BYTE PTR __k$530392[ebp+eax], dl
  01b01	40		 inc	 eax
  01b02	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  01b05	7c e0		 jl	 SHORT $LL5346@Load@4
  01b07	56		 push	 esi
  01b08	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01b0e	50		 push	 eax
  01b0f	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  01b14	8d 85 94 fb ff
	ff		 lea	 eax, DWORD PTR __k$530392[ebp]
  01b1a	50		 push	 eax
  01b1b	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01b21	ff d7		 call	 edi

; 1136 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_UNDERSCORE, szKeyText ) );

  01b23	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01b29	50		 push	 eax
  01b2a	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523182[ebp]
  01b30	50		 push	 eax
  01b31	8d 8d 70 e6 ff
	ff		 lea	 ecx, DWORD PTR $T523181[ebp]
  01b37	c7 85 cc f1 ff
	ff 5f 00 00 00	 mov	 DWORD PTR $T523182[ebp], 95 ; 0000005fH
  01b41	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  01b46	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  01b4c	50		 push	 eax
  01b4d	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523183[ebp]
  01b53	50		 push	 eax
  01b54	c6 45 fc 29	 mov	 BYTE PTR __$EHRec$[ebp+8], 41 ; 00000029H
  01b58	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  01b5d	8d 8d 74 e6 ff
	ff		 lea	 ecx, DWORD PTR $T523181[ebp+4]
  01b63	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01b67	ff d3		 call	 ebx
  01b69	6a 02		 push	 2

; 1137 : 
; 1138 : 	kLoader.LoadString_e( "KEY_GRAVE", "", szKeyText, MAX_PATH );

  01b6b	c7 85 58 fd ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$530540[ebp], -1246582362 ; b5b2a9a6H
  01b75	c7 85 5c fd ff
	ff aa be aa bc	 mov	 DWORD PTR __k$530540[ebp+4], -1129660758 ; bcaabeaaH
  01b7f	8d 85 58 fd ff
	ff		 lea	 eax, DWORD PTR __k$530540[ebp]
  01b85	66 c7 85 60 fd
	ff ff a8 00	 mov	 WORD PTR __k$530540[ebp+8], 168 ; 000000a8H
  01b8e	59		 pop	 ecx
$LL5461@Load@4:
  01b8f	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  01b95	83 c0 04	 add	 eax, 4
  01b98	49		 dec	 ecx
  01b99	75 f4		 jne	 SHORT $LL5461@Load@4
  01b9b	80 b5 60 fd ff
	ff ed		 xor	 BYTE PTR __k$530540[ebp+8], -19 ; ffffffedH
  01ba2	56		 push	 esi
  01ba3	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01ba9	50		 push	 eax
  01baa	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  01baf	8d 85 58 fd ff
	ff		 lea	 eax, DWORD PTR __k$530540[ebp]
  01bb5	50		 push	 eax
  01bb6	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01bbc	ff d7		 call	 edi

; 1139 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_GRAVE, szKeyText ) );

  01bbe	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01bc4	50		 push	 eax
  01bc5	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523185[ebp]
  01bcb	50		 push	 eax
  01bcc	8d 8d 90 ee ff
	ff		 lea	 ecx, DWORD PTR $T523184[ebp]
  01bd2	c7 85 cc f1 ff
	ff 60 00 00 00	 mov	 DWORD PTR $T523185[ebp], 96 ; 00000060H
  01bdc	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  01be1	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  01be7	50		 push	 eax
  01be8	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523186[ebp]
  01bee	50		 push	 eax
  01bef	c6 45 fc 2a	 mov	 BYTE PTR __$EHRec$[ebp+8], 42 ; 0000002aH
  01bf3	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  01bf8	8d 8d 94 ee ff
	ff		 lea	 ecx, DWORD PTR $T523184[ebp+4]
  01bfe	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01c02	ff d3		 call	 ebx

; 1140 : 
; 1141 : 	kLoader.LoadString_e( "KEY_A", "", szKeyText, MAX_PATH );

  01c04	56		 push	 esi
  01c05	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01c0b	50		 push	 eax
  01c0c	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  01c11	8d 85 30 f9 ff
	ff		 lea	 eax, DWORD PTR __k$530675[ebp]
  01c17	c7 85 30 f9 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$530675[ebp], -1246582362 ; b5b2a9a6H
  01c21	81 b5 30 f9 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$530675[ebp], -353637139 ; eaebecedH
  01c2b	50		 push	 eax
  01c2c	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01c32	66 c7 85 34 f9
	ff ff 41 00	 mov	 WORD PTR __k$530675[ebp+4], 65 ; 00000041H
  01c3b	ff d7		 call	 edi

; 1142 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_A, szKeyText ) );

  01c3d	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01c43	50		 push	 eax
  01c44	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523188[ebp]
  01c4a	50		 push	 eax
  01c4b	8d 8d 30 ea ff
	ff		 lea	 ecx, DWORD PTR $T523187[ebp]
  01c51	c7 85 cc f1 ff
	ff 61 00 00 00	 mov	 DWORD PTR $T523188[ebp], 97 ; 00000061H
  01c5b	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  01c60	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  01c66	50		 push	 eax
  01c67	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523189[ebp]
  01c6d	50		 push	 eax
  01c6e	c6 45 fc 2b	 mov	 BYTE PTR __$EHRec$[ebp+8], 43 ; 0000002bH
  01c72	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  01c77	8d 8d 34 ea ff
	ff		 lea	 ecx, DWORD PTR $T523187[ebp+4]
  01c7d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01c81	ff d3		 call	 ebx

; 1143 : 
; 1144 : 	kLoader.LoadString_e( "KEY_B", "", szKeyText, MAX_PATH );

  01c83	56		 push	 esi
  01c84	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01c8a	50		 push	 eax
  01c8b	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  01c90	8d 85 00 f9 ff
	ff		 lea	 eax, DWORD PTR __k$530810[ebp]
  01c96	c7 85 00 f9 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$530810[ebp], -1246582362 ; b5b2a9a6H
  01ca0	81 b5 00 f9 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$530810[ebp], -353637139 ; eaebecedH
  01caa	50		 push	 eax
  01cab	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01cb1	66 c7 85 04 f9
	ff ff 42 00	 mov	 WORD PTR __k$530810[ebp+4], 66 ; 00000042H
  01cba	ff d7		 call	 edi

; 1145 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_B, szKeyText ) );

  01cbc	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01cc2	50		 push	 eax
  01cc3	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523191[ebp]
  01cc9	50		 push	 eax
  01cca	8d 8d 68 ee ff
	ff		 lea	 ecx, DWORD PTR $T523190[ebp]
  01cd0	c7 85 cc f1 ff
	ff 62 00 00 00	 mov	 DWORD PTR $T523191[ebp], 98 ; 00000062H
  01cda	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  01cdf	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  01ce5	50		 push	 eax
  01ce6	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523192[ebp]
  01cec	50		 push	 eax
  01ced	c6 45 fc 2c	 mov	 BYTE PTR __$EHRec$[ebp+8], 44 ; 0000002cH
  01cf1	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  01cf6	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01cfa	8d 8d 6c ee ff
	ff		 lea	 ecx, DWORD PTR $T523190[ebp+4]
  01d00	ff d3		 call	 ebx

; 1146 : 
; 1147 : 	kLoader.LoadString_e( "KEY_C", "", szKeyText, MAX_PATH );

  01d02	56		 push	 esi
  01d03	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01d09	50		 push	 eax
  01d0a	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  01d0f	8d 85 e8 f8 ff
	ff		 lea	 eax, DWORD PTR __k$530945[ebp]
  01d15	c7 85 e8 f8 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$530945[ebp], -1246582362 ; b5b2a9a6H
  01d1f	81 b5 e8 f8 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$530945[ebp], -353637139 ; eaebecedH
  01d29	50		 push	 eax
  01d2a	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01d30	66 c7 85 ec f8
	ff ff 43 00	 mov	 WORD PTR __k$530945[ebp+4], 67 ; 00000043H
  01d39	ff d7		 call	 edi

; 1148 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_C, szKeyText ) );

  01d3b	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01d41	50		 push	 eax
  01d42	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523194[ebp]
  01d48	50		 push	 eax
  01d49	8d 8d 00 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523193[ebp]
  01d4f	c7 85 cc f1 ff
	ff 63 00 00 00	 mov	 DWORD PTR $T523194[ebp], 99 ; 00000063H
  01d59	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  01d5e	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  01d64	50		 push	 eax
  01d65	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523195[ebp]
  01d6b	50		 push	 eax
  01d6c	c6 45 fc 2d	 mov	 BYTE PTR __$EHRec$[ebp+8], 45 ; 0000002dH
  01d70	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  01d75	8d 8d 04 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523193[ebp+4]
  01d7b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01d7f	ff d3		 call	 ebx

; 1149 : 
; 1150 : 	kLoader.LoadString_e( "KEY_D", "", szKeyText, MAX_PATH );

  01d81	56		 push	 esi
  01d82	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01d88	50		 push	 eax
  01d89	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  01d8e	8d 85 d0 f8 ff
	ff		 lea	 eax, DWORD PTR __k$531067[ebp]
  01d94	c7 85 d0 f8 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$531067[ebp], -1246582362 ; b5b2a9a6H
  01d9e	81 b5 d0 f8 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$531067[ebp], -353637139 ; eaebecedH
  01da8	50		 push	 eax
  01da9	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01daf	66 c7 85 d4 f8
	ff ff 44 00	 mov	 WORD PTR __k$531067[ebp+4], 68 ; 00000044H
  01db8	ff d7		 call	 edi

; 1151 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_D, szKeyText ) );

  01dba	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01dc0	50		 push	 eax
  01dc1	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523197[ebp]
  01dc7	50		 push	 eax
  01dc8	8d 8d 40 ee ff
	ff		 lea	 ecx, DWORD PTR $T523196[ebp]
  01dce	c7 85 cc f1 ff
	ff 64 00 00 00	 mov	 DWORD PTR $T523197[ebp], 100 ; 00000064H
  01dd8	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  01ddd	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  01de3	50		 push	 eax
  01de4	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523198[ebp]
  01dea	50		 push	 eax
  01deb	c6 45 fc 2e	 mov	 BYTE PTR __$EHRec$[ebp+8], 46 ; 0000002eH
  01def	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  01df4	8d 8d 44 ee ff
	ff		 lea	 ecx, DWORD PTR $T523196[ebp+4]
  01dfa	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01dfe	ff d3		 call	 ebx

; 1152 : 
; 1153 : 	kLoader.LoadString_e( "KEY_E", "", szKeyText, MAX_PATH );

  01e00	56		 push	 esi
  01e01	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01e07	50		 push	 eax
  01e08	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  01e0d	8d 85 b8 f8 ff
	ff		 lea	 eax, DWORD PTR __k$531202[ebp]
  01e13	c7 85 b8 f8 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$531202[ebp], -1246582362 ; b5b2a9a6H
  01e1d	81 b5 b8 f8 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$531202[ebp], -353637139 ; eaebecedH
  01e27	50		 push	 eax
  01e28	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01e2e	66 c7 85 bc f8
	ff ff 45 00	 mov	 WORD PTR __k$531202[ebp+4], 69 ; 00000045H
  01e37	ff d7		 call	 edi

; 1154 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_E, szKeyText ) );

  01e39	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01e3f	50		 push	 eax
  01e40	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523200[ebp]
  01e46	50		 push	 eax
  01e47	8d 8d 08 ea ff
	ff		 lea	 ecx, DWORD PTR $T523199[ebp]
  01e4d	c7 85 cc f1 ff
	ff 65 00 00 00	 mov	 DWORD PTR $T523200[ebp], 101 ; 00000065H
  01e57	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  01e5c	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  01e62	50		 push	 eax
  01e63	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523201[ebp]
  01e69	c6 45 fc 2f	 mov	 BYTE PTR __$EHRec$[ebp+8], 47 ; 0000002fH
  01e6d	50		 push	 eax
  01e6e	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  01e73	8d 8d 0c ea ff
	ff		 lea	 ecx, DWORD PTR $T523199[ebp+4]
  01e79	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01e7d	ff d3		 call	 ebx

; 1155 : 
; 1156 : 	kLoader.LoadString_e( "KEY_F", "", szKeyText, MAX_PATH );

  01e7f	56		 push	 esi
  01e80	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01e86	50		 push	 eax
  01e87	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  01e8c	8d 85 7c f8 ff
	ff		 lea	 eax, DWORD PTR __k$531337[ebp]
  01e92	c7 85 7c f8 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$531337[ebp], -1246582362 ; b5b2a9a6H
  01e9c	81 b5 7c f8 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$531337[ebp], -353637139 ; eaebecedH
  01ea6	50		 push	 eax
  01ea7	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01ead	66 c7 85 80 f8
	ff ff 46 00	 mov	 WORD PTR __k$531337[ebp+4], 70 ; 00000046H
  01eb6	ff d7		 call	 edi

; 1157 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_F, szKeyText ) );

  01eb8	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01ebe	50		 push	 eax
  01ebf	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523203[ebp]
  01ec5	50		 push	 eax
  01ec6	8d 8d 18 ee ff
	ff		 lea	 ecx, DWORD PTR $T523202[ebp]
  01ecc	c7 85 cc f1 ff
	ff 66 00 00 00	 mov	 DWORD PTR $T523203[ebp], 102 ; 00000066H
  01ed6	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  01edb	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  01ee1	50		 push	 eax
  01ee2	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523204[ebp]
  01ee8	50		 push	 eax
  01ee9	c6 45 fc 30	 mov	 BYTE PTR __$EHRec$[ebp+8], 48 ; 00000030H
  01eed	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  01ef2	8d 8d 1c ee ff
	ff		 lea	 ecx, DWORD PTR $T523202[ebp+4]
  01ef8	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01efc	ff d3		 call	 ebx

; 1158 : 
; 1159 : 	kLoader.LoadString_e( "KEY_G", "", szKeyText, MAX_PATH );

  01efe	56		 push	 esi
  01eff	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01f05	50		 push	 eax
  01f06	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  01f0b	8d 85 e4 f9 ff
	ff		 lea	 eax, DWORD PTR __k$531485[ebp]
  01f11	c7 85 e4 f9 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$531485[ebp], -1246582362 ; b5b2a9a6H
  01f1b	81 b5 e4 f9 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$531485[ebp], -353637139 ; eaebecedH
  01f25	50		 push	 eax
  01f26	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01f2c	66 c7 85 e8 f9
	ff ff 47 00	 mov	 WORD PTR __k$531485[ebp+4], 71 ; 00000047H
  01f35	ff d7		 call	 edi

; 1160 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_G, szKeyText ) );

  01f37	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01f3d	50		 push	 eax
  01f3e	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523206[ebp]
  01f44	50		 push	 eax
  01f45	8d 8d e8 e6 ff
	ff		 lea	 ecx, DWORD PTR $T523205[ebp]
  01f4b	c7 85 cc f1 ff
	ff 67 00 00 00	 mov	 DWORD PTR $T523206[ebp], 103 ; 00000067H
  01f55	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  01f5a	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  01f60	50		 push	 eax
  01f61	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523207[ebp]
  01f67	50		 push	 eax
  01f68	c6 45 fc 31	 mov	 BYTE PTR __$EHRec$[ebp+8], 49 ; 00000031H
  01f6c	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  01f71	8d 8d ec e6 ff
	ff		 lea	 ecx, DWORD PTR $T523205[ebp+4]
  01f77	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01f7b	ff d3		 call	 ebx

; 1161 : 
; 1162 : 	kLoader.LoadString_e( "KEY_H", "", szKeyText, MAX_PATH );

  01f7d	56		 push	 esi
  01f7e	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01f84	50		 push	 eax
  01f85	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  01f8a	8d 85 fc f9 ff
	ff		 lea	 eax, DWORD PTR __k$531620[ebp]
  01f90	c7 85 fc f9 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$531620[ebp], -1246582362 ; b5b2a9a6H
  01f9a	81 b5 fc f9 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$531620[ebp], -353637139 ; eaebecedH
  01fa4	50		 push	 eax
  01fa5	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  01fab	66 c7 85 00 fa
	ff ff 48 00	 mov	 WORD PTR __k$531620[ebp+4], 72 ; 00000048H
  01fb4	ff d7		 call	 edi

; 1163 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_H, szKeyText ) );

  01fb6	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  01fbc	50		 push	 eax
  01fbd	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523209[ebp]
  01fc3	50		 push	 eax
  01fc4	8d 8d f0 ed ff
	ff		 lea	 ecx, DWORD PTR $T523208[ebp]
  01fca	c7 85 cc f1 ff
	ff 68 00 00 00	 mov	 DWORD PTR $T523209[ebp], 104 ; 00000068H
  01fd4	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  01fd9	c6 45 fc 32	 mov	 BYTE PTR __$EHRec$[ebp+8], 50 ; 00000032H
  01fdd	50		 push	 eax
  01fde	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  01fe4	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523210[ebp]
  01fea	50		 push	 eax
  01feb	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  01ff0	8d 8d f4 ed ff
	ff		 lea	 ecx, DWORD PTR $T523208[ebp+4]
  01ff6	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01ffa	ff d3		 call	 ebx

; 1164 : 
; 1165 : 	kLoader.LoadString_e( "KEY_I", "", szKeyText, MAX_PATH );

  01ffc	56		 push	 esi
  01ffd	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  02003	50		 push	 eax
  02004	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  02009	8d 85 a0 f8 ff
	ff		 lea	 eax, DWORD PTR __k$531755[ebp]
  0200f	c7 85 a0 f8 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$531755[ebp], -1246582362 ; b5b2a9a6H
  02019	81 b5 a0 f8 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$531755[ebp], -353637139 ; eaebecedH
  02023	50		 push	 eax
  02024	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0202a	66 c7 85 a4 f8
	ff ff 49 00	 mov	 WORD PTR __k$531755[ebp+4], 73 ; 00000049H
  02033	ff d7		 call	 edi

; 1166 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_I, szKeyText ) );

  02035	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0203b	50		 push	 eax
  0203c	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523212[ebp]
  02042	50		 push	 eax
  02043	8d 8d e0 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523211[ebp]
  02049	c7 85 cc f1 ff
	ff 69 00 00 00	 mov	 DWORD PTR $T523212[ebp], 105 ; 00000069H
  02053	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  02058	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  0205e	50		 push	 eax
  0205f	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523213[ebp]
  02065	50		 push	 eax
  02066	c6 45 fc 33	 mov	 BYTE PTR __$EHRec$[ebp+8], 51 ; 00000033H
  0206a	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  0206f	8d 8d e4 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523211[ebp+4]
  02075	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  02079	ff d3		 call	 ebx

; 1167 : 
; 1168 : 	kLoader.LoadString_e( "KEY_J", "", szKeyText, MAX_PATH );

  0207b	56		 push	 esi
  0207c	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  02082	50		 push	 eax
  02083	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  02088	8d 85 88 f8 ff
	ff		 lea	 eax, DWORD PTR __k$531890[ebp]
  0208e	c7 85 88 f8 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$531890[ebp], -1246582362 ; b5b2a9a6H
  02098	81 b5 88 f8 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$531890[ebp], -353637139 ; eaebecedH
  020a2	50		 push	 eax
  020a3	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  020a9	66 c7 85 8c f8
	ff ff 4a 00	 mov	 WORD PTR __k$531890[ebp+4], 74 ; 0000004aH
  020b2	ff d7		 call	 edi

; 1169 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_J, szKeyText ) );

  020b4	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  020ba	50		 push	 eax
  020bb	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523215[ebp]
  020c1	50		 push	 eax
  020c2	8d 8d c8 ed ff
	ff		 lea	 ecx, DWORD PTR $T523214[ebp]
  020c8	c7 85 cc f1 ff
	ff 6a 00 00 00	 mov	 DWORD PTR $T523215[ebp], 106 ; 0000006aH
  020d2	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  020d7	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  020dd	50		 push	 eax
  020de	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523216[ebp]
  020e4	50		 push	 eax
  020e5	c6 45 fc 34	 mov	 BYTE PTR __$EHRec$[ebp+8], 52 ; 00000034H
  020e9	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  020ee	8d 8d cc ed ff
	ff		 lea	 ecx, DWORD PTR $T523214[ebp+4]
  020f4	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  020f8	ff d3		 call	 ebx

; 1170 : 
; 1171 : 	kLoader.LoadString_e( "KEY_K", "", szKeyText, MAX_PATH );

  020fa	56		 push	 esi
  020fb	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  02101	50		 push	 eax
  02102	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  02107	8d 85 70 f8 ff
	ff		 lea	 eax, DWORD PTR __k$532025[ebp]
  0210d	c7 85 70 f8 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$532025[ebp], -1246582362 ; b5b2a9a6H
  02117	81 b5 70 f8 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$532025[ebp], -353637139 ; eaebecedH
  02121	50		 push	 eax
  02122	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02128	66 c7 85 74 f8
	ff ff 4b 00	 mov	 WORD PTR __k$532025[ebp+4], 75 ; 0000004bH
  02131	ff d7		 call	 edi

; 1172 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_K, szKeyText ) );

  02133	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  02139	50		 push	 eax
  0213a	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523218[ebp]
  02140	50		 push	 eax
  02141	8d 8d d8 e7 ff
	ff		 lea	 ecx, DWORD PTR $T523217[ebp]
  02147	c7 85 cc f1 ff
	ff 6b 00 00 00	 mov	 DWORD PTR $T523218[ebp], 107 ; 0000006bH
  02151	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  02156	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  0215c	50		 push	 eax
  0215d	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523219[ebp]
  02163	50		 push	 eax
  02164	c6 45 fc 35	 mov	 BYTE PTR __$EHRec$[ebp+8], 53 ; 00000035H
  02168	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  0216d	8d 8d dc e7 ff
	ff		 lea	 ecx, DWORD PTR $T523217[ebp+4]
  02173	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  02177	ff d3		 call	 ebx

; 1173 : 
; 1174 : 	kLoader.LoadString_e( "KEY_L", "", szKeyText, MAX_PATH );

  02179	56		 push	 esi
  0217a	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  02180	50		 push	 eax
  02181	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  02186	8d 85 58 f8 ff
	ff		 lea	 eax, DWORD PTR __k$532147[ebp]
  0218c	c7 85 58 f8 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$532147[ebp], -1246582362 ; b5b2a9a6H
  02196	81 b5 58 f8 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$532147[ebp], -353637139 ; eaebecedH
  021a0	50		 push	 eax
  021a1	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  021a7	66 c7 85 5c f8
	ff ff 4c 00	 mov	 WORD PTR __k$532147[ebp+4], 76 ; 0000004cH
  021b0	ff d7		 call	 edi

; 1175 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_L, szKeyText ) );

  021b2	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  021b8	50		 push	 eax
  021b9	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523221[ebp]
  021bf	50		 push	 eax
  021c0	8d 8d a0 ed ff
	ff		 lea	 ecx, DWORD PTR $T523220[ebp]
  021c6	c7 85 cc f1 ff
	ff 6c 00 00 00	 mov	 DWORD PTR $T523221[ebp], 108 ; 0000006cH
  021d0	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  021d5	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  021db	50		 push	 eax
  021dc	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523222[ebp]
  021e2	50		 push	 eax
  021e3	c6 45 fc 36	 mov	 BYTE PTR __$EHRec$[ebp+8], 54 ; 00000036H
  021e7	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  021ec	8d 8d a4 ed ff
	ff		 lea	 ecx, DWORD PTR $T523220[ebp+4]
  021f2	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  021f6	ff d3		 call	 ebx

; 1176 : 
; 1177 : 	kLoader.LoadString_e( "KEY_M", "", szKeyText, MAX_PATH );

  021f8	56		 push	 esi
  021f9	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  021ff	50		 push	 eax
  02200	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  02205	8d 85 18 f9 ff
	ff		 lea	 eax, DWORD PTR __k$532282[ebp]
  0220b	c7 85 18 f9 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$532282[ebp], -1246582362 ; b5b2a9a6H
  02215	81 b5 18 f9 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$532282[ebp], -353637139 ; eaebecedH
  0221f	50		 push	 eax
  02220	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02226	66 c7 85 1c f9
	ff ff 4d 00	 mov	 WORD PTR __k$532282[ebp+4], 77 ; 0000004dH
  0222f	ff d7		 call	 edi

; 1178 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_M, szKeyText ) );

  02231	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  02237	50		 push	 eax
  02238	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523224[ebp]
  0223e	50		 push	 eax
  0223f	8d 8d b8 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523223[ebp]
  02245	c7 85 cc f1 ff
	ff 6d 00 00 00	 mov	 DWORD PTR $T523224[ebp], 109 ; 0000006dH
  0224f	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  02254	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  0225a	50		 push	 eax
  0225b	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523225[ebp]
  02261	50		 push	 eax
  02262	c6 45 fc 37	 mov	 BYTE PTR __$EHRec$[ebp+8], 55 ; 00000037H
  02266	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  0226b	8d 8d bc e9 ff
	ff		 lea	 ecx, DWORD PTR $T523223[ebp+4]
  02271	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  02275	ff d3		 call	 ebx

; 1179 : 
; 1180 : 	kLoader.LoadString_e( "KEY_N", "", szKeyText, MAX_PATH );

  02277	56		 push	 esi
  02278	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0227e	50		 push	 eax
  0227f	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  02284	8d 85 64 f8 ff
	ff		 lea	 eax, DWORD PTR __k$532417[ebp]
  0228a	c7 85 64 f8 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$532417[ebp], -1246582362 ; b5b2a9a6H
  02294	81 b5 64 f8 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$532417[ebp], -353637139 ; eaebecedH
  0229e	50		 push	 eax
  0229f	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  022a5	66 c7 85 68 f8
	ff ff 4e 00	 mov	 WORD PTR __k$532417[ebp+4], 78 ; 0000004eH
  022ae	ff d7		 call	 edi

; 1181 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_N, szKeyText ) );

  022b0	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  022b6	50		 push	 eax
  022b7	c7 85 cc f1 ff
	ff 6e 00 00 00	 mov	 DWORD PTR $T523227[ebp], 110 ; 0000006eH
  022c1	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523227[ebp]
  022c7	50		 push	 eax
  022c8	8d 8d 78 ed ff
	ff		 lea	 ecx, DWORD PTR $T523226[ebp]
  022ce	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  022d3	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  022d9	50		 push	 eax
  022da	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523228[ebp]
  022e0	50		 push	 eax
  022e1	c6 45 fc 38	 mov	 BYTE PTR __$EHRec$[ebp+8], 56 ; 00000038H
  022e5	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  022ea	8d 8d 7c ed ff
	ff		 lea	 ecx, DWORD PTR $T523226[ebp+4]
  022f0	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  022f4	ff d3		 call	 ebx

; 1182 : 
; 1183 : 	kLoader.LoadString_e( "KEY_O", "", szKeyText, MAX_PATH );

  022f6	56		 push	 esi
  022f7	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  022fd	50		 push	 eax
  022fe	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  02303	8d 85 cc f9 ff
	ff		 lea	 eax, DWORD PTR __k$532565[ebp]
  02309	c7 85 cc f9 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$532565[ebp], -1246582362 ; b5b2a9a6H
  02313	81 b5 cc f9 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$532565[ebp], -353637139 ; eaebecedH
  0231d	50		 push	 eax
  0231e	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02324	66 c7 85 d0 f9
	ff ff 4f 00	 mov	 WORD PTR __k$532565[ebp+4], 79 ; 0000004fH
  0232d	ff d7		 call	 edi

; 1184 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_O, szKeyText ) );

  0232f	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  02335	50		 push	 eax
  02336	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523230[ebp]
  0233c	50		 push	 eax
  0233d	8d 8d 20 e6 ff
	ff		 lea	 ecx, DWORD PTR $T523229[ebp]
  02343	c7 85 cc f1 ff
	ff 6f 00 00 00	 mov	 DWORD PTR $T523230[ebp], 111 ; 0000006fH
  0234d	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  02352	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  02358	50		 push	 eax
  02359	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523231[ebp]
  0235f	50		 push	 eax
  02360	c6 45 fc 39	 mov	 BYTE PTR __$EHRec$[ebp+8], 57 ; 00000039H
  02364	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  02369	8d 8d 24 e6 ff
	ff		 lea	 ecx, DWORD PTR $T523229[ebp+4]
  0236f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  02373	ff d3		 call	 ebx

; 1185 : 
; 1186 : 	kLoader.LoadString_e( "KEY_P", "", szKeyText, MAX_PATH );

  02375	56		 push	 esi
  02376	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0237c	50		 push	 eax
  0237d	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  02382	8d 85 0c f9 ff
	ff		 lea	 eax, DWORD PTR __k$532700[ebp]
  02388	c7 85 0c f9 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$532700[ebp], -1246582362 ; b5b2a9a6H
  02392	81 b5 0c f9 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$532700[ebp], -353637139 ; eaebecedH
  0239c	50		 push	 eax
  0239d	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  023a3	66 c7 85 10 f9
	ff ff 50 00	 mov	 WORD PTR __k$532700[ebp+4], 80 ; 00000050H
  023ac	ff d7		 call	 edi

; 1187 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_P, szKeyText ) );

  023ae	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  023b4	50		 push	 eax
  023b5	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523233[ebp]
  023bb	50		 push	 eax
  023bc	8d 8d 50 ed ff
	ff		 lea	 ecx, DWORD PTR $T523232[ebp]
  023c2	c7 85 cc f1 ff
	ff 70 00 00 00	 mov	 DWORD PTR $T523233[ebp], 112 ; 00000070H
  023cc	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  023d1	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  023d7	50		 push	 eax
  023d8	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523234[ebp]
  023de	50		 push	 eax
  023df	c6 45 fc 3a	 mov	 BYTE PTR __$EHRec$[ebp+8], 58 ; 0000003aH
  023e3	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  023e8	8d 8d 54 ed ff
	ff		 lea	 ecx, DWORD PTR $T523232[ebp+4]
  023ee	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  023f2	ff d3		 call	 ebx

; 1188 : 
; 1189 : 	kLoader.LoadString_e( "KEY_Q", "", szKeyText, MAX_PATH );

  023f4	56		 push	 esi
  023f5	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  023fb	50		 push	 eax
  023fc	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  02401	8d 85 b4 f9 ff
	ff		 lea	 eax, DWORD PTR __k$532835[ebp]
  02407	c7 85 b4 f9 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$532835[ebp], -1246582362 ; b5b2a9a6H
  02411	81 b5 b4 f9 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$532835[ebp], -353637139 ; eaebecedH
  0241b	50		 push	 eax
  0241c	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02422	66 c7 85 b8 f9
	ff ff 51 00	 mov	 WORD PTR __k$532835[ebp+4], 81 ; 00000051H
  0242b	ff d7		 call	 edi

; 1190 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_Q, szKeyText ) );

  0242d	c7 85 cc f1 ff
	ff 71 00 00 00	 mov	 DWORD PTR $T523236[ebp], 113 ; 00000071H
  02437	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0243d	50		 push	 eax
  0243e	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523236[ebp]
  02444	50		 push	 eax
  02445	8d 8d 90 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523235[ebp]
  0244b	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  02450	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  02456	50		 push	 eax
  02457	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523237[ebp]
  0245d	50		 push	 eax
  0245e	c6 45 fc 3b	 mov	 BYTE PTR __$EHRec$[ebp+8], 59 ; 0000003bH
  02462	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  02467	8d 8d 94 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523235[ebp+4]
  0246d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  02471	ff d3		 call	 ebx

; 1191 : 
; 1192 : 	kLoader.LoadString_e( "KEY_R", "", szKeyText, MAX_PATH );

  02473	56		 push	 esi
  02474	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0247a	50		 push	 eax
  0247b	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  02480	8d 85 ac f8 ff
	ff		 lea	 eax, DWORD PTR __k$532970[ebp]
  02486	c7 85 ac f8 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$532970[ebp], -1246582362 ; b5b2a9a6H
  02490	81 b5 ac f8 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$532970[ebp], -353637139 ; eaebecedH
  0249a	50		 push	 eax
  0249b	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  024a1	66 c7 85 b0 f8
	ff ff 52 00	 mov	 WORD PTR __k$532970[ebp+4], 82 ; 00000052H
  024aa	ff d7		 call	 edi

; 1193 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_R, szKeyText ) );

  024ac	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  024b2	50		 push	 eax
  024b3	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523239[ebp]
  024b9	50		 push	 eax
  024ba	8d 8d 28 ed ff
	ff		 lea	 ecx, DWORD PTR $T523238[ebp]
  024c0	c7 85 cc f1 ff
	ff 72 00 00 00	 mov	 DWORD PTR $T523239[ebp], 114 ; 00000072H
  024ca	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  024cf	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  024d5	50		 push	 eax
  024d6	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523240[ebp]
  024dc	50		 push	 eax
  024dd	c6 45 fc 3c	 mov	 BYTE PTR __$EHRec$[ebp+8], 60 ; 0000003cH
  024e1	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  024e6	8d 8d 2c ed ff
	ff		 lea	 ecx, DWORD PTR $T523238[ebp+4]
  024ec	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  024f0	ff d3		 call	 ebx

; 1194 : 
; 1195 : 	kLoader.LoadString_e( "KEY_S", "", szKeyText, MAX_PATH );

  024f2	56		 push	 esi
  024f3	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  024f9	50		 push	 eax
  024fa	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  024ff	8d 85 9c f9 ff
	ff		 lea	 eax, DWORD PTR __k$533102[ebp]
  02505	c7 85 9c f9 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$533102[ebp], -1246582362 ; b5b2a9a6H
  0250f	81 b5 9c f9 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$533102[ebp], -353637139 ; eaebecedH
  02519	50		 push	 eax
  0251a	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02520	66 c7 85 a0 f9
	ff ff 53 00	 mov	 WORD PTR __k$533102[ebp+4], 83 ; 00000053H
  02529	ff d7		 call	 edi

; 1196 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_S, szKeyText ) );

  0252b	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  02531	50		 push	 eax
  02532	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523242[ebp]
  02538	50		 push	 eax
  02539	8d 8d b0 e7 ff
	ff		 lea	 ecx, DWORD PTR $T523241[ebp]
  0253f	c7 85 cc f1 ff
	ff 73 00 00 00	 mov	 DWORD PTR $T523242[ebp], 115 ; 00000073H
  02549	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  0254e	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  02554	50		 push	 eax
  02555	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523243[ebp]
  0255b	50		 push	 eax
  0255c	c6 45 fc 3d	 mov	 BYTE PTR __$EHRec$[ebp+8], 61 ; 0000003dH
  02560	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  02565	8d 8d b4 e7 ff
	ff		 lea	 ecx, DWORD PTR $T523241[ebp+4]
  0256b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0256f	ff d3		 call	 ebx

; 1197 : 
; 1198 : 	kLoader.LoadString_e( "KEY_T", "", szKeyText, MAX_PATH );

  02571	56		 push	 esi
  02572	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  02578	50		 push	 eax
  02579	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0257e	8d 85 f4 f8 ff
	ff		 lea	 eax, DWORD PTR __k$533227[ebp]
  02584	c7 85 f4 f8 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$533227[ebp], -1246582362 ; b5b2a9a6H
  0258e	81 b5 f4 f8 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$533227[ebp], -353637139 ; eaebecedH
  02598	66 c7 85 f8 f8
	ff ff 54 00	 mov	 WORD PTR __k$533227[ebp+4], 84 ; 00000054H
  025a1	50		 push	 eax
  025a2	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  025a8	ff d7		 call	 edi

; 1199 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_T, szKeyText ) );

  025aa	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  025b0	50		 push	 eax
  025b1	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523245[ebp]
  025b7	50		 push	 eax
  025b8	8d 8d 00 ed ff
	ff		 lea	 ecx, DWORD PTR $T523244[ebp]
  025be	c7 85 cc f1 ff
	ff 74 00 00 00	 mov	 DWORD PTR $T523245[ebp], 116 ; 00000074H
  025c8	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  025cd	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  025d3	50		 push	 eax
  025d4	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523246[ebp]
  025da	50		 push	 eax
  025db	c6 45 fc 3e	 mov	 BYTE PTR __$EHRec$[ebp+8], 62 ; 0000003eH
  025df	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  025e4	8d 8d 04 ed ff
	ff		 lea	 ecx, DWORD PTR $T523244[ebp+4]
  025ea	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  025ee	ff d3		 call	 ebx

; 1200 : 
; 1201 : 	kLoader.LoadString_e( "KEY_U", "", szKeyText, MAX_PATH );

  025f0	56		 push	 esi
  025f1	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  025f7	50		 push	 eax
  025f8	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  025fd	8d 85 84 f9 ff
	ff		 lea	 eax, DWORD PTR __k$533362[ebp]
  02603	c7 85 84 f9 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$533362[ebp], -1246582362 ; b5b2a9a6H
  0260d	81 b5 84 f9 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$533362[ebp], -353637139 ; eaebecedH
  02617	50		 push	 eax
  02618	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0261e	66 c7 85 88 f9
	ff ff 55 00	 mov	 WORD PTR __k$533362[ebp+4], 85 ; 00000055H
  02627	ff d7		 call	 edi

; 1202 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_U, szKeyText ) );

  02629	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0262f	50		 push	 eax
  02630	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523248[ebp]
  02636	50		 push	 eax
  02637	8d 8d 68 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523247[ebp]
  0263d	c7 85 cc f1 ff
	ff 75 00 00 00	 mov	 DWORD PTR $T523248[ebp], 117 ; 00000075H
  02647	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  0264c	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  02652	50		 push	 eax
  02653	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523249[ebp]
  02659	50		 push	 eax
  0265a	c6 45 fc 3f	 mov	 BYTE PTR __$EHRec$[ebp+8], 63 ; 0000003fH
  0265e	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  02663	8d 8d 6c e9 ff
	ff		 lea	 ecx, DWORD PTR $T523247[ebp+4]
  02669	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0266d	ff d3		 call	 ebx

; 1203 : 
; 1204 : 	kLoader.LoadString_e( "KEY_V", "", szKeyText, MAX_PATH );

  0266f	56		 push	 esi
  02670	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  02676	50		 push	 eax
  02677	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0267c	8d 85 6c f9 ff
	ff		 lea	 eax, DWORD PTR __k$533497[ebp]
  02682	c7 85 6c f9 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$533497[ebp], -1246582362 ; b5b2a9a6H
  0268c	81 b5 6c f9 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$533497[ebp], -353637139 ; eaebecedH
  02696	50		 push	 eax
  02697	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0269d	66 c7 85 70 f9
	ff ff 56 00	 mov	 WORD PTR __k$533497[ebp+4], 86 ; 00000056H
  026a6	ff d7		 call	 edi

; 1205 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_V, szKeyText ) );

  026a8	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  026ae	50		 push	 eax
  026af	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523251[ebp]
  026b5	50		 push	 eax
  026b6	8d 8d d8 ec ff
	ff		 lea	 ecx, DWORD PTR $T523250[ebp]
  026bc	c7 85 cc f1 ff
	ff 76 00 00 00	 mov	 DWORD PTR $T523251[ebp], 118 ; 00000076H
  026c6	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  026cb	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  026d1	50		 push	 eax
  026d2	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523252[ebp]
  026d8	50		 push	 eax
  026d9	c6 45 fc 40	 mov	 BYTE PTR __$EHRec$[ebp+8], 64 ; 00000040H
  026dd	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  026e2	8d 8d dc ec ff
	ff		 lea	 ecx, DWORD PTR $T523250[ebp+4]
  026e8	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  026ec	ff d3		 call	 ebx

; 1206 : 
; 1207 : 	kLoader.LoadString_e( "KEY_W", "", szKeyText, MAX_PATH );

  026ee	56		 push	 esi
  026ef	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  026f5	c7 85 dc f8 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$533645[ebp], -1246582362 ; b5b2a9a6H
  026ff	81 b5 dc f8 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$533645[ebp], -353637139 ; eaebecedH
  02709	66 c7 85 e0 f8
	ff ff 57 00	 mov	 WORD PTR __k$533645[ebp+4], 87 ; 00000057H
  02712	50		 push	 eax
  02713	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  02718	8d 85 dc f8 ff
	ff		 lea	 eax, DWORD PTR __k$533645[ebp]
  0271e	50		 push	 eax
  0271f	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02725	ff d7		 call	 edi

; 1208 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_W, szKeyText ) );

  02727	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0272d	50		 push	 eax
  0272e	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523254[ebp]
  02734	50		 push	 eax
  02735	8d 8d c0 e6 ff
	ff		 lea	 ecx, DWORD PTR $T523253[ebp]
  0273b	c7 85 cc f1 ff
	ff 77 00 00 00	 mov	 DWORD PTR $T523254[ebp], 119 ; 00000077H
  02745	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  0274a	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  02750	50		 push	 eax
  02751	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523255[ebp]
  02757	50		 push	 eax
  02758	c6 45 fc 41	 mov	 BYTE PTR __$EHRec$[ebp+8], 65 ; 00000041H
  0275c	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  02761	8d 8d c4 e6 ff
	ff		 lea	 ecx, DWORD PTR $T523253[ebp+4]
  02767	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0276b	ff d3		 call	 ebx

; 1209 : 
; 1210 : 	kLoader.LoadString_e( "KEY_X", "", szKeyText, MAX_PATH );

  0276d	56		 push	 esi
  0276e	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  02774	50		 push	 eax
  02775	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0277a	8d 85 54 f9 ff
	ff		 lea	 eax, DWORD PTR __k$533780[ebp]
  02780	c7 85 54 f9 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$533780[ebp], -1246582362 ; b5b2a9a6H
  0278a	81 b5 54 f9 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$533780[ebp], -353637139 ; eaebecedH
  02794	50		 push	 eax
  02795	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0279b	66 c7 85 58 f9
	ff ff 58 00	 mov	 WORD PTR __k$533780[ebp+4], 88 ; 00000058H
  027a4	ff d7		 call	 edi

; 1211 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_X, szKeyText ) );

  027a6	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  027ac	50		 push	 eax
  027ad	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523257[ebp]
  027b3	50		 push	 eax
  027b4	8d 8d b0 ec ff
	ff		 lea	 ecx, DWORD PTR $T523256[ebp]
  027ba	c7 85 cc f1 ff
	ff 78 00 00 00	 mov	 DWORD PTR $T523257[ebp], 120 ; 00000078H
  027c4	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  027c9	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  027cf	50		 push	 eax
  027d0	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523258[ebp]
  027d6	50		 push	 eax
  027d7	c6 45 fc 42	 mov	 BYTE PTR __$EHRec$[ebp+8], 66 ; 00000042H
  027db	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  027e0	8d 8d b4 ec ff
	ff		 lea	 ecx, DWORD PTR $T523256[ebp+4]
  027e6	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  027ea	ff d3		 call	 ebx

; 1212 : 
; 1213 : 	kLoader.LoadString_e( "KEY_Y", "", szKeyText, MAX_PATH );

  027ec	56		 push	 esi
  027ed	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  027f3	50		 push	 eax
  027f4	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  027f9	8d 85 94 f8 ff
	ff		 lea	 eax, DWORD PTR __k$533915[ebp]
  027ff	c7 85 94 f8 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$533915[ebp], -1246582362 ; b5b2a9a6H
  02809	81 b5 94 f8 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$533915[ebp], -353637139 ; eaebecedH
  02813	50		 push	 eax
  02814	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0281a	66 c7 85 98 f8
	ff ff 59 00	 mov	 WORD PTR __k$533915[ebp+4], 89 ; 00000059H
  02823	ff d7		 call	 edi

; 1214 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_Y, szKeyText ) );

  02825	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0282b	50		 push	 eax
  0282c	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523260[ebp]
  02832	50		 push	 eax
  02833	8d 8d 40 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523259[ebp]
  02839	c7 85 cc f1 ff
	ff 79 00 00 00	 mov	 DWORD PTR $T523260[ebp], 121 ; 00000079H
  02843	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  02848	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  0284e	50		 push	 eax
  0284f	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523261[ebp]
  02855	50		 push	 eax
  02856	c6 45 fc 43	 mov	 BYTE PTR __$EHRec$[ebp+8], 67 ; 00000043H
  0285a	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  0285f	8d 8d 44 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523259[ebp+4]
  02865	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  02869	ff d3		 call	 ebx

; 1215 : 
; 1216 : 	kLoader.LoadString_e( "KEY_Z", "", szKeyText, MAX_PATH );

  0286b	c7 85 3c f9 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$534050[ebp], -1246582362 ; b5b2a9a6H
  02875	81 b5 3c f9 ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$534050[ebp], -353637139 ; eaebecedH
  0287f	66 c7 85 40 f9
	ff ff 5a 00	 mov	 WORD PTR __k$534050[ebp+4], 90 ; 0000005aH
  02888	56		 push	 esi
  02889	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0288f	50		 push	 eax
  02890	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  02895	8d 85 3c f9 ff
	ff		 lea	 eax, DWORD PTR __k$534050[ebp]
  0289b	50		 push	 eax
  0289c	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  028a2	ff d7		 call	 edi

; 1217 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_Z, szKeyText ) );

  028a4	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  028aa	50		 push	 eax
  028ab	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523263[ebp]
  028b1	50		 push	 eax
  028b2	8d 8d 88 ec ff
	ff		 lea	 ecx, DWORD PTR $T523262[ebp]
  028b8	c7 85 cc f1 ff
	ff 7a 00 00 00	 mov	 DWORD PTR $T523263[ebp], 122 ; 0000007aH
  028c2	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  028c7	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  028cd	50		 push	 eax
  028ce	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523264[ebp]
  028d4	50		 push	 eax
  028d5	c6 45 fc 44	 mov	 BYTE PTR __$EHRec$[ebp+8], 68 ; 00000044H
  028d9	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  028de	8d 8d 8c ec ff
	ff		 lea	 ecx, DWORD PTR $T523262[ebp+4]
  028e4	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  028e8	ff d3		 call	 ebx
  028ea	6a 02		 push	 2

; 1218 : 
; 1219 : 	kLoader.LoadString_e( "KEY_LCURLY", "", szKeyText, MAX_PATH );

  028ec	c7 85 ac fa ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$534187[ebp], -1246582362 ; b5b2a9a6H
  028f6	c7 85 b0 fa ff
	ff a1 af be b8	 mov	 DWORD PTR __k$534187[ebp+4], -1195462751 ; b8beafa1H
  02900	66 c7 85 b4 fa
	ff ff a1 b5	 mov	 WORD PTR __k$534187[ebp+8], 46497 ; 0000b5a1H
  02909	8d 85 ac fa ff
	ff		 lea	 eax, DWORD PTR __k$534187[ebp]
  0290f	c6 85 b6 fa ff
	ff 00		 mov	 BYTE PTR __k$534187[ebp+10], 0
  02916	59		 pop	 ecx
$LL8485@Load@4:
  02917	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0291d	83 c0 04	 add	 eax, 4
  02920	49		 dec	 ecx
  02921	75 f4		 jne	 SHORT $LL8485@Load@4
  02923	6a 08		 push	 8
  02925	58		 pop	 eax
$LL8482@Load@4:
  02926	8b c8		 mov	 ecx, eax
  02928	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0292e	79 05		 jns	 SHORT $LN18424@Load@4
  02930	49		 dec	 ecx
  02931	83 c9 fc	 or	 ecx, -4			; fffffffcH
  02934	41		 inc	 ecx
$LN18424@Load@4:
  02935	b2 ed		 mov	 dl, -19			; ffffffedH
  02937	2a d1		 sub	 dl, cl
  02939	30 94 05 ac fa
	ff ff		 xor	 BYTE PTR __k$534187[ebp+eax], dl
  02940	40		 inc	 eax
  02941	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  02944	7c e0		 jl	 SHORT $LL8482@Load@4
  02946	56		 push	 esi
  02947	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0294d	50		 push	 eax
  0294e	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  02953	8d 85 ac fa ff
	ff		 lea	 eax, DWORD PTR __k$534187[ebp]
  02959	50		 push	 eax
  0295a	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02960	ff d7		 call	 edi

; 1220 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_LCURLY, szKeyText ) );

  02962	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  02968	50		 push	 eax
  02969	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523266[ebp]
  0296f	50		 push	 eax
  02970	8d 8d 88 e7 ff
	ff		 lea	 ecx, DWORD PTR $T523265[ebp]
  02976	c7 85 cc f1 ff
	ff 7b 00 00 00	 mov	 DWORD PTR $T523266[ebp], 123 ; 0000007bH
  02980	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  02985	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  0298b	50		 push	 eax
  0298c	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523267[ebp]
  02992	50		 push	 eax
  02993	c6 45 fc 45	 mov	 BYTE PTR __$EHRec$[ebp+8], 69 ; 00000045H
  02997	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  0299c	8d 8d 8c e7 ff
	ff		 lea	 ecx, DWORD PTR $T523265[ebp+4]
  029a2	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  029a6	ff d3		 call	 ebx
  029a8	6a 02		 push	 2

; 1221 : 
; 1222 : 	kLoader.LoadString_e( "KEY_PIPE", "", szKeyText, MAX_PATH );

  029aa	c7 85 90 f6 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$534307[ebp], -1246582362 ; b5b2a9a6H
  029b4	c7 85 94 f6 ff
	ff bd a5 bb af	 mov	 DWORD PTR __k$534307[ebp+4], -1346656835 ; afbba5bdH
  029be	8d 85 90 f6 ff
	ff		 lea	 eax, DWORD PTR __k$534307[ebp]
  029c4	c6 85 98 f6 ff
	ff 00		 mov	 BYTE PTR __k$534307[ebp+8], 0
  029cb	59		 pop	 ecx
$LL8597@Load@4:
  029cc	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  029d2	83 c0 04	 add	 eax, 4
  029d5	49		 dec	 ecx
  029d6	75 f4		 jne	 SHORT $LL8597@Load@4
  029d8	56		 push	 esi
  029d9	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  029df	50		 push	 eax
  029e0	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  029e5	8d 85 90 f6 ff
	ff		 lea	 eax, DWORD PTR __k$534307[ebp]
  029eb	50		 push	 eax
  029ec	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  029f2	ff d7		 call	 edi

; 1223 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_PIPE, szKeyText ) );

  029f4	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  029fa	50		 push	 eax
  029fb	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523269[ebp]
  02a01	50		 push	 eax
  02a02	8d 8d 60 ec ff
	ff		 lea	 ecx, DWORD PTR $T523268[ebp]
  02a08	c7 85 cc f1 ff
	ff 7c 00 00 00	 mov	 DWORD PTR $T523269[ebp], 124 ; 0000007cH
  02a12	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  02a17	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  02a1d	50		 push	 eax
  02a1e	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523270[ebp]
  02a24	50		 push	 eax
  02a25	c6 45 fc 46	 mov	 BYTE PTR __$EHRec$[ebp+8], 70 ; 00000046H
  02a29	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  02a2e	8d 8d 64 ec ff
	ff		 lea	 ecx, DWORD PTR $T523268[ebp+4]
  02a34	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  02a38	ff d3		 call	 ebx
  02a3a	6a 02		 push	 2

; 1224 : 
; 1225 : 	kLoader.LoadString_e( "KEY_RCURLY", "", szKeyText, MAX_PATH );

  02a3c	c7 85 80 fc ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$534444[ebp], -1246582362 ; b5b2a9a6H
  02a46	c7 85 84 fc ff
	ff bf af be b8	 mov	 DWORD PTR __k$534444[ebp+4], -1195462721 ; b8beafbfH
  02a50	66 c7 85 88 fc
	ff ff a1 b5	 mov	 WORD PTR __k$534444[ebp+8], 46497 ; 0000b5a1H
  02a59	8d 85 80 fc ff
	ff		 lea	 eax, DWORD PTR __k$534444[ebp]
  02a5f	c6 85 8a fc ff
	ff 00		 mov	 BYTE PTR __k$534444[ebp+10], 0
  02a66	59		 pop	 ecx
$LL8709@Load@4:
  02a67	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  02a6d	83 c0 04	 add	 eax, 4
  02a70	49		 dec	 ecx
  02a71	75 f4		 jne	 SHORT $LL8709@Load@4
  02a73	6a 08		 push	 8
  02a75	58		 pop	 eax
$LL8706@Load@4:
  02a76	8b c8		 mov	 ecx, eax
  02a78	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  02a7e	79 05		 jns	 SHORT $LN18425@Load@4
  02a80	49		 dec	 ecx
  02a81	83 c9 fc	 or	 ecx, -4			; fffffffcH
  02a84	41		 inc	 ecx
$LN18425@Load@4:
  02a85	b2 ed		 mov	 dl, -19			; ffffffedH
  02a87	2a d1		 sub	 dl, cl
  02a89	30 94 05 80 fc
	ff ff		 xor	 BYTE PTR __k$534444[ebp+eax], dl
  02a90	40		 inc	 eax
  02a91	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  02a94	7c e0		 jl	 SHORT $LL8706@Load@4
  02a96	56		 push	 esi
  02a97	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  02a9d	50		 push	 eax
  02a9e	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  02aa3	8d 85 80 fc ff
	ff		 lea	 eax, DWORD PTR __k$534444[ebp]
  02aa9	50		 push	 eax
  02aaa	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02ab0	ff d7		 call	 edi

; 1226 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_RCURLY, szKeyText ) );

  02ab2	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  02ab8	50		 push	 eax
  02ab9	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523272[ebp]
  02abf	50		 push	 eax
  02ac0	8d 8d 18 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523271[ebp]
  02ac6	c7 85 cc f1 ff
	ff 7d 00 00 00	 mov	 DWORD PTR $T523272[ebp], 125 ; 0000007dH
  02ad0	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  02ad5	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  02adb	50		 push	 eax
  02adc	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523273[ebp]
  02ae2	50		 push	 eax
  02ae3	c6 45 fc 47	 mov	 BYTE PTR __$EHRec$[ebp+8], 71 ; 00000047H
  02ae7	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  02aec	8d 8d 1c e9 ff
	ff		 lea	 ecx, DWORD PTR $T523271[ebp+4]
  02af2	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  02af6	ff d3		 call	 ebx
  02af8	6a 02		 push	 2

; 1227 : 
; 1228 : 	kLoader.LoadString_e( "KEY_TILDA", "", szKeyText, MAX_PATH );

  02afa	c7 85 a8 fb ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$534590[ebp], -1246582362 ; b5b2a9a6H
  02b04	c7 85 ac fb ff
	ff b9 a5 a7 ae	 mov	 DWORD PTR __k$534590[ebp+4], -1364744775 ; aea7a5b9H
  02b0e	8d 85 a8 fb ff
	ff		 lea	 eax, DWORD PTR __k$534590[ebp]
  02b14	66 c7 85 b0 fb
	ff ff ac 00	 mov	 WORD PTR __k$534590[ebp+8], 172 ; 000000acH
  02b1d	59		 pop	 ecx
$LL8821@Load@4:
  02b1e	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  02b24	83 c0 04	 add	 eax, 4
  02b27	49		 dec	 ecx
  02b28	75 f4		 jne	 SHORT $LL8821@Load@4
  02b2a	80 b5 b0 fb ff
	ff ed		 xor	 BYTE PTR __k$534590[ebp+8], -19 ; ffffffedH
  02b31	56		 push	 esi
  02b32	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  02b38	50		 push	 eax
  02b39	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  02b3e	8d 85 a8 fb ff
	ff		 lea	 eax, DWORD PTR __k$534590[ebp]
  02b44	50		 push	 eax
  02b45	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02b4b	ff d7		 call	 edi

; 1229 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_TILDA, szKeyText ) );

  02b4d	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  02b53	50		 push	 eax
  02b54	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523275[ebp]
  02b5a	50		 push	 eax
  02b5b	8d 8d 38 ec ff
	ff		 lea	 ecx, DWORD PTR $T523274[ebp]
  02b61	c7 85 cc f1 ff
	ff 7e 00 00 00	 mov	 DWORD PTR $T523275[ebp], 126 ; 0000007eH
  02b6b	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  02b70	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  02b76	50		 push	 eax
  02b77	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523276[ebp]
  02b7d	50		 push	 eax
  02b7e	c6 45 fc 48	 mov	 BYTE PTR __$EHRec$[ebp+8], 72 ; 00000048H
  02b82	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  02b87	8d 8d 3c ec ff
	ff		 lea	 ecx, DWORD PTR $T523274[ebp+4]
  02b8d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  02b91	ff d3		 call	 ebx
  02b93	6a 02		 push	 2

; 1230 : 
; 1231 : 	kLoader.LoadString_e( "KEY_DELETE", "", szKeyText, MAX_PATH );

  02b95	c7 85 3c fb ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$534727[ebp], -1246582362 ; b5b2a9a6H
  02b9f	c7 85 40 fb ff
	ff a9 a9 a7 af	 mov	 DWORD PTR __k$534727[ebp+4], -1347966551 ; afa7a9a9H
  02ba9	66 c7 85 44 fb
	ff ff b9 a9	 mov	 WORD PTR __k$534727[ebp+8], 43449 ; 0000a9b9H
  02bb2	8d 85 3c fb ff
	ff		 lea	 eax, DWORD PTR __k$534727[ebp]
  02bb8	c6 85 46 fb ff
	ff 00		 mov	 BYTE PTR __k$534727[ebp+10], 0
  02bbf	59		 pop	 ecx
$LL8933@Load@4:
  02bc0	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  02bc6	83 c0 04	 add	 eax, 4
  02bc9	49		 dec	 ecx
  02bca	75 f4		 jne	 SHORT $LL8933@Load@4
  02bcc	6a 08		 push	 8
  02bce	58		 pop	 eax
$LL8930@Load@4:
  02bcf	8b c8		 mov	 ecx, eax
  02bd1	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  02bd7	79 05		 jns	 SHORT $LN18426@Load@4
  02bd9	49		 dec	 ecx
  02bda	83 c9 fc	 or	 ecx, -4			; fffffffcH
  02bdd	41		 inc	 ecx
$LN18426@Load@4:
  02bde	b2 ed		 mov	 dl, -19			; ffffffedH
  02be0	2a d1		 sub	 dl, cl
  02be2	30 94 05 3c fb
	ff ff		 xor	 BYTE PTR __k$534727[ebp+eax], dl
  02be9	40		 inc	 eax
  02bea	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  02bed	7c e0		 jl	 SHORT $LL8930@Load@4
  02bef	56		 push	 esi
  02bf0	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  02bf6	50		 push	 eax
  02bf7	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  02bfc	8d 85 3c fb ff
	ff		 lea	 eax, DWORD PTR __k$534727[ebp]
  02c02	50		 push	 eax
  02c03	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02c09	ff d7		 call	 edi

; 1232 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_DELETE, szKeyText ) );

  02c0b	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  02c11	50		 push	 eax
  02c12	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523278[ebp]
  02c18	50		 push	 eax
  02c19	8d 8d 48 e6 ff
	ff		 lea	 ecx, DWORD PTR $T523277[ebp]
  02c1f	c7 85 cc f1 ff
	ff 7f 00 00 00	 mov	 DWORD PTR $T523278[ebp], 127 ; 0000007fH
  02c29	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  02c2e	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  02c34	50		 push	 eax
  02c35	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523279[ebp]
  02c3b	50		 push	 eax
  02c3c	c6 45 fc 49	 mov	 BYTE PTR __$EHRec$[ebp+8], 73 ; 00000049H
  02c40	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  02c45	8d 8d 4c e6 ff
	ff		 lea	 ecx, DWORD PTR $T523277[ebp+4]
  02c4b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  02c4f	ff d3		 call	 ebx
  02c51	6a 03		 push	 3

; 1233 : 
; 1234 : 	kLoader.LoadString_e( "KEY_LEFTSHIFT", "", szKeyText, MAX_PATH );

  02c53	c7 85 20 fd ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$534860[ebp], -1246582362 ; b5b2a9a6H
  02c5d	c7 85 24 fd ff
	ff a1 a9 ad be	 mov	 DWORD PTR __k$534860[ebp+4], -1095915103 ; beada9a1H
  02c67	c7 85 28 fd ff
	ff be a4 a2 ac	 mov	 DWORD PTR __k$534860[ebp+8], -1398627138 ; aca2a4beH
  02c71	8d 85 20 fd ff
	ff		 lea	 eax, DWORD PTR __k$534860[ebp]
  02c77	66 c7 85 2c fd
	ff ff b9 00	 mov	 WORD PTR __k$534860[ebp+12], 185 ; 000000b9H
  02c80	59		 pop	 ecx
$LL9045@Load@4:
  02c81	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  02c87	83 c0 04	 add	 eax, 4
  02c8a	49		 dec	 ecx
  02c8b	75 f4		 jne	 SHORT $LL9045@Load@4
  02c8d	80 b5 2c fd ff
	ff ed		 xor	 BYTE PTR __k$534860[ebp+12], -19 ; ffffffedH
  02c94	56		 push	 esi
  02c95	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  02c9b	50		 push	 eax
  02c9c	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  02ca1	8d 85 20 fd ff
	ff		 lea	 eax, DWORD PTR __k$534860[ebp]
  02ca7	50		 push	 eax
  02ca8	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02cae	ff d7		 call	 edi

; 1235 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_LEFTSHIFT, szKeyText ) );

  02cb0	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  02cb6	50		 push	 eax
  02cb7	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523281[ebp]
  02cbd	50		 push	 eax
  02cbe	8d 8d 10 ec ff
	ff		 lea	 ecx, DWORD PTR $T523280[ebp]
  02cc4	c7 85 cc f1 ff
	ff 80 00 00 00	 mov	 DWORD PTR $T523281[ebp], 128 ; 00000080H
  02cce	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  02cd3	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  02cd9	50		 push	 eax
  02cda	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523282[ebp]
  02ce0	50		 push	 eax
  02ce1	c6 45 fc 4a	 mov	 BYTE PTR __$EHRec$[ebp+8], 74 ; 0000004aH
  02ce5	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  02cea	8d 8d 14 ec ff
	ff		 lea	 ecx, DWORD PTR $T523280[ebp+4]
  02cf0	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  02cf4	ff d3		 call	 ebx
  02cf6	6a 03		 push	 3

; 1236 : 
; 1237 : 	kLoader.LoadString_e( "KEY_RIGHTSHIFT", "", szKeyText, MAX_PATH );

  02cf8	c7 85 70 fb ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$534982[ebp], -1246582362 ; b5b2a9a6H
  02d02	c7 85 74 fb ff
	ff bf a5 ac a2	 mov	 DWORD PTR __k$534982[ebp+4], -1565743681 ; a2aca5bfH
  02d0c	c7 85 78 fb ff
	ff b9 bf a3 a3	 mov	 DWORD PTR __k$534982[ebp+8], -1549549639 ; a3a3bfb9H
  02d16	66 c7 85 7c fb
	ff ff ab b8	 mov	 WORD PTR __k$534982[ebp+12], 47275 ; 0000b8abH
  02d1f	8d 85 70 fb ff
	ff		 lea	 eax, DWORD PTR __k$534982[ebp]
  02d25	c6 85 7e fb ff
	ff 00		 mov	 BYTE PTR __k$534982[ebp+14], 0
  02d2c	59		 pop	 ecx
$LL9157@Load@4:
  02d2d	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  02d33	83 c0 04	 add	 eax, 4
  02d36	49		 dec	 ecx
  02d37	75 f4		 jne	 SHORT $LL9157@Load@4
  02d39	6a 0c		 push	 12			; 0000000cH
  02d3b	58		 pop	 eax
$LL9154@Load@4:
  02d3c	8b c8		 mov	 ecx, eax
  02d3e	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  02d44	79 05		 jns	 SHORT $LN18427@Load@4
  02d46	49		 dec	 ecx
  02d47	83 c9 fc	 or	 ecx, -4			; fffffffcH
  02d4a	41		 inc	 ecx
$LN18427@Load@4:
  02d4b	b2 ed		 mov	 dl, -19			; ffffffedH
  02d4d	2a d1		 sub	 dl, cl
  02d4f	30 94 05 70 fb
	ff ff		 xor	 BYTE PTR __k$534982[ebp+eax], dl
  02d56	40		 inc	 eax
  02d57	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  02d5a	7c e0		 jl	 SHORT $LL9154@Load@4
  02d5c	56		 push	 esi
  02d5d	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  02d63	50		 push	 eax
  02d64	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  02d69	8d 85 70 fb ff
	ff		 lea	 eax, DWORD PTR __k$534982[ebp]
  02d6f	50		 push	 eax
  02d70	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02d76	ff d7		 call	 edi

; 1238 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_RIGHTSHIFT, szKeyText ) );

  02d78	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  02d7e	50		 push	 eax
  02d7f	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523284[ebp]
  02d85	50		 push	 eax
  02d86	8d 8d f0 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523283[ebp]
  02d8c	c7 85 cc f1 ff
	ff 81 00 00 00	 mov	 DWORD PTR $T523284[ebp], 129 ; 00000081H
  02d96	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  02d9b	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  02da1	50		 push	 eax
  02da2	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523285[ebp]
  02da8	50		 push	 eax
  02da9	c6 45 fc 4b	 mov	 BYTE PTR __$EHRec$[ebp+8], 75 ; 0000004bH
  02dad	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  02db2	8d 8d f4 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523283[ebp+4]
  02db8	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  02dbc	ff d3		 call	 ebx
  02dbe	6a 03		 push	 3

; 1239 : 
; 1240 : 	kLoader.LoadString_e( "KEY_LEFTCTRL", "", szKeyText, MAX_PATH );

  02dc0	c7 85 68 f7 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$535117[ebp], -1246582362 ; b5b2a9a6H
  02dca	c7 85 6c f7 ff
	ff a1 a9 ad be	 mov	 DWORD PTR __k$535117[ebp+4], -1095915103 ; beada9a1H
  02dd4	c7 85 70 f7 ff
	ff ae b8 b9 a6	 mov	 DWORD PTR __k$535117[ebp+8], -1497778002 ; a6b9b8aeH
  02dde	8d 85 68 f7 ff
	ff		 lea	 eax, DWORD PTR __k$535117[ebp]
  02de4	c6 85 74 f7 ff
	ff 00		 mov	 BYTE PTR __k$535117[ebp+12], 0
  02deb	59		 pop	 ecx
$LL9269@Load@4:
  02dec	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  02df2	83 c0 04	 add	 eax, 4
  02df5	49		 dec	 ecx
  02df6	75 f4		 jne	 SHORT $LL9269@Load@4
  02df8	56		 push	 esi
  02df9	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  02dff	50		 push	 eax
  02e00	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  02e05	8d 85 68 f7 ff
	ff		 lea	 eax, DWORD PTR __k$535117[ebp]
  02e0b	50		 push	 eax
  02e0c	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02e12	ff d7		 call	 edi

; 1241 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_LEFTCTRL, szKeyText ) );

  02e14	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  02e1a	50		 push	 eax
  02e1b	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523287[ebp]
  02e21	50		 push	 eax
  02e22	8d 8d e8 eb ff
	ff		 lea	 ecx, DWORD PTR $T523286[ebp]
  02e28	c7 85 cc f1 ff
	ff 82 00 00 00	 mov	 DWORD PTR $T523287[ebp], 130 ; 00000082H
  02e32	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  02e37	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  02e3d	50		 push	 eax
  02e3e	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523288[ebp]
  02e44	50		 push	 eax
  02e45	c6 45 fc 4c	 mov	 BYTE PTR __$EHRec$[ebp+8], 76 ; 0000004cH
  02e49	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  02e4e	8d 8d ec eb ff
	ff		 lea	 ecx, DWORD PTR $T523286[ebp+4]
  02e54	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  02e58	ff d3		 call	 ebx
  02e5a	6a 03		 push	 3

; 1242 : 
; 1243 : 	kLoader.LoadString_e( "KEY_RIGHTCTRL", "", szKeyText, MAX_PATH );

  02e5c	c7 85 fc fc ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$535252[ebp], -1246582362 ; b5b2a9a6H
  02e66	c7 85 00 fd ff
	ff bf a5 ac a2	 mov	 DWORD PTR __k$535252[ebp+4], -1565743681 ; a2aca5bfH
  02e70	c7 85 04 fd ff
	ff b9 af bf b8	 mov	 DWORD PTR __k$535252[ebp+8], -1195397191 ; b8bfafb9H
  02e7a	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR __k$535252[ebp]
  02e80	66 c7 85 08 fd
	ff ff a1 00	 mov	 WORD PTR __k$535252[ebp+12], 161 ; 000000a1H
  02e89	59		 pop	 ecx
$LL9381@Load@4:
  02e8a	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  02e90	83 c0 04	 add	 eax, 4
  02e93	49		 dec	 ecx
  02e94	75 f4		 jne	 SHORT $LL9381@Load@4
  02e96	80 b5 08 fd ff
	ff ed		 xor	 BYTE PTR __k$535252[ebp+12], -19 ; ffffffedH
  02e9d	56		 push	 esi
  02e9e	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  02ea4	50		 push	 eax
  02ea5	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  02eaa	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR __k$535252[ebp]
  02eb0	50		 push	 eax
  02eb1	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02eb7	ff d7		 call	 edi

; 1244 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_RIGHTCTRL, szKeyText ) );

  02eb9	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  02ebf	50		 push	 eax
  02ec0	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523290[ebp]
  02ec6	50		 push	 eax
  02ec7	8d 8d 60 e7 ff
	ff		 lea	 ecx, DWORD PTR $T523289[ebp]
  02ecd	c7 85 cc f1 ff
	ff 83 00 00 00	 mov	 DWORD PTR $T523290[ebp], 131 ; 00000083H
  02ed7	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  02edc	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  02ee2	50		 push	 eax
  02ee3	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523291[ebp]
  02ee9	50		 push	 eax
  02eea	c6 45 fc 4d	 mov	 BYTE PTR __$EHRec$[ebp+8], 77 ; 0000004dH
  02eee	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  02ef3	8d 8d 64 e7 ff
	ff		 lea	 ecx, DWORD PTR $T523289[ebp+4]
  02ef9	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  02efd	ff d3		 call	 ebx
  02eff	6a 02		 push	 2

; 1245 : 
; 1246 : 	kLoader.LoadString_e( "KEY_LEFTALT", "", szKeyText, MAX_PATH );

  02f01	c7 85 1c fa ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$535387[ebp], -1246582362 ; b5b2a9a6H
  02f0b	c7 85 20 fa ff
	ff a1 a9 ad be	 mov	 DWORD PTR __k$535387[ebp+4], -1095915103 ; beada9a1H
  02f15	8d 85 1c fa ff
	ff		 lea	 eax, DWORD PTR __k$535387[ebp]
  02f1b	c7 85 24 fa ff
	ff ac a0 bf 00	 mov	 DWORD PTR __k$535387[ebp+8], 12558508 ; 00bfa0acH
  02f25	59		 pop	 ecx
$LL9493@Load@4:
  02f26	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  02f2c	83 c0 04	 add	 eax, 4
  02f2f	49		 dec	 ecx
  02f30	75 f4		 jne	 SHORT $LL9493@Load@4
  02f32	6a 08		 push	 8
  02f34	58		 pop	 eax
$LL9490@Load@4:
  02f35	8b c8		 mov	 ecx, eax
  02f37	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  02f3d	79 05		 jns	 SHORT $LN18428@Load@4
  02f3f	49		 dec	 ecx
  02f40	83 c9 fc	 or	 ecx, -4			; fffffffcH
  02f43	41		 inc	 ecx
$LN18428@Load@4:
  02f44	b2 ed		 mov	 dl, -19			; ffffffedH
  02f46	2a d1		 sub	 dl, cl
  02f48	30 94 05 1c fa
	ff ff		 xor	 BYTE PTR __k$535387[ebp+eax], dl
  02f4f	40		 inc	 eax
  02f50	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  02f53	7c e0		 jl	 SHORT $LL9490@Load@4
  02f55	56		 push	 esi
  02f56	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  02f5c	50		 push	 eax
  02f5d	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  02f62	8d 85 1c fa ff
	ff		 lea	 eax, DWORD PTR __k$535387[ebp]
  02f68	50		 push	 eax
  02f69	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  02f6f	ff d7		 call	 edi

; 1247 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_LEFTALT, szKeyText ) );

  02f71	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  02f77	50		 push	 eax
  02f78	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523293[ebp]
  02f7e	50		 push	 eax
  02f7f	8d 8d c0 eb ff
	ff		 lea	 ecx, DWORD PTR $T523292[ebp]
  02f85	c7 85 cc f1 ff
	ff 84 00 00 00	 mov	 DWORD PTR $T523293[ebp], 132 ; 00000084H
  02f8f	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  02f94	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  02f9a	50		 push	 eax
  02f9b	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523294[ebp]
  02fa1	50		 push	 eax
  02fa2	c6 45 fc 4e	 mov	 BYTE PTR __$EHRec$[ebp+8], 78 ; 0000004eH
  02fa6	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  02fab	8d 8d c4 eb ff
	ff		 lea	 ecx, DWORD PTR $T523292[ebp+4]
  02fb1	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  02fb5	ff d3		 call	 ebx
  02fb7	6a 03		 push	 3

; 1248 : 
; 1249 : 	kLoader.LoadString_e( "KEY_RIGHTALT", "", szKeyText, MAX_PATH );

  02fb9	c7 85 18 f7 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$535522[ebp], -1246582362 ; b5b2a9a6H
  02fc3	c7 85 1c f7 ff
	ff bf a5 ac a2	 mov	 DWORD PTR __k$535522[ebp+4], -1565743681 ; a2aca5bfH
  02fcd	c7 85 20 f7 ff
	ff b9 ad a7 be	 mov	 DWORD PTR __k$535522[ebp+8], -1096307271 ; bea7adb9H
  02fd7	8d 85 18 f7 ff
	ff		 lea	 eax, DWORD PTR __k$535522[ebp]
  02fdd	c6 85 24 f7 ff
	ff 00		 mov	 BYTE PTR __k$535522[ebp+12], 0
  02fe4	59		 pop	 ecx
$LL9605@Load@4:
  02fe5	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  02feb	83 c0 04	 add	 eax, 4
  02fee	49		 dec	 ecx
  02fef	75 f4		 jne	 SHORT $LL9605@Load@4
  02ff1	56		 push	 esi
  02ff2	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  02ff8	50		 push	 eax
  02ff9	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  02ffe	8d 85 18 f7 ff
	ff		 lea	 eax, DWORD PTR __k$535522[ebp]
  03004	50		 push	 eax
  03005	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0300b	ff d7		 call	 edi

; 1250 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_RIGHTALT, szKeyText ) );

  0300d	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03013	50		 push	 eax
  03014	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523296[ebp]
  0301a	50		 push	 eax
  0301b	8d 8d a8 ef ff
	ff		 lea	 ecx, DWORD PTR $T523295[ebp]
  03021	c7 85 cc f1 ff
	ff 85 00 00 00	 mov	 DWORD PTR $T523296[ebp], 133 ; 00000085H
  0302b	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  03030	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  03036	50		 push	 eax
  03037	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523297[ebp]
  0303d	50		 push	 eax
  0303e	c6 45 fc 4f	 mov	 BYTE PTR __$EHRec$[ebp+8], 79 ; 0000004fH
  03042	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  03047	8d 8d ac ef ff
	ff		 lea	 ecx, DWORD PTR $T523295[ebp+4]
  0304d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  03051	ff d3		 call	 ebx
  03053	6a 03		 push	 3

; 1251 : 
; 1252 : 	kLoader.LoadString_e( "KEY_LEFTARROW", "", szKeyText, MAX_PATH );

  03055	c7 85 d8 fc ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$535670[ebp], -1246582362 ; b5b2a9a6H
  0305f	c7 85 dc fc ff
	ff a1 a9 ad be	 mov	 DWORD PTR __k$535670[ebp+4], -1095915103 ; beada9a1H
  03069	c7 85 e0 fc ff
	ff ac be b9 a5	 mov	 DWORD PTR __k$535670[ebp+8], -1514553684 ; a5b9beacH
  03073	8d 85 d8 fc ff
	ff		 lea	 eax, DWORD PTR __k$535670[ebp]
  03079	66 c7 85 e4 fc
	ff ff ba 00	 mov	 WORD PTR __k$535670[ebp+12], 186 ; 000000baH
  03082	59		 pop	 ecx
$LL9717@Load@4:
  03083	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  03089	83 c0 04	 add	 eax, 4
  0308c	49		 dec	 ecx
  0308d	75 f4		 jne	 SHORT $LL9717@Load@4
  0308f	80 b5 e4 fc ff
	ff ed		 xor	 BYTE PTR __k$535670[ebp+12], -19 ; ffffffedH
  03096	56		 push	 esi
  03097	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0309d	50		 push	 eax
  0309e	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  030a3	8d 85 d8 fc ff
	ff		 lea	 eax, DWORD PTR __k$535670[ebp]
  030a9	50		 push	 eax
  030aa	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  030b0	ff d7		 call	 edi

; 1253 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_LEFTARROW, szKeyText ) );

  030b2	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  030b8	50		 push	 eax
  030b9	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523299[ebp]
  030bf	50		 push	 eax
  030c0	8d 8d 98 eb ff
	ff		 lea	 ecx, DWORD PTR $T523298[ebp]
  030c6	c7 85 cc f1 ff
	ff 86 00 00 00	 mov	 DWORD PTR $T523299[ebp], 134 ; 00000086H
  030d0	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  030d5	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  030db	50		 push	 eax
  030dc	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523300[ebp]
  030e2	50		 push	 eax
  030e3	c6 45 fc 50	 mov	 BYTE PTR __$EHRec$[ebp+8], 80 ; 00000050H
  030e7	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  030ec	8d 8d 9c eb ff
	ff		 lea	 ecx, DWORD PTR $T523298[ebp+4]
  030f2	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  030f6	ff d3		 call	 ebx
  030f8	6a 03		 push	 3

; 1254 : 
; 1255 : 	kLoader.LoadString_e( "KEY_RIGHTARROW", "", szKeyText, MAX_PATH );

  030fa	c7 85 4c fb ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$535805[ebp], -1246582362 ; b5b2a9a6H
  03104	c7 85 50 fb ff
	ff bf a5 ac a2	 mov	 DWORD PTR __k$535805[ebp+4], -1565743681 ; a2aca5bfH
  0310e	c7 85 54 fb ff
	ff b9 ad b9 b8	 mov	 DWORD PTR __k$535805[ebp+8], -1195790919 ; b8b9adb9H
  03118	66 c7 85 58 fb
	ff ff a2 bb	 mov	 WORD PTR __k$535805[ebp+12], 48034 ; 0000bba2H
  03121	8d 85 4c fb ff
	ff		 lea	 eax, DWORD PTR __k$535805[ebp]
  03127	c6 85 5a fb ff
	ff 00		 mov	 BYTE PTR __k$535805[ebp+14], 0
  0312e	59		 pop	 ecx
$LL9829@Load@4:
  0312f	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  03135	83 c0 04	 add	 eax, 4
  03138	49		 dec	 ecx
  03139	75 f4		 jne	 SHORT $LL9829@Load@4
  0313b	6a 0c		 push	 12			; 0000000cH
  0313d	58		 pop	 eax
$LL9826@Load@4:
  0313e	8b c8		 mov	 ecx, eax
  03140	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  03146	79 05		 jns	 SHORT $LN18429@Load@4
  03148	49		 dec	 ecx
  03149	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0314c	41		 inc	 ecx
$LN18429@Load@4:
  0314d	b2 ed		 mov	 dl, -19			; ffffffedH
  0314f	2a d1		 sub	 dl, cl
  03151	30 94 05 4c fb
	ff ff		 xor	 BYTE PTR __k$535805[ebp+eax], dl
  03158	40		 inc	 eax
  03159	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  0315c	7c e0		 jl	 SHORT $LL9826@Load@4
  0315e	56		 push	 esi
  0315f	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03165	50		 push	 eax
  03166	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0316b	8d 85 4c fb ff
	ff		 lea	 eax, DWORD PTR __k$535805[ebp]
  03171	50		 push	 eax
  03172	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03178	ff d7		 call	 edi

; 1256 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_RIGHTARROW, szKeyText ) );

  0317a	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03180	50		 push	 eax
  03181	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523302[ebp]
  03187	50		 push	 eax
  03188	8d 8d 98 e6 ff
	ff		 lea	 ecx, DWORD PTR $T523301[ebp]
  0318e	c7 85 cc f1 ff
	ff 87 00 00 00	 mov	 DWORD PTR $T523302[ebp], 135 ; 00000087H
  03198	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  0319d	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  031a3	50		 push	 eax
  031a4	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523303[ebp]
  031aa	50		 push	 eax
  031ab	c6 45 fc 51	 mov	 BYTE PTR __$EHRec$[ebp+8], 81 ; 00000051H
  031af	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  031b4	8d 8d 9c e6 ff
	ff		 lea	 ecx, DWORD PTR $T523301[ebp+4]
  031ba	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  031be	ff d3		 call	 ebx
  031c0	6a 02		 push	 2

; 1257 : 
; 1258 : 	kLoader.LoadString_e( "KEY_UPARROW", "", szKeyText, MAX_PATH );

  031c2	c7 85 38 fc ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$535927[ebp], -1246582362 ; b5b2a9a6H
  031cc	c7 85 3c fc ff
	ff b8 bc aa b8	 mov	 DWORD PTR __k$535927[ebp+4], -1196770120 ; b8aabcb8H
  031d6	8d 85 38 fc ff
	ff		 lea	 eax, DWORD PTR __k$535927[ebp]
  031dc	c7 85 40 fc ff
	ff bf a3 bc 00	 mov	 DWORD PTR __k$535927[ebp+8], 12362687 ; 00bca3bfH
  031e6	59		 pop	 ecx
$LL9941@Load@4:
  031e7	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  031ed	83 c0 04	 add	 eax, 4
  031f0	49		 dec	 ecx
  031f1	75 f4		 jne	 SHORT $LL9941@Load@4
  031f3	6a 08		 push	 8
  031f5	58		 pop	 eax
$LL9938@Load@4:
  031f6	8b c8		 mov	 ecx, eax
  031f8	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  031fe	79 05		 jns	 SHORT $LN18430@Load@4
  03200	49		 dec	 ecx
  03201	83 c9 fc	 or	 ecx, -4			; fffffffcH
  03204	41		 inc	 ecx
$LN18430@Load@4:
  03205	b2 ed		 mov	 dl, -19			; ffffffedH
  03207	2a d1		 sub	 dl, cl
  03209	30 94 05 38 fc
	ff ff		 xor	 BYTE PTR __k$535927[ebp+eax], dl
  03210	40		 inc	 eax
  03211	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  03214	7c e0		 jl	 SHORT $LL9938@Load@4
  03216	56		 push	 esi
  03217	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0321d	50		 push	 eax
  0321e	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  03223	8d 85 38 fc ff
	ff		 lea	 eax, DWORD PTR __k$535927[ebp]
  03229	50		 push	 eax
  0322a	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03230	ff d7		 call	 edi

; 1259 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_UPARROW, szKeyText ) );

  03232	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03238	50		 push	 eax
  03239	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523305[ebp]
  0323f	50		 push	 eax
  03240	8d 8d 70 eb ff
	ff		 lea	 ecx, DWORD PTR $T523304[ebp]
  03246	c7 85 cc f1 ff
	ff 88 00 00 00	 mov	 DWORD PTR $T523305[ebp], 136 ; 00000088H
  03250	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  03255	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  0325b	50		 push	 eax
  0325c	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523306[ebp]
  03262	50		 push	 eax
  03263	c6 45 fc 52	 mov	 BYTE PTR __$EHRec$[ebp+8], 82 ; 00000052H
  03267	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  0326c	8d 8d 74 eb ff
	ff		 lea	 ecx, DWORD PTR $T523304[ebp+4]
  03272	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  03276	ff d3		 call	 ebx
  03278	6a 03		 push	 3

; 1260 : 
; 1261 : 	kLoader.LoadString_e( "KEY_DOWNARROW", "", szKeyText, MAX_PATH );

  0327a	c7 85 b4 fc ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$536062[ebp], -1246582362 ; b5b2a9a6H
  03284	c7 85 b8 fc ff
	ff a9 a3 bc a4	 mov	 DWORD PTR __k$536062[ebp+4], -1531141207 ; a4bca3a9H
  0328e	c7 85 bc fc ff
	ff ac be b9 a5	 mov	 DWORD PTR __k$536062[ebp+8], -1514553684 ; a5b9beacH
  03298	8d 85 b4 fc ff
	ff		 lea	 eax, DWORD PTR __k$536062[ebp]
  0329e	66 c7 85 c0 fc
	ff ff ba 00	 mov	 WORD PTR __k$536062[ebp+12], 186 ; 000000baH
  032a7	59		 pop	 ecx
$LL10053@Load@4:
  032a8	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  032ae	83 c0 04	 add	 eax, 4
  032b1	49		 dec	 ecx
  032b2	75 f4		 jne	 SHORT $LL10053@Load@4
  032b4	80 b5 c0 fc ff
	ff ed		 xor	 BYTE PTR __k$536062[ebp+12], -19 ; ffffffedH
  032bb	56		 push	 esi
  032bc	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  032c2	50		 push	 eax
  032c3	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  032c8	8d 85 b4 fc ff
	ff		 lea	 eax, DWORD PTR __k$536062[ebp]
  032ce	50		 push	 eax
  032cf	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  032d5	ff d7		 call	 edi

; 1262 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_DOWNARROW, szKeyText ) );

  032d7	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  032dd	50		 push	 eax
  032de	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523308[ebp]
  032e4	50		 push	 eax
  032e5	8d 8d a0 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523307[ebp]
  032eb	c7 85 cc f1 ff
	ff 89 00 00 00	 mov	 DWORD PTR $T523308[ebp], 137 ; 00000089H
  032f5	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  032fa	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  03300	50		 push	 eax
  03301	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523309[ebp]
  03307	50		 push	 eax
  03308	c6 45 fc 53	 mov	 BYTE PTR __$EHRec$[ebp+8], 83 ; 00000053H
  0330c	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  03311	8d 8d a4 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523307[ebp+4]
  03317	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0331b	ff d3		 call	 ebx

; 1263 : 
; 1264 : 	kLoader.LoadString_e( "KEY_F1", "", szKeyText, MAX_PATH );

  0331d	6a 04		 push	 4
  0331f	c7 85 98 fe ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$536225[ebp], -1246582362 ; b5b2a9a6H
  03329	81 b5 98 fe ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$536225[ebp], -353637139 ; eaebecedH
  03333	66 c7 85 9c fe
	ff ff ab dd	 mov	 WORD PTR __k$536225[ebp+4], 56747 ; 0000ddabH
  0333c	c6 85 9e fe ff
	ff 00		 mov	 BYTE PTR __k$536225[ebp+6], 0
  03343	58		 pop	 eax
$LL10162@Load@4:
  03344	8b c8		 mov	 ecx, eax
  03346	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0334c	79 05		 jns	 SHORT $LN18431@Load@4
  0334e	49		 dec	 ecx
  0334f	83 c9 fc	 or	 ecx, -4			; fffffffcH
  03352	41		 inc	 ecx
$LN18431@Load@4:
  03353	b2 ed		 mov	 dl, -19			; ffffffedH
  03355	2a d1		 sub	 dl, cl
  03357	30 94 05 98 fe
	ff ff		 xor	 BYTE PTR __k$536225[ebp+eax], dl
  0335e	40		 inc	 eax
  0335f	83 f8 06	 cmp	 eax, 6
  03362	7c e0		 jl	 SHORT $LL10162@Load@4
  03364	56		 push	 esi
  03365	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0336b	50		 push	 eax
  0336c	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  03371	8d 85 98 fe ff
	ff		 lea	 eax, DWORD PTR __k$536225[ebp]
  03377	50		 push	 eax
  03378	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0337e	ff d7		 call	 edi

; 1265 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_F1, szKeyText ) );

  03380	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03386	50		 push	 eax
  03387	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523311[ebp]
  0338d	50		 push	 eax
  0338e	8d 8d 48 eb ff
	ff		 lea	 ecx, DWORD PTR $T523310[ebp]
  03394	c7 85 cc f1 ff
	ff 8a 00 00 00	 mov	 DWORD PTR $T523311[ebp], 138 ; 0000008aH
  0339e	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  033a3	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  033a9	50		 push	 eax
  033aa	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523312[ebp]
  033b0	50		 push	 eax
  033b1	c6 45 fc 54	 mov	 BYTE PTR __$EHRec$[ebp+8], 84 ; 00000054H
  033b5	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  033ba	8d 8d 4c eb ff
	ff		 lea	 ecx, DWORD PTR $T523310[ebp+4]
  033c0	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  033c4	ff d3		 call	 ebx

; 1266 : 
; 1267 : 	kLoader.LoadString_e( "KEY_F2", "", szKeyText, MAX_PATH );

  033c6	6a 04		 push	 4
  033c8	c7 85 c8 fe ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$536360[ebp], -1246582362 ; b5b2a9a6H
  033d2	81 b5 c8 fe ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$536360[ebp], -353637139 ; eaebecedH
  033dc	66 c7 85 cc fe
	ff ff ab de	 mov	 WORD PTR __k$536360[ebp+4], 57003 ; 0000deabH
  033e5	c6 85 ce fe ff
	ff 00		 mov	 BYTE PTR __k$536360[ebp+6], 0
  033ec	58		 pop	 eax
$LL10274@Load@4:
  033ed	8b c8		 mov	 ecx, eax
  033ef	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  033f5	79 05		 jns	 SHORT $LN18432@Load@4
  033f7	49		 dec	 ecx
  033f8	83 c9 fc	 or	 ecx, -4			; fffffffcH
  033fb	41		 inc	 ecx
$LN18432@Load@4:
  033fc	b2 ed		 mov	 dl, -19			; ffffffedH
  033fe	2a d1		 sub	 dl, cl
  03400	30 94 05 c8 fe
	ff ff		 xor	 BYTE PTR __k$536360[ebp+eax], dl
  03407	40		 inc	 eax
  03408	83 f8 06	 cmp	 eax, 6
  0340b	7c e0		 jl	 SHORT $LL10274@Load@4
  0340d	56		 push	 esi
  0340e	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03414	50		 push	 eax
  03415	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0341a	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR __k$536360[ebp]
  03420	50		 push	 eax
  03421	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03427	ff d7		 call	 edi

; 1268 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_F2, szKeyText ) );

  03429	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0342f	50		 push	 eax
  03430	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523314[ebp]
  03436	50		 push	 eax
  03437	8d 8d 38 e7 ff
	ff		 lea	 ecx, DWORD PTR $T523313[ebp]
  0343d	c7 85 cc f1 ff
	ff 8b 00 00 00	 mov	 DWORD PTR $T523314[ebp], 139 ; 0000008bH
  03447	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  0344c	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  03452	50		 push	 eax
  03453	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523315[ebp]
  03459	50		 push	 eax
  0345a	c6 45 fc 55	 mov	 BYTE PTR __$EHRec$[ebp+8], 85 ; 00000055H
  0345e	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  03463	8d 8d 3c e7 ff
	ff		 lea	 ecx, DWORD PTR $T523313[ebp+4]
  03469	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0346d	ff d3		 call	 ebx

; 1269 : 
; 1270 : 	kLoader.LoadString_e( "KEY_F3", "", szKeyText, MAX_PATH );

  0346f	6a 04		 push	 4
  03471	c7 85 80 fe ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$536489[ebp], -1246582362 ; b5b2a9a6H
  0347b	81 b5 80 fe ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$536489[ebp], -353637139 ; eaebecedH
  03485	66 c7 85 84 fe
	ff ff ab df	 mov	 WORD PTR __k$536489[ebp+4], 57259 ; 0000dfabH
  0348e	c6 85 86 fe ff
	ff 00		 mov	 BYTE PTR __k$536489[ebp+6], 0
  03495	58		 pop	 eax
$LL10386@Load@4:
  03496	8b c8		 mov	 ecx, eax
  03498	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0349e	79 05		 jns	 SHORT $LN18433@Load@4
  034a0	49		 dec	 ecx
  034a1	83 c9 fc	 or	 ecx, -4			; fffffffcH
  034a4	41		 inc	 ecx
$LN18433@Load@4:
  034a5	b2 ed		 mov	 dl, -19			; ffffffedH
  034a7	2a d1		 sub	 dl, cl
  034a9	30 94 05 80 fe
	ff ff		 xor	 BYTE PTR __k$536489[ebp+eax], dl
  034b0	40		 inc	 eax
  034b1	83 f8 06	 cmp	 eax, 6
  034b4	7c e0		 jl	 SHORT $LL10386@Load@4
  034b6	56		 push	 esi
  034b7	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  034bd	50		 push	 eax
  034be	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  034c3	8d 85 80 fe ff
	ff		 lea	 eax, DWORD PTR __k$536489[ebp]
  034c9	50		 push	 eax
  034ca	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  034d0	ff d7		 call	 edi

; 1271 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_F3, szKeyText ) );

  034d2	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  034d8	50		 push	 eax
  034d9	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523317[ebp]
  034df	50		 push	 eax
  034e0	8d 8d 20 eb ff
	ff		 lea	 ecx, DWORD PTR $T523316[ebp]
  034e6	c7 85 cc f1 ff
	ff 8c 00 00 00	 mov	 DWORD PTR $T523317[ebp], 140 ; 0000008cH
  034f0	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  034f5	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  034fb	50		 push	 eax
  034fc	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523318[ebp]
  03502	50		 push	 eax
  03503	c6 45 fc 56	 mov	 BYTE PTR __$EHRec$[ebp+8], 86 ; 00000056H
  03507	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  0350c	8d 8d 24 eb ff
	ff		 lea	 ecx, DWORD PTR $T523316[ebp+4]
  03512	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  03516	ff d3		 call	 ebx

; 1272 : 
; 1273 : 	kLoader.LoadString_e( "KEY_F4", "", szKeyText, MAX_PATH );

  03518	6a 04		 push	 4
  0351a	c7 85 8c fe ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$536630[ebp], -1246582362 ; b5b2a9a6H
  03524	81 b5 8c fe ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$536630[ebp], -353637139 ; eaebecedH
  0352e	66 c7 85 90 fe
	ff ff ab d8	 mov	 WORD PTR __k$536630[ebp+4], 55467 ; 0000d8abH
  03537	c6 85 92 fe ff
	ff 00		 mov	 BYTE PTR __k$536630[ebp+6], 0
  0353e	58		 pop	 eax
$LL10498@Load@4:
  0353f	8b c8		 mov	 ecx, eax
  03541	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  03547	79 05		 jns	 SHORT $LN18434@Load@4
  03549	49		 dec	 ecx
  0354a	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0354d	41		 inc	 ecx
$LN18434@Load@4:
  0354e	b2 ed		 mov	 dl, -19			; ffffffedH
  03550	2a d1		 sub	 dl, cl
  03552	30 94 05 8c fe
	ff ff		 xor	 BYTE PTR __k$536630[ebp+eax], dl
  03559	40		 inc	 eax
  0355a	83 f8 06	 cmp	 eax, 6
  0355d	7c e0		 jl	 SHORT $LL10498@Load@4
  0355f	56		 push	 esi
  03560	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03566	50		 push	 eax
  03567	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0356c	8d 85 8c fe ff
	ff		 lea	 eax, DWORD PTR __k$536630[ebp]
  03572	50		 push	 eax
  03573	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03579	ff d7		 call	 edi

; 1274 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_F4, szKeyText ) );

  0357b	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03581	50		 push	 eax
  03582	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523320[ebp]
  03588	50		 push	 eax
  03589	8d 8d 78 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523319[ebp]
  0358f	c7 85 cc f1 ff
	ff 8d 00 00 00	 mov	 DWORD PTR $T523320[ebp], 141 ; 0000008dH
  03599	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  0359e	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  035a4	50		 push	 eax
  035a5	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523321[ebp]
  035ab	50		 push	 eax
  035ac	c6 45 fc 57	 mov	 BYTE PTR __$EHRec$[ebp+8], 87 ; 00000057H
  035b0	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  035b5	8d 8d 7c e8 ff
	ff		 lea	 ecx, DWORD PTR $T523319[ebp+4]
  035bb	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  035bf	ff d3		 call	 ebx

; 1275 : 
; 1276 : 	kLoader.LoadString_e( "KEY_F5", "", szKeyText, MAX_PATH );

  035c1	6a 04		 push	 4
  035c3	c7 85 a4 fe ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$536765[ebp], -1246582362 ; b5b2a9a6H
  035cd	81 b5 a4 fe ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$536765[ebp], -353637139 ; eaebecedH
  035d7	66 c7 85 a8 fe
	ff ff ab d9	 mov	 WORD PTR __k$536765[ebp+4], 55723 ; 0000d9abH
  035e0	c6 85 aa fe ff
	ff 00		 mov	 BYTE PTR __k$536765[ebp+6], 0
  035e7	58		 pop	 eax
$LL10610@Load@4:
  035e8	8b c8		 mov	 ecx, eax
  035ea	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  035f0	79 05		 jns	 SHORT $LN18435@Load@4
  035f2	49		 dec	 ecx
  035f3	83 c9 fc	 or	 ecx, -4			; fffffffcH
  035f6	41		 inc	 ecx
$LN18435@Load@4:
  035f7	b2 ed		 mov	 dl, -19			; ffffffedH
  035f9	2a d1		 sub	 dl, cl
  035fb	30 94 05 a4 fe
	ff ff		 xor	 BYTE PTR __k$536765[ebp+eax], dl
  03602	40		 inc	 eax
  03603	83 f8 06	 cmp	 eax, 6
  03606	7c e0		 jl	 SHORT $LL10610@Load@4
  03608	56		 push	 esi
  03609	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0360f	50		 push	 eax
  03610	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  03615	8d 85 a4 fe ff
	ff		 lea	 eax, DWORD PTR __k$536765[ebp]
  0361b	50		 push	 eax
  0361c	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03622	ff d7		 call	 edi

; 1277 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_F5, szKeyText ) );

  03624	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0362a	50		 push	 eax
  0362b	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523323[ebp]
  03631	50		 push	 eax
  03632	8d 8d f8 ea ff
	ff		 lea	 ecx, DWORD PTR $T523322[ebp]
  03638	c7 85 cc f1 ff
	ff 8e 00 00 00	 mov	 DWORD PTR $T523323[ebp], 142 ; 0000008eH
  03642	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  03647	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  0364d	50		 push	 eax
  0364e	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523324[ebp]
  03654	50		 push	 eax
  03655	c6 45 fc 58	 mov	 BYTE PTR __$EHRec$[ebp+8], 88 ; 00000058H
  03659	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  0365e	8d 8d fc ea ff
	ff		 lea	 ecx, DWORD PTR $T523322[ebp+4]
  03664	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  03668	ff d3		 call	 ebx

; 1278 : 
; 1279 : 	kLoader.LoadString_e( "KEY_F6", "", szKeyText, MAX_PATH );

  0366a	6a 04		 push	 4
  0366c	c7 85 bc fe ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$536900[ebp], -1246582362 ; b5b2a9a6H
  03676	81 b5 bc fe ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$536900[ebp], -353637139 ; eaebecedH
  03680	66 c7 85 c0 fe
	ff ff ab da	 mov	 WORD PTR __k$536900[ebp+4], 55979 ; 0000daabH
  03689	c6 85 c2 fe ff
	ff 00		 mov	 BYTE PTR __k$536900[ebp+6], 0
  03690	58		 pop	 eax
$LL10722@Load@4:
  03691	8b c8		 mov	 ecx, eax
  03693	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  03699	79 05		 jns	 SHORT $LN18436@Load@4
  0369b	49		 dec	 ecx
  0369c	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0369f	41		 inc	 ecx
$LN18436@Load@4:
  036a0	b2 ed		 mov	 dl, -19			; ffffffedH
  036a2	2a d1		 sub	 dl, cl
  036a4	30 94 05 bc fe
	ff ff		 xor	 BYTE PTR __k$536900[ebp+eax], dl
  036ab	40		 inc	 eax
  036ac	83 f8 06	 cmp	 eax, 6
  036af	7c e0		 jl	 SHORT $LL10722@Load@4
  036b1	56		 push	 esi
  036b2	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  036b8	50		 push	 eax
  036b9	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  036be	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR __k$536900[ebp]
  036c4	50		 push	 eax
  036c5	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  036cb	ff d7		 call	 edi

; 1280 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_F6, szKeyText ) );

  036cd	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  036d3	50		 push	 eax
  036d4	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523326[ebp]
  036da	50		 push	 eax
  036db	8d 8d f8 e5 ff
	ff		 lea	 ecx, DWORD PTR $T523325[ebp]
  036e1	c7 85 cc f1 ff
	ff 8f 00 00 00	 mov	 DWORD PTR $T523326[ebp], 143 ; 0000008fH
  036eb	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  036f0	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  036f6	50		 push	 eax
  036f7	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523327[ebp]
  036fd	50		 push	 eax
  036fe	c6 45 fc 59	 mov	 BYTE PTR __$EHRec$[ebp+8], 89 ; 00000059H
  03702	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  03707	8d 8d fc e5 ff
	ff		 lea	 ecx, DWORD PTR $T523325[ebp+4]
  0370d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  03711	ff d3		 call	 ebx

; 1281 : 
; 1282 : 	kLoader.LoadString_e( "KEY_F7", "", szKeyText, MAX_PATH );

  03713	6a 04		 push	 4
  03715	c7 85 b0 fe ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$537035[ebp], -1246582362 ; b5b2a9a6H
  0371f	81 b5 b0 fe ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$537035[ebp], -353637139 ; eaebecedH
  03729	66 c7 85 b4 fe
	ff ff ab db	 mov	 WORD PTR __k$537035[ebp+4], 56235 ; 0000dbabH
  03732	c6 85 b6 fe ff
	ff 00		 mov	 BYTE PTR __k$537035[ebp+6], 0
  03739	58		 pop	 eax
$LL10834@Load@4:
  0373a	8b c8		 mov	 ecx, eax
  0373c	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  03742	79 05		 jns	 SHORT $LN18437@Load@4
  03744	49		 dec	 ecx
  03745	83 c9 fc	 or	 ecx, -4			; fffffffcH
  03748	41		 inc	 ecx
$LN18437@Load@4:
  03749	b2 ed		 mov	 dl, -19			; ffffffedH
  0374b	2a d1		 sub	 dl, cl
  0374d	30 94 05 b0 fe
	ff ff		 xor	 BYTE PTR __k$537035[ebp+eax], dl
  03754	40		 inc	 eax
  03755	83 f8 06	 cmp	 eax, 6
  03758	7c e0		 jl	 SHORT $LL10834@Load@4
  0375a	56		 push	 esi
  0375b	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03761	50		 push	 eax
  03762	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  03767	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR __k$537035[ebp]
  0376d	50		 push	 eax
  0376e	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03774	ff d7		 call	 edi

; 1283 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_F7, szKeyText ) );

  03776	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0377c	50		 push	 eax
  0377d	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523329[ebp]
  03783	50		 push	 eax
  03784	8d 8d d0 ea ff
	ff		 lea	 ecx, DWORD PTR $T523328[ebp]
  0378a	c7 85 cc f1 ff
	ff 90 00 00 00	 mov	 DWORD PTR $T523329[ebp], 144 ; 00000090H
  03794	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  03799	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  0379f	50		 push	 eax
  037a0	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523330[ebp]
  037a6	50		 push	 eax
  037a7	c6 45 fc 5a	 mov	 BYTE PTR __$EHRec$[ebp+8], 90 ; 0000005aH
  037ab	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  037b0	8d 8d d4 ea ff
	ff		 lea	 ecx, DWORD PTR $T523328[ebp+4]
  037b6	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  037ba	ff d3		 call	 ebx

; 1284 : 
; 1285 : 	kLoader.LoadString_e( "KEY_F8", "", szKeyText, MAX_PATH );

  037bc	6a 04		 push	 4
  037be	c7 85 e0 fe ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$537170[ebp], -1246582362 ; b5b2a9a6H
  037c8	81 b5 e0 fe ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$537170[ebp], -353637139 ; eaebecedH
  037d2	66 c7 85 e4 fe
	ff ff ab d4	 mov	 WORD PTR __k$537170[ebp+4], 54443 ; 0000d4abH
  037db	c6 85 e6 fe ff
	ff 00		 mov	 BYTE PTR __k$537170[ebp+6], 0
  037e2	58		 pop	 eax
$LL10946@Load@4:
  037e3	8b c8		 mov	 ecx, eax
  037e5	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  037eb	79 05		 jns	 SHORT $LN18438@Load@4
  037ed	49		 dec	 ecx
  037ee	83 c9 fc	 or	 ecx, -4			; fffffffcH
  037f1	41		 inc	 ecx
$LN18438@Load@4:
  037f2	b2 ed		 mov	 dl, -19			; ffffffedH
  037f4	2a d1		 sub	 dl, cl
  037f6	30 94 05 e0 fe
	ff ff		 xor	 BYTE PTR __k$537170[ebp+eax], dl
  037fd	40		 inc	 eax
  037fe	83 f8 06	 cmp	 eax, 6
  03801	7c e0		 jl	 SHORT $LL10946@Load@4
  03803	56		 push	 esi
  03804	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0380a	50		 push	 eax
  0380b	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  03810	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR __k$537170[ebp]
  03816	50		 push	 eax
  03817	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0381d	ff d7		 call	 edi

; 1286 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_F8, szKeyText ) );

  0381f	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03825	50		 push	 eax
  03826	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523332[ebp]
  0382c	50		 push	 eax
  0382d	8d 8d 50 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523331[ebp]
  03833	c7 85 cc f1 ff
	ff 91 00 00 00	 mov	 DWORD PTR $T523332[ebp], 145 ; 00000091H
  0383d	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  03842	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  03848	50		 push	 eax
  03849	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523333[ebp]
  0384f	50		 push	 eax
  03850	c6 45 fc 5b	 mov	 BYTE PTR __$EHRec$[ebp+8], 91 ; 0000005bH
  03854	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  03859	8d 8d 54 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523331[ebp+4]
  0385f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  03863	ff d3		 call	 ebx

; 1287 : 
; 1288 : 	kLoader.LoadString_e( "KEY_F9", "", szKeyText, MAX_PATH );

  03865	6a 04		 push	 4
  03867	c7 85 d4 fe ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$537305[ebp], -1246582362 ; b5b2a9a6H
  03871	81 b5 d4 fe ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$537305[ebp], -353637139 ; eaebecedH
  0387b	66 c7 85 d8 fe
	ff ff ab d5	 mov	 WORD PTR __k$537305[ebp+4], 54699 ; 0000d5abH
  03884	c6 85 da fe ff
	ff 00		 mov	 BYTE PTR __k$537305[ebp+6], 0
  0388b	58		 pop	 eax
$LL11058@Load@4:
  0388c	8b c8		 mov	 ecx, eax
  0388e	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  03894	79 05		 jns	 SHORT $LN18439@Load@4
  03896	49		 dec	 ecx
  03897	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0389a	41		 inc	 ecx
$LN18439@Load@4:
  0389b	b2 ed		 mov	 dl, -19			; ffffffedH
  0389d	2a d1		 sub	 dl, cl
  0389f	30 94 05 d4 fe
	ff ff		 xor	 BYTE PTR __k$537305[ebp+eax], dl
  038a6	40		 inc	 eax
  038a7	83 f8 06	 cmp	 eax, 6
  038aa	7c e0		 jl	 SHORT $LL11058@Load@4
  038ac	56		 push	 esi
  038ad	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  038b3	50		 push	 eax
  038b4	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  038b9	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR __k$537305[ebp]
  038bf	50		 push	 eax
  038c0	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  038c6	ff d7		 call	 edi

; 1289 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_F9, szKeyText ) );

  038c8	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  038ce	50		 push	 eax
  038cf	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523335[ebp]
  038d5	50		 push	 eax
  038d6	8d 8d 94 ef ff
	ff		 lea	 ecx, DWORD PTR $T523334[ebp]
  038dc	c7 85 cc f1 ff
	ff 92 00 00 00	 mov	 DWORD PTR $T523335[ebp], 146 ; 00000092H
  038e6	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  038eb	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  038f1	50		 push	 eax
  038f2	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523336[ebp]
  038f8	50		 push	 eax
  038f9	c6 45 fc 5c	 mov	 BYTE PTR __$EHRec$[ebp+8], 92 ; 0000005cH
  038fd	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  03902	8d 8d 98 ef ff
	ff		 lea	 ecx, DWORD PTR $T523334[ebp+4]
  03908	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0390c	ff d3		 call	 ebx

; 1290 : 
; 1291 : 	kLoader.LoadString_e( "KEY_F10", "", szKeyText, MAX_PATH );

  0390e	6a 04		 push	 4
  03910	c7 85 38 fe ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$537412[ebp], -1246582362 ; b5b2a9a6H
  0391a	81 b5 38 fe ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$537412[ebp], -353637139 ; eaebecedH
  03924	c7 85 3c fe ff
	ff ab dd db 00	 mov	 DWORD PTR __k$537412[ebp+4], 14409131 ; 00dbddabH
  0392e	58		 pop	 eax
$LL11170@Load@4:
  0392f	8b c8		 mov	 ecx, eax
  03931	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  03937	79 05		 jns	 SHORT $LN18440@Load@4
  03939	49		 dec	 ecx
  0393a	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0393d	41		 inc	 ecx
$LN18440@Load@4:
  0393e	b2 ed		 mov	 dl, -19			; ffffffedH
  03940	2a d1		 sub	 dl, cl
  03942	30 94 05 38 fe
	ff ff		 xor	 BYTE PTR __k$537412[ebp+eax], dl
  03949	40		 inc	 eax
  0394a	83 f8 07	 cmp	 eax, 7
  0394d	7c e0		 jl	 SHORT $LL11170@Load@4
  0394f	56		 push	 esi
  03950	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03956	50		 push	 eax
  03957	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0395c	8d 85 38 fe ff
	ff		 lea	 eax, DWORD PTR __k$537412[ebp]
  03962	50		 push	 eax
  03963	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03969	ff d7		 call	 edi

; 1292 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_F10, szKeyText ) );

  0396b	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03971	50		 push	 eax
  03972	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523338[ebp]
  03978	50		 push	 eax
  03979	8d 8d 6c ef ff
	ff		 lea	 ecx, DWORD PTR $T523337[ebp]
  0397f	c7 85 cc f1 ff
	ff 93 00 00 00	 mov	 DWORD PTR $T523338[ebp], 147 ; 00000093H
  03989	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  0398e	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  03994	50		 push	 eax
  03995	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523339[ebp]
  0399b	50		 push	 eax
  0399c	c6 45 fc 5d	 mov	 BYTE PTR __$EHRec$[ebp+8], 93 ; 0000005dH
  039a0	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  039a5	8d 8d 70 ef ff
	ff		 lea	 ecx, DWORD PTR $T523337[ebp+4]
  039ab	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  039af	ff d3		 call	 ebx

; 1293 : 
; 1294 : 	kLoader.LoadString_e( "KEY_F11", "", szKeyText, MAX_PATH );

  039b1	6a 04		 push	 4
  039b3	c7 85 50 fe ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$537547[ebp], -1246582362 ; b5b2a9a6H
  039bd	81 b5 50 fe ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$537547[ebp], -353637139 ; eaebecedH
  039c7	c7 85 54 fe ff
	ff ab dd da 00	 mov	 DWORD PTR __k$537547[ebp+4], 14343595 ; 00daddabH
  039d1	58		 pop	 eax
$LL11282@Load@4:
  039d2	8b c8		 mov	 ecx, eax
  039d4	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  039da	79 05		 jns	 SHORT $LN18441@Load@4
  039dc	49		 dec	 ecx
  039dd	83 c9 fc	 or	 ecx, -4			; fffffffcH
  039e0	41		 inc	 ecx
$LN18441@Load@4:
  039e1	b2 ed		 mov	 dl, -19			; ffffffedH
  039e3	2a d1		 sub	 dl, cl
  039e5	30 94 05 50 fe
	ff ff		 xor	 BYTE PTR __k$537547[ebp+eax], dl
  039ec	40		 inc	 eax
  039ed	83 f8 07	 cmp	 eax, 7
  039f0	7c e0		 jl	 SHORT $LL11282@Load@4
  039f2	56		 push	 esi
  039f3	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  039f9	50		 push	 eax
  039fa	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  039ff	8d 85 50 fe ff
	ff		 lea	 eax, DWORD PTR __k$537547[ebp]
  03a05	50		 push	 eax
  03a06	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03a0c	ff d7		 call	 edi

; 1295 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_F11, szKeyText ) );

  03a0e	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03a14	50		 push	 eax
  03a15	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523341[ebp]
  03a1b	50		 push	 eax
  03a1c	8d 8d 44 ef ff
	ff		 lea	 ecx, DWORD PTR $T523340[ebp]
  03a22	c7 85 cc f1 ff
	ff 94 00 00 00	 mov	 DWORD PTR $T523341[ebp], 148 ; 00000094H
  03a2c	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  03a31	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  03a37	50		 push	 eax
  03a38	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523342[ebp]
  03a3e	50		 push	 eax
  03a3f	c6 45 fc 5e	 mov	 BYTE PTR __$EHRec$[ebp+8], 94 ; 0000005eH
  03a43	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  03a48	8d 8d 48 ef ff
	ff		 lea	 ecx, DWORD PTR $T523340[ebp+4]
  03a4e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  03a52	ff d3		 call	 ebx

; 1296 : 
; 1297 : 	kLoader.LoadString_e( "KEY_F12", "", szKeyText, MAX_PATH );

  03a54	6a 04		 push	 4
  03a56	c7 85 68 fe ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$537695[ebp], -1246582362 ; b5b2a9a6H
  03a60	81 b5 68 fe ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$537695[ebp], -353637139 ; eaebecedH
  03a6a	c7 85 6c fe ff
	ff ab dd d9 00	 mov	 DWORD PTR __k$537695[ebp+4], 14278059 ; 00d9ddabH
  03a74	58		 pop	 eax
$LL11394@Load@4:
  03a75	8b c8		 mov	 ecx, eax
  03a77	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  03a7d	79 05		 jns	 SHORT $LN18442@Load@4
  03a7f	49		 dec	 ecx
  03a80	83 c9 fc	 or	 ecx, -4			; fffffffcH
  03a83	41		 inc	 ecx
$LN18442@Load@4:
  03a84	b2 ed		 mov	 dl, -19			; ffffffedH
  03a86	2a d1		 sub	 dl, cl
  03a88	30 94 05 68 fe
	ff ff		 xor	 BYTE PTR __k$537695[ebp+eax], dl
  03a8f	40		 inc	 eax
  03a90	83 f8 07	 cmp	 eax, 7
  03a93	7c e0		 jl	 SHORT $LL11394@Load@4
  03a95	56		 push	 esi
  03a96	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03a9c	50		 push	 eax
  03a9d	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  03aa2	8d 85 68 fe ff
	ff		 lea	 eax, DWORD PTR __k$537695[ebp]
  03aa8	50		 push	 eax
  03aa9	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03aaf	ff d7		 call	 edi

; 1298 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_F12, szKeyText ) );

  03ab1	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03ab7	50		 push	 eax
  03ab8	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523344[ebp]
  03abe	50		 push	 eax
  03abf	8d 8d 1c ef ff
	ff		 lea	 ecx, DWORD PTR $T523343[ebp]
  03ac5	c7 85 cc f1 ff
	ff 95 00 00 00	 mov	 DWORD PTR $T523344[ebp], 149 ; 00000095H
  03acf	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  03ad4	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  03ada	50		 push	 eax
  03adb	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523345[ebp]
  03ae1	50		 push	 eax
  03ae2	c6 45 fc 5f	 mov	 BYTE PTR __$EHRec$[ebp+8], 95 ; 0000005fH
  03ae6	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  03aeb	8d 8d 20 ef ff
	ff		 lea	 ecx, DWORD PTR $T523343[ebp+4]
  03af1	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  03af5	ff d3		 call	 ebx

; 1299 : 
; 1300 : 	kLoader.LoadString_e( "KEY_INS", "", szKeyText, MAX_PATH );

  03af7	6a 04		 push	 4
  03af9	c7 85 5c fe ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$537830[ebp], -1246582362 ; b5b2a9a6H
  03b03	81 b5 5c fe ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$537830[ebp], -353637139 ; eaebecedH
  03b0d	c7 85 60 fe ff
	ff a4 a2 b8 00	 mov	 DWORD PTR __k$537830[ebp+4], 12100260 ; 00b8a2a4H
  03b17	58		 pop	 eax
$LL11506@Load@4:
  03b18	8b c8		 mov	 ecx, eax
  03b1a	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  03b20	79 05		 jns	 SHORT $LN18443@Load@4
  03b22	49		 dec	 ecx
  03b23	83 c9 fc	 or	 ecx, -4			; fffffffcH
  03b26	41		 inc	 ecx
$LN18443@Load@4:
  03b27	b2 ed		 mov	 dl, -19			; ffffffedH
  03b29	2a d1		 sub	 dl, cl
  03b2b	30 94 05 5c fe
	ff ff		 xor	 BYTE PTR __k$537830[ebp+eax], dl
  03b32	40		 inc	 eax
  03b33	83 f8 07	 cmp	 eax, 7
  03b36	7c e0		 jl	 SHORT $LL11506@Load@4
  03b38	56		 push	 esi
  03b39	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03b3f	50		 push	 eax
  03b40	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  03b45	8d 85 5c fe ff
	ff		 lea	 eax, DWORD PTR __k$537830[ebp]
  03b4b	50		 push	 eax
  03b4c	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03b52	ff d7		 call	 edi

; 1301 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_INS, szKeyText ) );

  03b54	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03b5a	50		 push	 eax
  03b5b	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523347[ebp]
  03b61	50		 push	 eax
  03b62	8d 8d f4 ee ff
	ff		 lea	 ecx, DWORD PTR $T523346[ebp]
  03b68	c7 85 cc f1 ff
	ff 96 00 00 00	 mov	 DWORD PTR $T523347[ebp], 150 ; 00000096H
  03b72	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  03b77	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  03b7d	50		 push	 eax
  03b7e	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523348[ebp]
  03b84	50		 push	 eax
  03b85	c6 45 fc 60	 mov	 BYTE PTR __$EHRec$[ebp+8], 96 ; 00000060H
  03b89	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  03b8e	8d 8d f8 ee ff
	ff		 lea	 ecx, DWORD PTR $T523346[ebp+4]
  03b94	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  03b98	ff d3		 call	 ebx

; 1302 : 
; 1303 : 	kLoader.LoadString_e( "KEY_DEL", "", szKeyText, MAX_PATH );

  03b9a	6a 04		 push	 4
  03b9c	c7 85 44 fe ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$537965[ebp], -1246582362 ; b5b2a9a6H
  03ba6	81 b5 44 fe ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$537965[ebp], -353637139 ; eaebecedH
  03bb0	c7 85 48 fe ff
	ff a9 a9 a7 00	 mov	 DWORD PTR __k$537965[ebp+4], 10987945 ; 00a7a9a9H
  03bba	58		 pop	 eax
$LL11618@Load@4:
  03bbb	8b c8		 mov	 ecx, eax
  03bbd	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  03bc3	79 05		 jns	 SHORT $LN18444@Load@4
  03bc5	49		 dec	 ecx
  03bc6	83 c9 fc	 or	 ecx, -4			; fffffffcH
  03bc9	41		 inc	 ecx
$LN18444@Load@4:
  03bca	b2 ed		 mov	 dl, -19			; ffffffedH
  03bcc	2a d1		 sub	 dl, cl
  03bce	30 94 05 44 fe
	ff ff		 xor	 BYTE PTR __k$537965[ebp+eax], dl
  03bd5	40		 inc	 eax
  03bd6	83 f8 07	 cmp	 eax, 7
  03bd9	7c e0		 jl	 SHORT $LL11618@Load@4
  03bdb	56		 push	 esi
  03bdc	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03be2	50		 push	 eax
  03be3	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  03be8	8d 85 44 fe ff
	ff		 lea	 eax, DWORD PTR __k$537965[ebp]
  03bee	50		 push	 eax
  03bef	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03bf5	ff d7		 call	 edi

; 1304 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_DEL, szKeyText ) );

  03bf7	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03bfd	50		 push	 eax
  03bfe	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523350[ebp]
  03c04	50		 push	 eax
  03c05	8d 8d cc ee ff
	ff		 lea	 ecx, DWORD PTR $T523349[ebp]
  03c0b	c7 85 cc f1 ff
	ff 97 00 00 00	 mov	 DWORD PTR $T523350[ebp], 151 ; 00000097H
  03c15	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  03c1a	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  03c20	50		 push	 eax
  03c21	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523351[ebp]
  03c27	50		 push	 eax
  03c28	c6 45 fc 61	 mov	 BYTE PTR __$EHRec$[ebp+8], 97 ; 00000061H
  03c2c	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  03c31	8d 8d d0 ee ff
	ff		 lea	 ecx, DWORD PTR $T523349[ebp+4]
  03c37	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  03c3b	ff d3		 call	 ebx
  03c3d	6a 02		 push	 2

; 1305 : 
; 1306 : 	kLoader.LoadString_e( "KEY_HOME", "", szKeyText, MAX_PATH );

  03c3f	c7 85 60 f5 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$538087[ebp], -1246582362 ; b5b2a9a6H
  03c49	c7 85 64 f5 ff
	ff a5 a3 a6 af	 mov	 DWORD PTR __k$538087[ebp+4], -1348033627 ; afa6a3a5H
  03c53	8d 85 60 f5 ff
	ff		 lea	 eax, DWORD PTR __k$538087[ebp]
  03c59	c6 85 68 f5 ff
	ff 00		 mov	 BYTE PTR __k$538087[ebp+8], 0
  03c60	59		 pop	 ecx
$LL11733@Load@4:
  03c61	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  03c67	83 c0 04	 add	 eax, 4
  03c6a	49		 dec	 ecx
  03c6b	75 f4		 jne	 SHORT $LL11733@Load@4
  03c6d	56		 push	 esi
  03c6e	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03c74	50		 push	 eax
  03c75	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  03c7a	8d 85 60 f5 ff
	ff		 lea	 eax, DWORD PTR __k$538087[ebp]
  03c80	50		 push	 eax
  03c81	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03c87	ff d7		 call	 edi

; 1307 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_HOME, szKeyText ) );

  03c89	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03c8f	50		 push	 eax
  03c90	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523353[ebp]
  03c96	50		 push	 eax
  03c97	8d 8d a4 ee ff
	ff		 lea	 ecx, DWORD PTR $T523352[ebp]
  03c9d	c7 85 cc f1 ff
	ff 98 00 00 00	 mov	 DWORD PTR $T523353[ebp], 152 ; 00000098H
  03ca7	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  03cac	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  03cb2	50		 push	 eax
  03cb3	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523354[ebp]
  03cb9	50		 push	 eax
  03cba	c6 45 fc 62	 mov	 BYTE PTR __$EHRec$[ebp+8], 98 ; 00000062H
  03cbe	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  03cc3	8d 8d a8 ee ff
	ff		 lea	 ecx, DWORD PTR $T523352[ebp+4]
  03cc9	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  03ccd	ff d3		 call	 ebx

; 1308 : 
; 1309 : 	kLoader.LoadString_e( "KEY_END", "", szKeyText, MAX_PATH );

  03ccf	6a 04		 push	 4
  03cd1	c7 85 2c fe ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$538222[ebp], -1246582362 ; b5b2a9a6H
  03cdb	81 b5 2c fe ff
	ff ed ec eb ea	 xor	 DWORD PTR __k$538222[ebp], -353637139 ; eaebecedH
  03ce5	c7 85 30 fe ff
	ff a8 a2 af 00	 mov	 DWORD PTR __k$538222[ebp+4], 11510440 ; 00afa2a8H
  03cef	58		 pop	 eax
$LL11842@Load@4:
  03cf0	8b c8		 mov	 ecx, eax
  03cf2	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  03cf8	79 05		 jns	 SHORT $LN18445@Load@4
  03cfa	49		 dec	 ecx
  03cfb	83 c9 fc	 or	 ecx, -4			; fffffffcH
  03cfe	41		 inc	 ecx
$LN18445@Load@4:
  03cff	b2 ed		 mov	 dl, -19			; ffffffedH
  03d01	2a d1		 sub	 dl, cl
  03d03	30 94 05 2c fe
	ff ff		 xor	 BYTE PTR __k$538222[ebp+eax], dl
  03d0a	40		 inc	 eax
  03d0b	83 f8 07	 cmp	 eax, 7
  03d0e	7c e0		 jl	 SHORT $LL11842@Load@4
  03d10	56		 push	 esi
  03d11	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03d17	50		 push	 eax
  03d18	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  03d1d	8d 85 2c fe ff
	ff		 lea	 eax, DWORD PTR __k$538222[ebp]
  03d23	50		 push	 eax
  03d24	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03d2a	ff d7		 call	 edi

; 1310 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_END, szKeyText ) );

  03d2c	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03d32	50		 push	 eax
  03d33	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523356[ebp]
  03d39	50		 push	 eax
  03d3a	8d 8d 7c ee ff
	ff		 lea	 ecx, DWORD PTR $T523355[ebp]
  03d40	c7 85 cc f1 ff
	ff 99 00 00 00	 mov	 DWORD PTR $T523356[ebp], 153 ; 00000099H
  03d4a	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  03d4f	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  03d55	50		 push	 eax
  03d56	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523357[ebp]
  03d5c	50		 push	 eax
  03d5d	c6 45 fc 63	 mov	 BYTE PTR __$EHRec$[ebp+8], 99 ; 00000063H
  03d61	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  03d66	8d 8d 80 ee ff
	ff		 lea	 ecx, DWORD PTR $T523355[ebp+4]
  03d6c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  03d70	ff d3		 call	 ebx
  03d72	6a 02		 push	 2

; 1311 : 
; 1312 : 	kLoader.LoadString_e( "KEY_PGUP", "", szKeyText, MAX_PATH );

  03d74	c7 85 70 f6 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$538357[ebp], -1246582362 ; b5b2a9a6H
  03d7e	c7 85 74 f6 ff
	ff bd ab be ba	 mov	 DWORD PTR __k$538357[ebp+4], -1161909315 ; babeabbdH
  03d88	8d 85 70 f6 ff
	ff		 lea	 eax, DWORD PTR __k$538357[ebp]
  03d8e	c6 85 78 f6 ff
	ff 00		 mov	 BYTE PTR __k$538357[ebp+8], 0
  03d95	59		 pop	 ecx
$LL11957@Load@4:
  03d96	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  03d9c	83 c0 04	 add	 eax, 4
  03d9f	49		 dec	 ecx
  03da0	75 f4		 jne	 SHORT $LL11957@Load@4
  03da2	56		 push	 esi
  03da3	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03da9	50		 push	 eax
  03daa	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  03daf	8d 85 70 f6 ff
	ff		 lea	 eax, DWORD PTR __k$538357[ebp]
  03db5	50		 push	 eax
  03db6	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03dbc	ff d7		 call	 edi

; 1313 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_PGUP, szKeyText ) );

  03dbe	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03dc4	50		 push	 eax
  03dc5	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523359[ebp]
  03dcb	50		 push	 eax
  03dcc	8d 8d 54 ee ff
	ff		 lea	 ecx, DWORD PTR $T523358[ebp]
  03dd2	c7 85 cc f1 ff
	ff 9a 00 00 00	 mov	 DWORD PTR $T523359[ebp], 154 ; 0000009aH
  03ddc	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  03de1	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  03de7	50		 push	 eax
  03de8	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523360[ebp]
  03dee	50		 push	 eax
  03def	c6 45 fc 64	 mov	 BYTE PTR __$EHRec$[ebp+8], 100 ; 00000064H
  03df3	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  03df8	8d 8d 58 ee ff
	ff		 lea	 ecx, DWORD PTR $T523358[ebp+4]
  03dfe	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  03e02	ff d3		 call	 ebx
  03e04	6a 02		 push	 2

; 1314 : 
; 1315 : 	kLoader.LoadString_e( "KEY_PGDN", "", szKeyText, MAX_PATH );

  03e06	c7 85 70 f5 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$538492[ebp], -1246582362 ; b5b2a9a6H
  03e10	c7 85 74 f5 ff
	ff bd ab af a4	 mov	 DWORD PTR __k$538492[ebp+4], -1531991107 ; a4afabbdH
  03e1a	8d 85 70 f5 ff
	ff		 lea	 eax, DWORD PTR __k$538492[ebp]
  03e20	c6 85 78 f5 ff
	ff 00		 mov	 BYTE PTR __k$538492[ebp+8], 0
  03e27	59		 pop	 ecx
$LL12069@Load@4:
  03e28	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  03e2e	83 c0 04	 add	 eax, 4
  03e31	49		 dec	 ecx
  03e32	75 f4		 jne	 SHORT $LL12069@Load@4
  03e34	56		 push	 esi
  03e35	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03e3b	50		 push	 eax
  03e3c	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  03e41	8d 85 70 f5 ff
	ff		 lea	 eax, DWORD PTR __k$538492[ebp]
  03e47	50		 push	 eax
  03e48	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03e4e	ff d7		 call	 edi

; 1316 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_PGDN, szKeyText ) );

  03e50	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03e56	50		 push	 eax
  03e57	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523362[ebp]
  03e5d	50		 push	 eax
  03e5e	8d 8d 2c ee ff
	ff		 lea	 ecx, DWORD PTR $T523361[ebp]
  03e64	c7 85 cc f1 ff
	ff 9b 00 00 00	 mov	 DWORD PTR $T523362[ebp], 155 ; 0000009bH
  03e6e	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  03e73	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  03e79	50		 push	 eax
  03e7a	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523363[ebp]
  03e80	50		 push	 eax
  03e81	c6 45 fc 65	 mov	 BYTE PTR __$EHRec$[ebp+8], 101 ; 00000065H
  03e85	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  03e8a	8d 8d 30 ee ff
	ff		 lea	 ecx, DWORD PTR $T523361[ebp+4]
  03e90	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  03e94	ff d3		 call	 ebx
  03e96	6a 03		 push	 3

; 1317 : 
; 1318 : 	kLoader.LoadString_e( "KEY_NUMSLASH", "", szKeyText, MAX_PATH );

  03e98	c7 85 f0 f6 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$538629[ebp], -1246582362 ; b5b2a9a6H
  03ea2	c7 85 f4 f6 ff
	ff a3 b9 a6 b9	 mov	 DWORD PTR __k$538629[ebp+4], -1180255837 ; b9a6b9a3H
  03eac	c7 85 f8 f6 ff
	ff a1 ad b8 a2	 mov	 DWORD PTR __k$538629[ebp+8], -1564955231 ; a2b8ada1H
  03eb6	8d 85 f0 f6 ff
	ff		 lea	 eax, DWORD PTR __k$538629[ebp]
  03ebc	c6 85 fc f6 ff
	ff 00		 mov	 BYTE PTR __k$538629[ebp+12], 0
  03ec3	59		 pop	 ecx
$LL12181@Load@4:
  03ec4	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  03eca	83 c0 04	 add	 eax, 4
  03ecd	49		 dec	 ecx
  03ece	75 f4		 jne	 SHORT $LL12181@Load@4
  03ed0	56		 push	 esi
  03ed1	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03ed7	50		 push	 eax
  03ed8	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  03edd	8d 85 f0 f6 ff
	ff		 lea	 eax, DWORD PTR __k$538629[ebp]
  03ee3	50		 push	 eax
  03ee4	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03eea	ff d7		 call	 edi

; 1319 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_NUMSLASH, szKeyText ) );

  03eec	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03ef2	50		 push	 eax
  03ef3	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523365[ebp]
  03ef9	50		 push	 eax
  03efa	8d 8d 04 ee ff
	ff		 lea	 ecx, DWORD PTR $T523364[ebp]
  03f00	c7 85 cc f1 ff
	ff 9c 00 00 00	 mov	 DWORD PTR $T523365[ebp], 156 ; 0000009cH
  03f0a	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  03f0f	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  03f15	50		 push	 eax
  03f16	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523366[ebp]
  03f1c	50		 push	 eax
  03f1d	c6 45 fc 66	 mov	 BYTE PTR __$EHRec$[ebp+8], 102 ; 00000066H
  03f21	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  03f26	8d 8d 08 ee ff
	ff		 lea	 ecx, DWORD PTR $T523364[ebp+4]
  03f2c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  03f30	ff d3		 call	 ebx
  03f32	6a 02		 push	 2

; 1320 : 
; 1321 : 	kLoader.LoadString_e( "KEY_NUMSTAR", "", szKeyText, MAX_PATH );

  03f34	c7 85 18 fb ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$538775[ebp], -1246582362 ; b5b2a9a6H
  03f3e	c7 85 1c fb ff
	ff a3 b9 a6 b9	 mov	 DWORD PTR __k$538775[ebp+4], -1180255837 ; b9a6b9a3H
  03f48	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR __k$538775[ebp]
  03f4e	c7 85 20 fb ff
	ff b9 ad b9 00	 mov	 DWORD PTR __k$538775[ebp+8], 12168633 ; 00b9adb9H
  03f58	59		 pop	 ecx
$LL12293@Load@4:
  03f59	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  03f5f	83 c0 04	 add	 eax, 4
  03f62	49		 dec	 ecx
  03f63	75 f4		 jne	 SHORT $LL12293@Load@4
  03f65	6a 08		 push	 8
  03f67	58		 pop	 eax
$LL12290@Load@4:
  03f68	8b c8		 mov	 ecx, eax
  03f6a	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  03f70	79 05		 jns	 SHORT $LN18446@Load@4
  03f72	49		 dec	 ecx
  03f73	83 c9 fc	 or	 ecx, -4			; fffffffcH
  03f76	41		 inc	 ecx
$LN18446@Load@4:
  03f77	b2 ed		 mov	 dl, -19			; ffffffedH
  03f79	2a d1		 sub	 dl, cl
  03f7b	30 94 05 18 fb
	ff ff		 xor	 BYTE PTR __k$538775[ebp+eax], dl
  03f82	40		 inc	 eax
  03f83	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  03f86	7c e0		 jl	 SHORT $LL12290@Load@4
  03f88	56		 push	 esi
  03f89	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03f8f	50		 push	 eax
  03f90	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  03f95	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR __k$538775[ebp]
  03f9b	50		 push	 eax
  03f9c	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  03fa2	ff d7		 call	 edi

; 1322 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_NUMSTAR, szKeyText ) );

  03fa4	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  03faa	50		 push	 eax
  03fab	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523368[ebp]
  03fb1	50		 push	 eax
  03fb2	8d 8d dc ed ff
	ff		 lea	 ecx, DWORD PTR $T523367[ebp]
  03fb8	c7 85 cc f1 ff
	ff 9d 00 00 00	 mov	 DWORD PTR $T523368[ebp], 157 ; 0000009dH
  03fc2	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  03fc7	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  03fcd	50		 push	 eax
  03fce	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523369[ebp]
  03fd4	50		 push	 eax
  03fd5	c6 45 fc 67	 mov	 BYTE PTR __$EHRec$[ebp+8], 103 ; 00000067H
  03fd9	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  03fde	8d 8d e0 ed ff
	ff		 lea	 ecx, DWORD PTR $T523367[ebp+4]
  03fe4	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  03fe8	ff d3		 call	 ebx
  03fea	6a 03		 push	 3

; 1323 : 
; 1324 : 	kLoader.LoadString_e( "KEY_NUMMINUS", "", szKeyText, MAX_PATH );

  03fec	c7 85 c8 f6 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$538910[ebp], -1246582362 ; b5b2a9a6H
  03ff6	c7 85 cc f6 ff
	ff a3 b9 a6 a7	 mov	 DWORD PTR __k$538910[ebp+4], -1482245725 ; a7a6b9a3H
  04000	c7 85 d0 f6 ff
	ff a4 a2 be b9	 mov	 DWORD PTR __k$538910[ebp+8], -1178688860 ; b9bea2a4H
  0400a	8d 85 c8 f6 ff
	ff		 lea	 eax, DWORD PTR __k$538910[ebp]
  04010	c6 85 d4 f6 ff
	ff 00		 mov	 BYTE PTR __k$538910[ebp+12], 0
  04017	59		 pop	 ecx
$LL12405@Load@4:
  04018	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0401e	83 c0 04	 add	 eax, 4
  04021	49		 dec	 ecx
  04022	75 f4		 jne	 SHORT $LL12405@Load@4
  04024	56		 push	 esi
  04025	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0402b	50		 push	 eax
  0402c	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  04031	8d 85 c8 f6 ff
	ff		 lea	 eax, DWORD PTR __k$538910[ebp]
  04037	50		 push	 eax
  04038	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0403e	ff d7		 call	 edi

; 1325 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_NUMMINUS, szKeyText ) );

  04040	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  04046	50		 push	 eax
  04047	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523371[ebp]
  0404d	50		 push	 eax
  0404e	8d 8d b4 ed ff
	ff		 lea	 ecx, DWORD PTR $T523370[ebp]
  04054	c7 85 cc f1 ff
	ff 9e 00 00 00	 mov	 DWORD PTR $T523371[ebp], 158 ; 0000009eH
  0405e	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  04063	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  04069	50		 push	 eax
  0406a	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523372[ebp]
  04070	50		 push	 eax
  04071	c6 45 fc 68	 mov	 BYTE PTR __$EHRec$[ebp+8], 104 ; 00000068H
  04075	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  0407a	8d 8d b8 ed ff
	ff		 lea	 ecx, DWORD PTR $T523370[ebp+4]
  04080	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  04084	ff d3		 call	 ebx
  04086	6a 02		 push	 2

; 1326 : 
; 1327 : 	kLoader.LoadString_e( "KEY_NUMPLUS", "", szKeyText, MAX_PATH );

  04088	c7 85 14 fc ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$539032[ebp], -1246582362 ; b5b2a9a6H
  04092	c7 85 18 fc ff
	ff a3 b9 a6 ba	 mov	 DWORD PTR __k$539032[ebp+4], -1163478621 ; baa6b9a3H
  0409c	8d 85 14 fc ff
	ff		 lea	 eax, DWORD PTR __k$539032[ebp]
  040a2	c7 85 1c fc ff
	ff a1 b9 b8 00	 mov	 DWORD PTR __k$539032[ebp+8], 12106145 ; 00b8b9a1H
  040ac	59		 pop	 ecx
$LL12517@Load@4:
  040ad	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  040b3	83 c0 04	 add	 eax, 4
  040b6	49		 dec	 ecx
  040b7	75 f4		 jne	 SHORT $LL12517@Load@4
  040b9	6a 08		 push	 8
  040bb	58		 pop	 eax
$LL12514@Load@4:
  040bc	8b c8		 mov	 ecx, eax
  040be	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  040c4	79 05		 jns	 SHORT $LN18447@Load@4
  040c6	49		 dec	 ecx
  040c7	83 c9 fc	 or	 ecx, -4			; fffffffcH
  040ca	41		 inc	 ecx
$LN18447@Load@4:
  040cb	b2 ed		 mov	 dl, -19			; ffffffedH
  040cd	2a d1		 sub	 dl, cl
  040cf	30 94 05 14 fc
	ff ff		 xor	 BYTE PTR __k$539032[ebp+eax], dl
  040d6	40		 inc	 eax
  040d7	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  040da	7c e0		 jl	 SHORT $LL12514@Load@4
  040dc	56		 push	 esi
  040dd	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  040e3	50		 push	 eax
  040e4	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  040e9	8d 85 14 fc ff
	ff		 lea	 eax, DWORD PTR __k$539032[ebp]
  040ef	50		 push	 eax
  040f0	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  040f6	ff d7		 call	 edi

; 1328 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_NUMPLUS, szKeyText ) );

  040f8	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  040fe	50		 push	 eax
  040ff	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523374[ebp]
  04105	50		 push	 eax
  04106	8d 8d 8c ed ff
	ff		 lea	 ecx, DWORD PTR $T523373[ebp]
  0410c	c7 85 cc f1 ff
	ff 9f 00 00 00	 mov	 DWORD PTR $T523374[ebp], 159 ; 0000009fH
  04116	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  0411b	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  04121	50		 push	 eax
  04122	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523375[ebp]
  04128	50		 push	 eax
  04129	c6 45 fc 69	 mov	 BYTE PTR __$EHRec$[ebp+8], 105 ; 00000069H
  0412d	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  04132	8d 8d 90 ed ff
	ff		 lea	 ecx, DWORD PTR $T523373[ebp+4]
  04138	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0413c	ff d3		 call	 ebx
  0413e	6a 03		 push	 3

; 1329 : 
; 1330 : 	kLoader.LoadString_e( "KEY_NUMENTER", "", szKeyText, MAX_PATH );

  04140	c7 85 a0 f6 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$539167[ebp], -1246582362 ; b5b2a9a6H
  0414a	c7 85 a4 f6 ff
	ff a3 b9 a6 af	 mov	 DWORD PTR __k$539167[ebp+4], -1348027997 ; afa6b9a3H
  04154	c7 85 a8 f6 ff
	ff a3 b8 ae b8	 mov	 DWORD PTR __k$539167[ebp+8], -1196509021 ; b8aeb8a3H
  0415e	8d 85 a0 f6 ff
	ff		 lea	 eax, DWORD PTR __k$539167[ebp]
  04164	c6 85 ac f6 ff
	ff 00		 mov	 BYTE PTR __k$539167[ebp+12], 0
  0416b	59		 pop	 ecx
$LL12629@Load@4:
  0416c	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  04172	83 c0 04	 add	 eax, 4
  04175	49		 dec	 ecx
  04176	75 f4		 jne	 SHORT $LL12629@Load@4
  04178	56		 push	 esi
  04179	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0417f	50		 push	 eax
  04180	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  04185	8d 85 a0 f6 ff
	ff		 lea	 eax, DWORD PTR __k$539167[ebp]
  0418b	50		 push	 eax
  0418c	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04192	ff d7		 call	 edi

; 1331 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_NUMENTER, szKeyText ) );

  04194	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0419a	50		 push	 eax
  0419b	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523377[ebp]
  041a1	50		 push	 eax
  041a2	8d 8d 64 ed ff
	ff		 lea	 ecx, DWORD PTR $T523376[ebp]
  041a8	c7 85 cc f1 ff
	ff a0 00 00 00	 mov	 DWORD PTR $T523377[ebp], 160 ; 000000a0H
  041b2	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  041b7	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  041bd	50		 push	 eax
  041be	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523378[ebp]
  041c4	50		 push	 eax
  041c5	c6 45 fc 6a	 mov	 BYTE PTR __$EHRec$[ebp+8], 106 ; 0000006aH
  041c9	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  041ce	8d 8d 68 ed ff
	ff		 lea	 ecx, DWORD PTR $T523376[ebp+4]
  041d4	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  041d8	ff d3		 call	 ebx
  041da	6a 03		 push	 3

; 1332 : 
; 1333 : 	kLoader.LoadString_e( "KEY_NUMPERIOD", "", szKeyText, MAX_PATH );

  041dc	c7 85 90 fc ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$539302[ebp], -1246582362 ; b5b2a9a6H
  041e6	c7 85 94 fc ff
	ff a3 b9 a6 ba	 mov	 DWORD PTR __k$539302[ebp+4], -1163478621 ; baa6b9a3H
  041f0	c7 85 98 fc ff
	ff a8 be a2 a5	 mov	 DWORD PTR __k$539302[ebp+8], -1516061016 ; a5a2bea8H
  041fa	8d 85 90 fc ff
	ff		 lea	 eax, DWORD PTR __k$539302[ebp]
  04200	66 c7 85 9c fc
	ff ff a9 00	 mov	 WORD PTR __k$539302[ebp+12], 169 ; 000000a9H
  04209	59		 pop	 ecx
$LL12741@Load@4:
  0420a	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  04210	83 c0 04	 add	 eax, 4
  04213	49		 dec	 ecx
  04214	75 f4		 jne	 SHORT $LL12741@Load@4
  04216	80 b5 9c fc ff
	ff ed		 xor	 BYTE PTR __k$539302[ebp+12], -19 ; ffffffedH
  0421d	56		 push	 esi
  0421e	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  04224	50		 push	 eax
  04225	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0422a	8d 85 90 fc ff
	ff		 lea	 eax, DWORD PTR __k$539302[ebp]
  04230	50		 push	 eax
  04231	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04237	ff d7		 call	 edi

; 1334 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_NUMPERIOD, szKeyText ) );

  04239	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0423f	50		 push	 eax
  04240	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523380[ebp]
  04246	50		 push	 eax
  04247	8d 8d 3c ed ff
	ff		 lea	 ecx, DWORD PTR $T523379[ebp]
  0424d	c7 85 cc f1 ff
	ff a1 00 00 00	 mov	 DWORD PTR $T523380[ebp], 161 ; 000000a1H
  04257	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  0425c	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  04262	50		 push	 eax
  04263	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523381[ebp]
  04269	50		 push	 eax
  0426a	c6 45 fc 6b	 mov	 BYTE PTR __$EHRec$[ebp+8], 107 ; 0000006bH
  0426e	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  04273	8d 8d 40 ed ff
	ff		 lea	 ecx, DWORD PTR $T523379[ebp+4]
  04279	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0427d	ff d3		 call	 ebx
  0427f	6a 02		 push	 2

; 1335 : 
; 1336 : 	kLoader.LoadString_e( "KEY_NUM0", "", szKeyText, MAX_PATH );

  04281	c7 85 50 f6 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$539437[ebp], -1246582362 ; b5b2a9a6H
  0428b	c7 85 54 f6 ff
	ff a3 b9 a6 da	 mov	 DWORD PTR __k$539437[ebp+4], -626607709 ; daa6b9a3H
  04295	8d 85 50 f6 ff
	ff		 lea	 eax, DWORD PTR __k$539437[ebp]
  0429b	c6 85 58 f6 ff
	ff 00		 mov	 BYTE PTR __k$539437[ebp+8], 0
  042a2	59		 pop	 ecx
$LL12853@Load@4:
  042a3	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  042a9	83 c0 04	 add	 eax, 4
  042ac	49		 dec	 ecx
  042ad	75 f4		 jne	 SHORT $LL12853@Load@4
  042af	56		 push	 esi
  042b0	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  042b6	50		 push	 eax
  042b7	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  042bc	8d 85 50 f6 ff
	ff		 lea	 eax, DWORD PTR __k$539437[ebp]
  042c2	50		 push	 eax
  042c3	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  042c9	ff d7		 call	 edi

; 1337 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_NUM0, szKeyText ) );

  042cb	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  042d1	50		 push	 eax
  042d2	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523383[ebp]
  042d8	50		 push	 eax
  042d9	8d 8d 14 ed ff
	ff		 lea	 ecx, DWORD PTR $T523382[ebp]
  042df	c7 85 cc f1 ff
	ff a2 00 00 00	 mov	 DWORD PTR $T523383[ebp], 162 ; 000000a2H
  042e9	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  042ee	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  042f4	50		 push	 eax
  042f5	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523384[ebp]
  042fb	50		 push	 eax
  042fc	c6 45 fc 6c	 mov	 BYTE PTR __$EHRec$[ebp+8], 108 ; 0000006cH
  04300	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  04305	8d 8d 18 ed ff
	ff		 lea	 ecx, DWORD PTR $T523382[ebp+4]
  0430b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0430f	ff d3		 call	 ebx
  04311	6a 02		 push	 2

; 1338 : 
; 1339 : 	kLoader.LoadString_e( "KEY_NUM1", "", szKeyText, MAX_PATH );

  04313	c7 85 d0 f5 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$539572[ebp], -1246582362 ; b5b2a9a6H
  0431d	c7 85 d4 f5 ff
	ff a3 b9 a6 db	 mov	 DWORD PTR __k$539572[ebp+4], -609830493 ; dba6b9a3H
  04327	8d 85 d0 f5 ff
	ff		 lea	 eax, DWORD PTR __k$539572[ebp]
  0432d	c6 85 d8 f5 ff
	ff 00		 mov	 BYTE PTR __k$539572[ebp+8], 0
  04334	59		 pop	 ecx
$LL12965@Load@4:
  04335	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0433b	83 c0 04	 add	 eax, 4
  0433e	49		 dec	 ecx
  0433f	75 f4		 jne	 SHORT $LL12965@Load@4
  04341	56		 push	 esi
  04342	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  04348	50		 push	 eax
  04349	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0434e	8d 85 d0 f5 ff
	ff		 lea	 eax, DWORD PTR __k$539572[ebp]
  04354	50		 push	 eax
  04355	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0435b	ff d7		 call	 edi

; 1340 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_NUM1, szKeyText ) );

  0435d	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  04363	50		 push	 eax
  04364	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523386[ebp]
  0436a	50		 push	 eax
  0436b	8d 8d ec ec ff
	ff		 lea	 ecx, DWORD PTR $T523385[ebp]
  04371	c7 85 cc f1 ff
	ff a3 00 00 00	 mov	 DWORD PTR $T523386[ebp], 163 ; 000000a3H
  0437b	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  04380	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  04386	50		 push	 eax
  04387	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523387[ebp]
  0438d	50		 push	 eax
  0438e	c6 45 fc 6d	 mov	 BYTE PTR __$EHRec$[ebp+8], 109 ; 0000006dH
  04392	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  04397	8d 8d f0 ec ff
	ff		 lea	 ecx, DWORD PTR $T523385[ebp+4]
  0439d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  043a1	ff d3		 call	 ebx
  043a3	6a 02		 push	 2

; 1341 : 
; 1342 : 	kLoader.LoadString_e( "KEY_NUM2", "", szKeyText, MAX_PATH );

  043a5	c7 85 30 f6 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$539707[ebp], -1246582362 ; b5b2a9a6H
  043af	c7 85 34 f6 ff
	ff a3 b9 a6 d8	 mov	 DWORD PTR __k$539707[ebp+4], -660162141 ; d8a6b9a3H
  043b9	8d 85 30 f6 ff
	ff		 lea	 eax, DWORD PTR __k$539707[ebp]
  043bf	c6 85 38 f6 ff
	ff 00		 mov	 BYTE PTR __k$539707[ebp+8], 0
  043c6	59		 pop	 ecx
$LL13077@Load@4:
  043c7	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  043cd	83 c0 04	 add	 eax, 4
  043d0	49		 dec	 ecx
  043d1	75 f4		 jne	 SHORT $LL13077@Load@4
  043d3	56		 push	 esi
  043d4	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  043da	50		 push	 eax
  043db	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  043e0	8d 85 30 f6 ff
	ff		 lea	 eax, DWORD PTR __k$539707[ebp]
  043e6	50		 push	 eax
  043e7	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  043ed	ff d7		 call	 edi

; 1343 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_NUM2, szKeyText ) );

  043ef	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  043f5	50		 push	 eax
  043f6	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523389[ebp]
  043fc	50		 push	 eax
  043fd	8d 8d c4 ec ff
	ff		 lea	 ecx, DWORD PTR $T523388[ebp]
  04403	c7 85 cc f1 ff
	ff a4 00 00 00	 mov	 DWORD PTR $T523389[ebp], 164 ; 000000a4H
  0440d	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  04412	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  04418	50		 push	 eax
  04419	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523390[ebp]
  0441f	50		 push	 eax
  04420	c6 45 fc 6e	 mov	 BYTE PTR __$EHRec$[ebp+8], 110 ; 0000006eH
  04424	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  04429	8d 8d c8 ec ff
	ff		 lea	 ecx, DWORD PTR $T523388[ebp+4]
  0442f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  04433	ff d3		 call	 ebx
  04435	6a 02		 push	 2

; 1344 : 
; 1345 : 	kLoader.LoadString_e( "KEY_NUM3", "", szKeyText, MAX_PATH );

  04437	c7 85 90 f5 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$539842[ebp], -1246582362 ; b5b2a9a6H
  04441	c7 85 94 f5 ff
	ff a3 b9 a6 d9	 mov	 DWORD PTR __k$539842[ebp+4], -643384925 ; d9a6b9a3H
  0444b	8d 85 90 f5 ff
	ff		 lea	 eax, DWORD PTR __k$539842[ebp]
  04451	c6 85 98 f5 ff
	ff 00		 mov	 BYTE PTR __k$539842[ebp+8], 0
  04458	59		 pop	 ecx
$LL13189@Load@4:
  04459	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0445f	83 c0 04	 add	 eax, 4
  04462	49		 dec	 ecx
  04463	75 f4		 jne	 SHORT $LL13189@Load@4
  04465	56		 push	 esi
  04466	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0446c	50		 push	 eax
  0446d	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  04472	8d 85 90 f5 ff
	ff		 lea	 eax, DWORD PTR __k$539842[ebp]
  04478	50		 push	 eax
  04479	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0447f	ff d7		 call	 edi

; 1346 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_NUM3, szKeyText ) );

  04481	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  04487	50		 push	 eax
  04488	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523392[ebp]
  0448e	50		 push	 eax
  0448f	8d 8d 9c ec ff
	ff		 lea	 ecx, DWORD PTR $T523391[ebp]
  04495	c7 85 cc f1 ff
	ff a5 00 00 00	 mov	 DWORD PTR $T523392[ebp], 165 ; 000000a5H
  0449f	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  044a4	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  044aa	50		 push	 eax
  044ab	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523393[ebp]
  044b1	50		 push	 eax
  044b2	c6 45 fc 6f	 mov	 BYTE PTR __$EHRec$[ebp+8], 111 ; 0000006fH
  044b6	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  044bb	8d 8d a0 ec ff
	ff		 lea	 ecx, DWORD PTR $T523391[ebp+4]
  044c1	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  044c5	ff d3		 call	 ebx
  044c7	6a 02		 push	 2

; 1347 : 
; 1348 : 	kLoader.LoadString_e( "KEY_NUM4", "", szKeyText, MAX_PATH );

  044c9	c7 85 10 f6 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$539977[ebp], -1246582362 ; b5b2a9a6H
  044d3	c7 85 14 f6 ff
	ff a3 b9 a6 de	 mov	 DWORD PTR __k$539977[ebp+4], -559498845 ; dea6b9a3H
  044dd	8d 85 10 f6 ff
	ff		 lea	 eax, DWORD PTR __k$539977[ebp]
  044e3	c6 85 18 f6 ff
	ff 00		 mov	 BYTE PTR __k$539977[ebp+8], 0
  044ea	59		 pop	 ecx
$LL13301@Load@4:
  044eb	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  044f1	83 c0 04	 add	 eax, 4
  044f4	49		 dec	 ecx
  044f5	75 f4		 jne	 SHORT $LL13301@Load@4
  044f7	56		 push	 esi
  044f8	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  044fe	50		 push	 eax
  044ff	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  04504	8d 85 10 f6 ff
	ff		 lea	 eax, DWORD PTR __k$539977[ebp]
  0450a	50		 push	 eax
  0450b	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04511	ff d7		 call	 edi

; 1349 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_NUM4, szKeyText ) );

  04513	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  04519	50		 push	 eax
  0451a	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523395[ebp]
  04520	50		 push	 eax
  04521	8d 8d 74 ec ff
	ff		 lea	 ecx, DWORD PTR $T523394[ebp]
  04527	c7 85 cc f1 ff
	ff a6 00 00 00	 mov	 DWORD PTR $T523395[ebp], 166 ; 000000a6H
  04531	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  04536	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  0453c	50		 push	 eax
  0453d	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523396[ebp]
  04543	50		 push	 eax
  04544	c6 45 fc 70	 mov	 BYTE PTR __$EHRec$[ebp+8], 112 ; 00000070H
  04548	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  0454d	8d 8d 78 ec ff
	ff		 lea	 ecx, DWORD PTR $T523394[ebp+4]
  04553	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  04557	ff d3		 call	 ebx
  04559	6a 02		 push	 2

; 1350 : 
; 1351 : 	kLoader.LoadString_e( "KEY_NUM5", "", szKeyText, MAX_PATH );

  0455b	c7 85 b0 f5 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$540112[ebp], -1246582362 ; b5b2a9a6H
  04565	c7 85 b4 f5 ff
	ff a3 b9 a6 df	 mov	 DWORD PTR __k$540112[ebp+4], -542721629 ; dfa6b9a3H
  0456f	8d 85 b0 f5 ff
	ff		 lea	 eax, DWORD PTR __k$540112[ebp]
  04575	c6 85 b8 f5 ff
	ff 00		 mov	 BYTE PTR __k$540112[ebp+8], 0
  0457c	59		 pop	 ecx
$LL13413@Load@4:
  0457d	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  04583	83 c0 04	 add	 eax, 4
  04586	49		 dec	 ecx
  04587	75 f4		 jne	 SHORT $LL13413@Load@4
  04589	56		 push	 esi
  0458a	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  04590	50		 push	 eax
  04591	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  04596	8d 85 b0 f5 ff
	ff		 lea	 eax, DWORD PTR __k$540112[ebp]
  0459c	50		 push	 eax
  0459d	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  045a3	ff d7		 call	 edi

; 1352 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_NUM5, szKeyText ) );

  045a5	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  045ab	50		 push	 eax
  045ac	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523398[ebp]
  045b2	50		 push	 eax
  045b3	8d 8d 4c ec ff
	ff		 lea	 ecx, DWORD PTR $T523397[ebp]
  045b9	c7 85 cc f1 ff
	ff a7 00 00 00	 mov	 DWORD PTR $T523398[ebp], 167 ; 000000a7H
  045c3	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  045c8	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  045ce	50		 push	 eax
  045cf	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523399[ebp]
  045d5	50		 push	 eax
  045d6	c6 45 fc 71	 mov	 BYTE PTR __$EHRec$[ebp+8], 113 ; 00000071H
  045da	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  045df	8d 8d 50 ec ff
	ff		 lea	 ecx, DWORD PTR $T523397[ebp+4]
  045e5	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  045e9	ff d3		 call	 ebx
  045eb	6a 02		 push	 2

; 1353 : 
; 1354 : 	kLoader.LoadString_e( "KEY_NUM6", "", szKeyText, MAX_PATH );

  045ed	c7 85 f0 f5 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$540247[ebp], -1246582362 ; b5b2a9a6H
  045f7	c7 85 f4 f5 ff
	ff a3 b9 a6 dc	 mov	 DWORD PTR __k$540247[ebp+4], -593053277 ; dca6b9a3H
  04601	8d 85 f0 f5 ff
	ff		 lea	 eax, DWORD PTR __k$540247[ebp]
  04607	c6 85 f8 f5 ff
	ff 00		 mov	 BYTE PTR __k$540247[ebp+8], 0
  0460e	59		 pop	 ecx
$LL13525@Load@4:
  0460f	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  04615	83 c0 04	 add	 eax, 4
  04618	49		 dec	 ecx
  04619	75 f4		 jne	 SHORT $LL13525@Load@4
  0461b	56		 push	 esi
  0461c	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  04622	50		 push	 eax
  04623	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  04628	8d 85 f0 f5 ff
	ff		 lea	 eax, DWORD PTR __k$540247[ebp]
  0462e	50		 push	 eax
  0462f	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04635	ff d7		 call	 edi

; 1355 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_NUM6, szKeyText ) );

  04637	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0463d	50		 push	 eax
  0463e	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523401[ebp]
  04644	50		 push	 eax
  04645	8d 8d 24 ec ff
	ff		 lea	 ecx, DWORD PTR $T523400[ebp]
  0464b	c7 85 cc f1 ff
	ff a8 00 00 00	 mov	 DWORD PTR $T523401[ebp], 168 ; 000000a8H
  04655	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  0465a	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  04660	50		 push	 eax
  04661	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523402[ebp]
  04667	50		 push	 eax
  04668	c6 45 fc 72	 mov	 BYTE PTR __$EHRec$[ebp+8], 114 ; 00000072H
  0466c	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  04671	8d 8d 28 ec ff
	ff		 lea	 ecx, DWORD PTR $T523400[ebp+4]
  04677	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0467b	ff d3		 call	 ebx
  0467d	6a 02		 push	 2

; 1356 : 
; 1357 : 	kLoader.LoadString_e( "KEY_NUM7", "", szKeyText, MAX_PATH );

  0467f	c7 85 80 f6 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$540382[ebp], -1246582362 ; b5b2a9a6H
  04689	c7 85 84 f6 ff
	ff a3 b9 a6 dd	 mov	 DWORD PTR __k$540382[ebp+4], -576276061 ; dda6b9a3H
  04693	8d 85 80 f6 ff
	ff		 lea	 eax, DWORD PTR __k$540382[ebp]
  04699	c6 85 88 f6 ff
	ff 00		 mov	 BYTE PTR __k$540382[ebp+8], 0
  046a0	59		 pop	 ecx
$LL13637@Load@4:
  046a1	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  046a7	83 c0 04	 add	 eax, 4
  046aa	49		 dec	 ecx
  046ab	75 f4		 jne	 SHORT $LL13637@Load@4
  046ad	56		 push	 esi
  046ae	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  046b4	50		 push	 eax
  046b5	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  046ba	8d 85 80 f6 ff
	ff		 lea	 eax, DWORD PTR __k$540382[ebp]
  046c0	50		 push	 eax
  046c1	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  046c7	ff d7		 call	 edi

; 1358 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_NUM7, szKeyText ) );

  046c9	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  046cf	50		 push	 eax
  046d0	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523404[ebp]
  046d6	50		 push	 eax
  046d7	8d 8d fc eb ff
	ff		 lea	 ecx, DWORD PTR $T523403[ebp]
  046dd	c7 85 cc f1 ff
	ff a9 00 00 00	 mov	 DWORD PTR $T523404[ebp], 169 ; 000000a9H
  046e7	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  046ec	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  046f2	50		 push	 eax
  046f3	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523405[ebp]
  046f9	50		 push	 eax
  046fa	c6 45 fc 73	 mov	 BYTE PTR __$EHRec$[ebp+8], 115 ; 00000073H
  046fe	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  04703	8d 8d 00 ec ff
	ff		 lea	 ecx, DWORD PTR $T523403[ebp+4]
  04709	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0470d	ff d3		 call	 ebx
  0470f	6a 02		 push	 2

; 1359 : 
; 1360 : 	kLoader.LoadString_e( "KEY_NUM8", "", szKeyText, MAX_PATH );

  04711	c7 85 60 f6 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$540517[ebp], -1246582362 ; b5b2a9a6H
  0471b	c7 85 64 f6 ff
	ff a3 b9 a6 d2	 mov	 DWORD PTR __k$540517[ebp+4], -760825437 ; d2a6b9a3H
  04725	8d 85 60 f6 ff
	ff		 lea	 eax, DWORD PTR __k$540517[ebp]
  0472b	c6 85 68 f6 ff
	ff 00		 mov	 BYTE PTR __k$540517[ebp+8], 0
  04732	59		 pop	 ecx
$LL13749@Load@4:
  04733	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  04739	83 c0 04	 add	 eax, 4
  0473c	49		 dec	 ecx
  0473d	75 f4		 jne	 SHORT $LL13749@Load@4
  0473f	56		 push	 esi
  04740	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  04746	50		 push	 eax
  04747	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0474c	8d 85 60 f6 ff
	ff		 lea	 eax, DWORD PTR __k$540517[ebp]
  04752	50		 push	 eax
  04753	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04759	ff d7		 call	 edi

; 1361 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_NUM8, szKeyText ) );

  0475b	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  04761	50		 push	 eax
  04762	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523407[ebp]
  04768	50		 push	 eax
  04769	8d 8d d4 eb ff
	ff		 lea	 ecx, DWORD PTR $T523406[ebp]
  0476f	c7 85 cc f1 ff
	ff aa 00 00 00	 mov	 DWORD PTR $T523407[ebp], 170 ; 000000aaH
  04779	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  0477e	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  04784	50		 push	 eax
  04785	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523408[ebp]
  0478b	50		 push	 eax
  0478c	c6 45 fc 74	 mov	 BYTE PTR __$EHRec$[ebp+8], 116 ; 00000074H
  04790	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  04795	8d 8d d8 eb ff
	ff		 lea	 ecx, DWORD PTR $T523406[ebp+4]
  0479b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0479f	ff d3		 call	 ebx
  047a1	6a 02		 push	 2

; 1362 : 
; 1363 : 	kLoader.LoadString_e( "KEY_NUM9", "", szKeyText, MAX_PATH );

  047a3	c7 85 40 f6 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$540652[ebp], -1246582362 ; b5b2a9a6H
  047ad	c7 85 44 f6 ff
	ff a3 b9 a6 d3	 mov	 DWORD PTR __k$540652[ebp+4], -744048221 ; d3a6b9a3H
  047b7	8d 85 40 f6 ff
	ff		 lea	 eax, DWORD PTR __k$540652[ebp]
  047bd	c6 85 48 f6 ff
	ff 00		 mov	 BYTE PTR __k$540652[ebp+8], 0
  047c4	59		 pop	 ecx
$LL13861@Load@4:
  047c5	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  047cb	83 c0 04	 add	 eax, 4
  047ce	49		 dec	 ecx
  047cf	75 f4		 jne	 SHORT $LL13861@Load@4
  047d1	56		 push	 esi
  047d2	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  047d8	50		 push	 eax
  047d9	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  047de	8d 85 40 f6 ff
	ff		 lea	 eax, DWORD PTR __k$540652[ebp]
  047e4	50		 push	 eax
  047e5	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  047eb	ff d7		 call	 edi

; 1364 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_NUM9, szKeyText ) );

  047ed	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  047f3	50		 push	 eax
  047f4	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523410[ebp]
  047fa	50		 push	 eax
  047fb	8d 8d ac eb ff
	ff		 lea	 ecx, DWORD PTR $T523409[ebp]
  04801	c7 85 cc f1 ff
	ff ab 00 00 00	 mov	 DWORD PTR $T523410[ebp], 171 ; 000000abH
  0480b	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  04810	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  04816	50		 push	 eax
  04817	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523411[ebp]
  0481d	50		 push	 eax
  0481e	c6 45 fc 75	 mov	 BYTE PTR __$EHRec$[ebp+8], 117 ; 00000075H
  04822	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  04827	8d 8d b0 eb ff
	ff		 lea	 ecx, DWORD PTR $T523409[ebp+4]
  0482d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  04831	ff d3		 call	 ebx
  04833	6a 02		 push	 2

; 1365 : 
; 1366 : 	kLoader.LoadString_e( "KEY_NUMLOCK", "", szKeyText, MAX_PATH );

  04835	c7 85 88 fa ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$540800[ebp], -1246582362 ; b5b2a9a6H
  0483f	c7 85 8c fa ff
	ff a3 b9 a6 a6	 mov	 DWORD PTR __k$540800[ebp+4], -1499022941 ; a6a6b9a3H
  04849	8d 85 88 fa ff
	ff		 lea	 eax, DWORD PTR __k$540800[ebp]
  0484f	c7 85 90 fa ff
	ff a2 af a0 00	 mov	 DWORD PTR __k$540800[ebp+8], 10530722 ; 00a0afa2H
  04859	59		 pop	 ecx
$LL13973@Load@4:
  0485a	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  04860	83 c0 04	 add	 eax, 4
  04863	49		 dec	 ecx
  04864	75 f4		 jne	 SHORT $LL13973@Load@4
  04866	6a 08		 push	 8
  04868	58		 pop	 eax
$LL13970@Load@4:
  04869	8b c8		 mov	 ecx, eax
  0486b	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  04871	79 05		 jns	 SHORT $LN18448@Load@4
  04873	49		 dec	 ecx
  04874	83 c9 fc	 or	 ecx, -4			; fffffffcH
  04877	41		 inc	 ecx
$LN18448@Load@4:
  04878	b2 ed		 mov	 dl, -19			; ffffffedH
  0487a	2a d1		 sub	 dl, cl
  0487c	30 94 05 88 fa
	ff ff		 xor	 BYTE PTR __k$540800[ebp+eax], dl
  04883	40		 inc	 eax
  04884	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  04887	7c e0		 jl	 SHORT $LL13970@Load@4
  04889	56		 push	 esi
  0488a	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  04890	50		 push	 eax
  04891	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  04896	8d 85 88 fa ff
	ff		 lea	 eax, DWORD PTR __k$540800[ebp]
  0489c	50		 push	 eax
  0489d	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  048a3	ff d7		 call	 edi

; 1367 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_NUMLOCK, szKeyText ) );

  048a5	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  048ab	50		 push	 eax
  048ac	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523413[ebp]
  048b2	50		 push	 eax
  048b3	8d 8d 84 eb ff
	ff		 lea	 ecx, DWORD PTR $T523412[ebp]
  048b9	c7 85 cc f1 ff
	ff ac 00 00 00	 mov	 DWORD PTR $T523413[ebp], 172 ; 000000acH
  048c3	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  048c8	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  048ce	50		 push	 eax
  048cf	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523414[ebp]
  048d5	50		 push	 eax
  048d6	c6 45 fc 76	 mov	 BYTE PTR __$EHRec$[ebp+8], 118 ; 00000076H
  048da	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  048df	8d 8d 88 eb ff
	ff		 lea	 ecx, DWORD PTR $T523412[ebp+4]
  048e5	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  048e9	ff d3		 call	 ebx
  048eb	6a 03		 push	 3

; 1368 : 
; 1369 : 	kLoader.LoadString_e( "KEY_CAPSLOCK", "", szKeyText, MAX_PATH );

  048ed	c7 85 1c f8 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$540935[ebp], -1246582362 ; b5b2a9a6H
  048f7	c7 85 20 f8 ff
	ff ae ad bb b9	 mov	 DWORD PTR __k$540935[ebp+4], -1178882642 ; b9bbadaeH
  04901	c7 85 24 f8 ff
	ff a1 a3 a8 a1	 mov	 DWORD PTR __k$540935[ebp+8], -1582783583 ; a1a8a3a1H
  0490b	8d 85 1c f8 ff
	ff		 lea	 eax, DWORD PTR __k$540935[ebp]
  04911	c6 85 28 f8 ff
	ff 00		 mov	 BYTE PTR __k$540935[ebp+12], 0
  04918	59		 pop	 ecx
$LL14085@Load@4:
  04919	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0491f	83 c0 04	 add	 eax, 4
  04922	49		 dec	 ecx
  04923	75 f4		 jne	 SHORT $LL14085@Load@4
  04925	56		 push	 esi
  04926	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0492c	50		 push	 eax
  0492d	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  04932	8d 85 1c f8 ff
	ff		 lea	 eax, DWORD PTR __k$540935[ebp]
  04938	50		 push	 eax
  04939	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0493f	ff d7		 call	 edi

; 1370 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_CAPSLOCK, szKeyText ) );

  04941	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  04947	50		 push	 eax
  04948	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523416[ebp]
  0494e	50		 push	 eax
  0494f	8d 8d 5c eb ff
	ff		 lea	 ecx, DWORD PTR $T523415[ebp]
  04955	c7 85 cc f1 ff
	ff ad 00 00 00	 mov	 DWORD PTR $T523416[ebp], 173 ; 000000adH
  0495f	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  04964	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  0496a	50		 push	 eax
  0496b	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523417[ebp]
  04971	50		 push	 eax
  04972	c6 45 fc 77	 mov	 BYTE PTR __$EHRec$[ebp+8], 119 ; 00000077H
  04976	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  0497b	8d 8d 60 eb ff
	ff		 lea	 ecx, DWORD PTR $T523415[ebp+4]
  04981	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  04985	ff d3		 call	 ebx
  04987	6a 03		 push	 3

; 1371 : 
; 1372 : 	kLoader.LoadString_e( "KEY_SCROLLLOCK", "", szKeyText, MAX_PATH );

  04989	c7 85 28 fb ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$541057[ebp], -1246582362 ; b5b2a9a6H
  04993	c7 85 2c fb ff
	ff be af b9 a5	 mov	 DWORD PTR __k$541057[ebp+4], -1514557506 ; a5b9afbeH
  0499d	c7 85 30 fb ff
	ff a1 a0 a7 a5	 mov	 DWORD PTR __k$541057[ebp+8], -1515741023 ; a5a7a0a1H
  049a7	66 c7 85 34 fb
	ff ff ae a7	 mov	 WORD PTR __k$541057[ebp+12], 42926 ; 0000a7aeH
  049b0	8d 85 28 fb ff
	ff		 lea	 eax, DWORD PTR __k$541057[ebp]
  049b6	c6 85 36 fb ff
	ff 00		 mov	 BYTE PTR __k$541057[ebp+14], 0
  049bd	59		 pop	 ecx
$LL14197@Load@4:
  049be	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  049c4	83 c0 04	 add	 eax, 4
  049c7	49		 dec	 ecx
  049c8	75 f4		 jne	 SHORT $LL14197@Load@4
  049ca	6a 0c		 push	 12			; 0000000cH
  049cc	58		 pop	 eax
$LL14194@Load@4:
  049cd	8b c8		 mov	 ecx, eax
  049cf	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  049d5	79 05		 jns	 SHORT $LN18449@Load@4
  049d7	49		 dec	 ecx
  049d8	83 c9 fc	 or	 ecx, -4			; fffffffcH
  049db	41		 inc	 ecx
$LN18449@Load@4:
  049dc	b2 ed		 mov	 dl, -19			; ffffffedH
  049de	2a d1		 sub	 dl, cl
  049e0	30 94 05 28 fb
	ff ff		 xor	 BYTE PTR __k$541057[ebp+eax], dl
  049e7	40		 inc	 eax
  049e8	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  049eb	7c e0		 jl	 SHORT $LL14194@Load@4
  049ed	56		 push	 esi
  049ee	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  049f4	50		 push	 eax
  049f5	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  049fa	8d 85 28 fb ff
	ff		 lea	 eax, DWORD PTR __k$541057[ebp]
  04a00	50		 push	 eax
  04a01	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04a07	ff d7		 call	 edi

; 1373 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_SCROLLLOCK, szKeyText ) );

  04a09	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  04a0f	50		 push	 eax
  04a10	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523419[ebp]
  04a16	50		 push	 eax
  04a17	8d 8d 34 eb ff
	ff		 lea	 ecx, DWORD PTR $T523418[ebp]
  04a1d	c7 85 cc f1 ff
	ff ae 00 00 00	 mov	 DWORD PTR $T523419[ebp], 174 ; 000000aeH
  04a27	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  04a2c	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  04a32	50		 push	 eax
  04a33	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523420[ebp]
  04a39	50		 push	 eax
  04a3a	c6 45 fc 78	 mov	 BYTE PTR __$EHRec$[ebp+8], 120 ; 00000078H
  04a3e	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  04a43	8d 8d 38 eb ff
	ff		 lea	 ecx, DWORD PTR $T523418[ebp+4]
  04a49	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  04a4d	ff d3		 call	 ebx
  04a4f	6a 03		 push	 3

; 1374 : 
; 1375 : 	kLoader.LoadString_e( "KEY_PRINTSCRN", "", szKeyText, MAX_PATH );

  04a51	c7 85 6c fc ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$541192[ebp], -1246582362 ; b5b2a9a6H
  04a5b	c7 85 70 fc ff
	ff bd be a2 a4	 mov	 DWORD PTR __k$541192[ebp+4], -1532838211 ; a4a2bebdH
  04a65	c7 85 74 fc ff
	ff b9 bf a8 b8	 mov	 DWORD PTR __k$541192[ebp+8], -1196900423 ; b8a8bfb9H
  04a6f	8d 85 6c fc ff
	ff		 lea	 eax, DWORD PTR __k$541192[ebp]
  04a75	66 c7 85 78 fc
	ff ff a3 00	 mov	 WORD PTR __k$541192[ebp+12], 163 ; 000000a3H
  04a7e	59		 pop	 ecx
$LL14309@Load@4:
  04a7f	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  04a85	83 c0 04	 add	 eax, 4
  04a88	49		 dec	 ecx
  04a89	75 f4		 jne	 SHORT $LL14309@Load@4
  04a8b	80 b5 78 fc ff
	ff ed		 xor	 BYTE PTR __k$541192[ebp+12], -19 ; ffffffedH
  04a92	56		 push	 esi
  04a93	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  04a99	50		 push	 eax
  04a9a	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  04a9f	8d 85 6c fc ff
	ff		 lea	 eax, DWORD PTR __k$541192[ebp]
  04aa5	50		 push	 eax
  04aa6	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04aac	ff d7		 call	 edi

; 1376 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_PRINTSCRN, szKeyText ) );

  04aae	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  04ab4	50		 push	 eax
  04ab5	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523422[ebp]
  04abb	50		 push	 eax
  04abc	8d 8d 0c eb ff
	ff		 lea	 ecx, DWORD PTR $T523421[ebp]
  04ac2	c7 85 cc f1 ff
	ff af 00 00 00	 mov	 DWORD PTR $T523422[ebp], 175 ; 000000afH
  04acc	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  04ad1	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  04ad7	50		 push	 eax
  04ad8	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523423[ebp]
  04ade	50		 push	 eax
  04adf	c6 45 fc 79	 mov	 BYTE PTR __$EHRec$[ebp+8], 121 ; 00000079H
  04ae3	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  04ae8	8d 8d 10 eb ff
	ff		 lea	 ecx, DWORD PTR $T523421[ebp+4]
  04aee	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  04af2	ff d3		 call	 ebx
  04af4	6a 02		 push	 2

; 1377 : 
; 1378 : 	kLoader.LoadString_e( "KEY_PAUSE", "", szKeyText, MAX_PATH );

  04af6	c7 85 34 fd ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$541340[ebp], -1246582362 ; b5b2a9a6H
  04b00	c7 85 38 fd ff
	ff bd ad be b9	 mov	 DWORD PTR __k$541340[ebp+4], -1178686019 ; b9beadbdH
  04b0a	8d 85 34 fd ff
	ff		 lea	 eax, DWORD PTR __k$541340[ebp]
  04b10	66 c7 85 3c fd
	ff ff a8 00	 mov	 WORD PTR __k$541340[ebp+8], 168 ; 000000a8H
  04b19	59		 pop	 ecx
$LL14421@Load@4:
  04b1a	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  04b20	83 c0 04	 add	 eax, 4
  04b23	49		 dec	 ecx
  04b24	75 f4		 jne	 SHORT $LL14421@Load@4
  04b26	80 b5 3c fd ff
	ff ed		 xor	 BYTE PTR __k$541340[ebp+8], -19 ; ffffffedH
  04b2d	56		 push	 esi
  04b2e	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  04b34	50		 push	 eax
  04b35	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  04b3a	8d 85 34 fd ff
	ff		 lea	 eax, DWORD PTR __k$541340[ebp]
  04b40	50		 push	 eax
  04b41	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04b47	ff d7		 call	 edi

; 1379 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_PAUSE, szKeyText ) );

  04b49	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  04b4f	50		 push	 eax
  04b50	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523425[ebp]
  04b56	50		 push	 eax
  04b57	8d 8d e4 ea ff
	ff		 lea	 ecx, DWORD PTR $T523424[ebp]
  04b5d	c7 85 cc f1 ff
	ff b0 00 00 00	 mov	 DWORD PTR $T523425[ebp], 176 ; 000000b0H
  04b67	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  04b6c	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  04b72	50		 push	 eax
  04b73	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523426[ebp]
  04b79	50		 push	 eax
  04b7a	c6 45 fc 7a	 mov	 BYTE PTR __$EHRec$[ebp+8], 122 ; 0000007aH
  04b7e	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  04b83	8d 8d e8 ea ff
	ff		 lea	 ecx, DWORD PTR $T523424[ebp+4]
  04b89	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  04b8d	ff d3		 call	 ebx
  04b8f	6a 02		 push	 2

; 1380 : 
; 1381 : 	kLoader.LoadString_e( "KEY_LWIN", "", szKeyText, MAX_PATH );

  04b91	c7 85 20 f6 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$541462[ebp], -1246582362 ; b5b2a9a6H
  04b9b	c7 85 24 f6 ff
	ff a1 bb a2 a4	 mov	 DWORD PTR __k$541462[ebp+4], -1532839007 ; a4a2bba1H
  04ba5	8d 85 20 f6 ff
	ff		 lea	 eax, DWORD PTR __k$541462[ebp]
  04bab	c6 85 28 f6 ff
	ff 00		 mov	 BYTE PTR __k$541462[ebp+8], 0
  04bb2	59		 pop	 ecx
$LL14533@Load@4:
  04bb3	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  04bb9	83 c0 04	 add	 eax, 4
  04bbc	49		 dec	 ecx
  04bbd	75 f4		 jne	 SHORT $LL14533@Load@4
  04bbf	56		 push	 esi
  04bc0	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  04bc6	50		 push	 eax
  04bc7	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  04bcc	8d 85 20 f6 ff
	ff		 lea	 eax, DWORD PTR __k$541462[ebp]
  04bd2	50		 push	 eax
  04bd3	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04bd9	ff d7		 call	 edi

; 1382 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_LWIN, szKeyText ) );

  04bdb	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  04be1	50		 push	 eax
  04be2	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523428[ebp]
  04be8	50		 push	 eax
  04be9	8d 8d bc ea ff
	ff		 lea	 ecx, DWORD PTR $T523427[ebp]
  04bef	c7 85 cc f1 ff
	ff b1 00 00 00	 mov	 DWORD PTR $T523428[ebp], 177 ; 000000b1H
  04bf9	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  04bfe	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  04c04	50		 push	 eax
  04c05	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523429[ebp]
  04c0b	50		 push	 eax
  04c0c	c6 45 fc 7b	 mov	 BYTE PTR __$EHRec$[ebp+8], 123 ; 0000007bH
  04c10	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  04c15	8d 8d c0 ea ff
	ff		 lea	 ecx, DWORD PTR $T523427[ebp+4]
  04c1b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  04c1f	ff d3		 call	 ebx
  04c21	6a 02		 push	 2

; 1383 : 
; 1384 : 	kLoader.LoadString_e( "KEY_RWIN", "", szKeyText, MAX_PATH );

  04c23	c7 85 00 f6 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$541597[ebp], -1246582362 ; b5b2a9a6H
  04c2d	c7 85 04 f6 ff
	ff bf bb a2 a4	 mov	 DWORD PTR __k$541597[ebp+4], -1532838977 ; a4a2bbbfH
  04c37	8d 85 00 f6 ff
	ff		 lea	 eax, DWORD PTR __k$541597[ebp]
  04c3d	c6 85 08 f6 ff
	ff 00		 mov	 BYTE PTR __k$541597[ebp+8], 0
  04c44	59		 pop	 ecx
$LL14645@Load@4:
  04c45	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  04c4b	83 c0 04	 add	 eax, 4
  04c4e	49		 dec	 ecx
  04c4f	75 f4		 jne	 SHORT $LL14645@Load@4
  04c51	56		 push	 esi
  04c52	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  04c58	50		 push	 eax
  04c59	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  04c5e	8d 85 00 f6 ff
	ff		 lea	 eax, DWORD PTR __k$541597[ebp]
  04c64	50		 push	 eax
  04c65	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04c6b	ff d7		 call	 edi

; 1385 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_RWIN, szKeyText ) );

  04c6d	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  04c73	50		 push	 eax
  04c74	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523431[ebp]
  04c7a	50		 push	 eax
  04c7b	8d 8d 94 ea ff
	ff		 lea	 ecx, DWORD PTR $T523430[ebp]
  04c81	c7 85 cc f1 ff
	ff b2 00 00 00	 mov	 DWORD PTR $T523431[ebp], 178 ; 000000b2H
  04c8b	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  04c90	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  04c96	50		 push	 eax
  04c97	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523432[ebp]
  04c9d	50		 push	 eax
  04c9e	c6 45 fc 7c	 mov	 BYTE PTR __$EHRec$[ebp+8], 124 ; 0000007cH
  04ca2	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  04ca7	8d 8d 98 ea ff
	ff		 lea	 ecx, DWORD PTR $T523430[ebp+4]
  04cad	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  04cb1	ff d3		 call	 ebx
  04cb3	6a 03		 push	 3

; 1386 : 
; 1387 : 	kLoader.LoadString_e( "KEY_MOUSELEFT", "", szKeyText, MAX_PATH );

  04cb5	c7 85 48 fc ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$541745[ebp], -1246582362 ; b5b2a9a6H
  04cbf	c7 85 4c fc ff
	ff a0 a3 be b9	 mov	 DWORD PTR __k$541745[ebp+4], -1178688608 ; b9bea3a0H
  04cc9	c7 85 50 fc ff
	ff a8 a0 ae ac	 mov	 DWORD PTR __k$541745[ebp+8], -1397841752 ; acaea0a8H
  04cd3	8d 85 48 fc ff
	ff		 lea	 eax, DWORD PTR __k$541745[ebp]
  04cd9	66 c7 85 54 fc
	ff ff b9 00	 mov	 WORD PTR __k$541745[ebp+12], 185 ; 000000b9H
  04ce2	59		 pop	 ecx
$LL14757@Load@4:
  04ce3	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  04ce9	83 c0 04	 add	 eax, 4
  04cec	49		 dec	 ecx
  04ced	75 f4		 jne	 SHORT $LL14757@Load@4
  04cef	80 b5 54 fc ff
	ff ed		 xor	 BYTE PTR __k$541745[ebp+12], -19 ; ffffffedH
  04cf6	56		 push	 esi
  04cf7	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  04cfd	50		 push	 eax
  04cfe	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  04d03	8d 85 48 fc ff
	ff		 lea	 eax, DWORD PTR __k$541745[ebp]
  04d09	50		 push	 eax
  04d0a	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04d10	ff d7		 call	 edi

; 1388 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_MOUSELEFT, szKeyText ) );

  04d12	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  04d18	50		 push	 eax
  04d19	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523434[ebp]
  04d1f	50		 push	 eax
  04d20	8d 8d 6c ea ff
	ff		 lea	 ecx, DWORD PTR $T523433[ebp]
  04d26	c7 85 cc f1 ff
	ff 00 01 00 00	 mov	 DWORD PTR $T523434[ebp], 256 ; 00000100H
  04d30	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  04d35	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  04d3b	50		 push	 eax
  04d3c	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523435[ebp]
  04d42	50		 push	 eax
  04d43	c6 45 fc 7d	 mov	 BYTE PTR __$EHRec$[ebp+8], 125 ; 0000007dH
  04d47	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  04d4c	8d 8d 70 ea ff
	ff		 lea	 ecx, DWORD PTR $T523433[ebp+4]
  04d52	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  04d56	ff d3		 call	 ebx
  04d58	6a 03		 push	 3

; 1389 : 
; 1390 : 	kLoader.LoadString_e( "KEY_MOUSERIGHT", "", szKeyText, MAX_PATH );

  04d5a	c7 85 04 fb ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$541880[ebp], -1246582362 ; b5b2a9a6H
  04d64	c7 85 08 fb ff
	ff a0 a3 be b9	 mov	 DWORD PTR __k$541880[ebp+4], -1178688608 ; b9bea3a0H
  04d6e	c7 85 0c fb ff
	ff a8 be a2 ad	 mov	 DWORD PTR __k$541880[ebp+8], -1381843288 ; ada2bea8H
  04d78	66 c7 85 10 fb
	ff ff a5 b8	 mov	 WORD PTR __k$541880[ebp+12], 47269 ; 0000b8a5H
  04d81	8d 85 04 fb ff
	ff		 lea	 eax, DWORD PTR __k$541880[ebp]
  04d87	c6 85 12 fb ff
	ff 00		 mov	 BYTE PTR __k$541880[ebp+14], 0
  04d8e	59		 pop	 ecx
$LL14869@Load@4:
  04d8f	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  04d95	83 c0 04	 add	 eax, 4
  04d98	49		 dec	 ecx
  04d99	75 f4		 jne	 SHORT $LL14869@Load@4
  04d9b	6a 0c		 push	 12			; 0000000cH
  04d9d	58		 pop	 eax
$LL14866@Load@4:
  04d9e	8b c8		 mov	 ecx, eax
  04da0	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  04da6	79 05		 jns	 SHORT $LN18450@Load@4
  04da8	49		 dec	 ecx
  04da9	83 c9 fc	 or	 ecx, -4			; fffffffcH
  04dac	41		 inc	 ecx
$LN18450@Load@4:
  04dad	b2 ed		 mov	 dl, -19			; ffffffedH
  04daf	2a d1		 sub	 dl, cl
  04db1	30 94 05 04 fb
	ff ff		 xor	 BYTE PTR __k$541880[ebp+eax], dl
  04db8	40		 inc	 eax
  04db9	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  04dbc	7c e0		 jl	 SHORT $LL14866@Load@4
  04dbe	56		 push	 esi
  04dbf	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  04dc5	50		 push	 eax
  04dc6	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  04dcb	8d 85 04 fb ff
	ff		 lea	 eax, DWORD PTR __k$541880[ebp]
  04dd1	50		 push	 eax
  04dd2	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04dd8	ff d7		 call	 edi

; 1391 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_MOUSERIGHT, szKeyText ) );

  04dda	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  04de0	50		 push	 eax
  04de1	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523437[ebp]
  04de7	50		 push	 eax
  04de8	8d 8d 44 ea ff
	ff		 lea	 ecx, DWORD PTR $T523436[ebp]
  04dee	c7 85 cc f1 ff
	ff 01 01 00 00	 mov	 DWORD PTR $T523437[ebp], 257 ; 00000101H
  04df8	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  04dfd	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  04e03	50		 push	 eax
  04e04	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523438[ebp]
  04e0a	50		 push	 eax
  04e0b	c6 45 fc 7e	 mov	 BYTE PTR __$EHRec$[ebp+8], 126 ; 0000007eH
  04e0f	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  04e14	8d 8d 48 ea ff
	ff		 lea	 ecx, DWORD PTR $T523436[ebp+4]
  04e1a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  04e1e	ff d3		 call	 ebx
  04e20	6a 03		 push	 3

; 1392 : 
; 1393 : 	kLoader.LoadString_e( "KEY_MOUSEMIDDLE", "", szKeyText, MAX_PATH );

  04e22	c7 85 08 fa ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$542015[ebp], -1246582362 ; b5b2a9a6H
  04e2c	c7 85 0c fa ff
	ff a0 a3 be b9	 mov	 DWORD PTR __k$542015[ebp+4], -1178688608 ; b9bea3a0H
  04e36	c7 85 10 fa ff
	ff a8 a1 a2 ae	 mov	 DWORD PTR __k$542015[ebp+8], -1365073496 ; aea2a1a8H
  04e40	8d 85 08 fa ff
	ff		 lea	 eax, DWORD PTR __k$542015[ebp]
  04e46	c7 85 14 fa ff
	ff a9 a0 ae 00	 mov	 DWORD PTR __k$542015[ebp+12], 11444393 ; 00aea0a9H
  04e50	59		 pop	 ecx
$LL14981@Load@4:
  04e51	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  04e57	83 c0 04	 add	 eax, 4
  04e5a	49		 dec	 ecx
  04e5b	75 f4		 jne	 SHORT $LL14981@Load@4
  04e5d	6a 0c		 push	 12			; 0000000cH
  04e5f	58		 pop	 eax
$LL14978@Load@4:
  04e60	8b c8		 mov	 ecx, eax
  04e62	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  04e68	79 05		 jns	 SHORT $LN18451@Load@4
  04e6a	49		 dec	 ecx
  04e6b	83 c9 fc	 or	 ecx, -4			; fffffffcH
  04e6e	41		 inc	 ecx
$LN18451@Load@4:
  04e6f	b2 ed		 mov	 dl, -19			; ffffffedH
  04e71	2a d1		 sub	 dl, cl
  04e73	30 94 05 08 fa
	ff ff		 xor	 BYTE PTR __k$542015[ebp+eax], dl
  04e7a	40		 inc	 eax
  04e7b	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  04e7e	7c e0		 jl	 SHORT $LL14978@Load@4
  04e80	56		 push	 esi
  04e81	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  04e87	50		 push	 eax
  04e88	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  04e8d	8d 85 08 fa ff
	ff		 lea	 eax, DWORD PTR __k$542015[ebp]
  04e93	50		 push	 eax
  04e94	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04e9a	ff d7		 call	 edi

; 1394 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_MOUSEMIDDLE, szKeyText ) );

  04e9c	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  04ea2	50		 push	 eax
  04ea3	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523440[ebp]
  04ea9	50		 push	 eax
  04eaa	8d 8d 1c ea ff
	ff		 lea	 ecx, DWORD PTR $T523439[ebp]
  04eb0	c7 85 cc f1 ff
	ff 02 01 00 00	 mov	 DWORD PTR $T523440[ebp], 258 ; 00000102H
  04eba	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  04ebf	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  04ec5	50		 push	 eax
  04ec6	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523441[ebp]
  04ecc	50		 push	 eax
  04ecd	c6 45 fc 7f	 mov	 BYTE PTR __$EHRec$[ebp+8], 127 ; 0000007fH
  04ed1	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  04ed6	8d 8d 20 ea ff
	ff		 lea	 ecx, DWORD PTR $T523439[ebp+4]
  04edc	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  04ee0	ff d3		 call	 ebx
  04ee2	6a 03		 push	 3

; 1395 : 
; 1396 : 	kLoader.LoadString_e( "KEY_MOUSEBUTN4", "", szKeyText, MAX_PATH );

  04ee4	c7 85 e0 fa ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$542137[ebp], -1246582362 ; b5b2a9a6H
  04eee	c7 85 e4 fa ff
	ff a0 a3 be b9	 mov	 DWORD PTR __k$542137[ebp+4], -1178688608 ; b9bea3a0H
  04ef8	c7 85 e8 fa ff
	ff a8 ae be be	 mov	 DWORD PTR __k$542137[ebp+8], -1094799704 ; bebeaea8H
  04f02	66 c7 85 ec fa
	ff ff a3 d8	 mov	 WORD PTR __k$542137[ebp+12], 55459 ; 0000d8a3H
  04f0b	8d 85 e0 fa ff
	ff		 lea	 eax, DWORD PTR __k$542137[ebp]
  04f11	c6 85 ee fa ff
	ff 00		 mov	 BYTE PTR __k$542137[ebp+14], 0
  04f18	59		 pop	 ecx
$LL15093@Load@4:
  04f19	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  04f1f	83 c0 04	 add	 eax, 4
  04f22	49		 dec	 ecx
  04f23	75 f4		 jne	 SHORT $LL15093@Load@4
  04f25	6a 0c		 push	 12			; 0000000cH
  04f27	58		 pop	 eax
$LL15090@Load@4:
  04f28	8b c8		 mov	 ecx, eax
  04f2a	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  04f30	79 05		 jns	 SHORT $LN18452@Load@4
  04f32	49		 dec	 ecx
  04f33	83 c9 fc	 or	 ecx, -4			; fffffffcH
  04f36	41		 inc	 ecx
$LN18452@Load@4:
  04f37	b2 ed		 mov	 dl, -19			; ffffffedH
  04f39	2a d1		 sub	 dl, cl
  04f3b	30 94 05 e0 fa
	ff ff		 xor	 BYTE PTR __k$542137[ebp+eax], dl
  04f42	40		 inc	 eax
  04f43	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  04f46	7c e0		 jl	 SHORT $LL15090@Load@4
  04f48	56		 push	 esi
  04f49	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  04f4f	50		 push	 eax
  04f50	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  04f55	8d 85 e0 fa ff
	ff		 lea	 eax, DWORD PTR __k$542137[ebp]
  04f5b	50		 push	 eax
  04f5c	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  04f62	ff d7		 call	 edi

; 1397 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_MOUSEBUTN4, szKeyText ) );

  04f64	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  04f6a	50		 push	 eax
  04f6b	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523443[ebp]
  04f71	50		 push	 eax
  04f72	8d 8d f4 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523442[ebp]
  04f78	c7 85 cc f1 ff
	ff 03 01 00 00	 mov	 DWORD PTR $T523443[ebp], 259 ; 00000103H
  04f82	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  04f87	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  04f8d	50		 push	 eax
  04f8e	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523444[ebp]
  04f94	50		 push	 eax
  04f95	c6 45 fc 80	 mov	 BYTE PTR __$EHRec$[ebp+8], 128 ; 00000080H
  04f99	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  04f9e	8d 8d f8 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523442[ebp+4]
  04fa4	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  04fa8	ff d3		 call	 ebx
  04faa	6a 03		 push	 3

; 1398 : 
; 1399 : 	kLoader.LoadString_e( "KEY_LSTICKLEFT", "", szKeyText, MAX_PATH );

  04fac	c7 85 bc fa ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$542272[ebp], -1246582362 ; b5b2a9a6H
  04fb6	c7 85 c0 fa ff
	ff a1 bf bf a3	 mov	 DWORD PTR __k$542272[ebp+4], -1547714655 ; a3bfbfa1H
  04fc0	c7 85 c4 fa ff
	ff ae a7 a7 af	 mov	 DWORD PTR __k$542272[ebp+8], -1347967058 ; afa7a7aeH
  04fca	66 c7 85 c8 fa
	ff ff ab b8	 mov	 WORD PTR __k$542272[ebp+12], 47275 ; 0000b8abH
  04fd3	8d 85 bc fa ff
	ff		 lea	 eax, DWORD PTR __k$542272[ebp]
  04fd9	c6 85 ca fa ff
	ff 00		 mov	 BYTE PTR __k$542272[ebp+14], 0
  04fe0	59		 pop	 ecx
$LL15205@Load@4:
  04fe1	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  04fe7	83 c0 04	 add	 eax, 4
  04fea	49		 dec	 ecx
  04feb	75 f4		 jne	 SHORT $LL15205@Load@4
  04fed	6a 0c		 push	 12			; 0000000cH
  04fef	58		 pop	 eax
$LL15202@Load@4:
  04ff0	8b c8		 mov	 ecx, eax
  04ff2	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  04ff8	79 05		 jns	 SHORT $LN18453@Load@4
  04ffa	49		 dec	 ecx
  04ffb	83 c9 fc	 or	 ecx, -4			; fffffffcH
  04ffe	41		 inc	 ecx
$LN18453@Load@4:
  04fff	b2 ed		 mov	 dl, -19			; ffffffedH
  05001	2a d1		 sub	 dl, cl
  05003	30 94 05 bc fa
	ff ff		 xor	 BYTE PTR __k$542272[ebp+eax], dl
  0500a	40		 inc	 eax
  0500b	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  0500e	7c e0		 jl	 SHORT $LL15202@Load@4
  05010	56		 push	 esi
  05011	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05017	50		 push	 eax
  05018	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0501d	8d 85 bc fa ff
	ff		 lea	 eax, DWORD PTR __k$542272[ebp]
  05023	50		 push	 eax
  05024	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0502a	ff d7		 call	 edi

; 1400 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_LSTICKLEFT, szKeyText ) );

  0502c	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05032	50		 push	 eax
  05033	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523446[ebp]
  05039	50		 push	 eax
  0503a	8d 8d cc e9 ff
	ff		 lea	 ecx, DWORD PTR $T523445[ebp]
  05040	89 b5 cc f1 ff
	ff		 mov	 DWORD PTR $T523446[ebp], esi
  05046	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  0504b	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  05051	50		 push	 eax
  05052	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523447[ebp]
  05058	50		 push	 eax
  05059	c6 45 fc 81	 mov	 BYTE PTR __$EHRec$[ebp+8], 129 ; 00000081H
  0505d	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  05062	8d 8d d0 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523445[ebp+4]
  05068	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0506c	ff d3		 call	 ebx
  0506e	6a 03		 push	 3

; 1401 : 
; 1402 : 	kLoader.LoadString_e( "KEY_LSTICKRIGHT", "", szKeyText, MAX_PATH );

  05070	c7 85 e4 fd ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$542420[ebp], -1246582362 ; b5b2a9a6H
  0507a	c7 85 e8 fd ff
	ff a1 bf bf a3	 mov	 DWORD PTR __k$542420[ebp+4], -1547714655 ; a3bfbfa1H
  05084	c7 85 ec fd ff
	ff ae a7 b9 a3	 mov	 DWORD PTR __k$542420[ebp+8], -1548114002 ; a3b9a7aeH
  0508e	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR __k$542420[ebp]
  05094	c7 85 f0 fd ff
	ff aa a4 bf 00	 mov	 DWORD PTR __k$542420[ebp+12], 12559530 ; 00bfa4aaH
  0509e	59		 pop	 ecx
$LL15317@Load@4:
  0509f	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  050a5	83 c0 04	 add	 eax, 4
  050a8	49		 dec	 ecx
  050a9	75 f4		 jne	 SHORT $LL15317@Load@4
  050ab	6a 0c		 push	 12			; 0000000cH
  050ad	58		 pop	 eax
$LL15314@Load@4:
  050ae	8b c8		 mov	 ecx, eax
  050b0	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  050b6	79 05		 jns	 SHORT $LN18454@Load@4
  050b8	49		 dec	 ecx
  050b9	83 c9 fc	 or	 ecx, -4			; fffffffcH
  050bc	41		 inc	 ecx
$LN18454@Load@4:
  050bd	b2 ed		 mov	 dl, -19			; ffffffedH
  050bf	2a d1		 sub	 dl, cl
  050c1	30 94 05 e4 fd
	ff ff		 xor	 BYTE PTR __k$542420[ebp+eax], dl
  050c8	40		 inc	 eax
  050c9	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  050cc	7c e0		 jl	 SHORT $LL15314@Load@4
  050ce	56		 push	 esi
  050cf	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  050d5	50		 push	 eax
  050d6	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  050db	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR __k$542420[ebp]
  050e1	50		 push	 eax
  050e2	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  050e8	ff d7		 call	 edi

; 1403 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_LSTICKRIGHT, szKeyText ) );

  050ea	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  050f0	50		 push	 eax
  050f1	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523449[ebp]
  050f7	50		 push	 eax
  050f8	8d 8d a4 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523448[ebp]
  050fe	c7 85 cc f1 ff
	ff 05 01 00 00	 mov	 DWORD PTR $T523449[ebp], 261 ; 00000105H
  05108	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  0510d	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  05113	50		 push	 eax
  05114	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523450[ebp]
  0511a	50		 push	 eax
  0511b	c6 45 fc 82	 mov	 BYTE PTR __$EHRec$[ebp+8], 130 ; 00000082H
  0511f	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  05124	8d 8d a8 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523448[ebp+4]
  0512a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0512e	ff d3		 call	 ebx
  05130	6a 03		 push	 3

; 1404 : 
; 1405 : 	kLoader.LoadString_e( "KEY_LSTICKUP", "", szKeyText, MAX_PATH );

  05132	c7 85 40 f7 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$542542[ebp], -1246582362 ; b5b2a9a6H
  0513c	c7 85 44 f7 ff
	ff a1 bf bf a3	 mov	 DWORD PTR __k$542542[ebp+4], -1547714655 ; a3bfbfa1H
  05146	c7 85 48 f7 ff
	ff ae a7 be ba	 mov	 DWORD PTR __k$542542[ebp+8], -1161910354 ; babea7aeH
  05150	8d 85 40 f7 ff
	ff		 lea	 eax, DWORD PTR __k$542542[ebp]
  05156	c6 85 4c f7 ff
	ff 00		 mov	 BYTE PTR __k$542542[ebp+12], 0
  0515d	59		 pop	 ecx
$LL15429@Load@4:
  0515e	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  05164	83 c0 04	 add	 eax, 4
  05167	49		 dec	 ecx
  05168	75 f4		 jne	 SHORT $LL15429@Load@4
  0516a	56		 push	 esi
  0516b	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05171	50		 push	 eax
  05172	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  05177	8d 85 40 f7 ff
	ff		 lea	 eax, DWORD PTR __k$542542[ebp]
  0517d	50		 push	 eax
  0517e	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  05184	ff d7		 call	 edi

; 1406 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_LSTICKUP, szKeyText ) );

  05186	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0518c	50		 push	 eax
  0518d	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523452[ebp]
  05193	50		 push	 eax
  05194	8d 8d 7c e9 ff
	ff		 lea	 ecx, DWORD PTR $T523451[ebp]
  0519a	c7 85 cc f1 ff
	ff 06 01 00 00	 mov	 DWORD PTR $T523452[ebp], 262 ; 00000106H
  051a4	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  051a9	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  051af	50		 push	 eax
  051b0	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523453[ebp]
  051b6	50		 push	 eax
  051b7	c6 45 fc 83	 mov	 BYTE PTR __$EHRec$[ebp+8], 131 ; 00000083H
  051bb	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  051c0	8d 8d 80 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523451[ebp+4]
  051c6	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  051ca	ff d3		 call	 ebx
  051cc	6a 03		 push	 3

; 1407 : 
; 1408 : 	kLoader.LoadString_e( "KEY_LSTICKDOWN", "", szKeyText, MAX_PATH );

  051ce	c7 85 98 fa ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$542677[ebp], -1246582362 ; b5b2a9a6H
  051d8	c7 85 9c fa ff
	ff a1 bf bf a3	 mov	 DWORD PTR __k$542677[ebp+4], -1547714655 ; a3bfbfa1H
  051e2	c7 85 a0 fa ff
	ff ae a7 af a5	 mov	 DWORD PTR __k$542677[ebp+8], -1515214930 ; a5afa7aeH
  051ec	66 c7 85 a4 fa
	ff ff ba a2	 mov	 WORD PTR __k$542677[ebp+12], 41658 ; 0000a2baH
  051f5	8d 85 98 fa ff
	ff		 lea	 eax, DWORD PTR __k$542677[ebp]
  051fb	c6 85 a6 fa ff
	ff 00		 mov	 BYTE PTR __k$542677[ebp+14], 0
  05202	59		 pop	 ecx
$LL15541@Load@4:
  05203	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  05209	83 c0 04	 add	 eax, 4
  0520c	49		 dec	 ecx
  0520d	75 f4		 jne	 SHORT $LL15541@Load@4
  0520f	6a 0c		 push	 12			; 0000000cH
  05211	58		 pop	 eax
$LL15538@Load@4:
  05212	8b c8		 mov	 ecx, eax
  05214	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0521a	79 05		 jns	 SHORT $LN18455@Load@4
  0521c	49		 dec	 ecx
  0521d	83 c9 fc	 or	 ecx, -4			; fffffffcH
  05220	41		 inc	 ecx
$LN18455@Load@4:
  05221	b2 ed		 mov	 dl, -19			; ffffffedH
  05223	2a d1		 sub	 dl, cl
  05225	30 94 05 98 fa
	ff ff		 xor	 BYTE PTR __k$542677[ebp+eax], dl
  0522c	40		 inc	 eax
  0522d	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  05230	7c e0		 jl	 SHORT $LL15538@Load@4
  05232	56		 push	 esi
  05233	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05239	50		 push	 eax
  0523a	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0523f	8d 85 98 fa ff
	ff		 lea	 eax, DWORD PTR __k$542677[ebp]
  05245	50		 push	 eax
  05246	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0524c	ff d7		 call	 edi

; 1409 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_LSTICKDOWN, szKeyText ) );

  0524e	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05254	50		 push	 eax
  05255	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523455[ebp]
  0525b	50		 push	 eax
  0525c	8d 8d 54 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523454[ebp]
  05262	c7 85 cc f1 ff
	ff 07 01 00 00	 mov	 DWORD PTR $T523455[ebp], 263 ; 00000107H
  0526c	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  05271	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  05277	50		 push	 eax
  05278	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523456[ebp]
  0527e	50		 push	 eax
  0527f	c6 45 fc 84	 mov	 BYTE PTR __$EHRec$[ebp+8], 132 ; 00000084H
  05283	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  05288	8d 8d 58 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523454[ebp+4]
  0528e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  05292	ff d3		 call	 ebx
  05294	6a 03		 push	 3

; 1410 : 
; 1411 : 	kLoader.LoadString_e( "KEY_RSTICKLEFT", "", szKeyText, MAX_PATH );

  05296	c7 85 74 fa ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$542825[ebp], -1246582362 ; b5b2a9a6H
  052a0	c7 85 78 fa ff
	ff bf bf bf a3	 mov	 DWORD PTR __k$542825[ebp+4], -1547714625 ; a3bfbfbfH
  052aa	c7 85 7c fa ff
	ff ae a7 a7 af	 mov	 DWORD PTR __k$542825[ebp+8], -1347967058 ; afa7a7aeH
  052b4	66 c7 85 80 fa
	ff ff ab b8	 mov	 WORD PTR __k$542825[ebp+12], 47275 ; 0000b8abH
  052bd	8d 85 74 fa ff
	ff		 lea	 eax, DWORD PTR __k$542825[ebp]
  052c3	c6 85 82 fa ff
	ff 00		 mov	 BYTE PTR __k$542825[ebp+14], 0
  052ca	59		 pop	 ecx
$LL15653@Load@4:
  052cb	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  052d1	83 c0 04	 add	 eax, 4
  052d4	49		 dec	 ecx
  052d5	75 f4		 jne	 SHORT $LL15653@Load@4
  052d7	6a 0c		 push	 12			; 0000000cH
  052d9	58		 pop	 eax
$LL15650@Load@4:
  052da	8b c8		 mov	 ecx, eax
  052dc	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  052e2	79 05		 jns	 SHORT $LN18456@Load@4
  052e4	49		 dec	 ecx
  052e5	83 c9 fc	 or	 ecx, -4			; fffffffcH
  052e8	41		 inc	 ecx
$LN18456@Load@4:
  052e9	b2 ed		 mov	 dl, -19			; ffffffedH
  052eb	2a d1		 sub	 dl, cl
  052ed	30 94 05 74 fa
	ff ff		 xor	 BYTE PTR __k$542825[ebp+eax], dl
  052f4	40		 inc	 eax
  052f5	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  052f8	7c e0		 jl	 SHORT $LL15650@Load@4
  052fa	56		 push	 esi
  052fb	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05301	50		 push	 eax
  05302	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  05307	8d 85 74 fa ff
	ff		 lea	 eax, DWORD PTR __k$542825[ebp]
  0530d	50		 push	 eax
  0530e	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  05314	ff d7		 call	 edi

; 1412 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_RSTICKLEFT, szKeyText ) );

  05316	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0531c	50		 push	 eax
  0531d	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523458[ebp]
  05323	50		 push	 eax
  05324	8d 8d 2c e9 ff
	ff		 lea	 ecx, DWORD PTR $T523457[ebp]
  0532a	c7 85 cc f1 ff
	ff 08 01 00 00	 mov	 DWORD PTR $T523458[ebp], 264 ; 00000108H
  05334	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  05339	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  0533f	50		 push	 eax
  05340	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523459[ebp]
  05346	50		 push	 eax
  05347	c6 45 fc 85	 mov	 BYTE PTR __$EHRec$[ebp+8], 133 ; 00000085H
  0534b	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  05350	8d 8d 30 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523457[ebp+4]
  05356	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0535a	ff d3		 call	 ebx
  0535c	6a 03		 push	 3

; 1413 : 
; 1414 : 	kLoader.LoadString_e( "KEY_RSTICKRIGHT", "", szKeyText, MAX_PATH );

  0535e	c7 85 18 fe ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$542960[ebp], -1246582362 ; b5b2a9a6H
  05368	c7 85 1c fe ff
	ff bf bf bf a3	 mov	 DWORD PTR __k$542960[ebp+4], -1547714625 ; a3bfbfbfH
  05372	c7 85 20 fe ff
	ff ae a7 b9 a3	 mov	 DWORD PTR __k$542960[ebp+8], -1548114002 ; a3b9a7aeH
  0537c	8d 85 18 fe ff
	ff		 lea	 eax, DWORD PTR __k$542960[ebp]
  05382	c7 85 24 fe ff
	ff aa a4 bf 00	 mov	 DWORD PTR __k$542960[ebp+12], 12559530 ; 00bfa4aaH
  0538c	59		 pop	 ecx
$LL15765@Load@4:
  0538d	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  05393	83 c0 04	 add	 eax, 4
  05396	49		 dec	 ecx
  05397	75 f4		 jne	 SHORT $LL15765@Load@4
  05399	6a 0c		 push	 12			; 0000000cH
  0539b	58		 pop	 eax
$LL15762@Load@4:
  0539c	8b c8		 mov	 ecx, eax
  0539e	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  053a4	79 05		 jns	 SHORT $LN18457@Load@4
  053a6	49		 dec	 ecx
  053a7	83 c9 fc	 or	 ecx, -4			; fffffffcH
  053aa	41		 inc	 ecx
$LN18457@Load@4:
  053ab	b2 ed		 mov	 dl, -19			; ffffffedH
  053ad	2a d1		 sub	 dl, cl
  053af	30 94 05 18 fe
	ff ff		 xor	 BYTE PTR __k$542960[ebp+eax], dl
  053b6	40		 inc	 eax
  053b7	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  053ba	7c e0		 jl	 SHORT $LL15762@Load@4
  053bc	56		 push	 esi
  053bd	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  053c3	50		 push	 eax
  053c4	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  053c9	8d 85 18 fe ff
	ff		 lea	 eax, DWORD PTR __k$542960[ebp]
  053cf	50		 push	 eax
  053d0	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  053d6	ff d7		 call	 edi

; 1415 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_RSTICKRIGHT, szKeyText ) );

  053d8	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  053de	50		 push	 eax
  053df	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523461[ebp]
  053e5	50		 push	 eax
  053e6	8d 8d 04 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523460[ebp]
  053ec	c7 85 cc f1 ff
	ff 09 01 00 00	 mov	 DWORD PTR $T523461[ebp], 265 ; 00000109H
  053f6	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  053fb	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  05401	50		 push	 eax
  05402	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523462[ebp]
  05408	50		 push	 eax
  05409	c6 45 fc 86	 mov	 BYTE PTR __$EHRec$[ebp+8], 134 ; 00000086H
  0540d	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  05412	8d 8d 08 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523460[ebp+4]
  05418	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0541c	ff d3		 call	 ebx
  0541e	6a 03		 push	 3

; 1416 : 
; 1417 : 	kLoader.LoadString_e( "KEY_RSTICKUP", "", szKeyText, MAX_PATH );

  05420	c7 85 54 f7 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$543095[ebp], -1246582362 ; b5b2a9a6H
  0542a	c7 85 58 f7 ff
	ff bf bf bf a3	 mov	 DWORD PTR __k$543095[ebp+4], -1547714625 ; a3bfbfbfH
  05434	c7 85 5c f7 ff
	ff ae a7 be ba	 mov	 DWORD PTR __k$543095[ebp+8], -1161910354 ; babea7aeH
  0543e	8d 85 54 f7 ff
	ff		 lea	 eax, DWORD PTR __k$543095[ebp]
  05444	c6 85 60 f7 ff
	ff 00		 mov	 BYTE PTR __k$543095[ebp+12], 0
  0544b	59		 pop	 ecx
$LL15877@Load@4:
  0544c	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  05452	83 c0 04	 add	 eax, 4
  05455	49		 dec	 ecx
  05456	75 f4		 jne	 SHORT $LL15877@Load@4
  05458	56		 push	 esi
  05459	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0545f	50		 push	 eax
  05460	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  05465	8d 85 54 f7 ff
	ff		 lea	 eax, DWORD PTR __k$543095[ebp]
  0546b	50		 push	 eax
  0546c	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  05472	ff d7		 call	 edi

; 1418 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_RSTICKUP, szKeyText ) );

  05474	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0547a	50		 push	 eax
  0547b	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523464[ebp]
  05481	50		 push	 eax
  05482	8d 8d dc e8 ff
	ff		 lea	 ecx, DWORD PTR $T523463[ebp]
  05488	c7 85 cc f1 ff
	ff 0a 01 00 00	 mov	 DWORD PTR $T523464[ebp], 266 ; 0000010aH
  05492	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  05497	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  0549d	50		 push	 eax
  0549e	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523465[ebp]
  054a4	50		 push	 eax
  054a5	c6 45 fc 87	 mov	 BYTE PTR __$EHRec$[ebp+8], 135 ; 00000087H
  054a9	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  054ae	8d 8d e0 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523463[ebp+4]
  054b4	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  054b8	ff d3		 call	 ebx
  054ba	6a 03		 push	 3

; 1419 : 
; 1420 : 	kLoader.LoadString_e( "KEY_RSTICKDOWN", "", szKeyText, MAX_PATH );

  054bc	c7 85 50 fa ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$543217[ebp], -1246582362 ; b5b2a9a6H
  054c6	c7 85 54 fa ff
	ff bf bf bf a3	 mov	 DWORD PTR __k$543217[ebp+4], -1547714625 ; a3bfbfbfH
  054d0	c7 85 58 fa ff
	ff ae a7 af a5	 mov	 DWORD PTR __k$543217[ebp+8], -1515214930 ; a5afa7aeH
  054da	66 c7 85 5c fa
	ff ff ba a2	 mov	 WORD PTR __k$543217[ebp+12], 41658 ; 0000a2baH
  054e3	8d 85 50 fa ff
	ff		 lea	 eax, DWORD PTR __k$543217[ebp]
  054e9	c6 85 5e fa ff
	ff 00		 mov	 BYTE PTR __k$543217[ebp+14], 0
  054f0	59		 pop	 ecx
$LL15989@Load@4:
  054f1	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  054f7	83 c0 04	 add	 eax, 4
  054fa	49		 dec	 ecx
  054fb	75 f4		 jne	 SHORT $LL15989@Load@4
  054fd	6a 0c		 push	 12			; 0000000cH
  054ff	58		 pop	 eax
$LL15986@Load@4:
  05500	8b c8		 mov	 ecx, eax
  05502	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  05508	79 05		 jns	 SHORT $LN18458@Load@4
  0550a	49		 dec	 ecx
  0550b	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0550e	41		 inc	 ecx
$LN18458@Load@4:
  0550f	b2 ed		 mov	 dl, -19			; ffffffedH
  05511	2a d1		 sub	 dl, cl
  05513	30 94 05 50 fa
	ff ff		 xor	 BYTE PTR __k$543217[ebp+eax], dl
  0551a	40		 inc	 eax
  0551b	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  0551e	7c e0		 jl	 SHORT $LL15986@Load@4
  05520	56		 push	 esi
  05521	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05527	50		 push	 eax
  05528	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0552d	8d 85 50 fa ff
	ff		 lea	 eax, DWORD PTR __k$543217[ebp]
  05533	50		 push	 eax
  05534	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0553a	ff d7		 call	 edi

; 1421 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_RSTICKDOWN, szKeyText ) );

  0553c	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05542	50		 push	 eax
  05543	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523467[ebp]
  05549	50		 push	 eax
  0554a	8d 8d b4 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523466[ebp]
  05550	c7 85 cc f1 ff
	ff 0b 01 00 00	 mov	 DWORD PTR $T523467[ebp], 267 ; 0000010bH
  0555a	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  0555f	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  05565	50		 push	 eax
  05566	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523468[ebp]
  0556c	50		 push	 eax
  0556d	c6 45 fc 88	 mov	 BYTE PTR __$EHRec$[ebp+8], 136 ; 00000088H
  05571	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  05576	8d 8d b8 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523466[ebp+4]
  0557c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  05580	ff d3		 call	 ebx
  05582	6a 03		 push	 3

; 1422 : 
; 1423 : 	kLoader.LoadString_e( "KEY_JOYBUTN1", "", szKeyText, MAX_PATH );

  05584	c7 85 44 f8 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$543352[ebp], -1246582362 ; b5b2a9a6H
  0558e	c7 85 48 f8 ff
	ff a7 a3 b2 a8	 mov	 DWORD PTR __k$543352[ebp+4], -1464687705 ; a8b2a3a7H
  05598	c7 85 4c f8 ff
	ff b8 b8 a5 db	 mov	 DWORD PTR __k$543352[ebp+8], -609896264 ; dba5b8b8H
  055a2	8d 85 44 f8 ff
	ff		 lea	 eax, DWORD PTR __k$543352[ebp]
  055a8	c6 85 50 f8 ff
	ff 00		 mov	 BYTE PTR __k$543352[ebp+12], 0
  055af	59		 pop	 ecx
$LL16101@Load@4:
  055b0	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  055b6	83 c0 04	 add	 eax, 4
  055b9	49		 dec	 ecx
  055ba	75 f4		 jne	 SHORT $LL16101@Load@4
  055bc	56		 push	 esi
  055bd	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  055c3	50		 push	 eax
  055c4	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  055c9	8d 85 44 f8 ff
	ff		 lea	 eax, DWORD PTR __k$543352[ebp]
  055cf	50		 push	 eax
  055d0	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  055d6	ff d7		 call	 edi

; 1424 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_JOYBUTN1, szKeyText ) );

  055d8	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  055de	50		 push	 eax
  055df	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523470[ebp]
  055e5	50		 push	 eax
  055e6	8d 8d 8c e8 ff
	ff		 lea	 ecx, DWORD PTR $T523469[ebp]
  055ec	c7 85 cc f1 ff
	ff 0c 01 00 00	 mov	 DWORD PTR $T523470[ebp], 268 ; 0000010cH
  055f6	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  055fb	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  05601	50		 push	 eax
  05602	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523471[ebp]
  05608	50		 push	 eax
  05609	c6 45 fc 89	 mov	 BYTE PTR __$EHRec$[ebp+8], 137 ; 00000089H
  0560d	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  05612	8d 8d 90 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523469[ebp+4]
  05618	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0561c	ff d3		 call	 ebx
  0561e	6a 03		 push	 3

; 1425 : 
; 1426 : 	kLoader.LoadString_e( "KEY_JOYBUTN2", "", szKeyText, MAX_PATH );

  05620	c7 85 b4 f6 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$543487[ebp], -1246582362 ; b5b2a9a6H
  0562a	c7 85 b8 f6 ff
	ff a7 a3 b2 a8	 mov	 DWORD PTR __k$543487[ebp+4], -1464687705 ; a8b2a3a7H
  05634	c7 85 bc f6 ff
	ff b8 b8 a5 d8	 mov	 DWORD PTR __k$543487[ebp+8], -660227912 ; d8a5b8b8H
  0563e	8d 85 b4 f6 ff
	ff		 lea	 eax, DWORD PTR __k$543487[ebp]
  05644	c6 85 c0 f6 ff
	ff 00		 mov	 BYTE PTR __k$543487[ebp+12], 0
  0564b	59		 pop	 ecx
$LL16213@Load@4:
  0564c	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  05652	83 c0 04	 add	 eax, 4
  05655	49		 dec	 ecx
  05656	75 f4		 jne	 SHORT $LL16213@Load@4
  05658	56		 push	 esi
  05659	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0565f	50		 push	 eax
  05660	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  05665	8d 85 b4 f6 ff
	ff		 lea	 eax, DWORD PTR __k$543487[ebp]
  0566b	50		 push	 eax
  0566c	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  05672	ff d7		 call	 edi

; 1427 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_JOYBUTN2, szKeyText ) );

  05674	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0567a	50		 push	 eax
  0567b	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523473[ebp]
  05681	50		 push	 eax
  05682	8d 8d 64 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523472[ebp]
  05688	c7 85 cc f1 ff
	ff 0d 01 00 00	 mov	 DWORD PTR $T523473[ebp], 269 ; 0000010dH
  05692	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  05697	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  0569d	50		 push	 eax
  0569e	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523474[ebp]
  056a4	50		 push	 eax
  056a5	c6 45 fc 8a	 mov	 BYTE PTR __$EHRec$[ebp+8], 138 ; 0000008aH
  056a9	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  056ae	8d 8d 68 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523472[ebp+4]
  056b4	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  056b8	ff d3		 call	 ebx
  056ba	6a 03		 push	 3

; 1428 : 
; 1429 : 	kLoader.LoadString_e( "KEY_JOYBUTN3", "", szKeyText, MAX_PATH );

  056bc	c7 85 cc f7 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$543622[ebp], -1246582362 ; b5b2a9a6H
  056c6	c7 85 d0 f7 ff
	ff a7 a3 b2 a8	 mov	 DWORD PTR __k$543622[ebp+4], -1464687705 ; a8b2a3a7H
  056d0	c7 85 d4 f7 ff
	ff b8 b8 a5 d9	 mov	 DWORD PTR __k$543622[ebp+8], -643450696 ; d9a5b8b8H
  056da	8d 85 cc f7 ff
	ff		 lea	 eax, DWORD PTR __k$543622[ebp]
  056e0	c6 85 d8 f7 ff
	ff 00		 mov	 BYTE PTR __k$543622[ebp+12], 0
  056e7	59		 pop	 ecx
$LL16325@Load@4:
  056e8	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  056ee	83 c0 04	 add	 eax, 4
  056f1	49		 dec	 ecx
  056f2	75 f4		 jne	 SHORT $LL16325@Load@4
  056f4	56		 push	 esi
  056f5	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  056fb	50		 push	 eax
  056fc	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  05701	8d 85 cc f7 ff
	ff		 lea	 eax, DWORD PTR __k$543622[ebp]
  05707	50		 push	 eax
  05708	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0570e	ff d7		 call	 edi

; 1430 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_JOYBUTN3, szKeyText ) );

  05710	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05716	50		 push	 eax
  05717	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523476[ebp]
  0571d	50		 push	 eax
  0571e	8d 8d 3c e8 ff
	ff		 lea	 ecx, DWORD PTR $T523475[ebp]
  05724	c7 85 cc f1 ff
	ff 0e 01 00 00	 mov	 DWORD PTR $T523476[ebp], 270 ; 0000010eH
  0572e	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  05733	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  05739	50		 push	 eax
  0573a	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523477[ebp]
  05740	50		 push	 eax
  05741	c6 45 fc 8b	 mov	 BYTE PTR __$EHRec$[ebp+8], 139 ; 0000008bH
  05745	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  0574a	8d 8d 40 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523475[ebp+4]
  05750	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  05754	ff d3		 call	 ebx
  05756	6a 03		 push	 3

; 1431 : 
; 1432 : 	kLoader.LoadString_e( "KEY_JOYBUTN4", "", szKeyText, MAX_PATH );

  05758	c7 85 2c f7 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$543768[ebp], -1246582362 ; b5b2a9a6H
  05762	c7 85 30 f7 ff
	ff a7 a3 b2 a8	 mov	 DWORD PTR __k$543768[ebp+4], -1464687705 ; a8b2a3a7H
  0576c	c7 85 34 f7 ff
	ff b8 b8 a5 de	 mov	 DWORD PTR __k$543768[ebp+8], -559564616 ; dea5b8b8H
  05776	8d 85 2c f7 ff
	ff		 lea	 eax, DWORD PTR __k$543768[ebp]
  0577c	c6 85 38 f7 ff
	ff 00		 mov	 BYTE PTR __k$543768[ebp+12], 0
  05783	59		 pop	 ecx
$LL16437@Load@4:
  05784	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0578a	83 c0 04	 add	 eax, 4
  0578d	49		 dec	 ecx
  0578e	75 f4		 jne	 SHORT $LL16437@Load@4
  05790	56		 push	 esi
  05791	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05797	50		 push	 eax
  05798	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0579d	8d 85 2c f7 ff
	ff		 lea	 eax, DWORD PTR __k$543768[ebp]
  057a3	50		 push	 eax
  057a4	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  057aa	ff d7		 call	 edi

; 1433 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_JOYBUTN4, szKeyText ) );

  057ac	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  057b2	50		 push	 eax
  057b3	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523479[ebp]
  057b9	50		 push	 eax
  057ba	8d 8d 14 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523478[ebp]
  057c0	c7 85 cc f1 ff
	ff 0f 01 00 00	 mov	 DWORD PTR $T523479[ebp], 271 ; 0000010fH
  057ca	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  057cf	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  057d5	50		 push	 eax
  057d6	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523480[ebp]
  057dc	50		 push	 eax
  057dd	c6 45 fc 8c	 mov	 BYTE PTR __$EHRec$[ebp+8], 140 ; 0000008cH
  057e1	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  057e6	8d 8d 18 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523478[ebp+4]
  057ec	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  057f0	ff d3		 call	 ebx
  057f2	6a 03		 push	 3

; 1434 : 
; 1435 : 	kLoader.LoadString_e( "KEY_JOYBUTN5", "", szKeyText, MAX_PATH );

  057f4	c7 85 a4 f7 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$543905[ebp], -1246582362 ; b5b2a9a6H
  057fe	c7 85 a8 f7 ff
	ff a7 a3 b2 a8	 mov	 DWORD PTR __k$543905[ebp+4], -1464687705 ; a8b2a3a7H
  05808	c7 85 ac f7 ff
	ff b8 b8 a5 df	 mov	 DWORD PTR __k$543905[ebp+8], -542787400 ; dfa5b8b8H
  05812	8d 85 a4 f7 ff
	ff		 lea	 eax, DWORD PTR __k$543905[ebp]
  05818	c6 85 b0 f7 ff
	ff 00		 mov	 BYTE PTR __k$543905[ebp+12], 0
  0581f	59		 pop	 ecx
$LL16549@Load@4:
  05820	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  05826	83 c0 04	 add	 eax, 4
  05829	49		 dec	 ecx
  0582a	75 f4		 jne	 SHORT $LL16549@Load@4
  0582c	56		 push	 esi
  0582d	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05833	50		 push	 eax
  05834	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  05839	8d 85 a4 f7 ff
	ff		 lea	 eax, DWORD PTR __k$543905[ebp]
  0583f	50		 push	 eax
  05840	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  05846	ff d7		 call	 edi

; 1436 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_JOYBUTN5, szKeyText ) );

  05848	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0584e	50		 push	 eax
  0584f	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523482[ebp]
  05855	50		 push	 eax
  05856	8d 8d ec e7 ff
	ff		 lea	 ecx, DWORD PTR $T523481[ebp]
  0585c	c7 85 cc f1 ff
	ff 10 01 00 00	 mov	 DWORD PTR $T523482[ebp], 272 ; 00000110H
  05866	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  0586b	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  05871	50		 push	 eax
  05872	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523483[ebp]
  05878	50		 push	 eax
  05879	c6 45 fc 8d	 mov	 BYTE PTR __$EHRec$[ebp+8], 141 ; 0000008dH
  0587d	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  05882	8d 8d f0 e7 ff
	ff		 lea	 ecx, DWORD PTR $T523481[ebp+4]
  05888	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0588c	ff d3		 call	 ebx
  0588e	6a 03		 push	 3

; 1437 : 
; 1438 : 	kLoader.LoadString_e( "KEY_JOYBUTN6", "", szKeyText, MAX_PATH );

  05890	c7 85 dc f6 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$544040[ebp], -1246582362 ; b5b2a9a6H
  0589a	c7 85 e0 f6 ff
	ff a7 a3 b2 a8	 mov	 DWORD PTR __k$544040[ebp+4], -1464687705 ; a8b2a3a7H
  058a4	c7 85 e4 f6 ff
	ff b8 b8 a5 dc	 mov	 DWORD PTR __k$544040[ebp+8], -593119048 ; dca5b8b8H
  058ae	8d 85 dc f6 ff
	ff		 lea	 eax, DWORD PTR __k$544040[ebp]
  058b4	c6 85 e8 f6 ff
	ff 00		 mov	 BYTE PTR __k$544040[ebp+12], 0
  058bb	59		 pop	 ecx
$LL16661@Load@4:
  058bc	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  058c2	83 c0 04	 add	 eax, 4
  058c5	49		 dec	 ecx
  058c6	75 f4		 jne	 SHORT $LL16661@Load@4
  058c8	56		 push	 esi
  058c9	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  058cf	50		 push	 eax
  058d0	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  058d5	8d 85 dc f6 ff
	ff		 lea	 eax, DWORD PTR __k$544040[ebp]
  058db	50		 push	 eax
  058dc	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  058e2	ff d7		 call	 edi

; 1439 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_JOYBUTN6, szKeyText ) );

  058e4	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  058ea	50		 push	 eax
  058eb	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523485[ebp]
  058f1	50		 push	 eax
  058f2	8d 8d c4 e7 ff
	ff		 lea	 ecx, DWORD PTR $T523484[ebp]
  058f8	c7 85 cc f1 ff
	ff 11 01 00 00	 mov	 DWORD PTR $T523485[ebp], 273 ; 00000111H
  05902	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  05907	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  0590d	50		 push	 eax
  0590e	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523486[ebp]
  05914	50		 push	 eax
  05915	c6 45 fc 8e	 mov	 BYTE PTR __$EHRec$[ebp+8], 142 ; 0000008eH
  05919	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  0591e	8d 8d c8 e7 ff
	ff		 lea	 ecx, DWORD PTR $T523484[ebp+4]
  05924	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  05928	ff d3		 call	 ebx
  0592a	6a 03		 push	 3

; 1440 : 
; 1441 : 	kLoader.LoadString_e( "KEY_JOYBUTN7", "", szKeyText, MAX_PATH );

  0592c	c7 85 7c f7 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$544175[ebp], -1246582362 ; b5b2a9a6H
  05936	c7 85 80 f7 ff
	ff a7 a3 b2 a8	 mov	 DWORD PTR __k$544175[ebp+4], -1464687705 ; a8b2a3a7H
  05940	c7 85 84 f7 ff
	ff b8 b8 a5 dd	 mov	 DWORD PTR __k$544175[ebp+8], -576341832 ; dda5b8b8H
  0594a	8d 85 7c f7 ff
	ff		 lea	 eax, DWORD PTR __k$544175[ebp]
  05950	c6 85 88 f7 ff
	ff 00		 mov	 BYTE PTR __k$544175[ebp+12], 0
  05957	59		 pop	 ecx
$LL16773@Load@4:
  05958	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0595e	83 c0 04	 add	 eax, 4
  05961	49		 dec	 ecx
  05962	75 f4		 jne	 SHORT $LL16773@Load@4
  05964	56		 push	 esi
  05965	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  0596b	50		 push	 eax
  0596c	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  05971	8d 85 7c f7 ff
	ff		 lea	 eax, DWORD PTR __k$544175[ebp]
  05977	50		 push	 eax
  05978	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0597e	ff d7		 call	 edi

; 1442 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_JOYBUTN7, szKeyText ) );

  05980	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05986	50		 push	 eax
  05987	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523488[ebp]
  0598d	50		 push	 eax
  0598e	8d 8d 9c e7 ff
	ff		 lea	 ecx, DWORD PTR $T523487[ebp]
  05994	c7 85 cc f1 ff
	ff 12 01 00 00	 mov	 DWORD PTR $T523488[ebp], 274 ; 00000112H
  0599e	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  059a3	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  059a9	50		 push	 eax
  059aa	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523489[ebp]
  059b0	50		 push	 eax
  059b1	c6 45 fc 8f	 mov	 BYTE PTR __$EHRec$[ebp+8], 143 ; 0000008fH
  059b5	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  059ba	8d 8d a0 e7 ff
	ff		 lea	 ecx, DWORD PTR $T523487[ebp+4]
  059c0	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  059c4	ff d3		 call	 ebx
  059c6	6a 03		 push	 3

; 1443 : 
; 1444 : 	kLoader.LoadString_e( "KEY_JOYBUTN8", "", szKeyText, MAX_PATH );

  059c8	c7 85 04 f7 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$544297[ebp], -1246582362 ; b5b2a9a6H
  059d2	c7 85 08 f7 ff
	ff a7 a3 b2 a8	 mov	 DWORD PTR __k$544297[ebp+4], -1464687705 ; a8b2a3a7H
  059dc	c7 85 0c f7 ff
	ff b8 b8 a5 d2	 mov	 DWORD PTR __k$544297[ebp+8], -760891208 ; d2a5b8b8H
  059e6	8d 85 04 f7 ff
	ff		 lea	 eax, DWORD PTR __k$544297[ebp]
  059ec	c6 85 10 f7 ff
	ff 00		 mov	 BYTE PTR __k$544297[ebp+12], 0
  059f3	59		 pop	 ecx
$LL16885@Load@4:
  059f4	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  059fa	83 c0 04	 add	 eax, 4
  059fd	49		 dec	 ecx
  059fe	75 f4		 jne	 SHORT $LL16885@Load@4
  05a00	56		 push	 esi
  05a01	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05a07	50		 push	 eax
  05a08	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  05a0d	8d 85 04 f7 ff
	ff		 lea	 eax, DWORD PTR __k$544297[ebp]
  05a13	50		 push	 eax
  05a14	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  05a1a	ff d7		 call	 edi

; 1445 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_JOYBUTN8, szKeyText ) );

  05a1c	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05a22	50		 push	 eax
  05a23	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523491[ebp]
  05a29	50		 push	 eax
  05a2a	8d 8d 74 e7 ff
	ff		 lea	 ecx, DWORD PTR $T523490[ebp]
  05a30	c7 85 cc f1 ff
	ff 13 01 00 00	 mov	 DWORD PTR $T523491[ebp], 275 ; 00000113H
  05a3a	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  05a3f	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  05a45	50		 push	 eax
  05a46	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523492[ebp]
  05a4c	50		 push	 eax
  05a4d	c6 45 fc 90	 mov	 BYTE PTR __$EHRec$[ebp+8], 144 ; 00000090H
  05a51	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  05a56	8d 8d 78 e7 ff
	ff		 lea	 ecx, DWORD PTR $T523490[ebp+4]
  05a5c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  05a60	ff d3		 call	 ebx
  05a62	6a 03		 push	 3

; 1446 : 
; 1447 : 	kLoader.LoadString_e( "KEY_JOYBUTN9", "", szKeyText, MAX_PATH );

  05a64	c7 85 30 f8 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$544432[ebp], -1246582362 ; b5b2a9a6H
  05a6e	c7 85 34 f8 ff
	ff a7 a3 b2 a8	 mov	 DWORD PTR __k$544432[ebp+4], -1464687705 ; a8b2a3a7H
  05a78	c7 85 38 f8 ff
	ff b8 b8 a5 d3	 mov	 DWORD PTR __k$544432[ebp+8], -744113992 ; d3a5b8b8H
  05a82	8d 85 30 f8 ff
	ff		 lea	 eax, DWORD PTR __k$544432[ebp]
  05a88	c6 85 3c f8 ff
	ff 00		 mov	 BYTE PTR __k$544432[ebp+12], 0
  05a8f	59		 pop	 ecx
$LL16997@Load@4:
  05a90	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  05a96	83 c0 04	 add	 eax, 4
  05a99	49		 dec	 ecx
  05a9a	75 f4		 jne	 SHORT $LL16997@Load@4
  05a9c	56		 push	 esi
  05a9d	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05aa3	50		 push	 eax
  05aa4	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  05aa9	8d 85 30 f8 ff
	ff		 lea	 eax, DWORD PTR __k$544432[ebp]
  05aaf	50		 push	 eax
  05ab0	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  05ab6	ff d7		 call	 edi

; 1448 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_JOYBUTN9, szKeyText ) );

  05ab8	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05abe	50		 push	 eax
  05abf	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523494[ebp]
  05ac5	50		 push	 eax
  05ac6	8d 8d 4c e7 ff
	ff		 lea	 ecx, DWORD PTR $T523493[ebp]
  05acc	c7 85 cc f1 ff
	ff 14 01 00 00	 mov	 DWORD PTR $T523494[ebp], 276 ; 00000114H
  05ad6	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  05adb	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  05ae1	50		 push	 eax
  05ae2	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523495[ebp]
  05ae8	50		 push	 eax
  05ae9	c6 45 fc 91	 mov	 BYTE PTR __$EHRec$[ebp+8], 145 ; 00000091H
  05aed	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  05af2	8d 8d 50 e7 ff
	ff		 lea	 ecx, DWORD PTR $T523493[ebp+4]
  05af8	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  05afc	ff d3		 call	 ebx
  05afe	6a 03		 push	 3

; 1449 : 
; 1450 : 	kLoader.LoadString_e( "KEY_JOYBUTN10", "", szKeyText, MAX_PATH );

  05b00	c7 85 24 fc ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$544567[ebp], -1246582362 ; b5b2a9a6H
  05b0a	c7 85 28 fc ff
	ff a7 a3 b2 a8	 mov	 DWORD PTR __k$544567[ebp+4], -1464687705 ; a8b2a3a7H
  05b14	c7 85 2c fc ff
	ff b8 b8 a5 db	 mov	 DWORD PTR __k$544567[ebp+8], -609896264 ; dba5b8b8H
  05b1e	8d 85 24 fc ff
	ff		 lea	 eax, DWORD PTR __k$544567[ebp]
  05b24	66 c7 85 30 fc
	ff ff dd 00	 mov	 WORD PTR __k$544567[ebp+12], 221 ; 000000ddH
  05b2d	59		 pop	 ecx
$LL17109@Load@4:
  05b2e	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  05b34	83 c0 04	 add	 eax, 4
  05b37	49		 dec	 ecx
  05b38	75 f4		 jne	 SHORT $LL17109@Load@4
  05b3a	80 b5 30 fc ff
	ff ed		 xor	 BYTE PTR __k$544567[ebp+12], -19 ; ffffffedH
  05b41	56		 push	 esi
  05b42	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05b48	50		 push	 eax
  05b49	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  05b4e	8d 85 24 fc ff
	ff		 lea	 eax, DWORD PTR __k$544567[ebp]
  05b54	50		 push	 eax
  05b55	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  05b5b	ff d7		 call	 edi

; 1451 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_JOYBUTN10, szKeyText ) );

  05b5d	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05b63	50		 push	 eax
  05b64	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523497[ebp]
  05b6a	50		 push	 eax
  05b6b	8d 8d 24 e7 ff
	ff		 lea	 ecx, DWORD PTR $T523496[ebp]
  05b71	c7 85 cc f1 ff
	ff 15 01 00 00	 mov	 DWORD PTR $T523497[ebp], 277 ; 00000115H
  05b7b	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  05b80	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  05b86	50		 push	 eax
  05b87	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523498[ebp]
  05b8d	50		 push	 eax
  05b8e	c6 45 fc 92	 mov	 BYTE PTR __$EHRec$[ebp+8], 146 ; 00000092H
  05b92	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  05b97	8d 8d 28 e7 ff
	ff		 lea	 ecx, DWORD PTR $T523496[ebp+4]
  05b9d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  05ba1	ff d3		 call	 ebx
  05ba3	6a 03		 push	 3

; 1452 : 
; 1453 : 	kLoader.LoadString_e( "KEY_JOYBUTN11", "", szKeyText, MAX_PATH );

  05ba5	c7 85 00 fc ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$544702[ebp], -1246582362 ; b5b2a9a6H
  05baf	c7 85 04 fc ff
	ff a7 a3 b2 a8	 mov	 DWORD PTR __k$544702[ebp+4], -1464687705 ; a8b2a3a7H
  05bb9	c7 85 08 fc ff
	ff b8 b8 a5 db	 mov	 DWORD PTR __k$544702[ebp+8], -609896264 ; dba5b8b8H
  05bc3	8d 85 00 fc ff
	ff		 lea	 eax, DWORD PTR __k$544702[ebp]
  05bc9	66 c7 85 0c fc
	ff ff dc 00	 mov	 WORD PTR __k$544702[ebp+12], 220 ; 000000dcH
  05bd2	59		 pop	 ecx
$LL17221@Load@4:
  05bd3	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  05bd9	83 c0 04	 add	 eax, 4
  05bdc	49		 dec	 ecx
  05bdd	75 f4		 jne	 SHORT $LL17221@Load@4
  05bdf	80 b5 0c fc ff
	ff ed		 xor	 BYTE PTR __k$544702[ebp+12], -19 ; ffffffedH
  05be6	56		 push	 esi
  05be7	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05bed	50		 push	 eax
  05bee	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  05bf3	8d 85 00 fc ff
	ff		 lea	 eax, DWORD PTR __k$544702[ebp]
  05bf9	50		 push	 eax
  05bfa	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  05c00	ff d7		 call	 edi

; 1454 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_JOYBUTN11, szKeyText ) );

  05c02	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05c08	50		 push	 eax
  05c09	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523500[ebp]
  05c0f	50		 push	 eax
  05c10	8d 8d fc e6 ff
	ff		 lea	 ecx, DWORD PTR $T523499[ebp]
  05c16	c7 85 cc f1 ff
	ff 16 01 00 00	 mov	 DWORD PTR $T523500[ebp], 278 ; 00000116H
  05c20	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  05c25	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  05c2b	50		 push	 eax
  05c2c	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523501[ebp]
  05c32	50		 push	 eax
  05c33	c6 45 fc 93	 mov	 BYTE PTR __$EHRec$[ebp+8], 147 ; 00000093H
  05c37	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  05c3c	8d 8d 00 e7 ff
	ff		 lea	 ecx, DWORD PTR $T523499[ebp+4]
  05c42	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  05c46	ff d3		 call	 ebx
  05c48	6a 03		 push	 3

; 1455 : 
; 1456 : 	kLoader.LoadString_e( "KEY_JOYBUTN12", "", szKeyText, MAX_PATH );

  05c4a	c7 85 dc fb ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$544850[ebp], -1246582362 ; b5b2a9a6H
  05c54	c7 85 e0 fb ff
	ff a7 a3 b2 a8	 mov	 DWORD PTR __k$544850[ebp+4], -1464687705 ; a8b2a3a7H
  05c5e	c7 85 e4 fb ff
	ff b8 b8 a5 db	 mov	 DWORD PTR __k$544850[ebp+8], -609896264 ; dba5b8b8H
  05c68	8d 85 dc fb ff
	ff		 lea	 eax, DWORD PTR __k$544850[ebp]
  05c6e	66 c7 85 e8 fb
	ff ff df 00	 mov	 WORD PTR __k$544850[ebp+12], 223 ; 000000dfH
  05c77	59		 pop	 ecx
$LL17333@Load@4:
  05c78	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  05c7e	83 c0 04	 add	 eax, 4
  05c81	49		 dec	 ecx
  05c82	75 f4		 jne	 SHORT $LL17333@Load@4
  05c84	80 b5 e8 fb ff
	ff ed		 xor	 BYTE PTR __k$544850[ebp+12], -19 ; ffffffedH
  05c8b	56		 push	 esi
  05c8c	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05c92	50		 push	 eax
  05c93	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  05c98	8d 85 dc fb ff
	ff		 lea	 eax, DWORD PTR __k$544850[ebp]
  05c9e	50		 push	 eax
  05c9f	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  05ca5	ff d7		 call	 edi

; 1457 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_JOYBUTN12, szKeyText ) );

  05ca7	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05cad	50		 push	 eax
  05cae	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523503[ebp]
  05cb4	50		 push	 eax
  05cb5	8d 8d d4 e6 ff
	ff		 lea	 ecx, DWORD PTR $T523502[ebp]
  05cbb	c7 85 cc f1 ff
	ff 17 01 00 00	 mov	 DWORD PTR $T523503[ebp], 279 ; 00000117H
  05cc5	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  05cca	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  05cd0	50		 push	 eax
  05cd1	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523504[ebp]
  05cd7	50		 push	 eax
  05cd8	c6 45 fc 94	 mov	 BYTE PTR __$EHRec$[ebp+8], 148 ; 00000094H
  05cdc	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  05ce1	8d 8d d8 e6 ff
	ff		 lea	 ecx, DWORD PTR $T523502[ebp+4]
  05ce7	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  05ceb	ff d3		 call	 ebx
  05ced	6a 02		 push	 2

; 1458 : 
; 1459 : 	kLoader.LoadString_e( "KEY_POVLEFT", "", szKeyText, MAX_PATH );

  05cef	c7 85 f8 fd ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$544972[ebp], -1246582362 ; b5b2a9a6H
  05cf9	c7 85 fc fd ff
	ff bd a3 bd a6	 mov	 DWORD PTR __k$544972[ebp+4], -1497521219 ; a6bda3bdH
  05d03	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR __k$544972[ebp]
  05d09	c7 85 00 fe ff
	ff a8 aa bf 00	 mov	 DWORD PTR __k$544972[ebp+8], 12561064 ; 00bfaaa8H
  05d13	59		 pop	 ecx
$LL17445@Load@4:
  05d14	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  05d1a	83 c0 04	 add	 eax, 4
  05d1d	49		 dec	 ecx
  05d1e	75 f4		 jne	 SHORT $LL17445@Load@4
  05d20	6a 08		 push	 8
  05d22	58		 pop	 eax
$LL17442@Load@4:
  05d23	8b c8		 mov	 ecx, eax
  05d25	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  05d2b	79 05		 jns	 SHORT $LN18459@Load@4
  05d2d	49		 dec	 ecx
  05d2e	83 c9 fc	 or	 ecx, -4			; fffffffcH
  05d31	41		 inc	 ecx
$LN18459@Load@4:
  05d32	b2 ed		 mov	 dl, -19			; ffffffedH
  05d34	2a d1		 sub	 dl, cl
  05d36	30 94 05 f8 fd
	ff ff		 xor	 BYTE PTR __k$544972[ebp+eax], dl
  05d3d	40		 inc	 eax
  05d3e	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  05d41	7c e0		 jl	 SHORT $LL17442@Load@4
  05d43	56		 push	 esi
  05d44	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05d4a	50		 push	 eax
  05d4b	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  05d50	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR __k$544972[ebp]
  05d56	50		 push	 eax
  05d57	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  05d5d	ff d7		 call	 edi

; 1460 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_POVLEFT, szKeyText ) );

  05d5f	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05d65	50		 push	 eax
  05d66	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523506[ebp]
  05d6c	50		 push	 eax
  05d6d	8d 8d ac e6 ff
	ff		 lea	 ecx, DWORD PTR $T523505[ebp]
  05d73	c7 85 cc f1 ff
	ff 18 01 00 00	 mov	 DWORD PTR $T523506[ebp], 280 ; 00000118H
  05d7d	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  05d82	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  05d88	50		 push	 eax
  05d89	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523507[ebp]
  05d8f	50		 push	 eax
  05d90	c6 45 fc 95	 mov	 BYTE PTR __$EHRec$[ebp+8], 149 ; 00000095H
  05d94	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  05d99	8d 8d b0 e6 ff
	ff		 lea	 ecx, DWORD PTR $T523505[ebp+4]
  05d9f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  05da3	ff d3		 call	 ebx
  05da5	6a 03		 push	 3

; 1461 : 
; 1462 : 	kLoader.LoadString_e( "KEY_POVRIGHT", "", szKeyText, MAX_PATH );

  05da7	c7 85 08 f8 ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$545120[ebp], -1246582362 ; b5b2a9a6H
  05db1	c7 85 0c f8 ff
	ff bd a3 bd b8	 mov	 DWORD PTR __k$545120[ebp+4], -1195531331 ; b8bda3bdH
  05dbb	c7 85 10 f8 ff
	ff a4 ab a3 be	 mov	 DWORD PTR __k$545120[ebp+8], -1096569948 ; bea3aba4H
  05dc5	8d 85 08 f8 ff
	ff		 lea	 eax, DWORD PTR __k$545120[ebp]
  05dcb	c6 85 14 f8 ff
	ff 00		 mov	 BYTE PTR __k$545120[ebp+12], 0
  05dd2	59		 pop	 ecx
$LL17557@Load@4:
  05dd3	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  05dd9	83 c0 04	 add	 eax, 4
  05ddc	49		 dec	 ecx
  05ddd	75 f4		 jne	 SHORT $LL17557@Load@4
  05ddf	56		 push	 esi
  05de0	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05de6	50		 push	 eax
  05de7	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  05dec	8d 85 08 f8 ff
	ff		 lea	 eax, DWORD PTR __k$545120[ebp]
  05df2	50		 push	 eax
  05df3	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  05df9	ff d7		 call	 edi

; 1463 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_POVRIGHT, szKeyText ) );

  05dfb	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05e01	50		 push	 eax
  05e02	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523509[ebp]
  05e08	50		 push	 eax
  05e09	8d 8d 84 e6 ff
	ff		 lea	 ecx, DWORD PTR $T523508[ebp]
  05e0f	c7 85 cc f1 ff
	ff 19 01 00 00	 mov	 DWORD PTR $T523509[ebp], 281 ; 00000119H
  05e19	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  05e1e	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  05e24	50		 push	 eax
  05e25	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523510[ebp]
  05e2b	50		 push	 eax
  05e2c	c6 45 fc 96	 mov	 BYTE PTR __$EHRec$[ebp+8], 150 ; 00000096H
  05e30	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  05e35	8d 8d 88 e6 ff
	ff		 lea	 ecx, DWORD PTR $T523508[ebp+4]
  05e3b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  05e3f	ff d3		 call	 ebx
  05e41	6a 02		 push	 2

; 1464 : 
; 1465 : 	kLoader.LoadString_e( "KEY_POVUP", "", szKeyText, MAX_PATH );

  05e43	c7 85 d0 fa ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$545255[ebp], -1246582362 ; b5b2a9a6H
  05e4d	c7 85 d4 fa ff
	ff bd a3 bd bf	 mov	 DWORD PTR __k$545255[ebp+4], -1078090819 ; bfbda3bdH
  05e57	8d 85 d0 fa ff
	ff		 lea	 eax, DWORD PTR __k$545255[ebp]
  05e5d	66 c7 85 d8 fa
	ff ff bd 00	 mov	 WORD PTR __k$545255[ebp+8], 189 ; 000000bdH
  05e66	59		 pop	 ecx
$LL17669@Load@4:
  05e67	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  05e6d	83 c0 04	 add	 eax, 4
  05e70	49		 dec	 ecx
  05e71	75 f4		 jne	 SHORT $LL17669@Load@4
  05e73	80 b5 d8 fa ff
	ff ed		 xor	 BYTE PTR __k$545255[ebp+8], -19 ; ffffffedH
  05e7a	56		 push	 esi
  05e7b	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05e81	50		 push	 eax
  05e82	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  05e87	8d 85 d0 fa ff
	ff		 lea	 eax, DWORD PTR __k$545255[ebp]
  05e8d	50		 push	 eax
  05e8e	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  05e94	ff d7		 call	 edi

; 1466 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_POVUP, szKeyText ) );

  05e96	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05e9c	50		 push	 eax
  05e9d	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523512[ebp]
  05ea3	50		 push	 eax
  05ea4	8d 8d 5c e6 ff
	ff		 lea	 ecx, DWORD PTR $T523511[ebp]
  05eaa	c7 85 cc f1 ff
	ff 1a 01 00 00	 mov	 DWORD PTR $T523512[ebp], 282 ; 0000011aH
  05eb4	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  05eb9	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  05ebf	50		 push	 eax
  05ec0	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523513[ebp]
  05ec6	50		 push	 eax
  05ec7	c6 45 fc 97	 mov	 BYTE PTR __$EHRec$[ebp+8], 151 ; 00000097H
  05ecb	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  05ed0	8d 8d 60 e6 ff
	ff		 lea	 ecx, DWORD PTR $T523511[ebp+4]
  05ed6	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  05eda	ff d3		 call	 ebx
  05edc	6a 02		 push	 2

; 1467 : 
; 1468 : 	kLoader.LoadString_e( "KEY_POVDOWN", "", szKeyText, MAX_PATH );

  05ede	c7 85 d4 fd ff
	ff a6 a9 b2 b5	 mov	 DWORD PTR __k$545377[ebp], -1246582362 ; b5b2a9a6H
  05ee8	c7 85 d8 fd ff
	ff bd a3 bd ae	 mov	 DWORD PTR __k$545377[ebp+4], -1363303491 ; aebda3bdH
  05ef2	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR __k$545377[ebp]
  05ef8	c7 85 dc fd ff
	ff a2 bb a5 00	 mov	 DWORD PTR __k$545377[ebp+8], 10861474 ; 00a5bba2H
  05f02	59		 pop	 ecx
$LL17781@Load@4:
  05f03	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  05f09	83 c0 04	 add	 eax, 4
  05f0c	49		 dec	 ecx
  05f0d	75 f4		 jne	 SHORT $LL17781@Load@4
  05f0f	6a 08		 push	 8
  05f11	58		 pop	 eax
$LL17778@Load@4:
  05f12	8b c8		 mov	 ecx, eax
  05f14	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  05f1a	79 05		 jns	 SHORT $LN18460@Load@4
  05f1c	49		 dec	 ecx
  05f1d	83 c9 fc	 or	 ecx, -4			; fffffffcH
  05f20	41		 inc	 ecx
$LN18460@Load@4:
  05f21	b2 ed		 mov	 dl, -19			; ffffffedH
  05f23	2a d1		 sub	 dl, cl
  05f25	30 94 05 d4 fd
	ff ff		 xor	 BYTE PTR __k$545377[ebp+eax], dl
  05f2c	40		 inc	 eax
  05f2d	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  05f30	7c e0		 jl	 SHORT $LL17778@Load@4
  05f32	56		 push	 esi
  05f33	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05f39	50		 push	 eax
  05f3a	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  05f3f	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR __k$545377[ebp]
  05f45	50		 push	 eax
  05f46	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  05f4c	ff d7		 call	 edi

; 1469 : 	m_KeyTextMap.insert( KeyTextMap::value_type( KEY_POVDOWN, szKeyText ) );

  05f4e	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szKeyText$[ebp]
  05f54	50		 push	 eax
  05f55	8d 85 cc f1 ff
	ff		 lea	 eax, DWORD PTR $T523515[ebp]
  05f5b	50		 push	 eax
  05f5c	8d 8d 34 e6 ff
	ff		 lea	 ecx, DWORD PTR $T523514[ebp]
  05f62	c7 85 cc f1 ff
	ff 1b 01 00 00	 mov	 DWORD PTR $T523515[ebp], 283 ; 0000011bH
  05f6c	e8 00 00 00 00	 call	 ??$?0W4<unnamed-tag>@@AAY0BAE@D@?$pair@$$CBGVioHashString@@@std@@QAE@$$QAW4<unnamed-tag>@@AAY0BAE@D@Z ; std::pair<unsigned short const ,ioHashString>::pair<unsigned short const ,ioHashString><enum <unnamed-tag>,char (&)[260]>
  05f71	8b 8d c4 f1 ff
	ff		 mov	 ecx, DWORD PTR tv115978[ebp]
  05f77	50		 push	 eax
  05f78	8d 85 c8 f1 ff
	ff		 lea	 eax, DWORD PTR $T523516[ebp]
  05f7e	50		 push	 eax
  05f7f	c6 45 fc 98	 mov	 BYTE PTR __$EHRec$[ebp+8], 152 ; 00000098H
  05f83	e8 00 00 00 00	 call	 ??$insert@U?$pair@$$CBGVioHashString@@@std@@@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBGVioHashString@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::insert<std::pair<unsigned short const ,ioHashString> >
  05f88	8d 8d 38 e6 ff
	ff		 lea	 ecx, DWORD PTR $T523514[ebp+4]
  05f8e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  05f92	ff d3		 call	 ebx

; 1470 : 
; 1471 : 	/*	KeyTextMap::iterator iCreate;
; 1472 : 	for( iCreate = m_KeyTextMap.begin() ; iCreate != m_KeyTextMap.end() ; ++iCreate )
; 1473 : 	{
; 1474 : 	LOG.PrintTimeAndLog( 0, "%s : %d", iCreate->second.c_str(), iCreate->first );
; 1475 : 	}
; 1476 : 	*/
; 1477 : }

  05f94	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  05f98	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  05f9e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioINILoader@@QAE@XZ
  05fa4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  05fa7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  05fae	59		 pop	 ecx
  05faf	5f		 pop	 edi
  05fb0	5e		 pop	 esi
  05fb1	5b		 pop	 ebx
  05fb2	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  05fb5	33 cd		 xor	 ecx, ebp
  05fb7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  05fbc	c9		 leave
  05fbd	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$0:
  00000	8d 8d d0 f1 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1ioINILoader_e@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$1:
  0000b	8d 8d 70 f0 ff
	ff		 lea	 ecx, DWORD PTR $T523061[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$2:
  00016	8d 8d bc ef ff
	ff		 lea	 ecx, DWORD PTR $T523064[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$3:
  00021	8d 8d 88 f1 ff
	ff		 lea	 ecx, DWORD PTR $T523067[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$4:
  0002c	8d 8d e4 ef ff
	ff		 lea	 ecx, DWORD PTR $T523070[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$5:
  00037	8d 8d 98 f0 ff
	ff		 lea	 ecx, DWORD PTR $T523073[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$6:
  00042	8d 8d 60 f1 ff
	ff		 lea	 ecx, DWORD PTR $T523076[ebp]
  00048	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$7:
  0004d	8d 8d 20 f0 ff
	ff		 lea	 ecx, DWORD PTR $T523079[ebp]
  00053	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$8:
  00058	8d 8d 38 f1 ff
	ff		 lea	 ecx, DWORD PTR $T523082[ebp]
  0005e	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$9:
  00063	8d 8d b0 f1 ff
	ff		 lea	 ecx, DWORD PTR $T523085[ebp]
  00069	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$10:
  0006e	8d 8d 10 f1 ff
	ff		 lea	 ecx, DWORD PTR $T523088[ebp]
  00074	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$11:
  00079	8d 8d d0 ef ff
	ff		 lea	 ecx, DWORD PTR $T523091[ebp]
  0007f	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$12:
  00084	8d 8d e8 f0 ff
	ff		 lea	 ecx, DWORD PTR $T523094[ebp]
  0008a	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$13:
  0008f	8d 8d 48 f0 ff
	ff		 lea	 ecx, DWORD PTR $T523097[ebp]
  00095	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$14:
  0009a	8d 8d c0 f0 ff
	ff		 lea	 ecx, DWORD PTR $T523100[ebp]
  000a0	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$15:
  000a5	8d 8d f8 ef ff
	ff		 lea	 ecx, DWORD PTR $T523103[ebp]
  000ab	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$16:
  000b0	8d 8d 9c f1 ff
	ff		 lea	 ecx, DWORD PTR $T523106[ebp]
  000b6	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$17:
  000bb	8d 8d 74 f1 ff
	ff		 lea	 ecx, DWORD PTR $T523109[ebp]
  000c1	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$18:
  000c6	8d 8d 4c f1 ff
	ff		 lea	 ecx, DWORD PTR $T523112[ebp]
  000cc	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$19:
  000d1	8d 8d 24 f1 ff
	ff		 lea	 ecx, DWORD PTR $T523115[ebp]
  000d7	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$20:
  000dc	8d 8d fc f0 ff
	ff		 lea	 ecx, DWORD PTR $T523118[ebp]
  000e2	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$21:
  000e7	8d 8d d4 f0 ff
	ff		 lea	 ecx, DWORD PTR $T523121[ebp]
  000ed	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$22:
  000f2	8d 8d ac f0 ff
	ff		 lea	 ecx, DWORD PTR $T523124[ebp]
  000f8	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$23:
  000fd	8d 8d 84 f0 ff
	ff		 lea	 ecx, DWORD PTR $T523127[ebp]
  00103	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$24:
  00108	8d 8d 5c f0 ff
	ff		 lea	 ecx, DWORD PTR $T523130[ebp]
  0010e	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$25:
  00113	8d 8d 34 f0 ff
	ff		 lea	 ecx, DWORD PTR $T523133[ebp]
  00119	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$26:
  0011e	8d 8d 0c f0 ff
	ff		 lea	 ecx, DWORD PTR $T523136[ebp]
  00124	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$27:
  00129	8d 8d c8 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523139[ebp]
  0012f	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$28:
  00134	8d 8d 0c e6 ff
	ff		 lea	 ecx, DWORD PTR $T523142[ebp]
  0013a	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$29:
  0013f	8d 8d e4 e5 ff
	ff		 lea	 ecx, DWORD PTR $T523145[ebp]
  00145	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$30:
  0014a	8d 8d 80 ef ff
	ff		 lea	 ecx, DWORD PTR $T523148[ebp]
  00150	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$31:
  00155	8d 8d a8 ea ff
	ff		 lea	 ecx, DWORD PTR $T523151[ebp]
  0015b	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$32:
  00160	8d 8d 58 ef ff
	ff		 lea	 ecx, DWORD PTR $T523154[ebp]
  00166	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$33:
  0016b	8d 8d 10 e7 ff
	ff		 lea	 ecx, DWORD PTR $T523157[ebp]
  00171	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$34:
  00176	8d 8d 30 ef ff
	ff		 lea	 ecx, DWORD PTR $T523160[ebp]
  0017c	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$35:
  00181	8d 8d 80 ea ff
	ff		 lea	 ecx, DWORD PTR $T523163[ebp]
  00187	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$36:
  0018c	8d 8d 08 ef ff
	ff		 lea	 ecx, DWORD PTR $T523166[ebp]
  00192	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$37:
  00197	8d 8d 28 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523169[ebp]
  0019d	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$38:
  001a2	8d 8d e0 ee ff
	ff		 lea	 ecx, DWORD PTR $T523172[ebp]
  001a8	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$39:
  001ad	8d 8d 58 ea ff
	ff		 lea	 ecx, DWORD PTR $T523175[ebp]
  001b3	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$40:
  001b8	8d 8d b8 ee ff
	ff		 lea	 ecx, DWORD PTR $T523178[ebp]
  001be	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$41:
  001c3	8d 8d 70 e6 ff
	ff		 lea	 ecx, DWORD PTR $T523181[ebp]
  001c9	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$42:
  001ce	8d 8d 90 ee ff
	ff		 lea	 ecx, DWORD PTR $T523184[ebp]
  001d4	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$43:
  001d9	8d 8d 30 ea ff
	ff		 lea	 ecx, DWORD PTR $T523187[ebp]
  001df	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$44:
  001e4	8d 8d 68 ee ff
	ff		 lea	 ecx, DWORD PTR $T523190[ebp]
  001ea	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$45:
  001ef	8d 8d 00 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523193[ebp]
  001f5	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$46:
  001fa	8d 8d 40 ee ff
	ff		 lea	 ecx, DWORD PTR $T523196[ebp]
  00200	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$47:
  00205	8d 8d 08 ea ff
	ff		 lea	 ecx, DWORD PTR $T523199[ebp]
  0020b	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$48:
  00210	8d 8d 18 ee ff
	ff		 lea	 ecx, DWORD PTR $T523202[ebp]
  00216	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$49:
  0021b	8d 8d e8 e6 ff
	ff		 lea	 ecx, DWORD PTR $T523205[ebp]
  00221	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$50:
  00226	8d 8d f0 ed ff
	ff		 lea	 ecx, DWORD PTR $T523208[ebp]
  0022c	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$51:
  00231	8d 8d e0 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523211[ebp]
  00237	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$52:
  0023c	8d 8d c8 ed ff
	ff		 lea	 ecx, DWORD PTR $T523214[ebp]
  00242	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$53:
  00247	8d 8d d8 e7 ff
	ff		 lea	 ecx, DWORD PTR $T523217[ebp]
  0024d	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$54:
  00252	8d 8d a0 ed ff
	ff		 lea	 ecx, DWORD PTR $T523220[ebp]
  00258	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$55:
  0025d	8d 8d b8 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523223[ebp]
  00263	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$56:
  00268	8d 8d 78 ed ff
	ff		 lea	 ecx, DWORD PTR $T523226[ebp]
  0026e	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$57:
  00273	8d 8d 20 e6 ff
	ff		 lea	 ecx, DWORD PTR $T523229[ebp]
  00279	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$58:
  0027e	8d 8d 50 ed ff
	ff		 lea	 ecx, DWORD PTR $T523232[ebp]
  00284	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$59:
  00289	8d 8d 90 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523235[ebp]
  0028f	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$60:
  00294	8d 8d 28 ed ff
	ff		 lea	 ecx, DWORD PTR $T523238[ebp]
  0029a	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$61:
  0029f	8d 8d b0 e7 ff
	ff		 lea	 ecx, DWORD PTR $T523241[ebp]
  002a5	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$62:
  002aa	8d 8d 00 ed ff
	ff		 lea	 ecx, DWORD PTR $T523244[ebp]
  002b0	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$63:
  002b5	8d 8d 68 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523247[ebp]
  002bb	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$64:
  002c0	8d 8d d8 ec ff
	ff		 lea	 ecx, DWORD PTR $T523250[ebp]
  002c6	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$65:
  002cb	8d 8d c0 e6 ff
	ff		 lea	 ecx, DWORD PTR $T523253[ebp]
  002d1	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$66:
  002d6	8d 8d b0 ec ff
	ff		 lea	 ecx, DWORD PTR $T523256[ebp]
  002dc	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$67:
  002e1	8d 8d 40 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523259[ebp]
  002e7	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$68:
  002ec	8d 8d 88 ec ff
	ff		 lea	 ecx, DWORD PTR $T523262[ebp]
  002f2	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$69:
  002f7	8d 8d 88 e7 ff
	ff		 lea	 ecx, DWORD PTR $T523265[ebp]
  002fd	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$70:
  00302	8d 8d 60 ec ff
	ff		 lea	 ecx, DWORD PTR $T523268[ebp]
  00308	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$71:
  0030d	8d 8d 18 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523271[ebp]
  00313	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$72:
  00318	8d 8d 38 ec ff
	ff		 lea	 ecx, DWORD PTR $T523274[ebp]
  0031e	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$73:
  00323	8d 8d 48 e6 ff
	ff		 lea	 ecx, DWORD PTR $T523277[ebp]
  00329	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$74:
  0032e	8d 8d 10 ec ff
	ff		 lea	 ecx, DWORD PTR $T523280[ebp]
  00334	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$75:
  00339	8d 8d f0 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523283[ebp]
  0033f	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$76:
  00344	8d 8d e8 eb ff
	ff		 lea	 ecx, DWORD PTR $T523286[ebp]
  0034a	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$77:
  0034f	8d 8d 60 e7 ff
	ff		 lea	 ecx, DWORD PTR $T523289[ebp]
  00355	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$78:
  0035a	8d 8d c0 eb ff
	ff		 lea	 ecx, DWORD PTR $T523292[ebp]
  00360	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$79:
  00365	8d 8d a8 ef ff
	ff		 lea	 ecx, DWORD PTR $T523295[ebp]
  0036b	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$80:
  00370	8d 8d 98 eb ff
	ff		 lea	 ecx, DWORD PTR $T523298[ebp]
  00376	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$81:
  0037b	8d 8d 98 e6 ff
	ff		 lea	 ecx, DWORD PTR $T523301[ebp]
  00381	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$82:
  00386	8d 8d 70 eb ff
	ff		 lea	 ecx, DWORD PTR $T523304[ebp]
  0038c	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$83:
  00391	8d 8d a0 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523307[ebp]
  00397	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$84:
  0039c	8d 8d 48 eb ff
	ff		 lea	 ecx, DWORD PTR $T523310[ebp]
  003a2	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$85:
  003a7	8d 8d 38 e7 ff
	ff		 lea	 ecx, DWORD PTR $T523313[ebp]
  003ad	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$86:
  003b2	8d 8d 20 eb ff
	ff		 lea	 ecx, DWORD PTR $T523316[ebp]
  003b8	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$87:
  003bd	8d 8d 78 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523319[ebp]
  003c3	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$88:
  003c8	8d 8d f8 ea ff
	ff		 lea	 ecx, DWORD PTR $T523322[ebp]
  003ce	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$89:
  003d3	8d 8d f8 e5 ff
	ff		 lea	 ecx, DWORD PTR $T523325[ebp]
  003d9	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$90:
  003de	8d 8d d0 ea ff
	ff		 lea	 ecx, DWORD PTR $T523328[ebp]
  003e4	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$91:
  003e9	8d 8d 50 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523331[ebp]
  003ef	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$92:
  003f4	8d 8d 94 ef ff
	ff		 lea	 ecx, DWORD PTR $T523334[ebp]
  003fa	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$93:
  003ff	8d 8d 6c ef ff
	ff		 lea	 ecx, DWORD PTR $T523337[ebp]
  00405	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$94:
  0040a	8d 8d 44 ef ff
	ff		 lea	 ecx, DWORD PTR $T523340[ebp]
  00410	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$95:
  00415	8d 8d 1c ef ff
	ff		 lea	 ecx, DWORD PTR $T523343[ebp]
  0041b	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$96:
  00420	8d 8d f4 ee ff
	ff		 lea	 ecx, DWORD PTR $T523346[ebp]
  00426	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$97:
  0042b	8d 8d cc ee ff
	ff		 lea	 ecx, DWORD PTR $T523349[ebp]
  00431	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$98:
  00436	8d 8d a4 ee ff
	ff		 lea	 ecx, DWORD PTR $T523352[ebp]
  0043c	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$99:
  00441	8d 8d 7c ee ff
	ff		 lea	 ecx, DWORD PTR $T523355[ebp]
  00447	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$100:
  0044c	8d 8d 54 ee ff
	ff		 lea	 ecx, DWORD PTR $T523358[ebp]
  00452	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$101:
  00457	8d 8d 2c ee ff
	ff		 lea	 ecx, DWORD PTR $T523361[ebp]
  0045d	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$102:
  00462	8d 8d 04 ee ff
	ff		 lea	 ecx, DWORD PTR $T523364[ebp]
  00468	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$103:
  0046d	8d 8d dc ed ff
	ff		 lea	 ecx, DWORD PTR $T523367[ebp]
  00473	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$104:
  00478	8d 8d b4 ed ff
	ff		 lea	 ecx, DWORD PTR $T523370[ebp]
  0047e	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$105:
  00483	8d 8d 8c ed ff
	ff		 lea	 ecx, DWORD PTR $T523373[ebp]
  00489	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$106:
  0048e	8d 8d 64 ed ff
	ff		 lea	 ecx, DWORD PTR $T523376[ebp]
  00494	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$107:
  00499	8d 8d 3c ed ff
	ff		 lea	 ecx, DWORD PTR $T523379[ebp]
  0049f	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$108:
  004a4	8d 8d 14 ed ff
	ff		 lea	 ecx, DWORD PTR $T523382[ebp]
  004aa	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$109:
  004af	8d 8d ec ec ff
	ff		 lea	 ecx, DWORD PTR $T523385[ebp]
  004b5	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$110:
  004ba	8d 8d c4 ec ff
	ff		 lea	 ecx, DWORD PTR $T523388[ebp]
  004c0	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$111:
  004c5	8d 8d 9c ec ff
	ff		 lea	 ecx, DWORD PTR $T523391[ebp]
  004cb	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$112:
  004d0	8d 8d 74 ec ff
	ff		 lea	 ecx, DWORD PTR $T523394[ebp]
  004d6	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$113:
  004db	8d 8d 4c ec ff
	ff		 lea	 ecx, DWORD PTR $T523397[ebp]
  004e1	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$114:
  004e6	8d 8d 24 ec ff
	ff		 lea	 ecx, DWORD PTR $T523400[ebp]
  004ec	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$115:
  004f1	8d 8d fc eb ff
	ff		 lea	 ecx, DWORD PTR $T523403[ebp]
  004f7	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$116:
  004fc	8d 8d d4 eb ff
	ff		 lea	 ecx, DWORD PTR $T523406[ebp]
  00502	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$117:
  00507	8d 8d ac eb ff
	ff		 lea	 ecx, DWORD PTR $T523409[ebp]
  0050d	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$118:
  00512	8d 8d 84 eb ff
	ff		 lea	 ecx, DWORD PTR $T523412[ebp]
  00518	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$119:
  0051d	8d 8d 5c eb ff
	ff		 lea	 ecx, DWORD PTR $T523415[ebp]
  00523	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$120:
  00528	8d 8d 34 eb ff
	ff		 lea	 ecx, DWORD PTR $T523418[ebp]
  0052e	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$121:
  00533	8d 8d 0c eb ff
	ff		 lea	 ecx, DWORD PTR $T523421[ebp]
  00539	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$122:
  0053e	8d 8d e4 ea ff
	ff		 lea	 ecx, DWORD PTR $T523424[ebp]
  00544	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$123:
  00549	8d 8d bc ea ff
	ff		 lea	 ecx, DWORD PTR $T523427[ebp]
  0054f	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$124:
  00554	8d 8d 94 ea ff
	ff		 lea	 ecx, DWORD PTR $T523430[ebp]
  0055a	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$125:
  0055f	8d 8d 6c ea ff
	ff		 lea	 ecx, DWORD PTR $T523433[ebp]
  00565	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$126:
  0056a	8d 8d 44 ea ff
	ff		 lea	 ecx, DWORD PTR $T523436[ebp]
  00570	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$127:
  00575	8d 8d 1c ea ff
	ff		 lea	 ecx, DWORD PTR $T523439[ebp]
  0057b	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$128:
  00580	8d 8d f4 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523442[ebp]
  00586	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$129:
  0058b	8d 8d cc e9 ff
	ff		 lea	 ecx, DWORD PTR $T523445[ebp]
  00591	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$130:
  00596	8d 8d a4 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523448[ebp]
  0059c	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$131:
  005a1	8d 8d 7c e9 ff
	ff		 lea	 ecx, DWORD PTR $T523451[ebp]
  005a7	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$132:
  005ac	8d 8d 54 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523454[ebp]
  005b2	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$133:
  005b7	8d 8d 2c e9 ff
	ff		 lea	 ecx, DWORD PTR $T523457[ebp]
  005bd	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$134:
  005c2	8d 8d 04 e9 ff
	ff		 lea	 ecx, DWORD PTR $T523460[ebp]
  005c8	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$135:
  005cd	8d 8d dc e8 ff
	ff		 lea	 ecx, DWORD PTR $T523463[ebp]
  005d3	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$136:
  005d8	8d 8d b4 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523466[ebp]
  005de	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$137:
  005e3	8d 8d 8c e8 ff
	ff		 lea	 ecx, DWORD PTR $T523469[ebp]
  005e9	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$138:
  005ee	8d 8d 64 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523472[ebp]
  005f4	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$139:
  005f9	8d 8d 3c e8 ff
	ff		 lea	 ecx, DWORD PTR $T523475[ebp]
  005ff	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$140:
  00604	8d 8d 14 e8 ff
	ff		 lea	 ecx, DWORD PTR $T523478[ebp]
  0060a	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$141:
  0060f	8d 8d ec e7 ff
	ff		 lea	 ecx, DWORD PTR $T523481[ebp]
  00615	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$142:
  0061a	8d 8d c4 e7 ff
	ff		 lea	 ecx, DWORD PTR $T523484[ebp]
  00620	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$143:
  00625	8d 8d 9c e7 ff
	ff		 lea	 ecx, DWORD PTR $T523487[ebp]
  0062b	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$144:
  00630	8d 8d 74 e7 ff
	ff		 lea	 ecx, DWORD PTR $T523490[ebp]
  00636	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$145:
  0063b	8d 8d 4c e7 ff
	ff		 lea	 ecx, DWORD PTR $T523493[ebp]
  00641	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$146:
  00646	8d 8d 24 e7 ff
	ff		 lea	 ecx, DWORD PTR $T523496[ebp]
  0064c	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$147:
  00651	8d 8d fc e6 ff
	ff		 lea	 ecx, DWORD PTR $T523499[ebp]
  00657	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$148:
  0065c	8d 8d d4 e6 ff
	ff		 lea	 ecx, DWORD PTR $T523502[ebp]
  00662	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$149:
  00667	8d 8d ac e6 ff
	ff		 lea	 ecx, DWORD PTR $T523505[ebp]
  0066d	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$150:
  00672	8d 8d 84 e6 ff
	ff		 lea	 ecx, DWORD PTR $T523508[ebp]
  00678	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$151:
  0067d	8d 8d 5c e6 ff
	ff		 lea	 ecx, DWORD PTR $T523511[ebp]
  00683	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__unwindfunclet$?Load@ioKeyManager@@QAEXXZ$152:
  00688	8d 8d 34 e6 ff
	ff		 lea	 ecx, DWORD PTR $T523514[ebp]
  0068e	e9 00 00 00 00	 jmp	 ??1?$pair@$$CBGVioHashString@@@std@@QAE@XZ
__ehhandler$?Load@ioKeyManager@@QAEXXZ:
  00693	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00697	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0069a	8b 8a e0 e5 ff
	ff		 mov	 ecx, DWORD PTR [edx-6688]
  006a0	33 c8		 xor	 ecx, eax
  006a2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006a7	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  006aa	33 c8		 xor	 ecx, eax
  006ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006b1	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Load@ioKeyManager@@QAEXXZ
  006b6	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Load@ioKeyManager@@QAEXXZ ENDP				; ioKeyManager::Load
PUBLIC	??1?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE@XZ ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::~vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??1?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::~vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >, COMDAT
; _this$ = ecx

; 705  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IAEXXZ ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Tidy
??1?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::~vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >
_TEXT	ENDS
PUBLIC	?reserve@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEXI@Z ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::reserve
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
__Ptr$509975 = 8					; size = 4
__Count$ = 8						; size = 4
?reserve@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEXI@Z PROC ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?reserve@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEXI@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_catch
  0000c	8b f1		 mov	 esi, ecx

; 747  : 		if (max_size() < _Count)

  0000e	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00011	81 fb cc cc cc
	0c		 cmp	 ebx, 214748364		; 0cccccccH
  00017	76 0b		 jbe	 SHORT $LN5@reserve@2

; 748  : 			_Xlen();	// result too long

  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN38@reserve@2:
$LN5@reserve@2:

; 749  : 		else if (capacity() < _Count)

  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	2b 06		 sub	 eax, DWORD PTR [esi]
  00029	6a 14		 push	 20			; 00000014H
  0002b	99		 cdq
  0002c	59		 pop	 ecx
  0002d	f7 f9		 idiv	 ecx
  0002f	3b c3		 cmp	 eax, ebx
  00031	73 70		 jae	 SHORT $LN3@reserve@2

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  00033	6a 00		 push	 0
  00035	53		 push	 ebx
  00036	e8 00 00 00 00	 call	 ??$_Allocate@UtagMecroTextInfo@CKeyInfo@@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@IPAU12@@Z ; std::_Allocate<CKeyInfo::tagMecroTextInfo>

; 752  : 
; 753  : 			_TRY_BEGIN
; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  0003b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0003d	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
  00041	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  00044	52		 push	 edx
  00045	89 45 08	 mov	 DWORD PTR __Ptr$509975[ebp], eax
  00048	ff 75 08	 push	 DWORD PTR __Ptr$509975[ebp]
  0004b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0004e	50		 push	 eax
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@@Z ; std::_Uninitialized_move<CKeyInfo::tagMecroTextInfo *,CKeyInfo::tagMecroTextInfo *,std::allocator<CKeyInfo::tagMecroTextInfo> >

; 758  : 			_CATCH_END
; 759  : 
; 760  : 			size_type _Size = size();

  00055	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00057	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0005a	83 c4 18	 add	 esp, 24			; 00000018H
  0005d	2b c1		 sub	 eax, ecx
  0005f	6a 14		 push	 20			; 00000014H
  00061	99		 cdq
  00062	5f		 pop	 edi
  00063	f7 ff		 idiv	 edi
  00065	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  00069	8b f8		 mov	 edi, eax
  0006b	85 c9		 test	 ecx, ecx
  0006d	74 17		 je	 SHORT $LN33@reserve@2

; 761  : 			if (this->_Myfirst != 0)
; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  0006f	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00072	50		 push	 eax
  00073	ff 76 04	 push	 DWORD PTR [esi+4]
  00076	51		 push	 ecx
  00077	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@0AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CKeyInfo::tagMecroTextInfo> >

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  0007c	ff 36		 push	 DWORD PTR [esi]
  0007e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00083	83 c4 10	 add	 esp, 16			; 00000010H
$LN33@reserve@2:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  00086	8b ce		 mov	 ecx, esi
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 769  : 			this->_Myend = _Ptr + _Count;

  0008e	6b db 14	 imul	 ebx, 20			; 00000014H

; 770  : 			this->_Mylast = _Ptr + _Size;

  00091	6b ff 14	 imul	 edi, 20			; 00000014H
  00094	8b 45 08	 mov	 eax, DWORD PTR __Ptr$509975[ebp]
  00097	03 d8		 add	 ebx, eax
  00099	03 f8		 add	 edi, eax
  0009b	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  0009e	89 7e 04	 mov	 DWORD PTR [esi+4], edi

; 771  : 			this->_Myfirst = _Ptr;

  000a1	89 06		 mov	 DWORD PTR [esi], eax
$LN3@reserve@2:

; 772  : 			}
; 773  : 		}

  000a3	e8 00 00 00 00	 call	 __EH_epilog3
  000a8	c2 04 00	 ret	 4
__catch$?reserve@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  000ab	ff 75 08	 push	 DWORD PTR __Ptr$509975[ebp]
  000ae	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000b3	59		 pop	 ecx

; 757  : 			_RERAISE;

  000b4	6a 00		 push	 0
  000b6	6a 00		 push	 0
  000b8	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN39@reserve@2:
$LN37@reserve@2:
  000bd	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::reserve
PUBLIC	?erase@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@0@Z ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::erase
; Function compile flags: /Ogsp
;	COMDAT ?erase@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Cat$546322 = 16					; size = 1
__Last_arg$ = 16					; size = 4
?erase@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@0@Z PROC ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	89 03		 mov	 DWORD PTR [ebx], eax

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);
; 1193 : 
; 1194 : 		if (_First != _Last)

  0000f	3b 45 10	 cmp	 eax, DWORD PTR __Last_arg$[ebp]
  00012	74 27		 je	 SHORT $LN1@erase@4

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  00014	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00017	57		 push	 edi
  00018	ff 75 10	 push	 DWORD PTR __Cat$546322[ebp]
  0001b	50		 push	 eax
  0001c	51		 push	 ecx
  0001d	ff 75 10	 push	 DWORD PTR __Last_arg$[ebp]
  00020	e8 00 00 00 00	 call	 ??$_Move@PAUtagMecroTextInfo@CKeyInfo@@PAU12@@std@@YAPAUtagMecroTextInfo@CKeyInfo@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<CKeyInfo::tagMecroTextInfo *,CKeyInfo::tagMecroTextInfo *>
  00025	8b f8		 mov	 edi, eax

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);

  00027	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  0002a	50		 push	 eax
  0002b	ff 76 04	 push	 DWORD PTR [esi+4]
  0002e	57		 push	 edi
  0002f	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@0AAV?$allocator@UtagMecroTextInfo@CKeyInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CKeyInfo::tagMecroTextInfo> >
  00034	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1211 : 			this->_Mylast = _Ptr;

  00037	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0003a	5f		 pop	 edi
$LN1@erase@4:

; 1212 : 			}
; 1213 : 		return (_First);

  0003b	5e		 pop	 esi
  0003c	8b c3		 mov	 eax, ebx
  0003e	5b		 pop	 ebx

; 1214 : 		}

  0003f	5d		 pop	 ebp
  00040	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@0@Z ENDP ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::erase
_TEXT	ENDS
PUBLIC	?_Reserve@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IAEXI@Z ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Reserve
; Function compile flags: /Ogsp
;	COMDAT ?_Reserve@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IAEXI@Z PROC ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1291 : 		size_type _Size = size();

  00006	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00008	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000b	2b c1		 sub	 eax, ecx
  0000d	57		 push	 edi
  0000e	99		 cdq
  0000f	6a 14		 push	 20			; 00000014H
  00011	5f		 pop	 edi
  00012	f7 ff		 idiv	 edi
  00014	8b f8		 mov	 edi, eax

; 1292 : 		if (max_size() - _Count < _Size)

  00016	b8 cc cc cc 0c	 mov	 eax, 214748364		; 0cccccccH
  0001b	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  0001e	3b c7		 cmp	 eax, edi
  00020	73 0b		 jae	 SHORT $LN4@Reserve@2

; 1293 : 			_Xlen();

  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN21@Reserve@2:
$LN4@Reserve@2:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	2b c1		 sub	 eax, ecx
  00032	6a 14		 push	 20			; 00000014H
  00034	99		 cdq
  00035	59		 pop	 ecx
  00036	f7 f9		 idiv	 ecx
  00038	03 7d 08	 add	 edi, DWORD PTR __Count$[ebp]
  0003b	3b f8		 cmp	 edi, eax
  0003d	76 10		 jbe	 SHORT $LN1@Reserve@2

; 1295 : 			;
; 1296 : 		else
; 1297 : 			reserve(_Grow_to(_Size));

  0003f	57		 push	 edi
  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IBEII@Z ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Grow_to
  00047	50		 push	 eax
  00048	8b ce		 mov	 ecx, esi
  0004a	e8 00 00 00 00	 call	 ?reserve@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEXI@Z ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::reserve
$LN1@Reserve@2:
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi

; 1298 : 		}

  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
$LN20@Reserve@2:
?_Reserve@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Reserve
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Tidy
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T546367 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1865 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1866 : 		erase(begin(), end());

  00004	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00007	8b 10		 mov	 edx, DWORD PTR [eax]
  00009	50		 push	 eax
  0000a	52		 push	 edx
  0000b	8d 45 fc	 lea	 eax, DWORD PTR $T546367[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::erase

; 1867 : 		}

  00014	c9		 leave
  00015	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	??_7CKeyInfo@@6B@				; CKeyInfo::`vftable'
PUBLIC	??0CKeyInfo@@QAE@XZ				; CKeyInfo::CKeyInfo
PUBLIC	??_R4CKeyInfo@@6B@				; CKeyInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCKeyInfo@@@8				; CKeyInfo `RTTI Type Descriptor'
PUBLIC	??_R3CKeyInfo@@8				; CKeyInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CKeyInfo@@8				; CKeyInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CKeyInfo@@8			; CKeyInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_ECKeyInfo@@UAEPAXI@Z:PROC			; CKeyInfo::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CKeyInfo@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
rdata$r	SEGMENT
??_R1A@?0A@EA@CKeyInfo@@8 DD FLAT:??_R0?AVCKeyInfo@@@8	; CKeyInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CKeyInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CKeyInfo@@8
rdata$r	SEGMENT
??_R2CKeyInfo@@8 DD FLAT:??_R1A@?0A@EA@CKeyInfo@@8	; CKeyInfo::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CKeyInfo@@8
rdata$r	SEGMENT
??_R3CKeyInfo@@8 DD 00H					; CKeyInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CKeyInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCKeyInfo@@@8
_DATA	SEGMENT
??_R0?AVCKeyInfo@@@8 DD FLAT:??_7type_info@@6B@		; CKeyInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCKeyInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CKeyInfo@@6B@
rdata$r	SEGMENT
??_R4CKeyInfo@@6B@ DD 00H				; CKeyInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCKeyInfo@@@8
	DD	FLAT:??_R3CKeyInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CKeyInfo@@6B@
CONST	SEGMENT
??_7CKeyInfo@@6B@ DD FLAT:??_R4CKeyInfo@@6B@		; CKeyInfo::`vftable'
	DD	FLAT:?SaveKey@CKeyInfo@@UAEXXZ
	DD	FLAT:?SaveMacroTextInfo@CKeyInfo@@UAEXXZ
	DD	FLAT:??_ECKeyInfo@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CKeyInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CKeyInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CKeyInfo@@QAE@XZ$1
__ehfuncinfo$??0CKeyInfo@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CKeyInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iokeymanager.cpp
xdata$x	ENDS
;	COMDAT ??0CKeyInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CKeyInfo@@QAE@XZ PROC				; CKeyInfo::CKeyInfo, COMDAT
; _this$ = ecx

; 9    : {

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0CKeyInfo@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00014	33 c0		 xor	 eax, eax
  00016	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CKeyInfo@@6B@
  0001c	89 01		 mov	 DWORD PTR [ecx], eax
  0001e	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00021	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00024	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], eax
  00027	89 46 14	 mov	 DWORD PTR [esi+20], eax
  0002a	89 46 18	 mov	 DWORD PTR [esi+24], eax
  0002d	89 46 1c	 mov	 DWORD PTR [esi+28], eax

; 10   : 	m_vKeyInfo.reserve(30);

  00030	6a 1e		 push	 30			; 0000001eH
  00032	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00036	66 c7 46 24 01
	00		 mov	 WORD PTR [esi+36], 1
  0003c	e8 00 00 00 00	 call	 ?reserve@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::reserve

; 11   : 	m_vMecroTextInfo.reserve(30);

  00041	6a 1e		 push	 30			; 0000001eH
  00043	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  00046	e8 00 00 00 00	 call	 ?reserve@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEXI@Z ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::reserve

; 12   : }

  0004b	8b c6		 mov	 eax, esi
  0004d	e8 00 00 00 00	 call	 __EH_epilog3
  00052	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CKeyInfo@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ ; std::vector<unsigned short,std::allocator<unsigned short> >::~vector<unsigned short,std::allocator<unsigned short> >
__unwindfunclet$??0CKeyInfo@@QAE@XZ$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 14	 add	 ecx, 20			; 00000014H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE@XZ ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::~vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >
__ehhandler$??0CKeyInfo@@QAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CKeyInfo@@QAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CKeyInfo@@QAE@XZ ENDP				; CKeyInfo::CKeyInfo
PUBLIC	?push_back@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEXABUtagMecroTextInfo@CKeyInfo@@@Z ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::push_back
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?push_back@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEXABUtagMecroTextInfo@CKeyInfo@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEXABUtagMecroTextInfo@CKeyInfo@@@Z PROC ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  00006	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	73 33		 jae	 SHORT $LN4@push_back@3
  00011	8b 16		 mov	 edx, DWORD PTR [esi]
  00013	3b d7		 cmp	 edx, edi
  00015	77 2d		 ja	 SHORT $LN4@push_back@3

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	8b c7		 mov	 eax, edi
  00019	2b c2		 sub	 eax, edx
  0001b	6a 14		 push	 20			; 00000014H
  0001d	99		 cdq
  0001e	5f		 pop	 edi
  0001f	f7 ff		 idiv	 edi
  00021	8b f8		 mov	 edi, eax

; 980  : 			if (this->_Mylast == this->_Myend)

  00023	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00026	75 09		 jne	 SHORT $LN3@push_back@3

; 981  : 				_Reserve(1);

  00028	6a 01		 push	 1
  0002a	8b ce		 mov	 ecx, esi
  0002c	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IAEXI@Z ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Reserve
$LN3@push_back@3:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  00031	6b ff 14	 imul	 edi, 20			; 00000014H
  00034	03 3e		 add	 edi, DWORD PTR [esi]
  00036	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00039	57		 push	 edi
  0003a	ff 76 04	 push	 DWORD PTR [esi+4]
  0003d	e8 00 00 00 00	 call	 ??$construct@AAUtagMecroTextInfo@CKeyInfo@@@?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@QAEXPAUtagMecroTextInfo@CKeyInfo@@AAU23@@Z ; std::allocator<CKeyInfo::tagMecroTextInfo>::construct<CKeyInfo::tagMecroTextInfo &>

; 986  : 			++this->_Mylast;
; 987  : 			}
; 988  : 		else

  00042	eb 19		 jmp	 SHORT $LN30@push_back@3
$LN4@push_back@3:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  00044	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00047	75 09		 jne	 SHORT $LN1@push_back@3

; 991  : 				_Reserve(1);

  00049	6a 01		 push	 1
  0004b	8b ce		 mov	 ecx, esi
  0004d	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IAEXI@Z ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Reserve
$LN1@push_back@3:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  00052	57		 push	 edi
  00053	ff 76 04	 push	 DWORD PTR [esi+4]
  00056	e8 00 00 00 00	 call	 ??$_Construct@UtagMecroTextInfo@CKeyInfo@@ABU12@@std@@YAXPAUtagMecroTextInfo@CKeyInfo@@ABU12@@Z ; std::_Construct<CKeyInfo::tagMecroTextInfo,CKeyInfo::tagMecroTextInfo const &>
  0005b	59		 pop	 ecx
  0005c	59		 pop	 ecx
$LN30@push_back@3:

; 996  : 			++this->_Mylast;

  0005d	83 46 04 14	 add	 DWORD PTR [esi+4], 20	; 00000014H
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?push_back@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEXABUtagMecroTextInfo@CKeyInfo@@@Z ENDP ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::push_back
_TEXT	ENDS
PUBLIC	?clear@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEXXZ ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::clear
; Function compile flags: /Ogsp
;	COMDAT ?clear@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T546566 = -4						; size = 4
?clear@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1218 : 		erase(begin(), end());

  00004	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00007	8b 11		 mov	 edx, DWORD PTR [ecx]
  00009	50		 push	 eax
  0000a	52		 push	 edx
  0000b	8d 45 fc	 lea	 eax, DWORD PTR $T546566[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?erase@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@0@Z ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::erase

; 1219 : 		}

  00014	c9		 leave
  00015	c3		 ret	 0
?clear@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::clear
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::~_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T546717 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::~_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >, COMDAT
; _this$ = ecx

; 790  : 		{	// destroy tree

  00000	6a 08		 push	 8
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??1?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 791  : 		_Tidy();

  00011	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0001a	50		 push	 eax
  0001b	51		 push	 ecx
  0001c	8d 45 ec	 lea	 eax, DWORD PTR $T546717[ebp]
  0001f	50		 push	 eax
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::erase

; 792  : 		}

  00027	ff 76 04	 push	 DWORD PTR [esi+4]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	e8 00 00 00 00	 call	 __EH_epilog3
  00035	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >
__ehhandler$??1?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::~_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >
PUBLIC	??1CKeyInfo@@UAE@XZ				; CKeyInfo::~CKeyInfo
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??1CKeyInfo@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CKeyInfo@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CKeyInfo@@UAE@XZ$1
__ehfuncinfo$??1CKeyInfo@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CKeyInfo@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iokeymanager.cpp
xdata$x	ENDS
;	COMDAT ??1CKeyInfo@@UAE@XZ
_TEXT	SEGMENT
$T546902 = -20						; size = 4
$T546824 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CKeyInfo@@UAE@XZ PROC				; CKeyInfo::~CKeyInfo, COMDAT
; _this$ = ecx

; 15   : {

  00000	6a 08		 push	 8
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??1CKeyInfo@@UAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f9		 mov	 edi, ecx
  0000e	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  00011	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CKeyInfo@@6B@

; 16   : 	m_vKeyInfo.clear();

  00017	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0001a	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0001d	50		 push	 eax
  0001e	51		 push	 ecx
  0001f	8d 45 ec	 lea	 eax, DWORD PTR $T546824[ebp]
  00022	50		 push	 eax
  00023	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00026	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0002d	e8 00 00 00 00	 call	 ?erase@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@0@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::erase

; 17   : 	m_vMecroTextInfo.clear();

  00032	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00035	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  00038	50		 push	 eax
  00039	51		 push	 ecx
  0003a	8d 45 ec	 lea	 eax, DWORD PTR $T546902[ebp]
  0003d	50		 push	 eax
  0003e	8d 4f 14	 lea	 ecx, DWORD PTR [edi+20]
  00041	e8 00 00 00 00	 call	 ?erase@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@0@Z ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::erase

; 18   : }

  00046	8d 4f 14	 lea	 ecx, DWORD PTR [edi+20]
  00049	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0004d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@IAEXXZ ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::_Tidy
  00052	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00056	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00059	e8 00 00 00 00	 call	 ?_Tidy@?$vector@GV?$allocator@G@std@@@std@@IAEXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Tidy
  0005e	e8 00 00 00 00	 call	 __EH_epilog3
  00063	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CKeyInfo@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ ; std::vector<unsigned short,std::allocator<unsigned short> >::~vector<unsigned short,std::allocator<unsigned short> >
__unwindfunclet$??1CKeyInfo@@UAE@XZ$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 14	 add	 ecx, 20			; 00000014H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE@XZ ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::~vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >
__ehhandler$??1CKeyInfo@@UAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CKeyInfo@@UAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CKeyInfo@@UAE@XZ ENDP				; CKeyInfo::~CKeyInfo
PUBLIC	?Load@CKeyInfo@@QAEXXZ				; CKeyInfo::Load
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Load@CKeyInfo@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Load@CKeyInfo@@QAEXXZ$0
__ehfuncinfo$?Load@CKeyInfo@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Load@CKeyInfo@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ?Load@CKeyInfo@@QAEXXZ
_TEXT	SEGMENT
_kInfo$505353 = -36					; size = 20
$T546945 = -16						; size = 2
__$EHRec$ = -12						; size = 12
?Load@CKeyInfo@@QAEXXZ PROC				; CKeyInfo::Load, COMDAT
; _this$ = ecx

; 322  : {

  00000	6a 18		 push	 24			; 00000018H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?Load@CKeyInfo@@QAEXXZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx

; 323  : 	for (int i = 0; i < KTA_MAX ; i++)

  0000e	6a 5f		 push	 95			; 0000005fH
  00010	5b		 pop	 ebx
$LL6@Load@5:

; 324  : 	{
; 325  : 		m_vKeyInfo.push_back( 0 );

  00011	83 65 f0 00	 and	 DWORD PTR $T546945[ebp], 0
  00015	8d 45 f0	 lea	 eax, DWORD PTR $T546945[ebp]
  00018	50		 push	 eax
  00019	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0001c	e8 00 00 00 00	 call	 ?push_back@?$vector@GV?$allocator@G@std@@@std@@QAEX$$QAG@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::push_back
  00021	4b		 dec	 ebx
  00022	75 ed		 jne	 SHORT $LL6@Load@5

; 326  : 	}
; 327  : 
; 328  : 	for (int i = 0; i < MAX_MACRO ; i++)

  00024	6a 0c		 push	 12			; 0000000cH
  00026	5b		 pop	 ebx
$LL3@Load@5:

; 329  : 	{
; 330  : 		MecroTextInfo kInfo;

  00027	8d 4d dc	 lea	 ecx, DWORD PTR _kInfo$505353[ebp]
  0002a	e8 00 00 00 00	 call	 ??0tagMecroTextInfo@CKeyInfo@@QAE@XZ ; CKeyInfo::tagMecroTextInfo::tagMecroTextInfo
  0002f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 331  : 		m_vMecroTextInfo.push_back( kInfo );

  00033	8d 45 dc	 lea	 eax, DWORD PTR _kInfo$505353[ebp]
  00036	50		 push	 eax
  00037	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  0003a	e8 00 00 00 00	 call	 ?push_back@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEXABUtagMecroTextInfo@CKeyInfo@@@Z ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::push_back

; 332  : 	}

  0003f	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00043	8d 4d e0	 lea	 ecx, DWORD PTR _kInfo$505353[ebp+4]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  0004c	4b		 dec	 ebx
  0004d	75 d8		 jne	 SHORT $LL3@Load@5

; 333  : 	m_bUse = false;

  0004f	88 5e 24	 mov	 BYTE PTR [esi+36], bl

; 334  : }

  00052	e8 00 00 00 00	 call	 __EH_epilog3
  00057	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Load@CKeyInfo@@QAEXXZ$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR _kInfo$505353[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1tagMecroTextInfo@CKeyInfo@@QAE@XZ
__ehhandler$?Load@CKeyInfo@@QAEXXZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Load@CKeyInfo@@QAEXXZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Load@CKeyInfo@@QAEXXZ ENDP				; CKeyInfo::Load
PUBLIC	??_7CDefaultKeyInfo@@6B@			; CDefaultKeyInfo::`vftable'
PUBLIC	??0CDefaultKeyInfo@@QAE@XZ			; CDefaultKeyInfo::CDefaultKeyInfo
PUBLIC	??_R4CDefaultKeyInfo@@6B@			; CDefaultKeyInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCDefaultKeyInfo@@@8			; CDefaultKeyInfo `RTTI Type Descriptor'
PUBLIC	??_R3CDefaultKeyInfo@@8				; CDefaultKeyInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDefaultKeyInfo@@8				; CDefaultKeyInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CDefaultKeyInfo@@8		; CDefaultKeyInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Load@CDefaultKeyInfo@@UAEXXZ			; CDefaultKeyInfo::Load
EXTRN	??_ECDefaultKeyInfo@@UAEPAXI@Z:PROC		; CDefaultKeyInfo::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CDefaultKeyInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CDefaultKeyInfo@@8 DD FLAT:??_R0?AVCDefaultKeyInfo@@@8 ; CDefaultKeyInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CDefaultKeyInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CDefaultKeyInfo@@8
rdata$r	SEGMENT
??_R2CDefaultKeyInfo@@8 DD FLAT:??_R1A@?0A@EA@CDefaultKeyInfo@@8 ; CDefaultKeyInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CKeyInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CDefaultKeyInfo@@8
rdata$r	SEGMENT
??_R3CDefaultKeyInfo@@8 DD 00H				; CDefaultKeyInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CDefaultKeyInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDefaultKeyInfo@@@8
_DATA	SEGMENT
??_R0?AVCDefaultKeyInfo@@@8 DD FLAT:??_7type_info@@6B@	; CDefaultKeyInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDefaultKeyInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CDefaultKeyInfo@@6B@
rdata$r	SEGMENT
??_R4CDefaultKeyInfo@@6B@ DD 00H			; CDefaultKeyInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCDefaultKeyInfo@@@8
	DD	FLAT:??_R3CDefaultKeyInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CDefaultKeyInfo@@6B@
CONST	SEGMENT
??_7CDefaultKeyInfo@@6B@ DD FLAT:??_R4CDefaultKeyInfo@@6B@ ; CDefaultKeyInfo::`vftable'
	DD	FLAT:?SaveKey@CKeyInfo@@UAEXXZ
	DD	FLAT:?SaveMacroTextInfo@CKeyInfo@@UAEXXZ
	DD	FLAT:??_ECDefaultKeyInfo@@UAEPAXI@Z
	DD	FLAT:?Load@CDefaultKeyInfo@@UAEXXZ
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??0CDefaultKeyInfo@@QAE@XZ
_TEXT	SEGMENT
??0CDefaultKeyInfo@@QAE@XZ PROC				; CDefaultKeyInfo::CDefaultKeyInfo, COMDAT
; _this$ = ecx

; 367  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??0CKeyInfo@@QAE@XZ	; CKeyInfo::CKeyInfo
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CDefaultKeyInfo@@6B@

; 368  : 
; 369  : }

  0000e	8b c6		 mov	 eax, esi
  00010	5e		 pop	 esi
  00011	c3		 ret	 0
??0CDefaultKeyInfo@@QAE@XZ ENDP				; CDefaultKeyInfo::CDefaultKeyInfo
_TEXT	ENDS
PUBLIC	??1CDefaultKeyInfo@@UAE@XZ			; CDefaultKeyInfo::~CDefaultKeyInfo
; Function compile flags: /Ogsp
;	COMDAT ??1CDefaultKeyInfo@@UAE@XZ
_TEXT	SEGMENT
??1CDefaultKeyInfo@@UAE@XZ PROC				; CDefaultKeyInfo::~CDefaultKeyInfo, COMDAT
; _this$ = ecx

; 372  : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CDefaultKeyInfo@@6B@

; 373  : }

  00006	e9 00 00 00 00	 jmp	 ??1CKeyInfo@@UAE@XZ	; CKeyInfo::~CKeyInfo
??1CDefaultKeyInfo@@UAE@XZ ENDP				; CDefaultKeyInfo::~CDefaultKeyInfo
_TEXT	ENDS
EXTRN	__imp_?LoadBool@ioINILoader@@QAE_NPBD_N@Z:PROC
EXTRN	__imp_??4ioHashString@@QAEAAV0@PBD@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Load@CDefaultKeyInfo@@UAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Load@CDefaultKeyInfo@@UAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@CDefaultKeyInfo@@UAEXXZ$1
__ehfuncinfo$?Load@CDefaultKeyInfo@@UAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Load@CDefaultKeyInfo@@UAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ?Load@CDefaultKeyInfo@@UAEXXZ
_TEXT	SEGMENT
_kInfo$505570 = -1504					; size = 20
_wKey$505405 = -1484					; size = 2
tv1681 = -1484						; size = 4
$T547117 = -1484					; size = 4
$T547036 = -1484					; size = 4
tv4096 = -1480						; size = 4
_i$505400 = -1480					; size = 4
_kLoader$ = -1476					; size = 912
_szBuf$505569 = -564					; size = 260
_szKeyName$505415 = -304				; size = 260
___encStr$505419 = -44					; size = 7
__t$547399 = -32					; size = 10
___encStr$505574 = -32					; size = 7
__$EHRec$ = -12						; size = 12
?Load@CDefaultKeyInfo@@UAEXXZ PROC			; CDefaultKeyInfo::Load, COMDAT
; _this$ = ecx

; 376  : {

  00000	68 d4 05 00 00	 push	 1492			; 000005d4H
  00005	b8 00 00 00 00	 mov	 eax, __ehhandler$?Load@CDefaultKeyInfo@@UAEXXZ
  0000a	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000f	8b d9		 mov	 ebx, ecx

; 377  : 	m_vKeyInfo.clear();

  00011	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00014	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00017	50		 push	 eax
  00018	51		 push	 ecx
  00019	8d 85 34 fa ff
	ff		 lea	 eax, DWORD PTR $T547036[ebp]
  0001f	50		 push	 eax
  00020	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  00023	e8 00 00 00 00	 call	 ?erase@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@0@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::erase

; 378  : 	m_vMecroTextInfo.clear();

  00028	8d 7b 14	 lea	 edi, DWORD PTR [ebx+20]
  0002b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0002e	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 85 34 fa ff
	ff		 lea	 eax, DWORD PTR $T547117[ebp]
  00038	50		 push	 eax
  00039	8b cf		 mov	 ecx, edi
  0003b	e8 00 00 00 00	 call	 ?erase@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@0@Z ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::erase

; 379  : 
; 380  : 	ioINILoader_e kLoader( "config/sp2_default_key.ini" );

  00040	6a 06		 push	 6
  00042	c7 85 8c fd ff
	ff 8e 83 85 8c	 mov	 DWORD PTR _kLoader$[ebp+848], -1937407090 ; 8c85838eH
  0004c	c7 85 90 fd ff
	ff 84 8b c4 99	 mov	 DWORD PTR _kLoader$[ebp+852], -1715172476 ; 99c48b84H
  00056	c7 85 94 fd ff
	ff 9d de b4 8e	 mov	 DWORD PTR _kLoader$[ebp+856], -1900749155 ; 8eb4de9dH
  00060	c7 85 98 fd ff
	ff 88 8a 8a 9f	 mov	 DWORD PTR _kLoader$[ebp+860], -1618310520 ; 9f8a8a88H
  0006a	c7 85 9c fd ff
	ff 81 98 b4 81	 mov	 DWORD PTR _kLoader$[ebp+864], -2118870911 ; 81b49881H
  00074	c7 85 a0 fd ff
	ff 88 95 c5 83	 mov	 DWORD PTR _kLoader$[ebp+868], -2084203128 ; 83c59588H
  0007e	66 c7 85 a4 fd
	ff ff 83 85	 mov	 WORD PTR _kLoader$[ebp+872], 34179 ; 00008583H
  00087	8d 85 8c fd ff
	ff		 lea	 eax, DWORD PTR _kLoader$[ebp+848]
  0008d	c6 85 a6 fd ff
	ff 00		 mov	 BYTE PTR _kLoader$[ebp+874], 0
  00094	59		 pop	 ecx
$LL351@Load@6:
  00095	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  0009b	83 c0 04	 add	 eax, 4
  0009e	49		 dec	 ecx
  0009f	75 f4		 jne	 SHORT $LL351@Load@6
  000a1	6a 18		 push	 24			; 00000018H
  000a3	58		 pop	 eax
$LL348@Load@6:
  000a4	8b c8		 mov	 ecx, eax
  000a6	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  000ac	79 05		 jns	 SHORT $LN504@Load@6
  000ae	49		 dec	 ecx
  000af	83 c9 fc	 or	 ecx, -4			; fffffffcH
  000b2	41		 inc	 ecx
$LN504@Load@6:
  000b3	b2 ed		 mov	 dl, -19			; ffffffedH
  000b5	2a d1		 sub	 dl, cl
  000b7	30 94 05 8c fd
	ff ff		 xor	 BYTE PTR _kLoader$[ebp+eax+848], dl
  000be	40		 inc	 eax
  000bf	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  000c2	7c e0		 jl	 SHORT $LL348@Load@6
  000c4	6a 01		 push	 1
  000c6	8d 85 8c fd ff
	ff		 lea	 eax, DWORD PTR _kLoader$[ebp+848]
  000cc	50		 push	 eax
  000cd	8d 8d 3c fa ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioINILoader@@QAE@PBD_N@Z
  000d9	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 381  : 	kLoader.SetTitle( "Key" );

  000dd	68 00 00 00 00	 push	 OFFSET ??_C@_03CCEPDEKL@Key?$AA@
  000e2	8d 8d 3c fa ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z

; 382  : 	for (int i = 0; i < KTA_MAX ; i++)

  000ee	83 a5 38 fa ff
	ff 00		 and	 DWORD PTR _i$505400[ebp], 0
$LN204@Load@6:

; 383  : 	{
; 384  : 		char szBuf[MAX_PATH]="";
; 385  : 		WORD wKey = kLoader.LoadInt(GetINIKeyName((KeyTypeArray)i), 0);

  000f5	6a 00		 push	 0
  000f7	ff b5 38 fa ff
	ff		 push	 DWORD PTR _i$505400[ebp]
  000fd	8b cb		 mov	 ecx, ebx
  000ff	e8 00 00 00 00	 call	 ?GetINIKeyName@CKeyInfo@@IAEPADW4KeyTypeArray@1@@Z ; CKeyInfo::GetINIKeyName
  00104	50		 push	 eax
  00105	8d 8d 3c fa ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  00111	0f b7 c0	 movzx	 eax, ax
  00114	89 85 34 fa ff
	ff		 mov	 DWORD PTR _wKey$505405[ebp], eax

; 386  : 		m_vKeyInfo.push_back(wKey);

  0011a	8d 85 34 fa ff
	ff		 lea	 eax, DWORD PTR _wKey$505405[ebp]
  00120	50		 push	 eax
  00121	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  00124	e8 00 00 00 00	 call	 ?push_back@?$vector@GV?$allocator@G@std@@@std@@QAEXABG@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::push_back
  00129	ff 85 38 fa ff
	ff		 inc	 DWORD PTR _i$505400[ebp]
  0012f	83 bd 38 fa ff
	ff 5f		 cmp	 DWORD PTR _i$505400[ebp], 95 ; 0000005fH
  00136	7c bd		 jl	 SHORT $LN204@Load@6

; 387  : 	}
; 388  : 
; 389  : 	kLoader.SetTitle_e( "MacroText" );

  00138	6a 02		 push	 2
  0013a	c7 45 e0 a0 8d
	88 98		 mov	 DWORD PTR __t$547399[ebp], -1735881312 ; 98888da0H
  00141	c7 45 e4 82 b8
	8e 92		 mov	 DWORD PTR __t$547399[ebp+4], -1836140414 ; 928eb882H
  00148	8d 45 e0	 lea	 eax, DWORD PTR __t$547399[ebp]
  0014b	66 c7 45 e8 99
	00		 mov	 WORD PTR __t$547399[ebp+8], 153 ; 00000099H
  00151	59		 pop	 ecx
$LL457@Load@6:
  00152	81 30 ed ec eb
	ea		 xor	 DWORD PTR [eax], -353637139 ; eaebecedH
  00158	83 c0 04	 add	 eax, 4
  0015b	49		 dec	 ecx
  0015c	75 f4		 jne	 SHORT $LL457@Load@6
  0015e	80 75 e8 ed	 xor	 BYTE PTR __t$547399[ebp+8], -19 ; ffffffedH
  00162	8d 45 e0	 lea	 eax, DWORD PTR __t$547399[ebp]
  00165	50		 push	 eax
  00166	8d 8d 3c fa ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0016c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z
  00172	bb 03 01 00 00	 mov	 ebx, 259		; 00000103H
  00177	c7 85 38 fa ff
	ff 01 00 00 00	 mov	 DWORD PTR tv4096[ebp], 1
  00181	c7 85 34 fa ff
	ff 0c 00 00 00	 mov	 DWORD PTR tv1681[ebp], 12 ; 0000000cH
  0018b	8d 73 01	 lea	 esi, DWORD PTR [ebx+1]
$LL201@Load@6:

; 390  : 	for (int i = 0; i < MAX_MACRO ; i++)
; 391  : 	{
; 392  : 		char szKeyName[MAX_PATH]="";

  0018e	53		 push	 ebx
  0018f	8d 85 d1 fe ff
	ff		 lea	 eax, DWORD PTR _szKeyName$505415[ebp+1]
  00195	6a 00		 push	 0
  00197	50		 push	 eax
  00198	c6 85 d0 fe ff
	ff 00		 mov	 BYTE PTR _szKeyName$505415[ebp], 0
  0019f	e8 00 00 00 00	 call	 _memset
  001a4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 393  : 		StringCbPrintf_e(szKeyName, sizeof(szKeyName), "Text%d", i+1);

  001a7	6a 04		 push	 4
  001a9	c7 45 d4 b9 89
	93 9e		 mov	 DWORD PTR ___encStr$505419[ebp], -1634498119 ; 9e9389b9H
  001b0	81 75 d4 ed ec
	eb ea		 xor	 DWORD PTR ___encStr$505419[ebp], -353637139 ; eaebecedH
  001b7	66 c7 45 d8 c8
	88		 mov	 WORD PTR ___encStr$505419[ebp+4], 35016 ; 000088c8H
  001bd	c6 45 da 00	 mov	 BYTE PTR ___encStr$505419[ebp+6], 0
  001c1	58		 pop	 eax
$LL462@Load@6:
  001c2	8b c8		 mov	 ecx, eax
  001c4	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  001ca	79 05		 jns	 SHORT $LN505@Load@6
  001cc	49		 dec	 ecx
  001cd	83 c9 fc	 or	 ecx, -4			; fffffffcH
  001d0	41		 inc	 ecx
$LN505@Load@6:
  001d1	b2 ed		 mov	 dl, -19			; ffffffedH
  001d3	2a d1		 sub	 dl, cl
  001d5	30 54 05 d4	 xor	 BYTE PTR ___encStr$505419[ebp+eax], dl
  001d9	40		 inc	 eax
  001da	83 f8 06	 cmp	 eax, 6
  001dd	7c e3		 jl	 SHORT $LL462@Load@6
  001df	ff b5 38 fa ff
	ff		 push	 DWORD PTR tv4096[ebp]
  001e5	8d 45 d4	 lea	 eax, DWORD PTR ___encStr$505419[ebp]
  001e8	50		 push	 eax
  001e9	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _szKeyName$505415[ebp]
  001ef	56		 push	 esi
  001f0	50		 push	 eax
  001f1	e8 00 00 00 00	 call	 ?StringCbPrintfA@@YAJPADIPBDZZ ; StringCbPrintfA

; 394  : 		char szBuf[MAX_PATH]="";

  001f6	53		 push	 ebx
  001f7	8d 85 cd fd ff
	ff		 lea	 eax, DWORD PTR _szBuf$505569[ebp+1]
  001fd	6a 00		 push	 0
  001ff	50		 push	 eax
  00200	c6 85 cc fd ff
	ff 00		 mov	 BYTE PTR _szBuf$505569[ebp], 0
  00207	e8 00 00 00 00	 call	 _memset
  0020c	83 c4 1c	 add	 esp, 28			; 0000001cH

; 395  : 		kLoader.LoadString(szKeyName, "", szBuf, sizeof(szBuf));

  0020f	56		 push	 esi
  00210	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _szBuf$505569[ebp]
  00216	50		 push	 eax
  00217	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0021c	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _szKeyName$505415[ebp]
  00222	50		 push	 eax
  00223	8d 8d 3c fa ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00229	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 396  : 
; 397  : 		MecroTextInfo kInfo;

  0022f	8d 8d 20 fa ff
	ff		 lea	 ecx, DWORD PTR _kInfo$505570[ebp]
  00235	e8 00 00 00 00	 call	 ??0tagMecroTextInfo@CKeyInfo@@QAE@XZ ; CKeyInfo::tagMecroTextInfo::tagMecroTextInfo

; 398  : 		kInfo.m_szText = szBuf;

  0023a	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _szBuf$505569[ebp]
  00240	50		 push	 eax
  00241	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _kInfo$505570[ebp+4]
  00247	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0024b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 399  : 
; 400  : 		ZeroMemory( szKeyName, sizeof(szKeyName) );

  00251	56		 push	 esi
  00252	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _szKeyName$505415[ebp]
  00258	6a 00		 push	 0
  0025a	50		 push	 eax
  0025b	e8 00 00 00 00	 call	 _memset
  00260	83 c4 0c	 add	 esp, 12			; 0000000cH

; 401  : 		StringCbPrintf_e(szKeyName, sizeof(szKeyName), "Type%d", i+1);

  00263	6a 04		 push	 4
  00265	c7 45 e0 b9 95
	9b 8f		 mov	 DWORD PTR ___encStr$505574[ebp], -1885628999 ; 8f9b95b9H
  0026c	81 75 e0 ed ec
	eb ea		 xor	 DWORD PTR ___encStr$505574[ebp], -353637139 ; eaebecedH
  00273	66 c7 45 e4 c8
	88		 mov	 WORD PTR ___encStr$505574[ebp+4], 35016 ; 000088c8H
  00279	c6 45 e6 00	 mov	 BYTE PTR ___encStr$505574[ebp+6], 0
  0027d	58		 pop	 eax
$LL470@Load@6:
  0027e	8b c8		 mov	 ecx, eax
  00280	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00286	79 05		 jns	 SHORT $LN506@Load@6
  00288	49		 dec	 ecx
  00289	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0028c	41		 inc	 ecx
$LN506@Load@6:
  0028d	b2 ed		 mov	 dl, -19			; ffffffedH
  0028f	2a d1		 sub	 dl, cl
  00291	30 54 05 e0	 xor	 BYTE PTR ___encStr$505574[ebp+eax], dl
  00295	40		 inc	 eax
  00296	83 f8 06	 cmp	 eax, 6
  00299	7c e3		 jl	 SHORT $LL470@Load@6
  0029b	ff b5 38 fa ff
	ff		 push	 DWORD PTR tv4096[ebp]
  002a1	8d 45 e0	 lea	 eax, DWORD PTR ___encStr$505574[ebp]
  002a4	50		 push	 eax
  002a5	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _szKeyName$505415[ebp]
  002ab	56		 push	 esi
  002ac	50		 push	 eax
  002ad	e8 00 00 00 00	 call	 ?StringCbPrintfA@@YAJPADIPBDZZ ; StringCbPrintfA
  002b2	83 c4 10	 add	 esp, 16			; 00000010H

; 402  : 		kInfo.m_bAll = kLoader.LoadBool( szKeyName, true );

  002b5	6a 01		 push	 1
  002b7	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _szKeyName$505415[ebp]
  002bd	50		 push	 eax
  002be	8d 8d 3c fa ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  002c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadBool@ioINILoader@@QAE_NPBD_N@Z
  002ca	88 85 20 fa ff
	ff		 mov	 BYTE PTR _kInfo$505570[ebp], al

; 403  : 
; 404  : 		m_vMecroTextInfo.push_back( kInfo );

  002d0	8d 85 20 fa ff
	ff		 lea	 eax, DWORD PTR _kInfo$505570[ebp]
  002d6	50		 push	 eax
  002d7	8b cf		 mov	 ecx, edi
  002d9	e8 00 00 00 00	 call	 ?push_back@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEXABUtagMecroTextInfo@CKeyInfo@@@Z ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::push_back

; 405  : 	}

  002de	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _kInfo$505570[ebp+4]
  002e4	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  002e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  002ee	ff 85 38 fa ff
	ff		 inc	 DWORD PTR tv4096[ebp]
  002f4	ff 8d 34 fa ff
	ff		 dec	 DWORD PTR tv1681[ebp]
  002fa	0f 85 8e fe ff
	ff		 jne	 $LL201@Load@6

; 406  : }

  00300	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00304	8d 8d 3c fa ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0030a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioINILoader@@QAE@XZ
  00310	e8 00 00 00 00	 call	 __EH_epilog3_GS
  00315	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Load@CDefaultKeyInfo@@UAEXXZ$0:
  00000	8d 8d 3c fa ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1ioINILoader_e@@QAE@XZ
__unwindfunclet$?Load@CDefaultKeyInfo@@UAEXXZ$1:
  0000b	8d 8d 20 fa ff
	ff		 lea	 ecx, DWORD PTR _kInfo$505570[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1tagMecroTextInfo@CKeyInfo@@QAE@XZ
__ehhandler$?Load@CDefaultKeyInfo@@UAEXXZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 8a 1c fa ff
	ff		 mov	 ecx, DWORD PTR [edx-1508]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Load@CDefaultKeyInfo@@UAEXXZ
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Load@CDefaultKeyInfo@@UAEXXZ ENDP			; CDefaultKeyInfo::Load
PUBLIC	??_7CCustomKeyInfo@@6B@				; CCustomKeyInfo::`vftable'
PUBLIC	??0CCustomKeyInfo@@QAE@XZ			; CCustomKeyInfo::CCustomKeyInfo
PUBLIC	??_R4CCustomKeyInfo@@6B@			; CCustomKeyInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCCustomKeyInfo@@@8			; CCustomKeyInfo `RTTI Type Descriptor'
PUBLIC	??_R3CCustomKeyInfo@@8				; CCustomKeyInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CCustomKeyInfo@@8				; CCustomKeyInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CCustomKeyInfo@@8			; CCustomKeyInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Load@CCustomKeyInfo@@UAEXABUControlKeys@@@Z	; CCustomKeyInfo::Load
EXTRN	??_ECCustomKeyInfo@@UAEPAXI@Z:PROC		; CCustomKeyInfo::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CCustomKeyInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CCustomKeyInfo@@8 DD FLAT:??_R0?AVCCustomKeyInfo@@@8 ; CCustomKeyInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CCustomKeyInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CCustomKeyInfo@@8
rdata$r	SEGMENT
??_R2CCustomKeyInfo@@8 DD FLAT:??_R1A@?0A@EA@CCustomKeyInfo@@8 ; CCustomKeyInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CKeyInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CCustomKeyInfo@@8
rdata$r	SEGMENT
??_R3CCustomKeyInfo@@8 DD 00H				; CCustomKeyInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CCustomKeyInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCCustomKeyInfo@@@8
_DATA	SEGMENT
??_R0?AVCCustomKeyInfo@@@8 DD FLAT:??_7type_info@@6B@	; CCustomKeyInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCCustomKeyInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CCustomKeyInfo@@6B@
rdata$r	SEGMENT
??_R4CCustomKeyInfo@@6B@ DD 00H				; CCustomKeyInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCCustomKeyInfo@@@8
	DD	FLAT:??_R3CCustomKeyInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CCustomKeyInfo@@6B@
CONST	SEGMENT
??_7CCustomKeyInfo@@6B@ DD FLAT:??_R4CCustomKeyInfo@@6B@ ; CCustomKeyInfo::`vftable'
	DD	FLAT:?SaveKey@CCustomKeyInfo@@UAEXXZ
	DD	FLAT:?SaveMacroTextInfo@CCustomKeyInfo@@UAEXXZ
	DD	FLAT:??_ECCustomKeyInfo@@UAEPAXI@Z
	DD	FLAT:?Load@CCustomKeyInfo@@UAEXABUControlKeys@@@Z
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??0CCustomKeyInfo@@QAE@XZ
_TEXT	SEGMENT
??0CCustomKeyInfo@@QAE@XZ PROC				; CCustomKeyInfo::CCustomKeyInfo, COMDAT
; _this$ = ecx

; 410  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??0CKeyInfo@@QAE@XZ	; CKeyInfo::CKeyInfo
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CCustomKeyInfo@@6B@

; 411  : 
; 412  : }

  0000e	8b c6		 mov	 eax, esi
  00010	5e		 pop	 esi
  00011	c3		 ret	 0
??0CCustomKeyInfo@@QAE@XZ ENDP				; CCustomKeyInfo::CCustomKeyInfo
_TEXT	ENDS
PUBLIC	??1CCustomKeyInfo@@UAE@XZ			; CCustomKeyInfo::~CCustomKeyInfo
; Function compile flags: /Ogsp
;	COMDAT ??1CCustomKeyInfo@@UAE@XZ
_TEXT	SEGMENT
??1CCustomKeyInfo@@UAE@XZ PROC				; CCustomKeyInfo::~CCustomKeyInfo, COMDAT
; _this$ = ecx

; 415  : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CCustomKeyInfo@@6B@

; 416  : 
; 417  : }

  00006	e9 00 00 00 00	 jmp	 ??1CKeyInfo@@UAE@XZ	; CKeyInfo::~CKeyInfo
??1CCustomKeyInfo@@UAE@XZ ENDP				; CCustomKeyInfo::~CCustomKeyInfo
_TEXT	ENDS
PUBLIC	_this$GSCopy$
EXTRN	__imp__strtoul:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Load@CCustomKeyInfo@@UAEXABUControlKeys@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Load@CCustomKeyInfo@@UAEXABUControlKeys@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@CCustomKeyInfo@@UAEXABUControlKeys@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Load@CCustomKeyInfo@@UAEXABUControlKeys@@@Z$2
__ehfuncinfo$?Load@CCustomKeyInfo@@UAEXABUControlKeys@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?Load@CCustomKeyInfo@@UAEXABUControlKeys@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ?Load@CCustomKeyInfo@@UAEXABUControlKeys@@@Z
_TEXT	SEGMENT
_kInfo$506111 = -2856					; size = 20
_iVersion$ = -2836					; size = 4
tv6609 = -2832						; size = 4
$T548526 = -2832					; size = 4
$T548227 = -2832					; size = 4
$T547640 = -2832					; size = 4
tv7841 = -2828						; size = 4
_wKey$505918 = -2828					; size = 2
_iCopyCursor$506098 = -2824				; size = 4
_szHax$505911 = -2824					; size = 3
_this$GSCopy$ = -2820					; size = 4
_wKey$505931 = -2816					; size = 2
$T547571 = -2816					; size = 2
tv2435 = -2816						; size = 4
_pTemp$505917 = -2816					; size = 4
_iControlKeysSize$ = -2816				; size = 4
_iCursor$506096 = -2812					; size = 4
_iPos$505910 = -2812					; size = 4
_i$ = -2812						; size = 4
_kLoader$ = -2808					; size = 784
_kDefaultLoader$ = -2024				; size = 912
_fName$ = -1112						; size = 260
_szCopyBuf$506099 = -852				; size = 260
_szBuf$506093 = -592					; size = 260
_szKeyName$505941 = -332				; size = 260
___encStr$505744 = -72					; size = 22
__t$547717 = -44					; size = 7
___encStr$505945 = -44					; size = 7
__t$548398 = -32					; size = 10
__t$548273 = -32					; size = 10
__k$547815 = -32					; size = 8
___encStr$506115 = -32					; size = 7
__$EHRec$ = -12						; size = 12
_rkControlKeys$ = 8					; size = 4
?Load@CCustomKeyInfo@@UAEXABUControlKeys@@@Z PROC	; CCustomKeyInfo::Load, COMDAT
; _this$ = ecx

; 420  : {

  00000	68 1c 0b 00 00	 push	 2844			; 00000b1cH
  00005	b8 00 00 00 00	 mov	 eax, __ehhandler$?Load@CCustomKeyInfo@@UAEXABUControlKeys@@@Z
  0000a	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000f	8b f1		 mov	 esi, ecx

; 564  : 		}
; 565  : 
; 566  : 		m_vMecroTextInfo.push_back( kInfo );

  00011	89 b5 fc f4 ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], esi
  00017	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  0001c	8d 48 1c	 lea	 ecx, DWORD PTR [eax+28]
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?IsEmpty@ioHashString@@QBE_NXZ
  00025	84 c0		 test	 al, al
  00027	0f 85 e0 07 00
	00		 jne	 $LN340@Load@7

; 421  : 	if( g_MyInfo.GetPublicID().IsEmpty() )
; 422  : 		return;
; 423  : 
; 424  : 	m_vKeyInfo.clear();

  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00033	50		 push	 eax
  00034	51		 push	 ecx
  00035	8d 85 f0 f4 ff
	ff		 lea	 eax, DWORD PTR $T547640[ebp]
  0003b	50		 push	 eax
  0003c	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0003f	e8 00 00 00 00	 call	 ?erase@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@GV?$allocator@G@std@@@std@@@2@0@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::erase

; 425  : 
; 426  : 	char fName[MAX_PATH]="";

  00044	33 db		 xor	 ebx, ebx
  00046	68 03 01 00 00	 push	 259			; 00000103H
  0004b	8d 85 a9 fb ff
	ff		 lea	 eax, DWORD PTR _fName$[ebp+1]
  00051	53		 push	 ebx
  00052	50		 push	 eax
  00053	88 9d a8 fb ff
	ff		 mov	 BYTE PTR _fName$[ebp], bl
  00059	e8 00 00 00 00	 call	 _memset
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00061	6a 05		 push	 5

; 427  : 	StringCbPrintf_e( fName, sizeof(fName), "Save\\%s\\customkey.ini", g_MyInfo.GetPublicID().c_str() );

  00063	c7 45 b8 be 8d
	9d 8f		 mov	 DWORD PTR ___encStr$505744[ebp], -1885499970 ; 8f9d8dbeH
  0006a	c7 45 bc b1 c9
	98 b6		 mov	 DWORD PTR ___encStr$505744[ebp+4], -1231500879 ; b698c9b1H
  00071	c7 45 c0 8e 99
	98 9e		 mov	 DWORD PTR ___encStr$505744[ebp+8], -1634166386 ; 9e98998eH
  00078	c7 45 c4 82 81
	80 8f		 mov	 DWORD PTR ___encStr$505744[ebp+12], -1887403646 ; 8f808182H
  0007f	c7 45 c8 94 c2
	82 84		 mov	 DWORD PTR ___encStr$505744[ebp+16], -2071805292 ; 8482c294H
  00086	8d 45 b8	 lea	 eax, DWORD PTR ___encStr$505744[ebp]
  00089	66 c7 45 cc 84
	00		 mov	 WORD PTR ___encStr$505744[ebp+20], 132 ; 00000084H
  0008f	59		 pop	 ecx
  00090	be ed ec eb ea	 mov	 esi, -353637139		; eaebecedH
$LL370@Load@7:
  00095	31 30		 xor	 DWORD PTR [eax], esi
  00097	83 c0 04	 add	 eax, 4
  0009a	49		 dec	 ecx
  0009b	75 f8		 jne	 SHORT $LL370@Load@7
  0009d	80 75 cc ed	 xor	 BYTE PTR ___encStr$505744[ebp+20], -19 ; ffffffedH
  000a1	e8 00 00 00 00	 call	 ?GetSingleton@ioMyInfo@@SAAAV1@XZ ; ioMyInfo::GetSingleton
  000a6	8d 48 1c	 lea	 ecx, DWORD PTR [eax+28]
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@ioHashString@@QBEPBDXZ
  000af	50		 push	 eax
  000b0	8d 45 b8	 lea	 eax, DWORD PTR ___encStr$505744[ebp]
  000b3	50		 push	 eax
  000b4	8d 85 a8 fb ff
	ff		 lea	 eax, DWORD PTR _fName$[ebp]
  000ba	68 04 01 00 00	 push	 260			; 00000104H
  000bf	50		 push	 eax
  000c0	e8 00 00 00 00	 call	 ?StringCbPrintfA@@YAJPADIPBDZZ ; StringCbPrintfA
  000c5	83 c4 10	 add	 esp, 16			; 00000010H

; 428  : 
; 429  : 	ioINILoader kLoader( fName, false );

  000c8	53		 push	 ebx
  000c9	8d 85 a8 fb ff
	ff		 lea	 eax, DWORD PTR _fName$[ebp]
  000cf	50		 push	 eax
  000d0	8d 8d 08 f5 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioINILoader@@QAE@PBD_N@Z

; 430  : 	kLoader.SetTitle_e( "Common" );

  000dc	6a 04		 push	 4
  000de	c7 45 d4 ae 83
	86 87		 mov	 DWORD PTR __t$547717[ebp], -2021227602 ; 878683aeH
  000e5	31 75 d4	 xor	 DWORD PTR __t$547717[ebp], esi
  000e8	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  000eb	66 c7 45 d8 82
	82		 mov	 WORD PTR __t$547717[ebp+4], 33410 ; 00008282H
  000f1	88 5d da	 mov	 BYTE PTR __t$547717[ebp+6], bl
  000f4	5f		 pop	 edi
$LL475@Load@7:
  000f5	8b c7		 mov	 eax, edi
  000f7	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  000fc	79 05		 jns	 SHORT $LN1002@Load@7
  000fe	48		 dec	 eax
  000ff	83 c8 fc	 or	 eax, -4			; fffffffcH
  00102	40		 inc	 eax
$LN1002@Load@7:
  00103	b1 ed		 mov	 cl, -19			; ffffffedH
  00105	2a c8		 sub	 cl, al
  00107	30 4c 3d d4	 xor	 BYTE PTR __t$547717[ebp+edi], cl
  0010b	47		 inc	 edi
  0010c	83 ff 06	 cmp	 edi, 6
  0010f	7c e4		 jl	 SHORT $LL475@Load@7
  00111	8d 45 d4	 lea	 eax, DWORD PTR __t$547717[ebp]
  00114	50		 push	 eax
  00115	8d 8d 08 f5 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0011b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z

; 431  : 
; 432  : 	int iVersion = kLoader.LoadInt_e("Version", 0);

  00121	6a 04		 push	 4
  00123	c7 45 e0 bb 89
	99 99		 mov	 DWORD PTR __k$547815[ebp], -1717990981 ; 999989bbH
  0012a	31 75 e0	 xor	 DWORD PTR __k$547815[ebp], esi
  0012d	c7 45 e4 84 83
	85 00		 mov	 DWORD PTR __k$547815[ebp+4], 8749956 ; 00858384H
  00134	5f		 pop	 edi
$LL581@Load@7:
  00135	8b c7		 mov	 eax, edi
  00137	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  0013c	79 05		 jns	 SHORT $LN1003@Load@7
  0013e	48		 dec	 eax
  0013f	83 c8 fc	 or	 eax, -4			; fffffffcH
  00142	40		 inc	 eax
$LN1003@Load@7:
  00143	b1 ed		 mov	 cl, -19			; ffffffedH
  00145	2a c8		 sub	 cl, al
  00147	30 4c 3d e0	 xor	 BYTE PTR __k$547815[ebp+edi], cl
  0014b	47		 inc	 edi
  0014c	83 ff 07	 cmp	 edi, 7
  0014f	7c e4		 jl	 SHORT $LL581@Load@7
  00151	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  00157	53		 push	 ebx
  00158	8d 45 e0	 lea	 eax, DWORD PTR __k$547815[ebp]
  0015b	50		 push	 eax
  0015c	8d 8d 08 f5 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00162	ff d7		 call	 edi
  00164	89 85 ec f4 ff
	ff		 mov	 DWORD PTR _iVersion$[ebp], eax

; 433  : 	int i = 0;
; 434  : 	int iControlKeysSize = strlen( rkControlKeys.m_szControlKeys );

  0016a	8b 45 08	 mov	 eax, DWORD PTR _rkControlKeys$[ebp]
  0016d	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
$LL998@Load@7:
  00170	8a 10		 mov	 dl, BYTE PTR [eax]
  00172	40		 inc	 eax
  00173	3a d3		 cmp	 dl, bl
  00175	75 f9		 jne	 SHORT $LL998@Load@7
  00177	2b c1		 sub	 eax, ecx

; 435  : 	if( rkControlKeys.IsRight() && (iControlKeysSize/2) == KTA_MAX ) //   MAX     .         

  00179	8b 4d 08	 mov	 ecx, DWORD PTR _rkControlKeys$[ebp]
  0017c	89 85 00 f5 ff
	ff		 mov	 DWORD PTR _iControlKeysSize$[ebp], eax
  00182	e8 00 00 00 00	 call	 ?IsRight@ControlKeys@@QBE_NXZ ; ControlKeys::IsRight
  00187	84 c0		 test	 al, al
  00189	0f 84 db 00 00
	00		 je	 $LN239@Load@7
  0018f	8b 85 00 f5 ff
	ff		 mov	 eax, DWORD PTR _iControlKeysSize$[ebp]
  00195	99		 cdq
  00196	2b c2		 sub	 eax, edx
  00198	d1 f8		 sar	 eax, 1
  0019a	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  0019d	0f 85 c7 00 00
	00		 jne	 $LN239@Load@7

; 436  : 	{
; 437  : 		enum { HAX_STRING = 3, MAX_POS = 2, };
; 438  : 		int iPos = 0;
; 439  : 		char szHax[HAX_STRING]="";

  001a3	33 c0		 xor	 eax, eax
  001a5	8d bd f9 f4 ff
	ff		 lea	 edi, DWORD PTR _szHax$505911[ebp+1]
  001ab	88 9d f8 f4 ff
	ff		 mov	 BYTE PTR _szHax$505911[ebp], bl
  001b1	66 ab		 stosw
  001b3	89 9d 04 f5 ff
	ff		 mov	 DWORD PTR _iPos$505910[ebp], ebx

; 440  : 		for (i = 0; i < MAX_CONTROL_KEYS_PLUS_ONE ; i++)

  001b9	33 ff		 xor	 edi, edi
$LN238@Load@7:

; 441  : 		{
; 442  : 			if( rkControlKeys.m_szControlKeys[i] == NULL )

  001bb	8b 45 08	 mov	 eax, DWORD PTR _rkControlKeys$[ebp]
  001be	8a 04 07	 mov	 al, BYTE PTR [edi+eax]
  001c1	3a c3		 cmp	 al, bl
  001c3	74 68		 je	 SHORT $LN974@Load@7

; 443  : 				break;
; 444  : 			szHax[iPos]=rkControlKeys.m_szControlKeys[i];

  001c5	8b 8d 04 f5 ff
	ff		 mov	 ecx, DWORD PTR _iPos$505910[ebp]

; 445  : 			iPos++;

  001cb	ff 85 04 f5 ff
	ff		 inc	 DWORD PTR _iPos$505910[ebp]

; 446  : 			if( iPos >= MAX_POS )

  001d1	83 bd 04 f5 ff
	ff 02		 cmp	 DWORD PTR _iPos$505910[ebp], 2
  001d8	88 84 0d f8 f4
	ff ff		 mov	 BYTE PTR _szHax$505911[ebp+ecx], al
  001df	7c 43		 jl	 SHORT $LN237@Load@7

; 447  : 			{
; 448  : 				iPos=0;
; 449  : 				char *pTemp=NULL;
; 450  : 				WORD wKey = strtoul( szHax, &pTemp, 16 );

  001e1	6a 10		 push	 16			; 00000010H
  001e3	8d 85 00 f5 ff
	ff		 lea	 eax, DWORD PTR _pTemp$505917[ebp]
  001e9	50		 push	 eax
  001ea	8d 85 f8 f4 ff
	ff		 lea	 eax, DWORD PTR _szHax$505911[ebp]
  001f0	50		 push	 eax
  001f1	89 9d 04 f5 ff
	ff		 mov	 DWORD PTR _iPos$505910[ebp], ebx
  001f7	89 9d 00 f5 ff
	ff		 mov	 DWORD PTR _pTemp$505917[ebp], ebx
  001fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtoul

; 451  : 				m_vKeyInfo.push_back(wKey);

  00203	8b 8d fc f4 ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00209	0f b7 c0	 movzx	 eax, ax
  0020c	89 85 f4 f4 ff
	ff		 mov	 DWORD PTR _wKey$505918[ebp], eax
  00212	83 c4 0c	 add	 esp, 12			; 0000000cH
  00215	8d 85 f4 f4 ff
	ff		 lea	 eax, DWORD PTR _wKey$505918[ebp]
  0021b	50		 push	 eax
  0021c	83 c1 04	 add	 ecx, 4
  0021f	e8 00 00 00 00	 call	 ?push_back@?$vector@GV?$allocator@G@std@@@std@@QAEXABG@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::push_back
$LN237@Load@7:

; 440  : 		for (i = 0; i < MAX_CONTROL_KEYS_PLUS_ONE ; i++)

  00224	47		 inc	 edi
  00225	81 ff c9 00 00
	00		 cmp	 edi, 201		; 000000c9H
  0022b	7c 8e		 jl	 SHORT $LN238@Load@7
$LN974@Load@7:

; 452  : 			}
; 453  : 		}
; 454  : 
; 455  : 		// key    
; 456  : 		int iLoop = KTA_MAX - m_vKeyInfo.size();

  0022d	8b 85 fc f4 ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$[ebp]
  00233	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00236	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00239	6a 5f		 push	 95			; 0000005fH
  0023b	d1 f9		 sar	 ecx, 1
  0023d	58		 pop	 eax
  0023e	2b c1		 sub	 eax, ecx

; 457  : 		for (int i = 0; i < iLoop ; i++)

  00240	3b c3		 cmp	 eax, ebx
  00242	0f 8e 9a 00 00
	00		 jle	 $LN225@Load@7

; 452  : 			}
; 453  : 		}
; 454  : 
; 455  : 		// key    
; 456  : 		int iLoop = KTA_MAX - m_vKeyInfo.size();

  00248	8b f8		 mov	 edi, eax
$LL233@Load@7:

; 458  : 		{
; 459  : 			m_vKeyInfo.push_back( 0 );

  0024a	8b 8d fc f4 ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00250	8d 85 00 f5 ff
	ff		 lea	 eax, DWORD PTR $T547571[ebp]
  00256	50		 push	 eax
  00257	83 c1 04	 add	 ecx, 4
  0025a	89 9d 00 f5 ff
	ff		 mov	 DWORD PTR $T547571[ebp], ebx
  00260	e8 00 00 00 00	 call	 ?push_back@?$vector@GV?$allocator@G@std@@@std@@QAEX$$QAG@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::push_back
  00265	4f		 dec	 edi
  00266	75 e2		 jne	 SHORT $LL233@Load@7

; 460  : 		}
; 461  : 	}
; 462  : 	else if( iVersion != CUSTOMKEY_VERSION ) 

  00268	eb 78		 jmp	 SHORT $LN225@Load@7
$LN239@Load@7:
  0026a	81 bd ec f4 ff
	ff 73 51 33 01	 cmp	 DWORD PTR _iVersion$[ebp], 20140403 ; 01335173H
  00274	74 0d		 je	 SHORT $LN229@Load@7

; 463  : 	{
; 464  : 		CKeyInfo::Load();

  00276	8b 8d fc f4 ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0027c	e8 00 00 00 00	 call	 ?Load@CKeyInfo@@QAEXXZ	; CKeyInfo::Load

; 465  : 	}
; 466  : 	else

  00281	eb 5f		 jmp	 SHORT $LN225@Load@7
$LN229@Load@7:

; 467  : 	{
; 468  : 		kLoader.SetTitle( "Key" );

  00283	68 00 00 00 00	 push	 OFFSET ??_C@_03CCEPDEKL@Key?$AA@
  00288	8d 8d 08 f5 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0028e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z

; 469  : 		for (i = 0; i < KTA_MAX ; i++)

  00294	89 9d 04 f5 ff
	ff		 mov	 DWORD PTR _i$[ebp], ebx
$LL227@Load@7:

; 470  : 		{
; 471  : 			WORD wKey = kLoader.LoadInt( GetINIKeyName((KeyTypeArray)i), 0 );

  0029a	8b 8d fc f4 ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  002a0	53		 push	 ebx
  002a1	ff b5 04 f5 ff
	ff		 push	 DWORD PTR _i$[ebp]
  002a7	e8 00 00 00 00	 call	 ?GetINIKeyName@CKeyInfo@@IAEPADW4KeyTypeArray@1@@Z ; CKeyInfo::GetINIKeyName
  002ac	50		 push	 eax
  002ad	8d 8d 08 f5 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  002b3	ff d7		 call	 edi

; 472  : 			m_vKeyInfo.push_back(wKey);

  002b5	8b 8d fc f4 ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  002bb	0f b7 c0	 movzx	 eax, ax
  002be	89 85 00 f5 ff
	ff		 mov	 DWORD PTR _wKey$505931[ebp], eax
  002c4	8d 85 00 f5 ff
	ff		 lea	 eax, DWORD PTR _wKey$505931[ebp]
  002ca	50		 push	 eax
  002cb	83 c1 04	 add	 ecx, 4
  002ce	e8 00 00 00 00	 call	 ?push_back@?$vector@GV?$allocator@G@std@@@std@@QAEXABG@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::push_back
  002d3	ff 85 04 f5 ff
	ff		 inc	 DWORD PTR _i$[ebp]
  002d9	83 bd 04 f5 ff
	ff 5f		 cmp	 DWORD PTR _i$[ebp], 95	; 0000005fH
  002e0	7c b8		 jl	 SHORT $LL227@Load@7
$LN225@Load@7:

; 473  : 		}
; 474  : 	}
; 475  : 
; 476  : 	ioINILoader_e kDefaultLoader( "config/sp2_default_key.ini" );

  002e2	6a 06		 push	 6
  002e4	c7 85 68 fb ff
	ff 8e 83 85 8c	 mov	 DWORD PTR _kDefaultLoader$[ebp+848], -1937407090 ; 8c85838eH
  002ee	c7 85 6c fb ff
	ff 84 8b c4 99	 mov	 DWORD PTR _kDefaultLoader$[ebp+852], -1715172476 ; 99c48b84H
  002f8	c7 85 70 fb ff
	ff 9d de b4 8e	 mov	 DWORD PTR _kDefaultLoader$[ebp+856], -1900749155 ; 8eb4de9dH
  00302	c7 85 74 fb ff
	ff 88 8a 8a 9f	 mov	 DWORD PTR _kDefaultLoader$[ebp+860], -1618310520 ; 9f8a8a88H
  0030c	c7 85 78 fb ff
	ff 81 98 b4 81	 mov	 DWORD PTR _kDefaultLoader$[ebp+864], -2118870911 ; 81b49881H
  00316	c7 85 7c fb ff
	ff 88 95 c5 83	 mov	 DWORD PTR _kDefaultLoader$[ebp+868], -2084203128 ; 83c59588H
  00320	66 c7 85 80 fb
	ff ff 83 85	 mov	 WORD PTR _kDefaultLoader$[ebp+872], 34179 ; 00008583H
  00329	8d 85 68 fb ff
	ff		 lea	 eax, DWORD PTR _kDefaultLoader$[ebp+848]
  0032f	88 9d 82 fb ff
	ff		 mov	 BYTE PTR _kDefaultLoader$[ebp+874], bl
  00335	59		 pop	 ecx
$LL695@Load@7:
  00336	31 30		 xor	 DWORD PTR [eax], esi
  00338	83 c0 04	 add	 eax, 4
  0033b	49		 dec	 ecx
  0033c	75 f8		 jne	 SHORT $LL695@Load@7
  0033e	6a 18		 push	 24			; 00000018H
  00340	5f		 pop	 edi
$LL692@Load@7:
  00341	8b c7		 mov	 eax, edi
  00343	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00348	79 05		 jns	 SHORT $LN1004@Load@7
  0034a	48		 dec	 eax
  0034b	83 c8 fc	 or	 eax, -4			; fffffffcH
  0034e	40		 inc	 eax
$LN1004@Load@7:
  0034f	b1 ed		 mov	 cl, -19			; ffffffedH
  00351	2a c8		 sub	 cl, al
  00353	30 8c 3d 68 fb
	ff ff		 xor	 BYTE PTR _kDefaultLoader$[ebp+edi+848], cl
  0035a	47		 inc	 edi
  0035b	83 ff 1a	 cmp	 edi, 26			; 0000001aH
  0035e	7c e1		 jl	 SHORT $LL692@Load@7
  00360	33 ff		 xor	 edi, edi
  00362	47		 inc	 edi
  00363	57		 push	 edi
  00364	8d 85 68 fb ff
	ff		 lea	 eax, DWORD PTR _kDefaultLoader$[ebp+848]
  0036a	50		 push	 eax
  0036b	8d 8d 18 f8 ff
	ff		 lea	 ecx, DWORD PTR _kDefaultLoader$[ebp]
  00371	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0ioINILoader@@QAE@PBD_N@Z

; 477  : 	//     . -    default setting
; 478  : 	m_vMecroTextInfo.clear();

  00377	8b 8d fc f4 ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0037d	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00380	83 c1 14	 add	 ecx, 20			; 00000014H
  00383	8b 11		 mov	 edx, DWORD PTR [ecx]
  00385	50		 push	 eax
  00386	52		 push	 edx
  00387	8d 85 f0 f4 ff
	ff		 lea	 eax, DWORD PTR $T548227[ebp]
  0038d	50		 push	 eax
  0038e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00392	e8 00 00 00 00	 call	 ?erase@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@@2@0@Z ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::erase

; 479  : 	enum { MAX_MACRO_LEN = 50 };	
; 480  : 	if( iVersion == 0 )
; 481  : 	{
; 482  : 		kDefaultLoader.SetTitle_e( "MacroText" );

  00397	6a 02		 push	 2
  00399	c7 45 e0 a0 8d
	88 98		 mov	 DWORD PTR __t$548273[ebp], -1735881312 ; 98888da0H
  003a0	c7 45 e4 82 b8
	8e 92		 mov	 DWORD PTR __t$548273[ebp+4], -1836140414 ; 928eb882H
  003a7	8d 45 e0	 lea	 eax, DWORD PTR __t$548273[ebp]
  003aa	66 c7 45 e8 99
	00		 mov	 WORD PTR __t$548273[ebp+8], 153 ; 00000099H
  003b0	59		 pop	 ecx
  003b1	39 9d ec f4 ff
	ff		 cmp	 DWORD PTR _iVersion$[ebp], ebx
  003b7	75 10		 jne	 SHORT $LL925@Load@7
$LL819@Load@7:
  003b9	31 30		 xor	 DWORD PTR [eax], esi
  003bb	83 c0 04	 add	 eax, 4
  003be	49		 dec	 ecx
  003bf	75 f8		 jne	 SHORT $LL819@Load@7
  003c1	8d 8d 18 f8 ff
	ff		 lea	 ecx, DWORD PTR _kDefaultLoader$[ebp]

; 483  : 	}
; 484  : 	else

  003c7	eb 0e		 jmp	 SHORT $LN1007@Load@7

; 485  : 	{
; 486  : 		kLoader.SetTitle_e( "MacroText" );

$LL925@Load@7:
  003c9	31 30		 xor	 DWORD PTR [eax], esi
  003cb	83 c0 04	 add	 eax, 4
  003ce	49		 dec	 ecx
  003cf	75 f8		 jne	 SHORT $LL925@Load@7
  003d1	8d 8d 08 f5 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
$LN1007@Load@7:
  003d7	80 75 e8 ed	 xor	 BYTE PTR __t$548398[ebp+8], -19 ; ffffffedH
  003db	8d 45 e0	 lea	 eax, DWORD PTR __t$548398[ebp]
  003de	50		 push	 eax
  003df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z

; 487  : 	}
; 488  : 
; 489  : 	for (i = 0; i < MAX_MACRO ; i++)

  003e5	89 bd f4 f4 ff
	ff		 mov	 DWORD PTR tv7841[ebp], edi
  003eb	c7 85 00 f5 ff
	ff 0c 00 00 00	 mov	 DWORD PTR tv2435[ebp], 12 ; 0000000cH
  003f5	bf 04 01 00 00	 mov	 edi, 260		; 00000104H
$LL222@Load@7:

; 490  : 	{
; 491  : 		char szKeyName[MAX_PATH]="";

  003fa	68 03 01 00 00	 push	 259			; 00000103H
  003ff	8d 85 b5 fe ff
	ff		 lea	 eax, DWORD PTR _szKeyName$505941[ebp+1]
  00405	53		 push	 ebx
  00406	50		 push	 eax
  00407	88 9d b4 fe ff
	ff		 mov	 BYTE PTR _szKeyName$505941[ebp], bl
  0040d	e8 00 00 00 00	 call	 _memset
  00412	83 c4 0c	 add	 esp, 12			; 0000000cH

; 492  : 		StringCbPrintf_e(szKeyName, sizeof(szKeyName), "Text%d", i+1);

  00415	6a 04		 push	 4
  00417	c7 45 d4 b9 89
	93 9e		 mov	 DWORD PTR ___encStr$505945[ebp], -1634498119 ; 9e9389b9H
  0041e	31 75 d4	 xor	 DWORD PTR ___encStr$505945[ebp], esi
  00421	66 c7 45 d8 c8
	88		 mov	 WORD PTR ___encStr$505945[ebp+4], 35016 ; 000088c8H
  00427	88 5d da	 mov	 BYTE PTR ___encStr$505945[ebp+6], bl
  0042a	58		 pop	 eax
$LL930@Load@7:
  0042b	8b c8		 mov	 ecx, eax
  0042d	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00433	79 05		 jns	 SHORT $LN1005@Load@7
  00435	49		 dec	 ecx
  00436	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00439	41		 inc	 ecx
$LN1005@Load@7:
  0043a	b2 ed		 mov	 dl, -19			; ffffffedH
  0043c	2a d1		 sub	 dl, cl
  0043e	30 54 05 d4	 xor	 BYTE PTR ___encStr$505945[ebp+eax], dl
  00442	40		 inc	 eax
  00443	83 f8 06	 cmp	 eax, 6
  00446	7c e3		 jl	 SHORT $LL930@Load@7
  00448	ff b5 f4 f4 ff
	ff		 push	 DWORD PTR tv7841[ebp]
  0044e	8d 45 d4	 lea	 eax, DWORD PTR ___encStr$505945[ebp]
  00451	50		 push	 eax
  00452	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _szKeyName$505941[ebp]
  00458	57		 push	 edi
  00459	50		 push	 eax
  0045a	e8 00 00 00 00	 call	 ?StringCbPrintfA@@YAJPADIPBDZZ ; StringCbPrintfA

; 493  : 
; 494  : 		char szBuf[MAX_PATH]="";

  0045f	68 03 01 00 00	 push	 259			; 00000103H
  00464	8d 85 b1 fd ff
	ff		 lea	 eax, DWORD PTR _szBuf$506093[ebp+1]
  0046a	53		 push	 ebx
  0046b	50		 push	 eax
  0046c	88 9d b0 fd ff
	ff		 mov	 BYTE PTR _szBuf$506093[ebp], bl
  00472	e8 00 00 00 00	 call	 _memset
  00477	83 c4 1c	 add	 esp, 28			; 0000001cH

; 495  : 		
; 496  : 		if( iVersion == 0 )
; 497  : 		{
; 498  : 			kDefaultLoader.LoadString( szKeyName, "", szBuf, sizeof(szBuf) );

  0047a	57		 push	 edi
  0047b	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR _szBuf$506093[ebp]
  00481	50		 push	 eax
  00482	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00487	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _szKeyName$505941[ebp]
  0048d	50		 push	 eax
  0048e	8d 8d 18 f8 ff
	ff		 lea	 ecx, DWORD PTR _kDefaultLoader$[ebp]
  00494	39 9d ec f4 ff
	ff		 cmp	 DWORD PTR _iVersion$[ebp], ebx
  0049a	74 06		 je	 SHORT $LN1008@Load@7

; 499  : 		}
; 500  : 		else
; 501  : 		{
; 502  : 			kLoader.LoadString( szKeyName, "", szBuf, sizeof(szBuf) );

  0049c	8d 8d 08 f5 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
$LN1008@Load@7:
  004a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadStringA@ioINILoader@@QAEXPBD0PADH@Z

; 503  : 		}
; 504  : 
; 505  : 		int iCursor = 0;
; 506  : 		int iAmount = 0;
; 507  : 		int iCopyCursor = 0;
; 508  : 		char szCopyBuf[MAX_PATH] = "";

  004a8	68 03 01 00 00	 push	 259			; 00000103H
  004ad	8d 85 ad fc ff
	ff		 lea	 eax, DWORD PTR _szCopyBuf$506099[ebp+1]
  004b3	53		 push	 ebx
  004b4	50		 push	 eax
  004b5	89 9d 04 f5 ff
	ff		 mov	 DWORD PTR _iCursor$506096[ebp], ebx
  004bb	89 9d f8 f4 ff
	ff		 mov	 DWORD PTR _iCopyCursor$506098[ebp], ebx
  004c1	88 9d ac fc ff
	ff		 mov	 BYTE PTR _szCopyBuf$506099[ebp], bl
  004c7	e8 00 00 00 00	 call	 _memset

; 509  : 
; 510  : 		int iTextLen = strlen( szBuf );

  004cc	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR _szBuf$506093[ebp]
  004d2	83 c4 0c	 add	 esp, 12			; 0000000cH
  004d5	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
$LL999@Load@7:
  004d8	8a 10		 mov	 dl, BYTE PTR [eax]
  004da	40		 inc	 eax
  004db	3a d3		 cmp	 dl, bl
  004dd	75 f9		 jne	 SHORT $LL999@Load@7
  004df	2b c1		 sub	 eax, ecx
  004e1	89 85 f0 f4 ff
	ff		 mov	 DWORD PTR tv6609[ebp], eax

; 511  : 		while( iCursor < iTextLen )	// MAX_MACRO_LEN  , '%', '\t' 

  004e7	3b c3		 cmp	 eax, ebx
  004e9	7e 53		 jle	 SHORT $LN975@Load@7
  004eb	33 d2		 xor	 edx, edx
  004ed	42		 inc	 edx
  004ee	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR _szBuf$506093[ebp]
  004f4	2b d0		 sub	 edx, eax
$LL118@Load@7:

; 512  : 		{
; 513  : 
; 514  : #if defined( SRC_OVERSEAS ) && !defined( SRC_ID )
; 515  : 
; 516  : #if defined( MULTI_BYTE_CHECK )
; 517  : 			if( IsDBCSLeadByteEx( COUNTRY_CODE_PAGE, (BYTE)szBuf[iCursor] ) )
; 518  : #else
; 519  : 			if( false && IsDBCSLeadByteEx( COUNTRY_CODE_PAGE, (BYTE)szBuf[iCursor] ) )
; 520  : #endif
; 521  : 
; 522  : #else
; 523  : 			if( IsDBCSLeadByte( (BYTE)szBuf[iCursor] ) )
; 524  : #endif
; 525  : 
; 526  : 				iAmount = 2;
; 527  : 			else
; 528  : 				iAmount = 1;
; 529  : 
; 530  : 			if( iCursor + iAmount > MAX_MACRO_LEN )

  004f6	8b 8d 04 f5 ff
	ff		 mov	 ecx, DWORD PTR _iCursor$506096[ebp]
  004fc	8d 8c 0d b0 fd
	ff ff		 lea	 ecx, DWORD PTR _szBuf$506093[ebp+ecx]
  00503	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  00506	83 f8 32	 cmp	 eax, 50			; 00000032H
  00509	7f 33		 jg	 SHORT $LN975@Load@7

; 531  : 				break;
; 532  : 
; 533  : 			if( iAmount == 2 )
; 534  : 			{
; 535  : 				szCopyBuf[iCopyCursor++] = szBuf[iCursor++];
; 536  : 				szCopyBuf[iCopyCursor++] = szBuf[iCursor++];
; 537  : 			}
; 538  : 			else	// iAmount == 1
; 539  : 			{
; 540  : 				if( szBuf[iCursor] != '%' && szBuf[iCursor] != '\t' )

  0050b	8a 09		 mov	 cl, BYTE PTR [ecx]
  0050d	80 f9 25	 cmp	 cl, 37			; 00000025H
  00510	74 18		 je	 SHORT $LN111@Load@7
  00512	80 f9 09	 cmp	 cl, 9
  00515	74 13		 je	 SHORT $LN111@Load@7

; 541  : 				{
; 542  : 					szCopyBuf[iCopyCursor++] = szBuf[iCursor];

  00517	8b 85 f8 f4 ff
	ff		 mov	 eax, DWORD PTR _iCopyCursor$506098[ebp]
  0051d	ff 85 f8 f4 ff
	ff		 inc	 DWORD PTR _iCopyCursor$506098[ebp]
  00523	88 8c 05 ac fc
	ff ff		 mov	 BYTE PTR _szCopyBuf$506099[ebp+eax], cl
$LN111@Load@7:

; 543  : 				}
; 544  : 
; 545  : 				iCursor++;

  0052a	ff 85 04 f5 ff
	ff		 inc	 DWORD PTR _iCursor$506096[ebp]
  00530	8b 85 04 f5 ff
	ff		 mov	 eax, DWORD PTR _iCursor$506096[ebp]
  00536	3b 85 f0 f4 ff
	ff		 cmp	 eax, DWORD PTR tv6609[ebp]
  0053c	7c b8		 jl	 SHORT $LL118@Load@7
$LN975@Load@7:

; 546  : 			}
; 547  : 		}
; 548  : 
; 549  : 		szCopyBuf[iCopyCursor] = '\0';

  0053e	8b 85 f8 f4 ff
	ff		 mov	 eax, DWORD PTR _iCopyCursor$506098[ebp]

; 550  : 
; 551  : 		MecroTextInfo kInfo;

  00544	8d 8d d8 f4 ff
	ff		 lea	 ecx, DWORD PTR _kInfo$506111[ebp]
  0054a	88 9c 05 ac fc
	ff ff		 mov	 BYTE PTR _szCopyBuf$506099[ebp+eax], bl
  00551	e8 00 00 00 00	 call	 ??0tagMecroTextInfo@CKeyInfo@@QAE@XZ ; CKeyInfo::tagMecroTextInfo::tagMecroTextInfo

; 552  : 		kInfo.m_szText = szCopyBuf;

  00556	8d 85 ac fc ff
	ff		 lea	 eax, DWORD PTR _szCopyBuf$506099[ebp]
  0055c	50		 push	 eax
  0055d	8d 8d dc f4 ff
	ff		 lea	 ecx, DWORD PTR _kInfo$506111[ebp+4]
  00563	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00567	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4ioHashString@@QAEAAV0@PBD@Z

; 553  : 
; 554  : 		ZeroMemory( szKeyName, sizeof(szKeyName) );

  0056d	57		 push	 edi
  0056e	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _szKeyName$505941[ebp]
  00574	53		 push	 ebx
  00575	50		 push	 eax
  00576	e8 00 00 00 00	 call	 _memset
  0057b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 555  : 		StringCbPrintf_e(szKeyName, sizeof(szKeyName), "Type%d", i+1);

  0057e	6a 04		 push	 4
  00580	c7 45 e0 b9 95
	9b 8f		 mov	 DWORD PTR ___encStr$506115[ebp], -1885628999 ; 8f9b95b9H
  00587	31 75 e0	 xor	 DWORD PTR ___encStr$506115[ebp], esi
  0058a	66 c7 45 e4 c8
	88		 mov	 WORD PTR ___encStr$506115[ebp+4], 35016 ; 000088c8H
  00590	88 5d e6	 mov	 BYTE PTR ___encStr$506115[ebp+6], bl
  00593	58		 pop	 eax
$LL938@Load@7:
  00594	8b c8		 mov	 ecx, eax
  00596	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  0059c	79 05		 jns	 SHORT $LN1006@Load@7
  0059e	49		 dec	 ecx
  0059f	83 c9 fc	 or	 ecx, -4			; fffffffcH
  005a2	41		 inc	 ecx
$LN1006@Load@7:
  005a3	b2 ed		 mov	 dl, -19			; ffffffedH
  005a5	2a d1		 sub	 dl, cl
  005a7	30 54 05 e0	 xor	 BYTE PTR ___encStr$506115[ebp+eax], dl
  005ab	40		 inc	 eax
  005ac	83 f8 06	 cmp	 eax, 6
  005af	7c e3		 jl	 SHORT $LL938@Load@7
  005b1	ff b5 f4 f4 ff
	ff		 push	 DWORD PTR tv7841[ebp]
  005b7	8d 45 e0	 lea	 eax, DWORD PTR ___encStr$506115[ebp]
  005ba	50		 push	 eax
  005bb	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _szKeyName$505941[ebp]
  005c1	57		 push	 edi
  005c2	50		 push	 eax
  005c3	e8 00 00 00 00	 call	 ?StringCbPrintfA@@YAJPADIPBDZZ ; StringCbPrintfA
  005c8	83 c4 10	 add	 esp, 16			; 00000010H

; 556  : 		
; 557  : 		if( iVersion == 0 )
; 558  : 		{
; 559  : 			kInfo.m_bAll = kDefaultLoader.LoadBool( szKeyName, true );

  005cb	6a 01		 push	 1
  005cd	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _szKeyName$505941[ebp]
  005d3	50		 push	 eax
  005d4	8d 8d 18 f8 ff
	ff		 lea	 ecx, DWORD PTR _kDefaultLoader$[ebp]
  005da	39 9d ec f4 ff
	ff		 cmp	 DWORD PTR _iVersion$[ebp], ebx
  005e0	74 06		 je	 SHORT $LN1009@Load@7

; 560  : 		}
; 561  : 		else
; 562  : 		{
; 563  : 			kInfo.m_bAll = kLoader.LoadBool( szKeyName, true );

  005e2	8d 8d 08 f5 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
$LN1009@Load@7:
  005e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadBool@ioINILoader@@QAE_NPBD_N@Z

; 564  : 		}
; 565  : 
; 566  : 		m_vMecroTextInfo.push_back( kInfo );

  005ee	8b 8d fc f4 ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  005f4	88 85 d8 f4 ff
	ff		 mov	 BYTE PTR _kInfo$506111[ebp], al
  005fa	8d 85 d8 f4 ff
	ff		 lea	 eax, DWORD PTR _kInfo$506111[ebp]
  00600	50		 push	 eax
  00601	83 c1 14	 add	 ecx, 20			; 00000014H
  00604	e8 00 00 00 00	 call	 ?push_back@?$vector@UtagMecroTextInfo@CKeyInfo@@V?$allocator@UtagMecroTextInfo@CKeyInfo@@@std@@@std@@QAEXABUtagMecroTextInfo@CKeyInfo@@@Z ; std::vector<CKeyInfo::tagMecroTextInfo,std::allocator<CKeyInfo::tagMecroTextInfo> >::push_back

; 567  : 	}

  00609	8d 8d dc f4 ff
	ff		 lea	 ecx, DWORD PTR _kInfo$506111[ebp+4]
  0060f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00613	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1ioHashString@@QAE@XZ
  00619	ff 85 f4 f4 ff
	ff		 inc	 DWORD PTR tv7841[ebp]
  0061f	ff 8d 00 f5 ff
	ff		 dec	 DWORD PTR tv2435[ebp]
  00625	0f 85 cf fd ff
	ff		 jne	 $LL222@Load@7

; 568  : 
; 569  : 	//       .
; 570  : 	if( !COMPARE( GetKey( KTA_UP )   , KEY_BACKSPACE, KEY_NUMKEYS + 1 )  ||
; 571  : 		!COMPARE( GetKey( KTA_DOWN ) , KEY_BACKSPACE, KEY_NUMKEYS + 1 )  ||
; 572  : 		!COMPARE( GetKey( KTA_LEFT ) , KEY_BACKSPACE, KEY_NUMKEYS + 1 )  ||
; 573  : 		!COMPARE( GetKey( KTA_RIGHT ) , KEY_BACKSPACE, KEY_NUMKEYS + 1 )  ||
; 574  : 		!COMPARE( GetKey( KTA_ATTACK ) , KEY_BACKSPACE, KEY_NUMKEYS + 1 )  ||
; 575  : 		!COMPARE( GetKey( KTA_DEFENSE ) , KEY_BACKSPACE, KEY_NUMKEYS + 1 )  ||
; 576  : 		!COMPARE( GetKey( KTA_JUMP ) , KEY_BACKSPACE, KEY_NUMKEYS + 1 )  ||
; 577  : 		!COMPARE( GetKey( KTA_SECOND_ATTACK ) , KEY_BACKSPACE, KEY_NUMKEYS + 1 )  ||
; 578  : 		!COMPARE( GetKey( KTA_SECOND_DEFENSE ) , KEY_BACKSPACE, KEY_NUMKEYS + 1 )  ||
; 579  : 		!COMPARE( GetKey( KTA_SECOND_JUMP ) , KEY_BACKSPACE, KEY_NUMKEYS + 1 )  )

  0062b	8b bd fc f4 ff
	ff		 mov	 edi, DWORD PTR _this$GSCopy$[ebp]
  00631	53		 push	 ebx
  00632	8b cf		 mov	 ecx, edi
  00634	e8 00 00 00 00	 call	 ?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CKeyInfo::GetKey
  00639	66 83 f8 08	 cmp	 ax, 8
  0063d	0f 82 3f 01 00
	00		 jb	 $LN7@Load@7
  00643	53		 push	 ebx
  00644	8b cf		 mov	 ecx, edi
  00646	e8 00 00 00 00	 call	 ?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CKeyInfo::GetKey
  0064b	be 1d 01 00 00	 mov	 esi, 285		; 0000011dH
  00650	66 3b c6	 cmp	 ax, si
  00653	0f 83 29 01 00
	00		 jae	 $LN7@Load@7
  00659	6a 01		 push	 1
  0065b	8b cf		 mov	 ecx, edi
  0065d	e8 00 00 00 00	 call	 ?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CKeyInfo::GetKey
  00662	66 83 f8 08	 cmp	 ax, 8
  00666	0f 82 16 01 00
	00		 jb	 $LN7@Load@7
  0066c	6a 01		 push	 1
  0066e	8b cf		 mov	 ecx, edi
  00670	e8 00 00 00 00	 call	 ?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CKeyInfo::GetKey
  00675	66 3b c6	 cmp	 ax, si
  00678	0f 83 04 01 00
	00		 jae	 $LN7@Load@7
  0067e	6a 02		 push	 2
  00680	8b cf		 mov	 ecx, edi
  00682	e8 00 00 00 00	 call	 ?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CKeyInfo::GetKey
  00687	66 83 f8 08	 cmp	 ax, 8
  0068b	0f 82 f1 00 00
	00		 jb	 $LN7@Load@7
  00691	6a 02		 push	 2
  00693	8b cf		 mov	 ecx, edi
  00695	e8 00 00 00 00	 call	 ?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CKeyInfo::GetKey
  0069a	66 3b c6	 cmp	 ax, si
  0069d	0f 83 df 00 00
	00		 jae	 $LN7@Load@7
  006a3	6a 03		 push	 3
  006a5	8b cf		 mov	 ecx, edi
  006a7	e8 00 00 00 00	 call	 ?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CKeyInfo::GetKey
  006ac	66 83 f8 08	 cmp	 ax, 8
  006b0	0f 82 cc 00 00
	00		 jb	 $LN7@Load@7
  006b6	6a 03		 push	 3
  006b8	8b cf		 mov	 ecx, edi
  006ba	e8 00 00 00 00	 call	 ?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CKeyInfo::GetKey
  006bf	66 3b c6	 cmp	 ax, si
  006c2	0f 83 ba 00 00
	00		 jae	 $LN7@Load@7
  006c8	6a 04		 push	 4
  006ca	8b cf		 mov	 ecx, edi
  006cc	e8 00 00 00 00	 call	 ?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CKeyInfo::GetKey
  006d1	66 83 f8 08	 cmp	 ax, 8
  006d5	0f 82 a7 00 00
	00		 jb	 $LN7@Load@7
  006db	6a 04		 push	 4
  006dd	8b cf		 mov	 ecx, edi
  006df	e8 00 00 00 00	 call	 ?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CKeyInfo::GetKey
  006e4	66 3b c6	 cmp	 ax, si
  006e7	0f 83 95 00 00
	00		 jae	 $LN7@Load@7
  006ed	6a 05		 push	 5
  006ef	8b cf		 mov	 ecx, edi
  006f1	e8 00 00 00 00	 call	 ?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CKeyInfo::GetKey
  006f6	66 83 f8 08	 cmp	 ax, 8
  006fa	0f 82 82 00 00
	00		 jb	 $LN7@Load@7
  00700	6a 05		 push	 5
  00702	8b cf		 mov	 ecx, edi
  00704	e8 00 00 00 00	 call	 ?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CKeyInfo::GetKey
  00709	66 3b c6	 cmp	 ax, si
  0070c	73 74		 jae	 SHORT $LN7@Load@7
  0070e	6a 06		 push	 6
  00710	8b cf		 mov	 ecx, edi
  00712	e8 00 00 00 00	 call	 ?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CKeyInfo::GetKey
  00717	66 83 f8 08	 cmp	 ax, 8
  0071b	72 65		 jb	 SHORT $LN7@Load@7
  0071d	6a 06		 push	 6
  0071f	8b cf		 mov	 ecx, edi
  00721	e8 00 00 00 00	 call	 ?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CKeyInfo::GetKey
  00726	66 3b c6	 cmp	 ax, si
  00729	73 57		 jae	 SHORT $LN7@Load@7
  0072b	6a 0b		 push	 11			; 0000000bH
  0072d	8b cf		 mov	 ecx, edi
  0072f	e8 00 00 00 00	 call	 ?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CKeyInfo::GetKey
  00734	66 83 f8 08	 cmp	 ax, 8
  00738	72 48		 jb	 SHORT $LN7@Load@7
  0073a	6a 0b		 push	 11			; 0000000bH
  0073c	8b cf		 mov	 ecx, edi
  0073e	e8 00 00 00 00	 call	 ?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CKeyInfo::GetKey
  00743	66 3b c6	 cmp	 ax, si
  00746	73 3a		 jae	 SHORT $LN7@Load@7
  00748	6a 0c		 push	 12			; 0000000cH
  0074a	8b cf		 mov	 ecx, edi
  0074c	e8 00 00 00 00	 call	 ?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CKeyInfo::GetKey
  00751	66 83 f8 08	 cmp	 ax, 8
  00755	72 2b		 jb	 SHORT $LN7@Load@7
  00757	6a 0c		 push	 12			; 0000000cH
  00759	8b cf		 mov	 ecx, edi
  0075b	e8 00 00 00 00	 call	 ?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CKeyInfo::GetKey
  00760	66 3b c6	 cmp	 ax, si
  00763	73 1d		 jae	 SHORT $LN7@Load@7
  00765	6a 0d		 push	 13			; 0000000dH
  00767	8b cf		 mov	 ecx, edi
  00769	e8 00 00 00 00	 call	 ?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CKeyInfo::GetKey
  0076e	66 83 f8 08	 cmp	 ax, 8
  00772	72 0e		 jb	 SHORT $LN7@Load@7
  00774	6a 0d		 push	 13			; 0000000dH
  00776	8b cf		 mov	 ecx, edi
  00778	e8 00 00 00 00	 call	 ?GetKey@CKeyInfo@@QAEGW4KeyTypeArray@1@@Z ; CKeyInfo::GetKey
  0077d	66 3b c6	 cmp	 ax, si
  00780	72 6e		 jb	 SHORT $LN2@Load@7
$LN7@Load@7:

; 580  : 	{
; 581  : 		// set default
; 582  : 		kDefaultLoader.SetTitle( "Key" );

  00782	68 00 00 00 00	 push	 OFFSET ??_C@_03CCEPDEKL@Key?$AA@
  00787	8d 8d 18 f8 ff
	ff		 lea	 ecx, DWORD PTR _kDefaultLoader$[ebp]
  0078d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?SetTitle@ioINILoader@@QAEXPBD@Z

; 583  : 		for (i = 0; i < KTA_MAX ; i++)

  00793	33 f6		 xor	 esi, esi
$LL6@Load@7:
  00795	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 584  : 			m_vKeyInfo[i] = kDefaultLoader.LoadInt( GetINIKeyName((KeyTypeArray)i), 0 );

  00798	53		 push	 ebx
  00799	8d 04 70	 lea	 eax, DWORD PTR [eax+esi*2]
  0079c	56		 push	 esi
  0079d	8b cf		 mov	 ecx, edi
  0079f	89 85 f0 f4 ff
	ff		 mov	 DWORD PTR $T548526[ebp], eax
  007a5	e8 00 00 00 00	 call	 ?GetINIKeyName@CKeyInfo@@IAEPADW4KeyTypeArray@1@@Z ; CKeyInfo::GetINIKeyName
  007aa	50		 push	 eax
  007ab	8d 8d 18 f8 ff
	ff		 lea	 ecx, DWORD PTR _kDefaultLoader$[ebp]
  007b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadInt@ioINILoader@@QAEHPBDH@Z
  007b7	8b 8d f0 f4 ff
	ff		 mov	 ecx, DWORD PTR $T548526[ebp]
  007bd	46		 inc	 esi
  007be	66 89 01	 mov	 WORD PTR [ecx], ax
  007c1	83 fe 5f	 cmp	 esi, 95			; 0000005fH
  007c4	7c cf		 jl	 SHORT $LL6@Load@7

; 585  : 
; 586  : 		if( !rkControlKeys.IsRight() )

  007c6	8b 4d 08	 mov	 ecx, DWORD PTR _rkControlKeys$[ebp]
  007c9	e8 00 00 00 00	 call	 ?IsRight@ControlKeys@@QBE_NXZ ; ControlKeys::IsRight
  007ce	84 c0		 test	 al, al
  007d0	75 06		 jne	 SHORT $LN3@Load@7

; 587  : 			SaveKey();

  007d2	8b 07		 mov	 eax, DWORD PTR [edi]
  007d4	8b cf		 mov	 ecx, edi
  007d6	ff 10		 call	 DWORD PTR [eax]
$LN3@Load@7:

; 588  : 
; 589  : 		if( iVersion != 0 || rkControlKeys.IsRight() ) //          AutoFix     

  007d8	39 9d ec f4 ff
	ff		 cmp	 DWORD PTR _iVersion$[ebp], ebx
  007de	75 0c		 jne	 SHORT $LN1@Load@7
  007e0	8b 4d 08	 mov	 ecx, DWORD PTR _rkControlKeys$[ebp]
  007e3	e8 00 00 00 00	 call	 ?IsRight@ControlKeys@@QBE_NXZ ; ControlKeys::IsRight
  007e8	84 c0		 test	 al, al
  007ea	74 04		 je	 SHORT $LN2@Load@7
$LN1@Load@7:

; 590  : 			m_bAutoFix = true;

  007ec	c6 47 25 01	 mov	 BYTE PTR [edi+37], 1
$LN2@Load@7:

; 591  : 	}
; 592  : }

  007f0	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_??1ioINILoader@@QAE@XZ
  007f6	8d 8d 18 f8 ff
	ff		 lea	 ecx, DWORD PTR _kDefaultLoader$[ebp]
  007fc	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  007ff	ff d6		 call	 esi
  00801	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00805	8d 8d 08 f5 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  0080b	ff d6		 call	 esi
$LN340@Load@7:
  0080d	e8 00 00 00 00	 call	 __EH_epilog3_GS
  00812	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Load@CCustomKeyInfo@@UAEXABUControlKeys@@@Z$0:
  00000	8d 8d 08 f5 ff
	ff		 lea	 ecx, DWORD PTR _kLoader$[ebp]
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1ioINILoader@@QAE@XZ
__unwindfunclet$?Load@CCustomKeyInfo@@UAEXABUControlKeys@@@Z$1:
  0000c	8d 8d 18 f8 ff
	ff		 lea	 ecx, DWORD PTR _kDefaultLoader$[ebp]
  00012	e9 00 00 00 00	 jmp	 ??1ioINILoader_e@@QAE@XZ
__unwindfunclet$?Load@CCustomKeyInfo@@UAEXABUControlKeys@@@Z$2:
  00017	8d 8d d8 f4 ff
	ff		 lea	 ecx, DWORD PTR _kInfo$506111[ebp]
  0001d	e9 00 00 00 00	 jmp	 ??1tagMecroTextInfo@CKeyInfo@@QAE@XZ
__ehhandler$?Load@CCustomKeyInfo@@UAEXABUControlKeys@@@Z:
  00022	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00026	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00029	8b 8a d4 f4 ff
	ff		 mov	 ecx, DWORD PTR [edx-2860]
  0002f	33 c8		 xor	 ecx, eax
  00031	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00036	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00039	33 c8		 xor	 ecx, eax
  0003b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00040	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Load@CCustomKeyInfo@@UAEXABUControlKeys@@@Z
  00045	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Load@CCustomKeyInfo@@UAEXABUControlKeys@@@Z ENDP	; CCustomKeyInfo::Load
PUBLIC	??1?$map@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@@std@@QAE@XZ ; std::map<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> > >::~map<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> > >
; Function compile flags: /Ogsp
;	COMDAT ??1?$map@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$map@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@@std@@QAE@XZ PROC ; std::map<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> > >::~map<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> > >, COMDAT
; _this$ = ecx
  00000	e9 00 00 00 00	 jmp	 ??1?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::~_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >
??1?$map@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> > >::~map<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> > >
_TEXT	ENDS
PUBLIC	??_7ioKeyManager@@6B@				; ioKeyManager::`vftable'
PUBLIC	??1ioKeyManager@@UAE@XZ				; ioKeyManager::~ioKeyManager
PUBLIC	??_R4ioKeyManager@@6B@				; ioKeyManager::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVioKeyManager@@@8			; ioKeyManager `RTTI Type Descriptor'
PUBLIC	??_R3ioKeyManager@@8				; ioKeyManager::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ioKeyManager@@8				; ioKeyManager::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ioKeyManager@@8			; ioKeyManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R13?0A@EA@?$Singleton@VioKeyManager@@@@8	; Singleton<ioKeyManager>::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AV?$Singleton@VioKeyManager@@@@@8		; Singleton<ioKeyManager> `RTTI Type Descriptor'
PUBLIC	??_R3?$Singleton@VioKeyManager@@@@8		; Singleton<ioKeyManager>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$Singleton@VioKeyManager@@@@8		; Singleton<ioKeyManager>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$Singleton@VioKeyManager@@@@8	; Singleton<ioKeyManager>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_EioKeyManager@@UAEPAXI@Z:PROC		; ioKeyManager::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$Singleton@VioKeyManager@@@@8
; File d:\lost saga for developer\youtube\tutorial\source\src\io3dengine\iosingleton.h
rdata$r	SEGMENT
??_R1A@?0A@EA@?$Singleton@VioKeyManager@@@@8 DD FLAT:??_R0?AV?$Singleton@VioKeyManager@@@@@8 ; Singleton<ioKeyManager>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$Singleton@VioKeyManager@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$Singleton@VioKeyManager@@@@8
rdata$r	SEGMENT
??_R2?$Singleton@VioKeyManager@@@@8 DD FLAT:??_R1A@?0A@EA@?$Singleton@VioKeyManager@@@@8 ; Singleton<ioKeyManager>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$Singleton@VioKeyManager@@@@8
rdata$r	SEGMENT
??_R3?$Singleton@VioKeyManager@@@@8 DD 00H		; Singleton<ioKeyManager>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$Singleton@VioKeyManager@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$Singleton@VioKeyManager@@@@@8
_DATA	SEGMENT
??_R0?AV?$Singleton@VioKeyManager@@@@@8 DD FLAT:??_7type_info@@6B@ ; Singleton<ioKeyManager> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$Singleton@VioKeyManager@@@@', 00H
_DATA	ENDS
;	COMDAT ??_R13?0A@EA@?$Singleton@VioKeyManager@@@@8
rdata$r	SEGMENT
??_R13?0A@EA@?$Singleton@VioKeyManager@@@@8 DD FLAT:??_R0?AV?$Singleton@VioKeyManager@@@@@8 ; Singleton<ioKeyManager>::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$Singleton@VioKeyManager@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ioKeyManager@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ioKeyManager@@8 DD FLAT:??_R0?AVioKeyManager@@@8 ; ioKeyManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ioKeyManager@@8
rdata$r	ENDS
;	COMDAT ??_R2ioKeyManager@@8
rdata$r	SEGMENT
??_R2ioKeyManager@@8 DD FLAT:??_R1A@?0A@EA@ioKeyManager@@8 ; ioKeyManager::`RTTI Base Class Array'
	DD	FLAT:??_R13?0A@EA@?$Singleton@VioKeyManager@@@@8
rdata$r	ENDS
;	COMDAT ??_R3ioKeyManager@@8
rdata$r	SEGMENT
??_R3ioKeyManager@@8 DD 00H				; ioKeyManager::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ioKeyManager@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVioKeyManager@@@8
_DATA	SEGMENT
??_R0?AVioKeyManager@@@8 DD FLAT:??_7type_info@@6B@	; ioKeyManager `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVioKeyManager@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ioKeyManager@@6B@
rdata$r	SEGMENT
??_R4ioKeyManager@@6B@ DD 00H				; ioKeyManager::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVioKeyManager@@@8
	DD	FLAT:??_R3ioKeyManager@@8
rdata$r	ENDS
;	COMDAT ??_7ioKeyManager@@6B@
CONST	SEGMENT
??_7ioKeyManager@@6B@ DD FLAT:??_R4ioKeyManager@@6B@	; ioKeyManager::`vftable'
	DD	FLAT:??_EioKeyManager@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1ioKeyManager@@UAE@XZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??1ioKeyManager@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1ioKeyManager@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1ioKeyManager@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1ioKeyManager@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1ioKeyManager@@UAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1ioKeyManager@@UAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1ioKeyManager@@UAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1ioKeyManager@@UAE@XZ$5
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iokeymanager.cpp
xdata$x	ENDS
;	COMDAT ??1ioKeyManager@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1ioKeyManager@@UAE@XZ PROC				; ioKeyManager::~ioKeyManager, COMDAT
; _this$ = ecx

; 984  : {

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??1ioKeyManager@@UAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioKeyManager@@6B@

; 985  : 	m_KeyTextMap.clear();

  00017	8d 8e 84 00 00
	00		 lea	 ecx, DWORD PTR [esi+132]
  0001d	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5
  00024	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::clear

; 986  : }

  00029	8d 8e 84 00 00
	00		 lea	 ecx, DWORD PTR [esi+132]
  0002f	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00033	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::~_Tree<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >
  00038	8d 4e 6c	 lea	 ecx, DWORD PTR [esi+108]
  0003b	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0003f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CCustomJoyKeyInfo@@6B@
  00045	e8 00 00 00 00	 call	 ??1CJoyKeyInfo@@UAE@XZ	; CJoyKeyInfo::~CJoyKeyInfo
  0004a	8d 4e 54	 lea	 ecx, DWORD PTR [esi+84]
  0004d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00051	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CDefaultJoyKeyInfo@@6B@
  00057	e8 00 00 00 00	 call	 ??1CJoyKeyInfo@@UAE@XZ	; CJoyKeyInfo::~CJoyKeyInfo
  0005c	8d 4e 2c	 lea	 ecx, DWORD PTR [esi+44]
  0005f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00063	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CCustomKeyInfo@@6B@
  00069	e8 00 00 00 00	 call	 ??1CKeyInfo@@UAE@XZ	; CKeyInfo::~CKeyInfo
  0006e	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00071	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00075	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CDefaultKeyInfo@@6B@
  0007b	e8 00 00 00 00	 call	 ??1CKeyInfo@@UAE@XZ	; CKeyInfo::~CKeyInfo
  00080	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_Singleton@?$Singleton@VioKeyManager@@@@1PAVioKeyManager@@A, 0 ; Singleton<ioKeyManager>::ms_Singleton
  00087	e8 00 00 00 00	 call	 __EH_epilog3
  0008c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1ioKeyManager@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$Singleton@VioKeyManager@@@@QAE@XZ ; Singleton<ioKeyManager>::~Singleton<ioKeyManager>
__unwindfunclet$??1ioKeyManager@@UAE@XZ$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 04	 add	 ecx, 4
  00011	e9 00 00 00 00	 jmp	 ??1CDefaultKeyInfo@@UAE@XZ ; CDefaultKeyInfo::~CDefaultKeyInfo
__unwindfunclet$??1ioKeyManager@@UAE@XZ$2:
  00016	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	83 c1 2c	 add	 ecx, 44			; 0000002cH
  0001c	e9 00 00 00 00	 jmp	 ??1CCustomKeyInfo@@UAE@XZ ; CCustomKeyInfo::~CCustomKeyInfo
__unwindfunclet$??1ioKeyManager@@UAE@XZ$3:
  00021	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 54	 add	 ecx, 84			; 00000054H
  00027	e9 00 00 00 00	 jmp	 ??1CDefaultJoyKeyInfo@@UAE@XZ ; CDefaultJoyKeyInfo::~CDefaultJoyKeyInfo
__unwindfunclet$??1ioKeyManager@@UAE@XZ$4:
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 6c	 add	 ecx, 108		; 0000006cH
  00032	e9 00 00 00 00	 jmp	 ??1CCustomJoyKeyInfo@@UAE@XZ ; CCustomJoyKeyInfo::~CCustomJoyKeyInfo
__unwindfunclet$??1ioKeyManager@@UAE@XZ$5:
  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  00040	e9 00 00 00 00	 jmp	 ??1?$map@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@@std@@QAE@XZ
__ehhandler$??1ioKeyManager@@UAE@XZ:
  00045	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00049	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0004c	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0004f	33 c8		 xor	 ecx, eax
  00051	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00056	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1ioKeyManager@@UAE@XZ
  0005b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1ioKeyManager@@UAE@XZ ENDP				; ioKeyManager::~ioKeyManager
PUBLIC	??0?$map@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@@std@@QAE@XZ ; std::map<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> > >::map<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> > >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??0?$map@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T548656 = -8						; size = 4
$T548659 = -8						; size = 4
$T548645 = -1						; size = 1
??0?$map@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@@std@@QAE@XZ PROC ; std::map<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> > >::map<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> > >, COMDAT
; _this$ = ecx

; 106  : 		{	// construct empty map from defaults

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	56		 push	 esi
  00006	51		 push	 ecx
  00007	89 65 f8	 mov	 DWORD PTR $T548659[ebp], esp
  0000a	8d 45 ff	 lea	 eax, DWORD PTR $T548645[ebp]
  0000d	89 65 f8	 mov	 DWORD PTR $T548656[ebp], esp
  00010	50		 push	 eax
  00011	8b f1		 mov	 esi, ecx
  00013	e8 00 00 00 00	 call	 ??0?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@G@1@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >

; 107  : 		}

  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c9		 leave
  0001c	c3		 ret	 0
??0?$map@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> > >::map<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> > >
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??_GCKeyInfo@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCKeyInfo@@UAEPAXI@Z PROC				; CKeyInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CKeyInfo@@UAE@XZ	; CKeyInfo::~CKeyInfo
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 07		 je	 SHORT $LN1@scalar@7
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	59		 pop	 ecx
$LN1@scalar@7:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??_GCKeyInfo@@UAEPAXI@Z ENDP				; CKeyInfo::`scalar deleting destructor'
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??_GCDefaultKeyInfo@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCDefaultKeyInfo@@UAEPAXI@Z PROC			; CDefaultKeyInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CDefaultKeyInfo@@6B@
  0000c	e8 00 00 00 00	 call	 ??1CKeyInfo@@UAE@XZ	; CKeyInfo::~CKeyInfo
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 07		 je	 SHORT $LN1@scalar@8
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	59		 pop	 ecx
$LN1@scalar@8:
  0001e	8b c6		 mov	 eax, esi
  00020	5e		 pop	 esi
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??_GCDefaultKeyInfo@@UAEPAXI@Z ENDP			; CDefaultKeyInfo::`scalar deleting destructor'
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??_GCCustomKeyInfo@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCCustomKeyInfo@@UAEPAXI@Z PROC			; CCustomKeyInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CCustomKeyInfo@@6B@
  0000c	e8 00 00 00 00	 call	 ??1CKeyInfo@@UAE@XZ	; CKeyInfo::~CKeyInfo
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 07		 je	 SHORT $LN1@scalar@9
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	59		 pop	 ecx
$LN1@scalar@9:
  0001e	8b c6		 mov	 eax, esi
  00020	5e		 pop	 esi
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??_GCCustomKeyInfo@@UAEPAXI@Z ENDP			; CCustomKeyInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0ioKeyManager@@QAE@XZ				; ioKeyManager::ioKeyManager
;	COMDAT xdata$x
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iokeymanager.h
xdata$x	SEGMENT
__ehfuncinfo$??0ioKeyManager@@QAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0ioKeyManager@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0ioKeyManager@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ioKeyManager@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0ioKeyManager@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0ioKeyManager@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0ioKeyManager@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0ioKeyManager@@QAE@XZ$4
; Function compile flags: /Ogsp
; File d:\lost saga for developer\youtube\tutorial\source\src\lsclient\iokeymanager.cpp
xdata$x	ENDS
;	COMDAT ??0ioKeyManager@@QAE@XZ
_TEXT	SEGMENT
$T548706 = -24						; size = 4
$T548720 = -24						; size = 4
_this$ = -20						; size = 4
$T548715 = -13						; size = 1
__$EHRec$ = -12						; size = 12
??0ioKeyManager@@QAE@XZ PROC				; ioKeyManager::ioKeyManager, COMDAT
; _this$ = ecx

; 972  : {

  00000	6a 0c		 push	 12			; 0000000cH
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0ioKeyManager@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  00011	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00014	8d 41 fc	 lea	 eax, DWORD PTR [ecx-4]
  00017	a3 00 00 00 00	 mov	 DWORD PTR ?ms_Singleton@?$Singleton@VioKeyManager@@@@1PAVioKeyManager@@A, eax ; Singleton<ioKeyManager>::ms_Singleton
  0001c	33 db		 xor	 ebx, ebx
  0001e	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00021	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ioKeyManager@@6B@
  00027	e8 00 00 00 00	 call	 ??0CDefaultKeyInfo@@QAE@XZ ; CDefaultKeyInfo::CDefaultKeyInfo
  0002c	8d 4e 2c	 lea	 ecx, DWORD PTR [esi+44]
  0002f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00033	e8 00 00 00 00	 call	 ??0CCustomKeyInfo@@QAE@XZ ; CCustomKeyInfo::CCustomKeyInfo
  00038	8d 4e 54	 lea	 ecx, DWORD PTR [esi+84]
  0003b	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0003f	e8 00 00 00 00	 call	 ??0CDefaultJoyKeyInfo@@QAE@XZ ; CDefaultJoyKeyInfo::CDefaultJoyKeyInfo
  00044	8d 4e 6c	 lea	 ecx, DWORD PTR [esi+108]
  00047	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0004b	e8 00 00 00 00	 call	 ??0CCustomJoyKeyInfo@@QAE@XZ ; CCustomJoyKeyInfo::CCustomJoyKeyInfo
  00050	8d 8e 84 00 00
	00		 lea	 ecx, DWORD PTR [esi+132]
  00056	51		 push	 ecx
  00057	89 65 e8	 mov	 DWORD PTR $T548720[ebp], esp
  0005a	8d 45 f3	 lea	 eax, DWORD PTR $T548715[ebp]
  0005d	89 65 e8	 mov	 DWORD PTR $T548706[ebp], esp
  00060	50		 push	 eax
  00061	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00065	e8 00 00 00 00	 call	 ??0?$_Tree_val@V?$_Tmap_traits@GVioHashString@@U?$less@G@std@@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@G@1@V?$allocator@U?$pair@$$CBGVioHashString@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >::_Tree_val<std::_Tmap_traits<unsigned short,ioHashString,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,ioHashString> >,0> >
  0006a	bf c9 00 00 00	 mov	 edi, 201		; 000000c9H
  0006f	57		 push	 edi
  00070	8d 86 99 00 00
	00		 lea	 eax, DWORD PTR [esi+153]
  00076	53		 push	 ebx
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 _memset

; 973  : 	m_bUseCustom     = false;
; 974  : 	m_bSaveKey       = false;
; 975  : 	m_bUseJoyCustom     = false;
; 976  : 	m_bSaveJoyKey       = false;
; 977  : 
; 978  : 	m_bSaveMacroText = false;
; 979  : 
; 980  : 	m_kServerKeys.Clear();

  0007d	57		 push	 edi
  0007e	8d 86 99 00 00
	00		 lea	 eax, DWORD PTR [esi+153]
  00084	53		 push	 ebx
  00085	50		 push	 eax
  00086	89 9e 94 00 00
	00		 mov	 DWORD PTR [esi+148], ebx
  0008c	88 9e 98 00 00
	00		 mov	 BYTE PTR [esi+152], bl
  00092	e8 00 00 00 00	 call	 _memset
  00097	83 c4 18	 add	 esp, 24			; 00000018H

; 981  : }

  0009a	8b c6		 mov	 eax, esi
  0009c	e8 00 00 00 00	 call	 __EH_epilog3
  000a1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ioKeyManager@@QAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$Singleton@VioKeyManager@@@@QAE@XZ ; Singleton<ioKeyManager>::~Singleton<ioKeyManager>
__unwindfunclet$??0ioKeyManager@@QAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 04	 add	 ecx, 4
  00011	e9 00 00 00 00	 jmp	 ??1CDefaultKeyInfo@@UAE@XZ ; CDefaultKeyInfo::~CDefaultKeyInfo
__unwindfunclet$??0ioKeyManager@@QAE@XZ$2:
  00016	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	83 c1 2c	 add	 ecx, 44			; 0000002cH
  0001c	e9 00 00 00 00	 jmp	 ??1CCustomKeyInfo@@UAE@XZ ; CCustomKeyInfo::~CCustomKeyInfo
__unwindfunclet$??0ioKeyManager@@QAE@XZ$3:
  00021	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 54	 add	 ecx, 84			; 00000054H
  00027	e9 00 00 00 00	 jmp	 ??1CDefaultJoyKeyInfo@@UAE@XZ ; CDefaultJoyKeyInfo::~CDefaultJoyKeyInfo
__unwindfunclet$??0ioKeyManager@@QAE@XZ$4:
  0002c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 6c	 add	 ecx, 108		; 0000006cH
  00032	e9 00 00 00 00	 jmp	 ??1CCustomJoyKeyInfo@@UAE@XZ ; CCustomJoyKeyInfo::~CCustomJoyKeyInfo
__ehhandler$??0ioKeyManager@@QAE@XZ:
  00037	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0003b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003e	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00041	33 c8		 xor	 ecx, eax
  00043	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00048	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ioKeyManager@@QAE@XZ
  0004d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ioKeyManager@@QAE@XZ ENDP				; ioKeyManager::ioKeyManager
; Function compile flags: /Ogsp
;	COMDAT ??_GioKeyManager@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GioKeyManager@@UAEPAXI@Z PROC			; ioKeyManager::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1ioKeyManager@@UAE@XZ	; ioKeyManager::~ioKeyManager
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 07		 je	 SHORT $LN1@scalar@10
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	59		 pop	 ecx
$LN1@scalar@10:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??_GioKeyManager@@UAEPAXI@Z ENDP			; ioKeyManager::`scalar deleting destructor'
_TEXT	ENDS
END
